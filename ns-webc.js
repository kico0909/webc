var E8 = Object.defineProperty;
var b8 = (r, e, t) => e in r ? E8(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var xr = (r, e, t) => (b8(r, typeof e != "symbol" ? e + "" : e, t), t);
function Hi(r, e) {
  const t = /* @__PURE__ */ Object.create(null), i = r.split(",");
  for (let n = 0; n < i.length; n++)
    t[i[n]] = !0;
  return e ? (n) => !!t[n.toLowerCase()] : (n) => !!t[n];
}
const wt = {}, Rc = [], Ri = () => {
}, im = () => !1, S8 = /^on[^a-z]/, ph = (r) => S8.test(r), E1 = (r) => r.startsWith("onUpdate:"), Ot = Object.assign, b1 = (r, e) => {
  const t = r.indexOf(e);
  t > -1 && r.splice(t, 1);
}, T8 = Object.prototype.hasOwnProperty, bt = (r, e) => T8.call(r, e), Oe = Array.isArray, Ac = (r) => pf(r) === "[object Map]", gh = (r) => pf(r) === "[object Set]", zP = (r) => pf(r) === "[object Date]", y8 = (r) => pf(r) === "[object RegExp]", Xe = (r) => typeof r == "function", it = (r) => typeof r == "string", qs = (r) => typeof r == "symbol", kt = (r) => r !== null && typeof r == "object", S1 = (r) => kt(r) && Xe(r.then) && Xe(r.catch), eV = Object.prototype.toString, pf = (r) => eV.call(r), R8 = (r) => pf(r).slice(8, -1), tV = (r) => pf(r) === "[object Object]", T1 = (r) => it(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, Pu = /* @__PURE__ */ Hi(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), A8 = /* @__PURE__ */ Hi(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), Bb = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, C8 = /-(\w)/g, Or = Bb((r) => r.replace(C8, (e, t) => t ? t.toUpperCase() : "")), _8 = /\B([A-Z])/g, sn = Bb(
  (r) => r.replace(_8, "-$1").toLowerCase()
), vh = Bb(
  (r) => r.charAt(0).toUpperCase() + r.slice(1)
), Cc = Bb(
  (r) => r ? `on${vh(r)}` : ""
), Vc = (r, e) => !Object.is(r, e), _c = (r, e) => {
  for (let t = 0; t < r.length; t++)
    r[t](e);
}, Vm = (r, e, t) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
}, Fm = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
}, Xm = (r) => {
  const e = it(r) ? Number(r) : NaN;
  return isNaN(e) ? r : e;
};
let ZP;
const qR = () => ZP || (ZP = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), I8 = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console", x8 = /* @__PURE__ */ Hi(I8);
function Wn(r) {
  if (Oe(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const i = r[t], n = it(i) ? rV(i) : Wn(i);
      if (n)
        for (const a in n)
          e[a] = n[a];
    }
    return e;
  } else {
    if (it(r))
      return r;
    if (kt(r))
      return r;
  }
}
const w8 = /;(?![^(]*\))/g, P8 = /:([^]+)/, N8 = /\/\*[^]*?\*\//g;
function rV(r) {
  const e = {};
  return r.replace(N8, "").split(w8).forEach((t) => {
    if (t) {
      const i = t.split(P8);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Oh(r) {
  let e = "";
  if (it(r))
    e = r;
  else if (Oe(r))
    for (let t = 0; t < r.length; t++) {
      const i = Oh(r[t]);
      i && (e += i + " ");
    }
  else if (kt(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
function L8(r) {
  if (!r)
    return null;
  let { class: e, style: t } = r;
  return e && !it(e) && (r.class = Oh(e)), t && (r.style = Wn(t)), r;
}
const D8 = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", M8 = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", k8 = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", Q8 = /* @__PURE__ */ Hi(D8), U8 = /* @__PURE__ */ Hi(M8), $8 = /* @__PURE__ */ Hi(k8), G8 = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", B8 = /* @__PURE__ */ Hi(G8);
function iV(r) {
  return !!r || r === "";
}
function V8(r, e) {
  if (r.length !== e.length)
    return !1;
  let t = !0;
  for (let i = 0; t && i < r.length; i++)
    t = js(r[i], e[i]);
  return t;
}
function js(r, e) {
  if (r === e)
    return !0;
  let t = zP(r), i = zP(e);
  if (t || i)
    return t && i ? r.getTime() === e.getTime() : !1;
  if (t = qs(r), i = qs(e), t || i)
    return r === e;
  if (t = Oe(r), i = Oe(e), t || i)
    return t && i ? V8(r, e) : !1;
  if (t = kt(r), i = kt(e), t || i) {
    if (!t || !i)
      return !1;
    const n = Object.keys(r).length, a = Object.keys(e).length;
    if (n !== a)
      return !1;
    for (const o in r) {
      const s = r.hasOwnProperty(o), l = e.hasOwnProperty(o);
      if (s && !l || !s && l || !js(r[o], e[o]))
        return !1;
    }
  }
  return String(r) === String(e);
}
function Vb(r, e) {
  return r.findIndex((t) => js(t, e));
}
const y1 = (r) => it(r) ? r : r == null ? "" : Oe(r) || kt(r) && (r.toString === eV || !Xe(r.toString)) ? JSON.stringify(r, nV, 2) : String(r), nV = (r, e) => e && e.__v_isRef ? nV(r, e.value) : Ac(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((t, [i, n]) => (t[`${i} =>`] = n, t), {})
} : gh(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : kt(e) && !Oe(e) && !tV(e) ? String(e) : e;
let en;
class R1 {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = en, !e && en && (this.index = (en.scopes || (en.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const t = en;
      try {
        return en = this, e();
      } finally {
        en = t;
      }
    }
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    en = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    en = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, i;
      for (t = 0, i = this.effects.length; t < i; t++)
        this.effects[t].stop();
      for (t = 0, i = this.cleanups.length; t < i; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, i = this.scopes.length; t < i; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const n = this.parent.scopes.pop();
        n && n !== this && (this.parent.scopes[this.index] = n, n.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function F8(r) {
  return new R1(r);
}
function aV(r, e = en) {
  e && e.active && e.effects.push(r);
}
function oV() {
  return en;
}
function X8(r) {
  en && en.cleanups.push(r);
}
const A1 = (r) => {
  const e = new Set(r);
  return e.w = 0, e.n = 0, e;
}, sV = (r) => (r.w & Ks) > 0, lV = (r) => (r.n & Ks) > 0, Y8 = ({ deps: r }) => {
  if (r.length)
    for (let e = 0; e < r.length; e++)
      r[e].w |= Ks;
}, H8 = (r) => {
  const { deps: e } = r;
  if (e.length) {
    let t = 0;
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      sV(n) && !lV(n) ? n.delete(r) : e[t++] = n, n.w &= ~Ks, n.n &= ~Ks;
    }
    e.length = t;
  }
}, Ym = /* @__PURE__ */ new WeakMap();
let xd = 0, Ks = 1;
const jR = 30;
let sa;
const Nu = Symbol(""), KR = Symbol("");
class xg {
  constructor(e, t = null, i) {
    this.fn = e, this.scheduler = t, this.active = !0, this.deps = [], this.parent = void 0, aV(this, i);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = sa, t = $s;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = sa, sa = this, $s = !0, Ks = 1 << ++xd, xd <= jR ? Y8(this) : qP(this), this.fn();
    } finally {
      xd <= jR && H8(this), Ks = 1 << --xd, sa = this.parent, $s = t, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    sa === this ? this.deferStop = !0 : this.active && (qP(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function qP(r) {
  const { deps: e } = r;
  if (e.length) {
    for (let t = 0; t < e.length; t++)
      e[t].delete(r);
    e.length = 0;
  }
}
function W8(r, e) {
  r.effect && (r = r.effect.fn);
  const t = new xg(r);
  e && (Ot(t, e), e.scope && aV(t, e.scope)), (!e || !e.lazy) && t.run();
  const i = t.run.bind(t);
  return i.effect = t, i;
}
function z8(r) {
  r.effect.stop();
}
let $s = !0;
const uV = [];
function gf() {
  uV.push($s), $s = !1;
}
function vf() {
  const r = uV.pop();
  $s = r === void 0 ? !0 : r;
}
function Fi(r, e, t) {
  if ($s && sa) {
    let i = Ym.get(r);
    i || Ym.set(r, i = /* @__PURE__ */ new Map());
    let n = i.get(t);
    n || i.set(t, n = A1()), hV(n);
  }
}
function hV(r, e) {
  let t = !1;
  xd <= jR ? lV(r) || (r.n |= Ks, t = !sV(r)) : t = !r.has(sa), t && (r.add(sa), sa.deps.push(r));
}
function Bo(r, e, t, i, n, a) {
  const o = Ym.get(r);
  if (!o)
    return;
  let s = [];
  if (e === "clear")
    s = [...o.values()];
  else if (t === "length" && Oe(r)) {
    const l = Number(i);
    o.forEach((u, h) => {
      (h === "length" || h >= l) && s.push(u);
    });
  } else
    switch (t !== void 0 && s.push(o.get(t)), e) {
      case "add":
        Oe(r) ? T1(t) && s.push(o.get("length")) : (s.push(o.get(Nu)), Ac(r) && s.push(o.get(KR)));
        break;
      case "delete":
        Oe(r) || (s.push(o.get(Nu)), Ac(r) && s.push(o.get(KR)));
        break;
      case "set":
        Ac(r) && s.push(o.get(Nu));
        break;
    }
  if (s.length === 1)
    s[0] && JR(s[0]);
  else {
    const l = [];
    for (const u of s)
      u && l.push(...u);
    JR(A1(l));
  }
}
function JR(r, e) {
  const t = Oe(r) ? r : [...r];
  for (const i of t)
    i.computed && jP(i);
  for (const i of t)
    i.computed || jP(i);
}
function jP(r, e) {
  (r !== sa || r.allowRecurse) && (r.scheduler ? r.scheduler() : r.run());
}
function Z8(r, e) {
  var t;
  return (t = Ym.get(r)) == null ? void 0 : t.get(e);
}
const q8 = /* @__PURE__ */ Hi("__proto__,__v_isRef,__isVue"), cV = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(qs)
), j8 = /* @__PURE__ */ Fb(), K8 = /* @__PURE__ */ Fb(!1, !0), J8 = /* @__PURE__ */ Fb(!0), eq = /* @__PURE__ */ Fb(!0, !0), KP = /* @__PURE__ */ tq();
function tq() {
  const r = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    r[e] = function(...t) {
      const i = mt(this);
      for (let a = 0, o = this.length; a < o; a++)
        Fi(i, "get", a + "");
      const n = i[e](...t);
      return n === -1 || n === !1 ? i[e](...t.map(mt)) : n;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    r[e] = function(...t) {
      gf();
      const i = mt(this)[e].apply(this, t);
      return vf(), i;
    };
  }), r;
}
function rq(r) {
  const e = mt(this);
  return Fi(e, "has", r), e.hasOwnProperty(r);
}
function Fb(r = !1, e = !1) {
  return function(i, n, a) {
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return e;
    if (n === "__v_raw" && a === (r ? e ? mV : OV : e ? vV : gV).get(i))
      return i;
    const o = Oe(i);
    if (!r) {
      if (o && bt(KP, n))
        return Reflect.get(KP, n, a);
      if (n === "hasOwnProperty")
        return rq;
    }
    const s = Reflect.get(i, n, a);
    return (qs(n) ? cV.has(n) : q8(n)) || (r || Fi(i, "get", n), e) ? s : Tr(s) ? o && T1(n) ? s : s.value : kt(s) ? r ? _1(s) : Hb(s) : s;
  };
}
const iq = /* @__PURE__ */ fV(), nq = /* @__PURE__ */ fV(!0);
function fV(r = !1) {
  return function(t, i, n, a) {
    let o = t[i];
    if (zu(o) && Tr(o) && !Tr(n))
      return !1;
    if (!r && (!yp(n) && !zu(n) && (o = mt(o), n = mt(n)), !Oe(t) && Tr(o) && !Tr(n)))
      return o.value = n, !0;
    const s = Oe(t) && T1(i) ? Number(i) < t.length : bt(t, i), l = Reflect.set(t, i, n, a);
    return t === mt(a) && (s ? Vc(n, o) && Bo(t, "set", i, n) : Bo(t, "add", i, n)), l;
  };
}
function aq(r, e) {
  const t = bt(r, e);
  r[e];
  const i = Reflect.deleteProperty(r, e);
  return i && t && Bo(r, "delete", e, void 0), i;
}
function oq(r, e) {
  const t = Reflect.has(r, e);
  return (!qs(e) || !cV.has(e)) && Fi(r, "has", e), t;
}
function sq(r) {
  return Fi(r, "iterate", Oe(r) ? "length" : Nu), Reflect.ownKeys(r);
}
const dV = {
  get: j8,
  set: iq,
  deleteProperty: aq,
  has: oq,
  ownKeys: sq
}, pV = {
  get: J8,
  set(r, e) {
    return !0;
  },
  deleteProperty(r, e) {
    return !0;
  }
}, lq = /* @__PURE__ */ Ot(
  {},
  dV,
  {
    get: K8,
    set: nq
  }
), uq = /* @__PURE__ */ Ot(
  {},
  pV,
  {
    get: eq
  }
), C1 = (r) => r, Xb = (r) => Reflect.getPrototypeOf(r);
function vv(r, e, t = !1, i = !1) {
  r = r.__v_raw;
  const n = mt(r), a = mt(e);
  t || (e !== a && Fi(n, "get", e), Fi(n, "get", a));
  const { has: o } = Xb(n), s = i ? C1 : t ? w1 : Rp;
  if (o.call(n, e))
    return s(r.get(e));
  if (o.call(n, a))
    return s(r.get(a));
  r !== n && r.get(e);
}
function Ov(r, e = !1) {
  const t = this.__v_raw, i = mt(t), n = mt(r);
  return e || (r !== n && Fi(i, "has", r), Fi(i, "has", n)), r === n ? t.has(r) : t.has(r) || t.has(n);
}
function mv(r, e = !1) {
  return r = r.__v_raw, !e && Fi(mt(r), "iterate", Nu), Reflect.get(r, "size", r);
}
function JP(r) {
  r = mt(r);
  const e = mt(this);
  return Xb(e).has.call(e, r) || (e.add(r), Bo(e, "add", r, r)), this;
}
function eN(r, e) {
  e = mt(e);
  const t = mt(this), { has: i, get: n } = Xb(t);
  let a = i.call(t, r);
  a || (r = mt(r), a = i.call(t, r));
  const o = n.call(t, r);
  return t.set(r, e), a ? Vc(e, o) && Bo(t, "set", r, e) : Bo(t, "add", r, e), this;
}
function tN(r) {
  const e = mt(this), { has: t, get: i } = Xb(e);
  let n = t.call(e, r);
  n || (r = mt(r), n = t.call(e, r)), i && i.call(e, r);
  const a = e.delete(r);
  return n && Bo(e, "delete", r, void 0), a;
}
function rN() {
  const r = mt(this), e = r.size !== 0, t = r.clear();
  return e && Bo(r, "clear", void 0, void 0), t;
}
function Ev(r, e) {
  return function(i, n) {
    const a = this, o = a.__v_raw, s = mt(o), l = e ? C1 : r ? w1 : Rp;
    return !r && Fi(s, "iterate", Nu), o.forEach((u, h) => i.call(n, l(u), l(h), a));
  };
}
function bv(r, e, t) {
  return function(...i) {
    const n = this.__v_raw, a = mt(n), o = Ac(a), s = r === "entries" || r === Symbol.iterator && o, l = r === "keys" && o, u = n[r](...i), h = t ? C1 : e ? w1 : Rp;
    return !e && Fi(
      a,
      "iterate",
      l ? KR : Nu
    ), {
      // iterator protocol
      next() {
        const { value: c, done: f } = u.next();
        return f ? { value: c, done: f } : {
          value: s ? [h(c[0]), h(c[1])] : h(c),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function as(r) {
  return function(...e) {
    return r === "delete" ? !1 : this;
  };
}
function hq() {
  const r = {
    get(a) {
      return vv(this, a);
    },
    get size() {
      return mv(this);
    },
    has: Ov,
    add: JP,
    set: eN,
    delete: tN,
    clear: rN,
    forEach: Ev(!1, !1)
  }, e = {
    get(a) {
      return vv(this, a, !1, !0);
    },
    get size() {
      return mv(this);
    },
    has: Ov,
    add: JP,
    set: eN,
    delete: tN,
    clear: rN,
    forEach: Ev(!1, !0)
  }, t = {
    get(a) {
      return vv(this, a, !0);
    },
    get size() {
      return mv(this, !0);
    },
    has(a) {
      return Ov.call(this, a, !0);
    },
    add: as("add"),
    set: as("set"),
    delete: as("delete"),
    clear: as("clear"),
    forEach: Ev(!0, !1)
  }, i = {
    get(a) {
      return vv(this, a, !0, !0);
    },
    get size() {
      return mv(this, !0);
    },
    has(a) {
      return Ov.call(this, a, !0);
    },
    add: as("add"),
    set: as("set"),
    delete: as("delete"),
    clear: as("clear"),
    forEach: Ev(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((a) => {
    r[a] = bv(
      a,
      !1,
      !1
    ), t[a] = bv(
      a,
      !0,
      !1
    ), e[a] = bv(
      a,
      !1,
      !0
    ), i[a] = bv(
      a,
      !0,
      !0
    );
  }), [
    r,
    t,
    e,
    i
  ];
}
const [
  cq,
  fq,
  dq,
  pq
] = /* @__PURE__ */ hq();
function Yb(r, e) {
  const t = e ? r ? pq : dq : r ? fq : cq;
  return (i, n, a) => n === "__v_isReactive" ? !r : n === "__v_isReadonly" ? r : n === "__v_raw" ? i : Reflect.get(
    bt(t, n) && n in i ? t : i,
    n,
    a
  );
}
const gq = {
  get: /* @__PURE__ */ Yb(!1, !1)
}, vq = {
  get: /* @__PURE__ */ Yb(!1, !0)
}, Oq = {
  get: /* @__PURE__ */ Yb(!0, !1)
}, mq = {
  get: /* @__PURE__ */ Yb(!0, !0)
}, gV = /* @__PURE__ */ new WeakMap(), vV = /* @__PURE__ */ new WeakMap(), OV = /* @__PURE__ */ new WeakMap(), mV = /* @__PURE__ */ new WeakMap();
function Eq(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function bq(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : Eq(R8(r));
}
function Hb(r) {
  return zu(r) ? r : Wb(
    r,
    !1,
    dV,
    gq,
    gV
  );
}
function EV(r) {
  return Wb(
    r,
    !1,
    lq,
    vq,
    vV
  );
}
function _1(r) {
  return Wb(
    r,
    !0,
    pV,
    Oq,
    OV
  );
}
function Sq(r) {
  return Wb(
    r,
    !0,
    uq,
    mq,
    mV
  );
}
function Wb(r, e, t, i, n) {
  if (!kt(r) || r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const a = n.get(r);
  if (a)
    return a;
  const o = bq(r);
  if (o === 0)
    return r;
  const s = new Proxy(
    r,
    o === 2 ? i : t
  );
  return n.set(r, s), s;
}
function Lu(r) {
  return zu(r) ? Lu(r.__v_raw) : !!(r && r.__v_isReactive);
}
function zu(r) {
  return !!(r && r.__v_isReadonly);
}
function yp(r) {
  return !!(r && r.__v_isShallow);
}
function I1(r) {
  return Lu(r) || zu(r);
}
function mt(r) {
  const e = r && r.__v_raw;
  return e ? mt(e) : r;
}
function x1(r) {
  return Vm(r, "__v_skip", !0), r;
}
const Rp = (r) => kt(r) ? Hb(r) : r, w1 = (r) => kt(r) ? _1(r) : r;
function P1(r) {
  $s && sa && (r = mt(r), hV(r.dep || (r.dep = A1())));
}
function zb(r, e) {
  r = mt(r);
  const t = r.dep;
  t && JR(t);
}
function Tr(r) {
  return !!(r && r.__v_isRef === !0);
}
function Sr(r) {
  return bV(r, !1);
}
function Tq(r) {
  return bV(r, !0);
}
function bV(r, e) {
  return Tr(r) ? r : new yq(r, e);
}
class yq {
  constructor(e, t) {
    this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : mt(e), this._value = t ? e : Rp(e);
  }
  get value() {
    return P1(this), this._value;
  }
  set value(e) {
    const t = this.__v_isShallow || yp(e) || zu(e);
    e = t ? e : mt(e), Vc(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : Rp(e), zb(this));
  }
}
function Rq(r) {
  zb(r);
}
function Fc(r) {
  return Tr(r) ? r.value : r;
}
function Aq(r) {
  return Xe(r) ? r() : Fc(r);
}
const Cq = {
  get: (r, e, t) => Fc(Reflect.get(r, e, t)),
  set: (r, e, t, i) => {
    const n = r[e];
    return Tr(n) && !Tr(t) ? (n.value = t, !0) : Reflect.set(r, e, t, i);
  }
};
function N1(r) {
  return Lu(r) ? r : new Proxy(r, Cq);
}
class _q {
  constructor(e) {
    this.dep = void 0, this.__v_isRef = !0;
    const { get: t, set: i } = e(
      () => P1(this),
      () => zb(this)
    );
    this._get = t, this._set = i;
  }
  get value() {
    return this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function Iq(r) {
  return new _q(r);
}
function xq(r) {
  const e = Oe(r) ? new Array(r.length) : {};
  for (const t in r)
    e[t] = SV(r, t);
  return e;
}
class wq {
  constructor(e, t, i) {
    this._object = e, this._key = t, this._defaultValue = i, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return Z8(mt(this._object), this._key);
  }
}
class Pq {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0;
  }
  get value() {
    return this._getter();
  }
}
function Nq(r, e, t) {
  return Tr(r) ? r : Xe(r) ? new Pq(r) : kt(r) && arguments.length > 1 ? SV(r, e, t) : Sr(r);
}
function SV(r, e, t) {
  const i = r[e];
  return Tr(i) ? i : new wq(
    r,
    e,
    t
  );
}
class Lq {
  constructor(e, t, i, n) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new xg(e, () => {
      this._dirty || (this._dirty = !0, zb(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !n, this.__v_isReadonly = i;
  }
  get value() {
    const e = mt(this);
    return P1(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
function Dq(r, e, t = !1) {
  let i, n;
  const a = Xe(r);
  return a ? (i = r, n = Ri) : (i = r.get, n = r.set), new Lq(i, n, a || !n, t);
}
function Mq(r, ...e) {
}
function kq(r, e) {
}
function Lo(r, e, t, i) {
  let n;
  try {
    n = i ? r(...i) : r();
  } catch (a) {
    mh(a, e, t);
  }
  return n;
}
function fn(r, e, t, i) {
  if (Xe(r)) {
    const a = Lo(r, e, t, i);
    return a && S1(a) && a.catch((o) => {
      mh(o, e, t);
    }), a;
  }
  const n = [];
  for (let a = 0; a < r.length; a++)
    n.push(fn(r[a], e, t, i));
  return n;
}
function mh(r, e, t, i = !0) {
  const n = e ? e.vnode : null;
  if (e) {
    let a = e.parent;
    const o = e.proxy, s = t;
    for (; a; ) {
      const u = a.ec;
      if (u) {
        for (let h = 0; h < u.length; h++)
          if (u[h](r, o, s) === !1)
            return;
      }
      a = a.parent;
    }
    const l = e.appContext.config.errorHandler;
    if (l) {
      Lo(
        l,
        null,
        10,
        [r, o, s]
      );
      return;
    }
  }
  Qq(r, t, n, i);
}
function Qq(r, e, t, i = !0) {
  console.error(r);
}
let Ap = !1, eA = !1;
const ai = [];
let $a = 0;
const Ic = [];
let Ao = null, hu = 0;
const TV = /* @__PURE__ */ Promise.resolve();
let L1 = null;
function Zu(r) {
  const e = L1 || TV;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function Uq(r) {
  let e = $a + 1, t = ai.length;
  for (; e < t; ) {
    const i = e + t >>> 1;
    Cp(ai[i]) < r ? e = i + 1 : t = i;
  }
  return e;
}
function Zb(r) {
  (!ai.length || !ai.includes(
    r,
    Ap && r.allowRecurse ? $a + 1 : $a
  )) && (r.id == null ? ai.push(r) : ai.splice(Uq(r.id), 0, r), yV());
}
function yV() {
  !Ap && !eA && (eA = !0, L1 = TV.then(RV));
}
function $q(r) {
  const e = ai.indexOf(r);
  e > $a && ai.splice(e, 1);
}
function D1(r) {
  Oe(r) ? Ic.push(...r) : (!Ao || !Ao.includes(
    r,
    r.allowRecurse ? hu + 1 : hu
  )) && Ic.push(r), yV();
}
function iN(r, e = Ap ? $a + 1 : 0) {
  for (; e < ai.length; e++) {
    const t = ai[e];
    t && t.pre && (ai.splice(e, 1), e--, t());
  }
}
function Hm(r) {
  if (Ic.length) {
    const e = [...new Set(Ic)];
    if (Ic.length = 0, Ao) {
      Ao.push(...e);
      return;
    }
    for (Ao = e, Ao.sort((t, i) => Cp(t) - Cp(i)), hu = 0; hu < Ao.length; hu++)
      Ao[hu]();
    Ao = null, hu = 0;
  }
}
const Cp = (r) => r.id == null ? 1 / 0 : r.id, Gq = (r, e) => {
  const t = Cp(r) - Cp(e);
  if (t === 0) {
    if (r.pre && !e.pre)
      return -1;
    if (e.pre && !r.pre)
      return 1;
  }
  return t;
};
function RV(r) {
  eA = !1, Ap = !0, ai.sort(Gq);
  const e = Ri;
  try {
    for ($a = 0; $a < ai.length; $a++) {
      const t = ai[$a];
      t && t.active !== !1 && Lo(t, null, 14);
    }
  } finally {
    $a = 0, ai.length = 0, Hm(), Ap = !1, L1 = null, (ai.length || Ic.length) && RV();
  }
}
let ac, Sv = [];
function AV(r, e) {
  var t, i;
  ac = r, ac ? (ac.enabled = !0, Sv.forEach(({ event: n, args: a }) => ac.emit(n, ...a)), Sv = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((i = (t = window.navigator) == null ? void 0 : t.userAgent) != null && i.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((a) => {
    AV(a, e);
  }), setTimeout(() => {
    ac || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Sv = []);
  }, 3e3)) : Sv = [];
}
function Bq(r, e, ...t) {
  if (r.isUnmounted)
    return;
  const i = r.vnode.props || wt;
  let n = t;
  const a = e.startsWith("update:"), o = a && e.slice(7);
  if (o && o in i) {
    const h = `${o === "modelValue" ? "model" : o}Modifiers`, { number: c, trim: f } = i[h] || wt;
    f && (n = t.map((d) => it(d) ? d.trim() : d)), c && (n = t.map(Fm));
  }
  let s, l = i[s = Cc(e)] || // also try camelCase event handler (#2249)
  i[s = Cc(Or(e))];
  !l && a && (l = i[s = Cc(sn(e))]), l && fn(
    l,
    r,
    6,
    n
  );
  const u = i[s + "Once"];
  if (u) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[s])
      return;
    r.emitted[s] = !0, fn(
      u,
      r,
      6,
      n
    );
  }
}
function CV(r, e, t = !1) {
  const i = e.emitsCache, n = i.get(r);
  if (n !== void 0)
    return n;
  const a = r.emits;
  let o = {}, s = !1;
  if (!Xe(r)) {
    const l = (u) => {
      const h = CV(u, e, !0);
      h && (s = !0, Ot(o, h));
    };
    !t && e.mixins.length && e.mixins.forEach(l), r.extends && l(r.extends), r.mixins && r.mixins.forEach(l);
  }
  return !a && !s ? (kt(r) && i.set(r, null), null) : (Oe(a) ? a.forEach((l) => o[l] = null) : Ot(o, a), kt(r) && i.set(r, o), o);
}
function qb(r, e) {
  return !r || !ph(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), bt(r, e[0].toLowerCase() + e.slice(1)) || bt(r, sn(e)) || bt(r, e));
}
let Lr = null, jb = null;
function _p(r) {
  const e = Lr;
  return Lr = r, jb = r && r.type.__scopeId || null, e;
}
function _V(r) {
  jb = r;
}
function IV() {
  jb = null;
}
const Vq = (r) => Ip;
function Ip(r, e = Lr, t) {
  if (!e || r._n)
    return r;
  const i = (...n) => {
    i._d && sA(-1);
    const a = _p(e);
    let o;
    try {
      o = r(...n);
    } finally {
      _p(a), i._d && sA(1);
    }
    return o;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
function nm(r) {
  const {
    type: e,
    vnode: t,
    proxy: i,
    withProxy: n,
    props: a,
    propsOptions: [o],
    slots: s,
    attrs: l,
    emit: u,
    render: h,
    renderCache: c,
    data: f,
    setupState: d,
    ctx: p,
    inheritAttrs: g
  } = r;
  let v, O;
  const m = _p(r);
  try {
    if (t.shapeFlag & 4) {
      const b = n || i;
      v = an(
        h.call(
          b,
          b,
          c,
          a,
          d,
          f,
          p
        )
      ), O = l;
    } else {
      const b = e;
      v = an(
        b.length > 1 ? b(
          a,
          { attrs: l, slots: s, emit: u }
        ) : b(
          a,
          null
          /* we know it doesn't need it */
        )
      ), O = e.props ? l : Xq(l);
    }
  } catch (b) {
    Kd.length = 0, mh(b, r, 1), v = Vt(ui);
  }
  let E = v;
  if (O && g !== !1) {
    const b = Object.keys(O), { shapeFlag: T } = E;
    b.length && T & 7 && (o && b.some(E1) && (O = Yq(
      O,
      o
    )), E = io(E, O));
  }
  return t.dirs && (E = io(E), E.dirs = E.dirs ? E.dirs.concat(t.dirs) : t.dirs), t.transition && (E.transition = t.transition), v = E, _p(m), v;
}
function Fq(r) {
  let e;
  for (let t = 0; t < r.length; t++) {
    const i = r[t];
    if (Js(i)) {
      if (i.type !== ui || i.children === "v-if") {
        if (e)
          return;
        e = i;
      }
    } else
      return;
  }
  return e;
}
const Xq = (r) => {
  let e;
  for (const t in r)
    (t === "class" || t === "style" || ph(t)) && ((e || (e = {}))[t] = r[t]);
  return e;
}, Yq = (r, e) => {
  const t = {};
  for (const i in r)
    (!E1(i) || !(i.slice(9) in e)) && (t[i] = r[i]);
  return t;
};
function Hq(r, e, t) {
  const { props: i, children: n, component: a } = r, { props: o, children: s, patchFlag: l } = e, u = a.emitsOptions;
  if (e.dirs || e.transition)
    return !0;
  if (t && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return i ? nN(i, o, u) : !!o;
    if (l & 8) {
      const h = e.dynamicProps;
      for (let c = 0; c < h.length; c++) {
        const f = h[c];
        if (o[f] !== i[f] && !qb(u, f))
          return !0;
      }
    }
  } else
    return (n || s) && (!s || !s.$stable) ? !0 : i === o ? !1 : i ? o ? nN(i, o, u) : !0 : !!o;
  return !1;
}
function nN(r, e, t) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(r).length)
    return !0;
  for (let n = 0; n < i.length; n++) {
    const a = i[n];
    if (e[a] !== r[a] && !qb(t, a))
      return !0;
  }
  return !1;
}
function M1({ vnode: r, parent: e }, t) {
  for (; e && e.subTree === r; )
    (r = e.vnode).el = t, e = e.parent;
}
const xV = (r) => r.__isSuspense, Wq = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(r, e, t, i, n, a, o, s, l, u) {
    r == null ? Zq(
      e,
      t,
      i,
      n,
      a,
      o,
      s,
      l,
      u
    ) : qq(
      r,
      e,
      t,
      i,
      n,
      o,
      s,
      l,
      u
    );
  },
  hydrate: jq,
  create: k1,
  normalize: Kq
}, zq = Wq;
function xp(r, e) {
  const t = r.props && r.props[e];
  Xe(t) && t();
}
function Zq(r, e, t, i, n, a, o, s, l) {
  const {
    p: u,
    o: { createElement: h }
  } = l, c = h("div"), f = r.suspense = k1(
    r,
    n,
    i,
    e,
    c,
    t,
    a,
    o,
    s,
    l
  );
  u(
    null,
    f.pendingBranch = r.ssContent,
    c,
    null,
    i,
    f,
    a,
    o
  ), f.deps > 0 ? (xp(r, "onPending"), xp(r, "onFallback"), u(
    null,
    r.ssFallback,
    e,
    t,
    i,
    null,
    // fallback tree will not have suspense context
    a,
    o
  ), xc(f, r.ssFallback)) : f.resolve(!1, !0);
}
function qq(r, e, t, i, n, a, o, s, { p: l, um: u, o: { createElement: h } }) {
  const c = e.suspense = r.suspense;
  c.vnode = e, e.el = r.el;
  const f = e.ssContent, d = e.ssFallback, { activeBranch: p, pendingBranch: g, isInFallback: v, isHydrating: O } = c;
  if (g)
    c.pendingBranch = f, ua(f, g) ? (l(
      g,
      f,
      c.hiddenContainer,
      null,
      n,
      c,
      a,
      o,
      s
    ), c.deps <= 0 ? c.resolve() : v && (l(
      p,
      d,
      t,
      i,
      n,
      null,
      // fallback tree will not have suspense context
      a,
      o,
      s
    ), xc(c, d))) : (c.pendingId++, O ? (c.isHydrating = !1, c.activeBranch = g) : u(g, n, c), c.deps = 0, c.effects.length = 0, c.hiddenContainer = h("div"), v ? (l(
      null,
      f,
      c.hiddenContainer,
      null,
      n,
      c,
      a,
      o,
      s
    ), c.deps <= 0 ? c.resolve() : (l(
      p,
      d,
      t,
      i,
      n,
      null,
      // fallback tree will not have suspense context
      a,
      o,
      s
    ), xc(c, d))) : p && ua(f, p) ? (l(
      p,
      f,
      t,
      i,
      n,
      c,
      a,
      o,
      s
    ), c.resolve(!0)) : (l(
      null,
      f,
      c.hiddenContainer,
      null,
      n,
      c,
      a,
      o,
      s
    ), c.deps <= 0 && c.resolve()));
  else if (p && ua(f, p))
    l(
      p,
      f,
      t,
      i,
      n,
      c,
      a,
      o,
      s
    ), xc(c, f);
  else if (xp(e, "onPending"), c.pendingBranch = f, c.pendingId++, l(
    null,
    f,
    c.hiddenContainer,
    null,
    n,
    c,
    a,
    o,
    s
  ), c.deps <= 0)
    c.resolve();
  else {
    const { timeout: m, pendingId: E } = c;
    m > 0 ? setTimeout(() => {
      c.pendingId === E && c.fallback(d);
    }, m) : m === 0 && c.fallback(d);
  }
}
function k1(r, e, t, i, n, a, o, s, l, u, h = !1) {
  const {
    p: c,
    m: f,
    um: d,
    n: p,
    o: { parentNode: g, remove: v }
  } = u;
  let O;
  const m = Jq(r);
  m && e != null && e.pendingBranch && (O = e.pendingId, e.deps++);
  const E = r.props ? Xm(r.props.timeout) : void 0, b = {
    vnode: r,
    parent: e,
    parentComponent: t,
    isSVG: o,
    container: i,
    hiddenContainer: n,
    anchor: a,
    deps: 0,
    pendingId: 0,
    timeout: typeof E == "number" ? E : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !0,
    isHydrating: h,
    isUnmounted: !1,
    effects: [],
    resolve(T = !1, S = !1) {
      const {
        vnode: y,
        activeBranch: A,
        pendingBranch: C,
        pendingId: _,
        effects: I,
        parentComponent: x,
        container: P
      } = b;
      if (b.isHydrating)
        b.isHydrating = !1;
      else if (!T) {
        const D = A && C.transition && C.transition.mode === "out-in";
        D && (A.transition.afterLeave = () => {
          _ === b.pendingId && f(C, P, $, 0);
        });
        let { anchor: $ } = b;
        A && ($ = p(A), d(A, x, b, !0)), D || f(C, P, $, 0);
      }
      xc(b, C), b.pendingBranch = null, b.isInFallback = !1;
      let N = b.parent, L = !1;
      for (; N; ) {
        if (N.pendingBranch) {
          N.effects.push(...I), L = !0;
          break;
        }
        N = N.parent;
      }
      L || D1(I), b.effects = [], m && e && e.pendingBranch && O === e.pendingId && (e.deps--, e.deps === 0 && !S && e.resolve()), xp(y, "onResolve");
    },
    fallback(T) {
      if (!b.pendingBranch)
        return;
      const { vnode: S, activeBranch: y, parentComponent: A, container: C, isSVG: _ } = b;
      xp(S, "onFallback");
      const I = p(y), x = () => {
        b.isInFallback && (c(
          null,
          T,
          C,
          I,
          A,
          null,
          // fallback tree will not have suspense context
          _,
          s,
          l
        ), xc(b, T));
      }, P = T.transition && T.transition.mode === "out-in";
      P && (y.transition.afterLeave = x), b.isInFallback = !0, d(
        y,
        A,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), P || x();
    },
    move(T, S, y) {
      b.activeBranch && f(b.activeBranch, T, S, y), b.container = T;
    },
    next() {
      return b.activeBranch && p(b.activeBranch);
    },
    registerDep(T, S) {
      const y = !!b.pendingBranch;
      y && b.deps++;
      const A = T.vnode.el;
      T.asyncDep.catch((C) => {
        mh(C, T, 0);
      }).then((C) => {
        if (T.isUnmounted || b.isUnmounted || b.pendingId !== T.suspenseId)
          return;
        T.asyncResolved = !0;
        const { vnode: _ } = T;
        lA(T, C, !1), A && (_.el = A);
        const I = !A && T.subTree.el;
        S(
          T,
          _,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          g(A || T.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          A ? null : p(T.subTree),
          b,
          o,
          l
        ), I && v(I), M1(T, _.el), y && --b.deps === 0 && b.resolve();
      });
    },
    unmount(T, S) {
      b.isUnmounted = !0, b.activeBranch && d(
        b.activeBranch,
        t,
        T,
        S
      ), b.pendingBranch && d(
        b.pendingBranch,
        t,
        T,
        S
      );
    }
  };
  return b;
}
function jq(r, e, t, i, n, a, o, s, l) {
  const u = e.suspense = k1(
    e,
    i,
    t,
    r.parentNode,
    document.createElement("div"),
    null,
    n,
    a,
    o,
    s,
    !0
    /* hydrating */
  ), h = l(
    r,
    u.pendingBranch = e.ssContent,
    t,
    u,
    a,
    o
  );
  return u.deps === 0 && u.resolve(!1, !0), h;
}
function Kq(r) {
  const { shapeFlag: e, children: t } = r, i = e & 32;
  r.ssContent = aN(
    i ? t.default : t
  ), r.ssFallback = i ? aN(t.fallback) : Vt(ui);
}
function aN(r) {
  let e;
  if (Xe(r)) {
    const t = Ku && r._c;
    t && (r._d = !1, Tt()), r = r(), t && (r._d = !0, e = $i, s5());
  }
  return Oe(r) && (r = Fq(r)), r = an(r), e && !r.dynamicChildren && (r.dynamicChildren = e.filter((t) => t !== r)), r;
}
function wV(r, e) {
  e && e.pendingBranch ? Oe(r) ? e.effects.push(...r) : e.effects.push(r) : D1(r);
}
function xc(r, e) {
  r.activeBranch = e;
  const { vnode: t, parentComponent: i } = r, n = t.el = e.el;
  i && i.subTree === t && (i.vnode.el = n, M1(i, n));
}
function Jq(r) {
  var e;
  return ((e = r.props) == null ? void 0 : e.suspensible) != null && r.props.suspensible !== !1;
}
function ej(r, e) {
  return wg(r, null, e);
}
function PV(r, e) {
  return wg(
    r,
    null,
    { flush: "post" }
  );
}
function tj(r, e) {
  return wg(
    r,
    null,
    { flush: "sync" }
  );
}
const Tv = {};
function Vn(r, e, t) {
  return wg(r, e, t);
}
function wg(r, e, { immediate: t, deep: i, flush: n, onTrack: a, onTrigger: o } = wt) {
  var s;
  const l = oV() === ((s = pr) == null ? void 0 : s.scope) ? pr : null;
  let u, h = !1, c = !1;
  if (Tr(r) ? (u = () => r.value, h = yp(r)) : Lu(r) ? (u = () => r, i = !0) : Oe(r) ? (c = !0, h = r.some((b) => Lu(b) || yp(b)), u = () => r.map((b) => {
    if (Tr(b))
      return b.value;
    if (Lu(b))
      return mu(b);
    if (Xe(b))
      return Lo(b, l, 2);
  })) : Xe(r) ? e ? u = () => Lo(r, l, 2) : u = () => {
    if (!(l && l.isUnmounted))
      return f && f(), fn(
        r,
        l,
        3,
        [d]
      );
  } : u = Ri, e && i) {
    const b = u;
    u = () => mu(b());
  }
  let f, d = (b) => {
    f = m.onStop = () => {
      Lo(b, l, 4);
    };
  }, p;
  if (Yc)
    if (d = Ri, e ? t && fn(e, l, 3, [
      u(),
      c ? [] : void 0,
      d
    ]) : u(), n === "sync") {
      const b = b5();
      p = b.__watcherHandles || (b.__watcherHandles = []);
    } else
      return Ri;
  let g = c ? new Array(r.length).fill(Tv) : Tv;
  const v = () => {
    if (m.active)
      if (e) {
        const b = m.run();
        (i || h || (c ? b.some(
          (T, S) => Vc(T, g[S])
        ) : Vc(b, g))) && (f && f(), fn(e, l, 3, [
          b,
          // pass undefined as the old value when it's changed for the first time
          g === Tv ? void 0 : c && g[0] === Tv ? [] : g,
          d
        ]), g = b);
      } else
        m.run();
  };
  v.allowRecurse = !!e;
  let O;
  n === "sync" ? O = v : n === "post" ? O = () => Gr(v, l && l.suspense) : (v.pre = !0, l && (v.id = l.uid), O = () => Zb(v));
  const m = new xg(u, O);
  e ? t ? v() : g = m.run() : n === "post" ? Gr(
    m.run.bind(m),
    l && l.suspense
  ) : m.run();
  const E = () => {
    m.stop(), l && l.scope && b1(l.scope.effects, m);
  };
  return p && p.push(E), E;
}
function rj(r, e, t) {
  const i = this.proxy, n = it(r) ? r.includes(".") ? NV(i, r) : () => i[r] : r.bind(i, i);
  let a;
  Xe(e) ? a = e : (a = e.handler, t = e);
  const o = pr;
  el(this);
  const s = wg(n, a.bind(i), t);
  return o ? el(o) : Gs(), s;
}
function NV(r, e) {
  const t = e.split(".");
  return () => {
    let i = r;
    for (let n = 0; n < t.length && i; n++)
      i = i[t[n]];
    return i;
  };
}
function mu(r, e) {
  if (!kt(r) || r.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(r)))
    return r;
  if (e.add(r), Tr(r))
    mu(r.value, e);
  else if (Oe(r))
    for (let t = 0; t < r.length; t++)
      mu(r[t], e);
  else if (gh(r) || Ac(r))
    r.forEach((t) => {
      mu(t, e);
    });
  else if (tV(r))
    for (const t in r)
      mu(r[t], e);
  return r;
}
function ij(r, e) {
  const t = Lr;
  if (t === null)
    return r;
  const i = nS(t) || t.proxy, n = r.dirs || (r.dirs = []);
  for (let a = 0; a < e.length; a++) {
    let [o, s, l, u = wt] = e[a];
    o && (Xe(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && mu(s), n.push({
      dir: o,
      instance: i,
      value: s,
      oldValue: void 0,
      arg: l,
      modifiers: u
    }));
  }
  return r;
}
function ka(r, e, t, i) {
  const n = r.dirs, a = e && e.dirs;
  for (let o = 0; o < n.length; o++) {
    const s = n[o];
    a && (s.oldValue = a[o].value);
    let l = s.dir[i];
    l && (gf(), fn(l, t, 8, [
      r.el,
      s,
      r,
      e
    ]), vf());
  }
}
function Q1() {
  const r = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return po(() => {
    r.isMounted = !0;
  }), tS(() => {
    r.isUnmounting = !0;
  }), r;
}
const Sn = [Function, Array], U1 = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: Sn,
  onEnter: Sn,
  onAfterEnter: Sn,
  onEnterCancelled: Sn,
  // leave
  onBeforeLeave: Sn,
  onLeave: Sn,
  onAfterLeave: Sn,
  onLeaveCancelled: Sn,
  // appear
  onBeforeAppear: Sn,
  onAppear: Sn,
  onAfterAppear: Sn,
  onAppearCancelled: Sn
}, nj = {
  name: "BaseTransition",
  props: U1,
  setup(r, { slots: e }) {
    const t = Jo(), i = Q1();
    let n;
    return () => {
      const a = e.default && Kb(e.default(), !0);
      if (!a || !a.length)
        return;
      let o = a[0];
      if (a.length > 1) {
        for (const g of a)
          if (g.type !== ui) {
            o = g;
            break;
          }
      }
      const s = mt(r), { mode: l } = s;
      if (i.isLeaving)
        return CT(o);
      const u = oN(o);
      if (!u)
        return CT(o);
      const h = Xc(
        u,
        s,
        i,
        t
      );
      qu(u, h);
      const c = t.subTree, f = c && oN(c);
      let d = !1;
      const { getTransitionKey: p } = u.type;
      if (p) {
        const g = p();
        n === void 0 ? n = g : g !== n && (n = g, d = !0);
      }
      if (f && f.type !== ui && (!ua(u, f) || d)) {
        const g = Xc(
          f,
          s,
          i,
          t
        );
        if (qu(f, g), l === "out-in")
          return i.isLeaving = !0, g.afterLeave = () => {
            i.isLeaving = !1, t.update.active !== !1 && t.update();
          }, CT(o);
        l === "in-out" && u.type !== ui && (g.delayLeave = (v, O, m) => {
          const E = DV(
            i,
            f
          );
          E[String(f.key)] = f, v._leaveCb = () => {
            O(), v._leaveCb = void 0, delete h.delayedLeave;
          }, h.delayedLeave = m;
        });
      }
      return o;
    };
  }
}, LV = nj;
function DV(r, e) {
  const { leavingVNodes: t } = r;
  let i = t.get(e.type);
  return i || (i = /* @__PURE__ */ Object.create(null), t.set(e.type, i)), i;
}
function Xc(r, e, t, i) {
  const {
    appear: n,
    mode: a,
    persisted: o = !1,
    onBeforeEnter: s,
    onEnter: l,
    onAfterEnter: u,
    onEnterCancelled: h,
    onBeforeLeave: c,
    onLeave: f,
    onAfterLeave: d,
    onLeaveCancelled: p,
    onBeforeAppear: g,
    onAppear: v,
    onAfterAppear: O,
    onAppearCancelled: m
  } = e, E = String(r.key), b = DV(t, r), T = (A, C) => {
    A && fn(
      A,
      i,
      9,
      C
    );
  }, S = (A, C) => {
    const _ = C[1];
    T(A, C), Oe(A) ? A.every((I) => I.length <= 1) && _() : A.length <= 1 && _();
  }, y = {
    mode: a,
    persisted: o,
    beforeEnter(A) {
      let C = s;
      if (!t.isMounted)
        if (n)
          C = g || s;
        else
          return;
      A._leaveCb && A._leaveCb(
        !0
        /* cancelled */
      );
      const _ = b[E];
      _ && ua(r, _) && _.el._leaveCb && _.el._leaveCb(), T(C, [A]);
    },
    enter(A) {
      let C = l, _ = u, I = h;
      if (!t.isMounted)
        if (n)
          C = v || l, _ = O || u, I = m || h;
        else
          return;
      let x = !1;
      const P = A._enterCb = (N) => {
        x || (x = !0, N ? T(I, [A]) : T(_, [A]), y.delayedLeave && y.delayedLeave(), A._enterCb = void 0);
      };
      C ? S(C, [A, P]) : P();
    },
    leave(A, C) {
      const _ = String(r.key);
      if (A._enterCb && A._enterCb(
        !0
        /* cancelled */
      ), t.isUnmounting)
        return C();
      T(c, [A]);
      let I = !1;
      const x = A._leaveCb = (P) => {
        I || (I = !0, C(), P ? T(p, [A]) : T(d, [A]), A._leaveCb = void 0, b[_] === r && delete b[_]);
      };
      b[_] = r, f ? S(f, [A, x]) : x();
    },
    clone(A) {
      return Xc(A, e, t, i);
    }
  };
  return y;
}
function CT(r) {
  if (Pg(r))
    return r = io(r), r.children = null, r;
}
function oN(r) {
  return Pg(r) ? r.children ? r.children[0] : void 0 : r;
}
function qu(r, e) {
  r.shapeFlag & 6 && r.component ? qu(r.component.subTree, e) : r.shapeFlag & 128 ? (r.ssContent.transition = e.clone(r.ssContent), r.ssFallback.transition = e.clone(r.ssFallback)) : r.transition = e;
}
function Kb(r, e = !1, t) {
  let i = [], n = 0;
  for (let a = 0; a < r.length; a++) {
    let o = r[a];
    const s = t == null ? o.key : String(t) + String(o.key != null ? o.key : a);
    o.type === Nr ? (o.patchFlag & 128 && n++, i = i.concat(
      Kb(o.children, e, s)
    )) : (e || o.type !== ui) && i.push(s != null ? io(o, { key: s }) : o);
  }
  if (n > 1)
    for (let a = 0; a < i.length; a++)
      i[a].patchFlag = -2;
  return i;
}
function xi(r, e) {
  return Xe(r) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => Ot({ name: r.name }, e, { setup: r }))()
  ) : r;
}
const Du = (r) => !!r.type.__asyncLoader;
function aj(r) {
  Xe(r) && (r = { loader: r });
  const {
    loader: e,
    loadingComponent: t,
    errorComponent: i,
    delay: n = 200,
    timeout: a,
    // undefined = never times out
    suspensible: o = !0,
    onError: s
  } = r;
  let l = null, u, h = 0;
  const c = () => (h++, l = null, f()), f = () => {
    let d;
    return l || (d = l = e().catch((p) => {
      if (p = p instanceof Error ? p : new Error(String(p)), s)
        return new Promise((g, v) => {
          s(p, () => g(c()), () => v(p), h + 1);
        });
      throw p;
    }).then((p) => d !== l && l ? l : (p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), u = p, p)));
  };
  return xi({
    name: "AsyncComponentWrapper",
    __asyncLoader: f,
    get __asyncResolved() {
      return u;
    },
    setup() {
      const d = pr;
      if (u)
        return () => _T(u, d);
      const p = (m) => {
        l = null, mh(
          m,
          d,
          13,
          !i
          /* do not throw in dev if user provided error component */
        );
      };
      if (o && d.suspense || Yc)
        return f().then((m) => () => _T(m, d)).catch((m) => (p(m), () => i ? Vt(i, {
          error: m
        }) : null));
      const g = Sr(!1), v = Sr(), O = Sr(!!n);
      return n && setTimeout(() => {
        O.value = !1;
      }, n), a != null && setTimeout(() => {
        if (!g.value && !v.value) {
          const m = new Error(
            `Async component timed out after ${a}ms.`
          );
          p(m), v.value = m;
        }
      }, a), f().then(() => {
        g.value = !0, d.parent && Pg(d.parent.vnode) && Zb(d.parent.update);
      }).catch((m) => {
        p(m), v.value = m;
      }), () => {
        if (g.value && u)
          return _T(u, d);
        if (v.value && i)
          return Vt(i, {
            error: v.value
          });
        if (t && !O.value)
          return Vt(t);
      };
    }
  });
}
function _T(r, e) {
  const { ref: t, props: i, children: n, ce: a } = e.vnode, o = Vt(r, i, n);
  return o.ref = t, o.ce = a, delete e.vnode.ce, o;
}
const Pg = (r) => r.type.__isKeepAlive, oj = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(r, { slots: e }) {
    const t = Jo(), i = t.ctx;
    if (!i.renderer)
      return () => {
        const m = e.default && e.default();
        return m && m.length === 1 ? m[0] : m;
      };
    const n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set();
    let o = null;
    const s = t.suspense, {
      renderer: {
        p: l,
        m: u,
        um: h,
        o: { createElement: c }
      }
    } = i, f = c("div");
    i.activate = (m, E, b, T, S) => {
      const y = m.component;
      u(m, E, b, 0, s), l(
        y.vnode,
        m,
        E,
        b,
        y,
        s,
        T,
        m.slotScopeIds,
        S
      ), Gr(() => {
        y.isDeactivated = !1, y.a && _c(y.a);
        const A = m.props && m.props.onVnodeMounted;
        A && Li(A, y.parent, m);
      }, s);
    }, i.deactivate = (m) => {
      const E = m.component;
      u(m, f, null, 1, s), Gr(() => {
        E.da && _c(E.da);
        const b = m.props && m.props.onVnodeUnmounted;
        b && Li(b, E.parent, m), E.isDeactivated = !0;
      }, s);
    };
    function d(m) {
      IT(m), h(m, t, s, !0);
    }
    function p(m) {
      n.forEach((E, b) => {
        const T = hA(E.type);
        T && (!m || !m(T)) && g(b);
      });
    }
    function g(m) {
      const E = n.get(m);
      !o || !ua(E, o) ? d(E) : o && IT(o), n.delete(m), a.delete(m);
    }
    Vn(
      () => [r.include, r.exclude],
      ([m, E]) => {
        m && p((b) => wd(m, b)), E && p((b) => !wd(E, b));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let v = null;
    const O = () => {
      v != null && n.set(v, xT(t.subTree));
    };
    return po(O), eS(O), tS(() => {
      n.forEach((m) => {
        const { subTree: E, suspense: b } = t, T = xT(E);
        if (m.type === T.type && m.key === T.key) {
          IT(T);
          const S = T.component.da;
          S && Gr(S, b);
          return;
        }
        d(m);
      });
    }), () => {
      if (v = null, !e.default)
        return null;
      const m = e.default(), E = m[0];
      if (m.length > 1)
        return o = null, m;
      if (!Js(E) || !(E.shapeFlag & 4) && !(E.shapeFlag & 128))
        return o = null, E;
      let b = xT(E);
      const T = b.type, S = hA(
        Du(b) ? b.type.__asyncResolved || {} : T
      ), { include: y, exclude: A, max: C } = r;
      if (y && (!S || !wd(y, S)) || A && S && wd(A, S))
        return o = b, E;
      const _ = b.key == null ? T : b.key, I = n.get(_);
      return b.el && (b = io(b), E.shapeFlag & 128 && (E.ssContent = b)), v = _, I ? (b.el = I.el, b.component = I.component, b.transition && qu(b, b.transition), b.shapeFlag |= 512, a.delete(_), a.add(_)) : (a.add(_), C && a.size > parseInt(C, 10) && g(a.values().next().value)), b.shapeFlag |= 256, o = b, xV(E.type) ? E : b;
    };
  }
}, sj = oj;
function wd(r, e) {
  return Oe(r) ? r.some((t) => wd(t, e)) : it(r) ? r.split(",").includes(e) : y8(r) ? r.test(e) : !1;
}
function MV(r, e) {
  QV(r, "a", e);
}
function kV(r, e) {
  QV(r, "da", e);
}
function QV(r, e, t = pr) {
  const i = r.__wdc || (r.__wdc = () => {
    let n = t;
    for (; n; ) {
      if (n.isDeactivated)
        return;
      n = n.parent;
    }
    return r();
  });
  if (Jb(e, i, t), t) {
    let n = t.parent;
    for (; n && n.parent; )
      Pg(n.parent.vnode) && lj(i, e, t, n), n = n.parent;
  }
}
function lj(r, e, t, i) {
  const n = Jb(
    e,
    r,
    i,
    !0
    /* prepend */
  );
  rS(() => {
    b1(i[e], n);
  }, t);
}
function IT(r) {
  r.shapeFlag &= -257, r.shapeFlag &= -513;
}
function xT(r) {
  return r.shapeFlag & 128 ? r.ssContent : r;
}
function Jb(r, e, t = pr, i = !1) {
  if (t) {
    const n = t[r] || (t[r] = []), a = e.__weh || (e.__weh = (...o) => {
      if (t.isUnmounted)
        return;
      gf(), el(t);
      const s = fn(e, t, r, o);
      return Gs(), vf(), s;
    });
    return i ? n.unshift(a) : n.push(a), a;
  }
}
const Ko = (r) => (e, t = pr) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Yc || r === "sp") && Jb(r, (...i) => e(...i), t)
), UV = Ko("bm"), po = Ko("m"), $V = Ko("bu"), eS = Ko("u"), tS = Ko("bum"), rS = Ko("um"), GV = Ko("sp"), BV = Ko(
  "rtg"
), VV = Ko(
  "rtc"
);
function FV(r, e = pr) {
  Jb("ec", r, e);
}
const $1 = "components", uj = "directives";
function XV(r, e) {
  return G1($1, r, !0, e) || r;
}
const YV = Symbol.for("v-ndc");
function hj(r) {
  return it(r) ? G1($1, r, !1) || r : r || YV;
}
function cj(r) {
  return G1(uj, r);
}
function G1(r, e, t = !0, i = !1) {
  const n = Lr || pr;
  if (n) {
    const a = n.type;
    if (r === $1) {
      const s = hA(
        a,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (s && (s === e || s === Or(e) || s === vh(Or(e))))
        return a;
    }
    const o = (
      // local registration
      // check instance[type] first which is resolved for options API
      sN(n[r] || a[r], e) || // global registration
      sN(n.appContext[r], e)
    );
    return !o && i ? a : o;
  }
}
function sN(r, e) {
  return r && (r[e] || r[Or(e)] || r[vh(Or(e))]);
}
function HV(r, e, t, i) {
  let n;
  const a = t && t[i];
  if (Oe(r) || it(r)) {
    n = new Array(r.length);
    for (let o = 0, s = r.length; o < s; o++)
      n[o] = e(r[o], o, void 0, a && a[o]);
  } else if (typeof r == "number") {
    n = new Array(r);
    for (let o = 0; o < r; o++)
      n[o] = e(o + 1, o, void 0, a && a[o]);
  } else if (kt(r))
    if (r[Symbol.iterator])
      n = Array.from(
        r,
        (o, s) => e(o, s, void 0, a && a[s])
      );
    else {
      const o = Object.keys(r);
      n = new Array(o.length);
      for (let s = 0, l = o.length; s < l; s++) {
        const u = o[s];
        n[s] = e(r[u], u, s, a && a[s]);
      }
    }
  else
    n = [];
  return t && (t[i] = n), n;
}
function fj(r, e) {
  for (let t = 0; t < e.length; t++) {
    const i = e[t];
    if (Oe(i))
      for (let n = 0; n < i.length; n++)
        r[i[n].name] = i[n].fn;
    else
      i && (r[i.name] = i.key ? (...n) => {
        const a = i.fn(...n);
        return a && (a.key = i.key), a;
      } : i.fn);
  }
  return r;
}
function oi(r, e, t = {}, i, n) {
  if (Lr.isCE || Lr.parent && Du(Lr.parent) && Lr.parent.isCE)
    return e !== "default" && (t.name = e), Vt("slot", t, i && i());
  let a = r[e];
  a && a._c && (a._d = !1), Tt();
  const o = a && WV(a(t)), s = la(
    Nr,
    {
      key: t.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      o && o.key || `_${e}`
    },
    o || (i ? i() : []),
    o && r._ === 1 ? 64 : -2
  );
  return !n && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]), a && a._c && (a._d = !0), s;
}
function WV(r) {
  return r.some((e) => Js(e) ? !(e.type === ui || e.type === Nr && !WV(e.children)) : !0) ? r : null;
}
function dj(r, e) {
  const t = {};
  for (const i in r)
    t[e && /[A-Z]/.test(i) ? `on:${i}` : Cc(i)] = r[i];
  return t;
}
const tA = (r) => r ? d5(r) ? nS(r) || r.proxy : tA(r.parent) : null, Zd = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ Ot(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => r.props,
    $attrs: (r) => r.attrs,
    $slots: (r) => r.slots,
    $refs: (r) => r.refs,
    $parent: (r) => tA(r.parent),
    $root: (r) => tA(r.root),
    $emit: (r) => r.emit,
    $options: (r) => B1(r),
    $forceUpdate: (r) => r.f || (r.f = () => Zb(r.update)),
    $nextTick: (r) => r.n || (r.n = Zu.bind(r.proxy)),
    $watch: (r) => rj.bind(r)
  })
), wT = (r, e) => r !== wt && !r.__isScriptSetup && bt(r, e), rA = {
  get({ _: r }, e) {
    const { ctx: t, setupState: i, data: n, props: a, accessCache: o, type: s, appContext: l } = r;
    let u;
    if (e[0] !== "$") {
      const d = o[e];
      if (d !== void 0)
        switch (d) {
          case 1:
            return i[e];
          case 2:
            return n[e];
          case 4:
            return t[e];
          case 3:
            return a[e];
        }
      else {
        if (wT(i, e))
          return o[e] = 1, i[e];
        if (n !== wt && bt(n, e))
          return o[e] = 2, n[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (u = r.propsOptions[0]) && bt(u, e)
        )
          return o[e] = 3, a[e];
        if (t !== wt && bt(t, e))
          return o[e] = 4, t[e];
        iA && (o[e] = 0);
      }
    }
    const h = Zd[e];
    let c, f;
    if (h)
      return e === "$attrs" && Fi(r, "get", e), h(r);
    if (
      // css module (injected by vue-loader)
      (c = s.__cssModules) && (c = c[e])
    )
      return c;
    if (t !== wt && bt(t, e))
      return o[e] = 4, t[e];
    if (
      // global properties
      f = l.config.globalProperties, bt(f, e)
    )
      return f[e];
  },
  set({ _: r }, e, t) {
    const { data: i, setupState: n, ctx: a } = r;
    return wT(n, e) ? (n[e] = t, !0) : i !== wt && bt(i, e) ? (i[e] = t, !0) : bt(r.props, e) || e[0] === "$" && e.slice(1) in r ? !1 : (a[e] = t, !0);
  },
  has({
    _: { data: r, setupState: e, accessCache: t, ctx: i, appContext: n, propsOptions: a }
  }, o) {
    let s;
    return !!t[o] || r !== wt && bt(r, o) || wT(e, o) || (s = a[0]) && bt(s, o) || bt(i, o) || bt(Zd, o) || bt(n.config.globalProperties, o);
  },
  defineProperty(r, e, t) {
    return t.get != null ? r._.accessCache[e] = 0 : bt(t, "value") && this.set(r, e, t.value, null), Reflect.defineProperty(r, e, t);
  }
}, pj = /* @__PURE__ */ Ot(
  {},
  rA,
  {
    get(r, e) {
      if (e !== Symbol.unscopables)
        return rA.get(r, e, r);
    },
    has(r, e) {
      return e[0] !== "_" && !x8(e);
    }
  }
);
function gj() {
  return null;
}
function vj() {
  return null;
}
function Oj(r) {
}
function mj(r) {
}
function Ej() {
  return null;
}
function bj() {
}
function Sj(r, e) {
  return null;
}
function Tj() {
  return zV().slots;
}
function yj() {
  return zV().attrs;
}
function Rj(r, e, t) {
  const i = Jo();
  if (t && t.local) {
    const n = Sr(r[e]);
    return Vn(
      () => r[e],
      (a) => n.value = a
    ), Vn(n, (a) => {
      a !== r[e] && i.emit(`update:${e}`, a);
    }), n;
  } else
    return {
      __v_isRef: !0,
      get value() {
        return r[e];
      },
      set value(n) {
        i.emit(`update:${e}`, n);
      }
    };
}
function zV() {
  const r = Jo();
  return r.setupContext || (r.setupContext = O5(r));
}
function wp(r) {
  return Oe(r) ? r.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : r;
}
function Aj(r, e) {
  const t = wp(r);
  for (const i in e) {
    if (i.startsWith("__skip"))
      continue;
    let n = t[i];
    n ? Oe(n) || Xe(n) ? n = t[i] = { type: n, default: e[i] } : n.default = e[i] : n === null && (n = t[i] = { default: e[i] }), n && e[`__skip_${i}`] && (n.skipFactory = !0);
  }
  return t;
}
function Cj(r, e) {
  return !r || !e ? r || e : Oe(r) && Oe(e) ? r.concat(e) : Ot({}, wp(r), wp(e));
}
function _j(r, e) {
  const t = {};
  for (const i in r)
    e.includes(i) || Object.defineProperty(t, i, {
      enumerable: !0,
      get: () => r[i]
    });
  return t;
}
function Ij(r) {
  const e = Jo();
  let t = r();
  return Gs(), S1(t) && (t = t.catch((i) => {
    throw el(e), i;
  })), [t, () => el(e)];
}
let iA = !0;
function xj(r) {
  const e = B1(r), t = r.proxy, i = r.ctx;
  iA = !1, e.beforeCreate && lN(e.beforeCreate, r, "bc");
  const {
    // state
    data: n,
    computed: a,
    methods: o,
    watch: s,
    provide: l,
    inject: u,
    // lifecycle
    created: h,
    beforeMount: c,
    mounted: f,
    beforeUpdate: d,
    updated: p,
    activated: g,
    deactivated: v,
    beforeDestroy: O,
    beforeUnmount: m,
    destroyed: E,
    unmounted: b,
    render: T,
    renderTracked: S,
    renderTriggered: y,
    errorCaptured: A,
    serverPrefetch: C,
    // public API
    expose: _,
    inheritAttrs: I,
    // assets
    components: x,
    directives: P,
    filters: N
  } = e;
  if (u && wj(u, i, null), o)
    for (const $ in o) {
      const k = o[$];
      Xe(k) && (i[$] = k.bind(t));
    }
  if (n) {
    const $ = n.call(t, t);
    kt($) && (r.data = Hb($));
  }
  if (iA = !0, a)
    for (const $ in a) {
      const k = a[$], G = Xe(k) ? k.bind(t, t) : Xe(k.get) ? k.get.bind(t, t) : Ri, F = !Xe(k) && Xe(k.set) ? k.set.bind(t) : Ri, q = m5({
        get: G,
        set: F
      });
      Object.defineProperty(i, $, {
        enumerable: !0,
        configurable: !0,
        get: () => q.value,
        set: (re) => q.value = re
      });
    }
  if (s)
    for (const $ in s)
      ZV(s[$], i, t, $);
  if (l) {
    const $ = Xe(l) ? l.call(t) : l;
    Reflect.ownKeys($).forEach((k) => {
      jV(k, $[k]);
    });
  }
  h && lN(h, r, "c");
  function D($, k) {
    Oe(k) ? k.forEach((G) => $(G.bind(t))) : k && $(k.bind(t));
  }
  if (D(UV, c), D(po, f), D($V, d), D(eS, p), D(MV, g), D(kV, v), D(FV, A), D(VV, S), D(BV, y), D(tS, m), D(rS, b), D(GV, C), Oe(_))
    if (_.length) {
      const $ = r.exposed || (r.exposed = {});
      _.forEach((k) => {
        Object.defineProperty($, k, {
          get: () => t[k],
          set: (G) => t[k] = G
        });
      });
    } else
      r.exposed || (r.exposed = {});
  T && r.render === Ri && (r.render = T), I != null && (r.inheritAttrs = I), x && (r.components = x), P && (r.directives = P);
}
function wj(r, e, t = Ri) {
  Oe(r) && (r = nA(r));
  for (const i in r) {
    const n = r[i];
    let a;
    kt(n) ? "default" in n ? a = qd(
      n.from || i,
      n.default,
      !0
      /* treat default function as factory */
    ) : a = qd(n.from || i) : a = qd(n), Tr(a) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => a.value,
      set: (o) => a.value = o
    }) : e[i] = a;
  }
}
function lN(r, e, t) {
  fn(
    Oe(r) ? r.map((i) => i.bind(e.proxy)) : r.bind(e.proxy),
    e,
    t
  );
}
function ZV(r, e, t, i) {
  const n = i.includes(".") ? NV(t, i) : () => t[i];
  if (it(r)) {
    const a = e[r];
    Xe(a) && Vn(n, a);
  } else if (Xe(r))
    Vn(n, r.bind(t));
  else if (kt(r))
    if (Oe(r))
      r.forEach((a) => ZV(a, e, t, i));
    else {
      const a = Xe(r.handler) ? r.handler.bind(t) : e[r.handler];
      Xe(a) && Vn(n, a, r);
    }
}
function B1(r) {
  const e = r.type, { mixins: t, extends: i } = e, {
    mixins: n,
    optionsCache: a,
    config: { optionMergeStrategies: o }
  } = r.appContext, s = a.get(e);
  let l;
  return s ? l = s : !n.length && !t && !i ? l = e : (l = {}, n.length && n.forEach(
    (u) => Wm(l, u, o, !0)
  ), Wm(l, e, o)), kt(e) && a.set(e, l), l;
}
function Wm(r, e, t, i = !1) {
  const { mixins: n, extends: a } = e;
  a && Wm(r, a, t, !0), n && n.forEach(
    (o) => Wm(r, o, t, !0)
  );
  for (const o in e)
    if (!(i && o === "expose")) {
      const s = Pj[o] || t && t[o];
      r[o] = s ? s(r[o], e[o]) : e[o];
    }
  return r;
}
const Pj = {
  data: uN,
  props: hN,
  emits: hN,
  // objects
  methods: Pd,
  computed: Pd,
  // lifecycle
  beforeCreate: gi,
  created: gi,
  beforeMount: gi,
  mounted: gi,
  beforeUpdate: gi,
  updated: gi,
  beforeDestroy: gi,
  beforeUnmount: gi,
  destroyed: gi,
  unmounted: gi,
  activated: gi,
  deactivated: gi,
  errorCaptured: gi,
  serverPrefetch: gi,
  // assets
  components: Pd,
  directives: Pd,
  // watch
  watch: Lj,
  // provide / inject
  provide: uN,
  inject: Nj
};
function uN(r, e) {
  return e ? r ? function() {
    return Ot(
      Xe(r) ? r.call(this, this) : r,
      Xe(e) ? e.call(this, this) : e
    );
  } : e : r;
}
function Nj(r, e) {
  return Pd(nA(r), nA(e));
}
function nA(r) {
  if (Oe(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++)
      e[r[t]] = r[t];
    return e;
  }
  return r;
}
function gi(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function Pd(r, e) {
  return r ? Ot(/* @__PURE__ */ Object.create(null), r, e) : e;
}
function hN(r, e) {
  return r ? Oe(r) && Oe(e) ? [.../* @__PURE__ */ new Set([...r, ...e])] : Ot(
    /* @__PURE__ */ Object.create(null),
    wp(r),
    wp(e ?? {})
  ) : e;
}
function Lj(r, e) {
  if (!r)
    return e;
  if (!e)
    return r;
  const t = Ot(/* @__PURE__ */ Object.create(null), r);
  for (const i in e)
    t[i] = gi(r[i], e[i]);
  return t;
}
function qV() {
  return {
    app: null,
    config: {
      isNativeTag: im,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let Dj = 0;
function Mj(r, e) {
  return function(i, n = null) {
    Xe(i) || (i = Ot({}, i)), n != null && !kt(n) && (n = null);
    const a = qV(), o = /* @__PURE__ */ new Set();
    let s = !1;
    const l = a.app = {
      _uid: Dj++,
      _component: i,
      _props: n,
      _container: null,
      _context: a,
      _instance: null,
      version: T5,
      get config() {
        return a.config;
      },
      set config(u) {
      },
      use(u, ...h) {
        return o.has(u) || (u && Xe(u.install) ? (o.add(u), u.install(l, ...h)) : Xe(u) && (o.add(u), u(l, ...h))), l;
      },
      mixin(u) {
        return a.mixins.includes(u) || a.mixins.push(u), l;
      },
      component(u, h) {
        return h ? (a.components[u] = h, l) : a.components[u];
      },
      directive(u, h) {
        return h ? (a.directives[u] = h, l) : a.directives[u];
      },
      mount(u, h, c) {
        if (!s) {
          const f = Vt(
            i,
            n
          );
          return f.appContext = a, h && e ? e(f, u) : r(f, u, c), s = !0, l._container = u, u.__vue_app__ = l, nS(f.component) || f.component.proxy;
        }
      },
      unmount() {
        s && (r(null, l._container), delete l._container.__vue_app__);
      },
      provide(u, h) {
        return a.provides[u] = h, l;
      },
      runWithContext(u) {
        Pp = l;
        try {
          return u();
        } finally {
          Pp = null;
        }
      }
    };
    return l;
  };
}
let Pp = null;
function jV(r, e) {
  if (pr) {
    let t = pr.provides;
    const i = pr.parent && pr.parent.provides;
    i === t && (t = pr.provides = Object.create(i)), t[r] = e;
  }
}
function qd(r, e, t = !1) {
  const i = pr || Lr;
  if (i || Pp) {
    const n = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : Pp._context.provides;
    if (n && r in n)
      return n[r];
    if (arguments.length > 1)
      return t && Xe(e) ? e.call(i && i.proxy) : e;
  }
}
function kj() {
  return !!(pr || Lr || Pp);
}
function Qj(r, e, t, i = !1) {
  const n = {}, a = {};
  Vm(a, iS, 1), r.propsDefaults = /* @__PURE__ */ Object.create(null), KV(r, e, n, a);
  for (const o in r.propsOptions[0])
    o in n || (n[o] = void 0);
  t ? r.props = i ? n : EV(n) : r.type.props ? r.props = n : r.props = a, r.attrs = a;
}
function Uj(r, e, t, i) {
  const {
    props: n,
    attrs: a,
    vnode: { patchFlag: o }
  } = r, s = mt(n), [l] = r.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    (i || o > 0) && !(o & 16)
  ) {
    if (o & 8) {
      const h = r.vnode.dynamicProps;
      for (let c = 0; c < h.length; c++) {
        let f = h[c];
        if (qb(r.emitsOptions, f))
          continue;
        const d = e[f];
        if (l)
          if (bt(a, f))
            d !== a[f] && (a[f] = d, u = !0);
          else {
            const p = Or(f);
            n[p] = aA(
              l,
              s,
              p,
              d,
              r,
              !1
              /* isAbsent */
            );
          }
        else
          d !== a[f] && (a[f] = d, u = !0);
      }
    }
  } else {
    KV(r, e, n, a) && (u = !0);
    let h;
    for (const c in s)
      (!e || // for camelCase
      !bt(e, c) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((h = sn(c)) === c || !bt(e, h))) && (l ? t && // for camelCase
      (t[c] !== void 0 || // for kebab-case
      t[h] !== void 0) && (n[c] = aA(
        l,
        s,
        c,
        void 0,
        r,
        !0
        /* isAbsent */
      )) : delete n[c]);
    if (a !== s)
      for (const c in a)
        (!e || !bt(e, c)) && (delete a[c], u = !0);
  }
  u && Bo(r, "set", "$attrs");
}
function KV(r, e, t, i) {
  const [n, a] = r.propsOptions;
  let o = !1, s;
  if (e)
    for (let l in e) {
      if (Pu(l))
        continue;
      const u = e[l];
      let h;
      n && bt(n, h = Or(l)) ? !a || !a.includes(h) ? t[h] = u : (s || (s = {}))[h] = u : qb(r.emitsOptions, l) || (!(l in i) || u !== i[l]) && (i[l] = u, o = !0);
    }
  if (a) {
    const l = mt(t), u = s || wt;
    for (let h = 0; h < a.length; h++) {
      const c = a[h];
      t[c] = aA(
        n,
        l,
        c,
        u[c],
        r,
        !bt(u, c)
      );
    }
  }
  return o;
}
function aA(r, e, t, i, n, a) {
  const o = r[t];
  if (o != null) {
    const s = bt(o, "default");
    if (s && i === void 0) {
      const l = o.default;
      if (o.type !== Function && !o.skipFactory && Xe(l)) {
        const { propsDefaults: u } = n;
        t in u ? i = u[t] : (el(n), i = u[t] = l.call(
          null,
          e
        ), Gs());
      } else
        i = l;
    }
    o[
      0
      /* shouldCast */
    ] && (a && !s ? i = !1 : o[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === sn(t)) && (i = !0));
  }
  return i;
}
function JV(r, e, t = !1) {
  const i = e.propsCache, n = i.get(r);
  if (n)
    return n;
  const a = r.props, o = {}, s = [];
  let l = !1;
  if (!Xe(r)) {
    const h = (c) => {
      l = !0;
      const [f, d] = JV(c, e, !0);
      Ot(o, f), d && s.push(...d);
    };
    !t && e.mixins.length && e.mixins.forEach(h), r.extends && h(r.extends), r.mixins && r.mixins.forEach(h);
  }
  if (!a && !l)
    return kt(r) && i.set(r, Rc), Rc;
  if (Oe(a))
    for (let h = 0; h < a.length; h++) {
      const c = Or(a[h]);
      cN(c) && (o[c] = wt);
    }
  else if (a)
    for (const h in a) {
      const c = Or(h);
      if (cN(c)) {
        const f = a[h], d = o[c] = Oe(f) || Xe(f) ? { type: f } : Ot({}, f);
        if (d) {
          const p = pN(Boolean, d.type), g = pN(String, d.type);
          d[
            0
            /* shouldCast */
          ] = p > -1, d[
            1
            /* shouldCastTrue */
          ] = g < 0 || p < g, (p > -1 || bt(d, "default")) && s.push(c);
        }
      }
    }
  const u = [o, s];
  return kt(r) && i.set(r, u), u;
}
function cN(r) {
  return r[0] !== "$";
}
function fN(r) {
  const e = r && r.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : r === null ? "null" : "";
}
function dN(r, e) {
  return fN(r) === fN(e);
}
function pN(r, e) {
  return Oe(e) ? e.findIndex((t) => dN(t, r)) : Xe(e) && dN(e, r) ? 0 : -1;
}
const e5 = (r) => r[0] === "_" || r === "$stable", V1 = (r) => Oe(r) ? r.map(an) : [an(r)], $j = (r, e, t) => {
  if (e._n)
    return e;
  const i = Ip((...n) => V1(e(...n)), t);
  return i._c = !1, i;
}, t5 = (r, e, t) => {
  const i = r._ctx;
  for (const n in r) {
    if (e5(n))
      continue;
    const a = r[n];
    if (Xe(a))
      e[n] = $j(n, a, i);
    else if (a != null) {
      const o = V1(a);
      e[n] = () => o;
    }
  }
}, r5 = (r, e) => {
  const t = V1(e);
  r.slots.default = () => t;
}, Gj = (r, e) => {
  if (r.vnode.shapeFlag & 32) {
    const t = e._;
    t ? (r.slots = mt(e), Vm(e, "_", t)) : t5(
      e,
      r.slots = {}
    );
  } else
    r.slots = {}, e && r5(r, e);
  Vm(r.slots, iS, 1);
}, Bj = (r, e, t) => {
  const { vnode: i, slots: n } = r;
  let a = !0, o = wt;
  if (i.shapeFlag & 32) {
    const s = e._;
    s ? t && s === 1 ? a = !1 : (Ot(n, e), !t && s === 1 && delete n._) : (a = !e.$stable, t5(e, n)), o = e;
  } else
    e && (r5(r, e), o = { default: 1 });
  if (a)
    for (const s in n)
      !e5(s) && !(s in o) && delete n[s];
};
function zm(r, e, t, i, n = !1) {
  if (Oe(r)) {
    r.forEach(
      (f, d) => zm(
        f,
        e && (Oe(e) ? e[d] : e),
        t,
        i,
        n
      )
    );
    return;
  }
  if (Du(i) && !n)
    return;
  const a = i.shapeFlag & 4 ? nS(i.component) || i.component.proxy : i.el, o = n ? null : a, { i: s, r: l } = r, u = e && e.r, h = s.refs === wt ? s.refs = {} : s.refs, c = s.setupState;
  if (u != null && u !== l && (it(u) ? (h[u] = null, bt(c, u) && (c[u] = null)) : Tr(u) && (u.value = null)), Xe(l))
    Lo(l, s, 12, [o, h]);
  else {
    const f = it(l), d = Tr(l);
    if (f || d) {
      const p = () => {
        if (r.f) {
          const g = f ? bt(c, l) ? c[l] : h[l] : l.value;
          n ? Oe(g) && b1(g, a) : Oe(g) ? g.includes(a) || g.push(a) : f ? (h[l] = [a], bt(c, l) && (c[l] = h[l])) : (l.value = [a], r.k && (h[r.k] = l.value));
        } else
          f ? (h[l] = o, bt(c, l) && (c[l] = o)) : d && (l.value = o, r.k && (h[r.k] = o));
      };
      o ? (p.id = -1, Gr(p, t)) : p();
    }
  }
}
let os = !1;
const yv = (r) => /svg/.test(r.namespaceURI) && r.tagName !== "foreignObject", Rv = (r) => r.nodeType === 8;
function Vj(r) {
  const {
    mt: e,
    p: t,
    o: {
      patchProp: i,
      createText: n,
      nextSibling: a,
      parentNode: o,
      remove: s,
      insert: l,
      createComment: u
    }
  } = r, h = (O, m) => {
    if (!m.hasChildNodes()) {
      t(null, O, m), Hm(), m._vnode = O;
      return;
    }
    os = !1, c(m.firstChild, O, null, null, null), Hm(), m._vnode = O, os && console.error("Hydration completed but contains mismatches.");
  }, c = (O, m, E, b, T, S = !1) => {
    const y = Rv(O) && O.data === "[", A = () => g(
      O,
      m,
      E,
      b,
      T,
      y
    ), { type: C, ref: _, shapeFlag: I, patchFlag: x } = m;
    let P = O.nodeType;
    m.el = O, x === -2 && (S = !1, m.dynamicChildren = null);
    let N = null;
    switch (C) {
      case ju:
        P !== 3 ? m.children === "" ? (l(m.el = n(""), o(O), O), N = O) : N = A() : (O.data !== m.children && (os = !0, O.data = m.children), N = a(O));
        break;
      case ui:
        P !== 8 || y ? N = A() : N = a(O);
        break;
      case Mu:
        if (y && (O = a(O), P = O.nodeType), P === 1 || P === 3) {
          N = O;
          const L = !m.children.length;
          for (let D = 0; D < m.staticCount; D++)
            L && (m.children += N.nodeType === 1 ? N.outerHTML : N.data), D === m.staticCount - 1 && (m.anchor = N), N = a(N);
          return y ? a(N) : N;
        } else
          A();
        break;
      case Nr:
        y ? N = p(
          O,
          m,
          E,
          b,
          T,
          S
        ) : N = A();
        break;
      default:
        if (I & 1)
          P !== 1 || m.type.toLowerCase() !== O.tagName.toLowerCase() ? N = A() : N = f(
            O,
            m,
            E,
            b,
            T,
            S
          );
        else if (I & 6) {
          m.slotScopeIds = T;
          const L = o(O);
          if (e(
            m,
            L,
            null,
            E,
            b,
            yv(L),
            S
          ), N = y ? v(O) : a(O), N && Rv(N) && N.data === "teleport end" && (N = a(N)), Du(m)) {
            let D;
            y ? (D = Vt(Nr), D.anchor = N ? N.previousSibling : L.lastChild) : D = O.nodeType === 3 ? X1("") : Vt("div"), D.el = O, m.component.subTree = D;
          }
        } else
          I & 64 ? P !== 8 ? N = A() : N = m.type.hydrate(
            O,
            m,
            E,
            b,
            T,
            S,
            r,
            d
          ) : I & 128 && (N = m.type.hydrate(
            O,
            m,
            E,
            b,
            yv(o(O)),
            T,
            S,
            r,
            c
          ));
    }
    return _ != null && zm(_, null, b, m), N;
  }, f = (O, m, E, b, T, S) => {
    S = S || !!m.dynamicChildren;
    const { type: y, props: A, patchFlag: C, shapeFlag: _, dirs: I } = m, x = y === "input" && I || y === "option";
    if (x || C !== -1) {
      if (I && ka(m, null, E, "created"), A)
        if (x || !S || C & 48)
          for (const N in A)
            (x && N.endsWith("value") || ph(N) && !Pu(N)) && i(
              O,
              N,
              null,
              A[N],
              !1,
              void 0,
              E
            );
        else
          A.onClick && i(
            O,
            "onClick",
            null,
            A.onClick,
            !1,
            void 0,
            E
          );
      let P;
      if ((P = A && A.onVnodeBeforeMount) && Li(P, E, m), I && ka(m, null, E, "beforeMount"), ((P = A && A.onVnodeMounted) || I) && wV(() => {
        P && Li(P, E, m), I && ka(m, null, E, "mounted");
      }, b), _ & 16 && // skip if element has innerHTML / textContent
      !(A && (A.innerHTML || A.textContent))) {
        let N = d(
          O.firstChild,
          m,
          O,
          E,
          b,
          T,
          S
        );
        for (; N; ) {
          os = !0;
          const L = N;
          N = N.nextSibling, s(L);
        }
      } else
        _ & 8 && O.textContent !== m.children && (os = !0, O.textContent = m.children);
    }
    return O.nextSibling;
  }, d = (O, m, E, b, T, S, y) => {
    y = y || !!m.dynamicChildren;
    const A = m.children, C = A.length;
    for (let _ = 0; _ < C; _++) {
      const I = y ? A[_] : A[_] = an(A[_]);
      if (O)
        O = c(
          O,
          I,
          b,
          T,
          S,
          y
        );
      else {
        if (I.type === ju && !I.children)
          continue;
        os = !0, t(
          null,
          I,
          E,
          null,
          b,
          T,
          yv(E),
          S
        );
      }
    }
    return O;
  }, p = (O, m, E, b, T, S) => {
    const { slotScopeIds: y } = m;
    y && (T = T ? T.concat(y) : y);
    const A = o(O), C = d(
      a(O),
      m,
      A,
      E,
      b,
      T,
      S
    );
    return C && Rv(C) && C.data === "]" ? a(m.anchor = C) : (os = !0, l(m.anchor = u("]"), A, C), C);
  }, g = (O, m, E, b, T, S) => {
    if (os = !0, m.el = null, S) {
      const C = v(O);
      for (; ; ) {
        const _ = a(O);
        if (_ && _ !== C)
          s(_);
        else
          break;
      }
    }
    const y = a(O), A = o(O);
    return s(O), t(
      null,
      m,
      A,
      y,
      E,
      b,
      yv(A),
      T
    ), y;
  }, v = (O) => {
    let m = 0;
    for (; O; )
      if (O = a(O), O && Rv(O) && (O.data === "[" && m++, O.data === "]")) {
        if (m === 0)
          return a(O);
        m--;
      }
    return O;
  };
  return [h, c];
}
const Gr = wV;
function i5(r) {
  return a5(r);
}
function n5(r) {
  return a5(r, Vj);
}
function a5(r, e) {
  const t = qR();
  t.__VUE__ = !0;
  const {
    insert: i,
    remove: n,
    patchProp: a,
    createElement: o,
    createText: s,
    createComment: l,
    setText: u,
    setElementText: h,
    parentNode: c,
    nextSibling: f,
    setScopeId: d = Ri,
    insertStaticContent: p
  } = r, g = (M, Q, B, W = null, H = null, J = null, le = !1, ee = null, se = !!Q.dynamicChildren) => {
    if (M === Q)
      return;
    M && !ua(M, Q) && (W = Ne(M), re(M, H, J, !0), M = null), Q.patchFlag === -2 && (se = !1, Q.dynamicChildren = null);
    const { type: j, ref: we, shapeFlag: Te } = Q;
    switch (j) {
      case ju:
        v(M, Q, B, W);
        break;
      case ui:
        O(M, Q, B, W);
        break;
      case Mu:
        M == null && m(Q, B, W, le);
        break;
      case Nr:
        x(
          M,
          Q,
          B,
          W,
          H,
          J,
          le,
          ee,
          se
        );
        break;
      default:
        Te & 1 ? T(
          M,
          Q,
          B,
          W,
          H,
          J,
          le,
          ee,
          se
        ) : Te & 6 ? P(
          M,
          Q,
          B,
          W,
          H,
          J,
          le,
          ee,
          se
        ) : (Te & 64 || Te & 128) && j.process(
          M,
          Q,
          B,
          W,
          H,
          J,
          le,
          ee,
          se,
          xe
        );
    }
    we != null && H && zm(we, M && M.ref, J, Q || M, !Q);
  }, v = (M, Q, B, W) => {
    if (M == null)
      i(
        Q.el = s(Q.children),
        B,
        W
      );
    else {
      const H = Q.el = M.el;
      Q.children !== M.children && u(H, Q.children);
    }
  }, O = (M, Q, B, W) => {
    M == null ? i(
      Q.el = l(Q.children || ""),
      B,
      W
    ) : Q.el = M.el;
  }, m = (M, Q, B, W) => {
    [M.el, M.anchor] = p(
      M.children,
      Q,
      B,
      W,
      M.el,
      M.anchor
    );
  }, E = ({ el: M, anchor: Q }, B, W) => {
    let H;
    for (; M && M !== Q; )
      H = f(M), i(M, B, W), M = H;
    i(Q, B, W);
  }, b = ({ el: M, anchor: Q }) => {
    let B;
    for (; M && M !== Q; )
      B = f(M), n(M), M = B;
    n(Q);
  }, T = (M, Q, B, W, H, J, le, ee, se) => {
    le = le || Q.type === "svg", M == null ? S(
      Q,
      B,
      W,
      H,
      J,
      le,
      ee,
      se
    ) : C(
      M,
      Q,
      H,
      J,
      le,
      ee,
      se
    );
  }, S = (M, Q, B, W, H, J, le, ee) => {
    let se, j;
    const { type: we, props: Te, shapeFlag: De, transition: We, dirs: gt } = M;
    if (se = M.el = o(
      M.type,
      J,
      Te && Te.is,
      Te
    ), De & 8 ? h(se, M.children) : De & 16 && A(
      M.children,
      se,
      null,
      W,
      H,
      J && we !== "foreignObject",
      le,
      ee
    ), gt && ka(M, null, W, "created"), y(se, M, M.scopeId, le, W), Te) {
      for (const Qt in Te)
        Qt !== "value" && !Pu(Qt) && a(
          se,
          Qt,
          null,
          Te[Qt],
          J,
          M.children,
          W,
          H,
          Pe
        );
      "value" in Te && a(se, "value", null, Te.value), (j = Te.onVnodeBeforeMount) && Li(j, W, M);
    }
    gt && ka(M, null, W, "beforeMount");
    const $t = (!H || H && !H.pendingBranch) && We && !We.persisted;
    $t && We.beforeEnter(se), i(se, Q, B), ((j = Te && Te.onVnodeMounted) || $t || gt) && Gr(() => {
      j && Li(j, W, M), $t && We.enter(se), gt && ka(M, null, W, "mounted");
    }, H);
  }, y = (M, Q, B, W, H) => {
    if (B && d(M, B), W)
      for (let J = 0; J < W.length; J++)
        d(M, W[J]);
    if (H) {
      let J = H.subTree;
      if (Q === J) {
        const le = H.vnode;
        y(
          M,
          le,
          le.scopeId,
          le.slotScopeIds,
          H.parent
        );
      }
    }
  }, A = (M, Q, B, W, H, J, le, ee, se = 0) => {
    for (let j = se; j < M.length; j++) {
      const we = M[j] = ee ? Ts(M[j]) : an(M[j]);
      g(
        null,
        we,
        Q,
        B,
        W,
        H,
        J,
        le,
        ee
      );
    }
  }, C = (M, Q, B, W, H, J, le) => {
    const ee = Q.el = M.el;
    let { patchFlag: se, dynamicChildren: j, dirs: we } = Q;
    se |= M.patchFlag & 16;
    const Te = M.props || wt, De = Q.props || wt;
    let We;
    B && Il(B, !1), (We = De.onVnodeBeforeUpdate) && Li(We, B, Q, M), we && ka(Q, M, B, "beforeUpdate"), B && Il(B, !0);
    const gt = H && Q.type !== "foreignObject";
    if (j ? _(
      M.dynamicChildren,
      j,
      ee,
      B,
      W,
      gt,
      J
    ) : le || k(
      M,
      Q,
      ee,
      null,
      B,
      W,
      gt,
      J,
      !1
    ), se > 0) {
      if (se & 16)
        I(
          ee,
          Q,
          Te,
          De,
          B,
          W,
          H
        );
      else if (se & 2 && Te.class !== De.class && a(ee, "class", null, De.class, H), se & 4 && a(ee, "style", Te.style, De.style, H), se & 8) {
        const $t = Q.dynamicProps;
        for (let Qt = 0; Qt < $t.length; Qt++) {
          const cr = $t[Qt], ta = Te[cr], Nh = De[cr];
          (Nh !== ta || cr === "value") && a(
            ee,
            cr,
            ta,
            Nh,
            H,
            M.children,
            B,
            W,
            Pe
          );
        }
      }
      se & 1 && M.children !== Q.children && h(ee, Q.children);
    } else
      !le && j == null && I(
        ee,
        Q,
        Te,
        De,
        B,
        W,
        H
      );
    ((We = De.onVnodeUpdated) || we) && Gr(() => {
      We && Li(We, B, Q, M), we && ka(Q, M, B, "updated");
    }, W);
  }, _ = (M, Q, B, W, H, J, le) => {
    for (let ee = 0; ee < Q.length; ee++) {
      const se = M[ee], j = Q[ee], we = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        se.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (se.type === Nr || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !ua(se, j) || // - In the case of a component, it could contain anything.
        se.shapeFlag & 70) ? c(se.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          B
        )
      );
      g(
        se,
        j,
        we,
        null,
        W,
        H,
        J,
        le,
        !0
      );
    }
  }, I = (M, Q, B, W, H, J, le) => {
    if (B !== W) {
      if (B !== wt)
        for (const ee in B)
          !Pu(ee) && !(ee in W) && a(
            M,
            ee,
            B[ee],
            null,
            le,
            Q.children,
            H,
            J,
            Pe
          );
      for (const ee in W) {
        if (Pu(ee))
          continue;
        const se = W[ee], j = B[ee];
        se !== j && ee !== "value" && a(
          M,
          ee,
          j,
          se,
          le,
          Q.children,
          H,
          J,
          Pe
        );
      }
      "value" in W && a(M, "value", B.value, W.value);
    }
  }, x = (M, Q, B, W, H, J, le, ee, se) => {
    const j = Q.el = M ? M.el : s(""), we = Q.anchor = M ? M.anchor : s("");
    let { patchFlag: Te, dynamicChildren: De, slotScopeIds: We } = Q;
    We && (ee = ee ? ee.concat(We) : We), M == null ? (i(j, B, W), i(we, B, W), A(
      Q.children,
      B,
      we,
      H,
      J,
      le,
      ee,
      se
    )) : Te > 0 && Te & 64 && De && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    M.dynamicChildren ? (_(
      M.dynamicChildren,
      De,
      B,
      H,
      J,
      le,
      ee
    ), // #2080 if the stable fragment has a key, it's a <template v-for> that may
    //  get moved around. Make sure all root level vnodes inherit el.
    // #2134 or if it's a component root, it may also get moved around
    // as the component is being moved.
    (Q.key != null || H && Q === H.subTree) && F1(
      M,
      Q,
      !0
      /* shallow */
    )) : k(
      M,
      Q,
      B,
      we,
      H,
      J,
      le,
      ee,
      se
    );
  }, P = (M, Q, B, W, H, J, le, ee, se) => {
    Q.slotScopeIds = ee, M == null ? Q.shapeFlag & 512 ? H.ctx.activate(
      Q,
      B,
      W,
      le,
      se
    ) : N(
      Q,
      B,
      W,
      H,
      J,
      le,
      se
    ) : L(M, Q, se);
  }, N = (M, Q, B, W, H, J, le) => {
    const ee = M.component = f5(
      M,
      W,
      H
    );
    if (Pg(M) && (ee.ctx.renderer = xe), p5(ee), ee.asyncDep) {
      if (H && H.registerDep(ee, D), !M.el) {
        const se = ee.subTree = Vt(ui);
        O(null, se, Q, B);
      }
      return;
    }
    D(
      ee,
      M,
      Q,
      B,
      H,
      J,
      le
    );
  }, L = (M, Q, B) => {
    const W = Q.component = M.component;
    if (Hq(M, Q, B))
      if (W.asyncDep && !W.asyncResolved) {
        $(W, Q, B);
        return;
      } else
        W.next = Q, $q(W.update), W.update();
    else
      Q.el = M.el, W.vnode = Q;
  }, D = (M, Q, B, W, H, J, le) => {
    const ee = () => {
      if (M.isMounted) {
        let { next: we, bu: Te, u: De, parent: We, vnode: gt } = M, $t = we, Qt;
        Il(M, !1), we ? (we.el = gt.el, $(M, we, le)) : we = gt, Te && _c(Te), (Qt = we.props && we.props.onVnodeBeforeUpdate) && Li(Qt, We, we, gt), Il(M, !0);
        const cr = nm(M), ta = M.subTree;
        M.subTree = cr, g(
          ta,
          cr,
          // parent may have changed if it's in a teleport
          c(ta.el),
          // anchor may have changed if it's in a fragment
          Ne(ta),
          M,
          H,
          J
        ), we.el = cr.el, $t === null && M1(M, cr.el), De && Gr(De, H), (Qt = we.props && we.props.onVnodeUpdated) && Gr(
          () => Li(Qt, We, we, gt),
          H
        );
      } else {
        let we;
        const { el: Te, props: De } = Q, { bm: We, m: gt, parent: $t } = M, Qt = Du(Q);
        if (Il(M, !1), We && _c(We), !Qt && (we = De && De.onVnodeBeforeMount) && Li(we, $t, Q), Il(M, !0), Te && ue) {
          const cr = () => {
            M.subTree = nm(M), ue(
              Te,
              M.subTree,
              M,
              H,
              null
            );
          };
          Qt ? Q.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !M.isUnmounted && cr()
          ) : cr();
        } else {
          const cr = M.subTree = nm(M);
          g(
            null,
            cr,
            B,
            W,
            M,
            H,
            J
          ), Q.el = cr.el;
        }
        if (gt && Gr(gt, H), !Qt && (we = De && De.onVnodeMounted)) {
          const cr = Q;
          Gr(
            () => Li(we, $t, cr),
            H
          );
        }
        (Q.shapeFlag & 256 || $t && Du($t.vnode) && $t.vnode.shapeFlag & 256) && M.a && Gr(M.a, H), M.isMounted = !0, Q = B = W = null;
      }
    }, se = M.effect = new xg(
      ee,
      () => Zb(j),
      M.scope
      // track it in component's effect scope
    ), j = M.update = () => se.run();
    j.id = M.uid, Il(M, !0), j();
  }, $ = (M, Q, B) => {
    Q.component = M;
    const W = M.vnode.props;
    M.vnode = Q, M.next = null, Uj(M, Q.props, W, B), Bj(M, Q.children, B), gf(), iN(), vf();
  }, k = (M, Q, B, W, H, J, le, ee, se = !1) => {
    const j = M && M.children, we = M ? M.shapeFlag : 0, Te = Q.children, { patchFlag: De, shapeFlag: We } = Q;
    if (De > 0) {
      if (De & 128) {
        F(
          j,
          Te,
          B,
          W,
          H,
          J,
          le,
          ee,
          se
        );
        return;
      } else if (De & 256) {
        G(
          j,
          Te,
          B,
          W,
          H,
          J,
          le,
          ee,
          se
        );
        return;
      }
    }
    We & 8 ? (we & 16 && Pe(j, H, J), Te !== j && h(B, Te)) : we & 16 ? We & 16 ? F(
      j,
      Te,
      B,
      W,
      H,
      J,
      le,
      ee,
      se
    ) : Pe(j, H, J, !0) : (we & 8 && h(B, ""), We & 16 && A(
      Te,
      B,
      W,
      H,
      J,
      le,
      ee,
      se
    ));
  }, G = (M, Q, B, W, H, J, le, ee, se) => {
    M = M || Rc, Q = Q || Rc;
    const j = M.length, we = Q.length, Te = Math.min(j, we);
    let De;
    for (De = 0; De < Te; De++) {
      const We = Q[De] = se ? Ts(Q[De]) : an(Q[De]);
      g(
        M[De],
        We,
        B,
        null,
        H,
        J,
        le,
        ee,
        se
      );
    }
    j > we ? Pe(
      M,
      H,
      J,
      !0,
      !1,
      Te
    ) : A(
      Q,
      B,
      W,
      H,
      J,
      le,
      ee,
      se,
      Te
    );
  }, F = (M, Q, B, W, H, J, le, ee, se) => {
    let j = 0;
    const we = Q.length;
    let Te = M.length - 1, De = we - 1;
    for (; j <= Te && j <= De; ) {
      const We = M[j], gt = Q[j] = se ? Ts(Q[j]) : an(Q[j]);
      if (ua(We, gt))
        g(
          We,
          gt,
          B,
          null,
          H,
          J,
          le,
          ee,
          se
        );
      else
        break;
      j++;
    }
    for (; j <= Te && j <= De; ) {
      const We = M[Te], gt = Q[De] = se ? Ts(Q[De]) : an(Q[De]);
      if (ua(We, gt))
        g(
          We,
          gt,
          B,
          null,
          H,
          J,
          le,
          ee,
          se
        );
      else
        break;
      Te--, De--;
    }
    if (j > Te) {
      if (j <= De) {
        const We = De + 1, gt = We < we ? Q[We].el : W;
        for (; j <= De; )
          g(
            null,
            Q[j] = se ? Ts(Q[j]) : an(Q[j]),
            B,
            gt,
            H,
            J,
            le,
            ee,
            se
          ), j++;
      }
    } else if (j > De)
      for (; j <= Te; )
        re(M[j], H, J, !0), j++;
    else {
      const We = j, gt = j, $t = /* @__PURE__ */ new Map();
      for (j = gt; j <= De; j++) {
        const Zi = Q[j] = se ? Ts(Q[j]) : an(Q[j]);
        Zi.key != null && $t.set(Zi.key, j);
      }
      let Qt, cr = 0;
      const ta = De - gt + 1;
      let Nh = !1, YP = 0;
      const Bf = new Array(ta);
      for (j = 0; j < ta; j++)
        Bf[j] = 0;
      for (j = We; j <= Te; j++) {
        const Zi = M[j];
        if (cr >= ta) {
          re(Zi, H, J, !0);
          continue;
        }
        let ya;
        if (Zi.key != null)
          ya = $t.get(Zi.key);
        else
          for (Qt = gt; Qt <= De; Qt++)
            if (Bf[Qt - gt] === 0 && ua(Zi, Q[Qt])) {
              ya = Qt;
              break;
            }
        ya === void 0 ? re(Zi, H, J, !0) : (Bf[ya - gt] = j + 1, ya >= YP ? YP = ya : Nh = !0, g(
          Zi,
          Q[ya],
          B,
          null,
          H,
          J,
          le,
          ee,
          se
        ), cr++);
      }
      const HP = Nh ? Fj(Bf) : Rc;
      for (Qt = HP.length - 1, j = ta - 1; j >= 0; j--) {
        const Zi = gt + j, ya = Q[Zi], WP = Zi + 1 < we ? Q[Zi + 1].el : W;
        Bf[j] === 0 ? g(
          null,
          ya,
          B,
          WP,
          H,
          J,
          le,
          ee,
          se
        ) : Nh && (Qt < 0 || j !== HP[Qt] ? q(ya, B, WP, 2) : Qt--);
      }
    }
  }, q = (M, Q, B, W, H = null) => {
    const { el: J, type: le, transition: ee, children: se, shapeFlag: j } = M;
    if (j & 6) {
      q(M.component.subTree, Q, B, W);
      return;
    }
    if (j & 128) {
      M.suspense.move(Q, B, W);
      return;
    }
    if (j & 64) {
      le.move(M, Q, B, xe);
      return;
    }
    if (le === Nr) {
      i(J, Q, B);
      for (let Te = 0; Te < se.length; Te++)
        q(se[Te], Q, B, W);
      i(M.anchor, Q, B);
      return;
    }
    if (le === Mu) {
      E(M, Q, B);
      return;
    }
    if (W !== 2 && j & 1 && ee)
      if (W === 0)
        ee.beforeEnter(J), i(J, Q, B), Gr(() => ee.enter(J), H);
      else {
        const { leave: Te, delayLeave: De, afterLeave: We } = ee, gt = () => i(J, Q, B), $t = () => {
          Te(J, () => {
            gt(), We && We();
          });
        };
        De ? De(J, gt, $t) : $t();
      }
    else
      i(J, Q, B);
  }, re = (M, Q, B, W = !1, H = !1) => {
    const {
      type: J,
      props: le,
      ref: ee,
      children: se,
      dynamicChildren: j,
      shapeFlag: we,
      patchFlag: Te,
      dirs: De
    } = M;
    if (ee != null && zm(ee, null, B, M, !0), we & 256) {
      Q.ctx.deactivate(M);
      return;
    }
    const We = we & 1 && De, gt = !Du(M);
    let $t;
    if (gt && ($t = le && le.onVnodeBeforeUnmount) && Li($t, Q, M), we & 6)
      $e(M.component, B, W);
    else {
      if (we & 128) {
        M.suspense.unmount(B, W);
        return;
      }
      We && ka(M, null, Q, "beforeUnmount"), we & 64 ? M.type.remove(
        M,
        Q,
        B,
        H,
        xe,
        W
      ) : j && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (J !== Nr || Te > 0 && Te & 64) ? Pe(
        j,
        Q,
        B,
        !1,
        !0
      ) : (J === Nr && Te & 384 || !H && we & 16) && Pe(se, Q, B), W && fe(M);
    }
    (gt && ($t = le && le.onVnodeUnmounted) || We) && Gr(() => {
      $t && Li($t, Q, M), We && ka(M, null, Q, "unmounted");
    }, B);
  }, fe = (M) => {
    const { type: Q, el: B, anchor: W, transition: H } = M;
    if (Q === Nr) {
      de(B, W);
      return;
    }
    if (Q === Mu) {
      b(M);
      return;
    }
    const J = () => {
      n(B), H && !H.persisted && H.afterLeave && H.afterLeave();
    };
    if (M.shapeFlag & 1 && H && !H.persisted) {
      const { leave: le, delayLeave: ee } = H, se = () => le(B, J);
      ee ? ee(M.el, J, se) : se();
    } else
      J();
  }, de = (M, Q) => {
    let B;
    for (; M !== Q; )
      B = f(M), n(M), M = B;
    n(Q);
  }, $e = (M, Q, B) => {
    const { bum: W, scope: H, update: J, subTree: le, um: ee } = M;
    W && _c(W), H.stop(), J && (J.active = !1, re(le, M, Q, B)), ee && Gr(ee, Q), Gr(() => {
      M.isUnmounted = !0;
    }, Q), Q && Q.pendingBranch && !Q.isUnmounted && M.asyncDep && !M.asyncResolved && M.suspenseId === Q.pendingId && (Q.deps--, Q.deps === 0 && Q.resolve());
  }, Pe = (M, Q, B, W = !1, H = !1, J = 0) => {
    for (let le = J; le < M.length; le++)
      re(M[le], Q, B, W, H);
  }, Ne = (M) => M.shapeFlag & 6 ? Ne(M.component.subTree) : M.shapeFlag & 128 ? M.suspense.next() : f(M.anchor || M.el), Ee = (M, Q, B) => {
    M == null ? Q._vnode && re(Q._vnode, null, null, !0) : g(Q._vnode || null, M, Q, null, null, null, B), iN(), Hm(), Q._vnode = M;
  }, xe = {
    p: g,
    um: re,
    m: q,
    r: fe,
    mt: N,
    mc: A,
    pc: k,
    pbc: _,
    n: Ne,
    o: r
  };
  let Ce, ue;
  return e && ([Ce, ue] = e(
    xe
  )), {
    render: Ee,
    hydrate: Ce,
    createApp: Mj(Ee, Ce)
  };
}
function Il({ effect: r, update: e }, t) {
  r.allowRecurse = e.allowRecurse = t;
}
function F1(r, e, t = !1) {
  const i = r.children, n = e.children;
  if (Oe(i) && Oe(n))
    for (let a = 0; a < i.length; a++) {
      const o = i[a];
      let s = n[a];
      s.shapeFlag & 1 && !s.dynamicChildren && ((s.patchFlag <= 0 || s.patchFlag === 32) && (s = n[a] = Ts(n[a]), s.el = o.el), t || F1(o, s)), s.type === ju && (s.el = o.el);
    }
}
function Fj(r) {
  const e = r.slice(), t = [0];
  let i, n, a, o, s;
  const l = r.length;
  for (i = 0; i < l; i++) {
    const u = r[i];
    if (u !== 0) {
      if (n = t[t.length - 1], r[n] < u) {
        e[i] = n, t.push(i);
        continue;
      }
      for (a = 0, o = t.length - 1; a < o; )
        s = a + o >> 1, r[t[s]] < u ? a = s + 1 : o = s;
      u < r[t[a]] && (a > 0 && (e[i] = t[a - 1]), t[a] = i);
    }
  }
  for (a = t.length, o = t[a - 1]; a-- > 0; )
    t[a] = o, o = e[o];
  return t;
}
const Xj = (r) => r.__isTeleport, jd = (r) => r && (r.disabled || r.disabled === ""), gN = (r) => typeof SVGElement < "u" && r instanceof SVGElement, oA = (r, e) => {
  const t = r && r.to;
  return it(t) ? e ? e(t) : null : t;
}, Yj = {
  __isTeleport: !0,
  process(r, e, t, i, n, a, o, s, l, u) {
    const {
      mc: h,
      pc: c,
      pbc: f,
      o: { insert: d, querySelector: p, createText: g, createComment: v }
    } = u, O = jd(e.props);
    let { shapeFlag: m, children: E, dynamicChildren: b } = e;
    if (r == null) {
      const T = e.el = g(""), S = e.anchor = g("");
      d(T, t, i), d(S, t, i);
      const y = e.target = oA(e.props, p), A = e.targetAnchor = g("");
      y && (d(A, y), o = o || gN(y));
      const C = (_, I) => {
        m & 16 && h(
          E,
          _,
          I,
          n,
          a,
          o,
          s,
          l
        );
      };
      O ? C(t, S) : y && C(y, A);
    } else {
      e.el = r.el;
      const T = e.anchor = r.anchor, S = e.target = r.target, y = e.targetAnchor = r.targetAnchor, A = jd(r.props), C = A ? t : S, _ = A ? T : y;
      if (o = o || gN(S), b ? (f(
        r.dynamicChildren,
        b,
        C,
        n,
        a,
        o,
        s
      ), F1(r, e, !0)) : l || c(
        r,
        e,
        C,
        _,
        n,
        a,
        o,
        s,
        !1
      ), O)
        A || Av(
          e,
          t,
          T,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
        const I = e.target = oA(
          e.props,
          p
        );
        I && Av(
          e,
          I,
          null,
          u,
          0
        );
      } else
        A && Av(
          e,
          S,
          y,
          u,
          1
        );
    }
    o5(e);
  },
  remove(r, e, t, i, { um: n, o: { remove: a } }, o) {
    const { shapeFlag: s, children: l, anchor: u, targetAnchor: h, target: c, props: f } = r;
    if (c && a(h), (o || !jd(f)) && (a(u), s & 16))
      for (let d = 0; d < l.length; d++) {
        const p = l[d];
        n(
          p,
          e,
          t,
          !0,
          !!p.dynamicChildren
        );
      }
  },
  move: Av,
  hydrate: Hj
};
function Av(r, e, t, { o: { insert: i }, m: n }, a = 2) {
  a === 0 && i(r.targetAnchor, e, t);
  const { el: o, anchor: s, shapeFlag: l, children: u, props: h } = r, c = a === 2;
  if (c && i(o, e, t), (!c || jd(h)) && l & 16)
    for (let f = 0; f < u.length; f++)
      n(
        u[f],
        e,
        t,
        2
      );
  c && i(s, e, t);
}
function Hj(r, e, t, i, n, a, {
  o: { nextSibling: o, parentNode: s, querySelector: l }
}, u) {
  const h = e.target = oA(
    e.props,
    l
  );
  if (h) {
    const c = h._lpa || h.firstChild;
    if (e.shapeFlag & 16)
      if (jd(e.props))
        e.anchor = u(
          o(r),
          e,
          s(r),
          t,
          i,
          n,
          a
        ), e.targetAnchor = c;
      else {
        e.anchor = o(r);
        let f = c;
        for (; f; )
          if (f = o(f), f && f.nodeType === 8 && f.data === "teleport anchor") {
            e.targetAnchor = f, h._lpa = e.targetAnchor && o(e.targetAnchor);
            break;
          }
        u(
          c,
          e,
          h,
          t,
          i,
          n,
          a
        );
      }
    o5(e);
  }
  return e.anchor && o(e.anchor);
}
const Wj = Yj;
function o5(r) {
  const e = r.ctx;
  if (e && e.ut) {
    let t = r.children[0].el;
    for (; t !== r.targetAnchor; )
      t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid), t = t.nextSibling;
    e.ut();
  }
}
const Nr = Symbol.for("v-fgt"), ju = Symbol.for("v-txt"), ui = Symbol.for("v-cmt"), Mu = Symbol.for("v-stc"), Kd = [];
let $i = null;
function Tt(r = !1) {
  Kd.push($i = r ? null : []);
}
function s5() {
  Kd.pop(), $i = Kd[Kd.length - 1] || null;
}
let Ku = 1;
function sA(r) {
  Ku += r;
}
function l5(r) {
  return r.dynamicChildren = Ku > 0 ? $i || Rc : null, s5(), Ku > 0 && $i && $i.push(r), r;
}
function ir(r, e, t, i, n, a) {
  return l5(
    dt(
      r,
      e,
      t,
      i,
      n,
      a,
      !0
      /* isBlock */
    )
  );
}
function la(r, e, t, i, n) {
  return l5(
    Vt(
      r,
      e,
      t,
      i,
      n,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function Js(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function ua(r, e) {
  return r.type === e.type && r.key === e.key;
}
function zj(r) {
}
const iS = "__vInternal", u5 = ({ key: r }) => r ?? null, am = ({
  ref: r,
  ref_key: e,
  ref_for: t
}) => (typeof r == "number" && (r = "" + r), r != null ? it(r) || Tr(r) || Xe(r) ? { i: Lr, r, k: e, f: !!t } : r : null);
function dt(r, e = null, t = null, i = 0, n = null, a = r === Nr ? 0 : 1, o = !1, s = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && u5(e),
    ref: e && am(e),
    scopeId: jb,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a,
    patchFlag: i,
    dynamicProps: n,
    dynamicChildren: null,
    appContext: null,
    ctx: Lr
  };
  return s ? (Y1(l, t), a & 128 && r.normalize(l)) : t && (l.shapeFlag |= it(t) ? 8 : 16), Ku > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  $i && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || a & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && $i.push(l), l;
}
const Vt = Zj;
function Zj(r, e = null, t = null, i = 0, n = null, a = !1) {
  if ((!r || r === YV) && (r = ui), Js(r)) {
    const s = io(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return t && Y1(s, t), Ku > 0 && !a && $i && (s.shapeFlag & 6 ? $i[$i.indexOf(r)] = s : $i.push(s)), s.patchFlag |= -2, s;
  }
  if (rK(r) && (r = r.__vccOpts), e) {
    e = h5(e);
    let { class: s, style: l } = e;
    s && !it(s) && (e.class = Oh(s)), kt(l) && (I1(l) && !Oe(l) && (l = Ot({}, l)), e.style = Wn(l));
  }
  const o = it(r) ? 1 : xV(r) ? 128 : Xj(r) ? 64 : kt(r) ? 4 : Xe(r) ? 2 : 0;
  return dt(
    r,
    e,
    t,
    i,
    n,
    o,
    a,
    !0
  );
}
function h5(r) {
  return r ? I1(r) || iS in r ? Ot({}, r) : r : null;
}
function io(r, e, t = !1) {
  const { props: i, ref: n, patchFlag: a, children: o } = r, s = e ? c5(i || {}, e) : i;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: s,
    key: s && u5(s),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && n ? Oe(n) ? n.concat(am(e)) : [n, am(e)] : am(e)
    ) : n,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: o,
    target: r.target,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== Nr ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: r.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && io(r.ssContent),
    ssFallback: r.ssFallback && io(r.ssFallback),
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce
  };
}
function X1(r = " ", e = 0) {
  return Vt(ju, null, r, e);
}
function qj(r, e) {
  const t = Vt(Mu, null, r);
  return t.staticCount = e, t;
}
function ln(r = "", e = !1) {
  return e ? (Tt(), la(ui, null, r)) : Vt(ui, null, r);
}
function an(r) {
  return r == null || typeof r == "boolean" ? Vt(ui) : Oe(r) ? Vt(
    Nr,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : typeof r == "object" ? Ts(r) : Vt(ju, null, String(r));
}
function Ts(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : io(r);
}
function Y1(r, e) {
  let t = 0;
  const { shapeFlag: i } = r;
  if (e == null)
    e = null;
  else if (Oe(e))
    t = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const n = e.default;
      n && (n._c && (n._d = !1), Y1(r, n()), n._c && (n._d = !0));
      return;
    } else {
      t = 32;
      const n = e._;
      !n && !(iS in e) ? e._ctx = Lr : n === 3 && Lr && (Lr.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else
    Xe(e) ? (e = { default: e, _ctx: Lr }, t = 32) : (e = String(e), i & 64 ? (t = 16, e = [X1(e)]) : t = 8);
  r.children = e, r.shapeFlag |= t;
}
function c5(...r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const i = r[t];
    for (const n in i)
      if (n === "class")
        e.class !== i.class && (e.class = Oh([e.class, i.class]));
      else if (n === "style")
        e.style = Wn([e.style, i.style]);
      else if (ph(n)) {
        const a = e[n], o = i[n];
        o && a !== o && !(Oe(a) && a.includes(o)) && (e[n] = a ? [].concat(a, o) : o);
      } else
        n !== "" && (e[n] = i[n]);
  }
  return e;
}
function Li(r, e, t, i = null) {
  fn(r, e, 7, [
    t,
    i
  ]);
}
const jj = qV();
let Kj = 0;
function f5(r, e, t) {
  const i = r.type, n = (e ? e.appContext : r.appContext) || jj, a = {
    uid: Kj++,
    vnode: r,
    type: i,
    parent: e,
    appContext: n,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new R1(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(n.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: JV(i, n),
    emitsOptions: CV(i, n),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: wt,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: wt,
    data: wt,
    props: wt,
    attrs: wt,
    slots: wt,
    refs: wt,
    setupState: wt,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return a.ctx = { _: a }, a.root = e ? e.root : a, a.emit = Bq.bind(null, a), r.ce && r.ce(a), a;
}
let pr = null;
const Jo = () => pr || Lr;
let H1, Lh, vN = "__VUE_INSTANCE_SETTERS__";
(Lh = qR()[vN]) || (Lh = qR()[vN] = []), Lh.push((r) => pr = r), H1 = (r) => {
  Lh.length > 1 ? Lh.forEach((e) => e(r)) : Lh[0](r);
};
const el = (r) => {
  H1(r), r.scope.on();
}, Gs = () => {
  pr && pr.scope.off(), H1(null);
};
function d5(r) {
  return r.vnode.shapeFlag & 4;
}
let Yc = !1;
function p5(r, e = !1) {
  Yc = e;
  const { props: t, children: i } = r.vnode, n = d5(r);
  Qj(r, t, n, e), Gj(r, i);
  const a = n ? Jj(r, e) : void 0;
  return Yc = !1, a;
}
function Jj(r, e) {
  const t = r.type;
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = x1(new Proxy(r.ctx, rA));
  const { setup: i } = t;
  if (i) {
    const n = r.setupContext = i.length > 1 ? O5(r) : null;
    el(r), gf();
    const a = Lo(
      i,
      r,
      0,
      [r.props, n]
    );
    if (vf(), Gs(), S1(a)) {
      if (a.then(Gs, Gs), e)
        return a.then((o) => {
          lA(r, o, e);
        }).catch((o) => {
          mh(o, r, 0);
        });
      r.asyncDep = a;
    } else
      lA(r, a, e);
  } else
    v5(r, e);
}
function lA(r, e, t) {
  Xe(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : kt(e) && (r.setupState = N1(e)), v5(r, t);
}
let Zm, uA;
function g5(r) {
  Zm = r, uA = (e) => {
    e.render._rc && (e.withProxy = new Proxy(e.ctx, pj));
  };
}
const eK = () => !Zm;
function v5(r, e, t) {
  const i = r.type;
  if (!r.render) {
    if (!e && Zm && !i.render) {
      const n = i.template || B1(r).template;
      if (n) {
        const { isCustomElement: a, compilerOptions: o } = r.appContext.config, { delimiters: s, compilerOptions: l } = i, u = Ot(
          Ot(
            {
              isCustomElement: a,
              delimiters: s
            },
            o
          ),
          l
        );
        i.render = Zm(n, u);
      }
    }
    r.render = i.render || Ri, uA && uA(r);
  }
  el(r), gf(), xj(r), vf(), Gs();
}
function tK(r) {
  return r.attrsProxy || (r.attrsProxy = new Proxy(
    r.attrs,
    {
      get(e, t) {
        return Fi(r, "get", "$attrs"), e[t];
      }
    }
  ));
}
function O5(r) {
  const e = (t) => {
    r.exposed = t || {};
  };
  return {
    get attrs() {
      return tK(r);
    },
    slots: r.slots,
    emit: r.emit,
    expose: e
  };
}
function nS(r) {
  if (r.exposed)
    return r.exposeProxy || (r.exposeProxy = new Proxy(N1(x1(r.exposed)), {
      get(e, t) {
        if (t in e)
          return e[t];
        if (t in Zd)
          return Zd[t](r);
      },
      has(e, t) {
        return t in e || t in Zd;
      }
    }));
}
function hA(r, e = !0) {
  return Xe(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function rK(r) {
  return Xe(r) && "__vccOpts" in r;
}
const m5 = (r, e) => Dq(r, e, Yc);
function Sl(r, e, t) {
  const i = arguments.length;
  return i === 2 ? kt(e) && !Oe(e) ? Js(e) ? Vt(r, null, [e]) : Vt(r, e) : Vt(r, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && Js(t) && (t = [t]), Vt(r, e, t));
}
const E5 = Symbol.for("v-scx"), b5 = () => qd(E5);
function iK() {
}
function nK(r, e, t, i) {
  const n = t[i];
  if (n && S5(n, r))
    return n;
  const a = e();
  return a.memo = r.slice(), t[i] = a;
}
function S5(r, e) {
  const t = r.memo;
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (Vc(t[i], e[i]))
      return !1;
  return Ku > 0 && $i && $i.push(r), !0;
}
const T5 = "3.3.4", aK = {
  createComponentInstance: f5,
  setupComponent: p5,
  renderComponentRoot: nm,
  setCurrentRenderingInstance: _p,
  isVNode: Js,
  normalizeVNode: an
}, oK = aK, sK = null, lK = null, uK = "http://www.w3.org/2000/svg", cu = typeof document < "u" ? document : null, ON = cu && /* @__PURE__ */ cu.createElement("template"), hK = {
  insert: (r, e, t) => {
    e.insertBefore(r, t || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, t, i) => {
    const n = e ? cu.createElementNS(uK, r) : cu.createElement(r, t ? { is: t } : void 0);
    return r === "select" && i && i.multiple != null && n.setAttribute("multiple", i.multiple), n;
  },
  createText: (r) => cu.createTextNode(r),
  createComment: (r) => cu.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => cu.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, t, i, n, a) {
    const o = t ? t.previousSibling : e.lastChild;
    if (n && (n === a || n.nextSibling))
      for (; e.insertBefore(n.cloneNode(!0), t), !(n === a || !(n = n.nextSibling)); )
        ;
    else {
      ON.innerHTML = i ? `<svg>${r}</svg>` : r;
      const s = ON.content;
      if (i) {
        const l = s.firstChild;
        for (; l.firstChild; )
          s.appendChild(l.firstChild);
        s.removeChild(l);
      }
      e.insertBefore(s, t);
    }
    return [
      // first
      o ? o.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
};
function cK(r, e, t) {
  const i = r._vtc;
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? r.removeAttribute("class") : t ? r.setAttribute("class", e) : r.className = e;
}
function fK(r, e, t) {
  const i = r.style, n = it(t);
  if (t && !n) {
    if (e && !it(e))
      for (const a in e)
        t[a] == null && cA(i, a, "");
    for (const a in t)
      cA(i, a, t[a]);
  } else {
    const a = i.display;
    n ? e !== t && (i.cssText = t) : e && r.removeAttribute("style"), "_vod" in r && (i.display = a);
  }
}
const mN = /\s*!important$/;
function cA(r, e, t) {
  if (Oe(t))
    t.forEach((i) => cA(r, e, i));
  else if (t == null && (t = ""), e.startsWith("--"))
    r.setProperty(e, t);
  else {
    const i = dK(r, e);
    mN.test(t) ? r.setProperty(
      sn(i),
      t.replace(mN, ""),
      "important"
    ) : r[i] = t;
  }
}
const EN = ["Webkit", "Moz", "ms"], PT = {};
function dK(r, e) {
  const t = PT[e];
  if (t)
    return t;
  let i = Or(e);
  if (i !== "filter" && i in r)
    return PT[e] = i;
  i = vh(i);
  for (let n = 0; n < EN.length; n++) {
    const a = EN[n] + i;
    if (a in r)
      return PT[e] = a;
  }
  return e;
}
const bN = "http://www.w3.org/1999/xlink";
function pK(r, e, t, i, n) {
  if (i && e.startsWith("xlink:"))
    t == null ? r.removeAttributeNS(bN, e.slice(6, e.length)) : r.setAttributeNS(bN, e, t);
  else {
    const a = B8(e);
    t == null || a && !iV(t) ? r.removeAttribute(e) : r.setAttribute(e, a ? "" : t);
  }
}
function gK(r, e, t, i, n, a, o) {
  if (e === "innerHTML" || e === "textContent") {
    i && o(i, n, a), r[e] = t ?? "";
    return;
  }
  const s = r.tagName;
  if (e === "value" && s !== "PROGRESS" && // custom elements may use _value internally
  !s.includes("-")) {
    r._value = t;
    const u = s === "OPTION" ? r.getAttribute("value") : r.value, h = t ?? "";
    u !== h && (r.value = h), t == null && r.removeAttribute(e);
    return;
  }
  let l = !1;
  if (t === "" || t == null) {
    const u = typeof r[e];
    u === "boolean" ? t = iV(t) : t == null && u === "string" ? (t = "", l = !0) : u === "number" && (t = 0, l = !0);
  }
  try {
    r[e] = t;
  } catch {
  }
  l && r.removeAttribute(e);
}
function xo(r, e, t, i) {
  r.addEventListener(e, t, i);
}
function vK(r, e, t, i) {
  r.removeEventListener(e, t, i);
}
function OK(r, e, t, i, n = null) {
  const a = r._vei || (r._vei = {}), o = a[e];
  if (i && o)
    o.value = i;
  else {
    const [s, l] = mK(e);
    if (i) {
      const u = a[e] = SK(i, n);
      xo(r, s, u, l);
    } else
      o && (vK(r, s, o, l), a[e] = void 0);
  }
}
const SN = /(?:Once|Passive|Capture)$/;
function mK(r) {
  let e;
  if (SN.test(r)) {
    e = {};
    let i;
    for (; i = r.match(SN); )
      r = r.slice(0, r.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : sn(r.slice(2)), e];
}
let NT = 0;
const EK = /* @__PURE__ */ Promise.resolve(), bK = () => NT || (EK.then(() => NT = 0), NT = Date.now());
function SK(r, e) {
  const t = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= t.attached)
      return;
    fn(
      TK(i, t.value),
      e,
      5,
      [i]
    );
  };
  return t.value = r, t.attached = bK(), t;
}
function TK(r, e) {
  if (Oe(e)) {
    const t = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      t.call(r), r._stopped = !0;
    }, e.map((i) => (n) => !n._stopped && i && i(n));
  } else
    return e;
}
const TN = /^on[a-z]/, yK = (r, e, t, i, n = !1, a, o, s, l) => {
  e === "class" ? cK(r, i, n) : e === "style" ? fK(r, t, i) : ph(e) ? E1(e) || OK(r, e, t, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : RK(r, e, i, n)) ? gK(
    r,
    e,
    i,
    a,
    o,
    s,
    l
  ) : (e === "true-value" ? r._trueValue = i : e === "false-value" && (r._falseValue = i), pK(r, e, i, n));
};
function RK(r, e, t, i) {
  return i ? !!(e === "innerHTML" || e === "textContent" || e in r && TN.test(e) && Xe(t)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA" || TN.test(e) && it(t) ? !1 : e in r;
}
function W1(r, e) {
  const t = xi(r);
  class i extends aS {
    constructor(a) {
      super(t, a, e);
    }
  }
  return i.def = t, i;
}
const AK = (r) => W1(r, U5), CK = typeof HTMLElement < "u" ? HTMLElement : class {
};
class aS extends CK {
  constructor(e, t = {}, i) {
    super(), this._def = e, this._props = t, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && i ? i(this._createVNode(), this.shadowRoot) : (this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, Zu(() => {
      this._connected || (pA(null, this.shadowRoot), this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = !0;
    for (let i = 0; i < this.attributes.length; i++)
      this._setAttr(this.attributes[i].name);
    new MutationObserver((i) => {
      for (const n of i)
        this._setAttr(n.attributeName);
    }).observe(this, { attributes: !0 });
    const e = (i, n = !1) => {
      const { props: a, styles: o } = i;
      let s;
      if (a && !Oe(a))
        for (const l in a) {
          const u = a[l];
          (u === Number || u && u.type === Number) && (l in this._props && (this._props[l] = Xm(this._props[l])), (s || (s = /* @__PURE__ */ Object.create(null)))[Or(l)] = !0);
        }
      this._numberProps = s, n && this._resolveProps(i), this._applyStyles(o), this._update();
    }, t = this._def.__asyncLoader;
    t ? t().then((i) => e(i, !0)) : e(this._def);
  }
  _resolveProps(e) {
    const { props: t } = e, i = Oe(t) ? t : Object.keys(t || {});
    for (const n of Object.keys(this))
      n[0] !== "_" && i.includes(n) && this._setProp(n, this[n], !0, !1);
    for (const n of i.map(Or))
      Object.defineProperty(this, n, {
        get() {
          return this._getProp(n);
        },
        set(a) {
          this._setProp(n, a);
        }
      });
  }
  _setAttr(e) {
    let t = this.getAttribute(e);
    const i = Or(e);
    this._numberProps && this._numberProps[i] && (t = Xm(t)), this._setProp(i, t, !1);
  }
  /**
   * @internal
   */
  _getProp(e) {
    return this._props[e];
  }
  /**
   * @internal
   */
  _setProp(e, t, i = !0, n = !0) {
    t !== this._props[e] && (this._props[e] = t, n && this._instance && this._update(), i && (t === !0 ? this.setAttribute(sn(e), "") : typeof t == "string" || typeof t == "number" ? this.setAttribute(sn(e), t + "") : t || this.removeAttribute(sn(e))));
  }
  _update() {
    pA(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const e = Vt(this._def, Ot({}, this._props));
    return this._instance || (e.ce = (t) => {
      this._instance = t, t.isCE = !0;
      const i = (a, o) => {
        this.dispatchEvent(
          new CustomEvent(a, {
            detail: o
          })
        );
      };
      t.emit = (a, ...o) => {
        i(a, o), sn(a) !== a && i(sn(a), o);
      };
      let n = this;
      for (; n = n && (n.parentNode || n.host); )
        if (n instanceof aS) {
          t.parent = n._instance, t.provides = n._instance.provides;
          break;
        }
    }), e;
  }
  _applyStyles(e) {
    e && e.forEach((t) => {
      const i = document.createElement("style");
      i.textContent = t, this.shadowRoot.appendChild(i);
    });
  }
}
function _K(r = "$style") {
  {
    const e = Jo();
    if (!e)
      return wt;
    const t = e.type.__cssModules;
    if (!t)
      return wt;
    const i = t[r];
    return i || wt;
  }
}
function IK(r) {
  const e = Jo();
  if (!e)
    return;
  const t = e.ut = (n = r(e.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${e.uid}"]`)
    ).forEach((a) => dA(a, n));
  }, i = () => {
    const n = r(e.proxy);
    fA(e.subTree, n), t(n);
  };
  PV(i), po(() => {
    const n = new MutationObserver(i);
    n.observe(e.subTree.el.parentNode, { childList: !0 }), rS(() => n.disconnect());
  });
}
function fA(r, e) {
  if (r.shapeFlag & 128) {
    const t = r.suspense;
    r = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => {
      fA(t.activeBranch, e);
    });
  }
  for (; r.component; )
    r = r.component.subTree;
  if (r.shapeFlag & 1 && r.el)
    dA(r.el, e);
  else if (r.type === Nr)
    r.children.forEach((t) => fA(t, e));
  else if (r.type === Mu) {
    let { el: t, anchor: i } = r;
    for (; t && (dA(t, e), t !== i); )
      t = t.nextSibling;
  }
}
function dA(r, e) {
  if (r.nodeType === 1) {
    const t = r.style;
    for (const i in e)
      t.setProperty(`--${i}`, e[i]);
  }
}
const ss = "transition", Vf = "animation", z1 = (r, { slots: e }) => Sl(LV, R5(r), e);
z1.displayName = "Transition";
const y5 = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, xK = z1.props = /* @__PURE__ */ Ot(
  {},
  U1,
  y5
), xl = (r, e = []) => {
  Oe(r) ? r.forEach((t) => t(...e)) : r && r(...e);
}, yN = (r) => r ? Oe(r) ? r.some((e) => e.length > 1) : r.length > 1 : !1;
function R5(r) {
  const e = {};
  for (const x in r)
    x in y5 || (e[x] = r[x]);
  if (r.css === !1)
    return e;
  const {
    name: t = "v",
    type: i,
    duration: n,
    enterFromClass: a = `${t}-enter-from`,
    enterActiveClass: o = `${t}-enter-active`,
    enterToClass: s = `${t}-enter-to`,
    appearFromClass: l = a,
    appearActiveClass: u = o,
    appearToClass: h = s,
    leaveFromClass: c = `${t}-leave-from`,
    leaveActiveClass: f = `${t}-leave-active`,
    leaveToClass: d = `${t}-leave-to`
  } = r, p = wK(n), g = p && p[0], v = p && p[1], {
    onBeforeEnter: O,
    onEnter: m,
    onEnterCancelled: E,
    onLeave: b,
    onLeaveCancelled: T,
    onBeforeAppear: S = O,
    onAppear: y = m,
    onAppearCancelled: A = E
  } = e, C = (x, P, N) => {
    Es(x, P ? h : s), Es(x, P ? u : o), N && N();
  }, _ = (x, P) => {
    x._isLeaving = !1, Es(x, c), Es(x, d), Es(x, f), P && P();
  }, I = (x) => (P, N) => {
    const L = x ? y : m, D = () => C(P, x, N);
    xl(L, [P, D]), RN(() => {
      Es(P, x ? l : a), Ro(P, x ? h : s), yN(L) || AN(P, i, g, D);
    });
  };
  return Ot(e, {
    onBeforeEnter(x) {
      xl(O, [x]), Ro(x, a), Ro(x, o);
    },
    onBeforeAppear(x) {
      xl(S, [x]), Ro(x, l), Ro(x, u);
    },
    onEnter: I(!1),
    onAppear: I(!0),
    onLeave(x, P) {
      x._isLeaving = !0;
      const N = () => _(x, P);
      Ro(x, c), C5(), Ro(x, f), RN(() => {
        x._isLeaving && (Es(x, c), Ro(x, d), yN(b) || AN(x, i, v, N));
      }), xl(b, [x, N]);
    },
    onEnterCancelled(x) {
      C(x, !1), xl(E, [x]);
    },
    onAppearCancelled(x) {
      C(x, !0), xl(A, [x]);
    },
    onLeaveCancelled(x) {
      _(x), xl(T, [x]);
    }
  });
}
function wK(r) {
  if (r == null)
    return null;
  if (kt(r))
    return [LT(r.enter), LT(r.leave)];
  {
    const e = LT(r);
    return [e, e];
  }
}
function LT(r) {
  return Xm(r);
}
function Ro(r, e) {
  e.split(/\s+/).forEach((t) => t && r.classList.add(t)), (r._vtc || (r._vtc = /* @__PURE__ */ new Set())).add(e);
}
function Es(r, e) {
  e.split(/\s+/).forEach((i) => i && r.classList.remove(i));
  const { _vtc: t } = r;
  t && (t.delete(e), t.size || (r._vtc = void 0));
}
function RN(r) {
  requestAnimationFrame(() => {
    requestAnimationFrame(r);
  });
}
let PK = 0;
function AN(r, e, t, i) {
  const n = r._endId = ++PK, a = () => {
    n === r._endId && i();
  };
  if (t)
    return setTimeout(a, t);
  const { type: o, timeout: s, propCount: l } = A5(r, e);
  if (!o)
    return i();
  const u = o + "end";
  let h = 0;
  const c = () => {
    r.removeEventListener(u, f), a();
  }, f = (d) => {
    d.target === r && ++h >= l && c();
  };
  setTimeout(() => {
    h < l && c();
  }, s + 1), r.addEventListener(u, f);
}
function A5(r, e) {
  const t = window.getComputedStyle(r), i = (p) => (t[p] || "").split(", "), n = i(`${ss}Delay`), a = i(`${ss}Duration`), o = CN(n, a), s = i(`${Vf}Delay`), l = i(`${Vf}Duration`), u = CN(s, l);
  let h = null, c = 0, f = 0;
  e === ss ? o > 0 && (h = ss, c = o, f = a.length) : e === Vf ? u > 0 && (h = Vf, c = u, f = l.length) : (c = Math.max(o, u), h = c > 0 ? o > u ? ss : Vf : null, f = h ? h === ss ? a.length : l.length : 0);
  const d = h === ss && /\b(transform|all)(,|$)/.test(
    i(`${ss}Property`).toString()
  );
  return {
    type: h,
    timeout: c,
    propCount: f,
    hasTransform: d
  };
}
function CN(r, e) {
  for (; r.length < e.length; )
    r = r.concat(r);
  return Math.max(...e.map((t, i) => _N(t) + _N(r[i])));
}
function _N(r) {
  return Number(r.slice(0, -1).replace(",", ".")) * 1e3;
}
function C5() {
  return document.body.offsetHeight;
}
const _5 = /* @__PURE__ */ new WeakMap(), I5 = /* @__PURE__ */ new WeakMap(), x5 = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ Ot({}, xK, {
    tag: String,
    moveClass: String
  }),
  setup(r, { slots: e }) {
    const t = Jo(), i = Q1();
    let n, a;
    return eS(() => {
      if (!n.length)
        return;
      const o = r.moveClass || `${r.name || "v"}-move`;
      if (!QK(
        n[0].el,
        t.vnode.el,
        o
      ))
        return;
      n.forEach(DK), n.forEach(MK);
      const s = n.filter(kK);
      C5(), s.forEach((l) => {
        const u = l.el, h = u.style;
        Ro(u, o), h.transform = h.webkitTransform = h.transitionDuration = "";
        const c = u._moveCb = (f) => {
          f && f.target !== u || (!f || /transform$/.test(f.propertyName)) && (u.removeEventListener("transitionend", c), u._moveCb = null, Es(u, o));
        };
        u.addEventListener("transitionend", c);
      });
    }), () => {
      const o = mt(r), s = R5(o);
      let l = o.tag || Nr;
      n = a, a = e.default ? Kb(e.default()) : [];
      for (let u = 0; u < a.length; u++) {
        const h = a[u];
        h.key != null && qu(
          h,
          Xc(h, s, i, t)
        );
      }
      if (n)
        for (let u = 0; u < n.length; u++) {
          const h = n[u];
          qu(
            h,
            Xc(h, s, i, t)
          ), _5.set(h, h.el.getBoundingClientRect());
        }
      return Vt(l, null, a);
    };
  }
}, NK = (r) => delete r.mode;
x5.props;
const LK = x5;
function DK(r) {
  const e = r.el;
  e._moveCb && e._moveCb(), e._enterCb && e._enterCb();
}
function MK(r) {
  I5.set(r, r.el.getBoundingClientRect());
}
function kK(r) {
  const e = _5.get(r), t = I5.get(r), i = e.left - t.left, n = e.top - t.top;
  if (i || n) {
    const a = r.el.style;
    return a.transform = a.webkitTransform = `translate(${i}px,${n}px)`, a.transitionDuration = "0s", r;
  }
}
function QK(r, e, t) {
  const i = r.cloneNode();
  r._vtc && r._vtc.forEach((o) => {
    o.split(/\s+/).forEach((s) => s && i.classList.remove(s));
  }), t.split(/\s+/).forEach((o) => o && i.classList.add(o)), i.style.display = "none";
  const n = e.nodeType === 1 ? e : e.parentNode;
  n.appendChild(i);
  const { hasTransform: a } = A5(i);
  return n.removeChild(i), a;
}
const tl = (r) => {
  const e = r.props["onUpdate:modelValue"] || !1;
  return Oe(e) ? (t) => _c(e, t) : e;
};
function UK(r) {
  r.target.composing = !0;
}
function IN(r) {
  const e = r.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const qm = {
  created(r, { modifiers: { lazy: e, trim: t, number: i } }, n) {
    r._assign = tl(n);
    const a = i || n.props && n.props.type === "number";
    xo(r, e ? "change" : "input", (o) => {
      if (o.target.composing)
        return;
      let s = r.value;
      t && (s = s.trim()), a && (s = Fm(s)), r._assign(s);
    }), t && xo(r, "change", () => {
      r.value = r.value.trim();
    }), e || (xo(r, "compositionstart", UK), xo(r, "compositionend", IN), xo(r, "change", IN));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(r, { value: e }) {
    r.value = e ?? "";
  },
  beforeUpdate(r, { value: e, modifiers: { lazy: t, trim: i, number: n } }, a) {
    if (r._assign = tl(a), r.composing || document.activeElement === r && r.type !== "range" && (t || i && r.value.trim() === e || (n || r.type === "number") && Fm(r.value) === e))
      return;
    const o = e ?? "";
    r.value !== o && (r.value = o);
  }
}, Z1 = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(r, e, t) {
    r._assign = tl(t), xo(r, "change", () => {
      const i = r._modelValue, n = Hc(r), a = r.checked, o = r._assign;
      if (Oe(i)) {
        const s = Vb(i, n), l = s !== -1;
        if (a && !l)
          o(i.concat(n));
        else if (!a && l) {
          const u = [...i];
          u.splice(s, 1), o(u);
        }
      } else if (gh(i)) {
        const s = new Set(i);
        a ? s.add(n) : s.delete(n), o(s);
      } else
        o(P5(r, a));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: xN,
  beforeUpdate(r, e, t) {
    r._assign = tl(t), xN(r, e, t);
  }
};
function xN(r, { value: e, oldValue: t }, i) {
  r._modelValue = e, Oe(e) ? r.checked = Vb(e, i.props.value) > -1 : gh(e) ? r.checked = e.has(i.props.value) : e !== t && (r.checked = js(e, P5(r, !0)));
}
const q1 = {
  created(r, { value: e }, t) {
    r.checked = js(e, t.props.value), r._assign = tl(t), xo(r, "change", () => {
      r._assign(Hc(r));
    });
  },
  beforeUpdate(r, { value: e, oldValue: t }, i) {
    r._assign = tl(i), e !== t && (r.checked = js(e, i.props.value));
  }
}, w5 = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(r, { value: e, modifiers: { number: t } }, i) {
    const n = gh(e);
    xo(r, "change", () => {
      const a = Array.prototype.filter.call(r.options, (o) => o.selected).map(
        (o) => t ? Fm(Hc(o)) : Hc(o)
      );
      r._assign(
        r.multiple ? n ? new Set(a) : a : a[0]
      );
    }), r._assign = tl(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(r, { value: e }) {
    wN(r, e);
  },
  beforeUpdate(r, e, t) {
    r._assign = tl(t);
  },
  updated(r, { value: e }) {
    wN(r, e);
  }
};
function wN(r, e) {
  const t = r.multiple;
  if (!(t && !Oe(e) && !gh(e))) {
    for (let i = 0, n = r.options.length; i < n; i++) {
      const a = r.options[i], o = Hc(a);
      if (t)
        Oe(e) ? a.selected = Vb(e, o) > -1 : a.selected = e.has(o);
      else if (js(Hc(a), e)) {
        r.selectedIndex !== i && (r.selectedIndex = i);
        return;
      }
    }
    !t && r.selectedIndex !== -1 && (r.selectedIndex = -1);
  }
}
function Hc(r) {
  return "_value" in r ? r._value : r.value;
}
function P5(r, e) {
  const t = e ? "_trueValue" : "_falseValue";
  return t in r ? r[t] : e;
}
const N5 = {
  created(r, e, t) {
    Cv(r, e, t, null, "created");
  },
  mounted(r, e, t) {
    Cv(r, e, t, null, "mounted");
  },
  beforeUpdate(r, e, t, i) {
    Cv(r, e, t, i, "beforeUpdate");
  },
  updated(r, e, t, i) {
    Cv(r, e, t, i, "updated");
  }
};
function L5(r, e) {
  switch (r) {
    case "SELECT":
      return w5;
    case "TEXTAREA":
      return qm;
    default:
      switch (e) {
        case "checkbox":
          return Z1;
        case "radio":
          return q1;
        default:
          return qm;
      }
  }
}
function Cv(r, e, t, i, n) {
  const o = L5(
    r.tagName,
    t.props && t.props.type
  )[n];
  o && o(r, e, t, i);
}
function $K() {
  qm.getSSRProps = ({ value: r }) => ({ value: r }), q1.getSSRProps = ({ value: r }, e) => {
    if (e.props && js(e.props.value, r))
      return { checked: !0 };
  }, Z1.getSSRProps = ({ value: r }, e) => {
    if (Oe(r)) {
      if (e.props && Vb(r, e.props.value) > -1)
        return { checked: !0 };
    } else if (gh(r)) {
      if (e.props && r.has(e.props.value))
        return { checked: !0 };
    } else if (r)
      return { checked: !0 };
  }, N5.getSSRProps = (r, e) => {
    if (typeof e.type != "string")
      return;
    const t = L5(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      e.type.toUpperCase(),
      e.props && e.props.type
    );
    if (t.getSSRProps)
      return t.getSSRProps(r, e);
  };
}
const GK = ["ctrl", "shift", "alt", "meta"], BK = {
  stop: (r) => r.stopPropagation(),
  prevent: (r) => r.preventDefault(),
  self: (r) => r.target !== r.currentTarget,
  ctrl: (r) => !r.ctrlKey,
  shift: (r) => !r.shiftKey,
  alt: (r) => !r.altKey,
  meta: (r) => !r.metaKey,
  left: (r) => "button" in r && r.button !== 0,
  middle: (r) => "button" in r && r.button !== 1,
  right: (r) => "button" in r && r.button !== 2,
  exact: (r, e) => GK.some((t) => r[`${t}Key`] && !e.includes(t))
}, VK = (r, e) => (t, ...i) => {
  for (let n = 0; n < e.length; n++) {
    const a = BK[e[n]];
    if (a && a(t, e))
      return;
  }
  return r(t, ...i);
}, FK = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, XK = (r, e) => (t) => {
  if (!("key" in t))
    return;
  const i = sn(t.key);
  if (e.some((n) => n === i || FK[n] === i))
    return r(t);
}, D5 = {
  beforeMount(r, { value: e }, { transition: t }) {
    r._vod = r.style.display === "none" ? "" : r.style.display, t && e ? t.beforeEnter(r) : Ff(r, e);
  },
  mounted(r, { value: e }, { transition: t }) {
    t && e && t.enter(r);
  },
  updated(r, { value: e, oldValue: t }, { transition: i }) {
    !e != !t && (i ? e ? (i.beforeEnter(r), Ff(r, !0), i.enter(r)) : i.leave(r, () => {
      Ff(r, !1);
    }) : Ff(r, e));
  },
  beforeUnmount(r, { value: e }) {
    Ff(r, e);
  }
};
function Ff(r, e) {
  r.style.display = e ? r._vod : "none";
}
function YK() {
  D5.getSSRProps = ({ value: r }) => {
    if (!r)
      return { style: { display: "none" } };
  };
}
const M5 = /* @__PURE__ */ Ot({ patchProp: yK }, hK);
let Jd, PN = !1;
function k5() {
  return Jd || (Jd = i5(M5));
}
function Q5() {
  return Jd = PN ? Jd : n5(M5), PN = !0, Jd;
}
const pA = (...r) => {
  k5().render(...r);
}, U5 = (...r) => {
  Q5().hydrate(...r);
}, HK = (...r) => {
  const e = k5().createApp(...r), { mount: t } = e;
  return e.mount = (i) => {
    const n = $5(i);
    if (!n)
      return;
    const a = e._component;
    !Xe(a) && !a.render && !a.template && (a.template = n.innerHTML), n.innerHTML = "";
    const o = t(n, !1, n instanceof SVGElement);
    return n instanceof Element && (n.removeAttribute("v-cloak"), n.setAttribute("data-v-app", "")), o;
  }, e;
}, WK = (...r) => {
  const e = Q5().createApp(...r), { mount: t } = e;
  return e.mount = (i) => {
    const n = $5(i);
    if (n)
      return t(n, !0, n instanceof SVGElement);
  }, e;
};
function $5(r) {
  return it(r) ? document.querySelector(r) : r;
}
let NN = !1;
const zK = () => {
  NN || (NN = !0, $K(), YK());
}, ZK = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: LV,
  BaseTransitionPropsValidators: U1,
  Comment: ui,
  EffectScope: R1,
  Fragment: Nr,
  KeepAlive: sj,
  ReactiveEffect: xg,
  Static: Mu,
  Suspense: zq,
  Teleport: Wj,
  Text: ju,
  Transition: z1,
  TransitionGroup: LK,
  VueElement: aS,
  assertNumber: kq,
  callWithAsyncErrorHandling: fn,
  callWithErrorHandling: Lo,
  camelize: Or,
  capitalize: vh,
  cloneVNode: io,
  compatUtils: lK,
  computed: m5,
  createApp: HK,
  createBlock: la,
  createCommentVNode: ln,
  createElementBlock: ir,
  createElementVNode: dt,
  createHydrationRenderer: n5,
  createPropsRestProxy: _j,
  createRenderer: i5,
  createSSRApp: WK,
  createSlots: fj,
  createStaticVNode: qj,
  createTextVNode: X1,
  createVNode: Vt,
  customRef: Iq,
  defineAsyncComponent: aj,
  defineComponent: xi,
  defineCustomElement: W1,
  defineEmits: vj,
  defineExpose: Oj,
  defineModel: bj,
  defineOptions: mj,
  defineProps: gj,
  defineSSRCustomElement: AK,
  defineSlots: Ej,
  get devtools() {
    return ac;
  },
  effect: W8,
  effectScope: F8,
  getCurrentInstance: Jo,
  getCurrentScope: oV,
  getTransitionRawChildren: Kb,
  guardReactiveProps: h5,
  h: Sl,
  handleError: mh,
  hasInjectionContext: kj,
  hydrate: U5,
  initCustomFormatter: iK,
  initDirectivesForSSR: zK,
  inject: qd,
  isMemoSame: S5,
  isProxy: I1,
  isReactive: Lu,
  isReadonly: zu,
  isRef: Tr,
  isRuntimeOnly: eK,
  isShallow: yp,
  isVNode: Js,
  markRaw: x1,
  mergeDefaults: Aj,
  mergeModels: Cj,
  mergeProps: c5,
  nextTick: Zu,
  normalizeClass: Oh,
  normalizeProps: L8,
  normalizeStyle: Wn,
  onActivated: MV,
  onBeforeMount: UV,
  onBeforeUnmount: tS,
  onBeforeUpdate: $V,
  onDeactivated: kV,
  onErrorCaptured: FV,
  onMounted: po,
  onRenderTracked: VV,
  onRenderTriggered: BV,
  onScopeDispose: X8,
  onServerPrefetch: GV,
  onUnmounted: rS,
  onUpdated: eS,
  openBlock: Tt,
  popScopeId: IV,
  provide: jV,
  proxyRefs: N1,
  pushScopeId: _V,
  queuePostFlushCb: D1,
  reactive: Hb,
  readonly: _1,
  ref: Sr,
  registerRuntimeCompiler: g5,
  render: pA,
  renderList: HV,
  renderSlot: oi,
  resolveComponent: XV,
  resolveDirective: cj,
  resolveDynamicComponent: hj,
  resolveFilter: sK,
  resolveTransitionHooks: Xc,
  setBlockTracking: sA,
  setDevtoolsHook: AV,
  setTransitionHooks: qu,
  shallowReactive: EV,
  shallowReadonly: Sq,
  shallowRef: Tq,
  ssrContextKey: E5,
  ssrUtils: oK,
  stop: z8,
  toDisplayString: y1,
  toHandlerKey: Cc,
  toHandlers: dj,
  toRaw: mt,
  toRef: Nq,
  toRefs: xq,
  toValue: Aq,
  transformVNodeArgs: zj,
  triggerRef: Rq,
  unref: Fc,
  useAttrs: yj,
  useCssModule: _K,
  useCssVars: IK,
  useModel: Rj,
  useSSRContext: b5,
  useSlots: Tj,
  useTransitionState: Q1,
  vModelCheckbox: Z1,
  vModelDynamic: N5,
  vModelRadio: q1,
  vModelSelect: w5,
  vModelText: qm,
  vShow: D5,
  version: T5,
  warn: Mq,
  watch: Vn,
  watchEffect: ej,
  watchPostEffect: PV,
  watchSyncEffect: tj,
  withAsyncContext: Ij,
  withCtx: Ip,
  withDefaults: Sj,
  withDirectives: ij,
  withKeys: XK,
  withMemo: nK,
  withModifiers: VK,
  withScopeId: Vq
}, Symbol.toStringTag, { value: "Module" }));
function j1(r) {
  throw r;
}
function G5(r) {
}
function Ht(r, e, t, i) {
  const n = r, a = new SyntaxError(String(n));
  return a.code = r, a.loc = e, a;
}
const Np = Symbol(""), ep = Symbol(""), K1 = Symbol(""), jm = Symbol(""), B5 = Symbol(""), Ju = Symbol(""), V5 = Symbol(""), F5 = Symbol(""), J1 = Symbol(""), eI = Symbol(""), Ng = Symbol(""), tI = Symbol(""), X5 = Symbol(""), rI = Symbol(""), Km = Symbol(
  ""
), iI = Symbol(""), nI = Symbol(""), aI = Symbol(""), oI = Symbol(""), Y5 = Symbol(""), H5 = Symbol(""), oS = Symbol(""), Jm = Symbol(""), sI = Symbol(""), lI = Symbol(""), Lp = Symbol(""), Lg = Symbol(""), uI = Symbol(""), gA = Symbol(""), qK = Symbol(""), vA = Symbol(""), eE = Symbol(""), jK = Symbol(""), KK = Symbol(""), hI = Symbol(""), JK = Symbol(""), eJ = Symbol(""), cI = Symbol(""), W5 = Symbol(""), Wc = {
  [Np]: "Fragment",
  [ep]: "Teleport",
  [K1]: "Suspense",
  [jm]: "KeepAlive",
  [B5]: "BaseTransition",
  [Ju]: "openBlock",
  [V5]: "createBlock",
  [F5]: "createElementBlock",
  [J1]: "createVNode",
  [eI]: "createElementVNode",
  [Ng]: "createCommentVNode",
  [tI]: "createTextVNode",
  [X5]: "createStaticVNode",
  [rI]: "resolveComponent",
  [Km]: "resolveDynamicComponent",
  [iI]: "resolveDirective",
  [nI]: "resolveFilter",
  [aI]: "withDirectives",
  [oI]: "renderList",
  [Y5]: "renderSlot",
  [H5]: "createSlots",
  [oS]: "toDisplayString",
  [Jm]: "mergeProps",
  [sI]: "normalizeClass",
  [lI]: "normalizeStyle",
  [Lp]: "normalizeProps",
  [Lg]: "guardReactiveProps",
  [uI]: "toHandlers",
  [gA]: "camelize",
  [qK]: "capitalize",
  [vA]: "toHandlerKey",
  [eE]: "setBlockTracking",
  [jK]: "pushScopeId",
  [KK]: "popScopeId",
  [hI]: "withCtx",
  [JK]: "unref",
  [eJ]: "isRef",
  [cI]: "withMemo",
  [W5]: "isMemoSame"
};
function tJ(r) {
  Object.getOwnPropertySymbols(r).forEach((e) => {
    Wc[e] = r[e];
  });
}
const mn = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function rJ(r, e = mn) {
  return {
    type: 0,
    children: r,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: e
  };
}
function Dp(r, e, t, i, n, a, o, s = !1, l = !1, u = !1, h = mn) {
  return r && (s ? (r.helper(Ju), r.helper(qc(r.inSSR, u))) : r.helper(Zc(r.inSSR, u)), o && r.helper(aI)), {
    type: 13,
    tag: e,
    props: t,
    children: i,
    patchFlag: n,
    dynamicProps: a,
    directives: o,
    isBlock: s,
    disableTracking: l,
    isComponent: u,
    loc: h
  };
}
function Dg(r, e = mn) {
  return {
    type: 17,
    loc: e,
    elements: r
  };
}
function Qn(r, e = mn) {
  return {
    type: 15,
    loc: e,
    properties: r
  };
}
function nr(r, e) {
  return {
    type: 16,
    loc: mn,
    key: it(r) ? ct(r, !0) : r,
    value: e
  };
}
function ct(r, e = !1, t = mn, i = 0) {
  return {
    type: 4,
    loc: t,
    content: r,
    isStatic: e,
    constType: e ? 3 : i
  };
}
function ga(r, e = mn) {
  return {
    type: 8,
    loc: e,
    children: r
  };
}
function dr(r, e = [], t = mn) {
  return {
    type: 14,
    loc: t,
    callee: r,
    arguments: e
  };
}
function zc(r, e = void 0, t = !1, i = !1, n = mn) {
  return {
    type: 18,
    params: r,
    returns: e,
    newline: t,
    isSlot: i,
    loc: n
  };
}
function OA(r, e, t, i = !0) {
  return {
    type: 19,
    test: r,
    consequent: e,
    alternate: t,
    newline: i,
    loc: mn
  };
}
function iJ(r, e, t = !1) {
  return {
    type: 20,
    index: r,
    value: e,
    isVNode: t,
    loc: mn
  };
}
function nJ(r) {
  return {
    type: 21,
    body: r,
    loc: mn
  };
}
function Zc(r, e) {
  return r || e ? J1 : eI;
}
function qc(r, e) {
  return r || e ? V5 : F5;
}
function fI(r, { helper: e, removeHelper: t, inSSR: i }) {
  r.isBlock || (r.isBlock = !0, t(Zc(i, r.isComponent)), e(Ju), e(qc(i, r.isComponent)));
}
const Gi = (r) => r.type === 4 && r.isStatic, pc = (r, e) => r === e || r === sn(e);
function z5(r) {
  if (pc(r, "Teleport"))
    return ep;
  if (pc(r, "Suspense"))
    return K1;
  if (pc(r, "KeepAlive"))
    return jm;
  if (pc(r, "BaseTransition"))
    return B5;
}
const aJ = /^\d|[^\$\w]/, dI = (r) => !aJ.test(r), oJ = /[A-Za-z_$\xA0-\uFFFF]/, sJ = /[\.\?\w$\xA0-\uFFFF]/, lJ = /\s+[.[]\s*|\s*[.[]\s+/g, uJ = (r) => {
  r = r.trim().replace(lJ, (o) => o.trim());
  let e = 0, t = [], i = 0, n = 0, a = null;
  for (let o = 0; o < r.length; o++) {
    const s = r.charAt(o);
    switch (e) {
      case 0:
        if (s === "[")
          t.push(e), e = 1, i++;
        else if (s === "(")
          t.push(e), e = 2, n++;
        else if (!(o === 0 ? oJ : sJ).test(s))
          return !1;
        break;
      case 1:
        s === "'" || s === '"' || s === "`" ? (t.push(e), e = 3, a = s) : s === "[" ? i++ : s === "]" && (--i || (e = t.pop()));
        break;
      case 2:
        if (s === "'" || s === '"' || s === "`")
          t.push(e), e = 3, a = s;
        else if (s === "(")
          n++;
        else if (s === ")") {
          if (o === r.length - 1)
            return !1;
          --n || (e = t.pop());
        }
        break;
      case 3:
        s === a && (e = t.pop(), a = null);
        break;
    }
  }
  return !i && !n;
}, Z5 = uJ;
function q5(r, e, t) {
  const n = {
    source: r.source.slice(e, e + t),
    start: tE(r.start, r.source, e),
    end: r.end
  };
  return t != null && (n.end = tE(
    r.start,
    r.source,
    e + t
  )), n;
}
function tE(r, e, t = e.length) {
  return rE(
    Ot({}, r),
    e,
    t
  );
}
function rE(r, e, t = e.length) {
  let i = 0, n = -1;
  for (let a = 0; a < t; a++)
    e.charCodeAt(a) === 10 && (i++, n = a);
  return r.offset += t, r.line += i, r.column = n === -1 ? r.column + t : t - n, r;
}
function Pn(r, e, t = !1) {
  for (let i = 0; i < r.props.length; i++) {
    const n = r.props[i];
    if (n.type === 7 && (t || n.exp) && (it(e) ? n.name === e : e.test(n.name)))
      return n;
  }
}
function sS(r, e, t = !1, i = !1) {
  for (let n = 0; n < r.props.length; n++) {
    const a = r.props[n];
    if (a.type === 6) {
      if (t)
        continue;
      if (a.name === e && (a.value || i))
        return a;
    } else if (a.name === "bind" && (a.exp || i) && Eu(a.arg, e))
      return a;
  }
}
function Eu(r, e) {
  return !!(r && Gi(r) && r.content === e);
}
function hJ(r) {
  return r.props.some(
    (e) => e.type === 7 && e.name === "bind" && (!e.arg || // v-bind="obj"
    e.arg.type !== 4 || // v-bind:[_ctx.foo]
    !e.arg.isStatic)
    // v-bind:[foo]
  );
}
function DT(r) {
  return r.type === 5 || r.type === 2;
}
function cJ(r) {
  return r.type === 7 && r.name === "slot";
}
function iE(r) {
  return r.type === 1 && r.tagType === 3;
}
function nE(r) {
  return r.type === 1 && r.tagType === 2;
}
const fJ = /* @__PURE__ */ new Set([Lp, Lg]);
function j5(r, e = []) {
  if (r && !it(r) && r.type === 14) {
    const t = r.callee;
    if (!it(t) && fJ.has(t))
      return j5(
        r.arguments[0],
        e.concat(r)
      );
  }
  return [r, e];
}
function aE(r, e, t) {
  let i, n = r.type === 13 ? r.props : r.arguments[2], a = [], o;
  if (n && !it(n) && n.type === 14) {
    const s = j5(n);
    n = s[0], a = s[1], o = a[a.length - 1];
  }
  if (n == null || it(n))
    i = Qn([e]);
  else if (n.type === 14) {
    const s = n.arguments[0];
    !it(s) && s.type === 15 ? LN(e, s) || s.properties.unshift(e) : n.callee === uI ? i = dr(t.helper(Jm), [
      Qn([e]),
      n
    ]) : n.arguments.unshift(Qn([e])), !i && (i = n);
  } else
    n.type === 15 ? (LN(e, n) || n.properties.unshift(e), i = n) : (i = dr(t.helper(Jm), [
      Qn([e]),
      n
    ]), o && o.callee === Lg && (o = a[a.length - 2]));
  r.type === 13 ? o ? o.arguments[0] = i : r.props = i : o ? o.arguments[0] = i : r.arguments[2] = i;
}
function LN(r, e) {
  let t = !1;
  if (r.key.type === 4) {
    const i = r.key.content;
    t = e.properties.some(
      (n) => n.key.type === 4 && n.key.content === i
    );
  }
  return t;
}
function Mp(r, e) {
  return `_${e}_${r.replace(/[^\w]/g, (t, i) => t === "-" ? "_" : r.charCodeAt(i).toString())}`;
}
function dJ(r) {
  return r.type === 14 && r.callee === cI ? r.arguments[1].returns : r;
}
function DN(r, e) {
  const t = e.options ? e.options.compatConfig : e.compatConfig, i = t && t[r];
  return r === "MODE" ? i || 3 : i;
}
function ku(r, e) {
  const t = DN("MODE", e), i = DN(r, e);
  return t === 3 ? i === !0 : i !== !1;
}
function kp(r, e, t, ...i) {
  return ku(r, e);
}
const pJ = /&(gt|lt|amp|apos|quot);/g, gJ = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
}, MN = {
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: im,
  isPreTag: im,
  isCustomElement: im,
  decodeEntities: (r) => r.replace(pJ, (e, t) => gJ[t]),
  onError: j1,
  onWarn: G5,
  comments: !1
};
function vJ(r, e = {}) {
  const t = OJ(r, e), i = dn(t);
  return rJ(
    pI(t, 0, []),
    zn(t, i)
  );
}
function OJ(r, e) {
  const t = Ot({}, MN);
  let i;
  for (i in e)
    t[i] = e[i] === void 0 ? MN[i] : e[i];
  return {
    options: t,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: r,
    source: r,
    inPre: !1,
    inVPre: !1,
    onWarn: t.onWarn
  };
}
function pI(r, e, t) {
  const i = lS(t), n = i ? i.ns : 0, a = [];
  for (; !CJ(r, e, t); ) {
    const s = r.source;
    let l;
    if (e === 0 || e === 1) {
      if (!r.inVPre && si(s, r.options.delimiters[0]))
        l = RJ(r, e);
      else if (e === 0 && s[0] === "<")
        if (s.length === 1)
          xt(r, 5, 1);
        else if (s[1] === "!")
          si(s, "<!--") ? l = EJ(r) : si(s, "<!DOCTYPE") ? l = Xf(r) : si(s, "<![CDATA[") ? n !== 0 ? l = mJ(r, t) : (xt(r, 1), l = Xf(r)) : (xt(r, 11), l = Xf(r));
        else if (s[1] === "/")
          if (s.length === 2)
            xt(r, 5, 2);
          else if (s[2] === ">") {
            xt(r, 14, 2), Ar(r, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            xt(r, 23), mA(r, oE.End, i);
            continue;
          } else
            xt(
              r,
              12,
              2
            ), l = Xf(r);
        else
          /[a-z]/i.test(s[1]) ? (l = bJ(r, t), ku(
            "COMPILER_NATIVE_TEMPLATE",
            r
          ) && l && l.tag === "template" && !l.props.some(
            (u) => u.type === 7 && K5(u.name)
          ) && (l = l.children)) : s[1] === "?" ? (xt(
            r,
            21,
            1
          ), l = Xf(r)) : xt(r, 12, 1);
    }
    if (l || (l = AJ(r, e)), Oe(l))
      for (let u = 0; u < l.length; u++)
        kN(a, l[u]);
    else
      kN(a, l);
  }
  let o = !1;
  if (e !== 2 && e !== 1) {
    const s = r.options.whitespace !== "preserve";
    for (let l = 0; l < a.length; l++) {
      const u = a[l];
      if (u.type === 2)
        if (r.inPre)
          u.content = u.content.replace(/\r\n/g, `
`);
        else if (/[^\t\r\n\f ]/.test(u.content))
          s && (u.content = u.content.replace(/[\t\r\n\f ]+/g, " "));
        else {
          const h = a[l - 1], c = a[l + 1];
          !h || !c || s && (h.type === 3 && c.type === 3 || h.type === 3 && c.type === 1 || h.type === 1 && c.type === 3 || h.type === 1 && c.type === 1 && /[\r\n]/.test(u.content)) ? (o = !0, a[l] = null) : u.content = " ";
        }
      else
        u.type === 3 && !r.options.comments && (o = !0, a[l] = null);
    }
    if (r.inPre && i && r.options.isPreTag(i.tag)) {
      const l = a[0];
      l && l.type === 2 && (l.content = l.content.replace(/^\r?\n/, ""));
    }
  }
  return o ? a.filter(Boolean) : a;
}
function kN(r, e) {
  if (e.type === 2) {
    const t = lS(r);
    if (t && t.type === 2 && t.loc.end.offset === e.loc.start.offset) {
      t.content += e.content, t.loc.end = e.loc.end, t.loc.source += e.loc.source;
      return;
    }
  }
  r.push(e);
}
function mJ(r, e) {
  Ar(r, 9);
  const t = pI(r, 3, e);
  return r.source.length === 0 ? xt(r, 6) : Ar(r, 3), t;
}
function EJ(r) {
  const e = dn(r);
  let t;
  const i = /--(\!)?>/.exec(r.source);
  if (!i)
    t = r.source.slice(4), Ar(r, r.source.length), xt(r, 7);
  else {
    i.index <= 3 && xt(r, 0), i[1] && xt(r, 10), t = r.source.slice(4, i.index);
    const n = r.source.slice(0, i.index);
    let a = 1, o = 0;
    for (; (o = n.indexOf("<!--", a)) !== -1; )
      Ar(r, o - a + 1), o + 4 < n.length && xt(r, 16), a = o + 1;
    Ar(r, i.index + i[0].length - a + 1);
  }
  return {
    type: 3,
    content: t,
    loc: zn(r, e)
  };
}
function Xf(r) {
  const e = dn(r), t = r.source[1] === "?" ? 1 : 2;
  let i;
  const n = r.source.indexOf(">");
  return n === -1 ? (i = r.source.slice(t), Ar(r, r.source.length)) : (i = r.source.slice(t, n), Ar(r, n + 1)), {
    type: 3,
    content: i,
    loc: zn(r, e)
  };
}
function bJ(r, e) {
  const t = r.inPre, i = r.inVPre, n = lS(e), a = mA(r, oE.Start, n), o = r.inPre && !t, s = r.inVPre && !i;
  if (a.isSelfClosing || r.options.isVoidTag(a.tag))
    return o && (r.inPre = !1), s && (r.inVPre = !1), a;
  e.push(a);
  const l = r.options.getTextMode(a, n), u = pI(r, l, e);
  e.pop();
  {
    const h = a.props.find(
      (c) => c.type === 6 && c.name === "inline-template"
    );
    if (h && kp(
      "COMPILER_INLINE_TEMPLATE",
      r,
      h.loc
    )) {
      const c = zn(r, a.loc.end);
      h.value = {
        type: 2,
        content: c.source,
        loc: c
      };
    }
  }
  if (a.children = u, EA(r.source, a.tag))
    mA(r, oE.End, n);
  else if (xt(r, 24, 0, a.loc.start), r.source.length === 0 && a.tag.toLowerCase() === "script") {
    const h = u[0];
    h && si(h.loc.source, "<!--") && xt(r, 8);
  }
  return a.loc = zn(r, a.loc.start), o && (r.inPre = !1), s && (r.inVPre = !1), a;
}
var oE = /* @__PURE__ */ ((r) => (r[r.Start = 0] = "Start", r[r.End = 1] = "End", r))(oE || {});
const K5 = /* @__PURE__ */ Hi(
  "if,else,else-if,for,slot"
);
function mA(r, e, t) {
  const i = dn(r), n = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(r.source), a = n[1], o = r.options.getNamespace(a, t);
  Ar(r, n[0].length), Qp(r);
  const s = dn(r), l = r.source;
  r.options.isPreTag(a) && (r.inPre = !0);
  let u = QN(r, e);
  e === 0 && !r.inVPre && u.some((f) => f.type === 7 && f.name === "pre") && (r.inVPre = !0, Ot(r, s), r.source = l, u = QN(r, e).filter((f) => f.name !== "v-pre"));
  let h = !1;
  if (r.source.length === 0 ? xt(r, 9) : (h = si(r.source, "/>"), e === 1 && h && xt(r, 4), Ar(r, h ? 2 : 1)), e === 1)
    return;
  let c = 0;
  return r.inVPre || (a === "slot" ? c = 2 : a === "template" ? u.some(
    (f) => f.type === 7 && K5(f.name)
  ) && (c = 3) : SJ(a, u, r) && (c = 1)), {
    type: 1,
    ns: o,
    tag: a,
    tagType: c,
    props: u,
    isSelfClosing: h,
    children: [],
    loc: zn(r, i),
    codegenNode: void 0
    // to be created during transform phase
  };
}
function SJ(r, e, t) {
  const i = t.options;
  if (i.isCustomElement(r))
    return !1;
  if (r === "component" || /^[A-Z]/.test(r) || z5(r) || i.isBuiltInComponent && i.isBuiltInComponent(r) || i.isNativeTag && !i.isNativeTag(r))
    return !0;
  for (let n = 0; n < e.length; n++) {
    const a = e[n];
    if (a.type === 6) {
      if (a.name === "is" && a.value) {
        if (a.value.content.startsWith("vue:"))
          return !0;
        if (kp(
          "COMPILER_IS_ON_ELEMENT",
          t,
          a.loc
        ))
          return !0;
      }
    } else {
      if (a.name === "is")
        return !0;
      if (
        // :is on plain element - only treat as component in compat mode
        a.name === "bind" && Eu(a.arg, "is") && kp(
          "COMPILER_IS_ON_ELEMENT",
          t,
          a.loc
        )
      )
        return !0;
    }
  }
}
function QN(r, e) {
  const t = [], i = /* @__PURE__ */ new Set();
  for (; r.source.length > 0 && !si(r.source, ">") && !si(r.source, "/>"); ) {
    if (si(r.source, "/")) {
      xt(r, 22), Ar(r, 1), Qp(r);
      continue;
    }
    e === 1 && xt(r, 3);
    const n = TJ(r, i);
    n.type === 6 && n.value && n.name === "class" && (n.value.content = n.value.content.replace(/\s+/g, " ").trim()), e === 0 && t.push(n), /^[^\t\r\n\f />]/.test(r.source) && xt(r, 15), Qp(r);
  }
  return t;
}
function TJ(r, e) {
  var t;
  const i = dn(r), a = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(r.source)[0];
  e.has(a) && xt(r, 2), e.add(a), a[0] === "=" && xt(r, 19);
  {
    const l = /["'<]/g;
    let u;
    for (; u = l.exec(a); )
      xt(
        r,
        17,
        u.index
      );
  }
  Ar(r, a.length);
  let o;
  /^[\t\r\n\f ]*=/.test(r.source) && (Qp(r), Ar(r, 1), Qp(r), o = yJ(r), o || xt(r, 13));
  const s = zn(r, i);
  if (!r.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(a)) {
    const l = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
      a
    );
    let u = si(a, "."), h = l[1] || (u || si(a, ":") ? "bind" : si(a, "@") ? "on" : "slot"), c;
    if (l[2]) {
      const d = h === "slot", p = a.lastIndexOf(
        l[2],
        a.length - (((t = l[3]) == null ? void 0 : t.length) || 0)
      ), g = zn(
        r,
        UN(r, i, p),
        UN(
          r,
          i,
          p + l[2].length + (d && l[3] || "").length
        )
      );
      let v = l[2], O = !0;
      v.startsWith("[") ? (O = !1, v.endsWith("]") ? v = v.slice(1, v.length - 1) : (xt(
        r,
        27
      ), v = v.slice(1))) : d && (v += l[3] || ""), c = {
        type: 4,
        content: v,
        isStatic: O,
        constType: O ? 3 : 0,
        loc: g
      };
    }
    if (o && o.isQuoted) {
      const d = o.loc;
      d.start.offset++, d.start.column++, d.end = tE(d.start, o.content), d.source = d.source.slice(1, -1);
    }
    const f = l[3] ? l[3].slice(1).split(".") : [];
    return u && f.push("prop"), h === "bind" && c && f.includes("sync") && kp(
      "COMPILER_V_BIND_SYNC",
      r,
      s,
      c.loc.source
    ) && (h = "model", f.splice(f.indexOf("sync"), 1)), {
      type: 7,
      name: h,
      exp: o && {
        type: 4,
        content: o.content,
        isStatic: !1,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: o.loc
      },
      arg: c,
      modifiers: f,
      loc: s
    };
  }
  return !r.inVPre && si(a, "v-") && xt(r, 26), {
    type: 6,
    name: a,
    value: o && {
      type: 2,
      content: o.content,
      loc: o.loc
    },
    loc: s
  };
}
function yJ(r) {
  const e = dn(r);
  let t;
  const i = r.source[0], n = i === '"' || i === "'";
  if (n) {
    Ar(r, 1);
    const a = r.source.indexOf(i);
    a === -1 ? t = tp(
      r,
      r.source.length,
      4
    ) : (t = tp(r, a, 4), Ar(r, 1));
  } else {
    const a = /^[^\t\r\n\f >]+/.exec(r.source);
    if (!a)
      return;
    const o = /["'<=`]/g;
    let s;
    for (; s = o.exec(a[0]); )
      xt(
        r,
        18,
        s.index
      );
    t = tp(r, a[0].length, 4);
  }
  return { content: t, isQuoted: n, loc: zn(r, e) };
}
function RJ(r, e) {
  const [t, i] = r.options.delimiters, n = r.source.indexOf(i, t.length);
  if (n === -1) {
    xt(r, 25);
    return;
  }
  const a = dn(r);
  Ar(r, t.length);
  const o = dn(r), s = dn(r), l = n - t.length, u = r.source.slice(0, l), h = tp(r, l, e), c = h.trim(), f = h.indexOf(c);
  f > 0 && rE(o, u, f);
  const d = l - (h.length - c.length - f);
  return rE(s, u, d), Ar(r, i.length), {
    type: 5,
    content: {
      type: 4,
      isStatic: !1,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content: c,
      loc: zn(r, o, s)
    },
    loc: zn(r, a)
  };
}
function AJ(r, e) {
  const t = e === 3 ? ["]]>"] : ["<", r.options.delimiters[0]];
  let i = r.source.length;
  for (let o = 0; o < t.length; o++) {
    const s = r.source.indexOf(t[o], 1);
    s !== -1 && i > s && (i = s);
  }
  const n = dn(r);
  return {
    type: 2,
    content: tp(r, i, e),
    loc: zn(r, n)
  };
}
function tp(r, e, t) {
  const i = r.source.slice(0, e);
  return Ar(r, e), t === 2 || t === 3 || !i.includes("&") ? i : r.options.decodeEntities(
    i,
    t === 4
  );
}
function dn(r) {
  const { column: e, line: t, offset: i } = r;
  return { column: e, line: t, offset: i };
}
function zn(r, e, t) {
  return t = t || dn(r), {
    start: e,
    end: t,
    source: r.originalSource.slice(e.offset, t.offset)
  };
}
function lS(r) {
  return r[r.length - 1];
}
function si(r, e) {
  return r.startsWith(e);
}
function Ar(r, e) {
  const { source: t } = r;
  rE(r, t, e), r.source = t.slice(e);
}
function Qp(r) {
  const e = /^[\t\r\n\f ]+/.exec(r.source);
  e && Ar(r, e[0].length);
}
function UN(r, e, t) {
  return tE(
    e,
    r.originalSource.slice(e.offset, t),
    t
  );
}
function xt(r, e, t, i = dn(r)) {
  t && (i.offset += t, i.column += t), r.options.onError(
    Ht(e, {
      start: i,
      end: i,
      source: ""
    })
  );
}
function CJ(r, e, t) {
  const i = r.source;
  switch (e) {
    case 0:
      if (si(i, "</")) {
        for (let n = t.length - 1; n >= 0; --n)
          if (EA(i, t[n].tag))
            return !0;
      }
      break;
    case 1:
    case 2: {
      const n = lS(t);
      if (n && EA(i, n.tag))
        return !0;
      break;
    }
    case 3:
      if (si(i, "]]>"))
        return !0;
      break;
  }
  return !i;
}
function EA(r, e) {
  return si(r, "</") && r.slice(2, 2 + e.length).toLowerCase() === e.toLowerCase() && /[\t\r\n\f />]/.test(r[2 + e.length] || ">");
}
function _J(r, e) {
  om(
    r,
    e,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    J5(r, r.children[0])
  );
}
function J5(r, e) {
  const { children: t } = r;
  return t.length === 1 && e.type === 1 && !nE(e);
}
function om(r, e, t = !1) {
  const { children: i } = r, n = i.length;
  let a = 0;
  for (let o = 0; o < i.length; o++) {
    const s = i[o];
    if (s.type === 1 && s.tagType === 0) {
      const l = t ? 0 : Un(s, e);
      if (l > 0) {
        if (l >= 2) {
          s.codegenNode.patchFlag = "-1", s.codegenNode = e.hoist(s.codegenNode), a++;
          continue;
        }
      } else {
        const u = s.codegenNode;
        if (u.type === 13) {
          const h = iF(u);
          if ((!h || h === 512 || h === 1) && tF(s, e) >= 2) {
            const c = rF(s);
            c && (u.props = e.hoist(c));
          }
          u.dynamicProps && (u.dynamicProps = e.hoist(u.dynamicProps));
        }
      }
    }
    if (s.type === 1) {
      const l = s.tagType === 1;
      l && e.scopes.vSlot++, om(s, e), l && e.scopes.vSlot--;
    } else if (s.type === 11)
      om(s, e, s.children.length === 1);
    else if (s.type === 9)
      for (let l = 0; l < s.branches.length; l++)
        om(
          s.branches[l],
          e,
          s.branches[l].children.length === 1
        );
  }
  a && e.transformHoist && e.transformHoist(i, e, r), a && a === n && r.type === 1 && r.tagType === 0 && r.codegenNode && r.codegenNode.type === 13 && Oe(r.codegenNode.children) && (r.codegenNode.children = e.hoist(
    Dg(r.codegenNode.children)
  ));
}
function Un(r, e) {
  const { constantCache: t } = e;
  switch (r.type) {
    case 1:
      if (r.tagType !== 0)
        return 0;
      const i = t.get(r);
      if (i !== void 0)
        return i;
      const n = r.codegenNode;
      if (n.type !== 13 || n.isBlock && r.tag !== "svg" && r.tag !== "foreignObject")
        return 0;
      if (iF(n))
        return t.set(r, 0), 0;
      {
        let s = 3;
        const l = tF(r, e);
        if (l === 0)
          return t.set(r, 0), 0;
        l < s && (s = l);
        for (let u = 0; u < r.children.length; u++) {
          const h = Un(r.children[u], e);
          if (h === 0)
            return t.set(r, 0), 0;
          h < s && (s = h);
        }
        if (s > 1)
          for (let u = 0; u < r.props.length; u++) {
            const h = r.props[u];
            if (h.type === 7 && h.name === "bind" && h.exp) {
              const c = Un(h.exp, e);
              if (c === 0)
                return t.set(r, 0), 0;
              c < s && (s = c);
            }
          }
        if (n.isBlock) {
          for (let u = 0; u < r.props.length; u++)
            if (r.props[u].type === 7)
              return t.set(r, 0), 0;
          e.removeHelper(Ju), e.removeHelper(
            qc(e.inSSR, n.isComponent)
          ), n.isBlock = !1, e.helper(Zc(e.inSSR, n.isComponent));
        }
        return t.set(r, s), s;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return Un(r.content, e);
    case 4:
      return r.constType;
    case 8:
      let o = 3;
      for (let s = 0; s < r.children.length; s++) {
        const l = r.children[s];
        if (it(l) || qs(l))
          continue;
        const u = Un(l, e);
        if (u === 0)
          return 0;
        u < o && (o = u);
      }
      return o;
    default:
      return 0;
  }
}
const IJ = /* @__PURE__ */ new Set([
  sI,
  lI,
  Lp,
  Lg
]);
function eF(r, e) {
  if (r.type === 14 && !it(r.callee) && IJ.has(r.callee)) {
    const t = r.arguments[0];
    if (t.type === 4)
      return Un(t, e);
    if (t.type === 14)
      return eF(t, e);
  }
  return 0;
}
function tF(r, e) {
  let t = 3;
  const i = rF(r);
  if (i && i.type === 15) {
    const { properties: n } = i;
    for (let a = 0; a < n.length; a++) {
      const { key: o, value: s } = n[a], l = Un(o, e);
      if (l === 0)
        return l;
      l < t && (t = l);
      let u;
      if (s.type === 4 ? u = Un(s, e) : s.type === 14 ? u = eF(s, e) : u = 0, u === 0)
        return u;
      u < t && (t = u);
    }
  }
  return t;
}
function rF(r) {
  const e = r.codegenNode;
  if (e.type === 13)
    return e.props;
}
function iF(r) {
  const e = r.patchFlag;
  return e ? parseInt(e, 10) : void 0;
}
function xJ(r, {
  filename: e = "",
  prefixIdentifiers: t = !1,
  hoistStatic: i = !1,
  cacheHandlers: n = !1,
  nodeTransforms: a = [],
  directiveTransforms: o = {},
  transformHoist: s = null,
  isBuiltInComponent: l = Ri,
  isCustomElement: u = Ri,
  expressionPlugins: h = [],
  scopeId: c = null,
  slotted: f = !0,
  ssr: d = !1,
  inSSR: p = !1,
  ssrCssVars: g = "",
  bindingMetadata: v = wt,
  inline: O = !1,
  isTS: m = !1,
  onError: E = j1,
  onWarn: b = G5,
  compatConfig: T
}) {
  const S = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), y = {
    // options
    selfName: S && vh(Or(S[1])),
    prefixIdentifiers: t,
    hoistStatic: i,
    cacheHandlers: n,
    nodeTransforms: a,
    directiveTransforms: o,
    transformHoist: s,
    isBuiltInComponent: l,
    isCustomElement: u,
    expressionPlugins: h,
    scopeId: c,
    slotted: f,
    ssr: d,
    inSSR: p,
    ssrCssVars: g,
    bindingMetadata: v,
    inline: O,
    isTS: m,
    onError: E,
    onWarn: b,
    compatConfig: T,
    // state
    root: r,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: r,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(A) {
      const C = y.helpers.get(A) || 0;
      return y.helpers.set(A, C + 1), A;
    },
    removeHelper(A) {
      const C = y.helpers.get(A);
      if (C) {
        const _ = C - 1;
        _ ? y.helpers.set(A, _) : y.helpers.delete(A);
      }
    },
    helperString(A) {
      return `_${Wc[y.helper(A)]}`;
    },
    replaceNode(A) {
      y.parent.children[y.childIndex] = y.currentNode = A;
    },
    removeNode(A) {
      const C = y.parent.children, _ = A ? C.indexOf(A) : y.currentNode ? y.childIndex : -1;
      !A || A === y.currentNode ? (y.currentNode = null, y.onNodeRemoved()) : y.childIndex > _ && (y.childIndex--, y.onNodeRemoved()), y.parent.children.splice(_, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(A) {
    },
    removeIdentifiers(A) {
    },
    hoist(A) {
      it(A) && (A = ct(A)), y.hoists.push(A);
      const C = ct(
        `_hoisted_${y.hoists.length}`,
        !1,
        A.loc,
        2
      );
      return C.hoisted = A, C;
    },
    cache(A, C = !1) {
      return iJ(y.cached++, A, C);
    }
  };
  return y.filters = /* @__PURE__ */ new Set(), y;
}
function wJ(r, e) {
  const t = xJ(r, e);
  uS(r, t), e.hoistStatic && _J(r, t), e.ssr || PJ(r, t), r.helpers = /* @__PURE__ */ new Set([...t.helpers.keys()]), r.components = [...t.components], r.directives = [...t.directives], r.imports = t.imports, r.hoists = t.hoists, r.temps = t.temps, r.cached = t.cached, r.filters = [...t.filters];
}
function PJ(r, e) {
  const { helper: t } = e, { children: i } = r;
  if (i.length === 1) {
    const n = i[0];
    if (J5(r, n) && n.codegenNode) {
      const a = n.codegenNode;
      a.type === 13 && fI(a, e), r.codegenNode = a;
    } else
      r.codegenNode = n;
  } else if (i.length > 1) {
    let n = 64;
    r.codegenNode = Dp(
      e,
      t(Np),
      void 0,
      r.children,
      n + "",
      void 0,
      void 0,
      !0,
      void 0,
      !1
      /* isComponent */
    );
  }
}
function NJ(r, e) {
  let t = 0;
  const i = () => {
    t--;
  };
  for (; t < r.children.length; t++) {
    const n = r.children[t];
    it(n) || (e.parent = r, e.childIndex = t, e.onNodeRemoved = i, uS(n, e));
  }
}
function uS(r, e) {
  e.currentNode = r;
  const { nodeTransforms: t } = e, i = [];
  for (let a = 0; a < t.length; a++) {
    const o = t[a](r, e);
    if (o && (Oe(o) ? i.push(...o) : i.push(o)), e.currentNode)
      r = e.currentNode;
    else
      return;
  }
  switch (r.type) {
    case 3:
      e.ssr || e.helper(Ng);
      break;
    case 5:
      e.ssr || e.helper(oS);
      break;
    case 9:
      for (let a = 0; a < r.branches.length; a++)
        uS(r.branches[a], e);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      NJ(r, e);
      break;
  }
  e.currentNode = r;
  let n = i.length;
  for (; n--; )
    i[n]();
}
function nF(r, e) {
  const t = it(r) ? (i) => i === r : (i) => r.test(i);
  return (i, n) => {
    if (i.type === 1) {
      const { props: a } = i;
      if (i.tagType === 3 && a.some(cJ))
        return;
      const o = [];
      for (let s = 0; s < a.length; s++) {
        const l = a[s];
        if (l.type === 7 && t(l.name)) {
          a.splice(s, 1), s--;
          const u = e(i, l, n);
          u && o.push(u);
        }
      }
      return o;
    }
  };
}
const hS = "/*#__PURE__*/", aF = (r) => `${Wc[r]}: _${Wc[r]}`;
function $N(r, {
  mode: e = "function",
  prefixIdentifiers: t = e === "module",
  sourceMap: i = !1,
  filename: n = "template.vue.html",
  scopeId: a = null,
  optimizeImports: o = !1,
  runtimeGlobalName: s = "Vue",
  runtimeModuleName: l = "vue",
  ssrRuntimeModuleName: u = "vue/server-renderer",
  ssr: h = !1,
  isTS: c = !1,
  inSSR: f = !1
}) {
  const d = {
    mode: e,
    prefixIdentifiers: t,
    sourceMap: i,
    filename: n,
    scopeId: a,
    optimizeImports: o,
    runtimeGlobalName: s,
    runtimeModuleName: l,
    ssrRuntimeModuleName: u,
    ssr: h,
    isTS: c,
    inSSR: f,
    source: r.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(g) {
      return `_${Wc[g]}`;
    },
    push(g, v) {
      d.code += g;
    },
    indent() {
      p(++d.indentLevel);
    },
    deindent(g = !1) {
      g ? --d.indentLevel : p(--d.indentLevel);
    },
    newline() {
      p(d.indentLevel);
    }
  };
  function p(g) {
    d.push(`
` + "  ".repeat(g));
  }
  return d;
}
function LJ(r, e = {}) {
  const t = $N(r, e);
  e.onContextCreated && e.onContextCreated(t);
  const {
    mode: i,
    push: n,
    prefixIdentifiers: a,
    indent: o,
    deindent: s,
    newline: l,
    scopeId: u,
    ssr: h
  } = t, c = Array.from(r.helpers), f = c.length > 0, d = !a && i !== "module", p = !1, g = p ? $N(r, e) : t;
  DJ(r, g);
  const v = h ? "ssrRender" : "render", m = (h ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ");
  if (n(`function ${v}(${m}) {`), o(), d && (n("with (_ctx) {"), o(), f && (n(`const { ${c.map(aF).join(", ")} } = _Vue`), n(`
`), l())), r.components.length && (MT(r.components, "component", t), (r.directives.length || r.temps > 0) && l()), r.directives.length && (MT(r.directives, "directive", t), r.temps > 0 && l()), r.filters && r.filters.length && (l(), MT(r.filters, "filter", t), l()), r.temps > 0) {
    n("let ");
    for (let E = 0; E < r.temps; E++)
      n(`${E > 0 ? ", " : ""}_temp${E}`);
  }
  return (r.components.length || r.directives.length || r.temps) && (n(`
`), l()), h || n("return "), r.codegenNode ? hi(r.codegenNode, t) : n("null"), d && (s(), n("}")), s(), n("}"), {
    ast: r,
    code: t.code,
    preamble: p ? g.code : "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: t.map ? t.map.toJSON() : void 0
  };
}
function DJ(r, e) {
  const {
    ssr: t,
    prefixIdentifiers: i,
    push: n,
    newline: a,
    runtimeModuleName: o,
    runtimeGlobalName: s,
    ssrRuntimeModuleName: l
  } = e, u = s, h = Array.from(r.helpers);
  if (h.length > 0 && (n(`const _Vue = ${u}
`), r.hoists.length)) {
    const c = [
      J1,
      eI,
      Ng,
      tI,
      X5
    ].filter((f) => h.includes(f)).map(aF).join(", ");
    n(`const { ${c} } = _Vue
`);
  }
  MJ(r.hoists, e), a(), n("return ");
}
function MT(r, e, { helper: t, push: i, newline: n, isTS: a }) {
  const o = t(
    e === "filter" ? nI : e === "component" ? rI : iI
  );
  for (let s = 0; s < r.length; s++) {
    let l = r[s];
    const u = l.endsWith("__self");
    u && (l = l.slice(0, -6)), i(
      `const ${Mp(l, e)} = ${o}(${JSON.stringify(l)}${u ? ", true" : ""})${a ? "!" : ""}`
    ), s < r.length - 1 && n();
  }
}
function MJ(r, e) {
  if (!r.length)
    return;
  e.pure = !0;
  const { push: t, newline: i, helper: n, scopeId: a, mode: o } = e;
  i();
  for (let s = 0; s < r.length; s++) {
    const l = r[s];
    l && (t(
      `const _hoisted_${s + 1} = `
    ), hi(l, e), i());
  }
  e.pure = !1;
}
function gI(r, e) {
  const t = r.length > 3 || !1;
  e.push("["), t && e.indent(), Mg(r, e, t), t && e.deindent(), e.push("]");
}
function Mg(r, e, t = !1, i = !0) {
  const { push: n, newline: a } = e;
  for (let o = 0; o < r.length; o++) {
    const s = r[o];
    it(s) ? n(s) : Oe(s) ? gI(s, e) : hi(s, e), o < r.length - 1 && (t ? (i && n(","), a()) : i && n(", "));
  }
}
function hi(r, e) {
  if (it(r)) {
    e.push(r);
    return;
  }
  if (qs(r)) {
    e.push(e.helper(r));
    return;
  }
  switch (r.type) {
    case 1:
    case 9:
    case 11:
      hi(r.codegenNode, e);
      break;
    case 2:
      kJ(r, e);
      break;
    case 4:
      oF(r, e);
      break;
    case 5:
      QJ(r, e);
      break;
    case 12:
      hi(r.codegenNode, e);
      break;
    case 8:
      sF(r, e);
      break;
    case 3:
      $J(r, e);
      break;
    case 13:
      GJ(r, e);
      break;
    case 14:
      VJ(r, e);
      break;
    case 15:
      FJ(r, e);
      break;
    case 17:
      XJ(r, e);
      break;
    case 18:
      YJ(r, e);
      break;
    case 19:
      HJ(r, e);
      break;
    case 20:
      WJ(r, e);
      break;
    case 21:
      Mg(r.body, e, !0, !1);
      break;
  }
}
function kJ(r, e) {
  e.push(JSON.stringify(r.content), r);
}
function oF(r, e) {
  const { content: t, isStatic: i } = r;
  e.push(i ? JSON.stringify(t) : t, r);
}
function QJ(r, e) {
  const { push: t, helper: i, pure: n } = e;
  n && t(hS), t(`${i(oS)}(`), hi(r.content, e), t(")");
}
function sF(r, e) {
  for (let t = 0; t < r.children.length; t++) {
    const i = r.children[t];
    it(i) ? e.push(i) : hi(i, e);
  }
}
function UJ(r, e) {
  const { push: t } = e;
  if (r.type === 8)
    t("["), sF(r, e), t("]");
  else if (r.isStatic) {
    const i = dI(r.content) ? r.content : JSON.stringify(r.content);
    t(i, r);
  } else
    t(`[${r.content}]`, r);
}
function $J(r, e) {
  const { push: t, helper: i, pure: n } = e;
  n && t(hS), t(`${i(Ng)}(${JSON.stringify(r.content)})`, r);
}
function GJ(r, e) {
  const { push: t, helper: i, pure: n } = e, {
    tag: a,
    props: o,
    children: s,
    patchFlag: l,
    dynamicProps: u,
    directives: h,
    isBlock: c,
    disableTracking: f,
    isComponent: d
  } = r;
  h && t(i(aI) + "("), c && t(`(${i(Ju)}(${f ? "true" : ""}), `), n && t(hS);
  const p = c ? qc(e.inSSR, d) : Zc(e.inSSR, d);
  t(i(p) + "(", r), Mg(
    BJ([a, o, s, l, u]),
    e
  ), t(")"), c && t(")"), h && (t(", "), hi(h, e), t(")"));
}
function BJ(r) {
  let e = r.length;
  for (; e-- && r[e] == null; )
    ;
  return r.slice(0, e + 1).map((t) => t || "null");
}
function VJ(r, e) {
  const { push: t, helper: i, pure: n } = e, a = it(r.callee) ? r.callee : i(r.callee);
  n && t(hS), t(a + "(", r), Mg(r.arguments, e), t(")");
}
function FJ(r, e) {
  const { push: t, indent: i, deindent: n, newline: a } = e, { properties: o } = r;
  if (!o.length) {
    t("{}", r);
    return;
  }
  const s = o.length > 1 || !1;
  t(s ? "{" : "{ "), s && i();
  for (let l = 0; l < o.length; l++) {
    const { key: u, value: h } = o[l];
    UJ(u, e), t(": "), hi(h, e), l < o.length - 1 && (t(","), a());
  }
  s && n(), t(s ? "}" : " }");
}
function XJ(r, e) {
  gI(r.elements, e);
}
function YJ(r, e) {
  const { push: t, indent: i, deindent: n } = e, { params: a, returns: o, body: s, newline: l, isSlot: u } = r;
  u && t(`_${Wc[hI]}(`), t("(", r), Oe(a) ? Mg(a, e) : a && hi(a, e), t(") => "), (l || s) && (t("{"), i()), o ? (l && t("return "), Oe(o) ? gI(o, e) : hi(o, e)) : s && hi(s, e), (l || s) && (n(), t("}")), u && (r.isNonScopedSlot && t(", undefined, true"), t(")"));
}
function HJ(r, e) {
  const { test: t, consequent: i, alternate: n, newline: a } = r, { push: o, indent: s, deindent: l, newline: u } = e;
  if (t.type === 4) {
    const c = !dI(t.content);
    c && o("("), oF(t, e), c && o(")");
  } else
    o("("), hi(t, e), o(")");
  a && s(), e.indentLevel++, a || o(" "), o("? "), hi(i, e), e.indentLevel--, a && u(), a || o(" "), o(": ");
  const h = n.type === 19;
  h || e.indentLevel++, hi(n, e), h || e.indentLevel--, a && l(
    !0
    /* without newline */
  );
}
function WJ(r, e) {
  const { push: t, helper: i, indent: n, deindent: a, newline: o } = e;
  t(`_cache[${r.index}] || (`), r.isVNode && (n(), t(`${i(eE)}(-1),`), o()), t(`_cache[${r.index}] = `), hi(r.value, e), r.isVNode && (t(","), o(), t(`${i(eE)}(1),`), o(), t(`_cache[${r.index}]`), a()), t(")");
}
new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
);
const zJ = nF(
  /^(if|else|else-if)$/,
  (r, e, t) => ZJ(r, e, t, (i, n, a) => {
    const o = t.parent.children;
    let s = o.indexOf(i), l = 0;
    for (; s-- >= 0; ) {
      const u = o[s];
      u && u.type === 9 && (l += u.branches.length);
    }
    return () => {
      if (a)
        i.codegenNode = BN(
          n,
          l,
          t
        );
      else {
        const u = qJ(i.codegenNode);
        u.alternate = BN(
          n,
          l + i.branches.length - 1,
          t
        );
      }
    };
  })
);
function ZJ(r, e, t, i) {
  if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
    const n = e.exp ? e.exp.loc : r.loc;
    t.onError(
      Ht(28, e.loc)
    ), e.exp = ct("true", !1, n);
  }
  if (e.name === "if") {
    const n = GN(r, e), a = {
      type: 9,
      loc: r.loc,
      branches: [n]
    };
    if (t.replaceNode(a), i)
      return i(a, n, !0);
  } else {
    const n = t.parent.children;
    let a = n.indexOf(r);
    for (; a-- >= -1; ) {
      const o = n[a];
      if (o && o.type === 3) {
        t.removeNode(o);
        continue;
      }
      if (o && o.type === 2 && !o.content.trim().length) {
        t.removeNode(o);
        continue;
      }
      if (o && o.type === 9) {
        e.name === "else-if" && o.branches[o.branches.length - 1].condition === void 0 && t.onError(
          Ht(30, r.loc)
        ), t.removeNode();
        const s = GN(r, e);
        o.branches.push(s);
        const l = i && i(o, s, !1);
        uS(s, t), l && l(), t.currentNode = null;
      } else
        t.onError(
          Ht(30, r.loc)
        );
      break;
    }
  }
}
function GN(r, e) {
  const t = r.tagType === 3;
  return {
    type: 10,
    loc: r.loc,
    condition: e.name === "else" ? void 0 : e.exp,
    children: t && !Pn(r, "for") ? r.children : [r],
    userKey: sS(r, "key"),
    isTemplateIf: t
  };
}
function BN(r, e, t) {
  return r.condition ? OA(
    r.condition,
    VN(r, e, t),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    dr(t.helper(Ng), [
      '""',
      "true"
    ])
  ) : VN(r, e, t);
}
function VN(r, e, t) {
  const { helper: i } = t, n = nr(
    "key",
    ct(
      `${e}`,
      !1,
      mn,
      2
    )
  ), { children: a } = r, o = a[0];
  if (a.length !== 1 || o.type !== 1)
    if (a.length === 1 && o.type === 11) {
      const l = o.codegenNode;
      return aE(l, n, t), l;
    } else {
      let l = 64;
      return Dp(
        t,
        i(Np),
        Qn([n]),
        a,
        l + "",
        void 0,
        void 0,
        !0,
        !1,
        !1,
        r.loc
      );
    }
  else {
    const l = o.codegenNode, u = dJ(l);
    return u.type === 13 && fI(u, t), aE(u, n, t), l;
  }
}
function qJ(r) {
  for (; ; )
    if (r.type === 19)
      if (r.alternate.type === 19)
        r = r.alternate;
      else
        return r;
    else
      r.type === 20 && (r = r.value);
}
const jJ = nF(
  "for",
  (r, e, t) => {
    const { helper: i, removeHelper: n } = t;
    return KJ(r, e, t, (a) => {
      const o = dr(i(oI), [
        a.source
      ]), s = iE(r), l = Pn(r, "memo"), u = sS(r, "key"), h = u && (u.type === 6 ? ct(u.value.content, !0) : u.exp), c = u ? nr("key", h) : null, f = a.source.type === 4 && a.source.constType > 0, d = f ? 64 : u ? 128 : 256;
      return a.codegenNode = Dp(
        t,
        i(Np),
        void 0,
        o,
        d + "",
        void 0,
        void 0,
        !0,
        !f,
        !1,
        r.loc
      ), () => {
        let p;
        const { children: g } = a, v = g.length !== 1 || g[0].type !== 1, O = nE(r) ? r : s && r.children.length === 1 && nE(r.children[0]) ? r.children[0] : null;
        if (O ? (p = O.codegenNode, s && c && aE(p, c, t)) : v ? p = Dp(
          t,
          i(Np),
          c ? Qn([c]) : void 0,
          r.children,
          "64",
          void 0,
          void 0,
          !0,
          void 0,
          !1
          /* isComponent */
        ) : (p = g[0].codegenNode, s && c && aE(p, c, t), p.isBlock !== !f && (p.isBlock ? (n(Ju), n(
          qc(t.inSSR, p.isComponent)
        )) : n(
          Zc(t.inSSR, p.isComponent)
        )), p.isBlock = !f, p.isBlock ? (i(Ju), i(qc(t.inSSR, p.isComponent))) : i(Zc(t.inSSR, p.isComponent))), l) {
          const m = zc(
            bA(a.parseResult, [
              ct("_cached")
            ])
          );
          m.body = nJ([
            ga(["const _memo = (", l.exp, ")"]),
            ga([
              "if (_cached",
              ...h ? [" && _cached.key === ", h] : [],
              ` && ${t.helperString(
                W5
              )}(_cached, _memo)) return _cached`
            ]),
            ga(["const _item = ", p]),
            ct("_item.memo = _memo"),
            ct("return _item")
          ]), o.arguments.push(
            m,
            ct("_cache"),
            ct(String(t.cached++))
          );
        } else
          o.arguments.push(
            zc(
              bA(a.parseResult),
              p,
              !0
              /* force newline */
            )
          );
      };
    });
  }
);
function KJ(r, e, t, i) {
  if (!e.exp) {
    t.onError(
      Ht(31, e.loc)
    );
    return;
  }
  const n = lF(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    e.exp
  );
  if (!n) {
    t.onError(
      Ht(32, e.loc)
    );
    return;
  }
  const { addIdentifiers: a, removeIdentifiers: o, scopes: s } = t, { source: l, value: u, key: h, index: c } = n, f = {
    type: 11,
    loc: e.loc,
    source: l,
    valueAlias: u,
    keyAlias: h,
    objectIndexAlias: c,
    parseResult: n,
    children: iE(r) ? r.children : [r]
  };
  t.replaceNode(f), s.vFor++;
  const d = i && i(f);
  return () => {
    s.vFor--, d && d();
  };
}
const JJ = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, FN = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, eee = /^\(|\)$/g;
function lF(r, e) {
  const t = r.loc, i = r.content, n = i.match(JJ);
  if (!n)
    return;
  const [, a, o] = n, s = {
    source: _v(
      t,
      o.trim(),
      i.indexOf(o, a.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0
  };
  let l = a.trim().replace(eee, "").trim();
  const u = a.indexOf(l), h = l.match(FN);
  if (h) {
    l = l.replace(FN, "").trim();
    const c = h[1].trim();
    let f;
    if (c && (f = i.indexOf(c, u + l.length), s.key = _v(t, c, f)), h[2]) {
      const d = h[2].trim();
      d && (s.index = _v(
        t,
        d,
        i.indexOf(
          d,
          s.key ? f + c.length : u + l.length
        )
      ));
    }
  }
  return l && (s.value = _v(t, l, u)), s;
}
function _v(r, e, t) {
  return ct(
    e,
    !1,
    q5(r, t, e.length)
  );
}
function bA({ value: r, key: e, index: t }, i = []) {
  return tee([r, e, t, ...i]);
}
function tee(r) {
  let e = r.length;
  for (; e-- && !r[e]; )
    ;
  return r.slice(0, e + 1).map((t, i) => t || ct("_".repeat(i + 1), !1));
}
const XN = ct("undefined", !1), ree = (r, e) => {
  if (r.type === 1 && (r.tagType === 1 || r.tagType === 3)) {
    const t = Pn(r, "slot");
    if (t)
      return t.exp, e.scopes.vSlot++, () => {
        e.scopes.vSlot--;
      };
  }
}, iee = (r, e, t) => zc(
  r,
  e,
  !1,
  !0,
  e.length ? e[0].loc : t
);
function nee(r, e, t = iee) {
  e.helper(hI);
  const { children: i, loc: n } = r, a = [], o = [];
  let s = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
  const l = Pn(r, "slot", !0);
  if (l) {
    const { arg: v, exp: O } = l;
    v && !Gi(v) && (s = !0), a.push(
      nr(
        v || ct("default", !0),
        t(O, i, n)
      )
    );
  }
  let u = !1, h = !1;
  const c = [], f = /* @__PURE__ */ new Set();
  let d = 0;
  for (let v = 0; v < i.length; v++) {
    const O = i[v];
    let m;
    if (!iE(O) || !(m = Pn(O, "slot", !0))) {
      O.type !== 3 && c.push(O);
      continue;
    }
    if (l) {
      e.onError(
        Ht(37, m.loc)
      );
      break;
    }
    u = !0;
    const { children: E, loc: b } = O, {
      arg: T = ct("default", !0),
      exp: S,
      loc: y
    } = m;
    let A;
    Gi(T) ? A = T ? T.content : "default" : s = !0;
    const C = t(S, E, b);
    let _, I, x;
    if (_ = Pn(O, "if"))
      s = !0, o.push(
        OA(
          _.exp,
          Iv(T, C, d++),
          XN
        )
      );
    else if (I = Pn(
      O,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let P = v, N;
      for (; P-- && (N = i[P], N.type === 3); )
        ;
      if (N && iE(N) && Pn(N, "if")) {
        i.splice(v, 1), v--;
        let L = o[o.length - 1];
        for (; L.alternate.type === 19; )
          L = L.alternate;
        L.alternate = I.exp ? OA(
          I.exp,
          Iv(
            T,
            C,
            d++
          ),
          XN
        ) : Iv(T, C, d++);
      } else
        e.onError(
          Ht(30, I.loc)
        );
    } else if (x = Pn(O, "for")) {
      s = !0;
      const P = x.parseResult || lF(x.exp);
      P ? o.push(
        dr(e.helper(oI), [
          P.source,
          zc(
            bA(P),
            Iv(T, C),
            !0
            /* force newline */
          )
        ])
      ) : e.onError(
        Ht(32, x.loc)
      );
    } else {
      if (A) {
        if (f.has(A)) {
          e.onError(
            Ht(
              38,
              y
            )
          );
          continue;
        }
        f.add(A), A === "default" && (h = !0);
      }
      a.push(nr(T, C));
    }
  }
  if (!l) {
    const v = (O, m) => {
      const E = t(O, m, n);
      return e.compatConfig && (E.isNonScopedSlot = !0), nr("default", E);
    };
    u ? c.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    c.some((O) => uF(O)) && (h ? e.onError(
      Ht(
        39,
        c[0].loc
      )
    ) : a.push(
      v(void 0, c)
    )) : a.push(v(void 0, i));
  }
  const p = s ? 2 : sm(r.children) ? 3 : 1;
  let g = Qn(
    a.concat(
      nr(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        ct(
          p + "",
          !1
        )
      )
    ),
    n
  );
  return o.length && (g = dr(e.helper(H5), [
    g,
    Dg(o)
  ])), {
    slots: g,
    hasDynamicSlots: s
  };
}
function Iv(r, e, t) {
  const i = [
    nr("name", r),
    nr("fn", e)
  ];
  return t != null && i.push(
    nr("key", ct(String(t), !0))
  ), Qn(i);
}
function sm(r) {
  for (let e = 0; e < r.length; e++) {
    const t = r[e];
    switch (t.type) {
      case 1:
        if (t.tagType === 2 || sm(t.children))
          return !0;
        break;
      case 9:
        if (sm(t.branches))
          return !0;
        break;
      case 10:
      case 11:
        if (sm(t.children))
          return !0;
        break;
    }
  }
  return !1;
}
function uF(r) {
  return r.type !== 2 && r.type !== 12 ? !0 : r.type === 2 ? !!r.content.trim() : uF(r.content);
}
const hF = /* @__PURE__ */ new WeakMap(), aee = (r, e) => function() {
  if (r = e.currentNode, !(r.type === 1 && (r.tagType === 0 || r.tagType === 1)))
    return;
  const { tag: i, props: n } = r, a = r.tagType === 1;
  let o = a ? oee(r, e) : `"${i}"`;
  const s = kt(o) && o.callee === Km;
  let l, u, h, c = 0, f, d, p, g = (
    // dynamic component may resolve to plain elements
    s || o === ep || o === K1 || !a && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (i === "svg" || i === "foreignObject")
  );
  if (n.length > 0) {
    const v = cF(
      r,
      e,
      void 0,
      a,
      s
    );
    l = v.props, c = v.patchFlag, d = v.dynamicPropNames;
    const O = v.directives;
    p = O && O.length ? Dg(
      O.map((m) => lee(m, e))
    ) : void 0, v.shouldUseBlock && (g = !0);
  }
  if (r.children.length > 0)
    if (o === jm && (g = !0, c |= 1024), a && // Teleport is not a real component and has dedicated runtime handling
    o !== ep && // explained above.
    o !== jm) {
      const { slots: O, hasDynamicSlots: m } = nee(r, e);
      u = O, m && (c |= 1024);
    } else if (r.children.length === 1 && o !== ep) {
      const O = r.children[0], m = O.type, E = m === 5 || m === 8;
      E && Un(O, e) === 0 && (c |= 1), E || m === 2 ? u = O : u = r.children;
    } else
      u = r.children;
  c !== 0 && (h = String(c), d && d.length && (f = uee(d))), r.codegenNode = Dp(
    e,
    o,
    l,
    u,
    h,
    f,
    p,
    !!g,
    !1,
    a,
    r.loc
  );
};
function oee(r, e, t = !1) {
  let { tag: i } = r;
  const n = SA(i), a = sS(r, "is");
  if (a)
    if (n || ku(
      "COMPILER_IS_ON_ELEMENT",
      e
    )) {
      const l = a.type === 6 ? a.value && ct(a.value.content, !0) : a.exp;
      if (l)
        return dr(e.helper(Km), [
          l
        ]);
    } else
      a.type === 6 && a.value.content.startsWith("vue:") && (i = a.value.content.slice(4));
  const o = !n && Pn(r, "is");
  if (o && o.exp)
    return dr(e.helper(Km), [
      o.exp
    ]);
  const s = z5(i) || e.isBuiltInComponent(i);
  return s ? (t || e.helper(s), s) : (e.helper(rI), e.components.add(i), Mp(i, "component"));
}
function cF(r, e, t = r.props, i, n, a = !1) {
  const { tag: o, loc: s, children: l } = r;
  let u = [];
  const h = [], c = [], f = l.length > 0;
  let d = !1, p = 0, g = !1, v = !1, O = !1, m = !1, E = !1, b = !1;
  const T = [], S = (C) => {
    u.length && (h.push(
      Qn(YN(u), s)
    ), u = []), C && h.push(C);
  }, y = ({ key: C, value: _ }) => {
    if (Gi(C)) {
      const I = C.content, x = ph(I);
      if (x && (!i || n) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      I.toLowerCase() !== "onclick" && // omit v-model handlers
      I !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !Pu(I) && (m = !0), x && Pu(I) && (b = !0), _.type === 20 || (_.type === 4 || _.type === 8) && Un(_, e) > 0)
        return;
      I === "ref" ? g = !0 : I === "class" ? v = !0 : I === "style" ? O = !0 : I !== "key" && !T.includes(I) && T.push(I), i && (I === "class" || I === "style") && !T.includes(I) && T.push(I);
    } else
      E = !0;
  };
  for (let C = 0; C < t.length; C++) {
    const _ = t[C];
    if (_.type === 6) {
      const { loc: I, name: x, value: P } = _;
      let N = !0;
      if (x === "ref" && (g = !0, e.scopes.vFor > 0 && u.push(
        nr(
          ct("ref_for", !0),
          ct("true")
        )
      )), x === "is" && (SA(o) || P && P.content.startsWith("vue:") || ku(
        "COMPILER_IS_ON_ELEMENT",
        e
      )))
        continue;
      u.push(
        nr(
          ct(
            x,
            !0,
            q5(I, 0, x.length)
          ),
          ct(
            P ? P.content : "",
            N,
            P ? P.loc : I
          )
        )
      );
    } else {
      const { name: I, arg: x, exp: P, loc: N } = _, L = I === "bind", D = I === "on";
      if (I === "slot") {
        i || e.onError(
          Ht(40, N)
        );
        continue;
      }
      if (I === "once" || I === "memo" || I === "is" || L && Eu(x, "is") && (SA(o) || ku(
        "COMPILER_IS_ON_ELEMENT",
        e
      )) || D && a)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (L && Eu(x, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        D && f && Eu(x, "vue:before-update")) && (d = !0), L && Eu(x, "ref") && e.scopes.vFor > 0 && u.push(
          nr(
            ct("ref_for", !0),
            ct("true")
          )
        ), !x && (L || D)
      ) {
        if (E = !0, P)
          if (L) {
            if (S(), ku(
              "COMPILER_V_BIND_OBJECT_ORDER",
              e
            )) {
              h.unshift(P);
              continue;
            }
            h.push(P);
          } else
            S({
              type: 14,
              loc: N,
              callee: e.helper(uI),
              arguments: i ? [P] : [P, "true"]
            });
        else
          e.onError(
            Ht(
              L ? 34 : 35,
              N
            )
          );
        continue;
      }
      const $ = e.directiveTransforms[I];
      if ($) {
        const { props: k, needRuntime: G } = $(_, r, e);
        !a && k.forEach(y), D && x && !Gi(x) ? S(Qn(k, s)) : u.push(...k), G && (c.push(_), qs(G) && hF.set(_, G));
      } else
        A8(I) || (c.push(_), f && (d = !0));
    }
  }
  let A;
  if (h.length ? (S(), h.length > 1 ? A = dr(
    e.helper(Jm),
    h,
    s
  ) : A = h[0]) : u.length && (A = Qn(
    YN(u),
    s
  )), E ? p |= 16 : (v && !i && (p |= 2), O && !i && (p |= 4), T.length && (p |= 8), m && (p |= 32)), !d && (p === 0 || p === 32) && (g || b || c.length > 0) && (p |= 512), !e.inSSR && A)
    switch (A.type) {
      case 15:
        let C = -1, _ = -1, I = !1;
        for (let N = 0; N < A.properties.length; N++) {
          const L = A.properties[N].key;
          Gi(L) ? L.content === "class" ? C = N : L.content === "style" && (_ = N) : L.isHandlerKey || (I = !0);
        }
        const x = A.properties[C], P = A.properties[_];
        I ? A = dr(
          e.helper(Lp),
          [A]
        ) : (x && !Gi(x.value) && (x.value = dr(
          e.helper(sI),
          [x.value]
        )), P && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (O || P.value.type === 4 && P.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        P.value.type === 17) && (P.value = dr(
          e.helper(lI),
          [P.value]
        )));
        break;
      case 14:
        break;
      default:
        A = dr(
          e.helper(Lp),
          [
            dr(e.helper(Lg), [
              A
            ])
          ]
        );
        break;
    }
  return {
    props: A,
    directives: c,
    patchFlag: p,
    dynamicPropNames: T,
    shouldUseBlock: d
  };
}
function YN(r) {
  const e = /* @__PURE__ */ new Map(), t = [];
  for (let i = 0; i < r.length; i++) {
    const n = r[i];
    if (n.key.type === 8 || !n.key.isStatic) {
      t.push(n);
      continue;
    }
    const a = n.key.content, o = e.get(a);
    o ? (a === "style" || a === "class" || ph(a)) && see(o, n) : (e.set(a, n), t.push(n));
  }
  return t;
}
function see(r, e) {
  r.value.type === 17 ? r.value.elements.push(e.value) : r.value = Dg(
    [r.value, e.value],
    r.loc
  );
}
function lee(r, e) {
  const t = [], i = hF.get(r);
  i ? t.push(e.helperString(i)) : (e.helper(iI), e.directives.add(r.name), t.push(Mp(r.name, "directive")));
  const { loc: n } = r;
  if (r.exp && t.push(r.exp), r.arg && (r.exp || t.push("void 0"), t.push(r.arg)), Object.keys(r.modifiers).length) {
    r.arg || (r.exp || t.push("void 0"), t.push("void 0"));
    const a = ct("true", !1, n);
    t.push(
      Qn(
        r.modifiers.map(
          (o) => nr(o, a)
        ),
        n
      )
    );
  }
  return Dg(t, r.loc);
}
function uee(r) {
  let e = "[";
  for (let t = 0, i = r.length; t < i; t++)
    e += JSON.stringify(r[t]), t < i - 1 && (e += ", ");
  return e + "]";
}
function SA(r) {
  return r === "component" || r === "Component";
}
const hee = (r, e) => {
  if (nE(r)) {
    const { children: t, loc: i } = r, { slotName: n, slotProps: a } = cee(r, e), o = [
      e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      n,
      "{}",
      "undefined",
      "true"
    ];
    let s = 2;
    a && (o[2] = a, s = 3), t.length && (o[3] = zc([], t, !1, !1, i), s = 4), e.scopeId && !e.slotted && (s = 5), o.splice(s), r.codegenNode = dr(
      e.helper(Y5),
      o,
      i
    );
  }
};
function cee(r, e) {
  let t = '"default"', i;
  const n = [];
  for (let a = 0; a < r.props.length; a++) {
    const o = r.props[a];
    o.type === 6 ? o.value && (o.name === "name" ? t = JSON.stringify(o.value.content) : (o.name = Or(o.name), n.push(o))) : o.name === "bind" && Eu(o.arg, "name") ? o.exp && (t = o.exp) : (o.name === "bind" && o.arg && Gi(o.arg) && (o.arg.content = Or(o.arg.content)), n.push(o));
  }
  if (n.length > 0) {
    const { props: a, directives: o } = cF(
      r,
      e,
      n,
      !1,
      !1
    );
    i = a, o.length && e.onError(
      Ht(
        36,
        o[0].loc
      )
    );
  }
  return {
    slotName: t,
    slotProps: i
  };
}
const fee = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, fF = (r, e, t, i) => {
  const { loc: n, modifiers: a, arg: o } = r;
  !r.exp && !a.length && t.onError(Ht(35, n));
  let s;
  if (o.type === 4)
    if (o.isStatic) {
      let c = o.content;
      c.startsWith("vue:") && (c = `vnode-${c.slice(4)}`);
      const f = e.tagType !== 0 || c.startsWith("vnode") || !/[A-Z]/.test(c) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        Cc(Or(c))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${c}`
      );
      s = ct(f, !0, o.loc);
    } else
      s = ga([
        `${t.helperString(vA)}(`,
        o,
        ")"
      ]);
  else
    s = o, s.children.unshift(`${t.helperString(vA)}(`), s.children.push(")");
  let l = r.exp;
  l && !l.content.trim() && (l = void 0);
  let u = t.cacheHandlers && !l && !t.inVOnce;
  if (l) {
    const c = Z5(l.content), f = !(c || fee.test(l.content)), d = l.content.includes(";");
    (f || u && c) && (l = ga([
      `${f ? "$event" : "(...args)"} => ${d ? "{" : "("}`,
      l,
      d ? "}" : ")"
    ]));
  }
  let h = {
    props: [
      nr(
        s,
        l || ct("() => {}", !1, n)
      )
    ]
  };
  return i && (h = i(h)), u && (h.props[0].value = t.cache(h.props[0].value)), h.props.forEach((c) => c.key.isHandlerKey = !0), h;
}, dee = (r, e, t) => {
  const { exp: i, modifiers: n, loc: a } = r, o = r.arg;
  return o.type !== 4 ? (o.children.unshift("("), o.children.push(') || ""')) : o.isStatic || (o.content = `${o.content} || ""`), n.includes("camel") && (o.type === 4 ? o.isStatic ? o.content = Or(o.content) : o.content = `${t.helperString(gA)}(${o.content})` : (o.children.unshift(`${t.helperString(gA)}(`), o.children.push(")"))), t.inSSR || (n.includes("prop") && HN(o, "."), n.includes("attr") && HN(o, "^")), !i || i.type === 4 && !i.content.trim() ? (t.onError(Ht(34, a)), {
    props: [nr(o, ct("", !0, a))]
  }) : {
    props: [nr(o, i)]
  };
}, HN = (r, e) => {
  r.type === 4 ? r.isStatic ? r.content = e + r.content : r.content = `\`${e}\${${r.content}}\`` : (r.children.unshift(`'${e}' + (`), r.children.push(")"));
}, pee = (r, e) => {
  if (r.type === 0 || r.type === 1 || r.type === 11 || r.type === 10)
    return () => {
      const t = r.children;
      let i, n = !1;
      for (let a = 0; a < t.length; a++) {
        const o = t[a];
        if (DT(o)) {
          n = !0;
          for (let s = a + 1; s < t.length; s++) {
            const l = t[s];
            if (DT(l))
              i || (i = t[a] = ga(
                [o],
                o.loc
              )), i.children.push(" + ", l), t.splice(s, 1), s--;
            else {
              i = void 0;
              break;
            }
          }
        }
      }
      if (!(!n || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      t.length === 1 && (r.type === 0 || r.type === 1 && r.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !r.props.find(
        (a) => a.type === 7 && !e.directiveTransforms[a.name]
      ) && r.tag !== "template")))
        for (let a = 0; a < t.length; a++) {
          const o = t[a];
          if (DT(o) || o.type === 8) {
            const s = [];
            (o.type !== 2 || o.content !== " ") && s.push(o), !e.ssr && Un(o, e) === 0 && s.push(
              "1"
            ), t[a] = {
              type: 12,
              content: o,
              loc: o.loc,
              codegenNode: dr(
                e.helper(tI),
                s
              )
            };
          }
        }
    };
}, WN = /* @__PURE__ */ new WeakSet(), gee = (r, e) => {
  if (r.type === 1 && Pn(r, "once", !0))
    return WN.has(r) || e.inVOnce || e.inSSR ? void 0 : (WN.add(r), e.inVOnce = !0, e.helper(eE), () => {
      e.inVOnce = !1;
      const t = e.currentNode;
      t.codegenNode && (t.codegenNode = e.cache(
        t.codegenNode,
        !0
        /* isVNode */
      ));
    });
}, dF = (r, e, t) => {
  const { exp: i, arg: n } = r;
  if (!i)
    return t.onError(
      Ht(41, r.loc)
    ), xv();
  const a = i.loc.source, o = i.type === 4 ? i.content : a, s = t.bindingMetadata[a];
  if (s === "props" || s === "props-aliased")
    return t.onError(Ht(44, i.loc)), xv();
  const l = !1;
  if (!o.trim() || !Z5(o) && !l)
    return t.onError(
      Ht(42, i.loc)
    ), xv();
  const u = n || ct("modelValue", !0), h = n ? Gi(n) ? `onUpdate:${Or(n.content)}` : ga(['"onUpdate:" + ', n]) : "onUpdate:modelValue";
  let c;
  const f = t.isTS ? "($event: any)" : "$event";
  c = ga([
    `${f} => ((`,
    i,
    ") = $event)"
  ]);
  const d = [
    // modelValue: foo
    nr(u, r.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    nr(h, c)
  ];
  if (r.modifiers.length && e.tagType === 1) {
    const p = r.modifiers.map((v) => (dI(v) ? v : JSON.stringify(v)) + ": true").join(", "), g = n ? Gi(n) ? `${n.content}Modifiers` : ga([n, ' + "Modifiers"']) : "modelModifiers";
    d.push(
      nr(
        g,
        ct(
          `{ ${p} }`,
          !1,
          r.loc,
          2
        )
      )
    );
  }
  return xv(d);
};
function xv(r = []) {
  return { props: r };
}
const vee = /[\w).+\-_$\]]/, Oee = (r, e) => {
  ku("COMPILER_FILTER", e) && (r.type === 5 && sE(r.content, e), r.type === 1 && r.props.forEach((t) => {
    t.type === 7 && t.name !== "for" && t.exp && sE(t.exp, e);
  }));
};
function sE(r, e) {
  if (r.type === 4)
    zN(r, e);
  else
    for (let t = 0; t < r.children.length; t++) {
      const i = r.children[t];
      typeof i == "object" && (i.type === 4 ? zN(i, e) : i.type === 8 ? sE(r, e) : i.type === 5 && sE(i.content, e));
    }
}
function zN(r, e) {
  const t = r.content;
  let i = !1, n = !1, a = !1, o = !1, s = 0, l = 0, u = 0, h = 0, c, f, d, p, g = [];
  for (d = 0; d < t.length; d++)
    if (f = c, c = t.charCodeAt(d), i)
      c === 39 && f !== 92 && (i = !1);
    else if (n)
      c === 34 && f !== 92 && (n = !1);
    else if (a)
      c === 96 && f !== 92 && (a = !1);
    else if (o)
      c === 47 && f !== 92 && (o = !1);
    else if (c === 124 && // pipe
    t.charCodeAt(d + 1) !== 124 && t.charCodeAt(d - 1) !== 124 && !s && !l && !u)
      p === void 0 ? (h = d + 1, p = t.slice(0, d).trim()) : v();
    else {
      switch (c) {
        case 34:
          n = !0;
          break;
        case 39:
          i = !0;
          break;
        case 96:
          a = !0;
          break;
        case 40:
          u++;
          break;
        case 41:
          u--;
          break;
        case 91:
          l++;
          break;
        case 93:
          l--;
          break;
        case 123:
          s++;
          break;
        case 125:
          s--;
          break;
      }
      if (c === 47) {
        let O = d - 1, m;
        for (; O >= 0 && (m = t.charAt(O), m === " "); O--)
          ;
        (!m || !vee.test(m)) && (o = !0);
      }
    }
  p === void 0 ? p = t.slice(0, d).trim() : h !== 0 && v();
  function v() {
    g.push(t.slice(h, d).trim()), h = d + 1;
  }
  if (g.length) {
    for (d = 0; d < g.length; d++)
      p = mee(p, g[d], e);
    r.content = p;
  }
}
function mee(r, e, t) {
  t.helper(nI);
  const i = e.indexOf("(");
  if (i < 0)
    return t.filters.add(e), `${Mp(e, "filter")}(${r})`;
  {
    const n = e.slice(0, i), a = e.slice(i + 1);
    return t.filters.add(n), `${Mp(n, "filter")}(${r}${a !== ")" ? "," + a : a}`;
  }
}
const ZN = /* @__PURE__ */ new WeakSet(), Eee = (r, e) => {
  if (r.type === 1) {
    const t = Pn(r, "memo");
    return !t || ZN.has(r) ? void 0 : (ZN.add(r), () => {
      const i = r.codegenNode || e.currentNode.codegenNode;
      i && i.type === 13 && (r.tagType !== 1 && fI(i, e), r.codegenNode = dr(e.helper(cI), [
        t.exp,
        zc(void 0, i),
        "_cache",
        String(e.cached++)
      ]));
    });
  }
};
function bee(r) {
  return [
    [
      gee,
      zJ,
      Eee,
      jJ,
      Oee,
      hee,
      aee,
      ree,
      pee
    ],
    {
      on: fF,
      bind: dee,
      model: dF
    }
  ];
}
function See(r, e = {}) {
  const t = e.onError || j1, i = e.mode === "module";
  e.prefixIdentifiers === !0 ? t(Ht(47)) : i && t(Ht(48));
  const n = !1;
  e.cacheHandlers && t(Ht(49)), e.scopeId && !i && t(Ht(50));
  const a = it(r) ? vJ(r, e) : r, [o, s] = bee();
  return wJ(
    a,
    Ot({}, e, {
      prefixIdentifiers: n,
      nodeTransforms: [
        ...o,
        ...e.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: Ot(
        {},
        s,
        e.directiveTransforms || {}
        // user transforms
      )
    })
  ), LJ(
    a,
    Ot({}, e, {
      prefixIdentifiers: n
    })
  );
}
const Tee = () => ({ props: [] }), pF = Symbol(""), gF = Symbol(""), vF = Symbol(""), OF = Symbol(""), TA = Symbol(""), mF = Symbol(""), EF = Symbol(""), bF = Symbol(""), SF = Symbol(""), TF = Symbol("");
tJ({
  [pF]: "vModelRadio",
  [gF]: "vModelCheckbox",
  [vF]: "vModelText",
  [OF]: "vModelSelect",
  [TA]: "vModelDynamic",
  [mF]: "withModifiers",
  [EF]: "withKeys",
  [bF]: "vShow",
  [SF]: "Transition",
  [TF]: "TransitionGroup"
});
let Dh;
function yee(r, e = !1) {
  return Dh || (Dh = document.createElement("div")), e ? (Dh.innerHTML = `<div foo="${r.replace(/"/g, "&quot;")}">`, Dh.children[0].getAttribute("foo")) : (Dh.innerHTML = r, Dh.textContent);
}
const Ree = /* @__PURE__ */ Hi(
  "style,iframe,script,noscript",
  !0
), Aee = {
  isVoidTag: $8,
  isNativeTag: (r) => Q8(r) || U8(r),
  isPreTag: (r) => r === "pre",
  decodeEntities: yee,
  isBuiltInComponent: (r) => {
    if (pc(r, "Transition"))
      return SF;
    if (pc(r, "TransitionGroup"))
      return TF;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(r, e) {
    let t = e ? e.ns : 0;
    if (e && t === 2)
      if (e.tag === "annotation-xml") {
        if (r === "svg")
          return 1;
        e.props.some(
          (i) => i.type === 6 && i.name === "encoding" && i.value != null && (i.value.content === "text/html" || i.value.content === "application/xhtml+xml")
        ) && (t = 0);
      } else
        /^m(?:[ions]|text)$/.test(e.tag) && r !== "mglyph" && r !== "malignmark" && (t = 0);
    else
      e && t === 1 && (e.tag === "foreignObject" || e.tag === "desc" || e.tag === "title") && (t = 0);
    if (t === 0) {
      if (r === "svg")
        return 1;
      if (r === "math")
        return 2;
    }
    return t;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag: r, ns: e }) {
    if (e === 0) {
      if (r === "textarea" || r === "title")
        return 1;
      if (Ree(r))
        return 2;
    }
    return 0;
  }
}, Cee = (r) => {
  r.type === 1 && r.props.forEach((e, t) => {
    e.type === 6 && e.name === "style" && e.value && (r.props[t] = {
      type: 7,
      name: "bind",
      arg: ct("style", !0, e.loc),
      exp: _ee(e.value.content, e.loc),
      modifiers: [],
      loc: e.loc
    });
  });
}, _ee = (r, e) => {
  const t = rV(r);
  return ct(
    JSON.stringify(t),
    !1,
    e,
    3
  );
};
function Bs(r, e) {
  return Ht(
    r,
    e
  );
}
const Iee = (r, e, t) => {
  const { exp: i, loc: n } = r;
  return i || t.onError(
    Bs(53, n)
  ), e.children.length && (t.onError(
    Bs(54, n)
  ), e.children.length = 0), {
    props: [
      nr(
        ct("innerHTML", !0, n),
        i || ct("", !0)
      )
    ]
  };
}, xee = (r, e, t) => {
  const { exp: i, loc: n } = r;
  return i || t.onError(
    Bs(55, n)
  ), e.children.length && (t.onError(
    Bs(56, n)
  ), e.children.length = 0), {
    props: [
      nr(
        ct("textContent", !0),
        i ? Un(i, t) > 0 ? i : dr(
          t.helperString(oS),
          [i],
          n
        ) : ct("", !0)
      )
    ]
  };
}, wee = (r, e, t) => {
  const i = dF(r, e, t);
  if (!i.props.length || e.tagType === 1)
    return i;
  r.arg && t.onError(
    Bs(
      58,
      r.arg.loc
    )
  );
  const { tag: n } = e, a = t.isCustomElement(n);
  if (n === "input" || n === "textarea" || n === "select" || a) {
    let o = vF, s = !1;
    if (n === "input" || a) {
      const l = sS(e, "type");
      if (l) {
        if (l.type === 7)
          o = TA;
        else if (l.value)
          switch (l.value.content) {
            case "radio":
              o = pF;
              break;
            case "checkbox":
              o = gF;
              break;
            case "file":
              s = !0, t.onError(
                Bs(
                  59,
                  r.loc
                )
              );
              break;
          }
      } else
        hJ(e) && (o = TA);
    } else
      n === "select" && (o = OF);
    s || (i.needRuntime = t.helper(o));
  } else
    t.onError(
      Bs(
        57,
        r.loc
      )
    );
  return i.props = i.props.filter(
    (o) => !(o.key.type === 4 && o.key.content === "modelValue")
  ), i;
}, Pee = /* @__PURE__ */ Hi("passive,once,capture"), Nee = /* @__PURE__ */ Hi(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), Lee = /* @__PURE__ */ Hi("left,right"), yF = /* @__PURE__ */ Hi(
  "onkeyup,onkeydown,onkeypress",
  !0
), Dee = (r, e, t, i) => {
  const n = [], a = [], o = [];
  for (let s = 0; s < e.length; s++) {
    const l = e[s];
    l === "native" && kp(
      "COMPILER_V_ON_NATIVE",
      t
    ) || Pee(l) ? o.push(l) : Lee(l) ? Gi(r) ? yF(r.content) ? n.push(l) : a.push(l) : (n.push(l), a.push(l)) : Nee(l) ? a.push(l) : n.push(l);
  }
  return {
    keyModifiers: n,
    nonKeyModifiers: a,
    eventOptionModifiers: o
  };
}, qN = (r, e) => Gi(r) && r.content.toLowerCase() === "onclick" ? ct(e, !0) : r.type !== 4 ? ga([
  "(",
  r,
  `) === "onClick" ? "${e}" : (`,
  r,
  ")"
]) : r, Mee = (r, e, t) => fF(r, e, t, (i) => {
  const { modifiers: n } = r;
  if (!n.length)
    return i;
  let { key: a, value: o } = i.props[0];
  const { keyModifiers: s, nonKeyModifiers: l, eventOptionModifiers: u } = Dee(a, n, t, r.loc);
  if (l.includes("right") && (a = qN(a, "onContextmenu")), l.includes("middle") && (a = qN(a, "onMouseup")), l.length && (o = dr(t.helper(mF), [
    o,
    JSON.stringify(l)
  ])), s.length && // if event name is dynamic, always wrap with keys guard
  (!Gi(a) || yF(a.content)) && (o = dr(t.helper(EF), [
    o,
    JSON.stringify(s)
  ])), u.length) {
    const h = u.map(vh).join("");
    a = Gi(a) ? ct(`${a.content}${h}`, !0) : ga(["(", a, `) + "${h}"`]);
  }
  return {
    props: [nr(a, o)]
  };
}), kee = (r, e, t) => {
  const { exp: i, loc: n } = r;
  return i || t.onError(
    Bs(61, n)
  ), {
    props: [],
    needRuntime: t.helper(bF)
  };
}, Qee = (r, e) => {
  r.type === 1 && r.tagType === 0 && (r.tag === "script" || r.tag === "style") && e.removeNode();
}, Uee = [
  Cee
], $ee = {
  cloak: Tee,
  html: Iee,
  text: xee,
  model: wee,
  // override compiler-core
  on: Mee,
  // override compiler-core
  show: kee
};
function Gee(r, e = {}) {
  return See(
    r,
    Ot({}, Aee, e, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        Qee,
        ...Uee,
        ...e.nodeTransforms || []
      ],
      directiveTransforms: Ot(
        {},
        $ee,
        e.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
const jN = /* @__PURE__ */ Object.create(null);
function Bee(r, e) {
  if (!it(r))
    if (r.nodeType)
      r = r.innerHTML;
    else
      return Ri;
  const t = r, i = jN[t];
  if (i)
    return i;
  if (r[0] === "#") {
    const s = document.querySelector(r);
    r = s ? s.innerHTML : "";
  }
  const n = Ot(
    {
      hoistStatic: !0,
      onError: void 0,
      onWarn: Ri
    },
    e
  );
  !n.isCustomElement && typeof customElements < "u" && (n.isCustomElement = (s) => !!customElements.get(s));
  const { code: a } = Gee(r, n), o = new Function("Vue", a)(ZK);
  return o._rc = !0, jN[t] = o;
}
g5(Bee);
const Vee = {
  "Content-Type": "application/json;charset=UTF-8;"
}, Fee = {
  mode: "cors",
  credentials: "include",
  cache: "no-cache"
}, Tp = class Tp {
  constructor(e = "", t = 5e3, i) {
    xr(this, "RequestFilters", {});
    xr(this, "headers", {
      ...Vee
    });
    xr(this, "BasePath", "");
    this.setBasePath(e), this.setTimeout(t), i && (this.RequestFilters = {
      ...i
    });
  }
  fetchHandler(e, t, i, n, a = "json") {
    let o = { ...Fee };
    const s = {
      ...this.headers,
      ...n || {}
    };
    let l = `${/^http/gi.test(e) ? "" : this.BasePath}${e}`;
    switch (o = {
      ...o,
      method: t.toUpperCase(),
      headers: s,
      responseType: a
    }, t.toLocaleLowerCase()) {
      case "get":
        i && (l += "?", Object.keys(i).forEach((c) => {
          l += `${c}=${i[c]}&`;
        }));
        break;
      case "formdata":
        o = {
          ...o,
          body: i
        }, delete o.headers["Content-Type"];
        break;
      default:
        o = {
          ...o,
          body: i ? JSON.stringify(i) : "{}"
        };
    }
    const u = new Promise((c, f) => window.fetch(l, o).then((d) => {
      switch (a) {
        case "arraybuffer":
        case "file":
          c(d.arrayBuffer());
          break;
        case "blob":
          c(d.blob());
          break;
        case "document":
          c(d.formData());
          break;
        case "text":
          this.RequestFilters.after ? c(this.RequestFilters.after(d.text())) : c(d.text());
          break;
        default:
          this.RequestFilters.after ? c(this.RequestFilters.after(d.json())) : c(d.json());
      }
    }).catch((d) => {
      f(d);
    })), h = new Promise((c, f) => {
      setTimeout(() => {
        c({
          code: 500,
          message: "timeout",
          success: !1,
          data: null
        });
      }, Tp.timeout);
    });
    return Promise.race([u, h]);
  }
  setTimeout(e) {
    Tp.timeout = e;
  }
  setBasePath(e) {
    this.BasePath = e;
  }
  setHeader(e) {
    e && (this.headers = {
      ...this.headers,
      ...e
    });
  }
  registerRequestFilter(e, t) {
    this.RequestFilters[e] = t;
  }
  post(e, t, i, n = "json") {
    return this.fetchHandler(e, "POST", t, i, n);
  }
  get(e, t, i, n = "json") {
    return this.fetchHandler(e, "GET", t, i, n);
  }
  put(e, t, i, n = "json") {
    return this.fetchHandler(e, "PUT", t, i, n);
  }
  delete(e, t, i, n = "json") {
    return this.fetchHandler(e, "DELETE", t, i, n);
  }
};
xr(Tp, "timeout", 5e3);
let yA = Tp;
function KN(r) {
  var c;
  const e = document.getElementById(r);
  if (!e)
    return null;
  const t = (c = e.shadowRoot) == null ? void 0 : c.querySelector(`#${r}`);
  if (!t)
    return null;
  const { width: i, height: n, x: a, y: o } = t.getBoundingClientRect(), { clientHeight: s, clientWidth: l, clientTop: u, clientLeft: h } = window.document.body;
  return {
    ele: {
      width: i,
      height: n,
      x: a,
      y: o,
      element: e
    },
    window: {
      clientHeight: s,
      clientWidth: l,
      clientTop: u,
      clientLeft: h
    }
  };
}
const ls = 10;
window.NsFloatingbox = {
  open(r, e) {
    var E;
    const t = KN(r);
    if (!t)
      return;
    const { clientX: i, clientY: n } = e, { width: a, height: o, x: s, y: l } = t.ele, { clientHeight: u, clientWidth: h, clientTop: c, clientLeft: f } = t.window;
    let d = i - ls, p = n - ls;
    const g = i - ls + a, v = n - ls + o;
    d < f && (d = f + ls), g > h + f && (d = h - a - ls), p < c && (p = c + ls), v > u + c && (p = u - o - ls);
    const { element: O } = t.ele, m = (E = O.shadowRoot) == null ? void 0 : E.querySelector("#" + r);
    m && (m.style.top = `${p}px`, m.style.left = `${d}px`, Zu(() => {
      m.style.opacity = "1";
    }));
  },
  close(r) {
    var n;
    const e = KN(r);
    if (!e)
      return;
    const { element: t } = e.ele, i = (n = t.shadowRoot) == null ? void 0 : n.querySelector("#" + r);
    i && (i.style.opacity = "0", setTimeout(() => {
      i.style.top = "-1000px", i.style.left = "-1000px";
    }, 200));
  }
};
var wv, Xee = new Uint8Array(16);
function RF() {
  if (!wv && (wv = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !wv))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return wv(Xee);
}
const Yee = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function AF(r) {
  return typeof r == "string" && Yee.test(r);
}
var Ur = [];
for (var kT = 0; kT < 256; ++kT)
  Ur.push((kT + 256).toString(16).substr(1));
function vI(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (Ur[r[e + 0]] + Ur[r[e + 1]] + Ur[r[e + 2]] + Ur[r[e + 3]] + "-" + Ur[r[e + 4]] + Ur[r[e + 5]] + "-" + Ur[r[e + 6]] + Ur[r[e + 7]] + "-" + Ur[r[e + 8]] + Ur[r[e + 9]] + "-" + Ur[r[e + 10]] + Ur[r[e + 11]] + Ur[r[e + 12]] + Ur[r[e + 13]] + Ur[r[e + 14]] + Ur[r[e + 15]]).toLowerCase();
  if (!AF(t))
    throw TypeError("Stringified UUID is invalid");
  return t;
}
var JN, QT, UT = 0, $T = 0;
function Hee(r, e, t) {
  var i = e && t || 0, n = e || new Array(16);
  r = r || {};
  var a = r.node || JN, o = r.clockseq !== void 0 ? r.clockseq : QT;
  if (a == null || o == null) {
    var s = r.random || (r.rng || RF)();
    a == null && (a = JN = [s[0] | 1, s[1], s[2], s[3], s[4], s[5]]), o == null && (o = QT = (s[6] << 8 | s[7]) & 16383);
  }
  var l = r.msecs !== void 0 ? r.msecs : Date.now(), u = r.nsecs !== void 0 ? r.nsecs : $T + 1, h = l - UT + (u - $T) / 1e4;
  if (h < 0 && r.clockseq === void 0 && (o = o + 1 & 16383), (h < 0 || l > UT) && r.nsecs === void 0 && (u = 0), u >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  UT = l, $T = u, QT = o, l += 122192928e5;
  var c = ((l & 268435455) * 1e4 + u) % 4294967296;
  n[i++] = c >>> 24 & 255, n[i++] = c >>> 16 & 255, n[i++] = c >>> 8 & 255, n[i++] = c & 255;
  var f = l / 4294967296 * 1e4 & 268435455;
  n[i++] = f >>> 8 & 255, n[i++] = f & 255, n[i++] = f >>> 24 & 15 | 16, n[i++] = f >>> 16 & 255, n[i++] = o >>> 8 | 128, n[i++] = o & 255;
  for (var d = 0; d < 6; ++d)
    n[i + d] = a[d];
  return e || vI(n);
}
function Wee(r) {
  if (!AF(r))
    throw TypeError("Invalid UUID");
  var e, t = new Uint8Array(16);
  return t[0] = (e = parseInt(r.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(r.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(r.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(r.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
function zee(r) {
  r = unescape(encodeURIComponent(r));
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t));
  return e;
}
var Zee = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", qee = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function CF(r, e, t) {
  function i(n, a, o, s) {
    if (typeof n == "string" && (n = zee(n)), typeof a == "string" && (a = Wee(a)), a.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var l = new Uint8Array(16 + n.length);
    if (l.set(a), l.set(n, a.length), l = t(l), l[6] = l[6] & 15 | e, l[8] = l[8] & 63 | 128, o) {
      s = s || 0;
      for (var u = 0; u < 16; ++u)
        o[s + u] = l[u];
      return o;
    }
    return vI(l);
  }
  try {
    i.name = r;
  } catch {
  }
  return i.DNS = Zee, i.URL = qee, i;
}
function jee(r) {
  if (typeof r == "string") {
    var e = unescape(encodeURIComponent(r));
    r = new Uint8Array(e.length);
    for (var t = 0; t < e.length; ++t)
      r[t] = e.charCodeAt(t);
  }
  return Kee(Jee(ete(r), r.length * 8));
}
function Kee(r) {
  for (var e = [], t = r.length * 32, i = "0123456789abcdef", n = 0; n < t; n += 8) {
    var a = r[n >> 5] >>> n % 32 & 255, o = parseInt(i.charAt(a >>> 4 & 15) + i.charAt(a & 15), 16);
    e.push(o);
  }
  return e;
}
function _F(r) {
  return (r + 64 >>> 9 << 4) + 14 + 1;
}
function Jee(r, e) {
  r[e >> 5] |= 128 << e % 32, r[_F(e) - 1] = e;
  for (var t = 1732584193, i = -271733879, n = -1732584194, a = 271733878, o = 0; o < r.length; o += 16) {
    var s = t, l = i, u = n, h = a;
    t = jr(t, i, n, a, r[o], 7, -680876936), a = jr(a, t, i, n, r[o + 1], 12, -389564586), n = jr(n, a, t, i, r[o + 2], 17, 606105819), i = jr(i, n, a, t, r[o + 3], 22, -1044525330), t = jr(t, i, n, a, r[o + 4], 7, -176418897), a = jr(a, t, i, n, r[o + 5], 12, 1200080426), n = jr(n, a, t, i, r[o + 6], 17, -1473231341), i = jr(i, n, a, t, r[o + 7], 22, -45705983), t = jr(t, i, n, a, r[o + 8], 7, 1770035416), a = jr(a, t, i, n, r[o + 9], 12, -1958414417), n = jr(n, a, t, i, r[o + 10], 17, -42063), i = jr(i, n, a, t, r[o + 11], 22, -1990404162), t = jr(t, i, n, a, r[o + 12], 7, 1804603682), a = jr(a, t, i, n, r[o + 13], 12, -40341101), n = jr(n, a, t, i, r[o + 14], 17, -1502002290), i = jr(i, n, a, t, r[o + 15], 22, 1236535329), t = Kr(t, i, n, a, r[o + 1], 5, -165796510), a = Kr(a, t, i, n, r[o + 6], 9, -1069501632), n = Kr(n, a, t, i, r[o + 11], 14, 643717713), i = Kr(i, n, a, t, r[o], 20, -373897302), t = Kr(t, i, n, a, r[o + 5], 5, -701558691), a = Kr(a, t, i, n, r[o + 10], 9, 38016083), n = Kr(n, a, t, i, r[o + 15], 14, -660478335), i = Kr(i, n, a, t, r[o + 4], 20, -405537848), t = Kr(t, i, n, a, r[o + 9], 5, 568446438), a = Kr(a, t, i, n, r[o + 14], 9, -1019803690), n = Kr(n, a, t, i, r[o + 3], 14, -187363961), i = Kr(i, n, a, t, r[o + 8], 20, 1163531501), t = Kr(t, i, n, a, r[o + 13], 5, -1444681467), a = Kr(a, t, i, n, r[o + 2], 9, -51403784), n = Kr(n, a, t, i, r[o + 7], 14, 1735328473), i = Kr(i, n, a, t, r[o + 12], 20, -1926607734), t = Jr(t, i, n, a, r[o + 5], 4, -378558), a = Jr(a, t, i, n, r[o + 8], 11, -2022574463), n = Jr(n, a, t, i, r[o + 11], 16, 1839030562), i = Jr(i, n, a, t, r[o + 14], 23, -35309556), t = Jr(t, i, n, a, r[o + 1], 4, -1530992060), a = Jr(a, t, i, n, r[o + 4], 11, 1272893353), n = Jr(n, a, t, i, r[o + 7], 16, -155497632), i = Jr(i, n, a, t, r[o + 10], 23, -1094730640), t = Jr(t, i, n, a, r[o + 13], 4, 681279174), a = Jr(a, t, i, n, r[o], 11, -358537222), n = Jr(n, a, t, i, r[o + 3], 16, -722521979), i = Jr(i, n, a, t, r[o + 6], 23, 76029189), t = Jr(t, i, n, a, r[o + 9], 4, -640364487), a = Jr(a, t, i, n, r[o + 12], 11, -421815835), n = Jr(n, a, t, i, r[o + 15], 16, 530742520), i = Jr(i, n, a, t, r[o + 2], 23, -995338651), t = ei(t, i, n, a, r[o], 6, -198630844), a = ei(a, t, i, n, r[o + 7], 10, 1126891415), n = ei(n, a, t, i, r[o + 14], 15, -1416354905), i = ei(i, n, a, t, r[o + 5], 21, -57434055), t = ei(t, i, n, a, r[o + 12], 6, 1700485571), a = ei(a, t, i, n, r[o + 3], 10, -1894986606), n = ei(n, a, t, i, r[o + 10], 15, -1051523), i = ei(i, n, a, t, r[o + 1], 21, -2054922799), t = ei(t, i, n, a, r[o + 8], 6, 1873313359), a = ei(a, t, i, n, r[o + 15], 10, -30611744), n = ei(n, a, t, i, r[o + 6], 15, -1560198380), i = ei(i, n, a, t, r[o + 13], 21, 1309151649), t = ei(t, i, n, a, r[o + 4], 6, -145523070), a = ei(a, t, i, n, r[o + 11], 10, -1120210379), n = ei(n, a, t, i, r[o + 2], 15, 718787259), i = ei(i, n, a, t, r[o + 9], 21, -343485551), t = Is(t, s), i = Is(i, l), n = Is(n, u), a = Is(a, h);
  }
  return [t, i, n, a];
}
function ete(r) {
  if (r.length === 0)
    return [];
  for (var e = r.length * 8, t = new Uint32Array(_F(e)), i = 0; i < e; i += 8)
    t[i >> 5] |= (r[i / 8] & 255) << i % 32;
  return t;
}
function Is(r, e) {
  var t = (r & 65535) + (e & 65535), i = (r >> 16) + (e >> 16) + (t >> 16);
  return i << 16 | t & 65535;
}
function tte(r, e) {
  return r << e | r >>> 32 - e;
}
function cS(r, e, t, i, n, a) {
  return Is(tte(Is(Is(e, r), Is(i, a)), n), t);
}
function jr(r, e, t, i, n, a, o) {
  return cS(e & t | ~e & i, r, e, n, a, o);
}
function Kr(r, e, t, i, n, a, o) {
  return cS(e & i | t & ~i, r, e, n, a, o);
}
function Jr(r, e, t, i, n, a, o) {
  return cS(e ^ t ^ i, r, e, n, a, o);
}
function ei(r, e, t, i, n, a, o) {
  return cS(t ^ (e | ~i), r, e, n, a, o);
}
var rte = CF("v3", 48, jee);
const ite = rte;
function nte(r, e, t) {
  r = r || {};
  var i = r.random || (r.rng || RF)();
  if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, e) {
    t = t || 0;
    for (var n = 0; n < 16; ++n)
      e[t + n] = i[n];
    return e;
  }
  return vI(i);
}
function ate(r, e, t, i) {
  switch (r) {
    case 0:
      return e & t ^ ~e & i;
    case 1:
      return e ^ t ^ i;
    case 2:
      return e & t ^ e & i ^ t & i;
    case 3:
      return e ^ t ^ i;
  }
}
function GT(r, e) {
  return r << e | r >>> 32 - e;
}
function ote(r) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782], t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof r == "string") {
    var i = unescape(encodeURIComponent(r));
    r = [];
    for (var n = 0; n < i.length; ++n)
      r.push(i.charCodeAt(n));
  } else
    Array.isArray(r) || (r = Array.prototype.slice.call(r));
  r.push(128);
  for (var a = r.length / 4 + 2, o = Math.ceil(a / 16), s = new Array(o), l = 0; l < o; ++l) {
    for (var u = new Uint32Array(16), h = 0; h < 16; ++h)
      u[h] = r[l * 64 + h * 4] << 24 | r[l * 64 + h * 4 + 1] << 16 | r[l * 64 + h * 4 + 2] << 8 | r[l * 64 + h * 4 + 3];
    s[l] = u;
  }
  s[o - 1][14] = (r.length - 1) * 8 / Math.pow(2, 32), s[o - 1][14] = Math.floor(s[o - 1][14]), s[o - 1][15] = (r.length - 1) * 8 & 4294967295;
  for (var c = 0; c < o; ++c) {
    for (var f = new Uint32Array(80), d = 0; d < 16; ++d)
      f[d] = s[c][d];
    for (var p = 16; p < 80; ++p)
      f[p] = GT(f[p - 3] ^ f[p - 8] ^ f[p - 14] ^ f[p - 16], 1);
    for (var g = t[0], v = t[1], O = t[2], m = t[3], E = t[4], b = 0; b < 80; ++b) {
      var T = Math.floor(b / 20), S = GT(g, 5) + ate(T, v, O, m) + E + e[T] + f[b] >>> 0;
      E = m, m = O, O = GT(v, 30) >>> 0, v = g, g = S;
    }
    t[0] = t[0] + g >>> 0, t[1] = t[1] + v >>> 0, t[2] = t[2] + O >>> 0, t[3] = t[3] + m >>> 0, t[4] = t[4] + E >>> 0;
  }
  return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255];
}
var ste = CF("v5", 80, ote);
const lte = ste;
var lE = {
  v1: Hee,
  v3: ite,
  v4: nte,
  v5: lte
};
const ute = { class: "ns-sandbox-box" }, hte = ["src", "id", "name", "sandbox"], cte = /* @__PURE__ */ xi({
  __name: "sandbox",
  props: {
    url: {
      type: String,
      default: ""
    },
    limit: {
      // , 
      type: String,
      default: "allow-same-origin allow-scripts allow-forms"
    }
  },
  emits: ["name", "loaded", "change"],
  setup(r, { expose: e, emit: t }) {
    const i = r, n = Sr(), a = Sr(lE.v4()), o = Sr(!1), s = Sr(), l = Sr(!0);
    function u() {
      if (!n.value) {
        setTimeout(() => {
          u();
        }, 100);
        return;
      }
      n.value.onload = function(f) {
        Zu(() => {
          t("loaded", i.url);
        });
      };
    }
    function h(f, d) {
      !o.value || !s.value || s.value.on(f, d);
    }
    function c(f, d) {
      return !o.value || !s.value ? Promise.reject() : s.value.send(f, d);
    }
    return Vn(() => i.url, (f, d) => {
      f && (d || (l.value = !1, Zu(() => {
        l.value = !0;
      })));
    }, {
      immediate: !0
    }), po(() => {
      u(), t("name", a.value);
    }), e({
      on: h,
      send: c
    }), (f, d) => (Tt(), ir("div", ute, [
      r.url && l.value ? (Tt(), ir("iframe", {
        key: 0,
        src: r.url,
        id: a.value,
        name: a.value,
        ref_key: "RefIframeBox",
        ref: n,
        sandbox: r.limit.toLocaleLowerCase() === "all" ? "" : r.limit
      }, null, 8, hte)) : ln("", !0)
    ]));
  }
}), fte = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box;padding:0}.ns-sandbox-box{width:100%;height:100%;overflow:hidden;box-sizing:border-box;padding:0}.ns-sandbox-box iframe{width:100%;height:100%;overflow:hidden;border:0;padding:0}
`, go = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [i, n] of e)
    t[i] = n;
  return t;
}, dte = /* @__PURE__ */ go(cte, [["styles", [fte]]]), pte = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: !1,
    panes: [],
    touch: {
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null
    },
    splitterTaps: {
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    // Indexed panes by `uid` of Pane components for fast lookup.
    // Every time a pane is destroyed this index is recomputed.
    indexedPanes() {
      return this.panes.reduce((r, e) => (r[e.id] = e) && r, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((r) => {
        r.update && r.update({
          // Panes are indexed by Pane component uid, as they might be inserted at different index.
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[r.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(r, e) {
      this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = e;
    },
    onMouseMove(r) {
      this.touch.mouseDown && (r.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(r)), this.$emit("resize", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((r) => ({ min: r.min, max: r.max, size: r.size }))), this.touch.mouseDown = !1, setTimeout(() => {
        this.touch.dragging = !1, this.unbindEvents();
      }, 100);
    },
    // If touch device, detect double tap manually (2 taps separated by less than 500ms).
    onSplitterClick(r, e) {
      "ontouchstart" in window && (r.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === e ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(r, e), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = e, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[e]);
    },
    // On splitter dbl click or dbl tap maximize this pane.
    onSplitterDblClick(r, e) {
      let t = 0;
      this.panes = this.panes.map((i, n) => (i.size = n === e ? i.max : i.min, n !== e && (t += i.min), i)), this.panes[e].size -= t, this.$emit("pane-maximize", this.panes[e]), this.$emit("resized", this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })));
    },
    onPaneClick(r, e) {
      this.$emit("pane-click", this.indexedPanes[e]);
    },
    // Get the cursor position relative to the splitpane container.
    getCurrentMouseDrag(r) {
      const e = this.container.getBoundingClientRect(), { clientX: t, clientY: i } = "ontouchstart" in window && r.touches ? r.touches[0] : r;
      return {
        x: t - e.left,
        y: i - e.top
      };
    },
    // Returns the drag percentage of the splitter relative to the 2 panes it's inbetween.
    // if the sum of size of the 2 cells is 60%, the dragPercentage range will be 0 to 100% of this 60%.
    getCurrentDragPercentage(r) {
      r = r[this.horizontal ? "y" : "x"];
      const e = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (r = e - r), r * 100 / e;
    },
    calculatePanesSize(r) {
      const e = this.touch.activeSplitter;
      let t = {
        prevPanesSize: this.sumPrevPanesSize(e),
        nextPanesSize: this.sumNextPanesSize(e),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const i = 0 + (this.pushOtherPanes ? 0 : t.prevPanesSize), n = 100 - (this.pushOtherPanes ? 0 : t.nextPanesSize), a = Math.max(Math.min(this.getCurrentDragPercentage(r), n), i);
      let o = [e, e + 1], s = this.panes[o[0]] || null, l = this.panes[o[1]] || null;
      const u = s.max < 100 && a >= s.max + t.prevPanesSize, h = l.max < 100 && a <= 100 - (l.max + this.sumNextPanesSize(e + 1));
      if (u || h) {
        u ? (s.size = s.max, l.size = Math.max(100 - s.max - t.prevPanesSize - t.nextPanesSize, 0)) : (s.size = Math.max(100 - l.max - t.prevPanesSize - this.sumNextPanesSize(e + 1), 0), l.size = l.max);
        return;
      }
      if (this.pushOtherPanes) {
        const c = this.doPushOtherPanes(t, a);
        if (!c)
          return;
        ({ sums: t, panesToResize: o } = c), s = this.panes[o[0]] || null, l = this.panes[o[1]] || null;
      }
      s !== null && (s.size = Math.min(Math.max(a - t.prevPanesSize - t.prevReachedMinPanes, s.min), s.max)), l !== null && (l.size = Math.min(Math.max(100 - a - t.nextPanesSize - t.nextReachedMinPanes, l.min), l.max));
    },
    doPushOtherPanes(r, e) {
      const t = this.touch.activeSplitter, i = [t, t + 1];
      return e < r.prevPanesSize + this.panes[i[0]].min && (i[0] = this.findPrevExpandedPane(t).index, r.prevReachedMinPanes = 0, i[0] < t && this.panes.forEach((n, a) => {
        a > i[0] && a <= t && (n.size = n.min, r.prevReachedMinPanes += n.min);
      }), r.prevPanesSize = this.sumPrevPanesSize(i[0]), i[0] === void 0) ? (r.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((n, a) => {
        a > 0 && a <= t && (n.size = n.min, r.prevReachedMinPanes += n.min);
      }), this.panes[i[1]].size = 100 - r.prevReachedMinPanes - this.panes[0].min - r.prevPanesSize - r.nextPanesSize, null) : e > 100 - r.nextPanesSize - this.panes[i[1]].min && (i[1] = this.findNextExpandedPane(t).index, r.nextReachedMinPanes = 0, i[1] > t + 1 && this.panes.forEach((n, a) => {
        a > t && a < i[1] && (n.size = n.min, r.nextReachedMinPanes += n.min);
      }), r.nextPanesSize = this.sumNextPanesSize(i[1] - 1), i[1] === void 0) ? (r.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((n, a) => {
        a < this.panesCount - 1 && a >= t + 1 && (n.size = n.min, r.nextReachedMinPanes += n.min);
      }), this.panes[i[0]].size = 100 - r.prevPanesSize - r.nextReachedMinPanes - this.panes[this.panesCount - 1].min - r.nextPanesSize, null) : { sums: r, panesToResize: i };
    },
    sumPrevPanesSize(r) {
      return this.panes.reduce((e, t, i) => e + (i < r ? t.size : 0), 0);
    },
    sumNextPanesSize(r) {
      return this.panes.reduce((e, t, i) => e + (i > r + 1 ? t.size : 0), 0);
    },
    // Return the previous pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findPrevExpandedPane(r) {
      return [...this.panes].reverse().find((t) => t.index < r && t.size > t.min) || {};
    },
    // Return the next pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findNextExpandedPane(r) {
      return this.panes.find((t) => t.index > r + 1 && t.size > t.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((e) => {
        const t = e.classList.contains("splitpanes__pane"), i = e.classList.contains("splitpanes__splitter");
        !t && !i && console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed.");
      });
    },
    addSplitter(r, e, t = !1) {
      const i = r - 1, n = document.createElement("div");
      n.classList.add("splitpanes__splitter"), t || (n.onmousedown = (a) => this.onMouseDown(a, i), typeof window < "u" && "ontouchstart" in window && (n.ontouchstart = (a) => this.onMouseDown(a, i)), n.onclick = (a) => this.onSplitterClick(a, i + 1)), this.dblClickSplitter && (n.ondblclick = (a) => this.onSplitterDblClick(a, i + 1)), e.parentNode.insertBefore(n, e);
    },
    removeSplitter(r) {
      r.onmousedown = void 0, r.onclick = void 0, r.ondblclick = void 0, r.parentNode.removeChild(r);
    },
    redoSplitters() {
      const r = Array.from(this.container.children);
      r.forEach((t) => {
        t.className.includes("splitpanes__splitter") && this.removeSplitter(t);
      });
      let e = 0;
      r.forEach((t) => {
        t.className.includes("splitpanes__pane") && (!e && this.firstSplitter ? this.addSplitter(e, t, !0) : e && this.addSplitter(e, t), e++);
      });
    },
    // Called by Pane component on programmatic resize.
    requestUpdate({ target: r, ...e }) {
      const t = this.indexedPanes[r._.uid];
      Object.entries(e).forEach(([i, n]) => t[i] = n);
    },
    onPaneAdd(r) {
      let e = -1;
      Array.from(r.$el.parentNode.children).some((n) => (n.className.includes("splitpanes__pane") && e++, n === r.$el));
      const t = parseFloat(r.minSize), i = parseFloat(r.maxSize);
      this.panes.splice(e, 0, {
        id: r._.uid,
        index: e,
        min: isNaN(t) ? 0 : t,
        max: isNaN(i) ? 100 : i,
        size: r.size === null ? null : parseFloat(r.size),
        givenSize: r.size,
        update: r.update
      }), this.panes.forEach((n, a) => n.index = a), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[e] }), this.$emit("pane-add", { index: e, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
      });
    },
    onPaneRemove(r) {
      const e = this.panes.findIndex((i) => i.id === r._.uid), t = this.panes.splice(e, 1)[0];
      this.panes.forEach((i, n) => i.index = n), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...t, index: e } }), this.$emit("pane-remove", { removed: t, panes: this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })) });
      });
    },
    resetPaneSizes(r = {}) {
      !r.addedPane && !r.removedPane ? this.initialPanesSizing() : this.panes.some((e) => e.givenSize !== null || e.min || e.max < 100) ? this.equalizeAfterAddOrRemove(r) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size })));
    },
    equalize() {
      const r = 100 / this.panesCount;
      let e = 0;
      const t = [], i = [];
      this.panes.forEach((n) => {
        n.size = Math.max(Math.min(r, n.max), n.min), e -= n.size, n.size >= n.max && t.push(n.id), n.size <= n.min && i.push(n.id);
      }), e > 0.1 && this.readjustSizes(e, t, i);
    },
    initialPanesSizing() {
      let r = 100;
      const e = [], t = [];
      let i = 0;
      this.panes.forEach((a) => {
        r -= a.size, a.size !== null && i++, a.size >= a.max && e.push(a.id), a.size <= a.min && t.push(a.id);
      });
      let n = 100;
      r > 0.1 && (this.panes.forEach((a) => {
        a.size === null && (a.size = Math.max(Math.min(r / (this.panesCount - i), a.max), a.min)), n -= a.size;
      }), n > 0.1 && this.readjustSizes(r, e, t));
    },
    equalizeAfterAddOrRemove({ addedPane: r, removedPane: e } = {}) {
      let t = 100 / this.panesCount, i = 0;
      const n = [], a = [];
      r && r.givenSize !== null && (t = (100 - r.givenSize) / (this.panesCount - 1)), this.panes.forEach((o) => {
        i -= o.size, o.size >= o.max && n.push(o.id), o.size <= o.min && a.push(o.id);
      }), !(Math.abs(i) < 0.1) && (this.panes.forEach((o) => {
        r && r.givenSize !== null && r.id === o.id || (o.size = Math.max(Math.min(t, o.max), o.min)), i -= o.size, o.size >= o.max && n.push(o.id), o.size <= o.min && a.push(o.id);
      }), i > 0.1 && this.readjustSizes(i, n, a));
    },
    /* recalculatePaneSizes ({ addedPane, removedPane } = {}) {
          let leftToAllocate = 100
          let equalSpaceToAllocate = leftToAllocate / this.panesCount
          let ungrowable = []
          let unshrinkable = []
    
          // When adding a pane with no size, apply min-size if defined otherwise divide another pane
          // (next or prev) in 2.
          // if (addedPane && addedPane.size === null) {
          //   if (addedPane.min) addedPane.size = addedPane.min
          //   else {
          //     const paneToDivide = this.panes[addedPane.index + 1] || this.panes[addedPane.index - 1]
          //     if (paneToDivide) {
          //       // @todo: Dividing that pane in 2 could be incorrect if becoming lower than its min size.
          //       addedPane.size = paneToDivide.size / 2
          //       paneToDivide.size /= 2
          //     }
          //   }
          // }
    
          this.panes.forEach((pane, i) => {
            // Added pane - reduce the size of the next pane.
            if (addedPane && addedPane.index + 1 === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Removed pane - increase the size of the next pane.
            else if (removedPane && removedPane.index === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Initial load and on demand recalculation.
            else if (!addedPane && !removedPane && pane.size === null) {
              pane.size = Math.max(Math.min(equalSpaceToAllocate, pane.max), pane.min)
            }
    
            leftToAllocate -= pane.size
    
            if (pane.size >= pane.max) ungrowable.push(pane.id)
            if (pane.size <= pane.min) unshrinkable.push(pane.id)
          })
    
          // Do one more loop to adjust sizes if still wrong.
          // > 0.1: Prevent maths rounding issues due to bytes.
          if (Math.abs(leftToAllocate) > 0.1) this.readjustSizes(leftToAllocate, ungrowable, unshrinkable)
        }, */
    // Second loop to adjust sizes now that we know more about the panes constraints.
    readjustSizes(r, e, t) {
      let i;
      r > 0 ? i = r / (this.panesCount - e.length) : i = r / (this.panesCount - t.length), this.panes.forEach((n, a) => {
        if (r > 0 && !e.includes(n.id)) {
          const o = Math.max(Math.min(n.size + i, n.max), n.min), s = o - n.size;
          r -= s, n.size = o;
        } else if (!t.includes(n.id)) {
          const o = Math.max(Math.min(n.size + i, n.max), n.min), s = o - n.size;
          r -= s, n.size = o;
        }
        n.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[n.id].size}%`
        });
      }), Math.abs(r) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
    /* distributeEmptySpace () {
          let growablePanes = []
          let collapsedPanesCount = 0
          let growableAmount = 0 // Total of how much the current panes can grow to fill blank space.
          let spaceToDistribute = 100 - this.panes.reduce((sum, pane) => (sum += pane.size) && sum, 0)
          // Do a first loop to determine if we can distribute the new blank space between all the
          // expandedPanes, without expanding the collapsed ones.
          this.panes.forEach(pane => {
            if (pane.size < pane.max) growablePanes.push(pane)
    
            if (!pane.size) collapsedPanesCount++
            else growableAmount += pane.max - pane.size
          })
    
          // If the blank space to distribute is too great for the expanded panes, also expand collapsed ones.
          let expandCollapsedPanes = growableAmount < spaceToDistribute
    
          // New space to distribute equally.
          let growablePanesCount = (growablePanes.length - (expandCollapsedPanes ? 0 : collapsedPanesCount))
          let equalSpaceToDistribute = spaceToDistribute / growablePanesCount
          // if (growablePanesCount === 1) equalSpace = 100 / this.panesCount
          let spaceLeftToDistribute = spaceToDistribute
    
          // Now add the equalSpaceToDistribute to each pane size accordingly.
          growablePanes.forEach(pane => {
            if (pane.size < pane.max && (pane.size || (!pane.size && expandCollapsedPanes))) {
              const newSize = Math.min(pane.size + equalSpaceToDistribute, pane.max)
              let allocatedSpace = (newSize - pane.size)
              spaceLeftToDistribute -= allocatedSpace
              pane.size = newSize
              // If the equalSpaceToDistribute is not fully added to the current pane, distribute the remainder
              // to the next panes.
              // Also fix decimal issue due to bites - E.g. calculating 8.33 and getting 8.3299999999999
              if (equalSpaceToDistribute - allocatedSpace > 0.1) equalSpaceToDistribute = spaceLeftToDistribute / (--growablePanesCount)
            }
          })
    
          /* Disabled otherwise will show up on hot reload.
          // if there is still space to allocate show warning message.
          if (this.panesCount && ~~spaceLeftToDistribute) {
            // eslint-disable-next-line no-console
            console.warn('Splitpanes: Could not distribute all the empty space between panes due to their constraints.')
          } *\/
    
          this.$emit('resized', this.panes.map(pane => ({ min: pane.min, max: pane.max, size: pane.size })))
        } */
  },
  watch: {
    panes: {
      // Every time a pane is updated, update the panes accordingly.
      deep: !0,
      immediate: !1,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(r) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((t, i) => {
        t.ondblclick = r ? (n) => this.onSplitterDblClick(n, i) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = !1;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = !0;
  },
  render() {
    return Sl(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          "default-theme",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
}, gte = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    // Called from the splitpanes component.
    update(r) {
      this.style = r;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(r) {
      this.requestUpdate({ target: this, size: r });
    },
    minSizeNumber(r) {
      this.requestUpdate({ target: this, min: r });
    },
    maxSizeNumber(r) {
      this.requestUpdate({ target: this, max: r });
    }
  }
};
function vte(r, e, t, i, n, a) {
  return Tt(), ir("div", {
    class: "splitpanes__pane",
    onClick: e[0] || (e[0] = (o) => a.onPaneClick(o, r._.uid)),
    style: Wn(r.style)
  }, [
    oi(r.$slots, "default")
  ], 4);
}
const Ote = /* @__PURE__ */ go(gte, [["render", vte]]), mte = { class: "pane-box" }, Ete = /* @__PURE__ */ xi({
  __name: "splitpane",
  props: {
    keys: {
      type: Array,
      default: () => []
    },
    size: {
      type: Array,
      default: () => [25, 25, 25, 25]
    },
    minSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    maxSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  setup(r, { emit: e }) {
    return (t, i) => (Tt(), la(pte, {
      onReady: i[0] || (i[0] = (n) => e("ready", n)),
      onResize: i[1] || (i[1] = (n) => e("resize", n)),
      onResized: i[2] || (i[2] = (n) => e("resized", n)),
      onPaneClick: i[3] || (i[3] = (n) => e("pane-click", n)),
      onPaneMaximize: i[4] || (i[4] = (n) => e("pane-maximize", n)),
      onPaneAdd: i[5] || (i[5] = (n) => e("pane-add", n)),
      onPaneRemove: i[6] || (i[6] = (n) => e("pane-remove", n)),
      onSplitterClick: i[7] || (i[7] = (n) => e("splitter-click", n)),
      horizontal: r.horizontal,
      pushOtherPanes: r.pushOtherPanes,
      dblClickSplitter: r.dblClickSplitter,
      rtl: r.rtl,
      firstSplitter: r.firstSplitter
    }, {
      default: Ip(() => [
        (Tt(!0), ir(Nr, null, HV(r.keys, (n, a) => (Tt(), la(Ote, {
          size: r.size[a] ? r.size[a] : 10,
          "min-size": r.minSize[a] ? r.minSize[a] : 0,
          "max-size": r.maxSize[a] ? r.maxSize[a] : 100
        }, {
          default: Ip(() => [
            dt("div", mte, [
              oi(t.$slots, n)
            ])
          ]),
          _: 2
        }, 1032, ["size", "min-size", "max-size"]))), 256))
      ]),
      _: 3
    }, 8, ["horizontal", "pushOtherPanes", "dblClickSplitter", "rtl", "firstSplitter"]));
  }
}), bte = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.splitpanes{display:flex;width:100%;height:100%}.splitpanes--vertical{flex-direction:row}.splitpanes--horizontal{flex-direction:column}.splitpanes--dragging *{-webkit-user-select:none;user-select:none}.splitpanes__pane{width:100%;height:100%;overflow:hidden}.splitpanes--vertical .splitpanes__pane{transition:width .2s ease-out}.splitpanes--horizontal .splitpanes__pane{transition:height .2s ease-out}.splitpanes--dragging .splitpanes__pane{transition:none}.splitpanes__splitter{touch-action:none}.splitpanes--vertical>.splitpanes__splitter{min-width:1px;cursor:col-resize}.splitpanes--horizontal>.splitpanes__splitter{min-height:1px;cursor:row-resize}.splitpanes.default-theme .splitpanes__pane{background-color:#f2f2f2}.splitpanes.default-theme .splitpanes__splitter{background-color:#fff;box-sizing:border-box;position:relative;flex-shrink:0}.splitpanes.default-theme .splitpanes__splitter:before,.splitpanes.default-theme .splitpanes__splitter:after{content:"";position:absolute;top:50%;left:50%;background-color:#00000026;transition:background-color .3s}.splitpanes.default-theme .splitpanes__splitter:hover:before,.splitpanes.default-theme .splitpanes__splitter:hover:after{background-color:#00000040}.splitpanes.default-theme .splitpanes__splitter:first-child{cursor:auto}.default-theme.splitpanes .splitpanes .splitpanes__splitter{z-index:1}.default-theme.splitpanes--vertical>.splitpanes__splitter,.default-theme .splitpanes--vertical>.splitpanes__splitter{width:7px;border-left:1px solid #eee;margin-left:-1px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{transform:translateY(-50%);width:1px;height:30px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:before{margin-left:-2px}.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{margin-left:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter,.default-theme .splitpanes--horizontal>.splitpanes__splitter{height:7px;border-top:1px solid #eee;margin-top:-1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{transform:translate(-50%);width:30px;height:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before{margin-top:-2px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{margin-top:1px}
`, Ste = `.pane-box{height:100%;width:100%;background-color:#fff;box-sizing:border-box;overflow:hidden;overflow-y:auto;overflow-x:auto;border-radius:4px}.splitpanes__splitter{background-color:#f0f0f0!important}
`, Tte = /* @__PURE__ */ go(Ete, [["styles", [bte, Ste]]]);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var RA = function(r, e) {
  return RA = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
  }, RA(r, e);
};
function U(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  RA(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var yte = function() {
  function r() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return r;
}(), Rte = function() {
  function r() {
    this.browser = new yte(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return r;
}(), ru = new Rte();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (ru.wxa = !0, ru.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? ru.worker = !0 : typeof navigator > "u" ? (ru.node = !0, ru.svgSupported = !0) : Ate(navigator.userAgent, ru);
function Ate(r, e) {
  var t = e.browser, i = r.match(/Firefox\/([\d.]+)/), n = r.match(/MSIE\s([\d.]+)/) || r.match(/Trident\/.+?rv:(([\d.]+))/), a = r.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(r);
  i && (t.firefox = !0, t.version = i[1]), n && (t.ie = !0, t.version = n[1]), a && (t.edge = !0, t.version = a[1], t.newEdge = +a[1].split(".")[0] > 18), o && (t.weChat = !0), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u";
  var s = document.documentElement.style;
  e.transform3dSupported = (t.ie && "transition" in s || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9;
}
const st = ru;
var OI = 12, IF = "sans-serif", rl = OI + "px " + IF, Cte = 20, _te = 100, Ite = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function xte(r) {
  var e = {};
  if (typeof JSON > "u")
    return e;
  for (var t = 0; t < r.length; t++) {
    var i = String.fromCharCode(t + 32), n = (r.charCodeAt(t) - Cte) / _te;
    e[i] = n;
  }
  return e;
}
var wte = xte(Ite), il = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: function() {
    var r, e;
    return function(t, i) {
      if (!r) {
        var n = il.createCanvas();
        r = n && n.getContext("2d");
      }
      if (r)
        return e !== i && (e = r.font = i || rl), r.measureText(t);
      t = t || "", i = i || rl;
      var a = /(\d+)px/.exec(i), o = a && +a[1] || OI, s = 0;
      if (i.indexOf("mono") >= 0)
        s = o * t.length;
      else
        for (var l = 0; l < t.length; l++) {
          var u = wte[t[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  }(),
  loadImage: function(r, e, t) {
    var i = new Image();
    return i.onload = e, i.onerror = t, i.src = r, i;
  }
}, xF = no([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(r, e) {
  return r["[object " + e + "]"] = !0, r;
}, {}), wF = no([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(r, e) {
  return r["[object " + e + "Array]"] = !0, r;
}, {}), Of = Object.prototype.toString, fS = Array.prototype, Pte = fS.forEach, Nte = fS.filter, mI = fS.slice, Lte = fS.map, eL = (function() {
}).constructor, Pv = eL ? eL.prototype : null, EI = "__proto__", Dte = 2311;
function PF() {
  return Dte++;
}
function bI() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  typeof console < "u" && console.error.apply(console, r);
}
function Se(r) {
  if (r == null || typeof r != "object")
    return r;
  var e = r, t = Of.call(r);
  if (t === "[object Array]") {
    if (!rp(r)) {
      e = [];
      for (var i = 0, n = r.length; i < n; i++)
        e[i] = Se(r[i]);
    }
  } else if (wF[t]) {
    if (!rp(r)) {
      var a = r.constructor;
      if (a.from)
        e = a.from(r);
      else {
        e = new a(r.length);
        for (var i = 0, n = r.length; i < n; i++)
          e[i] = r[i];
      }
    }
  } else if (!xF[t] && !rp(r) && !Up(r)) {
    e = {};
    for (var o in r)
      r.hasOwnProperty(o) && o !== EI && (e[o] = Se(r[o]));
  }
  return e;
}
function Qe(r, e, t) {
  if (!be(e) || !be(r))
    return t ? Se(e) : r;
  for (var i in e)
    if (e.hasOwnProperty(i) && i !== EI) {
      var n = r[i], a = e[i];
      be(a) && be(n) && !X(a) && !X(n) && !Up(a) && !Up(n) && !tL(a) && !tL(n) && !rp(a) && !rp(n) ? Qe(n, a, t) : (t || !(i in r)) && (r[i] = Se(e[i]));
    }
  return r;
}
function SI(r, e) {
  for (var t = r[0], i = 1, n = r.length; i < n; i++)
    t = Qe(t, r[i], e);
  return t;
}
function V(r, e) {
  if (Object.assign)
    Object.assign(r, e);
  else
    for (var t in e)
      e.hasOwnProperty(t) && t !== EI && (r[t] = e[t]);
  return r;
}
function me(r, e, t) {
  for (var i = He(e), n = 0; n < i.length; n++) {
    var a = i[n];
    (t ? e[a] != null : r[a] == null) && (r[a] = e[a]);
  }
  return r;
}
function Ge(r, e) {
  if (r) {
    if (r.indexOf)
      return r.indexOf(e);
    for (var t = 0, i = r.length; t < i; t++)
      if (r[t] === e)
        return t;
  }
  return -1;
}
function Mte(r, e) {
  var t = r.prototype;
  function i() {
  }
  i.prototype = e.prototype, r.prototype = new i();
  for (var n in t)
    t.hasOwnProperty(n) && (r.prototype[n] = t[n]);
  r.prototype.constructor = r, r.superClass = e;
}
function hr(r, e, t) {
  if (r = "prototype" in r ? r.prototype : r, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames)
    for (var i = Object.getOwnPropertyNames(e), n = 0; n < i.length; n++) {
      var a = i[n];
      a !== "constructor" && (t ? e[a] != null : r[a] == null) && (r[a] = e[a]);
    }
  else
    me(r, e, t);
}
function ci(r) {
  return !r || typeof r == "string" ? !1 : typeof r.length == "number";
}
function w(r, e, t) {
  if (r && e)
    if (r.forEach && r.forEach === Pte)
      r.forEach(e, t);
    else if (r.length === +r.length)
      for (var i = 0, n = r.length; i < n; i++)
        e.call(t, r[i], i, r);
    else
      for (var a in r)
        r.hasOwnProperty(a) && e.call(t, r[a], a, r);
}
function Y(r, e, t) {
  if (!r)
    return [];
  if (!e)
    return TI(r);
  if (r.map && r.map === Lte)
    return r.map(e, t);
  for (var i = [], n = 0, a = r.length; n < a; n++)
    i.push(e.call(t, r[n], n, r));
  return i;
}
function no(r, e, t, i) {
  if (r && e) {
    for (var n = 0, a = r.length; n < a; n++)
      t = e.call(i, t, r[n], n, r);
    return t;
  }
}
function yt(r, e, t) {
  if (!r)
    return [];
  if (!e)
    return TI(r);
  if (r.filter && r.filter === Nte)
    return r.filter(e, t);
  for (var i = [], n = 0, a = r.length; n < a; n++)
    e.call(t, r[n], n, r) && i.push(r[n]);
  return i;
}
function kte(r, e, t) {
  if (r && e) {
    for (var i = 0, n = r.length; i < n; i++)
      if (e.call(t, r[i], i, r))
        return r[i];
  }
}
function He(r) {
  if (!r)
    return [];
  if (Object.keys)
    return Object.keys(r);
  var e = [];
  for (var t in r)
    r.hasOwnProperty(t) && e.push(t);
  return e;
}
function Qte(r, e) {
  for (var t = [], i = 2; i < arguments.length; i++)
    t[i - 2] = arguments[i];
  return function() {
    return r.apply(e, t.concat(mI.call(arguments)));
  };
}
var ae = Pv && ve(Pv.bind) ? Pv.call.bind(Pv.bind) : Qte;
function Ie(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return function() {
    return r.apply(this, e.concat(mI.call(arguments)));
  };
}
function X(r) {
  return Array.isArray ? Array.isArray(r) : Of.call(r) === "[object Array]";
}
function ve(r) {
  return typeof r == "function";
}
function ne(r) {
  return typeof r == "string";
}
function AA(r) {
  return Of.call(r) === "[object String]";
}
function ut(r) {
  return typeof r == "number";
}
function be(r) {
  var e = typeof r;
  return e === "function" || !!r && e === "object";
}
function tL(r) {
  return !!xF[Of.call(r)];
}
function vn(r) {
  return !!wF[Of.call(r)];
}
function Up(r) {
  return typeof r == "object" && typeof r.nodeType == "number" && typeof r.ownerDocument == "object";
}
function dS(r) {
  return r.colorStops != null;
}
function Ute(r) {
  return r.image != null;
}
function $te(r) {
  return Of.call(r) === "[object RegExp]";
}
function $p(r) {
  return r !== r;
}
function Dr() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  for (var t = 0, i = r.length; t < i; t++)
    if (r[t] != null)
      return r[t];
}
function ke(r, e) {
  return r ?? e;
}
function Ka(r, e, t) {
  return r ?? e ?? t;
}
function TI(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return mI.apply(r, e);
}
function yI(r) {
  if (typeof r == "number")
    return [r, r, r, r];
  var e = r.length;
  return e === 2 ? [r[0], r[1], r[0], r[1]] : e === 3 ? [r[0], r[1], r[2], r[1]] : r;
}
function _i(r, e) {
  if (!r)
    throw new Error(e);
}
function ha(r) {
  return r == null ? null : typeof r.trim == "function" ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var NF = "__ec_primitive__";
function uE(r) {
  r[NF] = !0;
}
function rp(r) {
  return r[NF];
}
var Gte = function() {
  function r() {
    this.data = {};
  }
  return r.prototype.delete = function(e) {
    var t = this.has(e);
    return t && delete this.data[e], t;
  }, r.prototype.has = function(e) {
    return this.data.hasOwnProperty(e);
  }, r.prototype.get = function(e) {
    return this.data[e];
  }, r.prototype.set = function(e, t) {
    return this.data[e] = t, this;
  }, r.prototype.keys = function() {
    return He(this.data);
  }, r.prototype.forEach = function(e) {
    var t = this.data;
    for (var i in t)
      t.hasOwnProperty(i) && e(t[i], i);
  }, r;
}(), LF = typeof Map == "function";
function Bte() {
  return LF ? /* @__PURE__ */ new Map() : new Gte();
}
var Vte = function() {
  function r(e) {
    var t = X(e);
    this.data = Bte();
    var i = this;
    e instanceof r ? e.each(n) : e && w(e, n);
    function n(a, o) {
      t ? i.set(a, o) : i.set(o, a);
    }
  }
  return r.prototype.hasKey = function(e) {
    return this.data.has(e);
  }, r.prototype.get = function(e) {
    return this.data.get(e);
  }, r.prototype.set = function(e, t) {
    return this.data.set(e, t), t;
  }, r.prototype.each = function(e, t) {
    this.data.forEach(function(i, n) {
      e.call(t, i, n);
    });
  }, r.prototype.keys = function() {
    var e = this.data.keys();
    return LF ? Array.from(e) : e;
  }, r.prototype.removeKey = function(e) {
    this.data.delete(e);
  }, r;
}();
function ce(r) {
  return new Vte(r);
}
function hE(r, e) {
  for (var t = new r.constructor(r.length + e.length), i = 0; i < r.length; i++)
    t[i] = r[i];
  for (var n = r.length, i = 0; i < e.length; i++)
    t[i + n] = e[i];
  return t;
}
function pS(r, e) {
  var t;
  if (Object.create)
    t = Object.create(r);
  else {
    var i = function() {
    };
    i.prototype = r, t = new i();
  }
  return e && V(t, e), t;
}
function DF(r) {
  var e = r.style;
  e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
}
function oe(r, e) {
  return r.hasOwnProperty(e);
}
function ar() {
}
var lm = 180 / Math.PI;
function Eh(r, e) {
  return r == null && (r = 0), e == null && (e = 0), [r, e];
}
function Oi(r, e) {
  return r[0] = e[0], r[1] = e[1], r;
}
function Do(r) {
  return [r[0], r[1]];
}
function Fte(r, e, t) {
  return r[0] = e, r[1] = t, r;
}
function rL(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function CA(r, e, t, i) {
  return r[0] = e[0] + t[0] * i, r[1] = e[1] + t[1] * i, r;
}
function bu(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r;
}
function _A(r) {
  return Math.sqrt(Xte(r));
}
function Xte(r) {
  return r[0] * r[0] + r[1] * r[1];
}
function um(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r;
}
function mf(r, e) {
  var t = _A(e);
  return t === 0 ? (r[0] = 0, r[1] = 0) : (r[0] = e[0] / t, r[1] = e[1] / t), r;
}
function IA(r, e) {
  return Math.sqrt((r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]));
}
var xs = IA;
function Yte(r, e) {
  return (r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]);
}
var Qu = Yte;
function hm(r, e, t, i) {
  return r[0] = e[0] + i * (t[0] - e[0]), r[1] = e[1] + i * (t[1] - e[1]), r;
}
function Hr(r, e, t) {
  var i = e[0], n = e[1];
  return r[0] = t[0] * i + t[2] * n + t[4], r[1] = t[1] * i + t[3] * n + t[5], r;
}
function ws(r, e, t) {
  return r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r;
}
function Ps(r, e, t) {
  return r[0] = Math.max(e[0], t[0]), r[1] = Math.max(e[1], t[1]), r;
}
var Mh = function() {
  function r(e, t) {
    this.target = e, this.topTarget = t && t.topTarget;
  }
  return r;
}(), Hte = function() {
  function r(e) {
    this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
  }
  return r.prototype._dragStart = function(e) {
    for (var t = e.target; t && !t.draggable; )
      t = t.parent || t.__hostTarget;
    t && (this._draggingTarget = t, t.dragging = !0, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new Mh(t, e), "dragstart", e.event));
  }, r.prototype._drag = function(e) {
    var t = this._draggingTarget;
    if (t) {
      var i = e.offsetX, n = e.offsetY, a = i - this._x, o = n - this._y;
      this._x = i, this._y = n, t.drift(a, o, e), this.handler.dispatchToElement(new Mh(t, e), "drag", e.event);
      var s = this.handler.findHover(i, n, t).target, l = this._dropTarget;
      this._dropTarget = s, t !== s && (l && s !== l && this.handler.dispatchToElement(new Mh(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new Mh(s, e), "dragenter", e.event));
    }
  }, r.prototype._dragEnd = function(e) {
    var t = this._draggingTarget;
    t && (t.dragging = !1), this.handler.dispatchToElement(new Mh(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new Mh(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
  }, r;
}();
const Wte = Hte;
var zte = function() {
  function r(e) {
    e && (this._$eventProcessor = e);
  }
  return r.prototype.on = function(e, t, i, n) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof t == "function" && (n = i, i = t, t = null), !i || !e)
      return this;
    var o = this._$eventProcessor;
    t != null && o && o.normalizeQuery && (t = o.normalizeQuery(t)), a[e] || (a[e] = []);
    for (var s = 0; s < a[e].length; s++)
      if (a[e][s].h === i)
        return this;
    var l = {
      h: i,
      query: t,
      ctx: n || this,
      callAtLast: i.zrEventfulCallAtLast
    }, u = a[e].length - 1, h = a[e][u];
    return h && h.callAtLast ? a[e].splice(u, 0, l) : a[e].push(l), this;
  }, r.prototype.isSilent = function(e) {
    var t = this._$handlers;
    return !t || !t[e] || !t[e].length;
  }, r.prototype.off = function(e, t) {
    var i = this._$handlers;
    if (!i)
      return this;
    if (!e)
      return this._$handlers = {}, this;
    if (t) {
      if (i[e]) {
        for (var n = [], a = 0, o = i[e].length; a < o; a++)
          i[e][a].h !== t && n.push(i[e][a]);
        i[e] = n;
      }
      i[e] && i[e].length === 0 && delete i[e];
    } else
      delete i[e];
    return this;
  }, r.prototype.trigger = function(e) {
    for (var t = [], i = 1; i < arguments.length; i++)
      t[i - 1] = arguments[i];
    if (!this._$handlers)
      return this;
    var n = this._$handlers[e], a = this._$eventProcessor;
    if (n)
      for (var o = t.length, s = n.length, l = 0; l < s; l++) {
        var u = n[l];
        if (!(a && a.filter && u.query != null && !a.filter(e, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, t[0]);
              break;
            case 2:
              u.h.call(u.ctx, t[0], t[1]);
              break;
            default:
              u.h.apply(u.ctx, t);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, r.prototype.triggerWithContext = function(e) {
    for (var t = [], i = 1; i < arguments.length; i++)
      t[i - 1] = arguments[i];
    if (!this._$handlers)
      return this;
    var n = this._$handlers[e], a = this._$eventProcessor;
    if (n)
      for (var o = t.length, s = t[o - 1], l = n.length, u = 0; u < l; u++) {
        var h = n[u];
        if (!(a && a.filter && h.query != null && !a.filter(e, h.query)))
          switch (o) {
            case 0:
              h.h.call(s);
              break;
            case 1:
              h.h.call(s, t[0]);
              break;
            case 2:
              h.h.call(s, t[0], t[1]);
              break;
            default:
              h.h.apply(s, t.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, r;
}();
const jn = zte;
var Zte = Math.log(2);
function xA(r, e, t, i, n, a) {
  var o = i + "-" + n, s = r.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (e === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~n) / Zte);
    return r[t][l];
  }
  for (var u = i | 1 << t, h = t + 1; i & 1 << h; )
    h++;
  for (var c = 0, f = 0, d = 0; f < s; f++) {
    var p = 1 << f;
    p & n || (c += (d % 2 ? -1 : 1) * r[t][f] * xA(r, e - 1, h, u, n | p, a), d++);
  }
  return a[o] = c, c;
}
function iL(r, e) {
  var t = [
    [r[0], r[1], 1, 0, 0, 0, -e[0] * r[0], -e[0] * r[1]],
    [0, 0, 0, r[0], r[1], 1, -e[1] * r[0], -e[1] * r[1]],
    [r[2], r[3], 1, 0, 0, 0, -e[2] * r[2], -e[2] * r[3]],
    [0, 0, 0, r[2], r[3], 1, -e[3] * r[2], -e[3] * r[3]],
    [r[4], r[5], 1, 0, 0, 0, -e[4] * r[4], -e[4] * r[5]],
    [0, 0, 0, r[4], r[5], 1, -e[5] * r[4], -e[5] * r[5]],
    [r[6], r[7], 1, 0, 0, 0, -e[6] * r[6], -e[6] * r[7]],
    [0, 0, 0, r[6], r[7], 1, -e[7] * r[6], -e[7] * r[7]]
  ], i = {}, n = xA(t, 8, 0, 0, 0, i);
  if (n !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * xA(t, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, i) / n * e[o];
    return function(l, u, h) {
      var c = u * a[6] + h * a[7] + 1;
      l[0] = (u * a[0] + h * a[1] + a[2]) / c, l[1] = (u * a[3] + h * a[4] + a[5]) / c;
    };
  }
}
var nL = "___zrEVENTSAVED", BT = [];
function qte(r, e, t, i, n) {
  return wA(BT, e, i, n, !0) && wA(r, t, BT[0], BT[1]);
}
function wA(r, e, t, i, n) {
  if (e.getBoundingClientRect && st.domSupported && !MF(e)) {
    var a = e[nL] || (e[nL] = {}), o = jte(e, a), s = Kte(o, a, n);
    if (s)
      return s(r, t, i), !0;
  }
  return !1;
}
function jte(r, e) {
  var t = e.markers;
  if (t)
    return t;
  t = e.markers = [];
  for (var i = ["left", "right"], n = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      i[l] + ":0",
      n[u] + ":0",
      i[1 - l] + ":auto",
      n[1 - u] + ":auto",
      ""
    ].join("!important;"), r.appendChild(o), t.push(o);
  }
  return t;
}
function Kte(r, e, t) {
  for (var i = t ? "invTrans" : "trans", n = e[i], a = e.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var h = r[u].getBoundingClientRect(), c = 2 * u, f = h.left, d = h.top;
    o.push(f, d), l = l && a && f === a[c] && d === a[c + 1], s.push(r[u].offsetLeft, r[u].offsetTop);
  }
  return l && n ? n : (e.srcCoords = o, e[i] = t ? iL(s, o) : iL(o, s));
}
function MF(r) {
  return r.nodeName.toUpperCase() === "CANVAS";
}
var Jte = /([&<>"'])/g, ere = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Di(r) {
  return r == null ? "" : (r + "").replace(Jte, function(e, t) {
    return ere[t];
  });
}
var tre = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, VT = [], rre = st.browser.firefox && +st.browser.version.split(".")[0] < 39;
function PA(r, e, t, i) {
  return t = t || {}, i ? aL(r, e, t) : rre && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : aL(r, e, t), t;
}
function aL(r, e, t) {
  if (st.domSupported && r.getBoundingClientRect) {
    var i = e.clientX, n = e.clientY;
    if (MF(r)) {
      var a = r.getBoundingClientRect();
      t.zrX = i - a.left, t.zrY = n - a.top;
      return;
    } else if (wA(VT, r, i, n)) {
      t.zrX = VT[0], t.zrY = VT[1];
      return;
    }
  }
  t.zrX = t.zrY = 0;
}
function RI(r) {
  return r || window.event;
}
function _n(r, e, t) {
  if (e = RI(e), e.zrX != null)
    return e;
  var i = e.type, n = i && i.indexOf("touch") >= 0;
  if (n) {
    var o = i !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
    o && PA(r, o, e, t);
  } else {
    PA(r, e, e, t);
    var a = ire(e);
    e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3;
  }
  var s = e.button;
  return e.which == null && s !== void 0 && tre.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e;
}
function ire(r) {
  var e = r.wheelDelta;
  if (e)
    return e;
  var t = r.deltaX, i = r.deltaY;
  if (t == null || i == null)
    return e;
  var n = Math.abs(i !== 0 ? i : t), a = i > 0 ? -1 : i < 0 ? 1 : t > 0 ? -1 : 1;
  return 3 * n * a;
}
function NA(r, e, t, i) {
  r.addEventListener(e, t, i);
}
function nre(r, e, t, i) {
  r.removeEventListener(e, t, i);
}
var Vo = function(r) {
  r.preventDefault(), r.stopPropagation(), r.cancelBubble = !0;
};
function oL(r) {
  return r.which === 2 || r.which === 3;
}
var are = function() {
  function r() {
    this._track = [];
  }
  return r.prototype.recognize = function(e, t, i) {
    return this._doTrack(e, t, i), this._recognize(e);
  }, r.prototype.clear = function() {
    return this._track.length = 0, this;
  }, r.prototype._doTrack = function(e, t, i) {
    var n = e.touches;
    if (n) {
      for (var a = {
        points: [],
        touches: [],
        target: t,
        event: e
      }, o = 0, s = n.length; o < s; o++) {
        var l = n[o], u = PA(i, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, r.prototype._recognize = function(e) {
    for (var t in FT)
      if (FT.hasOwnProperty(t)) {
        var i = FT[t](this._track, e);
        if (i)
          return i;
      }
  }, r;
}();
function sL(r) {
  var e = r[1][0] - r[0][0], t = r[1][1] - r[0][1];
  return Math.sqrt(e * e + t * t);
}
function ore(r) {
  return [
    (r[0][0] + r[1][0]) / 2,
    (r[0][1] + r[1][1]) / 2
  ];
}
var FT = {
  pinch: function(r, e) {
    var t = r.length;
    if (t) {
      var i = (r[t - 1] || {}).points, n = (r[t - 2] || {}).points || i;
      if (n && n.length > 1 && i && i.length > 1) {
        var a = sL(i) / sL(n);
        !isFinite(a) && (a = 1), e.pinchScale = a;
        var o = ore(i);
        return e.pinchX = o[0], e.pinchY = o[1], {
          type: "pinch",
          target: r[0].target,
          event: e
        };
      }
    }
  }
};
function Zn() {
  return [1, 0, 0, 1, 0, 0];
}
function gS(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
}
function AI(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r;
}
function Mo(r, e, t) {
  var i = e[0] * t[0] + e[2] * t[1], n = e[1] * t[0] + e[3] * t[1], a = e[0] * t[2] + e[2] * t[3], o = e[1] * t[2] + e[3] * t[3], s = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5];
  return r[0] = i, r[1] = n, r[2] = a, r[3] = o, r[4] = s, r[5] = l, r;
}
function ao(r, e, t) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4] + t[0], r[5] = e[5] + t[1], r;
}
function bh(r, e, t) {
  var i = e[0], n = e[2], a = e[4], o = e[1], s = e[3], l = e[5], u = Math.sin(t), h = Math.cos(t);
  return r[0] = i * h + o * u, r[1] = -i * u + o * h, r[2] = n * h + s * u, r[3] = -n * u + h * s, r[4] = h * a + u * l, r[5] = h * l - u * a, r;
}
function CI(r, e, t) {
  var i = t[0], n = t[1];
  return r[0] = e[0] * i, r[1] = e[1] * n, r[2] = e[2] * i, r[3] = e[3] * n, r[4] = e[4] * i, r[5] = e[5] * n, r;
}
function Ef(r, e) {
  var t = e[0], i = e[2], n = e[4], a = e[1], o = e[3], s = e[5], l = t * o - a * i;
  return l ? (l = 1 / l, r[0] = o * l, r[1] = -a * l, r[2] = -i * l, r[3] = t * l, r[4] = (i * s - o * n) * l, r[5] = (a * n - t * s) * l, r) : null;
}
function sre(r) {
  var e = Zn();
  return AI(e, r), e;
}
var lre = function() {
  function r(e, t) {
    this.x = e || 0, this.y = t || 0;
  }
  return r.prototype.copy = function(e) {
    return this.x = e.x, this.y = e.y, this;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y);
  }, r.prototype.set = function(e, t) {
    return this.x = e, this.y = t, this;
  }, r.prototype.equal = function(e) {
    return e.x === this.x && e.y === this.y;
  }, r.prototype.add = function(e) {
    return this.x += e.x, this.y += e.y, this;
  }, r.prototype.scale = function(e) {
    this.x *= e, this.y *= e;
  }, r.prototype.scaleAndAdd = function(e, t) {
    this.x += e.x * t, this.y += e.y * t;
  }, r.prototype.sub = function(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }, r.prototype.dot = function(e) {
    return this.x * e.x + this.y * e.y;
  }, r.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, r.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, r.prototype.normalize = function() {
    var e = this.len();
    return this.x /= e, this.y /= e, this;
  }, r.prototype.distance = function(e) {
    var t = this.x - e.x, i = this.y - e.y;
    return Math.sqrt(t * t + i * i);
  }, r.prototype.distanceSquare = function(e) {
    var t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }, r.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, r.prototype.transform = function(e) {
    if (e) {
      var t = this.x, i = this.y;
      return this.x = e[0] * t + e[2] * i + e[4], this.y = e[1] * t + e[3] * i + e[5], this;
    }
  }, r.prototype.toArray = function(e) {
    return e[0] = this.x, e[1] = this.y, e;
  }, r.prototype.fromArray = function(e) {
    this.x = e[0], this.y = e[1];
  }, r.set = function(e, t, i) {
    e.x = t, e.y = i;
  }, r.copy = function(e, t) {
    e.x = t.x, e.y = t.y;
  }, r.len = function(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }, r.lenSquare = function(e) {
    return e.x * e.x + e.y * e.y;
  }, r.dot = function(e, t) {
    return e.x * t.x + e.y * t.y;
  }, r.add = function(e, t, i) {
    e.x = t.x + i.x, e.y = t.y + i.y;
  }, r.sub = function(e, t, i) {
    e.x = t.x - i.x, e.y = t.y - i.y;
  }, r.scale = function(e, t, i) {
    e.x = t.x * i, e.y = t.y * i;
  }, r.scaleAndAdd = function(e, t, i, n) {
    e.x = t.x + i.x * n, e.y = t.y + i.y * n;
  }, r.lerp = function(e, t, i, n) {
    var a = 1 - n;
    e.x = a * t.x + n * i.x, e.y = a * t.y + n * i.y;
  }, r;
}();
const Le = lre;
var Nv = Math.min, Lv = Math.max, wl = new Le(), Pl = new Le(), Nl = new Le(), Ll = new Le(), Yf = new Le(), Hf = new Le(), ure = function() {
  function r(e, t, i, n) {
    i < 0 && (e = e + i, i = -i), n < 0 && (t = t + n, n = -n), this.x = e, this.y = t, this.width = i, this.height = n;
  }
  return r.prototype.union = function(e) {
    var t = Nv(e.x, this.x), i = Nv(e.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Lv(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = Lv(e.y + e.height, this.y + this.height) - i : this.height = e.height, this.x = t, this.y = i;
  }, r.prototype.applyTransform = function(e) {
    r.applyTransform(this, this, e);
  }, r.prototype.calculateTransform = function(e) {
    var t = this, i = e.width / t.width, n = e.height / t.height, a = Zn();
    return ao(a, a, [-t.x, -t.y]), CI(a, a, [i, n]), ao(a, a, [e.x, e.y]), a;
  }, r.prototype.intersect = function(e, t) {
    if (!e)
      return !1;
    e instanceof r || (e = r.create(e));
    var i = this, n = i.x, a = i.x + i.width, o = i.y, s = i.y + i.height, l = e.x, u = e.x + e.width, h = e.y, c = e.y + e.height, f = !(a < l || u < n || s < h || c < o);
    if (t) {
      var d = 1 / 0, p = 0, g = Math.abs(a - l), v = Math.abs(u - n), O = Math.abs(s - h), m = Math.abs(c - o), E = Math.min(g, v), b = Math.min(O, m);
      a < l || u < n ? E > p && (p = E, g < v ? Le.set(Hf, -g, 0) : Le.set(Hf, v, 0)) : E < d && (d = E, g < v ? Le.set(Yf, g, 0) : Le.set(Yf, -v, 0)), s < h || c < o ? b > p && (p = b, O < m ? Le.set(Hf, 0, -O) : Le.set(Hf, 0, m)) : E < d && (d = E, O < m ? Le.set(Yf, 0, O) : Le.set(Yf, 0, -m));
    }
    return t && Le.copy(t, f ? Yf : Hf), f;
  }, r.prototype.contain = function(e, t) {
    var i = this;
    return e >= i.x && e <= i.x + i.width && t >= i.y && t <= i.y + i.height;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y, this.width, this.height);
  }, r.prototype.copy = function(e) {
    r.copy(this, e);
  }, r.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, r.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, r.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, r.create = function(e) {
    return new r(e.x, e.y, e.width, e.height);
  }, r.copy = function(e, t) {
    e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height;
  }, r.applyTransform = function(e, t, i) {
    if (!i) {
      e !== t && r.copy(e, t);
      return;
    }
    if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
      var n = i[0], a = i[3], o = i[4], s = i[5];
      e.x = t.x * n + o, e.y = t.y * a + s, e.width = t.width * n, e.height = t.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
      return;
    }
    wl.x = Nl.x = t.x, wl.y = Ll.y = t.y, Pl.x = Ll.x = t.x + t.width, Pl.y = Nl.y = t.y + t.height, wl.transform(i), Ll.transform(i), Pl.transform(i), Nl.transform(i), e.x = Nv(wl.x, Pl.x, Nl.x, Ll.x), e.y = Nv(wl.y, Pl.y, Nl.y, Ll.y);
    var l = Lv(wl.x, Pl.x, Nl.x, Ll.x), u = Lv(wl.y, Pl.y, Nl.y, Ll.y);
    e.width = l - e.x, e.height = u - e.y;
  }, r;
}();
const Ue = ure;
var kF = "silent";
function hre(r, e, t) {
  return {
    type: r,
    event: t,
    target: e.target,
    topTarget: e.topTarget,
    cancelBubble: !1,
    offsetX: t.zrX,
    offsetY: t.zrY,
    gestureEvent: t.gestureEvent,
    pinchX: t.pinchX,
    pinchY: t.pinchY,
    pinchScale: t.pinchScale,
    wheelDelta: t.zrDelta,
    zrByTouch: t.zrByTouch,
    which: t.which,
    stop: cre
  };
}
function cre() {
  Vo(this.event);
}
var fre = function(r) {
  U(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.handler = null, t;
  }
  return e.prototype.dispose = function() {
  }, e.prototype.setCursor = function() {
  }, e;
}(jn), Wf = function() {
  function r(e, t) {
    this.x = e, this.y = t;
  }
  return r;
}(), dre = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], XT = new Ue(0, 0, 0, 0), QF = function(r) {
  U(e, r);
  function e(t, i, n, a, o) {
    var s = r.call(this) || this;
    return s._hovered = new Wf(0, 0), s.storage = t, s.painter = i, s.painterRoot = a, s._pointerSize = o, n = n || new fre(), s.proxy = null, s.setHandlerProxy(n), s._draggingMgr = new Wte(s), s;
  }
  return e.prototype.setHandlerProxy = function(t) {
    this.proxy && this.proxy.dispose(), t && (w(dre, function(i) {
      t.on && t.on(i, this[i], this);
    }, this), t.handler = this), this.proxy = t;
  }, e.prototype.mousemove = function(t) {
    var i = t.zrX, n = t.zrY, a = UF(this, i, n), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new Wf(i, n) : this.findHover(i, n), u = l.target, h = this.proxy;
    h.setCursor && h.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(l, "mousemove", t), u && u !== s && this.dispatchToElement(l, "mouseover", t);
  }, e.prototype.mouseout = function(t) {
    var i = t.zrEventControl;
    i !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), i !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: t });
  }, e.prototype.resize = function() {
    this._hovered = new Wf(0, 0);
  }, e.prototype.dispatch = function(t, i) {
    var n = this[t];
    n && n.call(this, i);
  }, e.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, e.prototype.setCursorStyle = function(t) {
    var i = this.proxy;
    i.setCursor && i.setCursor(t);
  }, e.prototype.dispatchToElement = function(t, i, n) {
    t = t || {};
    var a = t.target;
    if (!(a && a.silent)) {
      for (var o = "on" + i, s = hre(i, t, n); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(i, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(i, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(i, s);
      }));
    }
  }, e.prototype.findHover = function(t, i, n) {
    var a = this.storage.getDisplayList(), o = new Wf(t, i);
    if (lL(a, o, t, i, n), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, h = new Ue(t - u, i - u, l, l), c = a.length - 1; c >= 0; c--) {
        var f = a[c];
        f !== n && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (XT.copy(f.getBoundingRect()), f.transform && XT.applyTransform(f.transform), XT.intersect(h) && s.push(f));
      }
      if (s.length)
        for (var d = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += d)
          for (var O = 0; O < g; O += p) {
            var m = t + v * Math.cos(O), E = i + v * Math.sin(O);
            if (lL(s, o, m, E, n), o.target)
              return o;
          }
    }
    return o;
  }, e.prototype.processGesture = function(t, i) {
    this._gestureMgr || (this._gestureMgr = new are());
    var n = this._gestureMgr;
    i === "start" && n.clear();
    var a = n.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
    if (i === "end" && n.clear(), a) {
      var o = a.type;
      t.gestureEvent = o;
      var s = new Wf();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, e;
}(jn);
w(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(r) {
  QF.prototype[r] = function(e) {
    var t = e.zrX, i = e.zrY, n = UF(this, t, i), a, o;
    if ((r !== "mouseup" || !n) && (a = this.findHover(t, i), o = a.target), r === "mousedown")
      this._downEl = o, this._downPoint = [e.zrX, e.zrY], this._upEl = o;
    else if (r === "mouseup")
      this._upEl = o;
    else if (r === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || xs(this._downPoint, [e.zrX, e.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, r, e);
  };
});
function pre(r, e, t) {
  if (r[r.rectHover ? "rectContain" : "contain"](e, t)) {
    for (var i = r, n = void 0, a = !1; i; ) {
      if (i.ignoreClip && (a = !0), !a) {
        var o = i.getClipPath();
        if (o && !o.contain(e, t))
          return !1;
        i.silent && (n = !0);
      }
      var s = i.__hostTarget;
      i = s || i.parent;
    }
    return n ? kF : !0;
  }
  return !1;
}
function lL(r, e, t, i, n) {
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a], s = void 0;
    if (o !== n && !o.ignore && (s = pre(o, t, i)) && (!e.topTarget && (e.topTarget = o), s !== kF)) {
      e.target = o;
      break;
    }
  }
}
function UF(r, e, t) {
  var i = r.painter;
  return e < 0 || e > i.getWidth() || t < 0 || t > i.getHeight();
}
const gre = QF;
var $F = 32, zf = 7;
function vre(r) {
  for (var e = 0; r >= $F; )
    e |= r & 1, r >>= 1;
  return r + e;
}
function uL(r, e, t, i) {
  var n = e + 1;
  if (n === t)
    return 1;
  if (i(r[n++], r[e]) < 0) {
    for (; n < t && i(r[n], r[n - 1]) < 0; )
      n++;
    Ore(r, e, n);
  } else
    for (; n < t && i(r[n], r[n - 1]) >= 0; )
      n++;
  return n - e;
}
function Ore(r, e, t) {
  for (t--; e < t; ) {
    var i = r[e];
    r[e++] = r[t], r[t--] = i;
  }
}
function hL(r, e, t, i, n) {
  for (i === e && i++; i < t; i++) {
    for (var a = r[i], o = e, s = i, l; o < s; )
      l = o + s >>> 1, n(a, r[l]) < 0 ? s = l : o = l + 1;
    var u = i - o;
    switch (u) {
      case 3:
        r[o + 3] = r[o + 2];
      case 2:
        r[o + 2] = r[o + 1];
      case 1:
        r[o + 1] = r[o];
        break;
      default:
        for (; u > 0; )
          r[o + u] = r[o + u - 1], u--;
    }
    r[o] = a;
  }
}
function YT(r, e, t, i, n, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, e[t + n]) > 0) {
    for (s = i - n; l < s && a(r, e[t + n + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += n, l += n;
  } else {
    for (s = n + 1; l < s && a(r, e[t + n - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = n - l, l = n - u;
  }
  for (o++; o < l; ) {
    var h = o + (l - o >>> 1);
    a(r, e[t + h]) > 0 ? o = h + 1 : l = h;
  }
  return l;
}
function HT(r, e, t, i, n, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, e[t + n]) < 0) {
    for (s = n + 1; l < s && a(r, e[t + n - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = n - l, l = n - u;
  } else {
    for (s = i - n; l < s && a(r, e[t + n + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += n, l += n;
  }
  for (o++; o < l; ) {
    var h = o + (l - o >>> 1);
    a(r, e[t + h]) < 0 ? l = h : o = h + 1;
  }
  return l;
}
function mre(r, e) {
  var t = zf, i, n, a = 0;
  r.length;
  var o = [];
  i = [], n = [];
  function s(d, p) {
    i[a] = d, n[a] = p, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var d = a - 2;
      if (d >= 1 && n[d - 1] <= n[d] + n[d + 1] || d >= 2 && n[d - 2] <= n[d] + n[d - 1])
        n[d - 1] < n[d + 1] && d--;
      else if (n[d] > n[d + 1])
        break;
      h(d);
    }
  }
  function u() {
    for (; a > 1; ) {
      var d = a - 2;
      d > 0 && n[d - 1] < n[d + 1] && d--, h(d);
    }
  }
  function h(d) {
    var p = i[d], g = n[d], v = i[d + 1], O = n[d + 1];
    n[d] = g + O, d === a - 3 && (i[d + 1] = i[d + 2], n[d + 1] = n[d + 2]), a--;
    var m = HT(r[v], r, p, g, 0, e);
    p += m, g -= m, g !== 0 && (O = YT(r[p + g - 1], r, v, O, O - 1, e), O !== 0 && (g <= O ? c(p, g, v, O) : f(p, g, v, O)));
  }
  function c(d, p, g, v) {
    var O = 0;
    for (O = 0; O < p; O++)
      o[O] = r[d + O];
    var m = 0, E = g, b = d;
    if (r[b++] = r[E++], --v === 0) {
      for (O = 0; O < p; O++)
        r[b + O] = o[m + O];
      return;
    }
    if (p === 1) {
      for (O = 0; O < v; O++)
        r[b + O] = r[E + O];
      r[b + v] = o[m];
      return;
    }
    for (var T = t, S, y, A; ; ) {
      S = 0, y = 0, A = !1;
      do
        if (e(r[E], o[m]) < 0) {
          if (r[b++] = r[E++], y++, S = 0, --v === 0) {
            A = !0;
            break;
          }
        } else if (r[b++] = o[m++], S++, y = 0, --p === 1) {
          A = !0;
          break;
        }
      while ((S | y) < T);
      if (A)
        break;
      do {
        if (S = HT(r[E], o, m, p, 0, e), S !== 0) {
          for (O = 0; O < S; O++)
            r[b + O] = o[m + O];
          if (b += S, m += S, p -= S, p <= 1) {
            A = !0;
            break;
          }
        }
        if (r[b++] = r[E++], --v === 0) {
          A = !0;
          break;
        }
        if (y = YT(o[m], r, E, v, 0, e), y !== 0) {
          for (O = 0; O < y; O++)
            r[b + O] = r[E + O];
          if (b += y, E += y, v -= y, v === 0) {
            A = !0;
            break;
          }
        }
        if (r[b++] = o[m++], --p === 1) {
          A = !0;
          break;
        }
        T--;
      } while (S >= zf || y >= zf);
      if (A)
        break;
      T < 0 && (T = 0), T += 2;
    }
    if (t = T, t < 1 && (t = 1), p === 1) {
      for (O = 0; O < v; O++)
        r[b + O] = r[E + O];
      r[b + v] = o[m];
    } else {
      if (p === 0)
        throw new Error();
      for (O = 0; O < p; O++)
        r[b + O] = o[m + O];
    }
  }
  function f(d, p, g, v) {
    var O = 0;
    for (O = 0; O < v; O++)
      o[O] = r[g + O];
    var m = d + p - 1, E = v - 1, b = g + v - 1, T = 0, S = 0;
    if (r[b--] = r[m--], --p === 0) {
      for (T = b - (v - 1), O = 0; O < v; O++)
        r[T + O] = o[O];
      return;
    }
    if (v === 1) {
      for (b -= p, m -= p, S = b + 1, T = m + 1, O = p - 1; O >= 0; O--)
        r[S + O] = r[T + O];
      r[b] = o[E];
      return;
    }
    for (var y = t; ; ) {
      var A = 0, C = 0, _ = !1;
      do
        if (e(o[E], r[m]) < 0) {
          if (r[b--] = r[m--], A++, C = 0, --p === 0) {
            _ = !0;
            break;
          }
        } else if (r[b--] = o[E--], C++, A = 0, --v === 1) {
          _ = !0;
          break;
        }
      while ((A | C) < y);
      if (_)
        break;
      do {
        if (A = p - HT(o[E], r, d, p, p - 1, e), A !== 0) {
          for (b -= A, m -= A, p -= A, S = b + 1, T = m + 1, O = A - 1; O >= 0; O--)
            r[S + O] = r[T + O];
          if (p === 0) {
            _ = !0;
            break;
          }
        }
        if (r[b--] = o[E--], --v === 1) {
          _ = !0;
          break;
        }
        if (C = v - YT(r[m], o, 0, v, v - 1, e), C !== 0) {
          for (b -= C, E -= C, v -= C, S = b + 1, T = E + 1, O = 0; O < C; O++)
            r[S + O] = o[T + O];
          if (v <= 1) {
            _ = !0;
            break;
          }
        }
        if (r[b--] = r[m--], --p === 0) {
          _ = !0;
          break;
        }
        y--;
      } while (A >= zf || C >= zf);
      if (_)
        break;
      y < 0 && (y = 0), y += 2;
    }
    if (t = y, t < 1 && (t = 1), v === 1) {
      for (b -= p, m -= p, S = b + 1, T = m + 1, O = p - 1; O >= 0; O--)
        r[S + O] = r[T + O];
      r[b] = o[E];
    } else {
      if (v === 0)
        throw new Error();
      for (T = b - (v - 1), O = 0; O < v; O++)
        r[T + O] = o[O];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function cm(r, e, t, i) {
  t || (t = 0), i || (i = r.length);
  var n = i - t;
  if (!(n < 2)) {
    var a = 0;
    if (n < $F) {
      a = uL(r, t, i, e), hL(r, t, i, t + a, e);
      return;
    }
    var o = mre(r, e), s = vre(n);
    do {
      if (a = uL(r, t, i, e), a < s) {
        var l = n;
        l > s && (l = s), hL(r, t, t + l, t + a, e), a = l;
      }
      o.pushRun(t, a), o.mergeRuns(), n -= a, t += a;
    } while (n !== 0);
    o.forceMergeRuns();
  }
}
var un = 1, Nd = 2, oc = 4, cL = !1;
function WT() {
  cL || (cL = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function fL(r, e) {
  return r.zlevel === e.zlevel ? r.z === e.z ? r.z2 - e.z2 : r.z - e.z : r.zlevel - e.zlevel;
}
var Ere = function() {
  function r() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = fL;
  }
  return r.prototype.traverse = function(e, t) {
    for (var i = 0; i < this._roots.length; i++)
      this._roots[i].traverse(e, t);
  }, r.prototype.getDisplayList = function(e, t) {
    t = t || !1;
    var i = this._displayList;
    return (e || !i.length) && this.updateDisplayList(t), i;
  }, r.prototype.updateDisplayList = function(e) {
    this._displayListLen = 0;
    for (var t = this._roots, i = this._displayList, n = 0, a = t.length; n < a; n++)
      this._updateAndAddDisplayable(t[n], null, e);
    i.length = this._displayListLen, cm(i, fL);
  }, r.prototype._updateAndAddDisplayable = function(e, t, i) {
    if (!(e.ignore && !i)) {
      e.beforeUpdate(), e.update(), e.afterUpdate();
      var n = e.getClipPath();
      if (e.ignoreClip)
        t = null;
      else if (n) {
        t ? t = t.slice() : t = [];
        for (var a = n, o = e; a; )
          a.parent = o, a.updateTransform(), t.push(a), o = a, a = a.getClipPath();
      }
      if (e.childrenRef) {
        for (var s = e.childrenRef(), l = 0; l < s.length; l++) {
          var u = s[l];
          e.__dirty && (u.__dirty |= un), this._updateAndAddDisplayable(u, t, i);
        }
        e.__dirty = 0;
      } else {
        var h = e;
        t && t.length ? h.__clipPaths = t : h.__clipPaths && h.__clipPaths.length > 0 && (h.__clipPaths = []), isNaN(h.z) && (WT(), h.z = 0), isNaN(h.z2) && (WT(), h.z2 = 0), isNaN(h.zlevel) && (WT(), h.zlevel = 0), this._displayList[this._displayListLen++] = h;
      }
      var c = e.getDecalElement && e.getDecalElement();
      c && this._updateAndAddDisplayable(c, t, i);
      var f = e.getTextGuideLine();
      f && this._updateAndAddDisplayable(f, t, i);
      var d = e.getTextContent();
      d && this._updateAndAddDisplayable(d, t, i);
    }
  }, r.prototype.addRoot = function(e) {
    e.__zr && e.__zr.storage === this || this._roots.push(e);
  }, r.prototype.delRoot = function(e) {
    if (e instanceof Array) {
      for (var t = 0, i = e.length; t < i; t++)
        this.delRoot(e[t]);
      return;
    }
    var n = Ge(this._roots, e);
    n >= 0 && this._roots.splice(n, 1);
  }, r.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, r.prototype.getRoots = function() {
    return this._roots;
  }, r.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, r;
}();
const bre = Ere;
var GF;
GF = st.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(r) {
  return setTimeout(r, 16);
};
const LA = GF;
var fm = {
  linear: function(r) {
    return r;
  },
  quadraticIn: function(r) {
    return r * r;
  },
  quadraticOut: function(r) {
    return r * (2 - r);
  },
  quadraticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
  },
  cubicIn: function(r) {
    return r * r * r;
  },
  cubicOut: function(r) {
    return --r * r * r + 1;
  },
  cubicInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
  },
  quarticIn: function(r) {
    return r * r * r * r;
  },
  quarticOut: function(r) {
    return 1 - --r * r * r * r;
  },
  quarticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
  },
  quinticIn: function(r) {
    return r * r * r * r * r;
  },
  quinticOut: function(r) {
    return --r * r * r * r * r + 1;
  },
  quinticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
  },
  sinusoidalIn: function(r) {
    return 1 - Math.cos(r * Math.PI / 2);
  },
  sinusoidalOut: function(r) {
    return Math.sin(r * Math.PI / 2);
  },
  sinusoidalInOut: function(r) {
    return 0.5 * (1 - Math.cos(Math.PI * r));
  },
  exponentialIn: function(r) {
    return r === 0 ? 0 : Math.pow(1024, r - 1);
  },
  exponentialOut: function(r) {
    return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
  },
  exponentialInOut: function(r) {
    return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
  },
  circularIn: function(r) {
    return 1 - Math.sqrt(1 - r * r);
  },
  circularOut: function(r) {
    return Math.sqrt(1 - --r * r);
  },
  circularInOut: function(r) {
    return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
  },
  elasticIn: function(r) {
    var e, t = 0.1, i = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = i / 4) : e = i * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / i)));
  },
  elasticOut: function(r) {
    var e, t = 0.1, i = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = i / 4) : e = i * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * r) * Math.sin((r - e) * (2 * Math.PI) / i) + 1);
  },
  elasticInOut: function(r) {
    var e, t = 0.1, i = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = i / 4) : e = i * Math.asin(1 / t) / (2 * Math.PI), (r *= 2) < 1 ? -0.5 * (t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / i)) : t * Math.pow(2, -10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / i) * 0.5 + 1);
  },
  backIn: function(r) {
    var e = 1.70158;
    return r * r * ((e + 1) * r - e);
  },
  backOut: function(r) {
    var e = 1.70158;
    return --r * r * ((e + 1) * r + e) + 1;
  },
  backInOut: function(r) {
    var e = 2.5949095;
    return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
  },
  bounceIn: function(r) {
    return 1 - fm.bounceOut(1 - r);
  },
  bounceOut: function(r) {
    return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
  },
  bounceInOut: function(r) {
    return r < 0.5 ? fm.bounceIn(r * 2) * 0.5 : fm.bounceOut(r * 2 - 1) * 0.5 + 0.5;
  }
};
const BF = fm;
var Dv = Math.pow, Vs = Math.sqrt, cE = 1e-8, VF = 1e-4, dL = Vs(3), Mv = 1 / 3, Ga = Eh(), Nn = Eh(), wc = Eh();
function Ns(r) {
  return r > -cE && r < cE;
}
function FF(r) {
  return r > cE || r < -cE;
}
function Er(r, e, t, i, n) {
  var a = 1 - n;
  return a * a * (a * r + 3 * n * e) + n * n * (n * i + 3 * a * t);
}
function pL(r, e, t, i, n) {
  var a = 1 - n;
  return 3 * (((e - r) * a + 2 * (t - e) * n) * a + (i - t) * n * n);
}
function fE(r, e, t, i, n, a) {
  var o = i + 3 * (e - t) - r, s = 3 * (t - e * 2 + r), l = 3 * (e - r), u = r - n, h = s * s - 3 * o * l, c = s * l - 9 * o * u, f = l * l - 3 * s * u, d = 0;
  if (Ns(h) && Ns(c))
    if (Ns(s))
      a[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (a[d++] = p);
    }
  else {
    var g = c * c - 4 * h * f;
    if (Ns(g)) {
      var v = c / h, p = -s / o + v, O = -v / 2;
      p >= 0 && p <= 1 && (a[d++] = p), O >= 0 && O <= 1 && (a[d++] = O);
    } else if (g > 0) {
      var m = Vs(g), E = h * s + 1.5 * o * (-c + m), b = h * s + 1.5 * o * (-c - m);
      E < 0 ? E = -Dv(-E, Mv) : E = Dv(E, Mv), b < 0 ? b = -Dv(-b, Mv) : b = Dv(b, Mv);
      var p = (-s - (E + b)) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p);
    } else {
      var T = (2 * h * s - 3 * o * c) / (2 * Vs(h * h * h)), S = Math.acos(T) / 3, y = Vs(h), A = Math.cos(S), p = (-s - 2 * y * A) / (3 * o), O = (-s + y * (A + dL * Math.sin(S))) / (3 * o), C = (-s + y * (A - dL * Math.sin(S))) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p), O >= 0 && O <= 1 && (a[d++] = O), C >= 0 && C <= 1 && (a[d++] = C);
    }
  }
  return d;
}
function XF(r, e, t, i, n) {
  var a = 6 * t - 12 * e + 6 * r, o = 9 * e + 3 * i - 3 * r - 9 * t, s = 3 * e - 3 * r, l = 0;
  if (Ns(o)) {
    if (FF(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (n[l++] = u);
    }
  } else {
    var h = a * a - 4 * o * s;
    if (Ns(h))
      n[0] = -a / (2 * o);
    else if (h > 0) {
      var c = Vs(h), u = (-a + c) / (2 * o), f = (-a - c) / (2 * o);
      u >= 0 && u <= 1 && (n[l++] = u), f >= 0 && f <= 1 && (n[l++] = f);
    }
  }
  return l;
}
function nl(r, e, t, i, n, a) {
  var o = (e - r) * n + r, s = (t - e) * n + e, l = (i - t) * n + t, u = (s - o) * n + o, h = (l - s) * n + s, c = (h - u) * n + u;
  a[0] = r, a[1] = o, a[2] = u, a[3] = c, a[4] = c, a[5] = h, a[6] = l, a[7] = i;
}
function YF(r, e, t, i, n, a, o, s, l, u, h) {
  var c, f = 5e-3, d = 1 / 0, p, g, v, O;
  Ga[0] = l, Ga[1] = u;
  for (var m = 0; m < 1; m += 0.05)
    Nn[0] = Er(r, t, n, o, m), Nn[1] = Er(e, i, a, s, m), v = Qu(Ga, Nn), v < d && (c = m, d = v);
  d = 1 / 0;
  for (var E = 0; E < 32 && !(f < VF); E++)
    p = c - f, g = c + f, Nn[0] = Er(r, t, n, o, p), Nn[1] = Er(e, i, a, s, p), v = Qu(Nn, Ga), p >= 0 && v < d ? (c = p, d = v) : (wc[0] = Er(r, t, n, o, g), wc[1] = Er(e, i, a, s, g), O = Qu(wc, Ga), g <= 1 && O < d ? (c = g, d = O) : f *= 0.5);
  return h && (h[0] = Er(r, t, n, o, c), h[1] = Er(e, i, a, s, c)), Vs(d);
}
function Sre(r, e, t, i, n, a, o, s, l) {
  for (var u = r, h = e, c = 0, f = 1 / l, d = 1; d <= l; d++) {
    var p = d * f, g = Er(r, t, n, o, p), v = Er(e, i, a, s, p), O = g - u, m = v - h;
    c += Math.sqrt(O * O + m * m), u = g, h = v;
  }
  return c;
}
function Pr(r, e, t, i) {
  var n = 1 - i;
  return n * (n * r + 2 * i * e) + i * i * t;
}
function DA(r, e, t, i) {
  return 2 * ((1 - i) * (e - r) + i * (t - e));
}
function Tre(r, e, t, i, n) {
  var a = r - 2 * e + t, o = 2 * (e - r), s = r - i, l = 0;
  if (Ns(a)) {
    if (FF(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (n[l++] = u);
    }
  } else {
    var h = o * o - 4 * a * s;
    if (Ns(h)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (n[l++] = u);
    } else if (h > 0) {
      var c = Vs(h), u = (-o + c) / (2 * a), f = (-o - c) / (2 * a);
      u >= 0 && u <= 1 && (n[l++] = u), f >= 0 && f <= 1 && (n[l++] = f);
    }
  }
  return l;
}
function HF(r, e, t) {
  var i = r + t - 2 * e;
  return i === 0 ? 0.5 : (r - e) / i;
}
function Gp(r, e, t, i, n) {
  var a = (e - r) * i + r, o = (t - e) * i + e, s = (o - a) * i + a;
  n[0] = r, n[1] = a, n[2] = s, n[3] = s, n[4] = o, n[5] = t;
}
function WF(r, e, t, i, n, a, o, s, l) {
  var u, h = 5e-3, c = 1 / 0;
  Ga[0] = o, Ga[1] = s;
  for (var f = 0; f < 1; f += 0.05) {
    Nn[0] = Pr(r, t, n, f), Nn[1] = Pr(e, i, a, f);
    var d = Qu(Ga, Nn);
    d < c && (u = f, c = d);
  }
  c = 1 / 0;
  for (var p = 0; p < 32 && !(h < VF); p++) {
    var g = u - h, v = u + h;
    Nn[0] = Pr(r, t, n, g), Nn[1] = Pr(e, i, a, g);
    var d = Qu(Nn, Ga);
    if (g >= 0 && d < c)
      u = g, c = d;
    else {
      wc[0] = Pr(r, t, n, v), wc[1] = Pr(e, i, a, v);
      var O = Qu(wc, Ga);
      v <= 1 && O < c ? (u = v, c = O) : h *= 0.5;
    }
  }
  return l && (l[0] = Pr(r, t, n, u), l[1] = Pr(e, i, a, u)), Vs(c);
}
function yre(r, e, t, i, n, a, o) {
  for (var s = r, l = e, u = 0, h = 1 / o, c = 1; c <= o; c++) {
    var f = c * h, d = Pr(r, t, n, f), p = Pr(e, i, a, f), g = d - s, v = p - l;
    u += Math.sqrt(g * g + v * v), s = d, l = p;
  }
  return u;
}
var Rre = /cubic-bezier\(([0-9,\.e ]+)\)/;
function _I(r) {
  var e = r && Rre.exec(r);
  if (e) {
    var t = e[1].split(","), i = +ha(t[0]), n = +ha(t[1]), a = +ha(t[2]), o = +ha(t[3]);
    if (isNaN(i + n + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : fE(0, i, a, 1, l, s) && Er(0, n, o, 1, s[0]);
    };
  }
}
var Are = function() {
  function r(e) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || !1, this.onframe = e.onframe || ar, this.ondestroy = e.ondestroy || ar, this.onrestart = e.onrestart || ar, e.easing && this.setEasing(e.easing);
  }
  return r.prototype.step = function(e, t) {
    if (this._inited || (this._startTime = e + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += t;
      return;
    }
    var i = this._life, n = e - this._startTime - this._pausedTime, a = n / i;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = n % i;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, r.prototype.pause = function() {
    this._paused = !0;
  }, r.prototype.resume = function() {
    this._paused = !1;
  }, r.prototype.setEasing = function(e) {
    this.easing = e, this.easingFunc = ve(e) ? e : BF[e] || _I(e);
  }, r;
}();
const Cre = Are;
var zF = function() {
  function r(e) {
    this.value = e;
  }
  return r;
}(), _re = function() {
  function r() {
    this._len = 0;
  }
  return r.prototype.insert = function(e) {
    var t = new zF(e);
    return this.insertEntry(t), t;
  }, r.prototype.insertEntry = function(e) {
    this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
  }, r.prototype.remove = function(e) {
    var t = e.prev, i = e.next;
    t ? t.next = i : this.head = i, i ? i.prev = t : this.tail = t, e.next = e.prev = null, this._len--;
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, r;
}(), Ire = function() {
  function r(e) {
    this._list = new _re(), this._maxSize = 10, this._map = {}, this._maxSize = e;
  }
  return r.prototype.put = function(e, t) {
    var i = this._list, n = this._map, a = null;
    if (n[e] == null) {
      var o = i.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = i.head;
        i.remove(l), delete n[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = t : s = new zF(t), s.key = e, i.insertEntry(s), n[e] = s;
    }
    return a;
  }, r.prototype.get = function(e) {
    var t = this._map[e], i = this._list;
    if (t != null)
      return t !== i.tail && (i.remove(t), i.insertEntry(t)), t.value;
  }, r.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, r.prototype.len = function() {
    return this._list.len();
  }, r;
}();
const kg = Ire;
var gL = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function va(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 255 ? 255 : r;
}
function xre(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 360 ? 360 : r;
}
function Bp(r) {
  return r < 0 ? 0 : r > 1 ? 1 : r;
}
function zT(r) {
  var e = r;
  return e.length && e.charAt(e.length - 1) === "%" ? va(parseFloat(e) / 100 * 255) : va(parseInt(e, 10));
}
function Uu(r) {
  var e = r;
  return e.length && e.charAt(e.length - 1) === "%" ? Bp(parseFloat(e) / 100) : Bp(parseFloat(e));
}
function ZT(r, e, t) {
  return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? r + (e - r) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? r + (e - r) * (2 / 3 - t) * 6 : r;
}
function Ls(r, e, t) {
  return r + (e - r) * t;
}
function Cn(r, e, t, i, n) {
  return r[0] = e, r[1] = t, r[2] = i, r[3] = n, r;
}
function MA(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r;
}
var ZF = new kg(20), kv = null;
function kh(r, e) {
  kv && MA(kv, e), kv = ZF.put(r, kv || e.slice());
}
function pn(r, e) {
  if (r) {
    e = e || [];
    var t = ZF.get(r);
    if (t)
      return MA(e, t);
    r = r + "";
    var i = r.replace(/ /g, "").toLowerCase();
    if (i in gL)
      return MA(e, gL[i]), kh(r, e), e;
    var n = i.length;
    if (i.charAt(0) === "#") {
      if (n === 4 || n === 5) {
        var a = parseInt(i.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          Cn(e, 0, 0, 0, 1);
          return;
        }
        return Cn(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, n === 5 ? parseInt(i.slice(4), 16) / 15 : 1), kh(r, e), e;
      } else if (n === 7 || n === 9) {
        var a = parseInt(i.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          Cn(e, 0, 0, 0, 1);
          return;
        }
        return Cn(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, n === 9 ? parseInt(i.slice(7), 16) / 255 : 1), kh(r, e), e;
      }
      return;
    }
    var o = i.indexOf("("), s = i.indexOf(")");
    if (o !== -1 && s + 1 === n) {
      var l = i.substr(0, o), u = i.substr(o + 1, s - (o + 1)).split(","), h = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? Cn(e, +u[0], +u[1], +u[2], 1) : Cn(e, 0, 0, 0, 1);
          h = Uu(u.pop());
        case "rgb":
          if (u.length >= 3)
            return Cn(e, zT(u[0]), zT(u[1]), zT(u[2]), u.length === 3 ? h : Uu(u[3])), kh(r, e), e;
          Cn(e, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            Cn(e, 0, 0, 0, 1);
            return;
          }
          return u[3] = Uu(u[3]), kA(u, e), kh(r, e), e;
        case "hsl":
          if (u.length !== 3) {
            Cn(e, 0, 0, 0, 1);
            return;
          }
          return kA(u, e), kh(r, e), e;
        default:
          return;
      }
    }
    Cn(e, 0, 0, 0, 1);
  }
}
function kA(r, e) {
  var t = (parseFloat(r[0]) % 360 + 360) % 360 / 360, i = Uu(r[1]), n = Uu(r[2]), a = n <= 0.5 ? n * (i + 1) : n + i - n * i, o = n * 2 - a;
  return e = e || [], Cn(e, va(ZT(o, a, t + 1 / 3) * 255), va(ZT(o, a, t) * 255), va(ZT(o, a, t - 1 / 3) * 255), 1), r.length === 4 && (e[3] = r[3]), e;
}
function wre(r) {
  if (r) {
    var e = r[0] / 255, t = r[1] / 255, i = r[2] / 255, n = Math.min(e, t, i), a = Math.max(e, t, i), o = a - n, s = (a + n) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + n) : u = o / (2 - a - n);
      var h = ((a - e) / 6 + o / 2) / o, c = ((a - t) / 6 + o / 2) / o, f = ((a - i) / 6 + o / 2) / o;
      e === a ? l = f - c : t === a ? l = 1 / 3 + h - f : i === a && (l = 2 / 3 + c - h), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var d = [l * 360, u, s];
    return r[3] != null && d.push(r[3]), d;
  }
}
function QA(r, e) {
  var t = pn(r);
  if (t) {
    for (var i = 0; i < 3; i++)
      e < 0 ? t[i] = t[i] * (1 - e) | 0 : t[i] = (255 - t[i]) * e + t[i] | 0, t[i] > 255 ? t[i] = 255 : t[i] < 0 && (t[i] = 0);
    return ko(t, t.length === 4 ? "rgba" : "rgb");
  }
}
function qT(r, e, t) {
  if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
    t = t || [];
    var i = r * (e.length - 1), n = Math.floor(i), a = Math.ceil(i), o = e[n], s = e[a], l = i - n;
    return t[0] = va(Ls(o[0], s[0], l)), t[1] = va(Ls(o[1], s[1], l)), t[2] = va(Ls(o[2], s[2], l)), t[3] = Bp(Ls(o[3], s[3], l)), t;
  }
}
function Pre(r, e, t) {
  if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
    var i = r * (e.length - 1), n = Math.floor(i), a = Math.ceil(i), o = pn(e[n]), s = pn(e[a]), l = i - n, u = ko([
      va(Ls(o[0], s[0], l)),
      va(Ls(o[1], s[1], l)),
      va(Ls(o[2], s[2], l)),
      Bp(Ls(o[3], s[3], l))
    ], "rgba");
    return t ? {
      color: u,
      leftIndex: n,
      rightIndex: a,
      value: i
    } : u;
  }
}
function ip(r, e, t, i) {
  var n = pn(r);
  if (r)
    return n = wre(n), e != null && (n[0] = xre(e)), t != null && (n[1] = Uu(t)), i != null && (n[2] = Uu(i)), ko(kA(n), "rgba");
}
function dE(r, e) {
  var t = pn(r);
  if (t && e != null)
    return t[3] = Bp(e), ko(t, "rgba");
}
function ko(r, e) {
  if (!(!r || !r.length)) {
    var t = r[0] + "," + r[1] + "," + r[2];
    return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + r[3]), e + "(" + t + ")";
  }
}
function pE(r, e) {
  var t = pn(r);
  return t ? (0.299 * t[0] + 0.587 * t[1] + 0.114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0;
}
var gE = Math.round;
function Vp(r) {
  var e;
  if (!r || r === "transparent")
    r = "none";
  else if (typeof r == "string" && r.indexOf("rgba") > -1) {
    var t = pn(r);
    t && (r = "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")", e = t[3]);
  }
  return {
    color: r,
    opacity: e ?? 1
  };
}
var vL = 1e-4;
function Ds(r) {
  return r < vL && r > -vL;
}
function Qv(r) {
  return gE(r * 1e3) / 1e3;
}
function UA(r) {
  return gE(r * 1e4) / 1e4;
}
function Nre(r) {
  return "matrix(" + Qv(r[0]) + "," + Qv(r[1]) + "," + Qv(r[2]) + "," + Qv(r[3]) + "," + UA(r[4]) + "," + UA(r[5]) + ")";
}
var Lre = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function Dre(r, e, t) {
  return t === "top" ? r += e / 2 : t === "bottom" && (r -= e / 2), r;
}
function Mre(r) {
  return r && (r.shadowBlur || r.shadowOffsetX || r.shadowOffsetY);
}
function kre(r) {
  var e = r.style, t = r.getGlobalScale();
  return [
    e.shadowColor,
    (e.shadowBlur || 0).toFixed(2),
    (e.shadowOffsetX || 0).toFixed(2),
    (e.shadowOffsetY || 0).toFixed(2),
    t[0],
    t[1]
  ].join(",");
}
function qF(r) {
  return r && !!r.image;
}
function Qre(r) {
  return r && !!r.svgElement;
}
function II(r) {
  return qF(r) || Qre(r);
}
function jF(r) {
  return r.type === "linear";
}
function KF(r) {
  return r.type === "radial";
}
function JF(r) {
  return r && (r.type === "linear" || r.type === "radial");
}
function vS(r) {
  return "url(#" + r + ")";
}
function eX(r) {
  var e = r.getGlobalScale(), t = Math.max(e[0], e[1]);
  return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1);
}
function tX(r) {
  var e = r.x || 0, t = r.y || 0, i = (r.rotation || 0) * lm, n = ke(r.scaleX, 1), a = ke(r.scaleY, 1), o = r.skewX || 0, s = r.skewY || 0, l = [];
  return (e || t) && l.push("translate(" + e + "px," + t + "px)"), i && l.push("rotate(" + i + ")"), (n !== 1 || a !== 1) && l.push("scale(" + n + "," + a + ")"), (o || s) && l.push("skew(" + gE(o * lm) + "deg, " + gE(s * lm) + "deg)"), l.join(" ");
}
var Ure = function() {
  return st.hasGlobalWindow && ve(window.btoa) ? function(r) {
    return window.btoa(unescape(encodeURIComponent(r)));
  } : typeof Buffer < "u" ? function(r) {
    return Buffer.from(r).toString("base64");
  } : function(r) {
    return null;
  };
}(), $A = Array.prototype.slice;
function Co(r, e, t) {
  return (e - r) * t + r;
}
function jT(r, e, t, i) {
  for (var n = e.length, a = 0; a < n; a++)
    r[a] = Co(e[a], t[a], i);
  return r;
}
function $re(r, e, t, i) {
  for (var n = e.length, a = n && e[0].length, o = 0; o < n; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = Co(e[o][s], t[o][s], i);
  }
  return r;
}
function Uv(r, e, t, i) {
  for (var n = e.length, a = 0; a < n; a++)
    r[a] = e[a] + t[a] * i;
  return r;
}
function OL(r, e, t, i) {
  for (var n = e.length, a = n && e[0].length, o = 0; o < n; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = e[o][s] + t[o][s] * i;
  }
  return r;
}
function Gre(r, e) {
  for (var t = r.length, i = e.length, n = t > i ? e : r, a = Math.min(t, i), o = n[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(t, i); s++)
    n.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function Bre(r, e, t) {
  var i = r, n = e;
  if (!(!i.push || !n.push)) {
    var a = i.length, o = n.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        i.length = o;
      else
        for (var l = a; l < o; l++)
          i.push(t === 1 ? n[l] : $A.call(n[l]));
    }
    for (var u = i[0] && i[0].length, l = 0; l < i.length; l++)
      if (t === 1)
        isNaN(i[l]) && (i[l] = n[l]);
      else
        for (var h = 0; h < u; h++)
          isNaN(i[l][h]) && (i[l][h] = n[l][h]);
  }
}
function np(r) {
  if (ci(r)) {
    var e = r.length;
    if (ci(r[0])) {
      for (var t = [], i = 0; i < e; i++)
        t.push($A.call(r[i]));
      return t;
    }
    return $A.call(r);
  }
  return r;
}
function dm(r) {
  return r[0] = Math.floor(r[0]) || 0, r[1] = Math.floor(r[1]) || 0, r[2] = Math.floor(r[2]) || 0, r[3] = r[3] == null ? 1 : r[3], "rgba(" + r.join(",") + ")";
}
function Vre(r) {
  return ci(r && r[0]) ? 2 : 1;
}
var $v = 0, pm = 1, rX = 2, Ld = 3, GA = 4, BA = 5, mL = 6;
function EL(r) {
  return r === GA || r === BA;
}
function Gv(r) {
  return r === pm || r === rX;
}
var Zf = [0, 0, 0, 0], Fre = function() {
  function r(e) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
  }
  return r.prototype.isFinished = function() {
    return this._finished;
  }, r.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, r.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, r.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, r.prototype.addKeyframe = function(e, t, i) {
    this._needsSort = !0;
    var n = this.keyframes, a = n.length, o = !1, s = mL, l = t;
    if (ci(t)) {
      var u = Vre(t);
      s = u, (u === 1 && !ut(t[0]) || u === 2 && !ut(t[0][0])) && (o = !0);
    } else if (ut(t) && !$p(t))
      s = $v;
    else if (ne(t))
      if (!isNaN(+t))
        s = $v;
      else {
        var h = pn(t);
        h && (l = h, s = Ld);
      }
    else if (dS(t)) {
      var c = V({}, l);
      c.colorStops = Y(t.colorStops, function(d) {
        return {
          offset: d.offset,
          color: pn(d.color)
        };
      }), jF(t) ? s = GA : KF(t) && (s = BA), l = c;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === mL) && (o = !0), this.discrete = this.discrete || o;
    var f = {
      time: e,
      value: l,
      rawValue: t,
      percent: 0
    };
    return i && (f.easing = i, f.easingFunc = ve(i) ? i : BF[i] || _I(i)), n.push(f), f;
  }, r.prototype.prepare = function(e, t) {
    var i = this.keyframes;
    this._needsSort && i.sort(function(g, v) {
      return g.time - v.time;
    });
    for (var n = this.valType, a = i.length, o = i[a - 1], s = this.discrete, l = Gv(n), u = EL(n), h = 0; h < a; h++) {
      var c = i[h], f = c.value, d = o.value;
      c.percent = c.time / e, s || (l && h !== a - 1 ? Bre(f, d, n) : u && Gre(f.colorStops, d.colorStops));
    }
    if (!s && n !== BA && t && this.needsAnimate() && t.needsAnimate() && n === t.valType && !t._finished) {
      this._additiveTrack = t;
      for (var p = i[0].value, h = 0; h < a; h++)
        n === $v ? i[h].additiveValue = i[h].value - p : n === Ld ? i[h].additiveValue = Uv([], i[h].value, p, -1) : Gv(n) && (i[h].additiveValue = n === pm ? Uv([], i[h].value, p, -1) : OL([], i[h].value, p, -1));
    }
  }, r.prototype.step = function(e, t) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var i = this._additiveTrack != null, n = i ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Ld, h, c = this._lastFr, f = Math.min, d, p;
      if (s === 1)
        d = p = o[0];
      else {
        if (t < 0)
          h = 0;
        else if (t < this._lastFrP) {
          var g = f(c + 1, s - 1);
          for (h = g; h >= 0 && !(o[h].percent <= t); h--)
            ;
          h = f(h, s - 2);
        } else {
          for (h = c; h < s && !(o[h].percent > t); h++)
            ;
          h = f(h - 1, s - 2);
        }
        p = o[h + 1], d = o[h];
      }
      if (d && p) {
        this._lastFr = h, this._lastFrP = t;
        var v = p.percent - d.percent, O = v === 0 ? 1 : f((t - d.percent) / v, 1);
        p.easingFunc && (O = p.easingFunc(O));
        var m = i ? this._additiveValue : u ? Zf : e[l];
        if ((Gv(a) || u) && !m && (m = this._additiveValue = []), this.discrete)
          e[l] = O < 1 ? d.rawValue : p.rawValue;
        else if (Gv(a))
          a === pm ? jT(m, d[n], p[n], O) : $re(m, d[n], p[n], O);
        else if (EL(a)) {
          var E = d[n], b = p[n], T = a === GA;
          e[l] = {
            type: T ? "linear" : "radial",
            x: Co(E.x, b.x, O),
            y: Co(E.y, b.y, O),
            colorStops: Y(E.colorStops, function(y, A) {
              var C = b.colorStops[A];
              return {
                offset: Co(y.offset, C.offset, O),
                color: dm(jT([], y.color, C.color, O))
              };
            }),
            global: b.global
          }, T ? (e[l].x2 = Co(E.x2, b.x2, O), e[l].y2 = Co(E.y2, b.y2, O)) : e[l].r = Co(E.r, b.r, O);
        } else if (u)
          jT(m, d[n], p[n], O), i || (e[l] = dm(m));
        else {
          var S = Co(d[n], p[n], O);
          i ? this._additiveValue = S : e[l] = S;
        }
        i && this._addToTarget(e);
      }
    }
  }, r.prototype._addToTarget = function(e) {
    var t = this.valType, i = this.propName, n = this._additiveValue;
    t === $v ? e[i] = e[i] + n : t === Ld ? (pn(e[i], Zf), Uv(Zf, Zf, n, 1), e[i] = dm(Zf)) : t === pm ? Uv(e[i], e[i], n, 1) : t === rX && OL(e[i], e[i], n, 1);
  }, r;
}(), xI = function() {
  function r(e, t, i, n) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && n) {
      bI("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = n, this._allowDiscrete = i;
  }
  return r.prototype.getMaxTime = function() {
    return this._maxTime;
  }, r.prototype.getDelay = function() {
    return this._delay;
  }, r.prototype.getLoop = function() {
    return this._loop;
  }, r.prototype.getTarget = function() {
    return this._target;
  }, r.prototype.changeTarget = function(e) {
    this._target = e;
  }, r.prototype.when = function(e, t, i) {
    return this.whenWithKeys(e, t, He(t), i);
  }, r.prototype.whenWithKeys = function(e, t, i, n) {
    for (var a = this._tracks, o = 0; o < i.length; o++) {
      var s = i[o], l = a[s];
      if (!l) {
        l = a[s] = new Fre(s);
        var u = void 0, h = this._getAdditiveTrack(s);
        if (h) {
          var c = h.keyframes, f = c[c.length - 1];
          u = f && f.value, h.valType === Ld && u && (u = dm(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        e > 0 && l.addKeyframe(0, np(u), n), this._trackKeys.push(s);
      }
      l.addKeyframe(e, np(t[s]), n);
    }
    return this._maxTime = Math.max(this._maxTime, e), this;
  }, r.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, r.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, r.prototype.isPaused = function() {
    return !!this._paused;
  }, r.prototype.duration = function(e) {
    return this._maxTime = e, this._force = !0, this;
  }, r.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var e = this._doneCbs;
    if (e)
      for (var t = e.length, i = 0; i < t; i++)
        e[i].call(this);
  }, r.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var e = this.animation, t = this._abortedCbs;
    if (e && e.removeClip(this._clip), this._clip = null, t)
      for (var i = 0; i < t.length; i++)
        t[i].call(this);
  }, r.prototype._setTracksFinished = function() {
    for (var e = this._tracks, t = this._trackKeys, i = 0; i < t.length; i++)
      e[t[i]].setFinished();
  }, r.prototype._getAdditiveTrack = function(e) {
    var t, i = this._additiveAnimators;
    if (i)
      for (var n = 0; n < i.length; n++) {
        var a = i[n].getTrack(e);
        a && (t = a);
      }
    return t;
  }, r.prototype.start = function(e) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var t = this, i = [], n = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, h = u.length;
        if (s.prepare(n, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var c = u[h - 1];
            c && (t._target[s.propName] = c.rawValue), s.setFinished();
          } else
            i.push(s);
      }
      if (i.length || this._force) {
        var f = new Cre({
          life: n,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(d) {
            t._started = 2;
            var p = t._additiveAnimators;
            if (p) {
              for (var g = !1, v = 0; v < p.length; v++)
                if (p[v]._clip) {
                  g = !0;
                  break;
                }
              g || (t._additiveAnimators = null);
            }
            for (var v = 0; v < i.length; v++)
              i[v].step(t._target, d);
            var O = t._onframeCbs;
            if (O)
              for (var v = 0; v < O.length; v++)
                O[v](t._target, d);
          },
          ondestroy: function() {
            t._doneCallback();
          }
        });
        this._clip = f, this.animation && this.animation.addClip(f), e && f.setEasing(e);
      } else
        this._doneCallback();
      return this;
    }
  }, r.prototype.stop = function(e) {
    if (this._clip) {
      var t = this._clip;
      e && t.onframe(1), this._abortedCallback();
    }
  }, r.prototype.delay = function(e) {
    return this._delay = e, this;
  }, r.prototype.during = function(e) {
    return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
  }, r.prototype.done = function(e) {
    return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
  }, r.prototype.aborted = function(e) {
    return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
  }, r.prototype.getClip = function() {
    return this._clip;
  }, r.prototype.getTrack = function(e) {
    return this._tracks[e];
  }, r.prototype.getTracks = function() {
    var e = this;
    return Y(this._trackKeys, function(t) {
      return e._tracks[t];
    });
  }, r.prototype.stopTracks = function(e, t) {
    if (!e.length || !this._clip)
      return !0;
    for (var i = this._tracks, n = this._trackKeys, a = 0; a < e.length; a++) {
      var o = i[e[a]];
      o && !o.isFinished() && (t ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < n.length; a++)
      if (!i[n[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, r.prototype.saveTo = function(e, t, i) {
    if (e) {
      t = t || this._trackKeys;
      for (var n = 0; n < t.length; n++) {
        var a = t[n], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[i ? 0 : s.length - 1];
          l && (e[a] = np(l.rawValue));
        }
      }
    }
  }, r.prototype.__changeFinalValue = function(e, t) {
    t = t || He(e);
    for (var i = 0; i < t.length; i++) {
      var n = t[i], a = this._tracks[n];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, e[n]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, r;
}();
function gc() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var Xre = function(r) {
  U(e, r);
  function e(t) {
    var i = r.call(this) || this;
    return i._running = !1, i._time = 0, i._pausedTime = 0, i._pauseStart = 0, i._paused = !1, t = t || {}, i.stage = t.stage || {}, i;
  }
  return e.prototype.addClip = function(t) {
    t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
  }, e.prototype.addAnimator = function(t) {
    t.animation = this;
    var i = t.getClip();
    i && this.addClip(i);
  }, e.prototype.removeClip = function(t) {
    if (t.animation) {
      var i = t.prev, n = t.next;
      i ? i.next = n : this._head = n, n ? n.prev = i : this._tail = i, t.next = t.prev = t.animation = null;
    }
  }, e.prototype.removeAnimator = function(t) {
    var i = t.getClip();
    i && this.removeClip(i), t.animation = null;
  }, e.prototype.update = function(t) {
    for (var i = gc() - this._pausedTime, n = i - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(i, n);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = i, t || (this.trigger("frame", n), this.stage.update && this.stage.update());
  }, e.prototype._startLoop = function() {
    var t = this;
    this._running = !0;
    function i() {
      t._running && (LA(i), !t._paused && t.update());
    }
    LA(i);
  }, e.prototype.start = function() {
    this._running || (this._time = gc(), this._pausedTime = 0, this._startLoop());
  }, e.prototype.stop = function() {
    this._running = !1;
  }, e.prototype.pause = function() {
    this._paused || (this._pauseStart = gc(), this._paused = !0);
  }, e.prototype.resume = function() {
    this._paused && (this._pausedTime += gc() - this._pauseStart, this._paused = !1);
  }, e.prototype.clear = function() {
    for (var t = this._head; t; ) {
      var i = t.next;
      t.prev = t.next = t.animation = null, t = i;
    }
    this._head = this._tail = null;
  }, e.prototype.isFinished = function() {
    return this._head == null;
  }, e.prototype.animate = function(t, i) {
    i = i || {}, this.start();
    var n = new xI(t, i.loop);
    return this.addAnimator(n), n;
  }, e;
}(jn);
const Yre = Xre;
var Hre = 300, KT = st.domSupported, JT = function() {
  var r = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], e = [
    "touchstart",
    "touchend",
    "touchmove"
  ], t = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, i = Y(r, function(n) {
    var a = n.replace("mouse", "pointer");
    return t.hasOwnProperty(a) ? a : n;
  });
  return {
    mouse: r,
    touch: e,
    pointer: i
  };
}(), bL = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, SL = !1;
function VA(r) {
  var e = r.pointerType;
  return e === "pen" || e === "touch";
}
function Wre(r) {
  r.touching = !0, r.touchTimer != null && (clearTimeout(r.touchTimer), r.touchTimer = null), r.touchTimer = setTimeout(function() {
    r.touching = !1, r.touchTimer = null;
  }, 700);
}
function ey(r) {
  r && (r.zrByTouch = !0);
}
function zre(r, e) {
  return _n(r.dom, new Zre(r, e), !0);
}
function iX(r, e) {
  for (var t = e, i = !1; t && t.nodeType !== 9 && !(i = t.domBelongToZr || t !== e && t === r.painterRoot); )
    t = t.parentNode;
  return i;
}
var Zre = function() {
  function r(e, t) {
    this.stopPropagation = ar, this.stopImmediatePropagation = ar, this.preventDefault = ar, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY;
  }
  return r;
}(), aa = {
  mousedown: function(r) {
    r = _n(this.dom, r), this.__mayPointerCapture = [r.zrX, r.zrY], this.trigger("mousedown", r);
  },
  mousemove: function(r) {
    r = _n(this.dom, r);
    var e = this.__mayPointerCapture;
    e && (r.zrX !== e[0] || r.zrY !== e[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    r = _n(this.dom, r), this.__togglePointerCapture(!1), this.trigger("mouseup", r);
  },
  mouseout: function(r) {
    r = _n(this.dom, r);
    var e = r.toElement || r.relatedTarget;
    iX(this, e) || (this.__pointerCapturing && (r.zrEventControl = "no_globalout"), this.trigger("mouseout", r));
  },
  wheel: function(r) {
    SL = !0, r = _n(this.dom, r), this.trigger("mousewheel", r);
  },
  mousewheel: function(r) {
    SL || (r = _n(this.dom, r), this.trigger("mousewheel", r));
  },
  touchstart: function(r) {
    r = _n(this.dom, r), ey(r), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(r, "start"), aa.mousemove.call(this, r), aa.mousedown.call(this, r);
  },
  touchmove: function(r) {
    r = _n(this.dom, r), ey(r), this.handler.processGesture(r, "change"), aa.mousemove.call(this, r);
  },
  touchend: function(r) {
    r = _n(this.dom, r), ey(r), this.handler.processGesture(r, "end"), aa.mouseup.call(this, r), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < Hre && aa.click.call(this, r);
  },
  pointerdown: function(r) {
    aa.mousedown.call(this, r);
  },
  pointermove: function(r) {
    VA(r) || aa.mousemove.call(this, r);
  },
  pointerup: function(r) {
    aa.mouseup.call(this, r);
  },
  pointerout: function(r) {
    VA(r) || aa.mouseout.call(this, r);
  }
};
w(["click", "dblclick", "contextmenu"], function(r) {
  aa[r] = function(e) {
    e = _n(this.dom, e), this.trigger(r, e);
  };
});
var FA = {
  pointermove: function(r) {
    VA(r) || FA.mousemove.call(this, r);
  },
  pointerup: function(r) {
    FA.mouseup.call(this, r);
  },
  mousemove: function(r) {
    this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    var e = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", r), e && (r.zrEventControl = "only_globalout", this.trigger("mouseout", r));
  }
};
function qre(r, e) {
  var t = e.domHandlers;
  st.pointerEventsSupported ? w(JT.pointer, function(i) {
    gm(e, i, function(n) {
      t[i].call(r, n);
    });
  }) : (st.touchEventsSupported && w(JT.touch, function(i) {
    gm(e, i, function(n) {
      t[i].call(r, n), Wre(e);
    });
  }), w(JT.mouse, function(i) {
    gm(e, i, function(n) {
      n = RI(n), e.touching || t[i].call(r, n);
    });
  }));
}
function jre(r, e) {
  st.pointerEventsSupported ? w(bL.pointer, t) : st.touchEventsSupported || w(bL.mouse, t);
  function t(i) {
    function n(a) {
      a = RI(a), iX(r, a.target) || (a = zre(r, a), e.domHandlers[i].call(r, a));
    }
    gm(e, i, n, { capture: !0 });
  }
}
function gm(r, e, t, i) {
  r.mounted[e] = t, r.listenerOpts[e] = i, NA(r.domTarget, e, t, i);
}
function ty(r) {
  var e = r.mounted;
  for (var t in e)
    e.hasOwnProperty(t) && nre(r.domTarget, t, e[t], r.listenerOpts[t]);
  r.mounted = {};
}
var TL = function() {
  function r(e, t) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = e, this.domHandlers = t;
  }
  return r;
}(), Kre = function(r) {
  U(e, r);
  function e(t, i) {
    var n = r.call(this) || this;
    return n.__pointerCapturing = !1, n.dom = t, n.painterRoot = i, n._localHandlerScope = new TL(t, aa), KT && (n._globalHandlerScope = new TL(document, FA)), qre(n, n._localHandlerScope), n;
  }
  return e.prototype.dispose = function() {
    ty(this._localHandlerScope), KT && ty(this._globalHandlerScope);
  }, e.prototype.setCursor = function(t) {
    this.dom.style && (this.dom.style.cursor = t || "default");
  }, e.prototype.__togglePointerCapture = function(t) {
    if (this.__mayPointerCapture = null, KT && +this.__pointerCapturing ^ +t) {
      this.__pointerCapturing = t;
      var i = this._globalHandlerScope;
      t ? jre(this, i) : ty(i);
    }
  }, e;
}(jn);
const Jre = Kre;
var nX = 1;
st.hasGlobalWindow && (nX = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var vE = nX, XA = 0.4, YA = "#333", HA = "#ccc", eie = "#eee", yL = gS, RL = 5e-5;
function Dl(r) {
  return r > RL || r < -RL;
}
var Ml = [], Qh = [], ry = Zn(), iy = Math.abs, tie = function() {
  function r() {
  }
  return r.prototype.getLocalTransform = function(e) {
    return r.getLocalTransform(this, e);
  }, r.prototype.setPosition = function(e) {
    this.x = e[0], this.y = e[1];
  }, r.prototype.setScale = function(e) {
    this.scaleX = e[0], this.scaleY = e[1];
  }, r.prototype.setSkew = function(e) {
    this.skewX = e[0], this.skewY = e[1];
  }, r.prototype.setOrigin = function(e) {
    this.originX = e[0], this.originY = e[1];
  }, r.prototype.needLocalTransform = function() {
    return Dl(this.rotation) || Dl(this.x) || Dl(this.y) || Dl(this.scaleX - 1) || Dl(this.scaleY - 1) || Dl(this.skewX) || Dl(this.skewY);
  }, r.prototype.updateTransform = function() {
    var e = this.parent && this.parent.transform, t = this.needLocalTransform(), i = this.transform;
    if (!(t || e)) {
      i && (yL(i), this.invTransform = null);
      return;
    }
    i = i || Zn(), t ? this.getLocalTransform(i) : yL(i), e && (t ? Mo(i, e, i) : AI(i, e)), this.transform = i, this._resolveGlobalScaleRatio(i);
  }, r.prototype._resolveGlobalScaleRatio = function(e) {
    var t = this.globalScaleRatio;
    if (t != null && t !== 1) {
      this.getGlobalScale(Ml);
      var i = Ml[0] < 0 ? -1 : 1, n = Ml[1] < 0 ? -1 : 1, a = ((Ml[0] - i) * t + i) / Ml[0] || 0, o = ((Ml[1] - n) * t + n) / Ml[1] || 0;
      e[0] *= a, e[1] *= a, e[2] *= o, e[3] *= o;
    }
    this.invTransform = this.invTransform || Zn(), Ef(this.invTransform, e);
  }, r.prototype.getComputedTransform = function() {
    for (var e = this, t = []; e; )
      t.push(e), e = e.parent;
    for (; e = t.pop(); )
      e.updateTransform();
    return this.transform;
  }, r.prototype.setLocalTransform = function(e) {
    if (e) {
      var t = e[0] * e[0] + e[1] * e[1], i = e[2] * e[2] + e[3] * e[3], n = Math.atan2(e[1], e[0]), a = Math.PI / 2 + n - Math.atan2(e[3], e[2]);
      i = Math.sqrt(i) * Math.cos(a), t = Math.sqrt(t), this.skewX = a, this.skewY = 0, this.rotation = -n, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = i, this.originX = 0, this.originY = 0;
    }
  }, r.prototype.decomposeTransform = function() {
    if (this.transform) {
      var e = this.parent, t = this.transform;
      e && e.transform && (Mo(Qh, e.invTransform, t), t = Qh);
      var i = this.originX, n = this.originY;
      (i || n) && (ry[4] = i, ry[5] = n, Mo(Qh, t, ry), Qh[4] -= i, Qh[5] -= n, t = Qh), this.setLocalTransform(t);
    }
  }, r.prototype.getGlobalScale = function(e) {
    var t = this.transform;
    return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
  }, r.prototype.transformCoordToLocal = function(e, t) {
    var i = [e, t], n = this.invTransform;
    return n && Hr(i, i, n), i;
  }, r.prototype.transformCoordToGlobal = function(e, t) {
    var i = [e, t], n = this.transform;
    return n && Hr(i, i, n), i;
  }, r.prototype.getLineScale = function() {
    var e = this.transform;
    return e && iy(e[0] - 1) > 1e-10 && iy(e[3] - 1) > 1e-10 ? Math.sqrt(iy(e[0] * e[3] - e[2] * e[1])) : 1;
  }, r.prototype.copyTransform = function(e) {
    aX(this, e);
  }, r.getLocalTransform = function(e, t) {
    t = t || [];
    var i = e.originX || 0, n = e.originY || 0, a = e.scaleX, o = e.scaleY, s = e.anchorX, l = e.anchorY, u = e.rotation || 0, h = e.x, c = e.y, f = e.skewX ? Math.tan(e.skewX) : 0, d = e.skewY ? Math.tan(-e.skewY) : 0;
    if (i || n || s || l) {
      var p = i + s, g = n + l;
      t[4] = -p * a - f * g * o, t[5] = -g * o - d * p * a;
    } else
      t[4] = t[5] = 0;
    return t[0] = a, t[3] = o, t[1] = d * a, t[2] = f * o, u && bh(t, t, u), t[4] += i + h, t[5] += n + c, t;
  }, r.initDefaultProps = function() {
    var e = r.prototype;
    e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
  }(), r;
}(), oo = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function aX(r, e) {
  for (var t = 0; t < oo.length; t++) {
    var i = oo[t];
    r[i] = e[i];
  }
}
const wo = tie;
var AL = {};
function gn(r, e) {
  e = e || rl;
  var t = AL[e];
  t || (t = AL[e] = new kg(500));
  var i = t.get(r);
  return i == null && (i = il.measureText(r, e).width, t.put(r, i)), i;
}
function CL(r, e, t, i) {
  var n = gn(r, e), a = OS(e), o = Dd(0, n, t), s = sc(0, a, i), l = new Ue(o, s, n, a);
  return l;
}
function Qg(r, e, t, i) {
  var n = ((r || "") + "").split(`
`), a = n.length;
  if (a === 1)
    return CL(n[0], e, t, i);
  for (var o = new Ue(0, 0, 0, 0), s = 0; s < n.length; s++) {
    var l = CL(n[s], e, t, i);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function Dd(r, e, t) {
  return t === "right" ? r -= e : t === "center" && (r -= e / 2), r;
}
function sc(r, e, t) {
  return t === "middle" ? r -= e / 2 : t === "bottom" && (r -= e), r;
}
function OS(r) {
  return gn("", r);
}
function Ea(r, e) {
  return typeof r == "string" ? r.lastIndexOf("%") >= 0 ? parseFloat(r) / 100 * e : parseFloat(r) : r;
}
function OE(r, e, t) {
  var i = e.position || "inside", n = e.distance != null ? e.distance : 5, a = t.height, o = t.width, s = a / 2, l = t.x, u = t.y, h = "left", c = "top";
  if (i instanceof Array)
    l += Ea(i[0], t.width), u += Ea(i[1], t.height), h = null, c = null;
  else
    switch (i) {
      case "left":
        l -= n, u += s, h = "right", c = "middle";
        break;
      case "right":
        l += n + o, u += s, c = "middle";
        break;
      case "top":
        l += o / 2, u -= n, h = "center", c = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + n, h = "center";
        break;
      case "inside":
        l += o / 2, u += s, h = "center", c = "middle";
        break;
      case "insideLeft":
        l += n, u += s, c = "middle";
        break;
      case "insideRight":
        l += o - n, u += s, h = "right", c = "middle";
        break;
      case "insideTop":
        l += o / 2, u += n, h = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - n, h = "center", c = "bottom";
        break;
      case "insideTopLeft":
        l += n, u += n;
        break;
      case "insideTopRight":
        l += o - n, u += n, h = "right";
        break;
      case "insideBottomLeft":
        l += n, u += a - n, c = "bottom";
        break;
      case "insideBottomRight":
        l += o - n, u += a - n, h = "right", c = "bottom";
        break;
    }
  return r = r || {}, r.x = l, r.y = u, r.align = h, r.verticalAlign = c, r;
}
var ny = "__zr_normal__", ay = oo.concat(["ignore"]), rie = no(oo, function(r, e) {
  return r[e] = !0, r;
}, { ignore: !1 }), Uh = {}, iie = new Ue(0, 0, 0, 0), wI = function() {
  function r(e) {
    this.id = PF(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
  }
  return r.prototype._init = function(e) {
    this.attr(e);
  }, r.prototype.drift = function(e, t, i) {
    switch (this.draggable) {
      case "horizontal":
        t = 0;
        break;
      case "vertical":
        e = 0;
        break;
    }
    var n = this.transform;
    n || (n = this.transform = [1, 0, 0, 1, 0, 0]), n[4] += e, n[5] += t, this.decomposeTransform(), this.markRedraw();
  }, r.prototype.beforeUpdate = function() {
  }, r.prototype.afterUpdate = function() {
  }, r.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, r.prototype.updateInnerText = function(e) {
    var t = this._textContent;
    if (t && (!t.ignore || e)) {
      this.textConfig || (this.textConfig = {});
      var i = this.textConfig, n = i.local, a = t.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = n ? this : null;
      var u = !1;
      if (a.copyTransform(t), i.position != null) {
        var h = iie;
        i.layoutRect ? h.copy(i.layoutRect) : h.copy(this.getBoundingRect()), n || h.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Uh, i, h) : OE(Uh, i, h), a.x = Uh.x, a.y = Uh.y, o = Uh.align, s = Uh.verticalAlign;
        var c = i.origin;
        if (c && i.rotation != null) {
          var f = void 0, d = void 0;
          c === "center" ? (f = h.width * 0.5, d = h.height * 0.5) : (f = Ea(c[0], h.width), d = Ea(c[1], h.height)), u = !0, a.originX = -a.x + f + (n ? 0 : h.x), a.originY = -a.y + d + (n ? 0 : h.y);
        }
      }
      i.rotation != null && (a.rotation = i.rotation);
      var p = i.offset;
      p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
      var g = i.inside == null ? typeof i.position == "string" && i.position.indexOf("inside") >= 0 : i.inside, v = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), O = void 0, m = void 0, E = void 0;
      g && this.canBeInsideText() ? (O = i.insideFill, m = i.insideStroke, (O == null || O === "auto") && (O = this.getInsideTextFill()), (m == null || m === "auto") && (m = this.getInsideTextStroke(O), E = !0)) : (O = i.outsideFill, m = i.outsideStroke, (O == null || O === "auto") && (O = this.getOutsideFill()), (m == null || m === "auto") && (m = this.getOutsideStroke(O), E = !0)), O = O || "#000", (O !== v.fill || m !== v.stroke || E !== v.autoStroke || o !== v.align || s !== v.verticalAlign) && (l = !0, v.fill = O, v.stroke = m, v.autoStroke = E, v.align = o, v.verticalAlign = s, t.setDefaultTextStyle(v)), t.__dirty |= un, l && t.dirtyStyle(!0);
    }
  }, r.prototype.canBeInsideText = function() {
    return !0;
  }, r.prototype.getInsideTextFill = function() {
    return "#fff";
  }, r.prototype.getInsideTextStroke = function(e) {
    return "#000";
  }, r.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? HA : YA;
  }, r.prototype.getOutsideStroke = function(e) {
    var t = this.__zr && this.__zr.getBackgroundColor(), i = typeof t == "string" && pn(t);
    i || (i = [255, 255, 255, 1]);
    for (var n = i[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      i[o] = i[o] * n + (a ? 0 : 255) * (1 - n);
    return i[3] = 1, ko(i, "rgba");
  }, r.prototype.traverse = function(e, t) {
  }, r.prototype.attrKV = function(e, t) {
    e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, V(this.extra, t)) : this[e] = t;
  }, r.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, r.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, r.prototype.attr = function(e, t) {
    if (typeof e == "string")
      this.attrKV(e, t);
    else if (be(e))
      for (var i = e, n = He(i), a = 0; a < n.length; a++) {
        var o = n[a];
        this.attrKV(o, e[o]);
      }
    return this.markRedraw(), this;
  }, r.prototype.saveCurrentToNormalState = function(e) {
    this._innerSaveToNormal(e);
    for (var t = this._normalState, i = 0; i < this.animators.length; i++) {
      var n = this.animators[i], a = n.__fromStateTransition;
      if (!(n.getLoop() || a && a !== ny)) {
        var o = n.targetName, s = o ? t[o] : t;
        n.saveTo(s);
      }
    }
  }, r.prototype._innerSaveToNormal = function(e) {
    var t = this._normalState;
    t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, ay);
  }, r.prototype._savePrimaryToNormal = function(e, t, i) {
    for (var n = 0; n < i.length; n++) {
      var a = i[n];
      e[a] != null && !(a in t) && (t[a] = this[a]);
    }
  }, r.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, r.prototype.getState = function(e) {
    return this.states[e];
  }, r.prototype.ensureState = function(e) {
    var t = this.states;
    return t[e] || (t[e] = {}), t[e];
  }, r.prototype.clearStates = function(e) {
    this.useState(ny, !1, e);
  }, r.prototype.useState = function(e, t, i, n) {
    var a = e === ny, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(Ge(s, e) >= 0 && (t || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !a) {
          bI("State " + e + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var h = !!(u && u.hoverLayer || n);
        h && this._toggleHoverLayerFlag(!0), this._applyStateObj(e, u, this._normalState, t, !i && !this.__inHover && l && l.duration > 0, l);
        var c = this._textContent, f = this._textGuide;
        return c && c.useState(e, t, i, h), f && f.useState(e, t, i, h), a ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [e], this._updateAnimationTargets(), this.markRedraw(), !h && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~un), u;
      }
    }
  }, r.prototype.useStates = function(e, t, i) {
    if (!e.length)
      this.clearStates();
    else {
      var n = [], a = this.currentStates, o = e.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (e[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = e[l], h = void 0;
        this.stateProxy && (h = this.stateProxy(u, e)), h || (h = this.states[u]), h && n.push(h);
      }
      var c = n[o - 1], f = !!(c && c.hoverLayer || i);
      f && this._toggleHoverLayerFlag(!0);
      var d = this._mergeStates(n), p = this.stateTransition;
      this.saveCurrentToNormalState(d), this._applyStateObj(e.join(","), d, this._normalState, !1, !t && !this.__inHover && p && p.duration > 0, p);
      var g = this._textContent, v = this._textGuide;
      g && g.useStates(e, t, f), v && v.useStates(e, t, f), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~un);
    }
  }, r.prototype._updateAnimationTargets = function() {
    for (var e = 0; e < this.animators.length; e++) {
      var t = this.animators[e];
      t.targetName && t.changeTarget(this[t.targetName]);
    }
  }, r.prototype.removeState = function(e) {
    var t = Ge(this.currentStates, e);
    if (t >= 0) {
      var i = this.currentStates.slice();
      i.splice(t, 1), this.useStates(i);
    }
  }, r.prototype.replaceState = function(e, t, i) {
    var n = this.currentStates.slice(), a = Ge(n, e), o = Ge(n, t) >= 0;
    a >= 0 ? o ? n.splice(a, 1) : n[a] = t : i && !o && n.push(t), this.useStates(n);
  }, r.prototype.toggleState = function(e, t) {
    t ? this.useState(e, !0) : this.removeState(e);
  }, r.prototype._mergeStates = function(e) {
    for (var t = {}, i, n = 0; n < e.length; n++) {
      var a = e[n];
      V(t, a), a.textConfig && (i = i || {}, V(i, a.textConfig));
    }
    return i && (t.textConfig = i), t;
  }, r.prototype._applyStateObj = function(e, t, i, n, a, o) {
    var s = !(t && n);
    t && t.textConfig ? (this.textConfig = V({}, n ? this.textConfig : i.textConfig), V(this.textConfig, t.textConfig)) : s && i.textConfig && (this.textConfig = i.textConfig);
    for (var l = {}, u = !1, h = 0; h < ay.length; h++) {
      var c = ay[h], f = a && rie[c];
      t && t[c] != null ? f ? (u = !0, l[c] = t[c]) : this[c] = t[c] : s && i[c] != null && (f ? (u = !0, l[c] = i[c]) : this[c] = i[c]);
    }
    if (!a)
      for (var h = 0; h < this.animators.length; h++) {
        var d = this.animators[h], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (t || i)[p] : t || i);
      }
    u && this._transitionState(e, l, o);
  }, r.prototype._attachComponent = function(e) {
    if (!(e.__zr && !e.__hostTarget) && e !== this) {
      var t = this.__zr;
      t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this;
    }
  }, r.prototype._detachComponent = function(e) {
    e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
  }, r.prototype.getClipPath = function() {
    return this._clipPath;
  }, r.prototype.setClipPath = function(e) {
    this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
  }, r.prototype.removeClipPath = function() {
    var e = this._clipPath;
    e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
  }, r.prototype.getTextContent = function() {
    return this._textContent;
  }, r.prototype.setTextContent = function(e) {
    var t = this._textContent;
    t !== e && (t && t !== e && this.removeTextContent(), e.innerTransformable = new wo(), this._attachComponent(e), this._textContent = e, this.markRedraw());
  }, r.prototype.setTextConfig = function(e) {
    this.textConfig || (this.textConfig = {}), V(this.textConfig, e), this.markRedraw();
  }, r.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, r.prototype.removeTextContent = function() {
    var e = this._textContent;
    e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, r.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, r.prototype.setTextGuideLine = function(e) {
    this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
  }, r.prototype.removeTextGuideLine = function() {
    var e = this._textGuide;
    e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
  }, r.prototype.markRedraw = function() {
    this.__dirty |= un;
    var e = this.__zr;
    e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, r.prototype.dirty = function() {
    this.markRedraw();
  }, r.prototype._toggleHoverLayerFlag = function(e) {
    this.__inHover = e;
    var t = this._textContent, i = this._textGuide;
    t && (t.__inHover = e), i && (i.__inHover = e);
  }, r.prototype.addSelfToZr = function(e) {
    if (this.__zr !== e) {
      this.__zr = e;
      var t = this.animators;
      if (t)
        for (var i = 0; i < t.length; i++)
          e.animation.addAnimator(t[i]);
      this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
    }
  }, r.prototype.removeSelfFromZr = function(e) {
    if (this.__zr) {
      this.__zr = null;
      var t = this.animators;
      if (t)
        for (var i = 0; i < t.length; i++)
          e.animation.removeAnimator(t[i]);
      this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
    }
  }, r.prototype.animate = function(e, t, i) {
    var n = e ? this[e] : this, a = new xI(n, t, i);
    return e && (a.targetName = e), this.addAnimator(a, e), a;
  }, r.prototype.addAnimator = function(e, t) {
    var i = this.__zr, n = this;
    e.during(function() {
      n.updateDuringAnimation(t);
    }).done(function() {
      var a = n.animators, o = Ge(a, e);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(e), i && i.animation.addAnimator(e), i && i.wakeUp();
  }, r.prototype.updateDuringAnimation = function(e) {
    this.markRedraw();
  }, r.prototype.stopAnimation = function(e, t) {
    for (var i = this.animators, n = i.length, a = [], o = 0; o < n; o++) {
      var s = i[o];
      !e || e === s.scope ? s.stop(t) : a.push(s);
    }
    return this.animators = a, this;
  }, r.prototype.animateTo = function(e, t, i) {
    oy(this, e, t, i);
  }, r.prototype.animateFrom = function(e, t, i) {
    oy(this, e, t, i, !0);
  }, r.prototype._transitionState = function(e, t, i, n) {
    for (var a = oy(this, t, i, n), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = e;
  }, r.prototype.getBoundingRect = function() {
    return null;
  }, r.prototype.getPaintRect = function() {
    return null;
  }, r.initDefaultProps = function() {
    var e = r.prototype;
    e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = !1, e.__dirty = un;
    function t(i, n, a, o) {
      Object.defineProperty(e, i, {
        get: function() {
          if (!this[n]) {
            var l = this[n] = [];
            s(this, l);
          }
          return this[n];
        },
        set: function(l) {
          this[a] = l[0], this[o] = l[1], this[n] = l, s(this, l);
        }
      });
      function s(l, u) {
        Object.defineProperty(u, 0, {
          get: function() {
            return l[a];
          },
          set: function(h) {
            l[a] = h;
          }
        }), Object.defineProperty(u, 1, {
          get: function() {
            return l[o];
          },
          set: function(h) {
            l[o] = h;
          }
        });
      }
    }
    Object.defineProperty && (t("position", "_legacyPos", "x", "y"), t("scale", "_legacyScale", "scaleX", "scaleY"), t("origin", "_legacyOrigin", "originX", "originY"));
  }(), r;
}();
hr(wI, jn);
hr(wI, wo);
function oy(r, e, t, i, n) {
  t = t || {};
  var a = [];
  oX(r, "", r, e, t, i, a, n);
  var o = a.length, s = !1, l = t.done, u = t.aborted, h = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, c = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && t.during && a[0].during(function(p, g) {
    t.during(g);
  });
  for (var f = 0; f < a.length; f++) {
    var d = a[f];
    h && d.done(h), c && d.aborted(c), t.force && d.duration(t.duration), d.start(t.easing);
  }
  return a;
}
function sy(r, e, t) {
  for (var i = 0; i < t; i++)
    r[i] = e[i];
}
function nie(r) {
  return ci(r[0]);
}
function aie(r, e, t) {
  if (ci(e[t]))
    if (ci(r[t]) || (r[t] = []), vn(e[t])) {
      var i = e[t].length;
      r[t].length !== i && (r[t] = new e[t].constructor(i), sy(r[t], e[t], i));
    } else {
      var n = e[t], a = r[t], o = n.length;
      if (nie(n))
        for (var s = n[0].length, l = 0; l < o; l++)
          a[l] ? sy(a[l], n[l], s) : a[l] = Array.prototype.slice.call(n[l]);
      else
        sy(a, n, o);
      a.length = n.length;
    }
  else
    r[t] = e[t];
}
function oie(r, e) {
  return r === e || ci(r) && ci(e) && sie(r, e);
}
function sie(r, e) {
  var t = r.length;
  if (t !== e.length)
    return !1;
  for (var i = 0; i < t; i++)
    if (r[i] !== e[i])
      return !1;
  return !0;
}
function oX(r, e, t, i, n, a, o, s) {
  for (var l = He(i), u = n.duration, h = n.delay, c = n.additive, f = n.setToFinal, d = !be(a), p = r.animators, g = [], v = 0; v < l.length; v++) {
    var O = l[v], m = i[O];
    if (m != null && t[O] != null && (d || a[O]))
      if (be(m) && !ci(m) && !dS(m)) {
        if (e) {
          s || (t[O] = m, r.updateDuringAnimation(e));
          continue;
        }
        oX(r, O, t[O], m, n, a && a[O], o, s);
      } else
        g.push(O);
    else
      s || (t[O] = m, r.updateDuringAnimation(e), g.push(O));
  }
  var E = g.length;
  if (!c && E)
    for (var b = 0; b < p.length; b++) {
      var T = p[b];
      if (T.targetName === e) {
        var S = T.stopTracks(g);
        if (S) {
          var y = Ge(p, T);
          p.splice(y, 1);
        }
      }
    }
  if (n.force || (g = yt(g, function(I) {
    return !oie(i[I], t[I]);
  }), E = g.length), E > 0 || n.force && !o.length) {
    var A = void 0, C = void 0, _ = void 0;
    if (s) {
      C = {}, f && (A = {});
      for (var b = 0; b < E; b++) {
        var O = g[b];
        C[O] = t[O], f ? A[O] = i[O] : t[O] = i[O];
      }
    } else if (f) {
      _ = {};
      for (var b = 0; b < E; b++) {
        var O = g[b];
        _[O] = np(t[O]), aie(t, i, O);
      }
    }
    var T = new xI(t, !1, !1, c ? yt(p, function(x) {
      return x.targetName === e;
    }) : null);
    T.targetName = e, n.scope && (T.scope = n.scope), f && A && T.whenWithKeys(0, A, g), _ && T.whenWithKeys(0, _, g), T.whenWithKeys(u ?? 500, s ? C : i, g).delay(h || 0), r.addAnimator(T, e), o.push(T);
  }
}
const sX = wI;
var lX = function(r) {
  U(e, r);
  function e(t) {
    var i = r.call(this) || this;
    return i.isGroup = !0, i._children = [], i.attr(t), i;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.children = function() {
    return this._children.slice();
  }, e.prototype.childAt = function(t) {
    return this._children[t];
  }, e.prototype.childOfName = function(t) {
    for (var i = this._children, n = 0; n < i.length; n++)
      if (i[n].name === t)
        return i[n];
  }, e.prototype.childCount = function() {
    return this._children.length;
  }, e.prototype.add = function(t) {
    return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this;
  }, e.prototype.addBefore = function(t, i) {
    if (t && t !== this && t.parent !== this && i && i.parent === this) {
      var n = this._children, a = n.indexOf(i);
      a >= 0 && (n.splice(a, 0, t), this._doAdd(t));
    }
    return this;
  }, e.prototype.replace = function(t, i) {
    var n = Ge(this._children, t);
    return n >= 0 && this.replaceAt(i, n), this;
  }, e.prototype.replaceAt = function(t, i) {
    var n = this._children, a = n[i];
    if (t && t !== this && t.parent !== this && t !== a) {
      n[i] = t, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(t);
    }
    return this;
  }, e.prototype._doAdd = function(t) {
    t.parent && t.parent.remove(t), t.parent = this;
    var i = this.__zr;
    i && i !== t.__zr && t.addSelfToZr(i), i && i.refresh();
  }, e.prototype.remove = function(t) {
    var i = this.__zr, n = this._children, a = Ge(n, t);
    return a < 0 ? this : (n.splice(a, 1), t.parent = null, i && t.removeSelfFromZr(i), i && i.refresh(), this);
  }, e.prototype.removeAll = function() {
    for (var t = this._children, i = this.__zr, n = 0; n < t.length; n++) {
      var a = t[n];
      i && a.removeSelfFromZr(i), a.parent = null;
    }
    return t.length = 0, this;
  }, e.prototype.eachChild = function(t, i) {
    for (var n = this._children, a = 0; a < n.length; a++) {
      var o = n[a];
      t.call(i, o, a);
    }
    return this;
  }, e.prototype.traverse = function(t, i) {
    for (var n = 0; n < this._children.length; n++) {
      var a = this._children[n], o = t.call(i, a);
      a.isGroup && !o && a.traverse(t, i);
    }
    return this;
  }, e.prototype.addSelfToZr = function(t) {
    r.prototype.addSelfToZr.call(this, t);
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    r.prototype.removeSelfFromZr.call(this, t);
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.removeSelfFromZr(t);
    }
  }, e.prototype.getBoundingRect = function(t) {
    for (var i = new Ue(0, 0, 0, 0), n = t || this._children, a = [], o = null, s = 0; s < n.length; s++) {
      var l = n[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), h = l.getLocalTransform(a);
        h ? (Ue.applyTransform(i, u, h), o = o || i.clone(), o.union(i)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || i;
  }, e;
}(sX);
lX.prototype.type = "group";
const ye = lX;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var vm = {}, uX = {};
function lie(r) {
  delete uX[r];
}
function uie(r) {
  if (!r)
    return !1;
  if (typeof r == "string")
    return pE(r, 1) < XA;
  if (r.colorStops) {
    for (var e = r.colorStops, t = 0, i = e.length, n = 0; n < i; n++)
      t += pE(e[n].color, 1);
    return t /= i, t < XA;
  }
  return !1;
}
var hie = function() {
  function r(e, t, i) {
    var n = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, i = i || {}, this.dom = t, this.id = e;
    var a = new bre(), o = i.renderer || "canvas";
    vm[o] || (o = He(vm)[0]), i.useDirtyRect = i.useDirtyRect == null ? !1 : i.useDirtyRect;
    var s = new vm[o](t, a, i, e), l = i.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !st.node && !st.worker && !l ? new Jre(s.getViewportRoot(), s.root) : null, h = i.useCoarsePointer, c = h == null || h === "auto" ? st.touchEventsSupported : !!h, f = 44, d;
    c && (d = ke(i.pointerSize, f)), this.handler = new gre(a, s, u, s.root, d), this.animation = new Yre({
      stage: {
        update: l ? null : function() {
          return n._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return r.prototype.add = function(e) {
    e && (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
  }, r.prototype.remove = function(e) {
    e && (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
  }, r.prototype.configLayer = function(e, t) {
    this.painter.configLayer && this.painter.configLayer(e, t), this.refresh();
  }, r.prototype.setBackgroundColor = function(e) {
    this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = uie(e);
  }, r.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, r.prototype.setDarkMode = function(e) {
    this._darkMode = e;
  }, r.prototype.isDarkMode = function() {
    return this._darkMode;
  }, r.prototype.refreshImmediately = function(e) {
    e || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1;
  }, r.prototype.refresh = function() {
    this._needsRefresh = !0, this.animation.start();
  }, r.prototype.flush = function() {
    this._flush(!1);
  }, r.prototype._flush = function(e) {
    var t, i = gc();
    this._needsRefresh && (t = !0, this.refreshImmediately(e)), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately());
    var n = gc();
    t ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: n - i
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, r.prototype.setSleepAfterStill = function(e) {
    this._sleepAfterStill = e;
  }, r.prototype.wakeUp = function() {
    this.animation.start(), this._stillFrameAccum = 0;
  }, r.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, r.prototype.refreshHoverImmediately = function() {
    this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover();
  }, r.prototype.resize = function(e) {
    e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize();
  }, r.prototype.clearAnimation = function() {
    this.animation.clear();
  }, r.prototype.getWidth = function() {
    return this.painter.getWidth();
  }, r.prototype.getHeight = function() {
    return this.painter.getHeight();
  }, r.prototype.setCursorStyle = function(e) {
    this.handler.setCursorStyle(e);
  }, r.prototype.findHover = function(e, t) {
    return this.handler.findHover(e, t);
  }, r.prototype.on = function(e, t, i) {
    return this.handler.on(e, t, i), this;
  }, r.prototype.off = function(e, t) {
    this.handler.off(e, t);
  }, r.prototype.trigger = function(e, t) {
    this.handler.trigger(e, t);
  }, r.prototype.clear = function() {
    for (var e = this.storage.getRoots(), t = 0; t < e.length; t++)
      e[t] instanceof ye && e[t].removeSelfFromZr(this);
    this.storage.delAllRoots(), this.painter.clear();
  }, r.prototype.dispose = function() {
    this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, lie(this.id);
  }, r;
}();
function _L(r, e) {
  var t = new hie(PF(), r, e);
  return uX[t.id] = t, t;
}
function cie(r, e) {
  vm[r] = e;
}
var IL = 1e-4, hX = 20;
function fie(r) {
  return r.replace(/^\s+|\s+$/g, "");
}
function Et(r, e, t, i) {
  var n = e[0], a = e[1], o = t[0], s = t[1], l = a - n, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (i)
    if (l > 0) {
      if (r <= n)
        return o;
      if (r >= a)
        return s;
    } else {
      if (r >= n)
        return o;
      if (r <= a)
        return s;
    }
  else {
    if (r === n)
      return o;
    if (r === a)
      return s;
  }
  return (r - n) / l * u + o;
}
function K(r, e) {
  switch (r) {
    case "center":
    case "middle":
      r = "50%";
      break;
    case "left":
    case "top":
      r = "0%";
      break;
    case "right":
    case "bottom":
      r = "100%";
      break;
  }
  return ne(r) ? fie(r).match(/%$/) ? parseFloat(r) / 100 * e : parseFloat(r) : r == null ? NaN : +r;
}
function Kt(r, e, t) {
  return e == null && (e = 10), e = Math.min(Math.max(0, e), hX), r = (+r).toFixed(e), t ? r : +r;
}
function $n(r) {
  return r.sort(function(e, t) {
    return e - t;
  }), r;
}
function Ya(r) {
  if (r = +r, isNaN(r))
    return 0;
  if (r > 1e-14) {
    for (var e = 1, t = 0; t < 15; t++, e *= 10)
      if (Math.round(r * e) / e === r)
        return t;
  }
  return die(r);
}
function die(r) {
  var e = r.toString().toLowerCase(), t = e.indexOf("e"), i = t > 0 ? +e.slice(t + 1) : 0, n = t > 0 ? t : e.length, a = e.indexOf("."), o = a < 0 ? 0 : n - 1 - a;
  return Math.max(0, o - i);
}
function cX(r, e) {
  var t = Math.log, i = Math.LN10, n = Math.floor(t(r[1] - r[0]) / i), a = Math.round(t(Math.abs(e[1] - e[0])) / i), o = Math.min(Math.max(-n + a, 0), 20);
  return isFinite(o) ? o : 20;
}
function pie(r, e) {
  var t = no(r, function(d, p) {
    return d + (isNaN(p) ? 0 : p);
  }, 0);
  if (t === 0)
    return [];
  for (var i = Math.pow(10, e), n = Y(r, function(d) {
    return (isNaN(d) ? 0 : d) / t * i * 100;
  }), a = i * 100, o = Y(n, function(d) {
    return Math.floor(d);
  }), s = no(o, function(d, p) {
    return d + p;
  }, 0), l = Y(n, function(d, p) {
    return d - o[p];
  }); s < a; ) {
    for (var u = Number.NEGATIVE_INFINITY, h = null, c = 0, f = l.length; c < f; ++c)
      l[c] > u && (u = l[c], h = c);
    ++o[h], l[h] = 0, ++s;
  }
  return Y(o, function(d) {
    return d / i;
  });
}
function gie(r, e) {
  var t = Math.max(Ya(r), Ya(e)), i = r + e;
  return t > hX ? i : Kt(i, t);
}
var xL = 9007199254740991;
function fX(r) {
  var e = Math.PI * 2;
  return (r % e + e) % e;
}
function mE(r) {
  return r > -IL && r < IL;
}
var vie = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function so(r) {
  if (r instanceof Date)
    return r;
  if (ne(r)) {
    var e = vie.exec(r);
    if (!e)
      return /* @__PURE__ */ new Date(NaN);
    if (e[8]) {
      var t = +e[4] || 0;
      return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
    } else
      return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
  } else if (r == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(r));
}
function Oie(r) {
  return Math.pow(10, PI(r));
}
function PI(r) {
  if (r === 0)
    return 0;
  var e = Math.floor(Math.log(r) / Math.LN10);
  return r / Math.pow(10, e) >= 10 && e++, e;
}
function dX(r, e) {
  var t = PI(r), i = Math.pow(10, t), n = r / i, a;
  return e ? n < 1.5 ? a = 1 : n < 2.5 ? a = 2 : n < 4 ? a = 3 : n < 7 ? a = 5 : a = 10 : n < 1 ? a = 1 : n < 2 ? a = 2 : n < 3 ? a = 3 : n < 5 ? a = 5 : a = 10, r = a * i, t >= -20 ? +r.toFixed(t < 0 ? -t : 0) : r;
}
function ly(r, e) {
  var t = (r.length - 1) * e + 1, i = Math.floor(t), n = +r[i - 1], a = t - i;
  return a ? n + a * (r[i] - n) : n;
}
function wL(r) {
  r.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var e = -1 / 0, t = 1, i = 0; i < r.length; ) {
    for (var n = r[i].interval, a = r[i].close, o = 0; o < 2; o++)
      n[o] <= e && (n[o] = e, a[o] = o ? 1 : 1 - t), e = n[o], t = a[o];
    n[0] === n[1] && a[0] * a[1] !== 1 ? r.splice(i, 1) : i++;
  }
  return r;
  function s(l, u, h) {
    return l.interval[h] < u.interval[h] || l.interval[h] === u.interval[h] && (l.close[h] - u.close[h] === (h ? -1 : 1) || !h && s(l, u, 1));
  }
}
function Fo(r) {
  var e = parseFloat(r);
  return e == r && (e !== 0 || !ne(r) || r.indexOf("x") <= 0) ? e : NaN;
}
function pX(r) {
  return !isNaN(Fo(r));
}
function gX() {
  return Math.round(Math.random() * 9);
}
function vX(r, e) {
  return e === 0 ? r : vX(e, r % e);
}
function PL(r, e) {
  return r == null ? e : e == null ? r : r * e / vX(r, e);
}
function vt(r) {
  throw new Error(r);
}
function NL(r, e, t) {
  return (e - r) * t + r;
}
var OX = "series\0", mX = "\0_ec_\0";
function At(r) {
  return r instanceof Array ? r : r == null ? [] : [r];
}
function eh(r, e, t) {
  if (r) {
    r[e] = r[e] || {}, r.emphasis = r.emphasis || {}, r.emphasis[e] = r.emphasis[e] || {};
    for (var i = 0, n = t.length; i < n; i++) {
      var a = t[i];
      !r.emphasis[e].hasOwnProperty(a) && r[e].hasOwnProperty(a) && (r.emphasis[e][a] = r[e][a]);
    }
  }
}
var LL = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function bf(r) {
  return be(r) && !X(r) && !(r instanceof Date) ? r.value : r;
}
function mie(r) {
  return be(r) && !(r instanceof Array);
}
function EX(r, e, t) {
  var i = t === "normalMerge", n = t === "replaceMerge", a = t === "replaceAll";
  r = r || [], e = (e || []).slice();
  var o = ce();
  w(e, function(l, u) {
    if (!be(l)) {
      e[u] = null;
      return;
    }
  });
  var s = Eie(r, o, t);
  return (i || n) && bie(s, r, o, e), i && Sie(s, e), i || n ? Tie(s, e, n) : a && yie(s, e), Rie(s), s;
}
function Eie(r, e, t) {
  var i = [];
  if (t === "replaceAll")
    return i;
  for (var n = 0; n < r.length; n++) {
    var a = r[n];
    a && a.id != null && e.set(a.id, n), i.push({
      existing: t === "replaceMerge" || Fp(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return i;
}
function bie(r, e, t, i) {
  w(i, function(n, a) {
    if (!(!n || n.id == null)) {
      var o = ap(n.id), s = t.get(o);
      if (s != null) {
        var l = r[s];
        _i(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = n, l.existing = e[s], i[a] = null;
      }
    }
  });
}
function Sie(r, e) {
  w(e, function(t, i) {
    if (!(!t || t.name == null))
      for (var n = 0; n < r.length; n++) {
        var a = r[n].existing;
        if (!r[n].newOption && a && (a.id == null || t.id == null) && !Fp(t) && !Fp(a) && bX("name", a, t)) {
          r[n].newOption = t, e[i] = null;
          return;
        }
      }
  });
}
function Tie(r, e, t) {
  w(e, function(i) {
    if (i) {
      for (
        var n, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (n = r[a]) && // (1) Existing models that already have id should be able to mapped to. Because
        // after mapping performed, model will always be assigned with an id if user not given.
        // After that all models have id.
        // (2) If new option has id, it can only set to a hole or append to the last. It should
        // not be merged to the existings with different id. Because id should not be overwritten.
        // (3) Name can be overwritten, because axis use name as 'show label text'.
        (n.newOption || Fp(n.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        n.existing && i.id != null && !bX("id", i, n.existing));
      )
        a++;
      n ? (n.newOption = i, n.brandNew = t) : r.push({
        newOption: i,
        brandNew: t,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function yie(r, e) {
  w(e, function(t) {
    r.push({
      newOption: t,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function Rie(r) {
  var e = ce();
  w(r, function(t) {
    var i = t.existing;
    i && e.set(i.id, t);
  }), w(r, function(t) {
    var i = t.newOption;
    _i(!i || i.id == null || !e.get(i.id) || e.get(i.id) === t, "id duplicates: " + (i && i.id)), i && i.id != null && e.set(i.id, t), !t.keyInfo && (t.keyInfo = {});
  }), w(r, function(t, i) {
    var n = t.existing, a = t.newOption, o = t.keyInfo;
    if (be(a)) {
      if (o.name = a.name != null ? ap(a.name) : n ? n.name : OX + i, n)
        o.id = ap(n.id);
      else if (a.id != null)
        o.id = ap(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (e.get(o.id));
      }
      e.set(o.id, t);
    }
  });
}
function bX(r, e, t) {
  var i = gr(e[r], null), n = gr(t[r], null);
  return i != null && n != null && i === n;
}
function ap(r) {
  return gr(r, "");
}
function gr(r, e) {
  return r == null ? e : ne(r) ? r : ut(r) || AA(r) ? r + "" : e;
}
function NI(r) {
  var e = r.name;
  return !!(e && e.indexOf(OX));
}
function Fp(r) {
  return r && r.id != null && ap(r.id).indexOf(mX) === 0;
}
function Aie(r) {
  return mX + r;
}
function Cie(r, e, t) {
  w(r, function(i) {
    var n = i.newOption;
    be(n) && (i.keyInfo.mainType = e, i.keyInfo.subType = _ie(e, n, i.existing, t));
  });
}
function _ie(r, e, t, i) {
  var n = e.type ? e.type : t ? t.subType : i.determineSubType(r, e);
  return n;
}
function Iie(r, e) {
  var t = {}, i = {};
  return n(r || [], t), n(e || [], i, t), [a(t), a(i)];
  function n(o, s, l) {
    for (var u = 0, h = o.length; u < h; u++) {
      var c = gr(o[u].seriesId, null);
      if (c == null)
        return;
      for (var f = At(o[u].dataIndex), d = l && l[c], p = 0, g = f.length; p < g; p++) {
        var v = f[p];
        d && d[v] ? d[v] = null : (s[c] || (s[c] = {}))[v] = 1;
      }
    }
  }
  function a(o, s) {
    var l = [];
    for (var u in o)
      if (o.hasOwnProperty(u) && o[u] != null)
        if (s)
          l.push(+u);
        else {
          var h = a(o[u], !0);
          h.length && l.push({
            seriesId: u,
            dataIndex: h
          });
        }
    return l;
  }
}
function th(r, e) {
  if (e.dataIndexInside != null)
    return e.dataIndexInside;
  if (e.dataIndex != null)
    return X(e.dataIndex) ? Y(e.dataIndex, function(t) {
      return r.indexOfRawIndex(t);
    }) : r.indexOfRawIndex(e.dataIndex);
  if (e.name != null)
    return X(e.name) ? Y(e.name, function(t) {
      return r.indexOfName(t);
    }) : r.indexOfName(e.name);
}
function at() {
  var r = "__ec_inner_" + xie++;
  return function(e) {
    return e[r] || (e[r] = {});
  };
}
var xie = gX();
function op(r, e, t) {
  var i = LI(e, t), n = i.mainTypeSpecified, a = i.queryOptionMap, o = i.others, s = o, l = t ? t.defaultMainType : null;
  return !n && l && a.set(l, {}), a.each(function(u, h) {
    var c = Ug(r, h, u, {
      useDefault: l === h,
      enableAll: t && t.enableAll != null ? t.enableAll : !0,
      enableNone: t && t.enableNone != null ? t.enableNone : !0
    });
    s[h + "Models"] = c.models, s[h + "Model"] = c.models[0];
  }), s;
}
function LI(r, e) {
  var t;
  if (ne(r)) {
    var i = {};
    i[r + "Index"] = 0, t = i;
  } else
    t = r;
  var n = ce(), a = {}, o = !1;
  return w(t, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], h = u[1], c = (u[2] || "").toLowerCase();
    if (!(!h || !c || e && e.includeMainTypes && Ge(e.includeMainTypes, h) < 0)) {
      o = o || !!h;
      var f = n.get(h) || n.set(h, {});
      f[c] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: n,
    others: a
  };
}
var lr = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, wie = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Ug(r, e, t, i) {
  i = i || lr;
  var n = t.index, a = t.id, o = t.name, s = {
    models: null,
    specified: n != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = i.useDefault && (l = r.getComponent(e)) ? [l] : [], s;
  }
  return n === "none" || n === !1 ? (_i(i.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (n === "all" && (_i(i.enableAll, '`"all"` is not a valid value on index option.'), n = a = o = null), s.models = r.queryComponents({
    mainType: e,
    index: n,
    id: a,
    name: o
  }), s);
}
function Pie(r, e, t) {
  r.setAttribute ? r.setAttribute(e, t) : r[e] = t;
}
function Nie(r) {
  return r === "auto" ? st.domSupported ? "html" : "richText" : r || "html";
}
function WA(r, e) {
  var t = ce(), i = [];
  return w(r, function(n) {
    var a = e(n);
    (t.get(a) || (i.push(a), t.set(a, []))).push(n);
  }), {
    keys: i,
    buckets: t
  };
}
function SX(r, e, t, i, n) {
  var a = e == null || e === "auto";
  if (i == null)
    return i;
  if (ut(i)) {
    var o = NL(t || 0, i, n);
    return Kt(o, a ? Math.max(Ya(t || 0), Ya(i)) : e);
  } else {
    if (ne(i))
      return n < 1 ? t : i;
    for (var s = [], l = t, u = i, h = Math.max(l ? l.length : 0, u.length), c = 0; c < h; ++c) {
      var f = r.getDimensionInfo(c);
      if (f && f.type === "ordinal")
        s[c] = (n < 1 && l ? l : u)[c];
      else {
        var d = l && l[c] ? l[c] : 0, p = u[c], o = NL(d, p, n);
        s[c] = Kt(o, a ? Math.max(Ya(d), Ya(p)) : e);
      }
    }
    return s;
  }
}
var Lie = ".", kl = "___EC__COMPONENT__CONTAINER___", TX = "___EC__EXTENDED_CLASS___";
function Ha(r) {
  var e = {
    main: "",
    sub: ""
  };
  if (r) {
    var t = r.split(Lie);
    e.main = t[0] || "", e.sub = t[1] || "";
  }
  return e;
}
function Die(r) {
  _i(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(r), 'componentType "' + r + '" illegal');
}
function Mie(r) {
  return !!(r && r[TX]);
}
function DI(r, e) {
  r.$constructor = r, r.extend = function(t) {
    var i = this, n;
    return kie(i) ? n = /** @class */
    function(a) {
      U(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    }(i) : (n = function() {
      (t.$constructor || i).apply(this, arguments);
    }, Mte(n, this)), V(n.prototype, t), n[TX] = !0, n.extend = this.extend, n.superCall = $ie, n.superApply = Gie, n.superClass = i, n;
  };
}
function kie(r) {
  return ve(r) && /^class\s/.test(Function.prototype.toString.call(r));
}
function yX(r, e) {
  r.extend = e.extend;
}
var Qie = Math.round(Math.random() * 10);
function Uie(r) {
  var e = ["__\0is_clz", Qie++].join("_");
  r.prototype[e] = !0, r.isInstance = function(t) {
    return !!(t && t[e]);
  };
}
function $ie(r, e) {
  for (var t = [], i = 2; i < arguments.length; i++)
    t[i - 2] = arguments[i];
  return this.superClass.prototype[e].apply(r, t);
}
function Gie(r, e, t) {
  return this.superClass.prototype[e].apply(r, t);
}
function mS(r) {
  var e = {};
  r.registerClass = function(i) {
    var n = i.type || i.prototype.type;
    if (n) {
      Die(n), i.prototype.type = n;
      var a = Ha(n);
      if (!a.sub)
        e[a.main] = i;
      else if (a.sub !== kl) {
        var o = t(a);
        o[a.sub] = i;
      }
    }
    return i;
  }, r.getClass = function(i, n, a) {
    var o = e[i];
    if (o && o[kl] && (o = n ? o[n] : null), a && !o)
      throw new Error(n ? "Component " + i + "." + (n || "") + " is used but not imported." : i + ".type should be specified.");
    return o;
  }, r.getClassesByMainType = function(i) {
    var n = Ha(i), a = [], o = e[n.main];
    return o && o[kl] ? w(o, function(s, l) {
      l !== kl && a.push(s);
    }) : a.push(o), a;
  }, r.hasClass = function(i) {
    var n = Ha(i);
    return !!e[n.main];
  }, r.getAllClassMainTypes = function() {
    var i = [];
    return w(e, function(n, a) {
      i.push(a);
    }), i;
  }, r.hasSubTypes = function(i) {
    var n = Ha(i), a = e[n.main];
    return a && a[kl];
  };
  function t(i) {
    var n = e[i.main];
    return (!n || !n[kl]) && (n = e[i.main] = {}, n[kl] = !0), n;
  }
}
function rh(r, e) {
  for (var t = 0; t < r.length; t++)
    r[t][1] || (r[t][1] = r[t][0]);
  return e = e || !1, function(i, n, a) {
    for (var o = {}, s = 0; s < r.length; s++) {
      var l = r[s][1];
      if (!(n && Ge(n, l) >= 0 || a && Ge(a, l) < 0)) {
        var u = i.getShallow(l, e);
        u != null && (o[r[s][0]] = u);
      }
    }
    return o;
  };
}
var Bie = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], Vie = rh(Bie), Fie = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getAreaStyle = function(e, t) {
      return Vie(this, e, t);
    }, r;
  }()
), zA = new kg(50);
function Xie(r) {
  if (typeof r == "string") {
    var e = zA.get(r);
    return e && e.image;
  } else
    return r;
}
function MI(r, e, t, i, n) {
  if (r)
    if (typeof r == "string") {
      if (e && e.__zrImageSrc === r || !t)
        return e;
      var a = zA.get(r), o = { hostEl: t, cb: i, cbPayload: n };
      return a ? (e = a.image, !ES(e) && a.pending.push(o)) : (e = il.loadImage(r, DL, DL), e.__zrImageSrc = r, zA.put(r, e.__cachedImgObj = {
        image: e,
        pending: [o]
      })), e;
    } else
      return r;
  else
    return e;
}
function DL() {
  var r = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var e = 0; e < r.pending.length; e++) {
    var t = r.pending[e], i = t.cb;
    i && i(this, t.cbPayload), t.hostEl.dirty();
  }
  r.pending.length = 0;
}
function ES(r) {
  return r && r.width && r.height;
}
var uy = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function Yie(r, e, t, i, n) {
  if (!e)
    return "";
  var a = (r + "").split(`
`);
  n = RX(e, t, i, n);
  for (var o = 0, s = a.length; o < s; o++)
    a[o] = AX(a[o], n);
  return a.join(`
`);
}
function RX(r, e, t, i) {
  i = i || {};
  var n = V({}, i);
  n.font = e, t = ke(t, "..."), n.maxIterations = ke(i.maxIterations, 2);
  var a = n.minChar = ke(i.minChar, 0);
  n.cnCharWidth = gn("", e);
  var o = n.ascCharWidth = gn("a", e);
  n.placeholder = ke(i.placeholder, "");
  for (var s = r = Math.max(0, r - 1), l = 0; l < a && s >= o; l++)
    s -= o;
  var u = gn(t, e);
  return u > s && (t = "", u = 0), s = r - u, n.ellipsis = t, n.ellipsisWidth = u, n.contentWidth = s, n.containerWidth = r, n;
}
function AX(r, e) {
  var t = e.containerWidth, i = e.font, n = e.contentWidth;
  if (!t)
    return "";
  var a = gn(r, i);
  if (a <= t)
    return r;
  for (var o = 0; ; o++) {
    if (a <= n || o >= e.maxIterations) {
      r += e.ellipsis;
      break;
    }
    var s = o === 0 ? Hie(r, n, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(r.length * n / a) : 0;
    r = r.substr(0, s), a = gn(r, i);
  }
  return r === "" && (r = e.placeholder), r;
}
function Hie(r, e, t, i) {
  for (var n = 0, a = 0, o = r.length; a < o && n < e; a++) {
    var s = r.charCodeAt(a);
    n += 0 <= s && s <= 127 ? t : i;
  }
  return a;
}
function Wie(r, e) {
  r != null && (r += "");
  var t = e.overflow, i = e.padding, n = e.font, a = t === "truncate", o = OS(n), s = ke(e.lineHeight, o), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", h = e.width, c;
  h != null && (t === "break" || t === "breakAll") ? c = r ? CX(r, e.font, h, t === "breakAll", 0).lines : [] : c = r ? r.split(`
`) : [];
  var f = c.length * s, d = ke(e.height, f);
  if (f > d && u) {
    var p = Math.floor(d / s);
    c = c.slice(0, p);
  }
  if (r && a && h != null)
    for (var g = RX(h, n, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), v = 0; v < c.length; v++)
      c[v] = AX(c[v], g);
  for (var O = d, m = 0, v = 0; v < c.length; v++)
    m = Math.max(gn(c[v], n), m);
  h == null && (h = m);
  var E = m;
  return i && (O += i[0] + i[2], E += i[1] + i[3], h += i[1] + i[3]), l && (E = h), {
    lines: c,
    height: d,
    outerWidth: E,
    outerHeight: O,
    lineHeight: s,
    calculatedLineHeight: o,
    contentWidth: m,
    contentHeight: f,
    width: h
  };
}
var zie = function() {
  function r() {
  }
  return r;
}(), ML = function() {
  function r(e) {
    this.tokens = [], e && (this.tokens = e);
  }
  return r;
}(), Zie = function() {
  function r() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
  }
  return r;
}();
function qie(r, e) {
  var t = new Zie();
  if (r != null && (r += ""), !r)
    return t;
  for (var i = e.width, n = e.height, a = e.overflow, o = (a === "break" || a === "breakAll") && i != null ? { width: i, accumWidth: 0, breakAll: a === "breakAll" } : null, s = uy.lastIndex = 0, l; (l = uy.exec(r)) != null; ) {
    var u = l.index;
    u > s && hy(t, r.substring(s, u), e, o), hy(t, l[2], e, o, l[1]), s = uy.lastIndex;
  }
  s < r.length && hy(t, r.substring(s, r.length), e, o);
  var h = [], c = 0, f = 0, d = e.padding, p = a === "truncate", g = e.lineOverflow === "truncate";
  function v(k, G, F) {
    k.width = G, k.lineHeight = F, c += F, f = Math.max(f, G);
  }
  e:
    for (var O = 0; O < t.lines.length; O++) {
      for (var m = t.lines[O], E = 0, b = 0, T = 0; T < m.tokens.length; T++) {
        var S = m.tokens[T], y = S.styleName && e.rich[S.styleName] || {}, A = S.textPadding = y.padding, C = A ? A[1] + A[3] : 0, _ = S.font = y.font || e.font;
        S.contentHeight = OS(_);
        var I = ke(y.height, S.contentHeight);
        if (S.innerHeight = I, A && (I += A[0] + A[2]), S.height = I, S.lineHeight = Ka(y.lineHeight, e.lineHeight, I), S.align = y && y.align || e.align, S.verticalAlign = y && y.verticalAlign || "middle", g && n != null && c + S.lineHeight > n) {
          T > 0 ? (m.tokens = m.tokens.slice(0, T), v(m, b, E), t.lines = t.lines.slice(0, O + 1)) : t.lines = t.lines.slice(0, O);
          break e;
        }
        var x = y.width, P = x == null || x === "auto";
        if (typeof x == "string" && x.charAt(x.length - 1) === "%")
          S.percentWidth = x, h.push(S), S.contentWidth = gn(S.text, _);
        else {
          if (P) {
            var N = y.backgroundColor, L = N && N.image;
            L && (L = Xie(L), ES(L) && (S.width = Math.max(S.width, L.width * I / L.height)));
          }
          var D = p && i != null ? i - b : null;
          D != null && D < S.width ? !P || D < C ? (S.text = "", S.width = S.contentWidth = 0) : (S.text = Yie(S.text, D - C, _, e.ellipsis, { minChar: e.truncateMinChar }), S.width = S.contentWidth = gn(S.text, _)) : S.contentWidth = gn(S.text, _);
        }
        S.width += C, b += S.width, y && (E = Math.max(E, S.lineHeight));
      }
      v(m, b, E);
    }
  t.outerWidth = t.width = ke(i, f), t.outerHeight = t.height = ke(n, c), t.contentHeight = c, t.contentWidth = f, d && (t.outerWidth += d[1] + d[3], t.outerHeight += d[0] + d[2]);
  for (var O = 0; O < h.length; O++) {
    var S = h[O], $ = S.percentWidth;
    S.width = parseInt($, 10) / 100 * t.width;
  }
  return t;
}
function hy(r, e, t, i, n) {
  var a = e === "", o = n && t.rich[n] || {}, s = r.lines, l = o.font || t.font, u = !1, h, c;
  if (i) {
    var f = o.padding, d = f ? f[1] + f[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var p = Ea(o.width, i.width) + d;
      s.length > 0 && p + i.accumWidth > i.width && (h = e.split(`
`), u = !0), i.accumWidth = p;
    } else {
      var g = CX(e, l, i.width, i.breakAll, i.accumWidth);
      i.accumWidth = g.accumWidth + d, c = g.linesWidths, h = g.lines;
    }
  } else
    h = e.split(`
`);
  for (var v = 0; v < h.length; v++) {
    var O = h[v], m = new zie();
    if (m.styleName = n, m.text = O, m.isLineHolder = !O && !a, typeof o.width == "number" ? m.width = o.width : m.width = c ? c[v] : gn(O, l), !v && !u) {
      var E = (s[s.length - 1] || (s[0] = new ML())).tokens, b = E.length;
      b === 1 && E[0].isLineHolder ? E[0] = m : (O || !b || a) && E.push(m);
    } else
      s.push(new ML([m]));
  }
}
function jie(r) {
  var e = r.charCodeAt(0);
  return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
}
var Kie = no(",&?/;] ".split(""), function(r, e) {
  return r[e] = !0, r;
}, {});
function Jie(r) {
  return jie(r) ? !!Kie[r] : !0;
}
function CX(r, e, t, i, n) {
  for (var a = [], o = [], s = "", l = "", u = 0, h = 0, c = 0; c < r.length; c++) {
    var f = r.charAt(c);
    if (f === `
`) {
      l && (s += l, h += u), a.push(s), o.push(h), s = "", l = "", u = 0, h = 0;
      continue;
    }
    var d = gn(f, e), p = i ? !1 : !Jie(f);
    if (a.length ? h + d > t : n + h + d > t) {
      h ? (s || l) && (p ? (s || (s = l, l = "", u = 0, h = u), a.push(s), o.push(h - u), l += f, u += d, s = "", h = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(h), s = f, h = d)) : p ? (a.push(l), o.push(u), l = f, u = d) : (a.push(f), o.push(d));
      continue;
    }
    h += d, p ? (l += f, u += d) : (l && (s += l, l = "", u = 0), s += f);
  }
  return !a.length && !s && (s = r, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(h)), a.length === 1 && (h += n), {
    accumWidth: h,
    lines: a,
    linesWidths: o
  };
}
var ZA = "__zr_style_" + Math.round(Math.random() * 10), $u = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, bS = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
$u[ZA] = !0;
var kL = ["z", "z2", "invisible"], ene = ["invisible"], tne = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype._init = function(t) {
    for (var i = He(t), n = 0; n < i.length; n++) {
      var a = i[n];
      a === "style" ? this.useStyle(t[a]) : r.prototype.attrKV.call(this, a, t[a]);
    }
    this.style || this.useStyle({});
  }, e.prototype.beforeBrush = function() {
  }, e.prototype.afterBrush = function() {
  }, e.prototype.innerBeforeBrush = function() {
  }, e.prototype.innerAfterBrush = function() {
  }, e.prototype.shouldBePainted = function(t, i, n, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && rne(this, t, i) || o && !o[0] && !o[3])
      return !1;
    if (n && this.__clipPaths) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, e.prototype.contain = function(t, i) {
    return this.rectContain(t, i);
  }, e.prototype.traverse = function(t, i) {
    t.call(i, this);
  }, e.prototype.rectContain = function(t, i) {
    var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
    return a.contain(n[0], n[1]);
  }, e.prototype.getPaintRect = function() {
    var t = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var i = this.transform, n = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      t = this._paintRect || (this._paintRect = new Ue(0, 0, 0, 0)), i ? Ue.applyTransform(t, n, i) : t.copy(n), (o || s || l) && (t.width += o * 2 + Math.abs(s), t.height += o * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + s - o), t.y = Math.min(t.y, t.y + l - o));
      var u = this.dirtyRectTolerance;
      t.isZero() || (t.x = Math.floor(t.x - u), t.y = Math.floor(t.y - u), t.width = Math.ceil(t.width + 1 + u * 2), t.height = Math.ceil(t.height + 1 + u * 2));
    }
    return t;
  }, e.prototype.setPrevPaintRect = function(t) {
    t ? (this._prevPaintRect = this._prevPaintRect || new Ue(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
  }, e.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, e.prototype.animateStyle = function(t) {
    return this.animate("style", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : this.markRedraw();
  }, e.prototype.attrKV = function(t, i) {
    t !== "style" ? r.prototype.attrKV.call(this, t, i) : this.style ? this.setStyle(i) : this.useStyle(i);
  }, e.prototype.setStyle = function(t, i) {
    return typeof t == "string" ? this.style[t] = i : V(this.style, t), this.dirtyStyle(), this;
  }, e.prototype.dirtyStyle = function(t) {
    t || this.markRedraw(), this.__dirty |= Nd, this._rect && (this._rect = null);
  }, e.prototype.dirty = function() {
    this.dirtyStyle();
  }, e.prototype.styleChanged = function() {
    return !!(this.__dirty & Nd);
  }, e.prototype.styleUpdated = function() {
    this.__dirty &= ~Nd;
  }, e.prototype.createStyle = function(t) {
    return pS($u, t);
  }, e.prototype.useStyle = function(t) {
    t[ZA] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
  }, e.prototype.isStyleObject = function(t) {
    return t[ZA];
  }, e.prototype._innerSaveToNormal = function(t) {
    r.prototype._innerSaveToNormal.call(this, t);
    var i = this._normalState;
    t.style && !i.style && (i.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, i, kL);
  }, e.prototype._applyStateObj = function(t, i, n, a, o, s) {
    r.prototype._applyStateObj.call(this, t, i, n, a, o, s);
    var l = !(i && a), u;
    if (i && i.style ? o ? a ? u = i.style : (u = this._mergeStyle(this.createStyle(), n.style), this._mergeStyle(u, i.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : n.style), this._mergeStyle(u, i.style)) : l && (u = n.style), u)
      if (o) {
        var h = this.style;
        if (this.style = this.createStyle(l ? {} : h), l)
          for (var c = He(h), f = 0; f < c.length; f++) {
            var d = c[f];
            d in u && (u[d] = u[d], this.style[d] = h[d]);
          }
        for (var p = He(u), f = 0; f < p.length; f++) {
          var d = p[f];
          this.style[d] = this.style[d];
        }
        this._transitionState(t, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? ene : kL, f = 0; f < g.length; f++) {
      var d = g[f];
      i && i[d] != null ? this[d] = i[d] : l && n[d] != null && (this[d] = n[d]);
    }
  }, e.prototype._mergeStates = function(t) {
    for (var i = r.prototype._mergeStates.call(this, t), n, a = 0; a < t.length; a++) {
      var o = t[a];
      o.style && (n = n || {}, this._mergeStyle(n, o.style));
    }
    return n && (i.style = n), i;
  }, e.prototype._mergeStyle = function(t, i) {
    return V(t, i), t;
  }, e.prototype.getAnimationStyleProps = function() {
    return bS;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "displayable", t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = "pointer", t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = un | Nd;
  }(), e;
}(sX), cy = new Ue(0, 0, 0, 0), fy = new Ue(0, 0, 0, 0);
function rne(r, e, t) {
  return cy.copy(r.getBoundingRect()), r.transform && cy.applyTransform(r.transform), fy.width = e, fy.height = t, !cy.intersect(fy);
}
const qn = tne;
var Mi = Math.min, ki = Math.max, dy = Math.sin, py = Math.cos, Ql = Math.PI * 2, Bv = Eh(), Vv = Eh(), Fv = Eh();
function SS(r, e, t) {
  if (r.length !== 0) {
    for (var i = r[0], n = i[0], a = i[0], o = i[1], s = i[1], l = 1; l < r.length; l++)
      i = r[l], n = Mi(n, i[0]), a = ki(a, i[0]), o = Mi(o, i[1]), s = ki(s, i[1]);
    e[0] = n, e[1] = o, t[0] = a, t[1] = s;
  }
}
function QL(r, e, t, i, n, a) {
  n[0] = Mi(r, t), n[1] = Mi(e, i), a[0] = ki(r, t), a[1] = ki(e, i);
}
var UL = [], $L = [];
function ine(r, e, t, i, n, a, o, s, l, u) {
  var h = XF, c = Er, f = h(r, t, n, o, UL);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var d = 0; d < f; d++) {
    var p = c(r, t, n, o, UL[d]);
    l[0] = Mi(p, l[0]), u[0] = ki(p, u[0]);
  }
  f = h(e, i, a, s, $L);
  for (var d = 0; d < f; d++) {
    var g = c(e, i, a, s, $L[d]);
    l[1] = Mi(g, l[1]), u[1] = ki(g, u[1]);
  }
  l[0] = Mi(r, l[0]), u[0] = ki(r, u[0]), l[0] = Mi(o, l[0]), u[0] = ki(o, u[0]), l[1] = Mi(e, l[1]), u[1] = ki(e, u[1]), l[1] = Mi(s, l[1]), u[1] = ki(s, u[1]);
}
function nne(r, e, t, i, n, a, o, s) {
  var l = HF, u = Pr, h = ki(Mi(l(r, t, n), 1), 0), c = ki(Mi(l(e, i, a), 1), 0), f = u(r, t, n, h), d = u(e, i, a, c);
  o[0] = Mi(r, n, f), o[1] = Mi(e, a, d), s[0] = ki(r, n, f), s[1] = ki(e, a, d);
}
function ane(r, e, t, i, n, a, o, s, l) {
  var u = ws, h = Ps, c = Math.abs(n - a);
  if (c % Ql < 1e-4 && c > 1e-4) {
    s[0] = r - t, s[1] = e - i, l[0] = r + t, l[1] = e + i;
    return;
  }
  if (Bv[0] = py(n) * t + r, Bv[1] = dy(n) * i + e, Vv[0] = py(a) * t + r, Vv[1] = dy(a) * i + e, u(s, Bv, Vv), h(l, Bv, Vv), n = n % Ql, n < 0 && (n = n + Ql), a = a % Ql, a < 0 && (a = a + Ql), n > a && !o ? a += Ql : n < a && o && (n += Ql), o) {
    var f = a;
    a = n, n = f;
  }
  for (var d = 0; d < a; d += Math.PI / 2)
    d > n && (Fv[0] = py(d) * t + r, Fv[1] = dy(d) * i + e, u(s, Fv, s), h(l, Fv, l));
}
var _t = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, Ul = [], $l = [], Ra = [], us = [], Aa = [], Ca = [], gy = Math.min, vy = Math.max, Gl = Math.cos, Bl = Math.sin, So = Math.abs, qA = Math.PI, bs = qA * 2, Oy = typeof Float32Array < "u", qf = [];
function my(r) {
  var e = Math.round(r / qA * 1e8) / 1e8;
  return e % 2 * qA;
}
function _X(r, e) {
  var t = my(r[0]);
  t < 0 && (t += bs);
  var i = t - r[0], n = r[1];
  n += i, !e && n - t >= bs ? n = t + bs : e && t - n >= bs ? n = t - bs : !e && t > n ? n = t + (bs - my(t - n)) : e && t < n && (n = t - (bs - my(n - t))), r[0] = t, r[1] = n;
}
var lo = function() {
  function r(e) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return r.prototype.increaseVersion = function() {
    this._version++;
  }, r.prototype.getVersion = function() {
    return this._version;
  }, r.prototype.setScale = function(e, t, i) {
    i = i || 0, i > 0 && (this._ux = So(i / vE / e) || 0, this._uy = So(i / vE / t) || 0);
  }, r.prototype.setDPR = function(e) {
    this.dpr = e;
  }, r.prototype.setContext = function(e) {
    this._ctx = e;
  }, r.prototype.getContext = function() {
    return this._ctx;
  }, r.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, r.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, r.prototype.moveTo = function(e, t) {
    return this._drawPendingPt(), this.addData(_t.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this;
  }, r.prototype.lineTo = function(e, t) {
    var i = So(e - this._xi), n = So(t - this._yi), a = i > this._ux || n > this._uy;
    if (this.addData(_t.L, e, t), this._ctx && a && this._ctx.lineTo(e, t), a)
      this._xi = e, this._yi = t, this._pendingPtDist = 0;
    else {
      var o = i * i + n * n;
      o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = o);
    }
    return this;
  }, r.prototype.bezierCurveTo = function(e, t, i, n, a, o) {
    return this._drawPendingPt(), this.addData(_t.C, e, t, i, n, a, o), this._ctx && this._ctx.bezierCurveTo(e, t, i, n, a, o), this._xi = a, this._yi = o, this;
  }, r.prototype.quadraticCurveTo = function(e, t, i, n) {
    return this._drawPendingPt(), this.addData(_t.Q, e, t, i, n), this._ctx && this._ctx.quadraticCurveTo(e, t, i, n), this._xi = i, this._yi = n, this;
  }, r.prototype.arc = function(e, t, i, n, a, o) {
    this._drawPendingPt(), qf[0] = n, qf[1] = a, _X(qf, o), n = qf[0], a = qf[1];
    var s = a - n;
    return this.addData(_t.A, e, t, i, i, n, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(e, t, i, n, a, o), this._xi = Gl(a) * i + e, this._yi = Bl(a) * i + t, this;
  }, r.prototype.arcTo = function(e, t, i, n, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, i, n, a), this;
  }, r.prototype.rect = function(e, t, i, n) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, i, n), this.addData(_t.R, e, t, i, n), this;
  }, r.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(_t.Z);
    var e = this._ctx, t = this._x0, i = this._y0;
    return e && e.closePath(), this._xi = t, this._yi = i, this;
  }, r.prototype.fill = function(e) {
    e && e.fill(), this.toStatic();
  }, r.prototype.stroke = function(e) {
    e && e.stroke(), this.toStatic();
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.setData = function(e) {
    var t = e.length;
    !(this.data && this.data.length === t) && Oy && (this.data = new Float32Array(t));
    for (var i = 0; i < t; i++)
      this.data[i] = e[i];
    this._len = t;
  }, r.prototype.appendPath = function(e) {
    e instanceof Array || (e = [e]);
    for (var t = e.length, i = 0, n = this._len, a = 0; a < t; a++)
      i += e[a].len();
    Oy && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
    for (var a = 0; a < t; a++)
      for (var o = e[a].data, s = 0; s < o.length; s++)
        this.data[n++] = o[s];
    this._len = n;
  }, r.prototype.addData = function(e, t, i, n, a, o, s, l, u) {
    if (this._saveData) {
      var h = this.data;
      this._len + arguments.length > h.length && (this._expandData(), h = this.data);
      for (var c = 0; c < arguments.length; c++)
        h[this._len++] = arguments[c];
    }
  }, r.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, r.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var e = [], t = 0; t < this._len; t++)
        e[t] = this.data[t];
      this.data = e;
    }
  }, r.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var e = this.data;
      e instanceof Array && (e.length = this._len, Oy && this._len > 11 && (this.data = new Float32Array(e)));
    }
  }, r.prototype.getBoundingRect = function() {
    Ra[0] = Ra[1] = Aa[0] = Aa[1] = Number.MAX_VALUE, us[0] = us[1] = Ca[0] = Ca[1] = -Number.MAX_VALUE;
    var e = this.data, t = 0, i = 0, n = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = e[o++], l = o === 1;
      switch (l && (t = e[o], i = e[o + 1], n = t, a = i), s) {
        case _t.M:
          t = n = e[o++], i = a = e[o++], Aa[0] = n, Aa[1] = a, Ca[0] = n, Ca[1] = a;
          break;
        case _t.L:
          QL(t, i, e[o], e[o + 1], Aa, Ca), t = e[o++], i = e[o++];
          break;
        case _t.C:
          ine(t, i, e[o++], e[o++], e[o++], e[o++], e[o], e[o + 1], Aa, Ca), t = e[o++], i = e[o++];
          break;
        case _t.Q:
          nne(t, i, e[o++], e[o++], e[o], e[o + 1], Aa, Ca), t = e[o++], i = e[o++];
          break;
        case _t.A:
          var u = e[o++], h = e[o++], c = e[o++], f = e[o++], d = e[o++], p = e[o++] + d;
          o += 1;
          var g = !e[o++];
          l && (n = Gl(d) * c + u, a = Bl(d) * f + h), ane(u, h, c, f, d, p, g, Aa, Ca), t = Gl(p) * c + u, i = Bl(p) * f + h;
          break;
        case _t.R:
          n = t = e[o++], a = i = e[o++];
          var v = e[o++], O = e[o++];
          QL(n, a, n + v, a + O, Aa, Ca);
          break;
        case _t.Z:
          t = n, i = a;
          break;
      }
      ws(Ra, Ra, Aa), Ps(us, us, Ca);
    }
    return o === 0 && (Ra[0] = Ra[1] = us[0] = us[1] = 0), new Ue(Ra[0], Ra[1], us[0] - Ra[0], us[1] - Ra[1]);
  }, r.prototype._calculateLength = function() {
    var e = this.data, t = this._len, i = this._ux, n = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, h = 0, c = 0, f = 0; f < t; ) {
      var d = e[f++], p = f === 1;
      p && (a = e[f], o = e[f + 1], s = a, l = o);
      var g = -1;
      switch (d) {
        case _t.M:
          a = s = e[f++], o = l = e[f++];
          break;
        case _t.L: {
          var v = e[f++], O = e[f++], m = v - a, E = O - o;
          (So(m) > i || So(E) > n || f === t - 1) && (g = Math.sqrt(m * m + E * E), a = v, o = O);
          break;
        }
        case _t.C: {
          var b = e[f++], T = e[f++], v = e[f++], O = e[f++], S = e[f++], y = e[f++];
          g = Sre(a, o, b, T, v, O, S, y, 10), a = S, o = y;
          break;
        }
        case _t.Q: {
          var b = e[f++], T = e[f++], v = e[f++], O = e[f++];
          g = yre(a, o, b, T, v, O, 10), a = v, o = O;
          break;
        }
        case _t.A:
          var A = e[f++], C = e[f++], _ = e[f++], I = e[f++], x = e[f++], P = e[f++], N = P + x;
          f += 1, e[f++], p && (s = Gl(x) * _ + A, l = Bl(x) * I + C), g = vy(_, I) * gy(bs, Math.abs(P)), a = Gl(N) * _ + A, o = Bl(N) * I + C;
          break;
        case _t.R: {
          s = a = e[f++], l = o = e[f++];
          var L = e[f++], D = e[f++];
          g = L * 2 + D * 2;
          break;
        }
        case _t.Z: {
          var m = s - a, E = l - o;
          g = Math.sqrt(m * m + E * E), a = s, o = l;
          break;
        }
      }
      g >= 0 && (u[c++] = g, h += g);
    }
    return this._pathLen = h, h;
  }, r.prototype.rebuildPath = function(e, t) {
    var i = this.data, n = this._ux, a = this._uy, o = this._len, s, l, u, h, c, f, d = t < 1, p, g, v = 0, O = 0, m, E = 0, b, T;
    if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, m = t * g, !m)))
      e:
        for (var S = 0; S < o; ) {
          var y = i[S++], A = S === 1;
          switch (A && (u = i[S], h = i[S + 1], s = u, l = h), y !== _t.L && E > 0 && (e.lineTo(b, T), E = 0), y) {
            case _t.M:
              s = u = i[S++], l = h = i[S++], e.moveTo(u, h);
              break;
            case _t.L: {
              c = i[S++], f = i[S++];
              var C = So(c - u), _ = So(f - h);
              if (C > n || _ > a) {
                if (d) {
                  var I = p[O++];
                  if (v + I > m) {
                    var x = (m - v) / I;
                    e.lineTo(u * (1 - x) + c * x, h * (1 - x) + f * x);
                    break e;
                  }
                  v += I;
                }
                e.lineTo(c, f), u = c, h = f, E = 0;
              } else {
                var P = C * C + _ * _;
                P > E && (b = c, T = f, E = P);
              }
              break;
            }
            case _t.C: {
              var N = i[S++], L = i[S++], D = i[S++], $ = i[S++], k = i[S++], G = i[S++];
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var x = (m - v) / I;
                  nl(u, N, D, k, x, Ul), nl(h, L, $, G, x, $l), e.bezierCurveTo(Ul[1], $l[1], Ul[2], $l[2], Ul[3], $l[3]);
                  break e;
                }
                v += I;
              }
              e.bezierCurveTo(N, L, D, $, k, G), u = k, h = G;
              break;
            }
            case _t.Q: {
              var N = i[S++], L = i[S++], D = i[S++], $ = i[S++];
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var x = (m - v) / I;
                  Gp(u, N, D, x, Ul), Gp(h, L, $, x, $l), e.quadraticCurveTo(Ul[1], $l[1], Ul[2], $l[2]);
                  break e;
                }
                v += I;
              }
              e.quadraticCurveTo(N, L, D, $), u = D, h = $;
              break;
            }
            case _t.A:
              var F = i[S++], q = i[S++], re = i[S++], fe = i[S++], de = i[S++], $e = i[S++], Pe = i[S++], Ne = !i[S++], Ee = re > fe ? re : fe, xe = So(re - fe) > 1e-3, Ce = de + $e, ue = !1;
              if (d) {
                var I = p[O++];
                v + I > m && (Ce = de + $e * (m - v) / I, ue = !0), v += I;
              }
              if (xe && e.ellipse ? e.ellipse(F, q, re, fe, Pe, de, Ce, Ne) : e.arc(F, q, Ee, de, Ce, Ne), ue)
                break e;
              A && (s = Gl(de) * re + F, l = Bl(de) * fe + q), u = Gl(Ce) * re + F, h = Bl(Ce) * fe + q;
              break;
            case _t.R:
              s = u = i[S], l = h = i[S + 1], c = i[S++], f = i[S++];
              var M = i[S++], Q = i[S++];
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var B = m - v;
                  e.moveTo(c, f), e.lineTo(c + gy(B, M), f), B -= M, B > 0 && e.lineTo(c + M, f + gy(B, Q)), B -= Q, B > 0 && e.lineTo(c + vy(M - B, 0), f + Q), B -= M, B > 0 && e.lineTo(c, f + vy(Q - B, 0));
                  break e;
                }
                v += I;
              }
              e.rect(c, f, M, Q);
              break;
            case _t.Z:
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var x = (m - v) / I;
                  e.lineTo(u * (1 - x) + s * x, h * (1 - x) + l * x);
                  break e;
                }
                v += I;
              }
              e.closePath(), u = s, h = l;
          }
        }
  }, r.prototype.clone = function() {
    var e = new r(), t = this.data;
    return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e;
  }, r.CMD = _t, r.initDefaultProps = function() {
    var e = r.prototype;
    e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
  }(), r;
}();
function ys(r, e, t, i, n, a, o) {
  if (n === 0)
    return !1;
  var s = n, l = 0, u = r;
  if (o > e + s && o > i + s || o < e - s && o < i - s || a > r + s && a > t + s || a < r - s && a < t - s)
    return !1;
  if (r !== t)
    l = (e - i) / (r - t), u = (r * i - t * e) / (r - t);
  else
    return Math.abs(a - r) <= s / 2;
  var h = l * a - o + u, c = h * h / (l * l + 1);
  return c <= s / 2 * s / 2;
}
function one(r, e, t, i, n, a, o, s, l, u, h) {
  if (l === 0)
    return !1;
  var c = l;
  if (h > e + c && h > i + c && h > a + c && h > s + c || h < e - c && h < i - c && h < a - c && h < s - c || u > r + c && u > t + c && u > n + c && u > o + c || u < r - c && u < t - c && u < n - c && u < o - c)
    return !1;
  var f = YF(r, e, t, i, n, a, o, s, u, h, null);
  return f <= c / 2;
}
function IX(r, e, t, i, n, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > e + u && l > i + u && l > a + u || l < e - u && l < i - u && l < a - u || s > r + u && s > t + u && s > n + u || s < r - u && s < t - u && s < n - u)
    return !1;
  var h = WF(r, e, t, i, n, a, s, l, null);
  return h <= u / 2;
}
var GL = Math.PI * 2;
function ca(r) {
  return r %= GL, r < 0 && (r += GL), r;
}
var jf = Math.PI * 2;
function sne(r, e, t, i, n, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= r, l -= e;
  var h = Math.sqrt(s * s + l * l);
  if (h - u > t || h + u < t)
    return !1;
  if (Math.abs(i - n) % jf < 1e-4)
    return !0;
  if (a) {
    var c = i;
    i = ca(n), n = ca(c);
  } else
    i = ca(i), n = ca(n);
  i > n && (n += jf);
  var f = Math.atan2(l, s);
  return f < 0 && (f += jf), f >= i && f <= n || f + jf >= i && f + jf <= n;
}
function _o(r, e, t, i, n, a) {
  if (a > e && a > i || a < e && a < i || i === e)
    return 0;
  var o = (a - e) / (i - e), s = i < e ? 1 : -1;
  (o === 1 || o === 0) && (s = i < e ? 0.5 : -0.5);
  var l = o * (t - r) + r;
  return l === n ? 1 / 0 : l > n ? s : 0;
}
var hs = lo.CMD, Vl = Math.PI * 2, lne = 1e-4;
function une(r, e) {
  return Math.abs(r - e) < lne;
}
var mi = [-1, -1, -1], xn = [-1, -1];
function hne() {
  var r = xn[0];
  xn[0] = xn[1], xn[1] = r;
}
function cne(r, e, t, i, n, a, o, s, l, u) {
  if (u > e && u > i && u > a && u > s || u < e && u < i && u < a && u < s)
    return 0;
  var h = fE(e, i, a, s, u, mi);
  if (h === 0)
    return 0;
  for (var c = 0, f = -1, d = void 0, p = void 0, g = 0; g < h; g++) {
    var v = mi[g], O = v === 0 || v === 1 ? 0.5 : 1, m = Er(r, t, n, o, v);
    m < l || (f < 0 && (f = XF(e, i, a, s, xn), xn[1] < xn[0] && f > 1 && hne(), d = Er(e, i, a, s, xn[0]), f > 1 && (p = Er(e, i, a, s, xn[1]))), f === 2 ? v < xn[0] ? c += d < e ? O : -O : v < xn[1] ? c += p < d ? O : -O : c += s < p ? O : -O : v < xn[0] ? c += d < e ? O : -O : c += s < d ? O : -O);
  }
  return c;
}
function fne(r, e, t, i, n, a, o, s) {
  if (s > e && s > i && s > a || s < e && s < i && s < a)
    return 0;
  var l = Tre(e, i, a, s, mi);
  if (l === 0)
    return 0;
  var u = HF(e, i, a);
  if (u >= 0 && u <= 1) {
    for (var h = 0, c = Pr(e, i, a, u), f = 0; f < l; f++) {
      var d = mi[f] === 0 || mi[f] === 1 ? 0.5 : 1, p = Pr(r, t, n, mi[f]);
      p < o || (mi[f] < u ? h += c < e ? d : -d : h += a < c ? d : -d);
    }
    return h;
  } else {
    var d = mi[0] === 0 || mi[0] === 1 ? 0.5 : 1, p = Pr(r, t, n, mi[0]);
    return p < o ? 0 : a < e ? d : -d;
  }
}
function dne(r, e, t, i, n, a, o, s) {
  if (s -= e, s > t || s < -t)
    return 0;
  var l = Math.sqrt(t * t - s * s);
  mi[0] = -l, mi[1] = l;
  var u = Math.abs(i - n);
  if (u < 1e-4)
    return 0;
  if (u >= Vl - 1e-4) {
    i = 0, n = Vl;
    var h = a ? 1 : -1;
    return o >= mi[0] + r && o <= mi[1] + r ? h : 0;
  }
  if (i > n) {
    var c = i;
    i = n, n = c;
  }
  i < 0 && (i += Vl, n += Vl);
  for (var f = 0, d = 0; d < 2; d++) {
    var p = mi[d];
    if (p + r > o) {
      var g = Math.atan2(s, p), h = a ? 1 : -1;
      g < 0 && (g = Vl + g), (g >= i && g <= n || g + Vl >= i && g + Vl <= n) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (h = -h), f += h);
    }
  }
  return f;
}
function xX(r, e, t, i, n) {
  for (var a = r.data, o = r.len(), s = 0, l = 0, u = 0, h = 0, c = 0, f, d, p = 0; p < o; ) {
    var g = a[p++], v = p === 1;
    switch (g === hs.M && p > 1 && (t || (s += _o(l, u, h, c, i, n))), v && (l = a[p], u = a[p + 1], h = l, c = u), g) {
      case hs.M:
        h = a[p++], c = a[p++], l = h, u = c;
        break;
      case hs.L:
        if (t) {
          if (ys(l, u, a[p], a[p + 1], e, i, n))
            return !0;
        } else
          s += _o(l, u, a[p], a[p + 1], i, n) || 0;
        l = a[p++], u = a[p++];
        break;
      case hs.C:
        if (t) {
          if (one(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], e, i, n))
            return !0;
        } else
          s += cne(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], i, n) || 0;
        l = a[p++], u = a[p++];
        break;
      case hs.Q:
        if (t) {
          if (IX(l, u, a[p++], a[p++], a[p], a[p + 1], e, i, n))
            return !0;
        } else
          s += fne(l, u, a[p++], a[p++], a[p], a[p + 1], i, n) || 0;
        l = a[p++], u = a[p++];
        break;
      case hs.A:
        var O = a[p++], m = a[p++], E = a[p++], b = a[p++], T = a[p++], S = a[p++];
        p += 1;
        var y = !!(1 - a[p++]);
        f = Math.cos(T) * E + O, d = Math.sin(T) * b + m, v ? (h = f, c = d) : s += _o(l, u, f, d, i, n);
        var A = (i - O) * b / E + O;
        if (t) {
          if (sne(O, m, b, T, T + S, y, e, A, n))
            return !0;
        } else
          s += dne(O, m, b, T, T + S, y, A, n);
        l = Math.cos(T + S) * E + O, u = Math.sin(T + S) * b + m;
        break;
      case hs.R:
        h = l = a[p++], c = u = a[p++];
        var C = a[p++], _ = a[p++];
        if (f = h + C, d = c + _, t) {
          if (ys(h, c, f, c, e, i, n) || ys(f, c, f, d, e, i, n) || ys(f, d, h, d, e, i, n) || ys(h, d, h, c, e, i, n))
            return !0;
        } else
          s += _o(f, c, f, d, i, n), s += _o(h, d, h, c, i, n);
        break;
      case hs.Z:
        if (t) {
          if (ys(l, u, h, c, e, i, n))
            return !0;
        } else
          s += _o(l, u, h, c, i, n);
        l = h, u = c;
        break;
    }
  }
  return !t && !une(u, c) && (s += _o(l, u, h, c, i, n) || 0), s !== 0;
}
function pne(r, e, t) {
  return xX(r, 0, !1, e, t);
}
function gne(r, e, t, i) {
  return xX(r, e, !0, t, i);
}
var EE = me({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, $u), vne = {
  style: me({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, bS.style)
}, Ey = oo.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), One = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.update = function() {
    var t = this;
    r.prototype.update.call(this);
    var i = this.style;
    if (i.decal) {
      var n = this._decalEl = this._decalEl || new e();
      n.buildPath === e.prototype.buildPath && (n.buildPath = function(l) {
        t.buildPath(l, t.shape);
      }), n.silent = !0;
      var a = n.style;
      for (var o in i)
        a[o] !== i[o] && (a[o] = i[o]);
      a.fill = i.fill ? i.decal : null, a.decal = null, a.shadowColor = null, i.strokeFirst && (a.stroke = null);
      for (var s = 0; s < Ey.length; ++s)
        n[Ey[s]] = this[Ey[s]];
      n.__dirty |= un;
    } else
      this._decalEl && (this._decalEl = null);
  }, e.prototype.getDecalElement = function() {
    return this._decalEl;
  }, e.prototype._init = function(t) {
    var i = He(t);
    this.shape = this.getDefaultShape();
    var n = this.getDefaultStyle();
    n && this.useStyle(n);
    for (var a = 0; a < i.length; a++) {
      var o = i[a], s = t[o];
      o === "style" ? this.style ? V(this.style, s) : this.useStyle(s) : o === "shape" ? V(this.shape, s) : r.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, e.prototype.getDefaultStyle = function() {
    return null;
  }, e.prototype.getDefaultShape = function() {
    return {};
  }, e.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, e.prototype.getInsideTextFill = function() {
    var t = this.style.fill;
    if (t !== "none") {
      if (ne(t)) {
        var i = pE(t, 0);
        return i > 0.5 ? YA : i > 0.2 ? eie : HA;
      } else if (t)
        return HA;
    }
    return YA;
  }, e.prototype.getInsideTextStroke = function(t) {
    var i = this.style.fill;
    if (ne(i)) {
      var n = this.__zr, a = !!(n && n.isDarkMode()), o = pE(t, 0) < XA;
      if (a === o)
        return i;
    }
  }, e.prototype.buildPath = function(t, i, n) {
  }, e.prototype.pathUpdated = function() {
    this.__dirty &= ~oc;
  }, e.prototype.getUpdatedPathProxy = function(t) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
  }, e.prototype.createPathProxy = function() {
    this.path = new lo(!1);
  }, e.prototype.hasStroke = function() {
    var t = this.style, i = t.stroke;
    return !(i == null || i === "none" || !(t.lineWidth > 0));
  }, e.prototype.hasFill = function() {
    var t = this.style, i = t.fill;
    return i != null && i !== "none";
  }, e.prototype.getBoundingRect = function() {
    var t = this._rect, i = this.style, n = !t;
    if (n) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & oc) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), t = o.getBoundingRect();
    }
    if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = t.clone());
      if (this.__dirty || n) {
        s.copy(t);
        var l = i.strokeNoScale ? this.getLineScale() : 1, u = i.lineWidth;
        if (!this.hasFill()) {
          var h = this.strokeContainThreshold;
          u = Math.max(u, h ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return t;
  }, e.prototype.contain = function(t, i) {
    var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect(), o = this.style;
    if (t = n[0], i = n[1], a.contain(t, i)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), gne(s, l / u, t, i)))
          return !0;
      }
      if (this.hasFill())
        return pne(s, t, i);
    }
    return !1;
  }, e.prototype.dirtyShape = function() {
    this.__dirty |= oc, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, e.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, e.prototype.animateShape = function(t) {
    return this.animate("shape", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
  }, e.prototype.attrKV = function(t, i) {
    t === "shape" ? this.setShape(i) : r.prototype.attrKV.call(this, t, i);
  }, e.prototype.setShape = function(t, i) {
    var n = this.shape;
    return n || (n = this.shape = {}), typeof t == "string" ? n[t] = i : V(n, t), this.dirtyShape(), this;
  }, e.prototype.shapeChanged = function() {
    return !!(this.__dirty & oc);
  }, e.prototype.createStyle = function(t) {
    return pS(EE, t);
  }, e.prototype._innerSaveToNormal = function(t) {
    r.prototype._innerSaveToNormal.call(this, t);
    var i = this._normalState;
    t.shape && !i.shape && (i.shape = V({}, this.shape));
  }, e.prototype._applyStateObj = function(t, i, n, a, o, s) {
    r.prototype._applyStateObj.call(this, t, i, n, a, o, s);
    var l = !(i && a), u;
    if (i && i.shape ? o ? a ? u = i.shape : (u = V({}, n.shape), V(u, i.shape)) : (u = V({}, a ? this.shape : n.shape), V(u, i.shape)) : l && (u = n.shape), u)
      if (o) {
        this.shape = V({}, this.shape);
        for (var h = {}, c = He(u), f = 0; f < c.length; f++) {
          var d = c[f];
          typeof u[d] == "object" ? this.shape[d] = u[d] : h[d] = u[d];
        }
        this._transitionState(t, {
          shape: h
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, e.prototype._mergeStates = function(t) {
    for (var i = r.prototype._mergeStates.call(this, t), n, a = 0; a < t.length; a++) {
      var o = t[a];
      o.shape && (n = n || {}, this._mergeStyle(n, o.shape));
    }
    return n && (i.shape = n), i;
  }, e.prototype.getAnimationStyleProps = function() {
    return vne;
  }, e.prototype.isZeroArea = function() {
    return !1;
  }, e.extend = function(t) {
    var i = function(a) {
      U(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return t.init && t.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return Se(t.style);
      }, o.prototype.getDefaultShape = function() {
        return Se(t.shape);
      }, o;
    }(e);
    for (var n in t)
      typeof t[n] == "function" && (i.prototype[n] = t[n]);
    return i;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = un | Nd | oc;
  }(), e;
}(qn);
const Fe = One;
var mne = me({
  strokeFirst: !0,
  font: rl,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, EE), wX = function(r) {
  U(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.hasStroke = function() {
    var t = this.style, i = t.stroke;
    return i != null && i !== "none" && t.lineWidth > 0;
  }, e.prototype.hasFill = function() {
    var t = this.style, i = t.fill;
    return i != null && i !== "none";
  }, e.prototype.createStyle = function(t) {
    return pS(mne, t);
  }, e.prototype.setBoundingRect = function(t) {
    this._rect = t;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    if (!this._rect) {
      var i = t.text;
      i != null ? i += "" : i = "";
      var n = Qg(i, t.font, t.textAlign, t.textBaseline);
      if (n.x += t.x || 0, n.y += t.y || 0, this.hasStroke()) {
        var a = t.lineWidth;
        n.x -= a / 2, n.y -= a / 2, n.width += a, n.height += a;
      }
      this._rect = n;
    }
    return this._rect;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.dirtyRectTolerance = 10;
  }(), e;
}(qn);
wX.prototype.type = "tspan";
const Xp = wX;
var Ene = me({
  x: 0,
  y: 0
}, $u), bne = {
  style: me({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, bS.style)
};
function Sne(r) {
  return !!(r && typeof r != "string" && r.width && r.height);
}
var PX = function(r) {
  U(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.createStyle = function(t) {
    return pS(Ene, t);
  }, e.prototype._getSize = function(t) {
    var i = this.style, n = i[t];
    if (n != null)
      return n;
    var a = Sne(i.image) ? i.image : this.__image;
    if (!a)
      return 0;
    var o = t === "width" ? "height" : "width", s = i[o];
    return s == null ? a[t] : a[t] / a[o] * s;
  }, e.prototype.getWidth = function() {
    return this._getSize("width");
  }, e.prototype.getHeight = function() {
    return this._getSize("height");
  }, e.prototype.getAnimationStyleProps = function() {
    return bne;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    return this._rect || (this._rect = new Ue(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, e;
}(qn);
PX.prototype.type = "image";
const qr = PX;
function Tne(r, e) {
  var t = e.x, i = e.y, n = e.width, a = e.height, o = e.r, s, l, u, h;
  n < 0 && (t = t + n, n = -n), a < 0 && (i = i + a, a = -a), typeof o == "number" ? s = l = u = h = o : o instanceof Array ? o.length === 1 ? s = l = u = h = o[0] : o.length === 2 ? (s = u = o[0], l = h = o[1]) : o.length === 3 ? (s = o[0], l = h = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], h = o[3]) : s = l = u = h = 0;
  var c;
  s + l > n && (c = s + l, s *= n / c, l *= n / c), u + h > n && (c = u + h, u *= n / c, h *= n / c), l + u > a && (c = l + u, l *= a / c, u *= a / c), s + h > a && (c = s + h, s *= a / c, h *= a / c), r.moveTo(t + s, i), r.lineTo(t + n - l, i), l !== 0 && r.arc(t + n - l, i + l, l, -Math.PI / 2, 0), r.lineTo(t + n, i + a - u), u !== 0 && r.arc(t + n - u, i + a - u, u, 0, Math.PI / 2), r.lineTo(t + h, i + a), h !== 0 && r.arc(t + h, i + a - h, h, Math.PI / 2, Math.PI), r.lineTo(t, i + s), s !== 0 && r.arc(t + s, i + s, s, Math.PI, Math.PI * 1.5);
}
var vc = Math.round;
function NX(r, e, t) {
  if (e) {
    var i = e.x1, n = e.x2, a = e.y1, o = e.y2;
    r.x1 = i, r.x2 = n, r.y1 = a, r.y2 = o;
    var s = t && t.lineWidth;
    return s && (vc(i * 2) === vc(n * 2) && (r.x1 = r.x2 = Su(i, s, !0)), vc(a * 2) === vc(o * 2) && (r.y1 = r.y2 = Su(a, s, !0))), r;
  }
}
function LX(r, e, t) {
  if (e) {
    var i = e.x, n = e.y, a = e.width, o = e.height;
    r.x = i, r.y = n, r.width = a, r.height = o;
    var s = t && t.lineWidth;
    return s && (r.x = Su(i, s, !0), r.y = Su(n, s, !0), r.width = Math.max(Su(i + a, s, !1) - r.x, a === 0 ? 0 : 1), r.height = Math.max(Su(n + o, s, !1) - r.y, o === 0 ? 0 : 1)), r;
  }
}
function Su(r, e, t) {
  if (!e)
    return r;
  var i = vc(r * 2);
  return (i + vc(e)) % 2 === 0 ? i / 2 : (i + (t ? 1 : -1)) / 2;
}
var yne = function() {
  function r() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return r;
}(), Rne = {}, DX = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new yne();
  }, e.prototype.buildPath = function(t, i) {
    var n, a, o, s;
    if (this.subPixelOptimize) {
      var l = LX(Rne, i, this.style);
      n = l.x, a = l.y, o = l.width, s = l.height, l.r = i.r, i = l;
    } else
      n = i.x, a = i.y, o = i.width, s = i.height;
    i.r ? Tne(t, i) : t.rect(n, a, o, s);
  }, e.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, e;
}(Fe);
DX.prototype.type = "rect";
const nt = DX;
var BL = {
  fill: "#000"
}, VL = 2, Ane = {
  style: me({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, bS.style)
}, MX = function(r) {
  U(e, r);
  function e(t) {
    var i = r.call(this) || this;
    return i.type = "text", i._children = [], i._defaultStyle = BL, i.attr(t), i;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.update = function() {
    r.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var t = 0; t < this._children.length; t++) {
      var i = this._children[t];
      i.zlevel = this.zlevel, i.z = this.z, i.z2 = this.z2, i.culling = this.culling, i.cursor = this.cursor, i.invisible = this.invisible;
    }
  }, e.prototype.updateTransform = function() {
    var t = this.innerTransformable;
    t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : r.prototype.updateTransform.call(this);
  }, e.prototype.getLocalTransform = function(t) {
    var i = this.innerTransformable;
    return i ? i.getLocalTransform(t) : r.prototype.getLocalTransform.call(this, t);
  }, e.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), r.prototype.getComputedTransform.call(this);
  }, e.prototype._updateSubTexts = function() {
    this._childCursor = 0, Ine(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, e.prototype.addSelfToZr = function(t) {
    r.prototype.addSelfToZr.call(this, t);
    for (var i = 0; i < this._children.length; i++)
      this._children[i].__zr = t;
  }, e.prototype.removeSelfFromZr = function(t) {
    r.prototype.removeSelfFromZr.call(this, t);
    for (var i = 0; i < this._children.length; i++)
      this._children[i].__zr = null;
  }, e.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var t = new Ue(0, 0, 0, 0), i = this._children, n = [], a = null, o = 0; o < i.length; o++) {
        var s = i[o], l = s.getBoundingRect(), u = s.getLocalTransform(n);
        u ? (t.copy(l), t.applyTransform(u), a = a || t.clone(), a.union(t)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || t;
    }
    return this._rect;
  }, e.prototype.setDefaultTextStyle = function(t) {
    this._defaultStyle = t || BL;
  }, e.prototype.setTextContent = function(t) {
  }, e.prototype._mergeStyle = function(t, i) {
    if (!i)
      return t;
    var n = i.rich, a = t.rich || n && {};
    return V(t, i), n && a ? (this._mergeRich(a, n), t.rich = a) : a && (t.rich = a), t;
  }, e.prototype._mergeRich = function(t, i) {
    for (var n = He(i), a = 0; a < n.length; a++) {
      var o = n[a];
      t[o] = t[o] || {}, V(t[o], i[o]);
    }
  }, e.prototype.getAnimationStyleProps = function() {
    return Ane;
  }, e.prototype._getOrCreateChild = function(t) {
    var i = this._children[this._childCursor];
    return (!i || !(i instanceof t)) && (i = new t()), this._children[this._childCursor++] = i, i.__zr = this.__zr, i.parent = this, i;
  }, e.prototype._updatePlainTexts = function() {
    var t = this.style, i = t.font || rl, n = t.padding, a = ZL(t), o = Wie(a, t), s = by(t), l = !!t.backgroundColor, u = o.outerHeight, h = o.outerWidth, c = o.contentWidth, f = o.lines, d = o.lineHeight, p = this._defaultStyle, g = t.x || 0, v = t.y || 0, O = t.align || p.align || "left", m = t.verticalAlign || p.verticalAlign || "top", E = g, b = sc(v, o.contentHeight, m);
    if (s || n) {
      var T = Dd(g, h, O), S = sc(v, u, m);
      s && this._renderBackground(t, t, T, S, h, u);
    }
    b += d / 2, n && (E = zL(g, O, n), m === "top" ? b += n[0] : m === "bottom" && (b -= n[2]));
    for (var y = 0, A = !1, C = WL("fill" in t ? t.fill : (A = !0, p.fill)), _ = HL("stroke" in t ? t.stroke : !l && (!p.autoStroke || A) ? (y = VL, p.stroke) : null), I = t.textShadowBlur > 0, x = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), P = o.calculatedLineHeight, N = 0; N < f.length; N++) {
      var L = this._getOrCreateChild(Xp), D = L.createStyle();
      L.useStyle(D), D.text = f[N], D.x = E, D.y = b, O && (D.textAlign = O), D.textBaseline = "middle", D.opacity = t.opacity, D.strokeFirst = !0, I && (D.shadowBlur = t.textShadowBlur || 0, D.shadowColor = t.textShadowColor || "transparent", D.shadowOffsetX = t.textShadowOffsetX || 0, D.shadowOffsetY = t.textShadowOffsetY || 0), D.stroke = _, D.fill = C, _ && (D.lineWidth = t.lineWidth || y, D.lineDash = t.lineDash, D.lineDashOffset = t.lineDashOffset || 0), D.font = i, XL(D, t), b += d, x && L.setBoundingRect(new Ue(Dd(D.x, t.width, D.textAlign), sc(D.y, P, D.textBaseline), c, P));
    }
  }, e.prototype._updateRichTexts = function() {
    var t = this.style, i = ZL(t), n = qie(i, t), a = n.width, o = n.outerWidth, s = n.outerHeight, l = t.padding, u = t.x || 0, h = t.y || 0, c = this._defaultStyle, f = t.align || c.align, d = t.verticalAlign || c.verticalAlign, p = Dd(u, o, f), g = sc(h, s, d), v = p, O = g;
    l && (v += l[3], O += l[0]);
    var m = v + a;
    by(t) && this._renderBackground(t, t, p, g, o, s);
    for (var E = !!t.backgroundColor, b = 0; b < n.lines.length; b++) {
      for (var T = n.lines[b], S = T.tokens, y = S.length, A = T.lineHeight, C = T.width, _ = 0, I = v, x = m, P = y - 1, N = void 0; _ < y && (N = S[_], !N.align || N.align === "left"); )
        this._placeToken(N, t, A, O, I, "left", E), C -= N.width, I += N.width, _++;
      for (; P >= 0 && (N = S[P], N.align === "right"); )
        this._placeToken(N, t, A, O, x, "right", E), C -= N.width, x -= N.width, P--;
      for (I += (a - (I - v) - (m - x) - C) / 2; _ <= P; )
        N = S[_], this._placeToken(N, t, A, O, I + N.width / 2, "center", E), I += N.width, _++;
      O += A;
    }
  }, e.prototype._placeToken = function(t, i, n, a, o, s, l) {
    var u = i.rich[t.styleName] || {};
    u.text = t.text;
    var h = t.verticalAlign, c = a + n / 2;
    h === "top" ? c = a + t.height / 2 : h === "bottom" && (c = a + n - t.height / 2);
    var f = !t.isLineHolder && by(u);
    f && this._renderBackground(u, i, s === "right" ? o - t.width : s === "center" ? o - t.width / 2 : o, c - t.height / 2, t.width, t.height);
    var d = !!u.backgroundColor, p = t.textPadding;
    p && (o = zL(o, s, p), c -= t.height / 2 - p[0] - t.innerHeight / 2);
    var g = this._getOrCreateChild(Xp), v = g.createStyle();
    g.useStyle(v);
    var O = this._defaultStyle, m = !1, E = 0, b = WL("fill" in u ? u.fill : "fill" in i ? i.fill : (m = !0, O.fill)), T = HL("stroke" in u ? u.stroke : "stroke" in i ? i.stroke : !d && !l && (!O.autoStroke || m) ? (E = VL, O.stroke) : null), S = u.textShadowBlur > 0 || i.textShadowBlur > 0;
    v.text = t.text, v.x = o, v.y = c, S && (v.shadowBlur = u.textShadowBlur || i.textShadowBlur || 0, v.shadowColor = u.textShadowColor || i.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || i.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || i.textShadowOffsetY || 0), v.textAlign = s, v.textBaseline = "middle", v.font = t.font || rl, v.opacity = Ka(u.opacity, i.opacity, 1), XL(v, u), T && (v.lineWidth = Ka(u.lineWidth, i.lineWidth, E), v.lineDash = ke(u.lineDash, i.lineDash), v.lineDashOffset = i.lineDashOffset || 0, v.stroke = T), b && (v.fill = b);
    var y = t.contentWidth, A = t.contentHeight;
    g.setBoundingRect(new Ue(Dd(v.x, y, v.textAlign), sc(v.y, A, v.textBaseline), y, A));
  }, e.prototype._renderBackground = function(t, i, n, a, o, s) {
    var l = t.backgroundColor, u = t.borderWidth, h = t.borderColor, c = l && l.image, f = l && !c, d = t.borderRadius, p = this, g, v;
    if (f || t.lineHeight || u && h) {
      g = this._getOrCreateChild(nt), g.useStyle(g.createStyle()), g.style.fill = null;
      var O = g.shape;
      O.x = n, O.y = a, O.width = o, O.height = s, O.r = d, g.dirtyShape();
    }
    if (f) {
      var m = g.style;
      m.fill = l || null, m.fillOpacity = ke(t.fillOpacity, 1);
    } else if (c) {
      v = this._getOrCreateChild(qr), v.onload = function() {
        p.dirtyStyle();
      };
      var E = v.style;
      E.image = l.image, E.x = n, E.y = a, E.width = o, E.height = s;
    }
    if (u && h) {
      var m = g.style;
      m.lineWidth = u, m.stroke = h, m.strokeOpacity = ke(t.strokeOpacity, 1), m.lineDash = t.borderDash, m.lineDashOffset = t.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (m.strokeFirst = !0, m.lineWidth *= 2);
    }
    var b = (g || v).style;
    b.shadowBlur = t.shadowBlur || 0, b.shadowColor = t.shadowColor || "transparent", b.shadowOffsetX = t.shadowOffsetX || 0, b.shadowOffsetY = t.shadowOffsetY || 0, b.opacity = Ka(t.opacity, i.opacity, 1);
  }, e.makeFont = function(t) {
    var i = "";
    return QX(t) && (i = [
      t.fontStyle,
      t.fontWeight,
      kX(t.fontSize),
      t.fontFamily || "sans-serif"
    ].join(" ")), i && ha(i) || t.textFont || t.font;
  }, e;
}(qn), Cne = { left: !0, right: 1, center: 1 }, _ne = { top: 1, bottom: 1, middle: 1 }, FL = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function kX(r) {
  return typeof r == "string" && (r.indexOf("px") !== -1 || r.indexOf("rem") !== -1 || r.indexOf("em") !== -1) ? r : isNaN(+r) ? OI + "px" : r + "px";
}
function XL(r, e) {
  for (var t = 0; t < FL.length; t++) {
    var i = FL[t], n = e[i];
    n != null && (r[i] = n);
  }
}
function QX(r) {
  return r.fontSize != null || r.fontFamily || r.fontWeight;
}
function Ine(r) {
  return YL(r), w(r.rich, YL), r;
}
function YL(r) {
  if (r) {
    r.font = MX.makeFont(r);
    var e = r.align;
    e === "middle" && (e = "center"), r.align = e == null || Cne[e] ? e : "left";
    var t = r.verticalAlign;
    t === "center" && (t = "middle"), r.verticalAlign = t == null || _ne[t] ? t : "top";
    var i = r.padding;
    i && (r.padding = yI(r.padding));
  }
}
function HL(r, e) {
  return r == null || e <= 0 || r === "transparent" || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function WL(r) {
  return r == null || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function zL(r, e, t) {
  return e === "right" ? r - t[1] : e === "center" ? r + t[3] / 2 - t[1] / 2 : r + t[3];
}
function ZL(r) {
  var e = r.text;
  return e != null && (e += ""), e;
}
function by(r) {
  return !!(r.backgroundColor || r.lineHeight || r.borderWidth && r.borderColor);
}
const lt = MX;
var _e = at(), jA = function(r, e, t, i) {
  if (i) {
    var n = _e(i);
    n.dataIndex = t, n.dataType = e, n.seriesIndex = r, i.type === "group" && i.traverse(function(a) {
      var o = _e(a);
      o.seriesIndex = r, o.dataIndex = t, o.dataType = e;
    });
  }
}, qL = 1, jL = {}, UX = at(), kI = at(), QI = 0, $g = 1, TS = 2, Ii = ["emphasis", "blur", "select"], Yp = ["normal", "emphasis", "blur", "select"], Sf = 10, xne = 9, Gu = "highlight", Om = "downplay", sp = "select", mm = "unselect", lp = "toggleSelect";
function $h(r) {
  return r != null && r !== "none";
}
var KL = new kg(100);
function JL(r) {
  if (ne(r)) {
    var e = KL.get(r);
    return e || (e = QA(r, -0.1), KL.put(r, e)), e;
  } else if (dS(r)) {
    var t = V({}, r);
    return t.colorStops = Y(r.colorStops, function(i) {
      return {
        offset: i.offset,
        color: QA(i.color, -0.1)
      };
    }), t;
  }
  return r;
}
function yS(r, e, t) {
  r.onHoverStateChange && (r.hoverState || 0) !== t && r.onHoverStateChange(e), r.hoverState = t;
}
function $X(r) {
  yS(r, "emphasis", TS);
}
function GX(r) {
  r.hoverState === TS && yS(r, "normal", QI);
}
function UI(r) {
  yS(r, "blur", $g);
}
function BX(r) {
  r.hoverState === $g && yS(r, "normal", QI);
}
function wne(r) {
  r.selected = !0;
}
function Pne(r) {
  r.selected = !1;
}
function eD(r, e, t) {
  e(r, t);
}
function es(r, e, t) {
  eD(r, e, t), r.isGroup && r.traverse(function(i) {
    eD(i, e, t);
  });
}
function bE(r, e) {
  switch (e) {
    case "emphasis":
      r.hoverState = TS;
      break;
    case "normal":
      r.hoverState = QI;
      break;
    case "blur":
      r.hoverState = $g;
      break;
    case "select":
      r.selected = !0;
  }
}
function Nne(r, e, t, i) {
  for (var n = r.style, a = {}, o = 0; o < e.length; o++) {
    var s = e[o], l = n[s];
    a[s] = l ?? (i && i[s]);
  }
  for (var o = 0; o < r.animators.length; o++) {
    var u = r.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(t) < 0 && u.targetName === "style" && u.saveTo(a, e);
  }
  return a;
}
function Lne(r, e, t, i) {
  var n = t && Ge(t, "select") >= 0, a = !1;
  if (r instanceof Fe) {
    var o = UX(r), s = n && o.selectFill || o.normalFill, l = n && o.selectStroke || o.normalStroke;
    if ($h(s) || $h(l)) {
      i = i || {};
      var u = i.style || {};
      u.fill === "inherit" ? (a = !0, i = V({}, i), u = V({}, u), u.fill = s) : !$h(u.fill) && $h(s) ? (a = !0, i = V({}, i), u = V({}, u), u.fill = JL(s)) : !$h(u.stroke) && $h(l) && (a || (i = V({}, i), u = V({}, u)), u.stroke = JL(l)), i.style = u;
    }
  }
  if (i && i.z2 == null) {
    a || (i = V({}, i));
    var h = r.z2EmphasisLift;
    i.z2 = r.z2 + (h ?? Sf);
  }
  return i;
}
function Dne(r, e, t) {
  if (t && t.z2 == null) {
    t = V({}, t);
    var i = r.z2SelectLift;
    t.z2 = r.z2 + (i ?? xne);
  }
  return t;
}
function Mne(r, e, t) {
  var i = Ge(r.currentStates, e) >= 0, n = r.style.opacity, a = i ? null : Nne(r, ["opacity"], e, {
    opacity: 1
  });
  t = t || {};
  var o = t.style || {};
  return o.opacity == null && (t = V({}, t), o = V({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: i ? n : a.opacity * 0.1
  }, o), t.style = o), t;
}
function Sy(r, e) {
  var t = this.states[r];
  if (this.style) {
    if (r === "emphasis")
      return Lne(this, r, e, t);
    if (r === "blur")
      return Mne(this, r, t);
    if (r === "select")
      return Dne(this, r, t);
  }
  return t;
}
function ih(r) {
  r.stateProxy = Sy;
  var e = r.getTextContent(), t = r.getTextGuideLine();
  e && (e.stateProxy = Sy), t && (t.stateProxy = Sy);
}
function tD(r, e) {
  !YX(r, e) && !r.__highByOuter && es(r, $X);
}
function rD(r, e) {
  !YX(r, e) && !r.__highByOuter && es(r, GX);
}
function Xo(r, e) {
  r.__highByOuter |= 1 << (e || 0), es(r, $X);
}
function Yo(r, e) {
  !(r.__highByOuter &= ~(1 << (e || 0))) && es(r, GX);
}
function VX(r) {
  es(r, UI);
}
function $I(r) {
  es(r, BX);
}
function FX(r) {
  es(r, wne);
}
function XX(r) {
  es(r, Pne);
}
function YX(r, e) {
  return r.__highDownSilentOnTouch && e.zrByTouch;
}
function HX(r) {
  var e = r.getModel(), t = [], i = [];
  e.eachComponent(function(n, a) {
    var o = kI(a), s = n === "series", l = s ? r.getViewOfSeriesModel(a) : r.getViewOfComponentModel(a);
    !s && i.push(l), o.isBlured && (l.group.traverse(function(u) {
      BX(u);
    }), s && t.push(a)), o.isBlured = !1;
  }), w(i, function(n) {
    n && n.toggleBlurSeries && n.toggleBlurSeries(t, !1, e);
  });
}
function KA(r, e, t, i) {
  var n = i.getModel();
  t = t || "coordinateSystem";
  function a(u, h) {
    for (var c = 0; c < h.length; c++) {
      var f = u.getItemGraphicEl(h[c]);
      f && $I(f);
    }
  }
  if (r != null && !(!e || e === "none")) {
    var o = n.getSeriesByIndex(r), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    n.eachSeries(function(u) {
      var h = o === u, c = u.coordinateSystem;
      c && c.master && (c = c.master);
      var f = c && s ? c === s : h;
      if (!// Not blur other series if blurScope series
      (t === "series" && !h || t === "coordinateSystem" && !f || e === "series" && h)) {
        var d = i.getViewOfSeriesModel(u);
        if (d.group.traverse(function(v) {
          v.__highByOuter && h && e === "self" || UI(v);
        }), ci(e))
          a(u.getData(), e);
        else if (be(e))
          for (var p = He(e), g = 0; g < p.length; g++)
            a(u.getData(p[g]), e[p[g]]);
        l.push(u), kI(u).isBlured = !0;
      }
    }), n.eachComponent(function(u, h) {
      if (u !== "series") {
        var c = i.getViewOfComponentModel(h);
        c && c.toggleBlurSeries && c.toggleBlurSeries(l, !0, n);
      }
    });
  }
}
function JA(r, e, t) {
  if (!(r == null || e == null)) {
    var i = t.getModel().getComponent(r, e);
    if (i) {
      kI(i).isBlured = !0;
      var n = t.getViewOfComponentModel(i);
      !n || !n.focusBlurEnabled || n.group.traverse(function(a) {
        UI(a);
      });
    }
  }
}
function kne(r, e, t) {
  var i = r.seriesIndex, n = r.getData(e.dataType);
  if (n) {
    var a = th(n, e);
    a = (X(a) ? a[0] : a) || 0;
    var o = n.getItemGraphicEl(a);
    if (!o)
      for (var s = n.count(), l = 0; !o && l < s; )
        o = n.getItemGraphicEl(l++);
    if (o) {
      var u = _e(o);
      KA(i, u.focus, u.blurScope, t);
    } else {
      var h = r.get(["emphasis", "focus"]), c = r.get(["emphasis", "blurScope"]);
      h != null && KA(i, h, c, t);
    }
  }
}
function GI(r, e, t, i) {
  var n = {
    focusSelf: !1,
    dispatchers: null
  };
  if (r == null || r === "series" || e == null || t == null)
    return n;
  var a = i.getModel().getComponent(r, e);
  if (!a)
    return n;
  var o = i.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return n;
  for (var s = o.findHighDownDispatchers(t), l, u = 0; u < s.length; u++)
    if (_e(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function Qne(r, e, t) {
  var i = _e(r), n = GI(i.componentMainType, i.componentIndex, i.componentHighDownName, t), a = n.dispatchers, o = n.focusSelf;
  a ? (o && JA(i.componentMainType, i.componentIndex, t), w(a, function(s) {
    return tD(s, e);
  })) : (KA(i.seriesIndex, i.focus, i.blurScope, t), i.focus === "self" && JA(i.componentMainType, i.componentIndex, t), tD(r, e));
}
function Une(r, e, t) {
  HX(t);
  var i = _e(r), n = GI(i.componentMainType, i.componentIndex, i.componentHighDownName, t).dispatchers;
  n ? w(n, function(a) {
    return rD(a, e);
  }) : rD(r, e);
}
function $ne(r, e, t) {
  if (tC(e)) {
    var i = e.dataType, n = r.getData(i), a = th(n, e);
    X(a) || (a = [a]), r[e.type === lp ? "toggleSelect" : e.type === sp ? "select" : "unselect"](a, i);
  }
}
function iD(r) {
  var e = r.getAllData();
  w(e, function(t) {
    var i = t.data, n = t.type;
    i.eachItemGraphicEl(function(a, o) {
      r.isSelected(o, n) ? FX(a) : XX(a);
    });
  });
}
function Gne(r) {
  var e = [];
  return r.eachSeries(function(t) {
    var i = t.getAllData();
    w(i, function(n) {
      n.data;
      var a = n.type, o = t.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: t.seriesIndex
        };
        a != null && (s.dataType = a), e.push(s);
      }
    });
  }), e;
}
function Bu(r, e, t) {
  Tu(r, !0), es(r, ih), eC(r, e, t);
}
function Bne(r) {
  Tu(r, !1);
}
function zt(r, e, t, i) {
  i ? Bne(r) : Bu(r, e, t);
}
function eC(r, e, t) {
  var i = _e(r);
  e != null ? (i.focus = e, i.blurScope = t) : i.focus && (i.focus = null);
}
var nD = ["emphasis", "blur", "select"], Vne = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function zr(r, e, t, i) {
  t = t || "itemStyle";
  for (var n = 0; n < nD.length; n++) {
    var a = nD[n], o = e.getModel([a, t]), s = r.ensureState(a);
    s.style = i ? i(o) : o[Vne[t]]();
  }
}
function Tu(r, e) {
  var t = e === !1, i = r;
  r.highDownSilentOnTouch && (i.__highDownSilentOnTouch = r.highDownSilentOnTouch), (!t || i.__highDownDispatcher) && (i.__highByOuter = i.__highByOuter || 0, i.__highDownDispatcher = !t);
}
function Hp(r) {
  return !!(r && r.__highDownDispatcher);
}
function Fne(r, e, t) {
  var i = _e(r);
  i.componentMainType = e.mainType, i.componentIndex = e.componentIndex, i.componentHighDownName = t;
}
function Xne(r) {
  var e = jL[r];
  return e == null && qL <= 32 && (e = jL[r] = qL++), e;
}
function tC(r) {
  var e = r.type;
  return e === sp || e === mm || e === lp;
}
function aD(r) {
  var e = r.type;
  return e === Gu || e === Om;
}
function Yne(r) {
  var e = UX(r);
  e.normalFill = r.style.fill, e.normalStroke = r.style.stroke;
  var t = r.states.select || {};
  e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null;
}
var Gh = lo.CMD, Hne = [[], [], []], oD = Math.sqrt, Wne = Math.atan2;
function WX(r, e) {
  if (e) {
    var t = r.data, i = r.len(), n, a, o, s, l, u, h = Gh.M, c = Gh.C, f = Gh.L, d = Gh.R, p = Gh.A, g = Gh.Q;
    for (o = 0, s = 0; o < i; ) {
      switch (n = t[o++], s = o, a = 0, n) {
        case h:
          a = 1;
          break;
        case f:
          a = 1;
          break;
        case c:
          a = 3;
          break;
        case g:
          a = 2;
          break;
        case p:
          var v = e[4], O = e[5], m = oD(e[0] * e[0] + e[1] * e[1]), E = oD(e[2] * e[2] + e[3] * e[3]), b = Wne(-e[1] / E, e[0] / m);
          t[o] *= m, t[o++] += v, t[o] *= E, t[o++] += O, t[o++] *= m, t[o++] *= E, t[o++] += b, t[o++] += b, o += 2, s = o;
          break;
        case d:
          u[0] = t[o++], u[1] = t[o++], Hr(u, u, e), t[s++] = u[0], t[s++] = u[1], u[0] += t[o++], u[1] += t[o++], Hr(u, u, e), t[s++] = u[0], t[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var T = Hne[l];
        T[0] = t[o++], T[1] = t[o++], Hr(T, T, e), t[s++] = T[0], t[s++] = T[1];
      }
    }
    r.increaseVersion();
  }
}
var Ty = Math.sqrt, Xv = Math.sin, Yv = Math.cos, Kf = Math.PI;
function sD(r) {
  return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
}
function rC(r, e) {
  return (r[0] * e[0] + r[1] * e[1]) / (sD(r) * sD(e));
}
function lD(r, e) {
  return (r[0] * e[1] < r[1] * e[0] ? -1 : 1) * Math.acos(rC(r, e));
}
function uD(r, e, t, i, n, a, o, s, l, u, h) {
  var c = l * (Kf / 180), f = Yv(c) * (r - t) / 2 + Xv(c) * (e - i) / 2, d = -1 * Xv(c) * (r - t) / 2 + Yv(c) * (e - i) / 2, p = f * f / (o * o) + d * d / (s * s);
  p > 1 && (o *= Ty(p), s *= Ty(p));
  var g = (n === a ? -1 : 1) * Ty((o * o * (s * s) - o * o * (d * d) - s * s * (f * f)) / (o * o * (d * d) + s * s * (f * f))) || 0, v = g * o * d / s, O = g * -s * f / o, m = (r + t) / 2 + Yv(c) * v - Xv(c) * O, E = (e + i) / 2 + Xv(c) * v + Yv(c) * O, b = lD([1, 0], [(f - v) / o, (d - O) / s]), T = [(f - v) / o, (d - O) / s], S = [(-1 * f - v) / o, (-1 * d - O) / s], y = lD(T, S);
  if (rC(T, S) <= -1 && (y = Kf), rC(T, S) >= 1 && (y = 0), y < 0) {
    var A = Math.round(y / Kf * 1e6) / 1e6;
    y = Kf * 2 + A % 2 * Kf;
  }
  h.addData(u, m, E, o, s, b, y, c, a);
}
var zne = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, Zne = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function qne(r) {
  var e = new lo();
  if (!r)
    return e;
  var t = 0, i = 0, n = t, a = i, o, s = lo.CMD, l = r.match(zne);
  if (!l)
    return e;
  for (var u = 0; u < l.length; u++) {
    for (var h = l[u], c = h.charAt(0), f = void 0, d = h.match(Zne) || [], p = d.length, g = 0; g < p; g++)
      d[g] = parseFloat(d[g]);
    for (var v = 0; v < p; ) {
      var O = void 0, m = void 0, E = void 0, b = void 0, T = void 0, S = void 0, y = void 0, A = t, C = i, _ = void 0, I = void 0;
      switch (c) {
        case "l":
          t += d[v++], i += d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "L":
          t = d[v++], i = d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "m":
          t += d[v++], i += d[v++], f = s.M, e.addData(f, t, i), n = t, a = i, c = "l";
          break;
        case "M":
          t = d[v++], i = d[v++], f = s.M, e.addData(f, t, i), n = t, a = i, c = "L";
          break;
        case "h":
          t += d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "H":
          t = d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "v":
          i += d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "V":
          i = d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "C":
          f = s.C, e.addData(f, d[v++], d[v++], d[v++], d[v++], d[v++], d[v++]), t = d[v - 2], i = d[v - 1];
          break;
        case "c":
          f = s.C, e.addData(f, d[v++] + t, d[v++] + i, d[v++] + t, d[v++] + i, d[v++] + t, d[v++] + i), t += d[v - 2], i += d[v - 1];
          break;
        case "S":
          O = t, m = i, _ = e.len(), I = e.data, o === s.C && (O += t - I[_ - 4], m += i - I[_ - 3]), f = s.C, A = d[v++], C = d[v++], t = d[v++], i = d[v++], e.addData(f, O, m, A, C, t, i);
          break;
        case "s":
          O = t, m = i, _ = e.len(), I = e.data, o === s.C && (O += t - I[_ - 4], m += i - I[_ - 3]), f = s.C, A = t + d[v++], C = i + d[v++], t += d[v++], i += d[v++], e.addData(f, O, m, A, C, t, i);
          break;
        case "Q":
          A = d[v++], C = d[v++], t = d[v++], i = d[v++], f = s.Q, e.addData(f, A, C, t, i);
          break;
        case "q":
          A = d[v++] + t, C = d[v++] + i, t += d[v++], i += d[v++], f = s.Q, e.addData(f, A, C, t, i);
          break;
        case "T":
          O = t, m = i, _ = e.len(), I = e.data, o === s.Q && (O += t - I[_ - 4], m += i - I[_ - 3]), t = d[v++], i = d[v++], f = s.Q, e.addData(f, O, m, t, i);
          break;
        case "t":
          O = t, m = i, _ = e.len(), I = e.data, o === s.Q && (O += t - I[_ - 4], m += i - I[_ - 3]), t += d[v++], i += d[v++], f = s.Q, e.addData(f, O, m, t, i);
          break;
        case "A":
          E = d[v++], b = d[v++], T = d[v++], S = d[v++], y = d[v++], A = t, C = i, t = d[v++], i = d[v++], f = s.A, uD(A, C, t, i, S, y, E, b, T, f, e);
          break;
        case "a":
          E = d[v++], b = d[v++], T = d[v++], S = d[v++], y = d[v++], A = t, C = i, t += d[v++], i += d[v++], f = s.A, uD(A, C, t, i, S, y, E, b, T, f, e);
          break;
      }
    }
    (c === "z" || c === "Z") && (f = s.Z, e.addData(f), t = n, i = a), o = f;
  }
  return e.toStatic(), e;
}
var zX = function(r) {
  U(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.applyTransform = function(t) {
  }, e;
}(Fe);
function ZX(r) {
  return r.setData != null;
}
function qX(r, e) {
  var t = qne(r), i = V({}, e);
  return i.buildPath = function(n) {
    if (ZX(n)) {
      n.setData(t.data);
      var a = n.getContext();
      a && n.rebuildPath(a, 1);
    } else {
      var a = n;
      t.rebuildPath(a, 1);
    }
  }, i.applyTransform = function(n) {
    WX(t, n), this.dirtyShape();
  }, i;
}
function jX(r, e) {
  return new zX(qX(r, e));
}
function jne(r, e) {
  var t = qX(r, e), i = function(n) {
    U(a, n);
    function a(o) {
      var s = n.call(this, o) || this;
      return s.applyTransform = t.applyTransform, s.buildPath = t.buildPath, s;
    }
    return a;
  }(zX);
  return i;
}
function Kne(r, e) {
  for (var t = [], i = r.length, n = 0; n < i; n++) {
    var a = r[n];
    t.push(a.getUpdatedPathProxy(!0));
  }
  var o = new Fe(e);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (ZX(s)) {
      s.appendPath(t);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
function BI(r, e) {
  e = e || {};
  var t = new Fe();
  return r.shape && t.setShape(r.shape), t.setStyle(r.style), e.bakeTransform ? WX(t.path, r.getComputedTransform()) : e.toLocal ? t.setLocalTransform(r.getComputedTransform()) : t.copyTransform(r), t.buildPath = r.buildPath, t.applyTransform = t.applyTransform, t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel, t;
}
var Jne = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return r;
}(), KX = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new Jne();
  }, e.prototype.buildPath = function(t, i) {
    t.moveTo(i.cx + i.r, i.cy), t.arc(i.cx, i.cy, i.r, 0, Math.PI * 2);
  }, e;
}(Fe);
KX.prototype.type = "circle";
const uo = KX;
var eae = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return r;
}(), JX = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new eae();
  }, e.prototype.buildPath = function(t, i) {
    var n = 0.5522848, a = i.cx, o = i.cy, s = i.rx, l = i.ry, u = s * n, h = l * n;
    t.moveTo(a - s, o), t.bezierCurveTo(a - s, o - h, a - u, o - l, a, o - l), t.bezierCurveTo(a + u, o - l, a + s, o - h, a + s, o), t.bezierCurveTo(a + s, o + h, a + u, o + l, a, o + l), t.bezierCurveTo(a - u, o + l, a - s, o + h, a - s, o), t.closePath();
  }, e;
}(Fe);
JX.prototype.type = "ellipse";
const VI = JX;
var eY = Math.PI, yy = eY * 2, Fl = Math.sin, Bh = Math.cos, tae = Math.acos, ti = Math.atan2, hD = Math.abs, up = Math.sqrt, Md = Math.max, _a = Math.min, na = 1e-4;
function rae(r, e, t, i, n, a, o, s) {
  var l = t - r, u = i - e, h = o - n, c = s - a, f = c * l - h * u;
  if (!(f * f < na))
    return f = (h * (e - a) - c * (r - n)) / f, [r + f * l, e + f * u];
}
function Hv(r, e, t, i, n, a, o) {
  var s = r - t, l = e - i, u = (o ? a : -a) / up(s * s + l * l), h = u * l, c = -u * s, f = r + h, d = e + c, p = t + h, g = i + c, v = (f + p) / 2, O = (d + g) / 2, m = p - f, E = g - d, b = m * m + E * E, T = n - a, S = f * g - p * d, y = (E < 0 ? -1 : 1) * up(Md(0, T * T * b - S * S)), A = (S * E - m * y) / b, C = (-S * m - E * y) / b, _ = (S * E + m * y) / b, I = (-S * m + E * y) / b, x = A - v, P = C - O, N = _ - v, L = I - O;
  return x * x + P * P > N * N + L * L && (A = _, C = I), {
    cx: A,
    cy: C,
    x0: -h,
    y0: -c,
    x1: A * (n / T - 1),
    y1: C * (n / T - 1)
  };
}
function iae(r) {
  var e;
  if (X(r)) {
    var t = r.length;
    if (!t)
      return r;
    t === 1 ? e = [r[0], r[0], 0, 0] : t === 2 ? e = [r[0], r[0], r[1], r[1]] : t === 3 ? e = r.concat(r[2]) : e = r;
  } else
    e = [r, r, r, r];
  return e;
}
function nae(r, e) {
  var t, i = Md(e.r, 0), n = Md(e.r0 || 0, 0), a = i > 0, o = n > 0;
  if (!(!a && !o)) {
    if (a || (i = n, n = 0), n > i) {
      var s = i;
      i = n, n = s;
    }
    var l = e.startAngle, u = e.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var h = e.cx, c = e.cy, f = !!e.clockwise, d = hD(u - l), p = d > yy && d % yy;
      if (p > na && (d = p), !(i > na))
        r.moveTo(h, c);
      else if (d > yy - na)
        r.moveTo(h + i * Bh(l), c + i * Fl(l)), r.arc(h, c, i, l, u, !f), n > na && (r.moveTo(h + n * Bh(u), c + n * Fl(u)), r.arc(h, c, n, u, l, f));
      else {
        var g = void 0, v = void 0, O = void 0, m = void 0, E = void 0, b = void 0, T = void 0, S = void 0, y = void 0, A = void 0, C = void 0, _ = void 0, I = void 0, x = void 0, P = void 0, N = void 0, L = i * Bh(l), D = i * Fl(l), $ = n * Bh(u), k = n * Fl(u), G = d > na;
        if (G) {
          var F = e.cornerRadius;
          F && (t = iae(F), g = t[0], v = t[1], O = t[2], m = t[3]);
          var q = hD(i - n) / 2;
          if (E = _a(q, O), b = _a(q, m), T = _a(q, g), S = _a(q, v), C = y = Md(E, b), _ = A = Md(T, S), (y > na || A > na) && (I = i * Bh(u), x = i * Fl(u), P = n * Bh(l), N = n * Fl(l), d < eY)) {
            var re = rae(L, D, P, N, I, x, $, k);
            if (re) {
              var fe = L - re[0], de = D - re[1], $e = I - re[0], Pe = x - re[1], Ne = 1 / Fl(tae((fe * $e + de * Pe) / (up(fe * fe + de * de) * up($e * $e + Pe * Pe))) / 2), Ee = up(re[0] * re[0] + re[1] * re[1]);
              C = _a(y, (i - Ee) / (Ne + 1)), _ = _a(A, (n - Ee) / (Ne - 1));
            }
          }
        }
        if (!G)
          r.moveTo(h + L, c + D);
        else if (C > na) {
          var xe = _a(O, C), Ce = _a(m, C), ue = Hv(P, N, L, D, i, xe, f), M = Hv(I, x, $, k, i, Ce, f);
          r.moveTo(h + ue.cx + ue.x0, c + ue.cy + ue.y0), C < y && xe === Ce ? r.arc(h + ue.cx, c + ue.cy, C, ti(ue.y0, ue.x0), ti(M.y0, M.x0), !f) : (xe > 0 && r.arc(h + ue.cx, c + ue.cy, xe, ti(ue.y0, ue.x0), ti(ue.y1, ue.x1), !f), r.arc(h, c, i, ti(ue.cy + ue.y1, ue.cx + ue.x1), ti(M.cy + M.y1, M.cx + M.x1), !f), Ce > 0 && r.arc(h + M.cx, c + M.cy, Ce, ti(M.y1, M.x1), ti(M.y0, M.x0), !f));
        } else
          r.moveTo(h + L, c + D), r.arc(h, c, i, l, u, !f);
        if (!(n > na) || !G)
          r.lineTo(h + $, c + k);
        else if (_ > na) {
          var xe = _a(g, _), Ce = _a(v, _), ue = Hv($, k, I, x, n, -Ce, f), M = Hv(L, D, P, N, n, -xe, f);
          r.lineTo(h + ue.cx + ue.x0, c + ue.cy + ue.y0), _ < A && xe === Ce ? r.arc(h + ue.cx, c + ue.cy, _, ti(ue.y0, ue.x0), ti(M.y0, M.x0), !f) : (Ce > 0 && r.arc(h + ue.cx, c + ue.cy, Ce, ti(ue.y0, ue.x0), ti(ue.y1, ue.x1), !f), r.arc(h, c, n, ti(ue.cy + ue.y1, ue.cx + ue.x1), ti(M.cy + M.y1, M.cx + M.x1), f), xe > 0 && r.arc(h + M.cx, c + M.cy, xe, ti(M.y1, M.x1), ti(M.y0, M.x0), !f));
        } else
          r.lineTo(h + $, c + k), r.arc(h, c, n, u, l, f);
      }
      r.closePath();
    }
  }
}
var aae = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return r;
}(), tY = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new aae();
  }, e.prototype.buildPath = function(t, i) {
    nae(t, i);
  }, e.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, e;
}(Fe);
tY.prototype.type = "sector";
const Xi = tY;
var oae = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return r;
}(), rY = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new oae();
  }, e.prototype.buildPath = function(t, i) {
    var n = i.cx, a = i.cy, o = Math.PI * 2;
    t.moveTo(n + i.r, a), t.arc(n, a, i.r, 0, o, !1), t.moveTo(n + i.r0, a), t.arc(n, a, i.r0, 0, o, !0);
  }, e;
}(Fe);
rY.prototype.type = "ring";
const RS = rY;
function sae(r, e, t, i) {
  var n = [], a = [], o = [], s = [], l, u, h, c;
  if (i) {
    h = [1 / 0, 1 / 0], c = [-1 / 0, -1 / 0];
    for (var f = 0, d = r.length; f < d; f++)
      ws(h, h, r[f]), Ps(c, c, r[f]);
    ws(h, h, i[0]), Ps(c, c, i[1]);
  }
  for (var f = 0, d = r.length; f < d; f++) {
    var p = r[f];
    if (t)
      l = r[f ? f - 1 : d - 1], u = r[(f + 1) % d];
    else if (f === 0 || f === d - 1) {
      n.push(Do(r[f]));
      continue;
    } else
      l = r[f - 1], u = r[f + 1];
    bu(a, u, l), um(a, a, e);
    var g = IA(p, l), v = IA(p, u), O = g + v;
    O !== 0 && (g /= O, v /= O), um(o, a, -g), um(s, a, v);
    var m = rL([], p, o), E = rL([], p, s);
    i && (Ps(m, m, h), ws(m, m, c), Ps(E, E, h), ws(E, E, c)), n.push(m), n.push(E);
  }
  return t && n.push(n.shift()), n;
}
function iY(r, e, t) {
  var i = e.smooth, n = e.points;
  if (n && n.length >= 2) {
    if (i) {
      var a = sae(n, i, t, e.smoothConstraint);
      r.moveTo(n[0][0], n[0][1]);
      for (var o = n.length, s = 0; s < (t ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], h = n[(s + 1) % o];
        r.bezierCurveTo(l[0], l[1], u[0], u[1], h[0], h[1]);
      }
    } else {
      r.moveTo(n[0][0], n[0][1]);
      for (var s = 1, c = n.length; s < c; s++)
        r.lineTo(n[s][0], n[s][1]);
    }
    t && r.closePath();
  }
}
var lae = function() {
  function r() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), nY = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new lae();
  }, e.prototype.buildPath = function(t, i) {
    iY(t, i, !0);
  }, e;
}(Fe);
nY.prototype.type = "polygon";
const Yi = nY;
var uae = function() {
  function r() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), aY = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new uae();
  }, e.prototype.buildPath = function(t, i) {
    iY(t, i, !1);
  }, e;
}(Fe);
aY.prototype.type = "polyline";
const Wi = aY;
var hae = {}, cae = function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return r;
}(), oY = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new cae();
  }, e.prototype.buildPath = function(t, i) {
    var n, a, o, s;
    if (this.subPixelOptimize) {
      var l = NX(hae, i, this.style);
      n = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      n = i.x1, a = i.y1, o = i.x2, s = i.y2;
    var u = i.percent;
    u !== 0 && (t.moveTo(n, a), u < 1 && (o = n * (1 - u) + o * u, s = a * (1 - u) + s * u), t.lineTo(o, s));
  }, e.prototype.pointAt = function(t) {
    var i = this.shape;
    return [
      i.x1 * (1 - t) + i.x2 * t,
      i.y1 * (1 - t) + i.y2 * t
    ];
  }, e;
}(Fe);
oY.prototype.type = "line";
const Mr = oY;
var Pi = [], fae = function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return r;
}();
function cD(r, e, t) {
  var i = r.cpx2, n = r.cpy2;
  return i != null || n != null ? [
    (t ? pL : Er)(r.x1, r.cpx1, r.cpx2, r.x2, e),
    (t ? pL : Er)(r.y1, r.cpy1, r.cpy2, r.y2, e)
  ] : [
    (t ? DA : Pr)(r.x1, r.cpx1, r.x2, e),
    (t ? DA : Pr)(r.y1, r.cpy1, r.y2, e)
  ];
}
var sY = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new fae();
  }, e.prototype.buildPath = function(t, i) {
    var n = i.x1, a = i.y1, o = i.x2, s = i.y2, l = i.cpx1, u = i.cpy1, h = i.cpx2, c = i.cpy2, f = i.percent;
    f !== 0 && (t.moveTo(n, a), h == null || c == null ? (f < 1 && (Gp(n, l, o, f, Pi), l = Pi[1], o = Pi[2], Gp(a, u, s, f, Pi), u = Pi[1], s = Pi[2]), t.quadraticCurveTo(l, u, o, s)) : (f < 1 && (nl(n, l, h, o, f, Pi), l = Pi[1], h = Pi[2], o = Pi[3], nl(a, u, c, s, f, Pi), u = Pi[1], c = Pi[2], s = Pi[3]), t.bezierCurveTo(l, u, h, c, o, s)));
  }, e.prototype.pointAt = function(t) {
    return cD(this.shape, t, !1);
  }, e.prototype.tangentAt = function(t) {
    var i = cD(this.shape, t, !0);
    return mf(i, i);
  }, e;
}(Fe);
sY.prototype.type = "bezier-curve";
const AS = sY;
var dae = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return r;
}(), lY = function(r) {
  U(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new dae();
  }, e.prototype.buildPath = function(t, i) {
    var n = i.cx, a = i.cy, o = Math.max(i.r, 0), s = i.startAngle, l = i.endAngle, u = i.clockwise, h = Math.cos(s), c = Math.sin(s);
    t.moveTo(h * o + n, c * o + a), t.arc(n, a, o, s, l, !u);
  }, e;
}(Fe);
lY.prototype.type = "arc";
const FI = lY;
var pae = function(r) {
  U(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.type = "compound", t;
  }
  return e.prototype._updatePathDirty = function() {
    for (var t = this.shape.paths, i = this.shapeChanged(), n = 0; n < t.length; n++)
      i = i || t[n].shapeChanged();
    i && this.dirtyShape();
  }, e.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var t = this.shape.paths || [], i = this.getGlobalScale(), n = 0; n < t.length; n++)
      t[n].path || t[n].createPathProxy(), t[n].path.setScale(i[0], i[1], t[n].segmentIgnoreThreshold);
  }, e.prototype.buildPath = function(t, i) {
    for (var n = i.paths || [], a = 0; a < n.length; a++)
      n[a].buildPath(t, n[a].shape, !0);
  }, e.prototype.afterBrush = function() {
    for (var t = this.shape.paths || [], i = 0; i < t.length; i++)
      t[i].pathUpdated();
  }, e.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Fe.prototype.getBoundingRect.call(this);
  }, e;
}(Fe);
const XI = pae;
var gae = function() {
  function r(e) {
    this.colorStops = e || [];
  }
  return r.prototype.addColorStop = function(e, t) {
    this.colorStops.push({
      offset: e,
      color: t
    });
  }, r;
}();
const uY = gae;
var vae = function(r) {
  U(e, r);
  function e(t, i, n, a, o, s) {
    var l = r.call(this, o) || this;
    return l.x = t ?? 0, l.y = i ?? 0, l.x2 = n ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return e;
}(uY);
const Gg = vae;
var Oae = function(r) {
  U(e, r);
  function e(t, i, n, a, o) {
    var s = r.call(this, a) || this;
    return s.x = t ?? 0.5, s.y = i ?? 0.5, s.r = n ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return e;
}(uY);
const hY = Oae;
var Xl = [0, 0], Yl = [0, 0], Wv = new Le(), zv = new Le(), mae = function() {
  function r(e, t) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var i = 0; i < 4; i++)
      this._corners[i] = new Le();
    for (var i = 0; i < 2; i++)
      this._axes[i] = new Le();
    e && this.fromBoundingRect(e, t);
  }
  return r.prototype.fromBoundingRect = function(e, t) {
    var i = this._corners, n = this._axes, a = e.x, o = e.y, s = a + e.width, l = o + e.height;
    if (i[0].set(a, o), i[1].set(s, o), i[2].set(s, l), i[3].set(a, l), t)
      for (var u = 0; u < 4; u++)
        i[u].transform(t);
    Le.sub(n[0], i[1], i[0]), Le.sub(n[1], i[3], i[0]), n[0].normalize(), n[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = n[u].dot(i[0]);
  }, r.prototype.intersect = function(e, t) {
    var i = !0, n = !t;
    return Wv.set(1 / 0, 1 / 0), zv.set(0, 0), !this._intersectCheckOneSide(this, e, Wv, zv, n, 1) && (i = !1, n) || !this._intersectCheckOneSide(e, this, Wv, zv, n, -1) && (i = !1, n) || n || Le.copy(t, i ? Wv : zv), i;
  }, r.prototype._intersectCheckOneSide = function(e, t, i, n, a, o) {
    for (var s = !0, l = 0; l < 2; l++) {
      var u = this._axes[l];
      if (this._getProjMinMaxOnAxis(l, e._corners, Xl), this._getProjMinMaxOnAxis(l, t._corners, Yl), Xl[1] < Yl[0] || Xl[0] > Yl[1]) {
        if (s = !1, a)
          return s;
        var h = Math.abs(Yl[0] - Xl[1]), c = Math.abs(Xl[0] - Yl[1]);
        Math.min(h, c) > n.len() && (h < c ? Le.scale(n, u, -h * o) : Le.scale(n, u, c * o));
      } else if (i) {
        var h = Math.abs(Yl[0] - Xl[1]), c = Math.abs(Xl[0] - Yl[1]);
        Math.min(h, c) < i.len() && (h < c ? Le.scale(i, u, h * o) : Le.scale(i, u, -c * o));
      }
    }
    return s;
  }, r.prototype._getProjMinMaxOnAxis = function(e, t, i) {
    for (var n = this._axes[e], a = this._origin, o = t[0].dot(n) + a[e], s = o, l = o, u = 1; u < t.length; u++) {
      var h = t[u].dot(n) + a[e];
      s = Math.min(h, s), l = Math.max(h, l);
    }
    i[0] = s, i[1] = l;
  }, r;
}();
const SE = mae;
var Eae = [], bae = function(r) {
  U(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.notClear = !0, t.incremental = !0, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t;
  }
  return e.prototype.traverse = function(t, i) {
    t.call(i, this);
  }, e.prototype.useStyle = function() {
    this.style = {};
  }, e.prototype.getCursor = function() {
    return this._cursor;
  }, e.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, e.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, e.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, e.prototype.addDisplayable = function(t, i) {
    i ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
  }, e.prototype.addDisplayables = function(t, i) {
    i = i || !1;
    for (var n = 0; n < t.length; n++)
      this.addDisplayable(t[n], i);
  }, e.prototype.getDisplayables = function() {
    return this._displayables;
  }, e.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, e.prototype.eachPendingDisplayable = function(t) {
    for (var i = this._cursor; i < this._displayables.length; i++)
      t && t(this._displayables[i]);
    for (var i = 0; i < this._temporaryDisplayables.length; i++)
      t && t(this._temporaryDisplayables[i]);
  }, e.prototype.update = function() {
    this.updateTransform();
    for (var t = this._cursor; t < this._displayables.length; t++) {
      var i = this._displayables[t];
      i.parent = this, i.update(), i.parent = null;
    }
    for (var t = 0; t < this._temporaryDisplayables.length; t++) {
      var i = this._temporaryDisplayables[t];
      i.parent = this, i.update(), i.parent = null;
    }
  }, e.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var t = new Ue(1 / 0, 1 / 0, -1 / 0, -1 / 0), i = 0; i < this._displayables.length; i++) {
        var n = this._displayables[i], a = n.getBoundingRect().clone();
        n.needLocalTransform() && a.applyTransform(n.getLocalTransform(Eae)), t.union(a);
      }
      this._rect = t;
    }
    return this._rect;
  }, e.prototype.contain = function(t, i) {
    var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
    if (a.contain(n[0], n[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(t, i))
          return !0;
      }
    return !1;
  }, e;
}(qn);
const Sae = bae;
var cY = at();
function Tf(r, e, t, i, n) {
  var a;
  if (e && e.ecModel) {
    var o = e.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = e && e.isAnimationEnabled(), l = r === "update";
  if (s) {
    var u = void 0, h = void 0, c = void 0;
    i ? (u = ke(i.duration, 200), h = ke(i.easing, "cubicOut"), c = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), h = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), c = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (h = a.easing), a.delay != null && (c = a.delay)), ve(c) && (c = c(t, n)), ve(u) && (u = u(t));
    var f = {
      duration: u || 0,
      delay: c,
      easing: h
    };
    return f;
  } else
    return null;
}
function YI(r, e, t, i, n, a, o) {
  var s = !1, l;
  ve(n) ? (o = a, a = n, n = null) : be(n) && (a = n.cb, o = n.during, s = n.isFrom, l = n.removeOpt, n = n.dataIndex);
  var u = r === "leave";
  u || e.stopAnimation("leave");
  var h = Tf(r, i, n, u ? l || {} : null, i && i.getAnimationDelayParams ? i.getAnimationDelayParams(e, n) : null);
  if (h && h.duration > 0) {
    var c = h.duration, f = h.delay, d = h.easing, p = {
      duration: c,
      delay: f || 0,
      easing: d,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: r,
      during: o
    };
    s ? e.animateFrom(t, p) : e.animateTo(t, p);
  } else
    e.stopAnimation(), !s && e.attr(t), o && o(1), a && a();
}
function ft(r, e, t, i, n, a) {
  YI("update", r, e, t, i, n, a);
}
function Ut(r, e, t, i, n, a) {
  YI("enter", r, e, t, i, n, a);
}
function Pc(r) {
  if (!r.__zr)
    return !0;
  for (var e = 0; e < r.animators.length; e++) {
    var t = r.animators[e];
    if (t.scope === "leave")
      return !0;
  }
  return !1;
}
function al(r, e, t, i, n, a) {
  Pc(r) || YI("leave", r, e, t, i, n, a);
}
function fD(r, e, t, i) {
  r.removeTextContent(), r.removeTextGuideLine(), al(r, {
    style: {
      opacity: 0
    }
  }, e, t, i);
}
function Wp(r, e, t) {
  function i() {
    r.parent && r.parent.remove(r);
  }
  r.isGroup ? r.traverse(function(n) {
    n.isGroup || fD(n, e, t, i);
  }) : fD(r, e, t, i);
}
function ba(r) {
  cY(r).oldStyle = r.style;
}
function Tae(r) {
  return cY(r).oldStyle;
}
var TE = Math.max, yE = Math.min, iC = {};
function yae(r) {
  return Fe.extend(r);
}
var Rae = jne;
function Aae(r, e) {
  return Rae(r, e);
}
function Sa(r, e) {
  iC[r] = e;
}
function HI(r) {
  if (iC.hasOwnProperty(r))
    return iC[r];
}
function CS(r, e, t, i) {
  var n = jX(r, e);
  return t && (i === "center" && (t = dY(t, n.getBoundingRect())), pY(n, t)), n;
}
function fY(r, e, t) {
  var i = new qr({
    style: {
      image: r,
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    onload: function(n) {
      if (t === "center") {
        var a = {
          width: n.width,
          height: n.height
        };
        i.setStyle(dY(e, a));
      }
    }
  });
  return i;
}
function dY(r, e) {
  var t = e.width / e.height, i = r.height * t, n;
  i <= r.width ? n = r.height : (i = r.width, n = i / t);
  var a = r.x + r.width / 2, o = r.y + r.height / 2;
  return {
    x: a - i / 2,
    y: o - n / 2,
    width: i,
    height: n
  };
}
var Dn = Kne;
function pY(r, e) {
  if (r.applyTransform) {
    var t = r.getBoundingRect(), i = t.calculateTransform(e);
    r.applyTransform(i);
  }
}
function jc(r, e) {
  return NX(r, r, {
    lineWidth: e
  }), r;
}
function Cae(r) {
  return LX(r.shape, r.shape, r.style), r;
}
var Em = Su;
function Vu(r, e) {
  for (var t = gS([]); r && r !== e; )
    Mo(t, r.getLocalTransform(), t), r = r.parent;
  return t;
}
function Oa(r, e, t) {
  return e && !ci(e) && (e = wo.getLocalTransform(e)), t && (e = Ef([], e)), Hr([], r, e);
}
function _S(r, e, t) {
  var i = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), n = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [r === "left" ? -i : r === "right" ? i : 0, r === "top" ? -n : r === "bottom" ? n : 0];
  return a = Oa(a, e, t), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function dD(r) {
  return !r.isGroup;
}
function _ae(r) {
  return r.shape != null;
}
function Bg(r, e, t) {
  if (!r || !e)
    return;
  function i(o) {
    var s = {};
    return o.traverse(function(l) {
      dD(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function n(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return _ae(o) && (s.shape = V({}, o.shape)), s;
  }
  var a = i(r);
  e.traverse(function(o) {
    if (dD(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = n(o);
        o.attr(n(s)), ft(o, l, t, _e(o).dataIndex);
      }
    }
  });
}
function gY(r, e) {
  return Y(r, function(t) {
    var i = t[0];
    i = TE(i, e.x), i = yE(i, e.x + e.width);
    var n = t[1];
    return n = TE(n, e.y), n = yE(n, e.y + e.height), [i, n];
  });
}
function Iae(r, e) {
  var t = TE(r.x, e.x), i = yE(r.x + r.width, e.x + e.width), n = TE(r.y, e.y), a = yE(r.y + r.height, e.y + e.height);
  if (i >= t && a >= n)
    return {
      x: t,
      y: n,
      width: i - t,
      height: a - n
    };
}
function Vg(r, e, t) {
  var i = V({
    rectHover: !0
  }, e), n = i.style = {
    strokeNoScale: !0
  };
  if (t = t || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, r)
    return r.indexOf("image://") === 0 ? (n.image = r.slice(8), me(n, t), new qr(i)) : CS(r.replace("path://", ""), i, t, "center");
}
function kd(r, e, t, i, n) {
  for (var a = 0, o = n[n.length - 1]; a < n.length; a++) {
    var s = n[a];
    if (vY(r, e, t, i, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function vY(r, e, t, i, n, a, o, s) {
  var l = t - r, u = i - e, h = o - n, c = s - a, f = Ry(h, c, l, u);
  if (xae(f))
    return !1;
  var d = r - n, p = e - a, g = Ry(d, p, l, u) / f;
  if (g < 0 || g > 1)
    return !1;
  var v = Ry(d, p, h, c) / f;
  return !(v < 0 || v > 1);
}
function Ry(r, e, t, i) {
  return r * i - t * e;
}
function xae(r) {
  return r <= 1e-6 && r >= -1e-6;
}
function yf(r) {
  var e = r.itemTooltipOption, t = r.componentModel, i = r.itemName, n = ne(e) ? {
    formatter: e
  } : e, a = t.mainType, o = t.componentIndex, s = {
    componentType: a,
    name: i,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = r.formatterParamsExtra;
  l && w(He(l), function(h) {
    oe(s, h) || (s[h] = l[h], s.$vars.push(h));
  });
  var u = _e(r.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: i,
    option: me({
      content: i,
      formatterParams: s
    }, n)
  };
}
function pD(r, e) {
  var t;
  r.isGroup && (t = e(r)), t || r.traverse(e);
}
function Tl(r, e) {
  if (r)
    if (X(r))
      for (var t = 0; t < r.length; t++)
        pD(r[t], e);
    else
      pD(r, e);
}
Sa("circle", uo);
Sa("ellipse", VI);
Sa("sector", Xi);
Sa("ring", RS);
Sa("polygon", Yi);
Sa("polyline", Wi);
Sa("rect", nt);
Sa("line", Mr);
Sa("bezierCurve", AS);
Sa("arc", FI);
const Fg = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: FI,
  BezierCurve: AS,
  BoundingRect: Ue,
  Circle: uo,
  CompoundPath: XI,
  Ellipse: VI,
  Group: ye,
  Image: qr,
  IncrementalDisplayable: Sae,
  Line: Mr,
  LinearGradient: Gg,
  OrientedBoundingRect: SE,
  Path: Fe,
  Point: Le,
  Polygon: Yi,
  Polyline: Wi,
  RadialGradient: hY,
  Rect: nt,
  Ring: RS,
  Sector: Xi,
  Text: lt,
  applyTransform: Oa,
  clipPointsByRect: gY,
  clipRectByRect: Iae,
  createIcon: Vg,
  extendPath: Aae,
  extendShape: yae,
  getShapeClass: HI,
  getTransform: Vu,
  groupTransition: Bg,
  initProps: Ut,
  isElementRemoved: Pc,
  lineLineIntersect: vY,
  linePolygonIntersect: kd,
  makeImage: fY,
  makePath: CS,
  mergePath: Dn,
  registerShape: Sa,
  removeElement: al,
  removeElementWithFadeOut: Wp,
  resizePath: pY,
  setTooltipConfig: yf,
  subPixelOptimize: Em,
  subPixelOptimizeLine: jc,
  subPixelOptimizeRect: Cae,
  transformDirection: _S,
  traverseElements: Tl,
  updateProps: ft
}, Symbol.toStringTag, { value: "Module" }));
var IS = {};
function OY(r, e) {
  for (var t = 0; t < Ii.length; t++) {
    var i = Ii[t], n = e[i], a = r.ensureState(i);
    a.style = a.style || {}, a.style.text = n;
  }
  var o = r.currentStates.slice();
  r.clearStates(!0), r.setStyle({
    text: e.normal
  }), r.useStates(o, !0);
}
function nC(r, e, t) {
  var i = r.labelFetcher, n = r.labelDataIndex, a = r.labelDimIndex, o = e.normal, s;
  i && (s = i.getFormattedLabel(n, "normal", null, a, o && o.get("formatter"), t != null ? {
    interpolatedValue: t
  } : null)), s == null && (s = ve(r.defaultText) ? r.defaultText(n, r, t) : r.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < Ii.length; u++) {
    var h = Ii[u], c = e[h];
    l[h] = ke(i ? i.getFormattedLabel(n, h, null, a, c && c.get("formatter")) : null, s);
  }
  return l;
}
function Zr(r, e, t, i) {
  t = t || IS;
  for (var n = r instanceof lt, a = !1, o = 0; o < Yp.length; o++) {
    var s = e[Yp[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = n ? r : r.getTextContent();
  if (a) {
    n || (l || (l = new lt(), r.setTextContent(l)), r.stateProxy && (l.stateProxy = r.stateProxy));
    var u = nC(t, e), h = e.normal, c = !!h.getShallow("show"), f = Lt(h, i && i.normal, t, !1, !n);
    f.text = u.normal, n || r.setTextConfig(RE(h, t, !1));
    for (var o = 0; o < Ii.length; o++) {
      var d = Ii[o], s = e[d];
      if (s) {
        var p = l.ensureState(d), g = !!ke(s.getShallow("show"), c);
        if (g !== c && (p.ignore = !g), p.style = Lt(s, i && i[d], t, !0, !n), p.style.text = u[d], !n) {
          var v = r.ensureState(d);
          v.textConfig = RE(s, t, !0);
        }
      }
    }
    l.silent = !!h.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !c, l.useStyle(f), l.dirty(), t.enableTextSetter && (Rf(l).setLabelText = function(O) {
      var m = nC(t, e, O);
      OY(l, m);
    });
  } else
    l && (l.ignore = !0);
  r.dirty();
}
function Cr(r, e) {
  e = e || "label";
  for (var t = {
    normal: r.getModel(e)
  }, i = 0; i < Ii.length; i++) {
    var n = Ii[i];
    t[n] = r.getModel([n, e]);
  }
  return t;
}
function Lt(r, e, t, i, n) {
  var a = {};
  return wae(a, r, t, i, n), e && V(a, e), a;
}
function RE(r, e, t) {
  e = e || {};
  var i = {}, n, a = r.getShallow("rotate"), o = ke(r.getShallow("distance"), t ? null : 5), s = r.getShallow("offset");
  return n = r.getShallow("position") || (t ? null : "inside"), n === "outside" && (n = e.defaultOutsidePosition || "top"), n != null && (i.position = n), s != null && (i.offset = s), a != null && (a *= Math.PI / 180, i.rotation = a), o != null && (i.distance = o), i.outsideFill = r.get("color") === "inherit" ? e.inheritColor || null : "auto", i;
}
function wae(r, e, t, i, n) {
  t = t || IS;
  var a = e.ecModel, o = a && a.option.textStyle, s = Pae(e), l;
  if (s) {
    l = {};
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var h = e.getModel(["rich", u]);
        mD(l[u] = {}, h, o, t, i, n, !1, !0);
      }
  }
  l && (r.rich = l);
  var c = e.get("overflow");
  c && (r.overflow = c);
  var f = e.get("minMargin");
  f != null && (r.margin = f), mD(r, e, o, t, i, n, !0, !1);
}
function Pae(r) {
  for (var e; r && r !== r.ecModel; ) {
    var t = (r.option || IS).rich;
    if (t) {
      e = e || {};
      for (var i = He(t), n = 0; n < i.length; n++) {
        var a = i[n];
        e[a] = 1;
      }
    }
    r = r.parentModel;
  }
  return e;
}
var gD = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], vD = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], OD = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function mD(r, e, t, i, n, a, o, s) {
  t = !n && t || IS;
  var l = i && i.inheritColor, u = e.getShallow("color"), h = e.getShallow("textBorderColor"), c = ke(e.getShallow("opacity"), t.opacity);
  (u === "inherit" || u === "auto") && (l ? u = l : u = null), (h === "inherit" || h === "auto") && (l ? h = l : h = null), a || (u = u || t.color, h = h || t.textBorderColor), u != null && (r.fill = u), h != null && (r.stroke = h);
  var f = ke(e.getShallow("textBorderWidth"), t.textBorderWidth);
  f != null && (r.lineWidth = f);
  var d = ke(e.getShallow("textBorderType"), t.textBorderType);
  d != null && (r.lineDash = d);
  var p = ke(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset);
  p != null && (r.lineDashOffset = p), !n && c == null && !s && (c = i && i.defaultOpacity), c != null && (r.opacity = c), !n && !a && r.fill == null && i.inheritColor && (r.fill = i.inheritColor);
  for (var g = 0; g < gD.length; g++) {
    var v = gD[g], O = ke(e.getShallow(v), t[v]);
    O != null && (r[v] = O);
  }
  for (var g = 0; g < vD.length; g++) {
    var v = vD[g], O = e.getShallow(v);
    O != null && (r[v] = O);
  }
  if (r.verticalAlign == null) {
    var m = e.getShallow("baseline");
    m != null && (r.verticalAlign = m);
  }
  if (!o || !i.disableBox) {
    for (var g = 0; g < OD.length; g++) {
      var v = OD[g], O = e.getShallow(v);
      O != null && (r[v] = O);
    }
    var E = e.getShallow("borderType");
    E != null && (r.borderDash = E), (r.backgroundColor === "auto" || r.backgroundColor === "inherit") && l && (r.backgroundColor = l), (r.borderColor === "auto" || r.borderColor === "inherit") && l && (r.borderColor = l);
  }
}
function mY(r, e) {
  var t = e && e.getModel("textStyle");
  return ha([
    // FIXME in node-canvas fontWeight is before fontStyle
    r.fontStyle || t && t.getShallow("fontStyle") || "",
    r.fontWeight || t && t.getShallow("fontWeight") || "",
    (r.fontSize || t && t.getShallow("fontSize") || 12) + "px",
    r.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var Rf = at();
function EY(r, e, t, i) {
  if (r) {
    var n = Rf(r);
    n.prevValue = n.value, n.value = t;
    var a = e.normal;
    n.valueAnimation = a.get("valueAnimation"), n.valueAnimation && (n.precision = a.get("precision"), n.defaultInterpolatedText = i, n.statesModels = e);
  }
}
function bY(r, e, t, i, n) {
  var a = Rf(r);
  if (!a.valueAnimation || a.prevValue === a.value)
    return;
  var o = a.defaultInterpolatedText, s = ke(a.interpolatedValue, a.prevValue), l = a.value;
  function u(h) {
    var c = SX(t, a.precision, s, l, h);
    a.interpolatedValue = h === 1 ? null : c;
    var f = nC({
      labelDataIndex: e,
      labelFetcher: n,
      defaultText: o ? o(c) : c + ""
    }, a.statesModels, c);
    OY(r, f);
  }
  r.percent = 0, (a.prevValue == null ? Ut : ft)(r, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, i, e, null, u);
}
var Nae = ["textStyle", "color"], Ay = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], Cy = new lt(), Lae = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getTextColor = function(e) {
      var t = this.ecModel;
      return this.getShallow("color") || (!e && t ? t.get(Nae) : null);
    }, r.prototype.getFont = function() {
      return mY({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, r.prototype.getTextRect = function(e) {
      for (var t = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, i = 0; i < Ay.length; i++)
        t[Ay[i]] = this.getShallow(Ay[i]);
      return Cy.useStyle(t), Cy.update(), Cy.getBoundingRect();
    }, r;
  }()
);
const Dae = Lae;
var SY = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], Mae = rh(SY), kae = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getLineStyle = function(e) {
      return Mae(this, e);
    }, r;
  }()
), TY = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], Qae = rh(TY), Uae = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getItemStyle = function(e, t) {
      return Qae(this, e, t);
    }, r;
  }()
), Sh = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.parentModel = t, this.ecModel = i, this.option = e;
    }
    return r.prototype.init = function(e, t, i) {
    }, r.prototype.mergeOption = function(e, t) {
      Qe(this.option, e, !0);
    }, r.prototype.get = function(e, t) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel);
    }, r.prototype.getShallow = function(e, t) {
      var i = this.option, n = i == null ? i : i[e];
      if (n == null && !t) {
        var a = this.parentModel;
        a && (n = a.getShallow(e));
      }
      return n;
    }, r.prototype.getModel = function(e, t) {
      var i = e != null, n = i ? this.parsePath(e) : null, a = i ? this._doGet(n) : this.option;
      return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(n)), new r(a, t, this.ecModel);
    }, r.prototype.isEmpty = function() {
      return this.option == null;
    }, r.prototype.restoreData = function() {
    }, r.prototype.clone = function() {
      var e = this.constructor;
      return new e(Se(this.option));
    }, r.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, r.prototype.resolveParentPath = function(e) {
      return e;
    }, r.prototype.isAnimationEnabled = function() {
      if (!st.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, r.prototype._doGet = function(e, t) {
      var i = this.option;
      if (!e)
        return i;
      for (var n = 0; n < e.length && !(e[n] && (i = i && typeof i == "object" ? i[e[n]] : null, i == null)); n++)
        ;
      return i == null && t && (i = t._doGet(this.resolveParentPath(e), t.parentModel)), i;
    }, r;
  }()
);
DI(Sh);
Uie(Sh);
hr(Sh, kae);
hr(Sh, Uae);
hr(Sh, Fie);
hr(Sh, Dae);
const Dt = Sh;
var $ae = Math.round(Math.random() * 10);
function Af(r) {
  return [r || "", $ae++].join("_");
}
function Gae(r) {
  var e = {};
  r.registerSubTypeDefaulter = function(t, i) {
    var n = Ha(t);
    e[n.main] = i;
  }, r.determineSubType = function(t, i) {
    var n = i.type;
    if (!n) {
      var a = Ha(t).main;
      r.hasSubTypes(t) && e[a] && (n = e[a](i));
    }
    return n;
  };
}
function Bae(r, e) {
  r.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = t(o), h = u.graph, c = u.noEntryList, f = {};
    for (w(a, function(m) {
      f[m] = !0;
    }); c.length; ) {
      var d = c.pop(), p = h[d], g = !!f[d];
      g && (s.call(l, d, p.originalDeps.slice()), delete f[d]), w(p.successor, g ? O : v);
    }
    w(f, function() {
      var m = "";
      throw new Error(m);
    });
    function v(m) {
      h[m].entryCount--, h[m].entryCount === 0 && c.push(m);
    }
    function O(m) {
      f[m] = !0, v(m);
    }
  };
  function t(a) {
    var o = {}, s = [];
    return w(a, function(l) {
      var u = i(o, l), h = u.originalDeps = e(l), c = n(h, a);
      u.entryCount = c.length, u.entryCount === 0 && s.push(l), w(c, function(f) {
        Ge(u.predecessor, f) < 0 && u.predecessor.push(f);
        var d = i(o, f);
        Ge(d.successor, f) < 0 && d.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function i(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function n(a, o) {
    var s = [];
    return w(a, function(l) {
      Ge(o, l) >= 0 && s.push(l);
    }), s;
  }
}
function yl(r, e) {
  return Qe(Qe({}, r, !0), e, !0);
}
const Vae = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, Fae = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var AE = "ZH", WI = "EN", zp = WI, bm = {}, zI = {}, yY = st.domSupported ? function() {
  var r = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase()
  );
  return r.indexOf(AE) > -1 ? AE : zp;
}() : zp;
function RY(r, e) {
  r = r.toUpperCase(), zI[r] = new Dt(e), bm[r] = e;
}
function Xae(r) {
  if (ne(r)) {
    var e = bm[r.toUpperCase()] || {};
    return r === AE || r === WI ? Se(e) : Qe(Se(e), Se(bm[zp]), !1);
  } else
    return Qe(Se(r), Se(bm[zp]), !1);
}
function aC(r) {
  return zI[r];
}
function Yae() {
  return zI[zp];
}
RY(WI, Vae);
RY(AE, Fae);
var ZI = 1e3, qI = ZI * 60, hp = qI * 60, Mn = hp * 24, ED = Mn * 365, Qd = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, Zv = "{yyyy}-{MM}-{dd}", bD = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: Zv,
  hour: Zv + " " + Qd.hour,
  minute: Zv + " " + Qd.minute,
  second: Zv + " " + Qd.second,
  millisecond: Qd.none
}, _y = ["year", "month", "day", "hour", "minute", "second", "millisecond"], AY = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function cs(r, e) {
  return r += "", "0000".substr(0, e - r.length) + r;
}
function Nc(r) {
  switch (r) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return r;
  }
}
function Hae(r) {
  return r === Nc(r);
}
function Wae(r) {
  switch (r) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function xS(r, e, t, i) {
  var n = so(r), a = n[jI(t)](), o = n[Lc(t)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = n[wS(t)](), u = n["get" + (t ? "UTC" : "") + "Day"](), h = n[Zp(t)](), c = (h - 1) % 12 + 1, f = n[PS(t)](), d = n[NS(t)](), p = n[LS(t)](), g = i instanceof Dt ? i : aC(i || yY) || Yae(), v = g.getModel("time"), O = v.get("month"), m = v.get("monthAbbr"), E = v.get("dayOfWeek"), b = v.get("dayOfWeekAbbr");
  return (e || "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, cs(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, O[o - 1]).replace(/{MMM}/g, m[o - 1]).replace(/{MM}/g, cs(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, cs(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, E[u]).replace(/{ee}/g, b[u]).replace(/{e}/g, u + "").replace(/{HH}/g, cs(h, 2)).replace(/{H}/g, h + "").replace(/{hh}/g, cs(c + "", 2)).replace(/{h}/g, c + "").replace(/{mm}/g, cs(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, cs(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, cs(p, 3)).replace(/{S}/g, p + "");
}
function zae(r, e, t, i, n) {
  var a = null;
  if (ne(t))
    a = t;
  else if (ve(t))
    a = t(r.value, e, {
      level: r.level
    });
  else {
    var o = V({}, Qd);
    if (r.level > 0)
      for (var s = 0; s < _y.length; ++s)
        o[_y[s]] = "{primary|" + o[_y[s]] + "}";
    var l = t ? t.inherit === !1 ? t : me(t, o) : o, u = CY(r.value, n);
    if (l[u])
      a = l[u];
    else if (l.inherit) {
      for (var h = AY.indexOf(u), s = h - 1; s >= 0; --s)
        if (l[u]) {
          a = l[u];
          break;
        }
      a = a || o.none;
    }
    if (X(a)) {
      var c = r.level == null ? 0 : r.level >= 0 ? r.level : a.length + r.level;
      c = Math.min(c, a.length - 1), a = a[c];
    }
  }
  return xS(new Date(r.value), a, n, i);
}
function CY(r, e) {
  var t = so(r), i = t[Lc(e)]() + 1, n = t[wS(e)](), a = t[Zp(e)](), o = t[PS(e)](), s = t[NS(e)](), l = t[LS(e)](), u = l === 0, h = u && s === 0, c = h && o === 0, f = c && a === 0, d = f && n === 1, p = d && i === 1;
  return p ? "year" : d ? "month" : f ? "day" : c ? "hour" : h ? "minute" : u ? "second" : "millisecond";
}
function SD(r, e, t) {
  var i = ut(r) ? so(r) : r;
  switch (e = e || CY(r, t), e) {
    case "year":
      return i[jI(t)]();
    case "half-year":
      return i[Lc(t)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((i[Lc(t)]() + 1) / 4);
    case "month":
      return i[Lc(t)]();
    case "day":
      return i[wS(t)]();
    case "half-day":
      return i[Zp(t)]() / 24;
    case "hour":
      return i[Zp(t)]();
    case "minute":
      return i[PS(t)]();
    case "second":
      return i[NS(t)]();
    case "millisecond":
      return i[LS(t)]();
  }
}
function jI(r) {
  return r ? "getUTCFullYear" : "getFullYear";
}
function Lc(r) {
  return r ? "getUTCMonth" : "getMonth";
}
function wS(r) {
  return r ? "getUTCDate" : "getDate";
}
function Zp(r) {
  return r ? "getUTCHours" : "getHours";
}
function PS(r) {
  return r ? "getUTCMinutes" : "getMinutes";
}
function NS(r) {
  return r ? "getUTCSeconds" : "getSeconds";
}
function LS(r) {
  return r ? "getUTCMilliseconds" : "getMilliseconds";
}
function Zae(r) {
  return r ? "setUTCFullYear" : "setFullYear";
}
function _Y(r) {
  return r ? "setUTCMonth" : "setMonth";
}
function IY(r) {
  return r ? "setUTCDate" : "setDate";
}
function xY(r) {
  return r ? "setUTCHours" : "setHours";
}
function wY(r) {
  return r ? "setUTCMinutes" : "setMinutes";
}
function PY(r) {
  return r ? "setUTCSeconds" : "setSeconds";
}
function NY(r) {
  return r ? "setUTCMilliseconds" : "setMilliseconds";
}
function LY(r) {
  if (!pX(r))
    return ne(r) ? r : "-";
  var e = (r + "").split(".");
  return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
}
function DY(r, e) {
  return r = (r || "").toLowerCase().replace(/-(.)/g, function(t, i) {
    return i.toUpperCase();
  }), e && r && (r = r.charAt(0).toUpperCase() + r.slice(1)), r;
}
var Cf = yI;
function oC(r, e, t) {
  var i = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function n(h) {
    return h && ha(h) ? h : "-";
  }
  function a(h) {
    return !!(h != null && !isNaN(h) && isFinite(h));
  }
  var o = e === "time", s = r instanceof Date;
  if (o || s) {
    var l = o ? so(r) : r;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else
      return xS(l, i, t);
  }
  if (e === "ordinal")
    return AA(r) ? n(r) : ut(r) && a(r) ? r + "" : "-";
  var u = Fo(r);
  return a(u) ? LY(u) : AA(r) ? n(r) : typeof r == "boolean" ? r + "" : "-";
}
var TD = ["a", "b", "c", "d", "e", "f", "g"], Iy = function(r, e) {
  return "{" + r + (e ?? "") + "}";
};
function MY(r, e, t) {
  X(e) || (e = [e]);
  var i = e.length;
  if (!i)
    return "";
  for (var n = e[0].$vars || [], a = 0; a < n.length; a++) {
    var o = TD[a];
    r = r.replace(Iy(o), Iy(o, 0));
  }
  for (var s = 0; s < i; s++)
    for (var l = 0; l < n.length; l++) {
      var u = e[s][n[l]];
      r = r.replace(Iy(TD[l], s), t ? Di(u) : u);
    }
  return r;
}
function qae(r, e, t) {
  return w(e, function(i, n) {
    r = r.replace("{" + n + "}", t ? Di(i) : i);
  }), r;
}
function jae(r, e) {
  var t = ne(r) ? {
    color: r,
    extraCssText: e
  } : r || {}, i = t.color, n = t.type;
  e = t.extraCssText;
  var a = t.renderMode || "html";
  if (!i)
    return "";
  if (a === "html")
    return n === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Di(i) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Di(i) + ";" + (e || "") + '"></span>';
  var o = t.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: n === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: i
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: i
    }
  };
}
function nh(r, e) {
  return e = e || "transparent", ne(r) ? r : be(r) && r.colorStops && (r.colorStops[0] || {}).color || e;
}
function CE(r, e) {
  if (e === "_blank" || e === "blank") {
    var t = window.open();
    t.opener = null, t.location.href = r;
  } else
    window.open(r, e);
}
var Sm = w, kY = ["left", "right", "top", "bottom", "width", "height"], yu = [["width", "left", "right"], ["height", "top", "bottom"]];
function KI(r, e, t, i, n) {
  var a = 0, o = 0;
  i == null && (i = 1 / 0), n == null && (n = 1 / 0);
  var s = 0;
  e.eachChild(function(l, u) {
    var h = l.getBoundingRect(), c = e.childAt(u + 1), f = c && c.getBoundingRect(), d, p;
    if (r === "horizontal") {
      var g = h.width + (f ? -f.x + h.x : 0);
      d = a + g, d > i || l.newline ? (a = 0, d = g, o += s + t, s = h.height) : s = Math.max(s, h.height);
    } else {
      var v = h.height + (f ? -f.y + h.y : 0);
      p = o + v, p > n || l.newline ? (a += s + t, o = 0, p = v, s = h.width) : s = Math.max(s, h.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), r === "horizontal" ? a = d + t : o = p + t);
  });
}
var Fu = KI;
Ie(KI, "vertical");
Ie(KI, "horizontal");
function Kae(r, e, t) {
  var i = e.width, n = e.height, a = K(r.left, i), o = K(r.top, n), s = K(r.right, i), l = K(r.bottom, n);
  return (isNaN(a) || isNaN(parseFloat(r.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(r.right))) && (s = i), (isNaN(o) || isNaN(parseFloat(r.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(r.bottom))) && (l = n), t = Cf(t || 0), {
    width: Math.max(s - a - t[1] - t[3], 0),
    height: Math.max(l - o - t[0] - t[2], 0)
  };
}
function mr(r, e, t) {
  t = Cf(t || 0);
  var i = e.width, n = e.height, a = K(r.left, i), o = K(r.top, n), s = K(r.right, i), l = K(r.bottom, n), u = K(r.width, i), h = K(r.height, n), c = t[2] + t[0], f = t[1] + t[3], d = r.aspect;
  switch (isNaN(u) && (u = i - s - f - a), isNaN(h) && (h = n - l - c - o), d != null && (isNaN(u) && isNaN(h) && (d > i / n ? u = i * 0.8 : h = n * 0.8), isNaN(u) && (u = d * h), isNaN(h) && (h = u / d)), isNaN(a) && (a = i - s - u - f), isNaN(o) && (o = n - l - h - c), r.left || r.right) {
    case "center":
      a = i / 2 - u / 2 - t[3];
      break;
    case "right":
      a = i - u - f;
      break;
  }
  switch (r.top || r.bottom) {
    case "middle":
    case "center":
      o = n / 2 - h / 2 - t[0];
      break;
    case "bottom":
      o = n - h - c;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = i - f - a - (s || 0)), isNaN(h) && (h = n - c - o - (l || 0));
  var p = new Ue(a + t[3], o + t[0], u, h);
  return p.margin = t, p;
}
function DS(r, e, t, i, n, a) {
  var o = !n || !n.hv || n.hv[0], s = !n || !n.hv || n.hv[1], l = n && n.boundingMode || "all";
  if (a = a || r, a.x = r.x, a.y = r.y, !o && !s)
    return !1;
  var u;
  if (l === "raw")
    u = r.type === "group" ? new Ue(0, 0, +e.width || 0, +e.height || 0) : r.getBoundingRect();
  else if (u = r.getBoundingRect(), r.needLocalTransform()) {
    var h = r.getLocalTransform();
    u = u.clone(), u.applyTransform(h);
  }
  var c = mr(me({
    width: u.width,
    height: u.height
  }, e), t, i), f = o ? c.x - u.x : 0, d = s ? c.y - u.y : 0;
  return l === "raw" ? (a.x = f, a.y = d) : (a.x += f, a.y += d), a === r && r.markRedraw(), !0;
}
function Jae(r, e) {
  return r[yu[e][0]] != null || r[yu[e][1]] != null && r[yu[e][2]] != null;
}
function qp(r) {
  var e = r.layoutMode || r.constructor.layoutMode;
  return be(e) ? e : e ? {
    type: e
  } : null;
}
function ol(r, e, t) {
  var i = t && t.ignoreSize;
  !X(i) && (i = [i, i]);
  var n = o(yu[0], 0), a = o(yu[1], 1);
  u(yu[0], r, n), u(yu[1], r, a);
  function o(h, c) {
    var f = {}, d = 0, p = {}, g = 0, v = 2;
    if (Sm(h, function(E) {
      p[E] = r[E];
    }), Sm(h, function(E) {
      s(e, E) && (f[E] = p[E] = e[E]), l(f, E) && d++, l(p, E) && g++;
    }), i[c])
      return l(e, h[1]) ? p[h[2]] = null : l(e, h[2]) && (p[h[1]] = null), p;
    if (g === v || !d)
      return p;
    if (d >= v)
      return f;
    for (var O = 0; O < h.length; O++) {
      var m = h[O];
      if (!s(f, m) && s(r, m)) {
        f[m] = r[m];
        break;
      }
    }
    return f;
  }
  function s(h, c) {
    return h.hasOwnProperty(c);
  }
  function l(h, c) {
    return h[c] != null && h[c] !== "auto";
  }
  function u(h, c, f) {
    Sm(h, function(d) {
      c[d] = f[d];
    });
  }
}
function _f(r) {
  return QY({}, r);
}
function QY(r, e) {
  return e && r && Sm(kY, function(t) {
    e.hasOwnProperty(t) && (r[t] = e[t]);
  }), r;
}
var eoe = at(), If = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this, t, i, n) || this;
      return a.uid = Af("ec_cpt_model"), a;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n);
    }, e.prototype.mergeDefaultAndTheme = function(t, i) {
      var n = qp(this), a = n ? _f(t) : {}, o = i.getTheme();
      Qe(t, o.get(this.mainType)), Qe(t, this.getDefaultOption()), n && ol(t, a, n);
    }, e.prototype.mergeOption = function(t, i) {
      Qe(this.option, t, !0);
      var n = qp(this);
      n && ol(this.option, t, n);
    }, e.prototype.optionUpdated = function(t, i) {
    }, e.prototype.getDefaultOption = function() {
      var t = this.constructor;
      if (!Mie(t))
        return t.defaultOption;
      var i = eoe(this);
      if (!i.defaultOption) {
        for (var n = [], a = t; a; ) {
          var o = a.prototype.defaultOption;
          o && n.push(o), a = a.superClass;
        }
        for (var s = {}, l = n.length - 1; l >= 0; l--)
          s = Qe(s, n[l], !0);
        i.defaultOption = s;
      }
      return i.defaultOption;
    }, e.prototype.getReferringComponents = function(t, i) {
      var n = t + "Index", a = t + "Id";
      return Ug(this.ecModel, t, {
        index: this.get(n, !0),
        id: this.get(a, !0)
      }, i);
    }, e.prototype.getBoxLayoutParams = function() {
      var t = this;
      return {
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(t) {
      this.option.zlevel = t;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
    }(), e;
  }(Dt)
);
yX(If, Dt);
mS(If);
Gae(If);
Bae(If, toe);
function toe(r) {
  var e = [];
  return w(If.getClassesByMainType(r), function(t) {
    e = e.concat(t.dependencies || t.prototype.dependencies || []);
  }), e = Y(e, function(t) {
    return Ha(t).main;
  }), r !== "dataset" && Ge(e, "dataset") <= 0 && e.unshift("dataset"), e;
}
const ot = If;
var UY = "";
typeof navigator < "u" && (UY = navigator.platform || "");
var Vh = "rgba(0, 0, 0, 0.2)";
const roe = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: Vh,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Vh,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Vh,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Vh,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Vh,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Vh,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: UY.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var $Y = ce(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]), Kn = "original", fi = "arrayRows", Jn = "objectRows", vo = "keyedColumns", Fs = "typedArray", GY = "unknown", Ja = "column", xf = "row", Br = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, BY = at();
function ioe(r) {
  BY(r).datasetMap = ce();
}
function VY(r, e, t) {
  var i = {}, n = ex(e);
  if (!n || !r)
    return i;
  var a = [], o = [], s = e.ecModel, l = BY(s).datasetMap, u = n.uid + "_" + t.seriesLayoutBy, h, c;
  r = r.slice(), w(r, function(g, v) {
    var O = be(g) ? g : r[v] = {
      name: g
    };
    O.type === "ordinal" && h == null && (h = v, c = p(O)), i[O.name] = [];
  });
  var f = l.get(u) || l.set(u, {
    categoryWayDim: c,
    valueWayDim: 0
  });
  w(r, function(g, v) {
    var O = g.name, m = p(g);
    if (h == null) {
      var E = f.valueWayDim;
      d(i[O], E, m), d(o, E, m), f.valueWayDim += m;
    } else if (h === v)
      d(i[O], 0, m), d(a, 0, m);
    else {
      var E = f.categoryWayDim;
      d(i[O], E, m), d(o, E, m), f.categoryWayDim += m;
    }
  });
  function d(g, v, O) {
    for (var m = 0; m < O; m++)
      g.push(v + m);
  }
  function p(g) {
    var v = g.dimsDef;
    return v ? v.length : 1;
  }
  return a.length && (i.itemName = a), o.length && (i.seriesName = o), i;
}
function JI(r, e, t) {
  var i = {}, n = ex(r);
  if (!n)
    return i;
  var a = e.sourceFormat, o = e.dimensionsDefine, s;
  (a === Jn || a === vo) && w(o, function(h, c) {
    (be(h) ? h.name : h) === "name" && (s = c);
  });
  var l = function() {
    for (var h = {}, c = {}, f = [], d = 0, p = Math.min(5, t); d < p; d++) {
      var g = XY(e.data, a, e.seriesLayoutBy, o, e.startIndex, d);
      f.push(g);
      var v = g === Br.Not;
      if (v && h.v == null && d !== s && (h.v = d), (h.n == null || h.n === h.v || !v && f[h.n] === Br.Not) && (h.n = d), O(h) && f[h.n] !== Br.Not)
        return h;
      v || (g === Br.Might && c.v == null && d !== s && (c.v = d), (c.n == null || c.n === c.v) && (c.n = d));
    }
    function O(m) {
      return m.v != null && m.n != null;
    }
    return O(h) ? h : O(c) ? c : null;
  }();
  if (l) {
    i.value = [l.v];
    var u = s ?? l.n;
    i.itemName = [u], i.seriesName = [u];
  }
  return i;
}
function ex(r) {
  var e = r.get("data", !0);
  if (!e)
    return Ug(r.ecModel, "dataset", {
      index: r.get("datasetIndex", !0),
      id: r.get("datasetId", !0)
    }, lr).models[0];
}
function noe(r) {
  return !r.get("transform", !0) && !r.get("fromTransformResult", !0) ? [] : Ug(r.ecModel, "dataset", {
    index: r.get("fromDatasetIndex", !0),
    id: r.get("fromDatasetId", !0)
  }, lr).models;
}
function FY(r, e) {
  return XY(r.data, r.sourceFormat, r.seriesLayoutBy, r.dimensionsDefine, r.startIndex, e);
}
function XY(r, e, t, i, n, a) {
  var o, s = 5;
  if (vn(r))
    return Br.Not;
  var l, u;
  if (i) {
    var h = i[a];
    be(h) ? (l = h.name, u = h.type) : ne(h) && (l = h);
  }
  if (u != null)
    return u === "ordinal" ? Br.Must : Br.Not;
  if (e === fi) {
    var c = r;
    if (t === xf) {
      for (var f = c[a], d = 0; d < (f || []).length && d < s; d++)
        if ((o = b(f[n + d])) != null)
          return o;
    } else
      for (var d = 0; d < c.length && d < s; d++) {
        var p = c[n + d];
        if (p && (o = b(p[a])) != null)
          return o;
      }
  } else if (e === Jn) {
    var g = r;
    if (!l)
      return Br.Not;
    for (var d = 0; d < g.length && d < s; d++) {
      var v = g[d];
      if (v && (o = b(v[l])) != null)
        return o;
    }
  } else if (e === vo) {
    var O = r;
    if (!l)
      return Br.Not;
    var f = O[l];
    if (!f || vn(f))
      return Br.Not;
    for (var d = 0; d < f.length && d < s; d++)
      if ((o = b(f[d])) != null)
        return o;
  } else if (e === Kn)
    for (var m = r, d = 0; d < m.length && d < s; d++) {
      var v = m[d], E = bf(v);
      if (!X(E))
        return Br.Not;
      if ((o = b(E[a])) != null)
        return o;
    }
  function b(T) {
    var S = ne(T);
    if (T != null && isFinite(T) && T !== "")
      return S ? Br.Might : Br.Not;
    if (S && T !== "-")
      return Br.Must;
  }
  return Br.Not;
}
var sC = ce();
function aoe(r, e) {
  _i(sC.get(r) == null && e), sC.set(r, e);
}
function ooe(r, e, t) {
  var i = sC.get(e);
  if (!i)
    return t;
  var n = i(r);
  return n ? t.concat(n) : t;
}
var yD = at(), soe = at(), tx = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getColorFromPalette = function(e, t, i) {
      var n = At(this.get("color", !0)), a = this.get("colorLayer", !0);
      return YY(this, yD, n, a, e, t, i);
    }, r.prototype.clearColorPalette = function() {
      uoe(this, yD);
    }, r;
  }()
);
function lC(r, e, t, i) {
  var n = At(r.get(["aria", "decal", "decals"]));
  return YY(r, soe, n, null, e, t, i);
}
function loe(r, e) {
  for (var t = r.length, i = 0; i < t; i++)
    if (r[i].length > e)
      return r[i];
  return r[t - 1];
}
function YY(r, e, t, i, n, a, o) {
  a = a || r;
  var s = e(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(n))
    return u[n];
  var h = o == null || !i ? t : loe(i, o);
  if (h = h || t, !(!h || !h.length)) {
    var c = h[l];
    return n && (u[n] = c), s.paletteIdx = (l + 1) % h.length, c;
  }
}
function uoe(r, e) {
  e(r).paletteIdx = 0, e(r).paletteNameMap = {};
}
var qv, Jf, RD, AD = "\0_ec_inner", hoe = 1, HY = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, i, n, a, o, s) {
      a = a || {}, this.option = null, this._theme = new Dt(a), this._locale = new Dt(o), this._optionManager = s;
    }, e.prototype.setOption = function(t, i, n) {
      var a = ID(i);
      this._optionManager.setOption(t, n, a), this._resetOption(null, a);
    }, e.prototype.resetOption = function(t, i) {
      return this._resetOption(t, ID(i));
    }, e.prototype._resetOption = function(t, i) {
      var n = !1, a = this._optionManager;
      if (!t || t === "recreate") {
        var o = a.mountOption(t === "recreate");
        !this.option || t === "recreate" ? RD(this, o) : (this.restoreData(), this._mergeOption(o, i)), n = !0;
      }
      if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
        var s = a.getTimelineOption(this);
        s && (n = !0, this._mergeOption(s, i));
      }
      if (!t || t === "recreate" || t === "media") {
        var l = a.getMediaOption(this);
        l.length && w(l, function(u) {
          n = !0, this._mergeOption(u, i);
        }, this);
      }
      return n;
    }, e.prototype.mergeOption = function(t) {
      this._mergeOption(t, null);
    }, e.prototype._mergeOption = function(t, i) {
      var n = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = ce(), u = i && i.replaceMergeMainTypeMap;
      ioe(this), w(t, function(c, f) {
        c != null && (ot.hasClass(f) ? f && (s.push(f), l.set(f, !0)) : n[f] = n[f] == null ? Se(c) : Qe(n[f], c, !0));
      }), u && u.each(function(c, f) {
        ot.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, !0));
      }), ot.topologicalTravel(s, ot.getAllClassMainTypes(), h, this);
      function h(c) {
        var f = ooe(this, c, At(t[c])), d = a.get(c), p = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          d ? u && u.get(c) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = EX(d, f, p);
        Cie(g, c, ot), n[c] = null, a.set(c, null), o.set(c, 0);
        var v = [], O = [], m = 0, E;
        w(g, function(b, T) {
          var S = b.existing, y = b.newOption;
          if (!y)
            S && (S.mergeOption({}, this), S.optionUpdated({}, !1));
          else {
            var A = c === "series", C = ot.getClass(
              c,
              b.keyInfo.subType,
              !A
              // Give a more detailed warn later if series don't exists
            );
            if (!C)
              return;
            if (c === "tooltip") {
              if (E)
                return;
              E = !0;
            }
            if (S && S.constructor === C)
              S.name = b.keyInfo.name, S.mergeOption(y, this), S.optionUpdated(y, !1);
            else {
              var _ = V({
                componentIndex: T
              }, b.keyInfo);
              S = new C(y, this, this, _), V(S, _), b.brandNew && (S.__requireNewView = !0), S.init(y, this, this), S.optionUpdated(null, !0);
            }
          }
          S ? (v.push(S.option), O.push(S), m++) : (v.push(void 0), O.push(void 0));
        }, this), n[c] = v, a.set(c, O), o.set(c, m), c === "series" && qv(this);
      }
      this._seriesIndices || qv(this);
    }, e.prototype.getOption = function() {
      var t = Se(this.option);
      return w(t, function(i, n) {
        if (ot.hasClass(n)) {
          for (var a = At(i), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !Fp(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, t[n] = a;
        }
      }), delete t[AD], t;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(t) {
      this._payload = t;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(t, i) {
      var n = this._componentsMap.get(t);
      if (n) {
        var a = n[i || 0];
        if (a)
          return a;
        if (i == null) {
          for (var o = 0; o < n.length; o++)
            if (n[o])
              return n[o];
        }
      }
    }, e.prototype.queryComponents = function(t) {
      var i = t.mainType;
      if (!i)
        return [];
      var n = t.index, a = t.id, o = t.name, s = this._componentsMap.get(i);
      if (!s || !s.length)
        return [];
      var l;
      return n != null ? (l = [], w(At(n), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = CD("id", a, s) : o != null ? l = CD("name", o, s) : l = yt(s, function(u) {
        return !!u;
      }), _D(l, t);
    }, e.prototype.findComponents = function(t) {
      var i = t.query, n = t.mainType, a = s(i), o = a ? this.queryComponents(a) : yt(this._componentsMap.get(n), function(u) {
        return !!u;
      });
      return l(_D(o, t));
      function s(u) {
        var h = n + "Index", c = n + "Id", f = n + "Name";
        return u && (u[h] != null || u[c] != null || u[f] != null) ? {
          mainType: n,
          // subType will be filtered finally.
          index: u[h],
          id: u[c],
          name: u[f]
        } : null;
      }
      function l(u) {
        return t.filter ? yt(u, t.filter) : u;
      }
    }, e.prototype.eachComponent = function(t, i, n) {
      var a = this._componentsMap;
      if (ve(t)) {
        var o = i, s = t;
        a.each(function(c, f) {
          for (var d = 0; c && d < c.length; d++) {
            var p = c[d];
            p && s.call(o, f, p, p.componentIndex);
          }
        });
      } else
        for (var l = ne(t) ? a.get(t) : be(t) ? this.findComponents(t) : null, u = 0; l && u < l.length; u++) {
          var h = l[u];
          h && i.call(n, h, h.componentIndex);
        }
    }, e.prototype.getSeriesByName = function(t) {
      var i = gr(t, null);
      return yt(this._componentsMap.get("series"), function(n) {
        return !!n && i != null && n.name === i;
      });
    }, e.prototype.getSeriesByIndex = function(t) {
      return this._componentsMap.get("series")[t];
    }, e.prototype.getSeriesByType = function(t) {
      return yt(this._componentsMap.get("series"), function(i) {
        return !!i && i.subType === t;
      });
    }, e.prototype.getSeries = function() {
      return yt(this._componentsMap.get("series"), function(t) {
        return !!t;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(t, i) {
      Jf(this), w(this._seriesIndices, function(n) {
        var a = this._componentsMap.get("series")[n];
        t.call(i, a, n);
      }, this);
    }, e.prototype.eachRawSeries = function(t, i) {
      w(this._componentsMap.get("series"), function(n) {
        n && t.call(i, n, n.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(t, i, n) {
      Jf(this), w(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === t && i.call(n, o, a);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(t, i, n) {
      return w(this.getSeriesByType(t), i, n);
    }, e.prototype.isSeriesFiltered = function(t) {
      return Jf(this), this._seriesIndicesMap.get(t.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(t, i) {
      Jf(this);
      var n = [];
      w(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        t.call(i, o, a) && n.push(a);
      }, this), this._seriesIndices = n, this._seriesIndicesMap = ce(n);
    }, e.prototype.restoreData = function(t) {
      qv(this);
      var i = this._componentsMap, n = [];
      i.each(function(a, o) {
        ot.hasClass(o) && n.push(o);
      }), ot.topologicalTravel(n, ot.getAllClassMainTypes(), function(a) {
        w(i.get(a), function(o) {
          o && (a !== "series" || !coe(o, t)) && o.restoreData();
        });
      });
    }, e.internalField = function() {
      qv = function(t) {
        var i = t._seriesIndices = [];
        w(t._componentsMap.get("series"), function(n) {
          n && i.push(n.componentIndex);
        }), t._seriesIndicesMap = ce(i);
      }, Jf = function(t) {
      }, RD = function(t, i) {
        t.option = {}, t.option[AD] = hoe, t._componentsMap = ce({
          series: []
        }), t._componentsCount = ce();
        var n = i.aria;
        be(n) && n.enabled == null && (n.enabled = !0), foe(i, t._theme.option), Qe(i, roe, !1), t._mergeOption(i, null);
      };
    }(), e;
  }(Dt)
);
function coe(r, e) {
  if (e) {
    var t = e.seriesIndex, i = e.seriesId, n = e.seriesName;
    return t != null && r.componentIndex !== t || i != null && r.id !== i || n != null && r.name !== n;
  }
}
function foe(r, e) {
  var t = r.color && !r.colorLayer;
  w(e, function(i, n) {
    n === "colorLayer" && t || ot.hasClass(n) || (typeof i == "object" ? r[n] = r[n] ? Qe(r[n], i, !1) : Se(i) : r[n] == null && (r[n] = i));
  });
}
function CD(r, e, t) {
  if (X(e)) {
    var i = ce();
    return w(e, function(a) {
      if (a != null) {
        var o = gr(a, null);
        o != null && i.set(a, !0);
      }
    }), yt(t, function(a) {
      return a && i.get(a[r]);
    });
  } else {
    var n = gr(e, null);
    return yt(t, function(a) {
      return a && n != null && a[r] === n;
    });
  }
}
function _D(r, e) {
  return e.hasOwnProperty("subType") ? yt(r, function(t) {
    return t && t.subType === e.subType;
  }) : r;
}
function ID(r) {
  var e = ce();
  return r && w(At(r.replaceMerge), function(t) {
    e.set(t, !0);
  }), {
    replaceMergeMainTypeMap: e
  };
}
hr(HY, tx);
const WY = HY;
var doe = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], poe = (
  /** @class */
  function() {
    function r(e) {
      w(doe, function(t) {
        this[t] = ae(e[t], e);
      }, this);
    }
    return r;
  }()
);
const zY = poe;
var xy = {}, goe = (
  /** @class */
  function() {
    function r() {
      this._coordinateSystems = [];
    }
    return r.prototype.create = function(e, t) {
      var i = [];
      w(xy, function(n, a) {
        var o = n.create(e, t);
        i = i.concat(o || []);
      }), this._coordinateSystems = i;
    }, r.prototype.update = function(e, t) {
      w(this._coordinateSystems, function(i) {
        i.update && i.update(e, t);
      });
    }, r.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, r.register = function(e, t) {
      xy[e] = t;
    }, r.get = function(e) {
      return xy[e];
    }, r;
  }()
);
const Xg = goe;
var voe = /^(min|max)?(.+)$/, Ooe = (
  /** @class */
  function() {
    function r(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return r.prototype.setOption = function(e, t, i) {
      e && (w(At(e.series), function(o) {
        o && o.data && vn(o.data) && uE(o.data);
      }), w(At(e.dataset), function(o) {
        o && o.source && vn(o.source) && uE(o.source);
      })), e = Se(e);
      var n = this._optionBackup, a = moe(e, t, !n);
      this._newBaseOption = a.baseOption, n ? (a.timelineOptions.length && (n.timelineOptions = a.timelineOptions), a.mediaList.length && (n.mediaList = a.mediaList), a.mediaDefault && (n.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, r.prototype.mountOption = function(e) {
      var t = this._optionBackup;
      return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], Se(e ? t.baseOption : this._newBaseOption);
    }, r.prototype.getTimelineOption = function(e) {
      var t, i = this._timelineOptions;
      if (i.length) {
        var n = e.getComponent("timeline");
        n && (t = Se(
          // FIXME:TS as TimelineModel or quivlant interface
          i[n.getCurrentIndex()]
        ));
      }
      return t;
    }, r.prototype.getMediaOption = function(e) {
      var t = this._api.getWidth(), i = this._api.getHeight(), n = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!n.length && !a)
        return s;
      for (var l = 0, u = n.length; l < u; l++)
        Eoe(n[l].query, t, i) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !Soe(o, this._currentMediaIndices) && (s = Y(o, function(h) {
        return Se(h === -1 ? a.option : n[h].option);
      })), this._currentMediaIndices = o, s;
    }, r;
  }()
);
function moe(r, e, t) {
  var i = [], n, a, o = r.baseOption, s = r.timeline, l = r.options, u = r.media, h = !!r.media, c = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((c || h) && (r.options = r.media = null), a = r), h && X(u) && w(u, function(d) {
    d && d.option && (d.query ? i.push(d) : n || (n = d));
  }), f(a), w(l, function(d) {
    return f(d);
  }), w(i, function(d) {
    return f(d.option);
  });
  function f(d) {
    w(e, function(p) {
      p(d, t);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: n,
    mediaList: i
  };
}
function Eoe(r, e, t) {
  var i = {
    width: e,
    height: t,
    aspectratio: e / t
    // lower case for convenience.
  }, n = !0;
  return w(r, function(a, o) {
    var s = o.match(voe);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      boe(i[u], a, l) || (n = !1);
    }
  }), n;
}
function boe(r, e, t) {
  return t === "min" ? r >= e : t === "max" ? r <= e : r === e;
}
function Soe(r, e) {
  return r.join(",") === e.join(",");
}
const Toe = Ooe;
var ra = w, jp = be, xD = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function wy(r) {
  var e = r && r.itemStyle;
  if (e)
    for (var t = 0, i = xD.length; t < i; t++) {
      var n = xD[t], a = e.normal, o = e.emphasis;
      a && a[n] && (r[n] = r[n] || {}, r[n].normal ? Qe(r[n].normal, a[n]) : r[n].normal = a[n], a[n] = null), o && o[n] && (r[n] = r[n] || {}, r[n].emphasis ? Qe(r[n].emphasis, o[n]) : r[n].emphasis = o[n], o[n] = null);
    }
}
function ii(r, e, t) {
  if (r && r[e] && (r[e].normal || r[e].emphasis)) {
    var i = r[e].normal, n = r[e].emphasis;
    i && (t ? (r[e].normal = r[e].emphasis = null, me(r[e], i)) : r[e] = i), n && (r.emphasis = r.emphasis || {}, r.emphasis[e] = n, n.focus && (r.emphasis.focus = n.focus), n.blurScope && (r.emphasis.blurScope = n.blurScope));
  }
}
function Ud(r) {
  ii(r, "itemStyle"), ii(r, "lineStyle"), ii(r, "areaStyle"), ii(r, "label"), ii(r, "labelLine"), ii(r, "upperLabel"), ii(r, "edgeLabel");
}
function or(r, e) {
  var t = jp(r) && r[e], i = jp(t) && t.textStyle;
  if (i)
    for (var n = 0, a = LL.length; n < a; n++) {
      var o = LL[n];
      i.hasOwnProperty(o) && (t[o] = i[o]);
    }
}
function In(r) {
  r && (Ud(r), or(r, "label"), r.emphasis && or(r.emphasis, "label"));
}
function yoe(r) {
  if (jp(r)) {
    wy(r), Ud(r), or(r, "label"), or(r, "upperLabel"), or(r, "edgeLabel"), r.emphasis && (or(r.emphasis, "label"), or(r.emphasis, "upperLabel"), or(r.emphasis, "edgeLabel"));
    var e = r.markPoint;
    e && (wy(e), In(e));
    var t = r.markLine;
    t && (wy(t), In(t));
    var i = r.markArea;
    i && In(i);
    var n = r.data;
    if (r.type === "graph") {
      n = n || r.nodes;
      var a = r.links || r.edges;
      if (a && !vn(a))
        for (var o = 0; o < a.length; o++)
          In(a[o]);
      w(r.categories, function(u) {
        Ud(u);
      });
    }
    if (n && !vn(n))
      for (var o = 0; o < n.length; o++)
        In(n[o]);
    if (e = r.markPoint, e && e.data)
      for (var s = e.data, o = 0; o < s.length; o++)
        In(s[o]);
    if (t = r.markLine, t && t.data)
      for (var l = t.data, o = 0; o < l.length; o++)
        X(l[o]) ? (In(l[o][0]), In(l[o][1])) : In(l[o]);
    r.type === "gauge" ? (or(r, "axisLabel"), or(r, "title"), or(r, "detail")) : r.type === "treemap" ? (ii(r.breadcrumb, "itemStyle"), w(r.levels, function(u) {
      Ud(u);
    })) : r.type === "tree" && Ud(r.leaves);
  }
}
function To(r) {
  return X(r) ? r : r ? [r] : [];
}
function wD(r) {
  return (X(r) ? r[0] : r) || {};
}
function Roe(r, e) {
  ra(To(r.series), function(i) {
    jp(i) && yoe(i);
  });
  var t = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), ra(t, function(i) {
    ra(To(r[i]), function(n) {
      n && (or(n, "axisLabel"), or(n.axisPointer, "label"));
    });
  }), ra(To(r.parallel), function(i) {
    var n = i && i.parallelAxisDefault;
    or(n, "axisLabel"), or(n && n.axisPointer, "label");
  }), ra(To(r.calendar), function(i) {
    ii(i, "itemStyle"), or(i, "dayLabel"), or(i, "monthLabel"), or(i, "yearLabel");
  }), ra(To(r.radar), function(i) {
    or(i, "name"), i.name && i.axisName == null && (i.axisName = i.name, delete i.name), i.nameGap != null && i.axisNameGap == null && (i.axisNameGap = i.nameGap, delete i.nameGap);
  }), ra(To(r.geo), function(i) {
    jp(i) && (In(i), ra(To(i.regions), function(n) {
      In(n);
    }));
  }), ra(To(r.timeline), function(i) {
    In(i), ii(i, "label"), ii(i, "itemStyle"), ii(i, "controlStyle", !0);
    var n = i.data;
    X(n) && w(n, function(a) {
      be(a) && (ii(a, "label"), ii(a, "itemStyle"));
    });
  }), ra(To(r.toolbox), function(i) {
    ii(i, "iconStyle"), ra(i.feature, function(n) {
      ii(n, "iconStyle");
    });
  }), or(wD(r.axisPointer), "label"), or(wD(r.tooltip).axisPointer, "label");
}
function Aoe(r, e) {
  for (var t = e.split(","), i = r, n = 0; n < t.length && (i = i && i[t[n]], i != null); n++)
    ;
  return i;
}
function Coe(r, e, t, i) {
  for (var n = e.split(","), a = r, o, s = 0; s < n.length - 1; s++)
    o = n[s], a[o] == null && (a[o] = {}), a = a[o];
  (i || a[n[s]] == null) && (a[n[s]] = t);
}
function PD(r) {
  r && w(_oe, function(e) {
    e[0] in r && !(e[1] in r) && (r[e[1]] = r[e[0]]);
  });
}
var _oe = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], Ioe = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], Py = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function ed(r) {
  var e = r && r.itemStyle;
  if (e)
    for (var t = 0; t < Py.length; t++) {
      var i = Py[t][1], n = Py[t][0];
      e[i] != null && (e[n] = e[i]);
    }
}
function ND(r) {
  r && r.alignTo === "edge" && r.margin != null && r.edgeDistance == null && (r.edgeDistance = r.margin);
}
function LD(r) {
  r && r.downplay && !r.blur && (r.blur = r.downplay);
}
function xoe(r) {
  r && r.focusNodeAdjacency != null && (r.emphasis = r.emphasis || {}, r.emphasis.focus == null && (r.emphasis.focus = "adjacency"));
}
function ZY(r, e) {
  if (r)
    for (var t = 0; t < r.length; t++)
      e(r[t]), r[t] && ZY(r[t].children, e);
}
function qY(r, e) {
  Roe(r, e), r.series = At(r.series), w(r.series, function(t) {
    if (be(t)) {
      var i = t.type;
      if (i === "line")
        t.clipOverflow != null && (t.clip = t.clipOverflow);
      else if (i === "pie" || i === "gauge") {
        t.clockWise != null && (t.clockwise = t.clockWise), ND(t.label);
        var n = t.data;
        if (n && !vn(n))
          for (var a = 0; a < n.length; a++)
            ND(n[a]);
        t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (t.emphasis.scaleSize = t.hoverOffset));
      } else if (i === "gauge") {
        var o = Aoe(t, "pointer.color");
        o != null && Coe(t, "itemStyle.color", o);
      } else if (i === "bar") {
        ed(t), ed(t.backgroundStyle), ed(t.emphasis);
        var n = t.data;
        if (n && !vn(n))
          for (var a = 0; a < n.length; a++)
            typeof n[a] == "object" && (ed(n[a]), ed(n[a] && n[a].emphasis));
      } else if (i === "sunburst") {
        var s = t.highlightPolicy;
        s && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = s)), LD(t), ZY(t.data, LD);
      } else
        i === "graph" || i === "sankey" ? xoe(t) : i === "map" && (t.mapType && !t.map && (t.map = t.mapType), t.mapLocation && me(t, t.mapLocation));
      t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (t.emphasis.scale = t.hoverAnimation)), PD(t);
    }
  }), r.dataRange && (r.visualMap = r.dataRange), w(Ioe, function(t) {
    var i = r[t];
    i && (X(i) || (i = [i]), w(i, function(n) {
      PD(n);
    }));
  });
}
function woe(r) {
  var e = ce();
  r.eachSeries(function(t) {
    var i = t.get("stack");
    if (i) {
      var n = e.get(i) || e.set(i, []), a = t.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: t
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      n.length && a.setCalculationInfo("stackedOnSeries", n[n.length - 1].seriesModel), n.push(o);
    }
  }), e.each(Poe);
}
function Poe(r) {
  w(r, function(e, t) {
    var i = [], n = [NaN, NaN], a = [e.stackResultDimension, e.stackedOverDimension], o = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, h, c) {
      var f = o.get(e.stackedDimension, c);
      if (isNaN(f))
        return n;
      var d, p;
      s ? p = o.getRawIndex(c) : d = o.get(e.stackedByDimension, c);
      for (var g = NaN, v = t - 1; v >= 0; v--) {
        var O = r[v];
        if (s || (p = O.data.rawIndexOf(O.stackedByDimension, d)), p >= 0) {
          var m = O.data.getByRawIndex(O.stackResultDimension, p);
          if (l === "all" || l === "positive" && m > 0 || l === "negative" && m < 0 || l === "samesign" && f >= 0 && m > 0 || l === "samesign" && f <= 0 && m < 0) {
            f = gie(f, m), g = m;
            break;
          }
        }
      }
      return i[0] = f, i[1] = g, i;
    });
  });
}
var MS = (
  /** @class */
  function() {
    function r(e) {
      this.data = e.data || (e.sourceFormat === vo ? {} : []), this.sourceFormat = e.sourceFormat || GY, this.seriesLayoutBy = e.seriesLayoutBy || Ja, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var t = this.dimensionsDefine = e.dimensionsDefine;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var n = t[i];
          n.type == null && FY(this, i) === Br.Must && (n.type = "ordinal");
        }
    }
    return r;
  }()
);
function rx(r) {
  return r instanceof MS;
}
function uC(r, e, t) {
  t = t || jY(r);
  var i = e.seriesLayoutBy, n = Loe(r, t, i, e.sourceHeader, e.dimensions), a = new MS({
    data: r,
    sourceFormat: t,
    seriesLayoutBy: i,
    dimensionsDefine: n.dimensionsDefine,
    startIndex: n.startIndex,
    dimensionsDetectedCount: n.dimensionsDetectedCount,
    metaRawOption: Se(e)
  });
  return a;
}
function ix(r) {
  return new MS({
    data: r,
    sourceFormat: vn(r) ? Fs : Kn
  });
}
function Noe(r) {
  return new MS({
    data: r.data,
    sourceFormat: r.sourceFormat,
    seriesLayoutBy: r.seriesLayoutBy,
    dimensionsDefine: Se(r.dimensionsDefine),
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount
  });
}
function jY(r) {
  var e = GY;
  if (vn(r))
    e = Fs;
  else if (X(r)) {
    r.length === 0 && (e = fi);
    for (var t = 0, i = r.length; t < i; t++) {
      var n = r[t];
      if (n != null) {
        if (X(n)) {
          e = fi;
          break;
        } else if (be(n)) {
          e = Jn;
          break;
        }
      }
    }
  } else if (be(r)) {
    for (var a in r)
      if (oe(r, a) && ci(r[a])) {
        e = vo;
        break;
      }
  }
  return e;
}
function Loe(r, e, t, i, n) {
  var a, o;
  if (!r)
    return {
      dimensionsDefine: DD(n),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (e === fi) {
    var s = r;
    i === "auto" || i == null ? MD(function(u) {
      u != null && u !== "-" && (ne(u) ? o == null && (o = 1) : o = 0);
    }, t, s, 10) : o = ut(i) ? i : i ? 1 : 0, !n && o === 1 && (n = [], MD(function(u, h) {
      n[h] = u != null ? u + "" : "";
    }, t, s, 1 / 0)), a = n ? n.length : t === xf ? s.length : s[0] ? s[0].length : null;
  } else if (e === Jn)
    n || (n = Doe(r));
  else if (e === vo)
    n || (n = [], w(r, function(u, h) {
      n.push(h);
    }));
  else if (e === Kn) {
    var l = bf(r[0]);
    a = X(l) && l.length || 1;
  }
  return {
    startIndex: o,
    dimensionsDefine: DD(n),
    dimensionsDetectedCount: a
  };
}
function Doe(r) {
  for (var e = 0, t; e < r.length && !(t = r[e++]); )
    ;
  if (t)
    return He(t);
}
function DD(r) {
  if (r) {
    var e = ce();
    return Y(r, function(t, i) {
      t = be(t) ? t : {
        name: t
      };
      var n = {
        name: t.name,
        displayName: t.displayName,
        type: t.type
      };
      if (n.name == null)
        return n;
      n.name += "", n.displayName == null && (n.displayName = n.name);
      var a = e.get(n.name);
      return a ? n.name += "-" + a.count++ : e.set(n.name, {
        count: 1
      }), n;
    });
  }
}
function MD(r, e, t, i) {
  if (e === xf)
    for (var n = 0; n < t.length && n < i; n++)
      r(t[n] ? t[n][0] : null, n);
  else
    for (var a = t[0] || [], n = 0; n < a.length && n < i; n++)
      r(a[n], n);
}
function KY(r) {
  var e = r.sourceFormat;
  return e === Jn || e === vo;
}
var Hl, Wl, zl, kD, QD, JY = (
  /** @class */
  function() {
    function r(e, t) {
      var i = rx(e) ? e : ix(e);
      this._source = i;
      var n = this._data = i.data;
      i.sourceFormat === Fs && (this._offset = 0, this._dimSize = t, this._data = n), QD(this, n, i);
    }
    return r.prototype.getSource = function() {
      return this._source;
    }, r.prototype.count = function() {
      return 0;
    }, r.prototype.getItem = function(e, t) {
    }, r.prototype.appendData = function(e) {
    }, r.prototype.clean = function() {
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.pure = !1, e.persistent = !0;
    }(), r.internalField = function() {
      var e;
      QD = function(o, s, l) {
        var u = l.sourceFormat, h = l.seriesLayoutBy, c = l.startIndex, f = l.dimensionsDefine, d = kD[nx(u, h)];
        if (V(o, d), u === Fs)
          o.getItem = t, o.count = n, o.fillStorage = i;
        else {
          var p = eH(u, h);
          o.getItem = ae(p, null, s, c, f);
          var g = tH(u, h);
          o.count = ae(g, null, s, c, f);
        }
      };
      var t = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, h = u * o, c = 0; c < u; c++)
          s[c] = l[h + c];
        return s;
      }, i = function(o, s, l, u) {
        for (var h = this._data, c = this._dimSize, f = 0; f < c; f++) {
          for (var d = u[f], p = d[0] == null ? 1 / 0 : d[0], g = d[1] == null ? -1 / 0 : d[1], v = s - o, O = l[f], m = 0; m < v; m++) {
            var E = h[m * c + f];
            O[o + m] = E, E < p && (p = E), E > g && (g = E);
          }
          d[0] = p, d[1] = g;
        }
      }, n = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      kD = (e = {}, e[fi + "_" + Ja] = {
        pure: !0,
        appendData: a
      }, e[fi + "_" + xf] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[Jn] = {
        pure: !0,
        appendData: a
      }, e[vo] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          w(o, function(l, u) {
            for (var h = s[u] || (s[u] = []), c = 0; c < (l || []).length; c++)
              h.push(l[c]);
          });
        }
      }, e[Kn] = {
        appendData: a
      }, e[Fs] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
          this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    }(), r;
  }()
), UD = function(r, e, t, i) {
  return r[i];
}, Moe = (Hl = {}, Hl[fi + "_" + Ja] = function(r, e, t, i) {
  return r[i + e];
}, Hl[fi + "_" + xf] = function(r, e, t, i, n) {
  i += e;
  for (var a = n || [], o = r, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[i] : null;
  }
  return a;
}, Hl[Jn] = UD, Hl[vo] = function(r, e, t, i, n) {
  for (var a = n || [], o = 0; o < t.length; o++) {
    var s = t[o].name, l = r[s];
    a[o] = l ? l[i] : null;
  }
  return a;
}, Hl[Kn] = UD, Hl);
function eH(r, e) {
  var t = Moe[nx(r, e)];
  return t;
}
var $D = function(r, e, t) {
  return r.length;
}, koe = (Wl = {}, Wl[fi + "_" + Ja] = function(r, e, t) {
  return Math.max(0, r.length - e);
}, Wl[fi + "_" + xf] = function(r, e, t) {
  var i = r[0];
  return i ? Math.max(0, i.length - e) : 0;
}, Wl[Jn] = $D, Wl[vo] = function(r, e, t) {
  var i = t[0].name, n = r[i];
  return n ? n.length : 0;
}, Wl[Kn] = $D, Wl);
function tH(r, e) {
  var t = koe[nx(r, e)];
  return t;
}
var Ny = function(r, e, t) {
  return r[e];
}, Qoe = (zl = {}, zl[fi] = Ny, zl[Jn] = function(r, e, t) {
  return r[t];
}, zl[vo] = Ny, zl[Kn] = function(r, e, t) {
  var i = bf(r);
  return i instanceof Array ? i[e] : i;
}, zl[Fs] = Ny, zl);
function rH(r) {
  var e = Qoe[r];
  return e;
}
function nx(r, e) {
  return r === fi ? r + "_" + e : r;
}
function Kc(r, e, t) {
  if (r) {
    var i = r.getRawDataItem(e);
    if (i != null) {
      var n = r.getStore(), a = n.getSource().sourceFormat;
      if (t != null) {
        var o = r.getDimensionIndex(t), s = n.getDimensionProperty(o);
        return rH(a)(i, o, s);
      } else {
        var l = i;
        return a === Kn && (l = bf(i)), l;
      }
    }
  }
}
var Uoe = /\{@(.+?)\}/g, ax = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getDataParams = function(e, t) {
      var i = this.getData(t), n = this.getRawValue(e, t), a = i.getRawIndex(e), o = i.getName(e), s = i.getRawDataItem(e), l = i.getItemVisual(e, "style"), u = l && l[i.getItemVisual(e, "drawType") || "fill"], h = l && l.stroke, c = this.mainType, f = c === "series", d = i.userOutput && i.userOutput.get();
      return {
        componentType: c,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: t,
        value: n,
        color: u,
        borderColor: h,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, r.prototype.getFormattedLabel = function(e, t, i, n, a, o) {
      t = t || "normal";
      var s = this.getData(i), l = this.getDataParams(e, i);
      if (o && (l.value = o.interpolatedValue), n != null && X(l.value) && (l.value = l.value[n]), !a) {
        var u = s.getItemModel(e);
        a = u.get(t === "normal" ? ["label", "formatter"] : [t, "label", "formatter"]);
      }
      if (ve(a))
        return l.status = t, l.dimensionIndex = n, a(l);
      if (ne(a)) {
        var h = MY(a, l);
        return h.replace(Uoe, function(c, f) {
          var d = f.length, p = f;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1));
          var g = Kc(s, e, p);
          if (o && X(o.interpolatedValue)) {
            var v = s.getDimensionIndex(p);
            v >= 0 && (g = o.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, r.prototype.getRawValue = function(e, t) {
      return Kc(this.getData(t), e);
    }, r.prototype.formatTooltip = function(e, t, i) {
    }, r;
  }()
);
function GD(r) {
  var e, t;
  return be(r) ? r.type && (t = r) : e = r, {
    text: e,
    // markers: markers || markersExisting,
    frag: t
  };
}
function cp(r) {
  return new $oe(r);
}
var $oe = (
  /** @class */
  function() {
    function r(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = !0;
    }
    return r.prototype.perform = function(e) {
      var t = this._upstream, i = e && e.skip;
      if (this._dirty && t) {
        var n = this.context;
        n.data = n.outputData = t.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !i && (a = this._plan(this.context));
      var o = h(this._modBy), s = this._modDataCount || 0, l = h(e && e.modBy), u = e && e.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function h(m) {
        return !(m >= 1) && (m = 1), m;
      }
      var c;
      (this._dirty || a === "reset") && (this._dirty = !1, c = this._doReset(i)), this._modBy = l, this._modDataCount = u;
      var f = e && e.step;
      if (t ? this._dueEnd = t._outputDueEnd : this._dueEnd = this._count ? this._count(this.context) : 1 / 0, this._progress) {
        var d = this._dueIndex, p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!i && (c || d < p)) {
          var g = this._progress;
          if (X(g))
            for (var v = 0; v < g.length; v++)
              this._doProgress(g[v], d, p, l, u);
          else
            this._doProgress(g, d, p, l, u);
        }
        this._dueIndex = p;
        var O = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        this._outputDueEnd = O;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, r.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, r.prototype._doProgress = function(e, t, i, n, a) {
      BD.reset(t, i, n, a), this._callingProgress = e, this._callingProgress({
        start: t,
        end: i,
        count: i - t,
        next: BD.next
      }, this.context);
    }, r.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var t, i;
      !e && this._reset && (t = this._reset(this.context), t && t.progress && (i = t.forceFirstProgress, t = t.progress), X(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null;
      var n = this._downstream;
      return n && n.dirty(), i;
    }, r.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, r.prototype.pipe = function(e) {
      (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, r.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, r.prototype.getUpstream = function() {
      return this._upstream;
    }, r.prototype.getDownstream = function() {
      return this._downstream;
    }, r.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, r;
  }()
), BD = function() {
  var r, e, t, i, n, a = {
    reset: function(l, u, h, c) {
      e = l, r = u, t = h, i = c, n = Math.ceil(i / t), a.next = t > 1 && i > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return e < r ? e++ : null;
  }
  function s() {
    var l = e % n * t + Math.ceil(e / n), u = e >= r ? null : l < i ? l : e;
    return e++, u;
  }
}();
function Xs(r, e) {
  var t = e && e.type;
  return t === "ordinal" ? r : (t === "time" && !ut(r) && r != null && r !== "-" && (r = +so(r)), r == null || r === "" ? NaN : +r);
}
var Goe = ce({
  number: function(r) {
    return parseFloat(r);
  },
  time: function(r) {
    return +so(r);
  },
  trim: function(r) {
    return ne(r) ? ha(r) : r;
  }
});
function iH(r) {
  return Goe.get(r);
}
var nH = {
  lt: function(r, e) {
    return r < e;
  },
  lte: function(r, e) {
    return r <= e;
  },
  gt: function(r, e) {
    return r > e;
  },
  gte: function(r, e) {
    return r >= e;
  }
}, Boe = (
  /** @class */
  function() {
    function r(e, t) {
      if (!ut(t)) {
        var i = "";
        vt(i);
      }
      this._opFn = nH[e], this._rvalFloat = Fo(t);
    }
    return r.prototype.evaluate = function(e) {
      return ut(e) ? this._opFn(e, this._rvalFloat) : this._opFn(Fo(e), this._rvalFloat);
    }, r;
  }()
), aH = (
  /** @class */
  function() {
    function r(e, t) {
      var i = e === "desc";
      this._resultLT = i ? 1 : -1, t == null && (t = i ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0;
    }
    return r.prototype.evaluate = function(e, t) {
      var i = ut(e) ? e : Fo(e), n = ut(t) ? t : Fo(t), a = isNaN(i), o = isNaN(n);
      if (a && (i = this._incomparable), o && (n = this._incomparable), a && o) {
        var s = ne(e), l = ne(t);
        s && (i = l ? e : 0), l && (n = s ? t : 0);
      }
      return i < n ? this._resultLT : i > n ? -this._resultLT : 0;
    }, r;
  }()
), Voe = (
  /** @class */
  function() {
    function r(e, t) {
      this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = Fo(t);
    }
    return r.prototype.evaluate = function(e) {
      var t = e === this._rval;
      if (!t) {
        var i = typeof e;
        i !== this._rvalTypeof && (i === "number" || this._rvalTypeof === "number") && (t = Fo(e) === this._rvalFloat);
      }
      return this._isEQ ? t : !t;
    }, r;
  }()
);
function Foe(r, e) {
  return r === "eq" || r === "ne" ? new Voe(r === "eq", e) : oe(nH, r) ? new Boe(r, e) : null;
}
var Xoe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getRawData = function() {
      throw new Error("not supported");
    }, r.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, r.prototype.cloneRawData = function() {
    }, r.prototype.getDimensionInfo = function(e) {
    }, r.prototype.cloneAllDimensionInfo = function() {
    }, r.prototype.count = function() {
    }, r.prototype.retrieveValue = function(e, t) {
    }, r.prototype.retrieveValueFromItem = function(e, t) {
    }, r.prototype.convertValue = function(e, t) {
      return Xs(e, t);
    }, r;
  }()
);
function Yoe(r, e) {
  var t = new Xoe(), i = r.data, n = t.sourceFormat = r.sourceFormat, a = r.startIndex, o = "";
  r.seriesLayoutBy !== Ja && vt(o);
  var s = [], l = {}, u = r.dimensionsDefine;
  if (u)
    w(u, function(g, v) {
      var O = g.name, m = {
        index: v,
        name: O,
        displayName: g.displayName
      };
      if (s.push(m), O != null) {
        var E = "";
        oe(l, O) && vt(E), l[O] = m;
      }
    });
  else
    for (var h = 0; h < r.dimensionsDetectedCount; h++)
      s.push({
        index: h
      });
  var c = eH(n, Ja);
  e.__isBuiltIn && (t.getRawDataItem = function(g) {
    return c(i, a, s, g);
  }, t.getRawData = ae(Hoe, null, r)), t.cloneRawData = ae(Woe, null, r);
  var f = tH(n, Ja);
  t.count = ae(f, null, i, a, s);
  var d = rH(n);
  t.retrieveValue = function(g, v) {
    var O = c(i, a, s, g);
    return p(O, v);
  };
  var p = t.retrieveValueFromItem = function(g, v) {
    if (g != null) {
      var O = s[v];
      if (O)
        return d(g, v, O.name);
    }
  };
  return t.getDimensionInfo = ae(zoe, null, s, l), t.cloneAllDimensionInfo = ae(Zoe, null, s), t;
}
function Hoe(r) {
  var e = r.sourceFormat;
  if (!ox(e)) {
    var t = "";
    vt(t);
  }
  return r.data;
}
function Woe(r) {
  var e = r.sourceFormat, t = r.data;
  if (!ox(e)) {
    var i = "";
    vt(i);
  }
  if (e === fi) {
    for (var n = [], a = 0, o = t.length; a < o; a++)
      n.push(t[a].slice());
    return n;
  } else if (e === Jn) {
    for (var n = [], a = 0, o = t.length; a < o; a++)
      n.push(V({}, t[a]));
    return n;
  }
}
function zoe(r, e, t) {
  if (t != null) {
    if (ut(t) || !isNaN(t) && !oe(e, t))
      return r[t];
    if (oe(e, t))
      return e[t];
  }
}
function Zoe(r) {
  return Se(r);
}
var oH = ce();
function qoe(r) {
  r = Se(r);
  var e = r.type, t = "";
  e || vt(t);
  var i = e.split(":");
  i.length !== 2 && vt(t);
  var n = !1;
  i[0] === "echarts" && (e = i[1], n = !0), r.__isBuiltIn = n, oH.set(e, r);
}
function joe(r, e, t) {
  var i = At(r), n = i.length, a = "";
  n || vt(a);
  for (var o = 0, s = n; o < s; o++) {
    var l = i[o];
    e = Koe(l, e), o !== s - 1 && (e.length = Math.max(e.length, 1));
  }
  return e;
}
function Koe(r, e, t, i) {
  var n = "";
  e.length || vt(n), be(r) || vt(n);
  var a = r.type, o = oH.get(a);
  o || vt(n);
  var s = Y(e, function(u) {
    return Yoe(u, o);
  }), l = At(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: Se(r.config)
  }));
  return Y(l, function(u, h) {
    var c = "";
    be(u) || vt(c), u.data || vt(c);
    var f = jY(u.data);
    ox(f) || vt(c);
    var d, p = e[0];
    if (p && h === 0 && !u.dimensions) {
      var g = p.startIndex;
      g && (u.data = p.data.slice(0, g).concat(u.data)), d = {
        seriesLayoutBy: Ja,
        sourceHeader: g,
        dimensions: p.metaRawOption.dimensions
      };
    } else
      d = {
        seriesLayoutBy: Ja,
        sourceHeader: 0,
        dimensions: u.dimensions
      };
    return uC(u.data, d, null);
  });
}
function ox(r) {
  return r === fi || r === Jn;
}
var kS = "undefined", Joe = typeof Uint32Array === kS ? Array : Uint32Array, ese = typeof Uint16Array === kS ? Array : Uint16Array, sH = typeof Int32Array === kS ? Array : Int32Array, VD = typeof Float64Array === kS ? Array : Float64Array, lH = {
  float: VD,
  int: sH,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: VD
}, Ly;
function td(r) {
  return r > 65535 ? Joe : ese;
}
function Fh() {
  return [1 / 0, -1 / 0];
}
function tse(r) {
  var e = r.constructor;
  return e === Array ? r.slice() : new e(r);
}
function FD(r, e, t, i, n) {
  var a = lH[t || "float"];
  if (n) {
    var o = r[e], s = o && o.length;
    if (s !== i) {
      for (var l = new a(i), u = 0; u < s; u++)
        l[u] = o[u];
      r[e] = l;
    }
  } else
    r[e] = new a(i);
}
var hC = (
  /** @class */
  function() {
    function r() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = ce();
    }
    return r.prototype.initData = function(e, t, i) {
      this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var n = e.getSource(), a = this.defaultDimValueGetter = Ly[n.sourceFormat];
      this._dimValueGetter = i || a, this._rawExtent = [], KY(n), this._dimensions = Y(t, function(o) {
        return {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: o.type,
          property: o.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, r.prototype.getProvider = function() {
      return this._provider;
    }, r.prototype.getSource = function() {
      return this._provider.getSource();
    }, r.prototype.ensureCalculationDimension = function(e, t) {
      var i = this._calcDimNameToIdx, n = this._dimensions, a = i.get(e);
      if (a != null) {
        if (n[a].type === t)
          return a;
      } else
        a = n.length;
      return n[a] = {
        type: t
      }, i.set(e, a), this._chunks[a] = new lH[t || "float"](this._rawCount), this._rawExtent[a] = Fh(), a;
    }, r.prototype.collectOrdinalMeta = function(e, t) {
      var i = this._chunks[e], n = this._dimensions[e], a = this._rawExtent, o = n.ordinalOffset || 0, s = i.length;
      o === 0 && (a[e] = Fh());
      for (var l = a[e], u = o; u < s; u++) {
        var h = i[u] = t.parseAndCollect(i[u]);
        isNaN(h) || (l[0] = Math.min(h, l[0]), l[1] = Math.max(h, l[1]));
      }
      n.ordinalMeta = t, n.ordinalOffset = s, n.type = "ordinal";
    }, r.prototype.getOrdinalMeta = function(e) {
      var t = this._dimensions[e], i = t.ordinalMeta;
      return i;
    }, r.prototype.getDimensionProperty = function(e) {
      var t = this._dimensions[e];
      return t && t.property;
    }, r.prototype.appendData = function(e) {
      var t = this._provider, i = this.count();
      t.appendData(e);
      var n = t.count();
      return t.persistent || (n += i), i < n && this._initDataFromProvider(i, n, !0), [i, n];
    }, r.prototype.appendValues = function(e, t) {
      for (var i = this._chunks, n = this._dimensions, a = n.length, o = this._rawExtent, s = this.count(), l = s + Math.max(e.length, t || 0), u = 0; u < a; u++) {
        var h = n[u];
        FD(i, u, h.type, l, !0);
      }
      for (var c = [], f = s; f < l; f++)
        for (var d = f - s, p = 0; p < a; p++) {
          var h = n[p], g = Ly.arrayRows.call(this, e[d] || c, h.property, d, p);
          i[p][f] = g;
          var v = o[p];
          g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, r.prototype._initDataFromProvider = function(e, t, i) {
      for (var n = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = Y(o, function(m) {
        return m.property;
      }), h = 0; h < s; h++) {
        var c = o[h];
        l[h] || (l[h] = Fh()), FD(a, h, c.type, t, i);
      }
      if (n.fillStorage)
        n.fillStorage(e, t, a, l);
      else
        for (var f = [], d = e; d < t; d++) {
          f = n.getItem(d, f);
          for (var p = 0; p < s; p++) {
            var g = a[p], v = this._dimValueGetter(f, u[p], d, p);
            g[d] = v;
            var O = l[p];
            v < O[0] && (O[0] = v), v > O[1] && (O[1] = v);
          }
        }
      !n.persistent && n.clean && n.clean(), this._rawCount = this._count = t, this._extent = [];
    }, r.prototype.count = function() {
      return this._count;
    }, r.prototype.get = function(e, t) {
      if (!(t >= 0 && t < this._count))
        return NaN;
      var i = this._chunks[e];
      return i ? i[this.getRawIndex(t)] : NaN;
    }, r.prototype.getValues = function(e, t) {
      var i = [], n = [];
      if (t == null) {
        t = e, e = [];
        for (var a = 0; a < this._dimensions.length; a++)
          n.push(a);
      } else
        n = e;
      for (var a = 0, o = n.length; a < o; a++)
        i.push(this.get(n[a], t));
      return i;
    }, r.prototype.getByRawIndex = function(e, t) {
      if (!(t >= 0 && t < this._rawCount))
        return NaN;
      var i = this._chunks[e];
      return i ? i[t] : NaN;
    }, r.prototype.getSum = function(e) {
      var t = this._chunks[e], i = 0;
      if (t)
        for (var n = 0, a = this.count(); n < a; n++) {
          var o = this.get(e, n);
          isNaN(o) || (i += o);
        }
      return i;
    }, r.prototype.getMedian = function(e) {
      var t = [];
      this.each([e], function(a) {
        isNaN(a) || t.push(a);
      });
      var i = t.sort(function(a, o) {
        return a - o;
      }), n = this.count();
      return n === 0 ? 0 : n % 2 === 1 ? i[(n - 1) / 2] : (i[n / 2] + i[n / 2 - 1]) / 2;
    }, r.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0)
        return -1;
      if (!this._indices)
        return e;
      var t = this._indices, i = t[e];
      if (i != null && i < this._count && i === e)
        return e;
      for (var n = 0, a = this._count - 1; n <= a; ) {
        var o = (n + a) / 2 | 0;
        if (t[o] < e)
          n = o + 1;
        else if (t[o] > e)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, r.prototype.indicesOfNearest = function(e, t, i) {
      var n = this._chunks, a = n[e], o = [];
      if (!a)
        return o;
      i == null && (i = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, h = 0, c = this.count(); h < c; h++) {
        var f = this.getRawIndex(h), d = t - a[f], p = Math.abs(d);
        p <= i && ((p < s || p === s && d >= 0 && l < 0) && (s = p, l = d, u = 0), d === l && (o[u++] = h));
      }
      return o.length = u, o;
    }, r.prototype.getIndices = function() {
      var e, t = this._indices;
      if (t) {
        var i = t.constructor, n = this._count;
        if (i === Array) {
          e = new i(n);
          for (var a = 0; a < n; a++)
            e[a] = t[a];
        } else
          e = new i(t.buffer, 0, n);
      } else {
        var i = td(this._rawCount);
        e = new i(this.count());
        for (var a = 0; a < e.length; a++)
          e[a] = a;
      }
      return e;
    }, r.prototype.filter = function(e, t) {
      if (!this._count)
        return this;
      for (var i = this.clone(), n = i.count(), a = td(i._rawCount), o = new a(n), s = [], l = e.length, u = 0, h = e[0], c = i._chunks, f = 0; f < n; f++) {
        var d = void 0, p = i.getRawIndex(f);
        if (l === 0)
          d = t(f);
        else if (l === 1) {
          var g = c[h][p];
          d = t(g, f);
        } else {
          for (var v = 0; v < l; v++)
            s[v] = c[e[v]][p];
          s[v] = f, d = t.apply(null, s);
        }
        d && (o[u++] = p);
      }
      return u < n && (i._indices = o), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
    }, r.prototype.selectRange = function(e) {
      var t = this.clone(), i = t._count;
      if (!i)
        return this;
      var n = He(e), a = n.length;
      if (!a)
        return this;
      var o = t.count(), s = td(t._rawCount), l = new s(o), u = 0, h = n[0], c = e[h][0], f = e[h][1], d = t._chunks, p = !1;
      if (!t._indices) {
        var g = 0;
        if (a === 1) {
          for (var v = d[n[0]], O = 0; O < i; O++) {
            var m = v[O];
            (m >= c && m <= f || isNaN(m)) && (l[u++] = g), g++;
          }
          p = !0;
        } else if (a === 2) {
          for (var v = d[n[0]], E = d[n[1]], b = e[n[1]][0], T = e[n[1]][1], O = 0; O < i; O++) {
            var m = v[O], S = E[O];
            (m >= c && m <= f || isNaN(m)) && (S >= b && S <= T || isNaN(S)) && (l[u++] = g), g++;
          }
          p = !0;
        }
      }
      if (!p)
        if (a === 1)
          for (var O = 0; O < o; O++) {
            var y = t.getRawIndex(O), m = d[n[0]][y];
            (m >= c && m <= f || isNaN(m)) && (l[u++] = y);
          }
        else
          for (var O = 0; O < o; O++) {
            for (var A = !0, y = t.getRawIndex(O), C = 0; C < a; C++) {
              var _ = n[C], m = d[_][y];
              (m < e[_][0] || m > e[_][1]) && (A = !1);
            }
            A && (l[u++] = t.getRawIndex(O));
          }
      return u < o && (t._indices = l), t._count = u, t._extent = [], t._updateGetRawIdx(), t;
    }, r.prototype.map = function(e, t) {
      var i = this.clone(e);
      return this._updateDims(i, e, t), i;
    }, r.prototype.modify = function(e, t) {
      this._updateDims(this, e, t);
    }, r.prototype._updateDims = function(e, t, i) {
      for (var n = e._chunks, a = [], o = t.length, s = e.count(), l = [], u = e._rawExtent, h = 0; h < t.length; h++)
        u[t[h]] = Fh();
      for (var c = 0; c < s; c++) {
        for (var f = e.getRawIndex(c), d = 0; d < o; d++)
          l[d] = n[t[d]][f];
        l[o] = c;
        var p = i && i.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var h = 0; h < p.length; h++) {
            var g = t[h], v = p[h], O = u[g], m = n[g];
            m && (m[f] = v), v < O[0] && (O[0] = v), v > O[1] && (O[1] = v);
          }
        }
      }
    }, r.prototype.lttbDownSample = function(e, t) {
      var i = this.clone([e], !0), n = i._chunks, a = n[e], o = this.count(), s = 0, l = Math.floor(1 / t), u = this.getRawIndex(0), h, c, f, d = new (td(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      d[s++] = u;
      for (var p = 1; p < o - 1; p += l) {
        for (var g = Math.min(p + l, o - 1), v = Math.min(p + l * 2, o), O = (v + g) / 2, m = 0, E = g; E < v; E++) {
          var b = this.getRawIndex(E), T = a[b];
          isNaN(T) || (m += T);
        }
        m /= v - g;
        var S = p, y = Math.min(p + l, o), A = p - 1, C = a[u];
        h = -1, f = S;
        for (var _ = -1, I = 0, E = S; E < y; E++) {
          var b = this.getRawIndex(E), T = a[b];
          if (isNaN(T)) {
            I++, _ < 0 && (_ = b);
            continue;
          }
          c = Math.abs((A - O) * (T - C) - (A - E) * (m - C)), c > h && (h = c, f = b);
        }
        I > 0 && I < y - S && (d[s++] = Math.min(_, f), f = Math.max(_, f)), d[s++] = f, u = f;
      }
      return d[s++] = this.getRawIndex(o - 1), i._count = s, i._indices = d, i.getRawIndex = this._getRawIdx, i;
    }, r.prototype.downSample = function(e, t, i, n) {
      for (var a = this.clone([e], !0), o = a._chunks, s = [], l = Math.floor(1 / t), u = o[e], h = this.count(), c = a._rawExtent[e] = Fh(), f = new (td(this._rawCount))(Math.ceil(h / l)), d = 0, p = 0; p < h; p += l) {
        l > h - p && (l = h - p, s.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          s[g] = u[v];
        }
        var O = i(s), m = this.getRawIndex(Math.min(p + n(s, O) || 0, h - 1));
        u[m] = O, O < c[0] && (c[0] = O), O > c[1] && (c[1] = O), f[d++] = m;
      }
      return a._count = d, a._indices = f, a._updateGetRawIdx(), a;
    }, r.prototype.each = function(e, t) {
      if (this._count)
        for (var i = e.length, n = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (i) {
            case 0:
              t(a);
              break;
            case 1:
              t(n[e[0]][s], a);
              break;
            case 2:
              t(n[e[0]][s], n[e[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < i; l++)
                u[l] = n[e[l]][s];
              u[l] = a, t.apply(null, u);
          }
        }
    }, r.prototype.getDataExtent = function(e) {
      var t = this._chunks[e], i = Fh();
      if (!t)
        return i;
      var n = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[e].slice();
      if (o = this._extent[e], o)
        return o.slice();
      o = i;
      for (var s = o[0], l = o[1], u = 0; u < n; u++) {
        var h = this.getRawIndex(u), c = t[h];
        c < s && (s = c), c > l && (l = c);
      }
      return o = [s, l], this._extent[e] = o, o;
    }, r.prototype.getRawDataItem = function(e) {
      var t = this.getRawIndex(e);
      if (this._provider.persistent)
        return this._provider.getItem(t);
      for (var i = [], n = this._chunks, a = 0; a < n.length; a++)
        i.push(n[a][t]);
      return i;
    }, r.prototype.clone = function(e, t) {
      var i = new r(), n = this._chunks, a = e && no(e, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < n.length; o++)
          i._chunks[o] = a[o] ? tse(n[o]) : n[o];
      else
        i._chunks = n;
      return this._copyCommonProps(i), t || (i._indices = this._cloneIndices()), i._updateGetRawIdx(), i;
    }, r.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = Se(this._extent), e._rawExtent = Se(this._rawExtent);
    }, r.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, t = void 0;
        if (e === Array) {
          var i = this._indices.length;
          t = new e(i);
          for (var n = 0; n < i; n++)
            t[n] = this._indices[n];
        } else
          t = new e(this._indices);
        return t;
      }
      return null;
    }, r.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, r.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, r.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, r.internalField = function() {
      function e(t, i, n, a) {
        return Xs(t[a], this._dimensions[a]);
      }
      Ly = {
        arrayRows: e,
        objectRows: function(t, i, n, a) {
          return Xs(t[i], this._dimensions[a]);
        },
        keyedColumns: e,
        original: function(t, i, n, a) {
          var o = t && (t.value == null ? t : t.value);
          return Xs(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(t, i, n, a) {
          return t[a];
        }
      };
    }(), r;
  }()
), uH = (
  /** @class */
  function() {
    function r(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = e;
    }
    return r.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, r.prototype._setLocalSource = function(e, t) {
      this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, r.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, r.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, r.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, t = this._getUpstreamSourceManagers(), i = !!t.length, n, a;
      if (jv(e)) {
        var o = e, s = void 0, l = void 0, u = void 0;
        if (i) {
          var h = t[0];
          h.prepareSource(), u = h.getSource(), s = u.data, l = u.sourceFormat, a = [h._getVersionSign()];
        } else
          s = o.get("data", !0), l = vn(s) ? Fs : Kn, a = [];
        var c = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, d = ke(c.seriesLayoutBy, f.seriesLayoutBy) || null, p = ke(c.sourceHeader, f.sourceHeader), g = ke(c.dimensions, f.dimensions), v = d !== f.seriesLayoutBy || !!p != !!f.sourceHeader || g;
        n = v ? [uC(s, {
          seriesLayoutBy: d,
          sourceHeader: p,
          dimensions: g
        }, l)] : [];
      } else {
        var O = e;
        if (i) {
          var m = this._applyTransform(t);
          n = m.sourceList, a = m.upstreamSignList;
        } else {
          var E = O.get("source", !0);
          n = [uC(E, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      this._setLocalSource(n, a);
    }, r.prototype._applyTransform = function(e) {
      var t = this._sourceHost, i = t.get("transform", !0), n = t.get("fromTransformResult", !0);
      if (n != null) {
        var a = "";
        e.length !== 1 && YD(a);
      }
      var o, s = [], l = [];
      return w(e, function(u) {
        u.prepareSource();
        var h = u.getSource(n || 0), c = "";
        n != null && !h && YD(c), s.push(h), l.push(u._getVersionSign());
      }), i ? o = joe(i, s, {
        datasetIndex: t.componentIndex
      }) : n != null && (o = [Noe(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, r.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var i = e[t];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          i._isDirty() || this._upstreamSignList[t] !== i._getVersionSign()
        )
          return !0;
      }
    }, r.prototype.getSource = function(e) {
      e = e || 0;
      var t = this._sourceList[e];
      if (!t) {
        var i = this._getUpstreamSourceManagers();
        return i[0] && i[0].getSource(e);
      }
      return t;
    }, r.prototype.getSharedDataStore = function(e) {
      var t = e.makeStoreSchema();
      return this._innerGetDataStore(t.dimensions, e.source, t.hash);
    }, r.prototype._innerGetDataStore = function(e, t, i) {
      var n = 0, a = this._storeList, o = a[n];
      o || (o = a[n] = {});
      var s = o[i];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        jv(this._sourceHost) && l ? s = l._innerGetDataStore(e, t, i) : (s = new hC(), s.initData(new JY(t, e.length), e)), o[i] = s;
      }
      return s;
    }, r.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if (jv(e)) {
        var t = ex(e);
        return t ? [t.getSourceManager()] : [];
      } else
        return Y(noe(e), function(i) {
          return i.getSourceManager();
        });
    }, r.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, t, i, n;
      if (jv(e))
        t = e.get("seriesLayoutBy", !0), i = e.get("sourceHeader", !0), n = e.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = e;
        t = a.get("seriesLayoutBy", !0), i = a.get("sourceHeader", !0), n = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: t,
        sourceHeader: i,
        dimensions: n
      };
    }, r;
  }()
);
function XD(r) {
  var e = r.option.transform;
  e && uE(r.option.transform);
}
function jv(r) {
  return r.mainType === "series";
}
function YD(r) {
  throw new Error(r);
}
var hH = "line-height:1";
function cH(r, e) {
  var t = r.color || "#6e7079", i = r.fontSize || 12, n = r.fontWeight || "400", a = r.color || "#464646", o = r.fontSize || 14, s = r.fontWeight || "900";
  return e === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Di(i + "") + "px;color:" + Di(t) + ";font-weight:" + Di(n + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Di(o + "") + "px;color:" + Di(a) + ";font-weight:" + Di(s + "")
  } : {
    nameStyle: {
      fontSize: i,
      fill: t,
      fontWeight: n
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var rse = [0, 10, 20, 30], ise = ["", `
`, `

`, `


`];
function _r(r, e) {
  return e.type = r, e;
}
function cC(r) {
  return r.type === "section";
}
function fH(r) {
  return cC(r) ? nse : ase;
}
function dH(r) {
  if (cC(r)) {
    var e = 0, t = r.blocks.length, i = t > 1 || t > 0 && !r.noHeader;
    return w(r.blocks, function(n) {
      var a = dH(n);
      a >= e && (e = a + +(i && // 0 always can not be readable gap level.
      (!a || cC(n) && !n.noHeader)));
    }), e;
  }
  return 0;
}
function nse(r, e, t, i) {
  var n = e.noHeader, a = ose(dH(e)), o = [], s = e.blocks || [];
  _i(!s || X(s)), s = s || [];
  var l = r.orderMode;
  if (e.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (oe(u, l)) {
      var h = new aH(u[l], null);
      s.sort(function(p, g) {
        return h.evaluate(p.sortParam, g.sortParam);
      });
    } else
      l === "seriesDesc" && s.reverse();
  }
  w(s, function(p, g) {
    var v = e.valueFormatter, O = fH(p)(
      // Inherit valueFormatter
      v ? V(V({}, r), {
        valueFormatter: v
      }) : r,
      p,
      g > 0 ? a.html : 0,
      i
    );
    O != null && o.push(O);
  });
  var c = r.renderMode === "richText" ? o.join(a.richText) : fC(o.join(""), n ? t : a.html);
  if (n)
    return c;
  var f = oC(e.header, "ordinal", r.useUTC), d = cH(i, r.renderMode).nameStyle;
  return r.renderMode === "richText" ? pH(r, f, d) + a.richText + c : fC('<div style="' + d + ";" + hH + ';">' + Di(f) + "</div>" + c, t);
}
function ase(r, e, t, i) {
  var n = r.renderMode, a = e.noName, o = e.noValue, s = !e.markerType, l = e.name, u = r.useUTC, h = e.valueFormatter || r.valueFormatter || function(b) {
    return b = X(b) ? b : [b], Y(b, function(T, S) {
      return oC(T, X(d) ? d[S] : d, u);
    });
  };
  if (!(a && o)) {
    var c = s ? "" : r.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", n), f = a ? "" : oC(l, "ordinal", u), d = e.valueType, p = o ? [] : h(e.value), g = !s || !a, v = !s && a, O = cH(i, n), m = O.nameStyle, E = O.valueStyle;
    return n === "richText" ? (s ? "" : c) + (a ? "" : pH(r, f, m)) + (o ? "" : use(r, p, g, v, E)) : fC((s ? "" : c) + (a ? "" : sse(f, !s, m)) + (o ? "" : lse(p, g, v, E)), t);
  }
}
function HD(r, e, t, i, n, a) {
  if (r) {
    var o = fH(r), s = {
      useUTC: n,
      renderMode: t,
      orderMode: i,
      markupStyleCreator: e,
      valueFormatter: r.valueFormatter
    };
    return o(s, r, 0, a);
  }
}
function ose(r) {
  return {
    html: rse[r],
    richText: ise[r]
  };
}
function fC(r, e) {
  var t = '<div style="clear:both"></div>', i = "margin: " + e + "px 0 0";
  return '<div style="' + i + ";" + hH + ';">' + r + t + "</div>";
}
function sse(r, e, t) {
  var i = e ? "margin-left:2px" : "";
  return '<span style="' + t + ";" + i + '">' + Di(r) + "</span>";
}
function lse(r, e, t, i) {
  var n = t ? "10px" : "20px", a = e ? "float:right;margin-left:" + n : "";
  return r = X(r) ? r : [r], '<span style="' + a + ";" + i + '">' + Y(r, function(o) {
    return Di(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function pH(r, e, t) {
  return r.markupStyleCreator.wrapRichTextStyle(e, t);
}
function use(r, e, t, i, n) {
  var a = [n], o = i ? 10 : 20;
  return t && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), r.markupStyleCreator.wrapRichTextStyle(X(e) ? e.join("  ") : e, a);
}
function gH(r, e) {
  var t = r.getData().getItemVisual(e, "style"), i = t[r.visualDrawType];
  return nh(i);
}
function vH(r, e) {
  var t = r.get("padding");
  return t ?? (e === "richText" ? [8, 10] : 10);
}
var Dy = (
  /** @class */
  function() {
    function r() {
      this.richTextStyles = {}, this._nextStyleNameId = gX();
    }
    return r.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, r.prototype.makeTooltipMarker = function(e, t, i) {
      var n = i === "richText" ? this._generateStyleName() : null, a = jae({
        color: t,
        type: e,
        renderMode: i,
        markerId: n
      });
      return ne(a) ? a : (this.richTextStyles[n] = a.style, a.content);
    }, r.prototype.wrapRichTextStyle = function(e, t) {
      var i = {};
      X(t) ? w(t, function(a) {
        return V(i, a);
      }) : V(i, t);
      var n = this._generateStyleName();
      return this.richTextStyles[n] = i, "{" + n + "|" + e + "}";
    }, r;
  }()
);
function OH(r) {
  var e = r.series, t = r.dataIndex, i = r.multipleSeries, n = e.getData(), a = n.mapDimensionsAll("defaultedTooltip"), o = a.length, s = e.getRawValue(t), l = X(s), u = gH(e, t), h, c, f, d;
  if (o > 1 || l && !o) {
    var p = hse(s, e, t, a, u);
    h = p.inlineValues, c = p.inlineValueTypes, f = p.blocks, d = p.inlineValues[0];
  } else if (o) {
    var g = n.getDimensionInfo(a[0]);
    d = h = Kc(n, t, a[0]), c = g.type;
  } else
    d = h = l ? s[0] : s;
  var v = NI(e), O = v && e.name || "", m = n.getName(t), E = i ? O : m;
  return _r("section", {
    header: O,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: i || !v,
    sortParam: d,
    blocks: [_r("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: E,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !ha(E),
      value: h,
      valueType: c
    })].concat(f || [])
  });
}
function hse(r, e, t, i, n) {
  var a = e.getData(), o = no(r, function(c, f, d) {
    var p = a.getDimensionInfo(d);
    return c = c || p && p.tooltip !== !1 && p.displayName != null;
  }, !1), s = [], l = [], u = [];
  i.length ? w(i, function(c) {
    h(Kc(a, t, c), c);
  }) : w(r, h);
  function h(c, f) {
    var d = a.getDimensionInfo(f);
    !d || d.otherDims.tooltip === !1 || (o ? u.push(_r("nameValue", {
      markerType: "subItem",
      markerColor: n,
      name: d.displayName,
      value: c,
      valueType: d.type
    })) : (s.push(c), l.push(d.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var fs = at();
function Kv(r, e) {
  return r.getName(e) || r.getId(e);
}
var Tm = "__universalTransitionEnabled", QS = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._selectedDataIndicesMap = {}, t;
    }
    return e.prototype.init = function(t, i, n) {
      this.seriesIndex = this.componentIndex, this.dataTask = cp({
        count: fse,
        reset: dse
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(t, n);
      var a = fs(this).sourceManager = new uH(this);
      a.prepareSource();
      var o = this.getInitialData(t, n);
      zD(o, this), this.dataTask.context.data = o, fs(this).dataBeforeProcessed = o, WD(this), this._initSelectedMapFromData(o);
    }, e.prototype.mergeDefaultAndTheme = function(t, i) {
      var n = qp(this), a = n ? _f(t) : {}, o = this.subType;
      ot.hasClass(o) && (o += "Series"), Qe(t, i.getTheme().get(this.subType)), Qe(t, this.getDefaultOption()), eh(t, "label", ["show"]), this.fillDataTextStyle(t.data), n && ol(t, a, n);
    }, e.prototype.mergeOption = function(t, i) {
      t = Qe(this.option, t, !0), this.fillDataTextStyle(t.data);
      var n = qp(this);
      n && ol(this.option, t, n);
      var a = fs(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(t, i);
      zD(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, fs(this).dataBeforeProcessed = o, WD(this), this._initSelectedMapFromData(o);
    }, e.prototype.fillDataTextStyle = function(t) {
      if (t && !vn(t))
        for (var i = ["show"], n = 0; n < t.length; n++)
          t[n] && t[n].label && eh(t[n], "label", i);
    }, e.prototype.getInitialData = function(t, i) {
    }, e.prototype.appendData = function(t) {
      var i = this.getRawData();
      i.appendData(t.data);
    }, e.prototype.getData = function(t) {
      var i = dC(this);
      if (i) {
        var n = i.context.data;
        return t == null ? n : n.getLinkedData(t);
      } else
        return fs(this).data;
    }, e.prototype.getAllData = function() {
      var t = this.getData();
      return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{
        data: t
      }];
    }, e.prototype.setData = function(t) {
      var i = dC(this);
      if (i) {
        var n = i.context;
        n.outputData = t, i !== this.dataTask && (n.data = t);
      }
      fs(this).data = t;
    }, e.prototype.getEncode = function() {
      var t = this.get("encode", !0);
      if (t)
        return ce(t);
    }, e.prototype.getSourceManager = function() {
      return fs(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return fs(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var t = this.get("colorBy");
      return t || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var t = this.coordinateSystem;
      return t && t.getBaseAxis && t.getBaseAxis();
    }, e.prototype.formatTooltip = function(t, i, n) {
      return OH({
        series: this,
        dataIndex: t,
        multipleSeries: i
      });
    }, e.prototype.isAnimationEnabled = function() {
      var t = this.ecModel;
      if (st.node && !(t && t.ssr))
        return !1;
      var i = this.getShallow("animation");
      return i && this.getData().count() > this.getShallow("animationThreshold") && (i = !1), !!i;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(t, i, n) {
      var a = this.ecModel, o = tx.prototype.getColorFromPalette.call(this, t, i, n);
      return o || (o = a.getColorFromPalette(t, i, n)), o;
    }, e.prototype.coordDimToDataDim = function(t) {
      return this.getRawData().mapDimensionsAll(t);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(t, i) {
      this._innerSelect(this.getData(i), t);
    }, e.prototype.unselect = function(t, i) {
      var n = this.option.selectedMap;
      if (n) {
        var a = this.option.selectedMode, o = this.getData(i);
        if (a === "series" || n === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < t.length; s++) {
          var l = t[s], u = Kv(o, l);
          n[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(t, i) {
      for (var n = [], a = 0; a < t.length; a++)
        n[0] = t[a], this.isSelected(t[a], i) ? this.unselect(n, i) : this.select(n, i);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var t = this._selectedDataIndicesMap, i = He(t), n = [], a = 0; a < i.length; a++) {
        var o = t[i[a]];
        o >= 0 && n.push(o);
      }
      return n;
    }, e.prototype.isSelected = function(t, i) {
      var n = this.option.selectedMap;
      if (!n)
        return !1;
      var a = this.getData(i);
      return (n === "all" || n[Kv(a, t)]) && !a.getItemModel(t).get(["select", "disabled"]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[Tm])
        return !0;
      var t = this.option.universalTransition;
      return t ? t === !0 ? !0 : t && t.enabled : !1;
    }, e.prototype._innerSelect = function(t, i) {
      var n, a, o = this.option, s = o.selectedMode, l = i.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          be(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, h = 0; h < l; h++) {
            var c = i[h], f = Kv(t, c);
            u[f] = !0, this._selectedDataIndicesMap[f] = t.getRawIndex(c);
          }
        } else if (s === "single" || s === !0) {
          var d = i[l - 1], f = Kv(t, d);
          o.selectedMap = (n = {}, n[f] = !0, n), this._selectedDataIndicesMap = (a = {}, a[f] = t.getRawIndex(d), a);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(t) {
      if (!this.option.selectedMap) {
        var i = [];
        t.hasItemOption && t.each(function(n) {
          var a = t.getRawDataItem(n);
          a && a.selected && i.push(n);
        }), i.length > 0 && this._innerSelect(t, i);
      }
    }, e.registerClass = function(t) {
      return ot.registerClass(t);
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
    }(), e;
  }(ot)
);
hr(QS, ax);
hr(QS, tx);
yX(QS, ot);
function WD(r) {
  var e = r.name;
  NI(r) || (r.name = cse(r) || e);
}
function cse(r) {
  var e = r.getRawData(), t = e.mapDimensionsAll("seriesName"), i = [];
  return w(t, function(n) {
    var a = e.getDimensionInfo(n);
    a.displayName && i.push(a.displayName);
  }), i.join(" ");
}
function fse(r) {
  return r.model.getRawData().count();
}
function dse(r) {
  var e = r.model;
  return e.setData(e.getRawData().cloneShallow()), pse;
}
function pse(r, e) {
  e.outputData && r.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
}
function zD(r, e) {
  w(hE(r.CHANGABLE_METHODS, r.DOWNSAMPLE_METHODS), function(t) {
    r.wrapMethod(t, Ie(gse, e));
  });
}
function gse(r, e) {
  var t = dC(r);
  return t && t.setOutputEnd((e || this).count()), e;
}
function dC(r) {
  var e = (r.ecModel || {}).scheduler, t = e && e.getPipeline(r.uid);
  if (t) {
    var i = t.currentTask;
    if (i) {
      var n = i.agentStubMap;
      n && (i = n.get(r.uid));
    }
    return i;
  }
}
const Xt = QS;
var sx = (
  /** @class */
  function() {
    function r() {
      this.group = new ye(), this.uid = Af("viewComponent");
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, i, n) {
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, i, n) {
    }, r.prototype.updateLayout = function(e, t, i, n) {
    }, r.prototype.updateVisual = function(e, t, i, n) {
    }, r.prototype.toggleBlurSeries = function(e, t, i) {
    }, r.prototype.eachRendered = function(e) {
      var t = this.group;
      t && t.traverse(e);
    }, r;
  }()
);
DI(sx);
mS(sx);
const Zt = sx;
function wf() {
  var r = at();
  return function(e) {
    var t = r(e), i = e.pipelineContext, n = !!t.large, a = !!t.progressiveRender, o = t.large = !!(i && i.large), s = t.progressiveRender = !!(i && i.progressiveRender);
    return (n !== o || a !== s) && "reset";
  };
}
var mH = at(), vse = wf(), lx = (
  /** @class */
  function() {
    function r() {
      this.group = new ye(), this.uid = Af("viewChart"), this.renderTask = cp({
        plan: Ose,
        reset: mse
      }), this.renderTask.context = {
        view: this
      };
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, i, n) {
    }, r.prototype.highlight = function(e, t, i, n) {
      var a = e.getData(n && n.dataType);
      a && qD(a, n, "emphasis");
    }, r.prototype.downplay = function(e, t, i, n) {
      var a = e.getData(n && n.dataType);
      a && qD(a, n, "normal");
    }, r.prototype.remove = function(e, t) {
      this.group.removeAll();
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, i, n) {
      this.render(e, t, i, n);
    }, r.prototype.updateLayout = function(e, t, i, n) {
      this.render(e, t, i, n);
    }, r.prototype.updateVisual = function(e, t, i, n) {
      this.render(e, t, i, n);
    }, r.prototype.eachRendered = function(e) {
      Tl(this.group, e);
    }, r.markUpdateMethod = function(e, t) {
      mH(e).updateMethod = t;
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.type = "chart";
    }(), r;
  }()
);
function ZD(r, e, t) {
  r && Hp(r) && (e === "emphasis" ? Xo : Yo)(r, t);
}
function qD(r, e, t) {
  var i = th(r, e), n = e && e.highlightKey != null ? Xne(e.highlightKey) : null;
  i != null ? w(At(i), function(a) {
    ZD(r.getItemGraphicEl(a), t, n);
  }) : r.eachItemGraphicEl(function(a) {
    ZD(a, t, n);
  });
}
DI(lx);
mS(lx);
function Ose(r) {
  return vse(r.model);
}
function mse(r) {
  var e = r.model, t = r.ecModel, i = r.api, n = r.payload, a = e.pipelineContext.progressiveRender, o = r.view, s = n && mH(n).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](e, t, i, n), Ese[l];
}
var Ese = {
  incrementalPrepareRender: {
    progress: function(r, e) {
      e.view.incrementalRender(r, e.model, e.ecModel, e.api, e.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(r, e) {
      e.view.render(e.model, e.ecModel, e.api, e.payload);
    }
  }
};
const Mt = lx;
var _E = "\0__throttleOriginMethod", jD = "\0__throttleRate", KD = "\0__throttleType";
function ux(r, e, t) {
  var i, n = 0, a = 0, o = null, s, l, u, h;
  e = e || 0;
  function c() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, r.apply(l, u || []);
  }
  var f = function() {
    for (var d = [], p = 0; p < arguments.length; p++)
      d[p] = arguments[p];
    i = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
    var g = h || e, v = h || t;
    h = null, s = i - (v ? n : a) - g, clearTimeout(o), v ? o = setTimeout(c, g) : s >= 0 ? c() : o = setTimeout(c, -s), n = i;
  };
  return f.clear = function() {
    o && (clearTimeout(o), o = null);
  }, f.debounceNextCall = function(d) {
    h = d;
  }, f;
}
function Pf(r, e, t, i) {
  var n = r[e];
  if (n) {
    var a = n[_E] || n, o = n[KD], s = n[jD];
    if (s !== t || o !== i) {
      if (t == null || !i)
        return r[e] = a;
      n = r[e] = ux(a, t, i === "debounce"), n[_E] = a, n[KD] = i, n[jD] = t;
    }
    return n;
  }
}
function Kp(r, e) {
  var t = r[e];
  t && t[_E] && (t.clear && t.clear(), r[e] = t[_E]);
}
var JD = at(), eM = {
  itemStyle: rh(TY, !0),
  lineStyle: rh(SY, !0)
}, bse = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function EH(r, e) {
  var t = r.visualStyleMapper || eM[e];
  return t || (console.warn("Unknown style type '" + e + "'."), eM.itemStyle);
}
function bH(r, e) {
  var t = r.visualDrawType || bse[e];
  return t || (console.warn("Unknown style type '" + e + "'."), "fill");
}
var Sse = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, e) {
    var t = r.getData(), i = r.visualStyleAccessPath || "itemStyle", n = r.getModel(i), a = EH(r, i), o = a(n), s = n.getShallow("decal");
    s && (t.setVisual("decal", s), s.dirty = !0);
    var l = bH(r, i), u = o[l], h = ve(u) ? u : null, c = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || h || c) {
      var f = r.getColorFromPalette(
        // TODO series count changed.
        r.name,
        null,
        e.getSeriesCount()
      );
      o[l] || (o[l] = f, t.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || ve(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || ve(o.stroke) ? f : o.stroke;
    }
    if (t.setVisual("style", o), t.setVisual("drawType", l), !e.isSeriesFiltered(r) && h)
      return t.setVisual("colorFromPalette", !1), {
        dataEach: function(d, p) {
          var g = r.getDataParams(p), v = V({}, o);
          v[l] = h(g), d.setItemVisual(p, "style", v);
        }
      };
  }
}, rd = new Dt(), Tse = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, e) {
    if (!(r.ignoreStyleOnData || e.isSeriesFiltered(r))) {
      var t = r.getData(), i = r.visualStyleAccessPath || "itemStyle", n = EH(r, i), a = t.getVisual("drawType");
      return {
        dataEach: t.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[i]) {
            rd.option = l[i];
            var u = n(rd), h = o.ensureUniqueItemVisual(s, "style");
            V(h, u), rd.option.decal && (o.setItemVisual(s, "decal", rd.option.decal), rd.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, yse = {
  performRawSeries: !0,
  overallReset: function(r) {
    var e = ce();
    r.eachSeries(function(t) {
      var i = t.getColorBy();
      if (!t.isColorBySeries()) {
        var n = t.type + "-" + i, a = e.get(n);
        a || (a = {}, e.set(n, a)), JD(t).scope = a;
      }
    }), r.eachSeries(function(t) {
      if (!(t.isColorBySeries() || r.isSeriesFiltered(t))) {
        var i = t.getRawData(), n = {}, a = t.getData(), o = JD(t).scope, s = t.visualStyleAccessPath || "itemStyle", l = bH(t, s);
        a.each(function(u) {
          var h = a.getRawIndex(u);
          n[h] = u;
        }), i.each(function(u) {
          var h = n[u], c = a.getItemVisual(h, "colorFromPalette");
          if (c) {
            var f = a.ensureUniqueItemVisual(h, "style"), d = i.getName(u) || u + "", p = i.count();
            f[l] = t.getColorFromPalette(d, o, p);
          }
        });
      }
    });
  }
}, Jv = Math.PI;
function Rse(r, e) {
  e = e || {}, me(e, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var t = new ye(), i = new nt({
    style: {
      fill: e.maskColor
    },
    zlevel: e.zlevel,
    z: 1e4
  });
  t.add(i);
  var n = new lt({
    style: {
      text: e.text,
      fill: e.textColor,
      fontSize: e.fontSize,
      fontWeight: e.fontWeight,
      fontStyle: e.fontStyle,
      fontFamily: e.fontFamily
    },
    zlevel: e.zlevel,
    z: 10001
  }), a = new nt({
    style: {
      fill: "none"
    },
    textContent: n,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: e.zlevel,
    z: 10001
  });
  t.add(a);
  var o;
  return e.showSpinner && (o = new FI({
    shape: {
      startAngle: -Jv / 2,
      endAngle: -Jv / 2 + 0.1,
      r: e.spinnerRadius
    },
    style: {
      stroke: e.color,
      lineCap: "round",
      lineWidth: e.lineWidth
    },
    zlevel: e.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: Jv * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: Jv * 3 / 2
  }).delay(300).start("circularInOut"), t.add(o)), t.resize = function() {
    var s = n.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (r.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), h = r.getHeight() / 2;
    e.showSpinner && o.setShape({
      cx: u,
      cy: h
    }), a.setShape({
      x: u - l,
      y: h - l,
      width: l * 2,
      height: l * 2
    }), i.setShape({
      x: 0,
      y: 0,
      width: r.getWidth(),
      height: r.getHeight()
    });
  }, t.resize(), t;
}
var Ase = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      this._stageTaskMap = ce(), this.ecInstance = e, this.api = t, i = this._dataProcessorHandlers = i.slice(), n = this._visualHandlers = n.slice(), this._allHandlers = i.concat(n);
    }
    return r.prototype.restoreData = function(e, t) {
      e.restoreData(t), this._stageTaskMap.each(function(i) {
        var n = i.overallTask;
        n && n.dirty();
      });
    }, r.prototype.getPerformArgs = function(e, t) {
      if (e.__pipeline) {
        var i = this._pipelineMap.get(e.__pipeline.id), n = i.context, a = !t && i.progressiveEnabled && (!n || n.progressiveRender) && e.__idxInPipeline > i.blockIndex, o = a ? i.step : null, s = n && n.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, r.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, r.prototype.updateStreamModes = function(e, t) {
      var i = this._pipelineMap.get(e.uid), n = e.getData(), a = n.count(), o = i.progressiveEnabled && t.incrementalPrepareRender && a >= i.threshold, s = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null;
      e.pipelineContext = i.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, r.prototype.restorePipelines = function(e) {
      var t = this, i = t._pipelineMap = ce();
      e.eachSeries(function(n) {
        var a = n.getProgressive(), o = n.uid;
        i.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: n.getProgressiveThreshold(),
          progressiveEnabled: a && !(n.preventIncremental && n.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), t._pipe(n, n.dataTask);
      });
    }, r.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, t = this.api.getModel(), i = this.api;
      w(this._allHandlers, function(n) {
        var a = e.get(n.uid) || e.set(n.uid, {}), o = "";
        _i(!(n.reset && n.overallReset), o), n.reset && this._createSeriesStageTask(n, a, t, i), n.overallReset && this._createOverallStageTask(n, a, t, i);
      }, this);
    }, r.prototype.prepareView = function(e, t, i, n) {
      var a = e.renderTask, o = a.context;
      o.model = t, o.ecModel = i, o.api = n, a.__block = !e.incrementalPrepareRender, this._pipe(t, a);
    }, r.prototype.performDataProcessorTasks = function(e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, {
        block: !0
      });
    }, r.prototype.performVisualTasks = function(e, t, i) {
      this._performStageTasks(this._visualHandlers, e, t, i);
    }, r.prototype._performStageTasks = function(e, t, i, n) {
      n = n || {};
      var a = !1, o = this;
      w(e, function(l, u) {
        if (!(n.visualType && n.visualType !== l.visualType)) {
          var h = o._stageTaskMap.get(l.uid), c = h.seriesTaskMap, f = h.overallTask;
          if (f) {
            var d, p = f.agentStubMap;
            p.each(function(v) {
              s(n, v) && (v.dirty(), d = !0);
            }), d && f.dirty(), o.updatePayload(f, i);
            var g = o.getPerformArgs(f, n.block);
            p.each(function(v) {
              v.perform(g);
            }), f.perform(g) && (a = !0);
          } else
            c && c.each(function(v, O) {
              s(n, v) && v.dirty();
              var m = o.getPerformArgs(v, n.block);
              m.skip = !l.performRawSeries && t.isSeriesFiltered(v.context.model), o.updatePayload(v, i), v.perform(m) && (a = !0);
            });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, r.prototype.performSeriesTasks = function(e) {
      var t;
      e.eachSeries(function(i) {
        t = i.dataTask.perform() || t;
      }), this.unfinished = t || this.unfinished;
    }, r.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var t = e.tail;
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline;
            break;
          }
          t = t.getUpstream();
        } while (t);
      });
    }, r.prototype.updatePayload = function(e, t) {
      t !== "remain" && (e.context.payload = t);
    }, r.prototype._createSeriesStageTask = function(e, t, i, n) {
      var a = this, o = t.seriesTaskMap, s = t.seriesTaskMap = ce(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? i.eachRawSeries(h) : l ? i.eachRawSeriesByType(l, h) : u && u(i, n).each(h);
      function h(c) {
        var f = c.uid, d = s.set(f, o && o.get(f) || cp({
          plan: wse,
          reset: Pse,
          count: Lse
        }));
        d.context = {
          model: c,
          ecModel: i,
          api: n,
          // PENDING: `useClearVisual` not used?
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: a
        }, a._pipe(c, d);
      }
    }, r.prototype._createOverallStageTask = function(e, t, i, n) {
      var a = this, o = t.overallTask = t.overallTask || cp({
        reset: Cse
      });
      o.context = {
        ecModel: i,
        api: n,
        overallReset: e.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = ce(), u = e.seriesType, h = e.getTargetSeries, c = !0, f = !1, d = "";
      _i(!e.createOnAllSeries, d), u ? i.eachRawSeriesByType(u, p) : h ? h(i, n).each(p) : (c = !1, w(i.getSeries(), p));
      function p(g) {
        var v = g.uid, O = l.set(v, s && s.get(v) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (f = !0, cp({
          reset: _se,
          onDirty: xse
        })));
        O.context = {
          model: g,
          overallProgress: c
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, O.agent = o, O.__block = c, a._pipe(g, O);
      }
      f && o.dirty();
    }, r.prototype._pipe = function(e, t) {
      var i = e.uid, n = this._pipelineMap.get(i);
      !n.head && (n.head = t), n.tail && n.tail.pipe(t), n.tail = t, t.__idxInPipeline = n.count++, t.__pipeline = n;
    }, r.wrapStageHandler = function(e, t) {
      return ve(e) && (e = {
        overallReset: e,
        seriesType: Dse(e)
      }), e.uid = Af("stageHandler"), t && (e.visualType = t), e;
    }, r;
  }()
);
function Cse(r) {
  r.overallReset(r.ecModel, r.api, r.payload);
}
function _se(r) {
  return r.overallProgress && Ise;
}
function Ise() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function xse() {
  this.agent && this.agent.dirty();
}
function wse(r) {
  return r.plan ? r.plan(r.model, r.ecModel, r.api, r.payload) : null;
}
function Pse(r) {
  r.useClearVisual && r.data.clearAllVisual();
  var e = r.resetDefines = At(r.reset(r.model, r.ecModel, r.api, r.payload));
  return e.length > 1 ? Y(e, function(t, i) {
    return SH(i);
  }) : Nse;
}
var Nse = SH(0);
function SH(r) {
  return function(e, t) {
    var i = t.data, n = t.resetDefines[r];
    if (n && n.dataEach)
      for (var a = e.start; a < e.end; a++)
        n.dataEach(i, a);
    else
      n && n.progress && n.progress(e, i);
  };
}
function Lse(r) {
  return r.data.count();
}
function Dse(r) {
  IE = null;
  try {
    r(Jp, TH);
  } catch {
  }
  return IE;
}
var Jp = {}, TH = {}, IE;
yH(Jp, WY);
yH(TH, zY);
Jp.eachSeriesByType = Jp.eachRawSeriesByType = function(r) {
  IE = r;
};
Jp.eachComponent = function(r) {
  r.mainType === "series" && r.subType && (IE = r.subType);
};
function yH(r, e) {
  for (var t in e.prototype)
    r[t] = ar;
}
const RH = Ase;
var tM = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const Mse = {
  color: tM,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], tM]
};
var vi = "#B9B8CE", rM = "#100C2A", eO = function() {
  return {
    axisLine: {
      lineStyle: {
        color: vi
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, iM = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], AH = {
  darkMode: !0,
  color: iM,
  backgroundColor: rM,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: vi
    }
  },
  textStyle: {
    color: vi
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: vi
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: vi
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: vi
    }
  },
  timeline: {
    lineStyle: {
      color: vi
    },
    label: {
      color: vi
    },
    controlStyle: {
      color: vi,
      borderColor: vi
    }
  },
  calendar: {
    itemStyle: {
      color: rM
    },
    dayLabel: {
      color: vi
    },
    monthLabel: {
      color: vi
    },
    yearLabel: {
      color: vi
    }
  },
  timeAxis: eO(),
  logAxis: eO(),
  valueAxis: eO(),
  categoryAxis: eO(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: iM
  },
  gauge: {
    title: {
      color: vi
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: vi
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
AH.categoryAxis.splitLine.show = !1;
const kse = AH;
var Qse = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.normalizeQuery = function(e) {
      var t = {}, i = {}, n = {};
      if (ne(e)) {
        var a = Ha(e);
        t.mainType = a.main || null, t.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        w(e, function(l, u) {
          for (var h = !1, c = 0; c < o.length; c++) {
            var f = o[c], d = u.lastIndexOf(f);
            if (d > 0 && d === u.length - f.length) {
              var p = u.slice(0, d);
              p !== "data" && (t.mainType = p, t[f.toLowerCase()] = l, h = !0);
            }
          }
          s.hasOwnProperty(u) && (i[u] = l, h = !0), h || (n[u] = l);
        });
      }
      return {
        cptQuery: t,
        dataQuery: i,
        otherQuery: n
      };
    }, r.prototype.filter = function(e, t) {
      var i = this.eventInfo;
      if (!i)
        return !0;
      var n = i.targetEl, a = i.packedEvent, o = i.model, s = i.view;
      if (!o || !s)
        return !0;
      var l = t.cptQuery, u = t.dataQuery;
      return h(l, o, "mainType") && h(l, o, "subType") && h(l, o, "index", "componentIndex") && h(l, o, "name") && h(l, o, "id") && h(u, a, "name") && h(u, a, "dataIndex") && h(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, t.otherQuery, n, a));
      function h(c, f, d, p) {
        return c[d] == null || f[p || d] === c[d];
      }
    }, r.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, r;
  }()
), pC = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], nM = pC.concat(["symbolKeepAspect"]), Use = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    var t = r.getData();
    if (r.legendIcon && t.setVisual("legendIcon", r.legendIcon), !r.hasSymbolVisual)
      return;
    for (var i = {}, n = {}, a = !1, o = 0; o < pC.length; o++) {
      var s = pC[o], l = r.get(s);
      ve(l) ? (a = !0, n[s] = l) : i[s] = l;
    }
    if (i.symbol = i.symbol || r.defaultSymbol, t.setVisual(V({
      legendIcon: r.legendIcon || i.symbol,
      symbolKeepAspect: r.get("symbolKeepAspect")
    }, i)), e.isSeriesFiltered(r))
      return;
    var u = He(n);
    function h(c, f) {
      for (var d = r.getRawValue(f), p = r.getDataParams(f), g = 0; g < u.length; g++) {
        var v = u[g];
        c.setItemVisual(f, v, n[v](d, p));
      }
    }
    return {
      dataEach: a ? h : null
    };
  }
}, $se = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    if (!r.hasSymbolVisual || e.isSeriesFiltered(r))
      return;
    var t = r.getData();
    function i(n, a) {
      for (var o = n.getItemModel(a), s = 0; s < nM.length; s++) {
        var l = nM[s], u = o.getShallow(l, !0);
        u != null && n.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: t.hasItemOption ? i : null
    };
  }
};
function hx(r, e, t) {
  switch (t) {
    case "color":
      var i = r.getItemVisual(e, "style");
      return i[r.getVisual("drawType")];
    case "opacity":
      return r.getItemVisual(e, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getItemVisual(e, t);
  }
}
function Yg(r, e) {
  switch (e) {
    case "color":
      var t = r.getVisual("style");
      return t[r.getVisual("drawType")];
    case "opacity":
      return r.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getVisual(e);
  }
}
function CH(r, e, t, i) {
  switch (t) {
    case "color":
      var n = r.ensureUniqueItemVisual(e, "style");
      n[r.getVisual("drawType")] = i, r.setItemVisual(e, "colorFromPalette", !1);
      break;
    case "opacity":
      r.ensureUniqueItemVisual(e, "style").opacity = i;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      r.setItemVisual(e, t, i);
      break;
  }
}
function _H(r, e) {
  function t(i, n) {
    var a = [];
    return i.eachComponent({
      mainType: "series",
      subType: r,
      query: n
    }, function(o) {
      a.push(o.seriesIndex);
    }), a;
  }
  w([[r + "ToggleSelect", "toggleSelect"], [r + "Select", "select"], [r + "UnSelect", "unselect"]], function(i) {
    e(i[0], function(n, a, o) {
      n = V({}, n), o.dispatchAction(V(n, {
        type: i[1],
        seriesIndex: t(a, n)
      }));
    });
  });
}
function Xh(r, e, t, i, n) {
  var a = r + e;
  t.isSilent(a) || i.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = n.selected, h = 0; h < u.length; h++)
      if (u[h].seriesIndex === s) {
        var c = o.getData(), f = th(c, n.fromActionPayload);
        t.trigger(a, {
          type: a,
          seriesId: o.id,
          name: X(f) ? c.getName(f[0]) : c.getName(f),
          selected: ne(l) ? l : V({}, l)
        });
      }
  });
}
function Gse(r, e, t) {
  r.on("selectchanged", function(i) {
    var n = t.getModel();
    i.isFromClick ? (Xh("map", "selectchanged", e, n, i), Xh("pie", "selectchanged", e, n, i)) : i.fromAction === "select" ? (Xh("map", "selected", e, n, i), Xh("pie", "selected", e, n, i)) : i.fromAction === "unselect" && (Xh("map", "unselected", e, n, i), Xh("pie", "unselected", e, n, i));
  });
}
function Ru(r, e, t) {
  for (var i; r && !(e(r) && (i = r, t)); )
    r = r.__hostTarget || r.parent;
  return i;
}
var Bse = Math.round(Math.random() * 9), Vse = typeof Object.defineProperty == "function", Fse = function() {
  function r() {
    this._id = "__ec_inner_" + Bse++;
  }
  return r.prototype.get = function(e) {
    return this._guard(e)[this._id];
  }, r.prototype.set = function(e, t) {
    var i = this._guard(e);
    return Vse ? Object.defineProperty(i, this._id, {
      value: t,
      enumerable: !1,
      configurable: !0
    }) : i[this._id] = t, this;
  }, r.prototype.delete = function(e) {
    return this.has(e) ? (delete this._guard(e)[this._id], !0) : !1;
  }, r.prototype.has = function(e) {
    return !!this._guard(e)[this._id];
  }, r.prototype._guard = function(e) {
    if (e !== Object(e))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return e;
  }, r;
}();
const Xse = Fse;
var Yse = Fe.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.cx, i = e.cy, n = e.width / 2, a = e.height / 2;
    r.moveTo(t, i - a), r.lineTo(t + n, i + a), r.lineTo(t - n, i + a), r.closePath();
  }
}), Hse = Fe.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.cx, i = e.cy, n = e.width / 2, a = e.height / 2;
    r.moveTo(t, i - a), r.lineTo(t + n, i), r.lineTo(t, i + a), r.lineTo(t - n, i), r.closePath();
  }
}), Wse = Fe.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.x, i = e.y, n = e.width / 5 * 3, a = Math.max(n, e.height), o = n / 2, s = o * o / (a - o), l = i - a + o + s, u = Math.asin(s / o), h = Math.cos(u) * o, c = Math.sin(u), f = Math.cos(u), d = o * 0.6, p = o * 0.7;
    r.moveTo(t - h, l + s), r.arc(t, l, o, Math.PI - u, Math.PI * 2 + u), r.bezierCurveTo(t + h - c * d, l + s + f * d, t, i - p, t, i), r.bezierCurveTo(t, i - p, t - h + c * d, l + s + f * d, t - h, l + s), r.closePath();
  }
}), zse = Fe.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.height, i = e.width, n = e.x, a = e.y, o = i / 3 * 2;
    r.moveTo(n, a), r.lineTo(n + o, a + t), r.lineTo(n, a + t / 4 * 3), r.lineTo(n - o, a + t), r.lineTo(n, a), r.closePath();
  }
}), Zse = {
  line: Mr,
  rect: nt,
  roundRect: nt,
  square: nt,
  circle: uo,
  diamond: Hse,
  pin: Wse,
  arrow: zse,
  triangle: Yse
}, qse = {
  line: function(r, e, t, i, n) {
    n.x1 = r, n.y1 = e + i / 2, n.x2 = r + t, n.y2 = e + i / 2;
  },
  rect: function(r, e, t, i, n) {
    n.x = r, n.y = e, n.width = t, n.height = i;
  },
  roundRect: function(r, e, t, i, n) {
    n.x = r, n.y = e, n.width = t, n.height = i, n.r = Math.min(t, i) / 4;
  },
  square: function(r, e, t, i, n) {
    var a = Math.min(t, i);
    n.x = r, n.y = e, n.width = a, n.height = a;
  },
  circle: function(r, e, t, i, n) {
    n.cx = r + t / 2, n.cy = e + i / 2, n.r = Math.min(t, i) / 2;
  },
  diamond: function(r, e, t, i, n) {
    n.cx = r + t / 2, n.cy = e + i / 2, n.width = t, n.height = i;
  },
  pin: function(r, e, t, i, n) {
    n.x = r + t / 2, n.y = e + i / 2, n.width = t, n.height = i;
  },
  arrow: function(r, e, t, i, n) {
    n.x = r + t / 2, n.y = e + i / 2, n.width = t, n.height = i;
  },
  triangle: function(r, e, t, i, n) {
    n.cx = r + t / 2, n.cy = e + i / 2, n.width = t, n.height = i;
  }
}, xE = {};
w(Zse, function(r, e) {
  xE[e] = new r();
});
var jse = Fe.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(r, e, t) {
    var i = OE(r, e, t), n = this.shape;
    return n && n.symbolType === "pin" && e.position === "inside" && (i.y = t.y + t.height * 0.4), i;
  },
  buildPath: function(r, e, t) {
    var i = e.symbolType;
    if (i !== "none") {
      var n = xE[i];
      n || (i = "rect", n = xE[i]), qse[i](e.x, e.y, e.width, e.height, n.shape), n.buildPath(r, n.shape, t);
    }
  }
});
function Kse(r, e) {
  if (this.type !== "image") {
    var t = this.style;
    this.__isEmptyBrush ? (t.stroke = r, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = r : t.fill = r, this.markRedraw();
  }
}
function ur(r, e, t, i, n, a, o) {
  var s = r.indexOf("empty") === 0;
  s && (r = r.substr(5, 1).toLowerCase() + r.substr(6));
  var l;
  return r.indexOf("image://") === 0 ? l = fY(r.slice(8), new Ue(e, t, i, n), o ? "center" : "cover") : r.indexOf("path://") === 0 ? l = CS(r.slice(7), {}, new Ue(e, t, i, n), o ? "center" : "cover") : l = new jse({
    shape: {
      symbolType: r,
      x: e,
      y: t,
      width: i,
      height: n
    }
  }), l.__isEmptyBrush = s, l.setColor = Kse, a && l.setColor(a), l;
}
function Nf(r) {
  return X(r) || (r = [+r, +r]), [r[0] || 0, r[1] || 0];
}
function Th(r, e) {
  if (r != null)
    return X(r) || (r = [r, r]), [K(r[0], e[0]) || 0, K(ke(r[1], r[0]), e[1]) || 0];
}
function Au(r) {
  return isFinite(r);
}
function Jse(r, e, t) {
  var i = e.x == null ? 0 : e.x, n = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, o = e.y2 == null ? 0 : e.y2;
  e.global || (i = i * t.width + t.x, n = n * t.width + t.x, a = a * t.height + t.y, o = o * t.height + t.y), i = Au(i) ? i : 0, n = Au(n) ? n : 1, a = Au(a) ? a : 0, o = Au(o) ? o : 0;
  var s = r.createLinearGradient(i, a, n, o);
  return s;
}
function ele(r, e, t) {
  var i = t.width, n = t.height, a = Math.min(i, n), o = e.x == null ? 0.5 : e.x, s = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
  e.global || (o = o * i + t.x, s = s * n + t.y, l = l * a), o = Au(o) ? o : 0.5, s = Au(s) ? s : 0.5, l = l >= 0 && Au(l) ? l : 0.5;
  var u = r.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function gC(r, e, t) {
  for (var i = e.type === "radial" ? ele(r, e, t) : Jse(r, e, t), n = e.colorStops, a = 0; a < n.length; a++)
    i.addColorStop(n[a].offset, n[a].color);
  return i;
}
function tle(r, e) {
  if (r === e || !r && !e)
    return !1;
  if (!r || !e || r.length !== e.length)
    return !0;
  for (var t = 0; t < r.length; t++)
    if (r[t] !== e[t])
      return !0;
  return !1;
}
function tO(r) {
  return parseInt(r, 10);
}
function Oc(r, e, t) {
  var i = ["width", "height"][e], n = ["clientWidth", "clientHeight"][e], a = ["paddingLeft", "paddingTop"][e], o = ["paddingRight", "paddingBottom"][e];
  if (t[i] != null && t[i] !== "auto")
    return parseFloat(t[i]);
  var s = document.defaultView.getComputedStyle(r);
  return (r[n] || tO(s[i]) || tO(r.style[i])) - (tO(s[a]) || 0) - (tO(s[o]) || 0) | 0;
}
function rle(r, e) {
  return !r || r === "solid" || !(e > 0) ? null : r === "dashed" ? [4 * e, 2 * e] : r === "dotted" ? [e] : ut(r) ? [r] : X(r) ? r : null;
}
function cx(r) {
  var e = r.style, t = e.lineDash && e.lineWidth > 0 && rle(e.lineDash, e.lineWidth), i = e.lineDashOffset;
  if (t) {
    var n = e.strokeNoScale && r.getLineScale ? r.getLineScale() : 1;
    n && n !== 1 && (t = Y(t, function(a) {
      return a / n;
    }), i /= n);
  }
  return [t, i];
}
var ile = new lo(!0);
function wE(r) {
  var e = r.stroke;
  return !(e == null || e === "none" || !(r.lineWidth > 0));
}
function aM(r) {
  return typeof r == "string" && r !== "none";
}
function PE(r) {
  var e = r.fill;
  return e != null && e !== "none";
}
function oM(r, e) {
  if (e.fillOpacity != null && e.fillOpacity !== 1) {
    var t = r.globalAlpha;
    r.globalAlpha = e.fillOpacity * e.opacity, r.fill(), r.globalAlpha = t;
  } else
    r.fill();
}
function sM(r, e) {
  if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
    var t = r.globalAlpha;
    r.globalAlpha = e.strokeOpacity * e.opacity, r.stroke(), r.globalAlpha = t;
  } else
    r.stroke();
}
function vC(r, e, t) {
  var i = MI(e.image, e.__image, t);
  if (ES(i)) {
    var n = r.createPattern(i, e.repeat || "repeat");
    if (typeof DOMMatrix == "function" && n && n.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * lm), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), n.setTransform(a);
    }
    return n;
  }
}
function nle(r, e, t, i) {
  var n, a = wE(t), o = PE(t), s = t.strokePercent, l = s < 1, u = !e.path;
  (!e.silent || l) && u && e.createPathProxy();
  var h = e.path || ile, c = e.__dirty;
  if (!i) {
    var f = t.fill, d = t.stroke, p = o && !!f.colorStops, g = a && !!d.colorStops, v = o && !!f.image, O = a && !!d.image, m = void 0, E = void 0, b = void 0, T = void 0, S = void 0;
    (p || g) && (S = e.getBoundingRect()), p && (m = c ? gC(r, f, S) : e.__canvasFillGradient, e.__canvasFillGradient = m), g && (E = c ? gC(r, d, S) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = E), v && (b = c || !e.__canvasFillPattern ? vC(r, f, e) : e.__canvasFillPattern, e.__canvasFillPattern = b), O && (T = c || !e.__canvasStrokePattern ? vC(r, d, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = b), p ? r.fillStyle = m : v && (b ? r.fillStyle = b : o = !1), g ? r.strokeStyle = E : O && (T ? r.strokeStyle = T : a = !1);
  }
  var y = e.getGlobalScale();
  h.setScale(y[0], y[1], e.segmentIgnoreThreshold);
  var A, C;
  r.setLineDash && t.lineDash && (n = cx(e), A = n[0], C = n[1]);
  var _ = !0;
  (u || c & oc) && (h.setDPR(r.dpr), l ? h.setContext(null) : (h.setContext(r), _ = !1), h.reset(), e.buildPath(h, e.shape, i), h.toStatic(), e.pathUpdated()), _ && h.rebuildPath(r, l ? s : 1), A && (r.setLineDash(A), r.lineDashOffset = C), i || (t.strokeFirst ? (a && sM(r, t), o && oM(r, t)) : (o && oM(r, t), a && sM(r, t))), A && r.setLineDash([]);
}
function ale(r, e, t) {
  var i = e.__image = MI(t.image, e.__image, e, e.onload);
  if (!(!i || !ES(i))) {
    var n = t.x || 0, a = t.y || 0, o = e.getWidth(), s = e.getHeight(), l = i.width / i.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = i.width, s = i.height), t.sWidth && t.sHeight) {
      var u = t.sx || 0, h = t.sy || 0;
      r.drawImage(i, u, h, t.sWidth, t.sHeight, n, a, o, s);
    } else if (t.sx && t.sy) {
      var u = t.sx, h = t.sy, c = o - u, f = s - h;
      r.drawImage(i, u, h, c, f, n, a, o, s);
    } else
      r.drawImage(i, n, a, o, s);
  }
}
function ole(r, e, t) {
  var i, n = t.text;
  if (n != null && (n += ""), n) {
    r.font = t.font || rl, r.textAlign = t.textAlign, r.textBaseline = t.textBaseline;
    var a = void 0, o = void 0;
    r.setLineDash && t.lineDash && (i = cx(e), a = i[0], o = i[1]), a && (r.setLineDash(a), r.lineDashOffset = o), t.strokeFirst ? (wE(t) && r.strokeText(n, t.x, t.y), PE(t) && r.fillText(n, t.x, t.y)) : (PE(t) && r.fillText(n, t.x, t.y), wE(t) && r.strokeText(n, t.x, t.y)), a && r.setLineDash([]);
  }
}
var lM = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], uM = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function IH(r, e, t, i, n) {
  var a = !1;
  if (!i && (t = t || {}, e === t))
    return !1;
  if (i || e.opacity !== t.opacity) {
    Ui(r, n), a = !0;
    var o = Math.max(Math.min(e.opacity, 1), 0);
    r.globalAlpha = isNaN(o) ? $u.opacity : o;
  }
  (i || e.blend !== t.blend) && (a || (Ui(r, n), a = !0), r.globalCompositeOperation = e.blend || $u.blend);
  for (var s = 0; s < lM.length; s++) {
    var l = lM[s];
    (i || e[l] !== t[l]) && (a || (Ui(r, n), a = !0), r[l] = r.dpr * (e[l] || 0));
  }
  return (i || e.shadowColor !== t.shadowColor) && (a || (Ui(r, n), a = !0), r.shadowColor = e.shadowColor || $u.shadowColor), a;
}
function hM(r, e, t, i, n) {
  var a = eg(e, n.inHover), o = i ? null : t && eg(t, n.inHover) || {};
  if (a === o)
    return !1;
  var s = IH(r, a, o, i, n);
  if ((i || a.fill !== o.fill) && (s || (Ui(r, n), s = !0), aM(a.fill) && (r.fillStyle = a.fill)), (i || a.stroke !== o.stroke) && (s || (Ui(r, n), s = !0), aM(a.stroke) && (r.strokeStyle = a.stroke)), (i || a.opacity !== o.opacity) && (s || (Ui(r, n), s = !0), r.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
    r.lineWidth !== u && (s || (Ui(r, n), s = !0), r.lineWidth = u);
  }
  for (var h = 0; h < uM.length; h++) {
    var c = uM[h], f = c[0];
    (i || a[f] !== o[f]) && (s || (Ui(r, n), s = !0), r[f] = a[f] || c[1]);
  }
  return s;
}
function sle(r, e, t, i, n) {
  return IH(r, eg(e, n.inHover), t && eg(t, n.inHover), i, n);
}
function xH(r, e) {
  var t = e.transform, i = r.dpr || 1;
  t ? r.setTransform(i * t[0], i * t[1], i * t[2], i * t[3], i * t[4], i * t[5]) : r.setTransform(i, 0, 0, i, 0, 0);
}
function lle(r, e, t) {
  for (var i = !1, n = 0; n < r.length; n++) {
    var a = r[n];
    i = i || a.isZeroArea(), xH(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip();
  }
  t.allClipped = i;
}
function ule(r, e) {
  return r && e ? r[0] !== e[0] || r[1] !== e[1] || r[2] !== e[2] || r[3] !== e[3] || r[4] !== e[4] || r[5] !== e[5] : !(!r && !e);
}
var cM = 1, fM = 2, dM = 3, pM = 4;
function hle(r) {
  var e = PE(r), t = wE(r);
  return !(r.lineDash || !(+e ^ +t) || e && typeof r.fill != "string" || t && typeof r.stroke != "string" || r.strokePercent < 1 || r.strokeOpacity < 1 || r.fillOpacity < 1);
}
function Ui(r, e) {
  e.batchFill && r.fill(), e.batchStroke && r.stroke(), e.batchFill = "", e.batchStroke = "";
}
function eg(r, e) {
  return e && r.__hoverStyle || r.style;
}
function wH(r, e) {
  Cu(r, e, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Cu(r, e, t, i) {
  var n = e.transform;
  if (!e.shouldBePainted(t.viewWidth, t.viewHeight, !1, !1)) {
    e.__dirty &= ~un, e.__isRendered = !1;
    return;
  }
  var a = e.__clipPaths, o = t.prevElClipPaths, s = !1, l = !1;
  if ((!o || tle(a, o)) && (o && o.length && (Ui(r, t), r.restore(), l = s = !0, t.prevElClipPaths = null, t.allClipped = !1, t.prevEl = null), a && a.length && (Ui(r, t), r.save(), lle(a, r, t), s = !0), t.prevElClipPaths = a), t.allClipped) {
    e.__isRendered = !1;
    return;
  }
  e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
  var u = t.prevEl;
  u || (l = s = !0);
  var h = e instanceof Fe && e.autoBatch && hle(e.style);
  s || ule(n, u.transform) ? (Ui(r, t), xH(r, e)) : h || Ui(r, t);
  var c = eg(e, t.inHover);
  e instanceof Fe ? (t.lastDrawType !== cM && (l = !0, t.lastDrawType = cM), hM(r, e, u, l, t), (!h || !t.batchFill && !t.batchStroke) && r.beginPath(), nle(r, e, c, h), h && (t.batchFill = c.fill || "", t.batchStroke = c.stroke || "")) : e instanceof Xp ? (t.lastDrawType !== dM && (l = !0, t.lastDrawType = dM), hM(r, e, u, l, t), ole(r, e, c)) : e instanceof qr ? (t.lastDrawType !== fM && (l = !0, t.lastDrawType = fM), sle(r, e, u, l, t), ale(r, e, c)) : e.getTemporalDisplayables && (t.lastDrawType !== pM && (l = !0, t.lastDrawType = pM), cle(r, e, t)), h && i && Ui(r, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = !0;
}
function cle(r, e, t) {
  var i = e.getDisplayables(), n = e.getTemporalDisplayables();
  r.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: t.viewWidth,
    viewHeight: t.viewHeight,
    inHover: t.inHover
  }, o, s;
  for (o = e.getCursor(), s = i.length; o < s; o++) {
    var l = i[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Cu(r, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, h = n.length; u < h; u++) {
    var l = n[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Cu(r, l, a, u === h - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  e.clearTemporalDisplayables(), e.notClear = !0, r.restore();
}
var My = new Xse(), gM = new kg(100), vM = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Jc(r, e) {
  if (r === "none")
    return null;
  var t = e.getDevicePixelRatio(), i = e.getZr(), n = i.painter.type === "svg";
  r.dirty && My.delete(r);
  var a = My.get(r);
  if (a)
    return a;
  var o = me(r, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = n ? 1 : 1 / t, My.set(r, s), r.dirty = !1, s;
  function l(u) {
    for (var h = [t], c = !0, f = 0; f < vM.length; ++f) {
      var d = o[vM[f]];
      if (d != null && !X(d) && !ne(d) && !ut(d) && typeof d != "boolean") {
        c = !1;
        break;
      }
      h.push(d);
    }
    var p;
    if (c) {
      p = h.join(",") + (n ? "-svg" : "");
      var g = gM.get(p);
      g && (n ? u.svgElement = g : u.image = g);
    }
    var v = NH(o.dashArrayX), O = fle(o.dashArrayY), m = PH(o.symbol), E = dle(v), b = LH(O), T = !n && il.createCanvas(), S = n && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, y = C(), A;
    T && (T.width = y.width * t, T.height = y.height * t, A = T.getContext("2d")), _(), c && gM.put(p, T || S), u.image = T, u.svgElement = S, u.svgWidth = y.width, u.svgHeight = y.height;
    function C() {
      for (var I = 1, x = 0, P = E.length; x < P; ++x)
        I = PL(I, E[x]);
      for (var N = 1, x = 0, P = m.length; x < P; ++x)
        N = PL(N, m[x].length);
      I *= N;
      var L = b * E.length * m.length;
      return {
        width: Math.max(1, Math.min(I, o.maxTileWidth)),
        height: Math.max(1, Math.min(L, o.maxTileHeight))
      };
    }
    function _() {
      A && (A.clearRect(0, 0, T.width, T.height), o.backgroundColor && (A.fillStyle = o.backgroundColor, A.fillRect(0, 0, T.width, T.height)));
      for (var I = 0, x = 0; x < O.length; ++x)
        I += O[x];
      if (I <= 0)
        return;
      for (var P = -b, N = 0, L = 0, D = 0; P < y.height; ) {
        if (N % 2 === 0) {
          for (var $ = L / 2 % m.length, k = 0, G = 0, F = 0; k < y.width * 2; ) {
            for (var q = 0, x = 0; x < v[D].length; ++x)
              q += v[D][x];
            if (q <= 0)
              break;
            if (G % 2 === 0) {
              var re = (1 - o.symbolSize) * 0.5, fe = k + v[D][G] * re, de = P + O[N] * re, $e = v[D][G] * o.symbolSize, Pe = O[N] * o.symbolSize, Ne = F / 2 % m[$].length;
              Ee(fe, de, $e, Pe, m[$][Ne]);
            }
            k += v[D][G], ++F, ++G, G === v[D].length && (G = 0);
          }
          ++D, D === v.length && (D = 0);
        }
        P += O[N], ++L, ++N, N === O.length && (N = 0);
      }
      function Ee(xe, Ce, ue, M, Q) {
        var B = n ? 1 : t, W = ur(Q, xe * B, Ce * B, ue * B, M * B, o.color, o.symbolKeepAspect);
        if (n) {
          var H = i.painter.renderOneToVNode(W);
          H && S.children.push(H);
        } else
          wH(A, W);
      }
    }
  }
}
function PH(r) {
  if (!r || r.length === 0)
    return [["rect"]];
  if (ne(r))
    return [[r]];
  for (var e = !0, t = 0; t < r.length; ++t)
    if (!ne(r[t])) {
      e = !1;
      break;
    }
  if (e)
    return PH([r]);
  for (var i = [], t = 0; t < r.length; ++t)
    ne(r[t]) ? i.push([r[t]]) : i.push(r[t]);
  return i;
}
function NH(r) {
  if (!r || r.length === 0)
    return [[0, 0]];
  if (ut(r)) {
    var e = Math.ceil(r);
    return [[e, e]];
  }
  for (var t = !0, i = 0; i < r.length; ++i)
    if (!ut(r[i])) {
      t = !1;
      break;
    }
  if (t)
    return NH([r]);
  for (var n = [], i = 0; i < r.length; ++i)
    if (ut(r[i])) {
      var e = Math.ceil(r[i]);
      n.push([e, e]);
    } else {
      var e = Y(r[i], function(s) {
        return Math.ceil(s);
      });
      e.length % 2 === 1 ? n.push(e.concat(e)) : n.push(e);
    }
  return n;
}
function fle(r) {
  if (!r || typeof r == "object" && r.length === 0)
    return [0, 0];
  if (ut(r)) {
    var e = Math.ceil(r);
    return [e, e];
  }
  var t = Y(r, function(i) {
    return Math.ceil(i);
  });
  return r.length % 2 ? t.concat(t) : t;
}
function dle(r) {
  return Y(r, function(e) {
    return LH(e);
  });
}
function LH(r) {
  for (var e = 0, t = 0; t < r.length; ++t)
    e += r[t];
  return r.length % 2 === 1 ? e * 2 : e;
}
function ple(r, e) {
  r.eachRawSeries(function(t) {
    if (!r.isSeriesFiltered(t)) {
      var i = t.getData();
      i.hasItemVisual() && i.each(function(o) {
        var s = i.getItemVisual(o, "decal");
        if (s) {
          var l = i.ensureUniqueItemVisual(o, "style");
          l.decal = Jc(s, e);
        }
      });
      var n = i.getVisual("decal");
      if (n) {
        var a = i.getVisual("style");
        a.decal = Jc(n, e);
      }
    }
  });
}
var gle = new jn();
const Na = gle;
var DH = {};
function vle(r, e) {
  DH[r] = e;
}
function Ole(r) {
  return DH[r];
}
var mle = 1, Ele = 800, ble = 900, Sle = 1e3, Tle = 2e3, yle = 5e3, MH = 1e3, Rle = 1100, fx = 2e3, kH = 3e3, Ale = 4e3, US = 4500, Cle = 4600, _le = 5e3, Ile = 6e3, QH = 7e3, xle = {
  PROCESSOR: {
    FILTER: Sle,
    SERIES_FILTER: Ele,
    STATISTIC: yle
  },
  VISUAL: {
    LAYOUT: MH,
    PROGRESSIVE_LAYOUT: Rle,
    GLOBAL: fx,
    CHART: kH,
    POST_CHART_LAYOUT: Cle,
    COMPONENT: Ale,
    BRUSH: _le,
    CHART_ITEM: US,
    ARIA: Ile,
    DECAL: QH
  }
}, ri = "__flagInMainProcess", Ni = "__pendingUpdate", ky = "__needsUpdateStatus", OM = /^[a-zA-Z0-9_]+$/;
function UH(r) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    if (this.isDisposed()) {
      this.id;
      return;
    }
    return GH(this, r, e);
  };
}
function $H(r) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return GH(this, r, e);
  };
}
function GH(r, e, t) {
  return t[0] = t[0] && t[0].toLowerCase(), jn.prototype[e].apply(r, t);
}
var BH = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(jn)
), VH = BH.prototype;
VH.on = $H("on");
VH.off = $H("off");
var Yh, Qy, rO, ds, Uy, $y, Gy, id, nd, mM, EM, By, bM, iO, SM, Tn, TM, wle = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this, new Qse()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], n = n || {}, ne(i) && (i = FH[i]), a._dom = t;
      var o = "canvas", s = "auto", l = !1, u = a._zr = _L(t, {
        renderer: n.renderer || o,
        devicePixelRatio: n.devicePixelRatio,
        width: n.width,
        height: n.height,
        ssr: n.ssr,
        useDirtyRect: ke(n.useDirtyRect, l),
        useCoarsePointer: ke(n.useCoarsePointer, s),
        pointerSize: n.pointerSize
      });
      a._ssr = n.ssr, a._throttledZrFlush = ux(ae(u.flush, u), 17), i = Se(i), i && qY(i, !0), a._theme = i, a._locale = Xae(n.locale || yY), a._coordSysMgr = new Xg();
      var h = a._api = SM(a);
      function c(f, d) {
        return f.__prio - d.__prio;
      }
      return cm(DE, c), cm(OC, c), a._scheduler = new RH(a, h, OC, DE), a._messageCenter = new BH(), a._initEvents(), a.resize = ae(a.resize, a), u.animation.on("frame", a._onframe, a), mM(u, a), EM(u, a), uE(a), a;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        TM(this);
        var t = this._scheduler;
        if (this[Ni]) {
          var i = this[Ni].silent;
          this[ri] = !0;
          try {
            Yh(this), ds.update.call(this, null, this[Ni].updateParams);
          } catch (l) {
            throw this[ri] = !1, this[Ni] = null, l;
          }
          this._zr.flush(), this[ri] = !1, this[Ni] = null, id.call(this, i), nd.call(this, i);
        } else if (t.unfinished) {
          var n = mle, a = this._model, o = this._api;
          t.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            t.performSeriesTasks(a), t.performDataProcessorTasks(a), $y(this, a), t.performVisualTasks(a), iO(this, this._model, o, "remain", {}), n -= +/* @__PURE__ */ new Date() - s;
          } while (n > 0 && t.unfinished);
          t.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(t, i, n) {
      if (!this[ri]) {
        if (this._disposed) {
          this.id;
          return;
        }
        var a, o, s;
        if (be(i) && (n = i.lazyUpdate, a = i.silent, o = i.replaceMerge, s = i.transition, i = i.notMerge), this[ri] = !0, !this._model || i) {
          var l = new Toe(this._api), u = this._theme, h = this._model = new WY();
          h.scheduler = this._scheduler, h.ssr = this._ssr, h.init(null, null, null, u, this._locale, l);
        }
        this._model.setOption(t, {
          replaceMerge: o
        }, mC);
        var c = {
          seriesTransition: s,
          optionChanged: !0
        };
        if (n)
          this[Ni] = {
            silent: a,
            updateParams: c
          }, this[ri] = !1, this.getZr().wakeUp();
        else {
          try {
            Yh(this), ds.update.call(this, null, c);
          } catch (f) {
            throw this[Ni] = null, this[ri] = !1, f;
          }
          this._ssr || this._zr.flush(), this[Ni] = null, this[ri] = !1, id.call(this, a), nd.call(this, a);
        }
      }
    }, e.prototype.setTheme = function() {
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || st.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(t) {
      return this.renderToCanvas(t);
    }, e.prototype.renderToCanvas = function(t) {
      t = t || {};
      var i = this._zr.painter;
      return i.getRenderedCanvas({
        backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(t) {
      t = t || {};
      var i = this._zr.painter;
      return i.renderToString({
        useViewBox: t.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (st.svgSupported) {
        var t = this._zr, i = t.storage.getDisplayList();
        return w(i, function(n) {
          n.stopAnimation(null, !0);
        }), t.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      t = t || {};
      var i = t.excludeComponents, n = this._model, a = [], o = this;
      w(i, function(l) {
        n.eachComponent({
          mainType: l
        }, function(u) {
          var h = o._componentsMap[u.__viewId];
          h.group.ignore || (a.push(h), h.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return w(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, e.prototype.getConnectedDataURL = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      var i = t.type === "svg", n = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (Nle[n]) {
        var l = s, u = s, h = -s, c = -s, f = [], d = t && t.pixelRatio || this.getDevicePixelRatio();
        w(yM, function(E, b) {
          if (E.group === n) {
            var T = i ? E.getZr().painter.getSvgDom().innerHTML : E.renderToCanvas(Se(t)), S = E.getDom().getBoundingClientRect();
            l = a(S.left, l), u = a(S.top, u), h = o(S.right, h), c = o(S.bottom, c), f.push({
              dom: T,
              left: S.left,
              top: S.top
            });
          }
        }), l *= d, u *= d, h *= d, c *= d;
        var p = h - l, g = c - u, v = il.createCanvas(), O = _L(v, {
          renderer: i ? "svg" : "canvas"
        });
        if (O.resize({
          width: p,
          height: g
        }), i) {
          var m = "";
          return w(f, function(E) {
            var b = E.left - l, T = E.top - u;
            m += '<g transform="translate(' + b + "," + T + ')">' + E.dom + "</g>";
          }), O.painter.getSvgRoot().innerHTML = m, t.connectedBackgroundColor && O.painter.setBackgroundColor(t.connectedBackgroundColor), O.refreshImmediately(), O.painter.toDataURL();
        } else
          return t.connectedBackgroundColor && O.add(new nt({
            shape: {
              x: 0,
              y: 0,
              width: p,
              height: g
            },
            style: {
              fill: t.connectedBackgroundColor
            }
          })), w(f, function(E) {
            var b = new qr({
              style: {
                x: E.left * d - l,
                y: E.top * d - u,
                image: E.dom
              }
            });
            O.add(b);
          }), O.refreshImmediately(), v.toDataURL("image/" + (t && t.type || "png"));
      } else
        return this.getDataURL(t);
    }, e.prototype.convertToPixel = function(t, i) {
      return Uy(this, "convertToPixel", t, i);
    }, e.prototype.convertFromPixel = function(t, i) {
      return Uy(this, "convertFromPixel", t, i);
    }, e.prototype.containPixel = function(t, i) {
      if (this._disposed) {
        this.id;
        return;
      }
      var n = this._model, a, o = op(n, t);
      return w(o, function(s, l) {
        l.indexOf("Models") >= 0 && w(s, function(u) {
          var h = u.coordinateSystem;
          if (h && h.containPoint)
            a = a || !!h.containPoint(i);
          else if (l === "seriesModels") {
            var c = this._chartsMap[u.__viewId];
            c && c.containPoint && (a = a || c.containPoint(i, u));
          }
        }, this);
      }, this), !!a;
    }, e.prototype.getVisual = function(t, i) {
      var n = this._model, a = op(n, t, {
        defaultMainType: "series"
      }), o = a.seriesModel, s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? hx(s, l, i) : Yg(s, i);
    }, e.prototype.getViewOfComponentModel = function(t) {
      return this._componentsMap[t.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(t) {
      return this._chartsMap[t.__viewId];
    }, e.prototype._initEvents = function() {
      var t = this;
      w(Ple, function(i) {
        var n = function(a) {
          var o = t.getModel(), s = a.target, l, u = i === "globalout";
          if (u ? l = {} : s && Ru(s, function(p) {
            var g = _e(p);
            if (g && g.dataIndex != null) {
              var v = g.dataModel || o.getSeriesByIndex(g.seriesIndex);
              return l = v && v.getDataParams(g.dataIndex, g.dataType, s) || {}, !0;
            } else if (g.eventData)
              return l = V({}, g.eventData), !0;
          }, !0), l) {
            var h = l.componentType, c = l.componentIndex;
            (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", c = l.seriesIndex);
            var f = h && c != null && o.getComponent(h, c), d = f && t[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            l.event = a, l.type = i, t._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: f,
              view: d
            }, t.trigger(i, l);
          }
        };
        n.zrEventfulCallAtLast = !0, t._zr.on(i, n, t);
      }), w(LE, function(i, n) {
        t._messageCenter.on(n, function(a) {
          this.trigger(n, a);
        }, t);
      }), w(["selectchanged"], function(i) {
        t._messageCenter.on(i, function(n) {
          this.trigger(i, n);
        }, t);
      }), Gse(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._disposed = !0;
      var t = this.getDom();
      t && Pie(this.getDom(), Lle, "");
      var i = this, n = i._api, a = i._model;
      w(i._componentsViews, function(o) {
        o.dispose(a, n);
      }), w(i._chartsViews, function(o) {
        o.dispose(a, n);
      }), i._zr.dispose(), i._dom = i._model = i._chartsMap = i._componentsMap = i._chartsViews = i._componentsViews = i._scheduler = i._api = i._zr = i._throttledZrFlush = i._theme = i._coordSysMgr = i._messageCenter = null, delete yM[i.id];
    }, e.prototype.resize = function(t) {
      if (!this[ri]) {
        if (this._disposed) {
          this.id;
          return;
        }
        this._zr.resize(t);
        var i = this._model;
        if (this._loadingFX && this._loadingFX.resize(), !!i) {
          var n = i.resetOption("media"), a = t && t.silent;
          this[Ni] && (a == null && (a = this[Ni].silent), n = !0, this[Ni] = null), this[ri] = !0;
          try {
            n && Yh(this), ds.update.call(this, {
              type: "resize",
              animation: V({
                // Disable animation
                duration: 0
              }, t && t.animation)
            });
          } catch (o) {
            throw this[ri] = !1, o;
          }
          this[ri] = !1, id.call(this, a), nd.call(this, a);
        }
      }
    }, e.prototype.showLoading = function(t, i) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (be(t) && (i = t, t = ""), t = t || "default", this.hideLoading(), !!EC[t]) {
        var n = EC[t](this._api, i), a = this._zr;
        this._loadingFX = n, a.add(n);
      }
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        this.id;
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(t) {
      var i = V({}, t);
      return i.type = LE[t.type], i;
    }, e.prototype.dispatchAction = function(t, i) {
      if (this._disposed) {
        this.id;
        return;
      }
      if (be(i) || (i = {
        silent: !!i
      }), !!NE[t.type] && this._model) {
        if (this[ri]) {
          this._pendingActions.push(t);
          return;
        }
        var n = i.silent;
        Gy.call(this, t, n);
        var a = i.flush;
        a ? this._zr.flush() : a !== !1 && st.browser.weChat && this._throttledZrFlush(), id.call(this, n), nd.call(this, n);
      }
    }, e.prototype.updateLabelLayout = function() {
      Na.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, e.prototype.appendData = function(t) {
      if (this._disposed) {
        this.id;
        return;
      }
      var i = t.seriesIndex, n = this.getModel(), a = n.getSeriesByIndex(i);
      a.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, e.internalField = function() {
      Yh = function(c) {
        var f = c._scheduler;
        f.restorePipelines(c._model), f.prepareStageTasks(), Qy(c, !0), Qy(c, !1), f.plan();
      }, Qy = function(c, f) {
        for (var d = c._model, p = c._scheduler, g = f ? c._componentsViews : c._chartsViews, v = f ? c._componentsMap : c._chartsMap, O = c._zr, m = c._api, E = 0; E < g.length; E++)
          g[E].__alive = !1;
        f ? d.eachComponent(function(S, y) {
          S !== "series" && b(y);
        }) : d.eachSeries(b);
        function b(S) {
          var y = S.__requireNewView;
          S.__requireNewView = !1;
          var A = "_ec_" + S.id + "_" + S.type, C = !y && v[A];
          if (!C) {
            var _ = Ha(S.type), I = f ? Zt.getClass(_.main, _.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Mt.getClass(_.sub)
            );
            C = new I(), C.init(d, m), v[A] = C, g.push(C), O.add(C.group);
          }
          S.__viewId = C.__id = A, C.__alive = !0, C.__model = S, C.group.__ecComponentInfo = {
            mainType: S.mainType,
            index: S.componentIndex
          }, !f && p.prepareView(C, S, d, m);
        }
        for (var E = 0; E < g.length; ) {
          var T = g[E];
          T.__alive ? E++ : (!f && T.renderTask.dispose(), O.remove(T.group), T.dispose(d, m), g.splice(E, 1), v[T.__id] === T && delete v[T.__id], T.__id = T.group.__ecComponentInfo = null);
        }
      }, rO = function(c, f, d, p, g) {
        var v = c._model;
        if (v.setUpdatePayload(d), !p) {
          w([].concat(c._componentsViews).concat(c._chartsViews), T);
          return;
        }
        var O = {};
        O[p + "Id"] = d[p + "Id"], O[p + "Index"] = d[p + "Index"], O[p + "Name"] = d[p + "Name"];
        var m = {
          mainType: p,
          query: O
        };
        g && (m.subType = g);
        var E = d.excludeSeriesId, b;
        E != null && (b = ce(), w(At(E), function(S) {
          var y = gr(S, null);
          y != null && b.set(y, !0);
        })), v && v.eachComponent(m, function(S) {
          var y = b && b.get(S.id) != null;
          if (!y)
            if (aD(d))
              if (S instanceof Xt)
                d.type === Gu && !d.notBlur && !S.get(["emphasis", "disabled"]) && kne(S, d, c._api);
              else {
                var A = GI(S.mainType, S.componentIndex, d.name, c._api), C = A.focusSelf, _ = A.dispatchers;
                d.type === Gu && C && !d.notBlur && JA(S.mainType, S.componentIndex, c._api), _ && w(_, function(I) {
                  d.type === Gu ? Xo(I) : Yo(I);
                });
              }
            else
              tC(d) && S instanceof Xt && ($ne(S, d, c._api), iD(S), Tn(c));
        }, c), v && v.eachComponent(m, function(S) {
          var y = b && b.get(S.id) != null;
          y || T(c[p === "series" ? "_chartsMap" : "_componentsMap"][S.__viewId]);
        }, c);
        function T(S) {
          S && S.__alive && S[f] && S[f](S.__model, v, c._api, d);
        }
      }, ds = {
        prepareAndUpdate: function(c) {
          Yh(this), ds.update.call(this, c, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: c.newOption != null
          });
        },
        update: function(c, f) {
          var d = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, O = this._scheduler;
          if (d) {
            d.setUpdatePayload(c), O.restoreData(d, c), O.performSeriesTasks(d), v.create(d, p), O.performDataProcessorTasks(d, c), $y(this, d), v.update(d, p), t(d), O.performVisualTasks(d, c), By(this, d, p, c, f);
            var m = d.get("backgroundColor") || "transparent", E = d.get("darkMode");
            g.setBackgroundColor(m), E != null && E !== "auto" && g.setDarkMode(E), Na.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(c) {
          var f = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(c);
            var g = [];
            d.eachComponent(function(O, m) {
              if (O !== "series") {
                var E = f.getViewOfComponentModel(m);
                if (E && E.__alive)
                  if (E.updateTransform) {
                    var b = E.updateTransform(m, d, p, c);
                    b && b.update && g.push(E);
                  } else
                    g.push(E);
              }
            });
            var v = ce();
            d.eachSeries(function(O) {
              var m = f._chartsMap[O.__viewId];
              if (m.updateTransform) {
                var E = m.updateTransform(O, d, p, c);
                E && E.update && v.set(O.uid, 1);
              } else
                v.set(O.uid, 1);
            }), t(d), this._scheduler.performVisualTasks(d, c, {
              setDirty: !0,
              dirtyMap: v
            }), iO(this, d, p, c, {}, v), Na.trigger("afterupdate", d, p);
          }
        },
        updateView: function(c) {
          var f = this._model;
          f && (f.setUpdatePayload(c), Mt.markUpdateMethod(c, "updateView"), t(f), this._scheduler.performVisualTasks(f, c, {
            setDirty: !0
          }), By(this, f, this._api, c, {}), Na.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(c) {
          var f = this, d = this._model;
          d && (d.setUpdatePayload(c), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), Mt.markUpdateMethod(c, "updateVisual"), t(d), this._scheduler.performVisualTasks(d, c, {
            visualType: "visual",
            setDirty: !0
          }), d.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = f.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, d, f._api, c);
            }
          }), d.eachSeries(function(p) {
            var g = f._chartsMap[p.__viewId];
            g.updateVisual(p, d, f._api, c);
          }), Na.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(c) {
          ds.update.call(this, c);
        }
      }, Uy = function(c, f, d, p) {
        if (c._disposed) {
          c.id;
          return;
        }
        for (var g = c._model, v = c._coordSysMgr.getCoordinateSystems(), O, m = op(g, d), E = 0; E < v.length; E++) {
          var b = v[E];
          if (b[f] && (O = b[f](g, m, p)) != null)
            return O;
        }
      }, $y = function(c, f) {
        var d = c._chartsMap, p = c._scheduler;
        f.eachSeries(function(g) {
          p.updateStreamModes(g, d[g.__viewId]);
        });
      }, Gy = function(c, f) {
        var d = this, p = this.getModel(), g = c.type, v = c.escapeConnect, O = NE[g], m = O.actionInfo, E = (m.update || "update").split(":"), b = E.pop(), T = E[0] != null && Ha(E[0]);
        this[ri] = !0;
        var S = [c], y = !1;
        c.batch && (y = !0, S = Y(c.batch, function(N) {
          return N = me(V({}, N), c), N.batch = null, N;
        }));
        var A = [], C, _ = tC(c), I = aD(c);
        if (I && HX(this._api), w(S, function(N) {
          if (C = O.action(N, d._model, d._api), C = C || V({}, N), C.type = m.event || C.type, A.push(C), I) {
            var L = LI(c), D = L.queryOptionMap, $ = L.mainTypeSpecified, k = $ ? D.keys()[0] : "series";
            rO(d, b, N, k), Tn(d);
          } else
            _ ? (rO(d, b, N, "series"), Tn(d)) : T && rO(d, b, N, T.main, T.sub);
        }), b !== "none" && !I && !_ && !T)
          try {
            this[Ni] ? (Yh(this), ds.update.call(this, c), this[Ni] = null) : ds[b].call(this, c);
          } catch (N) {
            throw this[ri] = !1, N;
          }
        if (y ? C = {
          type: m.event || g,
          escapeConnect: v,
          batch: A
        } : C = A[0], this[ri] = !1, !f) {
          var x = this._messageCenter;
          if (x.trigger(C.type, C), _) {
            var P = {
              type: "selectchanged",
              escapeConnect: v,
              selected: Gne(p),
              isFromClick: c.isFromClick || !1,
              fromAction: c.type,
              fromActionPayload: c
            };
            x.trigger(P.type, P);
          }
        }
      }, id = function(c) {
        for (var f = this._pendingActions; f.length; ) {
          var d = f.shift();
          Gy.call(this, d, c);
        }
      }, nd = function(c) {
        !c && this.trigger("updated");
      }, mM = function(c, f) {
        c.on("rendered", function(d) {
          f.trigger("rendered", d), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          c.animation.isFinished() && !f[Ni] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, EM = function(c, f) {
        c.on("mouseover", function(d) {
          var p = d.target, g = Ru(p, Hp);
          g && (Qne(g, d, f._api), Tn(f));
        }).on("mouseout", function(d) {
          var p = d.target, g = Ru(p, Hp);
          g && (Une(g, d, f._api), Tn(f));
        }).on("click", function(d) {
          var p = d.target, g = Ru(p, function(m) {
            return _e(m).dataIndex != null;
          }, !0);
          if (g) {
            var v = g.selected ? "unselect" : "select", O = _e(g);
            f._api.dispatchAction({
              type: v,
              dataType: O.dataType,
              dataIndexInside: O.dataIndex,
              seriesIndex: O.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function t(c) {
        c.clearColorPalette(), c.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function i(c) {
        var f = [], d = [], p = !1;
        if (c.eachComponent(function(m, E) {
          var b = E.get("zlevel") || 0, T = E.get("z") || 0, S = E.getZLevelKey();
          p = p || !!S, (m === "series" ? d : f).push({
            zlevel: b,
            z: T,
            idx: E.componentIndex,
            type: m,
            key: S
          });
        }), p) {
          var g = f.concat(d), v, O;
          cm(g, function(m, E) {
            return m.zlevel === E.zlevel ? m.z - E.z : m.zlevel - E.zlevel;
          }), w(g, function(m) {
            var E = c.getComponent(m.type, m.idx), b = m.zlevel, T = m.key;
            v != null && (b = Math.max(v, b)), T ? (b === v && T !== O && b++, O = T) : O && (b === v && b++, O = ""), v = b, E.setZLevel(b);
          });
        }
      }
      By = function(c, f, d, p, g) {
        i(f), bM(c, f, d, p, g), w(c._chartsViews, function(v) {
          v.__alive = !1;
        }), iO(c, f, d, p, g), w(c._chartsViews, function(v) {
          v.__alive || v.remove(f, d);
        });
      }, bM = function(c, f, d, p, g, v) {
        w(v || c._componentsViews, function(O) {
          var m = O.__model;
          u(m, O), O.render(m, f, d, p), s(m, O), h(m, O);
        });
      }, iO = function(c, f, d, p, g, v) {
        var O = c._scheduler;
        g = V(g || {}, {
          updatedSeries: f.getSeries()
        }), Na.trigger("series:beforeupdate", f, d, g);
        var m = !1;
        f.eachSeries(function(E) {
          var b = c._chartsMap[E.__viewId];
          b.__alive = !0;
          var T = b.renderTask;
          O.updatePayload(T, p), u(E, b), v && v.get(E.uid) && T.dirty(), T.perform(O.getPerformArgs(T)) && (m = !0), b.group.silent = !!E.get("silent"), o(E, b), iD(E);
        }), O.unfinished = m || O.unfinished, Na.trigger("series:layoutlabels", f, d, g), Na.trigger("series:transition", f, d, g), f.eachSeries(function(E) {
          var b = c._chartsMap[E.__viewId];
          s(E, b), h(E, b);
        }), a(c, f), Na.trigger("series:afterupdate", f, d, g);
      }, Tn = function(c) {
        c[ky] = !0, c.getZr().wakeUp();
      }, TM = function(c) {
        c[ky] && (c.getZr().storage.traverse(function(f) {
          Pc(f) || n(f);
        }), c[ky] = !1);
      };
      function n(c) {
        for (var f = [], d = c.currentStates, p = 0; p < d.length; p++) {
          var g = d[p];
          g === "emphasis" || g === "blur" || g === "select" || f.push(g);
        }
        c.selected && c.states.select && f.push("select"), c.hoverState === TS && c.states.emphasis ? f.push("emphasis") : c.hoverState === $g && c.states.blur && f.push("blur"), c.useStates(f);
      }
      function a(c, f) {
        var d = c._zr, p = d.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > f.get("hoverLayerThreshold") && !st.node && !st.worker && f.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var O = c._chartsMap[v.__viewId];
            O.__alive && O.eachRendered(function(m) {
              m.states.emphasis && (m.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function o(c, f) {
        var d = c.get("blendMode") || null;
        f.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function s(c, f) {
        if (!c.preventAutoZ) {
          var d = c.get("z") || 0, p = c.get("zlevel") || 0;
          f.eachRendered(function(g) {
            return l(g, d, p, -1 / 0), !0;
          });
        }
      }
      function l(c, f, d, p) {
        var g = c.getTextContent(), v = c.getTextGuideLine(), O = c.isGroup;
        if (O)
          for (var m = c.childrenRef(), E = 0; E < m.length; E++)
            p = Math.max(l(m[E], f, d, p), p);
        else
          c.z = f, c.zlevel = d, p = Math.max(c.z2, p);
        if (g && (g.z = f, g.zlevel = d, isFinite(p) && (g.z2 = p + 2)), v) {
          var b = c.textGuideLineConfig;
          v.z = f, v.zlevel = d, isFinite(p) && (v.z2 = p + (b && b.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(c, f) {
        f.eachRendered(function(d) {
          if (!Pc(d)) {
            var p = d.getTextContent(), g = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function h(c, f) {
        var d = c.getModel("stateAnimation"), p = c.isAnimationEnabled(), g = d.get("duration"), v = g > 0 ? {
          duration: g,
          delay: d.get("delay"),
          easing: d.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        f.eachRendered(function(O) {
          if (O.states && O.states.emphasis) {
            if (Pc(O))
              return;
            if (O instanceof Fe && Yne(O), O.__dirty) {
              var m = O.prevStates;
              m && O.useStates(m);
            }
            if (p) {
              O.stateTransition = v;
              var E = O.getTextContent(), b = O.getTextGuideLine();
              E && (E.stateTransition = v), b && (b.stateTransition = v);
            }
            O.__dirty && n(O);
          }
        });
      }
      SM = function(c) {
        return new /** @class */
        (function(f) {
          U(d, f);
          function d() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return c._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null)
                return c._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, g) {
            Xo(p, g), Tn(c);
          }, d.prototype.leaveEmphasis = function(p, g) {
            Yo(p, g), Tn(c);
          }, d.prototype.enterBlur = function(p) {
            VX(p), Tn(c);
          }, d.prototype.leaveBlur = function(p) {
            $I(p), Tn(c);
          }, d.prototype.enterSelect = function(p) {
            FX(p), Tn(c);
          }, d.prototype.leaveSelect = function(p) {
            XX(p), Tn(c);
          }, d.prototype.getModel = function() {
            return c.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return c.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return c.getViewOfSeriesModel(p);
          }, d;
        }(zY))(c);
      };
    }(), e;
  }(jn)
), dx = wle.prototype;
dx.on = UH("on");
dx.off = UH("off");
dx.one = function(r, e, t) {
  var i = this;
  function n() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    e && e.apply && e.apply(this, a), i.off(r, n);
  }
  this.on.call(this, r, n, t);
};
var Ple = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
var NE = {}, LE = {}, OC = [], mC = [], DE = [], FH = {}, EC = {}, yM = {}, Nle = {}, Lle = "_echarts_instance_";
function XH(r, e) {
  FH[r] = e;
}
function YH(r) {
  Ge(mC, r) < 0 && mC.push(r);
}
function HH(r, e) {
  gx(OC, r, e, Tle);
}
function Dle(r) {
  px("afterinit", r);
}
function Mle(r) {
  px("afterupdate", r);
}
function px(r, e) {
  Na.on(r, e);
}
function Oo(r, e, t) {
  ve(e) && (t = e, e = "");
  var i = be(r) ? r.type : [r, r = {
    event: e
  }][0];
  r.event = (r.event || i).toLowerCase(), e = r.event, !LE[e] && (_i(OM.test(i) && OM.test(e)), NE[i] || (NE[i] = {
    action: t,
    actionInfo: r
  }), LE[e] = i);
}
function kle(r, e) {
  Xg.register(r, e);
}
function Qle(r, e) {
  gx(DE, r, e, MH, "layout");
}
function yh(r, e) {
  gx(DE, r, e, kH, "visual");
}
var RM = [];
function gx(r, e, t, i, n) {
  if ((ve(e) || be(e)) && (t = e, e = i), !(Ge(RM, t) >= 0)) {
    RM.push(t);
    var a = RH.wrapStageHandler(t, n);
    a.__prio = e, a.__raw = t, r.push(a);
  }
}
function WH(r, e) {
  EC[r] = e;
}
function Ule(r, e, t) {
  var i = Ole("registerMap");
  i && i(r, e, t);
}
var $le = qoe;
yh(fx, Sse);
yh(US, Tse);
yh(US, yse);
yh(fx, Use);
yh(US, $se);
yh(QH, ple);
YH(qY);
HH(ble, woe);
WH("default", Rse);
Oo({
  type: Gu,
  event: Gu,
  update: Gu
}, ar);
Oo({
  type: Om,
  event: Om,
  update: Om
}, ar);
Oo({
  type: sp,
  event: sp,
  update: sp
}, ar);
Oo({
  type: mm,
  event: mm,
  update: mm
}, ar);
Oo({
  type: lp,
  event: lp,
  update: lp
}, ar);
XH("light", Mse);
XH("dark", kse);
var AM = [], Gle = {
  registerPreprocessor: YH,
  registerProcessor: HH,
  registerPostInit: Dle,
  registerPostUpdate: Mle,
  registerUpdateLifecycle: px,
  registerAction: Oo,
  registerCoordinateSystem: kle,
  registerLayout: Qle,
  registerVisual: yh,
  registerTransform: $le,
  registerLoading: WH,
  registerMap: Ule,
  registerImpl: vle,
  PRIORITY: xle,
  ComponentModel: ot,
  ComponentView: Zt,
  SeriesModel: Xt,
  ChartView: Mt,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(r) {
    ot.registerClass(r);
  },
  registerComponentView: function(r) {
    Zt.registerClass(r);
  },
  registerSeriesModel: function(r) {
    Xt.registerClass(r);
  },
  registerChartView: function(r) {
    Mt.registerClass(r);
  },
  registerSubTypeDefaulter: function(r, e) {
    ot.registerSubTypeDefaulter(r, e);
  },
  registerPainter: function(r, e) {
    cie(r, e);
  }
};
function Ve(r) {
  if (X(r)) {
    w(r, function(e) {
      Ve(e);
    });
    return;
  }
  Ge(AM, r) >= 0 || (AM.push(r), ve(r) && (r = {
    install: r
  }), r.install(Gle));
}
function ad(r) {
  return r == null ? 0 : r.length || 1;
}
function CM(r) {
  return r;
}
var Ble = (
  /** @class */
  function() {
    function r(e, t, i, n, a, o) {
      this._old = e, this._new = t, this._oldKeyGetter = i || CM, this._newKeyGetter = n || CM, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return r.prototype.add = function(e) {
      return this._add = e, this;
    }, r.prototype.update = function(e) {
      return this._update = e, this;
    }, r.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, r.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, r.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, r.prototype.remove = function(e) {
      return this._remove = e, this;
    }, r.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, r.prototype._executeOneToOne = function() {
      var e = this._old, t = this._new, i = {}, n = new Array(e.length), a = new Array(t.length);
      this._initIndexMap(e, null, n, "_oldKeyGetter"), this._initIndexMap(t, i, a, "_newKeyGetter");
      for (var o = 0; o < e.length; o++) {
        var s = n[o], l = i[s], u = ad(l);
        if (u > 1) {
          var h = l.shift();
          l.length === 1 && (i[s] = l[0]), this._update && this._update(h, o);
        } else
          u === 1 ? (i[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, i);
    }, r.prototype._executeMultiple = function() {
      var e = this._old, t = this._new, i = {}, n = {}, a = [], o = [];
      this._initIndexMap(e, i, a, "_oldKeyGetter"), this._initIndexMap(t, n, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = i[l], h = n[l], c = ad(u), f = ad(h);
        if (c > 1 && f === 1)
          this._updateManyToOne && this._updateManyToOne(h, u), n[l] = null;
        else if (c === 1 && f > 1)
          this._updateOneToMany && this._updateOneToMany(h, u), n[l] = null;
        else if (c === 1 && f === 1)
          this._update && this._update(h, u), n[l] = null;
        else if (c > 1 && f > 1)
          this._updateManyToMany && this._updateManyToMany(h, u), n[l] = null;
        else if (c > 1)
          for (var d = 0; d < c; d++)
            this._remove && this._remove(u[d]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, n);
    }, r.prototype._performRestAdd = function(e, t) {
      for (var i = 0; i < e.length; i++) {
        var n = e[i], a = t[n], o = ad(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else
          o === 1 && this._add && this._add(a);
        t[n] = null;
      }
    }, r.prototype._initIndexMap = function(e, t, i, n) {
      for (var a = this._diffModeMultiple, o = 0; o < e.length; o++) {
        var s = "_ec_" + this[n](e[o], o);
        if (a || (i[o] = s), !!t) {
          var l = t[s], u = ad(l);
          u === 0 ? (t[s] = o, a && i.push(s)) : u === 1 ? t[s] = [l, o] : l.push(o);
        }
      }
    }, r;
  }()
);
const Ho = Ble;
var Vle = (
  /** @class */
  function() {
    function r(e, t) {
      this._encode = e, this._schema = t;
    }
    return r.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, r.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, r;
  }()
);
function Fle(r, e) {
  var t = {}, i = t.encode = {}, n = ce(), a = [], o = [], s = {};
  w(r.dimensions, function(f) {
    var d = r.getDimensionInfo(f), p = d.coordDim;
    if (p) {
      var g = d.coordDimIndex;
      Vy(i, p)[g] = f, d.isExtraCoord || (n.set(p, 1), Xle(d.type) && (a[0] = f), Vy(s, p)[g] = r.getDimensionIndex(d.name)), d.defaultTooltip && o.push(f);
    }
    $Y.each(function(v, O) {
      var m = Vy(i, O), E = d.otherDims[O];
      E != null && E !== !1 && (m[E] = d.name);
    });
  });
  var l = [], u = {};
  n.each(function(f, d) {
    var p = i[d];
    u[d] = p[0], l = l.concat(p);
  }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = Y(l, function(f) {
    return r.getDimensionInfo(f).storeDimIndex;
  }), t.encodeFirstDimNotExtra = u;
  var h = i.label;
  h && h.length && (a = h.slice());
  var c = i.tooltip;
  return c && c.length ? o = c.slice() : o.length || (o = a.slice()), i.defaultedLabel = a, i.defaultedTooltip = o, t.userOutput = new Vle(s, e), t;
}
function Vy(r, e) {
  return r.hasOwnProperty(e) || (r[e] = []), r[e];
}
function ME(r) {
  return r === "category" ? "ordinal" : r === "time" ? "time" : "float";
}
function Xle(r) {
  return !(r === "ordinal" || r === "time");
}
var Yle = (
  /** @class */
  function() {
    function r(e) {
      this.otherDims = {}, e != null && V(this, e);
    }
    return r;
  }()
);
const ym = Yle;
var Hle = at(), Wle = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, zH = (
  /** @class */
  function() {
    function r(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return r.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, r.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = jH(this.source)));
    }, r.prototype.getSourceDimensionIndex = function(e) {
      return ke(this._dimNameMap.get(e), -1);
    }, r.prototype.getSourceDimension = function(e) {
      var t = this.source.dimensionsDefine;
      if (t)
        return t[e];
    }, r.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, t = KY(this.source), i = !KH(e), n = "", a = [], o = 0, s = 0; o < e; o++) {
        var l = void 0, u = void 0, h = void 0, c = this.dimensions[s];
        if (c && c.storeDimIndex === o)
          l = t ? c.name : null, u = c.type, h = c.ordinalMeta, s++;
        else {
          var f = this.getSourceDimension(o);
          f && (l = t ? f.name : null, u = f.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: h
        }), t && l != null && (!c || !c.isCalculationCoord) && (n += i ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), n += "$", n += Wle[u] || "f", h && (n += h.uid), n += "$";
      }
      var d = this.source, p = [d.seriesLayoutBy, d.startIndex, n].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, r.prototype.makeOutputDimensionNames = function() {
      for (var e = [], t = 0, i = 0; t < this._fullDimCount; t++) {
        var n = void 0, a = this.dimensions[i];
        if (a && a.storeDimIndex === t)
          a.isCalculationCoord || (n = a.name), i++;
        else {
          var o = this.getSourceDimension(t);
          o && (n = o.name);
        }
        e.push(n);
      }
      return e;
    }, r.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, r;
  }()
);
function ZH(r) {
  return r instanceof zH;
}
function qH(r) {
  for (var e = ce(), t = 0; t < (r || []).length; t++) {
    var i = r[t], n = be(i) ? i.name : i;
    n != null && e.get(n) == null && e.set(n, t);
  }
  return e;
}
function jH(r) {
  var e = Hle(r);
  return e.dimNameMap || (e.dimNameMap = qH(r.dimensionsDefine));
}
function KH(r) {
  return r > 30;
}
var od = be, ps = Y, zle = typeof Int32Array > "u" ? Array : Int32Array, Zle = "e\0\0", _M = -1, qle = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], jle = ["_approximateExtent"], IM, nO, sd, ld, Fy, aO, Xy, Kle = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var i, n = !1;
      ZH(e) ? (i = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (n = !0, i = e), i = i || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, h = 0; h < i.length; h++) {
        var c = i[h], f = ne(c) ? new ym({
          name: c
        }) : c instanceof ym ? c : new ym(c), d = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = d, f.coordDimIndex = 0);
        var p = f.otherDims = f.otherDims || {};
        o.push(d), a[d] = f, u[d] != null && (l = !0), f.createInvertedIndices && (s[d] = []), p.itemName === 0 && (this._nameDimIdx = h), p.itemId === 0 && (this._idDimIdx = h), n && (f.storeDimIndex = h);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = s, this._dimOmitted) {
        var g = this._dimIdxToName = ce();
        w(o, function(v) {
          g.set(a[v].storeDimIndex, v);
        });
      }
    }
    return r.prototype.getDimension = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t == null)
        return e;
      if (t = e, !this._dimOmitted)
        return this.dimensions[t];
      var i = this._dimIdxToName.get(t);
      if (i != null)
        return i;
      var n = this._schema.getSourceDimension(t);
      if (n)
        return n.name;
    }, r.prototype.getDimensionIndex = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t != null)
        return t;
      if (e == null)
        return -1;
      var i = this._getDimInfo(e);
      return i ? i.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, r.prototype._recognizeDimIndex = function(e) {
      if (ut(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0))
        return +e;
    }, r.prototype._getStoreDimIndex = function(e) {
      var t = this.getDimensionIndex(e);
      return t;
    }, r.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, r.prototype._initGetDimensionInfo = function(e) {
      var t = this._dimInfos;
      this._getDimInfo = e ? function(i) {
        return t.hasOwnProperty(i) ? t[i] : void 0;
      } : function(i) {
        return t[i];
      };
    }, r.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, r.prototype.mapDimension = function(e, t) {
      var i = this._dimSummary;
      if (t == null)
        return i.encodeFirstDimNotExtra[e];
      var n = i.encode[e];
      return n ? n[t] : null;
    }, r.prototype.mapDimensionsAll = function(e) {
      var t = this._dimSummary, i = t.encode[e];
      return (i || []).slice();
    }, r.prototype.getStore = function() {
      return this._store;
    }, r.prototype.initData = function(e, t, i) {
      var n = this, a;
      if (e instanceof hC && (a = e), !a) {
        var o = this.dimensions, s = rx(e) || ci(e) ? new JY(e, o.length) : e;
        a = new hC();
        var l = ps(o, function(u) {
          return {
            type: n._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, i);
      }
      this._store = a, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = Fle(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, r.prototype.appendData = function(e) {
      var t = this._store.appendData(e);
      this._doInit(t[0], t[1]);
    }, r.prototype.appendValues = function(e, t) {
      var i = this._store.appendValues(e, t.length), n = i.start, a = i.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), t)
        for (var s = n; s < a; s++) {
          var l = s - n;
          this._nameList[s] = t[l], o && Xy(this, s);
        }
    }, r.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, t = this.dimensions, i = 0; i < t.length; i++) {
        var n = this._dimInfos[t[i]];
        n.ordinalMeta && e.collectOrdinalMeta(n.storeDimIndex, n.ordinalMeta);
      }
    }, r.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== Fs && !e.fillStorage;
    }, r.prototype._doInit = function(e, t) {
      if (!(e >= t)) {
        var i = this._store, n = i.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = n.getSource().sourceFormat, l = s === Kn;
        if (l && !n.pure)
          for (var u = [], h = e; h < t; h++) {
            var c = n.getItem(h, u);
            if (!this.hasItemOption && mie(c) && (this.hasItemOption = !0), c) {
              var f = c.name;
              a[h] == null && f != null && (a[h] = gr(f, null));
              var d = c.id;
              o[h] == null && d != null && (o[h] = gr(d, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var h = e; h < t; h++)
            Xy(this, h);
        IM(this);
      }
    }, r.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.setApproximateExtent = function(e, t) {
      t = this.getDimension(t), this._approximateExtent[t] = e.slice();
    }, r.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, r.prototype.setCalculationInfo = function(e, t) {
      od(e) ? V(this._calculationInfo, e) : this._calculationInfo[e] = t;
    }, r.prototype.getName = function(e) {
      var t = this.getRawIndex(e), i = this._nameList[t];
      return i == null && this._nameDimIdx != null && (i = sd(this, this._nameDimIdx, t)), i == null && (i = ""), i;
    }, r.prototype._getCategory = function(e, t) {
      var i = this._store.get(e, t), n = this._store.getOrdinalMeta(e);
      return n ? n.categories[i] : i;
    }, r.prototype.getId = function(e) {
      return nO(this, this.getRawIndex(e));
    }, r.prototype.count = function() {
      return this._store.count();
    }, r.prototype.get = function(e, t) {
      var i = this._store, n = this._dimInfos[e];
      if (n)
        return i.get(n.storeDimIndex, t);
    }, r.prototype.getByRawIndex = function(e, t) {
      var i = this._store, n = this._dimInfos[e];
      if (n)
        return i.getByRawIndex(n.storeDimIndex, t);
    }, r.prototype.getIndices = function() {
      return this._store.getIndices();
    }, r.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, r.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, r.prototype.getValues = function(e, t) {
      var i = this, n = this._store;
      return X(e) ? n.getValues(ps(e, function(a) {
        return i._getStoreDimIndex(a);
      }), t) : n.getValues(e);
    }, r.prototype.hasValue = function(e) {
      for (var t = this._dimSummary.dataDimIndicesOnCoord, i = 0, n = t.length; i < n; i++)
        if (isNaN(this._store.get(t[i], e)))
          return !1;
      return !0;
    }, r.prototype.indexOfName = function(e) {
      for (var t = 0, i = this._store.count(); t < i; t++)
        if (this.getName(t) === e)
          return t;
      return -1;
    }, r.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, r.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, r.prototype.rawIndexOf = function(e, t) {
      var i = e && this._invertedIndicesMap[e], n = i[t];
      return n == null || isNaN(n) ? _M : n;
    }, r.prototype.indicesOfNearest = function(e, t, i) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, i);
    }, r.prototype.each = function(e, t, i) {
      ve(e) && (i = t, t = e, e = []);
      var n = i || this, a = ps(ld(e), this._getStoreDimIndex, this);
      this._store.each(a, n ? ae(t, n) : t);
    }, r.prototype.filterSelf = function(e, t, i) {
      ve(e) && (i = t, t = e, e = []);
      var n = i || this, a = ps(ld(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, n ? ae(t, n) : t), this;
    }, r.prototype.selectRange = function(e) {
      var t = this, i = {}, n = He(e);
      return w(n, function(a) {
        var o = t._getStoreDimIndex(a);
        i[o] = e[a];
      }), this._store = this._store.selectRange(i), this;
    }, r.prototype.mapArray = function(e, t, i) {
      ve(e) && (i = t, t = e, e = []), i = i || this;
      var n = [];
      return this.each(e, function() {
        n.push(t && t.apply(this, arguments));
      }, i), n;
    }, r.prototype.map = function(e, t, i, n) {
      var a = i || n || this, o = ps(ld(e), this._getStoreDimIndex, this), s = aO(this);
      return s._store = this._store.map(o, a ? ae(t, a) : t), s;
    }, r.prototype.modify = function(e, t, i, n) {
      var a = i || n || this, o = ps(ld(e), this._getStoreDimIndex, this);
      this._store.modify(o, a ? ae(t, a) : t);
    }, r.prototype.downSample = function(e, t, i, n) {
      var a = aO(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(e), t, i, n), a;
    }, r.prototype.lttbDownSample = function(e, t) {
      var i = aO(this);
      return i._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), i;
    }, r.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, r.prototype.getItemModel = function(e) {
      var t = this.hostModel, i = this.getRawDataItem(e);
      return new Dt(i, t, t && t.ecModel);
    }, r.prototype.diff = function(e) {
      var t = this;
      return new Ho(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(i) {
        return nO(e, i);
      }, function(i) {
        return nO(t, i);
      });
    }, r.prototype.getVisual = function(e) {
      var t = this._visual;
      return t && t[e];
    }, r.prototype.setVisual = function(e, t) {
      this._visual = this._visual || {}, od(e) ? V(this._visual, e) : this._visual[e] = t;
    }, r.prototype.getItemVisual = function(e, t) {
      var i = this._itemVisuals[e], n = i && i[t];
      return n ?? this.getVisual(t);
    }, r.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, r.prototype.ensureUniqueItemVisual = function(e, t) {
      var i = this._itemVisuals, n = i[e];
      n || (n = i[e] = {});
      var a = n[t];
      return a == null && (a = this.getVisual(t), X(a) ? a = a.slice() : od(a) && (a = V({}, a)), n[t] = a), a;
    }, r.prototype.setItemVisual = function(e, t, i) {
      var n = this._itemVisuals[e] || {};
      this._itemVisuals[e] = n, od(t) ? V(n, t) : n[t] = i;
    }, r.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, r.prototype.setLayout = function(e, t) {
      od(e) ? V(this._layout, e) : this._layout[e] = t;
    }, r.prototype.getLayout = function(e) {
      return this._layout[e];
    }, r.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, r.prototype.setItemLayout = function(e, t, i) {
      this._itemLayouts[e] = i ? V(this._itemLayouts[e] || {}, t) : t;
    }, r.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, r.prototype.setItemGraphicEl = function(e, t) {
      var i = this.hostModel && this.hostModel.seriesIndex;
      jA(i, this.dataType, e, t), this._graphicEls[e] = t;
    }, r.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, r.prototype.eachItemGraphicEl = function(e, t) {
      w(this._graphicEls, function(i, n) {
        i && e && e.call(t, i, n);
      });
    }, r.prototype.cloneShallow = function(e) {
      return e || (e = new r(this._schema ? this._schema : ps(this.dimensions, this._getDimInfo, this), this.hostModel)), Fy(e, this), e._store = this._store, e;
    }, r.prototype.wrapMethod = function(e, t) {
      var i = this[e];
      ve(i) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var n = i.apply(this, arguments);
        return t.apply(this, [n].concat(TI(arguments)));
      });
    }, r.internalField = function() {
      IM = function(e) {
        var t = e._invertedIndicesMap;
        w(t, function(i, n) {
          var a = e._dimInfos[n], o = a.ordinalMeta, s = e._store;
          if (o) {
            i = t[n] = new zle(o.categories.length);
            for (var l = 0; l < i.length; l++)
              i[l] = _M;
            for (var l = 0; l < s.count(); l++)
              i[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, sd = function(e, t, i) {
        return gr(e._getCategory(t, i), null);
      }, nO = function(e, t) {
        var i = e._idList[t];
        return i == null && e._idDimIdx != null && (i = sd(e, e._idDimIdx, t)), i == null && (i = Zle + t), i;
      }, ld = function(e) {
        return X(e) || (e = e != null ? [e] : []), e;
      }, aO = function(e) {
        var t = new r(e._schema ? e._schema : ps(e.dimensions, e._getDimInfo, e), e.hostModel);
        return Fy(t, e), t;
      }, Fy = function(e, t) {
        w(qle.concat(t.__wrappedMethods || []), function(i) {
          t.hasOwnProperty(i) && (e[i] = t[i]);
        }), e.__wrappedMethods = t.__wrappedMethods, w(jle, function(i) {
          e[i] = Se(t[i]);
        }), e._calculationInfo = V({}, t._calculationInfo);
      }, Xy = function(e, t) {
        var i = e._nameList, n = e._idList, a = e._nameDimIdx, o = e._idDimIdx, s = i[t], l = n[t];
        if (s == null && a != null && (i[t] = s = sd(e, a, t)), l == null && o != null && (n[t] = l = sd(e, o, t)), l == null && s != null) {
          var u = e._nameRepeatCount, h = u[s] = (u[s] || 0) + 1;
          l = s, h > 1 && (l += "__ec__" + h), n[t] = l;
        }
      };
    }(), r;
  }()
);
const Ai = Kle;
function Hg(r, e) {
  rx(r) || (r = ix(r)), e = e || {};
  var t = e.coordDimensions || [], i = e.dimensionsDefine || r.dimensionsDefine || [], n = ce(), a = [], o = eue(r, t, i, e.dimensionsCount), s = e.canOmitUnusedDimensions && KH(o), l = i === r.dimensionsDefine, u = l ? jH(r) : qH(i), h = e.encodeDefine;
  !h && e.encodeDefaulter && (h = e.encodeDefaulter(r, o));
  for (var c = ce(h), f = new sH(o), d = 0; d < f.length; d++)
    f[d] = -1;
  function p(C) {
    var _ = f[C];
    if (_ < 0) {
      var I = i[C], x = be(I) ? I : {
        name: I
      }, P = new ym(), N = x.name;
      N != null && u.get(N) != null && (P.name = P.displayName = N), x.type != null && (P.type = x.type), x.displayName != null && (P.displayName = x.displayName);
      var L = a.length;
      return f[C] = L, P.storeDimIndex = C, a.push(P), P;
    }
    return a[_];
  }
  if (!s)
    for (var d = 0; d < o; d++)
      p(d);
  c.each(function(C, _) {
    var I = At(C).slice();
    if (I.length === 1 && !ne(I[0]) && I[0] < 0) {
      c.set(_, !1);
      return;
    }
    var x = c.set(_, []);
    w(I, function(P, N) {
      var L = ne(P) ? u.get(P) : P;
      L != null && L < o && (x[N] = L, v(p(L), _, N));
    });
  });
  var g = 0;
  w(t, function(C) {
    var _, I, x, P;
    if (ne(C))
      _ = C, P = {};
    else {
      P = C, _ = P.name;
      var N = P.ordinalMeta;
      P.ordinalMeta = null, P = V({}, P), P.ordinalMeta = N, I = P.dimsDef, x = P.otherDims, P.name = P.coordDim = P.coordDimIndex = P.dimsDef = P.otherDims = null;
    }
    var L = c.get(_);
    if (L !== !1) {
      if (L = At(L), !L.length)
        for (var D = 0; D < (I && I.length || 1); D++) {
          for (; g < o && p(g).coordDim != null; )
            g++;
          g < o && L.push(g++);
        }
      w(L, function($, k) {
        var G = p($);
        if (l && P.type != null && (G.type = P.type), v(me(G, P), _, k), G.name == null && I) {
          var F = I[k];
          !be(F) && (F = {
            name: F
          }), G.name = G.displayName = F.name, G.defaultTooltip = F.defaultTooltip;
        }
        x && me(G.otherDims, x);
      });
    }
  });
  function v(C, _, I) {
    $Y.get(_) != null ? C.otherDims[_] = I : (C.coordDim = _, C.coordDimIndex = I, n.set(_, !0));
  }
  var O = e.generateCoord, m = e.generateCoordCount, E = m != null;
  m = O ? m || 1 : 0;
  var b = O || "value";
  function T(C) {
    C.name == null && (C.name = C.coordDim);
  }
  if (s)
    w(a, function(C) {
      T(C);
    }), a.sort(function(C, _) {
      return C.storeDimIndex - _.storeDimIndex;
    });
  else
    for (var S = 0; S < o; S++) {
      var y = p(S), A = y.coordDim;
      A == null && (y.coordDim = tue(b, n, E), y.coordDimIndex = 0, (!O || m <= 0) && (y.isExtraCoord = !0), m--), T(y), y.type == null && (FY(r, S) === Br.Must || y.isExtraCoord && (y.otherDims.itemName != null || y.otherDims.seriesName != null)) && (y.type = "ordinal");
    }
  return Jle(a), new zH({
    source: r,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function Jle(r) {
  for (var e = ce(), t = 0; t < r.length; t++) {
    var i = r[t], n = i.name, a = e.get(n) || 0;
    a > 0 && (i.name = n + (a - 1)), a++, e.set(n, a);
  }
}
function eue(r, e, t, i) {
  var n = Math.max(r.dimensionsDetectedCount || 1, e.length, t.length, i || 0);
  return w(e, function(a) {
    var o;
    be(a) && (o = a.dimsDef) && (n = Math.max(n, o.length));
  }), n;
}
function tue(r, e, t) {
  if (t || e.hasKey(r)) {
    for (var i = 0; e.hasKey(r + i); )
      i++;
    r += i;
  }
  return e.set(r, !0), r;
}
var rue = (
  /** @class */
  function() {
    function r(e) {
      this.coordSysDims = [], this.axisMap = ce(), this.categoryAxisMap = ce(), this.coordSysName = e;
    }
    return r;
  }()
);
function iue(r) {
  var e = r.get("coordinateSystem"), t = new rue(e), i = nue[e];
  if (i)
    return i(r, t, t.axisMap, t.categoryAxisMap), t;
}
var nue = {
  cartesian2d: function(r, e, t, i) {
    var n = r.getReferringComponents("xAxis", lr).models[0], a = r.getReferringComponents("yAxis", lr).models[0];
    e.coordSysDims = ["x", "y"], t.set("x", n), t.set("y", a), Hh(n) && (i.set("x", n), e.firstCategoryDimIndex = 0), Hh(a) && (i.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  singleAxis: function(r, e, t, i) {
    var n = r.getReferringComponents("singleAxis", lr).models[0];
    e.coordSysDims = ["single"], t.set("single", n), Hh(n) && (i.set("single", n), e.firstCategoryDimIndex = 0);
  },
  polar: function(r, e, t, i) {
    var n = r.getReferringComponents("polar", lr).models[0], a = n.findAxisModel("radiusAxis"), o = n.findAxisModel("angleAxis");
    e.coordSysDims = ["radius", "angle"], t.set("radius", a), t.set("angle", o), Hh(a) && (i.set("radius", a), e.firstCategoryDimIndex = 0), Hh(o) && (i.set("angle", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  geo: function(r, e, t, i) {
    e.coordSysDims = ["lng", "lat"];
  },
  parallel: function(r, e, t, i) {
    var n = r.ecModel, a = n.getComponent("parallel", r.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice();
    w(a.parallelAxisIndex, function(s, l) {
      var u = n.getComponent("parallelAxis", s), h = o[l];
      t.set(h, u), Hh(u) && (i.set(h, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
    });
  }
};
function Hh(r) {
  return r.get("type") === "category";
}
function aue(r, e, t) {
  t = t || {};
  var i = t.byIndex, n = t.stackedCoordDimension, a, o, s;
  oue(e) ? a = e : (o = e.schema, a = o.dimensions, s = e.store);
  var l = !!(r && r.get("stack")), u, h, c, f;
  if (w(a, function(m, E) {
    ne(m) && (a[E] = m = {
      name: m
    }), l && !m.isExtraCoord && (!i && !u && m.ordinalMeta && (u = m), !h && m.type !== "ordinal" && m.type !== "time" && (!n || n === m.coordDim) && (h = m));
  }), h && !i && !u && (i = !0), h) {
    c = "__\0ecstackresult_" + r.id, f = "__\0ecstackedover_" + r.id, u && (u.createInvertedIndices = !0);
    var d = h.coordDim, p = h.type, g = 0;
    w(a, function(m) {
      m.coordDim === d && g++;
    });
    var v = {
      name: c,
      coordDim: d,
      coordDimIndex: g,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, O = {
      name: f,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: f,
      coordDimIndex: g + 1,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (v.storeDimIndex = s.ensureCalculationDimension(f, p), O.storeDimIndex = s.ensureCalculationDimension(c, p)), o.appendCalculationDimension(v), o.appendCalculationDimension(O)) : (a.push(v), a.push(O));
  }
  return {
    stackedDimension: h && h.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: i,
    stackedOverDimension: f,
    stackResultDimension: c
  };
}
function oue(r) {
  return !ZH(r.schema);
}
function sl(r, e) {
  return !!e && e === r.getCalculationInfo("stackedDimension");
}
function JH(r, e) {
  return sl(r, e) ? r.getCalculationInfo("stackResultDimension") : e;
}
function sue(r, e) {
  var t = r.get("coordinateSystem"), i = Xg.get(t), n;
  return e && e.coordSysDims && (n = Y(e.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = e.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = ME(l);
    }
    return o;
  })), n || (n = i && (i.getDimensionsInfo ? i.getDimensionsInfo() : i.dimensions.slice()) || ["x", "y"]), n;
}
function lue(r, e, t) {
  var i, n;
  return t && w(r, function(a, o) {
    var s = a.coordDim, l = t.categoryAxisMap.get(s);
    l && (i == null && (i = o), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (n = !0);
  }), !n && i != null && (r[i].otherDims.itemName = 0), i;
}
function ts(r, e, t) {
  t = t || {};
  var i = e.getSourceManager(), n, a = !1;
  r ? (a = !0, n = ix(r)) : (n = i.getSource(), a = n.sourceFormat === Kn);
  var o = iue(e), s = sue(e, o), l = t.useEncodeDefaulter, u = ve(l) ? l : l ? Ie(VY, s, e) : null, h = {
    coordDimensions: s,
    generateCoord: t.generateCoord,
    encodeDefine: e.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, c = Hg(n, h), f = lue(c.dimensions, t.createInvertedIndices, o), d = a ? null : i.getSharedDataStore(c), p = aue(e, {
    schema: c,
    store: d
  }), g = new Ai(c, e);
  g.setCalculationInfo(p);
  var v = f != null && uue(n) ? function(O, m, E, b) {
    return b === f ? E : this.defaultDimValueGetter(O, m, E, b);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? n : d,
    null,
    v
  ), g;
}
function uue(r) {
  if (r.sourceFormat === Kn) {
    var e = hue(r.data || []);
    return !X(bf(e));
  }
}
function hue(r) {
  for (var e = 0; e < r.length && r[e] == null; )
    e++;
  return r[e];
}
var eW = (
  /** @class */
  function() {
    function r(e) {
      this._setting = e || {}, this._extent = [1 / 0, -1 / 0];
    }
    return r.prototype.getSetting = function(e) {
      return this._setting[e];
    }, r.prototype.unionExtent = function(e) {
      var t = this._extent;
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]);
    }, r.prototype.unionExtentFromData = function(e, t) {
      this.unionExtent(e.getApproximateExtent(t));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.setExtent = function(e, t) {
      var i = this._extent;
      isNaN(e) || (i[0] = e), isNaN(t) || (i[1] = t);
    }, r.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, r.prototype.isBlank = function() {
      return this._isBlank;
    }, r.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, r;
  }()
);
mS(eW);
const rs = eW;
var cue = 0, fue = (
  /** @class */
  function() {
    function r(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++cue;
    }
    return r.createByAxisModel = function(e) {
      var t = e.option, i = t.data, n = i && Y(i, due);
      return new r({
        categories: n,
        needCollect: !n,
        // deduplication is default in axis.
        deduplication: t.dedplication !== !1
      });
    }, r.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, r.prototype.parseAndCollect = function(e) {
      var t, i = this._needCollect;
      if (!ne(e) && !i)
        return e;
      if (i && !this._deduplication)
        return t = this.categories.length, this.categories[t] = e, t;
      var n = this._getOrCreateMap();
      return t = n.get(e), t == null && (i ? (t = this.categories.length, this.categories[t] = e, n.set(e, t)) : t = NaN), t;
    }, r.prototype._getOrCreateMap = function() {
      return this._map || (this._map = ce(this.categories));
    }, r;
  }()
);
function due(r) {
  return be(r) && r.value != null ? r.value : r + "";
}
const bC = fue;
function SC(r) {
  return r.type === "interval" || r.type === "log";
}
function pue(r, e, t, i) {
  var n = {}, a = r[1] - r[0], o = n.interval = dX(a / e, !0);
  t != null && o < t && (o = n.interval = t), i != null && o > i && (o = n.interval = i);
  var s = n.intervalPrecision = tW(o), l = n.niceTickExtent = [Kt(Math.ceil(r[0] / o) * o, s), Kt(Math.floor(r[1] / o) * o, s)];
  return gue(l, r), n;
}
function Yy(r) {
  var e = Math.pow(10, PI(r)), t = r / e;
  return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, Kt(t * e);
}
function tW(r) {
  return Ya(r) + 2;
}
function xM(r, e, t) {
  r[e] = Math.max(Math.min(r[e], t[1]), t[0]);
}
function gue(r, e) {
  !isFinite(r[0]) && (r[0] = e[0]), !isFinite(r[1]) && (r[1] = e[1]), xM(r, 0, e), xM(r, 1, e), r[0] > r[1] && (r[0] = r[1]);
}
function $S(r, e) {
  return r >= e[0] && r <= e[1];
}
function GS(r, e) {
  return e[1] === e[0] ? 0.5 : (r - e[0]) / (e[1] - e[0]);
}
function BS(r, e) {
  return r * (e[1] - e[0]) + e[0];
}
var rW = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      i.type = "ordinal";
      var n = i.getSetting("ordinalMeta");
      return n || (n = new bC({})), X(n) && (n = new bC({
        categories: Y(n, function(a) {
          return be(a) ? a.value : a;
        })
      })), i._ordinalMeta = n, i._extent = i.getSetting("extent") || [0, n.categories.length - 1], i;
    }
    return e.prototype.parse = function(t) {
      return t == null ? NaN : ne(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
    }, e.prototype.contain = function(t) {
      return t = this.parse(t), $S(t, this._extent) && this._ordinalMeta.categories[t] != null;
    }, e.prototype.normalize = function(t) {
      return t = this._getTickNumber(this.parse(t)), GS(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Math.round(BS(t, this._extent)), this.getRawOrdinalNumber(t);
    }, e.prototype.getTicks = function() {
      for (var t = [], i = this._extent, n = i[0]; n <= i[1]; )
        t.push({
          value: n
        }), n++;
      return t;
    }, e.prototype.getMinorTicks = function(t) {
    }, e.prototype.setSortInfo = function(t) {
      if (t == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var i = t.ordinalNumbers, n = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, i.length); o < l; ++o) {
        var u = i[o];
        n[o] = u, a[u] = o;
      }
      for (var h = 0; o < s; ++o) {
        for (; a[h] != null; )
          h++;
        n.push(h), a[h] = o;
      }
    }, e.prototype._getTickNumber = function(t) {
      var i = this._ticksByOrdinalNumber;
      return i && t >= 0 && t < i.length ? i[t] : t;
    }, e.prototype.getRawOrdinalNumber = function(t) {
      var i = this._ordinalNumbersByTick;
      return i && t >= 0 && t < i.length ? i[t] : t;
    }, e.prototype.getLabel = function(t) {
      if (!this.isBlank()) {
        var i = this.getRawOrdinalNumber(t.value), n = this._ordinalMeta.categories[i];
        return n == null ? "" : n + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(t, i) {
      this.unionExtent(t.getApproximateExtent(i));
    }, e.prototype.isInExtentRange = function(t) {
      return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(rs)
);
rs.registerClass(rW);
const vx = rW;
var Zl = Kt, iW = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t;
    }
    return e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return $S(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return GS(t, this._extent);
    }, e.prototype.scale = function(t) {
      return BS(t, this._extent);
    }, e.prototype.setExtent = function(t, i) {
      var n = this._extent;
      isNaN(t) || (n[0] = parseFloat(t)), isNaN(i) || (n[1] = parseFloat(i));
    }, e.prototype.unionExtent = function(t) {
      var i = this._extent;
      t[0] < i[0] && (i[0] = t[0]), t[1] > i[1] && (i[1] = t[1]), this.setExtent(i[0], i[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(t) {
      this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = tW(t);
    }, e.prototype.getTicks = function(t) {
      var i = this._interval, n = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
      if (!i)
        return s;
      var l = 1e4;
      n[0] < a[0] && (t ? s.push({
        value: Zl(a[0] - i, o)
      }) : s.push({
        value: n[0]
      }));
      for (var u = a[0]; u <= a[1] && (s.push({
        value: u
      }), u = Zl(u + i, o), u !== s[s.length - 1].value); )
        if (s.length > l)
          return [];
      var h = s.length ? s[s.length - 1].value : a[1];
      return n[1] > h && (t ? s.push({
        value: Zl(h + i, o)
      }) : s.push({
        value: n[1]
      })), s;
    }, e.prototype.getMinorTicks = function(t) {
      for (var i = this.getTicks(!0), n = [], a = this.getExtent(), o = 1; o < i.length; o++) {
        for (var s = i[o], l = i[o - 1], u = 0, h = [], c = s.value - l.value, f = c / t; u < t - 1; ) {
          var d = Zl(l.value + (u + 1) * f);
          d > a[0] && d < a[1] && h.push(d), u++;
        }
        n.push(h);
      }
      return n;
    }, e.prototype.getLabel = function(t, i) {
      if (t == null)
        return "";
      var n = i && i.precision;
      n == null ? n = Ya(t.value) || 0 : n === "auto" && (n = this._intervalPrecision);
      var a = Zl(t.value, n, !0);
      return LY(a);
    }, e.prototype.calcNiceTicks = function(t, i, n) {
      t = t || 5;
      var a = this._extent, o = a[1] - a[0];
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse());
        var s = pue(a, t, i, n);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      var i = this._extent;
      if (i[0] === i[1])
        if (i[0] !== 0) {
          var n = Math.abs(i[0]);
          t.fixMax || (i[1] += n / 2), i[0] -= n / 2;
        } else
          i[1] = 1;
      var a = i[1] - i[0];
      isFinite(a) || (i[0] = 0, i[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
      var o = this._interval;
      t.fixMin || (i[0] = Zl(Math.floor(i[0] / o) * o)), t.fixMax || (i[1] = Zl(Math.ceil(i[1] / o) * o));
    }, e.prototype.setNiceExtent = function(t, i) {
      this._niceExtent = [t, i];
    }, e.type = "interval", e;
  }(rs)
);
rs.registerClass(iW);
const ll = iW;
var nW = typeof Float32Array < "u", vue = nW ? Float32Array : Array;
function Wa(r) {
  return X(r) ? nW ? new Float32Array(r) : r : new vue(r);
}
var TC = "__ec_stack_";
function Ox(r) {
  return r.get("stack") || TC + r.seriesIndex;
}
function mx(r) {
  return r.dim + r.index;
}
function Oue(r) {
  var e = [], t = r.axis, i = "axis0";
  if (t.type === "category") {
    for (var n = t.getBandWidth(), a = 0; a < r.count; a++)
      e.push(me({
        bandWidth: n,
        axisKey: i,
        stackId: TC + a
      }, r));
    for (var o = sW(e), s = [], a = 0; a < r.count; a++) {
      var l = o[i][TC + a];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function aW(r, e) {
  var t = [];
  return e.eachSeriesByType(r, function(i) {
    hW(i) && t.push(i);
  }), t;
}
function mue(r) {
  var e = {};
  w(r, function(l) {
    var u = l.coordinateSystem, h = u.getBaseAxis();
    if (!(h.type !== "time" && h.type !== "value"))
      for (var c = l.getData(), f = h.dim + "_" + h.index, d = c.getDimensionIndex(c.mapDimension(h.dim)), p = c.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var O = p.get(d, g);
        e[f] ? e[f].push(O) : e[f] = [O];
      }
  });
  var t = {};
  for (var i in e)
    if (e.hasOwnProperty(i)) {
      var n = e[i];
      if (n) {
        n.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < n.length; ++o) {
          var s = n[o] - n[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        t[i] = a;
      }
    }
  return t;
}
function oW(r) {
  var e = mue(r), t = [];
  return w(r, function(i) {
    var n = i.coordinateSystem, a = n.getBaseAxis(), o = a.getExtent(), s;
    if (a.type === "category")
      s = a.getBandWidth();
    else if (a.type === "value" || a.type === "time") {
      var l = a.dim + "_" + a.index, u = e[l], h = Math.abs(o[1] - o[0]), c = a.scale.getExtent(), f = Math.abs(c[1] - c[0]);
      s = u ? h / f * u : h;
    } else {
      var d = i.getData();
      s = Math.abs(o[1] - o[0]) / d.count();
    }
    var p = K(i.get("barWidth"), s), g = K(i.get("barMaxWidth"), s), v = K(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      i.get("barMinWidth") || (cW(i) ? 0.5 : 1),
      s
    ), O = i.get("barGap"), m = i.get("barCategoryGap");
    t.push({
      bandWidth: s,
      barWidth: p,
      barMaxWidth: g,
      barMinWidth: v,
      barGap: O,
      barCategoryGap: m,
      axisKey: mx(a),
      stackId: Ox(i)
    });
  }), sW(t);
}
function sW(r) {
  var e = {};
  w(r, function(i, n) {
    var a = i.axisKey, o = i.bandWidth, s = e[a] || {
      bandWidth: o,
      remainedWidth: o,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, l = s.stacks;
    e[a] = s;
    var u = i.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var h = i.barWidth;
    h && !l[u].width && (l[u].width = h, h = Math.min(s.remainedWidth, h), s.remainedWidth -= h);
    var c = i.barMaxWidth;
    c && (l[u].maxWidth = c);
    var f = i.barMinWidth;
    f && (l[u].minWidth = f);
    var d = i.barGap;
    d != null && (s.gap = d);
    var p = i.barCategoryGap;
    p != null && (s.categoryGap = p);
  });
  var t = {};
  return w(e, function(i, n) {
    t[n] = {};
    var a = i.stacks, o = i.bandWidth, s = i.categoryGap;
    if (s == null) {
      var l = He(a).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = K(s, o), h = K(i.gap, 1), c = i.remainedWidth, f = i.autoWidthCount, d = (c - u) / (f + (f - 1) * h);
    d = Math.max(d, 0), w(a, function(O) {
      var m = O.maxWidth, E = O.minWidth;
      if (O.width) {
        var b = O.width;
        m && (b = Math.min(b, m)), E && (b = Math.max(b, E)), O.width = b, c -= b + h * b, f--;
      } else {
        var b = d;
        m && m < b && (b = Math.min(m, c)), E && E > b && (b = E), b !== d && (O.width = b, c -= b + h * b, f--);
      }
    }), d = (c - u) / (f + (f - 1) * h), d = Math.max(d, 0);
    var p = 0, g;
    w(a, function(O, m) {
      O.width || (O.width = d), g = O, p += O.width * (1 + h);
    }), g && (p -= g.width * h);
    var v = -p / 2;
    w(a, function(O, m) {
      t[n][m] = t[n][m] || {
        bandWidth: o,
        offset: v,
        width: O.width
      }, v += O.width * (1 + h);
    });
  }), t;
}
function Eue(r, e, t) {
  if (r && e) {
    var i = r[mx(e)];
    return i != null && t != null ? i[Ox(t)] : i;
  }
}
function lW(r, e) {
  var t = aW(r, e), i = oW(t);
  w(t, function(n) {
    var a = n.getData(), o = n.coordinateSystem, s = o.getBaseAxis(), l = Ox(n), u = i[mx(s)][l], h = u.offset, c = u.width;
    a.setLayout({
      bandWidth: u.bandWidth,
      offset: h,
      size: c
    });
  });
}
function uW(r) {
  return {
    seriesType: r,
    plan: wf(),
    reset: function(e) {
      if (hW(e)) {
        var t = e.getData(), i = e.coordinateSystem, n = i.getBaseAxis(), a = i.getOtherAxis(n), o = t.getDimensionIndex(t.mapDimension(a.dim)), s = t.getDimensionIndex(t.mapDimension(n.dim)), l = e.get("showBackground", !0), u = t.mapDimension(a.dim), h = t.getCalculationInfo("stackResultDimension"), c = sl(t, u) && !!t.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), d = bue(n, a), p = cW(e), g = e.get("barMinHeight") || 0, v = h && t.getDimensionIndex(h), O = t.getLayout("size"), m = t.getLayout("offset");
        return {
          progress: function(E, b) {
            for (var T = E.count, S = p && Wa(T * 3), y = p && l && Wa(T * 3), A = p && Wa(T), C = i.master.getRect(), _ = f ? C.width : C.height, I, x = b.getStore(), P = 0; (I = E.next()) != null; ) {
              var N = x.get(c ? v : o, I), L = x.get(s, I), D = d, $ = void 0;
              c && ($ = +N - x.get(o, I));
              var k = void 0, G = void 0, F = void 0, q = void 0;
              if (f) {
                var re = i.dataToPoint([N, L]);
                if (c) {
                  var fe = i.dataToPoint([$, L]);
                  D = fe[0];
                }
                k = D, G = re[1] + m, F = re[0] - D, q = O, Math.abs(F) < g && (F = (F < 0 ? -1 : 1) * g);
              } else {
                var re = i.dataToPoint([L, N]);
                if (c) {
                  var fe = i.dataToPoint([L, $]);
                  D = fe[1];
                }
                k = re[0] + m, G = D, F = O, q = re[1] - D, Math.abs(q) < g && (q = (q <= 0 ? -1 : 1) * g);
              }
              p ? (S[P] = k, S[P + 1] = G, S[P + 2] = f ? F : q, y && (y[P] = f ? C.x : k, y[P + 1] = f ? G : C.y, y[P + 2] = _), A[I] = I) : b.setItemLayout(I, {
                x: k,
                y: G,
                width: F,
                height: q
              }), P += 3;
            }
            p && b.setLayout({
              largePoints: S,
              largeDataIndices: A,
              largeBackgroundPoints: y,
              valueAxisHorizontal: f
            });
          }
        };
      }
    }
  };
}
function hW(r) {
  return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
}
function cW(r) {
  return r.pipelineContext && r.pipelineContext.large;
}
function bue(r, e) {
  return e.toGlobalCoord(e.dataToCoord(e.type === "log" ? 1 : 0));
}
var Sue = function(r, e, t, i) {
  for (; t < i; ) {
    var n = t + i >>> 1;
    r[n][1] < e ? t = n + 1 : i = n;
  }
  return t;
}, fW = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "time", i;
    }
    return e.prototype.getLabel = function(t) {
      var i = this.getSetting("useUTC");
      return xS(t.value, bD[Wae(Nc(this._minLevelUnit))] || bD.second, i, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(t, i, n) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return zae(t, i, n, o, a);
    }, e.prototype.getTicks = function() {
      var t = this._interval, i = this._extent, n = [];
      if (!t)
        return n;
      n.push({
        value: i[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), o = Iue(this._minLevelUnit, this._approxInterval, a, i);
      return n = n.concat(o), n.push({
        value: i[1],
        level: 0
      }), n;
    }, e.prototype.calcNiceExtent = function(t) {
      var i = this._extent;
      if (i[0] === i[1] && (i[0] -= Mn, i[1] += Mn), i[1] === -1 / 0 && i[0] === 1 / 0) {
        var n = /* @__PURE__ */ new Date();
        i[1] = +new Date(n.getFullYear(), n.getMonth(), n.getDate()), i[0] = i[1] - Mn;
      }
      this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
    }, e.prototype.calcNiceTicks = function(t, i, n) {
      t = t || 10;
      var a = this._extent, o = a[1] - a[0];
      this._approxInterval = o / t, i != null && this._approxInterval < i && (this._approxInterval = i), n != null && this._approxInterval > n && (this._approxInterval = n);
      var s = oO.length, l = Math.min(Sue(oO, this._approxInterval, 0, s), s - 1);
      this._interval = oO[l][1], this._minLevelUnit = oO[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(t) {
      return ut(t) ? t : +so(t);
    }, e.prototype.contain = function(t) {
      return $S(this.parse(t), this._extent);
    }, e.prototype.normalize = function(t) {
      return GS(this.parse(t), this._extent);
    }, e.prototype.scale = function(t) {
      return BS(t, this._extent);
    }, e.type = "time", e;
  }(ll)
), oO = [
  // Format                           interval
  ["second", ZI],
  ["minute", qI],
  ["hour", hp],
  ["quarter-day", hp * 6],
  ["half-day", hp * 12],
  ["day", Mn * 1.2],
  ["half-week", Mn * 3.5],
  ["week", Mn * 7],
  ["month", Mn * 31],
  ["quarter", Mn * 95],
  ["half-year", ED / 2],
  ["year", ED]
  // 1Y
];
function Tue(r, e, t, i) {
  var n = so(e), a = so(t), o = function(p) {
    return SD(n, p, i) === SD(a, p, i);
  }, s = function() {
    return o("year");
  }, l = function() {
    return s() && o("month");
  }, u = function() {
    return l() && o("day");
  }, h = function() {
    return u() && o("hour");
  }, c = function() {
    return h() && o("minute");
  }, f = function() {
    return c() && o("second");
  }, d = function() {
    return f() && o("millisecond");
  };
  switch (r) {
    case "year":
      return s();
    case "month":
      return l();
    case "day":
      return u();
    case "hour":
      return h();
    case "minute":
      return c();
    case "second":
      return f();
    case "millisecond":
      return d();
  }
}
function yue(r, e) {
  return r /= Mn, r > 16 ? 16 : r > 7.5 ? 7 : r > 3.5 ? 4 : r > 1.5 ? 2 : 1;
}
function Rue(r) {
  var e = 30 * Mn;
  return r /= e, r > 6 ? 6 : r > 3 ? 3 : r > 2 ? 2 : 1;
}
function Aue(r) {
  return r /= hp, r > 12 ? 12 : r > 6 ? 6 : r > 3.5 ? 4 : r > 2 ? 2 : 1;
}
function wM(r, e) {
  return r /= e ? qI : ZI, r > 30 ? 30 : r > 20 ? 20 : r > 15 ? 15 : r > 10 ? 10 : r > 5 ? 5 : r > 2 ? 2 : 1;
}
function Cue(r) {
  return dX(r, !0);
}
function _ue(r, e, t) {
  var i = new Date(r);
  switch (Nc(e)) {
    case "year":
    case "month":
      i[_Y(t)](0);
    case "day":
      i[IY(t)](1);
    case "hour":
      i[xY(t)](0);
    case "minute":
      i[wY(t)](0);
    case "second":
      i[PY(t)](0), i[NY(t)](0);
  }
  return i.getTime();
}
function Iue(r, e, t, i) {
  var n = 1e4, a = AY, o = 0;
  function s(_, I, x, P, N, L, D) {
    for (var $ = new Date(I), k = I, G = $[P](); k < x && k <= i[1]; )
      D.push({
        value: k
      }), G += _, $[N](G), k = $.getTime();
    D.push({
      value: k,
      notAdd: !0
    });
  }
  function l(_, I, x) {
    var P = [], N = !I.length;
    if (!Tue(Nc(_), i[0], i[1], t)) {
      N && (I = [{
        // TODO Optimize. Not include so may ticks.
        value: _ue(new Date(i[0]), _, t)
      }, {
        value: i[1]
      }]);
      for (var L = 0; L < I.length - 1; L++) {
        var D = I[L].value, $ = I[L + 1].value;
        if (D !== $) {
          var k = void 0, G = void 0, F = void 0, q = !1;
          switch (_) {
            case "year":
              k = Math.max(1, Math.round(e / Mn / 365)), G = jI(t), F = Zae(t);
              break;
            case "half-year":
            case "quarter":
            case "month":
              k = Rue(e), G = Lc(t), F = _Y(t);
              break;
            case "week":
            case "half-week":
            case "day":
              k = yue(e), G = wS(t), F = IY(t), q = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              k = Aue(e), G = Zp(t), F = xY(t);
              break;
            case "minute":
              k = wM(e, !0), G = PS(t), F = wY(t);
              break;
            case "second":
              k = wM(e, !1), G = NS(t), F = PY(t);
              break;
            case "millisecond":
              k = Cue(e), G = LS(t), F = NY(t);
              break;
          }
          s(k, D, $, G, F, q, P), _ === "year" && x.length > 1 && L === 0 && x.unshift({
            value: x[0].value - k
          });
        }
      }
      for (var L = 0; L < P.length; L++)
        x.push(P[L]);
      return P;
    }
  }
  for (var u = [], h = [], c = 0, f = 0, d = 0; d < a.length && o++ < n; ++d) {
    var p = Nc(a[d]);
    if (Hae(a[d])) {
      l(a[d], u[u.length - 1] || [], h);
      var g = a[d + 1] ? Nc(a[d + 1]) : null;
      if (p !== g) {
        if (h.length) {
          f = c, h.sort(function(_, I) {
            return _.value - I.value;
          });
          for (var v = [], O = 0; O < h.length; ++O) {
            var m = h[O].value;
            (O === 0 || h[O - 1].value !== m) && (v.push(h[O]), m >= i[0] && m <= i[1] && c++);
          }
          var E = (i[1] - i[0]) / e;
          if (c > E * 1.5 && f > E / 1.5 || (u.push(v), c > E || r === a[d]))
            break;
        }
        h = [];
      }
    }
  }
  for (var b = yt(Y(u, function(_) {
    return yt(_, function(I) {
      return I.value >= i[0] && I.value <= i[1] && !I.notAdd;
    });
  }), function(_) {
    return _.length > 0;
  }), T = [], S = b.length - 1, d = 0; d < b.length; ++d)
    for (var y = b[d], A = 0; A < y.length; ++A)
      T.push({
        value: y[A].value,
        level: S - d
      });
  T.sort(function(_, I) {
    return _.value - I.value;
  });
  for (var C = [], d = 0; d < T.length; ++d)
    (d === 0 || T[d].value !== T[d - 1].value) && C.push(T[d]);
  return C;
}
rs.registerClass(fW);
const dW = fW;
var PM = rs.prototype, fp = ll.prototype, xue = Kt, wue = Math.floor, Pue = Math.ceil, sO = Math.pow, ia = Math.log, Ex = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "log", t.base = 10, t._originalScale = new ll(), t._interval = 0, t;
    }
    return e.prototype.getTicks = function(t) {
      var i = this._originalScale, n = this._extent, a = i.getExtent(), o = fp.getTicks.call(this, t);
      return Y(o, function(s) {
        var l = s.value, u = Kt(sO(this.base, l));
        return u = l === n[0] && this._fixMin ? lO(u, a[0]) : u, u = l === n[1] && this._fixMax ? lO(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(t, i) {
      var n = ia(this.base);
      t = ia(Math.max(0, t)) / n, i = ia(Math.max(0, i)) / n, fp.setExtent.call(this, t, i);
    }, e.prototype.getExtent = function() {
      var t = this.base, i = PM.getExtent.call(this);
      i[0] = sO(t, i[0]), i[1] = sO(t, i[1]);
      var n = this._originalScale, a = n.getExtent();
      return this._fixMin && (i[0] = lO(i[0], a[0])), this._fixMax && (i[1] = lO(i[1], a[1])), i;
    }, e.prototype.unionExtent = function(t) {
      this._originalScale.unionExtent(t);
      var i = this.base;
      t[0] = ia(t[0]) / ia(i), t[1] = ia(t[1]) / ia(i), PM.unionExtent.call(this, t);
    }, e.prototype.unionExtentFromData = function(t, i) {
      this.unionExtent(t.getApproximateExtent(i));
    }, e.prototype.calcNiceTicks = function(t) {
      t = t || 10;
      var i = this._extent, n = i[1] - i[0];
      if (!(n === 1 / 0 || n <= 0)) {
        var a = Oie(n), o = t / n * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; )
          a *= 10;
        var s = [Kt(Pue(i[0] / a) * a), Kt(wue(i[1] / a) * a)];
        this._interval = a, this._niceExtent = s;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      fp.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
    }, e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return t = ia(t) / ia(this.base), $S(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return t = ia(t) / ia(this.base), GS(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = BS(t, this._extent), sO(this.base, t);
    }, e.type = "log", e;
  }(rs)
), pW = Ex.prototype;
pW.getMinorTicks = fp.getMinorTicks;
pW.getLabel = fp.getLabel;
function lO(r, e) {
  return xue(r, Ya(e));
}
rs.registerClass(Ex);
const Nue = Ex;
var Lue = (
  /** @class */
  function() {
    function r(e, t, i) {
      this._prepareParams(e, t, i);
    }
    return r.prototype._prepareParams = function(e, t, i) {
      i[1] < i[0] && (i = [NaN, NaN]), this._dataMin = i[0], this._dataMax = i[1];
      var n = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero();
      var a = this._modelMinRaw = t.get("min", !0);
      ve(a) ? this._modelMinNum = uO(e, a({
        min: i[0],
        max: i[1]
      })) : a !== "dataMin" && (this._modelMinNum = uO(e, a));
      var o = this._modelMaxRaw = t.get("max", !0);
      if (ve(o) ? this._modelMaxNum = uO(e, o({
        min: i[0],
        max: i[1]
      })) : o !== "dataMax" && (this._modelMaxNum = uO(e, o)), n)
        this._axisDataLen = t.getCategories().length;
      else {
        var s = t.get("boundaryGap"), l = X(s) ? s : [s || 0, s || 0];
        typeof l[0] == "boolean" || typeof l[1] == "boolean" ? this._boundaryGapInner = [0, 0] : this._boundaryGapInner = [Ea(l[0], 1), Ea(l[1], 1)];
      }
    }, r.prototype.calculate = function() {
      var e = this._isOrdinal, t = this._dataMin, i = this._dataMax, n = this._axisDataLen, a = this._boundaryGapInner, o = e ? null : i - t || Math.abs(t), s = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? i : this._modelMaxNum, u = s != null, h = l != null;
      s == null && (s = e ? n ? 0 : NaN : t - a[0] * o), l == null && (l = e ? n ? n - 1 : NaN : i + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var c = $p(s) || $p(l) || e && !n;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !h && (l = 0));
      var f = this._determinedMin, d = this._determinedMax;
      return f != null && (s = f, u = !0), d != null && (l = d, h = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: h,
        isBlank: c
      };
    }, r.prototype.modifyDataMinMax = function(e, t) {
      this[Mue[e]] = t;
    }, r.prototype.setDeterminedMinMax = function(e, t) {
      var i = Due[e];
      this[i] = t;
    }, r.prototype.freeze = function() {
      this.frozen = !0;
    }, r;
  }()
), Due = {
  min: "_determinedMin",
  max: "_determinedMax"
}, Mue = {
  min: "_dataMin",
  max: "_dataMax"
};
function gW(r, e, t) {
  var i = r.rawExtentInfo;
  return i || (i = new Lue(r, e, t), r.rawExtentInfo = i, i);
}
function uO(r, e) {
  return e == null ? null : $p(e) ? NaN : r.parse(e);
}
function vW(r, e) {
  var t = r.type, i = gW(r, e, r.getExtent()).calculate();
  r.setBlank(i.isBlank);
  var n = i.min, a = i.max, o = e.ecModel;
  if (o && t === "time") {
    var s = aW("bar", o), l = !1;
    if (w(s, function(c) {
      l = l || c.getBaseAxis() === e.axis;
    }), l) {
      var u = oW(s), h = kue(n, a, e, u);
      n = h.min, a = h.max;
    }
  }
  return {
    extent: [n, a],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: i.minFixed,
    fixMax: i.maxFixed
  };
}
function kue(r, e, t, i) {
  var n = t.axis.getExtent(), a = n[1] - n[0], o = Eue(i, t.axis);
  if (o === void 0)
    return {
      min: r,
      max: e
    };
  var s = 1 / 0;
  w(o, function(d) {
    s = Math.min(d.offset, s);
  });
  var l = -1 / 0;
  w(o, function(d) {
    l = Math.max(d.offset + d.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, h = e - r, c = 1 - (s + l) / a, f = h / c - h;
  return e += f * (l / u), r -= f * (s / u), {
    min: r,
    max: e
  };
}
function ef(r, e) {
  var t = e, i = vW(r, t), n = i.extent, a = t.get("splitNumber");
  r instanceof Nue && (r.base = t.get("logBase"));
  var o = r.type, s = t.get("interval"), l = o === "interval" || o === "time";
  r.setExtent(n[0], n[1]), r.calcNiceExtent({
    splitNumber: a,
    fixMin: i.fixMin,
    fixMax: i.fixMax,
    minInterval: l ? t.get("minInterval") : null,
    maxInterval: l ? t.get("maxInterval") : null
  }), s != null && r.setInterval && r.setInterval(s);
}
function VS(r, e) {
  if (e = e || r.get("type"), e)
    switch (e) {
      case "category":
        return new vx({
          ordinalMeta: r.getOrdinalMeta ? r.getOrdinalMeta() : r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new dW({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new (rs.getClass(e) || ll)();
    }
}
function Que(r) {
  var e = r.scale.getExtent(), t = e[0], i = e[1];
  return !(t > 0 && i > 0 || t < 0 && i < 0);
}
function Wg(r) {
  var e = r.getLabelModel().get("formatter"), t = r.type === "category" ? r.scale.getExtent()[0] : null;
  return r.scale.type === "time" ? function(i) {
    return function(n, a) {
      return r.scale.getFormattedLabel(n, a, i);
    };
  }(e) : ne(e) ? function(i) {
    return function(n) {
      var a = r.scale.getLabel(n), o = i.replace("{value}", a ?? "");
      return o;
    };
  }(e) : ve(e) ? function(i) {
    return function(n, a) {
      return t != null && (a = n.value - t), i(bx(r, n), a, n.level != null ? {
        level: n.level
      } : null);
    };
  }(e) : function(i) {
    return r.scale.getLabel(i);
  };
}
function bx(r, e) {
  return r.type === "category" ? r.scale.getLabel(e) : e.value;
}
function Uue(r) {
  var e = r.model, t = r.scale;
  if (!(!e.get(["axisLabel", "show"]) || t.isBlank())) {
    var i, n, a = t.getExtent();
    t instanceof vx ? n = t.count() : (i = t.getTicks(), n = i.length);
    var o = r.getLabelModel(), s = Wg(r), l, u = 1;
    n > 40 && (u = Math.ceil(n / 40));
    for (var h = 0; h < n; h += u) {
      var c = i ? i[h] : {
        value: a[0] + h
      }, f = s(c, h), d = o.getTextRect(f), p = $ue(d, o.get("rotate") || 0);
      l ? l.union(p) : l = p;
    }
    return l;
  }
}
function $ue(r, e) {
  var t = e * Math.PI / 180, i = r.width, n = r.height, a = i * Math.abs(Math.cos(t)) + Math.abs(n * Math.sin(t)), o = i * Math.abs(Math.sin(t)) + Math.abs(n * Math.cos(t)), s = new Ue(r.x, r.y, a, o);
  return s;
}
function Sx(r) {
  var e = r.get("interval");
  return e ?? "auto";
}
function OW(r) {
  return r.type === "category" && Sx(r.getLabelModel()) === 0;
}
function kE(r, e) {
  var t = {};
  return w(r.mapDimensionsAll(e), function(i) {
    t[JH(r, i)] = !0;
  }), He(t);
}
function Gue(r, e, t) {
  e && w(kE(e, t), function(i) {
    var n = e.getApproximateExtent(i);
    n[0] < r[0] && (r[0] = n[0]), n[1] > r[1] && (r[1] = n[1]);
  });
}
var zg = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, r.prototype.getCoordSysModel = function() {
    }, r;
  }()
), Bue = 1e-8;
function NM(r, e) {
  return Math.abs(r - e) < Bue;
}
function fu(r, e, t) {
  var i = 0, n = r[0];
  if (!n)
    return !1;
  for (var a = 1; a < r.length; a++) {
    var o = r[a];
    i += _o(n[0], n[1], o[0], o[1], e, t), n = o;
  }
  var s = r[0];
  return (!NM(n[0], s[0]) || !NM(n[1], s[1])) && (i += _o(n[0], n[1], s[0], s[1], e, t)), i !== 0;
}
var Vue = [];
function Hy(r, e) {
  for (var t = 0; t < r.length; t++)
    Hr(r[t], r[t], e);
}
function LM(r, e, t, i) {
  for (var n = 0; n < r.length; n++) {
    var a = r[n];
    i && (a = i.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (ws(e, e, a), Ps(t, t, a));
  }
}
function Fue(r) {
  for (var e = 0, t = 0, i = 0, n = r.length, a = r[n - 1][0], o = r[n - 1][1], s = 0; s < n; s++) {
    var l = r[s][0], u = r[s][1], h = a * u - l * o;
    e += h, t += (a + l) * h, i += (o + u) * h, a = l, o = u;
  }
  return e ? [t / e / 3, i / e / 3, e] : [r[0][0] || 0, r[0][1] || 0];
}
var mW = (
  /** @class */
  function() {
    function r(e) {
      this.name = e;
    }
    return r.prototype.setCenter = function(e) {
      this._center = e;
    }, r.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, r;
  }()
), DM = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "polygon", this.exterior = e, this.interiors = t;
    }
    return r;
  }()
), MM = (
  /** @class */
  function() {
    function r(e) {
      this.type = "linestring", this.points = e;
    }
    return r;
  }()
), EW = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this, t) || this;
      return a.type = "geoJSON", a.geometries = i, a._center = n && [n[0], n[1]], a;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this.geometries, i, n = 0, a = 0; a < t.length; a++) {
        var o = t[a], s = o.exterior, l = s && s.length;
        l > n && (i = o, n = l);
      }
      if (i)
        return Fue(i.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, e.prototype.getBoundingRect = function(t) {
      var i = this._rect;
      if (i && !t)
        return i;
      var n = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
      return w(o, function(s) {
        s.type === "polygon" ? LM(s.exterior, n, a, t) : w(s.points, function(l) {
          LM(l, n, a, t);
        });
      }), isFinite(n[0]) && isFinite(n[1]) && isFinite(a[0]) && isFinite(a[1]) || (n[0] = n[1] = a[0] = a[1] = 0), i = new Ue(n[0], n[1], a[0] - n[0], a[1] - n[1]), t || (this._rect = i), i;
    }, e.prototype.contain = function(t) {
      var i = this.getBoundingRect(), n = this.geometries;
      if (!i.contain(t[0], t[1]))
        return !1;
      e:
        for (var a = 0, o = n.length; a < o; a++) {
          var s = n[a];
          if (s.type === "polygon") {
            var l = s.exterior, u = s.interiors;
            if (fu(l, t[0], t[1])) {
              for (var h = 0; h < (u ? u.length : 0); h++)
                if (fu(u[h], t[0], t[1]))
                  continue e;
              return !0;
            }
          }
        }
      return !1;
    }, e.prototype.transformTo = function(t, i, n, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      n ? a || (a = n / s) : n = s * a;
      for (var l = new Ue(t, i, n, a), u = o.calculateTransform(l), h = this.geometries, c = 0; c < h.length; c++) {
        var f = h[c];
        f.type === "polygon" ? (Hy(f.exterior, u), w(f.interiors, function(d) {
          Hy(d, u);
        })) : w(f.points, function(d) {
          Hy(d, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
    }, e.prototype.cloneShallow = function(t) {
      t == null && (t = this.name);
      var i = new e(t, this.geometries, this._center);
      return i._rect = this._rect, i.transformTo = null, i;
    }, e;
  }(mW)
), Xue = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i) {
      var n = r.call(this, t) || this;
      return n.type = "geoSVG", n._elOnlyForCalculate = i, n;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this._elOnlyForCalculate, i = t.getBoundingRect(), n = [i.x + i.width / 2, i.y + i.height / 2], a = gS(Vue), o = t; o && !o.isGeoSVGGraphicRoot; )
        Mo(a, o.getLocalTransform(), a), o = o.parent;
      return Ef(a, a), Hr(n, n, a), n;
    }, e;
  }(mW)
);
function Yue(r) {
  if (!r.UTF8Encoding)
    return r;
  var e = r, t = e.UTF8Scale;
  t == null && (t = 1024);
  var i = e.features;
  return w(i, function(n) {
    var a = n.geometry, o = a.encodeOffsets, s = a.coordinates;
    if (o)
      switch (a.type) {
        case "LineString":
          a.coordinates = bW(s, o, t);
          break;
        case "Polygon":
          Wy(s, o, t);
          break;
        case "MultiLineString":
          Wy(s, o, t);
          break;
        case "MultiPolygon":
          w(s, function(l, u) {
            return Wy(l, o[u], t);
          });
      }
  }), e.UTF8Encoding = !1, e;
}
function Wy(r, e, t) {
  for (var i = 0; i < r.length; i++)
    r[i] = bW(r[i], e[i], t);
}
function bW(r, e, t) {
  for (var i = [], n = e[0], a = e[1], o = 0; o < r.length; o += 2) {
    var s = r.charCodeAt(o) - 64, l = r.charCodeAt(o + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += n, l += a, n = s, a = l, i.push([s / t, l / t]);
  }
  return i;
}
function Hue(r, e) {
  return r = Yue(r), Y(yt(r.features, function(t) {
    return t.geometry && t.properties && t.geometry.coordinates.length > 0;
  }), function(t) {
    var i = t.properties, n = t.geometry, a = [];
    switch (n.type) {
      case "Polygon":
        var o = n.coordinates;
        a.push(new DM(o[0], o.slice(1)));
        break;
      case "MultiPolygon":
        w(n.coordinates, function(l) {
          l[0] && a.push(new DM(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        a.push(new MM([n.coordinates]));
        break;
      case "MultiLineString":
        a.push(new MM(n.coordinates));
    }
    var s = new EW(i[e || "name"], a, i.cp);
    return s.properties = i, s;
  });
}
var tg = at();
function Wue(r) {
  return r.type === "category" ? Zue(r) : jue(r);
}
function zue(r, e) {
  return r.type === "category" ? que(r, e) : {
    ticks: Y(r.scale.getTicks(), function(t) {
      return t.value;
    })
  };
}
function Zue(r) {
  var e = r.getLabelModel(), t = SW(r, e);
  return !e.get("show") || r.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: t.labelCategoryInterval
  } : t;
}
function SW(r, e) {
  var t = TW(r, "labels"), i = Sx(e), n = yW(t, i);
  if (n)
    return n;
  var a, o;
  return ve(i) ? a = CW(r, i) : (o = i === "auto" ? Kue(r) : i, a = AW(r, o)), RW(t, i, {
    labels: a,
    labelCategoryInterval: o
  });
}
function que(r, e) {
  var t = TW(r, "ticks"), i = Sx(e), n = yW(t, i);
  if (n)
    return n;
  var a, o;
  if ((!e.get("show") || r.scale.isBlank()) && (a = []), ve(i))
    a = CW(r, i, !0);
  else if (i === "auto") {
    var s = SW(r, r.getLabelModel());
    o = s.labelCategoryInterval, a = Y(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    o = i, a = AW(r, o, !0);
  return RW(t, i, {
    ticks: a,
    tickCategoryInterval: o
  });
}
function jue(r) {
  var e = r.scale.getTicks(), t = Wg(r);
  return {
    labels: Y(e, function(i, n) {
      return {
        level: i.level,
        formattedLabel: t(i, n),
        rawLabel: r.scale.getLabel(i),
        tickValue: i.value
      };
    })
  };
}
function TW(r, e) {
  return tg(r)[e] || (tg(r)[e] = []);
}
function yW(r, e) {
  for (var t = 0; t < r.length; t++)
    if (r[t].key === e)
      return r[t].value;
}
function RW(r, e, t) {
  return r.push({
    key: e,
    value: t
  }), t;
}
function Kue(r) {
  var e = tg(r).autoInterval;
  return e ?? (tg(r).autoInterval = r.calculateCategoryInterval());
}
function Jue(r) {
  var e = ehe(r), t = Wg(r), i = (e.axisRotate - e.labelRotate) / 180 * Math.PI, n = r.scale, a = n.getExtent(), o = n.count();
  if (a[1] - a[0] < 1)
    return 0;
  var s = 1;
  o > 40 && (s = Math.max(1, Math.floor(o / 40)));
  for (var l = a[0], u = r.dataToCoord(l + 1) - r.dataToCoord(l), h = Math.abs(u * Math.cos(i)), c = Math.abs(u * Math.sin(i)), f = 0, d = 0; l <= a[1]; l += s) {
    var p = 0, g = 0, v = Qg(t({
      value: l
    }), e.font, "center", "top");
    p = v.width * 1.3, g = v.height * 1.3, f = Math.max(f, p, 7), d = Math.max(d, g, 7);
  }
  var O = f / h, m = d / c;
  isNaN(O) && (O = 1 / 0), isNaN(m) && (m = 1 / 0);
  var E = Math.max(0, Math.floor(Math.min(O, m))), b = tg(r.model), T = r.getExtent(), S = b.lastAutoInterval, y = b.lastTickCount;
  return S != null && y != null && Math.abs(S - E) <= 1 && Math.abs(y - o) <= 1 && S > E && b.axisExtent0 === T[0] && b.axisExtent1 === T[1] ? E = S : (b.lastTickCount = o, b.lastAutoInterval = E, b.axisExtent0 = T[0], b.axisExtent1 = T[1]), E;
}
function ehe(r) {
  var e = r.getLabelModel();
  return {
    axisRotate: r.getRotate ? r.getRotate() : r.isHorizontal && !r.isHorizontal() ? 90 : 0,
    labelRotate: e.get("rotate") || 0,
    font: e.getFont()
  };
}
function AW(r, e, t) {
  var i = Wg(r), n = r.scale, a = n.getExtent(), o = r.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), u = a[0], h = n.count();
  u !== 0 && l > 1 && h / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var c = OW(r), f = o.get("showMinLabel") || c, d = o.get("showMaxLabel") || c;
  f && u !== a[0] && g(a[0]);
  for (var p = u; p <= a[1]; p += l)
    g(p);
  d && p - l !== a[1] && g(a[1]);
  function g(v) {
    var O = {
      value: v
    };
    s.push(t ? v : {
      formattedLabel: i(O),
      rawLabel: n.getLabel(O),
      tickValue: v
    });
  }
  return s;
}
function CW(r, e, t) {
  var i = r.scale, n = Wg(r), a = [];
  return w(i.getTicks(), function(o) {
    var s = i.getLabel(o), l = o.value;
    e(o.value, s) && a.push(t ? l : {
      formattedLabel: n(o),
      rawLabel: s,
      tickValue: l
    });
  }), a;
}
var kM = [0, 1], the = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.onBand = !1, this.inverse = !1, this.dim = e, this.scale = t, this._extent = i || [0, 0];
    }
    return r.prototype.contain = function(e) {
      var t = this._extent, i = Math.min(t[0], t[1]), n = Math.max(t[0], t[1]);
      return e >= i && e <= n;
    }, r.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.getPixelPrecision = function(e) {
      return cX(e || this.scale.getExtent(), this._extent);
    }, r.prototype.setExtent = function(e, t) {
      var i = this._extent;
      i[0] = e, i[1] = t;
    }, r.prototype.dataToCoord = function(e, t) {
      var i = this._extent, n = this.scale;
      return e = n.normalize(e), this.onBand && n.type === "ordinal" && (i = i.slice(), QM(i, n.count())), Et(e, kM, i, t);
    }, r.prototype.coordToData = function(e, t) {
      var i = this._extent, n = this.scale;
      this.onBand && n.type === "ordinal" && (i = i.slice(), QM(i, n.count()));
      var a = Et(e, i, kM, t);
      return this.scale.scale(a);
    }, r.prototype.pointToData = function(e, t) {
    }, r.prototype.getTicksCoords = function(e) {
      e = e || {};
      var t = e.tickModel || this.getTickModel(), i = zue(this, t), n = i.ticks, a = Y(n, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = t.get("alignWithLabel");
      return rhe(this, a, o, e.clamp), a;
    }, r.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var e = this.model.getModel("minorTick"), t = e.get("splitNumber");
      t > 0 && t < 100 || (t = 5);
      var i = this.scale.getMinorTicks(t), n = Y(i, function(a) {
        return Y(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return n;
    }, r.prototype.getViewLabels = function() {
      return Wue(this).labels;
    }, r.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, r.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, r.prototype.getBandWidth = function() {
      var e = this._extent, t = this.scale.getExtent(), i = t[1] - t[0] + (this.onBand ? 1 : 0);
      i === 0 && (i = 1);
      var n = Math.abs(e[1] - e[0]);
      return Math.abs(n) / i;
    }, r.prototype.calculateCategoryInterval = function() {
      return Jue(this);
    }, r;
  }()
);
function QM(r, e) {
  var t = r[1] - r[0], i = e, n = t / i / 2;
  r[0] += n, r[1] -= n;
}
function rhe(r, e, t, i) {
  var n = e.length;
  if (!r.onBand || t || !n)
    return;
  var a = r.getExtent(), o, s;
  if (n === 1)
    e[0].coord = a[0], o = e[1] = {
      coord: a[1]
    };
  else {
    var l = e[n - 1].tickValue - e[0].tickValue, u = (e[n - 1].coord - e[0].coord) / l;
    w(e, function(d) {
      d.coord -= u / 2;
    });
    var h = r.scale.getExtent();
    s = 1 + h[1] - e[n - 1].tickValue, o = {
      coord: e[n - 1].coord + u * s
    }, e.push(o);
  }
  var c = a[0] > a[1];
  f(e[0].coord, a[0]) && (i ? e[0].coord = a[0] : e.shift()), i && f(a[0], e[0].coord) && e.unshift({
    coord: a[0]
  }), f(a[1], o.coord) && (i ? o.coord = a[1] : e.pop()), i && f(o.coord, a[1]) && e.push({
    coord: a[1]
  });
  function f(d, p) {
    return d = Kt(d), p = Kt(p), c ? d > p : d < p;
  }
}
const Ta = the;
var ud = Math.PI * 2, ql = lo.CMD, ihe = ["top", "right", "bottom", "left"];
function nhe(r, e, t, i, n) {
  var a = t.width, o = t.height;
  switch (r) {
    case "top":
      i.set(t.x + a / 2, t.y - e), n.set(0, -1);
      break;
    case "bottom":
      i.set(t.x + a / 2, t.y + o + e), n.set(0, 1);
      break;
    case "left":
      i.set(t.x - e, t.y + o / 2), n.set(-1, 0);
      break;
    case "right":
      i.set(t.x + a + e, t.y + o / 2), n.set(1, 0);
      break;
  }
}
function ahe(r, e, t, i, n, a, o, s, l) {
  o -= r, s -= e;
  var u = Math.sqrt(o * o + s * s);
  o /= u, s /= u;
  var h = o * t + r, c = s * t + e;
  if (Math.abs(i - n) % ud < 1e-4)
    return l[0] = h, l[1] = c, u - t;
  if (a) {
    var f = i;
    i = ca(n), n = ca(f);
  } else
    i = ca(i), n = ca(n);
  i > n && (n += ud);
  var d = Math.atan2(s, o);
  if (d < 0 && (d += ud), d >= i && d <= n || d + ud >= i && d + ud <= n)
    return l[0] = h, l[1] = c, u - t;
  var p = t * Math.cos(i) + r, g = t * Math.sin(i) + e, v = t * Math.cos(n) + r, O = t * Math.sin(n) + e, m = (p - o) * (p - o) + (g - s) * (g - s), E = (v - o) * (v - o) + (O - s) * (O - s);
  return m < E ? (l[0] = p, l[1] = g, Math.sqrt(m)) : (l[0] = v, l[1] = O, Math.sqrt(E));
}
function QE(r, e, t, i, n, a, o, s) {
  var l = n - r, u = a - e, h = t - r, c = i - e, f = Math.sqrt(h * h + c * c);
  h /= f, c /= f;
  var d = l * h + u * c, p = d / f;
  s && (p = Math.min(Math.max(p, 0), 1)), p *= f;
  var g = o[0] = r + p * h, v = o[1] = e + p * c;
  return Math.sqrt((g - n) * (g - n) + (v - a) * (v - a));
}
function _W(r, e, t, i, n, a, o) {
  t < 0 && (r = r + t, t = -t), i < 0 && (e = e + i, i = -i);
  var s = r + t, l = e + i, u = o[0] = Math.min(Math.max(n, r), s), h = o[1] = Math.min(Math.max(a, e), l);
  return Math.sqrt((u - n) * (u - n) + (h - a) * (h - a));
}
var oa = [];
function ohe(r, e, t) {
  var i = _W(e.x, e.y, e.width, e.height, r.x, r.y, oa);
  return t.set(oa[0], oa[1]), i;
}
function she(r, e, t) {
  for (var i = 0, n = 0, a = 0, o = 0, s, l, u = 1 / 0, h = e.data, c = r.x, f = r.y, d = 0; d < h.length; ) {
    var p = h[d++];
    d === 1 && (i = h[d], n = h[d + 1], a = i, o = n);
    var g = u;
    switch (p) {
      case ql.M:
        a = h[d++], o = h[d++], i = a, n = o;
        break;
      case ql.L:
        g = QE(i, n, h[d], h[d + 1], c, f, oa, !0), i = h[d++], n = h[d++];
        break;
      case ql.C:
        g = YF(i, n, h[d++], h[d++], h[d++], h[d++], h[d], h[d + 1], c, f, oa), i = h[d++], n = h[d++];
        break;
      case ql.Q:
        g = WF(i, n, h[d++], h[d++], h[d], h[d + 1], c, f, oa), i = h[d++], n = h[d++];
        break;
      case ql.A:
        var v = h[d++], O = h[d++], m = h[d++], E = h[d++], b = h[d++], T = h[d++];
        d += 1;
        var S = !!(1 - h[d++]);
        s = Math.cos(b) * m + v, l = Math.sin(b) * E + O, d <= 1 && (a = s, o = l);
        var y = (c - v) * E / m + v;
        g = ahe(v, O, E, b, b + T, S, y, f, oa), i = Math.cos(b + T) * m + v, n = Math.sin(b + T) * E + O;
        break;
      case ql.R:
        a = i = h[d++], o = n = h[d++];
        var A = h[d++], C = h[d++];
        g = _W(a, o, A, C, c, f, oa);
        break;
      case ql.Z:
        g = QE(i, n, a, o, c, f, oa, !0), i = a, n = o;
        break;
    }
    g < u && (u = g, t.set(oa[0], oa[1]));
  }
  return u;
}
var fa = new Le(), It = new Le(), rr = new Le(), za = new Le(), Ba = new Le();
function UM(r, e) {
  if (r) {
    var t = r.getTextGuideLine(), i = r.getTextContent();
    if (i && t) {
      var n = r.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = n.candidates || ihe, s = i.getBoundingRect().clone();
      s.applyTransform(i.getComputedTransform());
      var l = 1 / 0, u = n.anchor, h = r.getComputedTransform(), c = h && Ef([], h), f = e.get("length2") || 0;
      u && rr.copy(u);
      for (var d = 0; d < o.length; d++) {
        var p = o[d];
        nhe(p, 0, s, fa, za), Le.scaleAndAdd(It, fa, za, f), It.transform(c);
        var g = r.getBoundingRect(), v = u ? u.distance(It) : r instanceof Fe ? she(It, r.path, rr) : ohe(It, g, rr);
        v < l && (l = v, It.transform(h), rr.transform(h), rr.toArray(a[0]), It.toArray(a[1]), fa.toArray(a[2]));
      }
      IW(a, e.get("minTurnAngle")), t.setShape({
        points: a
      });
    }
  }
}
var UE = [], Ei = new Le();
function IW(r, e) {
  if (e <= 180 && e > 0) {
    e = e / 180 * Math.PI, fa.fromArray(r[0]), It.fromArray(r[1]), rr.fromArray(r[2]), Le.sub(za, fa, It), Le.sub(Ba, rr, It);
    var t = za.len(), i = Ba.len();
    if (!(t < 1e-3 || i < 1e-3)) {
      za.scale(1 / t), Ba.scale(1 / i);
      var n = za.dot(Ba), a = Math.cos(e);
      if (a < n) {
        var o = QE(It.x, It.y, rr.x, rr.y, fa.x, fa.y, UE, !1);
        Ei.fromArray(UE), Ei.scaleAndAdd(Ba, o / Math.tan(Math.PI - e));
        var s = rr.x !== It.x ? (Ei.x - It.x) / (rr.x - It.x) : (Ei.y - It.y) / (rr.y - It.y);
        if (isNaN(s))
          return;
        s < 0 ? Le.copy(Ei, It) : s > 1 && Le.copy(Ei, rr), Ei.toArray(r[1]);
      }
    }
  }
}
function lhe(r, e, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, fa.fromArray(r[0]), It.fromArray(r[1]), rr.fromArray(r[2]), Le.sub(za, It, fa), Le.sub(Ba, rr, It);
    var i = za.len(), n = Ba.len();
    if (!(i < 1e-3 || n < 1e-3)) {
      za.scale(1 / i), Ba.scale(1 / n);
      var a = za.dot(e), o = Math.cos(t);
      if (a < o) {
        var s = QE(It.x, It.y, rr.x, rr.y, fa.x, fa.y, UE, !1);
        Ei.fromArray(UE);
        var l = Math.PI / 2, u = Math.acos(Ba.dot(e)), h = l + u - t;
        if (h >= l)
          Le.copy(Ei, rr);
        else {
          Ei.scaleAndAdd(Ba, s / Math.tan(Math.PI / 2 - h));
          var c = rr.x !== It.x ? (Ei.x - It.x) / (rr.x - It.x) : (Ei.y - It.y) / (rr.y - It.y);
          if (isNaN(c))
            return;
          c < 0 ? Le.copy(Ei, It) : c > 1 && Le.copy(Ei, rr);
        }
        Ei.toArray(r[1]);
      }
    }
  }
}
function $M(r, e, t, i) {
  var n = t === "normal", a = n ? r : r.ensureState(t);
  a.ignore = e;
  var o = i.get("smooth");
  o && o === !0 && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
  var s = i.getModel("lineStyle").getLineStyle();
  n ? r.useStyle(s) : a.style = s;
}
function uhe(r, e) {
  var t = e.smooth, i = e.points;
  if (i)
    if (r.moveTo(i[0][0], i[0][1]), t > 0 && i.length >= 3) {
      var n = xs(i[0], i[1]), a = xs(i[1], i[2]);
      if (!n || !a) {
        r.lineTo(i[1][0], i[1][1]), r.lineTo(i[2][0], i[2][1]);
        return;
      }
      var o = Math.min(n, a) * t, s = hm([], i[1], i[0], o / n), l = hm([], i[1], i[2], o / a), u = hm([], s, l, 0.5);
      r.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), r.bezierCurveTo(l[0], l[1], l[0], l[1], i[2][0], i[2][1]);
    } else
      for (var h = 1; h < i.length; h++)
        r.lineTo(i[h][0], i[h][1]);
}
function Tx(r, e, t) {
  var i = r.getTextGuideLine(), n = r.getTextContent();
  if (!n) {
    i && r.removeTextGuideLine();
    return;
  }
  for (var a = e.normal, o = a.get("show"), s = n.ignore, l = 0; l < Yp.length; l++) {
    var u = Yp[l], h = e[u], c = u === "normal";
    if (h) {
      var f = h.get("show"), d = c ? s : ke(n.states[u] && n.states[u].ignore, s);
      if (d || !ke(f, o)) {
        var p = c ? i : i && i.states[u];
        p && (p.ignore = !0);
        continue;
      }
      i || (i = new Wi(), r.setTextGuideLine(i), !c && (s || !o) && $M(i, !0, "normal", e.normal), r.stateProxy && (i.stateProxy = r.stateProxy)), $M(i, !1, u, h);
    }
  }
  if (i) {
    me(i.style, t), i.style.fill = null;
    var g = a.get("showAbove"), v = r.textGuideLineConfig = r.textGuideLineConfig || {};
    v.showAbove = g || !1, i.buildPath = uhe;
  }
}
function yx(r, e) {
  e = e || "labelLine";
  for (var t = {
    normal: r.getModel(e)
  }, i = 0; i < Ii.length; i++) {
    var n = Ii[i];
    t[n] = r.getModel([n, e]);
  }
  return t;
}
function xW(r) {
  for (var e = [], t = 0; t < r.length; t++) {
    var i = r[t];
    if (!i.defaultAttr.ignore) {
      var n = i.label, a = n.getComputedTransform(), o = n.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = n.style.margin || 0, u = o.clone();
      u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
      var h = s ? new SE(o, a) : null;
      e.push({
        label: n,
        labelLine: i.labelLine,
        rect: u,
        localRect: o,
        obb: h,
        priority: i.priority,
        defaultAttr: i.defaultAttr,
        layoutOption: i.computedLayoutOption,
        axisAligned: s,
        transform: a
      });
    }
  }
  return e;
}
function wW(r, e, t, i, n, a) {
  var o = r.length;
  if (o < 2)
    return;
  r.sort(function(A, C) {
    return A.rect[e] - C.rect[e];
  });
  for (var s = 0, l, u = !1, h = 0, c = 0; c < o; c++) {
    var f = r[c], d = f.rect;
    l = d[e] - s, l < 0 && (d[e] -= l, f.label[e] -= l, u = !0);
    var p = Math.max(-l, 0);
    h += p, s = d[e] + d[t];
  }
  h > 0 && a && T(-h / o, 0, o);
  var g = r[0], v = r[o - 1], O, m;
  E(), O < 0 && S(-O, 0.8), m < 0 && S(m, 0.8), E(), b(O, m, 1), b(m, O, -1), E(), O < 0 && y(-O), m < 0 && y(m);
  function E() {
    O = g.rect[e] - i, m = n - v.rect[e] - v.rect[t];
  }
  function b(A, C, _) {
    if (A < 0) {
      var I = Math.min(C, -A);
      if (I > 0) {
        T(I * _, 0, o);
        var x = I + A;
        x < 0 && S(-x * _, 1);
      } else
        S(-A * _, 1);
    }
  }
  function T(A, C, _) {
    A !== 0 && (u = !0);
    for (var I = C; I < _; I++) {
      var x = r[I], P = x.rect;
      P[e] += A, x.label[e] += A;
    }
  }
  function S(A, C) {
    for (var _ = [], I = 0, x = 1; x < o; x++) {
      var P = r[x - 1].rect, N = Math.max(r[x].rect[e] - P[e] - P[t], 0);
      _.push(N), I += N;
    }
    if (I) {
      var L = Math.min(Math.abs(A) / I, C);
      if (A > 0)
        for (var x = 0; x < o - 1; x++) {
          var D = _[x] * L;
          T(D, 0, x + 1);
        }
      else
        for (var x = o - 1; x > 0; x--) {
          var D = _[x - 1] * L;
          T(-D, x, o);
        }
    }
  }
  function y(A) {
    var C = A < 0 ? -1 : 1;
    A = Math.abs(A);
    for (var _ = Math.ceil(A / (o - 1)), I = 0; I < o - 1; I++)
      if (C > 0 ? T(_, 0, I + 1) : T(-_, o - I - 1, o), A -= _, A <= 0)
        return;
  }
  return u;
}
function hhe(r, e, t, i) {
  return wW(r, "x", "width", e, t, i);
}
function PW(r, e, t, i) {
  return wW(r, "y", "height", e, t, i);
}
function NW(r) {
  var e = [];
  r.sort(function(g, v) {
    return v.priority - g.priority;
  });
  var t = new Ue(0, 0, 0, 0);
  function i(g) {
    if (!g.ignore) {
      var v = g.ensureState("emphasis");
      v.ignore == null && (v.ignore = !1);
    }
    g.ignore = !0;
  }
  for (var n = 0; n < r.length; n++) {
    var a = r[n], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, h = a.labelLine;
    t.copy(a.rect), t.width -= 0.1, t.height -= 0.1, t.x += 0.05, t.y += 0.05;
    for (var c = a.obb, f = !1, d = 0; d < e.length; d++) {
      var p = e[d];
      if (t.intersect(p.rect)) {
        if (o && p.axisAligned) {
          f = !0;
          break;
        }
        if (p.obb || (p.obb = new SE(p.localRect, p.transform)), c || (c = new SE(s, l)), c.intersect(p.obb)) {
          f = !0;
          break;
        }
      }
    }
    f ? (i(u), h && i(h)) : (u.attr("ignore", a.defaultAttr.ignore), h && h.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a));
  }
}
function che(r) {
  if (r) {
    for (var e = [], t = 0; t < r.length; t++)
      e.push(r[t].slice());
    return e;
  }
}
function fhe(r, e) {
  var t = r.label, i = e && e.getTextGuideLine();
  return {
    dataIndex: r.dataIndex,
    dataType: r.dataType,
    seriesIndex: r.seriesModel.seriesIndex,
    text: r.label.style.text,
    rect: r.hostRect,
    labelRect: r.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: t.style.align,
    verticalAlign: t.style.verticalAlign,
    labelLinePoints: che(i && i.shape.points)
  };
}
var GM = ["align", "verticalAlign", "width", "height", "fontSize"], pi = new wo(), zy = at(), dhe = at();
function hO(r, e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i];
    e[n] != null && (r[n] = e[n]);
  }
}
var cO = ["x", "y", "rotation"], phe = (
  /** @class */
  function() {
    function r() {
      this._labelList = [], this._chartViewList = [];
    }
    return r.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, r.prototype._addLabel = function(e, t, i, n, a) {
      var o = n.style, s = n.__hostTarget, l = s.textConfig || {}, u = n.getComputedTransform(), h = n.getBoundingRect().plain();
      Ue.applyTransform(h, h, u), u ? pi.setLocalTransform(u) : (pi.x = pi.y = pi.rotation = pi.originX = pi.originY = 0, pi.scaleX = pi.scaleY = 1), pi.rotation = ca(pi.rotation);
      var c = n.__hostTarget, f;
      if (c) {
        f = c.getBoundingRect().plain();
        var d = c.getComputedTransform();
        Ue.applyTransform(f, f, d);
      }
      var p = f && c.getTextGuideLine();
      this._labelList.push({
        label: n,
        labelLine: p,
        seriesModel: i,
        dataIndex: e,
        dataType: t,
        layoutOption: a,
        computedLayoutOption: null,
        rect: h,
        hostRect: f,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: f ? f.width * f.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: n.ignore,
          labelGuideIgnore: p && p.ignore,
          x: pi.x,
          y: pi.y,
          scaleX: pi.scaleX,
          scaleY: pi.scaleY,
          rotation: pi.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: n.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, r.prototype.addLabelsOfSeries = function(e) {
      var t = this;
      this._chartViewList.push(e);
      var i = e.__model, n = i.get("labelLayout");
      (ve(n) || He(n).length) && e.group.traverse(function(a) {
        if (a.ignore)
          return !0;
        var o = a.getTextContent(), s = _e(a);
        o && !o.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, i, o, n);
      });
    }, r.prototype.updateLayoutConfig = function(e) {
      var t = e.getWidth(), i = e.getHeight();
      function n(E, b) {
        return function() {
          UM(E, b);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, h = void 0;
        ve(o.layoutOption) ? h = o.layoutOption(fhe(o, l)) : h = o.layoutOption, h = h || {}, o.computedLayoutOption = h;
        var c = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: h.x != null || h.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: h.rotate != null ? h.rotate * c : u.attachedRot,
          offset: [h.dx || 0, h.dy || 0]
        });
        var f = !1;
        if (h.x != null ? (s.x = K(h.x, t), s.setStyle("x", 0), f = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), h.y != null ? (s.y = K(h.y, i), s.setStyle("y", 0), f = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), h.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: h.labelLinePoints
          }), f = !1);
        }
        var p = zy(s);
        p.needsUpdateLabelLine = f, s.rotation = h.rotate != null ? h.rotate * c : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < GM.length; g++) {
          var v = GM[g];
          s.setStyle(v, h[v] != null ? h[v] : u.style[v]);
        }
        if (h.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var O = o.seriesModel;
            if (o.dataIndex != null) {
              var m = o.seriesModel.getData(o.dataType);
              O = m.getItemModel(o.dataIndex);
            }
            s.on("drag", n(l, O.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, r.prototype.layout = function(e) {
      var t = e.getWidth(), i = e.getHeight(), n = xW(this._labelList), a = yt(n, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = yt(n, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      hhe(a, 0, t), PW(o, 0, i);
      var s = yt(n, function(l) {
        return l.layoutOption.hideOverlap;
      });
      NW(s);
    }, r.prototype.processLabelsOverall = function() {
      var e = this;
      w(this._chartViewList, function(t) {
        var i = t.__model, n = t.ignoreLabelLineUpdate, a = i.isAnimationEnabled();
        t.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation)
            return !0;
          var s = !n, l = o.getTextContent();
          !s && l && (s = zy(l).needsUpdateLabelLine), s && e._updateLabelLine(o, i), a && e._animateLabels(o, i);
        });
      });
    }, r.prototype._updateLabelLine = function(e, t) {
      var i = e.getTextContent(), n = _e(e), a = n.dataIndex;
      if (i && a != null) {
        var o = t.getData(n.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var h = o.getVisual("drawType");
          l.stroke = u[h];
        }
        var c = s.getModel("labelLine");
        Tx(e, yx(s), l), UM(e, c);
      }
    }, r.prototype._animateLabels = function(e, t) {
      var i = e.getTextContent(), n = e.getTextGuideLine();
      if (i && (e.forceLabelAnimation || !i.ignore && !i.invisible && !e.disableLabelAnimation && !Pc(e))) {
        var a = zy(i), o = a.oldLayout, s = _e(e), l = s.dataIndex, u = {
          x: i.x,
          y: i.y,
          rotation: i.rotation
        }, h = t.getData(s.dataType);
        if (o) {
          i.attr(o);
          var f = e.prevStates;
          f && (Ge(f, "select") >= 0 && i.attr(a.oldLayoutSelect), Ge(f, "emphasis") >= 0 && i.attr(a.oldLayoutEmphasis)), ft(i, u, t, l);
        } else if (i.attr(u), !Rf(i).valueAnimation) {
          var c = ke(i.style.opacity, 1);
          i.style.opacity = 0, Ut(i, {
            style: {
              opacity: c
            }
          }, t, l);
        }
        if (a.oldLayout = u, i.states.select) {
          var d = a.oldLayoutSelect = {};
          hO(d, u, cO), hO(d, i.states.select, cO);
        }
        if (i.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          hO(p, u, cO), hO(p, i.states.emphasis, cO);
        }
        bY(i, l, h, t, t);
      }
      if (n && !n.ignore && !n.invisible) {
        var a = dhe(n), o = a.oldLayout, g = {
          points: n.shape.points
        };
        o ? (n.attr({
          shape: o
        }), ft(n, {
          shape: g
        }, t)) : (n.setShape(g), n.style.strokePercent = 0, Ut(n, {
          style: {
            strokePercent: 1
          }
        }, t)), a.oldLayout = g;
      }
    }, r;
  }()
);
const ghe = phe;
var Zy = at();
function vhe(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(e, t, i) {
    var n = Zy(t).labelManager;
    n || (n = Zy(t).labelManager = new ghe()), n.clearLabels();
  }), r.registerUpdateLifecycle("series:layoutlabels", function(e, t, i) {
    var n = Zy(t).labelManager;
    i.updatedSeries.forEach(function(a) {
      n.addLabelsOfSeries(t.getViewOfSeriesModel(a));
    }), n.updateLayoutConfig(t), n.layout(t), n.processLabelsOverall();
  });
}
var qy = Math.sin, jy = Math.cos, LW = Math.PI, jl = Math.PI * 2, Ohe = 180 / LW, mhe = function() {
  function r() {
  }
  return r.prototype.reset = function(e) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, e || 4);
  }, r.prototype.moveTo = function(e, t) {
    this._add("M", e, t);
  }, r.prototype.lineTo = function(e, t) {
    this._add("L", e, t);
  }, r.prototype.bezierCurveTo = function(e, t, i, n, a, o) {
    this._add("C", e, t, i, n, a, o);
  }, r.prototype.quadraticCurveTo = function(e, t, i, n) {
    this._add("Q", e, t, i, n);
  }, r.prototype.arc = function(e, t, i, n, a, o) {
    this.ellipse(e, t, i, i, 0, n, a, o);
  }, r.prototype.ellipse = function(e, t, i, n, a, o, s, l) {
    var u = s - o, h = !l, c = Math.abs(u), f = Ds(c - jl) || (h ? u >= jl : -u >= jl), d = u > 0 ? u % jl : u % jl + jl, p = !1;
    f ? p = !0 : Ds(c) ? p = !1 : p = d >= LW == !!h;
    var g = e + i * jy(o), v = t + n * qy(o);
    this._start && this._add("M", g, v);
    var O = Math.round(a * Ohe);
    if (f) {
      var m = 1 / this._p, E = (h ? 1 : -1) * (jl - m);
      this._add("A", i, n, O, 1, +h, e + i * jy(o + E), t + n * qy(o + E)), m > 0.01 && this._add("A", i, n, O, 0, +h, g, v);
    } else {
      var b = e + i * jy(s), T = t + n * qy(s);
      this._add("A", i, n, O, +p, +h, b, T);
    }
  }, r.prototype.rect = function(e, t, i, n) {
    this._add("M", e, t), this._add("l", i, 0), this._add("l", 0, n), this._add("l", -i, 0), this._add("Z");
  }, r.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, r.prototype._add = function(e, t, i, n, a, o, s, l, u) {
    for (var h = [], c = this._p, f = 1; f < arguments.length; f++) {
      var d = arguments[f];
      if (isNaN(d)) {
        this._invalid = !0;
        return;
      }
      h.push(Math.round(d * c) / c);
    }
    this._d.push(e + h.join(" ")), this._start = e === "Z";
  }, r.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, r.prototype.getStr = function() {
    return this._str;
  }, r;
}();
const DW = mhe;
var dp = "none", Ehe = Math.round;
function bhe(r) {
  var e = r.fill;
  return e != null && e !== dp;
}
function She(r) {
  var e = r.stroke;
  return e != null && e !== dp;
}
var yC = ["lineCap", "miterLimit", "lineJoin"], The = Y(yC, function(r) {
  return "stroke-" + r.toLowerCase();
});
function yhe(r, e, t, i) {
  var n = e.opacity == null ? 1 : e.opacity;
  if (t instanceof qr) {
    r("opacity", n);
    return;
  }
  if (bhe(e)) {
    var a = Vp(e.fill);
    r("fill", a.color);
    var o = e.fillOpacity != null ? e.fillOpacity * a.opacity * n : a.opacity * n;
    (i || o < 1) && r("fill-opacity", o);
  } else
    r("fill", dp);
  if (She(e)) {
    var s = Vp(e.stroke);
    r("stroke", s.color);
    var l = e.strokeNoScale ? t.getLineScale() : 1, u = l ? (e.lineWidth || 0) / l : 0, h = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * n : s.opacity * n, c = e.strokeFirst;
    if ((i || u !== 1) && r("stroke-width", u), (i || c) && r("paint-order", c ? "stroke" : "fill"), (i || h < 1) && r("stroke-opacity", h), e.lineDash) {
      var f = cx(t), d = f[0], p = f[1];
      d && (p = Ehe(p || 0), r("stroke-dasharray", d.join(",")), (p || i) && r("stroke-dashoffset", p));
    } else
      i && r("stroke-dasharray", dp);
    for (var g = 0; g < yC.length; g++) {
      var v = yC[g];
      if (i || e[v] !== EE[v]) {
        var O = e[v] || EE[v];
        O && r(The[g], O);
      }
    }
  } else
    i && r("stroke", dp);
}
var MW = "http://www.w3.org/2000/svg", kW = "http://www.w3.org/1999/xlink", Rhe = "http://www.w3.org/2000/xmlns/", Ahe = "http://www.w3.org/XML/1998/namespace";
function QW(r) {
  return document.createElementNS(MW, r);
}
function yr(r, e, t, i, n) {
  return {
    tag: r,
    attrs: t || {},
    children: i,
    text: n,
    key: e
  };
}
function Che(r, e) {
  var t = [];
  if (e)
    for (var i in e) {
      var n = e[i], a = i;
      n !== !1 && (n !== !0 && n != null && (a += '="' + n + '"'), t.push(a));
    }
  return "<" + r + " " + t.join(" ") + ">";
}
function _he(r) {
  return "</" + r + ">";
}
function Rx(r, e) {
  e = e || {};
  var t = e.newline ? `
` : "";
  function i(n) {
    var a = n.children, o = n.tag, s = n.attrs, l = n.text;
    return Che(o, s) + (o !== "style" ? Di(l) : l || "") + (a ? "" + t + Y(a, function(u) {
      return i(u);
    }).join(t) + t : "") + _he(o);
  }
  return i(r);
}
function Ihe(r, e, t) {
  t = t || {};
  var i = t.newline ? `
` : "", n = " {" + i, a = i + "}", o = Y(He(r), function(l) {
    return l + n + Y(He(r[l]), function(u) {
      return u + ":" + r[l][u] + ";";
    }).join(i) + a;
  }).join(i), s = Y(He(e), function(l) {
    return "@keyframes " + l + n + Y(He(e[l]), function(u) {
      return u + n + Y(He(e[l][u]), function(h) {
        var c = e[l][u][h];
        return h === "d" && (c = 'path("' + c + '")'), h + ":" + c + ";";
      }).join(i) + a;
    }).join(i) + a;
  }).join(i);
  return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(i);
}
function RC(r) {
  return {
    zrId: r,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssClassIdx: 0,
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function BM(r, e, t, i) {
  return yr("svg", "root", {
    width: r,
    height: e,
    xmlns: MW,
    "xmlns:xlink": kW,
    version: "1.1",
    baseProfile: "full",
    viewBox: i ? "0 0 " + r + " " + e : !1
  }, t);
}
var VM = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, iu = "transform-origin";
function xhe(r, e, t) {
  var i = V({}, r.shape);
  V(i, e), r.buildPath(t, i);
  var n = new DW();
  return n.reset(eX(r)), t.rebuildPath(n, 1), n.generateStr(), n.getStr();
}
function whe(r, e) {
  var t = e.originX, i = e.originY;
  (t || i) && (r[iu] = t + "px " + i + "px");
}
var Phe = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function UW(r, e) {
  var t = e.zrId + "-ani-" + e.cssAnimIdx++;
  return e.cssAnims[t] = r, t;
}
function Nhe(r, e, t) {
  var i = r.shape.paths, n = {}, a, o;
  if (w(i, function(l) {
    var u = RC(t.zrId);
    u.animation = !0, FS(l, {}, u, !0);
    var h = u.cssAnims, c = u.cssNodes, f = He(h), d = f.length;
    if (d) {
      o = f[d - 1];
      var p = h[o];
      for (var g in p) {
        var v = p[g];
        n[g] = n[g] || { d: "" }, n[g].d += v.d || "";
      }
      for (var O in c) {
        var m = c[O].animation;
        m.indexOf(o) >= 0 && (a = m);
      }
    }
  }), !!a) {
    e.d = !1;
    var s = UW(n, t);
    return a.replace(o, s);
  }
}
function FM(r) {
  return ne(r) ? VM[r] ? "cubic-bezier(" + VM[r] + ")" : _I(r) ? r : "" : "";
}
function FS(r, e, t, i) {
  var n = r.animators, a = n.length, o = [];
  if (r instanceof XI) {
    var s = Nhe(r, e, t);
    if (s)
      o.push(s);
    else if (!a)
      return;
  } else if (!a)
    return;
  for (var l = {}, u = 0; u < a; u++) {
    var h = n[u], c = [h.getMaxTime() / 1e3 + "s"], f = FM(h.getClip().easing), d = h.getDelay();
    f ? c.push(f) : c.push("linear"), d && c.push(d / 1e3 + "s"), h.getLoop() && c.push("infinite");
    var p = c.join(" ");
    l[p] = l[p] || [p, []], l[p][1].push(h);
  }
  function g(m) {
    var E = m[1], b = E.length, T = {}, S = {}, y = {}, A = "animation-timing-function";
    function C(Ee, xe, Ce) {
      for (var ue = Ee.getTracks(), M = Ee.getMaxTime(), Q = 0; Q < ue.length; Q++) {
        var B = ue[Q];
        if (B.needsAnimate()) {
          var W = B.keyframes, H = B.propName;
          if (Ce && (H = Ce(H)), H)
            for (var J = 0; J < W.length; J++) {
              var le = W[J], ee = Math.round(le.time / M * 100) + "%", se = FM(le.easing), j = le.rawValue;
              (ne(j) || ut(j)) && (xe[ee] = xe[ee] || {}, xe[ee][H] = le.rawValue, se && (xe[ee][A] = se));
            }
        }
      }
    }
    for (var _ = 0; _ < b; _++) {
      var I = E[_], x = I.targetName;
      x ? x === "shape" && C(I, S) : !i && C(I, T);
    }
    for (var P in T) {
      var N = {};
      aX(N, r), V(N, T[P]);
      var L = tX(N), D = T[P][A];
      y[P] = L ? {
        transform: L
      } : {}, whe(y[P], N), D && (y[P][A] = D);
    }
    var $, k = !0;
    for (var P in S) {
      y[P] = y[P] || {};
      var G = !$, D = S[P][A];
      G && ($ = new lo());
      var F = $.len();
      $.reset(), y[P].d = xhe(r, S[P], $);
      var q = $.len();
      if (!G && F !== q) {
        k = !1;
        break;
      }
      D && (y[P][A] = D);
    }
    if (!k)
      for (var P in y)
        delete y[P].d;
    if (!i)
      for (var _ = 0; _ < b; _++) {
        var I = E[_], x = I.targetName;
        x === "style" && C(I, y, function(ue) {
          return Phe[ue];
        });
      }
    for (var re = He(y), fe = !0, de, _ = 1; _ < re.length; _++) {
      var $e = re[_ - 1], Pe = re[_];
      if (y[$e][iu] !== y[Pe][iu]) {
        fe = !1;
        break;
      }
      de = y[$e][iu];
    }
    if (fe && de) {
      for (var P in y)
        y[P][iu] && delete y[P][iu];
      e[iu] = de;
    }
    if (yt(re, function(Ee) {
      return He(y[Ee]).length > 0;
    }).length) {
      var Ne = UW(y, t);
      return Ne + " " + m[0] + " both";
    }
  }
  for (var v in l) {
    var s = g(l[v]);
    s && o.push(s);
  }
  if (o.length) {
    var O = t.zrId + "-cls-" + t.cssClassIdx++;
    t.cssNodes["." + O] = {
      animation: o.join(",")
    }, e.class = O;
  }
}
var rg = Math.round;
function $W(r) {
  return r && ne(r.src);
}
function GW(r) {
  return r && ve(r.toDataURL);
}
function Ax(r, e, t, i) {
  yhe(function(n, a) {
    var o = n === "fill" || n === "stroke";
    o && JF(a) ? VW(e, r, n, i) : o && II(a) ? FW(t, r, n, i) : r[n] = a;
  }, e, t, !1), $he(t, r, i);
}
function XM(r) {
  return Ds(r[0] - 1) && Ds(r[1]) && Ds(r[2]) && Ds(r[3] - 1);
}
function Lhe(r) {
  return Ds(r[4]) && Ds(r[5]);
}
function Cx(r, e, t) {
  if (e && !(Lhe(e) && XM(e))) {
    var i = t ? 10 : 1e4;
    r.transform = XM(e) ? "translate(" + rg(e[4] * i) / i + " " + rg(e[5] * i) / i + ")" : Nre(e);
  }
}
function YM(r, e, t) {
  for (var i = r.points, n = [], a = 0; a < i.length; a++)
    n.push(rg(i[a][0] * t) / t), n.push(rg(i[a][1] * t) / t);
  e.points = n.join(" ");
}
function HM(r) {
  return !r.smooth;
}
function Dhe(r) {
  var e = Y(r, function(t) {
    return typeof t == "string" ? [t, t] : t;
  });
  return function(t, i, n) {
    for (var a = 0; a < e.length; a++) {
      var o = e[a], s = t[o[0]];
      s != null && (i[o[1]] = rg(s * n) / n);
    }
  };
}
var Mhe = {
  circle: [Dhe(["cx", "cy", "r"])],
  polyline: [YM, HM],
  polygon: [YM, HM]
};
function khe(r) {
  for (var e = r.animators, t = 0; t < e.length; t++)
    if (e[t].targetName === "shape")
      return !0;
  return !1;
}
function BW(r, e) {
  var t = r.style, i = r.shape, n = Mhe[r.type], a = {}, o = e.animation, s = "path", l = r.style.strokePercent, u = e.compress && eX(r) || 4;
  if (n && !e.willUpdate && !(n[1] && !n[1](i)) && !(o && khe(r)) && !(l < 1)) {
    s = r.type;
    var h = Math.pow(10, u);
    n[0](i, a, h);
  } else {
    var c = !r.path || r.shapeChanged();
    r.path || r.createPathProxy();
    var f = r.path;
    c && (f.beginPath(), r.buildPath(f, r.shape), r.pathUpdated());
    var d = f.getVersion(), p = r, g = p.__svgPathBuilder;
    (p.__svgPathVersion !== d || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new DW()), g.reset(u), f.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), a.d = g.getStr();
  }
  return Cx(a, r.transform), Ax(a, t, r, e), e.animation && FS(r, a, e), yr(s, r.id + "", a);
}
function Qhe(r, e) {
  var t = r.style, i = t.image;
  if (i && !ne(i) && ($W(i) ? i = i.src : GW(i) && (i = i.toDataURL())), !!i) {
    var n = t.x || 0, a = t.y || 0, o = t.width, s = t.height, l = {
      href: i,
      width: o,
      height: s
    };
    return n && (l.x = n), a && (l.y = a), Cx(l, r.transform), Ax(l, t, r, e), e.animation && FS(r, l, e), yr("image", r.id + "", l);
  }
}
function Uhe(r, e) {
  var t = r.style, i = t.text;
  if (i != null && (i += ""), !(!i || isNaN(t.x) || isNaN(t.y))) {
    var n = t.font || rl, a = t.x || 0, o = Dre(t.y || 0, OS(n), t.textBaseline), s = Lre[t.textAlign] || t.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (QX(t)) {
      var u = "", h = t.fontStyle, c = kX(t.fontSize);
      if (!parseFloat(c))
        return;
      var f = t.fontFamily || IF, d = t.fontWeight;
      u += "font-size:" + c + ";font-family:" + f + ";", h && h !== "normal" && (u += "font-style:" + h + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
    } else
      l.style = "font: " + n;
    return i.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), Cx(l, r.transform), Ax(l, t, r, e), e.animation && FS(r, l, e), yr("text", r.id + "", l, void 0, i);
  }
}
function WM(r, e) {
  if (r instanceof Fe)
    return BW(r, e);
  if (r instanceof qr)
    return Qhe(r, e);
  if (r instanceof Xp)
    return Uhe(r, e);
}
function $he(r, e, t) {
  var i = r.style;
  if (Mre(i)) {
    var n = kre(r), a = t.shadowCache, o = a[n];
    if (!o) {
      var s = r.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var h = i.shadowOffsetX || 0, c = i.shadowOffsetY || 0, f = i.shadowBlur, d = Vp(i.shadowColor), p = d.opacity, g = d.color, v = f / 2 / l, O = f / 2 / u, m = v + " " + O;
      o = t.zrId + "-s" + t.shadowIdx++, t.defs[o] = yr("filter", o, {
        id: o,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        yr("feDropShadow", "", {
          dx: h / l,
          dy: c / u,
          stdDeviation: m,
          "flood-color": g,
          "flood-opacity": p
        })
      ]), a[n] = o;
    }
    e.filter = vS(o);
  }
}
function VW(r, e, t, i) {
  var n = r[t], a, o = {
    gradientUnits: n.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (jF(n))
    a = "linearGradient", o.x1 = n.x, o.y1 = n.y, o.x2 = n.x2, o.y2 = n.y2;
  else if (KF(n))
    a = "radialGradient", o.cx = ke(n.x, 0.5), o.cy = ke(n.y, 0.5), o.r = ke(n.r, 0.5);
  else
    return;
  for (var s = n.colorStops, l = [], u = 0, h = s.length; u < h; ++u) {
    var c = UA(s[u].offset) * 100 + "%", f = s[u].color, d = Vp(f), p = d.color, g = d.opacity, v = {
      offset: c
    };
    v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(yr("stop", u + "", v));
  }
  var O = yr(a, "", o, l), m = Rx(O), E = i.gradientCache, b = E[m];
  b || (b = i.zrId + "-g" + i.gradientIdx++, E[m] = b, o.id = b, i.defs[b] = yr(a, b, o, l)), e[t] = vS(b);
}
function FW(r, e, t, i) {
  var n = r.style[t], a = r.getBoundingRect(), o = {}, s = n.repeat, l = s === "no-repeat", u = s === "repeat-x", h = s === "repeat-y", c;
  if (qF(n)) {
    var f = n.imageWidth, d = n.imageHeight, p = void 0, g = n.image;
    if (ne(g) ? p = g : $W(g) ? p = g.src : GW(g) && (p = g.toDataURL()), typeof Image > "u") {
      var v = "Image width/height must been given explictly in svg-ssr renderer.";
      _i(f, v), _i(d, v);
    } else if (f == null || d == null) {
      var O = function(_, I) {
        if (_) {
          var x = _.elm, P = f || I.width, N = d || I.height;
          _.tag === "pattern" && (u ? (N = 1, P /= a.width) : h && (P = 1, N /= a.height)), _.attrs.width = P, _.attrs.height = N, x && (x.setAttribute("width", P), x.setAttribute("height", N));
        }
      }, m = MI(p, null, r, function(_) {
        l || O(S, _), O(c, _);
      });
      m && m.width && m.height && (f = f || m.width, d = d || m.height);
    }
    c = yr("image", "img", {
      href: p,
      width: f,
      height: d
    }), o.width = f, o.height = d;
  } else
    n.svgElement && (c = Se(n.svgElement), o.width = n.svgWidth, o.height = n.svgHeight);
  if (c) {
    var E, b;
    l ? E = b = 1 : u ? (b = 1, E = o.width / a.width) : h ? (E = 1, b = o.height / a.height) : o.patternUnits = "userSpaceOnUse", E != null && !isNaN(E) && (o.width = E), b != null && !isNaN(b) && (o.height = b);
    var T = tX(n);
    T && (o.patternTransform = T);
    var S = yr("pattern", "", o, [c]), y = Rx(S), A = i.patternCache, C = A[y];
    C || (C = i.zrId + "-p" + i.patternIdx++, A[y] = C, o.id = C, S = i.defs[C] = yr("pattern", C, o, [c])), e[t] = vS(C);
  }
}
function Ghe(r, e, t) {
  var i = t.clipPathCache, n = t.defs, a = i[r.id];
  if (!a) {
    a = t.zrId + "-c" + t.clipPathIdx++;
    var o = {
      id: a
    };
    i[r.id] = a, n[a] = yr("clipPath", a, o, [BW(r, t)]);
  }
  e["clip-path"] = vS(a);
}
function zM(r) {
  return document.createTextNode(r);
}
function du(r, e, t) {
  r.insertBefore(e, t);
}
function ZM(r, e) {
  r.removeChild(e);
}
function qM(r, e) {
  r.appendChild(e);
}
function XW(r) {
  return r.parentNode;
}
function YW(r) {
  return r.nextSibling;
}
function Ky(r, e) {
  r.textContent = e;
}
var jM = 58, Bhe = 120, Vhe = yr("", "");
function AC(r) {
  return r === void 0;
}
function Qa(r) {
  return r !== void 0;
}
function Fhe(r, e, t) {
  for (var i = {}, n = e; n <= t; ++n) {
    var a = r[n].key;
    a !== void 0 && (i[a] = n);
  }
  return i;
}
function $d(r, e) {
  var t = r.key === e.key, i = r.tag === e.tag;
  return i && t;
}
function ig(r) {
  var e, t = r.children, i = r.tag;
  if (Qa(i)) {
    var n = r.elm = QW(i);
    if (_x(Vhe, r), X(t))
      for (e = 0; e < t.length; ++e) {
        var a = t[e];
        a != null && qM(n, ig(a));
      }
    else
      Qa(r.text) && !be(r.text) && qM(n, zM(r.text));
  } else
    r.elm = zM(r.text);
  return r.elm;
}
function HW(r, e, t, i, n) {
  for (; i <= n; ++i) {
    var a = t[i];
    a != null && du(r, ig(a), e);
  }
}
function $E(r, e, t, i) {
  for (; t <= i; ++t) {
    var n = e[t];
    if (n != null)
      if (Qa(n.tag)) {
        var a = XW(n.elm);
        ZM(a, n.elm);
      } else
        ZM(r, n.elm);
  }
}
function _x(r, e) {
  var t, i = e.elm, n = r && r.attrs || {}, a = e.attrs || {};
  if (n !== a) {
    for (t in a) {
      var o = a[t], s = n[t];
      s !== o && (o === !0 ? i.setAttribute(t, "") : o === !1 ? i.removeAttribute(t) : t.charCodeAt(0) !== Bhe ? i.setAttribute(t, o) : t === "xmlns:xlink" || t === "xmlns" ? i.setAttributeNS(Rhe, t, o) : t.charCodeAt(3) === jM ? i.setAttributeNS(Ahe, t, o) : t.charCodeAt(5) === jM ? i.setAttributeNS(kW, t, o) : i.setAttribute(t, o));
    }
    for (t in n)
      t in a || i.removeAttribute(t);
  }
}
function Xhe(r, e, t) {
  for (var i = 0, n = 0, a = e.length - 1, o = e[0], s = e[a], l = t.length - 1, u = t[0], h = t[l], c, f, d, p; i <= a && n <= l; )
    o == null ? o = e[++i] : s == null ? s = e[--a] : u == null ? u = t[++n] : h == null ? h = t[--l] : $d(o, u) ? (lc(o, u), o = e[++i], u = t[++n]) : $d(s, h) ? (lc(s, h), s = e[--a], h = t[--l]) : $d(o, h) ? (lc(o, h), du(r, o.elm, YW(s.elm)), o = e[++i], h = t[--l]) : $d(s, u) ? (lc(s, u), du(r, s.elm, o.elm), s = e[--a], u = t[++n]) : (AC(c) && (c = Fhe(e, i, a)), f = c[u.key], AC(f) ? du(r, ig(u), o.elm) : (d = e[f], d.tag !== u.tag ? du(r, ig(u), o.elm) : (lc(d, u), e[f] = void 0, du(r, d.elm, o.elm))), u = t[++n]);
  (i <= a || n <= l) && (i > a ? (p = t[l + 1] == null ? null : t[l + 1].elm, HW(r, p, t, n, l)) : $E(r, e, i, a));
}
function lc(r, e) {
  var t = e.elm = r.elm, i = r.children, n = e.children;
  r !== e && (_x(r, e), AC(e.text) ? Qa(i) && Qa(n) ? i !== n && Xhe(t, i, n) : Qa(n) ? (Qa(r.text) && Ky(t, ""), HW(t, null, n, 0, n.length - 1)) : Qa(i) ? $E(t, i, 0, i.length - 1) : Qa(r.text) && Ky(t, "") : r.text !== e.text && (Qa(i) && $E(t, i, 0, i.length - 1), Ky(t, e.text)));
}
function Yhe(r, e) {
  if ($d(r, e))
    lc(r, e);
  else {
    var t = r.elm, i = XW(t);
    ig(e), i !== null && (du(i, e.elm, YW(t)), $E(i, [r], 0, 0));
  }
  return e;
}
var Hhe = 0, Whe = function() {
  function r(e, t, i) {
    if (this.type = "svg", this.refreshHover = KM(), this.configLayer = KM(), this.storage = t, this._opts = i = V({}, i), this.root = e, this._id = "zr" + Hhe++, this._oldVNode = BM(i.width, i.height), e && !i.ssr) {
      var n = this._viewport = document.createElement("div");
      n.style.cssText = "position:relative;overflow:hidden";
      var a = this._svgDom = this._oldVNode.elm = QW("svg");
      _x(null, this._oldVNode), n.appendChild(a), e.appendChild(n);
    }
    this.resize(i.width, i.height);
  }
  return r.prototype.getType = function() {
    return this.type;
  }, r.prototype.getViewportRoot = function() {
    return this._viewport;
  }, r.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, r.prototype.getSvgDom = function() {
    return this._svgDom;
  }, r.prototype.refresh = function() {
    if (this.root) {
      var e = this.renderToVNode({
        willUpdate: !0
      });
      e.attrs.style = "position:absolute;left:0;top:0;user-select:none", Yhe(this._oldVNode, e), this._oldVNode = e;
    }
  }, r.prototype.renderOneToVNode = function(e) {
    return WM(e, RC(this._id));
  }, r.prototype.renderToVNode = function(e) {
    e = e || {};
    var t = this.storage.getDisplayList(!0), i = this._width, n = this._height, a = RC(this._id);
    a.animation = e.animation, a.willUpdate = e.willUpdate, a.compress = e.compress;
    var o = [], s = this._bgVNode = zhe(i, n, this._backgroundColor, a);
    s && o.push(s);
    var l = e.compress ? null : this._mainVNode = yr("g", "main", {}, []);
    this._paintList(t, a, l ? l.children : o), l && o.push(l);
    var u = Y(He(a.defs), function(f) {
      return a.defs[f];
    });
    if (u.length && o.push(yr("defs", "defs", {}, u)), e.animation) {
      var h = Ihe(a.cssNodes, a.cssAnims, { newline: !0 });
      if (h) {
        var c = yr("style", "stl", {}, [], h);
        o.push(c);
      }
    }
    return BM(i, n, o, e.useViewBox);
  }, r.prototype.renderToString = function(e) {
    return e = e || {}, Rx(this.renderToVNode({
      animation: ke(e.cssAnimation, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: ke(e.useViewBox, !0)
    }), { newline: !0 });
  }, r.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e;
  }, r.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, r.prototype._paintList = function(e, t, i) {
    for (var n = e.length, a = [], o = 0, s, l, u = 0, h = 0; h < n; h++) {
      var c = e[h];
      if (!c.invisible) {
        var f = c.__clipPaths, d = f && f.length || 0, p = l && l.length || 0, g = void 0;
        for (g = Math.max(d - 1, p - 1); g >= 0 && !(f && l && f[g] === l[g]); g--)
          ;
        for (var v = p - 1; v > g; v--)
          o--, s = a[o - 1];
        for (var O = g + 1; O < d; O++) {
          var m = {};
          Ghe(f[O], m, t);
          var E = yr("g", "clip-g-" + u++, m, []);
          (s ? s.children : i).push(E), a[o++] = E, s = E;
        }
        l = f;
        var b = WM(c, t);
        b && (s ? s.children : i).push(b);
      }
    }
  }, r.prototype.resize = function(e, t) {
    var i = this._opts, n = this.root, a = this._viewport;
    if (e != null && (i.width = e), t != null && (i.height = t), n && a && (a.style.display = "none", e = Oc(n, 0, i), t = Oc(n, 1, i), a.style.display = ""), this._width !== e || this._height !== t) {
      if (this._width = e, this._height = t, a) {
        var o = a.style;
        o.width = e + "px", o.height = t + "px";
      }
      if (II(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", e), s.setAttribute("height", t));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", e), l.setAttribute("height", t));
      }
    }
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, r.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, r.prototype.toDataURL = function(e) {
    var t = this.renderToString(), i = "data:image/svg+xml;";
    return e ? (t = Ure(t), t && i + "base64," + t) : i + "charset=UTF-8," + encodeURIComponent(t);
  }, r;
}();
function KM(r) {
  return function() {
  };
}
function zhe(r, e, t, i) {
  var n;
  if (t && t !== "none")
    if (n = yr("rect", "bg", {
      width: r,
      height: e,
      x: "0",
      y: "0",
      id: "0"
    }), JF(t))
      VW({ fill: t }, n.attrs, "fill", i);
    else if (II(t))
      FW({
        style: {
          fill: t
        },
        dirty: ar,
        getBoundingRect: function() {
          return { width: r, height: e };
        }
      }, n.attrs, "fill", i);
    else {
      var a = Vp(t), o = a.color, s = a.opacity;
      n.attrs.fill = o, s < 1 && (n.attrs["fill-opacity"] = s);
    }
  return n;
}
const Zhe = Whe;
function qhe(r) {
  r.registerPainter("svg", Zhe);
}
function JM(r, e, t) {
  var i = il.createCanvas(), n = e.getWidth(), a = e.getHeight(), o = i.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = n + "px", o.height = a + "px", i.setAttribute("data-zr-dom-id", r)), i.width = n * t, i.height = a * t, i;
}
var jhe = function(r) {
  U(e, r);
  function e(t, i, n) {
    var a = r.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    n = n || vE, typeof t == "string" ? o = JM(t, i, n) : be(t) && (o = t, t = o.id), a.id = t, a.dom = o;
    var s = o.style;
    return s && (DF(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = i, a.dpr = n, a;
  }
  return e.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, e.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, e.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, e.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, e.prototype.createBackBuffer = function() {
    var t = this.dpr;
    this.domBack = JM("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
  }, e.prototype.createRepaintRects = function(t, i, n, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new Ue(0, 0, 0, 0);
    function h(m) {
      if (!(!m.isFinite() || m.isZero()))
        if (o.length === 0) {
          var E = new Ue(0, 0, 0, 0);
          E.copy(m), o.push(E);
        } else {
          for (var b = !1, T = 1 / 0, S = 0, y = 0; y < o.length; ++y) {
            var A = o[y];
            if (A.intersect(m)) {
              var C = new Ue(0, 0, 0, 0);
              C.copy(A), C.union(m), o[y] = C, b = !0;
              break;
            } else if (l) {
              u.copy(m), u.union(A);
              var _ = m.width * m.height, I = A.width * A.height, x = u.width * u.height, P = x - _ - I;
              P < T && (T = P, S = y);
            }
          }
          if (l && (o[S].union(m), b = !0), !b) {
            var E = new Ue(0, 0, 0, 0);
            E.copy(m), o.push(E);
          }
          l || (l = o.length >= s);
        }
    }
    for (var c = this.__startIndex; c < this.__endIndex; ++c) {
      var f = t[c];
      if (f) {
        var d = f.shouldBePainted(n, a, !0, !0), p = f.__isRendered && (f.__dirty & un || !d) ? f.getPrevPaintRect() : null;
        p && h(p);
        var g = d && (f.__dirty & un || !f.__isRendered) ? f.getPaintRect() : null;
        g && h(g);
      }
    }
    for (var c = this.__prevStartIndex; c < this.__prevEndIndex; ++c) {
      var f = i[c], d = f.shouldBePainted(n, a, !0, !0);
      if (f && (!d || !f.__zr) && f.__isRendered) {
        var p = f.getPrevPaintRect();
        p && h(p);
      }
    }
    var v;
    do {
      v = !1;
      for (var c = 0; c < o.length; ) {
        if (o[c].isZero()) {
          o.splice(c, 1);
          continue;
        }
        for (var O = c + 1; O < o.length; )
          o[c].intersect(o[O]) ? (v = !0, o[c].union(o[O]), o.splice(O, 1)) : O++;
        c++;
      }
    } while (v);
    return this._paintRects = o, o;
  }, e.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, e.prototype.resize = function(t, i) {
    var n = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = t + "px", o.height = i + "px"), a.width = t * n, a.height = i * n, s && (s.width = t * n, s.height = i * n, n !== 1 && this.ctxBack.scale(n, n));
  }, e.prototype.clear = function(t, i, n) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    i = i || this.clearColor;
    var u = this.motionBlur && !t, h = this.lastFrameAlpha, c = this.dpr, f = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / c, l / c));
    var d = this.domBack;
    function p(g, v, O, m) {
      if (o.clearRect(g, v, O, m), i && i !== "transparent") {
        var E = void 0;
        if (dS(i)) {
          var b = i.global || i.__width === O && i.__height === m;
          E = b && i.__canvasGradient || gC(o, i, {
            x: 0,
            y: 0,
            width: O,
            height: m
          }), i.__canvasGradient = E, i.__width = O, i.__height = m;
        } else
          Ute(i) && (i.scaleX = i.scaleX || c, i.scaleY = i.scaleY || c, E = vC(o, i, {
            dirty: function() {
              f.setUnpainted(), f.__painter.refresh();
            }
          }));
        o.save(), o.fillStyle = E || i, o.fillRect(g, v, O, m), o.restore();
      }
      u && (o.save(), o.globalAlpha = h, o.drawImage(d, g, v, O, m), o.restore());
    }
    !n || u ? p(0, 0, s, l) : n.length && w(n, function(g) {
      p(g.x * c, g.y * c, g.width * c, g.height * c);
    });
  }, e;
}(jn);
const Jy = jhe;
var ek = 1e5, Kl = 314159, fO = 0.01, Khe = 1e-3;
function Jhe(r) {
  return r ? r.__builtin__ ? !0 : !(typeof r.resize != "function" || typeof r.refresh != "function") : !1;
}
function ece(r, e) {
  var t = document.createElement("div");
  return t.style.cssText = [
    "position:relative",
    "width:" + r + "px",
    "height:" + e + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", t;
}
var tce = function() {
  function r(e, t, i, n) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
    this._opts = i = V({}, i || {}), this.dpr = i.devicePixelRatio || vE, this._singleCanvas = a, this.root = e;
    var o = e.style;
    o && (DF(e), e.innerHTML = ""), this.storage = t;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var h = e, c = h.width, f = h.height;
      i.width != null && (c = i.width), i.height != null && (f = i.height), this.dpr = i.devicePixelRatio || 1, h.width = c * this.dpr, h.height = f * this.dpr, this._width = c, this._height = f;
      var d = new Jy(h, this, this.dpr);
      d.__builtin__ = !0, d.initContext(), l[Kl] = d, d.zlevel = Kl, s.push(Kl), this._domRoot = e;
    } else {
      this._width = Oc(e, 0, i), this._height = Oc(e, 1, i);
      var u = this._domRoot = ece(this._width, this._height);
      e.appendChild(u);
    }
  }
  return r.prototype.getType = function() {
    return "canvas";
  }, r.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, r.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, r.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, r.prototype.refresh = function(e) {
    var t = this.storage.getDisplayList(!0), i = this._prevDisplayList, n = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(t, i, e, this._redrawId);
    for (var a = 0; a < n.length; a++) {
      var o = n[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this;
  }, r.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, r.prototype._paintHoverList = function(e) {
    var t = e.length, i = this._hoverlayer;
    if (i && i.clear(), !!t) {
      for (var n = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < t; o++) {
        var s = e[o];
        s.__inHover && (i || (i = this._hoverlayer = this.getLayer(ek)), a || (a = i.ctx, a.save()), Cu(a, s, n, o === t - 1));
      }
      a && a.restore();
    }
  }, r.prototype.getHoverLayer = function() {
    return this.getLayer(ek);
  }, r.prototype.paintOne = function(e, t) {
    wH(e, t);
  }, r.prototype._paintList = function(e, t, i, n) {
    if (this._redrawId === n) {
      i = i || !1, this._updateLayerStatus(e);
      var a = this._doPaintList(e, t, i), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        LA(function() {
          l._paintList(e, t, i, n);
        });
      }
    }
  }, r.prototype._compositeManually = function() {
    var e = this.getLayer(Kl).ctx, t = this._domRoot.width, i = this._domRoot.height;
    e.clearRect(0, 0, t, i), this.eachBuiltinLayer(function(n) {
      n.virtual && e.drawImage(n.dom, 0, 0, t, i);
    });
  }, r.prototype._doPaintList = function(e, t, i) {
    for (var n = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || i) && a.push(u);
    }
    for (var h = !0, c = !1, f = function(g) {
      var v = a[g], O = v.ctx, m = o && v.createRepaintRects(e, t, d._width, d._height), E = i ? v.__startIndex : v.__drawIndex, b = !i && v.incremental && Date.now, T = b && Date.now(), S = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
      if (v.__startIndex === v.__endIndex)
        v.clear(!1, S, m);
      else if (E === v.__startIndex) {
        var y = e[E];
        (!y.incremental || !y.notClear || i) && v.clear(!1, S, m);
      }
      E === -1 && (console.error("For some unknown reason. drawIndex is -1"), E = v.__startIndex);
      var A, C = function(P) {
        var N = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: n._width,
          viewHeight: n._height
        };
        for (A = E; A < v.__endIndex; A++) {
          var L = e[A];
          if (L.__inHover && (c = !0), n._doPaintEl(L, v, o, P, N, A === v.__endIndex - 1), b) {
            var D = Date.now() - T;
            if (D > 15)
              break;
          }
        }
        N.prevElClipPaths && O.restore();
      };
      if (m)
        if (m.length === 0)
          A = v.__endIndex;
        else
          for (var _ = d.dpr, I = 0; I < m.length; ++I) {
            var x = m[I];
            O.save(), O.beginPath(), O.rect(x.x * _, x.y * _, x.width * _, x.height * _), O.clip(), C(x), O.restore();
          }
      else
        O.save(), C(), O.restore();
      v.__drawIndex = A, v.__drawIndex < v.__endIndex && (h = !1);
    }, d = this, p = 0; p < a.length; p++)
      f(p);
    return st.wxa && w(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: h,
      needsRefreshHover: c
    };
  }, r.prototype._doPaintEl = function(e, t, i, n, a, o) {
    var s = t.ctx;
    if (i) {
      var l = e.getPaintRect();
      (!n || l && l.intersect(n)) && (Cu(s, e, a, o), e.setPrevPaintRect(l));
    } else
      Cu(s, e, a, o);
  }, r.prototype.getLayer = function(e, t) {
    this._singleCanvas && !this._needsManuallyCompositing && (e = Kl);
    var i = this._layers[e];
    return i || (i = new Jy("zr_" + e, this, this.dpr), i.zlevel = e, i.__builtin__ = !0, this._layerConfig[e] ? Qe(i, this._layerConfig[e], !0) : this._layerConfig[e - fO] && Qe(i, this._layerConfig[e - fO], !0), t && (i.virtual = t), this.insertLayer(e, i), i.initContext()), i;
  }, r.prototype.insertLayer = function(e, t) {
    var i = this._layers, n = this._zlevelList, a = n.length, o = this._domRoot, s = null, l = -1;
    if (!i[e] && Jhe(t)) {
      if (a > 0 && e > n[0]) {
        for (l = 0; l < a - 1 && !(n[l] < e && n[l + 1] > e); l++)
          ;
        s = i[n[l]];
      }
      if (n.splice(l + 1, 0, e), i[e] = t, !t.virtual)
        if (s) {
          var u = s.dom;
          u.nextSibling ? o.insertBefore(t.dom, u.nextSibling) : o.appendChild(t.dom);
        } else
          o.firstChild ? o.insertBefore(t.dom, o.firstChild) : o.appendChild(t.dom);
      t.__painter = this;
    }
  }, r.prototype.eachLayer = function(e, t) {
    for (var i = this._zlevelList, n = 0; n < i.length; n++) {
      var a = i[n];
      e.call(t, this._layers[a], a);
    }
  }, r.prototype.eachBuiltinLayer = function(e, t) {
    for (var i = this._zlevelList, n = 0; n < i.length; n++) {
      var a = i[n], o = this._layers[a];
      o.__builtin__ && e.call(t, o, a);
    }
  }, r.prototype.eachOtherLayer = function(e, t) {
    for (var i = this._zlevelList, n = 0; n < i.length; n++) {
      var a = i[n], o = this._layers[a];
      o.__builtin__ || e.call(t, o, a);
    }
  }, r.prototype.getLayers = function() {
    return this._layers;
  }, r.prototype._updateLayerStatus = function(e) {
    this.eachBuiltinLayer(function(c, f) {
      c.__dirty = c.__used = !1;
    });
    function t(c) {
      a && (a.__endIndex !== c && (a.__dirty = !0), a.__endIndex = c);
    }
    if (this._singleCanvas)
      for (var i = 1; i < e.length; i++) {
        var n = e[i];
        if (n.zlevel !== e[i - 1].zlevel || n.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < e.length; l++) {
      var n = e[l], u = n.zlevel, h = void 0;
      s !== u && (s = u, o = 0), n.incremental ? (h = this.getLayer(u + Khe, this._needsManuallyCompositing), h.incremental = !0, o = 1) : h = this.getLayer(u + (o > 0 ? fO : 0), this._needsManuallyCompositing), h.__builtin__ || bI("ZLevel " + u + " has been used by unkown layer " + h.id), h !== a && (h.__used = !0, h.__startIndex !== l && (h.__dirty = !0), h.__startIndex = l, h.incremental ? h.__drawIndex = -1 : h.__drawIndex = l, t(l), a = h), n.__dirty & un && !n.__inHover && (h.__dirty = !0, h.incremental && h.__drawIndex < 0 && (h.__drawIndex = l));
    }
    t(l), this.eachBuiltinLayer(function(c, f) {
      !c.__used && c.getElementCount() > 0 && (c.__dirty = !0, c.__startIndex = c.__endIndex = c.__drawIndex = 0), c.__dirty && c.__drawIndex < 0 && (c.__drawIndex = c.__startIndex);
    });
  }, r.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, r.prototype._clearLayer = function(e) {
    e.clear();
  }, r.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e, w(this._layers, function(t) {
      t.setUnpainted();
    });
  }, r.prototype.configLayer = function(e, t) {
    if (t) {
      var i = this._layerConfig;
      i[e] ? Qe(i[e], t, !0) : i[e] = t;
      for (var n = 0; n < this._zlevelList.length; n++) {
        var a = this._zlevelList[n];
        if (a === e || a === e + fO) {
          var o = this._layers[a];
          Qe(o, i[e], !0);
        }
      }
    }
  }, r.prototype.delLayer = function(e) {
    var t = this._layers, i = this._zlevelList, n = t[e];
    n && (n.dom.parentNode.removeChild(n.dom), delete t[e], i.splice(Ge(i, e), 1));
  }, r.prototype.resize = function(e, t) {
    if (this._domRoot.style) {
      var i = this._domRoot;
      i.style.display = "none";
      var n = this._opts, a = this.root;
      if (e != null && (n.width = e), t != null && (n.height = t), e = Oc(a, 0, n), t = Oc(a, 1, n), i.style.display = "", this._width !== e || t !== this._height) {
        i.style.width = e + "px", i.style.height = t + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(e, t);
        this.refresh(!0);
      }
      this._width = e, this._height = t;
    } else {
      if (e == null || t == null)
        return;
      this._width = e, this._height = t, this.getLayer(Kl).resize(e, t);
    }
    return this;
  }, r.prototype.clearLayer = function(e) {
    var t = this._layers[e];
    t && t.clear();
  }, r.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, r.prototype.getRenderedCanvas = function(e) {
    if (e = e || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Kl].dom;
    var t = new Jy("image", this, e.pixelRatio || this.dpr);
    t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor);
    var i = t.ctx;
    if (e.pixelRatio <= this.dpr) {
      this.refresh();
      var n = t.dom.width, a = t.dom.height;
      this.eachLayer(function(c) {
        c.__builtin__ ? i.drawImage(c.dom, 0, 0, n, a) : c.renderToCanvas && (i.save(), c.renderToCanvas(i), i.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var h = s[l];
        Cu(i, h, o, l === u - 1);
      }
    return t.dom;
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r;
}();
const rce = tce;
function ice(r) {
  r.registerPainter("canvas", rce);
}
var nce = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      return ts(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getLegendIcon = function(t) {
      var i = new ye(), n = ur("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1);
      i.add(n), n.setStyle(t.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = t.itemHeight * 0.8, u = ur(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
      i.add(u), u.setStyle(t.itemStyle);
      var h = t.iconRotate === "inherit" ? o : t.iconRotate || 0;
      return u.rotation = h * Math.PI / 180, u.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), i;
    }, e.type = "series.line", e.dependencies = ["grid", "polar"], e.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, e;
  }(Xt)
);
const ace = nce;
function tf(r, e) {
  var t = r.mapDimensionsAll("defaultedLabel"), i = t.length;
  if (i === 1) {
    var n = Kc(r, e, t[0]);
    return n != null ? n + "" : null;
  } else if (i) {
    for (var a = [], o = 0; o < t.length; o++)
      a.push(Kc(r, e, t[o]));
    return a.join(" ");
  }
}
function WW(r, e) {
  var t = r.mapDimensionsAll("defaultedLabel");
  if (!X(e))
    return e + "";
  for (var i = [], n = 0; n < t.length; n++) {
    var a = r.getDimensionIndex(t[n]);
    a >= 0 && i.push(e[a]);
  }
  return i.join(" ");
}
var oce = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n, a) {
      var o = r.call(this) || this;
      return o.updateData(t, i, n, a), o;
    }
    return e.prototype._createSymbol = function(t, i, n, a, o) {
      this.removeAll();
      var s = ur(t, -1, -1, 2, 2, null, o);
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), s.drift = sce, this._symbolType = t, this.add(s);
    }, e.prototype.stopSymbolAnimation = function(t) {
      this.childAt(0).stopAnimation(null, t);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      Xo(this.childAt(0));
    }, e.prototype.downplay = function() {
      Yo(this.childAt(0));
    }, e.prototype.setZ = function(t, i) {
      var n = this.childAt(0);
      n.zlevel = t, n.z = i;
    }, e.prototype.setDraggable = function(t, i) {
      var n = this.childAt(0);
      n.draggable = t, n.cursor = !i && t ? "move" : n.cursor;
    }, e.prototype.updateData = function(t, i, n, a) {
      this.silent = !1;
      var o = t.getItemVisual(i, "symbol") || "circle", s = t.hostModel, l = e.getSymbolSize(t, i), u = o !== this._symbolType, h = a && a.disableAnimation;
      if (u) {
        var c = t.getItemVisual(i, "symbolKeepAspect");
        this._createSymbol(o, t, i, l, c);
      } else {
        var f = this.childAt(0);
        f.silent = !1;
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        h ? f.attr(d) : ft(f, d, s, i), ba(f);
      }
      if (this._updateCommon(t, i, l, n, a), u) {
        var f = this.childAt(0);
        if (!h) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: f.style.opacity
            }
          };
          f.scaleX = f.scaleY = 0, f.style.opacity = 0, Ut(f, d, s, i);
        }
      }
      h && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(t, i, n, a, o) {
      var s = this.childAt(0), l = t.hostModel, u, h, c, f, d, p, g, v, O;
      if (a && (u = a.emphasisItemStyle, h = a.blurItemStyle, c = a.selectItemStyle, f = a.focus, d = a.blurScope, g = a.labelStatesModels, v = a.hoverScale, O = a.cursorStyle, p = a.emphasisDisabled), !a || t.hasItemOption) {
        var m = a && a.itemModel ? a.itemModel : t.getItemModel(i), E = m.getModel("emphasis");
        u = E.getModel("itemStyle").getItemStyle(), c = m.getModel(["select", "itemStyle"]).getItemStyle(), h = m.getModel(["blur", "itemStyle"]).getItemStyle(), f = E.get("focus"), d = E.get("blurScope"), p = E.get("disabled"), g = Cr(m), v = E.getShallow("scale"), O = m.getShallow("cursor");
      }
      var b = t.getItemVisual(i, "symbolRotate");
      s.attr("rotation", (b || 0) * Math.PI / 180 || 0);
      var T = Th(t.getItemVisual(i, "symbolOffset"), n);
      T && (s.x = T[0], s.y = T[1]), O && s.attr("cursor", O);
      var S = t.getItemVisual(i, "style"), y = S.fill;
      if (s instanceof qr) {
        var A = s.style;
        s.useStyle(V({
          // TODO other properties like x, y ?
          image: A.image,
          x: A.x,
          y: A.y,
          width: A.width,
          height: A.height
        }, S));
      } else
        s.__isEmptyBrush ? s.useStyle(V({}, S)) : s.useStyle(S), s.style.decal = null, s.setColor(y, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
      var C = t.getItemVisual(i, "liftZ"), _ = this._z2;
      C != null ? _ == null && (this._z2 = s.z2, s.z2 += C) : _ != null && (s.z2 = _, this._z2 = null);
      var I = o && o.useNameLabel;
      Zr(s, g, {
        labelFetcher: l,
        labelDataIndex: i,
        defaultText: x,
        inheritColor: y,
        defaultOpacity: S.opacity
      });
      function x(L) {
        return I ? t.getName(L) : tf(t, L);
      }
      this._sizeX = n[0] / 2, this._sizeY = n[1] / 2;
      var P = s.ensureState("emphasis");
      P.style = u, s.ensureState("select").style = c, s.ensureState("blur").style = h;
      var N = v == null || v === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      P.scaleX = this._sizeX * N, P.scaleY = this._sizeY * N, this.setSymbolScale(1), zt(this, f, d, p);
    }, e.prototype.setSymbolScale = function(t) {
      this.scaleX = this.scaleY = t;
    }, e.prototype.fadeOut = function(t, i, n) {
      var a = this.childAt(0), o = _e(this).dataIndex, s = n && n.animation;
      if (this.silent = a.silent = !0, n && n.fadeLabel) {
        var l = a.getTextContent();
        l && al(l, {
          style: {
            opacity: 0
          }
        }, i, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else
        a.removeTextContent();
      al(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, i, {
        dataIndex: o,
        cb: t,
        removeOpt: s
      });
    }, e.getSymbolSize = function(t, i) {
      return Nf(t.getItemVisual(i, "symbolSize"));
    }, e;
  }(ye)
);
function sce(r, e) {
  this.parent.drift(r, e);
}
const Zg = oce;
function e0(r, e, t, i) {
  return e && !isNaN(e[0]) && !isNaN(e[1]) && !(i.isIgnore && i.isIgnore(t)) && !(i.clipShape && !i.clipShape.contain(e[0], e[1])) && r.getItemVisual(t, "symbol") !== "none";
}
function tk(r) {
  return r != null && !be(r) && (r = {
    isIgnore: r
  }), r || {};
}
function rk(r) {
  var e = r.hostModel, t = e.getModel("emphasis");
  return {
    emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
    blurItemStyle: e.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: e.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: t.get("focus"),
    blurScope: t.get("blurScope"),
    emphasisDisabled: t.get("disabled"),
    hoverScale: t.get("scale"),
    labelStatesModels: Cr(e),
    cursorStyle: e.get("cursor")
  };
}
var lce = (
  /** @class */
  function() {
    function r(e) {
      this.group = new ye(), this._SymbolCtor = e || Zg;
    }
    return r.prototype.updateData = function(e, t) {
      this._progressiveEls = null, t = tk(t);
      var i = this.group, n = e.hostModel, a = this._data, o = this._SymbolCtor, s = t.disableAnimation, l = rk(e), u = {
        disableAnimation: s
      }, h = t.getSymbolPoint || function(c) {
        return e.getItemLayout(c);
      };
      a || i.removeAll(), e.diff(a).add(function(c) {
        var f = h(c);
        if (e0(e, f, c, t)) {
          var d = new o(e, c, l, u);
          d.setPosition(f), e.setItemGraphicEl(c, d), i.add(d);
        }
      }).update(function(c, f) {
        var d = a.getItemGraphicEl(f), p = h(c);
        if (!e0(e, p, c, t)) {
          i.remove(d);
          return;
        }
        var g = e.getItemVisual(c, "symbol") || "circle", v = d && d.getSymbolType && d.getSymbolType();
        if (!d || v && v !== g)
          i.remove(d), d = new o(e, c, l, u), d.setPosition(p);
        else {
          d.updateData(e, c, l, u);
          var O = {
            x: p[0],
            y: p[1]
          };
          s ? d.attr(O) : ft(d, O, n);
        }
        i.add(d), e.setItemGraphicEl(c, d);
      }).remove(function(c) {
        var f = a.getItemGraphicEl(c);
        f && f.fadeOut(function() {
          i.remove(f);
        }, n);
      }).execute(), this._getSymbolPoint = h, this._data = e;
    }, r.prototype.updateLayout = function() {
      var e = this, t = this._data;
      t && t.eachItemGraphicEl(function(i, n) {
        var a = e._getSymbolPoint(n);
        i.setPosition(a), i.markRedraw();
      });
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = rk(e), this._data = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t, i) {
      this._progressiveEls = [], i = tk(i);
      function n(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var a = e.start; a < e.end; a++) {
        var o = t.getItemLayout(a);
        if (e0(t, o, a, i)) {
          var s = new this._SymbolCtor(t, a, this._seriesScope);
          s.traverse(n), s.setPosition(o), this.group.add(s), t.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, r.prototype.eachRendered = function(e) {
      Tl(this._progressiveEls || this.group, e);
    }, r.prototype.remove = function(e) {
      var t = this.group, i = this._data;
      i && e ? i.eachItemGraphicEl(function(n) {
        n.fadeOut(function() {
          t.remove(n);
        }, i.hostModel);
      }) : t.removeAll();
    }, r;
  }()
);
const qg = lce;
function zW(r, e, t) {
  var i = r.getBaseAxis(), n = r.getOtherAxis(i), a = uce(n, t), o = i.dim, s = n.dim, l = e.mapDimension(s), u = e.mapDimension(o), h = s === "x" || s === "radius" ? 1 : 0, c = Y(r.dimensions, function(p) {
    return e.mapDimension(p);
  }), f = !1, d = e.getCalculationInfo("stackResultDimension");
  return sl(
    e,
    c[0]
    /* , dims[1] */
  ) && (f = !0, c[0] = d), sl(
    e,
    c[1]
    /* , dims[0] */
  ) && (f = !0, c[1] = d), {
    dataDimsForPoint: c,
    valueStart: a,
    valueAxisDim: s,
    baseAxisDim: o,
    stacked: !!f,
    valueDim: l,
    baseDim: u,
    baseDataOffset: h,
    stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
  };
}
function uce(r, e) {
  var t = 0, i = r.scale.getExtent();
  return e === "start" ? t = i[0] : e === "end" ? t = i[1] : ut(e) && !isNaN(e) ? t = e : i[0] > 0 ? t = i[0] : i[1] < 0 && (t = i[1]), t;
}
function ZW(r, e, t, i) {
  var n = NaN;
  r.stacked && (n = t.get(t.getCalculationInfo("stackedOverDimension"), i)), isNaN(n) && (n = r.valueStart);
  var a = r.baseDataOffset, o = [];
  return o[a] = t.get(r.baseDim, i), o[1 - a] = n, e.dataToPoint(o);
}
function hce(r, e) {
  var t = [];
  return e.diff(r).add(function(i) {
    t.push({
      cmd: "+",
      idx: i
    });
  }).update(function(i, n) {
    t.push({
      cmd: "=",
      idx: n,
      idx1: i
    });
  }).remove(function(i) {
    t.push({
      cmd: "-",
      idx: i
    });
  }).execute(), t;
}
function cce(r, e, t, i, n, a, o, s) {
  for (var l = hce(r, e), u = [], h = [], c = [], f = [], d = [], p = [], g = [], v = zW(n, e, o), O = r.getLayout("points") || [], m = e.getLayout("points") || [], E = 0; E < l.length; E++) {
    var b = l[E], T = !0, S = void 0, y = void 0;
    switch (b.cmd) {
      case "=":
        S = b.idx * 2, y = b.idx1 * 2;
        var A = O[S], C = O[S + 1], _ = m[y], I = m[y + 1];
        (isNaN(A) || isNaN(C)) && (A = _, C = I), u.push(A, C), h.push(_, I), c.push(t[S], t[S + 1]), f.push(i[y], i[y + 1]), g.push(e.getRawIndex(b.idx1));
        break;
      case "+":
        var x = b.idx, P = v.dataDimsForPoint, N = n.dataToPoint([e.get(P[0], x), e.get(P[1], x)]);
        y = x * 2, u.push(N[0], N[1]), h.push(m[y], m[y + 1]);
        var L = ZW(v, n, e, x);
        c.push(L[0], L[1]), f.push(i[y], i[y + 1]), g.push(e.getRawIndex(x));
        break;
      case "-":
        T = !1;
    }
    T && (d.push(b), p.push(p.length));
  }
  p.sort(function($e, Pe) {
    return g[$e] - g[Pe];
  });
  for (var D = u.length, $ = Wa(D), k = Wa(D), G = Wa(D), F = Wa(D), q = [], E = 0; E < p.length; E++) {
    var re = p[E], fe = E * 2, de = re * 2;
    $[fe] = u[de], $[fe + 1] = u[de + 1], k[fe] = h[de], k[fe + 1] = h[de + 1], G[fe] = c[de], G[fe + 1] = c[de + 1], F[fe] = f[de], F[fe + 1] = f[de + 1], q[E] = d[re];
  }
  return {
    current: $,
    next: k,
    stackedOnCurrent: G,
    stackedOnNext: F,
    status: q
  };
}
var gs = Math.min, vs = Math.max;
function Xu(r, e) {
  return isNaN(r) || isNaN(e);
}
function CC(r, e, t, i, n, a, o, s, l) {
  for (var u, h, c, f, d, p, g = t, v = 0; v < i; v++) {
    var O = e[g * 2], m = e[g * 2 + 1];
    if (g >= n || g < 0)
      break;
    if (Xu(O, m)) {
      if (l) {
        g += a;
        continue;
      }
      break;
    }
    if (g === t)
      r[a > 0 ? "moveTo" : "lineTo"](O, m), c = O, f = m;
    else {
      var E = O - u, b = m - h;
      if (E * E + b * b < 0.5) {
        g += a;
        continue;
      }
      if (o > 0) {
        for (var T = g + a, S = e[T * 2], y = e[T * 2 + 1]; S === O && y === m && v < i; )
          v++, T += a, g += a, S = e[T * 2], y = e[T * 2 + 1], O = e[g * 2], m = e[g * 2 + 1], E = O - u, b = m - h;
        var A = v + 1;
        if (l)
          for (; Xu(S, y) && A < i; )
            A++, T += a, S = e[T * 2], y = e[T * 2 + 1];
        var C = 0.5, _ = 0, I = 0, x = void 0, P = void 0;
        if (A >= i || Xu(S, y))
          d = O, p = m;
        else {
          _ = S - u, I = y - h;
          var N = O - u, L = S - O, D = m - h, $ = y - m, k = void 0, G = void 0;
          if (s === "x") {
            k = Math.abs(N), G = Math.abs(L);
            var F = _ > 0 ? 1 : -1;
            d = O - F * k * o, p = m, x = O + F * G * o, P = m;
          } else if (s === "y") {
            k = Math.abs(D), G = Math.abs($);
            var q = I > 0 ? 1 : -1;
            d = O, p = m - q * k * o, x = O, P = m + q * G * o;
          } else
            k = Math.sqrt(N * N + D * D), G = Math.sqrt(L * L + $ * $), C = G / (G + k), d = O - _ * o * (1 - C), p = m - I * o * (1 - C), x = O + _ * o * C, P = m + I * o * C, x = gs(x, vs(S, O)), P = gs(P, vs(y, m)), x = vs(x, gs(S, O)), P = vs(P, gs(y, m)), _ = x - O, I = P - m, d = O - _ * k / G, p = m - I * k / G, d = gs(d, vs(u, O)), p = gs(p, vs(h, m)), d = vs(d, gs(u, O)), p = vs(p, gs(h, m)), _ = O - d, I = m - p, x = O + _ * G / k, P = m + I * G / k;
        }
        r.bezierCurveTo(c, f, d, p, O, m), c = x, f = P;
      } else
        r.lineTo(O, m);
    }
    u = O, h = m, g += a;
  }
  return v;
}
var qW = (
  /** @class */
  function() {
    function r() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return r;
  }()
), fce = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "ec-polyline", i;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new qW();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = 0, o = n.length / 2;
      if (i.connectNulls) {
        for (; o > 0 && Xu(n[o * 2 - 2], n[o * 2 - 1]); o--)
          ;
        for (; a < o && Xu(n[a * 2], n[a * 2 + 1]); a++)
          ;
      }
      for (; a < o; )
        a += CC(t, n, a, o, o, 1, i.smooth, i.smoothMonotone, i.connectNulls) + 1;
    }, e.prototype.getPointOn = function(t, i) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var n = this.path, a = n.data, o = lo.CMD, s, l, u = i === "x", h = [], c = 0; c < a.length; ) {
        var f = a[c++], d = void 0, p = void 0, g = void 0, v = void 0, O = void 0, m = void 0, E = void 0;
        switch (f) {
          case o.M:
            s = a[c++], l = a[c++];
            break;
          case o.L:
            if (d = a[c++], p = a[c++], E = u ? (t - s) / (d - s) : (t - l) / (p - l), E <= 1 && E >= 0) {
              var b = u ? (p - l) * E + l : (d - s) * E + s;
              return u ? [t, b] : [b, t];
            }
            s = d, l = p;
            break;
          case o.C:
            d = a[c++], p = a[c++], g = a[c++], v = a[c++], O = a[c++], m = a[c++];
            var T = u ? fE(s, d, g, O, t, h) : fE(l, p, v, m, t, h);
            if (T > 0)
              for (var S = 0; S < T; S++) {
                var y = h[S];
                if (y <= 1 && y >= 0) {
                  var b = u ? Er(l, p, v, m, y) : Er(s, d, g, O, y);
                  return u ? [t, b] : [b, t];
                }
              }
            s = O, l = m;
            break;
        }
      }
    }, e;
  }(Fe)
), dce = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(qW)
), jW = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "ec-polygon", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new dce();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = i.stackedOnPoints, o = 0, s = n.length / 2, l = i.smoothMonotone;
      if (i.connectNulls) {
        for (; s > 0 && Xu(n[s * 2 - 2], n[s * 2 - 1]); s--)
          ;
        for (; o < s && Xu(n[o * 2], n[o * 2 + 1]); o++)
          ;
      }
      for (; o < s; ) {
        var u = CC(t, n, o, s, s, 1, i.smooth, l, i.connectNulls);
        CC(t, a, o + u - 1, u, s, -1, i.stackedOnSmooth, l, i.connectNulls), o += u + 1, t.closePath();
      }
    }, e;
  }(Fe)
);
function KW(r, e, t, i, n) {
  var a = r.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, h = t.get(["lineStyle", "width"]) || 2;
  o -= h / 2, s -= h / 2, l += h, u += h, o = Math.floor(o), l = Math.round(l);
  var c = new nt({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u
    }
  });
  if (e) {
    var f = r.getBaseAxis(), d = f.isHorizontal(), p = f.inverse;
    d ? (p && (c.shape.x += l), c.shape.width = 0) : (p || (c.shape.y += u), c.shape.height = 0);
    var g = ve(n) ? function(v) {
      n(v, c);
    } : null;
    Ut(c, {
      shape: {
        width: l,
        height: u,
        x: o,
        y: s
      }
    }, t, null, i, g);
  }
  return c;
}
function JW(r, e, t) {
  var i = r.getArea(), n = Kt(i.r0, 1), a = Kt(i.r, 1), o = new Xi({
    shape: {
      cx: Kt(r.cx, 1),
      cy: Kt(r.cy, 1),
      r0: n,
      r: a,
      startAngle: i.startAngle,
      endAngle: i.endAngle,
      clockwise: i.clockwise
    }
  });
  if (e) {
    var s = r.getBaseAxis().dim === "angle";
    s ? o.shape.endAngle = i.startAngle : o.shape.r = n, Ut(o, {
      shape: {
        endAngle: i.endAngle,
        r: a
      }
    }, t);
  }
  return o;
}
function XS(r, e, t, i, n) {
  if (r) {
    if (r.type === "polar")
      return JW(r, e, t);
    if (r.type === "cartesian2d")
      return KW(r, e, t, i, n);
  } else
    return null;
  return null;
}
function Rh(r, e) {
  return r.type === e;
}
function ik(r, e) {
  if (r.length === e.length) {
    for (var t = 0; t < r.length; t++)
      if (r[t] !== e[t])
        return;
    return !0;
  }
}
function nk(r) {
  for (var e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0, a = 0; a < r.length; ) {
    var o = r[a++], s = r[a++];
    isNaN(o) || (e = Math.min(o, e), i = Math.max(o, i)), isNaN(s) || (t = Math.min(s, t), n = Math.max(s, n));
  }
  return [[e, t], [i, n]];
}
function ak(r, e) {
  var t = nk(r), i = t[0], n = t[1], a = nk(e), o = a[0], s = a[1];
  return Math.max(Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]), Math.abs(n[0] - s[0]), Math.abs(n[1] - s[1]));
}
function ok(r) {
  return ut(r) ? r : r ? 0.5 : 0;
}
function pce(r, e, t) {
  if (!t.valueDim)
    return [];
  for (var i = e.count(), n = Wa(i * 2), a = 0; a < i; a++) {
    var o = ZW(t, r, e, a);
    n[a * 2] = o[0], n[a * 2 + 1] = o[1];
  }
  return n;
}
function Os(r, e, t, i) {
  var n = e.getBaseAxis(), a = n.dim === "x" || n.dim === "radius" ? 0 : 1, o = [], s = 0, l = [], u = [], h = [], c = [];
  if (i) {
    for (s = 0; s < r.length; s += 2)
      !isNaN(r[s]) && !isNaN(r[s + 1]) && c.push(r[s], r[s + 1]);
    r = c;
  }
  for (s = 0; s < r.length - 2; s += 2)
    switch (h[0] = r[s + 2], h[1] = r[s + 3], u[0] = r[s], u[1] = r[s + 1], o.push(u[0], u[1]), t) {
      case "end":
        l[a] = h[a], l[1 - a] = u[1 - a], o.push(l[0], l[1]);
        break;
      case "middle":
        var f = (u[a] + h[a]) / 2, d = [];
        l[a] = d[a] = f, l[1 - a] = u[1 - a], d[1 - a] = h[1 - a], o.push(l[0], l[1]), o.push(d[0], d[1]);
        break;
      default:
        l[a] = u[a], l[1 - a] = h[1 - a], o.push(l[0], l[1]);
    }
  return o.push(r[s++], r[s++]), o;
}
function gce(r, e) {
  var t = [], i = r.length, n, a;
  function o(h, c, f) {
    var d = h.coord, p = (f - d) / (c.coord - d), g = Pre(p, [h.color, c.color]);
    return {
      coord: f,
      color: g
    };
  }
  for (var s = 0; s < i; s++) {
    var l = r[s], u = l.coord;
    if (u < 0)
      n = l;
    else if (u > e) {
      a ? t.push(o(a, l, e)) : n && t.push(o(n, l, 0), o(n, l, e));
      break;
    } else
      n && (t.push(o(n, l, 0)), n = null), t.push(l), a = l;
  }
  return t;
}
function vce(r, e, t) {
  var i = r.getVisual("visualMeta");
  if (!(!i || !i.length || !r.count()) && e.type === "cartesian2d") {
    for (var n, a, o = i.length - 1; o >= 0; o--) {
      var s = r.getDimensionInfo(i[o].dimension);
      if (n = s && s.coordDim, n === "x" || n === "y") {
        a = i[o];
        break;
      }
    }
    if (a) {
      var l = e.getAxis(n), u = Y(a.stops, function(E) {
        return {
          coord: l.toGlobalCoord(l.dataToCoord(E.value)),
          color: E.color
        };
      }), h = u.length, c = a.outerColors.slice();
      h && u[0].coord > u[h - 1].coord && (u.reverse(), c.reverse());
      var f = gce(u, n === "x" ? t.getWidth() : t.getHeight()), d = f.length;
      if (!d && h)
        return u[0].coord < 0 ? c[1] ? c[1] : u[h - 1].color : c[0] ? c[0] : u[0].color;
      var p = 10, g = f[0].coord - p, v = f[d - 1].coord + p, O = v - g;
      if (O < 1e-3)
        return "transparent";
      w(f, function(E) {
        E.offset = (E.coord - g) / O;
      }), f.push({
        // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
        offset: d ? f[d - 1].offset : 0.5,
        color: c[1] || "transparent"
      }), f.unshift({
        offset: d ? f[0].offset : 0.5,
        color: c[0] || "transparent"
      });
      var m = new Gg(0, 0, 0, 0, f, !0);
      return m[n] = g, m[n + "2"] = v, m;
    }
  }
}
function Oce(r, e, t) {
  var i = r.get("showAllSymbol"), n = i === "auto";
  if (!(i && !n)) {
    var a = t.getAxesByScale("ordinal")[0];
    if (a && !(n && mce(a, e))) {
      var o = e.mapDimension(a.dim), s = {};
      return w(a.getViewLabels(), function(l) {
        var u = a.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(e.get(o, l));
      };
    }
  }
}
function mce(r, e) {
  var t = r.getExtent(), i = Math.abs(t[1] - t[0]) / r.scale.count();
  isNaN(i) && (i = 0);
  for (var n = e.count(), a = Math.max(1, Math.round(n / 5)), o = 0; o < n; o += a)
    if (Zg.getSymbolSize(
      e,
      o
      // Only for cartesian, where `isHorizontal` exists.
    )[r.isHorizontal() ? 1 : 0] * 1.5 > i)
      return !1;
  return !0;
}
function Ece(r, e) {
  return isNaN(r) || isNaN(e);
}
function bce(r) {
  for (var e = r.length / 2; e > 0 && Ece(r[e * 2 - 2], r[e * 2 - 1]); e--)
    ;
  return e - 1;
}
function sk(r, e) {
  return [r[e * 2], r[e * 2 + 1]];
}
function Sce(r, e, t) {
  for (var i = r.length / 2, n = t === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < i; u++)
    if (o = r[u * 2 + n], !(isNaN(o) || isNaN(r[u * 2 + 1 - n]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= e && o >= e || a >= e && o <= e) {
        l = u;
        break;
      }
      s = u, a = o;
    }
  return {
    range: [s, l],
    t: (e - a) / (o - a)
  };
}
function e3(r) {
  if (r.get(["endLabel", "show"]))
    return !0;
  for (var e = 0; e < Ii.length; e++)
    if (r.get([Ii[e], "endLabel", "show"]))
      return !0;
  return !1;
}
function t0(r, e, t, i) {
  if (Rh(e, "cartesian2d")) {
    var n = i.getModel("endLabel"), a = n.get("valueAnimation"), o = i.getData(), s = {
      lastFrameIndex: 0
    }, l = e3(i) ? function(d, p) {
      r._endLabelOnDuring(d, p, o, s, a, n, e);
    } : null, u = e.getBaseAxis().isHorizontal(), h = KW(e, t, i, function() {
      var d = r._endLabel;
      d && t && s.originalX != null && d.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!i.get("clip", !0)) {
      var c = h.shape, f = Math.max(c.width, c.height);
      u ? (c.y -= f, c.height += f * 2) : (c.x -= f, c.width += f * 2);
    }
    return l && l(1, h), h;
  } else
    return JW(e, t, i);
}
function Tce(r, e) {
  var t = e.getBaseAxis(), i = t.isHorizontal(), n = t.inverse, a = i ? n ? "right" : "left" : "center", o = i ? "middle" : n ? "top" : "bottom";
  return {
    normal: {
      align: r.get("align") || a,
      verticalAlign: r.get("verticalAlign") || o
    }
  };
}
var yce = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var t = new ye(), i = new qg();
      this.group.add(i.group), this._symbolDraw = i, this._lineGroup = t;
    }, e.prototype.render = function(t, i, n) {
      var a = this, o = t.coordinateSystem, s = this.group, l = t.getData(), u = t.getModel("lineStyle"), h = t.getModel("areaStyle"), c = l.getLayout("points") || [], f = o.type === "polar", d = this._coordSys, p = this._symbolDraw, g = this._polyline, v = this._polygon, O = this._lineGroup, m = !i.ssr && t.isAnimationEnabled(), E = !h.isEmpty(), b = h.get("origin"), T = zW(o, l, b), S = E && pce(o, l, T), y = t.get("showSymbol"), A = t.get("connectNulls"), C = y && !f && Oce(t, l, o), _ = this._data;
      _ && _.eachItemGraphicEl(function(Pe, Ne) {
        Pe.__temp && (s.remove(Pe), _.setItemGraphicEl(Ne, null));
      }), y || p.remove(), s.add(O);
      var I = f ? !1 : t.get("step"), x;
      o && o.getArea && t.get("clip", !0) && (x = o.getArea(), x.width != null ? (x.x -= 0.1, x.y -= 0.1, x.width += 0.2, x.height += 0.2) : x.r0 && (x.r0 -= 0.5, x.r += 0.5)), this._clipShapeForSymbol = x;
      var P = vce(l, o, n) || l.getVisual("style")[l.getVisual("drawType")];
      if (!(g && d.type === o.type && I === this._step))
        y && p.updateData(l, {
          isIgnore: C,
          clipShape: x,
          disableAnimation: !0,
          getSymbolPoint: function(Pe) {
            return [c[Pe * 2], c[Pe * 2 + 1]];
          }
        }), m && this._initSymbolLabelAnimation(l, o, x), I && (c = Os(c, o, I, A), S && (S = Os(S, o, I, A))), g = this._newPolyline(c), E ? v = this._newPolygon(c, S) : v && (O.remove(v), v = this._polygon = null), f || this._initOrUpdateEndLabel(t, o, nh(P)), O.setClipPath(t0(this, o, !0, t));
      else {
        E && !v ? v = this._newPolygon(c, S) : v && !E && (O.remove(v), v = this._polygon = null), f || this._initOrUpdateEndLabel(t, o, nh(P));
        var N = O.getClipPath();
        if (N) {
          var L = t0(this, o, !1, t);
          Ut(N, {
            shape: L.shape
          }, t);
        } else
          O.setClipPath(t0(this, o, !0, t));
        y && p.updateData(l, {
          isIgnore: C,
          clipShape: x,
          disableAnimation: !0,
          getSymbolPoint: function(Pe) {
            return [c[Pe * 2], c[Pe * 2 + 1]];
          }
        }), (!ik(this._stackedOnPoints, S) || !ik(this._points, c)) && (m ? this._doUpdateAnimation(l, S, o, n, I, b, A) : (I && (c = Os(c, o, I, A), S && (S = Os(S, o, I, A))), g.setShape({
          points: c
        }), v && v.setShape({
          points: c,
          stackedOnPoints: S
        })));
      }
      var D = t.getModel("emphasis"), $ = D.get("focus"), k = D.get("blurScope"), G = D.get("disabled");
      if (g.useStyle(me(
        // Use color in lineStyle first
        u.getLineStyle(),
        {
          fill: "none",
          stroke: P,
          lineJoin: "bevel"
        }
      )), zr(g, t, "lineStyle"), g.style.lineWidth > 0 && t.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var F = g.getState("emphasis").style;
        F.lineWidth = +g.style.lineWidth + 1;
      }
      _e(g).seriesIndex = t.seriesIndex, zt(g, $, k, G);
      var q = ok(t.get("smooth")), re = t.get("smoothMonotone");
      if (g.setShape({
        smooth: q,
        smoothMonotone: re,
        connectNulls: A
      }), v) {
        var fe = l.getCalculationInfo("stackedOnSeries"), de = 0;
        v.useStyle(me(h.getAreaStyle(), {
          fill: P,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: l.getVisual("style").decal
        })), fe && (de = ok(fe.get("smooth"))), v.setShape({
          smooth: q,
          stackedOnSmooth: de,
          smoothMonotone: re,
          connectNulls: A
        }), zr(v, t, "areaStyle"), _e(v).seriesIndex = t.seriesIndex, zt(v, $, k, G);
      }
      var $e = function(Pe) {
        a._changePolyState(Pe);
      };
      l.eachItemGraphicEl(function(Pe) {
        Pe && (Pe.onHoverStateChange = $e);
      }), this._polyline.onHoverStateChange = $e, this._data = l, this._coordSys = o, this._stackedOnPoints = S, this._points = c, this._step = I, this._valueOrigin = b, t.get("triggerLineEvent") && (this.packEventData(t, g), v && this.packEventData(t, v));
    }, e.prototype.packEventData = function(t, i) {
      _e(i).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: t.componentIndex,
        seriesIndex: t.seriesIndex,
        seriesName: t.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(t, i, n, a) {
      var o = t.getData(), s = th(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var h = l[s * 2], c = l[s * 2 + 1];
          if (isNaN(h) || isNaN(c) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(h, c))
            return;
          var f = t.get("zlevel") || 0, d = t.get("z") || 0;
          u = new Zg(o, s), u.x = h, u.y = c, u.setZ(f, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = f, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = !0, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        Mt.prototype.highlight.call(this, t, i, n, a);
    }, e.prototype.downplay = function(t, i, n, a) {
      var o = t.getData(), s = th(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        Mt.prototype.downplay.call(this, t, i, n, a);
    }, e.prototype._changePolyState = function(t) {
      var i = this._polygon;
      bE(this._polyline, t), i && bE(i, t);
    }, e.prototype._newPolyline = function(t) {
      var i = this._polyline;
      return i && this._lineGroup.remove(i), i = new fce({
        shape: {
          points: t
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(i), this._polyline = i, i;
    }, e.prototype._newPolygon = function(t, i) {
      var n = this._polygon;
      return n && this._lineGroup.remove(n), n = new jW({
        shape: {
          points: t,
          stackedOnPoints: i
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(n), this._polygon = n, n;
    }, e.prototype._initSymbolLabelAnimation = function(t, i, n) {
      var a, o, s = i.getBaseAxis(), l = s.inverse;
      i.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : i.type === "polar" && (a = s.dim === "angle", o = !0);
      var u = t.hostModel, h = u.get("animationDuration");
      ve(h) && (h = h(null));
      var c = u.get("animationDelay") || 0, f = ve(c) ? c(null) : c;
      t.eachItemGraphicEl(function(d, p) {
        var g = d;
        if (g) {
          var v = [d.x, d.y], O = void 0, m = void 0, E = void 0;
          if (n)
            if (o) {
              var b = n, T = i.pointToCoord(v);
              a ? (O = b.startAngle, m = b.endAngle, E = -T[1] / 180 * Math.PI) : (O = b.r0, m = b.r, E = T[0]);
            } else {
              var S = n;
              a ? (O = S.x, m = S.x + S.width, E = d.x) : (O = S.y + S.height, m = S.y, E = d.y);
            }
          var y = m === O ? 0 : (E - O) / (m - O);
          l && (y = 1 - y);
          var A = ve(c) ? c(p) : h * y + f, C = g.getSymbolPath(), _ = C.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: A
          }), _ && _.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: A
          }), C.disableLabelAnimation = !0;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(t, i, n) {
      var a = t.getModel("endLabel");
      if (e3(t)) {
        var o = t.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new lt({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var h = bce(l);
        h >= 0 && (Zr(s, Cr(t, "endLabel"), {
          inheritColor: n,
          labelFetcher: t,
          labelDataIndex: h,
          defaultText: function(c, f, d) {
            return d != null ? WW(o, d) : tf(o, c);
          },
          enableTextSetter: !0
        }, Tce(a, i)), s.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(t, i, n, a, o, s, l) {
      var u = this._endLabel, h = this._polyline;
      if (u) {
        t < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var c = n.getLayout("points"), f = n.hostModel, d = f.get("connectNulls"), p = s.get("precision"), g = s.get("distance") || 0, v = l.getBaseAxis(), O = v.isHorizontal(), m = v.inverse, E = i.shape, b = m ? O ? E.x : E.y + E.height : O ? E.x + E.width : E.y, T = (O ? g : 0) * (m ? -1 : 1), S = (O ? 0 : -g) * (m ? -1 : 1), y = O ? "x" : "y", A = Sce(c, b, y), C = A.range, _ = C[1] - C[0], I = void 0;
        if (_ >= 1) {
          if (_ > 1 && !d) {
            var x = sk(c, C[0]);
            u.attr({
              x: x[0] + T,
              y: x[1] + S
            }), o && (I = f.getRawValue(C[0]));
          } else {
            var x = h.getPointOn(b, y);
            x && u.attr({
              x: x[0] + T,
              y: x[1] + S
            });
            var P = f.getRawValue(C[0]), N = f.getRawValue(C[1]);
            o && (I = SX(n, p, P, N, A.t));
          }
          a.lastFrameIndex = C[0];
        } else {
          var L = t === 1 || a.lastFrameIndex > 0 ? C[0] : 0, x = sk(c, L);
          o && (I = f.getRawValue(L)), u.attr({
            x: x[0] + T,
            y: x[1] + S
          });
        }
        if (o) {
          var D = Rf(u);
          typeof D.setLabelText == "function" && D.setLabelText(I);
        }
      }
    }, e.prototype._doUpdateAnimation = function(t, i, n, a, o, s, l) {
      var u = this._polyline, h = this._polygon, c = t.hostModel, f = cce(this._data, t, this._stackedOnPoints, i, this._coordSys, n, this._valueOrigin), d = f.current, p = f.stackedOnCurrent, g = f.next, v = f.stackedOnNext;
      if (o && (d = Os(f.current, n, o, l), p = Os(f.stackedOnCurrent, n, o, l), g = Os(f.next, n, o, l), v = Os(f.stackedOnNext, n, o, l)), ak(d, g) > 3e3 || h && ak(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), h && (h.stopAnimation(), h.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = f.current, u.shape.points = d;
      var O = {
        shape: {
          points: g
        }
      };
      f.current !== d && (O.shape.__points = f.next), u.stopAnimation(), ft(u, O, c), h && (h.setShape({
        // Reuse the points with polyline.
        points: d,
        stackedOnPoints: p
      }), h.stopAnimation(), ft(h, {
        shape: {
          stackedOnPoints: v
        }
      }, c), u.shape.points !== h.shape.points && (h.shape.points = u.shape.points));
      for (var m = [], E = f.status, b = 0; b < E.length; b++) {
        var T = E[b].cmd;
        if (T === "=") {
          var S = t.getItemGraphicEl(E[b].idx1);
          S && m.push({
            el: S,
            ptIdx: b
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        h && h.dirtyShape();
        for (var y = u.shape.__points, A = 0; A < m.length; A++) {
          var C = m[A].el, _ = m[A].ptIdx * 2;
          C.x = y[_], C.y = y[_ + 1], C.markRedraw();
        }
      });
    }, e.prototype.remove = function(t) {
      var i = this.group, n = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), n && n.eachItemGraphicEl(function(a, o) {
        a.__temp && (i.remove(a), n.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }(Mt)
);
const Rce = yce;
function jg(r, e) {
  return {
    seriesType: r,
    plan: wf(),
    reset: function(t) {
      var i = t.getData(), n = t.coordinateSystem, a = t.pipelineContext, o = e || a.large;
      if (n) {
        var s = Y(n.dimensions, function(d) {
          return i.mapDimension(d);
        }).slice(0, 2), l = s.length, u = i.getCalculationInfo("stackResultDimension");
        sl(i, s[0]) && (s[0] = u), sl(i, s[1]) && (s[1] = u);
        var h = i.getStore(), c = i.getDimensionIndex(s[0]), f = i.getDimensionIndex(s[1]);
        return l && {
          progress: function(d, p) {
            for (var g = d.end - d.start, v = o && Wa(g * l), O = [], m = [], E = d.start, b = 0; E < d.end; E++) {
              var T = void 0;
              if (l === 1) {
                var S = h.get(c, E);
                T = n.dataToPoint(S, null, m);
              } else
                O[0] = h.get(c, E), O[1] = h.get(f, E), T = n.dataToPoint(O, null, m);
              o ? (v[b++] = T[0], v[b++] = T[1]) : p.setItemLayout(E, T.slice());
            }
            o && p.setLayout("points", v);
          }
        };
      }
    }
  };
}
var Ace = {
  average: function(r) {
    for (var e = 0, t = 0, i = 0; i < r.length; i++)
      isNaN(r[i]) || (e += r[i], t++);
    return t === 0 ? NaN : e / t;
  },
  sum: function(r) {
    for (var e = 0, t = 0; t < r.length; t++)
      e += r[t] || 0;
    return e;
  },
  max: function(r) {
    for (var e = -1 / 0, t = 0; t < r.length; t++)
      r[t] > e && (e = r[t]);
    return isFinite(e) ? e : NaN;
  },
  min: function(r) {
    for (var e = 1 / 0, t = 0; t < r.length; t++)
      r[t] < e && (e = r[t]);
    return isFinite(e) ? e : NaN;
  },
  // TODO
  // Median
  nearest: function(r) {
    return r[0];
  }
}, Cce = function(r) {
  return Math.round(r.length / 2);
};
function t3(r) {
  return {
    seriesType: r,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(e, t, i) {
      var n = e.getData(), a = e.get("sampling"), o = e.coordinateSystem, s = n.count();
      if (s > 10 && o.type === "cartesian2d" && a) {
        var l = o.getBaseAxis(), u = o.getOtherAxis(l), h = l.getExtent(), c = i.getDevicePixelRatio(), f = Math.abs(h[1] - h[0]) * (c || 1), d = Math.round(s / f);
        if (isFinite(d) && d > 1) {
          a === "lttb" && e.setData(n.lttbDownSample(n.mapDimension(u.dim), 1 / d));
          var p = void 0;
          ne(a) ? p = Ace[a] : ve(a) && (p = a), p && e.setData(n.downSample(n.mapDimension(u.dim), 1 / d, p, Cce));
        }
      }
    }
  };
}
function _ce(r) {
  r.registerChartView(Rce), r.registerSeriesModel(ace), r.registerLayout(jg("line", !0)), r.registerVisual({
    seriesType: "line",
    reset: function(e) {
      var t = e.getData(), i = e.getModel("lineStyle").getLineStyle();
      i && !i.stroke && (i.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", i);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, t3("line"));
}
var r3 = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return ts(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getMarkerPosition = function(t, i, n) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(t), s = a.dataToPoint(o);
        if (n)
          w(a.getAxes(), function(f, d) {
            if (f.type === "category" && i != null) {
              var p = f.getTicksCoords(), g = o[d], v = i[d] === "x1" || i[d] === "y1";
              if (v && (g += 1), p.length < 2)
                return;
              if (p.length === 2) {
                s[d] = f.toGlobalCoord(f.getExtent()[v ? 1 : 0]);
                return;
              }
              for (var O = void 0, m = void 0, E = 1, b = 0; b < p.length; b++) {
                var T = p[b].coord, S = b === p.length - 1 ? p[b - 1].tickValue + E : p[b].tickValue;
                if (S === g) {
                  m = T;
                  break;
                } else if (S < g)
                  O = T;
                else if (O != null && S > g) {
                  m = (T + O) / 2;
                  break;
                }
                b === 1 && (E = S - p[0].tickValue);
              }
              m == null && (O ? O && (m = p[p.length - 1].coord) : m = p[0].coord), s[d] = f.toGlobalCoord(m);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), h = l.getLayout("size"), c = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[c] += u + h / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(Xt)
);
Xt.registerClass(r3);
const GE = r3;
var Ice = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function() {
      return ts(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.get("progressiveThreshold"), i = this.get("largeThreshold");
      return i > t && (t = i), t;
    }, e.prototype.brushSelector = function(t, i, n) {
      return n.rect(i.getItemLayout(t));
    }, e.type = "series.bar", e.dependencies = ["grid", "polar"], e.defaultOption = yl(GE.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), e;
  }(GE)
);
const xce = Ice;
var wce = (
  /** @class */
  function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return r;
  }()
), Pce = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "sausage", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new wce();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.cx, a = i.cy, o = Math.max(i.r0 || 0, 0), s = Math.max(i.r, 0), l = (s - o) * 0.5, u = o + l, h = i.startAngle, c = i.endAngle, f = i.clockwise, d = Math.PI * 2, p = f ? c - h < d : h - c < d;
      p || (h = c - (f ? d : -d));
      var g = Math.cos(h), v = Math.sin(h), O = Math.cos(c), m = Math.sin(c);
      p ? (t.moveTo(g * o + n, v * o + a), t.arc(g * u + n, v * u + a, l, -Math.PI + h, h, !f)) : t.moveTo(g * s + n, v * s + a), t.arc(n, a, s, h, c, !f), t.arc(O * u + n, m * u + a, l, c - Math.PI * 2, c - Math.PI, !f), o !== 0 && t.arc(n, a, o, c, h, f);
    }, e;
  }(Fe)
);
const BE = Pce;
function Nce(r, e) {
  e = e || {};
  var t = e.isRoundCap;
  return function(i, n, a) {
    var o = n.position;
    if (!o || o instanceof Array)
      return OE(i, n, a);
    var s = r(o), l = n.distance != null ? n.distance : 5, u = this.shape, h = u.cx, c = u.cy, f = u.r, d = u.r0, p = (f + d) / 2, g = u.startAngle, v = u.endAngle, O = (g + v) / 2, m = t ? Math.abs(f - d) / 2 : 0, E = Math.cos, b = Math.sin, T = h + f * E(g), S = c + f * b(g), y = "left", A = "top";
    switch (s) {
      case "startArc":
        T = h + (d - l) * E(O), S = c + (d - l) * b(O), y = "center", A = "top";
        break;
      case "insideStartArc":
        T = h + (d + l) * E(O), S = c + (d + l) * b(O), y = "center", A = "bottom";
        break;
      case "startAngle":
        T = h + p * E(g) + dO(g, l + m, !1), S = c + p * b(g) + pO(g, l + m, !1), y = "right", A = "middle";
        break;
      case "insideStartAngle":
        T = h + p * E(g) + dO(g, -l + m, !1), S = c + p * b(g) + pO(g, -l + m, !1), y = "left", A = "middle";
        break;
      case "middle":
        T = h + p * E(O), S = c + p * b(O), y = "center", A = "middle";
        break;
      case "endArc":
        T = h + (f + l) * E(O), S = c + (f + l) * b(O), y = "center", A = "bottom";
        break;
      case "insideEndArc":
        T = h + (f - l) * E(O), S = c + (f - l) * b(O), y = "center", A = "top";
        break;
      case "endAngle":
        T = h + p * E(v) + dO(v, l + m, !0), S = c + p * b(v) + pO(v, l + m, !0), y = "left", A = "middle";
        break;
      case "insideEndAngle":
        T = h + p * E(v) + dO(v, -l + m, !0), S = c + p * b(v) + pO(v, -l + m, !0), y = "right", A = "middle";
        break;
      default:
        return OE(i, n, a);
    }
    return i = i || {}, i.x = T, i.y = S, i.align = y, i.verticalAlign = A, i;
  };
}
function Lce(r, e, t, i) {
  if (ut(i)) {
    r.setTextConfig({
      rotation: i
    });
    return;
  } else if (X(e)) {
    r.setTextConfig({
      rotation: 0
    });
    return;
  }
  var n = r.shape, a = n.clockwise ? n.startAngle : n.endAngle, o = n.clockwise ? n.endAngle : n.startAngle, s = (a + o) / 2, l, u = t(e);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = a;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = o;
      break;
    default:
      r.setTextConfig({
        rotation: 0
      });
      return;
  }
  var h = Math.PI * 1.5 - l;
  u === "middle" && h > Math.PI / 2 && h < Math.PI * 1.5 && (h -= Math.PI), r.setTextConfig({
    rotation: h
  });
}
function dO(r, e, t) {
  return e * Math.sin(r) * (t ? -1 : 1);
}
function pO(r, e, t) {
  return e * Math.cos(r) * (t ? 1 : -1);
}
function _u(r, e, t) {
  var i = r.get("borderRadius");
  if (i == null)
    return t ? {
      cornerRadius: 0
    } : null;
  X(i) || (i = [i, i, i, i]);
  var n = Math.abs(e.r || 0 - e.r0 || 0);
  return {
    cornerRadius: Y(i, function(a) {
      return Ea(a, n);
    })
  };
}
var r0 = Math.max, i0 = Math.min;
function Dce(r, e) {
  var t = r.getArea && r.getArea();
  if (Rh(r, "cartesian2d")) {
    var i = r.getBaseAxis();
    if (i.type !== "category" || !i.onBand) {
      var n = e.getLayout("bandWidth");
      i.isHorizontal() ? (t.x -= n, t.width += n * 2) : (t.y -= n, t.height += n * 2);
    }
  }
  return t;
}
var Mce = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.type = e.type, t._isFirstFrame = !0, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this._model = t, this._removeOnRenderedListener(n), this._updateDrawMode(t);
      var o = t.get("coordinateSystem");
      (o === "cartesian2d" || o === "polar") && (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, i, n) : this._renderNormal(t, i, n, a));
    }, e.prototype.incrementalPrepareRender = function(t) {
      this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
    }, e.prototype.incrementalRender = function(t, i) {
      this._progressiveEls = [], this._incrementalRenderLarge(t, i);
    }, e.prototype.eachRendered = function(t) {
      Tl(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var i = t.pipelineContext.large;
      (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
    }, e.prototype._renderNormal = function(t, i, n, a) {
      var o = this.group, s = t.getData(), l = this._data, u = t.coordinateSystem, h = u.getBaseAxis(), c;
      u.type === "cartesian2d" ? c = h.isHorizontal() : u.type === "polar" && (c = h.dim === "angle");
      var f = t.isAnimationEnabled() ? t : null, d = kce(t, u);
      d && this._enableRealtimeSort(d, s, n);
      var p = t.get("clip", !0) || d, g = Dce(u, s);
      o.removeClipPath();
      var v = t.get("roundCap", !0), O = t.get("showBackground", !0), m = t.getModel("backgroundStyle"), E = m.get("borderRadius") || 0, b = [], T = this._backgroundEls, S = a && a.isInitSort, y = a && a.type === "changeAxisOrder";
      function A(I) {
        var x = gO[u.type](s, I), P = Fce(u, c, x);
        return P.useStyle(m.getItemStyle()), u.type === "cartesian2d" ? P.setShape("r", E) : P.setShape("cornerRadius", E), b[I] = P, P;
      }
      s.diff(l).add(function(I) {
        var x = s.getItemModel(I), P = gO[u.type](s, I, x);
        if (O && A(I), !(!s.hasValue(I) || !fk[u.type](P))) {
          var N = !1;
          p && (N = lk[u.type](g, P));
          var L = uk[u.type](t, s, I, P, c, f, h.model, !1, v);
          d && (L.forceLabelAnimation = !0), dk(L, s, I, x, P, t, c, u.type === "polar"), S ? L.attr({
            shape: P
          }) : d ? hk(d, f, L, P, I, c, !1, !1) : Ut(L, {
            shape: P
          }, t, I), s.setItemGraphicEl(I, L), o.add(L), L.ignore = N;
        }
      }).update(function(I, x) {
        var P = s.getItemModel(I), N = gO[u.type](s, I, P);
        if (O) {
          var L = void 0;
          T.length === 0 ? L = A(x) : (L = T[x], L.useStyle(m.getItemStyle()), u.type === "cartesian2d" ? L.setShape("r", E) : L.setShape("cornerRadius", E), b[I] = L);
          var D = gO[u.type](s, I), $ = n3(c, D, u);
          ft(L, {
            shape: $
          }, f, I);
        }
        var k = l.getItemGraphicEl(x);
        if (!s.hasValue(I) || !fk[u.type](N)) {
          o.remove(k);
          return;
        }
        var G = !1;
        if (p && (G = lk[u.type](g, N), G && o.remove(k)), k ? ba(k) : k = uk[u.type](t, s, I, N, c, f, h.model, !!k, v), d && (k.forceLabelAnimation = !0), y) {
          var F = k.getTextContent();
          if (F) {
            var q = Rf(F);
            q.prevValue != null && (q.prevValue = q.value);
          }
        } else
          dk(k, s, I, P, N, t, c, u.type === "polar");
        S ? k.attr({
          shape: N
        }) : d ? hk(d, f, k, N, I, c, !0, y) : ft(k, {
          shape: N
        }, t, I, null), s.setItemGraphicEl(I, k), k.ignore = G, o.add(k);
      }).remove(function(I) {
        var x = l.getItemGraphicEl(I);
        x && Wp(x, t, I);
      }).execute();
      var C = this._backgroundGroup || (this._backgroundGroup = new ye());
      C.removeAll();
      for (var _ = 0; _ < b.length; ++_)
        C.add(b[_]);
      o.add(C), this._backgroundEls = b, this._data = s;
    }, e.prototype._renderLarge = function(t, i, n) {
      this._clear(), gk(t, this.group), this._updateLargeClip(t);
    }, e.prototype._incrementalRenderLarge = function(t, i) {
      this._removeBackground(), gk(i, this.group, this._progressiveEls, !0);
    }, e.prototype._updateLargeClip = function(t) {
      var i = t.get("clip", !0) && XS(t.coordinateSystem, !1, t), n = this.group;
      i ? n.setClipPath(i) : n.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(t, i, n) {
      var a = this;
      if (i.count()) {
        var o = t.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(i, t, n), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = i.getItemGraphicEl(l), h = u && u.shape;
            return h && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(o.isHorizontal() ? h.height : h.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(i, s, o, n);
          }, n.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(t, i, n) {
      var a = [];
      return t.each(t.mapDimension(i.dim), function(o, s) {
        var l = n(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: Y(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(t, i, n) {
      for (var a = n.scale, o = t.mapDimension(n.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var h = t.rawIndexOf(o, a.getRawOrdinalNumber(l)), c = h < 0 ? Number.MIN_VALUE : i(t.indexOfRawIndex(h));
        if (c > s)
          return !0;
        s = c;
      }
      return !1;
    }, e.prototype._isOrderDifferentInView = function(t, i) {
      for (var n = i.scale, a = n.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], n.getOrdinalMeta().categories.length - 1); o <= s; ++o)
        if (t.ordinalNumbers[o] !== n.getRawOrdinalNumber(o))
          return !0;
    }, e.prototype._updateSortWithinSameData = function(t, i, n, a) {
      if (this._isOrderChangedWithinSameData(t, i, n)) {
        var o = this._dataSort(t, n, i);
        this._isOrderDifferentInView(o, n) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: n.dim + "Axis",
          axisId: n.index,
          sortInfo: o
        }));
      }
    }, e.prototype._dispatchInitSort = function(t, i, n) {
      var a = i.baseAxis, o = this._dataSort(t, a, function(s) {
        return t.get(t.mapDimension(i.otherAxis.dim), s);
      });
      n.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: !0,
        axisId: a.index,
        sortInfo: o
      });
    }, e.prototype.remove = function(t, i) {
      this._clear(this._model), this._removeOnRenderedListener(i);
    }, e.prototype.dispose = function(t, i) {
      this._removeOnRenderedListener(i);
    }, e.prototype._removeOnRenderedListener = function(t) {
      this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(t) {
      var i = this.group, n = this._data;
      t && t.isAnimationEnabled() && n && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], n.eachItemGraphicEl(function(a) {
        Wp(a, t, _e(a).dataIndex);
      })) : i.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }(Mt)
), lk = {
  cartesian2d: function(r, e) {
    var t = e.width < 0 ? -1 : 1, i = e.height < 0 ? -1 : 1;
    t < 0 && (e.x += e.width, e.width = -e.width), i < 0 && (e.y += e.height, e.height = -e.height);
    var n = r.x + r.width, a = r.y + r.height, o = r0(e.x, r.x), s = i0(e.x + e.width, n), l = r0(e.y, r.y), u = i0(e.y + e.height, a), h = s < o, c = u < l;
    return e.x = h && o > n ? s : o, e.y = c && l > a ? u : l, e.width = h ? 0 : s - o, e.height = c ? 0 : u - l, t < 0 && (e.x += e.width, e.width = -e.width), i < 0 && (e.y += e.height, e.height = -e.height), h || c;
  },
  polar: function(r, e) {
    var t = e.r0 <= e.r ? 1 : -1;
    if (t < 0) {
      var i = e.r;
      e.r = e.r0, e.r0 = i;
    }
    var n = i0(e.r, r.r), a = r0(e.r0, r.r0);
    e.r = n, e.r0 = a;
    var o = n - a < 0;
    if (t < 0) {
      var i = e.r;
      e.r = e.r0, e.r0 = i;
    }
    return o;
  }
}, uk = {
  cartesian2d: function(r, e, t, i, n, a, o, s, l) {
    var u = new nt({
      shape: V({}, i),
      z2: 1
    });
    if (u.__dataIndex = t, u.name = "item", a) {
      var h = u.shape, c = n ? "height" : "width";
      h[c] = 0;
    }
    return u;
  },
  polar: function(r, e, t, i, n, a, o, s, l) {
    var u = !n && l ? BE : Xi, h = new u({
      shape: i,
      z2: 1
    });
    h.name = "item";
    var c = i3(n);
    if (h.calculateTextPosition = Nce(c, {
      isRoundCap: u === BE
    }), a) {
      var f = h.shape, d = n ? "r" : "endAngle", p = {};
      f[d] = n ? i.r0 : i.startAngle, p[d] = i[d], (s ? ft : Ut)(h, {
        shape: p
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, a);
    }
    return h;
  }
};
function kce(r, e) {
  var t = r.get("realtimeSort", !0), i = e.getBaseAxis();
  if (t && i.type === "category" && e.type === "cartesian2d")
    return {
      baseAxis: i,
      otherAxis: e.getOtherAxis(i)
    };
}
function hk(r, e, t, i, n, a, o, s) {
  var l, u;
  a ? (u = {
    x: i.x,
    width: i.width
  }, l = {
    y: i.y,
    height: i.height
  }) : (u = {
    y: i.y,
    height: i.height
  }, l = {
    x: i.x,
    width: i.width
  }), s || (o ? ft : Ut)(t, {
    shape: l
  }, e, n, null);
  var h = e ? r.baseAxis.model : null;
  (o ? ft : Ut)(t, {
    shape: u
  }, h, n);
}
function ck(r, e) {
  for (var t = 0; t < e.length; t++)
    if (!isFinite(r[e[t]]))
      return !0;
  return !1;
}
var Qce = ["x", "y", "width", "height"], Uce = ["cx", "cy", "r", "startAngle", "endAngle"], fk = {
  cartesian2d: function(r) {
    return !ck(r, Qce);
  },
  polar: function(r) {
    return !ck(r, Uce);
  }
}, gO = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(r, e, t) {
    var i = r.getItemLayout(e), n = t ? Gce(t, i) : 0, a = i.width > 0 ? 1 : -1, o = i.height > 0 ? 1 : -1;
    return {
      x: i.x + a * n / 2,
      y: i.y + o * n / 2,
      width: i.width - a * n,
      height: i.height - o * n
    };
  },
  polar: function(r, e, t) {
    var i = r.getItemLayout(e);
    return {
      cx: i.cx,
      cy: i.cy,
      r0: i.r0,
      r: i.r,
      startAngle: i.startAngle,
      endAngle: i.endAngle,
      clockwise: i.clockwise
    };
  }
};
function $ce(r) {
  return r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle;
}
function i3(r) {
  return function(e) {
    var t = e ? "Arc" : "Angle";
    return function(i) {
      switch (i) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return i + t;
        default:
          return i;
      }
    };
  }(r);
}
function dk(r, e, t, i, n, a, o, s) {
  var l = e.getItemVisual(t, "style");
  if (s) {
    if (!a.get("roundCap")) {
      var h = r.shape, c = _u(i.getModel("itemStyle"), h, !0);
      V(h, c), r.setShape(h);
    }
  } else {
    var u = i.get(["itemStyle", "borderRadius"]) || 0;
    r.setShape("r", u);
  }
  r.useStyle(l);
  var f = i.getShallow("cursor");
  f && r.attr("cursor", f);
  var d = s ? o ? n.r >= n.r0 ? "endArc" : "startArc" : n.endAngle >= n.startAngle ? "endAngle" : "startAngle" : o ? n.height >= 0 ? "bottom" : "top" : n.width >= 0 ? "right" : "left", p = Cr(i);
  Zr(r, p, {
    labelFetcher: a,
    labelDataIndex: t,
    defaultText: tf(a.getData(), t),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: d
  });
  var g = r.getTextContent();
  if (s && g) {
    var v = i.get(["label", "position"]);
    r.textConfig.inside = v === "middle" ? !0 : null, Lce(r, v === "outside" ? d : v, i3(o), i.get(["label", "rotate"]));
  }
  EY(g, p, a.getRawValue(t), function(m) {
    return WW(e, m);
  });
  var O = i.getModel(["emphasis"]);
  zt(r, O.get("focus"), O.get("blurScope"), O.get("disabled")), zr(r, i), $ce(n) && (r.style.fill = "none", r.style.stroke = "none", w(r.states, function(m) {
    m.style && (m.style.fill = m.style.stroke = "none");
  }));
}
function Gce(r, e) {
  var t = r.get(["itemStyle", "borderColor"]);
  if (!t || t === "none")
    return 0;
  var i = r.get(["itemStyle", "borderWidth"]) || 0, n = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
  return Math.min(i, n, a);
}
var Bce = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), pk = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "largeBar", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new Bce();
    }, e.prototype.buildPath = function(t, i) {
      for (var n = i.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, h = 0; h < n.length; h += 3)
        l[a] = u, l[o] = n[h + 2], s[a] = n[h + a], s[o] = n[h + o], t.rect(s[0], s[1], l[0], l[1]);
    }, e;
  }(Fe)
);
function gk(r, e, t, i) {
  var n = r.getData(), a = n.getLayout("valueAxisHorizontal") ? 1 : 0, o = n.getLayout("largeDataIndices"), s = n.getLayout("size"), l = r.getModel("backgroundStyle"), u = n.getLayout("largeBackgroundPoints");
  if (u) {
    var h = new pk({
      shape: {
        points: u
      },
      incremental: !!i,
      silent: !0,
      z2: 0
    });
    h.baseDimIdx = a, h.largeDataIndices = o, h.barWidth = s, h.useStyle(l.getItemStyle()), e.add(h), t && t.push(h);
  }
  var c = new pk({
    shape: {
      points: n.getLayout("largePoints")
    },
    incremental: !!i,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, e.add(c), c.useStyle(n.getVisual("style")), _e(c).seriesIndex = r.seriesIndex, r.get("silent") || (c.on("mousedown", vk), c.on("mousemove", vk)), t && t.push(c);
}
var vk = ux(function(r) {
  var e = this, t = Vce(e, r.offsetX, r.offsetY);
  _e(e).dataIndex = t >= 0 ? t : null;
}, 30, !1);
function Vce(r, e, t) {
  for (var i = r.baseDimIdx, n = 1 - i, a = r.shape.points, o = r.largeDataIndices, s = [], l = [], u = r.barWidth, h = 0, c = a.length / 3; h < c; h++) {
    var f = h * 3;
    if (l[i] = u, l[n] = a[f + 2], s[i] = a[f + i], s[n] = a[f + n], l[n] < 0 && (s[n] += l[n], l[n] = -l[n]), e >= s[0] && e <= s[0] + l[0] && t >= s[1] && t <= s[1] + l[1])
      return o[h];
  }
  return -1;
}
function n3(r, e, t) {
  if (Rh(t, "cartesian2d")) {
    var i = e, n = t.getArea();
    return {
      x: r ? i.x : n.x,
      y: r ? n.y : i.y,
      width: r ? i.width : n.width,
      height: r ? n.height : i.height
    };
  } else {
    var n = t.getArea(), a = e;
    return {
      cx: n.cx,
      cy: n.cy,
      r0: r ? n.r0 : a.r0,
      r: r ? n.r : a.r,
      startAngle: r ? a.startAngle : 0,
      endAngle: r ? a.endAngle : Math.PI * 2
    };
  }
}
function Fce(r, e, t) {
  var i = r.type === "polar" ? Xi : nt;
  return new i({
    shape: n3(e, t, r),
    silent: !0,
    z2: 0
  });
}
const Xce = Mce;
function Yce(r) {
  r.registerChartView(Xce), r.registerSeriesModel(xce), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Ie(lW, "bar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, uW("bar")), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, t3("bar")), r.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(e, t) {
    var i = e.componentType || "series";
    t.eachComponent({
      mainType: i,
      query: e
    }, function(n) {
      e.sortInfo && n.axis.setCategorySortInfo(e.sortInfo);
    });
  });
}
var vO = Math.PI * 2, Ok = Math.PI / 180;
function a3(r, e) {
  return mr(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function o3(r, e) {
  var t = a3(r, e), i = r.get("center"), n = r.get("radius");
  X(n) || (n = [0, n]);
  var a = K(t.width, e.getWidth()), o = K(t.height, e.getHeight()), s = Math.min(a, o), l = K(n[0], s / 2), u = K(n[1], s / 2), h, c, f = r.coordinateSystem;
  if (f) {
    var d = f.dataToPoint(i);
    h = d[0] || 0, c = d[1] || 0;
  } else
    X(i) || (i = [i, i]), h = K(i[0], a) + t.x, c = K(i[1], o) + t.y;
  return {
    cx: h,
    cy: c,
    r0: l,
    r: u
  };
}
function Hce(r, e, t) {
  e.eachSeriesByType(r, function(i) {
    var n = i.getData(), a = n.mapDimension("value"), o = a3(i, t), s = o3(i, t), l = s.cx, u = s.cy, h = s.r, c = s.r0, f = -i.get("startAngle") * Ok, d = i.get("minAngle") * Ok, p = 0;
    n.each(a, function(_) {
      !isNaN(_) && p++;
    });
    var g = n.getSum(a), v = Math.PI / (g || p) * 2, O = i.get("clockwise"), m = i.get("roseType"), E = i.get("stillShowZeroSum"), b = n.getDataExtent(a);
    b[0] = 0;
    var T = vO, S = 0, y = f, A = O ? 1 : -1;
    if (n.setLayout({
      viewRect: o,
      r: h
    }), n.each(a, function(_, I) {
      var x;
      if (isNaN(_)) {
        n.setItemLayout(I, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: O,
          cx: l,
          cy: u,
          r0: c,
          r: m ? NaN : h
        });
        return;
      }
      m !== "area" ? x = g === 0 && E ? v : _ * v : x = vO / p, x < d ? (x = d, T -= d) : S += _;
      var P = y + A * x;
      n.setItemLayout(I, {
        angle: x,
        startAngle: y,
        endAngle: P,
        clockwise: O,
        cx: l,
        cy: u,
        r0: c,
        r: m ? Et(_, b, [c, h]) : h
      }), y = P;
    }), T < vO && p)
      if (T <= 1e-3) {
        var C = vO / p;
        n.each(a, function(_, I) {
          if (!isNaN(_)) {
            var x = n.getItemLayout(I);
            x.angle = C, x.startAngle = f + A * I * C, x.endAngle = f + A * (I + 1) * C;
          }
        });
      } else
        v = T / S, y = f, n.each(a, function(_, I) {
          if (!isNaN(_)) {
            var x = n.getItemLayout(I), P = x.angle === d ? d : _ * v;
            x.startAngle = y, x.endAngle = y + A * P, y += A * P;
          }
        });
  });
}
function Kg(r) {
  return {
    seriesType: r,
    reset: function(e, t) {
      var i = t.findComponents({
        mainType: "legend"
      });
      if (!(!i || !i.length)) {
        var n = e.getData();
        n.filterSelf(function(a) {
          for (var o = n.getName(a), s = 0; s < i.length; s++)
            if (!i[s].isSelected(o))
              return !1;
          return !0;
        });
      }
    }
  };
}
var Wce = Math.PI / 180;
function mk(r, e, t, i, n, a, o, s, l, u) {
  if (r.length < 2)
    return;
  function h(g) {
    for (var v = g.rB, O = v * v, m = 0; m < g.list.length; m++) {
      var E = g.list[m], b = Math.abs(E.label.y - t), T = i + E.len, S = T * T, y = Math.sqrt((1 - Math.abs(b * b / O)) * S), A = e + (y + E.len2) * n, C = A - E.label.x, _ = E.targetTextWidth - C * n;
      s3(E, _, !0), E.label.x = A;
    }
  }
  function c(g) {
    for (var v = {
      list: [],
      maxY: 0
    }, O = {
      list: [],
      maxY: 0
    }, m = 0; m < g.length; m++)
      if (g[m].labelAlignTo === "none") {
        var E = g[m], b = E.label.y > t ? O : v, T = Math.abs(E.label.y - t);
        if (T >= b.maxY) {
          var S = E.label.x - e - E.len2 * n, y = i + E.len, A = Math.abs(S) < y ? Math.sqrt(T * T / (1 - S * S / y / y)) : y;
          b.rB = A, b.maxY = T;
        }
        b.list.push(E);
      }
    h(v), h(O);
  }
  for (var f = r.length, d = 0; d < f; d++)
    if (r[d].position === "outer" && r[d].labelAlignTo === "labelLine") {
      var p = r[d].label.x - u;
      r[d].linePoints[1][0] += p, r[d].label.x = u;
    }
  PW(r, l, l + o) && c(r);
}
function zce(r, e, t, i, n, a, o, s) {
  for (var l = [], u = [], h = Number.MAX_VALUE, c = -Number.MAX_VALUE, f = 0; f < r.length; f++) {
    var d = r[f].label;
    n0(r[f]) || (d.x < e ? (h = Math.min(h, d.x), l.push(r[f])) : (c = Math.max(c, d.x), u.push(r[f])));
  }
  for (var f = 0; f < r.length; f++) {
    var p = r[f];
    if (!n0(p) && p.linePoints) {
      if (p.labelStyleWidth != null)
        continue;
      var d = p.label, g = p.linePoints, v = void 0;
      p.labelAlignTo === "edge" ? d.x < e ? v = g[2][0] - p.labelDistance - o - p.edgeDistance : v = o + n - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < e ? v = h - o - p.bleedMargin : v = o + n - c - p.bleedMargin : d.x < e ? v = d.x - o - p.bleedMargin : v = o + n - d.x - p.bleedMargin, p.targetTextWidth = v, s3(p, v);
    }
  }
  mk(u, e, t, i, 1, n, a, o, s, c), mk(l, e, t, i, -1, n, a, o, s, h);
  for (var f = 0; f < r.length; f++) {
    var p = r[f];
    if (!n0(p) && p.linePoints) {
      var d = p.label, g = p.linePoints, O = p.labelAlignTo === "edge", m = d.style.padding, E = m ? m[1] + m[3] : 0, b = d.style.backgroundColor ? 0 : E, T = p.rect.width + b, S = g[1][0] - g[2][0];
      O ? d.x < e ? g[2][0] = o + p.edgeDistance + T + p.labelDistance : g[2][0] = o + n - p.edgeDistance - T - p.labelDistance : (d.x < e ? g[2][0] = d.x + p.labelDistance : g[2][0] = d.x - p.labelDistance, g[1][0] = g[2][0] + S), g[1][1] = g[2][1] = d.y;
    }
  }
}
function s3(r, e, t) {
  if (t === void 0 && (t = !1), r.labelStyleWidth == null) {
    var i = r.label, n = i.style, a = r.rect, o = n.backgroundColor, s = n.padding, l = s ? s[1] + s[3] : 0, u = n.overflow, h = a.width + (o ? 0 : l);
    if (e < h || t) {
      var c = a.height;
      if (u && u.match("break")) {
        i.setStyle("backgroundColor", null), i.setStyle("width", e - l);
        var f = i.getBoundingRect();
        i.setStyle("width", Math.ceil(f.width)), i.setStyle("backgroundColor", o);
      } else {
        var d = e - l, p = e < h ? d : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          t ? d > r.unconstrainedWidth ? null : d : (
            // Current available width is enough, so no need to
            // constrain.
            null
          )
        );
        i.setStyle("width", p);
      }
      var g = i.getBoundingRect();
      a.width = g.width;
      var v = (i.style.margin || 0) + 2.1;
      a.height = g.height + v, a.y -= (a.height - c) / 2;
    }
  }
}
function n0(r) {
  return r.position === "center";
}
function Zce(r) {
  var e = r.getData(), t = [], i, n, a = !1, o = (r.get("minShowLabelAngle") || 0) * Wce, s = e.getLayout("viewRect"), l = e.getLayout("r"), u = s.width, h = s.x, c = s.y, f = s.height;
  function d(S) {
    S.ignore = !0;
  }
  function p(S) {
    if (!S.ignore)
      return !0;
    for (var y in S.states)
      if (S.states[y].ignore === !1)
        return !0;
    return !1;
  }
  e.each(function(S) {
    var y = e.getItemGraphicEl(S), A = y.shape, C = y.getTextContent(), _ = y.getTextGuideLine(), I = e.getItemModel(S), x = I.getModel("label"), P = x.get("position") || I.get(["emphasis", "label", "position"]), N = x.get("distanceToLabelLine"), L = x.get("alignTo"), D = K(x.get("edgeDistance"), u), $ = x.get("bleedMargin"), k = I.getModel("labelLine"), G = k.get("length");
    G = K(G, u);
    var F = k.get("length2");
    if (F = K(F, u), Math.abs(A.endAngle - A.startAngle) < o) {
      w(C.states, d), C.ignore = !0, _ && (w(_.states, d), _.ignore = !0);
      return;
    }
    if (p(C)) {
      var q = (A.startAngle + A.endAngle) / 2, re = Math.cos(q), fe = Math.sin(q), de, $e, Pe, Ne;
      i = A.cx, n = A.cy;
      var Ee = P === "inside" || P === "inner";
      if (P === "center")
        de = A.cx, $e = A.cy, Ne = "center";
      else {
        var xe = (Ee ? (A.r + A.r0) / 2 * re : A.r * re) + i, Ce = (Ee ? (A.r + A.r0) / 2 * fe : A.r * fe) + n;
        if (de = xe + re * 3, $e = Ce + fe * 3, !Ee) {
          var ue = xe + re * (G + l - A.r), M = Ce + fe * (G + l - A.r), Q = ue + (re < 0 ? -1 : 1) * F, B = M;
          L === "edge" ? de = re < 0 ? h + D : h + u - D : de = Q + (re < 0 ? -N : N), $e = B, Pe = [[xe, Ce], [ue, M], [Q, B]];
        }
        Ne = Ee ? "center" : L === "edge" ? re > 0 ? "right" : "left" : re > 0 ? "left" : "right";
      }
      var W = Math.PI, H = 0, J = x.get("rotate");
      if (ut(J))
        H = J * (W / 180);
      else if (P === "center")
        H = 0;
      else if (J === "radial" || J === !0) {
        var le = re < 0 ? -q + W : -q;
        H = le;
      } else if (J === "tangential" && P !== "outside" && P !== "outer") {
        var ee = Math.atan2(re, fe);
        ee < 0 && (ee = W * 2 + ee);
        var se = fe > 0;
        se && (ee = W + ee), H = ee - W;
      }
      if (a = !!H, C.x = de, C.y = $e, C.rotation = H, C.setStyle({
        verticalAlign: "middle"
      }), Ee) {
        C.setStyle({
          align: Ne
        });
        var Te = C.states.select;
        Te && (Te.x += C.x, Te.y += C.y);
      } else {
        var j = C.getBoundingRect().clone();
        j.applyTransform(C.getComputedTransform());
        var we = (C.style.margin || 0) + 2.1;
        j.y -= we / 2, j.height += we, t.push({
          label: C,
          labelLine: _,
          position: P,
          len: G,
          len2: F,
          minTurnAngle: k.get("minTurnAngle"),
          maxSurfaceAngle: k.get("maxSurfaceAngle"),
          surfaceNormal: new Le(re, fe),
          linePoints: Pe,
          textAlign: Ne,
          labelDistance: N,
          labelAlignTo: L,
          edgeDistance: D,
          bleedMargin: $,
          rect: j,
          unconstrainedWidth: j.width,
          labelStyleWidth: C.style.width
        });
      }
      y.setTextConfig({
        inside: Ee
      });
    }
  }), !a && r.get("avoidLabelOverlap") && zce(t, i, n, l, u, f, h, c);
  for (var g = 0; g < t.length; g++) {
    var v = t[g], O = v.label, m = v.labelLine, E = isNaN(O.x) || isNaN(O.y);
    if (O) {
      O.setStyle({
        align: v.textAlign
      }), E && (w(O.states, d), O.ignore = !0);
      var b = O.states.select;
      b && (b.x += O.x, b.y += O.y);
    }
    if (m) {
      var T = v.linePoints;
      E || !T ? (w(m.states, d), m.ignore = !0) : (IW(T, v.minTurnAngle), lhe(T, v.surfaceNormal, v.maxSurfaceAngle), m.setShape({
        points: T
      }), O.__hostTarget.textGuideLineConfig = {
        anchor: new Le(T[0][0], T[0][1])
      });
    }
  }
}
var qce = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      a.z2 = 2;
      var o = new lt();
      return a.setTextContent(o), a.updateData(t, i, n, !0), a;
    }
    return e.prototype.updateData = function(t, i, n, a) {
      var o = this, s = t.hostModel, l = t.getItemModel(i), u = l.getModel("emphasis"), h = t.getItemLayout(i), c = V(_u(l.getModel("itemStyle"), h, !0), h);
      if (isNaN(c.startAngle)) {
        o.setShape(c);
        return;
      }
      if (a) {
        o.setShape(c);
        var f = s.getShallow("animationType");
        s.ecModel.ssr ? (Ut(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: i,
          isFrom: !0
        }), o.originX = c.cx, o.originY = c.cy) : f === "scale" ? (o.shape.r = h.r0, Ut(o, {
          shape: {
            r: h.r
          }
        }, s, i)) : n != null ? (o.setShape({
          startAngle: n,
          endAngle: n
        }), Ut(o, {
          shape: {
            startAngle: h.startAngle,
            endAngle: h.endAngle
          }
        }, s, i)) : (o.shape.endAngle = h.startAngle, ft(o, {
          shape: {
            endAngle: h.endAngle
          }
        }, s, i));
      } else
        ba(o), ft(o, {
          shape: c
        }, s, i);
      o.useStyle(t.getItemVisual(i, "style")), zr(o, l);
      var d = (h.startAngle + h.endAngle) / 2, p = s.get("selectedOffset"), g = Math.cos(d) * p, v = Math.sin(d) * p, O = l.getShallow("cursor");
      O && o.attr("cursor", O), this._updateLabel(s, t, i), o.ensureState("emphasis").shape = V({
        r: h.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, _u(u.getModel("itemStyle"), h)), V(o.ensureState("select"), {
        x: g,
        y: v,
        shape: _u(l.getModel(["select", "itemStyle"]), h)
      }), V(o.ensureState("blur"), {
        shape: _u(l.getModel(["blur", "itemStyle"]), h)
      });
      var m = o.getTextGuideLine(), E = o.getTextContent();
      m && V(m.ensureState("select"), {
        x: g,
        y: v
      }), V(E.ensureState("select"), {
        x: g,
        y: v
      }), zt(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, i, n) {
      var a = this, o = i.getItemModel(n), s = o.getModel("labelLine"), l = i.getItemVisual(n, "style"), u = l && l.fill, h = l && l.opacity;
      Zr(a, Cr(o), {
        labelFetcher: i.hostModel,
        labelDataIndex: n,
        inheritColor: u,
        defaultOpacity: h,
        defaultText: t.getFormattedLabel(n, "normal") || i.getName(n)
      });
      var c = a.getTextContent();
      a.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), c.attr({
        z2: 10
      });
      var f = t.get(["label", "position"]);
      if (f !== "outside" && f !== "outer")
        a.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new Wi(), this.setTextGuideLine(d)), Tx(this, yx(o), {
          stroke: u,
          opacity: Ka(s.get(["lineStyle", "opacity"]), h, 1)
        });
      }
    }, e;
  }(Xi)
), jce = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = t.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var h = o.getItemLayout(0), c = 1; isNaN(h && h.startAngle) && c < o.count(); ++c)
          h = o.getItemLayout(c);
        h && (u = h.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && t.get("showEmptyCircle")) {
        var f = new Xi({
          shape: o3(t, n)
        });
        f.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = f, l.add(f);
      }
      o.diff(s).add(function(d) {
        var p = new qce(o, d, u);
        o.setItemGraphicEl(d, p), l.add(p);
      }).update(function(d, p) {
        var g = s.getItemGraphicEl(p);
        g.updateData(o, d, u), g.off("click"), l.add(g), o.setItemGraphicEl(d, g);
      }).remove(function(d) {
        var p = s.getItemGraphicEl(d);
        Wp(p, t, d);
      }).execute(), Zce(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(t, i) {
      var n = i.getData(), a = n.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "pie", e;
  }(Mt)
);
const Kce = jce;
function Lf(r, e, t) {
  e = X(e) && {
    coordDimensions: e
  } || V({
    encodeDefine: r.getEncode()
  }, e);
  var i = r.getSource(), n = Hg(i, e).dimensions, a = new Ai(n, r);
  return a.initData(i, t), a;
}
var Jce = (
  /** @class */
  function() {
    function r(e, t) {
      this._getDataWithEncodedVisual = e, this._getRawData = t;
    }
    return r.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, r.prototype.containName = function(e) {
      var t = this._getRawData();
      return t.indexOfName(e) >= 0;
    }, r.prototype.indexOfName = function(e) {
      var t = this._getDataWithEncodedVisual();
      return t.indexOfName(e);
    }, r.prototype.getItemVisual = function(e, t) {
      var i = this._getDataWithEncodedVisual();
      return i.getItemVisual(e, t);
    }, r;
  }()
);
const Jg = Jce;
var efe = at(), tfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Jg(ae(this.getData, this), ae(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.mergeOption = function() {
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return Lf(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Ie(JI, this)
      });
    }, e.prototype.getDataParams = function(t) {
      var i = this.getData(), n = efe(i), a = n.seats;
      if (!a) {
        var o = [];
        i.each(i.mapDimension("value"), function(l) {
          o.push(l);
        }), a = n.seats = pie(o, i.hostModel.get("percentPrecision"));
      }
      var s = r.prototype.getDataParams.call(this, t);
      return s.percent = a[t] || 0, s.$vars.push("percent"), s;
    }, e.prototype._defaultLabelLine = function(t) {
      eh(t, "labelLine", ["show"]);
      var i = t.labelLine, n = t.emphasis.labelLine;
      i.show = i.show && t.label.show, n.show = n.show && t.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      // 0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 
      selectedOffset: 10,
      // singlemultiple
      // selectedMode: false,
      // 'radius' | 'area'
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter:  tooltip.formatter
        //  textStyle
        // distance: positioninnerlabel()
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 
        length: 15,
        // 
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: ,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(Xt)
);
const rfe = tfe;
function ife(r) {
  return {
    seriesType: r,
    reset: function(e, t) {
      var i = e.getData();
      i.filterSelf(function(n) {
        var a = i.mapDimension("value"), o = i.get(a, n);
        return !(ut(o) && !isNaN(o) && o < 0);
      });
    }
  };
}
function nfe(r) {
  r.registerChartView(Kce), r.registerSeriesModel(rfe), _H("pie", r.registerAction), r.registerLayout(Ie(Hce, "pie")), r.registerProcessor(Kg("pie")), r.registerProcessor(ife("pie"));
}
var afe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return ts(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, e.prototype.brushSelector = function(t, i, n) {
      return n.point(i.getItemLayout(t));
    }, e.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, e.type = "series.scatter", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, e;
  }(Xt)
);
const ofe = afe;
var l3 = 4, sfe = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), lfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i._off = 0, i.hoverDataIdx = -1, i;
    }
    return e.prototype.getDefaultShape = function() {
      return new sfe();
    }, e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = i.size, o = this.symbolProxy, s = o.shape, l = t.getContext ? t.getContext() : t, u = l && a[0] < l3, h = this.softClipShape, c;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, c = this._off; c < n.length; ) {
        var f = n[c++], d = n[c++];
        isNaN(f) || isNaN(d) || h && !h.contain(f, d) || (s.x = f - a[0] / 2, s.y = d - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(t, s, !0));
      }
      this.incremental && (this._off = c, this.notClear = !0);
    }, e.prototype.afterBrush = function() {
      var t = this.shape, i = t.points, n = t.size, a = this._ctx, o = this.softClipShape, s;
      if (a) {
        for (s = this._off; s < i.length; ) {
          var l = i[s++], u = i[s++];
          isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - n[0] / 2, u - n[1] / 2, n[0], n[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, e.prototype.findDataIndex = function(t, i) {
      for (var n = this.shape, a = n.points, o = n.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var h = u * 2, c = a[h] - s / 2, f = a[h + 1] - l / 2;
        if (t >= c && i >= f && t <= c + s && i <= f + l)
          return u;
      }
      return -1;
    }, e.prototype.contain = function(t, i) {
      var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
      if (t = n[0], i = n[1], a.contain(t, i)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, i);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var i = this.shape, n = i.points, a = i.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, h = -1 / 0, c = -1 / 0, f = 0; f < n.length; ) {
          var d = n[f++], p = n[f++];
          l = Math.min(d, l), h = Math.max(d, h), u = Math.min(p, u), c = Math.max(p, c);
        }
        t = this._rect = new Ue(l - o / 2, u - s / 2, h - l + o, c - u + s);
      }
      return t;
    }, e;
  }(Fe)
), ufe = (
  /** @class */
  function() {
    function r() {
      this.group = new ye();
    }
    return r.prototype.updateData = function(e, t) {
      this._clear();
      var i = this._create();
      i.setShape({
        points: e.getLayout("points")
      }), this._setCommon(i, e, t);
    }, r.prototype.updateLayout = function(e) {
      var t = e.getLayout("points");
      this.group.eachChild(function(i) {
        if (i.startIndex != null) {
          var n = (i.endIndex - i.startIndex) * 2, a = i.startIndex * 4 * 2;
          t = new Float32Array(t.buffer, a, n);
        }
        i.setShape("points", t), i.reset();
      });
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._clear();
    }, r.prototype.incrementalUpdate = function(e, t, i) {
      var n = this._newAdded[0], a = t.getLayout("points"), o = n && n.shape.points;
      if (o && o.length < 2e4) {
        var s = o.length, l = new Float32Array(s + a.length);
        l.set(o), l.set(a, s), n.endIndex = e.end, n.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = e.start, u.endIndex = e.end, u.incremental = !0, u.setShape({
          points: a
        }), this._setCommon(u, t, i);
      }
    }, r.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, r.prototype._create = function() {
      var e = new lfe({
        cursor: "default"
      });
      return e.ignoreCoarsePointer = !0, this.group.add(e), this._newAdded.push(e), e;
    }, r.prototype._setCommon = function(e, t, i) {
      var n = t.hostModel;
      i = i || {};
      var a = t.getVisual("symbolSize");
      e.setShape("size", a instanceof Array ? a : [a, a]), e.softClipShape = i.clipShape || null, e.symbolProxy = ur(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
      var o = e.shape.size[0] < l3;
      e.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        n.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = t.getVisual("style"), l = s && s.fill;
      l && e.setColor(l);
      var u = _e(e);
      u.seriesIndex = n.seriesIndex, e.on("mousemove", function(h) {
        u.dataIndex = null;
        var c = e.hoverDataIdx;
        c >= 0 && (u.dataIndex = c + (e.startIndex || 0));
      });
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
);
const hfe = ufe;
var cfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.updateData(a, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(t)
      }), this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.incrementalPrepareUpdate(a), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, i, n) {
      this._symbolDraw.incrementalUpdate(t, i.getData(), {
        clipShape: this._getClipShape(i)
      }), this._finished = t.end === i.getData().count();
    }, e.prototype.updateTransform = function(t, i, n) {
      var a = t.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4)
        return {
          update: !0
        };
      var o = jg("").reset(t, i, n);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, e.prototype.eachRendered = function(t) {
      this._symbolDraw && this._symbolDraw.eachRendered(t);
    }, e.prototype._getClipShape = function(t) {
      var i = t.coordinateSystem, n = i && i.getArea && i.getArea();
      return t.get("clip", !0) ? n : null;
    }, e.prototype._updateSymbolDraw = function(t, i) {
      var n = this._symbolDraw, a = i.pipelineContext, o = a.large;
      return (!n || o !== this._isLargeDraw) && (n && n.remove(), n = this._symbolDraw = o ? new hfe() : new qg(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(n.group), n;
    }, e.prototype.remove = function(t, i) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, e.prototype.dispose = function() {
    }, e.type = "scatter", e;
  }(Mt)
);
const ffe = cfe;
var dfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = ["xAxis", "yAxis"], e.layoutMode = "box", e.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(ot)
);
const pfe = dfe;
var _C = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", lr).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(ot)
);
hr(_C, zg);
var u3 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, gfe = Qe({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, u3), Ix = Qe({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, u3), vfe = Qe({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, Ix), Ofe = me({
  logBase: 10
}, Ix);
const h3 = {
  category: gfe,
  value: Ix,
  time: vfe,
  log: Ofe
};
var mfe = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function rf(r, e, t, i) {
  w(mfe, function(n, a) {
    var o = Qe(Qe({}, h3[a], !0), i, !0), s = (
      /** @class */
      function(l) {
        U(u, l);
        function u() {
          var h = l !== null && l.apply(this, arguments) || this;
          return h.type = e + "Axis." + a, h;
        }
        return u.prototype.mergeDefaultAndTheme = function(h, c) {
          var f = qp(this), d = f ? _f(h) : {}, p = c.getTheme();
          Qe(h, p.get(a + "Axis")), Qe(h, this.getDefaultOption()), h.type = Ek(h), f && ol(h, d, f);
        }, u.prototype.optionUpdated = function() {
          var h = this.option;
          h.type === "category" && (this.__ordinalMeta = bC.createByAxisModel(this));
        }, u.prototype.getCategories = function(h) {
          var c = this.option;
          if (c.type === "category")
            return h ? c.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + a, u.defaultOption = o, u;
      }(t)
    );
    r.registerComponentModel(s);
  }), r.registerSubTypeDefaulter(e + "Axis", Ek);
}
function Ek(r) {
  return r.type || (r.data ? "category" : "value");
}
var Efe = (
  /** @class */
  function() {
    function r(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return r.prototype.getAxis = function(e) {
      return this._axes[e];
    }, r.prototype.getAxes = function() {
      return Y(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, r.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), yt(this.getAxes(), function(t) {
        return t.scale.type === e;
      });
    }, r.prototype.addAxis = function(e) {
      var t = e.dim;
      this._axes[t] = e, this._dimList.push(t);
    }, r;
  }()
);
const bfe = Efe;
var IC = ["x", "y"];
function bk(r) {
  return r.type === "interval" || r.type === "time";
}
var Sfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "cartesian2d", t.dimensions = IC, t;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var t = this.getAxis("x").scale, i = this.getAxis("y").scale;
      if (!(!bk(t) || !bk(i))) {
        var n = t.getExtent(), a = i.getExtent(), o = this.dataToPoint([n[0], a[0]]), s = this.dataToPoint([n[1], a[1]]), l = n[1] - n[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var h = (s[0] - o[0]) / l, c = (s[1] - o[1]) / u, f = o[0] - n[0] * h, d = o[1] - a[0] * c, p = this._transform = [h, 0, 0, c, f, d];
          this._invTransform = Ef([], p);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(t) {
      var i = this.getAxis("x"), n = this.getAxis("y");
      return i.contain(i.toLocalCoord(t[0])) && n.contain(n.toLocalCoord(t[1]));
    }, e.prototype.containData = function(t) {
      return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
    }, e.prototype.containZone = function(t, i) {
      var n = this.dataToPoint(t), a = this.dataToPoint(i), o = this.getArea(), s = new Ue(n[0], n[1], a[0] - n[0], a[1] - n[1]);
      return o.intersect(s);
    }, e.prototype.dataToPoint = function(t, i, n) {
      n = n || [];
      var a = t[0], o = t[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o))
        return Hr(n, t, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return n[0] = s.toGlobalCoord(s.dataToCoord(a, i)), n[1] = l.toGlobalCoord(l.dataToCoord(o, i)), n;
    }, e.prototype.clampData = function(t, i) {
      var n = this.getAxis("x").scale, a = this.getAxis("y").scale, o = n.getExtent(), s = a.getExtent(), l = n.parse(t[0]), u = a.parse(t[1]);
      return i = i || [], i[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), i[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), i;
    }, e.prototype.pointToData = function(t, i) {
      var n = [];
      if (this._invTransform)
        return Hr(n, t, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return n[0] = a.coordToData(a.toLocalCoord(t[0]), i), n[1] = o.coordToData(o.toLocalCoord(t[1]), i), n;
    }, e.prototype.getOtherAxis = function(t) {
      return this.getAxis(t.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function() {
      var t = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), n = Math.min(t[0], t[1]), a = Math.min(i[0], i[1]), o = Math.max(t[0], t[1]) - n, s = Math.max(i[0], i[1]) - a;
      return new Ue(n, a, o, s);
    }, e;
  }(bfe)
), Tfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n, a, o) {
      var s = r.call(this, t, i, n) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.getGlobalExtent = function(t) {
      var i = this.getExtent();
      return i[0] = this.toGlobalCoord(i[0]), i[1] = this.toGlobalCoord(i[1]), t && i[0] > i[1] && i.reverse(), i;
    }, e.prototype.pointToData = function(t, i) {
      return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), i);
    }, e.prototype.setCategorySortInfo = function(t) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
    }, e;
  }(Ta)
);
const yfe = Tfe;
function xC(r, e, t) {
  t = t || {};
  var i = r.coordinateSystem, n = e.axis, a = {}, o = n.getAxesOnZeroOf()[0], s = n.position, l = o ? "onZero" : s, u = n.dim, h = i.getRect(), c = [h.x, h.x + h.width, h.y, h.y + h.height], f = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, d = e.get("offset") || 0, p = u === "x" ? [c[2] - d, c[3] + d] : [c[0] - d, c[1] + d];
  if (o) {
    var g = o.toGlobalCoord(o.dataToCoord(0));
    p[f.onZero] = Math.max(Math.min(g, p[1]), p[0]);
  }
  a.position = [u === "y" ? p[f[l]] : c[0], u === "x" ? p[f[l]] : c[3]], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  a.labelDirection = a.tickDirection = a.nameDirection = v[s], a.labelOffset = o ? p[f[s]] - p[f.onZero] : 0, e.get(["axisTick", "inside"]) && (a.tickDirection = -a.tickDirection), Dr(t.labelInside, e.get(["axisLabel", "inside"])) && (a.labelDirection = -a.labelDirection);
  var O = e.get(["axisLabel", "rotate"]);
  return a.labelRotate = l === "top" ? -O : O, a.z2 = 1, a;
}
function Sk(r) {
  return r.get("coordinateSystem") === "cartesian2d";
}
function Tk(r) {
  var e = {
    xAxisModel: null,
    yAxisModel: null
  };
  return w(e, function(t, i) {
    var n = i.replace(/Model$/, ""), a = r.getReferringComponents(n, lr).models[0];
    e[i] = a;
  }), e;
}
var a0 = Math.log;
function c3(r, e, t) {
  var i = ll.prototype, n = i.getTicks.call(t), a = i.getTicks.call(t, !0), o = n.length - 1, s = i.getInterval.call(t), l = vW(r, e), u = l.extent, h = l.fixMin, c = l.fixMax;
  if (r.type === "log") {
    var f = a0(r.base);
    u = [a0(u[0]) / f, a0(u[1]) / f];
  }
  r.setExtent(u[0], u[1]), r.calcNiceExtent({
    splitNumber: o,
    fixMin: h,
    fixMax: c
  });
  var d = i.getExtent.call(r);
  h && (u[0] = d[0]), c && (u[1] = d[1]);
  var p = i.getInterval.call(r), g = u[0], v = u[1];
  if (h && c)
    p = (v - g) / o;
  else if (h)
    for (v = u[0] + p * o; v < u[1] && isFinite(v) && isFinite(u[1]); )
      p = Yy(p), v = u[0] + p * o;
  else if (c)
    for (g = u[1] - p * o; g > u[0] && isFinite(g) && isFinite(u[0]); )
      p = Yy(p), g = u[1] - p * o;
  else {
    var O = r.getTicks().length - 1;
    O > o && (p = Yy(p));
    var m = p * o;
    v = Math.ceil(u[1] / p) * p, g = Kt(v - m), g < 0 && u[0] >= 0 ? (g = 0, v = Kt(m)) : v > 0 && u[1] <= 0 && (v = 0, g = -Kt(m));
  }
  var E = (n[0].value - a[0].value) / s, b = (n[o].value - a[o].value) / s;
  i.setExtent.call(r, g + p * E, v + p * b), i.setInterval.call(r, p), (E || b) && i.setNiceExtent.call(r, g + p, v - p);
}
var Rfe = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = IC, this._initCartesian(e, t, i), this.model = e;
    }
    return r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.update = function(e, t) {
      var i = this._axesMap;
      this._updateScale(e, this.model);
      function n(o) {
        var s, l = He(o), u = l.length;
        if (u) {
          for (var h = [], c = u - 1; c >= 0; c--) {
            var f = +l[c], d = o[f], p = d.model, g = d.scale;
            // Only value and log axis without interval support alignTicks.
            SC(g) && p.get("alignTicks") && p.get("interval") == null ? h.push(d) : (ef(g, p), SC(g) && (s = d));
          }
          h.length && (s || (s = h.pop(), ef(s.scale, s.model)), w(h, function(v) {
            c3(v.scale, v.model, s.scale);
          }));
        }
      }
      n(i.x), n(i.y);
      var a = {};
      w(i.x, function(o) {
        yk(i, "y", o, a);
      }), w(i.y, function(o) {
        yk(i, "x", o, a);
      }), this.resize(this.model, t);
    }, r.prototype.resize = function(e, t, i) {
      var n = e.getBoxLayoutParams(), a = !i && e.get("containLabel"), o = mr(n, {
        width: t.getWidth(),
        height: t.getHeight()
      });
      this._rect = o;
      var s = this._axesList;
      l(), a && (w(s, function(u) {
        if (!u.model.get(["axisLabel", "inside"])) {
          var h = Uue(u);
          if (h) {
            var c = u.isHorizontal() ? "height" : "width", f = u.model.get(["axisLabel", "margin"]);
            o[c] -= h[c] + f, u.position === "top" ? o.y += h.height + f : u.position === "left" && (o.x += h.width + f);
          }
        }
      }), l()), w(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        w(s, function(u) {
          var h = u.isHorizontal(), c = h ? [0, o.width] : [0, o.height], f = u.inverse ? 1 : 0;
          u.setExtent(c[f], c[1 - f]), Afe(u, h ? o.x : o.y);
        });
      }
    }, r.prototype.getAxis = function(e, t) {
      var i = this._axesMap[e];
      if (i != null)
        return i[t || 0];
    }, r.prototype.getAxes = function() {
      return this._axesList.slice();
    }, r.prototype.getCartesian = function(e, t) {
      if (e != null && t != null) {
        var i = "x" + e + "y" + t;
        return this._coordsMap[i];
      }
      be(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
      for (var n = 0, a = this._coordsList; n < a.length; n++)
        if (a[n].getAxis("x").index === e || a[n].getAxis("y").index === t)
          return a[n];
    }, r.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = this._findConvertTarget(t);
      return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = this._findConvertTarget(t);
      return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null;
    }, r.prototype._findConvertTarget = function(e) {
      var t = e.seriesModel, i = e.xAxisModel || t && t.getReferringComponents("xAxis", lr).models[0], n = e.yAxisModel || t && t.getReferringComponents("yAxis", lr).models[0], a = e.gridModel, o = this._coordsList, s, l;
      if (t)
        s = t.coordinateSystem, Ge(o, s) < 0 && (s = null);
      else if (i && n)
        s = this.getCartesian(i.componentIndex, n.componentIndex);
      else if (i)
        l = this.getAxis("x", i.componentIndex);
      else if (n)
        l = this.getAxis("y", n.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, r.prototype.containPoint = function(e) {
      var t = this._coordsList[0];
      if (t)
        return t.containPoint(e);
    }, r.prototype._initCartesian = function(e, t, i) {
      var n = this, a = this, o = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, w(s.x, function(h, c) {
        w(s.y, function(f, d) {
          var p = "x" + c + "y" + d, g = new Sfe(p);
          g.master = n, g.model = e, n._coordsMap[p] = g, n._coordsList.push(g), g.addAxis(h), g.addAxis(f);
        });
      });
      function u(h) {
        return function(c, f) {
          if (o0(c, e)) {
            var d = c.get("position");
            h === "x" ? d !== "top" && d !== "bottom" && (d = o.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = o.left ? "right" : "left"), o[d] = !0;
            var p = new yfe(h, VS(c), [0, 0], c.get("type"), d), g = p.type === "category";
            p.onBand = g && c.get("boundaryGap"), p.inverse = c.get("inverse"), c.axis = p, p.model = c, p.grid = a, p.index = f, a._axesList.push(p), s[h][f] = p, l[h]++;
          }
        };
      }
    }, r.prototype._updateScale = function(e, t) {
      w(this._axesList, function(n) {
        if (n.scale.setExtent(1 / 0, -1 / 0), n.type === "category") {
          var a = n.model.get("categorySortInfo");
          n.scale.setSortInfo(a);
        }
      }), e.eachSeries(function(n) {
        if (Sk(n)) {
          var a = Tk(n), o = a.xAxisModel, s = a.yAxisModel;
          if (!o0(o, t) || !o0(s, t))
            return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = n.getData(), h = l.getAxis("x"), c = l.getAxis("y");
          i(u, h), i(u, c);
        }
      }, this);
      function i(n, a) {
        w(kE(n, a.dim), function(o) {
          a.scale.unionExtentFromData(n, o);
        });
      }
    }, r.prototype.getTooltipAxes = function(e) {
      var t = [], i = [];
      return w(this.getCartesians(), function(n) {
        var a = e != null && e !== "auto" ? n.getAxis(e) : n.getBaseAxis(), o = n.getOtherAxis(a);
        Ge(t, a) < 0 && t.push(a), Ge(i, o) < 0 && i.push(o);
      }), {
        baseAxes: t,
        otherAxes: i
      };
    }, r.create = function(e, t) {
      var i = [];
      return e.eachComponent("grid", function(n, a) {
        var o = new r(n, e, t);
        o.name = "grid_" + a, o.resize(n, t, !0), n.coordinateSystem = o, i.push(o);
      }), e.eachSeries(function(n) {
        if (Sk(n)) {
          var a = Tk(n), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel(), u = l.coordinateSystem;
          n.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
        }
      }), i;
    }, r.dimensions = IC, r;
  }()
);
function o0(r, e) {
  return r.getCoordSysModel() === e;
}
function yk(r, e, t, i) {
  t.getAxesOnZeroOf = function() {
    return a ? [a] : [];
  };
  var n = r[e], a, o = t.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    Rk(n[l]) && (a = n[l]);
  else
    for (var u in n)
      if (n.hasOwnProperty(u) && Rk(n[u]) && !i[h(n[u])]) {
        a = n[u];
        break;
      }
  a && (i[h(a)] = !0);
  function h(c) {
    return c.dim + "_" + c.index;
  }
}
function Rk(r) {
  return r && r.type !== "category" && r.type !== "time" && Que(r);
}
function Afe(r, e) {
  var t = r.getExtent(), i = t[0] + t[1];
  r.toGlobalCoord = r.dim === "x" ? function(n) {
    return n + e;
  } : function(n) {
    return i - n + e;
  }, r.toLocalCoord = r.dim === "x" ? function(n) {
    return n - e;
  } : function(n) {
    return i - n + e;
  };
}
const Cfe = Rfe;
var Ms = Math.PI, Yu = (
  /** @class */
  function() {
    function r(e, t) {
      this.group = new ye(), this.opt = t, this.axisModel = e, me(t, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var i = new ye({
        x: t.position[0],
        y: t.position[1],
        rotation: t.rotation
      });
      i.updateTransform(), this._transformGroup = i;
    }
    return r.prototype.hasBuilder = function(e) {
      return !!Ak[e];
    }, r.prototype.add = function(e) {
      Ak[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, r.prototype.getGroup = function() {
      return this.group;
    }, r.innerTextLayout = function(e, t, i) {
      var n = fX(t - e), a, o;
      return mE(n) ? (o = i > 0 ? "top" : "bottom", a = "center") : mE(n - Ms) ? (o = i > 0 ? "bottom" : "top", a = "center") : (o = "middle", n > 0 && n < Ms ? a = i > 0 ? "right" : "left" : a = i > 0 ? "left" : "right"), {
        rotation: n,
        textAlign: a,
        textVerticalAlign: o
      };
    }, r.makeAxisEventDataBase = function(e) {
      var t = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return t[e.mainType + "Index"] = e.componentIndex, t;
    }, r.isLabelSilent = function(e) {
      var t = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || t && t.show);
    }, r;
  }()
), Ak = {
  axisLine: function(r, e, t, i) {
    var n = e.get(["axisLine", "show"]);
    if (n === "auto" && r.handleAutoShown && (n = r.handleAutoShown("axisLine")), !!n) {
      var a = e.axis.getExtent(), o = i.transform, s = [a[0], 0], l = [a[1], 0], u = s[0] > l[0];
      o && (Hr(s, s, o), Hr(l, l, o));
      var h = V({
        lineCap: "round"
      }, e.getModel(["axisLine", "lineStyle"]).getLineStyle()), c = new Mr({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: l[0],
          y2: l[1]
        },
        style: h,
        strokeContainThreshold: r.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      jc(c.shape, c.style.lineWidth), c.anid = "line", t.add(c);
      var f = e.get(["axisLine", "symbol"]);
      if (f != null) {
        var d = e.get(["axisLine", "symbolSize"]);
        ne(f) && (f = [f, f]), (ne(d) || ut(d)) && (d = [d, d]);
        var p = Th(e.get(["axisLine", "symbolOffset"]) || 0, d), g = d[0], v = d[1];
        w([{
          rotate: r.rotation + Math.PI / 2,
          offset: p[0],
          r: 0
        }, {
          rotate: r.rotation - Math.PI / 2,
          offset: p[1],
          r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
        }], function(O, m) {
          if (f[m] !== "none" && f[m] != null) {
            var E = ur(f[m], -g / 2, -v / 2, g, v, h.stroke, !0), b = O.r + O.offset, T = u ? l : s;
            E.attr({
              rotation: O.rotate,
              x: T[0] + b * Math.cos(r.rotation),
              y: T[1] - b * Math.sin(r.rotation),
              silent: !0,
              z2: 11
            }), t.add(E);
          }
        });
      }
    }
  },
  axisTickLabel: function(r, e, t, i) {
    var n = xfe(t, i, e, r), a = Pfe(t, i, e, r);
    if (Ife(e, a, n), wfe(t, i, e, r.tickDirection), e.get(["axisLabel", "hideOverlap"])) {
      var o = xW(Y(a, function(s) {
        return {
          label: s,
          priority: s.z2,
          defaultAttr: {
            ignore: s.ignore
          }
        };
      }));
      NW(o);
    }
  },
  axisName: function(r, e, t, i) {
    var n = Dr(r.axisName, e.get("name"));
    if (n) {
      var a = e.get("nameLocation"), o = r.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), h = u[0] > u[1] ? -1 : 1, c = [
        a === "start" ? u[0] - h * l : a === "end" ? u[1] + h * l : (u[0] + u[1]) / 2,
        // Reuse labelOffset.
        _k(a) ? r.labelOffset + o * l : 0
      ], f, d = e.get("nameRotate");
      d != null && (d = d * Ms / 180);
      var p;
      _k(a) ? f = Yu.innerTextLayout(
        r.rotation,
        d ?? r.rotation,
        // Adapt to axis.
        o
      ) : (f = _fe(r.rotation, a, d || 0, u), p = r.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(f.rotation)), !isFinite(p) && (p = null)));
      var g = s.getFont(), v = e.get("nameTruncate", !0) || {}, O = v.ellipsis, m = Dr(r.nameTruncateMaxWidth, v.maxWidth, p), E = new lt({
        x: c[0],
        y: c[1],
        rotation: f.rotation,
        silent: Yu.isLabelSilent(e),
        style: Lt(s, {
          text: n,
          font: g,
          overflow: "truncate",
          width: m,
          ellipsis: O,
          fill: s.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          align: s.get("align") || f.textAlign,
          verticalAlign: s.get("verticalAlign") || f.textVerticalAlign
        }),
        z2: 1
      });
      if (yf({
        el: E,
        componentModel: e,
        itemName: n
      }), E.__fullText = n, E.anid = "name", e.get("triggerEvent")) {
        var b = Yu.makeAxisEventDataBase(e);
        b.targetType = "axisName", b.name = n, _e(E).eventData = b;
      }
      i.add(E), E.updateTransform(), t.add(E), E.decomposeTransform();
    }
  }
};
function _fe(r, e, t, i) {
  var n = fX(t - r), a, o, s = i[0] > i[1], l = e === "start" && !s || e !== "start" && s;
  return mE(n - Ms / 2) ? (o = l ? "bottom" : "top", a = "center") : mE(n - Ms * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", n < Ms * 1.5 && n > Ms / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: n,
    textAlign: a,
    textVerticalAlign: o
  };
}
function Ife(r, e, t) {
  if (!OW(r.axis)) {
    var i = r.get(["axisLabel", "showMinLabel"]), n = r.get(["axisLabel", "showMaxLabel"]);
    e = e || [], t = t || [];
    var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], u = t[0], h = t[1], c = t[t.length - 1], f = t[t.length - 2];
    i === !1 ? (yn(a), yn(u)) : Ck(a, o) && (i ? (yn(o), yn(h)) : (yn(a), yn(u))), n === !1 ? (yn(s), yn(c)) : Ck(l, s) && (n ? (yn(l), yn(f)) : (yn(s), yn(c)));
  }
}
function yn(r) {
  r && (r.ignore = !0);
}
function Ck(r, e) {
  var t = r && r.getBoundingRect().clone(), i = e && e.getBoundingRect().clone();
  if (!(!t || !i)) {
    var n = gS([]);
    return bh(n, n, -r.rotation), t.applyTransform(Mo([], n, r.getLocalTransform())), i.applyTransform(Mo([], n, e.getLocalTransform())), t.intersect(i);
  }
}
function _k(r) {
  return r === "middle" || r === "center";
}
function f3(r, e, t, i, n) {
  for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
    var u = r[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = t, e && (Hr(o, o, e), Hr(s, s, e));
    var h = new Mr({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: i,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    jc(h.shape, h.style.lineWidth), h.anid = n + "_" + r[l].tickValue, a.push(h);
  }
  return a;
}
function xfe(r, e, t, i) {
  var n = t.axis, a = t.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && i.handleAutoShown && (o = i.handleAutoShown("axisTick")), !(!o || n.scale.isBlank())) {
    for (var s = a.getModel("lineStyle"), l = i.tickDirection * a.get("length"), u = n.getTicksCoords(), h = f3(u, e.transform, l, me(s.getLineStyle(), {
      stroke: t.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), c = 0; c < h.length; c++)
      r.add(h[c]);
    return h;
  }
}
function wfe(r, e, t, i) {
  var n = t.axis, a = t.getModel("minorTick");
  if (!(!a.get("show") || n.scale.isBlank())) {
    var o = n.getMinorTicksCoords();
    if (o.length)
      for (var s = a.getModel("lineStyle"), l = i * a.get("length"), u = me(s.getLineStyle(), me(t.getModel("axisTick").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })), h = 0; h < o.length; h++)
        for (var c = f3(o[h], e.transform, l, u, "minorticks_" + h), f = 0; f < c.length; f++)
          r.add(c[f]);
  }
}
function Pfe(r, e, t, i) {
  var n = t.axis, a = Dr(i.axisLabelShow, t.get(["axisLabel", "show"]));
  if (!(!a || n.scale.isBlank())) {
    var o = t.getModel("axisLabel"), s = o.get("margin"), l = n.getViewLabels(), u = (Dr(i.labelRotate, o.get("rotate")) || 0) * Ms / 180, h = Yu.innerTextLayout(i.rotation, u, i.labelDirection), c = t.getCategories && t.getCategories(!0), f = [], d = Yu.isLabelSilent(t), p = t.get("triggerEvent");
    return w(l, function(g, v) {
      var O = n.scale.type === "ordinal" ? n.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, m = g.formattedLabel, E = g.rawLabel, b = o;
      if (c && c[O]) {
        var T = c[O];
        be(T) && T.textStyle && (b = new Dt(T.textStyle, o, t.ecModel));
      }
      var S = b.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), y = n.dataToCoord(O), A = new lt({
        x: y,
        y: i.labelOffset + i.labelDirection * s,
        rotation: h.rotation,
        silent: d,
        z2: 10 + (g.level || 0),
        style: Lt(b, {
          text: m,
          align: b.getShallow("align", !0) || h.textAlign,
          verticalAlign: b.getShallow("verticalAlign", !0) || b.getShallow("baseline", !0) || h.textVerticalAlign,
          fill: ve(S) ? S(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            n.type === "category" ? E : n.type === "value" ? O + "" : O,
            v
          ) : S
        })
      });
      if (A.anid = "label_" + O, p) {
        var C = Yu.makeAxisEventDataBase(t);
        C.targetType = "axisLabel", C.value = E, C.tickIndex = v, n.type === "category" && (C.dataIndex = O), _e(A).eventData = C;
      }
      e.add(A), A.updateTransform(), f.push(A), r.add(A), A.decomposeTransform();
    }), f;
  }
}
const Wo = Yu;
function Nfe(r, e) {
  var t = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return Lfe(t, r, e), t.seriesInvolved && Mfe(t, r), t;
}
function Lfe(r, e, t) {
  var i = e.getComponent("tooltip"), n = e.getComponent("axisPointer"), a = n.get("link", !0) || [], o = [];
  w(t.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = ng(s.model), u = r.coordSysAxesInfo[l] = {};
    r.coordSysMap[l] = s;
    var h = s.model, c = h.getModel("tooltip", i);
    if (w(s.getAxes(), Ie(g, !1, null)), s.getTooltipAxes && i && c.get("show")) {
      var f = c.get("trigger") === "axis", d = c.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(c.get(["axisPointer", "axis"]));
      (f || d) && w(p.baseAxes, Ie(g, d ? "cross" : !0, f)), d && w(p.otherAxes, Ie(g, "cross", !1));
    }
    function g(v, O, m) {
      var E = m.model.getModel("axisPointer", n), b = E.get("show");
      if (!(!b || b === "auto" && !v && !wC(E))) {
        O == null && (O = E.get("triggerTooltip")), E = v ? Dfe(m, c, n, e, v, O) : E;
        var T = E.get("snap"), S = E.get("triggerEmphasis"), y = ng(m.model), A = O || T || m.type === "category", C = r.axesInfo[y] = {
          key: y,
          axis: m,
          coordSys: s,
          axisPointerModel: E,
          triggerTooltip: O,
          triggerEmphasis: S,
          involveSeries: A,
          snap: T,
          useHandle: wC(E),
          seriesModels: [],
          linkGroup: null
        };
        u[y] = C, r.seriesInvolved = r.seriesInvolved || A;
        var _ = kfe(a, m);
        if (_ != null) {
          var I = o[_] || (o[_] = {
            axesInfo: {}
          });
          I.axesInfo[y] = C, I.mapper = a[_].mapper, C.linkGroup = I;
        }
      }
    }
  });
}
function Dfe(r, e, t, i, n, a) {
  var o = e.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  w(s, function(f) {
    l[f] = Se(o.get(f));
  }), l.snap = r.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), n === "cross") {
    var h = o.get(["label", "show"]);
    if (u.show = h ?? !0, !a) {
      var c = l.lineStyle = o.get("crossStyle");
      c && me(u, c.textStyle);
    }
  }
  return r.model.getModel("axisPointer", new Dt(l, t, i));
}
function Mfe(r, e) {
  e.eachSeries(function(t) {
    var i = t.coordinateSystem, n = t.get(["tooltip", "trigger"], !0), a = t.get(["tooltip", "show"], !0);
    !i || n === "none" || n === !1 || n === "item" || a === !1 || t.get(["axisPointer", "show"], !0) === !1 || w(r.coordSysAxesInfo[ng(i.model)], function(o) {
      var s = o.axis;
      i.getAxis(s.dim) === s && (o.seriesModels.push(t), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += t.getData().count());
    });
  });
}
function kfe(r, e) {
  for (var t = e.model, i = e.dim, n = 0; n < r.length; n++) {
    var a = r[n] || {};
    if (s0(a[i + "AxisId"], t.id) || s0(a[i + "AxisIndex"], t.componentIndex) || s0(a[i + "AxisName"], t.name))
      return n;
  }
}
function s0(r, e) {
  return r === "all" || X(r) && Ge(r, e) >= 0 || r === e;
}
function Qfe(r) {
  var e = xx(r);
  if (e) {
    var t = e.axisPointerModel, i = e.axis.scale, n = t.option, a = t.get("status"), o = t.get("value");
    o != null && (o = i.parse(o));
    var s = wC(t);
    a == null && (n.status = s ? "show" : "hide");
    var l = i.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), n.value = o, s && (n.status = e.axis.scale.isBlank() ? "hide" : "show");
  }
}
function xx(r) {
  var e = (r.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return e && e.axesInfo[ng(r)];
}
function Ufe(r) {
  var e = xx(r);
  return e && e.axisPointerModel;
}
function wC(r) {
  return !!r.get(["handle", "show"]);
}
function ng(r) {
  return r.type + "||" + r.id;
}
var Ik = {}, $fe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this.axisPointerClass && Qfe(t), r.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, n, !0);
    }, e.prototype.updateAxisPointer = function(t, i, n, a) {
      this._doUpdateAxisPointerClass(t, n, !1);
    }, e.prototype.remove = function(t, i) {
      var n = this._axisPointer;
      n && n.remove(i);
    }, e.prototype.dispose = function(t, i) {
      this._disposeAxisPointer(i), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(t, i, n) {
      var a = e.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = Ufe(t);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(t, o, i, n) : this._disposeAxisPointer(i);
      }
    }, e.prototype._disposeAxisPointer = function(t) {
      this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(t, i) {
      Ik[t] = i;
    }, e.getAxisPointerClass = function(t) {
      return t && Ik[t];
    }, e.type = "axis", e;
  }(Zt)
);
const Ah = $fe;
var PC = at();
function d3(r, e, t, i) {
  var n = t.axis;
  if (!n.scale.isBlank()) {
    var a = t.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = i.coordinateSystem.getRect(), u = n.getTicksCoords({
      tickModel: a,
      clamp: !0
    });
    if (u.length) {
      var h = s.length, c = PC(r).splitAreaColors, f = ce(), d = 0;
      if (c)
        for (var p = 0; p < u.length; p++) {
          var g = c.get(u[p].tickValue);
          if (g != null) {
            d = (g + (h - 1) * p) % h;
            break;
          }
        }
      var v = n.toGlobalCoord(u[0].coord), O = o.getAreaStyle();
      s = X(s) ? s : [s];
      for (var p = 1; p < u.length; p++) {
        var m = n.toGlobalCoord(u[p].coord), E = void 0, b = void 0, T = void 0, S = void 0;
        n.isHorizontal() ? (E = v, b = l.y, T = m - E, S = l.height, v = E + T) : (E = l.x, b = v, T = l.width, S = m - b, v = b + S);
        var y = u[p - 1].tickValue;
        y != null && f.set(y, d), e.add(new nt({
          anid: y != null ? "area_" + y : null,
          shape: {
            x: E,
            y: b,
            width: T,
            height: S
          },
          style: me({
            fill: s[d]
          }, O),
          autoBatch: !0,
          silent: !0
        })), d = (d + 1) % h;
      }
      PC(r).splitAreaColors = f;
    }
  }
}
function p3(r) {
  PC(r).splitAreaColors = null;
}
var Gfe = ["axisLine", "axisTickLabel", "axisName"], Bfe = ["splitArea", "splitLine", "minorSplitLine"], g3 = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new ye(), this.group.add(this._axisGroup), !!t.get("show")) {
        var s = t.getCoordSysModel(), l = xC(s, t), u = new Wo(t, V({
          handleAutoShown: function(c) {
            for (var f = s.coordinateSystem.getCartesians(), d = 0; d < f.length; d++)
              if (SC(f[d].getOtherAxis(t.axis).scale))
                return !0;
            return !1;
          }
        }, l));
        w(Gfe, u.add, u), this._axisGroup.add(u.getGroup()), w(Bfe, function(c) {
          t.get([c, "show"]) && Vfe[c](this, this._axisGroup, t, s);
        }, this);
        var h = a && a.type === "changeAxisOrder" && a.isInitSort;
        h || Bg(o, this._axisGroup, t), r.prototype.render.call(this, t, i, n, a);
      }
    }, e.prototype.remove = function() {
      p3(this);
    }, e.type = "cartesianAxis", e;
  }(Ah)
), Vfe = {
  splitLine: function(r, e, t, i) {
    var n = t.axis;
    if (!n.scale.isBlank()) {
      var a = t.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
      s = X(s) ? s : [s];
      for (var l = i.coordinateSystem.getRect(), u = n.isHorizontal(), h = 0, c = n.getTicksCoords({
        tickModel: a
      }), f = [], d = [], p = o.getLineStyle(), g = 0; g < c.length; g++) {
        var v = n.toGlobalCoord(c[g].coord);
        u ? (f[0] = v, f[1] = l.y, d[0] = v, d[1] = l.y + l.height) : (f[0] = l.x, f[1] = v, d[0] = l.x + l.width, d[1] = v);
        var O = h++ % s.length, m = c[g].tickValue, E = new Mr({
          anid: m != null ? "line_" + c[g].tickValue : null,
          autoBatch: !0,
          shape: {
            x1: f[0],
            y1: f[1],
            x2: d[0],
            y2: d[1]
          },
          style: me({
            stroke: s[O]
          }, p),
          silent: !0
        });
        jc(E.shape, p.lineWidth), e.add(E);
      }
    }
  },
  minorSplitLine: function(r, e, t, i) {
    var n = t.axis, a = t.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = i.coordinateSystem.getRect(), l = n.isHorizontal(), u = n.getMinorTicksCoords();
    if (u.length)
      for (var h = [], c = [], f = o.getLineStyle(), d = 0; d < u.length; d++)
        for (var p = 0; p < u[d].length; p++) {
          var g = n.toGlobalCoord(u[d][p].coord);
          l ? (h[0] = g, h[1] = s.y, c[0] = g, c[1] = s.y + s.height) : (h[0] = s.x, h[1] = g, c[0] = s.x + s.width, c[1] = g);
          var v = new Mr({
            anid: "minor_line_" + u[d][p].tickValue,
            autoBatch: !0,
            shape: {
              x1: h[0],
              y1: h[1],
              x2: c[0],
              y2: c[1]
            },
            style: f,
            silent: !0
          });
          jc(v.shape, f.lineWidth), e.add(v);
        }
  },
  splitArea: function(r, e, t, i) {
    d3(r, e, t, i);
  }
}, v3 = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "xAxis", e;
  }(g3)
), Ffe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = v3.type, t;
    }
    return e.type = "yAxis", e;
  }(g3)
), Xfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "grid", t;
    }
    return e.prototype.render = function(t, i) {
      this.group.removeAll(), t.get("show") && this.group.add(new nt({
        shape: t.coordinateSystem.getRect(),
        style: me({
          fill: t.get("backgroundColor")
        }, t.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(Zt)
), xk = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function O3(r) {
  r.registerComponentView(Xfe), r.registerComponentModel(pfe), r.registerCoordinateSystem("cartesian2d", Cfe), rf(r, "x", _C, xk), rf(r, "y", _C, xk), r.registerComponentView(v3), r.registerComponentView(Ffe), r.registerPreprocessor(function(e) {
    e.xAxis && e.yAxis && !e.grid && (e.grid = {});
  });
}
function Yfe(r) {
  Ve(O3), r.registerSeriesModel(ofe), r.registerChartView(ffe), r.registerLayout(jg("scatter"));
}
function Hfe(r) {
  r.eachSeriesByType("radar", function(e) {
    var t = e.getData(), i = [], n = e.coordinateSystem;
    if (n) {
      var a = n.getIndicatorAxes();
      w(a, function(o, s) {
        t.each(t.mapDimension(a[s].dim), function(l, u) {
          i[u] = i[u] || [];
          var h = n.dataToPoint(l, s);
          i[u][s] = wk(h) ? h : Pk(n);
        });
      }), t.each(function(o) {
        var s = kte(i[o], function(l) {
          return wk(l);
        }) || Pk(n);
        i[o].push(s.slice()), t.setItemLayout(o, i[o]);
      });
    }
  });
}
function wk(r) {
  return !isNaN(r[0]) && !isNaN(r[1]);
}
function Pk(r) {
  return [r.cx, r.cy];
}
function Wfe(r) {
  var e = r.polar;
  if (e) {
    X(e) || (e = [e]);
    var t = [];
    w(e, function(i, n) {
      i.indicator ? (i.type && !i.shape && (i.shape = i.type), r.radar = r.radar || [], X(r.radar) || (r.radar = [r.radar]), r.radar.push(i)) : t.push(i);
    }), r.polar = t;
  }
  w(r.series, function(i) {
    i && i.type === "radar" && i.polarIndex && (i.radarIndex = i.polarIndex);
  });
}
var zfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.coordinateSystem, o = this.group, s = t.getData(), l = this._data;
      function u(f, d) {
        var p = f.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var g = Nf(f.getItemVisual(d, "symbolSize")), v = ur(p, -1, -1, 2, 2), O = f.getItemVisual(d, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: O * Math.PI / 180 || 0
          }), v;
        }
      }
      function h(f, d, p, g, v, O) {
        p.removeAll();
        for (var m = 0; m < d.length - 1; m++) {
          var E = u(g, v);
          E && (E.__dimIdx = m, f[m] ? (E.setPosition(f[m]), Fg[O ? "initProps" : "updateProps"](E, {
            x: d[m][0],
            y: d[m][1]
          }, t, v)) : E.setPosition(d[m]), p.add(E));
        }
      }
      function c(f) {
        return Y(f, function(d) {
          return [a.cx, a.cy];
        });
      }
      s.diff(l).add(function(f) {
        var d = s.getItemLayout(f);
        if (d) {
          var p = new Yi(), g = new Wi(), v = {
            shape: {
              points: d
            }
          };
          p.shape.points = c(d), g.shape.points = c(d), Ut(p, v, t, f), Ut(g, v, t, f);
          var O = new ye(), m = new ye();
          O.add(g), O.add(p), O.add(m), h(g.shape.points, d, m, s, f, !0), s.setItemGraphicEl(f, O);
        }
      }).update(function(f, d) {
        var p = l.getItemGraphicEl(d), g = p.childAt(0), v = p.childAt(1), O = p.childAt(2), m = {
          shape: {
            points: s.getItemLayout(f)
          }
        };
        m.shape.points && (h(g.shape.points, m.shape.points, O, s, f, !1), ba(v), ba(g), ft(g, m, t), ft(v, m, t), s.setItemGraphicEl(f, p));
      }).remove(function(f) {
        o.remove(l.getItemGraphicEl(f));
      }).execute(), s.eachItemGraphicEl(function(f, d) {
        var p = s.getItemModel(d), g = f.childAt(0), v = f.childAt(1), O = f.childAt(2), m = s.getItemVisual(d, "style"), E = m.fill;
        o.add(f), g.useStyle(me(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: E
        })), zr(g, p, "lineStyle"), zr(v, p, "areaStyle");
        var b = p.getModel("areaStyle"), T = b.isEmpty() && b.parentModel.isEmpty();
        v.ignore = T, w(["emphasis", "select", "blur"], function(A) {
          var C = p.getModel([A, "areaStyle"]), _ = C.isEmpty() && C.parentModel.isEmpty();
          v.ensureState(A).ignore = _ && T;
        }), v.useStyle(me(b.getAreaStyle(), {
          fill: E,
          opacity: 0.7,
          decal: m.decal
        }));
        var S = p.getModel("emphasis"), y = S.getModel("itemStyle").getItemStyle();
        O.eachChild(function(A) {
          if (A instanceof qr) {
            var C = A.style;
            A.useStyle(V({
              // TODO other properties like x, y ?
              image: C.image,
              x: C.x,
              y: C.y,
              width: C.width,
              height: C.height
            }, m));
          } else
            A.useStyle(m), A.setColor(E), A.style.strokeNoScale = !0;
          var _ = A.ensureState("emphasis");
          _.style = Se(y);
          var I = s.getStore().get(s.getDimensionIndex(A.__dimIdx), d);
          (I == null || isNaN(I)) && (I = ""), Zr(A, Cr(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: d,
            labelDimIndex: A.__dimIdx,
            defaultText: I,
            inheritColor: E,
            defaultOpacity: m.opacity
          });
        }), zt(f, S.get("focus"), S.get("blurScope"), S.get("disabled"));
      }), this._data = s;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "radar", e;
  }(Mt)
);
const Zfe = zfe;
var qfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Jg(ae(this.getData, this), ae(this.getRawData, this));
    }, e.prototype.getInitialData = function(t, i) {
      return Lf(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(t), u = l === "" ? this.name : l, h = gH(this, t);
      return _r("section", {
        header: u,
        sortBlocks: !0,
        blocks: Y(s, function(c) {
          var f = a.get(a.mapDimension(c.dim), t);
          return _r("nameValue", {
            markerType: "subItem",
            markerColor: h,
            name: c.name,
            value: f,
            sortParam: f
          });
        })
      });
    }, e.prototype.getTooltipPosition = function(t) {
      if (t != null) {
        for (var i = this.getData(), n = this.coordinateSystem, a = i.getValues(Y(n.dimensions, function(u) {
          return i.mapDimension(u);
        }), t), o = 0, s = a.length; o < s; o++)
          if (!isNaN(a[o])) {
            var l = n.getIndicatorAxes();
            return n.coordToPoint(l[o].dataToCoord(a[o]), o);
          }
      }
    }, e.type = "series.radar", e.dependencies = ["radar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, e;
  }(Xt)
);
const jfe = qfe;
var hd = h3.value;
function OO(r, e) {
  return me({
    show: e
  }, r);
}
var Kfe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      var t = this.get("boundaryGap"), i = this.get("splitNumber"), n = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), h = this.get(["axisName", "formatter"]), c = this.get("axisNameGap"), f = this.get("triggerEvent"), d = Y(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = me({
          color: p.color
        }, l));
        var v = Qe(Se(p), {
          boundaryGap: t,
          splitNumber: i,
          scale: n,
          axisLine: a,
          axisTick: o,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: c,
          // min: 0,
          nameTextStyle: g,
          triggerEvent: f
        }, !1);
        if (ne(h)) {
          var O = v.name;
          v.name = h.replace("{value}", O ?? "");
        } else
          ve(h) && (v.name = h(v.name, v));
        var m = new Dt(v, null, this.ecModel);
        return hr(m, zg.prototype), m.mainType = "radar", m.componentIndex = this.componentIndex, m;
      }, this);
      this._indicatorModels = d;
    }, e.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, e.type = "radar", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: Qe({
        lineStyle: {
          color: "#bbb"
        }
      }, hd.axisLine),
      axisLabel: OO(hd.axisLabel, !1),
      axisTick: OO(hd.axisTick, !1),
      // axisType: 'value',
      splitLine: OO(hd.splitLine, !0),
      splitArea: OO(hd.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, e;
  }(ot)
);
const Jfe = Kfe;
var ede = ["axisLine", "axisTickLabel", "axisName"], tde = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this.group;
      a.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
    }, e.prototype._buildAxes = function(t) {
      var i = t.coordinateSystem, n = i.getIndicatorAxes(), a = Y(n, function(o) {
        var s = o.model.get("showName") ? o.name : "", l = new Wo(o.model, {
          axisName: s,
          position: [i.cx, i.cy],
          rotation: o.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      w(a, function(o) {
        w(ede, o.add, o), this.group.add(o.getGroup());
      }, this);
    }, e.prototype._buildSplitLineAndArea = function(t) {
      var i = t.coordinateSystem, n = i.getIndicatorAxes();
      if (!n.length)
        return;
      var a = t.get("shape"), o = t.getModel("splitLine"), s = t.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), h = o.get("show"), c = s.get("show"), f = l.get("color"), d = u.get("color"), p = X(f) ? f : [f], g = X(d) ? d : [d], v = [], O = [];
      function m(L, D, $) {
        var k = $ % D.length;
        return L[k] = L[k] || [], k;
      }
      if (a === "circle")
        for (var E = n[0].getTicksCoords(), b = i.cx, T = i.cy, S = 0; S < E.length; S++) {
          if (h) {
            var y = m(v, p, S);
            v[y].push(new uo({
              shape: {
                cx: b,
                cy: T,
                r: E[S].coord
              }
            }));
          }
          if (c && S < E.length - 1) {
            var y = m(O, g, S);
            O[y].push(new RS({
              shape: {
                cx: b,
                cy: T,
                r0: E[S].coord,
                r: E[S + 1].coord
              }
            }));
          }
        }
      else
        for (var A, C = Y(n, function(L, D) {
          var $ = L.getTicksCoords();
          return A = A == null ? $.length - 1 : Math.min($.length - 1, A), Y($, function(k) {
            return i.coordToPoint(k.coord, D);
          });
        }), _ = [], S = 0; S <= A; S++) {
          for (var I = [], x = 0; x < n.length; x++)
            I.push(C[x][S]);
          if (I[0] && I.push(I[0].slice()), h) {
            var y = m(v, p, S);
            v[y].push(new Wi({
              shape: {
                points: I
              }
            }));
          }
          if (c && _) {
            var y = m(O, g, S - 1);
            O[y].push(new Yi({
              shape: {
                points: I.concat(_)
              }
            }));
          }
          _ = I.slice().reverse();
        }
      var P = l.getLineStyle(), N = u.getAreaStyle();
      w(O, function(L, D) {
        this.group.add(Dn(L, {
          style: me({
            stroke: "none",
            fill: g[D % g.length]
          }, N),
          silent: !0
        }));
      }, this), w(v, function(L, D) {
        this.group.add(Dn(L, {
          style: me({
            fill: "none",
            stroke: p[D % p.length]
          }, P),
          silent: !0
        }));
      }, this);
    }, e.type = "radar", e;
  }(Zt)
);
const rde = tde;
var ide = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this, t, i, n) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return e;
  }(Ta)
);
const nde = ide;
var ade = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.dimensions = [], this._model = e, this._indicatorAxes = Y(e.getIndicatorModels(), function(n, a) {
        var o = "indicator_" + a, s = new nde(
          o,
          new ll()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = n.get("name"), s.model = n, n.axis = s, this.dimensions.push(o), s;
      }, this), this.resize(e, i);
    }
    return r.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, r.prototype.dataToPoint = function(e, t) {
      var i = this._indicatorAxes[t];
      return this.coordToPoint(i.dataToCoord(e), t);
    }, r.prototype.coordToPoint = function(e, t) {
      var i = this._indicatorAxes[t], n = i.angle, a = this.cx + e * Math.cos(n), o = this.cy - e * Math.sin(n);
      return [a, o];
    }, r.prototype.pointToData = function(e) {
      var t = e[0] - this.cx, i = e[1] - this.cy, n = Math.sqrt(t * t + i * i);
      t /= n, i /= n;
      for (var a = Math.atan2(-i, t), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var h = this._indicatorAxes[u], c = Math.abs(a - h.angle);
        c < o && (s = h, l = u, o = c);
      }
      return [l, +(s && s.coordToData(n))];
    }, r.prototype.resize = function(e, t) {
      var i = e.get("center"), n = t.getWidth(), a = t.getHeight(), o = Math.min(n, a) / 2;
      this.cx = K(i[0], n), this.cy = K(i[1], a), this.startAngle = e.get("startAngle") * Math.PI / 180;
      var s = e.get("radius");
      (ne(s) || ut(s)) && (s = [0, s]), this.r0 = K(s[0], o), this.r = K(s[1], o), w(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var h = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        h = Math.atan2(Math.sin(h), Math.cos(h)), l.angle = h;
      }, this);
    }, r.prototype.update = function(e, t) {
      var i = this._indicatorAxes, n = this._model;
      w(i, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), e.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || e.getComponent("radar", s.get("radarIndex")) !== n)) {
          var u = s.getData();
          w(i, function(h) {
            h.scale.unionExtentFromData(u, u.mapDimension(h.dim));
          });
        }
      }, this);
      var a = n.get("splitNumber"), o = new ll();
      o.setExtent(0, a), o.setInterval(1), w(i, function(s, l) {
        c3(s.scale, s.model, o);
      });
    }, r.prototype.convertToPixel = function(e, t, i) {
      return console.warn("Not implemented."), null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      return console.warn("Not implemented."), null;
    }, r.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, r.create = function(e, t) {
      var i = [];
      return e.eachComponent("radar", function(n) {
        var a = new r(n, e, t);
        i.push(a), n.coordinateSystem = a;
      }), e.eachSeriesByType("radar", function(n) {
        n.get("coordinateSystem") === "radar" && (n.coordinateSystem = i[n.get("radarIndex") || 0]);
      }), i;
    }, r.dimensions = [], r;
  }()
);
const ode = ade;
function sde(r) {
  r.registerCoordinateSystem("radar", ode), r.registerComponentModel(Jfe), r.registerComponentView(rde), r.registerVisual({
    seriesType: "radar",
    reset: function(e) {
      var t = e.getData();
      t.each(function(i) {
        t.setItemVisual(i, "legendIcon", "roundRect");
      }), t.setVisual("legendIcon", "roundRect");
    }
  });
}
function lde(r) {
  Ve(sde), r.registerChartView(Zfe), r.registerSeriesModel(jfe), r.registerLayout(Hfe), r.registerProcessor(Kg("radar")), r.registerPreprocessor(Wfe);
}
var Nk = "\0_ec_interaction_mutex";
function ude(r, e, t) {
  var i = Px(r);
  i[e] = t;
}
function hde(r, e, t) {
  var i = Px(r), n = i[e];
  n === t && (i[e] = null);
}
function Lk(r, e) {
  return !!Px(r)[e];
}
function Px(r) {
  return r[Nk] || (r[Nk] = {});
}
Oo({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, ar);
var cde = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this) || this;
      i._zr = t;
      var n = ae(i._mousedownHandler, i), a = ae(i._mousemoveHandler, i), o = ae(i._mouseupHandler, i), s = ae(i._mousewheelHandler, i), l = ae(i._pinchHandler, i);
      return i.enable = function(u, h) {
        this.disable(), this._opt = me(Se(h) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (t.on("mousedown", n), t.on("mousemove", a), t.on("mouseup", o)), (u === !0 || u === "scale" || u === "zoom") && (t.on("mousewheel", s), t.on("pinch", l));
      }, i.disable = function() {
        t.off("mousedown", n), t.off("mousemove", a), t.off("mouseup", o), t.off("mousewheel", s), t.off("pinch", l);
      }, i;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(t) {
      this.pointerChecker = t;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(t) {
      if (!oL(t)) {
        for (var i = t.target; i; ) {
          if (i.draggable)
            return;
          i = i.__hostTarget || i.parent;
        }
        var n = t.offsetX, a = t.offsetY;
        this.pointerChecker && this.pointerChecker(t, n, a) && (this._x = n, this._y = a, this._dragging = !0);
      }
    }, e.prototype._mousemoveHandler = function(t) {
      if (!(!this._dragging || !Rm("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || Lk(this._zr, "globalPan"))) {
        var i = t.offsetX, n = t.offsetY, a = this._x, o = this._y, s = i - a, l = n - o;
        this._x = i, this._y = n, this._opt.preventDefaultMouseMove && Vo(t.event), m3(this, "pan", "moveOnMouseMove", t, {
          dx: s,
          dy: l,
          oldX: a,
          oldY: o,
          newX: i,
          newY: n,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(t) {
      oL(t) || (this._dragging = !1);
    }, e.prototype._mousewheelHandler = function(t) {
      var i = Rm("zoomOnMouseWheel", t, this._opt), n = Rm("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, o = Math.abs(a), s = t.offsetX, l = t.offsetY;
      if (!(a === 0 || !i && !n)) {
        if (i) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, h = a > 0 ? u : 1 / u;
          l0(this, "zoom", "zoomOnMouseWheel", t, {
            scale: h,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (n) {
          var c = Math.abs(a), f = (a > 0 ? 1 : -1) * (c > 3 ? 0.4 : c > 1 ? 0.15 : 0.05);
          l0(this, "scrollMove", "moveOnMouseWheel", t, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(t) {
      if (!Lk(this._zr, "globalPan")) {
        var i = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
        l0(this, "zoom", null, t, {
          scale: i,
          originX: t.pinchX,
          originY: t.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(jn)
);
function l0(r, e, t, i, n) {
  r.pointerChecker && r.pointerChecker(i, n.originX, n.originY) && (Vo(i.event), m3(r, e, t, i, n));
}
function m3(r, e, t, i, n) {
  n.isAvailableBehavior = ae(Rm, null, t, i), r.trigger(e, n);
}
function Rm(r, e, t) {
  var i = t[r];
  return !r || i && (!ne(i) || e.event[i + "Key"]);
}
const ev = cde;
function Nx(r, e, t) {
  var i = r.target;
  i.x += e, i.y += t, i.dirty();
}
function Lx(r, e, t, i) {
  var n = r.target, a = r.zoomLimit, o = r.zoom = r.zoom || 1;
  if (o *= e, a) {
    var s = a.min || 0, l = a.max || 1 / 0;
    o = Math.max(Math.min(l, o), s);
  }
  var u = o / r.zoom;
  r.zoom = o, n.x -= (t - n.x) * (u - 1), n.y -= (i - n.y) * (u - 1), n.scaleX *= u, n.scaleY *= u, n.dirty();
}
var fde = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function YS(r, e, t) {
  var i = e.getComponentByElement(r.topTarget), n = i && i.coordinateSystem;
  return i && i !== t && !fde.hasOwnProperty(i.mainType) && n && n.model !== t;
}
function E3(r) {
  if (ne(r)) {
    var e = new DOMParser();
    r = e.parseFromString(r, "text/xml");
  }
  var t = r;
  for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1; )
    t = t.nextSibling;
  return t;
}
var u0, VE = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, Dk = He(VE), FE = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, Mk = He(FE), dde = function() {
  function r() {
    this._defs = {}, this._root = null;
  }
  return r.prototype.parse = function(e, t) {
    t = t || {};
    var i = E3(e);
    this._defsUsePending = [];
    var n = new ye();
    this._root = n;
    var a = [], o = i.getAttribute("viewBox") || "", s = parseFloat(i.getAttribute("width") || t.width), l = parseFloat(i.getAttribute("height") || t.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), qi(i, n, null, !0, !1);
    for (var u = i.firstChild; u; )
      this._parseNode(u, n, a, null, !1, !1), u = u.nextSibling;
    vde(this._defs, this._defsUsePending), this._defsUsePending = [];
    var h, c;
    if (o) {
      var f = HS(o);
      f.length >= 4 && (h = {
        x: parseFloat(f[0] || 0),
        y: parseFloat(f[1] || 0),
        width: parseFloat(f[2]),
        height: parseFloat(f[3])
      });
    }
    if (h && s != null && l != null && (c = S3(h, { x: 0, y: 0, width: s, height: l }), !t.ignoreViewBox)) {
      var d = n;
      n = new ye(), n.add(d), d.scaleX = d.scaleY = c.scale, d.x = c.x, d.y = c.y;
    }
    return !t.ignoreRootClip && s != null && l != null && n.setClipPath(new nt({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: n,
      width: s,
      height: l,
      viewBoxRect: h,
      viewBoxTransform: c,
      named: a
    };
  }, r.prototype._parseNode = function(e, t, i, n, a, o) {
    var s = e.nodeName.toLowerCase(), l, u = n;
    if (s === "defs" && (a = !0), s === "text" && (o = !0), s === "defs" || s === "switch")
      l = t;
    else {
      if (!a) {
        var h = u0[s];
        if (h && oe(u0, s)) {
          l = h.call(this, e, t);
          var c = e.getAttribute("name");
          if (c) {
            var f = {
              name: c,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            i.push(f), s === "g" && (u = f);
          } else
            n && i.push({
              name: n.name,
              namedFrom: n,
              svgNodeTagLower: s,
              el: l
            });
          t.add(l);
        }
      }
      var d = kk[s];
      if (d && oe(kk, s)) {
        var p = d.call(this, e), g = e.getAttribute("id");
        g && (this._defs[g] = p);
      }
    }
    if (l && l.isGroup)
      for (var v = e.firstChild; v; )
        v.nodeType === 1 ? this._parseNode(v, l, i, u, a, o) : v.nodeType === 3 && o && this._parseText(v, l), v = v.nextSibling;
  }, r.prototype._parseText = function(e, t) {
    var i = new Xp({
      style: {
        text: e.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    Rn(t, i), qi(e, i, this._defsUsePending, !1, !1), pde(i, t);
    var n = i.style, a = n.fontSize;
    a && a < 9 && (n.fontSize = 9, i.scaleX *= a / 9, i.scaleY *= a / 9);
    var o = (n.fontSize || n.fontFamily) && [
      n.fontStyle,
      n.fontWeight,
      (n.fontSize || 12) + "px",
      n.fontFamily || "sans-serif"
    ].join(" ");
    n.font = o;
    var s = i.getBoundingRect();
    return this._textX += s.width, t.add(i), i;
  }, r.internalField = function() {
    u0 = {
      g: function(e, t) {
        var i = new ye();
        return Rn(t, i), qi(e, i, this._defsUsePending, !1, !1), i;
      },
      rect: function(e, t) {
        var i = new nt();
        return Rn(t, i), qi(e, i, this._defsUsePending, !1, !1), i.setShape({
          x: parseFloat(e.getAttribute("x") || "0"),
          y: parseFloat(e.getAttribute("y") || "0"),
          width: parseFloat(e.getAttribute("width") || "0"),
          height: parseFloat(e.getAttribute("height") || "0")
        }), i.silent = !0, i;
      },
      circle: function(e, t) {
        var i = new uo();
        return Rn(t, i), qi(e, i, this._defsUsePending, !1, !1), i.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          r: parseFloat(e.getAttribute("r") || "0")
        }), i.silent = !0, i;
      },
      line: function(e, t) {
        var i = new Mr();
        return Rn(t, i), qi(e, i, this._defsUsePending, !1, !1), i.setShape({
          x1: parseFloat(e.getAttribute("x1") || "0"),
          y1: parseFloat(e.getAttribute("y1") || "0"),
          x2: parseFloat(e.getAttribute("x2") || "0"),
          y2: parseFloat(e.getAttribute("y2") || "0")
        }), i.silent = !0, i;
      },
      ellipse: function(e, t) {
        var i = new VI();
        return Rn(t, i), qi(e, i, this._defsUsePending, !1, !1), i.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          rx: parseFloat(e.getAttribute("rx") || "0"),
          ry: parseFloat(e.getAttribute("ry") || "0")
        }), i.silent = !0, i;
      },
      polygon: function(e, t) {
        var i = e.getAttribute("points"), n;
        i && (n = $k(i));
        var a = new Yi({
          shape: {
            points: n || []
          },
          silent: !0
        });
        return Rn(t, a), qi(e, a, this._defsUsePending, !1, !1), a;
      },
      polyline: function(e, t) {
        var i = e.getAttribute("points"), n;
        i && (n = $k(i));
        var a = new Wi({
          shape: {
            points: n || []
          },
          silent: !0
        });
        return Rn(t, a), qi(e, a, this._defsUsePending, !1, !1), a;
      },
      image: function(e, t) {
        var i = new qr();
        return Rn(t, i), qi(e, i, this._defsUsePending, !1, !1), i.setStyle({
          image: e.getAttribute("xlink:href") || e.getAttribute("href"),
          x: +e.getAttribute("x"),
          y: +e.getAttribute("y"),
          width: +e.getAttribute("width"),
          height: +e.getAttribute("height")
        }), i.silent = !0, i;
      },
      text: function(e, t) {
        var i = e.getAttribute("x") || "0", n = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0";
        this._textX = parseFloat(i) + parseFloat(a), this._textY = parseFloat(n) + parseFloat(o);
        var s = new ye();
        return Rn(t, s), qi(e, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(e, t) {
        var i = e.getAttribute("x"), n = e.getAttribute("y");
        i != null && (this._textX = parseFloat(i)), n != null && (this._textY = parseFloat(n));
        var a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0", s = new ye();
        return Rn(t, s), qi(e, s, this._defsUsePending, !1, !0), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
      },
      path: function(e, t) {
        var i = e.getAttribute("d") || "", n = jX(i);
        return Rn(t, n), qi(e, n, this._defsUsePending, !1, !1), n.silent = !0, n;
      }
    };
  }(), r;
}(), kk = {
  lineargradient: function(r) {
    var e = parseInt(r.getAttribute("x1") || "0", 10), t = parseInt(r.getAttribute("y1") || "0", 10), i = parseInt(r.getAttribute("x2") || "10", 10), n = parseInt(r.getAttribute("y2") || "0", 10), a = new Gg(e, t, i, n);
    return Qk(r, a), Uk(r, a), a;
  },
  radialgradient: function(r) {
    var e = parseInt(r.getAttribute("cx") || "0", 10), t = parseInt(r.getAttribute("cy") || "0", 10), i = parseInt(r.getAttribute("r") || "0", 10), n = new hY(e, t, i);
    return Qk(r, n), Uk(r, n), n;
  }
};
function Qk(r, e) {
  var t = r.getAttribute("gradientUnits");
  t === "userSpaceOnUse" && (e.global = !0);
}
function Uk(r, e) {
  for (var t = r.firstChild; t; ) {
    if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
      var i = t.getAttribute("offset"), n = void 0;
      i && i.indexOf("%") > 0 ? n = parseInt(i, 10) / 100 : i ? n = parseFloat(i) : n = 0;
      var a = {};
      b3(t, a, a);
      var o = a.stopColor || t.getAttribute("stop-color") || "#000000";
      e.colorStops.push({
        offset: n,
        color: o
      });
    }
    t = t.nextSibling;
  }
}
function Rn(r, e) {
  r && r.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), me(e.__inheritedStyle, r.__inheritedStyle));
}
function $k(r) {
  for (var e = HS(r), t = [], i = 0; i < e.length; i += 2) {
    var n = parseFloat(e[i]), a = parseFloat(e[i + 1]);
    t.push([n, a]);
  }
  return t;
}
function qi(r, e, t, i, n) {
  var a = e, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
  r.nodeType === 1 && (Ede(r, e), b3(r, o, s), i || bde(r, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = Gk(a, "fill", o.fill, t)), o.stroke != null && (a.style.stroke = Gk(a, "stroke", o.stroke, t)), w([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    o[l] != null && (a.style[l] = parseFloat(o[l]));
  }), w([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    o[l] != null && (a.style[l] = o[l]);
  }), n && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = Y(HS(o.lineDash), function(l) {
    return parseFloat(l);
  })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = !0), o.display === "none" && (a.ignore = !0);
}
function pde(r, e) {
  var t = e.__selfStyle;
  if (t) {
    var i = t.textBaseline, n = i;
    !i || i === "auto" || i === "baseline" ? n = "alphabetic" : i === "before-edge" || i === "text-before-edge" ? n = "top" : i === "after-edge" || i === "text-after-edge" ? n = "bottom" : (i === "central" || i === "mathematical") && (n = "middle"), r.style.textBaseline = n;
  }
  var a = e.__inheritedStyle;
  if (a) {
    var o = a.textAlign, s = o;
    o && (o === "middle" && (s = "center"), r.style.textAlign = s);
  }
}
var gde = /^url\(\s*#(.*?)\)/;
function Gk(r, e, t, i) {
  var n = t && t.match(gde);
  if (n) {
    var a = ha(n[1]);
    i.push([r, e, a]);
    return;
  }
  return t === "none" && (t = null), t;
}
function vde(r, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i[0].style[i[1]] = r[i[2]];
  }
}
var Ode = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function HS(r) {
  return r.match(Ode) || [];
}
var mde = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, h0 = Math.PI / 180;
function Ede(r, e) {
  var t = r.getAttribute("transform");
  if (t) {
    t = t.replace(/,/g, " ");
    var i = [], n = null;
    t.replace(mde, function(c, f, d) {
      return i.push(f, d), "";
    });
    for (var a = i.length - 1; a > 0; a -= 2) {
      var o = i[a], s = i[a - 1], l = HS(o);
      switch (n = n || Zn(), s) {
        case "translate":
          ao(n, n, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          CI(n, n, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          bh(n, n, -parseFloat(l[0]) * h0);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * h0);
          Mo(n, [1, 0, u, 1, 0, 0], n);
          break;
        case "skewY":
          var h = Math.tan(parseFloat(l[0]) * h0);
          Mo(n, [1, h, 0, 1, 0, 0], n);
          break;
        case "matrix":
          n[0] = parseFloat(l[0]), n[1] = parseFloat(l[1]), n[2] = parseFloat(l[2]), n[3] = parseFloat(l[3]), n[4] = parseFloat(l[4]), n[5] = parseFloat(l[5]);
          break;
      }
    }
    e.setLocalTransform(n);
  }
}
var Bk = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function b3(r, e, t) {
  var i = r.getAttribute("style");
  if (i) {
    Bk.lastIndex = 0;
    for (var n; (n = Bk.exec(i)) != null; ) {
      var a = n[1], o = oe(VE, a) ? VE[a] : null;
      o && (e[o] = n[2]);
      var s = oe(FE, a) ? FE[a] : null;
      s && (t[s] = n[2]);
    }
  }
}
function bde(r, e, t) {
  for (var i = 0; i < Dk.length; i++) {
    var n = Dk[i], a = r.getAttribute(n);
    a != null && (e[VE[n]] = a);
  }
  for (var i = 0; i < Mk.length; i++) {
    var n = Mk[i], a = r.getAttribute(n);
    a != null && (t[FE[n]] = a);
  }
}
function S3(r, e) {
  var t = e.width / r.width, i = e.height / r.height, n = Math.min(t, i);
  return {
    scale: n,
    x: -(r.x + r.width / 2) * n + (e.x + e.width / 2),
    y: -(r.y + r.height / 2) * n + (e.y + e.height / 2)
  };
}
function Sde(r, e) {
  var t = new dde();
  return t.parse(r, e);
}
var Tde = ce([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), yde = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "geoSVG", this._usedGraphicMap = ce(), this._freedGraphics = [], this._mapName = e, this._parsedXML = E3(t);
    }
    return r.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var t = Ade(e.named), i = t.regions, n = t.regionsMap;
        this._regions = i, this._regionsMap = n;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, r.prototype._buildGraphic = function(e) {
      var t, i;
      try {
        t = e && Sde(e, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, i = t.root, _i(i != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var n = new ye();
      n.add(i), n.isGeoSVGGraphicRoot = !0;
      var a = t.width, o = t.height, s = t.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, h = void 0, c = void 0, f = void 0;
        if (a != null ? (u = 0, c = a) : s && (u = s.x, c = s.width), o != null ? (h = 0, f = o) : s && (h = s.y, f = s.height), u == null || h == null) {
          var d = i.getBoundingRect();
          u == null && (u = d.x, c = d.width), h == null && (h = d.y, f = d.height);
        }
        l = this._boundingRect = new Ue(u, h, c, f);
      }
      if (s) {
        var p = S3(s, l);
        i.scaleX = i.scaleY = p.scale, i.x = p.x, i.y = p.y;
      }
      n.setClipPath(new nt({
        shape: l.plain()
      }));
      var g = [];
      return w(t.named, function(v) {
        Tde.get(v.svgNodeTagLower) != null && (g.push(v), Rde(v.el));
      }), {
        root: n,
        boundingRect: l,
        named: g
      };
    }, r.prototype.useGraphic = function(e) {
      var t = this._usedGraphicMap, i = t.get(e);
      return i || (i = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, i), i);
    }, r.prototype.freeGraphic = function(e) {
      var t = this._usedGraphicMap, i = t.get(e);
      i && (t.removeKey(e), this._freedGraphics.push(i));
    }, r;
  }()
);
function Rde(r) {
  r.silent = !1, r.isGroup && r.traverse(function(e) {
    e.silent = !1;
  });
}
function Ade(r) {
  var e = [], t = ce();
  return w(r, function(i) {
    if (i.namedFrom == null) {
      var n = new Xue(i.name, i.el);
      e.push(n), t.set(i.name, n);
    }
  }), {
    regions: e,
    regionsMap: t
  };
}
var NC = [126, 25], Vk = "", nu = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var Jl = 0; Jl < nu.length; Jl++)
  for (var Wh = 0; Wh < nu[Jl].length; Wh++)
    nu[Jl][Wh][0] /= 10.5, nu[Jl][Wh][1] /= -10.5 / 0.75, nu[Jl][Wh][0] += NC[0], nu[Jl][Wh][1] += NC[1];
function Cde(r, e) {
  if (r === "china") {
    for (var t = 0; t < e.length; t++)
      if (e[t].name === Vk)
        return;
    e.push(new EW(Vk, Y(nu, function(i) {
      return {
        type: "polygon",
        exterior: i
      };
    }), NC));
  }
}
var _de = {
  : [32, 80],
  // 
  : [0, -10],
  : [10, 5],
  : [-10, 10],
  // '': [-10, 0],
  : [5, 5]
};
function Ide(r, e) {
  if (r === "china") {
    var t = _de[e.name];
    if (t) {
      var i = e.getCenter();
      i[0] += t[0] / 10.5, i[1] += -t[1] / (10.5 / 0.75), e.setCenter(i);
    }
  }
}
var xde = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function wde(r, e) {
  r === "china" && e.name === "" && e.geometries.push({
    type: "polygon",
    exterior: xde[0]
  });
}
var Pde = "name", Nde = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "geoJSON", this._parsedMap = ce(), this._mapName = e, this._specialAreas = i, this._geoJSON = Dde(t);
    }
    return r.prototype.load = function(e, t) {
      t = t || Pde;
      var i = this._parsedMap.get(t);
      if (!i) {
        var n = this._parseToRegions(t);
        i = this._parsedMap.set(t, {
          regions: n,
          boundingRect: Lde(n)
        });
      }
      var a = ce(), o = [];
      return w(i.regions, function(s) {
        var l = s.name;
        e && oe(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: i.boundingRect || new Ue(0, 0, 0, 0),
        regionsMap: a
      };
    }, r.prototype._parseToRegions = function(e) {
      var t = this._mapName, i = this._geoJSON, n;
      try {
        n = i ? Hue(i, e) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return Cde(t, n), w(n, function(a) {
        var o = a.name;
        Ide(t, a), wde(t, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), n;
    }, r.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, r;
  }()
);
function Lde(r) {
  for (var e, t = 0; t < r.length; t++) {
    var i = r[t].getBoundingRect();
    e = e || i.clone(), e.union(i);
  }
  return e;
}
function Dde(r) {
  return ne(r) ? typeof JSON < "u" && JSON.parse ? JSON.parse(r) : new Function("return (" + r + ");")() : r;
}
var cd = ce();
const zo = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(r, e, t) {
    if (e.svg) {
      var i = new yde(r, e.svg);
      cd.set(r, i);
    } else {
      var n = e.geoJson || e.geoJSON;
      n && !e.features ? t = e.specialAreas : n = e;
      var i = new Nde(r, n, t);
      cd.set(r, i);
    }
  },
  getGeoResource: function(r) {
    return cd.get(r);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(r) {
    var e = cd.get(r);
    return e && e.type === "geoJSON" && e.getMapForUser();
  },
  load: function(r, e, t) {
    var i = cd.get(r);
    if (i)
      return i.load(e, t);
  }
};
var Dx = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], Mde = ce(Dx), kde = ce(Dx.concat(["g"])), Qde = ce(Dx.concat(["g"])), T3 = at();
function mO(r) {
  var e = r.getItemStyle(), t = r.get("areaColor");
  return t != null && (e.fill = t), e;
}
function Fk(r) {
  var e = r.style;
  e && (e.stroke = e.stroke || e.fill, e.fill = null);
}
var Ude = (
  /** @class */
  function() {
    function r(e) {
      var t = new ye();
      this.uid = Af("ec_map_draw"), this._controller = new ev(e.getZr()), this._controllerHost = {
        target: t
      }, this.group = t, t.add(this._regionsGroup = new ye()), t.add(this._svgGroup = new ye());
    }
    return r.prototype.draw = function(e, t, i, n, a) {
      var o = e.mainType === "geo", s = e.getData && e.getData();
      o && t.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(O) {
        !s && O.getHostGeoModel() === e && (s = O.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, h = this.group, c = l.getTransformInfo(), f = c.raw, d = c.roam, p = !u.childAt(0) || a;
      p ? (h.x = d.x, h.y = d.y, h.scaleX = d.scaleX, h.scaleY = d.scaleY, h.dirty()) : ft(h, d, e);
      var g = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, v = {
        api: i,
        geo: l,
        mapOrGeoModel: e,
        data: s,
        isVisualEncodedByVisualMap: g,
        isGeo: o,
        transformInfoRaw: f
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(v) : l.resourceType === "geoSVG" && this._buildSVG(v), this._updateController(e, t, i), this._updateMapSelectHandler(e, u, i, n);
    }, r.prototype._buildGeoJSON = function(e) {
      var t = this._regionsGroupByName = ce(), i = ce(), n = this._regionsGroup, a = e.transformInfoRaw, o = e.mapOrGeoModel, s = e.data, l = e.geo.projection, u = l && l.stream;
      function h(d, p) {
        return p && (d = p(d)), d && [d[0] * a.scaleX + a.x, d[1] * a.scaleY + a.y];
      }
      function c(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var O = h(d[v], g);
          O && p.push(O);
        }
        return p;
      }
      function f(d) {
        return {
          shape: {
            points: c(d)
          }
        };
      }
      n.removeAll(), w(e.geo.regions, function(d) {
        var p = d.name, g = t.get(p), v = i.get(p) || {}, O = v.dataIdx, m = v.regionModel;
        g || (g = t.set(p, new ye()), n.add(g), O = s ? s.indexOfName(p) : null, m = e.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(O) : null, i.set(p, {
          dataIdx: O,
          regionModel: m
        }));
        var E = [], b = [];
        w(d.geometries, function(y) {
          if (y.type === "polygon") {
            var A = [y.exterior].concat(y.interiors || []);
            u && (A = Zk(A, u)), w(A, function(_) {
              E.push(new Yi(f(_)));
            });
          } else {
            var C = y.points;
            u && (C = Zk(C, u, !0)), w(C, function(_) {
              b.push(new Wi(f(_)));
            });
          }
        });
        var T = h(d.getCenter(), l && l.project);
        function S(y, A) {
          if (y.length) {
            var C = new XI({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: y
              }
            });
            g.add(C), Xk(e, C, O, m), Yk(e, C, p, m, o, O, T), A && (Fk(C), w(C.states, Fk));
          }
        }
        S(E), S(b, !0);
      }), t.each(function(d, p) {
        var g = i.get(p), v = g.dataIdx, O = g.regionModel;
        Hk(e, d, p, O, o, v), Wk(e, d, p, O, o), zk(e, d, p, O, o);
      }, this);
    }, r.prototype._buildSVG = function(e) {
      var t = e.geo.map, i = e.transformInfoRaw;
      this._svgGroup.x = i.x, this._svgGroup.y = i.y, this._svgGroup.scaleX = i.scaleX, this._svgGroup.scaleY = i.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
      var n = this._svgDispatcherMap = ce(), a = !1;
      w(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = e.mapOrGeoModel, u = e.data, h = o.svgNodeTagLower, c = o.el, f = u ? u.indexOfName(s) : null, d = l.getRegionModel(s);
        if (Mde.get(h) != null && c instanceof qn && Xk(e, c, f, d), c instanceof qn && (c.culling = !0), c.z2EmphasisLift = 0, !o.namedFrom && (Qde.get(h) != null && Yk(e, c, s, d, l, f, null), Hk(e, c, s, d, l, f), Wk(e, c, s, d, l), kde.get(h) != null)) {
          var p = zk(e, c, s, d, l);
          p === "self" && (a = !0);
          var g = n.get(s) || n.set(s, []);
          g.push(c);
        }
      }, this), this._enableBlurEntireSVG(a, e);
    }, r.prototype._enableBlurEntireSVG = function(e, t) {
      if (e && t.isGeo) {
        var i = t.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), n = i.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            ih(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && n != null && (o.opacity = n), a.ensureState("emphasis");
          }
        });
      }
    }, r.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, r.prototype.findHighDownDispatchers = function(e, t) {
      if (e == null)
        return [];
      var i = t.coordinateSystem;
      if (i.resourceType === "geoJSON") {
        var n = this._regionsGroupByName;
        if (n) {
          var a = n.get(e);
          return a ? [a] : [];
        }
      } else if (i.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, r.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, r.prototype._useSVG = function(e) {
      var t = zo.getGeoResource(e);
      if (t && t.type === "geoSVG") {
        var i = t.useGraphic(this.uid);
        this._svgGroup.add(i.root), this._svgGraphicRecord = i, this._svgMapName = e;
      }
    }, r.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var t = zo.getGeoResource(e);
        t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, r.prototype._updateController = function(e, t, i) {
      var n = e.coordinateSystem, a = this._controller, o = this._controllerHost;
      o.zoomLimit = e.get("scaleLimit"), o.zoom = n.getZoom(), a.enable(e.get("roam") || !1);
      var s = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = e.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = !1, Nx(o, u.dx, u.dy), i.dispatchAction(V(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = !1, Lx(o, u.scale, u.originX, u.originY), i.dispatchAction(V(l(), {
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, h, c) {
        return n.containPoint([h, c]) && !YS(u, i, e);
      });
    }, r.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var t = e.getTextContent();
        t && (t.ignore = T3(t).ignore);
      });
    }, r.prototype._updateMapSelectHandler = function(e, t, i, n) {
      var a = this;
      t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function() {
        a._mouseDownFlag = !0;
      }), t.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = !1);
      }));
    }, r;
  }()
);
function Xk(r, e, t, i) {
  var n = i.getModel("itemStyle"), a = i.getModel(["emphasis", "itemStyle"]), o = i.getModel(["blur", "itemStyle"]), s = i.getModel(["select", "itemStyle"]), l = mO(n), u = mO(a), h = mO(s), c = mO(o), f = r.data;
  if (f) {
    var d = f.getItemVisual(t, "style"), p = f.getItemVisual(t, "decal");
    r.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = Jc(p, r.api));
  }
  e.setStyle(l), e.style.strokeNoScale = !0, e.ensureState("emphasis").style = u, e.ensureState("select").style = h, e.ensureState("blur").style = c, ih(e);
}
function Yk(r, e, t, i, n, a, o) {
  var s = r.data, l = r.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), h = s && s.getItemLayout(a);
  if (l || u || h && h.showLabel) {
    var c = l ? t : a, f = void 0;
    (!s || a >= 0) && (f = n);
    var d = o ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    Zr(e, Cr(i), {
      labelFetcher: f,
      labelDataIndex: c,
      defaultText: t
    }, d);
    var p = e.getTextContent();
    if (p && (T3(p).ignore = p.ignore, e.textConfig && o)) {
      var g = e.getBoundingRect().clone();
      e.textConfig.layoutRect = g, e.textConfig.position = [(o[0] - g.x) / g.width * 100 + "%", (o[1] - g.y) / g.height * 100 + "%"];
    }
    e.disableLabelAnimation = !0;
  } else
    e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
}
function Hk(r, e, t, i, n, a) {
  r.data ? r.data.setItemGraphicEl(a, e) : _e(e).eventData = {
    componentType: "geo",
    componentIndex: n.componentIndex,
    geoIndex: n.componentIndex,
    name: t,
    region: i && i.option || {}
  };
}
function Wk(r, e, t, i, n) {
  r.data || yf({
    el: e,
    componentModel: n,
    itemName: t,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: i.get("tooltip")
  });
}
function zk(r, e, t, i, n) {
  e.highDownSilentOnTouch = !!n.get("selectedMode");
  var a = i.getModel("emphasis"), o = a.get("focus");
  return zt(e, o, a.get("blurScope"), a.get("disabled")), r.isGeo && Fne(e, n, t), o;
}
function Zk(r, e, t) {
  var i = [], n;
  function a() {
    n = [];
  }
  function o() {
    n.length && (i.push(n), n = []);
  }
  var s = e({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && n.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !t && s.polygonStart(), w(r, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !t && s.polygonEnd(), i;
}
const y3 = Ude;
var $de = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !t.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (t.needsDrawMap) {
            var s = this._mapDraw || new y3(n);
            o.add(s.group), s.draw(t, i, n, this, a), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          t.get("showLegendSymbol") && i.getComponent("legend") && this._renderSymbols(t, i, n);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(t, i, n) {
      var a = t.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var h = u.point, c = u.offset, f = new uo({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: t.getData().getVisual("style").fill
              },
              shape: {
                cx: h[0] + c * 9,
                cy: h[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (c ? 0 : Sf + 1)
            });
            if (!c) {
              var d = t.mainSeries.getData(), p = a.getName(l), g = d.indexOfName(p), v = a.getItemModel(l), O = v.getModel("label"), m = d.getItemGraphicEl(g);
              Zr(f, Cr(v), {
                labelFetcher: {
                  getFormattedLabel: function(E, b) {
                    return t.getFormattedLabel(g, b);
                  }
                },
                defaultText: p
              }), f.disableLabelAnimation = !0, O.get("position") || f.setTextConfig({
                position: "bottom"
              }), m.onHoverStateChange = function(E) {
                bE(f, E);
              };
            }
            o.add(f);
          }
        }
      });
    }, e.type = "map", e;
  }(Mt)
);
const Gde = $de;
var Bde = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.needsDrawMap = !1, t.seriesGroup = [], t.getTooltipPosition = function(i) {
        if (i != null) {
          var n = this.getData().getName(i), a = this.coordinateSystem, o = a.getRegion(n);
          return o && a.dataToPoint(o.getCenter());
        }
      }, t;
    }
    return e.prototype.getInitialData = function(t) {
      for (var i = Lf(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Ie(JI, this)
      }), n = ce(), a = [], o = 0, s = i.count(); o < s; o++) {
        var l = i.getName(o);
        n.set(l, !0);
      }
      var u = zo.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return w(u.regions, function(h) {
        var c = h.name;
        n.get(c) || a.push(c);
      }), i.appendValues([], a), i;
    }, e.prototype.getHostGeoModel = function() {
      var t = this.option.geoIndex;
      return t != null ? this.ecModel.getComponent("geo", t) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(t) {
      var i = this.getData();
      return i.get(i.mapDimension("value"), t);
    }, e.prototype.getRegionModel = function(t) {
      var i = this.getData();
      return i.getItemModel(i.indexOfName(t));
    }, e.prototype.formatTooltip = function(t, i, n) {
      for (var a = this.getData(), o = this.getRawValue(t), s = a.getName(t), l = this.seriesGroup, u = [], h = 0; h < l.length; h++) {
        var c = l[h].originalData.indexOfName(s), f = a.mapDimension("value");
        isNaN(l[h].originalData.get(f, c)) || u.push(l[h].name);
      }
      return _r("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [_r("nameValue", {
          name: s,
          value: o
        })]
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.getLegendIcon = function(t) {
      var i = t.icon || "roundRect", n = ur(i, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
      return n.setStyle(t.itemStyle), n.style.stroke = "none", i.indexOf("empty") > -1 && (n.style.stroke = n.style.fill, n.style.fill = "#fff", n.style.lineWidth = 2), n;
    }, e.type = "series.map", e.dependencies = ["geo"], e.layoutMode = "box", e.defaultOption = {
      // 
      // zlevel: 0,
      // 
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(Xt)
);
const Vde = Bde;
function Fde(r, e) {
  var t = {};
  return w(r, function(i) {
    i.each(i.mapDimension("value"), function(n, a) {
      var o = "ec-" + i.getName(a);
      t[o] = t[o] || [], isNaN(n) || t[o].push(n);
    });
  }), r[0].map(r[0].mapDimension("value"), function(i, n) {
    for (var a = "ec-" + r[0].getName(n), o = 0, s = 1 / 0, l = -1 / 0, u = t[a].length, h = 0; h < u; h++)
      s = Math.min(s, t[a][h]), l = Math.max(l, t[a][h]), o += t[a][h];
    var c;
    return e === "min" ? c = s : e === "max" ? c = l : e === "average" ? c = o / u : c = o, u === 0 ? NaN : c;
  });
}
function Xde(r) {
  var e = {};
  r.eachSeriesByType("map", function(t) {
    var i = t.getHostGeoModel(), n = i ? "o" + i.id : "i" + t.getMapType();
    (e[n] = e[n] || []).push(t);
  }), w(e, function(t, i) {
    for (var n = Fde(Y(t, function(o) {
      return o.getData();
    }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++)
      t[a].originalData = t[a].getData();
    for (var a = 0; a < t.length; a++)
      t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(n.cloneShallow()), t[a].mainSeries = t[0];
  });
}
function Yde(r) {
  var e = {};
  r.eachSeriesByType("map", function(t) {
    var i = t.getMapType();
    if (!(t.getHostGeoModel() || e[i])) {
      var n = {};
      w(t.seriesGroup, function(o) {
        var s = o.coordinateSystem, l = o.originalData;
        o.get("showLegendSymbol") && r.getComponent("legend") && l.each(l.mapDimension("value"), function(u, h) {
          var c = l.getName(h), f = s.getRegion(c);
          if (!(!f || isNaN(u))) {
            var d = n[c] || 0, p = s.dataToPoint(f.getCenter());
            n[c] = d + 1, l.setItemLayout(h, {
              point: p,
              offset: d
            });
          }
        });
      });
      var a = t.getData();
      a.each(function(o) {
        var s = a.getName(o), l = a.getItemLayout(o) || {};
        l.showLabel = !n[s], a.setItemLayout(o, l);
      }), e[i] = !0;
    }
  });
}
var qk = Hr, Hde = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this) || this;
      return i.type = "view", i.dimensions = ["x", "y"], i._roamTransformable = new wo(), i._rawTransformable = new wo(), i.name = t, i;
    }
    return e.prototype.setBoundingRect = function(t, i, n, a) {
      return this._rect = new Ue(t, i, n, a), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(t, i, n, a) {
      this._transformTo(t, i, n, a), this._viewRect = new Ue(t, i, n, a);
    }, e.prototype._transformTo = function(t, i, n, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new Ue(t, i, n, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(t, i) {
      t && (this._center = [K(t[0], i.getWidth()), K(t[1], i.getHeight())], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(t) {
      t = t || 1;
      var i = this.zoomLimit;
      i && (i.max != null && (t = Math.min(i.max, t)), i.min != null && (t = Math.max(i.min, t))), this._zoom = t, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var t = this.getBoundingRect(), i = t.x + t.width / 2, n = t.y + t.height / 2;
      return [i, n];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var t = this._rawTransformable.getLocalTransform(), i = this._roamTransformable, n = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
      a = Hr([], a, t), n = Hr([], n, t), i.originX = a[0], i.originY = a[1], i.x = n[0] - a[0], i.y = n[1] - a[1], i.scaleX = i.scaleY = o, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var t = this._roamTransformable, i = this._rawTransformable;
      i.parent = t, t.updateTransform(), i.updateTransform(), AI(this.transform || (this.transform = []), i.transform || Zn()), this._rawTransform = i.getLocalTransform(), this.invTransform = this.invTransform || [], Ef(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var t = this._rawTransformable, i = this._roamTransformable, n = new wo();
      return n.transform = i.transform, n.decomposeTransform(), {
        roam: {
          x: n.x,
          y: n.y,
          scaleX: n.scaleX,
          scaleY: n.scaleY
        },
        raw: {
          x: t.x,
          y: t.y,
          scaleX: t.scaleX,
          scaleY: t.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var t = this.getBoundingRect().clone();
      return t.applyTransform(this.transform), t;
    }, e.prototype.dataToPoint = function(t, i, n) {
      var a = i ? this._rawTransform : this.transform;
      return n = n || [], a ? qk(n, t, a) : Oi(n, t);
    }, e.prototype.pointToData = function(t) {
      var i = this.invTransform;
      return i ? qk([], t, i) : [t[0], t[1]];
    }, e.prototype.convertToPixel = function(t, i, n) {
      var a = jk(i);
      return a === this ? a.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, i, n) {
      var a = jk(i);
      return a === this ? a.pointToData(n) : null;
    }, e.prototype.containPoint = function(t) {
      return this.getViewRectAfterRoam().contain(t[0], t[1]);
    }, e.dimensions = ["x", "y"], e;
  }(wo)
);
function jk(r) {
  var e = r.seriesModel;
  return e ? e.coordinateSystem : null;
}
const tv = Hde;
var Wde = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, R3 = ["lng", "lat"], A3 = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this, t) || this;
      a.dimensions = R3, a.type = "geo", a._nameCoordMap = ce(), a.map = i;
      var o = n.projection, s = zo.load(i, n.nameMap, n.nameProperty), l = zo.getGeoResource(i);
      a.resourceType = l ? l.type : null;
      var u = a.regions = s.regions, h = Wde[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions, a.projection = o;
      var c;
      if (o)
        for (var f = 0; f < u.length; f++) {
          var d = u[f].getBoundingRect(o);
          c = c || d.clone(), c.union(d);
        }
      else
        c = s.boundingRect;
      return a.setBoundingRect(c.x, c.y, c.width, c.height), a.aspectScale = o ? 1 : ke(n.aspectScale, h.aspectScale), a._invertLongitute = o ? !1 : h.invertLongitute, a;
    }
    return e.prototype._transformTo = function(t, i, n, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new Ue(t, i, n, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(t) {
      return this._regionsMap.get(t);
    }, e.prototype.getRegionByCoord = function(t) {
      for (var i = this.regions, n = 0; n < i.length; n++) {
        var a = i[n];
        if (a.type === "geoJSON" && a.contain(t))
          return i[n];
      }
    }, e.prototype.addGeoCoord = function(t, i) {
      this._nameCoordMap.set(t, i);
    }, e.prototype.getGeoCoord = function(t) {
      var i = this._regionsMap.get(t);
      return this._nameCoordMap.get(t) || i && i.getCenter();
    }, e.prototype.dataToPoint = function(t, i, n) {
      if (ne(t) && (t = this.getGeoCoord(t)), t) {
        var a = this.projection;
        return a && (t = a.project(t)), t && this.projectedToPoint(t, i, n);
      }
    }, e.prototype.pointToData = function(t) {
      var i = this.projection;
      return i && (t = i.unproject(t)), t && this.pointToProjected(t);
    }, e.prototype.pointToProjected = function(t) {
      return r.prototype.pointToData.call(this, t);
    }, e.prototype.projectedToPoint = function(t, i, n) {
      return r.prototype.dataToPoint.call(this, t, i, n);
    }, e.prototype.convertToPixel = function(t, i, n) {
      var a = Kk(i);
      return a === this ? a.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, i, n) {
      var a = Kk(i);
      return a === this ? a.pointToData(n) : null;
    }, e;
  }(tv)
);
hr(A3, tv);
function Kk(r) {
  var e = r.geoModel, t = r.seriesModel;
  return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", lr).models[0] || {}).coordinateSystem : null;
}
const Jk = A3;
function e2(r, e) {
  var t = r.get("boundingCoords");
  if (t != null) {
    var i = t[0], n = t[1];
    if (isFinite(i[0]) && isFinite(i[1]) && isFinite(n[0]) && isFinite(n[1])) {
      var a = this.projection;
      if (a) {
        var o = i[0], s = i[1], l = n[0], u = n[1];
        i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0];
        var h = function(S, y, A, C) {
          for (var _ = A - S, I = C - y, x = 0; x <= 100; x++) {
            var P = x / 100, N = a.project([S + _ * P, y + I * P]);
            ws(i, i, N), Ps(n, n, N);
          }
        };
        h(o, s, l, s), h(l, s, l, u), h(l, u, o, u), h(o, u, l, s);
      }
      this.setBoundingRect(i[0], i[1], n[0] - i[0], n[1] - i[1]);
    }
  }
  var c = this.getBoundingRect(), f = r.get("layoutCenter"), d = r.get("layoutSize"), p = e.getWidth(), g = e.getHeight(), v = c.width / c.height * this.aspectScale, O = !1, m, E;
  f && d && (m = [K(f[0], p), K(f[1], g)], E = K(d, Math.min(p, g)), !isNaN(m[0]) && !isNaN(m[1]) && !isNaN(E) && (O = !0));
  var b;
  if (O)
    b = {}, v > 1 ? (b.width = E, b.height = E / v) : (b.height = E, b.width = E * v), b.y = m[1] - b.height / 2, b.x = m[0] - b.width / 2;
  else {
    var T = r.getBoxLayoutParams();
    T.aspect = v, b = mr(T, {
      width: p,
      height: g
    });
  }
  this.setViewRect(b.x, b.y, b.width, b.height), this.setCenter(r.get("center"), e), this.setZoom(r.get("zoom"));
}
function zde(r, e) {
  w(e.get("geoCoord"), function(t, i) {
    r.addGeoCoord(i, t);
  });
}
var Zde = (
  /** @class */
  function() {
    function r() {
      this.dimensions = R3;
    }
    return r.prototype.create = function(e, t) {
      var i = [];
      function n(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      e.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new Jk(l + s, l, V({
          nameMap: o.get("nameMap")
        }, n(o)));
        u.zoomLimit = o.get("scaleLimit"), i.push(u), o.coordinateSystem = u, u.model = o, u.resize = e2, u.resize(o, t);
      }), e.eachSeries(function(o) {
        var s = o.get("coordinateSystem");
        if (s === "geo") {
          var l = o.get("geoIndex") || 0;
          o.coordinateSystem = i[l];
        }
      });
      var a = {};
      return e.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), w(a, function(o, s) {
        var l = Y(o, function(h) {
          return h.get("nameMap");
        }), u = new Jk(s, s, V({
          nameMap: SI(l)
        }, n(o[0])));
        u.zoomLimit = Dr.apply(null, Y(o, function(h) {
          return h.get("scaleLimit");
        })), i.push(u), u.resize = e2, u.resize(o[0], t), w(o, function(h) {
          h.coordinateSystem = u, zde(u, h);
        });
      }), i;
    }, r.prototype.getFilledRegions = function(e, t, i, n) {
      for (var a = (e || []).slice(), o = ce(), s = 0; s < a.length; s++)
        o.set(a[s].name, a[s]);
      var l = zo.load(t, i, n);
      return w(l.regions, function(u) {
        var h = u.name;
        !o.get(h) && a.push({
          name: h
        });
      }), a;
    }, r;
  }()
), qde = new Zde();
const C3 = qde;
var jde = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i, n) {
      var a = zo.getGeoResource(t.map);
      if (a && a.type === "geoJSON") {
        var o = t.itemStyle = t.itemStyle || {};
        "color" in o || (o.color = "#eee");
      }
      this.mergeDefaultAndTheme(t, n), eh(t, "label", ["show"]);
    }, e.prototype.optionUpdated = function() {
      var t = this, i = this.option;
      i.regions = C3.getFilledRegions(i.regions, i.map, i.nameMap, i.nameProperty);
      var n = {};
      this._optionModelMap = no(i.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new Dt(o, t, t.ecModel)), o.selected && (n[s] = !0)), a;
      }, ce()), i.selectedMap || (i.selectedMap = n);
    }, e.prototype.getRegionModel = function(t) {
      return this._optionModelMap.get(t) || new Dt(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(t, i) {
      var n = this.getRegionModel(t), a = i === "normal" ? n.get(["label", "formatter"]) : n.get(["emphasis", "label", "formatter"]), o = {
        name: t
      };
      if (ve(a))
        return o.status = i, a(o);
      if (ne(a))
        return a.replace("{a}", t ?? "");
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.select = function(t) {
      var i = this.option, n = i.selectedMode;
      if (n) {
        n !== "multiple" && (i.selectedMap = null);
        var a = i.selectedMap || (i.selectedMap = {});
        a[t] = !0;
      }
    }, e.prototype.unSelect = function(t) {
      var i = this.option.selectedMap;
      i && (i[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      this[this.isSelected(t) ? "unSelect" : "select"](t);
    }, e.prototype.isSelected = function(t) {
      var i = this.option.selectedMap;
      return !!(i && i[t]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, e;
  }(ot)
);
const Kde = jde;
function t2(r, e) {
  return r.pointToProjected ? r.pointToProjected(e) : r.pointToData(e);
}
function Mx(r, e, t, i) {
  var n = r.getZoom(), a = r.getCenter(), o = e.zoom, s = r.projectedToPoint ? r.projectedToPoint(a) : r.dataToPoint(a);
  if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, r.setCenter(t2(r, s), i)), o != null) {
    if (t) {
      var l = t.min || 0, u = t.max || 1 / 0;
      o = Math.max(Math.min(n * o, u), l) / n;
    }
    r.scaleX *= o, r.scaleY *= o;
    var h = (e.originX - r.x) * (o - 1), c = (e.originY - r.y) * (o - 1);
    r.x -= h, r.y -= c, r.updateTransform(), r.setCenter(t2(r, s), i), r.setZoom(o * n);
  }
  return {
    center: r.getCenter(),
    zoom: r.getZoom()
  };
}
var Jde = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.focusBlurEnabled = !0, t;
    }
    return e.prototype.init = function(t, i) {
      this._api = i;
    }, e.prototype.render = function(t, i, n, a) {
      if (this._model = t, !t.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new y3(n));
      var o = this._mapDraw;
      o.draw(t, i, n, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, i, n);
    }, e.prototype._handleRegionClick = function(t) {
      var i;
      Ru(t.target, function(n) {
        return (i = _e(n).eventData) != null;
      }, !0), i && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: i.name
      });
    }, e.prototype.updateSelectStatus = function(t, i, n) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = _e(o).eventData;
        if (s)
          return a._model.isSelected(s.name) ? n.enterSelect(o) : n.leaveSelect(o), !0;
      });
    }, e.prototype.findHighDownDispatchers = function(t) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(Zt)
);
const epe = Jde;
function tpe(r, e, t) {
  zo.registerMap(r, e, t);
}
function _3(r) {
  r.registerCoordinateSystem("geo", C3), r.registerComponentModel(Kde), r.registerComponentView(epe), r.registerImpl("registerMap", tpe), r.registerImpl("getMap", function(t) {
    return zo.getMapForUser(t);
  });
  function e(t, i) {
    i.update = "geo:updateSelectStatus", r.registerAction(i, function(n, a) {
      var o = {}, s = [];
      return a.eachComponent({
        mainType: "geo",
        query: n
      }, function(l) {
        l[t](n.name);
        var u = l.coordinateSystem;
        w(u.regions, function(c) {
          o[c.name] = l.isSelected(c.name) || !1;
        });
        var h = [];
        w(o, function(c, f) {
          o[f] && h.push(f);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: h
        });
      }), {
        selected: o,
        allSelected: s,
        name: n.name
      };
    });
  }
  e("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), e("select", {
    type: "geoSelect",
    event: "geoselected"
  }), e("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), r.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(t, i, n) {
    var a = t.componentType || "series";
    i.eachComponent({
      mainType: a,
      query: t
    }, function(o) {
      var s = o.coordinateSystem;
      if (s.type === "geo") {
        var l = Mx(s, t, o.get("scaleLimit"), n);
        o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && w(o.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function rpe(r) {
  Ve(_3), r.registerChartView(Gde), r.registerSeriesModel(Vde), r.registerLayout(Yde), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, Xde), _H("map", r.registerAction);
}
function ipe(r) {
  var e = r;
  e.hierNode = {
    defaultAncestor: null,
    ancestor: e,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var t = [e], i, n; i = t.pop(); )
    if (n = i.children, i.isExpand && n.length)
      for (var a = n.length, o = a - 1; o >= 0; o--) {
        var s = n[o];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: o,
          thread: null
        }, t.push(s);
      }
}
function npe(r, e) {
  var t = r.isExpand ? r.children : [], i = r.parentNode.children, n = r.hierNode.i ? i[r.hierNode.i - 1] : null;
  if (t.length) {
    spe(r);
    var a = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2;
    n ? (r.hierNode.prelim = n.hierNode.prelim + e(r, n), r.hierNode.modifier = r.hierNode.prelim - a) : r.hierNode.prelim = a;
  } else
    n && (r.hierNode.prelim = n.hierNode.prelim + e(r, n));
  r.parentNode.hierNode.defaultAncestor = lpe(r, n, r.parentNode.hierNode.defaultAncestor || i[0], e);
}
function ape(r) {
  var e = r.hierNode.prelim + r.parentNode.hierNode.modifier;
  r.setLayout({
    x: e
  }, !0), r.hierNode.modifier += r.parentNode.hierNode.modifier;
}
function r2(r) {
  return arguments.length ? r : cpe;
}
function Gd(r, e) {
  return r -= Math.PI / 2, {
    x: e * Math.cos(r),
    y: e * Math.sin(r)
  };
}
function ope(r, e) {
  return mr(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function spe(r) {
  for (var e = r.children, t = e.length, i = 0, n = 0; --t >= 0; ) {
    var a = e[t];
    a.hierNode.prelim += i, a.hierNode.modifier += i, n += a.hierNode.change, i += a.hierNode.shift + n;
  }
}
function lpe(r, e, t, i) {
  if (e) {
    for (var n = r, a = r, o = a.parentNode.children[0], s = e, l = n.hierNode.modifier, u = a.hierNode.modifier, h = o.hierNode.modifier, c = s.hierNode.modifier; s = c0(s), a = f0(a), s && a; ) {
      n = c0(n), o = f0(o), n.hierNode.ancestor = r;
      var f = s.hierNode.prelim + c - a.hierNode.prelim - u + i(s, a);
      f > 0 && (hpe(upe(s, r, t), r, f), u += f, l += f), c += s.hierNode.modifier, u += a.hierNode.modifier, l += n.hierNode.modifier, h += o.hierNode.modifier;
    }
    s && !c0(n) && (n.hierNode.thread = s, n.hierNode.modifier += c - l), a && !f0(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - h, t = r);
  }
  return t;
}
function c0(r) {
  var e = r.children;
  return e.length && r.isExpand ? e[e.length - 1] : r.hierNode.thread;
}
function f0(r) {
  var e = r.children;
  return e.length && r.isExpand ? e[0] : r.hierNode.thread;
}
function upe(r, e, t) {
  return r.hierNode.ancestor.parentNode === e.parentNode ? r.hierNode.ancestor : t;
}
function hpe(r, e, t) {
  var i = t / (e.hierNode.i - r.hierNode.i);
  e.hierNode.change -= i, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, r.hierNode.change += i;
}
function cpe(r, e) {
  return r.parentNode === e.parentNode ? 1 : 2;
}
var fpe = (
  /** @class */
  function() {
    function r() {
      this.parentPoint = [], this.childPoints = [];
    }
    return r;
  }()
), dpe = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new fpe();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.childPoints, a = n.length, o = i.parentPoint, s = n[0], l = n[a - 1];
      if (a === 1) {
        t.moveTo(o[0], o[1]), t.lineTo(s[0], s[1]);
        return;
      }
      var u = i.orient, h = u === "TB" || u === "BT" ? 0 : 1, c = 1 - h, f = K(i.forkPosition, 1), d = [];
      d[h] = o[h], d[c] = o[c] + (l[c] - o[c]) * f, t.moveTo(o[0], o[1]), t.lineTo(d[0], d[1]), t.moveTo(s[0], s[1]), d[h] = s[h], t.lineTo(d[0], d[1]), d[h] = l[h], t.lineTo(d[0], d[1]), t.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var g = n[p];
        t.moveTo(g[0], g[1]), d[h] = g[h], t.lineTo(d[0], d[1]);
      }
    }, e;
  }(Fe)
), ppe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._mainGroup = new ye(), t;
    }
    return e.prototype.init = function(t, i) {
      this._controller = new ev(i.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = t.layoutInfo, s = this._mainGroup, l = t.get("layout");
      l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(t, n), this._updateController(t, i, n);
      var u = this._data;
      a.diff(u).add(function(h) {
        i2(a, h) && n2(a, h, null, s, t);
      }).update(function(h, c) {
        var f = u.getItemGraphicEl(c);
        if (!i2(a, h)) {
          f && o2(u, c, f, s, t);
          return;
        }
        n2(a, h, f, s, t);
      }).remove(function(h) {
        var c = u.getItemGraphicEl(h);
        c && o2(u, h, c, s, t);
      }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === !0 && a.eachItemGraphicEl(function(h, c) {
        h.off("click").on("click", function() {
          n.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: t.id,
            dataIndex: c
          });
        });
      }), this._data = a;
    }, e.prototype._updateViewCoordSys = function(t, i) {
      var n = t.getData(), a = [];
      n.each(function(c) {
        var f = n.getItemLayout(c);
        f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y]);
      });
      var o = [], s = [];
      SS(a, o, s);
      var l = this._min, u = this._max;
      s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var h = t.coordinateSystem = new tv();
      h.zoomLimit = t.get("scaleLimit"), h.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), h.setCenter(t.get("center"), i), h.setZoom(t.get("zoom")), this.group.attr({
        x: h.x,
        y: h.y,
        scaleX: h.scaleX,
        scaleY: h.scaleY
      }), this._min = o, this._max = s;
    }, e.prototype._updateController = function(t, i, n) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      o.setPointerChecker(function(u, h, c) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(h, c) && !YS(u, n, t);
      }), o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        Nx(s, u.dx, u.dy), n.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        Lx(s, u.scale, u.originX, u.originY), n.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(t), n.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function(t) {
      var i = t.getData(), n = this._getNodeGlobalScale(t);
      i.eachItemGraphicEl(function(a, o) {
        a.setSymbolScale(n);
      });
    }, e.prototype._getNodeGlobalScale = function(t) {
      var i = t.coordinateSystem;
      if (i.type !== "view")
        return 1;
      var n = this._nodeScaleRatio, a = i.scaleX || 1, o = i.getZoom(), s = (o - 1) * n + 1;
      return s / a;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, e.type = "tree", e;
  }(Mt)
);
function i2(r, e) {
  var t = r.getItemLayout(e);
  return t && !isNaN(t.x) && !isNaN(t.y);
}
function n2(r, e, t, i, n) {
  var a = !t, o = r.tree.getNodeByDataIndex(e), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === !1 && o.children.length !== 0 ? l : "#fff", h = r.tree.root, c = o.parentNode === h ? o : o.parentNode || o, f = r.getItemGraphicEl(c.dataIndex), d = c.getLayout(), p = f ? {
    x: f.__oldX,
    y: f.__oldY,
    rawX: f.__radialOldRawX,
    rawY: f.__radialOldRawY
  } : d, g = o.getLayout();
  a ? (t = new Zg(r, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.x = p.x, t.y = p.y) : t.updateData(r, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = g.rawX, t.__radialRawY = g.rawY, i.add(t), r.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, ft(t, {
    x: g.x,
    y: g.y
  }, n);
  var v = t.getSymbolPath();
  if (n.get("layout") === "radial") {
    var O = h.children[0], m = O.getLayout(), E = O.children.length, b = void 0, T = void 0;
    if (g.x === m.x && o.isExpand === !0 && O.children.length) {
      var S = {
        x: (O.children[0].getLayout().x + O.children[E - 1].getLayout().x) / 2,
        y: (O.children[0].getLayout().y + O.children[E - 1].getLayout().y) / 2
      };
      b = Math.atan2(S.y - m.y, S.x - m.x), b < 0 && (b = Math.PI * 2 + b), T = S.x < m.x, T && (b = b - Math.PI);
    } else
      b = Math.atan2(g.y - m.y, g.x - m.x), b < 0 && (b = Math.PI * 2 + b), o.children.length === 0 || o.children.length !== 0 && o.isExpand === !1 ? (T = g.x < m.x, T && (b = b - Math.PI)) : (T = g.x > m.x, T || (b = b - Math.PI));
    var y = T ? "left" : "right", A = s.getModel("label"), C = A.get("rotate"), _ = C * (Math.PI / 180), I = v.getTextContent();
    I && (v.setTextConfig({
      position: A.get("position") || y,
      rotation: C == null ? -b : _,
      origin: "center"
    }), I.setStyle("verticalAlign", "middle"));
  }
  var x = s.get(["emphasis", "focus"]), P = x === "relative" ? hE(o.getAncestorsIndices(), o.getDescendantIndices()) : x === "ancestor" ? o.getAncestorsIndices() : x === "descendant" ? o.getDescendantIndices() : null;
  P && (_e(t).focus = P), gpe(n, o, h, t, p, d, g, i), t.__edge && (t.onHoverStateChange = function(N) {
    if (N !== "blur") {
      var L = o.parentNode && r.getItemGraphicEl(o.parentNode.dataIndex);
      L && L.hoverState === $g || bE(t.__edge, N);
    }
  });
}
function gpe(r, e, t, i, n, a, o, s) {
  var l = e.getModel(), u = r.get("edgeShape"), h = r.get("layout"), c = r.getOrient(), f = r.get(["lineStyle", "curveness"]), d = r.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = i.__edge;
  if (u === "curve")
    e.parentNode && e.parentNode !== t && (g || (g = i.__edge = new AS({
      shape: LC(h, c, f, n, n)
    })), ft(g, {
      shape: LC(h, c, f, a, o)
    }, r));
  else if (u === "polyline" && h === "orthogonal" && e !== t && e.children && e.children.length !== 0 && e.isExpand === !0) {
    for (var v = e.children, O = [], m = 0; m < v.length; m++) {
      var E = v[m].getLayout();
      O.push([E.x, E.y]);
    }
    g || (g = i.__edge = new dpe({
      shape: {
        parentPoint: [o.x, o.y],
        childPoints: [[o.x, o.y]],
        orient: c,
        forkPosition: d
      }
    })), ft(g, {
      shape: {
        parentPoint: [o.x, o.y],
        childPoints: O
      }
    }, r);
  }
  g && !(u === "polyline" && !e.isExpand) && (g.useStyle(me({
    strokeNoScale: !0,
    fill: null
  }, p)), zr(g, l, "lineStyle"), ih(g), s.add(g));
}
function a2(r, e, t, i, n) {
  var a = e.tree.root, o = I3(a, r), s = o.source, l = o.sourceLayout, u = e.getItemGraphicEl(r.dataIndex);
  if (u) {
    var h = e.getItemGraphicEl(s.dataIndex), c = h.__edge, f = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? c : void 0), d = i.get("edgeShape"), p = i.get("layout"), g = i.get("orient"), v = i.get(["lineStyle", "curveness"]);
    f && (d === "curve" ? al(f, {
      shape: LC(p, g, v, l, l),
      style: {
        opacity: 0
      }
    }, i, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: n
    }) : d === "polyline" && i.get("layout") === "orthogonal" && al(f, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, i, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: n
    }));
  }
}
function I3(r, e) {
  for (var t = e.parentNode === r ? e : e.parentNode || e, i; i = t.getLayout(), i == null; )
    t = t.parentNode === r ? t : t.parentNode || t;
  return {
    source: t,
    sourceLayout: i
  };
}
function o2(r, e, t, i, n) {
  var a = r.tree.getNodeByDataIndex(e), o = r.tree.root, s = I3(o, a).sourceLayout, l = {
    duration: n.get("animationDurationUpdate"),
    easing: n.get("animationEasingUpdate")
  };
  al(t, {
    x: s.x + 1,
    y: s.y + 1
  }, n, {
    cb: function() {
      i.remove(t), r.setItemGraphicEl(e, null);
    },
    removeOpt: l
  }), t.fadeOut(null, r.hostModel, {
    fadeLabel: !0,
    animation: l
  }), a.children.forEach(function(u) {
    a2(u, r, i, n, l);
  }), a2(a, r, i, n, l);
}
function LC(r, e, t, i, n) {
  var a, o, s, l, u, h, c, f;
  if (r === "radial") {
    u = i.rawX, c = i.rawY, h = n.rawX, f = n.rawY;
    var d = Gd(u, c), p = Gd(u, c + (f - c) * t), g = Gd(h, f + (c - f) * t), v = Gd(h, f);
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0
    };
  } else
    u = i.x, c = i.y, h = n.x, f = n.y, (e === "LR" || e === "RL") && (a = u + (h - u) * t, o = c, s = h + (u - h) * t, l = f), (e === "TB" || e === "BT") && (a = u, o = c + (f - c) * t, s = h, l = f + (c - f) * t);
  return {
    x1: u,
    y1: c,
    x2: h,
    y2: f,
    cpx1: a,
    cpy1: o,
    cpx2: s,
    cpy2: l
  };
}
const vpe = ppe;
var Fn = at();
function x3(r) {
  var e = r.mainData, t = r.datas;
  t || (t = {
    main: e
  }, r.datasAttr = {
    main: "data"
  }), r.datas = r.mainData = null, w3(e, t, r), w(t, function(i) {
    w(e.TRANSFERABLE_METHODS, function(n) {
      i.wrapMethod(n, Ie(Ope, r));
    });
  }), e.wrapMethod("cloneShallow", Ie(Epe, r)), w(e.CHANGABLE_METHODS, function(i) {
    e.wrapMethod(i, Ie(mpe, r));
  }), _i(t[e.dataType] === e);
}
function Ope(r, e) {
  if (Tpe(this)) {
    var t = V({}, Fn(this).datas);
    t[this.dataType] = e, w3(e, t, r);
  } else
    kx(e, this.dataType, Fn(this).mainData, r);
  return e;
}
function mpe(r, e) {
  return r.struct && r.struct.update(), e;
}
function Epe(r, e) {
  return w(Fn(e).datas, function(t, i) {
    t !== e && kx(t.cloneShallow(), i, e, r);
  }), e;
}
function bpe(r) {
  var e = Fn(this).mainData;
  return r == null || e == null ? e : Fn(e).datas[r];
}
function Spe() {
  var r = Fn(this).mainData;
  return r == null ? [{
    data: r
  }] : Y(He(Fn(r).datas), function(e) {
    return {
      type: e,
      data: Fn(r).datas[e]
    };
  });
}
function Tpe(r) {
  return Fn(r).mainData === r;
}
function w3(r, e, t) {
  Fn(r).datas = {}, w(e, function(i, n) {
    kx(i, n, r, t);
  });
}
function kx(r, e, t, i) {
  Fn(t).datas[e] = r, Fn(r).mainData = t, r.dataType = e, i.struct && (r[i.structAttr] = i.struct, i.struct[i.datasAttr[e]] = r), r.getLinkedData = bpe, r.getLinkedDataAll = Spe;
}
var ype = (
  /** @class */
  function() {
    function r(e, t) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = e || "", this.hostTree = t;
    }
    return r.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, r.prototype.eachNode = function(e, t, i) {
      ve(e) && (i = t, t = e, e = null), e = e || {}, ne(e) && (e = {
        order: e
      });
      var n = e.order || "preorder", a = this[e.attr || "children"], o;
      n === "preorder" && (o = t.call(i, this));
      for (var s = 0; !o && s < a.length; s++)
        a[s].eachNode(e, t, i);
      n === "postorder" && t.call(i, this);
    }, r.prototype.updateDepthAndHeight = function(e) {
      var t = 0;
      this.depth = e;
      for (var i = 0; i < this.children.length; i++) {
        var n = this.children[i];
        n.updateDepthAndHeight(e + 1), n.height > t && (t = n.height);
      }
      this.height = t + 1;
    }, r.prototype.getNodeById = function(e) {
      if (this.getId() === e)
        return this;
      for (var t = 0, i = this.children, n = i.length; t < n; t++) {
        var a = i[t].getNodeById(e);
        if (a)
          return a;
      }
    }, r.prototype.contains = function(e) {
      if (e === this)
        return !0;
      for (var t = 0, i = this.children, n = i.length; t < n; t++) {
        var a = i[t].contains(e);
        if (a)
          return a;
      }
    }, r.prototype.getAncestors = function(e) {
      for (var t = [], i = e ? this : this.parentNode; i; )
        t.push(i), i = i.parentNode;
      return t.reverse(), t;
    }, r.prototype.getAncestorsIndices = function() {
      for (var e = [], t = this; t; )
        e.push(t.dataIndex), t = t.parentNode;
      return e.reverse(), e;
    }, r.prototype.getDescendantIndices = function() {
      var e = [];
      return this.eachNode(function(t) {
        e.push(t.dataIndex);
      }), e;
    }, r.prototype.getValue = function(e) {
      var t = this.hostTree.data;
      return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex);
    }, r.prototype.setLayout = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t);
    }, r.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostTree, i = t.data.getItemModel(this.dataIndex);
        return i.getModel(e);
      }
    }, r.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, r.prototype.setVisual = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t);
    }, r.prototype.getVisual = function(e) {
      return this.hostTree.data.getItemVisual(this.dataIndex, e);
    }, r.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, r.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, r.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var e = this.parentNode.children, t = 0; t < e.length; ++t)
          if (e[t] === this)
            return t;
        return -1;
      }
      return -1;
    }, r.prototype.isAncestorOf = function(e) {
      for (var t = e.parentNode; t; ) {
        if (t === this)
          return !0;
        t = t.parentNode;
      }
      return !1;
    }, r.prototype.isDescendantOf = function(e) {
      return e !== this && e.isAncestorOf(this);
    }, r;
  }()
), Rpe = (
  /** @class */
  function() {
    function r(e) {
      this.type = "tree", this._nodes = [], this.hostModel = e;
    }
    return r.prototype.eachNode = function(e, t, i) {
      this.root.eachNode(e, t, i);
    }, r.prototype.getNodeByDataIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this._nodes[t];
    }, r.prototype.getNodeById = function(e) {
      return this.root.getNodeById(e);
    }, r.prototype.update = function() {
      for (var e = this.data, t = this._nodes, i = 0, n = t.length; i < n; i++)
        t[i].dataIndex = -1;
      for (var i = 0, n = e.count(); i < n; i++)
        t[e.getRawIndex(i)].dataIndex = i;
    }, r.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, r.createTree = function(e, t, i) {
      var n = new r(t), a = [], o = 1;
      s(e);
      function s(h, c) {
        var f = h.value;
        o = Math.max(o, X(f) ? f.length : 1), a.push(h);
        var d = new ype(gr(h.name, ""), n);
        c ? Ape(d, c) : n.root = d, n._nodes.push(d);
        var p = h.children;
        if (p)
          for (var g = 0; g < p.length; g++)
            s(p[g], d);
      }
      n.root.updateDepthAndHeight(0);
      var l = Hg(a, {
        coordDimensions: ["value"],
        dimensionsCount: o
      }).dimensions, u = new Ai(l, t);
      return u.initData(a), i && i(u), x3({
        mainData: u,
        struct: n,
        structAttr: "tree"
      }), n.update(), n;
    }, r;
  }()
);
function Ape(r, e) {
  var t = e.children;
  r.parentNode !== e && (t.push(r), r.parentNode = e);
}
const Qx = Rpe;
function ag(r, e, t) {
  if (r && Ge(e, r.type) >= 0) {
    var i = t.getData().tree.root, n = r.targetNode;
    if (ne(n) && (n = i.getNodeById(n)), n && i.contains(n))
      return {
        node: n
      };
    var a = r.targetNodeId;
    if (a != null && (n = i.getNodeById(a)))
      return {
        node: n
      };
  }
}
function P3(r) {
  for (var e = []; r; )
    r = r.parentNode, r && e.push(r);
  return e.reverse();
}
function Ux(r, e) {
  var t = P3(r);
  return Ge(t, e) >= 0;
}
function WS(r, e) {
  for (var t = []; r; ) {
    var i = r.dataIndex;
    t.push({
      name: r.name,
      dataIndex: i,
      value: e.getRawValue(i)
    }), r = r.parentNode;
  }
  return t.reverse(), t;
}
var Cpe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.hasSymbolVisual = !0, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      var i = {
        name: t.name,
        children: t.data
      }, n = t.leaves || {}, a = new Dt(n, this, this.ecModel), o = Qx.createTree(i, this, s);
      function s(c) {
        c.wrapMethod("getItemModel", function(f, d) {
          var p = o.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (f.parentModel = a), f;
        });
      }
      var l = 0;
      o.eachNode("preorder", function(c) {
        c.depth > l && (l = c.depth);
      });
      var u = t.expandAndCollapse, h = u && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l;
      return o.root.eachNode("preorder", function(c) {
        var f = c.hostTree.data.getRawDataItem(c.dataIndex);
        c.isExpand = f && f.collapsed != null ? !f.collapsed : c.depth <= h;
      }), o.data;
    }, e.prototype.getOrient = function() {
      var t = this.get("orient");
      return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t;
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.formatTooltip = function(t, i, n) {
      for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(t), l = s.getValue(), u = s.name; s && s !== o; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return _r("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, e.prototype.getDataParams = function(t) {
      var i = r.prototype.getDataParams.apply(this, arguments), n = this.getData().tree.getNodeByDataIndex(t);
      return i.treeAncestors = WS(n, this), i.collapsed = !n.isExpand, i;
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, e;
  }(Xt)
);
const _pe = Cpe;
function Ipe(r, e, t) {
  for (var i = [r], n = [], a; a = i.pop(); )
    if (n.push(a), a.isExpand) {
      var o = a.children;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          i.push(o[s]);
    }
  for (; a = n.pop(); )
    e(a, t);
}
function fd(r, e) {
  for (var t = [r], i; i = t.pop(); )
    if (e(i), i.isExpand) {
      var n = i.children;
      if (n.length)
        for (var a = n.length - 1; a >= 0; a--)
          t.push(n[a]);
    }
}
function xpe(r, e) {
  r.eachSeriesByType("tree", function(t) {
    wpe(t, e);
  });
}
function wpe(r, e) {
  var t = ope(r, e);
  r.layoutInfo = t;
  var i = r.get("layout"), n = 0, a = 0, o = null;
  i === "radial" ? (n = 2 * Math.PI, a = Math.min(t.height, t.width) / 2, o = r2(function(E, b) {
    return (E.parentNode === b.parentNode ? 1 : 2) / E.depth;
  })) : (n = t.width, a = t.height, o = r2());
  var s = r.getData().tree.root, l = s.children[0];
  if (l) {
    ipe(s), Ipe(l, npe, o), s.hierNode.modifier = -l.hierNode.prelim, fd(l, ape);
    var u = l, h = l, c = l;
    fd(l, function(E) {
      var b = E.getLayout().x;
      b < u.getLayout().x && (u = E), b > h.getLayout().x && (h = E), E.depth > c.depth && (c = E);
    });
    var f = u === h ? 1 : o(u, h) / 2, d = f - u.getLayout().x, p = 0, g = 0, v = 0, O = 0;
    if (i === "radial")
      p = n / (h.getLayout().x + f + d), g = a / (c.depth - 1 || 1), fd(l, function(E) {
        v = (E.getLayout().x + d) * p, O = (E.depth - 1) * g;
        var b = Gd(v, O);
        E.setLayout({
          x: b.x,
          y: b.y,
          rawX: v,
          rawY: O
        }, !0);
      });
    else {
      var m = r.getOrient();
      m === "RL" || m === "LR" ? (g = a / (h.getLayout().x + f + d), p = n / (c.depth - 1 || 1), fd(l, function(E) {
        O = (E.getLayout().x + d) * g, v = m === "LR" ? (E.depth - 1) * p : n - (E.depth - 1) * p, E.setLayout({
          x: v,
          y: O
        }, !0);
      })) : (m === "TB" || m === "BT") && (p = n / (h.getLayout().x + f + d), g = a / (c.depth - 1 || 1), fd(l, function(E) {
        v = (E.getLayout().x + d) * p, O = m === "TB" ? (E.depth - 1) * g : a - (E.depth - 1) * g, E.setLayout({
          x: v,
          y: O
        }, !0);
      }));
    }
  }
}
function Ppe(r) {
  r.eachSeriesByType("tree", function(e) {
    var t = e.getData(), i = t.tree;
    i.eachNode(function(n) {
      var a = n.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = t.ensureUniqueItemVisual(n.dataIndex, "style");
      V(s, o);
    });
  });
}
function Npe(r) {
  r.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(i) {
      var n = e.dataIndex, a = i.getData().tree, o = a.getNodeByDataIndex(n);
      o.isExpand = !o.isExpand;
    });
  }), r.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(e, t, i) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(n) {
      var a = n.coordinateSystem, o = Mx(a, e, void 0, i);
      n.setCenter && n.setCenter(o.center), n.setZoom && n.setZoom(o.zoom);
    });
  });
}
function Lpe(r) {
  r.registerChartView(vpe), r.registerSeriesModel(_pe), r.registerLayout(xpe), r.registerVisual(Ppe), Npe(r);
}
var s2 = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function Dpe(r) {
  for (var e = 0; e < s2.length; e++)
    r.registerAction({
      type: s2[e],
      update: "updateView"
    }, ar);
  r.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(t, i) {
    i.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: t
    }, n);
    function n(a, o) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = ag(t, s, a);
      if (l) {
        var u = a.getViewRoot();
        u && (t.direction = Ux(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
      }
    }
  });
}
function N3(r) {
  var e = r.getData(), t = e.tree, i = {};
  t.eachNode(function(n) {
    for (var a = n; a && a.depth > 1; )
      a = a.parentNode;
    var o = lC(r.ecModel, a.name || a.dataIndex + "", i);
    n.setVisual("decal", o);
  });
}
var Mpe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.preventUsingHoverLayer = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      var n = {
        name: t.name,
        children: t.data
      };
      L3(n);
      var a = t.levels || [], o = this.designatedVisualItemStyle = {}, s = new Dt({
        itemStyle: o
      }, this, i);
      a = t.levels = kpe(a, i);
      var l = Y(a || [], function(c) {
        return new Dt(c, s, i);
      }, this), u = Qx.createTree(n, this, h);
      function h(c) {
        c.wrapMethod("getItemModel", function(f, d) {
          var p = u.getNodeByDataIndex(d), g = p ? l[p.depth] : null;
          return f.parentModel = g || s, f;
        });
      }
      return u.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return _r("nameValue", {
        name: s,
        value: o
      });
    }, e.prototype.getDataParams = function(t) {
      var i = r.prototype.getDataParams.apply(this, arguments), n = this.getData().tree.getNodeByDataIndex(t);
      return i.treeAncestors = WS(n, this), i.treePathInfo = i.treeAncestors, i;
    }, e.prototype.setLayoutInfo = function(t) {
      this.layoutInfo = this.layoutInfo || {}, V(this.layoutInfo, t);
    }, e.prototype.mapIdToIndex = function(t) {
      var i = this._idIndexMap;
      i || (i = this._idIndexMap = ce(), this._idIndexMapCount = 0);
      var n = i.get(t);
      return n == null && i.set(t, n = this._idIndexMapCount++), n;
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var i = this.getRawData().tree.root;
      (!t || t !== i && !i.contains(t)) && (this._viewRoot = i);
    }, e.prototype.enableAriaDecal = function() {
      N3(this);
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "",
      // to align specialized icon. 
      zoomToNodeRatio: 0.32 * 0.32,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, e;
  }(Xt)
);
function L3(r) {
  var e = 0;
  w(r.children, function(i) {
    L3(i);
    var n = i.value;
    X(n) && (n = n[0]), e += n;
  });
  var t = r.value;
  X(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), X(r.value) ? r.value[0] = t : r.value = t;
}
function kpe(r, e) {
  var t = At(e.get("color")), i = At(e.get(["aria", "decal", "decals"]));
  if (t) {
    r = r || [];
    var n, a;
    w(r, function(s) {
      var l = new Dt(s), u = l.get("color"), h = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (n = !0), (l.get(["itemStyle", "decal"]) || h && h !== "none") && (a = !0);
    });
    var o = r[0] || (r[0] = {});
    return n || (o.color = t.slice()), !a && i && (o.decal = i.slice()), r;
  }
}
const Qpe = Mpe;
var Upe = 8, l2 = 8, d0 = 5, $pe = (
  /** @class */
  function() {
    function r(e) {
      this.group = new ye(), e.add(this.group);
    }
    return r.prototype.render = function(e, t, i, n) {
      var a = e.getModel("breadcrumb"), o = this.group;
      if (o.removeAll(), !(!a.get("show") || !i)) {
        var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), h = l.getModel(["itemStyle", "textStyle"]), c = {
          pos: {
            left: a.get("left"),
            right: a.get("right"),
            top: a.get("top"),
            bottom: a.get("bottom")
          },
          box: {
            width: t.getWidth(),
            height: t.getHeight()
          },
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(i, c, u), this._renderContent(e, c, s, l, u, h, n), DS(o, c.pos, c.box);
      }
    }, r.prototype._prepare = function(e, t, i) {
      for (var n = e; n; n = n.parentNode) {
        var a = gr(n.getModel().get("name"), ""), o = i.getTextRect(a), s = Math.max(o.width + Upe * 2, t.emptyItemWidth);
        t.totalWidth += s + l2, t.renderList.push({
          node: n,
          text: a,
          width: s
        });
      }
    }, r.prototype._renderContent = function(e, t, i, n, a, o, s) {
      for (var l = 0, u = t.emptyItemWidth, h = e.get(["breadcrumb", "height"]), c = Kae(t.pos, t.box), f = t.totalWidth, d = t.renderList, p = n.getModel("itemStyle").getItemStyle(), g = d.length - 1; g >= 0; g--) {
        var v = d[g], O = v.node, m = v.width, E = v.text;
        f > c.width && (f -= m - u, m = u, E = null);
        var b = new Yi({
          shape: {
            points: Gpe(l, 0, m, h, g === d.length - 1, g === 0)
          },
          style: me(i.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new lt({
            style: Lt(a, {
              text: E
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: Sf * 1e4,
          onclick: Ie(s, O)
        });
        b.disableLabelAnimation = !0, b.getTextContent().ensureState("emphasis").style = Lt(o, {
          text: E
        }), b.ensureState("emphasis").style = p, zt(b, n.get("focus"), n.get("blurScope"), n.get("disabled")), this.group.add(b), Bpe(b, e, O), l += m + l2;
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r;
  }()
);
function Gpe(r, e, t, i, n, a) {
  var o = [[n ? r : r - d0, e], [r + t, e], [r + t, e + i], [n ? r : r - d0, e + i]];
  return !a && o.splice(2, 0, [r + t + d0, e + i / 2]), !n && o.push([r, e + i / 2]), o;
}
function Bpe(r, e, t) {
  _e(r).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: e.componentIndex,
    seriesIndex: e.seriesIndex,
    seriesName: e.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: t && t.dataIndex,
      name: t && t.name
    },
    treePathInfo: t && WS(t, e)
  };
}
const Vpe = $pe;
var Fpe = (
  /** @class */
  function() {
    function r() {
      this._storage = [], this._elExistsMap = {};
    }
    return r.prototype.add = function(e, t, i, n, a) {
      return this._elExistsMap[e.id] ? !1 : (this._elExistsMap[e.id] = !0, this._storage.push({
        el: e,
        target: t,
        duration: i,
        delay: n,
        easing: a
      }), !0);
    }, r.prototype.finished = function(e) {
      return this._finishedCallback = e, this;
    }, r.prototype.start = function() {
      for (var e = this, t = this._storage.length, i = function() {
        t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback());
      }, n = 0, a = this._storage.length; n < a; n++) {
        var o = this._storage[n];
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: !0,
          done: i,
          aborted: i
        });
      }
      return this;
    }, r;
  }()
);
function Xpe() {
  return new Fpe();
}
var DC = ye, u2 = nt, h2 = 3, c2 = "label", f2 = "upperLabel", Ype = Sf * 10, Hpe = Sf * 2, Wpe = Sf * 3, au = rh([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), d2 = function(r) {
  var e = au(r);
  return e.stroke = e.fill = e.lineWidth = null, e;
}, XE = at(), zpe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._state = "ready", t._storage = dd(), t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = i.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(Ge(o, t) < 0)) {
        this.seriesModel = t, this.api = n, this.ecModel = i;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = ag(a, s, t), u = a && a.type, h = t.layoutInfo, c = !this._oldTree, f = this._storage, d = u === "treemapRootToNode" && l && f ? {
          rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(h), g = t.get("animation"), v = this._doRender(p, t, d);
        g && !c && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, t, d) : v.renderFinally(), this._resetController(n), this._renderBreadcrumb(t, n, l);
      }
    }, e.prototype._giveContainerGroup = function(t) {
      var i = this._containerGroup;
      return i || (i = this._containerGroup = new DC(), this._initEvents(i), this.group.add(i)), i.x = t.x, i.y = t.y, i;
    }, e.prototype._doRender = function(t, i, n) {
      var a = i.getData().tree, o = this._oldTree, s = dd(), l = dd(), u = this._storage, h = [];
      function c(v, O, m, E) {
        return Zpe(i, l, u, n, s, h, v, O, m, E);
      }
      d(a.root ? [a.root] : [], o && o.root ? [o.root] : [], t, a === o || !o, 0);
      var f = p(u);
      return this._oldTree = a, this._storage = l, {
        lastsForAnimation: s,
        willDeleteEls: f,
        renderFinally: g
      };
      function d(v, O, m, E, b) {
        E ? (O = v, w(v, function(y, A) {
          !y.isRemoved() && S(A, A);
        })) : new Ho(O, v, T, T).add(S).update(S).remove(Ie(S, null)).execute();
        function T(y) {
          return y.getId();
        }
        function S(y, A) {
          var C = y != null ? v[y] : null, _ = A != null ? O[A] : null, I = c(C, _, m, b);
          I && d(C && C.viewChildren || [], _ && _.viewChildren || [], I, E, b + 1);
        }
      }
      function p(v) {
        var O = dd();
        return v && w(v, function(m, E) {
          var b = O[E];
          w(m, function(T) {
            T && (b.push(T), XE(T).willDelete = !0);
          });
        }), O;
      }
      function g() {
        w(f, function(v) {
          w(v, function(O) {
            O.parent && O.parent.remove(O);
          });
        }), w(h, function(v) {
          v.invisible = !0, v.dirty();
        });
      }
    }, e.prototype._doAnimation = function(t, i, n, a) {
      var o = n.get("animationDurationUpdate"), s = n.get("animationEasing"), l = (ve(o) ? 0 : o) || 0, u = (ve(s) ? null : s) || "cubicOut", h = Xpe();
      w(i.willDeleteEls, function(c, f) {
        w(c, function(d, p) {
          if (!d.invisible) {
            var g = d.parent, v, O = XE(g);
            if (a && a.direction === "drillDown")
              v = g === a.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: O.nodeWidth,
                  height: O.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var m = 0, E = 0;
              O.willDelete || (m = O.nodeWidth / 2, E = O.nodeHeight / 2), v = f === "nodeGroup" ? {
                x: m,
                y: E,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: m,
                  y: E,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && h.add(d, v, l, 0, u);
          }
        });
      }), w(this._storage, function(c, f) {
        w(c, function(d, p) {
          var g = i.lastsForAnimation[f][p], v = {};
          g && (d instanceof ye ? g.oldX != null && (v.x = d.x, v.y = d.y, d.x = g.oldX, d.y = g.oldY) : (g.oldShape && (v.shape = V({}, d.shape), d.setShape(g.oldShape)), g.fadein ? (d.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), h.add(d, v, l, 0, u));
        });
      }, this), this._state = "animating", h.finished(ae(function() {
        this._state = "ready", i.renderFinally();
      }, this)).start();
    }, e.prototype._resetController = function(t) {
      var i = this._controller;
      i || (i = this._controller = new ev(t.getZr()), i.enable(this.seriesModel.get("roam")), i.on("pan", ae(this._onPan, this)), i.on("zoom", ae(this._onZoom, this)));
      var n = new Ue(0, 0, t.getWidth(), t.getHeight());
      i.setPointerChecker(function(a, o, s) {
        return n.contain(o, s);
      });
    }, e.prototype._clearController = function() {
      var t = this._controller;
      t && (t.dispose(), t = null);
    }, e.prototype._onPan = function(t) {
      if (this._state !== "animating" && (Math.abs(t.dx) > h2 || Math.abs(t.dy) > h2)) {
        var i = this.seriesModel.getData().tree.root;
        if (!i)
          return;
        var n = i.getLayout();
        if (!n)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: n.x + t.dx,
            y: n.y + t.dy,
            width: n.width,
            height: n.height
          }
        });
      }
    }, e.prototype._onZoom = function(t) {
      var i = t.originX, n = t.originY;
      if (this._state !== "animating") {
        var a = this.seriesModel.getData().tree.root;
        if (!a)
          return;
        var o = a.getLayout();
        if (!o)
          return;
        var s = new Ue(o.x, o.y, o.width, o.height), l = this.seriesModel.layoutInfo;
        i -= l.x, n -= l.y;
        var u = Zn();
        ao(u, u, [-i, -n]), CI(u, u, [t.scale, t.scale]), ao(u, u, [i, n]), s.applyTransform(u), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: s.x,
            y: s.y,
            width: s.width,
            height: s.height
          }
        });
      }
    }, e.prototype._initEvents = function(t) {
      var i = this;
      t.on("click", function(n) {
        if (i._state === "ready") {
          var a = i.seriesModel.get("nodeClick", !0);
          if (a) {
            var o = i.findTarget(n.offsetX, n.offsetY);
            if (o) {
              var s = o.node;
              if (s.getLayout().isLeafRoot)
                i._rootToNode(o);
              else if (a === "zoomToNode")
                i._zoomToNode(o);
              else if (a === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), h = l.get("target", !0) || "blank";
                u && CE(u, h);
              }
            }
          }
        }
      }, this);
    }, e.prototype._renderBreadcrumb = function(t, i, n) {
      var a = this;
      n || (n = t.get("leafDepth", !0) != null ? {
        node: t.getViewRoot()
      } : this.findTarget(i.getWidth() / 2, i.getHeight() / 2), n || (n = {
        node: t.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new Vpe(this.group))).render(t, i, n.node, function(o) {
        a._state !== "animating" && (Ux(t.getViewRoot(), o) ? a._rootToNode({
          node: o
        }) : a._zoomToNode({
          node: o
        }));
      });
    }, e.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = dd(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, e.prototype.dispose = function() {
      this._clearController();
    }, e.prototype._zoomToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype._rootToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype.findTarget = function(t, i) {
      var n, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(o) {
        var s = this._storage.background[o.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(t, i), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            n = {
              node: o,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), n;
    }, e.type = "treemap", e;
  }(Mt)
);
function dd() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function Zpe(r, e, t, i, n, a, o, s, l, u) {
  if (!o)
    return;
  var h = o.getLayout(), c = r.getData(), f = o.getModel();
  if (c.setItemGraphicEl(o.dataIndex, null), !h || !h.isInView)
    return;
  var d = h.width, p = h.height, g = h.borderWidth, v = h.invisible, O = o.getRawIndex(), m = s && s.getRawIndex(), E = o.viewChildren, b = h.upperHeight, T = E && E.length, S = f.getModel("itemStyle"), y = f.getModel(["emphasis", "itemStyle"]), A = f.getModel(["blur", "itemStyle"]), C = f.getModel(["select", "itemStyle"]), _ = S.get("borderRadius") || 0, I = de("nodeGroup", DC);
  if (!I)
    return;
  if (l.add(I), I.x = h.x || 0, I.y = h.y || 0, I.markRedraw(), XE(I).nodeWidth = d, XE(I).nodeHeight = p, h.isAboveViewRoot)
    return I;
  var x = de("background", u2, u, Hpe);
  x && G(I, x, T && h.upperLabelHeight);
  var P = f.getModel("emphasis"), N = P.get("focus"), L = P.get("blurScope"), D = P.get("disabled"), $ = N === "ancestor" ? o.getAncestorsIndices() : N === "descendant" ? o.getDescendantIndices() : N;
  if (T)
    Hp(I) && Tu(I, !1), x && (Tu(x, !D), c.setItemGraphicEl(o.dataIndex, x), eC(x, $, L));
  else {
    var k = de("content", u2, u, Wpe);
    k && F(I, k), x.disableMorphing = !0, x && Hp(x) && Tu(x, !1), Tu(I, !D), c.setItemGraphicEl(o.dataIndex, I), eC(I, $, L);
  }
  return I;
  function G(Ne, Ee, xe) {
    var Ce = _e(Ee);
    if (Ce.dataIndex = o.dataIndex, Ce.seriesIndex = r.seriesIndex, Ee.setShape({
      x: 0,
      y: 0,
      width: d,
      height: p,
      r: _
    }), v)
      q(Ee);
    else {
      Ee.invisible = !1;
      var ue = o.getVisual("style"), M = ue.stroke, Q = d2(S);
      Q.fill = M;
      var B = au(y);
      B.fill = y.get("borderColor");
      var W = au(A);
      W.fill = A.get("borderColor");
      var H = au(C);
      if (H.fill = C.get("borderColor"), xe) {
        var J = d - 2 * g;
        re(
          // PENDING: convert ZRColor to ColorString for text.
          Ee,
          M,
          ue.opacity,
          {
            x: g,
            y: 0,
            width: J,
            height: b
          }
        );
      } else
        Ee.removeTextContent();
      Ee.setStyle(Q), Ee.ensureState("emphasis").style = B, Ee.ensureState("blur").style = W, Ee.ensureState("select").style = H, ih(Ee);
    }
    Ne.add(Ee);
  }
  function F(Ne, Ee) {
    var xe = _e(Ee);
    xe.dataIndex = o.dataIndex, xe.seriesIndex = r.seriesIndex;
    var Ce = Math.max(d - 2 * g, 0), ue = Math.max(p - 2 * g, 0);
    if (Ee.culling = !0, Ee.setShape({
      x: g,
      y: g,
      width: Ce,
      height: ue,
      r: _
    }), v)
      q(Ee);
    else {
      Ee.invisible = !1;
      var M = o.getVisual("style"), Q = M.fill, B = d2(S);
      B.fill = Q, B.decal = M.decal;
      var W = au(y), H = au(A), J = au(C);
      re(Ee, Q, M.opacity, null), Ee.setStyle(B), Ee.ensureState("emphasis").style = W, Ee.ensureState("blur").style = H, Ee.ensureState("select").style = J, ih(Ee);
    }
    Ne.add(Ee);
  }
  function q(Ne) {
    !Ne.invisible && a.push(Ne);
  }
  function re(Ne, Ee, xe, Ce) {
    var ue = f.getModel(Ce ? f2 : c2), M = gr(f.get("name"), null), Q = ue.getShallow("show");
    Zr(Ne, Cr(f, Ce ? f2 : c2), {
      defaultText: Q ? M : null,
      inheritColor: Ee,
      defaultOpacity: xe,
      labelFetcher: r,
      labelDataIndex: o.dataIndex
    });
    var B = Ne.getTextContent();
    if (B) {
      var W = B.style, H = yI(W.padding || 0);
      Ce && (Ne.setTextConfig({
        layoutRect: Ce
      }), B.disableLabelLayout = !0), B.beforeUpdate = function() {
        var le = Math.max((Ce ? Ce.width : Ne.shape.width) - H[1] - H[3], 0), ee = Math.max((Ce ? Ce.height : Ne.shape.height) - H[0] - H[2], 0);
        (W.width !== le || W.height !== ee) && B.setStyle({
          width: le,
          height: ee
        });
      }, W.truncateMinChar = 2, W.lineOverflow = "truncate", fe(W, Ce, h);
      var J = B.getState("emphasis");
      fe(J ? J.style : null, Ce, h);
    }
  }
  function fe(Ne, Ee, xe) {
    var Ce = Ne ? Ne.text : null;
    if (!Ee && xe.isLeafRoot && Ce != null) {
      var ue = r.get("drillDownIcon", !0);
      Ne.text = ue ? ue + " " + Ce : Ce;
    }
  }
  function de(Ne, Ee, xe, Ce) {
    var ue = m != null && t[Ne][m], M = n[Ne];
    return ue ? (t[Ne][m] = null, $e(M, ue)) : v || (ue = new Ee(), ue instanceof qn && (ue.z2 = qpe(xe, Ce)), Pe(M, ue)), e[Ne][O] = ue;
  }
  function $e(Ne, Ee) {
    var xe = Ne[O] = {};
    Ee instanceof DC ? (xe.oldX = Ee.x, xe.oldY = Ee.y) : xe.oldShape = V({}, Ee.shape);
  }
  function Pe(Ne, Ee) {
    var xe = Ne[O] = {}, Ce = o.parentNode, ue = Ee instanceof ye;
    if (Ce && (!i || i.direction === "drillDown")) {
      var M = 0, Q = 0, B = n.background[Ce.getRawIndex()];
      !i && B && B.oldShape && (M = B.oldShape.width, Q = B.oldShape.height), ue ? (xe.oldX = 0, xe.oldY = Q) : xe.oldShape = {
        x: M,
        y: Q,
        width: 0,
        height: 0
      };
    }
    xe.fadein = !ue;
  }
}
function qpe(r, e) {
  return r * Ype + e;
}
const jpe = zpe;
var og = w, Kpe = be, YE = -1, $x = (
  /** @class */
  function() {
    function r(e) {
      var t = e.mappingMethod, i = e.type, n = this.option = Se(e);
      this.type = i, this.mappingMethod = t, this._normalizeData = tge[t];
      var a = r.visualHandlers[i];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[t], t === "piecewise" ? (p0(n), Jpe(n)) : t === "category" ? n.categories ? ege(n) : p0(n, !0) : (_i(t !== "linear" || n.dataExtent), p0(n));
    }
    return r.prototype.mapValueToVisual = function(e) {
      var t = this._normalizeData(e);
      return this._normalizedToVisual(t, e);
    }, r.prototype.getNormalizer = function() {
      return ae(this._normalizeData, this);
    }, r.listVisualTypes = function() {
      return He(r.visualHandlers);
    }, r.isValidType = function(e) {
      return r.visualHandlers.hasOwnProperty(e);
    }, r.eachVisual = function(e, t, i) {
      be(e) ? w(e, t, i) : t.call(i, e);
    }, r.mapVisual = function(e, t, i) {
      var n, a = X(e) ? [] : be(e) ? {} : (n = !0, null);
      return r.eachVisual(e, function(o, s) {
        var l = t.call(i, o, s);
        n ? a = l : a[s] = l;
      }), a;
    }, r.retrieveVisuals = function(e) {
      var t = {}, i;
      return e && og(r.visualHandlers, function(n, a) {
        e.hasOwnProperty(a) && (t[a] = e[a], i = !0);
      }), i ? t : null;
    }, r.prepareVisualTypes = function(e) {
      if (X(e))
        e = e.slice();
      else if (Kpe(e)) {
        var t = [];
        og(e, function(i, n) {
          t.push(n);
        }), e = t;
      } else
        return [];
      return e.sort(function(i, n) {
        return n === "color" && i !== "color" && i.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, r.dependsOn = function(e, t) {
      return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t;
    }, r.findPieceIndex = function(e, t, i) {
      for (var n, a = 1 / 0, o = 0, s = t.length; o < s; o++) {
        var l = t[o].value;
        if (l != null) {
          if (l === e || ne(l) && l === e + "")
            return o;
          i && f(l, o);
        }
      }
      for (var o = 0, s = t.length; o < s; o++) {
        var u = t[o], h = u.interval, c = u.close;
        if (h) {
          if (h[0] === -1 / 0) {
            if (bO(c[1], e, h[1]))
              return o;
          } else if (h[1] === 1 / 0) {
            if (bO(c[0], h[0], e))
              return o;
          } else if (bO(c[0], h[0], e) && bO(c[1], e, h[1]))
            return o;
          i && f(h[0], o), i && f(h[1], o);
        }
      }
      if (i)
        return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : n;
      function f(d, p) {
        var g = Math.abs(d - e);
        g < a && (a = g, n = p);
      }
    }, r.visualHandlers = {
      color: {
        applyVisual: pd("color"),
        getColorMapper: function() {
          var e = this.option;
          return ae(e.mappingMethod === "category" ? function(t, i) {
            return !i && (t = this._normalizeData(t)), Bd.call(this, t);
          } : function(t, i, n) {
            var a = !!n;
            return !i && (t = this._normalizeData(t)), n = qT(t, e.parsedVisual, n), a ? n : ko(n, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return ko(qT(e, this.option.parsedVisual), "rgba");
          },
          category: Bd,
          piecewise: function(e, t) {
            var i = kC.call(this, t);
            return i == null && (i = ko(qT(e, this.option.parsedVisual), "rgba")), i;
          },
          fixed: ou
        }
      },
      colorHue: EO(function(e, t) {
        return ip(e, t);
      }),
      colorSaturation: EO(function(e, t) {
        return ip(e, null, t);
      }),
      colorLightness: EO(function(e, t) {
        return ip(e, null, null, t);
      }),
      colorAlpha: EO(function(e, t) {
        return dE(e, t);
      }),
      decal: {
        applyVisual: pd("decal"),
        _normalizedToVisual: {
          linear: null,
          category: Bd,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: pd("opacity"),
        _normalizedToVisual: MC([0, 1])
      },
      liftZ: {
        applyVisual: pd("liftZ"),
        _normalizedToVisual: {
          linear: ou,
          category: ou,
          piecewise: ou,
          fixed: ou
        }
      },
      symbol: {
        applyVisual: function(e, t, i) {
          var n = this.mapValueToVisual(e);
          i("symbol", n);
        },
        _normalizedToVisual: {
          linear: p2,
          category: Bd,
          piecewise: function(e, t) {
            var i = kC.call(this, t);
            return i == null && (i = p2.call(this, e)), i;
          },
          fixed: ou
        }
      },
      symbolSize: {
        applyVisual: pd("symbolSize"),
        _normalizedToVisual: MC([0, 1])
      }
    }, r;
  }()
);
function Jpe(r) {
  var e = r.pieceList;
  r.hasSpecialVisual = !1, w(e, function(t, i) {
    t.originIndex = i, t.visual != null && (r.hasSpecialVisual = !0);
  });
}
function ege(r) {
  var e = r.categories, t = r.categoryMap = {}, i = r.visual;
  if (og(e, function(o, s) {
    t[o] = s;
  }), !X(i)) {
    var n = [];
    be(i) ? og(i, function(o, s) {
      var l = t[s];
      n[l ?? YE] = o;
    }) : n[YE] = i, i = D3(r, n);
  }
  for (var a = e.length - 1; a >= 0; a--)
    i[a] == null && (delete t[e[a]], e.pop());
}
function p0(r, e) {
  var t = r.visual, i = [];
  be(t) ? og(t, function(a) {
    i.push(a);
  }) : t != null && i.push(t);
  var n = {
    color: 1,
    symbol: 1
  };
  !e && i.length === 1 && !n.hasOwnProperty(r.type) && (i[1] = i[0]), D3(r, i);
}
function EO(r) {
  return {
    applyVisual: function(e, t, i) {
      var n = this.mapValueToVisual(e);
      i("color", r(t("color"), n));
    },
    _normalizedToVisual: MC([0, 1])
  };
}
function p2(r) {
  var e = this.option.visual;
  return e[Math.round(Et(r, [0, 1], [0, e.length - 1], !0))] || {};
}
function pd(r) {
  return function(e, t, i) {
    i(r, this.mapValueToVisual(e));
  };
}
function Bd(r) {
  var e = this.option.visual;
  return e[this.option.loop && r !== YE ? r % e.length : r];
}
function ou() {
  return this.option.visual[0];
}
function MC(r) {
  return {
    linear: function(e) {
      return Et(e, r, this.option.visual, !0);
    },
    category: Bd,
    piecewise: function(e, t) {
      var i = kC.call(this, t);
      return i == null && (i = Et(e, r, this.option.visual, !0)), i;
    },
    fixed: ou
  };
}
function kC(r) {
  var e = this.option, t = e.pieceList;
  if (e.hasSpecialVisual) {
    var i = $x.findPieceIndex(r, t), n = t[i];
    if (n && n.visual)
      return n.visual[this.type];
  }
}
function D3(r, e) {
  return r.visual = e, r.type === "color" && (r.parsedVisual = Y(e, function(t) {
    var i = pn(t);
    return i || [0, 0, 0, 1];
  })), e;
}
var tge = {
  linear: function(r) {
    return Et(r, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(r) {
    var e = this.option.pieceList, t = $x.findPieceIndex(r, e, !0);
    if (t != null)
      return Et(t, [0, e.length - 1], [0, 1], !0);
  },
  category: function(r) {
    var e = this.option.categories ? this.option.categoryMap[r] : r;
    return e ?? YE;
  },
  fixed: ar
};
function bO(r, e, t) {
  return r ? e <= t : e < t;
}
const Wr = $x;
var rge = "itemStyle", M3 = at();
const ige = {
  seriesType: "treemap",
  reset: function(r) {
    var e = r.getData().tree, t = e.root;
    t.isRemoved() || k3(
      t,
      // Visual should calculate from tree root but not view root.
      {},
      r.getViewRoot().getAncestors(),
      r
    );
  }
};
function k3(r, e, t, i) {
  var n = r.getModel(), a = r.getLayout(), o = r.hostTree.data;
  if (!(!a || a.invisible || !a.isInView)) {
    var s = n.getModel(rge), l = nge(s, e, i), u = o.ensureUniqueItemVisual(r.dataIndex, "style"), h = s.get("borderColor"), c = s.get("borderColorSaturation"), f;
    c != null && (f = g2(l), h = age(c, f)), u.stroke = h;
    var d = r.viewChildren;
    if (!d || !d.length)
      f = g2(l), u.fill = f;
    else {
      var p = oge(r, n, a, s, l, d);
      w(d, function(g, v) {
        if (g.depth >= t.length || g === t[g.depth]) {
          var O = sge(n, l, g, v, p, i);
          k3(g, O, t, i);
        }
      });
    }
  }
}
function nge(r, e, t) {
  var i = V({}, e), n = t.designatedVisualItemStyle;
  return w(["color", "colorAlpha", "colorSaturation"], function(a) {
    n[a] = e[a];
    var o = r.get(a);
    n[a] = null, o != null && (i[a] = o);
  }), i;
}
function g2(r) {
  var e = g0(r, "color");
  if (e) {
    var t = g0(r, "colorAlpha"), i = g0(r, "colorSaturation");
    return i && (e = ip(e, null, null, i)), t && (e = dE(e, t)), e;
  }
}
function age(r, e) {
  return e != null ? ip(e, null, null, r) : null;
}
function g0(r, e) {
  var t = r[e];
  if (t != null && t !== "none")
    return t;
}
function oge(r, e, t, i, n, a) {
  if (!(!a || !a.length)) {
    var o = v0(e, "color") || n.color != null && n.color !== "none" && (v0(e, "colorAlpha") || v0(e, "colorSaturation"));
    if (o) {
      var s = e.get("visualMin"), l = e.get("visualMax"), u = t.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var h = e.get("colorMappingBy"), c = {
        type: o.name,
        dataExtent: u,
        visual: o.range
      };
      c.type === "color" && (h === "index" || h === "id") ? (c.mappingMethod = "category", c.loop = !0) : c.mappingMethod = "linear";
      var f = new Wr(c);
      return M3(f).drColorMappingBy = h, f;
    }
  }
}
function v0(r, e) {
  var t = r.get(e);
  return X(t) && t.length ? {
    name: e,
    range: t
  } : null;
}
function sge(r, e, t, i, n, a) {
  var o = V({}, e);
  if (n) {
    var s = n.type, l = s === "color" && M3(n).drColorMappingBy, u = l === "index" ? i : l === "id" ? a.mapIdToIndex(t.getId()) : t.getValue(r.get("visualDimension"));
    o[s] = n.mapValueToVisual(u);
  }
  return o;
}
var sg = Math.max, HE = Math.min, v2 = Dr, Gx = w, Q3 = ["itemStyle", "borderWidth"], lge = ["itemStyle", "gapWidth"], uge = ["upperLabel", "show"], hge = ["upperLabel", "height"];
const cge = {
  seriesType: "treemap",
  reset: function(r, e, t, i) {
    var n = t.getWidth(), a = t.getHeight(), o = r.option, s = mr(r.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    }), l = o.size || [], u = K(v2(s.width, l[0]), n), h = K(v2(s.height, l[1]), a), c = i && i.type, f = ["treemapZoomToNode", "treemapRootToNode"], d = ag(i, f, r), p = c === "treemapRender" || c === "treemapMove" ? i.rootRect : null, g = r.getViewRoot(), v = P3(g);
    if (c !== "treemapMove") {
      var O = c === "treemapZoomToNode" ? Oge(r, d, g, u, h) : p ? [p.width, p.height] : [u, h], m = o.sort;
      m && m !== "asc" && m !== "desc" && (m = "desc");
      var E = {
        squareRatio: o.squareRatio,
        sort: m,
        leafDepth: o.leafDepth
      };
      g.hostTree.clearLayouts();
      var b = {
        x: 0,
        y: 0,
        width: O[0],
        height: O[1],
        area: O[0] * O[1]
      };
      g.setLayout(b), U3(g, E, !1, 0), b = g.getLayout(), Gx(v, function(S, y) {
        var A = (v[y + 1] || g).getValue();
        S.setLayout(V({
          dataExtent: [A, A],
          borderWidth: 0,
          upperHeight: 0
        }, b));
      });
    }
    var T = r.getData().tree.root;
    T.setLayout(mge(s, p, d), !0), r.setLayoutInfo(s), $3(
      T,
      // Transform to base element coordinate system.
      new Ue(-s.x, -s.y, n, a),
      v,
      g,
      0
    );
  }
};
function U3(r, e, t, i) {
  var n, a;
  if (!r.isRemoved()) {
    var o = r.getLayout();
    n = o.width, a = o.height;
    var s = r.getModel(), l = s.get(Q3), u = s.get(lge) / 2, h = G3(s), c = Math.max(l, h), f = l - u, d = c - u;
    r.setLayout({
      borderWidth: l,
      upperHeight: c,
      upperLabelHeight: h
    }, !0), n = sg(n - 2 * f, 0), a = sg(a - f - d, 0);
    var p = n * a, g = fge(r, s, p, e, t, i);
    if (g.length) {
      var v = {
        x: f,
        y: d,
        width: n,
        height: a
      }, O = HE(n, a), m = 1 / 0, E = [];
      E.area = 0;
      for (var b = 0, T = g.length; b < T; ) {
        var S = g[b];
        E.push(S), E.area += S.getLayout().area;
        var y = vge(E, O, e.squareRatio);
        y <= m ? (b++, m = y) : (E.area -= E.pop().getLayout().area, O2(E, O, v, u, !1), O = HE(v.width, v.height), E.length = E.area = 0, m = 1 / 0);
      }
      if (E.length && O2(E, O, v, u, !0), !t) {
        var A = s.get("childrenVisibleMin");
        A != null && p < A && (t = !0);
      }
      for (var b = 0, T = g.length; b < T; b++)
        U3(g[b], e, t, i + 1);
    }
  }
}
function fge(r, e, t, i, n, a) {
  var o = r.children || [], s = i.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = i.leafDepth != null && i.leafDepth <= a;
  if (n && !l)
    return r.viewChildren = [];
  o = yt(o, function(d) {
    return !d.isRemoved();
  }), pge(o, s);
  var u = gge(e, o, s);
  if (u.sum === 0)
    return r.viewChildren = [];
  if (u.sum = dge(e, t, u.sum, s, o), u.sum === 0)
    return r.viewChildren = [];
  for (var h = 0, c = o.length; h < c; h++) {
    var f = o[h].getValue() / u.sum * t;
    o[h].setLayout({
      area: f
    });
  }
  return l && (o.length && r.setLayout({
    isLeafRoot: !0
  }, !0), o.length = 0), r.viewChildren = o, r.setLayout({
    dataExtent: u.dataExtent
  }, !0), o;
}
function dge(r, e, t, i, n) {
  if (!i)
    return t;
  for (var a = r.get("visibleMin"), o = n.length, s = o, l = o - 1; l >= 0; l--) {
    var u = n[i === "asc" ? o - l - 1 : l].getValue();
    u / t * e < a && (s = l, t -= u);
  }
  return i === "asc" ? n.splice(0, o - s) : n.splice(s, o - s), t;
}
function pge(r, e) {
  return e && r.sort(function(t, i) {
    var n = e === "asc" ? t.getValue() - i.getValue() : i.getValue() - t.getValue();
    return n === 0 ? e === "asc" ? t.dataIndex - i.dataIndex : i.dataIndex - t.dataIndex : n;
  }), r;
}
function gge(r, e, t) {
  for (var i = 0, n = 0, a = e.length; n < a; n++)
    i += e[n].getValue();
  var o = r.get("visualDimension"), s;
  return !e || !e.length ? s = [NaN, NaN] : o === "value" && t ? (s = [e[e.length - 1].getValue(), e[0].getValue()], t === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], Gx(e, function(l) {
    var u = l.getValue(o);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: i,
    dataExtent: s
  };
}
function vge(r, e, t) {
  for (var i = 0, n = 1 / 0, a = 0, o = void 0, s = r.length; a < s; a++)
    o = r[a].getLayout().area, o && (o < n && (n = o), o > i && (i = o));
  var l = r.area * r.area, u = e * e * t;
  return l ? sg(u * i / l, l / (u * n)) : 1 / 0;
}
function O2(r, e, t, i, n) {
  var a = e === t.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], u = t[s[a]], h = e ? r.area / e : 0;
  (n || h > t[l[o]]) && (h = t[l[o]]);
  for (var c = 0, f = r.length; c < f; c++) {
    var d = r[c], p = {}, g = h ? d.getLayout().area / h : 0, v = p[l[o]] = sg(h - 2 * i, 0), O = t[s[a]] + t[l[a]] - u, m = c === f - 1 || O < g ? O : g, E = p[l[a]] = sg(m - 2 * i, 0);
    p[s[o]] = t[s[o]] + HE(i, v / 2), p[s[a]] = u + HE(i, E / 2), u += m, d.setLayout(p, !0);
  }
  t[s[o]] += h, t[l[o]] -= h;
}
function Oge(r, e, t, i, n) {
  var a = (e || {}).node, o = [i, n];
  if (!a || a === t)
    return o;
  for (var s, l = i * n, u = l * r.option.zoomToNodeRatio; s = a.parentNode; ) {
    for (var h = 0, c = s.children, f = 0, d = c.length; f < d; f++)
      h += c[f].getValue();
    var p = a.getValue();
    if (p === 0)
      return o;
    u *= h / p;
    var g = s.getModel(), v = g.get(Q3), O = Math.max(v, G3(g));
    u += 4 * v * v + (3 * v + O) * Math.pow(u, 0.5), u > xL && (u = xL), a = s;
  }
  u < l && (u = l);
  var m = Math.pow(u / l, 0.5);
  return [i * m, n * m];
}
function mge(r, e, t) {
  if (e)
    return {
      x: e.x,
      y: e.y
    };
  var i = {
    x: 0,
    y: 0
  };
  if (!t)
    return i;
  var n = t.node, a = n.getLayout();
  if (!a)
    return i;
  for (var o = [a.width / 2, a.height / 2], s = n; s; ) {
    var l = s.getLayout();
    o[0] += l.x, o[1] += l.y, s = s.parentNode;
  }
  return {
    x: r.width / 2 - o[0],
    y: r.height / 2 - o[1]
  };
}
function $3(r, e, t, i, n) {
  var a = r.getLayout(), o = t[n], s = o && o === r;
  if (!(o && !s || n === t.length && r !== i)) {
    r.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !e.intersect(a),
      isAboveViewRoot: s
    }, !0);
    var l = new Ue(e.x - a.x, e.y - a.y, e.width, e.height);
    Gx(r.viewChildren || [], function(u) {
      $3(u, l, t, i, n + 1);
    });
  }
}
function G3(r) {
  return r.get(uge) ? r.get(hge) : 0;
}
function Ege(r) {
  r.registerSeriesModel(Qpe), r.registerChartView(jpe), r.registerVisual(ige), r.registerLayout(cge), Dpe(r);
}
function bge(r) {
  var e = r.findComponents({
    mainType: "legend"
  });
  !e || !e.length || r.eachSeriesByType("graph", function(t) {
    var i = t.getCategoriesData(), n = t.getGraph(), a = n.data, o = i.mapArray(i.getName);
    a.filterSelf(function(s) {
      var l = a.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        ut(u) && (u = o[u]);
        for (var h = 0; h < e.length; h++)
          if (!e[h].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function Sge(r) {
  var e = {};
  r.eachSeriesByType("graph", function(t) {
    var i = t.getCategoriesData(), n = t.getData(), a = {};
    i.each(function(o) {
      var s = i.getName(o);
      a["ec-" + s] = o;
      var l = i.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = t.getColorFromPalette(s, e)), i.setItemVisual(o, "style", u);
      for (var h = ["symbol", "symbolSize", "symbolKeepAspect"], c = 0; c < h.length; c++) {
        var f = l.getShallow(h[c], !0);
        f != null && i.setItemVisual(o, h[c], f);
      }
    }), i.count() && n.each(function(o) {
      var s = n.getItemModel(o), l = s.getShallow("category");
      if (l != null) {
        ne(l) && (l = a["ec-" + l]);
        var u = i.getItemVisual(l, "style"), h = n.ensureUniqueItemVisual(o, "style");
        V(h, u);
        for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < c.length; f++)
          n.setItemVisual(o, c[f], i.getItemVisual(l, c[f]));
      }
    });
  });
}
function SO(r) {
  return r instanceof Array || (r = [r, r]), r;
}
function Tge(r) {
  r.eachSeriesByType("graph", function(e) {
    var t = e.getGraph(), i = e.getEdgeData(), n = SO(e.get("edgeSymbol")), a = SO(e.get("edgeSymbolSize"));
    i.setVisual("fromSymbol", n && n[0]), i.setVisual("toSymbol", n && n[1]), i.setVisual("fromSymbolSize", a && a[0]), i.setVisual("toSymbolSize", a && a[1]), i.setVisual("style", e.getModel("lineStyle").getLineStyle()), i.each(function(o) {
      var s = i.getItemModel(o), l = t.getEdgeByIndex(o), u = SO(s.getShallow("symbol", !0)), h = SO(s.getShallow("symbolSize", !0)), c = s.getModel("lineStyle").getLineStyle(), f = i.ensureUniqueItemVisual(o, "style");
      switch (V(f, c), f.stroke) {
        case "source": {
          var d = l.node1.getVisual("style");
          f.stroke = d && d.fill;
          break;
        }
        case "target": {
          var d = l.node2.getVisual("style");
          f.stroke = d && d.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), h[0] && l.setVisual("fromSymbolSize", h[0]), h[1] && l.setVisual("toSymbolSize", h[1]);
    });
  });
}
var QC = "-->", zS = function(r) {
  return r.get("autoCurveness") || null;
}, B3 = function(r, e) {
  var t = zS(r), i = 20, n = [];
  if (ut(t))
    i = t;
  else if (X(t)) {
    r.__curvenessList = t;
    return;
  }
  e > i && (i = e);
  var a = i % 2 ? i + 2 : i + 3;
  n = [];
  for (var o = 0; o < a; o++)
    n.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
  r.__curvenessList = n;
}, lg = function(r, e, t) {
  var i = [r.id, r.dataIndex].join("."), n = [e.id, e.dataIndex].join(".");
  return [t.uid, i, n].join(QC);
}, V3 = function(r) {
  var e = r.split(QC);
  return [e[0], e[2], e[1]].join(QC);
}, yge = function(r, e) {
  var t = lg(r.node1, r.node2, e);
  return e.__edgeMap[t];
}, Rge = function(r, e) {
  var t = UC(lg(r.node1, r.node2, e), e), i = UC(lg(r.node2, r.node1, e), e);
  return t + i;
}, UC = function(r, e) {
  var t = e.__edgeMap;
  return t[r] ? t[r].length : 0;
};
function Age(r) {
  zS(r) && (r.__curvenessList = [], r.__edgeMap = {}, B3(r));
}
function Cge(r, e, t, i) {
  if (zS(t)) {
    var n = lg(r, e, t), a = t.__edgeMap, o = a[V3(n)];
    a[n] && !o ? a[n].isForward = !0 : o && a[n] && (o.isForward = !0, a[n].isForward = !1), a[n] = a[n] || [], a[n].push(i);
  }
}
function Bx(r, e, t, i) {
  var n = zS(e), a = X(n);
  if (!n)
    return null;
  var o = yge(r, e);
  if (!o)
    return null;
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === t) {
      s = l;
      break;
    }
  var u = Rge(r, e);
  B3(e, u), r.lineStyle = r.lineStyle || {};
  var h = lg(r.node1, r.node2, e), c = e.__curvenessList, f = a || u % 2 ? 0 : 1;
  if (o.isForward)
    return c[f + s];
  var d = V3(h), p = UC(d, e), g = c[s + p + f];
  return i ? a ? n && n[0] === 0 ? (p + f) % 2 ? g : -g : ((p % 2 ? 0 : 1) + f) % 2 ? g : -g : (p + f) % 2 ? g : -g : c[s + p + f];
}
function F3(r) {
  var e = r.coordinateSystem;
  if (!(e && e.type !== "view")) {
    var t = r.getGraph();
    t.eachNode(function(i) {
      var n = i.getModel();
      i.setLayout([+n.get("x"), +n.get("y")]);
    }), Vx(t, r);
  }
}
function Vx(r, e) {
  r.eachEdge(function(t, i) {
    var n = Ka(t.getModel().get(["lineStyle", "curveness"]), -Bx(t, e, i, !0), 0), a = Do(t.node1.getLayout()), o = Do(t.node2.getLayout()), s = [a, o];
    +n && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * n, (a[1] + o[1]) / 2 - (o[0] - a[0]) * n]), t.setLayout(s);
  });
}
function _ge(r, e) {
  r.eachSeriesByType("graph", function(t) {
    var i = t.get("layout"), n = t.coordinateSystem;
    if (n && n.type !== "view") {
      var a = t.getData(), o = [];
      w(n.dimensions, function(f) {
        o = o.concat(a.mapDimensionsAll(f));
      });
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, h = 0; h < o.length; h++) {
          var c = a.get(o[h], s);
          isNaN(c) || (u = !0), l.push(c);
        }
        u ? a.setItemLayout(s, n.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
      }
      Vx(a.graph, t);
    } else
      (!i || i === "none") && F3(t);
  });
}
function Vd(r) {
  var e = r.coordinateSystem;
  if (e.type !== "view")
    return 1;
  var t = r.option.nodeScaleRatio, i = e.scaleX, n = e.getZoom(), a = (n - 1) * t + 1;
  return a / i;
}
function Fd(r) {
  var e = r.getVisual("symbolSize");
  return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
}
var m2 = Math.PI, O0 = [];
function Fx(r, e, t, i) {
  var n = r.coordinateSystem;
  if (!(n && n.type !== "view")) {
    var a = n.getBoundingRect(), o = r.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, h = Math.min(a.width, a.height) / 2, c = o.count();
    if (o.setLayout({
      cx: l,
      cy: u
    }), !!c) {
      if (t) {
        var f = n.pointToData(i), d = f[0], p = f[1], g = [d - l, p - u];
        mf(g, g), um(g, g, h), t.setLayout([l + g[0], u + g[1]], !0);
        var v = r.get(["circular", "rotateLabel"]);
        X3(t, v, l, u);
      }
      Ige[e](r, s, o, h, l, u, c), s.eachEdge(function(O, m) {
        var E = Ka(O.getModel().get(["lineStyle", "curveness"]), Bx(O, r, m), 0), b = Do(O.node1.getLayout()), T = Do(O.node2.getLayout()), S, y = (b[0] + T[0]) / 2, A = (b[1] + T[1]) / 2;
        +E && (E *= 3, S = [l * E + y * (1 - E), u * E + A * (1 - E)]), O.setLayout([b, T, S]);
      });
    }
  }
}
var Ige = {
  value: function(r, e, t, i, n, a, o) {
    var s = 0, l = t.getSum("value"), u = Math.PI * 2 / (l || o);
    e.eachNode(function(h) {
      var c = h.getValue("value"), f = u * (l ? c : 1) / 2;
      s += f, h.setLayout([i * Math.cos(s) + n, i * Math.sin(s) + a]), s += f;
    });
  },
  symbolSize: function(r, e, t, i, n, a, o) {
    var s = 0;
    O0.length = o;
    var l = Vd(r);
    e.eachNode(function(c) {
      var f = Fd(c);
      isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
      var d = Math.asin(f / 2 / i);
      isNaN(d) && (d = m2 / 2), O0[c.dataIndex] = d, s += d * 2;
    });
    var u = (2 * m2 - s) / o / 2, h = 0;
    e.eachNode(function(c) {
      var f = u + O0[c.dataIndex];
      h += f, (!c.getLayout() || !c.getLayout().fixed) && c.setLayout([i * Math.cos(h) + n, i * Math.sin(h) + a]), h += f;
    });
  }
};
function X3(r, e, t, i) {
  var n = r.getGraphicEl();
  if (n) {
    var a = r.getModel(), o = a.get(["label", "rotate"]) || 0, s = n.getSymbolPath();
    if (e) {
      var l = r.getLayout(), u = Math.atan2(l[1] - i, l[0] - t);
      u < 0 && (u = Math.PI * 2 + u);
      var h = l[0] < t;
      h && (u = u - Math.PI);
      var c = h ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: c,
        origin: "center"
      });
      var f = s.ensureState("emphasis");
      V(f.textConfig || (f.textConfig = {}), {
        position: c
      });
    } else
      s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
  }
}
function xge(r) {
  r.eachSeriesByType("graph", function(e) {
    e.get("layout") === "circular" && Fx(e, "symbolSize");
  });
}
var zh = CA;
function wge(r, e, t) {
  for (var i = r, n = e, a = t.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = t.gravity == null ? 0.1 : t.gravity, h = 0; h < i.length; h++) {
    var c = i[h];
    c.p || (c.p = Eh(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), c.pp = Do(c.p), c.edges = null;
  }
  var f = t.friction == null ? 0.6 : t.friction, d = f, p, g;
  return {
    warmUp: function() {
      d = f * 0.8;
    },
    setFixed: function(v) {
      i[v].fixed = !0;
    },
    setUnfixed: function(v) {
      i[v].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(v) {
      p = v;
    },
    /**
     * After step hook
     */
    afterStep: function(v) {
      g = v;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(v) {
      p && p(i, n);
      for (var O = [], m = i.length, E = 0; E < n.length; E++) {
        var b = n[E];
        if (!b.ignoreForceLayout) {
          var T = b.n1, S = b.n2;
          bu(O, S.p, T.p);
          var y = _A(O) - b.d, A = S.w / (T.w + S.w);
          isNaN(A) && (A = 0), mf(O, O), !T.fixed && zh(T.p, T.p, O, A * y * d), !S.fixed && zh(S.p, S.p, O, -(1 - A) * y * d);
        }
      }
      for (var E = 0; E < m; E++) {
        var C = i[E];
        C.fixed || (bu(O, l, C.p), zh(C.p, C.p, O, u * d));
      }
      for (var E = 0; E < m; E++)
        for (var T = i[E], _ = E + 1; _ < m; _++) {
          var S = i[_];
          bu(O, S.p, T.p);
          var y = _A(O);
          y === 0 && (Fte(O, Math.random() - 0.5, Math.random() - 0.5), y = 1);
          var I = (T.rep + S.rep) / y / y;
          !T.fixed && zh(T.pp, T.pp, O, I), !S.fixed && zh(S.pp, S.pp, O, -I);
        }
      for (var x = [], E = 0; E < m; E++) {
        var C = i[E];
        C.fixed || (bu(x, C.p, C.pp), zh(C.p, C.p, x, d), Oi(C.pp, C.p));
      }
      d = d * 0.992;
      var P = d < 0.01;
      g && g(i, n, P), v && v(P);
    }
  };
}
function Pge(r) {
  r.eachSeriesByType("graph", function(e) {
    var t = e.coordinateSystem;
    if (!(t && t.type !== "view"))
      if (e.get("layout") === "force") {
        var i = e.preservedPoints || {}, n = e.getGraph(), a = n.data, o = n.edgeData, s = e.getModel("force"), l = s.get("initLayout");
        e.preservedPoints ? a.each(function(E) {
          var b = a.getId(E);
          a.setItemLayout(E, i[b] || [NaN, NaN]);
        }) : !l || l === "none" ? F3(e) : l === "circular" && Fx(e, "value");
        var u = a.getDataExtent("value"), h = o.getDataExtent("value"), c = s.get("repulsion"), f = s.get("edgeLength"), d = X(c) ? c : [c, c], p = X(f) ? f : [f, f];
        p = [p[1], p[0]];
        var g = a.mapArray("value", function(E, b) {
          var T = a.getItemLayout(b), S = Et(E, u, d);
          return isNaN(S) && (S = (d[0] + d[1]) / 2), {
            w: S,
            rep: S,
            fixed: a.getItemModel(b).get("fixed"),
            p: !T || isNaN(T[0]) || isNaN(T[1]) ? null : T
          };
        }), v = o.mapArray("value", function(E, b) {
          var T = n.getEdgeByIndex(b), S = Et(E, h, p);
          isNaN(S) && (S = (p[0] + p[1]) / 2);
          var y = T.getModel(), A = Ka(T.getModel().get(["lineStyle", "curveness"]), -Bx(T, e, b, !0), 0);
          return {
            n1: g[T.node1.dataIndex],
            n2: g[T.node2.dataIndex],
            d: S,
            curveness: A,
            ignoreForceLayout: y.get("ignoreForceLayout")
          };
        }), O = t.getBoundingRect(), m = wge(g, v, {
          rect: O,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        m.beforeStep(function(E, b) {
          for (var T = 0, S = E.length; T < S; T++)
            E[T].fixed && Oi(E[T].p, n.getNodeByIndex(T).getLayout());
        }), m.afterStep(function(E, b, T) {
          for (var S = 0, y = E.length; S < y; S++)
            E[S].fixed || n.getNodeByIndex(S).setLayout(E[S].p), i[a.getId(S)] = E[S].p;
          for (var S = 0, y = b.length; S < y; S++) {
            var A = b[S], C = n.getEdgeByIndex(S), _ = A.n1.p, I = A.n2.p, x = C.getLayout();
            x = x ? x.slice() : [], x[0] = x[0] || [], x[1] = x[1] || [], Oi(x[0], _), Oi(x[1], I), +A.curveness && (x[2] = [(_[0] + I[0]) / 2 - (_[1] - I[1]) * A.curveness, (_[1] + I[1]) / 2 - (I[0] - _[0]) * A.curveness]), C.setLayout(x);
          }
        }), e.forceLayout = m, e.preservedPoints = i, m.step();
      } else
        e.forceLayout = null;
  });
}
function Nge(r, e, t) {
  var i = V(r.getBoxLayoutParams(), {
    aspect: t
  });
  return mr(i, {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function Lge(r, e) {
  var t = [];
  return r.eachSeriesByType("graph", function(i) {
    var n = i.get("coordinateSystem");
    if (!n || n === "view") {
      var a = i.getData(), o = a.mapArray(function(v) {
        var O = a.getItemModel(v);
        return [+O.get("x"), +O.get("y")];
      }), s = [], l = [];
      SS(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), h = Nge(i, e, u);
      isNaN(u) && (s = [h.x, h.y], l = [h.x + h.width, h.y + h.height]);
      var c = l[0] - s[0], f = l[1] - s[1], d = h.width, p = h.height, g = i.coordinateSystem = new tv();
      g.zoomLimit = i.get("scaleLimit"), g.setBoundingRect(s[0], s[1], c, f), g.setViewRect(h.x, h.y, d, p), g.setCenter(i.get("center"), e), g.setZoom(i.get("zoom")), t.push(g);
    }
  }), t;
}
var E2 = Mr.prototype, m0 = AS.prototype, Y3 = (
  /** @class */
  function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return r;
  }()
);
(function(r) {
  U(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e;
})(Y3);
function E0(r) {
  return isNaN(+r.cpx1) || isNaN(+r.cpy1);
}
var Dge = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "ec-line", i;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new Y3();
    }, e.prototype.buildPath = function(t, i) {
      E0(i) ? E2.buildPath.call(this, t, i) : m0.buildPath.call(this, t, i);
    }, e.prototype.pointAt = function(t) {
      return E0(this.shape) ? E2.pointAt.call(this, t) : m0.pointAt.call(this, t);
    }, e.prototype.tangentAt = function(t) {
      var i = this.shape, n = E0(i) ? [i.x2 - i.x1, i.y2 - i.y1] : m0.tangentAt.call(this, t);
      return mf(n, n);
    }, e;
  }(Fe)
);
const Mge = Dge;
var b0 = ["fromSymbol", "toSymbol"];
function b2(r) {
  return "_" + r + "Type";
}
function S2(r, e, t) {
  var i = e.getItemVisual(t, r);
  if (!i || i === "none")
    return i;
  var n = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = Nf(n), u = Th(o || 0, l);
  return i + l + u + (a || "") + (s || "");
}
function T2(r, e, t) {
  var i = e.getItemVisual(t, r);
  if (!(!i || i === "none")) {
    var n = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = Nf(n), u = Th(o || 0, l), h = ur(i, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return h.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, h.name = r, h;
  }
}
function kge(r) {
  var e = new Mge({
    name: "line",
    subPixelOptimize: !0
  });
  return $C(e.shape, r), e;
}
function $C(r, e) {
  r.x1 = e[0][0], r.y1 = e[0][1], r.x2 = e[1][0], r.y2 = e[1][1], r.percent = 1;
  var t = e[2];
  t ? (r.cpx1 = t[0], r.cpy1 = t[1]) : (r.cpx1 = NaN, r.cpy1 = NaN);
}
var Qge = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      return a._createLine(t, i, n), a;
    }
    return e.prototype._createLine = function(t, i, n) {
      var a = t.hostModel, o = t.getItemLayout(i), s = kge(o);
      s.shape.percent = 0, Ut(s, {
        shape: {
          percent: 1
        }
      }, a, i), this.add(s), w(b0, function(l) {
        var u = T2(l, t, i);
        this.add(u), this[b2(l)] = S2(l, t, i);
      }, this), this._updateCommonStl(t, i, n);
    }, e.prototype.updateData = function(t, i, n) {
      var a = t.hostModel, o = this.childOfName("line"), s = t.getItemLayout(i), l = {
        shape: {}
      };
      $C(l.shape, s), ft(o, l, a, i), w(b0, function(u) {
        var h = S2(u, t, i), c = b2(u);
        if (this[c] !== h) {
          this.remove(this.childOfName(u));
          var f = T2(u, t, i);
          this.add(f);
        }
        this[c] = h;
      }, this), this._updateCommonStl(t, i, n);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(t, i, n) {
      var a = t.hostModel, o = this.childOfName("line"), s = n && n.emphasisLineStyle, l = n && n.blurLineStyle, u = n && n.selectLineStyle, h = n && n.labelStatesModels, c = n && n.emphasisDisabled, f = n && n.focus, d = n && n.blurScope;
      if (!n || t.hasItemOption) {
        var p = t.getItemModel(i), g = p.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), c = g.get("disabled"), f = g.get("focus"), d = g.get("blurScope"), h = Cr(p);
      }
      var v = t.getItemVisual(i, "style"), O = v.stroke;
      o.useStyle(v), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, w(b0, function(S) {
        var y = this.childOfName(S);
        if (y) {
          y.setColor(O), y.style.opacity = v.opacity;
          for (var A = 0; A < Ii.length; A++) {
            var C = Ii[A], _ = o.getState(C);
            if (_) {
              var I = _.style || {}, x = y.ensureState(C), P = x.style || (x.style = {});
              I.stroke != null && (P[y.__isEmptyBrush ? "stroke" : "fill"] = I.stroke), I.opacity != null && (P.opacity = I.opacity);
            }
          }
          y.markRedraw();
        }
      }, this);
      var m = a.getRawValue(i);
      Zr(this, h, {
        labelDataIndex: i,
        labelFetcher: {
          getFormattedLabel: function(S, y) {
            return a.getFormattedLabel(S, y, t.dataType);
          }
        },
        inheritColor: O || "#000",
        defaultOpacity: v.opacity,
        defaultText: (m == null ? t.getName(i) : isFinite(m) ? Kt(m) : m) + ""
      });
      var E = this.getTextContent();
      if (E) {
        var b = h.normal;
        E.__align = E.style.align, E.__verticalAlign = E.style.verticalAlign, E.__position = b.get("position") || "middle";
        var T = b.get("distance");
        X(T) || (T = [T, T]), E.__labelDistance = T;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), zt(this, f, d, c);
    }, e.prototype.highlight = function() {
      Xo(this);
    }, e.prototype.downplay = function() {
      Yo(this);
    }, e.prototype.updateLayout = function(t, i) {
      this.setLinePoints(t.getItemLayout(i));
    }, e.prototype.setLinePoints = function(t) {
      var i = this.childOfName("line");
      $C(i.shape, t), i.dirty();
    }, e.prototype.beforeUpdate = function() {
      var t = this, i = t.childOfName("fromSymbol"), n = t.childOfName("toSymbol"), a = t.getTextContent();
      if (!i && !n && (!a || a.ignore))
        return;
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = t.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, h = l.pointAt(0), c = l.pointAt(u), f = bu([], c, h);
      mf(f, f);
      function d(_, I) {
        var x = _.__specifiedRotation;
        if (x == null) {
          var P = l.tangentAt(I);
          _.attr("rotation", (I === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(P[1], P[0]));
        } else
          _.attr("rotation", x);
      }
      if (i && (i.setPosition(h), d(i, 0), i.scaleX = i.scaleY = o * u, i.markRedraw()), n && (n.setPosition(c), d(n, 1), n.scaleX = n.scaleY = o * u, n.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, g = void 0, v = a.__labelDistance, O = v[0] * o, m = v[1] * o, E = u / 2, b = l.tangentAt(E), T = [b[1], -b[0]], S = l.pointAt(E);
        T[1] > 0 && (T[0] = -T[0], T[1] = -T[1]);
        var y = b[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var A = -Math.atan2(b[1], b[0]);
          c[0] < h[0] && (A = Math.PI + A), a.rotation = A;
        }
        var C = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            C = -m, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            C = m, g = "top";
            break;
          default:
            C = 0, g = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = f[0] * O + c[0], a.y = f[1] * m + c[1], p = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", g = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -f[0] * O + h[0], a.y = -f[1] * m + h[1], p = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", g = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = O * y + h[0], a.y = h[1] + C, p = b[0] < 0 ? "right" : "left", a.originX = -O * y, a.originY = -C;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = S[0], a.y = S[1] + C, p = "center", a.originY = -C;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -O * y + c[0], a.y = c[1] + C, p = b[0] >= 0 ? "right" : "left", a.originX = O * y, a.originY = -C;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: a.__verticalAlign || g,
          align: a.__align || p
        });
      }
    }, e;
  }(ye)
);
const Xx = Qge;
var Uge = (
  /** @class */
  function() {
    function r(e) {
      this.group = new ye(), this._LineCtor = e || Xx;
    }
    return r.prototype.updateData = function(e) {
      var t = this;
      this._progressiveEls = null;
      var i = this, n = i.group, a = i._lineData;
      i._lineData = e, a || n.removeAll();
      var o = y2(e);
      e.diff(a).add(function(s) {
        t._doAdd(e, s, o);
      }).update(function(s, l) {
        t._doUpdate(a, e, l, s, o);
      }).remove(function(s) {
        n.remove(a.getItemGraphicEl(s));
      }).execute();
    }, r.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(t, i) {
        t.updateLayout(e, i);
      }, this);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = y2(e), this._lineData = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t) {
      this._progressiveEls = [];
      function i(s) {
        !s.isGroup && !$ge(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var n = e.start; n < e.end; n++) {
        var a = t.getItemLayout(n);
        if (S0(a)) {
          var o = new this._LineCtor(t, n, this._seriesScope);
          o.traverse(i), this.group.add(o), t.setItemGraphicEl(n, o), this._progressiveEls.push(o);
        }
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r.prototype.eachRendered = function(e) {
      Tl(this._progressiveEls || this.group, e);
    }, r.prototype._doAdd = function(e, t, i) {
      var n = e.getItemLayout(t);
      if (S0(n)) {
        var a = new this._LineCtor(e, t, i);
        e.setItemGraphicEl(t, a), this.group.add(a);
      }
    }, r.prototype._doUpdate = function(e, t, i, n, a) {
      var o = e.getItemGraphicEl(i);
      if (!S0(t.getItemLayout(n))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(t, n, a) : o = new this._LineCtor(t, n, a), t.setItemGraphicEl(n, o), this.group.add(o);
    }, r;
  }()
);
function $ge(r) {
  return r.animators && r.animators.length > 0;
}
function y2(r) {
  var e = r.hostModel, t = e.getModel("emphasis");
  return {
    lineStyle: e.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: t.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: e.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: e.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: t.get("disabled"),
    blurScope: t.get("blurScope"),
    focus: t.get("focus"),
    labelStatesModels: Cr(e)
  };
}
function R2(r) {
  return isNaN(r[0]) || isNaN(r[1]);
}
function S0(r) {
  return r && !R2(r[0]) && !R2(r[1]);
}
const Yx = Uge;
var T0 = [], y0 = [], R0 = [], Zh = Pr, A0 = Qu, A2 = Math.abs;
function C2(r, e, t) {
  for (var i = r[0], n = r[1], a = r[2], o = 1 / 0, s, l = t * t, u = 0.1, h = 0.1; h <= 0.9; h += 0.1) {
    T0[0] = Zh(i[0], n[0], a[0], h), T0[1] = Zh(i[1], n[1], a[1], h);
    var c = A2(A0(T0, e) - l);
    c < o && (o = c, s = h);
  }
  for (var f = 0; f < 32; f++) {
    var d = s + u;
    y0[0] = Zh(i[0], n[0], a[0], s), y0[1] = Zh(i[1], n[1], a[1], s), R0[0] = Zh(i[0], n[0], a[0], d), R0[1] = Zh(i[1], n[1], a[1], d);
    var c = A0(y0, e) - l;
    if (A2(c) < 0.01)
      break;
    var p = A0(R0, e) - l;
    u /= 2, c < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function C0(r, e) {
  var t = [], i = Gp, n = [[], [], []], a = [[], []], o = [];
  e /= 2, r.eachEdge(function(s, l) {
    var u = s.getLayout(), h = s.getVisual("fromSymbol"), c = s.getVisual("toSymbol");
    u.__original || (u.__original = [Do(u[0]), Do(u[1])], u[2] && u.__original.push(Do(u[2])));
    var f = u.__original;
    if (u[2] != null) {
      if (Oi(n[0], f[0]), Oi(n[1], f[2]), Oi(n[2], f[1]), h && h !== "none") {
        var d = Fd(s.node1), p = C2(n, f[0], d * e);
        i(n[0][0], n[1][0], n[2][0], p, t), n[0][0] = t[3], n[1][0] = t[4], i(n[0][1], n[1][1], n[2][1], p, t), n[0][1] = t[3], n[1][1] = t[4];
      }
      if (c && c !== "none") {
        var d = Fd(s.node2), p = C2(n, f[1], d * e);
        i(n[0][0], n[1][0], n[2][0], p, t), n[1][0] = t[1], n[2][0] = t[2], i(n[0][1], n[1][1], n[2][1], p, t), n[1][1] = t[1], n[2][1] = t[2];
      }
      Oi(u[0], n[0]), Oi(u[1], n[2]), Oi(u[2], n[1]);
    } else {
      if (Oi(a[0], f[0]), Oi(a[1], f[1]), bu(o, a[1], a[0]), mf(o, o), h && h !== "none") {
        var d = Fd(s.node1);
        CA(a[0], a[0], o, d * e);
      }
      if (c && c !== "none") {
        var d = Fd(s.node2);
        CA(a[1], a[1], o, -d * e);
      }
      Oi(u[0], a[0]), Oi(u[1], a[1]);
    }
  });
}
function _2(r) {
  return r.type === "view";
}
var Gge = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      var n = new qg(), a = new Yx(), o = this.group;
      this._controller = new ev(i.getZr()), this._controllerHost = {
        target: o
      }, o.add(n.group), o.add(a.group), this._symbolDraw = n, this._lineDraw = a, this._firstRender = !0;
    }, e.prototype.render = function(t, i, n) {
      var a = this, o = t.coordinateSystem;
      this._model = t;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (_2(o)) {
        var h = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? u.attr(h) : ft(u, h, t);
      }
      C0(t.getGraph(), Vd(t));
      var c = t.getData();
      s.updateData(c);
      var f = t.getEdgeData();
      l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(t, i, n), clearTimeout(this._layoutTimeout);
      var d = t.forceLayout, p = t.get(["force", "layoutAnimation"]);
      d && this._startForceLayoutIteration(d, p);
      var g = t.get("layout");
      c.graph.eachNode(function(E) {
        var b = E.dataIndex, T = E.getGraphicEl(), S = E.getModel();
        if (T) {
          T.off("drag").off("dragend");
          var y = S.get("draggable");
          y && T.on("drag", function(C) {
            switch (g) {
              case "force":
                d.warmUp(), !a._layouting && a._startForceLayoutIteration(d, p), d.setFixed(b), c.setItemLayout(b, [T.x, T.y]);
                break;
              case "circular":
                c.setItemLayout(b, [T.x, T.y]), E.setLayout({
                  fixed: !0
                }, !0), Fx(t, "symbolSize", E, [C.offsetX, C.offsetY]), a.updateLayout(t);
                break;
              case "none":
              default:
                c.setItemLayout(b, [T.x, T.y]), Vx(t.getGraph(), t), a.updateLayout(t);
                break;
            }
          }).on("dragend", function() {
            d && d.setUnfixed(b);
          }), T.setDraggable(y, !!S.get("cursor"));
          var A = S.get(["emphasis", "focus"]);
          A === "adjacency" && (_e(T).focus = E.getAdjacentDataIndices());
        }
      }), c.graph.eachEdge(function(E) {
        var b = E.getGraphicEl(), T = E.getModel().get(["emphasis", "focus"]);
        b && T === "adjacency" && (_e(b).focus = {
          edge: [E.dataIndex],
          node: [E.node1.dataIndex, E.node2.dataIndex]
        });
      });
      var v = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]), O = c.getLayout("cx"), m = c.getLayout("cy");
      c.graph.eachNode(function(E) {
        X3(E, v, O, m);
      }), this._firstRender = !1;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(t, i) {
      var n = this;
      (function a() {
        t.step(function(o) {
          n.updateLayout(n._model), (n._layouting = !o) && (i ? n._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, e.prototype._updateController = function(t, i, n) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      if (o.setPointerChecker(function(u, h, c) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(h, c) && !YS(u, n, t);
      }), !_2(t.coordinateSystem)) {
        o.disable();
        return;
      }
      o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        Nx(s, u.dx, u.dy), n.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        Lx(s, u.scale, u.originX, u.originY), n.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), C0(t.getGraph(), Vd(t)), a._lineDraw.updateLayout(), n.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var t = this._model, i = t.getData(), n = Vd(t);
      i.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(n);
      });
    }, e.prototype.updateLayout = function(t) {
      C0(t.getGraph(), Vd(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function(t, i) {
      this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }(Mt)
);
const Bge = Gge;
function qh(r) {
  return "_EC_" + r;
}
var Vge = (
  /** @class */
  function() {
    function r(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || !1;
    }
    return r.prototype.isDirected = function() {
      return this._directed;
    }, r.prototype.addNode = function(e, t) {
      e = e == null ? "" + t : "" + e;
      var i = this._nodesMap;
      if (!i[qh(e)]) {
        var n = new su(e, t);
        return n.hostGraph = this, this.nodes.push(n), i[qh(e)] = n, n;
      }
    }, r.prototype.getNodeByIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this.nodes[t];
    }, r.prototype.getNodeById = function(e) {
      return this._nodesMap[qh(e)];
    }, r.prototype.addEdge = function(e, t, i) {
      var n = this._nodesMap, a = this._edgesMap;
      if (ut(e) && (e = this.nodes[e]), ut(t) && (t = this.nodes[t]), e instanceof su || (e = n[qh(e)]), t instanceof su || (t = n[qh(t)]), !(!e || !t)) {
        var o = e.id + "-" + t.id, s = new H3(e, t, i);
        return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, r.prototype.getEdgeByIndex = function(e) {
      var t = this.edgeData.getRawIndex(e);
      return this.edges[t];
    }, r.prototype.getEdge = function(e, t) {
      e instanceof su && (e = e.id), t instanceof su && (t = t.id);
      var i = this._edgesMap;
      return this._directed ? i[e + "-" + t] : i[e + "-" + t] || i[t + "-" + e];
    }, r.prototype.eachNode = function(e, t) {
      for (var i = this.nodes, n = i.length, a = 0; a < n; a++)
        i[a].dataIndex >= 0 && e.call(t, i[a], a);
    }, r.prototype.eachEdge = function(e, t) {
      for (var i = this.edges, n = i.length, a = 0; a < n; a++)
        i[a].dataIndex >= 0 && i[a].node1.dataIndex >= 0 && i[a].node2.dataIndex >= 0 && e.call(t, i[a], a);
    }, r.prototype.breadthFirstTraverse = function(e, t, i, n) {
      if (t instanceof su || (t = this._nodesMap[qh(t)]), !!t) {
        for (var a = i === "out" ? "outEdges" : i === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!e.call(n, t, null))
          for (var s = [t]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var h = u[o], c = h.node1 === l ? h.node2 : h.node1;
              if (!c.__visited) {
                if (e.call(n, c, l))
                  return;
                s.push(c), c.__visited = !0;
              }
            }
      }
    }, r.prototype.update = function() {
      for (var e = this.data, t = this.edgeData, i = this.nodes, n = this.edges, a = 0, o = i.length; a < o; a++)
        i[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++)
        i[e.getRawIndex(a)].dataIndex = a;
      t.filterSelf(function(s) {
        var l = n[t.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = n.length; a < o; a++)
        n[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        n[t.getRawIndex(a)].dataIndex = a;
    }, r.prototype.clone = function() {
      for (var e = new r(this._directed), t = this.nodes, i = this.edges, n = 0; n < t.length; n++)
        e.addNode(t[n].id, t[n].dataIndex);
      for (var n = 0; n < i.length; n++) {
        var a = i[n];
        e.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return e;
    }, r;
  }()
), su = (
  /** @class */
  function() {
    function r(e, t) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1;
    }
    return r.prototype.degree = function() {
      return this.edges.length;
    }, r.prototype.inDegree = function() {
      return this.inEdges.length;
    }, r.prototype.outDegree = function() {
      return this.outEdges.length;
    }, r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, i = t.data.getItemModel(this.dataIndex);
        return i.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, t = 0; t < this.edges.length; t++) {
        var i = this.edges[t];
        i.dataIndex < 0 || (e.edge.push(i.dataIndex), e.node.push(i.node1.dataIndex, i.node2.dataIndex));
      }
      return e;
    }, r.prototype.getTrajectoryDataIndices = function() {
      for (var e = ce(), t = ce(), i = 0; i < this.edges.length; i++) {
        var n = this.edges[i];
        if (!(n.dataIndex < 0)) {
          e.set(n.dataIndex, !0);
          for (var a = [n.node1], o = [n.node2], s = 0; s < a.length; ) {
            var l = a[s];
            s++, t.set(l.dataIndex, !0);
            for (var u = 0; u < l.inEdges.length; u++)
              e.set(l.inEdges[u].dataIndex, !0), a.push(l.inEdges[u].node1);
          }
          for (s = 0; s < o.length; ) {
            var h = o[s];
            s++, t.set(h.dataIndex, !0);
            for (var u = 0; u < h.outEdges.length; u++)
              e.set(h.outEdges[u].dataIndex, !0), o.push(h.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }()
), H3 = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = i ?? -1;
    }
    return r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, i = t.edgeData.getItemModel(this.dataIndex);
        return i.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, r.prototype.getTrajectoryDataIndices = function() {
      var e = ce(), t = ce();
      e.set(this.dataIndex, !0);
      for (var i = [this.node1], n = [this.node2], a = 0; a < i.length; ) {
        var o = i[a];
        a++, t.set(o.dataIndex, !0);
        for (var s = 0; s < o.inEdges.length; s++)
          e.set(o.inEdges[s].dataIndex, !0), i.push(o.inEdges[s].node1);
      }
      for (a = 0; a < n.length; ) {
        var l = n[a];
        a++, t.set(l.dataIndex, !0);
        for (var s = 0; s < l.outEdges.length; s++)
          e.set(l.outEdges[s].dataIndex, !0), n.push(l.outEdges[s].node2);
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }()
);
function W3(r, e) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(t) {
      var i = this[r][e];
      return i.getStore().get(i.getDimensionIndex(t || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(t, i) {
      this.dataIndex >= 0 && this[r][e].setItemVisual(this.dataIndex, t, i);
    },
    getVisual: function(t) {
      return this[r][e].getItemVisual(this.dataIndex, t);
    },
    setLayout: function(t, i) {
      this.dataIndex >= 0 && this[r][e].setItemLayout(this.dataIndex, t, i);
    },
    getLayout: function() {
      return this[r][e].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[r][e].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[r][e].getRawIndex(this.dataIndex);
    }
  };
}
hr(su, W3("hostGraph", "data"));
hr(H3, W3("hostGraph", "edgeData"));
const Fge = Vge;
function z3(r, e, t, i, n) {
  for (var a = new Fge(i), o = 0; o < r.length; o++)
    a.addNode(Dr(
      // Id, name, dataIndex
      r[o].id,
      r[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < e.length; o++) {
    var h = e[o], c = h.source, f = h.target;
    a.addEdge(c, f, u) && (l.push(h), s.push(Dr(gr(h.id, null), c + " > " + f)), u++);
  }
  var d = t.get("coordinateSystem"), p;
  if (d === "cartesian2d" || d === "polar")
    p = ts(r, t);
  else {
    var g = Xg.get(d), v = g ? g.dimensions || [] : [];
    Ge(v, "value") < 0 && v.concat(["value"]);
    var O = Hg(r, {
      coordDimensions: v,
      encodeDefine: t.getEncode()
    }).dimensions;
    p = new Ai(O, t), p.initData(r);
  }
  var m = new Ai(["value"], t);
  return m.initData(l, s), n && n(p, m), x3({
    mainData: p,
    struct: a,
    structAttr: "graph",
    datas: {
      node: p,
      edge: m
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var Xge = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments);
      var i = this;
      function n() {
        return i._categoriesData;
      }
      this.legendVisualProvider = new Jg(n, n), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(t) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), eh(t, "edgeLabel", ["show"]);
    }, e.prototype.getInitialData = function(t, i) {
      var n = t.edges || t.links || [], a = t.data || t.nodes || [], o = this;
      if (a && n) {
        Age(this);
        var s = z3(a, n, this, !0, l);
        return w(s.edges, function(u) {
          Cge(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, h) {
        u.wrapMethod("getItemModel", function(p) {
          var g = o._categoriesModels, v = p.getShallow("category"), O = g[v];
          return O && (O.parentModel = p.parentModel, p.parentModel = O), p;
        });
        var c = Dt.prototype.getModel;
        function f(p, g) {
          var v = c.call(this, p, g);
          return v.resolveParentPath = d, v;
        }
        h.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = f, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(t, i, n) {
      if (n === "edge") {
        var a = this.getData(), o = this.getDataParams(t, n), s = a.graph.getEdgeByIndex(t), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), h = [];
        return l != null && h.push(l), u != null && h.push(u), _r("nameValue", {
          name: h.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var c = OH({
        series: this,
        dataIndex: t,
        multipleSeries: i
      });
      return c;
    }, e.prototype._updateCategoriesData = function() {
      var t = Y(this.option.categories || [], function(n) {
        return n.value != null ? n : V({
          value: 0
        }, n);
      }), i = new Ai(["value"], this);
      i.initData(t), this._categoriesData = i, this._categoriesModels = i.mapArray(function(n) {
        return i.getItemModel(n);
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.isAnimationEnabled = function() {
      return r.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, e.type = "series.graph", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Xt)
);
const Yge = Xge;
var Hge = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function Wge(r) {
  r.registerChartView(Bge), r.registerSeriesModel(Yge), r.registerProcessor(bge), r.registerVisual(Sge), r.registerVisual(Tge), r.registerLayout(_ge), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, xge), r.registerLayout(Pge), r.registerCoordinateSystem("graphView", {
    dimensions: tv.dimensions,
    create: Lge
  }), r.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, ar), r.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, ar), r.registerAction(Hge, function(e, t, i) {
    t.eachComponent({
      mainType: "series",
      query: e
    }, function(n) {
      var a = n.coordinateSystem, o = Mx(a, e, void 0, i);
      n.setCenter && n.setCenter(o.center), n.setZoom && n.setZoom(o.zoom);
    });
  });
}
var zge = (
  /** @class */
  function() {
    function r() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return r;
  }()
), Zge = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "pointer", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new zge();
    }, e.prototype.buildPath = function(t, i) {
      var n = Math.cos, a = Math.sin, o = i.r, s = i.width, l = i.angle, u = i.x - n(l) * s * (s >= o / 3 ? 1 : 2), h = i.y - a(l) * s * (s >= o / 3 ? 1 : 2);
      l = i.angle - Math.PI / 2, t.moveTo(u, h), t.lineTo(i.x + n(l) * s, i.y + a(l) * s), t.lineTo(i.x + n(i.angle) * o, i.y + a(i.angle) * o), t.lineTo(i.x - n(l) * s, i.y - a(l) * s), t.lineTo(u, h);
    }, e;
  }(Fe)
);
const qge = Zge;
function jge(r, e) {
  var t = r.get("center"), i = e.getWidth(), n = e.getHeight(), a = Math.min(i, n), o = K(t[0], e.getWidth()), s = K(t[1], e.getHeight()), l = K(r.get("radius"), a / 2);
  return {
    cx: o,
    cy: s,
    r: l
  };
}
function TO(r, e) {
  var t = r == null ? "" : r + "";
  return e && (ne(e) ? t = e.replace("{value}", t) : ve(e) && (t = e(r))), t;
}
var Kge = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      this.group.removeAll();
      var a = t.get(["axisLine", "lineStyle", "color"]), o = jge(t, n);
      this._renderMain(t, i, n, a, o), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.prototype._renderMain = function(t, i, n, a, o) {
      var s = this.group, l = t.get("clockwise"), u = -t.get("startAngle") / 180 * Math.PI, h = -t.get("endAngle") / 180 * Math.PI, c = t.getModel("axisLine"), f = c.get("roundCap"), d = f ? BE : Xi, p = c.get("show"), g = c.getModel("lineStyle"), v = g.get("width"), O = [u, h];
      _X(O, !l), u = O[0], h = O[1];
      for (var m = h - u, E = u, b = [], T = 0; p && T < a.length; T++) {
        var S = Math.min(Math.max(a[T][0], 0), 1);
        h = u + m * S;
        var y = new d({
          shape: {
            startAngle: E,
            endAngle: h,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - v,
            r: o.r
          },
          silent: !0
        });
        y.setStyle({
          fill: a[T][1]
        }), y.setStyle(g.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), b.push(y), E = h;
      }
      b.reverse(), w(b, function(C) {
        return s.add(C);
      });
      var A = function(C) {
        if (C <= 0)
          return a[0][1];
        var _;
        for (_ = 0; _ < a.length; _++)
          if (a[_][0] >= C && (_ === 0 ? 0 : a[_ - 1][0]) < C)
            return a[_][1];
        return a[_ - 1][1];
      };
      this._renderTicks(t, i, n, A, o, u, h, l, v), this._renderTitleAndDetail(t, i, n, A, o), this._renderAnchor(t, o), this._renderPointer(t, i, n, A, o, u, h, l, v);
    }, e.prototype._renderTicks = function(t, i, n, a, o, s, l, u, h) {
      for (var c = this.group, f = o.cx, d = o.cy, p = o.r, g = +t.get("min"), v = +t.get("max"), O = t.getModel("splitLine"), m = t.getModel("axisTick"), E = t.getModel("axisLabel"), b = t.get("splitNumber"), T = m.get("splitNumber"), S = K(O.get("length"), p), y = K(m.get("length"), p), A = s, C = (l - s) / b, _ = C / T, I = O.getModel("lineStyle").getLineStyle(), x = m.getModel("lineStyle").getLineStyle(), P = O.get("distance"), N, L, D = 0; D <= b; D++) {
        if (N = Math.cos(A), L = Math.sin(A), O.get("show")) {
          var $ = P ? P + h : h, k = new Mr({
            shape: {
              x1: N * (p - $) + f,
              y1: L * (p - $) + d,
              x2: N * (p - S - $) + f,
              y2: L * (p - S - $) + d
            },
            style: I,
            silent: !0
          });
          I.stroke === "auto" && k.setStyle({
            stroke: a(D / b)
          }), c.add(k);
        }
        if (E.get("show")) {
          var $ = E.get("distance") + P, G = TO(Kt(D / b * (v - g) + g), E.get("formatter")), F = a(D / b), q = N * (p - S - $) + f, re = L * (p - S - $) + d, fe = E.get("rotate"), de = 0;
          fe === "radial" ? (de = -A + 2 * Math.PI, de > Math.PI / 2 && (de += Math.PI)) : fe === "tangential" ? de = -A - Math.PI / 2 : ut(fe) && (de = fe * Math.PI / 180), de === 0 ? c.add(new lt({
            style: Lt(E, {
              text: G,
              x: q,
              y: re,
              verticalAlign: L < -0.8 ? "top" : L > 0.8 ? "bottom" : "middle",
              align: N < -0.4 ? "left" : N > 0.4 ? "right" : "center"
            }, {
              inheritColor: F
            }),
            silent: !0
          })) : c.add(new lt({
            style: Lt(E, {
              text: G,
              x: q,
              y: re,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: F
            }),
            silent: !0,
            originX: q,
            originY: re,
            rotation: de
          }));
        }
        if (m.get("show") && D !== b) {
          var $ = m.get("distance");
          $ = $ ? $ + h : h;
          for (var $e = 0; $e <= T; $e++) {
            N = Math.cos(A), L = Math.sin(A);
            var Pe = new Mr({
              shape: {
                x1: N * (p - $) + f,
                y1: L * (p - $) + d,
                x2: N * (p - y - $) + f,
                y2: L * (p - y - $) + d
              },
              silent: !0,
              style: x
            });
            x.stroke === "auto" && Pe.setStyle({
              stroke: a((D + $e / T) / b)
            }), c.add(Pe), A += _;
          }
          A -= _;
        } else
          A += C;
      }
    }, e.prototype._renderPointer = function(t, i, n, a, o, s, l, u, h) {
      var c = this.group, f = this._data, d = this._progressEls, p = [], g = t.get(["pointer", "show"]), v = t.getModel("progress"), O = v.get("show"), m = t.getData(), E = m.mapDimension("value"), b = +t.get("min"), T = +t.get("max"), S = [b, T], y = [s, l];
      function A(_, I) {
        var x = m.getItemModel(_), P = x.getModel("pointer"), N = K(P.get("width"), o.r), L = K(P.get("length"), o.r), D = t.get(["pointer", "icon"]), $ = P.get("offsetCenter"), k = K($[0], o.r), G = K($[1], o.r), F = P.get("keepAspect"), q;
        return D ? q = ur(D, k - N / 2, G - L, N, L, null, F) : q = new qge({
          shape: {
            angle: -Math.PI / 2,
            width: N,
            r: L,
            x: k,
            y: G
          }
        }), q.rotation = -(I + Math.PI / 2), q.x = o.cx, q.y = o.cy, q;
      }
      function C(_, I) {
        var x = v.get("roundCap"), P = x ? BE : Xi, N = v.get("overlap"), L = N ? v.get("width") : h / m.count(), D = N ? o.r - L : o.r - (_ + 1) * L, $ = N ? o.r : o.r - _ * L, k = new P({
          shape: {
            startAngle: s,
            endAngle: I,
            cx: o.cx,
            cy: o.cy,
            clockwise: u,
            r0: D,
            r: $
          }
        });
        return N && (k.z2 = T - m.get(E, _) % T), k;
      }
      (O || g) && (m.diff(f).add(function(_) {
        var I = m.get(E, _);
        if (g) {
          var x = A(_, s);
          Ut(x, {
            rotation: -((isNaN(+I) ? y[0] : Et(I, S, y, !0)) + Math.PI / 2)
          }, t), c.add(x), m.setItemGraphicEl(_, x);
        }
        if (O) {
          var P = C(_, s), N = v.get("clip");
          Ut(P, {
            shape: {
              endAngle: Et(I, S, y, N)
            }
          }, t), c.add(P), jA(t.seriesIndex, m.dataType, _, P), p[_] = P;
        }
      }).update(function(_, I) {
        var x = m.get(E, _);
        if (g) {
          var P = f.getItemGraphicEl(I), N = P ? P.rotation : s, L = A(_, N);
          L.rotation = N, ft(L, {
            rotation: -((isNaN(+x) ? y[0] : Et(x, S, y, !0)) + Math.PI / 2)
          }, t), c.add(L), m.setItemGraphicEl(_, L);
        }
        if (O) {
          var D = d[I], $ = D ? D.shape.endAngle : s, k = C(_, $), G = v.get("clip");
          ft(k, {
            shape: {
              endAngle: Et(x, S, y, G)
            }
          }, t), c.add(k), jA(t.seriesIndex, m.dataType, _, k), p[_] = k;
        }
      }).execute(), m.each(function(_) {
        var I = m.getItemModel(_), x = I.getModel("emphasis"), P = x.get("focus"), N = x.get("blurScope"), L = x.get("disabled");
        if (g) {
          var D = m.getItemGraphicEl(_), $ = m.getItemVisual(_, "style"), k = $.fill;
          if (D instanceof qr) {
            var G = D.style;
            D.useStyle(V({
              image: G.image,
              x: G.x,
              y: G.y,
              width: G.width,
              height: G.height
            }, $));
          } else
            D.useStyle($), D.type !== "pointer" && D.setColor(k);
          D.setStyle(I.getModel(["pointer", "itemStyle"]).getItemStyle()), D.style.fill === "auto" && D.setStyle("fill", a(Et(m.get(E, _), S, [0, 1], !0))), D.z2EmphasisLift = 0, zr(D, I), zt(D, P, N, L);
        }
        if (O) {
          var F = p[_];
          F.useStyle(m.getItemVisual(_, "style")), F.setStyle(I.getModel(["progress", "itemStyle"]).getItemStyle()), F.z2EmphasisLift = 0, zr(F, I), zt(F, P, N, L);
        }
      }), this._progressEls = p);
    }, e.prototype._renderAnchor = function(t, i) {
      var n = t.getModel("anchor"), a = n.get("show");
      if (a) {
        var o = n.get("size"), s = n.get("icon"), l = n.get("offsetCenter"), u = n.get("keepAspect"), h = ur(s, i.cx - o / 2 + K(l[0], i.r), i.cy - o / 2 + K(l[1], i.r), o, o, null, u);
        h.z2 = n.get("showAbove") ? 1 : 0, h.setStyle(n.getModel("itemStyle").getItemStyle()), this.group.add(h);
      }
    }, e.prototype._renderTitleAndDetail = function(t, i, n, a, o) {
      var s = this, l = t.getData(), u = l.mapDimension("value"), h = +t.get("min"), c = +t.get("max"), f = new ye(), d = [], p = [], g = t.isAnimationEnabled(), v = t.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(O) {
        d[O] = new lt({
          silent: !0
        }), p[O] = new lt({
          silent: !0
        });
      }).update(function(O, m) {
        d[O] = s._titleEls[m], p[O] = s._detailEls[m];
      }).execute(), l.each(function(O) {
        var m = l.getItemModel(O), E = l.get(u, O), b = new ye(), T = a(Et(E, [h, c], [0, 1], !0)), S = m.getModel("title");
        if (S.get("show")) {
          var y = S.get("offsetCenter"), A = o.cx + K(y[0], o.r), C = o.cy + K(y[1], o.r), _ = d[O];
          _.attr({
            z2: v ? 0 : 2,
            style: Lt(S, {
              x: A,
              y: C,
              text: l.getName(O),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: T
            })
          }), b.add(_);
        }
        var I = m.getModel("detail");
        if (I.get("show")) {
          var x = I.get("offsetCenter"), P = o.cx + K(x[0], o.r), N = o.cy + K(x[1], o.r), L = K(I.get("width"), o.r), D = K(I.get("height"), o.r), $ = t.get(["progress", "show"]) ? l.getItemVisual(O, "style").fill : T, _ = p[O], k = I.get("formatter");
          _.attr({
            z2: v ? 0 : 2,
            style: Lt(I, {
              x: P,
              y: N,
              text: TO(E, k),
              width: isNaN(L) ? null : L,
              height: isNaN(D) ? null : D,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: $
            })
          }), EY(_, {
            normal: I
          }, E, function(F) {
            return TO(F, k);
          }), g && bY(_, O, l, t, {
            getFormattedLabel: function(F, q, re, fe, de, $e) {
              return TO($e ? $e.interpolatedValue : E, k);
            }
          }), b.add(_);
        }
        f.add(b);
      }), this.group.add(f), this._titleEls = d, this._detailEls = p;
    }, e.type = "gauge", e;
  }(Mt)
);
const Jge = Kge;
var eve = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return Lf(this, ["value"]);
    }, e.type = "series.gauge", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 
      min: 0,
      // 
      max: 100,
      // 10
      splitNumber: 10,
      // 
      axisLine: {
        // show
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 
      progress: {
        // show
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 
      splitLine: {
        // show
        show: !0,
        // length
        length: 10,
        distance: 10,
        // lineStylelineStyle
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 
      axisTick: {
        // show
        show: !0,
        // split
        splitNumber: 5,
        // length
        length: 6,
        distance: 10,
        // lineStyle
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, ypx
        offsetCenter: [0, "20%"],
        // TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, ypx
        offsetCenter: [0, "40%"],
        // formatter: null,
        // TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, e;
  }(Xt)
);
const tve = eve;
function rve(r) {
  r.registerChartView(Jge), r.registerSeriesModel(tve);
}
var ive = ["itemStyle", "opacity"], nve = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i) {
      var n = r.call(this) || this, a = n, o = new Wi(), s = new lt();
      return a.setTextContent(s), n.setTextGuideLine(o), n.updateData(t, i, !0), n;
    }
    return e.prototype.updateData = function(t, i, n) {
      var a = this, o = t.hostModel, s = t.getItemModel(i), l = t.getItemLayout(i), u = s.getModel("emphasis"), h = s.get(ive);
      h = h ?? 1, n || ba(a), a.useStyle(t.getItemVisual(i, "style")), a.style.lineJoin = "round", n ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, Ut(a, {
        style: {
          opacity: h
        }
      }, o, i)) : ft(a, {
        style: {
          opacity: h
        },
        shape: {
          points: l.points
        }
      }, o, i), zr(a, s), this._updateLabel(t, i), zt(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, i) {
      var n = this, a = this.getTextGuideLine(), o = n.getTextContent(), s = t.hostModel, l = t.getItemModel(i), u = t.getItemLayout(i), h = u.label, c = t.getItemVisual(i, "style"), f = c.fill;
      Zr(
        // position will not be used in setLabelStyle
        o,
        Cr(l),
        {
          labelFetcher: t.hostModel,
          labelDataIndex: i,
          defaultOpacity: c.opacity,
          defaultText: t.getName(i)
        },
        {
          normal: {
            align: h.textAlign,
            verticalAlign: h.verticalAlign
          }
        }
      ), n.setTextConfig({
        local: !0,
        inside: !!h.inside,
        insideStroke: f,
        // insideFill: 'auto',
        outsideFill: f
      });
      var d = h.linePoints;
      a.setShape({
        points: d
      }), n.textGuideLineConfig = {
        anchor: d ? new Le(d[0][0], d[0][1]) : null
      }, ft(o, {
        style: {
          x: h.x,
          y: h.y
        }
      }, s, i), o.attr({
        rotation: h.rotation,
        originX: h.x,
        originY: h.y,
        z2: 10
      }), Tx(n, yx(l), {
        // Default use item visual color
        stroke: f
      });
    }, e;
  }(Yi)
), ave = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._data, s = this.group;
      a.diff(o).add(function(l) {
        var u = new nve(a, l);
        a.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var h = o.getItemGraphicEl(u);
        h.updateData(a, l), s.add(h), a.setItemGraphicEl(l, h);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        Wp(u, t, l);
      }).execute(), this._data = a;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.prototype.dispose = function() {
    }, e.type = "funnel", e;
  }(Mt)
);
const ove = ave;
var sve = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Jg(ae(this.getData, this), ae(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.getInitialData = function(t, i) {
      return Lf(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Ie(JI, this)
      });
    }, e.prototype._defaultLabelLine = function(t) {
      eh(t, "labelLine", ["show"]);
      var i = t.labelLine, n = t.emphasis.labelLine;
      i.show = i.show && t.label.show, n.show = n.show && t.emphasis.label.show;
    }, e.prototype.getDataParams = function(t) {
      var i = this.getData(), n = r.prototype.getDataParams.call(this, t), a = i.mapDimension("value"), o = i.getSum(a);
      return n.percent = o ? +(i.get(a, t) / o * 100).toFixed(2) : 0, n.$vars.push("percent"), n;
    }, e.type = "series.funnel", e.defaultOption = {
      // zlevel: 0,                  // 
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: Tooltip.formatter
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: ,
          width: 1
        }
      },
      itemStyle: {
        // color: ,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Xt)
);
const lve = sve;
function uve(r, e) {
  return mr(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function hve(r, e) {
  for (var t = r.mapDimension("value"), i = r.mapArray(t, function(l) {
    return l;
  }), n = [], a = e === "ascending", o = 0, s = r.count(); o < s; o++)
    n[o] = o;
  return ve(e) ? n.sort(e) : e !== "none" && n.sort(function(l, u) {
    return a ? i[l] - i[u] : i[u] - i[l];
  }), n;
}
function cve(r) {
  var e = r.hostModel, t = e.get("orient");
  r.each(function(i) {
    var n = r.getItemModel(i), a = n.getModel("label"), o = a.get("position"), s = n.getModel("labelLine"), l = r.getItemLayout(i), u = l.points, h = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", c, f, d, p;
    if (h)
      o === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, c = "left") : o === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, c = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, c = "center"), p = [[f, d], [f, d]];
    else {
      var g = void 0, v = void 0, O = void 0, m = void 0, E = s.get("length");
      o === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, O = g - E, f = O - 5, c = "right") : o === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, O = g + E, f = O + 5, c = "left") : o === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = v - E, d = m - 5, c = "center") : o === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = v + E, d = m + 5, c = "center") : o === "rightTop" ? (g = t === "horizontal" ? u[3][0] : u[1][0], v = t === "horizontal" ? u[3][1] : u[1][1], t === "horizontal" ? (m = v - E, d = m - 5, c = "center") : (O = g + E, f = O + 5, c = "top")) : o === "rightBottom" ? (g = u[2][0], v = u[2][1], t === "horizontal" ? (m = v + E, d = m + 5, c = "center") : (O = g + E, f = O + 5, c = "bottom")) : o === "leftTop" ? (g = u[0][0], v = t === "horizontal" ? u[0][1] : u[1][1], t === "horizontal" ? (m = v - E, d = m - 5, c = "center") : (O = g - E, f = O - 5, c = "right")) : o === "leftBottom" ? (g = t === "horizontal" ? u[1][0] : u[3][0], v = t === "horizontal" ? u[1][1] : u[2][1], t === "horizontal" ? (m = v + E, d = m + 5, c = "center") : (O = g - E, f = O - 5, c = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, t === "horizontal" ? (m = v + E, d = m + 5, c = "center") : (O = g + E, f = O + 5, c = "left")), t === "horizontal" ? (O = g, f = O) : (m = v, d = m), p = [[g, v], [O, m]];
    }
    l.label = {
      linePoints: p,
      x: f,
      y: d,
      verticalAlign: "middle",
      textAlign: c,
      inside: h
    };
  });
}
function fve(r, e) {
  r.eachSeriesByType("funnel", function(t) {
    var i = t.getData(), n = i.mapDimension("value"), a = t.get("sort"), o = uve(t, e), s = t.get("orient"), l = o.width, u = o.height, h = hve(i, a), c = o.x, f = o.y, d = s === "horizontal" ? [K(t.get("minSize"), u), K(t.get("maxSize"), u)] : [K(t.get("minSize"), l), K(t.get("maxSize"), l)], p = i.getDataExtent(n), g = t.get("min"), v = t.get("max");
    g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1]);
    var O = t.get("funnelAlign"), m = t.get("gap"), E = s === "horizontal" ? l : u, b = (E - m * (i.count() - 1)) / i.count(), T = function(N, L) {
      if (s === "horizontal") {
        var D = i.get(n, N) || 0, $ = Et(D, [g, v], d, !0), k = void 0;
        switch (O) {
          case "top":
            k = f;
            break;
          case "center":
            k = f + (u - $) / 2;
            break;
          case "bottom":
            k = f + (u - $);
            break;
        }
        return [[L, k], [L, k + $]];
      }
      var G = i.get(n, N) || 0, F = Et(G, [g, v], d, !0), q;
      switch (O) {
        case "left":
          q = c;
          break;
        case "center":
          q = c + (l - F) / 2;
          break;
        case "right":
          q = c + l - F;
          break;
      }
      return [[q, L], [q + F, L]];
    };
    a === "ascending" && (b = -b, m = -m, s === "horizontal" ? c += l : f += u, h = h.reverse());
    for (var S = 0; S < h.length; S++) {
      var y = h[S], A = h[S + 1], C = i.getItemModel(y);
      if (s === "horizontal") {
        var _ = C.get(["itemStyle", "width"]);
        _ == null ? _ = b : (_ = K(_, l), a === "ascending" && (_ = -_));
        var I = T(y, c), x = T(A, c + _);
        c += _ + m, i.setItemLayout(y, {
          points: I.concat(x.slice().reverse())
        });
      } else {
        var P = C.get(["itemStyle", "height"]);
        P == null ? P = b : (P = K(P, u), a === "ascending" && (P = -P));
        var I = T(y, f), x = T(A, f + P);
        f += P + m, i.setItemLayout(y, {
          points: I.concat(x.slice().reverse())
        });
      }
    }
    cve(i);
  });
}
function dve(r) {
  r.registerChartView(ove), r.registerSeriesModel(lve), r.registerLayout(fve), r.registerProcessor(Kg("funnel"));
}
var pve = 0.3, gve = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._dataGroup = new ye(), t._initialized = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, e.prototype.render = function(t, i, n, a) {
      this._progressiveEls = null;
      var o = this._dataGroup, s = t.getData(), l = this._data, u = t.coordinateSystem, h = u.dimensions, c = x2(t);
      s.diff(l).add(f).update(d).remove(p).execute();
      function f(v) {
        var O = I2(s, o, v, h, u);
        _0(O, s, v, c);
      }
      function d(v, O) {
        var m = l.getItemGraphicEl(O), E = Z3(s, v, h, u);
        s.setItemGraphicEl(v, m), ft(m, {
          shape: {
            points: E
          }
        }, t, v), ba(m), _0(m, s, v, c);
      }
      function p(v) {
        var O = l.getItemGraphicEl(v);
        o.remove(O);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var g = vve(u, t, function() {
          setTimeout(function() {
            o.removeClipPath();
          });
        });
        o.setClipPath(g);
      }
      this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, e.prototype.incrementalRender = function(t, i, n) {
      for (var a = i.getData(), o = i.coordinateSystem, s = o.dimensions, l = x2(i), u = this._progressiveEls = [], h = t.start; h < t.end; h++) {
        var c = I2(a, this._dataGroup, h, s, o);
        c.incremental = !0, _0(c, a, h, l), u.push(c);
      }
    }, e.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, e.type = "parallel", e;
  }(Mt)
);
function vve(r, e, t) {
  var i = r.model, n = r.getRect(), a = new nt({
    shape: {
      x: n.x,
      y: n.y,
      width: n.width,
      height: n.height
    }
  }), o = i.get("layout") === "horizontal" ? "width" : "height";
  return a.setShape(o, 0), Ut(a, {
    shape: {
      width: n.width,
      height: n.height
    }
  }, e, t), a;
}
function Z3(r, e, t, i) {
  for (var n = [], a = 0; a < t.length; a++) {
    var o = t[a], s = r.get(r.mapDimension(o), e);
    Ove(s, i.getAxis(o).type) || n.push(i.dataToPoint(s, o));
  }
  return n;
}
function I2(r, e, t, i, n) {
  var a = Z3(r, t, i, n), o = new Wi({
    shape: {
      points: a
    },
    // silent: true,
    z2: 10
  });
  return e.add(o), r.setItemGraphicEl(t, o), o;
}
function x2(r) {
  var e = r.get("smooth", !0);
  return e === !0 && (e = pve), e = Fo(e), $p(e) && (e = 0), {
    smooth: e
  };
}
function _0(r, e, t, i) {
  r.useStyle(e.getItemVisual(t, "style")), r.style.fill = null, r.setShape("smooth", i.smooth);
  var n = e.getItemModel(t), a = n.getModel("emphasis");
  zr(r, n, "lineStyle"), zt(r, a.get("focus"), a.get("blurScope"), a.get("disabled"));
}
function Ove(r, e) {
  return e === "category" ? r == null : r == null || isNaN(r);
}
const mve = gve;
var Eve = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return ts(null, this, {
        useEncodeDefaulter: ae(bve, null, this)
      });
    }, e.prototype.getRawIndicesByActiveState = function(t) {
      var i = this.coordinateSystem, n = this.getData(), a = [];
      return i.eachActiveState(n, function(o, s) {
        t === o && a.push(n.getRawIndex(s));
      }), a;
    }, e.type = "series.parallel", e.dependencies = ["parallel"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, e;
  }(Xt)
);
function bve(r) {
  var e = r.ecModel.getComponent("parallel", r.get("parallelIndex"));
  if (e) {
    var t = {};
    return w(e.dimensions, function(i) {
      var n = Sve(i);
      t[i] = n;
    }), t;
  }
}
function Sve(r) {
  return +r.replace("dim", "");
}
const Tve = Eve;
var yve = ["lineStyle", "opacity"], Rve = {
  seriesType: "parallel",
  reset: function(r, e) {
    var t = r.coordinateSystem, i = {
      normal: r.get(["lineStyle", "opacity"]),
      active: r.get("activeOpacity"),
      inactive: r.get("inactiveOpacity")
    };
    return {
      progress: function(n, a) {
        t.eachActiveState(a, function(o, s) {
          var l = i[o];
          if (o === "normal" && a.hasItemOption) {
            var u = a.getItemModel(s).get(yve, !0);
            u != null && (l = u);
          }
          var h = a.ensureUniqueItemVisual(s, "style");
          h.opacity = l;
        }, n.start, n.end);
      }
    };
  }
};
const Ave = Rve;
function Cve(r) {
  _ve(r), Ive(r);
}
function _ve(r) {
  if (!r.parallel) {
    var e = !1;
    w(r.series, function(t) {
      t && t.type === "parallel" && (e = !0);
    }), e && (r.parallel = [{}]);
  }
}
function Ive(r) {
  var e = At(r.parallelAxis);
  w(e, function(t) {
    if (be(t)) {
      var i = t.parallelIndex || 0, n = At(r.parallel)[i];
      n && n.parallelAxisDefault && Qe(t, n.parallelAxisDefault, !1);
    }
  });
}
var xve = 5, wve = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      this._model = t, this._api = n, this._handlers || (this._handlers = {}, w(Pve, function(a, o) {
        n.getZr().on(o, this._handlers[o] = ae(a, this));
      }, this)), Pf(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
    }, e.prototype.dispose = function(t, i) {
      Kp(this, "_throttledDispatchExpand"), w(this._handlers, function(n, a) {
        i.getZr().off(a, n);
      }), this._handlers = null;
    }, e.prototype._throttledDispatchExpand = function(t) {
      this._dispatchExpand(t);
    }, e.prototype._dispatchExpand = function(t) {
      t && this._api.dispatchAction(V({
        type: "parallelAxisExpand"
      }, t));
    }, e.type = "parallel", e;
  }(Zt)
), Pve = {
  mousedown: function(r) {
    I0(this, "click") && (this._mouseDownPoint = [r.offsetX, r.offsetY]);
  },
  mouseup: function(r) {
    var e = this._mouseDownPoint;
    if (I0(this, "click") && e) {
      var t = [r.offsetX, r.offsetY], i = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
      if (i > xve)
        return;
      var n = this._model.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]);
      n.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: n.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(r) {
    if (!(this._mouseDownPoint || !I0(this, "mousemove"))) {
      var e = this._model, t = e.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]), i = t.behavior;
      i === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(i === "none" ? null : {
        axisExpandWindow: t.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: i === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function I0(r, e) {
  var t = r._model;
  return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e;
}
const Nve = wve;
var Lve = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      r.prototype.init.apply(this, arguments), this.mergeOption({});
    }, e.prototype.mergeOption = function(t) {
      var i = this.option;
      t && Qe(i, t, !0), this._initDimensions();
    }, e.prototype.contains = function(t, i) {
      var n = t.get("parallelIndex");
      return n != null && i.getComponent("parallel", n) === this;
    }, e.prototype.setAxisExpand = function(t) {
      w(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(i) {
        t.hasOwnProperty(i) && (this.option[i] = t[i]);
      }, this);
    }, e.prototype._initDimensions = function() {
      var t = this.dimensions = [], i = this.parallelAxisIndex = [], n = yt(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      w(n, function(a) {
        t.push("dim" + a.get("dim")), i.push(a.componentIndex);
      });
    }, e.type = "parallel", e.dependencies = ["parallelAxis"], e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, e;
  }(ot)
);
const Dve = Lve;
var Mve = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n, a, o) {
      var s = r.call(this, t, i, n) || this;
      return s.type = a || "value", s.axisIndex = o, s;
    }
    return e.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, e;
  }(Ta)
);
const kve = Mve;
function Ch(r, e, t, i, n, a) {
  r = r || 0;
  var o = t[1] - t[0];
  if (n != null && (n = jh(n, [0, o])), a != null && (a = Math.max(a, n ?? 0)), i === "all") {
    var s = Math.abs(e[1] - e[0]);
    s = jh(s, [0, o]), n = a = jh(s, [n, a]), i = 0;
  }
  e[0] = jh(e[0], t), e[1] = jh(e[1], t);
  var l = x0(e, i);
  e[i] += r;
  var u = n || 0, h = t.slice();
  l.sign < 0 ? h[0] += u : h[1] -= u, e[i] = jh(e[i], h);
  var c;
  return c = x0(e, i), n != null && (c.sign !== l.sign || c.span < n) && (e[1 - i] = e[i] + l.sign * n), c = x0(e, i), a != null && c.span > a && (e[1 - i] = e[i] + c.sign * a), e;
}
function x0(r, e) {
  var t = r[e] - r[1 - e];
  return {
    span: Math.abs(t),
    sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
  };
}
function jh(r, e) {
  return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, r));
}
var w0 = w, q3 = Math.min, j3 = Math.max, w2 = Math.floor, Qve = Math.ceil, P2 = Kt, Uve = Math.PI, $ve = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "parallel", this._axesMap = ce(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, i);
    }
    return r.prototype._init = function(e, t, i) {
      var n = e.dimensions, a = e.parallelAxisIndex;
      w0(n, function(o, s) {
        var l = a[s], u = t.getComponent("parallelAxis", l), h = this._axesMap.set(o, new kve(o, VS(u), [0, 0], u.get("type"), l)), c = h.type === "category";
        h.onBand = c && u.get("boundaryGap"), h.inverse = u.get("inverse"), u.axis = h, h.model = u, h.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, r.prototype.update = function(e, t) {
      this._updateAxesFromSeries(this._model, e);
    }, r.prototype.containPoint = function(e) {
      var t = this._makeLayoutInfo(), i = t.axisBase, n = t.layoutBase, a = t.pixelDimIndex, o = e[1 - a], s = e[a];
      return o >= i && o <= i + t.axisLength && s >= n && s <= n + t.layoutLength;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype._updateAxesFromSeries = function(e, t) {
      t.eachSeries(function(i) {
        if (e.contains(i, t)) {
          var n = i.getData();
          w0(this.dimensions, function(a) {
            var o = this._axesMap.get(a);
            o.scale.unionExtentFromData(n, n.mapDimension(a)), ef(o.scale, o.model);
          }, this);
        }
      }, this);
    }, r.prototype.resize = function(e, t) {
      this._rect = mr(e.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._layoutAxes();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._makeLayoutInfo = function() {
      var e = this._model, t = this._rect, i = ["x", "y"], n = ["width", "height"], a = e.get("layout"), o = a === "horizontal" ? 0 : 1, s = t[n[o]], l = [0, s], u = this.dimensions.length, h = yO(e.get("axisExpandWidth"), l), c = yO(e.get("axisExpandCount") || 0, [0, u]), f = e.get("axisExpandable") && u > 3 && u > c && c > 1 && h > 0 && s > 0, d = e.get("axisExpandWindow"), p;
      if (d)
        p = yO(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = yO(h * (c - 1), l);
        var g = e.get("axisExpandCenter") || w2(u / 2);
        d = [h * g - p / 2], d[1] = d[0] + p;
      }
      var v = (s - p) / (u - c);
      v < 3 && (v = 0);
      var O = [w2(P2(d[0] / h, 1)) + 1, Qve(P2(d[1] / h, 1)) - 1], m = v / h * d[0];
      return {
        layout: a,
        pixelDimIndex: o,
        layoutBase: t[i[o]],
        layoutLength: s,
        axisBase: t[i[1 - o]],
        axisLength: t[n[1 - o]],
        axisExpandable: f,
        axisExpandWidth: h,
        axisCollapseWidth: v,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: O,
        axisExpandWindow0Pos: m
      };
    }, r.prototype._layoutAxes = function() {
      var e = this._rect, t = this._axesMap, i = this.dimensions, n = this._makeLayoutInfo(), a = n.layout;
      t.each(function(o) {
        var s = [0, n.axisLength], l = o.inverse ? 1 : 0;
        o.setExtent(s[l], s[1 - l]);
      }), w0(i, function(o, s) {
        var l = (n.axisExpandable ? Bve : Gve)(s, n), u = {
          horizontal: {
            x: l.position,
            y: n.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, h = {
          horizontal: Uve / 2,
          vertical: 0
        }, c = [u[a].x + e.x, u[a].y + e.y], f = h[a], d = Zn();
        bh(d, d, f), ao(d, d, c), this._axesLayout[o] = {
          position: c,
          rotation: f,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, r.prototype.getAxis = function(e) {
      return this._axesMap.get(e);
    }, r.prototype.dataToPoint = function(e, t) {
      return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t);
    }, r.prototype.eachActiveState = function(e, t, i, n) {
      i == null && (i = 0), n == null && (n = e.count());
      var a = this._axesMap, o = this.dimensions, s = [], l = [];
      w(o, function(v) {
        s.push(e.mapDimension(v)), l.push(a.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), h = i; h < n; h++) {
        var c = void 0;
        if (!u)
          c = "normal";
        else {
          c = "active";
          for (var f = e.getValues(s, h), d = 0, p = o.length; d < p; d++) {
            var g = l[d].getActiveState(f[d]);
            if (g === "inactive") {
              c = "inactive";
              break;
            }
          }
        }
        t(c, h);
      }
    }, r.prototype.hasAxisBrushed = function() {
      for (var e = this.dimensions, t = this._axesMap, i = !1, n = 0, a = e.length; n < a; n++)
        t.get(e[n]).model.getActiveState() !== "normal" && (i = !0);
      return i;
    }, r.prototype.axisCoordToPoint = function(e, t) {
      var i = this._axesLayout[t];
      return Oa([e, 0], i.transform);
    }, r.prototype.getAxisLayout = function(e) {
      return Se(this._axesLayout[e]);
    }, r.prototype.getSlidedAxisExpandWindow = function(e) {
      var t = this._makeLayoutInfo(), i = t.pixelDimIndex, n = t.axisExpandWindow.slice(), a = n[1] - n[0], o = [0, t.axisExpandWidth * (t.axisCount - 1)];
      if (!this.containPoint(e))
        return {
          behavior: "none",
          axisExpandWindow: n
        };
      var s = e[i] - t.layoutBase - t.axisExpandWindow0Pos, l, u = "slide", h = t.axisCollapseWidth, c = this._model.get("axisExpandSlideTriggerArea"), f = c[0] != null;
      if (h)
        f && h && s < a * c[0] ? (u = "jump", l = s - a * c[2]) : f && h && s > a * (1 - c[0]) ? (u = "jump", l = s - a * (1 - c[2])) : (l = s - a * c[1]) >= 0 && (l = s - a * (1 - c[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / h, l ? Ch(l, n, o, "all") : u = "none";
      else {
        var d = n[1] - n[0], p = o[1] * s / d;
        n = [j3(0, p - d / 2)], n[1] = q3(o[1], n[0] + d), n[0] = n[1] - d;
      }
      return {
        axisExpandWindow: n,
        behavior: u
      };
    }, r;
  }()
);
function yO(r, e) {
  return q3(j3(r, e[0]), e[1]);
}
function Gve(r, e) {
  var t = e.layoutLength / (e.axisCount - 1);
  return {
    position: t * r,
    axisNameAvailableWidth: t,
    axisLabelShow: !0
  };
}
function Bve(r, e) {
  var t = e.layoutLength, i = e.axisExpandWidth, n = e.axisCount, a = e.axisCollapseWidth, o = e.winInnerIndices, s, l = a, u = !1, h;
  return r < o[0] ? (s = r * a, h = a) : r <= o[1] ? (s = e.axisExpandWindow0Pos + r * i - e.axisExpandWindow[0], l = i, u = !0) : (s = t - (n - 1 - r) * a, h = a), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: h
  };
}
const Vve = $ve;
function Fve(r, e) {
  var t = [];
  return r.eachComponent("parallel", function(i, n) {
    var a = new Vve(i, r, e);
    a.name = "parallel_" + n, a.resize(i, e), i.coordinateSystem = a, a.model = i, t.push(a);
  }), r.eachSeries(function(i) {
    if (i.get("coordinateSystem") === "parallel") {
      var n = i.getReferringComponents("parallel", lr).models[0];
      i.coordinateSystem = n.coordinateSystem;
    }
  }), t;
}
var Xve = {
  create: Fve
};
const Yve = Xve;
var K3 = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.activeIntervals = [], t;
    }
    return e.prototype.getAreaSelectStyle = function() {
      return rh([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, e.prototype.setActiveIntervals = function(t) {
      var i = this.activeIntervals = Se(t);
      if (i)
        for (var n = i.length - 1; n >= 0; n--)
          $n(i[n]);
    }, e.prototype.getActiveState = function(t) {
      var i = this.activeIntervals;
      if (!i.length)
        return "normal";
      if (t == null || isNaN(+t))
        return "inactive";
      if (i.length === 1) {
        var n = i[0];
        if (n[0] <= t && t <= n[1])
          return "active";
      } else
        for (var a = 0, o = i.length; a < o; a++)
          if (i[a][0] <= t && t <= i[a][1])
            return "active";
      return "inactive";
    }, e;
  }(ot)
);
hr(K3, zg);
const N2 = K3;
var ah = !0, ug = Math.min, nf = Math.max, Hve = Math.pow, Wve = 1e4, zve = 6, Zve = 6, L2 = "globalPan", qve = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, jve = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, D2 = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, Kve = 0, Jve = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this) || this;
      return i._track = [], i._covers = [], i._handlers = {}, i._zr = t, i.group = new ye(), i._uid = "brushController_" + Kve++, w(oOe, function(n, a) {
        this._handlers[a] = ae(n, this);
      }, i), i;
    }
    return e.prototype.enableBrush = function(t) {
      return this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this;
    }, e.prototype._doEnableBrush = function(t) {
      var i = this._zr;
      this._enableGlobalPan || ude(i, L2, this._uid), w(this._handlers, function(n, a) {
        i.on(a, n);
      }), this._brushType = t.brushType, this._brushOption = Qe(Se(D2), t, !0);
    }, e.prototype._doDisableBrush = function() {
      var t = this._zr;
      hde(t, L2, this._uid), w(this._handlers, function(i, n) {
        t.off(n, i);
      }), this._brushType = this._brushOption = null;
    }, e.prototype.setPanels = function(t) {
      if (t && t.length) {
        var i = this._panels = {};
        w(t, function(n) {
          i[n.panelId] = Se(n);
        });
      } else
        this._panels = null;
      return this;
    }, e.prototype.mount = function(t) {
      t = t || {}, this._enableGlobalPan = t.enableGlobalPan;
      var i = this.group;
      return this._zr.add(i), i.attr({
        x: t.x || 0,
        y: t.y || 0,
        rotation: t.rotation || 0,
        scaleX: t.scaleX || 1,
        scaleY: t.scaleY || 1
      }), this._transform = i.getLocalTransform(), this;
    }, e.prototype.updateCovers = function(t) {
      t = Y(t, function(f) {
        return Qe(Se(D2), f, !0);
      });
      var i = "\0-brush-index-", n = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
      return new Ho(n, t, u, l).add(h).update(h).remove(c).execute(), this;
      function l(f, d) {
        return (f.id != null ? f.id : i + d) + "-" + f.brushType;
      }
      function u(f, d) {
        return l(f.__brushOption, d);
      }
      function h(f, d) {
        var p = t[f];
        if (d != null && n[d] === s)
          a[f] = n[d];
        else {
          var g = a[f] = d != null ? (n[d].__brushOption = p, n[d]) : ez(o, J3(o, p));
          Hx(o, g);
        }
      }
      function c(f) {
        n[f] !== s && o.group.remove(n[f]);
      }
    }, e.prototype.unmount = function() {
      return this.enableBrush(!1), GC(this), this._zr.remove(this.group), this;
    }, e.prototype.dispose = function() {
      this.unmount(), this.off();
    }, e;
  }(jn)
);
function J3(r, e) {
  var t = ZS[e.brushType].createCover(r, e);
  return t.__brushOption = e, rz(t, e), r.group.add(t), t;
}
function ez(r, e) {
  var t = Wx(e);
  return t.endCreating && (t.endCreating(r, e), rz(e, e.__brushOption)), e;
}
function tz(r, e) {
  var t = e.__brushOption;
  Wx(e).updateCoverShape(r, e, t.range, t);
}
function rz(r, e) {
  var t = e.z;
  t == null && (t = Wve), r.traverse(function(i) {
    i.z = t, i.z2 = t;
  });
}
function Hx(r, e) {
  Wx(e).updateCommon(r, e), tz(r, e);
}
function Wx(r) {
  return ZS[r.__brushOption.brushType];
}
function zx(r, e, t) {
  var i = r._panels;
  if (!i)
    return ah;
  var n, a = r._transform;
  return w(i, function(o) {
    o.isTargetByCursor(e, t, a) && (n = o);
  }), n;
}
function iz(r, e) {
  var t = r._panels;
  if (!t)
    return ah;
  var i = e.__brushOption.panelId;
  return i != null ? t[i] : ah;
}
function GC(r) {
  var e = r._covers, t = e.length;
  return w(e, function(i) {
    r.group.remove(i);
  }, r), e.length = 0, !!t;
}
function oh(r, e) {
  var t = Y(r._covers, function(i) {
    var n = i.__brushOption, a = Se(n.range);
    return {
      brushType: n.brushType,
      panelId: n.panelId,
      range: a
    };
  });
  r.trigger("brush", {
    areas: t,
    isEnd: !!e.isEnd,
    removeOnClick: !!e.removeOnClick
  });
}
function eOe(r) {
  var e = r._track;
  if (!e.length)
    return !1;
  var t = e[e.length - 1], i = e[0], n = t[0] - i[0], a = t[1] - i[1], o = Hve(n * n + a * a, 0.5);
  return o > zve;
}
function nz(r) {
  var e = r.length - 1;
  return e < 0 && (e = 0), [r[0], r[e]];
}
function az(r, e, t, i) {
  var n = new ye();
  return n.add(new nt({
    name: "main",
    style: Zx(t),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: Ie(M2, r, e, n, ["n", "s", "w", "e"]),
    ondragend: Ie(oh, e, {
      isEnd: !0
    })
  })), w(i, function(a) {
    n.add(new nt({
      name: a.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: Ie(M2, r, e, n, a),
      ondragend: Ie(oh, e, {
        isEnd: !0
      })
    }));
  }), n;
}
function oz(r, e, t, i) {
  var n = i.brushStyle.lineWidth || 0, a = nf(n, Zve), o = t[0][0], s = t[1][0], l = o - n / 2, u = s - n / 2, h = t[0][1], c = t[1][1], f = h - a + n / 2, d = c - a + n / 2, p = h - o, g = c - s, v = p + n, O = g + n;
  yo(r, e, "main", o, s, p, g), i.transformable && (yo(r, e, "w", l, u, a, O), yo(r, e, "e", f, u, a, O), yo(r, e, "n", l, u, v, a), yo(r, e, "s", l, d, v, a), yo(r, e, "nw", l, u, a, a), yo(r, e, "ne", f, u, a, a), yo(r, e, "sw", l, d, a, a), yo(r, e, "se", f, d, a, a));
}
function BC(r, e) {
  var t = e.__brushOption, i = t.transformable, n = e.childAt(0);
  n.useStyle(Zx(t)), n.attr({
    silent: !i,
    cursor: i ? "move" : "default"
  }), w([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(a) {
    var o = e.childOfName(a.join("")), s = a.length === 1 ? VC(r, a[0]) : rOe(r, a);
    o && o.attr({
      silent: !i,
      invisible: !i,
      cursor: i ? jve[s] + "-resize" : null
    });
  });
}
function yo(r, e, t, i, n, a, o) {
  var s = e.childOfName(t);
  s && s.setShape(nOe(qx(r, e, [[i, n], [i + a, n + o]])));
}
function Zx(r) {
  return me({
    strokeNoScale: !0
  }, r.brushStyle);
}
function sz(r, e, t, i) {
  var n = [ug(r, t), ug(e, i)], a = [nf(r, t), nf(e, i)];
  return [
    [n[0], a[0]],
    [n[1], a[1]]
    // y range
  ];
}
function tOe(r) {
  return Vu(r.group);
}
function VC(r, e) {
  var t = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, i = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, n = _S(t[e], tOe(r));
  return i[n];
}
function rOe(r, e) {
  var t = [VC(r, e[0]), VC(r, e[1])];
  return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("");
}
function M2(r, e, t, i, n, a) {
  var o = t.__brushOption, s = r.toRectRange(o.range), l = lz(e, n, a);
  w(i, function(u) {
    var h = qve[u];
    s[h[0]][h[1]] += l[h[0]];
  }), o.range = r.fromRectRange(sz(s[0][0], s[1][0], s[0][1], s[1][1])), Hx(e, t), oh(e, {
    isEnd: !1
  });
}
function iOe(r, e, t, i) {
  var n = e.__brushOption.range, a = lz(r, t, i);
  w(n, function(o) {
    o[0] += a[0], o[1] += a[1];
  }), Hx(r, e), oh(r, {
    isEnd: !1
  });
}
function lz(r, e, t) {
  var i = r.group, n = i.transformCoordToLocal(e, t), a = i.transformCoordToLocal(0, 0);
  return [n[0] - a[0], n[1] - a[1]];
}
function qx(r, e, t) {
  var i = iz(r, e);
  return i && i !== ah ? i.clipPath(t, r._transform) : Se(t);
}
function nOe(r) {
  var e = ug(r[0][0], r[1][0]), t = ug(r[0][1], r[1][1]), i = nf(r[0][0], r[1][0]), n = nf(r[0][1], r[1][1]);
  return {
    x: e,
    y: t,
    width: i - e,
    height: n - t
  };
}
function aOe(r, e, t) {
  if (
    // Check active
    !(!r._brushType || sOe(r, e.offsetX, e.offsetY))
  ) {
    var i = r._zr, n = r._covers, a = zx(r, e, t);
    if (!r._dragging)
      for (var o = 0; o < n.length; o++) {
        var s = n[o].__brushOption;
        if (a && (a === ah || s.panelId === a.panelId) && ZS[s.brushType].contain(n[o], t[0], t[1]))
          return;
      }
    a && i.setCursorStyle("crosshair");
  }
}
function FC(r) {
  var e = r.event;
  e.preventDefault && e.preventDefault();
}
function XC(r, e, t) {
  return r.childOfName("main").contain(e, t);
}
function uz(r, e, t, i) {
  var n = r._creatingCover, a = r._creatingPanel, o = r._brushOption, s;
  if (r._track.push(t.slice()), eOe(r) || n) {
    if (a && !n) {
      o.brushMode === "single" && GC(r);
      var l = Se(o);
      l.brushType = k2(l.brushType, a), l.panelId = a === ah ? null : a.panelId, n = r._creatingCover = J3(r, l), r._covers.push(n);
    }
    if (n) {
      var u = ZS[k2(r._brushType, a)], h = n.__brushOption;
      h.range = u.getCreatingRange(qx(r, n, r._track)), i && (ez(r, n), u.updateCommon(r, n)), tz(r, n), s = {
        isEnd: i
      };
    }
  } else
    i && o.brushMode === "single" && o.removeOnClick && zx(r, e, t) && GC(r) && (s = {
      isEnd: i,
      removeOnClick: !0
    });
  return s;
}
function k2(r, e) {
  return r === "auto" ? e.defaultBrushType : r;
}
var oOe = {
  mousedown: function(r) {
    if (this._dragging)
      Q2(this, r);
    else if (!r.target || !r.target.draggable) {
      FC(r);
      var e = this.group.transformCoordToLocal(r.offsetX, r.offsetY);
      this._creatingCover = null;
      var t = this._creatingPanel = zx(this, r, e);
      t && (this._dragging = !0, this._track = [e.slice()]);
    }
  },
  mousemove: function(r) {
    var e = r.offsetX, t = r.offsetY, i = this.group.transformCoordToLocal(e, t);
    if (aOe(this, r, i), this._dragging) {
      FC(r);
      var n = uz(this, r, i, !1);
      n && oh(this, n);
    }
  },
  mouseup: function(r) {
    Q2(this, r);
  }
};
function Q2(r, e) {
  if (r._dragging) {
    FC(e);
    var t = e.offsetX, i = e.offsetY, n = r.group.transformCoordToLocal(t, i), a = uz(r, e, n, !0);
    r._dragging = !1, r._track = [], r._creatingCover = null, a && oh(r, a);
  }
}
function sOe(r, e, t) {
  var i = r._zr;
  return e < 0 || e > i.getWidth() || t < 0 || t > i.getHeight();
}
var ZS = {
  lineX: U2(0),
  lineY: U2(1),
  rect: {
    createCover: function(r, e) {
      function t(i) {
        return i;
      }
      return az({
        toRectRange: t,
        fromRectRange: t
      }, r, e, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(r) {
      var e = nz(r);
      return sz(e[1][0], e[1][1], e[0][0], e[0][1]);
    },
    updateCoverShape: function(r, e, t, i) {
      oz(r, e, t, i);
    },
    updateCommon: BC,
    contain: XC
  },
  polygon: {
    createCover: function(r, e) {
      var t = new ye();
      return t.add(new Wi({
        name: "main",
        style: Zx(e),
        silent: !0
      })), t;
    },
    getCreatingRange: function(r) {
      return r;
    },
    endCreating: function(r, e) {
      e.remove(e.childAt(0)), e.add(new Yi({
        name: "main",
        draggable: !0,
        drift: Ie(iOe, r, e),
        ondragend: Ie(oh, r, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(r, e, t, i) {
      e.childAt(0).setShape({
        points: qx(r, e, t)
      });
    },
    updateCommon: BC,
    contain: XC
  }
};
function U2(r) {
  return {
    createCover: function(e, t) {
      return az({
        toRectRange: function(i) {
          var n = [i, [0, 100]];
          return r && n.reverse(), n;
        },
        fromRectRange: function(i) {
          return i[r];
        }
      }, e, t, [[["w"], ["e"]], [["n"], ["s"]]][r]);
    },
    getCreatingRange: function(e) {
      var t = nz(e), i = ug(t[0][r], t[1][r]), n = nf(t[0][r], t[1][r]);
      return [i, n];
    },
    updateCoverShape: function(e, t, i, n) {
      var a, o = iz(e, t);
      if (o !== ah && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(r);
      else {
        var s = e._zr;
        a = [0, [s.getWidth(), s.getHeight()][1 - r]];
      }
      var l = [i, a];
      r && l.reverse(), oz(e, t, l, n);
    },
    updateCommon: BC,
    contain: XC
  };
}
const jx = Jve;
function hz(r) {
  return r = Kx(r), function(e) {
    return gY(e, r);
  };
}
function cz(r, e) {
  return r = Kx(r), function(t) {
    var i = e ?? t, n = i ? r.width : r.height, a = i ? r.x : r.y;
    return [a, a + (n || 0)];
  };
}
function fz(r, e, t) {
  var i = Kx(r);
  return function(n, a) {
    return i.contain(a[0], a[1]) && !YS(n, e, t);
  };
}
function Kx(r) {
  return Ue.create(r);
}
var lOe = ["axisLine", "axisTickLabel", "axisName"], uOe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      r.prototype.init.apply(this, arguments), (this._brushController = new jx(i.getZr())).on("brush", ae(this._onBrush, this));
    }, e.prototype.render = function(t, i, n, a) {
      if (!hOe(t, i, a)) {
        this.axisModel = t, this.api = n, this.group.removeAll();
        var o = this._axisGroup;
        if (this._axisGroup = new ye(), this.group.add(this._axisGroup), !!t.get("show")) {
          var s = fOe(t, i), l = s.coordinateSystem, u = t.getAreaSelectStyle(), h = u.width, c = t.axis.dim, f = l.getAxisLayout(c), d = V({
            strokeContainThreshold: h
          }, f), p = new Wo(t, d);
          w(lOe, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(d, u, t, s, h, n), Bg(o, this._axisGroup, t);
        }
      }
    }, e.prototype._refreshBrushController = function(t, i, n, a, o, s) {
      var l = n.axis.getExtent(), u = l[1] - l[0], h = Math.min(30, Math.abs(u) * 0.1), c = Ue.create({
        x: l[0],
        y: -o / 2,
        width: u,
        height: o
      });
      c.x -= h, c.width += 2 * h, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: t.rotation,
        x: t.position[0],
        y: t.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: hz(c),
        isTargetByCursor: fz(c, s, a),
        getLinearBrushOtherExtent: cz(c, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: i,
        removeOnClick: !0
      }).updateCovers(cOe(n));
    }, e.prototype._onBrush = function(t) {
      var i = t.areas, n = this.axisModel, a = n.axis, o = Y(i, function(s) {
        return [a.coordToData(s.range[0], !0), a.coordToData(s.range[1], !0)];
      });
      (!n.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: n.id,
        intervals: o
      });
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.type = "parallelAxis", e;
  }(Zt)
);
function hOe(r, e, t) {
  return t && t.type === "axisAreaSelect" && e.findComponents({
    mainType: "parallelAxis",
    query: t
  })[0] === r;
}
function cOe(r) {
  var e = r.axis;
  return Y(r.activeIntervals, function(t) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)]
    };
  });
}
function fOe(r, e) {
  return e.getComponent("parallel", r.get("parallelIndex"));
}
const dOe = uOe;
var pOe = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function gOe(r) {
  r.registerAction(pOe, function(e, t) {
    t.eachComponent({
      mainType: "parallelAxis",
      query: e
    }, function(i) {
      i.axis.model.setActiveIntervals(e.intervals);
    });
  }), r.registerAction("parallelAxisExpand", function(e, t) {
    t.eachComponent({
      mainType: "parallel",
      query: e
    }, function(i) {
      i.setAxisExpand(e);
    });
  });
}
var vOe = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function dz(r) {
  r.registerComponentView(Nve), r.registerComponentModel(Dve), r.registerCoordinateSystem("parallel", Yve), r.registerPreprocessor(Cve), r.registerComponentModel(N2), r.registerComponentView(dOe), rf(r, "parallel", N2, vOe), gOe(r);
}
function OOe(r) {
  Ve(dz), r.registerChartView(mve), r.registerSeriesModel(Tve), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, Ave);
}
var mOe = (
  /** @class */
  function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return r;
  }()
), EOe = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new mOe();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.extent;
      t.moveTo(i.x1, i.y1), t.bezierCurveTo(i.cpx1, i.cpy1, i.cpx2, i.cpy2, i.x2, i.y2), i.orient === "vertical" ? (t.lineTo(i.x2 + n, i.y2), t.bezierCurveTo(i.cpx2 + n, i.cpy2, i.cpx1 + n, i.cpy1, i.x1 + n, i.y1)) : (t.lineTo(i.x2, i.y2 + n), t.bezierCurveTo(i.cpx2, i.cpy2 + n, i.cpx1, i.cpy1 + n, i.x1, i.y1 + n)), t.closePath();
    }, e.prototype.highlight = function() {
      Xo(this);
    }, e.prototype.downplay = function() {
      Yo(this);
    }, e;
  }(Fe)
), bOe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._focusAdjacencyDisabled = !1, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this, o = t.getGraph(), s = this.group, l = t.layoutInfo, u = l.width, h = l.height, c = t.getData(), f = t.getData("edge"), d = t.get("orient");
      this._model = t, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function(p) {
        var g = new EOe(), v = _e(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = t.seriesIndex, v.dataType = "edge";
        var O = p.getModel(), m = O.getModel("lineStyle"), E = m.get("curveness"), b = p.node1.getLayout(), T = p.node1.getModel(), S = T.get("localX"), y = T.get("localY"), A = p.node2.getLayout(), C = p.node2.getModel(), _ = C.get("localX"), I = C.get("localY"), x = p.getLayout(), P, N, L, D, $, k, G, F;
        g.shape.extent = Math.max(1, x.dy), g.shape.orient = d, d === "vertical" ? (P = (S != null ? S * u : b.x) + x.sy, N = (y != null ? y * h : b.y) + b.dy, L = (_ != null ? _ * u : A.x) + x.ty, D = I != null ? I * h : A.y, $ = P, k = N * (1 - E) + D * E, G = L, F = N * E + D * (1 - E)) : (P = (S != null ? S * u : b.x) + b.dx, N = (y != null ? y * h : b.y) + x.sy, L = _ != null ? _ * u : A.x, D = (I != null ? I * h : A.y) + x.ty, $ = P * (1 - E) + L * E, k = N, G = P * E + L * (1 - E), F = D), g.setShape({
          x1: P,
          y1: N,
          x2: L,
          y2: D,
          cpx1: $,
          cpy1: k,
          cpx2: G,
          cpy2: F
        }), g.useStyle(m.getItemStyle()), $2(g.style, d, p);
        var q = "" + O.get("value"), re = Cr(O, "edgeLabel");
        Zr(g, re, {
          labelFetcher: {
            getFormattedLabel: function($e, Pe, Ne, Ee, xe, Ce) {
              return t.getFormattedLabel(
                $e,
                Pe,
                "edge",
                Ee,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Ka(xe, re.normal && re.normal.get("formatter"), q),
                Ce
              );
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: q
        }), g.setTextConfig({
          position: "inside"
        });
        var fe = O.getModel("emphasis");
        zr(g, O, "lineStyle", function($e) {
          var Pe = $e.getItemStyle();
          return $2(Pe, d, p), Pe;
        }), s.add(g), f.setItemGraphicEl(p.dataIndex, g);
        var de = fe.get("focus");
        zt(g, de === "adjacency" ? p.getAdjacentDataIndices() : de === "trajectory" ? p.getTrajectoryDataIndices() : de, fe.get("blurScope"), fe.get("disabled"));
      }), o.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), O = v.get("localX"), m = v.get("localY"), E = v.getModel("emphasis"), b = new nt({
          shape: {
            x: O != null ? O * u : g.x,
            y: m != null ? m * h : g.y,
            width: g.dx,
            height: g.dy
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Zr(b, Cr(v), {
          labelFetcher: {
            getFormattedLabel: function(S, y) {
              return t.getFormattedLabel(S, y, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), b.disableLabelAnimation = !0, b.setStyle("fill", p.getVisual("color")), b.setStyle("decal", p.getVisual("style").decal), zr(b, v), s.add(b), c.setItemGraphicEl(p.dataIndex, b), _e(b).dataType = "node";
        var T = E.get("focus");
        zt(b, T === "adjacency" ? p.getAdjacentDataIndices() : T === "trajectory" ? p.getTrajectoryDataIndices() : T, E.get("blurScope"), E.get("disabled"));
      }), c.eachItemGraphicEl(function(p, g) {
        var v = c.getItemModel(g);
        v.get("draggable") && (p.drift = function(O, m) {
          a._focusAdjacencyDisabled = !0, this.shape.x += O, this.shape.y += m, this.dirty(), n.dispatchAction({
            type: "dragNode",
            seriesId: t.id,
            dataIndex: c.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / h
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, p.draggable = !0, p.cursor = "move");
      }), !this._data && t.isAnimationEnabled() && s.setClipPath(SOe(s.getBoundingRect(), t, function() {
        s.removeClipPath();
      })), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.type = "sankey", e;
  }(Mt)
);
function $2(r, e, t) {
  switch (r.fill) {
    case "source":
      r.fill = t.node1.getVisual("color"), r.decal = t.node1.getVisual("style").decal;
      break;
    case "target":
      r.fill = t.node2.getVisual("color"), r.decal = t.node2.getVisual("style").decal;
      break;
    case "gradient":
      var i = t.node1.getVisual("color"), n = t.node2.getVisual("color");
      ne(i) && ne(n) && (r.fill = new Gg(0, 0, +(e === "horizontal"), +(e === "vertical"), [{
        color: i,
        offset: 0
      }, {
        color: n,
        offset: 1
      }]));
  }
}
function SOe(r, e, t) {
  var i = new nt({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return Ut(i, {
    shape: {
      width: r.width + 20
    }
  }, e, t), i;
}
const TOe = bOe;
var yOe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      var n = t.edges || t.links, a = t.data || t.nodes, o = t.levels;
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        o[l].depth != null && o[l].depth >= 0 && (s[o[l].depth] = new Dt(o[l], this, i));
      if (a && n) {
        var u = z3(a, n, this, !0, h);
        return u.data;
      }
      function h(c, f) {
        c.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var O = v.depth, m = g.levelModels[O];
            m && (d.parentModel = m);
          }
          return d;
        }), f.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getGraph().getEdgeByIndex(p), O = v.node1.getLayout();
          if (O) {
            var m = O.depth, E = g.levelModels[m];
            E && (d.parentModel = E);
          }
          return d;
        });
      }
    }, e.prototype.setNodePosition = function(t, i) {
      var n = this.option.data || this.option.nodes, a = n[t];
      a.localX = i[0], a.localY = i[1];
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.formatTooltip = function(t, i, n) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (n === "edge") {
        var o = this.getDataParams(t, n), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return _r("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var h = this.getGraph().getNodeByIndex(t), c = h.getLayout().value, f = this.getDataParams(t, n).data.name;
        return _r("nameValue", {
          name: f != null ? f + "" : null,
          value: c,
          noValue: a(c)
        });
      }
    }, e.prototype.optionUpdated = function() {
    }, e.prototype.getDataParams = function(t, i) {
      var n = r.prototype.getDataParams.call(this, t, i);
      if (n.value == null && i === "node") {
        var a = this.getGraph().getNodeByIndex(t), o = a.getLayout().value;
        n.value = o;
      }
      return n;
    }, e.type = "series.sankey", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, e;
  }(Xt)
);
const ROe = yOe;
function AOe(r, e) {
  r.eachSeriesByType("sankey", function(t) {
    var i = t.get("nodeWidth"), n = t.get("nodeGap"), a = COe(t, e);
    t.layoutInfo = a;
    var o = a.width, s = a.height, l = t.getGraph(), u = l.nodes, h = l.edges;
    IOe(u);
    var c = yt(u, function(g) {
      return g.getLayout().value === 0;
    }), f = c.length !== 0 ? 0 : t.get("layoutIterations"), d = t.get("orient"), p = t.get("nodeAlign");
    _Oe(u, h, i, n, o, s, f, d, p);
  });
}
function COe(r, e) {
  return mr(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function _Oe(r, e, t, i, n, a, o, s, l) {
  xOe(r, e, t, n, a, s, l), LOe(r, e, a, n, i, o, s), VOe(r, s);
}
function IOe(r) {
  w(r, function(e) {
    var t = Ys(e.outEdges, WE), i = Ys(e.inEdges, WE), n = e.getValue() || 0, a = Math.max(t, i, n);
    e.setLayout({
      value: a
    }, !0);
  });
}
function xOe(r, e, t, i, n, a, o) {
  for (var s = [], l = [], u = [], h = [], c = 0, f = 0; f < e.length; f++)
    s[f] = 1;
  for (var f = 0; f < r.length; f++)
    l[f] = r[f].inEdges.length, l[f] === 0 && u.push(r[f]);
  for (var d = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), O = v.depth != null && v.depth >= 0;
      O && v.depth > d && (d = v.depth), g.setLayout({
        depth: O ? v.depth : c
      }, !0), a === "vertical" ? g.setLayout({
        dy: t
      }, !0) : g.setLayout({
        dx: t
      }, !0);
      for (var m = 0; m < g.outEdges.length; m++) {
        var E = g.outEdges[m], b = e.indexOf(E);
        s[b] = 0;
        var T = E.node2, S = r.indexOf(T);
        --l[S] === 0 && h.indexOf(T) < 0 && h.push(T);
      }
    }
    ++c, u = h, h = [];
  }
  for (var f = 0; f < s.length; f++)
    if (s[f] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var y = d > c - 1 ? d : c - 1;
  o && o !== "left" && wOe(r, o, a, y);
  var A = a === "vertical" ? (n - t) / y : (i - t) / y;
  NOe(r, A, a);
}
function pz(r) {
  var e = r.hostGraph.data.getRawDataItem(r.dataIndex);
  return e.depth != null && e.depth >= 0;
}
function wOe(r, e, t, i) {
  if (e === "right") {
    for (var n = [], a = r, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s];
        l.setLayout({
          skNodeHeight: o
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var h = l.inEdges[u];
          n.indexOf(h.node1) < 0 && n.push(h.node1);
        }
      }
      a = n, n = [], ++o;
    }
    w(r, function(c) {
      pz(c) || c.setLayout({
        depth: Math.max(0, i - c.getLayout().skNodeHeight)
      }, !0);
    });
  } else
    e === "justify" && POe(r, i);
}
function POe(r, e) {
  w(r, function(t) {
    !pz(t) && !t.outEdges.length && t.setLayout({
      depth: e
    }, !0);
  });
}
function NOe(r, e, t) {
  w(r, function(i) {
    var n = i.getLayout().depth * e;
    t === "vertical" ? i.setLayout({
      y: n
    }, !0) : i.setLayout({
      x: n
    }, !0);
  });
}
function LOe(r, e, t, i, n, a, o) {
  var s = DOe(r, o);
  MOe(s, e, t, i, n, o), P0(s, n, t, i, o);
  for (var l = 1; a > 0; a--)
    l *= 0.99, kOe(s, l, o), P0(s, n, t, i, o), BOe(s, l, o), P0(s, n, t, i, o);
}
function DOe(r, e) {
  var t = [], i = e === "vertical" ? "y" : "x", n = WA(r, function(a) {
    return a.getLayout()[i];
  });
  return n.keys.sort(function(a, o) {
    return a - o;
  }), w(n.keys, function(a) {
    t.push(n.buckets.get(a));
  }), t;
}
function MOe(r, e, t, i, n, a) {
  var o = 1 / 0;
  w(r, function(s) {
    var l = s.length, u = 0;
    w(s, function(c) {
      u += c.getLayout().value;
    });
    var h = a === "vertical" ? (i - (l - 1) * n) / u : (t - (l - 1) * n) / u;
    h < o && (o = h);
  }), w(r, function(s) {
    w(s, function(l, u) {
      var h = l.getLayout().value * o;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: h
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: h
      }, !0));
    });
  }), w(e, function(s) {
    var l = +s.getValue() * o;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function P0(r, e, t, i, n) {
  var a = n === "vertical" ? "x" : "y";
  w(r, function(o) {
    o.sort(function(g, v) {
      return g.getLayout()[a] - v.getLayout()[a];
    });
    for (var s, l, u, h = 0, c = o.length, f = n === "vertical" ? "dx" : "dy", d = 0; d < c; d++)
      l = o[d], u = h - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, n === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), h = l.getLayout()[a] + l.getLayout()[f] + e;
    var p = n === "vertical" ? i : t;
    if (u = h - e - p, u > 0) {
      s = l.getLayout()[a] - u, n === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), h = s;
      for (var d = c - 2; d >= 0; --d)
        l = o[d], u = l.getLayout()[a] + l.getLayout()[f] + e - h, u > 0 && (s = l.getLayout()[a] - u, n === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), h = l.getLayout()[a];
    }
  });
}
function kOe(r, e, t) {
  w(r.slice().reverse(), function(i) {
    w(i, function(n) {
      if (n.outEdges.length) {
        var a = Ys(n.outEdges, QOe, t) / Ys(n.outEdges, WE);
        if (isNaN(a)) {
          var o = n.outEdges.length;
          a = o ? Ys(n.outEdges, UOe, t) / o : 0;
        }
        if (t === "vertical") {
          var s = n.getLayout().x + (a - ul(n, t)) * e;
          n.setLayout({
            x: s
          }, !0);
        } else {
          var l = n.getLayout().y + (a - ul(n, t)) * e;
          n.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function QOe(r, e) {
  return ul(r.node2, e) * r.getValue();
}
function UOe(r, e) {
  return ul(r.node2, e);
}
function $Oe(r, e) {
  return ul(r.node1, e) * r.getValue();
}
function GOe(r, e) {
  return ul(r.node1, e);
}
function ul(r, e) {
  return e === "vertical" ? r.getLayout().x + r.getLayout().dx / 2 : r.getLayout().y + r.getLayout().dy / 2;
}
function WE(r) {
  return r.getValue();
}
function Ys(r, e, t) {
  for (var i = 0, n = r.length, a = -1; ++a < n; ) {
    var o = +e(r[a], t);
    isNaN(o) || (i += o);
  }
  return i;
}
function BOe(r, e, t) {
  w(r, function(i) {
    w(i, function(n) {
      if (n.inEdges.length) {
        var a = Ys(n.inEdges, $Oe, t) / Ys(n.inEdges, WE);
        if (isNaN(a)) {
          var o = n.inEdges.length;
          a = o ? Ys(n.inEdges, GOe, t) / o : 0;
        }
        if (t === "vertical") {
          var s = n.getLayout().x + (a - ul(n, t)) * e;
          n.setLayout({
            x: s
          }, !0);
        } else {
          var l = n.getLayout().y + (a - ul(n, t)) * e;
          n.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function VOe(r, e) {
  var t = e === "vertical" ? "x" : "y";
  w(r, function(i) {
    i.outEdges.sort(function(n, a) {
      return n.node2.getLayout()[t] - a.node2.getLayout()[t];
    }), i.inEdges.sort(function(n, a) {
      return n.node1.getLayout()[t] - a.node1.getLayout()[t];
    });
  }), w(r, function(i) {
    var n = 0, a = 0;
    w(i.outEdges, function(o) {
      o.setLayout({
        sy: n
      }, !0), n += o.getLayout().dy;
    }), w(i.inEdges, function(o) {
      o.setLayout({
        ty: a
      }, !0), a += o.getLayout().dy;
    });
  });
}
function FOe(r) {
  r.eachSeriesByType("sankey", function(e) {
    var t = e.getGraph(), i = t.nodes, n = t.edges;
    if (i.length) {
      var a = 1 / 0, o = -1 / 0;
      w(i, function(s) {
        var l = s.getLayout().value;
        l < a && (a = l), l > o && (o = l);
      }), w(i, function(s) {
        var l = new Wr({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, o],
          visual: e.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), h = s.getModel().get(["itemStyle", "color"]);
        h != null ? (s.setVisual("color", h), s.setVisual("style", {
          fill: h
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    n.length && w(n, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function XOe(r) {
  r.registerChartView(TOe), r.registerSeriesModel(ROe), r.registerLayout(AOe), r.registerVisual(FOe), r.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: e
    }, function(i) {
      i.setNodePosition(e.dataIndex, [e.localX, e.localY]);
    });
  });
}
var gz = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getInitialData = function(e, t) {
      var i, n = t.getComponent("xAxis", this.get("xAxisIndex")), a = t.getComponent("yAxis", this.get("yAxisIndex")), o = n.get("type"), s = a.get("type"), l;
      o === "category" ? (e.layout = "horizontal", i = n.getOrdinalMeta(), l = !0) : s === "category" ? (e.layout = "vertical", i = a.getOrdinalMeta(), l = !0) : e.layout = e.layout || "horizontal";
      var u = ["x", "y"], h = e.layout === "horizontal" ? 0 : 1, c = this._baseAxisDim = u[h], f = u[1 - h], d = [n, a], p = d[h].get("type"), g = d[1 - h].get("type"), v = e.data;
      if (v && l) {
        var O = [];
        w(v, function(b, T) {
          var S;
          X(b) ? (S = b.slice(), b.unshift(T)) : X(b.value) ? (S = V({}, b), S.value = S.value.slice(), b.value.unshift(T)) : S = b, O.push(S);
        }), e.data = O;
      }
      var m = this.defaultValueDimensions, E = [{
        name: c,
        type: ME(p),
        ordinalMeta: i,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: f,
        type: ME(g),
        dimsDef: m.slice()
      }];
      return Lf(this, {
        coordDimensions: E,
        dimensionsCount: m.length + 1,
        encodeDefaulter: Ie(VY, E, this)
      });
    }, r.prototype.getBaseAxis = function() {
      var e = this._baseAxisDim;
      return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis;
    }, r;
  }()
), vz = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], t.visualDrawType = "stroke", t;
    }
    return e.type = "series.boxplot", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, e;
  }(Xt)
);
hr(vz, gz, !0);
const YOe = vz;
var HOe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this.group, s = this._data;
      this._data || o.removeAll();
      var l = t.get("layout") === "horizontal" ? 1 : 0;
      a.diff(s).add(function(u) {
        if (a.hasValue(u)) {
          var h = a.getItemLayout(u), c = G2(h, a, u, l, !0);
          a.setItemGraphicEl(u, c), o.add(c);
        }
      }).update(function(u, h) {
        var c = s.getItemGraphicEl(h);
        if (!a.hasValue(u)) {
          o.remove(c);
          return;
        }
        var f = a.getItemLayout(u);
        c ? (ba(c), Oz(f, c, a, u)) : c = G2(f, a, u, l), o.add(c), a.setItemGraphicEl(u, c);
      }).remove(function(u) {
        var h = s.getItemGraphicEl(u);
        h && o.remove(h);
      }).execute(), this._data = a;
    }, e.prototype.remove = function(t) {
      var i = this.group, n = this._data;
      this._data = null, n && n.eachItemGraphicEl(function(a) {
        a && i.remove(a);
      });
    }, e.type = "boxplot", e;
  }(Mt)
), WOe = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), zOe = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "boxplotBoxPath", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new WOe();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = 0;
      for (t.moveTo(n[a][0], n[a][1]), a++; a < 4; a++)
        t.lineTo(n[a][0], n[a][1]);
      for (t.closePath(); a < n.length; a++)
        t.moveTo(n[a][0], n[a][1]), a++, t.lineTo(n[a][0], n[a][1]);
    }, e;
  }(Fe)
);
function G2(r, e, t, i, n) {
  var a = r.ends, o = new zOe({
    shape: {
      points: n ? ZOe(a, i, r) : a
    }
  });
  return Oz(r, o, e, t, n), o;
}
function Oz(r, e, t, i, n) {
  var a = t.hostModel, o = Fg[n ? "initProps" : "updateProps"];
  o(e, {
    shape: {
      points: r.ends
    }
  }, a, i), e.useStyle(t.getItemVisual(i, "style")), e.style.strokeNoScale = !0, e.z2 = 100;
  var s = t.getItemModel(i), l = s.getModel("emphasis");
  zr(e, s), zt(e, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function ZOe(r, e, t) {
  return Y(r, function(i) {
    return i = i.slice(), i[e] = t.initBaseline, i;
  });
}
const qOe = HOe;
var pp = w;
function jOe(r) {
  var e = KOe(r);
  pp(e, function(t) {
    var i = t.seriesModels;
    i.length && (JOe(t), pp(i, function(n, a) {
      eme(n, t.boxOffsetList[a], t.boxWidthList[a]);
    }));
  });
}
function KOe(r) {
  var e = [], t = [];
  return r.eachSeriesByType("boxplot", function(i) {
    var n = i.getBaseAxis(), a = Ge(t, n);
    a < 0 && (a = t.length, t[a] = n, e[a] = {
      axis: n,
      seriesModels: []
    }), e[a].seriesModels.push(i);
  }), e;
}
function JOe(r) {
  var e = r.axis, t = r.seriesModels, i = t.length, n = r.boxWidthList = [], a = r.boxOffsetList = [], o = [], s;
  if (e.type === "category")
    s = e.getBandWidth();
  else {
    var l = 0;
    pp(t, function(p) {
      l = Math.max(l, p.getData().count());
    });
    var u = e.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  pp(t, function(p) {
    var g = p.get("boxWidth");
    X(g) || (g = [g, g]), o.push([K(g[0], s) || 0, K(g[1], s) || 0]);
  });
  var h = s * 0.8 - 2, c = h / i * 0.3, f = (h - c * (i - 1)) / i, d = f / 2 - h / 2;
  pp(t, function(p, g) {
    a.push(d), d += c + f, n.push(Math.min(Math.max(f, o[g][0]), o[g][1]));
  });
}
function eme(r, e, t) {
  var i = r.coordinateSystem, n = r.getData(), a = t / 2, o = r.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], u = n.mapDimension(l[o]), h = n.mapDimensionsAll(l[s]);
  if (u == null || h.length < 5)
    return;
  for (var c = 0; c < n.count(); c++) {
    var f = n.get(u, c), d = E(f, h[2], c), p = E(f, h[0], c), g = E(f, h[1], c), v = E(f, h[3], c), O = E(f, h[4], c), m = [];
    b(m, g, !1), b(m, v, !0), m.push(p, g, O, v), T(m, p), T(m, O), T(m, d), n.setItemLayout(c, {
      initBaseline: d[s],
      ends: m
    });
  }
  function E(S, y, A) {
    var C = n.get(y, A), _ = [];
    _[o] = S, _[s] = C;
    var I;
    return isNaN(S) || isNaN(C) ? I = [NaN, NaN] : (I = i.dataToPoint(_), I[o] += e), I;
  }
  function b(S, y, A) {
    var C = y.slice(), _ = y.slice();
    C[o] += a, _[o] -= a, A ? S.push(C, _) : S.push(_, C);
  }
  function T(S, y) {
    var A = y.slice(), C = y.slice();
    A[o] -= a, C[o] += a, S.push(A, C);
  }
}
function tme(r, e) {
  e = e || {};
  for (var t = [], i = [], n = e.boundIQR, a = n === "none" || n === 0, o = 0; o < r.length; o++) {
    var s = $n(r[o].slice()), l = ly(s, 0.25), u = ly(s, 0.5), h = ly(s, 0.75), c = s[0], f = s[s.length - 1], d = (n ?? 1.5) * (h - l), p = a ? c : Math.max(c, l - d), g = a ? f : Math.min(f, h + d), v = e.itemNameFormatter, O = ve(v) ? v({
      value: o
    }) : ne(v) ? v.replace("{value}", o + "") : o + "";
    t.push([O, p, l, u, h, g]);
    for (var m = 0; m < s.length; m++) {
      var E = s[m];
      if (E < p || E > g) {
        var b = [O, E];
        i.push(b);
      }
    }
  }
  return {
    boxData: t,
    outliers: i
  };
}
var rme = {
  type: "echarts:boxplot",
  transform: function(e) {
    var t = e.upstream;
    if (t.sourceFormat !== fi) {
      var i = "";
      vt(i);
    }
    var n = tme(t.getRawData(), e.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: n.boxData
    }, {
      data: n.outliers
    }];
  }
};
function ime(r) {
  r.registerSeriesModel(YOe), r.registerChartView(qOe), r.registerLayout(jOe), r.registerTransform(rme);
}
var nme = ["color", "borderColor"], ame = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this._clear(), this._updateDrawMode(t);
    }, e.prototype.incrementalRender = function(t, i, n, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, i) : this._incrementalRenderNormal(t, i);
    }, e.prototype.eachRendered = function(t) {
      Tl(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var i = t.pipelineContext.large;
      (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
    }, e.prototype._renderNormal = function(t) {
      var i = t.getData(), n = this._data, a = this.group, o = i.getLayout("isSimpleBox"), s = t.get("clip", !0), l = t.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), i.diff(n).add(function(h) {
        if (i.hasValue(h)) {
          var c = i.getItemLayout(h);
          if (s && B2(u, c))
            return;
          var f = N0(c, h, !0);
          Ut(f, {
            shape: {
              points: c.ends
            }
          }, t, h), L0(f, i, h, o), a.add(f), i.setItemGraphicEl(h, f);
        }
      }).update(function(h, c) {
        var f = n.getItemGraphicEl(c);
        if (!i.hasValue(h)) {
          a.remove(f);
          return;
        }
        var d = i.getItemLayout(h);
        if (s && B2(u, d)) {
          a.remove(f);
          return;
        }
        f ? (ft(f, {
          shape: {
            points: d.ends
          }
        }, t, h), ba(f)) : f = N0(d), L0(f, i, h, o), a.add(f), i.setItemGraphicEl(h, f);
      }).remove(function(h) {
        var c = n.getItemGraphicEl(h);
        c && a.remove(c);
      }).execute(), this._data = i;
    }, e.prototype._renderLarge = function(t) {
      this._clear(), V2(t, this.group);
      var i = t.get("clip", !0) ? XS(t.coordinateSystem, !1, t) : null;
      i ? this.group.setClipPath(i) : this.group.removeClipPath();
    }, e.prototype._incrementalRenderNormal = function(t, i) {
      for (var n = i.getData(), a = n.getLayout("isSimpleBox"), o; (o = t.next()) != null; ) {
        var s = n.getItemLayout(o), l = N0(s);
        L0(l, n, o, a), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, e.prototype._incrementalRenderLarge = function(t, i) {
      V2(i, this.group, this._progressiveEls, !0);
    }, e.prototype.remove = function(t) {
      this._clear();
    }, e.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "candlestick", e;
  }(Mt)
), ome = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), sme = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "normalCandlestickBox", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new ome();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points;
      this.__simpleBox ? (t.moveTo(n[4][0], n[4][1]), t.lineTo(n[6][0], n[6][1])) : (t.moveTo(n[0][0], n[0][1]), t.lineTo(n[1][0], n[1][1]), t.lineTo(n[2][0], n[2][1]), t.lineTo(n[3][0], n[3][1]), t.closePath(), t.moveTo(n[4][0], n[4][1]), t.lineTo(n[5][0], n[5][1]), t.moveTo(n[6][0], n[6][1]), t.lineTo(n[7][0], n[7][1]));
    }, e;
  }(Fe)
);
function N0(r, e, t) {
  var i = r.ends;
  return new sme({
    shape: {
      points: t ? lme(i, r) : i
    },
    z2: 100
  });
}
function B2(r, e) {
  for (var t = !0, i = 0; i < e.ends.length; i++)
    if (r.contain(e.ends[i][0], e.ends[i][1])) {
      t = !1;
      break;
    }
  return t;
}
function L0(r, e, t, i) {
  var n = e.getItemModel(t);
  r.useStyle(e.getItemVisual(t, "style")), r.style.strokeNoScale = !0, r.__simpleBox = i, zr(r, n);
}
function lme(r, e) {
  return Y(r, function(t) {
    return t = t.slice(), t[1] = e.initBaseline, t;
  });
}
var ume = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), D0 = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "largeCandlestickBox", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new ume();
    }, e.prototype.buildPath = function(t, i) {
      for (var n = i.points, a = 0; a < n.length; )
        if (this.__sign === n[a++]) {
          var o = n[a++];
          t.moveTo(o, n[a++]), t.lineTo(o, n[a++]);
        } else
          a += 3;
    }, e;
  }(Fe)
);
function V2(r, e, t, i) {
  var n = r.getData(), a = n.getLayout("largePoints"), o = new D0({
    shape: {
      points: a
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  e.add(o);
  var s = new D0({
    shape: {
      points: a
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  e.add(s);
  var l = new D0({
    shape: {
      points: a
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  e.add(l), M0(1, o, r), M0(-1, s, r), M0(0, l, r), i && (o.incremental = !0, s.incremental = !0), t && t.push(o, s);
}
function M0(r, e, t, i) {
  var n = t.get(["itemStyle", r > 0 ? "borderColor" : "borderColor0"]) || t.get(["itemStyle", r > 0 ? "color" : "color0"]);
  r === 0 && (n = t.get(["itemStyle", "borderColorDoji"]));
  var a = t.getModel("itemStyle").getItemStyle(nme);
  e.useStyle(a), e.style.fill = null, e.style.stroke = n;
}
const hme = ame;
var mz = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], t;
    }
    return e.prototype.getShadowDim = function() {
      return "open";
    }, e.prototype.brushSelector = function(t, i, n) {
      var a = i.getItemLayout(t);
      return a && n.rect(a.brushRect);
    }, e.type = "series.candlestick", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, e;
  }(Xt)
);
hr(mz, gz, !0);
const cme = mz;
function fme(r) {
  !r || !X(r.series) || w(r.series, function(e) {
    be(e) && e.type === "k" && (e.type = "candlestick");
  });
}
var dme = ["itemStyle", "borderColor"], pme = ["itemStyle", "borderColor0"], gme = ["itemStyle", "borderColorDoji"], vme = ["itemStyle", "color"], Ome = ["itemStyle", "color0"], mme = {
  seriesType: "candlestick",
  plan: wf(),
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    function t(a, o) {
      return o.get(a > 0 ? vme : Ome);
    }
    function i(a, o) {
      return o.get(a === 0 ? gme : a > 0 ? dme : pme);
    }
    if (!e.isSeriesFiltered(r)) {
      var n = r.pipelineContext.large;
      return !n && {
        progress: function(a, o) {
          for (var s; (s = a.next()) != null; ) {
            var l = o.getItemModel(s), u = o.getItemLayout(s).sign, h = l.getItemStyle();
            h.fill = t(u, l), h.stroke = i(u, l) || h.fill;
            var c = o.ensureUniqueItemVisual(s, "style");
            V(c, h);
          }
        }
      };
    }
  }
};
const Eme = mme;
var bme = {
  seriesType: "candlestick",
  plan: wf(),
  reset: function(r) {
    var e = r.coordinateSystem, t = r.getData(), i = Sme(r, t), n = 0, a = 1, o = ["x", "y"], s = t.getDimensionIndex(t.mapDimension(o[n])), l = Y(t.mapDimensionsAll(o[a]), t.getDimensionIndex, t), u = l[0], h = l[1], c = l[2], f = l[3];
    if (t.setLayout({
      candleWidth: i,
      // The value is experimented visually.
      isSimpleBox: i <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: r.pipelineContext.large ? p : d
    };
    function d(g, v) {
      for (var O, m = v.getStore(); (O = g.next()) != null; ) {
        var E = m.get(s, O), b = m.get(u, O), T = m.get(h, O), S = m.get(c, O), y = m.get(f, O), A = Math.min(b, T), C = Math.max(b, T), _ = $(A, E), I = $(C, E), x = $(S, E), P = $(y, E), N = [];
        k(N, I, 0), k(N, _, 1), N.push(F(P), F(I), F(x), F(_));
        var L = v.getItemModel(O), D = !!L.get(["itemStyle", "borderColorDoji"]);
        v.setItemLayout(O, {
          sign: F2(m, O, b, T, h, D),
          initBaseline: b > T ? I[a] : _[a],
          ends: N,
          brushRect: G(S, y, E)
        });
      }
      function $(q, re) {
        var fe = [];
        return fe[n] = re, fe[a] = q, isNaN(re) || isNaN(q) ? [NaN, NaN] : e.dataToPoint(fe);
      }
      function k(q, re, fe) {
        var de = re.slice(), $e = re.slice();
        de[n] = Em(de[n] + i / 2, 1, !1), $e[n] = Em($e[n] - i / 2, 1, !0), fe ? q.push(de, $e) : q.push($e, de);
      }
      function G(q, re, fe) {
        var de = $(q, fe), $e = $(re, fe);
        return de[n] -= i / 2, $e[n] -= i / 2, {
          x: de[0],
          y: de[1],
          width: i,
          height: $e[1] - de[1]
        };
      }
      function F(q) {
        return q[n] = Em(q[n], 1), q;
      }
    }
    function p(g, v) {
      for (var O = Wa(g.count * 4), m = 0, E, b = [], T = [], S, y = v.getStore(), A = !!r.get(["itemStyle", "borderColorDoji"]); (S = g.next()) != null; ) {
        var C = y.get(s, S), _ = y.get(u, S), I = y.get(h, S), x = y.get(c, S), P = y.get(f, S);
        if (isNaN(C) || isNaN(x) || isNaN(P)) {
          O[m++] = NaN, m += 3;
          continue;
        }
        O[m++] = F2(y, S, _, I, h, A), b[n] = C, b[a] = x, E = e.dataToPoint(b, null, T), O[m++] = E ? E[0] : NaN, O[m++] = E ? E[1] : NaN, b[a] = P, E = e.dataToPoint(b, null, T), O[m++] = E ? E[1] : NaN;
      }
      v.setLayout("largePoints", O);
    }
  }
};
function F2(r, e, t, i, n, a) {
  var o;
  return t > i ? o = -1 : t < i ? o = 1 : o = a ? 0 : e > 0 ? r.get(n, e - 1) <= i ? 1 : -1 : (
    // No record of previous, set to be positive
    1
  ), o;
}
function Sme(r, e) {
  var t = r.getBaseAxis(), i, n = t.type === "category" ? t.getBandWidth() : (i = t.getExtent(), Math.abs(i[1] - i[0]) / e.count()), a = K(ke(r.get("barMaxWidth"), n), n), o = K(ke(r.get("barMinWidth"), 1), n), s = r.get("barWidth");
  return s != null ? K(s, n) : Math.max(Math.min(n / 2, a), o);
}
const Tme = bme;
function yme(r) {
  r.registerChartView(hme), r.registerSeriesModel(cme), r.registerPreprocessor(fme), r.registerVisual(Eme), r.registerLayout(Tme);
}
function X2(r, e) {
  var t = e.rippleEffectColor || e.color;
  r.eachChild(function(i) {
    i.attr({
      z: e.z,
      zlevel: e.zlevel,
      style: {
        stroke: e.brushType === "stroke" ? t : null,
        fill: e.brushType === "fill" ? t : null
      }
    });
  });
}
var Rme = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i) {
      var n = r.call(this) || this, a = new Zg(t, i), o = new ye();
      return n.add(a), n.add(o), n.updateData(t, i), n;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(t) {
      for (var i = t.symbolType, n = t.color, a = t.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = ur(i, -1, -1, 2, 2, n);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * t.period + t.effectOffset;
        l.animate("", !0).when(t.period, {
          scaleX: t.rippleScale / 2,
          scaleY: t.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(t.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      X2(o, t);
    }, e.prototype.updateEffectAnimation = function(t) {
      for (var i = this._effectCfg, n = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
        var s = a[o];
        if (i[s] !== t[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(t);
          return;
        }
      }
      X2(n, t);
    }, e.prototype.highlight = function() {
      Xo(this);
    }, e.prototype.downplay = function() {
      Yo(this);
    }, e.prototype.getSymbolType = function() {
      var t = this.childAt(0);
      return t && t.getSymbolType();
    }, e.prototype.updateData = function(t, i) {
      var n = this, a = t.hostModel;
      this.childAt(0).updateData(t, i);
      var o = this.childAt(1), s = t.getItemModel(i), l = t.getItemVisual(i, "symbol"), u = Nf(t.getItemVisual(i, "symbolSize")), h = t.getItemVisual(i, "style"), c = h && h.fill, f = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(v) {
        v.setStyle("fill", c);
      });
      var d = Th(t.getItemVisual(i, "symbolOffset"), u);
      d && (o.x = d[0], o.y = d[1]);
      var p = t.getItemVisual(i, "symbolRotate");
      o.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = a.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = i / t.count(), g.z = a.getShallow("z") || 0, g.zlevel = a.getShallow("zlevel") || 0, g.symbolType = l, g.color = c, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && n.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && n.stopEffectAnimation();
      }), this._effectCfg = g, zt(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
    }, e.prototype.fadeOut = function(t) {
      t && t();
    }, e;
  }(ye)
);
const Ame = Rme;
var Cme = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new qg(Ame);
    }, e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this.group.add(o.group);
    }, e.prototype._getClipShape = function(t) {
      var i = t.coordinateSystem, n = i && i.getArea && i.getArea();
      return t.get("clip", !0) ? n : null;
    }, e.prototype.updateTransform = function(t, i, n) {
      var a = t.getData();
      this.group.dirty();
      var o = jg("").reset(t, i, n);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(t) {
      var i = t.coordinateSystem;
      i && i.getRoamTransform && (this.group.transform = sre(i.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(t, i) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, e.type = "effectScatter", e;
  }(Mt)
);
const _me = Cme;
var Ime = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return ts(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.brushSelector = function(t, i, n) {
      return n.point(i.getItemLayout(t));
    }, e.type = "series.effectScatter", e.dependencies = ["grid", "polar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 
      symbolSize: 10
      // symbolSize * 2
      // symbolRotate: null,  // 
      // itemStyle: {
      //     opacity: 1
      // }
    }, e;
  }(Xt)
);
const xme = Ime;
function wme(r) {
  r.registerChartView(_me), r.registerSeriesModel(xme), r.registerLayout(jg("effectScatter"));
}
var Pme = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      return a.add(a.createLine(t, i, n)), a._updateEffectSymbol(t, i), a;
    }
    return e.prototype.createLine = function(t, i, n) {
      return new Xx(t, i, n);
    }, e.prototype._updateEffectSymbol = function(t, i) {
      var n = t.getItemModel(i), a = n.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      X(o) || (o = [o, o]);
      var l = t.getItemVisual(i, "style"), u = a.get("color") || l && l.stroke, h = this.childAt(1);
      this._symbolType !== s && (this.remove(h), h = ur(s, -0.5, -0.5, 1, 1, u), h.z2 = 100, h.culling = !0, this.add(h)), h && (h.setStyle("shadowColor", u), h.setStyle(a.getItemStyle(["color"])), h.scaleX = o[0], h.scaleY = o[1], h.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(t, a, i));
    }, e.prototype._updateEffectAnimation = function(t, i, n) {
      var a = this.childAt(1);
      if (a) {
        var o = t.getItemLayout(n), s = i.get("period") * 1e3, l = i.get("loop"), u = i.get("roundTrip"), h = i.get("constantSpeed"), c = Dr(i.get("delay"), function(d) {
          return d / t.count() * s / 3;
        });
        if (a.ignore = !0, this._updateAnimationPoints(a, o), h > 0 && (s = this._getLineLength(a) / h * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var f = void 0;
          ve(c) ? f = c(n) : f = c, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(t, i, n, a, o) {
      if (i > 0) {
        t.__t = 0;
        var s = this, l = t.animate("", a).when(o ? i * 2 : i, {
          __t: o ? 2 : 1
        }).delay(n).during(function() {
          s._updateSymbolPosition(t);
        });
        a || l.done(function() {
          s.remove(t);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(t) {
      return xs(t.__p1, t.__cp1) + xs(t.__cp1, t.__p2);
    }, e.prototype._updateAnimationPoints = function(t, i) {
      t.__p1 = i[0], t.__p2 = i[1], t.__cp1 = i[2] || [(i[0][0] + i[1][0]) / 2, (i[0][1] + i[1][1]) / 2];
    }, e.prototype.updateData = function(t, i, n) {
      this.childAt(0).updateData(t, i, n), this._updateEffectSymbol(t, i);
    }, e.prototype._updateSymbolPosition = function(t) {
      var i = t.__p1, n = t.__p2, a = t.__cp1, o = t.__t < 1 ? t.__t : 2 - t.__t, s = [t.x, t.y], l = s.slice(), u = Pr, h = DA;
      s[0] = u(i[0], a[0], n[0], o), s[1] = u(i[1], a[1], n[1], o);
      var c = t.__t < 1 ? h(i[0], a[0], n[0], o) : h(n[0], a[0], i[0], 1 - o), f = t.__t < 1 ? h(i[1], a[1], n[1], o) : h(n[1], a[1], i[1], 1 - o);
      t.rotation = -Math.atan2(f, c) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = xs(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * xs(i, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1];
    }, e.prototype.updateLayout = function(t, i) {
      this.childAt(0).updateLayout(t, i);
      var n = t.getItemModel(i).getModel("effect");
      this._updateEffectAnimation(t, n, i);
    }, e;
  }(ye)
);
const Ez = Pme;
var Nme = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      return a._createPolyline(t, i, n), a;
    }
    return e.prototype._createPolyline = function(t, i, n) {
      var a = t.getItemLayout(i), o = new Wi({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(t, i, n);
    }, e.prototype.updateData = function(t, i, n) {
      var a = t.hostModel, o = this.childAt(0), s = {
        shape: {
          points: t.getItemLayout(i)
        }
      };
      ft(o, s, a, i), this._updateCommonStl(t, i, n);
    }, e.prototype._updateCommonStl = function(t, i, n) {
      var a = this.childAt(0), o = t.getItemModel(i), s = n && n.emphasisLineStyle, l = n && n.focus, u = n && n.blurScope, h = n && n.emphasisDisabled;
      if (!n || t.hasItemOption) {
        var c = o.getModel("emphasis");
        s = c.getModel("lineStyle").getLineStyle(), h = c.get("disabled"), l = c.get("focus"), u = c.get("blurScope");
      }
      a.useStyle(t.getItemVisual(i, "style")), a.style.fill = null, a.style.strokeNoScale = !0;
      var f = a.ensureState("emphasis");
      f.style = s, zt(this, l, u, h);
    }, e.prototype.updateLayout = function(t, i) {
      var n = this.childAt(0);
      n.setShape("points", t.getItemLayout(i));
    }, e;
  }(ye)
);
const bz = Nme;
var Lme = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._lastFrame = 0, t._lastFramePercent = 0, t;
    }
    return e.prototype.createLine = function(t, i, n) {
      return new bz(t, i, n);
    }, e.prototype._updateAnimationPoints = function(t, i) {
      this._points = i;
      for (var n = [0], a = 0, o = 1; o < i.length; o++) {
        var s = i[o - 1], l = i[o];
        a += xs(s, l), n.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < n.length; o++)
        n[o] /= a;
      this._offsets = n, this._length = a;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(t) {
      var i = t.__t < 1 ? t.__t : 2 - t.__t, n = this._points, a = this._offsets, o = n.length;
      if (a) {
        var s = this._lastFrame, l;
        if (i < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= i); l--)
            ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > i); l++)
            ;
          l = Math.min(l - 1, o - 2);
        }
        var h = (i - a[l]) / (a[l + 1] - a[l]), c = n[l], f = n[l + 1];
        t.x = c[0] * (1 - h) + h * f[0], t.y = c[1] * (1 - h) + h * f[1];
        var d = t.__t < 1 ? f[0] - c[0] : c[0] - f[0], p = t.__t < 1 ? f[1] - c[1] : c[1] - f[1];
        t.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = i, t.ignore = !1;
      }
    }, e;
  }(Ez)
);
const Dme = Lme;
var Mme = (
  /** @class */
  function() {
    function r() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return r;
  }()
), kme = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i._off = 0, i.hoverDataIdx = -1, i;
    }
    return e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new Mme();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.segs, a = i.curveness, o;
      if (i.polyline)
        for (o = this._off; o < n.length; ) {
          var s = n[o++];
          if (s > 0) {
            t.moveTo(n[o++], n[o++]);
            for (var l = 1; l < s; l++)
              t.lineTo(n[o++], n[o++]);
          }
        }
      else
        for (o = this._off; o < n.length; ) {
          var u = n[o++], h = n[o++], c = n[o++], f = n[o++];
          if (t.moveTo(u, h), a > 0) {
            var d = (u + c) / 2 - (h - f) * a, p = (h + f) / 2 - (c - u) * a;
            t.quadraticCurveTo(d, p, c, f);
          } else
            t.lineTo(c, f);
        }
      this.incremental && (this._off = o, this.notClear = !0);
    }, e.prototype.findDataIndex = function(t, i) {
      var n = this.shape, a = n.segs, o = n.curveness, s = this.style.lineWidth;
      if (n.polyline)
        for (var l = 0, u = 0; u < a.length; ) {
          var h = a[u++];
          if (h > 0)
            for (var c = a[u++], f = a[u++], d = 1; d < h; d++) {
              var p = a[u++], g = a[u++];
              if (ys(c, f, p, g, s, t, i))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < a.length; ) {
          var c = a[u++], f = a[u++], p = a[u++], g = a[u++];
          if (o > 0) {
            var v = (c + p) / 2 - (f - g) * o, O = (f + g) / 2 - (p - c) * o;
            if (IX(c, f, v, O, p, g, s, t, i))
              return l;
          } else if (ys(c, f, p, g, s, t, i))
            return l;
          l++;
        }
      return -1;
    }, e.prototype.contain = function(t, i) {
      var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
      if (t = n[0], i = n[1], a.contain(t, i)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, i);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var i = this.shape, n = i.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < n.length; ) {
          var h = n[u++], c = n[u++];
          a = Math.min(h, a), s = Math.max(h, s), o = Math.min(c, o), l = Math.max(c, l);
        }
        t = this._rect = new Ue(a, o, s, l);
      }
      return t;
    }, e;
  }(Fe)
), Qme = (
  /** @class */
  function() {
    function r() {
      this.group = new ye();
    }
    return r.prototype.updateData = function(e) {
      this._clear();
      var t = this._create();
      t.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(t, e);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, r.prototype.incrementalUpdate = function(e, t) {
      var i = this._newAdded[0], n = t.getLayout("linesPoints"), a = i && i.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + n.length);
        s.set(a), s.set(n, o), i.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: n
        }), this._setCommon(l, t), l.__startIndex = e.start;
      }
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, r.prototype._create = function() {
      var e = new kme({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, r.prototype._setCommon = function(e, t, i) {
      var n = t.hostModel;
      e.setShape({
        polyline: n.get("polyline"),
        curveness: n.get(["lineStyle", "curveness"])
      }), e.useStyle(n.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = !0;
      var a = t.getVisual("style");
      a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null);
      var o = _e(e);
      o.seriesIndex = n.seriesIndex, e.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (o.dataIndex = l + e.__startIndex);
      });
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
);
const Ume = Qme;
var $me = {
  seriesType: "lines",
  plan: wf(),
  reset: function(r) {
    var e = r.coordinateSystem;
    if (e) {
      var t = r.get("polyline"), i = r.pipelineContext.large;
      return {
        progress: function(n, a) {
          var o = [];
          if (i) {
            var s = void 0, l = n.end - n.start;
            if (t) {
              for (var u = 0, h = n.start; h < n.end; h++)
                u += r.getLineCoordsCount(h);
              s = new Float32Array(l + u * 2);
            } else
              s = new Float32Array(l * 4);
            for (var c = 0, f = [], h = n.start; h < n.end; h++) {
              var d = r.getLineCoords(h, o);
              t && (s[c++] = d);
              for (var p = 0; p < d; p++)
                f = e.dataToPoint(o[p], !1, f), s[c++] = f[0], s[c++] = f[1];
            }
            a.setLayout("linesPoints", s);
          } else
            for (var h = n.start; h < n.end; h++) {
              var g = a.getItemModel(h), d = r.getLineCoords(h, o), v = [];
              if (t)
                for (var O = 0; O < d; O++)
                  v.push(e.dataToPoint(o[O]));
              else {
                v[0] = e.dataToPoint(o[0]), v[1] = e.dataToPoint(o[1]);
                var m = g.get(["lineStyle", "curveness"]);
                +m && (v[2] = [(v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * m, (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * m]);
              }
              a.setItemLayout(h, v);
            }
        }
      };
    }
  }
};
const Sz = $me;
var Gme = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._updateLineDraw(a, t), s = t.get("zlevel"), l = t.get(["effect", "trailLength"]), u = n.getZr(), h = u.painter.getType() === "svg";
      h || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !h && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(t) && l > 0 && (h || u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var c = t.get("clip", !0) && XS(t.coordinateSystem, !1, t);
      c ? this.group.setClipPath(c) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      var a = t.getData(), o = this._updateLineDraw(a, t);
      o.incrementalPrepareUpdate(a), this._clearLayer(n), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, i, n) {
      this._lineDraw.incrementalUpdate(t, i.getData()), this._finished = t.end === i.getData().count();
    }, e.prototype.eachRendered = function(t) {
      this._lineDraw && this._lineDraw.eachRendered(t);
    }, e.prototype.updateTransform = function(t, i, n) {
      var a = t.getData(), o = t.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0
        };
      var s = Sz.reset(t, i, n);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(n);
    }, e.prototype._updateLineDraw = function(t, i) {
      var n = this._lineDraw, a = this._showEffect(i), o = !!i.get("polyline"), s = i.pipelineContext, l = s.large;
      return (!n || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (n && n.remove(), n = this._lineDraw = l ? new Ume() : new Yx(o ? a ? Dme : bz : a ? Ez : Xx), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(n.group), n;
    }, e.prototype._showEffect = function(t) {
      return !!t.get(["effect", "show"]);
    }, e.prototype._clearLayer = function(t) {
      var i = t.getZr(), n = i.painter.getType() === "svg";
      !n && this._lastZlevel != null && i.painter.getLayer(this._lastZlevel).clear(!0);
    }, e.prototype.remove = function(t, i) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(i);
    }, e.prototype.dispose = function(t, i) {
      this.remove(t, i);
    }, e.type = "lines", e;
  }(Mt)
);
const Bme = Gme;
var Vme = typeof Uint32Array > "u" ? Array : Uint32Array, Fme = typeof Float64Array > "u" ? Array : Float64Array;
function Y2(r) {
  var e = r.data;
  e && e[0] && e[0][0] && e[0][0].coord && (r.data = Y(e, function(t) {
    var i = [t[0].coord, t[1].coord], n = {
      coords: i
    };
    return t[0].name && (n.fromName = t[0].name), t[1].name && (n.toName = t[1].name), SI([n, t[0], t[1]]);
  }));
}
var Xme = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.init = function(t) {
      t.data = t.data || [], Y2(t);
      var i = this._processFlatCoordsArray(t.data);
      this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (t.data = new Float32Array(i.count)), r.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(t) {
      if (Y2(t), t.data) {
        var i = this._processFlatCoordsArray(t.data);
        this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (t.data = new Float32Array(i.count));
      }
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(t) {
      var i = this._processFlatCoordsArray(t.data);
      i.flatCoords && (this._flatCoords ? (this._flatCoords = hE(this._flatCoords, i.flatCoords), this._flatCoordsOffset = hE(this._flatCoordsOffset, i.flatCoordsOffset)) : (this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset), t.data = new Float32Array(i.count)), this.getRawData().appendData(t.data);
    }, e.prototype._getCoordsFromItemModel = function(t) {
      var i = this.getData().getItemModel(t), n = i.option instanceof Array ? i.option : i.getShallow("coords");
      return n;
    }, e.prototype.getLineCoordsCount = function(t) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
    }, e.prototype.getLineCoords = function(t, i) {
      if (this._flatCoordsOffset) {
        for (var n = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], o = 0; o < a; o++)
          i[o] = i[o] || [], i[o][0] = this._flatCoords[n + o * 2], i[o][1] = this._flatCoords[n + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++)
          i[o] = i[o] || [], i[o][0] = s[o][0], i[o][1] = s[o][1];
        return s.length;
      }
    }, e.prototype._processFlatCoordsArray = function(t) {
      var i = 0;
      if (this._flatCoords && (i = this._flatCoords.length), ut(t[0])) {
        for (var n = t.length, a = new Vme(n), o = new Fme(n), s = 0, l = 0, u = 0, h = 0; h < n; ) {
          u++;
          var c = t[h++];
          a[l++] = s + i, a[l++] = c;
          for (var f = 0; f < c; f++) {
            var d = t[h++], p = t[h++];
            o[s++] = d, o[s++] = p;
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: t.length
      };
    }, e.prototype.getInitialData = function(t, i) {
      var n = new Ai(["value"], this);
      return n.hasItemOption = !1, n.initData(t.data, [], function(a, o, s, l) {
        if (a instanceof Array)
          return NaN;
        n.hasItemOption = !0;
        var u = a.value;
        if (u != null)
          return u instanceof Array ? u[l] : u;
      }), n;
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = a.getItemModel(t), s = o.get("name");
      if (s)
        return s;
      var l = o.get("fromName"), u = o.get("toName"), h = [];
      return l != null && h.push(l), u != null && h.push(u), _r("nameValue", {
        name: h.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var t = this.getModel("effect"), i = t.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && i > 0 ? i + "" : "";
    }, e.type = "series.lines", e.dependencies = ["grid", "polar", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: Tooltip.formatter
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(Xt)
);
const Yme = Xme;
function RO(r) {
  return r instanceof Array || (r = [r, r]), r;
}
var Hme = {
  seriesType: "lines",
  reset: function(r) {
    var e = RO(r.get("symbol")), t = RO(r.get("symbolSize")), i = r.getData();
    i.setVisual("fromSymbol", e && e[0]), i.setVisual("toSymbol", e && e[1]), i.setVisual("fromSymbolSize", t && t[0]), i.setVisual("toSymbolSize", t && t[1]);
    function n(a, o) {
      var s = a.getItemModel(o), l = RO(s.getShallow("symbol", !0)), u = RO(s.getShallow("symbolSize", !0));
      l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
    }
    return {
      dataEach: i.hasItemOption ? n : null
    };
  }
};
const Wme = Hme;
function zme(r) {
  r.registerChartView(Bme), r.registerSeriesModel(Yme), r.registerLayout(Sz), r.registerVisual(Wme);
}
var Zme = 256, qme = (
  /** @class */
  function() {
    function r() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var e = il.createCanvas();
      this.canvas = e;
    }
    return r.prototype.update = function(e, t, i, n, a, o) {
      var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), h = this.pointSize + this.blurSize, c = this.canvas, f = c.getContext("2d"), d = e.length;
      c.width = t, c.height = i;
      for (var p = 0; p < d; ++p) {
        var g = e[p], v = g[0], O = g[1], m = g[2], E = n(m);
        f.globalAlpha = E, f.drawImage(s, v - h, O - h);
      }
      if (!c.width || !c.height)
        return c;
      for (var b = f.getImageData(0, 0, c.width, c.height), T = b.data, S = 0, y = T.length, A = this.minOpacity, C = this.maxOpacity, _ = C - A; S < y; ) {
        var E = T[S + 3] / 256, I = Math.floor(E * (Zme - 1)) * 4;
        if (E > 0) {
          var x = o(E) ? l : u;
          E > 0 && (E = E * _ + A), T[S++] = x[I], T[S++] = x[I + 1], T[S++] = x[I + 2], T[S++] = x[I + 3] * E * 256;
        } else
          S += 4;
      }
      return f.putImageData(b, 0, 0), c;
    }, r.prototype._getBrush = function() {
      var e = this._brushCanvas || (this._brushCanvas = il.createCanvas()), t = this.pointSize + this.blurSize, i = t * 2;
      e.width = i, e.height = i;
      var n = e.getContext("2d");
      return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = "#000", n.beginPath(), n.arc(-t, t, this.pointSize, 0, Math.PI * 2, !0), n.closePath(), n.fill(), e;
    }, r.prototype._getGradient = function(e, t) {
      for (var i = this._gradientPixels, n = i[t] || (i[t] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++)
        e[t](s / 255, !0, a), n[o++] = a[0], n[o++] = a[1], n[o++] = a[2], n[o++] = a[3];
      return n;
    }, r;
  }()
);
const jme = qme;
function Kme(r, e, t) {
  var i = r[1] - r[0];
  e = Y(e, function(o) {
    return {
      interval: [(o.interval[0] - r[0]) / i, (o.interval[1] - r[0]) / i]
    };
  });
  var n = e.length, a = 0;
  return function(o) {
    var s;
    for (s = a; s < n; s++) {
      var l = e[s].interval;
      if (l[0] <= o && o <= l[1]) {
        a = s;
        break;
      }
    }
    if (s === n)
      for (s = a - 1; s >= 0; s--) {
        var l = e[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
    return s >= 0 && s < n && t[s];
  };
}
function Jme(r, e) {
  var t = r[1] - r[0];
  return e = [(e[0] - r[0]) / t, (e[1] - r[0]) / t], function(i) {
    return i >= e[0] && i <= e[1];
  };
}
function H2(r) {
  var e = r.dimensions;
  return e[0] === "lng" && e[1] === "lat";
}
var eEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a;
      i.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === t && (a = s);
        });
      }), this._progressiveEls = null, this.group.removeAll();
      var o = t.coordinateSystem;
      o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, n, 0, t.getData().count()) : H2(o) && this._renderOnGeo(o, t, a, n);
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this.group.removeAll();
    }, e.prototype.incrementalRender = function(t, i, n, a) {
      var o = i.coordinateSystem;
      o && (H2(o) ? this.render(i, n, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(i, a, t.start, t.end, !0)));
    }, e.prototype.eachRendered = function(t) {
      Tl(this._progressiveEls || this.group, t);
    }, e.prototype._renderOnCartesianAndCalendar = function(t, i, n, a, o) {
      var s = t.coordinateSystem, l = Rh(s, "cartesian2d"), u, h, c, f;
      if (l) {
        var d = s.getAxis("x"), p = s.getAxis("y");
        u = d.getBandWidth() + 0.5, h = p.getBandWidth() + 0.5, c = d.scale.getExtent(), f = p.scale.getExtent();
      }
      for (var g = this.group, v = t.getData(), O = t.getModel(["emphasis", "itemStyle"]).getItemStyle(), m = t.getModel(["blur", "itemStyle"]).getItemStyle(), E = t.getModel(["select", "itemStyle"]).getItemStyle(), b = t.get(["itemStyle", "borderRadius"]), T = Cr(t), S = t.getModel("emphasis"), y = S.get("focus"), A = S.get("blurScope"), C = S.get("disabled"), _ = l ? [v.mapDimension("x"), v.mapDimension("y"), v.mapDimension("value")] : [v.mapDimension("time"), v.mapDimension("value")], I = n; I < a; I++) {
        var x = void 0, P = v.getItemVisual(I, "style");
        if (l) {
          var N = v.get(_[0], I), L = v.get(_[1], I);
          if (isNaN(v.get(_[2], I)) || isNaN(N) || isNaN(L) || N < c[0] || N > c[1] || L < f[0] || L > f[1])
            continue;
          var D = s.dataToPoint([N, L]);
          x = new nt({
            shape: {
              x: D[0] - u / 2,
              y: D[1] - h / 2,
              width: u,
              height: h
            },
            style: P
          });
        } else {
          if (isNaN(v.get(_[1], I)))
            continue;
          x = new nt({
            z2: 1,
            shape: s.dataToRect([v.get(_[0], I)]).contentShape,
            style: P
          });
        }
        if (v.hasItemOption) {
          var $ = v.getItemModel(I), k = $.getModel("emphasis");
          O = k.getModel("itemStyle").getItemStyle(), m = $.getModel(["blur", "itemStyle"]).getItemStyle(), E = $.getModel(["select", "itemStyle"]).getItemStyle(), b = $.get(["itemStyle", "borderRadius"]), y = k.get("focus"), A = k.get("blurScope"), C = k.get("disabled"), T = Cr($);
        }
        x.shape.r = b;
        var G = t.getRawValue(I), F = "-";
        G && G[2] != null && (F = G[2] + ""), Zr(x, T, {
          labelFetcher: t,
          labelDataIndex: I,
          defaultOpacity: P.opacity,
          defaultText: F
        }), x.ensureState("emphasis").style = O, x.ensureState("blur").style = m, x.ensureState("select").style = E, zt(x, y, A, C), x.incremental = o, o && (x.states.emphasis.hoverLayer = !0), g.add(x), v.setItemGraphicEl(I, x), this._progressiveEls && this._progressiveEls.push(x);
      }
    }, e.prototype._renderOnGeo = function(t, i, n, a) {
      var o = n.targetVisuals.inRange, s = n.targetVisuals.outOfRange, l = i.getData(), u = this._hmLayer || this._hmLayer || new jme();
      u.blurSize = i.get("blurSize"), u.pointSize = i.get("pointSize"), u.minOpacity = i.get("minOpacity"), u.maxOpacity = i.get("maxOpacity");
      var h = t.getViewRect().clone(), c = t.getRoamTransform();
      h.applyTransform(c);
      var f = Math.max(h.x, 0), d = Math.max(h.y, 0), p = Math.min(h.width + h.x, a.getWidth()), g = Math.min(h.height + h.y, a.getHeight()), v = p - f, O = g - d, m = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], E = l.mapArray(m, function(y, A, C) {
        var _ = t.dataToPoint([y, A]);
        return _[0] -= f, _[1] -= d, _.push(C), _;
      }), b = n.getExtent(), T = n.type === "visualMap.continuous" ? Jme(b, n.option.range) : Kme(b, n.getPieceList(), n.option.selected);
      u.update(E, v, O, o.color.getNormalizer(), {
        inRange: o.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, T);
      var S = new qr({
        style: {
          width: v,
          height: O,
          x: f,
          y: d,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(S);
    }, e.type = "heatmap", e;
  }(Mt)
);
const tEe = eEe;
var rEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return ts(null, this, {
        generateCoord: "value"
      });
    }, e.prototype.preventIncremental = function() {
      var t = Xg.get(this.get("coordinateSystem"));
      if (t && t.dimensions)
        return t.dimensions[0] === "lng" && t.dimensions[1] === "lat";
    }, e.type = "series.heatmap", e.dependencies = ["grid", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Xt)
);
const iEe = rEe;
function nEe(r) {
  r.registerChartView(tEe), r.registerSeriesModel(iEe);
}
var aEe = ["itemStyle", "borderWidth"], W2 = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], k0 = new uo(), oEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this.group, o = t.getData(), s = this._data, l = t.coordinateSystem, u = l.getBaseAxis(), h = u.isHorizontal(), c = l.master.getRect(), f = {
        ecSize: {
          width: n.getWidth(),
          height: n.getHeight()
        },
        seriesModel: t,
        coordSys: l,
        coordSysExtent: [[c.x, c.x + c.width], [c.y, c.y + c.height]],
        isHorizontal: h,
        valueDim: W2[+h],
        categoryDim: W2[1 - +h]
      };
      return o.diff(s).add(function(d) {
        if (o.hasValue(d)) {
          var p = Z2(o, d), g = z2(o, d, p, f), v = q2(o, f, g);
          o.setItemGraphicEl(d, v), a.add(v), K2(v, f, g);
        }
      }).update(function(d, p) {
        var g = s.getItemGraphicEl(p);
        if (!o.hasValue(d)) {
          a.remove(g);
          return;
        }
        var v = Z2(o, d), O = z2(o, d, v, f), m = _z(o, O);
        g && m !== g.__pictorialShapeStr && (a.remove(g), o.setItemGraphicEl(d, null), g = null), g ? dEe(g, f, O) : g = q2(o, f, O, !0), o.setItemGraphicEl(d, g), g.__pictorialSymbolMeta = O, a.add(g), K2(g, f, O);
      }).remove(function(d) {
        var p = s.getItemGraphicEl(d);
        p && j2(s, d, p.__pictorialSymbolMeta.animationModel, p);
      }).execute(), this._data = o, this.group;
    }, e.prototype.remove = function(t, i) {
      var n = this.group, a = this._data;
      t.get("animation") ? a && a.eachItemGraphicEl(function(o) {
        j2(a, _e(o).dataIndex, t, o);
      }) : n.removeAll();
    }, e.type = "pictorialBar", e;
  }(Mt)
);
function z2(r, e, t, i) {
  var n = r.getItemLayout(e), a = t.get("symbolRepeat"), o = t.get("symbolClip"), s = t.get("symbolPosition") || "start", l = t.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, h = t.get("symbolPatternSize") || 2, c = t.isAnimationEnabled(), f = {
    dataIndex: e,
    layout: n,
    itemModel: t,
    symbolType: r.getItemVisual(e, "symbol") || "circle",
    style: r.getItemVisual(e, "style"),
    symbolClip: o,
    symbolRepeat: a,
    symbolRepeatDirection: t.get("symbolRepeatDirection"),
    symbolPatternSize: h,
    rotation: u,
    animationModel: c ? t : null,
    hoverScale: c && t.get(["emphasis", "scale"]),
    z2: t.getShallow("z", !0) || 0
  };
  sEe(t, a, n, i, f), lEe(r, e, n, a, o, f.boundingLength, f.pxSign, h, i, f), uEe(t, f.symbolScale, u, i, f);
  var d = f.symbolSize, p = Th(t.get("symbolOffset"), d);
  return hEe(t, d, n, a, o, p, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, i, f), f;
}
function sEe(r, e, t, i, n) {
  var a = i.valueDim, o = r.get("symbolBoundingData"), s = i.coordSys.getOtherAxis(i.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(t[a.wh] <= 0), h;
  if (X(o)) {
    var c = [Q0(s, o[0]) - l, Q0(s, o[1]) - l];
    c[1] < c[0] && c.reverse(), h = c[u];
  } else
    o != null ? h = Q0(s, o) - l : e ? h = i.coordSysExtent[a.index][u] - l : h = t[a.wh];
  n.boundingLength = h, e && (n.repeatCutLength = t[a.wh]), n.pxSign = h > 0 ? 1 : -1;
}
function Q0(r, e) {
  return r.toGlobalCoord(r.dataToCoord(r.scale.parse(e)));
}
function lEe(r, e, t, i, n, a, o, s, l, u) {
  var h = l.valueDim, c = l.categoryDim, f = Math.abs(t[c.wh]), d = r.getItemVisual(e, "symbolSize"), p;
  X(d) ? p = d.slice() : d == null ? p = ["100%", "100%"] : p = [d, d], p[c.index] = K(p[c.index], f), p[h.index] = K(p[h.index], i ? f : Math.abs(a)), u.symbolSize = p;
  var g = u.symbolScale = [p[0] / s, p[1] / s];
  g[h.index] *= (l.isHorizontal ? -1 : 1) * o;
}
function uEe(r, e, t, i, n) {
  var a = r.get(aEe) || 0;
  a && (k0.attr({
    scaleX: e[0],
    scaleY: e[1],
    rotation: t
  }), k0.updateTransform(), a /= k0.getLineScale(), a *= e[i.valueDim.index]), n.valueLineWidth = a || 0;
}
function hEe(r, e, t, i, n, a, o, s, l, u, h, c) {
  var f = h.categoryDim, d = h.valueDim, p = c.pxSign, g = Math.max(e[d.index] + s, 0), v = g;
  if (i) {
    var O = Math.abs(l), m = Dr(r.get("symbolMargin"), "15%") + "", E = !1;
    m.lastIndexOf("!") === m.length - 1 && (E = !0, m = m.slice(0, m.length - 1));
    var b = K(m, e[d.index]), T = Math.max(g + b * 2, 0), S = E ? 0 : b * 2, y = pX(i), A = y ? i : J2((O + S) / T), C = O - A * g;
    b = C / 2 / (E ? A : Math.max(A - 1, 1)), T = g + b * 2, S = E ? 0 : b * 2, !y && i !== "fixed" && (A = u ? J2((Math.abs(u) + S) / T) : 0), v = A * T - S, c.repeatTimes = A, c.symbolMargin = b;
  }
  var _ = p * (v / 2), I = c.pathPosition = [];
  I[f.index] = t[f.wh] / 2, I[d.index] = o === "start" ? _ : o === "end" ? l - _ : l / 2, a && (I[0] += a[0], I[1] += a[1]);
  var x = c.bundlePosition = [];
  x[f.index] = t[f.xy], x[d.index] = t[d.xy];
  var P = c.barRectShape = V({}, t);
  P[d.wh] = p * Math.max(Math.abs(t[d.wh]), Math.abs(I[d.index] + _)), P[f.wh] = t[f.wh];
  var N = c.clipShape = {};
  N[f.xy] = -t[f.xy], N[f.wh] = h.ecSize[f.wh], N[d.xy] = 0, N[d.wh] = t[d.wh];
}
function Tz(r) {
  var e = r.symbolPatternSize, t = ur(
    // Consider texture img, make a big size.
    r.symbolType,
    -e / 2,
    -e / 2,
    e,
    e
  );
  return t.attr({
    culling: !0
  }), t.type !== "image" && t.setStyle({
    strokeNoScale: !0
  }), t;
}
function yz(r, e, t, i) {
  var n = r.__pictorialBundle, a = t.symbolSize, o = t.valueLineWidth, s = t.pathPosition, l = e.valueDim, u = t.repeatTimes || 0, h = 0, c = a[e.valueDim.index] + o + t.symbolMargin * 2;
  for (Jx(r, function(g) {
    g.__pictorialAnimationIndex = h, g.__pictorialRepeatTimes = u, h < u ? Dc(g, null, p(h), t, i) : Dc(g, null, {
      scaleX: 0,
      scaleY: 0
    }, t, i, function() {
      n.remove(g);
    }), h++;
  }); h < u; h++) {
    var f = Tz(t);
    f.__pictorialAnimationIndex = h, f.__pictorialRepeatTimes = u, n.add(f);
    var d = p(h);
    Dc(f, {
      x: d.x,
      y: d.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: d.scaleX,
      scaleY: d.scaleY,
      rotation: d.rotation
    }, t, i);
  }
  function p(g) {
    var v = s.slice(), O = t.pxSign, m = g;
    return (t.symbolRepeatDirection === "start" ? O > 0 : O < 0) && (m = u - 1 - g), v[l.index] = c * (m - u / 2 + 0.5) + s[l.index], {
      x: v[0],
      y: v[1],
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1],
      rotation: t.rotation
    };
  }
}
function Rz(r, e, t, i) {
  var n = r.__pictorialBundle, a = r.__pictorialMainPath;
  a ? Dc(a, null, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1],
    rotation: t.rotation
  }, t, i) : (a = r.__pictorialMainPath = Tz(t), n.add(a), Dc(a, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: t.rotation
  }, {
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1]
  }, t, i));
}
function Az(r, e, t) {
  var i = V({}, e.barRectShape), n = r.__pictorialBarRect;
  n ? Dc(n, null, {
    shape: i
  }, e, t) : (n = r.__pictorialBarRect = new nt({
    z2: 2,
    shape: i,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), n.disableMorphing = !0, r.add(n));
}
function Cz(r, e, t, i) {
  if (t.symbolClip) {
    var n = r.__pictorialClipPath, a = V({}, t.clipShape), o = e.valueDim, s = t.animationModel, l = t.dataIndex;
    if (n)
      ft(n, {
        shape: a
      }, s, l);
    else {
      a[o.wh] = 0, n = new nt({
        shape: a
      }), r.__pictorialBundle.setClipPath(n), r.__pictorialClipPath = n;
      var u = {};
      u[o.wh] = t.clipShape[o.wh], Fg[i ? "updateProps" : "initProps"](n, {
        shape: u
      }, s, l);
    }
  }
}
function Z2(r, e) {
  var t = r.getItemModel(e);
  return t.getAnimationDelayParams = cEe, t.isAnimationEnabled = fEe, t;
}
function cEe(r) {
  return {
    index: r.__pictorialAnimationIndex,
    count: r.__pictorialRepeatTimes
  };
}
function fEe() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function q2(r, e, t, i) {
  var n = new ye(), a = new ye();
  return n.add(a), n.__pictorialBundle = a, a.x = t.bundlePosition[0], a.y = t.bundlePosition[1], t.symbolRepeat ? yz(n, e, t) : Rz(n, e, t), Az(n, t, i), Cz(n, e, t, i), n.__pictorialShapeStr = _z(r, t), n.__pictorialSymbolMeta = t, n;
}
function dEe(r, e, t) {
  var i = t.animationModel, n = t.dataIndex, a = r.__pictorialBundle;
  ft(a, {
    x: t.bundlePosition[0],
    y: t.bundlePosition[1]
  }, i, n), t.symbolRepeat ? yz(r, e, t, !0) : Rz(r, e, t, !0), Az(r, t, !0), Cz(r, e, t, !0);
}
function j2(r, e, t, i) {
  var n = i.__pictorialBarRect;
  n && n.removeTextContent();
  var a = [];
  Jx(i, function(o) {
    a.push(o);
  }), i.__pictorialMainPath && a.push(i.__pictorialMainPath), i.__pictorialClipPath && (t = null), w(a, function(o) {
    al(o, {
      scaleX: 0,
      scaleY: 0
    }, t, e, function() {
      i.parent && i.parent.remove(i);
    });
  }), r.setItemGraphicEl(e, null);
}
function _z(r, e) {
  return [r.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":");
}
function Jx(r, e, t) {
  w(r.__pictorialBundle.children(), function(i) {
    i !== r.__pictorialBarRect && e.call(t, i);
  });
}
function Dc(r, e, t, i, n, a) {
  e && r.attr(e), i.symbolClip && !n ? t && r.attr(t) : t && Fg[n ? "updateProps" : "initProps"](r, t, i.animationModel, i.dataIndex, a);
}
function K2(r, e, t) {
  var i = t.dataIndex, n = t.itemModel, a = n.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = n.getModel(["blur", "itemStyle"]).getItemStyle(), l = n.getModel(["select", "itemStyle"]).getItemStyle(), u = n.getShallow("cursor"), h = a.get("focus"), c = a.get("blurScope"), f = a.get("scale");
  Jx(r, function(g) {
    if (g instanceof qr) {
      var v = g.style;
      g.useStyle(V({
        // TODO other properties like dx, dy ?
        image: v.image,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      }, t.style));
    } else
      g.useStyle(t.style);
    var O = g.ensureState("emphasis");
    O.style = o, f && (O.scaleX = g.scaleX * 1.1, O.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = s, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = t.z2;
  });
  var d = e.valueDim.posDesc[+(t.boundingLength > 0)], p = r.__pictorialBarRect;
  Zr(p, Cr(n), {
    labelFetcher: e.seriesModel,
    labelDataIndex: i,
    defaultText: tf(e.seriesModel.getData(), i),
    inheritColor: t.style.fill,
    defaultOpacity: t.style.opacity,
    defaultOutsidePosition: d
  }), zt(r, h, c, a.get("disabled"));
}
function J2(r) {
  var e = Math.round(r);
  return Math.abs(r - e) < 1e-4 ? e : Math.ceil(r);
}
const pEe = oEe;
var gEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t.defaultSymbol = "roundRect", t;
    }
    return e.prototype.getInitialData = function(t) {
      return t.stack = null, r.prototype.getInitialData.apply(this, arguments);
    }, e.type = "series.pictorialBar", e.dependencies = ["grid"], e.defaultOption = yl(GE.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), e;
  }(GE)
);
const vEe = gEe;
function OEe(r) {
  r.registerChartView(pEe), r.registerSeriesModel(vEe), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Ie(lW, "pictorialBar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, uW("pictorialBar"));
}
var mEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._layers = [], t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this, s = this.group, l = t.getLayerSeries(), u = a.getLayout("layoutInfo"), h = u.rect, c = u.boundaryGap;
      s.x = 0, s.y = h.y + c[0];
      function f(v) {
        return v.name;
      }
      var d = new Ho(this._layersSeries || [], l, f, f), p = [];
      d.add(ae(g, this, "add")).update(ae(g, this, "update")).remove(ae(g, this, "remove")).execute();
      function g(v, O, m) {
        var E = o._layers;
        if (v === "remove") {
          s.remove(E[O]);
          return;
        }
        for (var b = [], T = [], S, y = l[O].indices, A = 0; A < y.length; A++) {
          var C = a.getItemLayout(y[A]), _ = C.x, I = C.y0, x = C.y;
          b.push(_, I), T.push(_, I + x), S = a.getItemVisual(y[A], "style");
        }
        var P, N = a.getItemLayout(y[0]), L = t.getModel("label"), D = L.get("margin"), $ = t.getModel("emphasis");
        if (v === "add") {
          var k = p[O] = new ye();
          P = new jW({
            shape: {
              points: b,
              stackedOnPoints: T,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), k.add(P), s.add(k), t.isAnimationEnabled() && P.setClipPath(EEe(P.getBoundingRect(), t, function() {
            P.removeClipPath();
          }));
        } else {
          var k = E[m];
          P = k.childAt(0), s.add(k), p[O] = k, ft(P, {
            shape: {
              points: b,
              stackedOnPoints: T
            }
          }, t), ba(P);
        }
        Zr(P, Cr(t), {
          labelDataIndex: y[A - 1],
          defaultText: a.getName(y[A - 1]),
          inheritColor: S.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), P.setTextConfig({
          position: null,
          local: !0
        });
        var G = P.getTextContent();
        G && (G.x = N.x - D, G.y = N.y0 + N.y / 2), P.useStyle(S), a.setItemGraphicEl(O, P), zr(P, t), zt(P, $.get("focus"), $.get("blurScope"), $.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, e.type = "themeRiver", e;
  }(Mt)
);
function EEe(r, e, t) {
  var i = new nt({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return Ut(i, {
    shape: {
      x: r.x - 50,
      width: r.width + 100,
      height: r.height + 20
    }
  }, e, t), i;
}
const bEe = mEe;
var U0 = 2, SEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Jg(ae(this.getData, this), ae(this.getRawData, this));
    }, e.prototype.fixData = function(t) {
      var i = t.length, n = {}, a = WA(t, function(f) {
        return n.hasOwnProperty(f[0] + "") || (n[f[0] + ""] = -1), f[2];
      }), o = [];
      a.buckets.each(function(f, d) {
        o.push({
          name: d,
          dataList: f
        });
      });
      for (var s = o.length, l = 0; l < s; ++l) {
        for (var u = o[l].name, h = 0; h < o[l].dataList.length; ++h) {
          var c = o[l].dataList[h][0] + "";
          n[c] = l;
        }
        for (var c in n)
          n.hasOwnProperty(c) && n[c] !== l && (n[c] = l, t[i] = [c, 0, u], i++);
      }
      return t;
    }, e.prototype.getInitialData = function(t, i) {
      for (var n = this.getReferringComponents("singleAxis", lr).models[0], a = n.get("type"), o = yt(t.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(o || []), l = [], u = this.nameMap = ce(), h = 0, c = 0; c < s.length; ++c)
        l.push(s[c][U0]), u.get(s[c][U0]) || (u.set(s[c][U0], h), h++);
      var f = Hg(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: ME(a)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new Ai(f, this);
      return d.initData(s), d;
    }, e.prototype.getLayerSeries = function() {
      for (var t = this.getData(), i = t.count(), n = [], a = 0; a < i; ++a)
        n[a] = a;
      var o = t.mapDimension("single"), s = WA(n, function(u) {
        return t.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, h) {
        u.sort(function(c, f) {
          return t.get(o, c) - t.get(o, f);
        }), l.push({
          name: h,
          indices: u
        });
      }), l;
    }, e.prototype.getAxisTooltipData = function(t, i, n) {
      X(t) || (t = t ? [t] : []);
      for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, h = 0; h < l; ++h) {
        for (var c = Number.MAX_VALUE, f = -1, d = o[h].indices.length, p = 0; p < d; ++p) {
          var g = a.get(t[0], o[h].indices[p]), v = Math.abs(g - i);
          v <= c && (u = g, c = v, f = o[h].indices[p]);
        }
        s.push(f);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = a.getName(t), s = a.get(a.mapDimension("value"), t);
      return _r("nameValue", {
        name: o,
        value: s
      });
    }, e.type = "series.themeRiver", e.dependencies = ["singleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(Xt)
);
const TEe = SEe;
function yEe(r, e) {
  r.eachSeriesByType("themeRiver", function(t) {
    var i = t.getData(), n = t.coordinateSystem, a = {}, o = n.getRect();
    a.rect = o;
    var s = t.get("boundaryGap"), l = n.getAxis();
    if (a.boundaryGap = s, l.orient === "horizontal") {
      s[0] = K(s[0], o.height), s[1] = K(s[1], o.height);
      var u = o.height - s[0] - s[1];
      eQ(i, t, u);
    } else {
      s[0] = K(s[0], o.width), s[1] = K(s[1], o.width);
      var h = o.width - s[0] - s[1];
      eQ(i, t, h);
    }
    i.setLayout("layoutInfo", a);
  });
}
function eQ(r, e, t) {
  if (r.count())
    for (var i = e.coordinateSystem, n = e.getLayerSeries(), a = r.mapDimension("single"), o = r.mapDimension("value"), s = Y(n, function(v) {
      return Y(v.indices, function(O) {
        var m = i.dataToPoint(r.get(a, O));
        return m[1] = r.get(o, O), m;
      });
    }), l = REe(s), u = l.y0, h = t / l.max, c = n.length, f = n[0].indices.length, d, p = 0; p < f; ++p) {
      d = u[p] * h, r.setItemLayout(n[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: d,
        y: s[0][p][1] * h
      });
      for (var g = 1; g < c; ++g)
        d += s[g - 1][p][1] * h, r.setItemLayout(n[g].indices[p], {
          layerIndex: g,
          x: s[g][p][0],
          y0: d,
          y: s[g][p][1] * h
        });
    }
}
function REe(r) {
  for (var e = r.length, t = r[0].length, i = [], n = [], a = 0, o = 0; o < t; ++o) {
    for (var s = 0, l = 0; l < e; ++l)
      s += r[l][o][1];
    s > a && (a = s), i.push(s);
  }
  for (var u = 0; u < t; ++u)
    n[u] = (a - i[u]) / 2;
  a = 0;
  for (var h = 0; h < t; ++h) {
    var c = i[h] + n[h];
    c > a && (a = c);
  }
  return {
    y0: n,
    max: a
  };
}
function AEe(r) {
  r.registerChartView(bEe), r.registerSeriesModel(TEe), r.registerLayout(yEe), r.registerProcessor(Kg("themeRiver"));
}
var CEe = 2, _Ee = 4, IEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n, a) {
      var o = r.call(this) || this;
      o.z2 = CEe, o.textConfig = {
        inside: !0
      }, _e(o).seriesIndex = i.seriesIndex;
      var s = new lt({
        z2: _Ee,
        silent: t.getModel().get(["label", "silent"])
      });
      return o.setTextContent(s), o.updateData(!0, t, i, n, a), o;
    }
    return e.prototype.updateData = function(t, i, n, a, o) {
      this.node = i, i.piece = this, n = n || this._seriesModel, a = a || this._ecModel;
      var s = this;
      _e(s).dataIndex = i.dataIndex;
      var l = i.getModel(), u = l.getModel("emphasis"), h = i.getLayout(), c = V({}, h);
      c.label = null;
      var f = i.getVisual("style");
      f.lineJoin = "bevel";
      var d = i.getVisual("decal");
      d && (f.decal = Jc(d, o));
      var p = _u(l.getModel("itemStyle"), c, !0);
      V(c, p), w(Ii, function(m) {
        var E = s.ensureState(m), b = l.getModel([m, "itemStyle"]);
        E.style = b.getItemStyle();
        var T = _u(b, c);
        T && (E.shape = T);
      }), t ? (s.setShape(c), s.shape.r = h.r0, Ut(s, {
        shape: {
          r: h.r
        }
      }, n, i.dataIndex)) : (ft(s, {
        shape: c
      }, n), ba(s)), s.useStyle(f), this._updateLabel(n);
      var g = l.getShallow("cursor");
      g && s.attr("cursor", g), this._seriesModel = n || this._seriesModel, this._ecModel = a || this._ecModel;
      var v = u.get("focus"), O = v === "ancestor" ? i.getAncestorsIndices() : v === "descendant" ? i.getDescendantIndices() : v;
      zt(this, O, u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t) {
      var i = this, n = this.node.getModel(), a = n.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), h = Math.sin(l), c = this, f = c.getTextContent(), d = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, g = a.get("show") && !(p != null && Math.abs(s) < p);
      f.ignore = !g, w(Yp, function(O) {
        var m = O === "normal" ? n.getModel("label") : n.getModel([O, "label"]), E = O === "normal", b = E ? f : f.ensureState(O), T = t.getFormattedLabel(d, O);
        E && (T = T || i.node.name), b.style = Lt(m, {}, null, O !== "normal", !0), T && (b.style.text = T);
        var S = m.get("show");
        S != null && !E && (b.ignore = !S);
        var y = v(m, "position"), A = E ? c : c.states[O], C = A.style.fill;
        A.textConfig = {
          outsideFill: m.get("color") === "inherit" ? C : null,
          inside: y !== "outside"
        };
        var _, I = v(m, "distance") || 0, x = v(m, "align");
        y === "outside" ? (_ = o.r + I, x = l > Math.PI / 2 ? "right" : "left") : !x || x === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? _ = 0 : _ = (o.r + o.r0) / 2, x = "center") : x === "left" ? (_ = o.r0 + I, l > Math.PI / 2 && (x = "right")) : x === "right" && (_ = o.r - I, l > Math.PI / 2 && (x = "left")), b.style.align = x, b.style.verticalAlign = v(m, "verticalAlign") || "middle", b.x = _ * u + o.cx, b.y = _ * h + o.cy;
        var P = v(m, "rotate"), N = 0;
        P === "radial" ? (N = ca(-l), N > Math.PI / 2 && N < Math.PI * 1.5 && (N += Math.PI)) : P === "tangential" ? (N = Math.PI / 2 - l, N > Math.PI / 2 ? N -= Math.PI : N < -Math.PI / 2 && (N += Math.PI)) : ut(P) && (N = P * Math.PI / 180), b.rotation = ca(N);
      });
      function v(O, m) {
        var E = O.get(m);
        return E ?? a.get(m);
      }
      f.dirtyStyle();
    }, e;
  }(Xi)
);
const tQ = IEe;
var YC = "sunburstRootToNode", rQ = "sunburstHighlight", xEe = "sunburstUnhighlight";
function wEe(r) {
  r.registerAction({
    type: YC,
    update: "updateView"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, i);
    function i(n, a) {
      var o = ag(e, [YC], n);
      if (o) {
        var s = n.getViewRoot();
        s && (e.direction = Ux(s, o.node) ? "rollUp" : "drillDown"), n.resetViewRoot(o.node);
      }
    }
  }), r.registerAction({
    type: rQ,
    update: "none"
  }, function(e, t, i) {
    e = V({}, e), t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, n);
    function n(a) {
      var o = ag(e, [rQ], a);
      o && (e.dataIndex = o.node.dataIndex);
    }
    i.dispatchAction(V(e, {
      type: "highlight"
    }));
  }), r.registerAction({
    type: xEe,
    update: "updateView"
  }, function(e, t, i) {
    e = V({}, e), i.dispatchAction(V(e, {
      type: "downplay"
    }));
  });
}
var PEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = this;
      this.seriesModel = t, this.api = n, this.ecModel = i;
      var s = t.getData(), l = s.tree.root, u = t.getViewRoot(), h = this.group, c = t.get("renderLabelForZeroData"), f = [];
      u.eachNode(function(m) {
        f.push(m);
      });
      var d = this._oldChildren || [];
      p(f, d), O(l, u), this._initEvents(), this._oldChildren = f;
      function p(m, E) {
        if (m.length === 0 && E.length === 0)
          return;
        new Ho(E, m, b, b).add(T).update(T).remove(Ie(T, null)).execute();
        function b(S) {
          return S.getId();
        }
        function T(S, y) {
          var A = S == null ? null : m[S], C = y == null ? null : E[y];
          g(A, C);
        }
      }
      function g(m, E) {
        if (!c && m && !m.getValue() && (m = null), m !== l && E !== l) {
          if (E && E.piece)
            m ? (E.piece.updateData(!1, m, t, i, n), s.setItemGraphicEl(m.dataIndex, E.piece)) : v(E);
          else if (m) {
            var b = new tQ(m, t, i, n);
            h.add(b), s.setItemGraphicEl(m.dataIndex, b);
          }
        }
      }
      function v(m) {
        m && m.piece && (h.remove(m.piece), m.piece = null);
      }
      function O(m, E) {
        E.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, m, t, i, n) : (o.virtualPiece = new tQ(m, t, i, n), h.add(o.virtualPiece)), E.piece.off("click"), o.virtualPiece.on("click", function(b) {
          o._rootToNode(E.parentNode);
        })) : o.virtualPiece && (h.remove(o.virtualPiece), o.virtualPiece = null);
      }
    }, e.prototype._initEvents = function() {
      var t = this;
      this.group.off("click"), this.group.on("click", function(i) {
        var n = !1, a = t.seriesModel.getViewRoot();
        a.eachNode(function(o) {
          if (!n && o.piece && o.piece === i.target) {
            var s = o.getModel().get("nodeClick");
            if (s === "rootToNode")
              t._rootToNode(o);
            else if (s === "link") {
              var l = o.getModel(), u = l.get("link");
              if (u) {
                var h = l.get("target", !0) || "_blank";
                CE(u, h);
              }
            }
            n = !0;
          }
        });
      });
    }, e.prototype._rootToNode = function(t) {
      t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: YC,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t
      });
    }, e.prototype.containPoint = function(t, i) {
      var n = i.getData(), a = n.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "sunburst", e;
  }(Mt)
);
const NEe = PEe;
var LEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      var n = {
        name: t.name,
        children: t.data
      };
      Iz(n);
      var a = this._levelModels = Y(t.levels || [], function(l) {
        return new Dt(l, this, i);
      }, this), o = Qx.createTree(n, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, h) {
          var c = o.getNodeByDataIndex(h), f = a[c.depth];
          return f && (u.parentModel = f), u;
        });
      }
      return o.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.getDataParams = function(t) {
      var i = r.prototype.getDataParams.apply(this, arguments), n = this.getData().tree.getNodeByDataIndex(t);
      return i.treePathInfo = WS(n, this), i;
    }, e.prototype.getLevelModel = function(t) {
      return this._levelModels && this._levelModels[t.depth];
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var i = this.getRawData().tree.root;
      (!t || t !== i && !i.contains(t)) && (this._viewRoot = i);
    }, e.prototype.enableAriaDecal = function() {
      N3(this);
    }, e.type = "series.sunburst", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      // 0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, e;
  }(Xt)
);
function Iz(r) {
  var e = 0;
  w(r.children, function(i) {
    Iz(i);
    var n = i.value;
    X(n) && (n = n[0]), e += n;
  });
  var t = r.value;
  X(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), X(r.value) ? r.value[0] = t : r.value = t;
}
const DEe = LEe;
var iQ = Math.PI / 180;
function MEe(r, e, t) {
  e.eachSeriesByType(r, function(i) {
    var n = i.get("center"), a = i.get("radius");
    X(a) || (a = [0, a]), X(n) || (n = [n, n]);
    var o = t.getWidth(), s = t.getHeight(), l = Math.min(o, s), u = K(n[0], o), h = K(n[1], s), c = K(a[0], l / 2), f = K(a[1], l / 2), d = -i.get("startAngle") * iQ, p = i.get("minAngle") * iQ, g = i.getData().tree.root, v = i.getViewRoot(), O = v.depth, m = i.get("sort");
    m != null && xz(v, m);
    var E = 0;
    w(v.children, function(D) {
      !isNaN(D.getValue()) && E++;
    });
    var b = v.getValue(), T = Math.PI / (b || E) * 2, S = v.depth > 0, y = v.height - (S ? -1 : 1), A = (f - c) / (y || 1), C = i.get("clockwise"), _ = i.get("stillShowZeroSum"), I = C ? 1 : -1, x = function(D, $) {
      if (D) {
        var k = $;
        if (D !== g) {
          var G = D.getValue(), F = b === 0 && _ ? T : G * T;
          F < p && (F = p), k = $ + I * F;
          var q = D.depth - O - (S ? -1 : 1), re = c + A * q, fe = c + A * (q + 1), de = i.getLevelModel(D);
          if (de) {
            var $e = de.get("r0", !0), Pe = de.get("r", !0), Ne = de.get("radius", !0);
            Ne != null && ($e = Ne[0], Pe = Ne[1]), $e != null && (re = K($e, l / 2)), Pe != null && (fe = K(Pe, l / 2));
          }
          D.setLayout({
            angle: F,
            startAngle: $,
            endAngle: k,
            clockwise: C,
            cx: u,
            cy: h,
            r0: re,
            r: fe
          });
        }
        if (D.children && D.children.length) {
          var Ee = 0;
          w(D.children, function(xe) {
            Ee += x(xe, $ + Ee);
          });
        }
        return k - $;
      }
    };
    if (S) {
      var P = c, N = c + A, L = Math.PI * 2;
      g.setLayout({
        angle: L,
        startAngle: d,
        endAngle: d + L,
        clockwise: C,
        cx: u,
        cy: h,
        r0: P,
        r: N
      });
    }
    x(v, d);
  });
}
function xz(r, e) {
  var t = r.children || [];
  r.children = kEe(t, e), t.length && w(r.children, function(i) {
    xz(i, e);
  });
}
function kEe(r, e) {
  if (ve(e)) {
    var t = Y(r, function(n, a) {
      var o = n.getValue();
      return {
        params: {
          depth: n.depth,
          height: n.height,
          dataIndex: n.dataIndex,
          getValue: function() {
            return o;
          }
        },
        index: a
      };
    });
    return t.sort(function(n, a) {
      return e(n.params, a.params);
    }), Y(t, function(n) {
      return r[n.index];
    });
  } else {
    var i = e === "asc";
    return r.sort(function(n, a) {
      var o = (n.getValue() - a.getValue()) * (i ? 1 : -1);
      return o === 0 ? (n.dataIndex - a.dataIndex) * (i ? -1 : 1) : o;
    });
  }
}
function QEe(r) {
  var e = {};
  function t(i, n, a) {
    for (var o = i; o && o.depth > 1; )
      o = o.parentNode;
    var s = n.getColorFromPalette(o.name || o.dataIndex + "", e);
    return i.depth > 1 && ne(s) && (s = QA(s, (i.depth - 1) / (a - 1) * 0.5)), s;
  }
  r.eachSeriesByType("sunburst", function(i) {
    var n = i.getData(), a = n.tree;
    a.eachNode(function(o) {
      var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = t(o, i, a.root.height));
      var u = n.ensureUniqueItemVisual(o.dataIndex, "style");
      V(u, l);
    });
  });
}
function UEe(r) {
  r.registerChartView(NEe), r.registerSeriesModel(DEe), r.registerLayout(Ie(MEe, "sunburst")), r.registerProcessor(Ie(Kg, "sunburst")), r.registerVisual(QEe), wEe(r);
}
var nQ = {
  color: "fill",
  borderColor: "stroke"
}, $Ee = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, Qo = at(), GEe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, e.prototype.getInitialData = function(t, i) {
      return ts(null, this);
    }, e.prototype.getDataParams = function(t, i, n) {
      var a = r.prototype.getDataParams.call(this, t, i);
      return n && (a.info = Qo(n).info), a;
    }, e.type = "series.custom", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, e;
  }(Xt)
);
const BEe = GEe;
function VEe(r, e) {
  return e = e || [0, 0], Y(["x", "y"], function(t, i) {
    var n = this.getAxis(t), a = e[i], o = r[i] / 2;
    return n.type === "category" ? n.getBandWidth() : Math.abs(n.dataToCoord(a - o) - n.dataToCoord(a + o));
  }, this);
}
function FEe(r) {
  var e = r.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return r.dataToPoint(t);
      },
      size: ae(VEe, r)
    }
  };
}
function XEe(r, e) {
  return e = e || [0, 0], Y([0, 1], function(t) {
    var i = e[t], n = r[t] / 2, a = [], o = [];
    return a[t] = i - n, o[t] = i + n, a[1 - t] = o[1 - t] = e[1 - t], Math.abs(this.dataToPoint(a)[t] - this.dataToPoint(o)[t]);
  }, this);
}
function YEe(r) {
  var e = r.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      zoom: r.getZoom()
    },
    api: {
      coord: function(t) {
        return r.dataToPoint(t);
      },
      size: ae(XEe, r)
    }
  };
}
function HEe(r, e) {
  var t = this.getAxis(), i = e instanceof Array ? e[0] : e, n = (r instanceof Array ? r[0] : r) / 2;
  return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(i - n) - t.dataToCoord(i + n));
}
function WEe(r) {
  var e = r.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return r.dataToPoint(t);
      },
      size: ae(HEe, r)
    }
  };
}
function zEe(r, e) {
  return e = e || [0, 0], Y(["Radius", "Angle"], function(t, i) {
    var n = "get" + t + "Axis", a = this[n](), o = e[i], s = r[i] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
    return t === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function ZEe(r) {
  var e = r.getRadiusAxis(), t = r.getAngleAxis(), i = e.getExtent();
  return i[0] > i[1] && i.reverse(), {
    coordSys: {
      type: "polar",
      cx: r.cx,
      cy: r.cy,
      r: i[1],
      r0: i[0]
    },
    api: {
      coord: function(n) {
        var a = e.dataToRadius(n[0]), o = t.dataToAngle(n[1]), s = r.coordToPoint([a, o]);
        return s.push(a, o * Math.PI / 180), s;
      },
      size: ae(zEe, r)
    }
  };
}
function qEe(r) {
  var e = r.getRect(), t = r.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      cellWidth: r.getCellWidth(),
      cellHeight: r.getCellHeight(),
      rangeInfo: {
        start: t.start,
        end: t.end,
        weeks: t.weeks,
        dayCount: t.allDay
      }
    },
    api: {
      coord: function(i, n) {
        return r.dataToPoint(i, n);
      }
    }
  };
}
function wz(r, e, t, i) {
  return r && (r.legacy || r.legacy !== !1 && !t && !i && e !== "tspan" && (e === "text" || oe(r, "text")));
}
function Pz(r, e, t) {
  var i = r, n, a, o;
  if (e === "text")
    o = i;
  else {
    o = {}, oe(i, "text") && (o.text = i.text), oe(i, "rich") && (o.rich = i.rich), oe(i, "textFill") && (o.fill = i.textFill), oe(i, "textStroke") && (o.stroke = i.textStroke), oe(i, "fontFamily") && (o.fontFamily = i.fontFamily), oe(i, "fontSize") && (o.fontSize = i.fontSize), oe(i, "fontStyle") && (o.fontStyle = i.fontStyle), oe(i, "fontWeight") && (o.fontWeight = i.fontWeight), a = {
      type: "text",
      style: o,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, n = {};
    var s = oe(i, "textPosition");
    t ? n.position = s ? i.textPosition : "inside" : s && (n.position = i.textPosition), oe(i, "textPosition") && (n.position = i.textPosition), oe(i, "textOffset") && (n.offset = i.textOffset), oe(i, "textRotation") && (n.rotation = i.textRotation), oe(i, "textDistance") && (n.distance = i.textDistance);
  }
  return aQ(o, r), w(o.rich, function(l) {
    aQ(l, l);
  }), {
    textConfig: n,
    textContent: a
  };
}
function aQ(r, e) {
  e && (e.font = e.textFont || e.font, oe(e, "textStrokeWidth") && (r.lineWidth = e.textStrokeWidth), oe(e, "textAlign") && (r.align = e.textAlign), oe(e, "textVerticalAlign") && (r.verticalAlign = e.textVerticalAlign), oe(e, "textLineHeight") && (r.lineHeight = e.textLineHeight), oe(e, "textWidth") && (r.width = e.textWidth), oe(e, "textHeight") && (r.height = e.textHeight), oe(e, "textBackgroundColor") && (r.backgroundColor = e.textBackgroundColor), oe(e, "textPadding") && (r.padding = e.textPadding), oe(e, "textBorderColor") && (r.borderColor = e.textBorderColor), oe(e, "textBorderWidth") && (r.borderWidth = e.textBorderWidth), oe(e, "textBorderRadius") && (r.borderRadius = e.textBorderRadius), oe(e, "textBoxShadowColor") && (r.shadowColor = e.textBoxShadowColor), oe(e, "textBoxShadowBlur") && (r.shadowBlur = e.textBoxShadowBlur), oe(e, "textBoxShadowOffsetX") && (r.shadowOffsetX = e.textBoxShadowOffsetX), oe(e, "textBoxShadowOffsetY") && (r.shadowOffsetY = e.textBoxShadowOffsetY));
}
function oQ(r, e, t) {
  var i = r;
  i.textPosition = i.textPosition || t.position || "inside", t.offset != null && (i.textOffset = t.offset), t.rotation != null && (i.textRotation = t.rotation), t.distance != null && (i.textDistance = t.distance);
  var n = i.textPosition.indexOf("inside") >= 0, a = r.fill || "#000";
  sQ(i, e);
  var o = i.textFill == null;
  return n ? o && (i.textFill = t.insideFill || "#fff", !i.textStroke && t.insideStroke && (i.textStroke = t.insideStroke), !i.textStroke && (i.textStroke = a), i.textStrokeWidth == null && (i.textStrokeWidth = 2)) : (o && (i.textFill = r.fill || t.outsideFill || "#000"), !i.textStroke && t.outsideStroke && (i.textStroke = t.outsideStroke)), i.text = e.text, i.rich = e.rich, w(e.rich, function(s) {
    sQ(s, s);
  }), i;
}
function sQ(r, e) {
  e && (oe(e, "fill") && (r.textFill = e.fill), oe(e, "stroke") && (r.textStroke = e.fill), oe(e, "lineWidth") && (r.textStrokeWidth = e.lineWidth), oe(e, "font") && (r.font = e.font), oe(e, "fontStyle") && (r.fontStyle = e.fontStyle), oe(e, "fontWeight") && (r.fontWeight = e.fontWeight), oe(e, "fontSize") && (r.fontSize = e.fontSize), oe(e, "fontFamily") && (r.fontFamily = e.fontFamily), oe(e, "align") && (r.textAlign = e.align), oe(e, "verticalAlign") && (r.textVerticalAlign = e.verticalAlign), oe(e, "lineHeight") && (r.textLineHeight = e.lineHeight), oe(e, "width") && (r.textWidth = e.width), oe(e, "height") && (r.textHeight = e.height), oe(e, "backgroundColor") && (r.textBackgroundColor = e.backgroundColor), oe(e, "padding") && (r.textPadding = e.padding), oe(e, "borderColor") && (r.textBorderColor = e.borderColor), oe(e, "borderWidth") && (r.textBorderWidth = e.borderWidth), oe(e, "borderRadius") && (r.textBorderRadius = e.borderRadius), oe(e, "shadowColor") && (r.textBoxShadowColor = e.shadowColor), oe(e, "shadowBlur") && (r.textBoxShadowBlur = e.shadowBlur), oe(e, "shadowOffsetX") && (r.textBoxShadowOffsetX = e.shadowOffsetX), oe(e, "shadowOffsetY") && (r.textBoxShadowOffsetY = e.shadowOffsetY), oe(e, "textShadowColor") && (r.textShadowColor = e.textShadowColor), oe(e, "textShadowBlur") && (r.textShadowBlur = e.textShadowBlur), oe(e, "textShadowOffsetX") && (r.textShadowOffsetX = e.textShadowOffsetX), oe(e, "textShadowOffsetY") && (r.textShadowOffsetY = e.textShadowOffsetY));
}
var Nz = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, lQ = He(Nz);
no(oo, function(r, e) {
  return r[e] = 1, r;
}, {});
oo.join(", ");
var zE = ["", "style", "shape", "extra"], af = at();
function ew(r, e, t, i, n) {
  var a = r + "Animation", o = Tf(r, i, n) || {}, s = af(e).userDuring;
  return o.duration > 0 && (o.during = s ? ae(tbe, {
    el: e,
    userDuring: s
  }) : null, o.setToFinal = !0, o.scope = r), V(o, t[a]), o;
}
function Am(r, e, t, i) {
  i = i || {};
  var n = i.dataIndex, a = i.isInit, o = i.clearStyle, s = t.isAnimationEnabled(), l = af(r), u = e.style;
  l.userDuring = e.during;
  var h = {}, c = {};
  if (ibe(r, e, c), hQ("shape", e, c), hQ("extra", e, c), !a && s && (rbe(r, e, h), uQ("shape", r, e, h), uQ("extra", r, e, h), nbe(r, e, u, h)), c.style = u, jEe(r, c, o), JEe(r, e), s)
    if (a) {
      var f = {};
      w(zE, function(p) {
        var g = p ? e[p] : e;
        g && g.enterFrom && (p && (f[p] = f[p] || {}), V(p ? f[p] : f, g.enterFrom));
      });
      var d = ew("enter", r, e, t, n);
      d.duration > 0 && r.animateFrom(f, d);
    } else
      KEe(r, e, n || 0, t, h);
  Lz(r, e), u ? r.dirty() : r.markRedraw();
}
function Lz(r, e) {
  for (var t = af(r).leaveToProps, i = 0; i < zE.length; i++) {
    var n = zE[i], a = n ? e[n] : e;
    a && a.leaveTo && (t || (t = af(r).leaveToProps = {}), n && (t[n] = t[n] || {}), V(n ? t[n] : t, a.leaveTo));
  }
}
function qS(r, e, t, i) {
  if (r) {
    var n = r.parent, a = af(r).leaveToProps;
    if (a) {
      var o = ew("update", r, e, t, 0);
      o.done = function() {
        n.remove(r), i && i();
      }, r.animateTo(a, o);
    } else
      n.remove(r), i && i();
  }
}
function Hu(r) {
  return r === "all";
}
function jEe(r, e, t) {
  var i = e.style;
  if (!r.isGroup && i) {
    if (t) {
      r.useStyle({});
      for (var n = r.animators, a = 0; a < n.length; a++) {
        var o = n[a];
        o.targetName === "style" && o.changeTarget(r.style);
      }
    }
    r.setStyle(i);
  }
  e && (e.style = null, e && r.attr(e), e.style = i);
}
function KEe(r, e, t, i, n) {
  if (n) {
    var a = ew("update", r, e, i, t);
    a.duration > 0 && r.animateFrom(n, a);
  }
}
function JEe(r, e) {
  oe(e, "silent") && (r.silent = e.silent), oe(e, "ignore") && (r.ignore = e.ignore), r instanceof qn && oe(e, "invisible") && (r.invisible = e.invisible), r instanceof Fe && oe(e, "autoBatch") && (r.autoBatch = e.autoBatch);
}
var La = {}, ebe = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(r, e) {
    return La.el[r] = e, this;
  },
  getTransform: function(r) {
    return La.el[r];
  },
  setShape: function(r, e) {
    var t = La.el, i = t.shape || (t.shape = {});
    return i[r] = e, t.dirtyShape && t.dirtyShape(), this;
  },
  getShape: function(r) {
    var e = La.el.shape;
    if (e)
      return e[r];
  },
  setStyle: function(r, e) {
    var t = La.el, i = t.style;
    return i && (i[r] = e, t.dirtyStyle && t.dirtyStyle()), this;
  },
  getStyle: function(r) {
    var e = La.el.style;
    if (e)
      return e[r];
  },
  setExtra: function(r, e) {
    var t = La.el.extra || (La.el.extra = {});
    return t[r] = e, this;
  },
  getExtra: function(r) {
    var e = La.el.extra;
    if (e)
      return e[r];
  }
};
function tbe() {
  var r = this, e = r.el;
  if (e) {
    var t = af(e).userDuring, i = r.userDuring;
    if (t !== i) {
      r.el = r.userDuring = null;
      return;
    }
    La.el = e, i(ebe);
  }
}
function uQ(r, e, t, i) {
  var n = t[r];
  if (n) {
    var a = e[r], o;
    if (a) {
      var s = t.transition, l = n.transition;
      if (l)
        if (!o && (o = i[r] = {}), Hu(l))
          V(o, a);
        else
          for (var u = At(l), h = 0; h < u.length; h++) {
            var c = u[h], f = a[c];
            o[c] = f;
          }
      else if (Hu(s) || Ge(s, r) >= 0) {
        !o && (o = i[r] = {});
        for (var d = He(a), h = 0; h < d.length; h++) {
          var c = d[h], f = a[c];
          abe(n[c], f) && (o[c] = f);
        }
      }
    }
  }
}
function hQ(r, e, t) {
  var i = e[r];
  if (i)
    for (var n = t[r] = {}, a = He(i), o = 0; o < a.length; o++) {
      var s = a[o];
      n[s] = np(i[s]);
    }
}
function rbe(r, e, t) {
  for (var i = e.transition, n = Hu(i) ? oo : At(i || []), a = 0; a < n.length; a++) {
    var o = n[a];
    if (!(o === "style" || o === "shape" || o === "extra")) {
      var s = r[o];
      t[o] = s;
    }
  }
}
function ibe(r, e, t) {
  for (var i = 0; i < lQ.length; i++) {
    var n = lQ[i], a = Nz[n], o = e[n];
    o && (t[a[0]] = o[0], t[a[1]] = o[1]);
  }
  for (var i = 0; i < oo.length; i++) {
    var s = oo[i];
    e[s] != null && (t[s] = e[s]);
  }
}
function nbe(r, e, t, i) {
  if (t) {
    var n = r.style, a;
    if (n) {
      var o = t.transition, s = e.transition;
      if (o && !Hu(o)) {
        var l = At(o);
        !a && (a = i.style = {});
        for (var u = 0; u < l.length; u++) {
          var h = l[u], c = n[h];
          a[h] = c;
        }
      } else if (r.getAnimationStyleProps && (Hu(s) || Hu(o) || Ge(s, "style") >= 0)) {
        var f = r.getAnimationStyleProps(), d = f ? f.style : null;
        if (d) {
          !a && (a = i.style = {});
          for (var p = He(t), u = 0; u < p.length; u++) {
            var h = p[u];
            if (d[h]) {
              var c = n[h];
              a[h] = c;
            }
          }
        }
      }
    }
  }
}
function abe(r, e) {
  return ci(r) ? r !== e : r != null && isFinite(r);
}
var Dz = at(), obe = ["percent", "easing", "shape", "style", "extra"];
function Mz(r) {
  r.stopAnimation("keyframe"), r.attr(Dz(r));
}
function ZE(r, e, t) {
  if (!(!t.isAnimationEnabled() || !e)) {
    if (X(e)) {
      w(e, function(s) {
        ZE(r, s, t);
      });
      return;
    }
    var i = e.keyframes, n = e.duration;
    if (t && n == null) {
      var a = Tf("enter", t, 0);
      n = a && a.duration;
    }
    if (!(!i || !n)) {
      var o = Dz(r);
      w(zE, function(s) {
        if (!(s && !r[s])) {
          var l;
          i.sort(function(u, h) {
            return u.percent - h.percent;
          }), w(i, function(u) {
            var h = r.animators, c = s ? u[s] : u;
            if (c) {
              var f = He(c);
              if (s || (f = yt(f, function(g) {
                return Ge(obe, g) < 0;
              })), !!f.length) {
                l || (l = r.animate(s, e.loop, !0), l.scope = "keyframe");
                for (var d = 0; d < h.length; d++)
                  h[d] !== l && h[d].targetName === l.targetName && h[d].stopTracks(f);
                s && (o[s] = o[s] || {});
                var p = s ? o[s] : o;
                w(f, function(g) {
                  p[g] = ((s ? r[s] : r) || {})[g];
                }), l.whenWithKeys(n * u.percent, c, f, u.easing);
              }
            }
          }), l && l.delay(e.delay || 0).duration(n).start(e.easing);
        }
      });
    }
  }
}
var Uo = "emphasis", ks = "normal", tw = "blur", rw = "select", hl = [ks, Uo, tw, rw], $0 = {
  normal: ["itemStyle"],
  emphasis: [Uo, "itemStyle"],
  blur: [tw, "itemStyle"],
  select: [rw, "itemStyle"]
}, G0 = {
  normal: ["label"],
  emphasis: [Uo, "label"],
  blur: [tw, "label"],
  select: [rw, "label"]
}, sbe = ["x", "y"], lbe = "e\0\0", An = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, ube = {
  cartesian2d: FEe,
  geo: YEe,
  single: WEe,
  polar: ZEe,
  calendar: qEe
};
function HC(r) {
  return r instanceof Fe;
}
function WC(r) {
  return r instanceof qn;
}
function hbe(r, e) {
  e.copyTransform(r), WC(e) && WC(r) && (e.setStyle(r.style), e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel, e.invisible = r.invisible, e.ignore = r.ignore, HC(e) && HC(r) && e.setShape(r.shape));
}
var cbe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this._progressiveEls = null;
      var o = this._data, s = t.getData(), l = this.group, u = cQ(t, s, i, n);
      o || l.removeAll(), s.diff(o).add(function(c) {
        B0(n, null, c, u(c, a), t, l, s);
      }).remove(function(c) {
        var f = o.getItemGraphicEl(c);
        f && qS(f, Qo(f).option, t);
      }).update(function(c, f) {
        var d = o.getItemGraphicEl(f);
        B0(n, d, c, u(c, a), t, l, s);
      }).execute();
      var h = t.get("clip", !0) ? XS(t.coordinateSystem, !1, t) : null;
      h ? l.setClipPath(h) : l.removeClipPath(), this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this.group.removeAll(), this._data = null;
    }, e.prototype.incrementalRender = function(t, i, n, a, o) {
      var s = i.getData(), l = cQ(i, s, n, a), u = this._progressiveEls = [];
      function h(d) {
        d.isGroup || (d.incremental = !0, d.ensureState("emphasis").hoverLayer = !0);
      }
      for (var c = t.start; c < t.end; c++) {
        var f = B0(null, null, c, l(c, o), i, this.group, s);
        f && (f.traverse(h), u.push(f));
      }
    }, e.prototype.eachRendered = function(t) {
      Tl(this._progressiveEls || this.group, t);
    }, e.prototype.filterForExposedEvent = function(t, i, n, a) {
      var o = i.element;
      if (o == null || n.name === o)
        return !0;
      for (; (n = n.__hostTarget || n.parent) && n !== this.group; )
        if (n.name === o)
          return !0;
      return !1;
    }, e.type = "custom", e;
  }(Mt)
);
const fbe = cbe;
function iw(r) {
  var e = r.type, t;
  if (e === "path") {
    var i = r.shape, n = i.width != null && i.height != null ? {
      x: i.x || 0,
      y: i.y || 0,
      width: i.width,
      height: i.height
    } : null, a = Uz(i);
    t = CS(a, null, n, i.layout || "center"), Qo(t).customPathData = a;
  } else if (e === "image")
    t = new qr({}), Qo(t).customImagePath = r.style.image;
  else if (e === "text")
    t = new lt({});
  else if (e === "group")
    t = new ye();
  else {
    if (e === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var o = HI(e);
    if (!o) {
      var s = "";
      vt(s);
    }
    t = new o();
  }
  return Qo(t).customGraphicType = e, t.name = r.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t;
}
function nw(r, e, t, i, n, a, o) {
  Mz(e);
  var s = n && n.normal.cfg;
  s && e.setTextConfig(s), i && i.transition == null && (i.transition = sbe);
  var l = i && i.style;
  if (l) {
    if (e.type === "text") {
      var u = l;
      oe(u, "textFill") && (u.fill = u.textFill), oe(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var h = void 0, c = HC(e) ? l.decal : null;
    r && c && (c.dirty = !0, h = Jc(c, r)), l.__decalPattern = h;
  }
  if (WC(e) && l) {
    var h = l.__decalPattern;
    h && (l.decal = h);
  }
  Am(e, i, a, {
    dataIndex: t,
    isInit: o,
    clearStyle: !0
  }), ZE(e, i.keyframeAnimation, a);
}
function kz(r, e, t, i, n) {
  var a = e.isGroup ? null : e, o = n && n[r].cfg;
  if (a) {
    var s = a.ensureState(r);
    if (i === !1) {
      var l = a.getState(r);
      l && (l.style = null);
    } else
      s.style = i || null;
    o && (s.textConfig = o), ih(a);
  }
}
function dbe(r, e, t) {
  if (!r.isGroup) {
    var i = r, n = t.currentZ, a = t.currentZLevel;
    i.z = n, i.zlevel = a;
    var o = e.z2;
    o != null && (i.z2 = o || 0);
    for (var s = 0; s < hl.length; s++)
      pbe(i, e, hl[s]);
  }
}
function pbe(r, e, t) {
  var i = t === ks, n = i ? e : qE(e, t), a = n ? n.z2 : null, o;
  a != null && (o = i ? r : r.ensureState(t), o.z2 = a || 0);
}
function cQ(r, e, t, i) {
  var n = r.get("renderItem"), a = r.coordinateSystem, o = {};
  a && (o = a.prepareCustoms ? a.prepareCustoms(a) : ube[a.type](a));
  for (var s = me({
    getWidth: i.getWidth,
    getHeight: i.getHeight,
    getZr: i.getZr,
    getDevicePixelRatio: i.getDevicePixelRatio,
    value: b,
    style: S,
    ordinalRawValue: T,
    styleEmphasis: y,
    visual: _,
    barLayout: I,
    currentSeriesIndices: x,
    font: P
  }, o.api || {}), l = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: r.id,
    seriesName: r.name,
    seriesIndex: r.seriesIndex,
    coordSys: o.coordSys,
    dataInsideLength: e.count(),
    encode: gbe(r.getData())
  }, u, h, c = {}, f = {}, d = {}, p = {}, g = 0; g < hl.length; g++) {
    var v = hl[g];
    d[v] = r.getModel($0[v]), p[v] = r.getModel(G0[v]);
  }
  function O(N) {
    return N === u ? h || (h = e.getItemModel(N)) : e.getItemModel(N);
  }
  function m(N, L) {
    return e.hasItemOption ? N === u ? c[L] || (c[L] = O(N).getModel($0[L])) : O(N).getModel($0[L]) : d[L];
  }
  function E(N, L) {
    return e.hasItemOption ? N === u ? f[L] || (f[L] = O(N).getModel(G0[L])) : O(N).getModel(G0[L]) : p[L];
  }
  return function(N, L) {
    return u = N, h = null, c = {}, f = {}, n && n(me({
      dataIndexInside: N,
      dataIndex: e.getRawIndex(N),
      // Can be used for optimization when zoom or roam.
      actionType: L ? L.type : null
    }, l), s);
  };
  function b(N, L) {
    return L == null && (L = u), e.getStore().get(e.getDimensionIndex(N || 0), L);
  }
  function T(N, L) {
    L == null && (L = u), N = N || 0;
    var D = e.getDimensionInfo(N);
    if (!D) {
      var $ = e.getDimensionIndex(N);
      return $ >= 0 ? e.getStore().get($, L) : void 0;
    }
    var k = e.get(D.name, L), G = D && D.ordinalMeta;
    return G ? G.categories[k] : k;
  }
  function S(N, L) {
    L == null && (L = u);
    var D = e.getItemVisual(L, "style"), $ = D && D.fill, k = D && D.opacity, G = m(L, ks).getItemStyle();
    $ != null && (G.fill = $), k != null && (G.opacity = k);
    var F = {
      inheritColor: ne($) ? $ : "#000"
    }, q = E(L, ks), re = Lt(q, null, F, !1, !0);
    re.text = q.getShallow("show") ? ke(r.getFormattedLabel(L, ks), tf(e, L)) : null;
    var fe = RE(q, F, !1);
    return C(N, G), G = oQ(G, re, fe), N && A(G, N), G.legacy = !0, G;
  }
  function y(N, L) {
    L == null && (L = u);
    var D = m(L, Uo).getItemStyle(), $ = E(L, Uo), k = Lt($, null, null, !0, !0);
    k.text = $.getShallow("show") ? Ka(r.getFormattedLabel(L, Uo), r.getFormattedLabel(L, ks), tf(e, L)) : null;
    var G = RE($, null, !0);
    return C(N, D), D = oQ(D, k, G), N && A(D, N), D.legacy = !0, D;
  }
  function A(N, L) {
    for (var D in L)
      oe(L, D) && (N[D] = L[D]);
  }
  function C(N, L) {
    N && (N.textFill && (L.textFill = N.textFill), N.textPosition && (L.textPosition = N.textPosition));
  }
  function _(N, L) {
    if (L == null && (L = u), oe(nQ, N)) {
      var D = e.getItemVisual(L, "style");
      return D ? D[nQ[N]] : null;
    }
    if (oe($Ee, N))
      return e.getItemVisual(L, N);
  }
  function I(N) {
    if (a.type === "cartesian2d") {
      var L = a.getBaseAxis();
      return Oue(me({
        axis: L
      }, N));
    }
  }
  function x() {
    return t.getCurrentSeriesIndices();
  }
  function P(N) {
    return mY(N, t);
  }
}
function gbe(r) {
  var e = {};
  return w(r.dimensions, function(t) {
    var i = r.getDimensionInfo(t);
    if (!i.isExtraCoord) {
      var n = i.coordDim, a = e[n] = e[n] || [];
      a[i.coordDimIndex] = r.getDimensionIndex(t);
    }
  }), e;
}
function B0(r, e, t, i, n, a, o) {
  if (!i) {
    a.remove(e);
    return;
  }
  var s = aw(r, e, t, i, n, a);
  return s && o.setItemGraphicEl(t, s), s && zt(s, i.focus, i.blurScope, i.emphasisDisabled), s;
}
function aw(r, e, t, i, n, a) {
  var o = -1, s = e;
  e && Qz(e, i, n) && (o = Ge(a.childrenRef(), e), e = null);
  var l = !e, u = e;
  u ? u.clearStates() : (u = iw(i), s && hbe(s, u)), i.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), An.normal.cfg = An.normal.conOpt = An.emphasis.cfg = An.emphasis.conOpt = An.blur.cfg = An.blur.conOpt = An.select.cfg = An.select.conOpt = null, An.isLegacy = !1, Obe(u, t, i, n, l, An), vbe(u, t, i, n, l), nw(r, u, t, i, An, n, l), oe(i, "info") && (Qo(u).info = i.info);
  for (var h = 0; h < hl.length; h++) {
    var c = hl[h];
    if (c !== ks) {
      var f = qE(i, c), d = ow(i, f, c);
      kz(c, u, f, d, An);
    }
  }
  return dbe(u, i, n), i.type === "group" && mbe(r, u, t, i, n), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
}
function Qz(r, e, t) {
  var i = Qo(r), n = e.type, a = e.shape, o = e.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    t.isUniversalTransitionEnabled() || n != null && n !== i.customGraphicType || n === "path" && Tbe(a) && Uz(a) !== i.customPathData || n === "image" && oe(o, "image") && o.image !== i.customImagePath
  );
}
function vbe(r, e, t, i, n) {
  var a = t.clipPath;
  if (a === !1)
    r && r.getClipPath() && r.removeClipPath();
  else if (a) {
    var o = r.getClipPath();
    o && Qz(o, a, i) && (o = null), o || (o = iw(a), r.setClipPath(o)), nw(null, o, e, a, null, i, n);
  }
}
function Obe(r, e, t, i, n, a) {
  if (!r.isGroup) {
    fQ(t, null, a), fQ(t, Uo, a);
    var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
    if (o != null || s != null || u != null || l != null) {
      var h = r.getTextContent();
      if (o === !1)
        h && r.removeTextContent();
      else {
        o = a.normal.conOpt = o || {
          type: "text"
        }, h ? h.clearStates() : (h = iw(o), r.setTextContent(h)), nw(null, h, e, o, null, i, n);
        for (var c = o && o.style, f = 0; f < hl.length; f++) {
          var d = hl[f];
          if (d !== ks) {
            var p = a[d].conOpt;
            kz(d, h, p, ow(o, p, d), null);
          }
        }
        c ? h.dirty() : h.markRedraw();
      }
    }
  }
}
function fQ(r, e, t) {
  var i = e ? qE(r, e) : r, n = e ? ow(r, i, Uo) : r.style, a = r.type, o = i ? i.textConfig : null, s = r.textContent, l = s ? e ? qE(s, e) : s : null;
  if (n && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (t.isLegacy || wz(n, a, !!o, !!l))) {
    t.isLegacy = !0;
    var u = Pz(n, a, !e);
    !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!e && l) {
    var h = l;
    !h.type && (h.type = "text");
  }
  var c = e ? t[e] : t.normal;
  c.cfg = o, c.conOpt = l;
}
function qE(r, e) {
  return e ? r ? r[e] : null : r;
}
function ow(r, e, t) {
  var i = e && e.style;
  return i == null && t === Uo && r && (i = r.styleEmphasis), i;
}
function mbe(r, e, t, i, n) {
  var a = i.children, o = a ? a.length : 0, s = i.$mergeChildren, l = s === "byName" || i.diffChildrenByName, u = s === !1;
  if (!(!o && !l && !u)) {
    if (l) {
      bbe({
        api: r,
        oldChildren: e.children() || [],
        newChildren: a || [],
        dataIndex: t,
        seriesModel: n,
        group: e
      });
      return;
    }
    u && e.removeAll();
    for (var h = 0; h < o; h++) {
      var c = a[h], f = e.childAt(h);
      c ? (c.ignore == null && (c.ignore = !1), aw(r, f, t, c, n, e)) : f.ignore = !0;
    }
    for (var d = e.childCount() - 1; d >= h; d--) {
      var p = e.childAt(d);
      Ebe(e, p, n);
    }
  }
}
function Ebe(r, e, t) {
  e && qS(e, Qo(r).option, t);
}
function bbe(r) {
  new Ho(r.oldChildren, r.newChildren, dQ, dQ, r).add(pQ).update(pQ).remove(Sbe).execute();
}
function dQ(r, e) {
  var t = r && r.name;
  return t ?? lbe + e;
}
function pQ(r, e) {
  var t = this.context, i = r != null ? t.newChildren[r] : null, n = e != null ? t.oldChildren[e] : null;
  aw(t.api, n, t.dataIndex, i, t.seriesModel, t.group);
}
function Sbe(r) {
  var e = this.context, t = e.oldChildren[r];
  t && qS(t, Qo(t).option, e.seriesModel);
}
function Uz(r) {
  return r && (r.pathData || r.d);
}
function Tbe(r) {
  return r && (oe(r, "pathData") || oe(r, "d"));
}
function ybe(r) {
  r.registerChartView(fbe), r.registerSeriesModel(BEe);
}
var pu = at(), gQ = Se, V0 = ae, Rbe = (
  /** @class */
  function() {
    function r() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return r.prototype.render = function(e, t, i, n) {
      var a = t.get("value"), o = t.get("status");
      if (this._axisModel = e, this._axisPointerModel = t, this._api = i, !(!n && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, e, t, i);
        var h = u.graphicKey;
        h !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = h;
        var c = this._moveAnimation = this.determineAnimation(e, t);
        if (!s)
          s = this._group = new ye(), this.createPointerEl(s, u, e, t), this.createLabelEl(s, u, e, t), i.getZr().add(s);
        else {
          var f = Ie(vQ, t, c);
          this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, t);
        }
        mQ(s, t, !0), this._renderHandle(a);
      }
    }, r.prototype.remove = function(e) {
      this.clear(e);
    }, r.prototype.dispose = function(e) {
      this.clear(e);
    }, r.prototype.determineAnimation = function(e, t) {
      var i = t.get("animation"), n = e.axis, a = n.type === "category", o = t.get("snap");
      if (!o && !a)
        return !1;
      if (i === "auto" || i == null) {
        var s = this.animationThreshold;
        if (a && n.getBandWidth() > s)
          return !0;
        if (o) {
          var l = xx(e).seriesDataCount, u = n.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return i === !0;
    }, r.prototype.makeElOption = function(e, t, i, n, a) {
    }, r.prototype.createPointerEl = function(e, t, i, n) {
      var a = t.pointer;
      if (a) {
        var o = pu(e).pointerEl = new Fg[a.type](gQ(t.pointer));
        e.add(o);
      }
    }, r.prototype.createLabelEl = function(e, t, i, n) {
      if (t.label) {
        var a = pu(e).labelEl = new lt(gQ(t.label));
        e.add(a), OQ(a, n);
      }
    }, r.prototype.updatePointerEl = function(e, t, i) {
      var n = pu(e).pointerEl;
      n && t.pointer && (n.setStyle(t.pointer.style), i(n, {
        shape: t.pointer.shape
      }));
    }, r.prototype.updateLabelEl = function(e, t, i, n) {
      var a = pu(e).labelEl;
      a && (a.setStyle(t.label.style), i(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: t.label.x,
        y: t.label.y
      }), OQ(a, n));
    }, r.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var t = this._axisPointerModel, i = this._api.getZr(), n = this._handle, a = t.getModel("handle"), o = t.get("status");
        if (!a.get("show") || !o || o === "hide") {
          n && i.remove(n), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, n = this._handle = Vg(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Vo(u.event);
          },
          onmousedown: V0(this._onHandleDragMove, this, 0, 0),
          drift: V0(this._onHandleDragMove, this),
          ondragend: V0(this._onHandleDragEnd, this)
        }), i.add(n)), mQ(n, t, !1), n.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        X(l) || (l = [l, l]), n.scaleX = l[0] / 2, n.scaleY = l[1] / 2, Pf(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s);
      }
    }, r.prototype._moveHandleToValue = function(e, t) {
      vQ(this._axisPointerModel, !t && this._moveAnimation, this._handle, F0(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, r.prototype._onHandleDragMove = function(e, t) {
      var i = this._handle;
      if (i) {
        this._dragging = !0;
        var n = this.updateHandleTransform(F0(i), [e, t], this._axisModel, this._axisPointerModel);
        this._payloadInfo = n, i.stopAnimation(), i.attr(F0(n)), pu(i).lastProp = null, this._doDispatchAxisPointer();
      }
    }, r.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var t = this._payloadInfo, i = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: t.cursorPoint[0],
          y: t.cursorPoint[1],
          tooltipOption: t.tooltipOption,
          axesInfo: [{
            axisDim: i.axis.dim,
            axisIndex: i.componentIndex
          }]
        });
      }
    }, r.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var e = this._handle;
      if (e) {
        var t = this._axisPointerModel.get("value");
        this._moveHandleToValue(t), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, r.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var t = e.getZr(), i = this._group, n = this._handle;
      t && i && (this._lastGraphicKey = null, i && t.remove(i), n && t.remove(n), this._group = null, this._handle = null, this._payloadInfo = null), Kp(this, "_doDispatchAxisPointer");
    }, r.prototype.doClear = function() {
    }, r.prototype.buildLabel = function(e, t, i) {
      return i = i || 0, {
        x: e[i],
        y: e[1 - i],
        width: t[i],
        height: t[1 - i]
      };
    }, r;
  }()
);
function vQ(r, e, t, i) {
  $z(pu(t).lastProp, i) || (pu(t).lastProp = i, e ? ft(t, i, r) : (t.stopAnimation(), t.attr(i)));
}
function $z(r, e) {
  if (be(r) && be(e)) {
    var t = !0;
    return w(e, function(i, n) {
      t = t && $z(r[n], i);
    }), !!t;
  } else
    return r === e;
}
function OQ(r, e) {
  r[e.get(["label", "show"]) ? "show" : "hide"]();
}
function F0(r) {
  return {
    x: r.x || 0,
    y: r.y || 0,
    rotation: r.rotation || 0
  };
}
function mQ(r, e, t) {
  var i = e.get("z"), n = e.get("zlevel");
  r && r.traverse(function(a) {
    a.type !== "group" && (i != null && (a.z = i), n != null && (a.zlevel = n), a.silent = t);
  });
}
const sw = Rbe;
function lw(r) {
  var e = r.get("type"), t = r.getModel(e + "Style"), i;
  return e === "line" ? (i = t.getLineStyle(), i.fill = null) : e === "shadow" && (i = t.getAreaStyle(), i.stroke = null), i;
}
function Gz(r, e, t, i, n) {
  var a = t.get("value"), o = Bz(a, e.axis, e.ecModel, t.get("seriesDataIndices"), {
    precision: t.get(["label", "precision"]),
    formatter: t.get(["label", "formatter"])
  }), s = t.getModel("label"), l = Cf(s.get("padding") || 0), u = s.getFont(), h = Qg(o, u), c = n.position, f = h.width + l[1] + l[3], d = h.height + l[0] + l[2], p = n.align;
  p === "right" && (c[0] -= f), p === "center" && (c[0] -= f / 2);
  var g = n.verticalAlign;
  g === "bottom" && (c[1] -= d), g === "middle" && (c[1] -= d / 2), Abe(c, f, d, i);
  var v = s.get("backgroundColor");
  (!v || v === "auto") && (v = e.get(["axisLine", "lineStyle", "color"])), r.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: c[0],
    y: c[1],
    style: Lt(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: v
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function Abe(r, e, t, i) {
  var n = i.getWidth(), a = i.getHeight();
  r[0] = Math.min(r[0] + e, n) - e, r[1] = Math.min(r[1] + t, a) - t, r[0] = Math.max(r[0], 0), r[1] = Math.max(r[1], 0);
}
function Bz(r, e, t, i, n) {
  r = e.scale.parse(r);
  var a = e.scale.getLabel({
    value: r
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: n.precision
  }), o = n.formatter;
  if (o) {
    var s = {
      value: bx(e, {
        value: r
      }),
      axisDimension: e.dim,
      axisIndex: e.index,
      seriesData: []
    };
    w(i, function(l) {
      var u = t.getSeriesByIndex(l.seriesIndex), h = l.dataIndexInside, c = u && u.getDataParams(h);
      c && s.seriesData.push(c);
    }), ne(o) ? a = o.replace("{value}", a) : ve(o) && (a = o(s));
  }
  return a;
}
function uw(r, e, t) {
  var i = Zn();
  return bh(i, i, t.rotation), ao(i, i, t.position), Oa([r.dataToCoord(e), (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)], i);
}
function Vz(r, e, t, i, n, a) {
  var o = Wo.innerTextLayout(t.rotation, 0, t.labelDirection);
  t.labelMargin = n.get(["label", "margin"]), Gz(e, i, n, a, {
    position: uw(i.axis, r, t),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function hw(r, e, t) {
  return t = t || 0, {
    x1: r[t],
    y1: r[1 - t],
    x2: e[t],
    y2: e[1 - t]
  };
}
function Fz(r, e, t) {
  return t = t || 0, {
    x: r[t],
    y: r[1 - t],
    width: e[t],
    height: e[1 - t]
  };
}
function EQ(r, e, t, i, n, a) {
  return {
    cx: r,
    cy: e,
    r0: t,
    r: i,
    startAngle: n,
    endAngle: a,
    clockwise: !0
  };
}
var Cbe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, i, n, a, o) {
      var s = n.axis, l = s.grid, u = a.get("type"), h = bQ(l, s).getOtherAxis(s).getGlobalExtent(), c = s.toGlobalCoord(s.dataToCoord(i, !0));
      if (u && u !== "none") {
        var f = lw(a), d = _be[u](s, c, h);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = xC(l.model, n);
      Vz(
        // @ts-ignore
        i,
        t,
        p,
        n,
        a,
        o
      );
    }, e.prototype.getHandleTransform = function(t, i, n) {
      var a = xC(i.axis.grid.model, i, {
        labelInside: !1
      });
      a.labelMargin = n.get(["handle", "margin"]);
      var o = uw(i.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, i, n, a) {
      var o = n.axis, s = o.grid, l = o.getGlobalExtent(!0), u = bQ(s, o).getOtherAxis(o).getGlobalExtent(), h = o.dim === "x" ? 0 : 1, c = [t.x, t.y];
      c[h] += i[h], c[h] = Math.min(l[1], c[h]), c[h] = Math.max(l[0], c[h]);
      var f = (u[1] + u[0]) / 2, d = [f, f];
      d[h] = c[h];
      var p = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: c[0],
        y: c[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: p[h]
      };
    }, e;
  }(sw)
);
function bQ(r, e) {
  var t = {};
  return t[e.dim + "AxisIndex"] = e.index, r.getCartesian(t);
}
var _be = {
  line: function(r, e, t) {
    var i = hw([e, t[0]], [e, t[1]], SQ(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: i
    };
  },
  shadow: function(r, e, t) {
    var i = Math.max(1, r.getBandWidth()), n = t[1] - t[0];
    return {
      type: "Rect",
      shape: Fz([e - i / 2, t[0]], [i, n], SQ(r))
    };
  }
};
function SQ(r) {
  return r.dim === "x" ? 0 : 1;
}
const Ibe = Cbe;
var xbe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "axisPointer", e.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, e;
  }(ot)
);
const wbe = xbe;
var Po = at(), Pbe = w;
function Xz(r, e, t) {
  if (!st.node) {
    var i = e.getZr();
    Po(i).records || (Po(i).records = {}), Nbe(i, e);
    var n = Po(i).records[r] || (Po(i).records[r] = {});
    n.handler = t;
  }
}
function Nbe(r, e) {
  if (Po(r).initialized)
    return;
  Po(r).initialized = !0, t("click", Ie(TQ, "click")), t("mousemove", Ie(TQ, "mousemove")), t("globalout", Dbe);
  function t(i, n) {
    r.on(i, function(a) {
      var o = Mbe(e);
      Pbe(Po(r).records, function(s) {
        s && n(s, a, o.dispatchAction);
      }), Lbe(o.pendings, e);
    });
  }
}
function Lbe(r, e) {
  var t = r.showTip.length, i = r.hideTip.length, n;
  t ? n = r.showTip[t - 1] : i && (n = r.hideTip[i - 1]), n && (n.dispatchAction = null, e.dispatchAction(n));
}
function Dbe(r, e, t) {
  r.handler("leave", null, t);
}
function TQ(r, e, t, i) {
  e.handler(r, t, i);
}
function Mbe(r) {
  var e = {
    showTip: [],
    hideTip: []
  }, t = function(i) {
    var n = e[i.type];
    n ? n.push(i) : (i.dispatchAction = t, r.dispatchAction(i));
  };
  return {
    dispatchAction: t,
    pendings: e
  };
}
function zC(r, e) {
  if (!st.node) {
    var t = e.getZr(), i = (Po(t).records || {})[r];
    i && (Po(t).records[r] = null);
  }
}
var kbe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = i.getComponent("tooltip"), o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      Xz("axisPointer", n, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(t, i) {
      zC("axisPointer", i);
    }, e.prototype.dispose = function(t, i) {
      zC("axisPointer", i);
    }, e.type = "axisPointer", e;
  }(Zt)
);
const Qbe = kbe;
function Yz(r, e) {
  var t = [], i = r.seriesIndex, n;
  if (i == null || !(n = e.getSeriesByIndex(i)))
    return {
      point: []
    };
  var a = n.getData(), o = th(a, r);
  if (o == null || o < 0 || X(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = n.coordinateSystem;
  if (n.getTooltipPosition)
    t = n.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (r.isStacked) {
      var u = l.getBaseAxis(), h = l.getOtherAxis(u), c = h.dim, f = u.dim, d = c === "x" || c === "radius" ? 1 : 0, p = a.mapDimension(f), g = [];
      g[d] = a.get(p, o), g[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), o), t = l.dataToPoint(g) || [];
    } else
      t = l.dataToPoint(a.getValues(Y(l.dimensions, function(O) {
        return a.mapDimension(O);
      }), o)) || [];
  else if (s) {
    var v = s.getBoundingRect().clone();
    v.applyTransform(s.transform), t = [v.x + v.width / 2, v.y + v.height / 2];
  }
  return {
    point: t,
    el: s
  };
}
var yQ = at();
function Ube(r, e, t) {
  var i = r.currTrigger, n = [r.x, r.y], a = r, o = r.dispatchAction || ae(t.dispatchAction, t), s = e.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    Cm(n) && (n = Yz({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, e).point);
    var l = Cm(n), u = a.axesInfo, h = s.axesInfo, c = i === "leave" || Cm(n), f = {}, d = {}, p = {
      list: [],
      map: {}
    }, g = {
      showPointer: Ie(Gbe, d),
      showTooltip: Ie(Bbe, p)
    };
    w(s.coordSysMap, function(O, m) {
      var E = l || O.containPoint(n);
      w(s.coordSysAxesInfo[m], function(b, T) {
        var S = b.axis, y = Ybe(u, b);
        if (!c && E && (!u || y)) {
          var A = y && y.value;
          A == null && !l && (A = S.pointToData(n)), A != null && RQ(b, A, g, !1, f);
        }
      });
    });
    var v = {};
    return w(h, function(O, m) {
      var E = O.linkGroup;
      E && !d[m] && w(E.axesInfo, function(b, T) {
        var S = d[T];
        if (b !== O && S) {
          var y = S.value;
          E.mapper && (y = O.axis.scale.parse(E.mapper(y, AQ(b), AQ(O)))), v[O.key] = y;
        }
      });
    }), w(v, function(O, m) {
      RQ(h[m], O, g, !0, f);
    }), Vbe(d, h, f), Fbe(p, n, r, o), Xbe(h, o, t), f;
  }
}
function RQ(r, e, t, i, n) {
  var a = r.axis;
  if (!(a.scale.isBlank() || !a.containData(e))) {
    if (!r.involveSeries) {
      t.showPointer(r, e);
      return;
    }
    var o = $be(e, r), s = o.payloadBatch, l = o.snapToValue;
    s[0] && n.seriesIndex == null && V(n, s[0]), !i && r.snap && a.containData(l) && l != null && (e = l), t.showPointer(r, e, s), t.showTooltip(r, o, l);
  }
}
function $be(r, e) {
  var t = e.axis, i = t.dim, n = r, a = [], o = Number.MAX_VALUE, s = -1;
  return w(e.seriesModels, function(l, u) {
    var h = l.getData().mapDimensionsAll(i), c, f;
    if (l.getAxisTooltipData) {
      var d = l.getAxisTooltipData(h, r, t);
      f = d.dataIndices, c = d.nestestValue;
    } else {
      if (f = l.getData().indicesOfNearest(
        h[0],
        r,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        t.type === "category" ? 0.5 : null
      ), !f.length)
        return;
      c = l.getData().get(h[0], f[0]);
    }
    if (!(c == null || !isFinite(c))) {
      var p = r - c, g = Math.abs(p);
      g <= o && ((g < o || p >= 0 && s < 0) && (o = g, s = p, n = c, a.length = 0), w(f, function(v) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: v,
          dataIndex: l.getData().getRawIndex(v)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: n
  };
}
function Gbe(r, e, t, i) {
  r[e.key] = {
    value: t,
    payloadBatch: i
  };
}
function Bbe(r, e, t, i) {
  var n = t.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel;
  if (!(!e.triggerTooltip || !n.length)) {
    var l = e.coordSys.model, u = ng(l), h = r.map[u];
    h || (h = r.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, r.list.push(h)), h.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: i,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: n.slice()
    });
  }
}
function Vbe(r, e, t) {
  var i = t.axesInfo = [];
  w(e, function(n, a) {
    var o = n.axisPointerModel.option, s = r[a];
    s ? (!n.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !n.useHandle && (o.status = "hide"), o.status === "show" && i.push({
      axisDim: n.axis.dim,
      axisIndex: n.axis.model.componentIndex,
      value: o.value
    });
  });
}
function Fbe(r, e, t, i) {
  if (Cm(e) || !r.list.length) {
    i({
      type: "hideTip"
    });
    return;
  }
  var n = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  i({
    type: "showTip",
    escapeConnect: !0,
    x: e[0],
    y: e[1],
    tooltipOption: t.tooltipOption,
    position: t.position,
    dataIndexInside: n.dataIndexInside,
    dataIndex: n.dataIndex,
    seriesIndex: n.seriesIndex,
    dataByCoordSys: r.list
  });
}
function Xbe(r, e, t) {
  var i = t.getZr(), n = "axisPointerLastHighlights", a = yQ(i)[n] || {}, o = yQ(i)[n] = {};
  w(r, function(u, h) {
    var c = u.axisPointerModel.option;
    c.status === "show" && u.triggerEmphasis && w(c.seriesDataIndices, function(f) {
      var d = f.seriesIndex + " | " + f.dataIndex;
      o[d] = f;
    });
  });
  var s = [], l = [];
  w(a, function(u, h) {
    !o[h] && l.push(u);
  }), w(o, function(u, h) {
    !a[h] && s.push(u);
  }), l.length && t.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && t.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function Ybe(r, e) {
  for (var t = 0; t < (r || []).length; t++) {
    var i = r[t];
    if (e.axis.dim === i.axisDim && e.axis.model.componentIndex === i.axisIndex)
      return i;
  }
}
function AQ(r) {
  var e = r.axis.model, t = {}, i = t.axisDim = r.axis.dim;
  return t.axisIndex = t[i + "AxisIndex"] = e.componentIndex, t.axisName = t[i + "AxisName"] = e.name, t.axisId = t[i + "AxisId"] = e.id, t;
}
function Cm(r) {
  return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1]);
}
function rv(r) {
  Ah.registerAxisPointerClass("CartesianAxisPointer", Ibe), r.registerComponentModel(wbe), r.registerComponentView(Qbe), r.registerPreprocessor(function(e) {
    if (e) {
      (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
      var t = e.axisPointer.link;
      t && !X(t) && (e.axisPointer.link = [t]);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function(e, t) {
    e.getComponent("axisPointer").coordSysAxesInfo = Nfe(e, t);
  }), r.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, Ube);
}
function Hbe(r) {
  Ve(O3), Ve(rv);
}
var Wbe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, i, n, a, o) {
      var s = n.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), h = u.getExtent(), c = s.dataToCoord(i), f = a.get("type");
      if (f && f !== "none") {
        var d = lw(a), p = Zbe[f](s, l, c, h);
        p.style = d, t.graphicKey = p.type, t.pointer = p;
      }
      var g = a.get(["label", "margin"]), v = zbe(i, n, a, l, g);
      Gz(t, n, a, o, v);
    }, e;
  }(sw)
);
function zbe(r, e, t, i, n) {
  var a = e.axis, o = a.dataToCoord(r), s = i.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = i.getRadiusAxis().getExtent(), u, h, c;
  if (a.dim === "radius") {
    var f = Zn();
    bh(f, f, s), ao(f, f, [i.cx, i.cy]), u = Oa([o, -n], f);
    var d = e.getModel("axisLabel").get("rotate") || 0, p = Wo.innerTextLayout(s, d * Math.PI / 180, -1);
    h = p.textAlign, c = p.textVerticalAlign;
  } else {
    var g = l[1];
    u = i.coordToPoint([g + n, o]);
    var v = i.cx, O = i.cy;
    h = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", c = Math.abs(u[1] - O) / g < 0.3 ? "middle" : u[1] > O ? "top" : "bottom";
  }
  return {
    position: u,
    align: h,
    verticalAlign: c
  };
}
var Zbe = {
  line: function(r, e, t, i) {
    return r.dim === "angle" ? {
      type: "Line",
      shape: hw(e.coordToPoint([i[0], t]), e.coordToPoint([i[1], t]))
    } : {
      type: "Circle",
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: t
      }
    };
  },
  shadow: function(r, e, t, i) {
    var n = Math.max(1, r.getBandWidth()), a = Math.PI / 180;
    return r.dim === "angle" ? {
      type: "Sector",
      shape: EQ(
        e.cx,
        e.cy,
        i[0],
        i[1],
        // In ECharts y is negative if angle is positive
        (-t - n / 2) * a,
        (-t + n / 2) * a
      )
    } : {
      type: "Sector",
      shape: EQ(e.cx, e.cy, t - n / 2, t + n / 2, 0, Math.PI * 2)
    };
  }
};
const qbe = Wbe;
var jbe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.findAxisModel = function(t) {
      var i, n = this.ecModel;
      return n.eachComponent(t, function(a) {
        a.getCoordSysModel() === this && (i = a);
      }, this), i;
    }, e.type = "polar", e.dependencies = ["radiusAxis", "angleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, e;
  }(ot)
);
const Kbe = jbe;
var cw = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", lr).models[0];
    }, e.type = "polarAxis", e;
  }(ot)
);
hr(cw, zg);
var Jbe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "angleAxis", e;
  }(cw)
), eSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "radiusAxis", e;
  }(cw)
), fw = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i) {
      return r.call(this, "radius", t, i) || this;
    }
    return e.prototype.pointToData = function(t, i) {
      return this.polar.pointToData(t, i)[this.dim === "radius" ? 0 : 1];
    }, e;
  }(Ta)
);
fw.prototype.dataToRadius = Ta.prototype.dataToCoord;
fw.prototype.radiusToData = Ta.prototype.coordToData;
const tSe = fw;
var rSe = at(), dw = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i) {
      return r.call(this, "angle", t, i || [0, 360]) || this;
    }
    return e.prototype.pointToData = function(t, i) {
      return this.polar.pointToData(t, i)[this.dim === "radius" ? 0 : 1];
    }, e.prototype.calculateCategoryInterval = function() {
      var t = this, i = t.getLabelModel(), n = t.scale, a = n.getExtent(), o = n.count();
      if (a[1] - a[0] < 1)
        return 0;
      var s = a[0], l = t.dataToCoord(s + 1) - t.dataToCoord(s), u = Math.abs(l), h = Qg(s == null ? "" : s + "", i.getFont(), "center", "top"), c = Math.max(h.height, 7), f = c / u;
      isNaN(f) && (f = 1 / 0);
      var d = Math.max(0, Math.floor(f)), p = rSe(t.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - d) <= 1 && Math.abs(v - o) <= 1 && g > d ? d = g : (p.lastTickCount = o, p.lastAutoInterval = d), d;
    }, e;
  }(Ta)
);
dw.prototype.dataToAngle = Ta.prototype.dataToCoord;
dw.prototype.angleToData = Ta.prototype.coordToData;
const iSe = dw;
var Hz = ["radius", "angle"], nSe = (
  /** @class */
  function() {
    function r(e) {
      this.dimensions = Hz, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new tSe(), this._angleAxis = new iSe(), this.axisPointerEnabled = !0, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return r.prototype.containPoint = function(e) {
      var t = this.pointToCoord(e);
      return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1]);
    }, r.prototype.containData = function(e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]);
    }, r.prototype.getAxis = function(e) {
      var t = "_" + e + "Axis";
      return this[t];
    }, r.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, r.prototype.getAxesByScale = function(e) {
      var t = [], i = this._angleAxis, n = this._radiusAxis;
      return i.scale.type === e && t.push(i), n.scale.type === e && t.push(n), t;
    }, r.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, r.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, r.prototype.getOtherAxis = function(e) {
      var t = this._angleAxis;
      return e === t ? this._radiusAxis : t;
    }, r.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, r.prototype.getTooltipAxes = function(e) {
      var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
      return {
        baseAxes: [t],
        otherAxes: [this.getOtherAxis(t)]
      };
    }, r.prototype.dataToPoint = function(e, t) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(e[0], t), this._angleAxis.dataToAngle(e[1], t)]);
    }, r.prototype.pointToData = function(e, t) {
      var i = this.pointToCoord(e);
      return [this._radiusAxis.radiusToData(i[0], t), this._angleAxis.angleToData(i[1], t)];
    }, r.prototype.pointToCoord = function(e) {
      var t = e[0] - this.cx, i = e[1] - this.cy, n = this.getAngleAxis(), a = n.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
      n.inverse ? o = s - 360 : s = o + 360;
      var l = Math.sqrt(t * t + i * i);
      t /= l, i /= l;
      for (var u = Math.atan2(-i, t) / Math.PI * 180, h = u < o ? 1 : -1; u < o || u > s; )
        u += h * 360;
      return [l, u];
    }, r.prototype.coordToPoint = function(e) {
      var t = e[0], i = e[1] / 180 * Math.PI, n = Math.cos(i) * t + this.cx, a = -Math.sin(i) * t + this.cy;
      return [n, a];
    }, r.prototype.getArea = function() {
      var e = this.getAngleAxis(), t = this.getRadiusAxis(), i = t.getExtent().slice();
      i[0] > i[1] && i.reverse();
      var n = e.getExtent(), a = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: i[0],
        r: i[1],
        startAngle: -n[0] * a,
        endAngle: -n[1] * a,
        clockwise: e.inverse,
        contain: function(o, s) {
          var l = o - this.cx, u = s - this.cy, h = l * l + u * u - 1e-4, c = this.r, f = this.r0;
          return h <= c * c && h >= f * f;
        }
      };
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = CQ(t);
      return n === this ? this.dataToPoint(i) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = CQ(t);
      return n === this ? this.pointToData(i) : null;
    }, r;
  }()
);
function CQ(r) {
  var e = r.seriesModel, t = r.polarModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
const aSe = nSe;
function oSe(r, e, t) {
  var i = e.get("center"), n = t.getWidth(), a = t.getHeight();
  r.cx = K(i[0], n), r.cy = K(i[1], a);
  var o = r.getRadiusAxis(), s = Math.min(n, a) / 2, l = e.get("radius");
  l == null ? l = [0, "100%"] : X(l) || (l = [0, l]);
  var u = [K(l[0], s), K(l[1], s)];
  o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1]);
}
function sSe(r, e) {
  var t = this, i = t.getAngleAxis(), n = t.getRadiusAxis();
  if (i.scale.setExtent(1 / 0, -1 / 0), n.scale.setExtent(1 / 0, -1 / 0), r.eachSeries(function(s) {
    if (s.coordinateSystem === t) {
      var l = s.getData();
      w(kE(l, "radius"), function(u) {
        n.scale.unionExtentFromData(l, u);
      }), w(kE(l, "angle"), function(u) {
        i.scale.unionExtentFromData(l, u);
      });
    }
  }), ef(i.scale, i.model), ef(n.scale, n.model), i.type === "category" && !i.onBand) {
    var a = i.getExtent(), o = 360 / i.scale.count();
    i.inverse ? a[1] += o : a[1] -= o, i.setExtent(a[0], a[1]);
  }
}
function lSe(r) {
  return r.mainType === "angleAxis";
}
function _Q(r, e) {
  if (r.type = e.get("type"), r.scale = VS(e), r.onBand = e.get("boundaryGap") && r.type === "category", r.inverse = e.get("inverse"), lSe(e)) {
    r.inverse = r.inverse !== e.get("clockwise");
    var t = e.get("startAngle");
    r.setExtent(t, t + (r.inverse ? -360 : 360));
  }
  e.axis = r, r.model = e;
}
var uSe = {
  dimensions: Hz,
  create: function(r, e) {
    var t = [];
    return r.eachComponent("polar", function(i, n) {
      var a = new aSe(n + "");
      a.update = sSe;
      var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = i.findAxisModel("radiusAxis"), u = i.findAxisModel("angleAxis");
      _Q(o, l), _Q(s, u), oSe(a, i, e), t.push(a), i.coordinateSystem = a, a.model = i;
    }), r.eachSeries(function(i) {
      if (i.get("coordinateSystem") === "polar") {
        var n = i.getReferringComponents("polar", lr).models[0];
        i.coordinateSystem = n.coordinateSystem;
      }
    }), t;
  }
};
const hSe = uSe;
var cSe = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function AO(r, e, t) {
  e[1] > e[0] && (e = e.slice().reverse());
  var i = r.coordToPoint([e[0], t]), n = r.coordToPoint([e[1], t]);
  return {
    x1: i[0],
    y1: i[1],
    x2: n[0],
    y2: n[1]
  };
}
function CO(r) {
  var e = r.getRadiusAxis();
  return e.inverse ? 0 : 1;
}
function IQ(r) {
  var e = r[0], t = r[r.length - 1];
  e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && r.pop();
}
var fSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var n = t.axis, a = n.polar, o = a.getRadiusAxis().getExtent(), s = n.getTicksCoords(), l = n.getMinorTicksCoords(), u = Y(n.getViewLabels(), function(h) {
          h = Se(h);
          var c = n.scale, f = c.type === "ordinal" ? c.getRawOrdinalNumber(h.tickValue) : h.tickValue;
          return h.coord = n.dataToCoord(f), h;
        });
        IQ(u), IQ(s), w(cSe, function(h) {
          t.get([h, "show"]) && (!n.scale.isBlank() || h === "axisLine") && dSe[h](this.group, t, a, s, l, o, u);
        }, this);
      }
    }, e.type = "angleAxis", e;
  }(Ah)
), dSe = {
  axisLine: function(r, e, t, i, n, a) {
    var o = e.getModel(["axisLine", "lineStyle"]), s = CO(t), l = s ? 0 : 1, u;
    a[l] === 0 ? u = new uo({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: a[s]
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }) : u = new RS({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: a[s],
        r0: a[l]
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }), u.style.fill = null, r.add(u);
  },
  axisTick: function(r, e, t, i, n, a) {
    var o = e.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[CO(t)], u = Y(i, function(h) {
      return new Mr({
        shape: AO(t, [l, l + s], h.coord)
      });
    });
    r.add(Dn(u, {
      style: me(o.getModel("lineStyle").getLineStyle(), {
        stroke: e.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(r, e, t, i, n, a) {
    if (n.length) {
      for (var o = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[CO(t)], h = [], c = 0; c < n.length; c++)
        for (var f = 0; f < n[c].length; f++)
          h.push(new Mr({
            shape: AO(t, [u, u + l], n[c][f].coord)
          }));
      r.add(Dn(h, {
        style: me(s.getModel("lineStyle").getLineStyle(), me(o.getLineStyle(), {
          stroke: e.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(r, e, t, i, n, a, o) {
    var s = e.getCategories(!0), l = e.getModel("axisLabel"), u = l.get("margin"), h = e.get("triggerEvent");
    w(o, function(c, f) {
      var d = l, p = c.tickValue, g = a[CO(t)], v = t.coordToPoint([g + u, c.coord]), O = t.cx, m = t.cy, E = Math.abs(v[0] - O) / g < 0.3 ? "center" : v[0] > O ? "left" : "right", b = Math.abs(v[1] - m) / g < 0.3 ? "middle" : v[1] > m ? "top" : "bottom";
      if (s && s[p]) {
        var T = s[p];
        be(T) && T.textStyle && (d = new Dt(T.textStyle, l, l.ecModel));
      }
      var S = new lt({
        silent: Wo.isLabelSilent(e),
        style: Lt(d, {
          x: v[0],
          y: v[1],
          fill: d.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          text: c.formattedLabel,
          align: E,
          verticalAlign: b
        })
      });
      if (r.add(S), h) {
        var y = Wo.makeAxisEventDataBase(e);
        y.targetType = "axisLabel", y.value = c.rawLabel, _e(S).eventData = y;
      }
    }, this);
  },
  splitLine: function(r, e, t, i, n, a) {
    var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var h = [], c = 0; c < i.length; c++) {
      var f = u++ % l.length;
      h[f] = h[f] || [], h[f].push(new Mr({
        shape: AO(t, a, i[c].coord)
      }));
    }
    for (var c = 0; c < h.length; c++)
      r.add(Dn(h[c], {
        style: me({
          stroke: l[c % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: e.get("z")
      }));
  },
  minorSplitLine: function(r, e, t, i, n, a) {
    if (n.length) {
      for (var o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < n.length; u++)
        for (var h = 0; h < n[u].length; h++)
          l.push(new Mr({
            shape: AO(t, a, n[u][h].coord)
          }));
      r.add(Dn(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: e.get("z")
      }));
    }
  },
  splitArea: function(r, e, t, i, n, a) {
    if (i.length) {
      var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var h = [], c = Math.PI / 180, f = -i[0].coord * c, d = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), g = e.get("clockwise"), v = 1, O = i.length; v <= O; v++) {
        var m = v === O ? i[0].coord : i[v].coord, E = u++ % l.length;
        h[E] = h[E] || [], h[E].push(new Xi({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: d,
            r: p,
            startAngle: f,
            endAngle: -m * c,
            clockwise: g
          },
          silent: !0
        })), f = -m * c;
      }
      for (var v = 0; v < h.length; v++)
        r.add(Dn(h[v], {
          style: me({
            fill: l[v % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
const pSe = fSe;
var gSe = ["axisLine", "axisTickLabel", "axisName"], vSe = ["splitLine", "splitArea", "minorSplitLine"], OSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var n = this._axisGroup, a = this._axisGroup = new ye();
        this.group.add(a);
        var o = t.axis, s = o.polar, l = s.getAngleAxis(), u = o.getTicksCoords(), h = o.getMinorTicksCoords(), c = l.getExtent()[0], f = o.getExtent(), d = ESe(s, t, c), p = new Wo(t, d);
        w(gSe, p.add, p), a.add(p.getGroup()), Bg(n, a, t), w(vSe, function(g) {
          t.get([g, "show"]) && !o.scale.isBlank() && mSe[g](this.group, t, s, c, f, u, h);
        }, this);
      }
    }, e.type = "radiusAxis", e;
  }(Ah)
), mSe = {
  splitLine: function(r, e, t, i, n, a) {
    var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var h = [], c = 0; c < a.length; c++) {
      var f = u++ % l.length;
      h[f] = h[f] || [], h[f].push(new uo({
        shape: {
          cx: t.cx,
          cy: t.cy,
          // ensure circle radius >= 0
          r: Math.max(a[c].coord, 0)
        }
      }));
    }
    for (var c = 0; c < h.length; c++)
      r.add(Dn(h[c], {
        style: me({
          stroke: l[c % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(r, e, t, i, n, a, o) {
    if (o.length) {
      for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], h = 0; h < o.length; h++)
        for (var c = 0; c < o[h].length; c++)
          u.push(new uo({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r: o[h][c].coord
            }
          }));
      r.add(Dn(u, {
        style: me({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(r, e, t, i, n, a) {
    if (a.length) {
      var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var h = [], c = a[0].coord, f = 1; f < a.length; f++) {
        var d = u++ % l.length;
        h[d] = h[d] || [], h[d].push(new Xi({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: c,
            r: a[f].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), c = a[f].coord;
      }
      for (var f = 0; f < h.length; f++)
        r.add(Dn(h[f], {
          style: me({
            fill: l[f % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function ESe(r, e, t) {
  return {
    position: [r.cx, r.cy],
    rotation: t / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: e.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
const bSe = OSe;
function Wz(r) {
  return r.get("stack") || "__ec_stack_" + r.seriesIndex;
}
function zz(r, e) {
  return e.dim + r.model.componentIndex;
}
function SSe(r, e, t) {
  var i = {}, n = TSe(yt(e.getSeriesByType(r), function(a) {
    return !e.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
  }));
  e.eachSeriesByType(r, function(a) {
    if (a.coordinateSystem.type === "polar") {
      var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = zz(s, l), h = Wz(a), c = n[u][h], f = c.offset, d = c.width, p = s.getOtherAxis(l), g = a.coordinateSystem.cx, v = a.coordinateSystem.cy, O = a.get("barMinHeight") || 0, m = a.get("barMinAngle") || 0;
      i[h] = i[h] || [];
      for (var E = o.mapDimension(p.dim), b = o.mapDimension(l.dim), T = sl(
        o,
        E
        /* , baseDim */
      ), S = l.dim !== "radius" || !a.get("roundCap", !0), y = p.dataToCoord(0), A = 0, C = o.count(); A < C; A++) {
        var _ = o.get(E, A), I = o.get(b, A), x = _ >= 0 ? "p" : "n", P = y;
        T && (i[h][I] || (i[h][I] = {
          p: y,
          n: y
          // Negative stack
        }), P = i[h][I][x]);
        var N = void 0, L = void 0, D = void 0, $ = void 0;
        if (p.dim === "radius") {
          var k = p.dataToCoord(_) - y, G = l.dataToCoord(I);
          Math.abs(k) < O && (k = (k < 0 ? -1 : 1) * O), N = P, L = P + k, D = G - f, $ = D - d, T && (i[h][I][x] = L);
        } else {
          var F = p.dataToCoord(_, S) - y, q = l.dataToCoord(I);
          Math.abs(F) < m && (F = (F < 0 ? -1 : 1) * m), N = q + f, L = N + d, D = P, $ = P + F, T && (i[h][I][x] = $);
        }
        o.setItemLayout(A, {
          cx: g,
          cy: v,
          r0: N,
          r: L,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -D * Math.PI / 180,
          endAngle: -$ * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: D >= $
        });
      }
    }
  });
}
function TSe(r) {
  var e = {};
  w(r, function(i, n) {
    var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = zz(o, s), u = s.getExtent(), h = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), c = e[l] || {
      bandWidth: h,
      remainedWidth: h,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, f = c.stacks;
    e[l] = c;
    var d = Wz(i);
    f[d] || c.autoWidthCount++, f[d] = f[d] || {
      width: 0,
      maxWidth: 0
    };
    var p = K(i.get("barWidth"), h), g = K(i.get("barMaxWidth"), h), v = i.get("barGap"), O = i.get("barCategoryGap");
    p && !f[d].width && (p = Math.min(c.remainedWidth, p), f[d].width = p, c.remainedWidth -= p), g && (f[d].maxWidth = g), v != null && (c.gap = v), O != null && (c.categoryGap = O);
  });
  var t = {};
  return w(e, function(i, n) {
    t[n] = {};
    var a = i.stacks, o = i.bandWidth, s = K(i.categoryGap, o), l = K(i.gap, 1), u = i.remainedWidth, h = i.autoWidthCount, c = (u - s) / (h + (h - 1) * l);
    c = Math.max(c, 0), w(a, function(g, v) {
      var O = g.maxWidth;
      O && O < c && (O = Math.min(O, u), g.width && (O = Math.min(O, g.width)), u -= O, g.width = O, h--);
    }), c = (u - s) / (h + (h - 1) * l), c = Math.max(c, 0);
    var f = 0, d;
    w(a, function(g, v) {
      g.width || (g.width = c), d = g, f += g.width * (1 + l);
    }), d && (f -= d.width * l);
    var p = -f / 2;
    w(a, function(g, v) {
      t[n][v] = t[n][v] || {
        offset: p,
        width: g.width
      }, p += g.width * (1 + l);
    });
  }), t;
}
var ySe = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, RSe = {
  splitNumber: 5
}, ASe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "polar", e;
  }(Zt)
);
function CSe(r) {
  Ve(rv), Ah.registerAxisPointerClass("PolarAxisPointer", qbe), r.registerCoordinateSystem("polar", hSe), r.registerComponentModel(Kbe), r.registerComponentView(ASe), rf(r, "angle", Jbe, ySe), rf(r, "radius", eSe, RSe), r.registerComponentView(pSe), r.registerComponentView(bSe), r.registerLayout(Ie(SSe, "bar"));
}
function ZC(r, e) {
  e = e || {};
  var t = r.coordinateSystem, i = r.axis, n = {}, a = i.position, o = i.orient, s = t.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  n.position = [o === "vertical" ? u.vertical[a] : l[0], o === "horizontal" ? u.horizontal[a] : l[3]];
  var h = {
    horizontal: 0,
    vertical: 1
  };
  n.rotation = Math.PI / 2 * h[o];
  var c = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  n.labelDirection = n.tickDirection = n.nameDirection = c[a], r.get(["axisTick", "inside"]) && (n.tickDirection = -n.tickDirection), Dr(e.labelInside, r.get(["axisLabel", "inside"])) && (n.labelDirection = -n.labelDirection);
  var f = e.rotate;
  return f == null && (f = r.get(["axisLabel", "rotate"])), n.labelRotation = a === "top" ? -f : f, n.z2 = 1, n;
}
var _Se = ["axisLine", "axisTickLabel", "axisName"], ISe = ["splitArea", "splitLine"], xSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = this.group;
      o.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new ye();
      var l = ZC(t), u = new Wo(t, l);
      w(_Se, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), w(ISe, function(h) {
        t.get([h, "show"]) && wSe[h](this, this.group, this._axisGroup, t);
      }, this), Bg(s, this._axisGroup, t), r.prototype.render.call(this, t, i, n, a);
    }, e.prototype.remove = function() {
      p3(this);
    }, e.type = "singleAxis", e;
  }(Ah)
), wSe = {
  splitLine: function(r, e, t, i) {
    var n = i.axis;
    if (!n.scale.isBlank()) {
      var a = i.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
      s = s instanceof Array ? s : [s];
      for (var l = o.get("width"), u = i.coordinateSystem.getRect(), h = n.isHorizontal(), c = [], f = 0, d = n.getTicksCoords({
        tickModel: a
      }), p = [], g = [], v = 0; v < d.length; ++v) {
        var O = n.toGlobalCoord(d[v].coord);
        h ? (p[0] = O, p[1] = u.y, g[0] = O, g[1] = u.y + u.height) : (p[0] = u.x, p[1] = O, g[0] = u.x + u.width, g[1] = O);
        var m = new Mr({
          shape: {
            x1: p[0],
            y1: p[1],
            x2: g[0],
            y2: g[1]
          },
          silent: !0
        });
        jc(m.shape, l);
        var E = f++ % s.length;
        c[E] = c[E] || [], c[E].push(m);
      }
      for (var b = o.getLineStyle(["color"]), v = 0; v < c.length; ++v)
        e.add(Dn(c[v], {
          style: me({
            stroke: s[v % s.length]
          }, b),
          silent: !0
        }));
    }
  },
  splitArea: function(r, e, t, i) {
    d3(r, t, i, i);
  }
};
const PSe = xSe;
var Zz = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getCoordSysModel = function() {
      return this;
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, e;
  }(ot)
);
hr(Zz, zg.prototype);
const X0 = Zz;
var NSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n, a, o) {
      var s = r.call(this, t, i, n) || this;
      return s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.pointToData = function(t, i) {
      return this.coordinateSystem.pointToData(t)[0];
    }, e;
  }(Ta)
);
const LSe = NSe;
var qz = ["single"], DSe = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "single", this.dimension = "single", this.dimensions = qz, this.axisPointerEnabled = !0, this.model = e, this._init(e, t, i);
    }
    return r.prototype._init = function(e, t, i) {
      var n = this.dimension, a = new LSe(n, VS(e), [0, 0], e.get("type"), e.get("position")), o = a.type === "category";
      a.onBand = o && e.get("boundaryGap"), a.inverse = e.get("inverse"), a.orient = e.get("orient"), e.axis = a, a.model = e, a.coordinateSystem = this, this._axis = a;
    }, r.prototype.update = function(e, t) {
      e.eachSeries(function(i) {
        if (i.coordinateSystem === this) {
          var n = i.getData();
          w(n.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(n, a);
          }, this), ef(this._axis.scale, this._axis.model);
        }
      }, this);
    }, r.prototype.resize = function(e, t) {
      this._rect = mr({
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      }, {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._adjustAxis();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._adjustAxis = function() {
      var e = this._rect, t = this._axis, i = t.isHorizontal(), n = i ? [0, e.width] : [0, e.height], a = t.inverse ? 1 : 0;
      t.setExtent(n[a], n[1 - a]), this._updateAxisTransform(t, i ? e.x : e.y);
    }, r.prototype._updateAxisTransform = function(e, t) {
      var i = e.getExtent(), n = i[0] + i[1], a = e.isHorizontal();
      e.toGlobalCoord = a ? function(o) {
        return o + t;
      } : function(o) {
        return n - o + t;
      }, e.toLocalCoord = a ? function(o) {
        return o - t;
      } : function(o) {
        return n - o + t;
      };
    }, r.prototype.getAxis = function() {
      return this._axis;
    }, r.prototype.getBaseAxis = function() {
      return this._axis;
    }, r.prototype.getAxes = function() {
      return [this._axis];
    }, r.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, r.prototype.containPoint = function(e) {
      var t = this.getRect(), i = this.getAxis(), n = i.orient;
      return n === "horizontal" ? i.contain(i.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : i.contain(i.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height;
    }, r.prototype.pointToData = function(e) {
      var t = this.getAxis();
      return [t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))];
    }, r.prototype.dataToPoint = function(e) {
      var t = this.getAxis(), i = this.getRect(), n = [], a = t.orient === "horizontal" ? 0 : 1;
      return e instanceof Array && (e = e[0]), n[a] = t.toGlobalCoord(t.dataToCoord(+e)), n[1 - a] = a === 0 ? i.y + i.height / 2 : i.x + i.width / 2, n;
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = xQ(t);
      return n === this ? this.dataToPoint(i) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = xQ(t);
      return n === this ? this.pointToData(i) : null;
    }, r;
  }()
);
function xQ(r) {
  var e = r.seriesModel, t = r.singleAxisModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
function MSe(r, e) {
  var t = [];
  return r.eachComponent("singleAxis", function(i, n) {
    var a = new DSe(i, r, e);
    a.name = "single_" + n, a.resize(i, e), i.coordinateSystem = a, t.push(a);
  }), r.eachSeries(function(i) {
    if (i.get("coordinateSystem") === "singleAxis") {
      var n = i.getReferringComponents("singleAxis", lr).models[0];
      i.coordinateSystem = n && n.coordinateSystem;
    }
  }), t;
}
var kSe = {
  create: MSe,
  dimensions: qz
};
const QSe = kSe;
var wQ = ["x", "y"], USe = ["width", "height"], $Se = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, i, n, a, o) {
      var s = n.axis, l = s.coordinateSystem, u = Y0(l, 1 - jE(s)), h = l.dataToPoint(i)[0], c = a.get("type");
      if (c && c !== "none") {
        var f = lw(a), d = GSe[c](s, h, u);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = ZC(n);
      Vz(
        // @ts-ignore
        i,
        t,
        p,
        n,
        a,
        o
      );
    }, e.prototype.getHandleTransform = function(t, i, n) {
      var a = ZC(i, {
        labelInside: !1
      });
      a.labelMargin = n.get(["handle", "margin"]);
      var o = uw(i.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, i, n, a) {
      var o = n.axis, s = o.coordinateSystem, l = jE(o), u = Y0(s, l), h = [t.x, t.y];
      h[l] += i[l], h[l] = Math.min(u[1], h[l]), h[l] = Math.max(u[0], h[l]);
      var c = Y0(s, 1 - l), f = (c[1] + c[0]) / 2, d = [f, f];
      return d[l] = h[l], {
        x: h[0],
        y: h[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, e;
  }(sw)
), GSe = {
  line: function(r, e, t) {
    var i = hw([e, t[0]], [e, t[1]], jE(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: i
    };
  },
  shadow: function(r, e, t) {
    var i = r.getBandWidth(), n = t[1] - t[0];
    return {
      type: "Rect",
      shape: Fz([e - i / 2, t[0]], [i, n], jE(r))
    };
  }
};
function jE(r) {
  return r.isHorizontal() ? 0 : 1;
}
function Y0(r, e) {
  var t = r.getRect();
  return [t[wQ[e]], t[wQ[e]] + t[USe[e]]];
}
const BSe = $Se;
var VSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "single", e;
  }(Zt)
);
function FSe(r) {
  Ve(rv), Ah.registerAxisPointerClass("SingleAxisPointer", BSe), r.registerComponentView(VSe), r.registerComponentView(PSe), r.registerComponentModel(X0), rf(r, "single", X0, X0.defaultOption), r.registerCoordinateSystem("single", QSe);
}
var XSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i, n) {
      var a = _f(t);
      r.prototype.init.apply(this, arguments), PQ(t, a);
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), PQ(this.option, t);
    }, e.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, e.type = "calendar", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, e;
  }(ot)
);
function PQ(r, e) {
  var t = r.cellSize, i;
  X(t) ? i = t : i = r.cellSize = [t, t], i.length === 1 && (i[1] = i[0]);
  var n = Y([0, 1], function(a) {
    return Jae(e, a) && (i[a] = "auto"), i[a] != null && i[a] !== "auto";
  });
  ol(r, e, {
    type: "box",
    ignoreSize: n
  });
}
const YSe = XSe;
var HSe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this.group;
      a.removeAll();
      var o = t.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = i.getLocaleModel();
      this._renderDayRect(t, s, a), this._renderLines(t, s, l, a), this._renderYearText(t, s, l, a), this._renderMonthText(t, u, l, a), this._renderWeekText(t, u, s, l, a);
    }, e.prototype._renderDayRect = function(t, i, n) {
      for (var a = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = i.start.time; u <= i.end.time; u = a.getNextNDay(u, 1).time) {
        var h = a.dataToRect([u], !1).tl, c = new nt({
          shape: {
            x: h[0],
            y: h[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: o
        });
        n.add(c);
      }
    }, e.prototype._renderLines = function(t, i, n, a) {
      var o = this, s = t.coordinateSystem, l = t.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = t.get(["splitLine", "show"]), h = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var c = i.start, f = 0; c.time <= i.end.time; f++) {
        p(c.formatedDate), f === 0 && (c = s.getDateInfo(i.start.y + "-" + i.start.m));
        var d = c.date;
        d.setMonth(d.getMonth() + 1), c = s.getDateInfo(d);
      }
      p(s.getNextNDay(i.end.time, 1).formatedDate);
      function p(g) {
        o._firstDayOfMonth.push(s.getDateInfo(g)), o._firstDayPoints.push(s.dataToRect([g], !1).tl);
        var v = o._getLinePointsOfOneWeek(t, g, n);
        o._tlpoints.push(v[0]), o._blpoints.push(v[v.length - 1]), u && o._drawSplitline(v, l, a);
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, h, n), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, h, n), l, a);
    }, e.prototype._getEdgesPoints = function(t, i, n) {
      var a = [t[0].slice(), t[t.length - 1].slice()], o = n === "horizontal" ? 0 : 1;
      return a[0][o] = a[0][o] - i / 2, a[1][o] = a[1][o] + i / 2, a;
    }, e.prototype._drawSplitline = function(t, i, n) {
      var a = new Wi({
        z2: 20,
        shape: {
          points: t
        },
        style: i
      });
      n.add(a);
    }, e.prototype._getLinePointsOfOneWeek = function(t, i, n) {
      for (var a = t.coordinateSystem, o = a.getDateInfo(i), s = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(o.time, l), h = a.dataToRect([u.time], !1);
        s[2 * u.day] = h.tl, s[2 * u.day + 1] = h[n === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, e.prototype._formatterLabel = function(t, i) {
      return ne(t) && t ? qae(t, i) : ve(t) ? t(i) : i.nameMap;
    }, e.prototype._yearTextPositionControl = function(t, i, n, a, o) {
      var s = i[0], l = i[1], u = ["center", "bottom"];
      a === "bottom" ? (l += o, u = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, u = ["center", "top"]) : l -= o;
      var h = 0;
      return (a === "left" || a === "right") && (h = Math.PI / 2), {
        rotation: h,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, e.prototype._renderYearText = function(t, i, n, a) {
      var o = t.getModel("yearLabel");
      if (o.get("show")) {
        var s = o.get("margin"), l = o.get("position");
        l || (l = n !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], h = (u[0][0] + u[1][0]) / 2, c = (u[0][1] + u[1][1]) / 2, f = n === "horizontal" ? 0 : 1, d = {
          top: [h, u[f][1]],
          bottom: [h, u[1 - f][1]],
          left: [u[1 - f][0], c],
          right: [u[f][0], c]
        }, p = i.start.y;
        +i.end.y > +i.start.y && (p = p + "-" + i.end.y);
        var g = o.get("formatter"), v = {
          start: i.start.y,
          end: i.end.y,
          nameMap: p
        }, O = this._formatterLabel(g, v), m = new lt({
          z2: 30,
          style: Lt(o, {
            text: O
          })
        });
        m.attr(this._yearTextPositionControl(m, d[l], n, l, s)), a.add(m);
      }
    }, e.prototype._monthTextPositionControl = function(t, i, n, a, o) {
      var s = "left", l = "top", u = t[0], h = t[1];
      return n === "horizontal" ? (h = h + o, i && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, i && (l = "middle"), a === "start" && (s = "right")), {
        x: u,
        y: h,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderMonthText = function(t, i, n, a) {
      var o = t.getModel("monthLabel");
      if (o.get("show")) {
        var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), h = o.get("align"), c = [this._tlpoints, this._blpoints];
        (!s || ne(s)) && (s && (i = aC(s) || i), s = i.get(["time", "monthAbbr"]) || []);
        var f = u === "start" ? 0 : 1, d = n === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = h === "center", g = 0; g < c[f].length - 1; g++) {
          var v = c[f][g].slice(), O = this._firstDayOfMonth[g];
          if (p) {
            var m = this._firstDayPoints[g];
            v[d] = (m[d] + c[0][g + 1][d]) / 2;
          }
          var E = o.get("formatter"), b = s[+O.m - 1], T = {
            yyyy: O.y,
            yy: (O.y + "").slice(2),
            MM: O.m,
            M: +O.m,
            nameMap: b
          }, S = this._formatterLabel(E, T), y = new lt({
            z2: 30,
            style: V(Lt(o, {
              text: S
            }), this._monthTextPositionControl(v, p, n, u, l))
          });
          a.add(y);
        }
      }
    }, e.prototype._weekTextPositionControl = function(t, i, n, a, o) {
      var s = "center", l = "middle", u = t[0], h = t[1], c = n === "start";
      return i === "horizontal" ? (u = u + a + (c ? 1 : -1) * o[0] / 2, s = c ? "right" : "left") : (h = h + a + (c ? 1 : -1) * o[1] / 2, l = c ? "bottom" : "top"), {
        x: u,
        y: h,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderWeekText = function(t, i, n, a, o) {
      var s = t.getModel("dayLabel");
      if (s.get("show")) {
        var l = t.coordinateSystem, u = s.get("position"), h = s.get("nameMap"), c = s.get("margin"), f = l.getFirstDayOfWeek();
        if (!h || ne(h)) {
          h && (i = aC(h) || i);
          var d = i.get(["time", "dayOfWeekShort"]);
          h = d || Y(i.get(["time", "dayOfWeekAbbr"]), function(T) {
            return T[0];
          });
        }
        var p = l.getNextNDay(n.end.time, 7 - n.lweek).time, g = [l.getCellWidth(), l.getCellHeight()];
        c = K(c, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(n.start.time, -(7 + n.fweek)).time, c = -c);
        for (var v = 0; v < 7; v++) {
          var O = l.getNextNDay(p, v), m = l.dataToRect([O.time], !1).center, E = v;
          E = Math.abs((v + f) % 7);
          var b = new lt({
            z2: 30,
            style: V(Lt(s, {
              text: h[E]
            }), this._weekTextPositionControl(m, a, u, c, g))
          });
          o.add(b);
        }
      }
    }, e.type = "calendar", e;
  }(Zt)
);
const WSe = HSe;
var H0 = 864e5, zSe = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "calendar", this.dimensions = r.dimensions, this.getDimensionsInfo = r.getDimensionsInfo, this._model = e;
    }
    return r.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, r.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.getCellWidth = function() {
      return this._sw;
    }, r.prototype.getCellHeight = function() {
      return this._sh;
    }, r.prototype.getOrient = function() {
      return this._orient;
    }, r.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, r.prototype.getDateInfo = function(e) {
      e = so(e);
      var t = e.getFullYear(), i = e.getMonth() + 1, n = i < 10 ? "0" + i : "" + i, a = e.getDate(), o = a < 10 ? "0" + a : "" + a, s = e.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: t + "",
        m: n,
        d: o,
        day: s,
        time: e.getTime(),
        formatedDate: t + "-" + n + "-" + o,
        date: e
      };
    }, r.prototype.getNextNDay = function(e, t) {
      return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e));
    }, r.prototype.update = function(e, t) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var i = this._rangeInfo.weeks || 1, n = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [i, 7] : [7, i];
      w([0, 1], function(c) {
        h(a, c) && (o[n[c]] = a[c] * s[c]);
      });
      var l = {
        width: t.getWidth(),
        height: t.getHeight()
      }, u = this._rect = mr(o, l);
      w([0, 1], function(c) {
        h(a, c) || (a[c] = u[n[c]] / s[c]);
      });
      function h(c, f) {
        return c[f] != null && c[f] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, r.prototype.dataToPoint = function(e, t) {
      X(e) && (e = e[0]), t == null && (t = !0);
      var i = this.getDateInfo(e), n = this._rangeInfo, a = i.formatedDate;
      if (t && !(i.time >= n.start.time && i.time < n.end.time + H0))
        return [NaN, NaN];
      var o = i.day, s = this._getRangeInfo([n.start.time, a]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2];
    }, r.prototype.pointToData = function(e) {
      var t = this.pointToDate(e);
      return t && t.time;
    }, r.prototype.dataToRect = function(e, t) {
      var i = this.dataToPoint(e, t);
      return {
        contentShape: {
          x: i[0] - (this._sw - this._lineWidth) / 2,
          y: i[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: i,
        tl: [i[0] - this._sw / 2, i[1] - this._sh / 2],
        tr: [i[0] + this._sw / 2, i[1] - this._sh / 2],
        br: [i[0] + this._sw / 2, i[1] + this._sh / 2],
        bl: [i[0] - this._sw / 2, i[1] + this._sh / 2]
      };
    }, r.prototype.pointToDate = function(e) {
      var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1, i = Math.floor((e[1] - this._rect.y) / this._sh) + 1, n = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(i, t - 1, n) : this._getDateByWeeksAndDay(t, i - 1, n);
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = NQ(t);
      return n === this ? n.dataToPoint(i) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = NQ(t);
      return n === this ? n.pointToData(i) : null;
    }, r.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, r.prototype._initRangeOption = function() {
      var e = this._model.get("range"), t;
      if (X(e) && e.length === 1 && (e = e[0]), X(e))
        t = e;
      else {
        var i = e.toString();
        if (/^\d{4}$/.test(i) && (t = [i + "-01-01", i + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(i)) {
          var n = this.getDateInfo(i), a = n.date;
          a.setMonth(a.getMonth() + 1);
          var o = this.getNextNDay(a, -1);
          t = [n.formatedDate, o.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(i) && (t = [i, i]);
      }
      if (!t)
        return e;
      var s = this._getRangeInfo(t);
      return s.start.time > s.end.time && t.reverse(), t;
    }, r.prototype._getRangeInfo = function(e) {
      var t = [this.getDateInfo(e[0]), this.getDateInfo(e[1])], i;
      t[0].time > t[1].time && (i = !0, t.reverse());
      var n = Math.floor(t[1].time / H0) - Math.floor(t[0].time / H0) + 1, a = new Date(t[0].time), o = a.getDate(), s = t[1].date.getDate();
      a.setDate(o + n - 1);
      var l = a.getDate();
      if (l !== s)
        for (var u = a.getTime() - t[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - t[1].time) * u > 0; )
          n -= u, a.setDate(l - u);
      var h = Math.floor((n + t[0].day + 6) / 7), c = i ? -h + 1 : h - 1;
      return i && t.reverse(), {
        range: [t[0].formatedDate, t[1].formatedDate],
        start: t[0],
        end: t[1],
        allDay: n,
        weeks: h,
        // From 0.
        nthWeek: c,
        fweek: t[0].day,
        lweek: t[1].day
      };
    }, r.prototype._getDateByWeeksAndDay = function(e, t, i) {
      var n = this._getRangeInfo(i);
      if (e > n.weeks || e === 0 && t < n.fweek || e === n.weeks && t > n.lweek)
        return null;
      var a = (e - 1) * 7 - n.fweek + t, o = new Date(n.start.time);
      return o.setDate(+n.start.d + a), this.getDateInfo(o);
    }, r.create = function(e, t) {
      var i = [];
      return e.eachComponent("calendar", function(n) {
        var a = new r(n);
        i.push(a), n.coordinateSystem = a;
      }), e.eachSeries(function(n) {
        n.get("coordinateSystem") === "calendar" && (n.coordinateSystem = i[n.get("calendarIndex") || 0]);
      }), i;
    }, r.dimensions = ["time", "value"], r;
  }()
);
function NQ(r) {
  var e = r.calendarModel, t = r.seriesModel, i = e ? e.coordinateSystem : t ? t.coordinateSystem : null;
  return i;
}
const ZSe = zSe;
function qSe(r) {
  r.registerComponentModel(YSe), r.registerComponentView(WSe), r.registerCoordinateSystem("calendar", ZSe);
}
function jSe(r, e) {
  var t = r.existing;
  if (e.id = r.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) {
    var i = e.parentOption;
    i ? e.parentId = i.id : t && (e.parentId = t.parentId);
  }
  e.parentOption = null;
}
function LQ(r, e) {
  var t;
  return w(e, function(i) {
    r[i] != null && r[i] !== "auto" && (t = !0);
  }), t;
}
function KSe(r, e, t) {
  var i = V({}, t), n = r[e], a = t.$action || "merge";
  a === "merge" ? n ? (Qe(n, i, !0), ol(n, i, {
    ignoreSize: !0
  }), QY(t, n), _O(t, n), _O(t, n, "shape"), _O(t, n, "style"), _O(t, n, "extra"), t.clipPath = n.clipPath) : r[e] = i : a === "replace" ? r[e] = i : a === "remove" && n && (r[e] = null);
}
var jz = ["transition", "enterFrom", "leaveTo"], JSe = jz.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function _O(r, e, t) {
  if (t && (!r[t] && e[t] && (r[t] = {}), r = r[t], e = e[t]), !(!r || !e))
    for (var i = t ? jz : JSe, n = 0; n < i.length; n++) {
      var a = i[n];
      r[a] == null && e[a] != null && (r[a] = e[a]);
    }
}
function eTe(r, e) {
  if (r && (r.hv = e.hv = [
    // Rigid body, don't care about `width`.
    LQ(e, ["left", "right"]),
    // Rigid body, don't care about `height`.
    LQ(e, ["top", "bottom"])
  ], r.type === "group")) {
    var t = r, i = e;
    t.width == null && (t.width = i.width = 0), t.height == null && (t.height = i.height = 0);
  }
}
var tTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.preventAutoZ = !0, t;
    }
    return e.prototype.mergeOption = function(t, i) {
      var n = this.option.elements;
      this.option.elements = null, r.prototype.mergeOption.call(this, t, i), this.option.elements = n;
    }, e.prototype.optionUpdated = function(t, i) {
      var n = this.option, a = (i ? n : t).elements, o = n.elements = i ? [] : n.elements, s = [];
      this._flatten(a, s, null);
      var l = EX(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      w(l, function(h, c) {
        var f = h.newOption;
        f && (u.push(f), jSe(h, f), KSe(o, c, f), eTe(o[c], f));
      }, this), n.elements = yt(o, function(h) {
        return h && delete h.$action, h != null;
      });
    }, e.prototype._flatten = function(t, i, n) {
      w(t, function(a) {
        if (a) {
          n && (a.parentOption = n), i.push(a);
          var o = a.children;
          o && o.length && this._flatten(o, i, a), delete a.children;
        }
      }, this);
    }, e.prototype.useElOptionsToUpdate = function() {
      var t = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, t;
    }, e.type = "graphic", e.defaultOption = {
      elements: []
      // parentId: null
    }, e;
  }(ot)
), DQ = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: ye,
  image: qr,
  text: lt
}, wn = at(), rTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._elMap = ce();
    }, e.prototype.render = function(t, i, n) {
      t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, n);
    }, e.prototype._updateElements = function(t) {
      var i = t.useElOptionsToUpdate();
      if (i) {
        var n = this._elMap, a = this.group, o = t.get("z"), s = t.get("zlevel");
        w(i, function(l) {
          var u = gr(l.id, null), h = u != null ? n.get(u) : null, c = gr(l.parentId, null), f = c != null ? n.get(c) : a, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && wz(p, d, !!v, !!g)) {
            var O = Pz(p, d, !0);
            !v && O.textConfig && (v = l.textConfig = O.textConfig), !g && O.textContent && (g = O.textContent);
          }
          var m = iTe(l), E = l.$action || "merge", b = E === "merge", T = E === "replace";
          if (b) {
            var S = !h, y = h;
            S ? y = MQ(u, f, l.type, n) : (y && (wn(y).isNew = !1), Mz(y)), y && (Am(y, m, t, {
              isInit: S
            }), kQ(y, l, o, s));
          } else if (T) {
            _m(h, l, n, t);
            var A = MQ(u, f, l.type, n);
            A && (Am(A, m, t, {
              isInit: !0
            }), kQ(A, l, o, s));
          } else
            E === "remove" && (Lz(h, l), _m(h, l, n, t));
          var C = n.get(u);
          if (C && g)
            if (b) {
              var _ = C.getTextContent();
              _ ? _.attr(g) : C.setTextContent(new lt(g));
            } else
              T && C.setTextContent(new lt(g));
          if (C) {
            var I = l.clipPath;
            if (I) {
              var x = I.type, P = void 0, S = !1;
              if (b) {
                var N = C.getClipPath();
                S = !N || wn(N).type !== x, P = S ? qC(x) : N;
              } else
                T && (S = !0, P = qC(x));
              C.setClipPath(P), Am(P, I, t, {
                isInit: S
              }), ZE(P, I.keyframeAnimation, t);
            }
            var L = wn(C);
            C.setTextConfig(v), L.option = l, nTe(C, t, l), yf({
              el: C,
              componentModel: t,
              itemName: C.name,
              itemTooltipOption: l.tooltip
            }), ZE(C, l.keyframeAnimation, t);
          }
        });
      }
    }, e.prototype._relocate = function(t, i) {
      for (var n = t.option.elements, a = this.group, o = this._elMap, s = i.getWidth(), l = i.getHeight(), u = ["x", "y"], h = 0; h < n.length; h++) {
        var c = n[h], f = gr(c.id, null), d = f != null ? o.get(f) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, g = p === a, v = wn(d), O = wn(p);
          v.width = K(v.option.width, g ? s : O.width) || 0, v.height = K(v.option.height, g ? l : O.height) || 0;
        }
      }
      for (var h = n.length - 1; h >= 0; h--) {
        var c = n[h], f = gr(c.id, null), d = f != null ? o.get(f) : null;
        if (d) {
          var p = d.parent, O = wn(p), m = p === a ? {
            width: s,
            height: l
          } : {
            width: O.width,
            height: O.height
          }, E = {}, b = DS(d, c, m, null, {
            hv: c.hv,
            boundingMode: c.bounding
          }, E);
          if (!wn(d).isNew && b) {
            for (var T = c.transition, S = {}, y = 0; y < u.length; y++) {
              var A = u[y], C = E[A];
              T && (Hu(T) || Ge(T, A) >= 0) ? S[A] = C : d[A] = C;
            }
            ft(d, S, t, 0);
          } else
            d.attr(E);
        }
      }
    }, e.prototype._clear = function() {
      var t = this, i = this._elMap;
      i.each(function(n) {
        _m(n, wn(n).option, i, t._lastGraphicModel);
      }), this._elMap = ce();
    }, e.prototype.dispose = function() {
      this._clear();
    }, e.type = "graphic", e;
  }(Zt)
);
function qC(r) {
  var e = oe(DQ, r) ? DQ[r] : HI(r), t = new e({});
  return wn(t).type = r, t;
}
function MQ(r, e, t, i) {
  var n = qC(t);
  return e.add(n), i.set(r, n), wn(n).id = r, wn(n).isNew = !0, n;
}
function _m(r, e, t, i) {
  var n = r && r.parent;
  n && (r.type === "group" && r.traverse(function(a) {
    _m(a, e, t, i);
  }), qS(r, e, i), t.removeKey(wn(r).id));
}
function kQ(r, e, t, i) {
  r.isGroup || w([
    ["cursor", qn.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", i || 0],
    ["z", t || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(n) {
    var a = n[0];
    oe(e, a) ? r[a] = ke(e[a], n[1]) : r[a] == null && (r[a] = n[1]);
  }), w(He(e), function(n) {
    if (n.indexOf("on") === 0) {
      var a = e[n];
      r[n] = ve(a) ? a : null;
    }
  }), oe(e, "draggable") && (r.draggable = e.draggable), e.name != null && (r.name = e.name), e.id != null && (r.id = e.id);
}
function iTe(r) {
  return r = V({}, r), w(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(kY), function(e) {
    delete r[e];
  }), r;
}
function nTe(r, e, t) {
  var i = _e(r).eventData;
  !r.silent && !r.ignore && !i && (i = _e(r).eventData = {
    componentType: "graphic",
    componentIndex: e.componentIndex,
    name: r.name
  }), i && (i.info = t.info);
}
function aTe(r) {
  r.registerComponentModel(tTe), r.registerComponentView(rTe), r.registerPreprocessor(function(e) {
    var t = e.graphic;
    X(t) ? !t[0] || !t[0].elements ? e.graphic = [{
      elements: t
    }] : e.graphic = [e.graphic[0]] : t && !t.elements && (e.graphic = [{
      elements: [t]
    }]);
  });
}
var QQ = ["x", "y", "radius", "angle", "single"], oTe = ["cartesian2d", "polar", "singleAxis"];
function sTe(r) {
  var e = r.get("coordinateSystem");
  return Ge(oTe, e) >= 0;
}
function Qs(r) {
  return r + "Axis";
}
function lTe(r, e) {
  var t = ce(), i = [], n = ce();
  r.eachComponent({
    mainType: "dataZoom",
    query: e
  }, function(h) {
    n.get(h.uid) || s(h);
  });
  var a;
  do
    a = !1, r.eachComponent("dataZoom", o);
  while (a);
  function o(h) {
    !n.get(h.uid) && l(h) && (s(h), a = !0);
  }
  function s(h) {
    n.set(h.uid, !0), i.push(h), u(h);
  }
  function l(h) {
    var c = !1;
    return h.eachTargetAxis(function(f, d) {
      var p = t.get(f);
      p && p[d] && (c = !0);
    }), c;
  }
  function u(h) {
    h.eachTargetAxis(function(c, f) {
      (t.get(c) || t.set(c, []))[f] = !0;
    });
  }
  return i;
}
function Kz(r) {
  var e = r.ecModel, t = {
    infoList: [],
    infoMap: ce()
  };
  return r.eachTargetAxis(function(i, n) {
    var a = e.getComponent(Qs(i), n);
    if (a) {
      var o = a.getCoordSysModel();
      if (o) {
        var s = o.uid, l = t.infoMap.get(s);
        l || (l = {
          model: o,
          axisModels: []
        }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(a);
      }
    }
  }), t;
}
var W0 = (
  /** @class */
  function() {
    function r() {
      this.indexList = [], this.indexMap = [];
    }
    return r.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = !0);
    }, r;
  }()
), uTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._autoThrottle = !0, t._noTarget = !0, t._rangePropMode = ["percent", "percent"], t;
    }
    return e.prototype.init = function(t, i, n) {
      var a = UQ(t);
      this.settledOption = a, this.mergeDefaultAndTheme(t, n), this._doInit(a);
    }, e.prototype.mergeOption = function(t) {
      var i = UQ(t);
      Qe(this.option, t, !0), Qe(this.settledOption, i, !0), this._doInit(i);
    }, e.prototype._doInit = function(t) {
      var i = this.option;
      this._setDefaultThrottle(t), this._updateRangeUse(t);
      var n = this.settledOption;
      w([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        this._rangePropMode[o] === "value" && (i[a[0]] = n[a[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var t = this.get("orient", !0), i = this._targetAxisInfoMap = ce(), n = this._fillSpecifiedTargetAxis(i);
      n ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(i, this._orient)), this._noTarget = !0, i.each(function(a) {
        a.indexList.length && (this._noTarget = !1);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(t) {
      var i = !1;
      return w(QQ, function(n) {
        var a = this.getReferringComponents(Qs(n), wie);
        if (a.specified) {
          i = !0;
          var o = new W0();
          w(a.models, function(s) {
            o.add(s.componentIndex);
          }), t.set(n, o);
        }
      }, this), i;
    }, e.prototype._fillAutoTargetAxisByOrient = function(t, i) {
      var n = this.ecModel, a = !0;
      if (a) {
        var o = i === "vertical" ? "y" : "x", s = n.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = n.findComponents({
          mainType: "singleAxis",
          filter: function(h) {
            return h.get("orient", !0) === i;
          }
        });
        l(s, "single");
      }
      function l(u, h) {
        var c = u[0];
        if (c) {
          var f = new W0();
          if (f.add(c.componentIndex), t.set(h, f), a = !1, h === "x" || h === "y") {
            var d = c.getReferringComponents("grid", lr).models[0];
            d && w(u, function(p) {
              c.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", lr).models[0] && f.add(p.componentIndex);
            });
          }
        }
      }
      a && w(QQ, function(u) {
        if (a) {
          var h = n.findComponents({
            mainType: Qs(u),
            filter: function(f) {
              return f.get("type", !0) === "category";
            }
          });
          if (h[0]) {
            var c = new W0();
            c.add(h[0].componentIndex), t.set(u, c), a = !1;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var t;
      return this.eachTargetAxis(function(i) {
        !t && (t = i);
      }, this), t === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(t) {
      if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var i = this.ecModel.option;
        this.option.throttle = i.animation && i.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(t) {
      var i = this._rangePropMode, n = this.get("rangeMode");
      w([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        var s = t[a[0]] != null, l = t[a[1]] != null;
        s && !l ? i[o] = "percent" : !s && l ? i[o] = "value" : n ? i[o] = n[o] : s && (i[o] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var t;
      return this.eachTargetAxis(function(i, n) {
        t == null && (t = this.ecModel.getComponent(Qs(i), n));
      }, this), t;
    }, e.prototype.eachTargetAxis = function(t, i) {
      this._targetAxisInfoMap.each(function(n, a) {
        w(n.indexList, function(o) {
          t.call(i, a, o);
        });
      });
    }, e.prototype.getAxisProxy = function(t, i) {
      var n = this.getAxisModel(t, i);
      if (n)
        return n.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(t, i) {
      var n = this._targetAxisInfoMap.get(t);
      if (n && n.indexMap[i])
        return this.ecModel.getComponent(Qs(t), i);
    }, e.prototype.setRawRange = function(t) {
      var i = this.option, n = this.settledOption;
      w([["start", "startValue"], ["end", "endValue"]], function(a) {
        (t[a[0]] != null || t[a[1]] != null) && (i[a[0]] = n[a[0]] = t[a[0]], i[a[1]] = n[a[1]] = t[a[1]]);
      }, this), this._updateRangeUse(t);
    }, e.prototype.setCalculatedRange = function(t) {
      var i = this.option;
      w(["start", "startValue", "end", "endValue"], function(n) {
        i[n] = t[n];
      });
    }, e.prototype.getPercentRange = function() {
      var t = this.findRepresentativeAxisProxy();
      if (t)
        return t.getDataPercentWindow();
    }, e.prototype.getValueRange = function(t, i) {
      if (t == null && i == null) {
        var n = this.findRepresentativeAxisProxy();
        if (n)
          return n.getDataValueWindow();
      } else
        return this.getAxisProxy(t, i).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(t) {
      if (t)
        return t.__dzAxisProxy;
      for (var i, n = this._targetAxisInfoMap.keys(), a = 0; a < n.length; a++)
        for (var o = n[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(o, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          i || (i = u);
        }
      return i;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return this._orient;
    }, e.type = "dataZoom", e.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(ot)
);
function UQ(r) {
  var e = {};
  return w(["start", "end", "startValue", "endValue", "throttle"], function(t) {
    r.hasOwnProperty(t) && (e[t] = r[t]);
  }), e;
}
const hg = uTe;
var hTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(hg)
);
const cTe = hTe;
var fTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this.dataZoomModel = t, this.ecModel = i, this.api = n;
    }, e.type = "dataZoom", e;
  }(Zt)
);
const pw = fTe;
var dTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(pw)
);
const pTe = dTe;
var uc = w, $Q = $n, gTe = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      this._dimName = e, this._axisIndex = t, this.ecModel = n, this._dataZoomModel = i;
    }
    return r.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, r.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, r.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, r.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(t) {
        if (sTe(t)) {
          var i = Qs(this._dimName), n = t.getReferringComponents(i, lr).models[0];
          n && this._axisIndex === n.componentIndex && e.push(t);
        }
      }, this), e;
    }, r.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, r.prototype.getMinMaxSpan = function() {
      return Se(this._minMaxSpan);
    }, r.prototype.calculateDataWindow = function(e) {
      var t = this._dataExtent, i = this.getAxisModel(), n = i.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
      uc(["start", "end"], function(f, d) {
        var p = e[f], g = e[f + "Value"];
        a[d] === "percent" ? (p == null && (p = o[d]), g = n.parse(Et(p, o, t))) : (u = !0, g = g == null ? t[d] : n.parse(g), p = Et(g, t, o)), l[d] = g == null || isNaN(g) ? t[d] : g, s[d] = p == null || isNaN(p) ? o[d] : p;
      }), $Q(l), $Q(s);
      var h = this._minMaxSpan;
      u ? c(l, s, t, o, !1) : c(s, l, o, t, !0);
      function c(f, d, p, g, v) {
        var O = v ? "Span" : "ValueSpan";
        Ch(0, f, p, "all", h["min" + O], h["max" + O]);
        for (var m = 0; m < 2; m++)
          d[m] = Et(f[m], p, g, !0), v && (d[m] = n.parse(d[m]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, r.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var t = this.getTargetSeriesModels();
        this._dataExtent = vTe(this, this._dimName, t), this._updateMinMaxSpan();
        var i = this.calculateDataWindow(e.settledOption);
        this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, this._setAxisModel();
      }
    }, r.prototype.filterData = function(e, t) {
      if (e !== this._dataZoomModel)
        return;
      var i = this._dimName, n = this.getTargetSeriesModels(), a = e.get("filterMode"), o = this._valueWindow;
      if (a === "none")
        return;
      uc(n, function(l) {
        var u = l.getData(), h = u.mapDimensionsAll(i);
        if (h.length) {
          if (a === "weakFilter") {
            var c = u.getStore(), f = Y(h, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, g, v, O = 0; O < h.length; O++) {
                var m = c.get(f[O], d), E = !isNaN(m), b = m < o[0], T = m > o[1];
                if (E && !b && !T)
                  return !0;
                E && (v = !0), b && (p = !0), T && (g = !0);
              }
              return v && p && g;
            });
          } else
            uc(h, function(d) {
              if (a === "empty")
                l.setData(u = u.map(d, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var p = {};
                p[d] = o, u.selectRange(p);
              }
            });
          uc(h, function(d) {
            u.setApproximateExtent(o, d);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, r.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, t = this._dataZoomModel, i = this._dataExtent;
      uc(["min", "max"], function(n) {
        var a = t.get(n + "Span"), o = t.get(n + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = Et(i[0] + o, i, [0, 100], !0) : a != null && (o = Et(a, [0, 100], i, !0) - i[0]), e[n + "Span"] = a, e[n + "ValueSpan"] = o;
      }, this);
    }, r.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), t = this._percentWindow, i = this._valueWindow;
      if (t) {
        var n = cX(i, [0, 500]);
        n = Math.min(n, 20);
        var a = e.axis.scale.rawExtentInfo;
        t[0] !== 0 && a.setDeterminedMinMax("min", +i[0].toFixed(n)), t[1] !== 100 && a.setDeterminedMinMax("max", +i[1].toFixed(n)), a.freeze();
      }
    }, r;
  }()
);
function vTe(r, e, t) {
  var i = [1 / 0, -1 / 0];
  uc(t, function(o) {
    Gue(i, o.getData(), e);
  });
  var n = r.getAxisModel(), a = gW(n.axis.scale, n, i).calculate();
  return [a.min, a.max];
}
const OTe = gTe;
var mTe = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(r) {
    function e(n) {
      r.eachComponent("dataZoom", function(a) {
        a.eachTargetAxis(function(o, s) {
          var l = r.getComponent(Qs(o), s);
          n(o, s, l, a);
        });
      });
    }
    e(function(n, a, o, s) {
      o.__dzAxisProxy = null;
    });
    var t = [];
    e(function(n, a, o, s) {
      o.__dzAxisProxy || (o.__dzAxisProxy = new OTe(n, a, s, r), t.push(o.__dzAxisProxy));
    });
    var i = ce();
    return w(t, function(n) {
      w(n.getTargetSeriesModels(), function(a) {
        i.set(a.uid, a);
      });
    }), i;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(r, e) {
    r.eachComponent("dataZoom", function(t) {
      t.eachTargetAxis(function(i, n) {
        t.getAxisProxy(i, n).reset(t);
      }), t.eachTargetAxis(function(i, n) {
        t.getAxisProxy(i, n).filterData(t, e);
      });
    }), r.eachComponent("dataZoom", function(t) {
      var i = t.findRepresentativeAxisProxy();
      if (i) {
        var n = i.getDataPercentWindow(), a = i.getDataValueWindow();
        t.setCalculatedRange({
          start: n[0],
          end: n[1],
          startValue: a[0],
          endValue: a[1]
        });
      }
    });
  }
};
const ETe = mTe;
function bTe(r) {
  r.registerAction("dataZoom", function(e, t) {
    var i = lTe(t, e);
    w(i, function(n) {
      n.setRawRange({
        start: e.start,
        end: e.end,
        startValue: e.startValue,
        endValue: e.endValue
      });
    });
  });
}
var GQ = !1;
function gw(r) {
  GQ || (GQ = !0, r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, ETe), bTe(r), r.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function STe(r) {
  r.registerComponentModel(cTe), r.registerComponentView(pTe), gw(r);
}
var Ln = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), Jz = {};
function hc(r, e) {
  Jz[r] = e;
}
function e4(r) {
  return Jz[r];
}
var TTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      r.prototype.optionUpdated.apply(this, arguments);
      var t = this.ecModel;
      w(this.option.feature, function(i, n) {
        var a = e4(n);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(t)), Qe(i, a.defaultOption));
      });
    }, e.type = "toolbox", e.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, e.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, e;
  }(ot)
);
const yTe = TTe;
function RTe(r, e, t) {
  var i = e.getBoxLayoutParams(), n = e.get("padding"), a = {
    width: t.getWidth(),
    height: t.getHeight()
  }, o = mr(i, a, n);
  Fu(e.get("orient"), r, e.get("itemGap"), o.width, o.height), DS(r, i, a, n);
}
function t4(r, e) {
  var t = Cf(e.get("padding")), i = e.getItemStyle(["color", "opacity"]);
  return i.fill = e.get("backgroundColor"), r = new nt({
    shape: {
      x: r.x - t[3],
      y: r.y - t[0],
      width: r.width + t[1] + t[3],
      height: r.height + t[0] + t[2],
      r: e.get("borderRadius")
    },
    style: i,
    silent: !0,
    z2: -1
  }), r;
}
var ATe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = this.group;
      if (o.removeAll(), !t.get("show"))
        return;
      var s = +t.get("itemSize"), l = t.get("orient") === "vertical", u = t.get("feature") || {}, h = this._features || (this._features = {}), c = [];
      w(u, function(p, g) {
        c.push(g);
      }), new Ho(this._featureNames || [], c).add(f).update(f).remove(Ie(f, null)).execute(), this._featureNames = c;
      function f(p, g) {
        var v = c[p], O = c[g], m = u[v], E = new Dt(m, t, t.ecModel), b;
        if (a && a.newTitle != null && a.featureName === v && (m.title = a.newTitle), v && !O) {
          if (CTe(v))
            b = {
              onclick: E.option.onclick,
              featureName: v
            };
          else {
            var T = e4(v);
            if (!T)
              return;
            b = new T();
          }
          h[v] = b;
        } else if (b = h[O], !b)
          return;
        b.uid = Af("toolbox-feature"), b.model = E, b.ecModel = i, b.api = n;
        var S = b instanceof Ln;
        if (!v && O) {
          S && b.dispose && b.dispose(i, n);
          return;
        }
        if (!E.get("show") || S && b.unusable) {
          S && b.remove && b.remove(i, n);
          return;
        }
        d(E, b, v), E.setIconStatus = function(y, A) {
          var C = this.option, _ = this.iconPaths;
          C.iconStatus = C.iconStatus || {}, C.iconStatus[y] = A, _[y] && (A === "emphasis" ? Xo : Yo)(_[y]);
        }, b instanceof Ln && b.render && b.render(E, i, n, a);
      }
      function d(p, g, v) {
        var O = p.getModel("iconStyle"), m = p.getModel(["emphasis", "iconStyle"]), E = g instanceof Ln && g.getIcons ? g.getIcons() : p.get("icon"), b = p.get("title") || {}, T, S;
        ne(E) ? (T = {}, T[v] = E) : T = E, ne(b) ? (S = {}, S[v] = b) : S = b;
        var y = p.iconPaths = {};
        w(T, function(A, C) {
          var _ = Vg(A, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          _.setStyle(O.getItemStyle());
          var I = _.ensureState("emphasis");
          I.style = m.getItemStyle();
          var x = new lt({
            style: {
              text: S[C],
              align: m.get("textAlign"),
              borderRadius: m.get("textBorderRadius"),
              padding: m.get("textPadding"),
              fill: null
            },
            ignore: !0
          });
          _.setTextContent(x), yf({
            el: _,
            componentModel: t,
            itemName: C,
            formatterParamsExtra: {
              title: S[C]
            }
          }), _.__title = S[C], _.on("mouseover", function() {
            var P = m.getItemStyle(), N = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
            x.setStyle({
              fill: m.get("textFill") || P.fill || P.stroke || "#000",
              backgroundColor: m.get("textBackgroundColor")
            }), _.setTextConfig({
              position: m.get("textPosition") || N
            }), x.ignore = !t.get("showTitle"), n.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get(["iconStatus", C]) !== "emphasis" && n.leaveEmphasis(this), x.hide();
          }), (p.get(["iconStatus", C]) === "emphasis" ? Xo : Yo)(_), o.add(_), _.on("click", ae(g.onclick, g, i, n, C)), y[C] = _;
        });
      }
      RTe(o, t, n), o.add(t4(o.getBoundingRect(), t)), l || o.eachChild(function(p) {
        var g = p.__title, v = p.ensureState("emphasis"), O = v.textConfig || (v.textConfig = {}), m = p.getTextContent(), E = m && m.ensureState("emphasis");
        if (E && !ve(E) && g) {
          var b = E.style || (E.style = {}), T = Qg(g, lt.makeFont(b)), S = p.x + o.x, y = p.y + o.y + s, A = !1;
          y + T.height > n.getHeight() && (O.position = "top", A = !0);
          var C = A ? -5 - T.height : s + 10;
          S + T.width / 2 > n.getWidth() ? (O.position = ["100%", C], b.align = "right") : S - T.width / 2 < 0 && (O.position = [0, C], b.align = "left");
        }
      });
    }, e.prototype.updateView = function(t, i, n, a) {
      w(this._features, function(o) {
        o instanceof Ln && o.updateView && o.updateView(o.model, i, n, a);
      });
    }, e.prototype.remove = function(t, i) {
      w(this._features, function(n) {
        n instanceof Ln && n.remove && n.remove(t, i);
      }), this.group.removeAll();
    }, e.prototype.dispose = function(t, i) {
      w(this._features, function(n) {
        n instanceof Ln && n.dispose && n.dispose(t, i);
      });
    }, e.type = "toolbox", e;
  }(Zt)
);
function CTe(r) {
  return r.indexOf("my") === 0;
}
const _Te = ATe;
var ITe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, i) {
      var n = this.model, a = n.get("name") || t.get("title.0.text") || "echarts", o = i.getZr().painter.getType() === "svg", s = o ? "svg" : n.get("type", !0) || "png", l = i.getConnectedDataURL({
        type: s,
        backgroundColor: n.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
        connectedBackgroundColor: n.get("connectedBackgroundColor"),
        excludeComponents: n.get("excludeComponents"),
        pixelRatio: n.get("pixelRatio")
      }), u = st.browser;
      if (ve(MouseEvent) && (u.newEdge || !u.ie && !u.edge)) {
        var h = document.createElement("a");
        h.download = a + "." + s, h.target = "_blank", h.href = l;
        var c = new MouseEvent("click", {
          // some micro front-end framework window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        h.dispatchEvent(c);
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var f = l.split(","), d = f[0].indexOf("base64") > -1, p = o ? decodeURIComponent(f[1]) : f[1];
        d && (p = window.atob(p));
        var g = a + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, O = new Uint8Array(v); v--; )
            O[v] = p.charCodeAt(v);
          var m = new Blob([O]);
          window.navigator.msSaveOrOpenBlob(m, g);
        } else {
          var E = document.createElement("iframe");
          document.body.appendChild(E);
          var b = E.contentWindow, T = b.document;
          T.open("image/svg+xml", "replace"), T.write(p), T.close(), b.focus(), T.execCommand("SaveAs", !0, g), document.body.removeChild(E);
        }
      } else {
        var S = n.get("lang"), y = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (S && S[0] || "") + '" /></body>', A = window.open();
        A.document.write(y), A.document.title = a;
      }
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: t.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: t.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return i;
    }, e;
  }(Ln)
);
const xTe = ITe;
var BQ = "__ec_magicType_stack__", wTe = [["line", "bar"], ["stack"]], PTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getIcons = function() {
      var t = this.model, i = t.get("icon"), n = {};
      return w(t.get("type"), function(a) {
        i[a] && (n[a] = i[a]);
      }), n;
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: t.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return i;
    }, e.prototype.onclick = function(t, i, n) {
      var a = this.model, o = a.get(["seriesIndex", n]);
      if (VQ[n]) {
        var s = {
          series: []
        }, l = function(c) {
          var f = c.subType, d = c.id, p = VQ[n](f, d, c, a);
          p && (me(p, c.option), s.series.push(p));
          var g = c.coordinateSystem;
          if (g && g.type === "cartesian2d" && (n === "line" || n === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var O = v.dim, m = O + "Axis", E = c.getReferringComponents(m, lr).models[0], b = E.componentIndex;
              s[m] = s[m] || [];
              for (var T = 0; T <= b; T++)
                s[m][b] = s[m][b] || {};
              s[m][b].boundaryGap = n === "bar";
            }
          }
        };
        w(wTe, function(c) {
          Ge(c, n) >= 0 && w(c, function(f) {
            a.setIconStatus(f, "normal");
          });
        }), a.setIconStatus(n, "emphasis"), t.eachComponent({
          mainType: "series",
          query: o == null ? null : {
            seriesIndex: o
          }
        }, l);
        var u, h = n;
        n === "stack" && (u = Qe({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get(["iconStatus", n]) !== "emphasis" && (h = "tiled")), i.dispatchAction({
          type: "changeMagicType",
          currentType: h,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, e;
  }(Ln)
), VQ = {
  line: function(r, e, t, i) {
    if (r === "bar")
      return Qe({
        id: e,
        type: "line",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, i.get(["option", "line"]) || {}, !0);
  },
  bar: function(r, e, t, i) {
    if (r === "line")
      return Qe({
        id: e,
        type: "bar",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, i.get(["option", "bar"]) || {}, !0);
  },
  stack: function(r, e, t, i) {
    var n = t.get("stack") === BQ;
    if (r === "line" || r === "bar")
      return i.setIconStatus("stack", n ? "normal" : "emphasis"), Qe({
        id: e,
        stack: n ? "" : BQ
      }, i.get(["option", "stack"]) || {}, !0);
  }
};
Oo({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(r, e) {
  e.mergeOption(r.newOption);
});
const NTe = PTe;
var jS = new Array(60).join("-"), of = "	";
function LTe(r) {
  var e = {}, t = [], i = [];
  return r.eachRawSeries(function(n) {
    var a = n.coordinateSystem;
    if (a && (a.type === "cartesian2d" || a.type === "polar")) {
      var o = a.getBaseAxis();
      if (o.type === "category") {
        var s = o.dim + "_" + o.index;
        e[s] || (e[s] = {
          categoryAxis: o,
          valueAxis: a.getOtherAxis(o),
          series: []
        }, i.push({
          axisDim: o.dim,
          axisIndex: o.index
        })), e[s].series.push(n);
      } else
        t.push(n);
    } else
      t.push(n);
  }), {
    seriesGroupByCategoryAxis: e,
    other: t,
    meta: i
  };
}
function DTe(r) {
  var e = [];
  return w(r, function(t, i) {
    var n = t.categoryAxis, a = t.valueAxis, o = a.dim, s = [" "].concat(Y(t.series, function(d) {
      return d.name;
    })), l = [n.model.getCategories()];
    w(t.series, function(d) {
      var p = d.getRawData();
      l.push(d.getRawData().mapArray(p.mapDimension(o), function(g) {
        return g;
      }));
    });
    for (var u = [s.join(of)], h = 0; h < l[0].length; h++) {
      for (var c = [], f = 0; f < l.length; f++)
        c.push(l[f][h]);
      u.push(c.join(of));
    }
    e.push(u.join(`
`));
  }), e.join(`

` + jS + `

`);
}
function MTe(r) {
  return Y(r, function(e) {
    var t = e.getRawData(), i = [e.name], n = [];
    return t.each(t.dimensions, function() {
      for (var a = arguments.length, o = arguments[a - 1], s = t.getName(o), l = 0; l < a - 1; l++)
        n[l] = arguments[l];
      i.push((s ? s + of : "") + n.join(of));
    }), i.join(`
`);
  }).join(`

` + jS + `

`);
}
function kTe(r) {
  var e = LTe(r);
  return {
    value: yt([DTe(e.seriesGroupByCategoryAxis), MTe(e.other)], function(t) {
      return !!t.replace(/[\n\t\s]/g, "");
    }).join(`

` + jS + `

`),
    meta: e.meta
  };
}
function KE(r) {
  return r.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function QTe(r) {
  var e = r.slice(0, r.indexOf(`
`));
  if (e.indexOf(of) >= 0)
    return !0;
}
var jC = new RegExp("[" + of + "]+", "g");
function UTe(r) {
  for (var e = r.split(/\n+/g), t = KE(e.shift()).split(jC), i = [], n = Y(t, function(l) {
    return {
      name: l,
      data: []
    };
  }), a = 0; a < e.length; a++) {
    var o = KE(e[a]).split(jC);
    i.push(o.shift());
    for (var s = 0; s < o.length; s++)
      n[s] && (n[s].data[a] = o[s]);
  }
  return {
    series: n,
    categories: i
  };
}
function $Te(r) {
  for (var e = r.split(/\n+/g), t = KE(e.shift()), i = [], n = 0; n < e.length; n++) {
    var a = KE(e[n]);
    if (a) {
      var o = a.split(jC), s = "", l = void 0, u = !1;
      isNaN(o[0]) ? (u = !0, s = o[0], o = o.slice(1), i[n] = {
        name: s,
        value: []
      }, l = i[n].value) : l = i[n] = [];
      for (var h = 0; h < o.length; h++)
        l.push(+o[h]);
      l.length === 1 && (u ? i[n].value = l[0] : i[n] = l[0]);
    }
  }
  return {
    name: t,
    data: i
  };
}
function GTe(r, e) {
  var t = r.split(new RegExp(`
*` + jS + `
*`, "g")), i = {
    series: []
  };
  return w(t, function(n, a) {
    if (QTe(n)) {
      var o = UTe(n), s = e[a], l = s.axisDim + "Axis";
      s && (i[l] = i[l] || [], i[l][s.axisIndex] = {
        data: o.categories
      }, i.series = i.series.concat(o.series));
    } else {
      var o = $Te(n);
      i.series.push(o);
    }
  }), i;
}
var BTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, i) {
      setTimeout(function() {
        i.dispatchAction({
          type: "hideTip"
        });
      });
      var n = i.getDom(), a = this.model;
      this._dom && n.removeChild(this._dom);
      var o = document.createElement("div");
      o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = a.get("lang") || [];
      s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
      var u = document.createElement("div"), h = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var c = a.get("optionToContent"), f = a.get("contentToOption"), d = kTe(t);
      if (ve(c)) {
        var p = c(i.getOption());
        ne(p) ? u.innerHTML = p : Up(p) && u.appendChild(p);
      } else {
        h.readOnly = a.get("readOnly");
        var g = h.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = a.get("textColor"), g.borderColor = a.get("textareaBorderColor"), g.backgroundColor = a.get("textareaColor"), h.value = d.value, u.appendChild(h);
      }
      var v = d.meta, O = document.createElement("div");
      O.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var m = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", E = document.createElement("div"), b = document.createElement("div");
      m += ";background-color:" + a.get("buttonColor"), m += ";color:" + a.get("buttonTextColor");
      var T = this;
      function S() {
        n.removeChild(o), T._dom = null;
      }
      NA(E, "click", S), NA(b, "click", function() {
        if (f == null && c != null || f != null && c == null) {
          S();
          return;
        }
        var y;
        try {
          ve(f) ? y = f(u, i.getOption()) : y = GTe(h.value, v);
        } catch (A) {
          throw S(), new Error("Data view format error " + A);
        }
        y && i.dispatchAction({
          type: "changeDataView",
          newOption: y
        }), S();
      }), E.innerHTML = l[1], b.innerHTML = l[2], b.style.cssText = E.style.cssText = m, !a.get("readOnly") && O.appendChild(b), O.appendChild(E), o.appendChild(s), o.appendChild(u), o.appendChild(O), u.style.height = n.clientHeight - 80 + "px", n.appendChild(o), this._dom = o;
    }, e.prototype.remove = function(t, i) {
      this._dom && i.getDom().removeChild(this._dom);
    }, e.prototype.dispose = function(t, i) {
      this.remove(t, i);
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: t.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: t.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return i;
    }, e;
  }(Ln)
);
function VTe(r, e) {
  return Y(r, function(t, i) {
    var n = e && e[i];
    if (be(n) && !X(n)) {
      var a = be(t) && !X(t);
      a || (t = {
        value: t
      });
      var o = n.name != null && t.name == null;
      return t = me(t, n), o && delete t.name, t;
    } else
      return t;
  });
}
Oo({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(r, e) {
  var t = [];
  w(r.newOption.series, function(i) {
    var n = e.getSeriesByName(i.name)[0];
    if (!n)
      t.push(V({
        // Default is scatter
        type: "scatter"
      }, i));
    else {
      var a = n.get("data");
      t.push({
        name: i.name,
        data: VTe(i.data, a)
      });
    }
  }), e.mergeOption(me({
    series: t
  }, r.newOption));
});
const FTe = BTe;
var r4 = w, i4 = at();
function XTe(r, e) {
  var t = vw(r);
  r4(e, function(i, n) {
    for (var a = t.length - 1; a >= 0; a--) {
      var o = t[a];
      if (o[n])
        break;
    }
    if (a < 0) {
      var s = r.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: n
      })[0];
      if (s) {
        var l = s.getPercentRange();
        t[0][n] = {
          dataZoomId: n,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), t.push(e);
}
function YTe(r) {
  var e = vw(r), t = e[e.length - 1];
  e.length > 1 && e.pop();
  var i = {};
  return r4(t, function(n, a) {
    for (var o = e.length - 1; o >= 0; o--)
      if (n = e[o][a], n) {
        i[a] = n;
        break;
      }
  }), i;
}
function HTe(r) {
  i4(r).snapshots = null;
}
function WTe(r) {
  return vw(r).length;
}
function vw(r) {
  var e = i4(r);
  return e.snapshots || (e.snapshots = [{}]), e.snapshots;
}
var zTe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, i) {
      HTe(t), i.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: t.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return i;
    }, e;
  }(Ln)
);
Oo({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(r, e) {
  e.resetOption("recreate");
});
const ZTe = zTe;
var qTe = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], jTe = (
  /** @class */
  function() {
    function r(e, t, i) {
      var n = this;
      this._targetInfoList = [];
      var a = FQ(t, e);
      w(KTe, function(o, s) {
        (!i || !i.include || Ge(i.include, s) >= 0) && o(a, n._targetInfoList);
      });
    }
    return r.prototype.setOutputRanges = function(e, t) {
      return this.matchOutputRanges(e, t, function(i, n, a) {
        if ((i.coordRanges || (i.coordRanges = [])).push(n), !i.coordRange) {
          i.coordRange = n;
          var o = z0[i.brushType](0, a, n);
          i.__rangeOffset = {
            offset: WQ[i.brushType](o.values, i.range, [1, 1]),
            xyMinMax: o.xyMinMax
          };
        }
      }), e;
    }, r.prototype.matchOutputRanges = function(e, t, i) {
      w(e, function(n) {
        var a = this.findTargetInfo(n, t);
        a && a !== !0 && w(a.coordSyses, function(o) {
          var s = z0[n.brushType](1, o, n.range, !0);
          i(n, s.values, o, t);
        });
      }, this);
    }, r.prototype.setInputRanges = function(e, t) {
      w(e, function(i) {
        var n = this.findTargetInfo(i, t);
        if (i.range = i.range || [], n && n !== !0) {
          i.panelId = n.panelId;
          var a = z0[i.brushType](0, n.coordSys, i.coordRange), o = i.__rangeOffset;
          i.range = o ? WQ[i.brushType](a.values, o.offset, JTe(a.xyMinMax, o.xyMinMax)) : a.values;
        }
      }, this);
    }, r.prototype.makePanelOpts = function(e, t) {
      return Y(this._targetInfoList, function(i) {
        var n = i.getPanelRect();
        return {
          panelId: i.panelId,
          defaultBrushType: t ? t(i) : null,
          clipPath: hz(n),
          isTargetByCursor: fz(n, e, i.coordSysModel),
          getLinearBrushOtherExtent: cz(n)
        };
      });
    }, r.prototype.controlSeries = function(e, t, i) {
      var n = this.findTargetInfo(e, i);
      return n === !0 || n && Ge(n.coordSyses, t.coordinateSystem) >= 0;
    }, r.prototype.findTargetInfo = function(e, t) {
      for (var i = this._targetInfoList, n = FQ(t, e), a = 0; a < i.length; a++) {
        var o = i[a], s = e.panelId;
        if (s) {
          if (o.panelId === s)
            return o;
        } else
          for (var l = 0; l < XQ.length; l++)
            if (XQ[l](n, o))
              return o;
      }
      return !0;
    }, r;
  }()
);
function KC(r) {
  return r[0] > r[1] && r.reverse(), r;
}
function FQ(r, e) {
  return op(r, e, {
    includeMainTypes: qTe
  });
}
var KTe = {
  grid: function(r, e) {
    var t = r.xAxisModels, i = r.yAxisModels, n = r.gridModels, a = ce(), o = {}, s = {};
    !t && !i && !n || (w(t, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), o[u.id] = !0;
    }), w(i, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), s[u.id] = !0;
    }), w(n, function(l) {
      a.set(l.id, l), o[l.id] = !0, s[l.id] = !0;
    }), a.each(function(l) {
      var u = l.coordinateSystem, h = [];
      w(u.getCartesians(), function(c, f) {
        (Ge(t, c.getAxis("x").model) >= 0 || Ge(i, c.getAxis("y").model) >= 0) && h.push(c);
      }), e.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: h[0],
        coordSyses: h,
        getPanelRect: YQ.grid,
        xAxisDeclared: o[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(r, e) {
    w(r.geoModels, function(t) {
      var i = t.coordinateSystem;
      e.push({
        panelId: "geo--" + t.id,
        geoModel: t,
        coordSysModel: t,
        coordSys: i,
        coordSyses: [i],
        getPanelRect: YQ.geo
      });
    });
  }
}, XQ = [
  // grid
  function(r, e) {
    var t = r.xAxisModel, i = r.yAxisModel, n = r.gridModel;
    return !n && t && (n = t.axis.grid.model), !n && i && (n = i.axis.grid.model), n && n === e.gridModel;
  },
  // geo
  function(r, e) {
    var t = r.geoModel;
    return t && t === e.geoModel;
  }
], YQ = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var r = this.coordSys, e = r.getBoundingRect().clone();
    return e.applyTransform(Vu(r)), e;
  }
}, z0 = {
  lineX: Ie(HQ, 0),
  lineY: Ie(HQ, 1),
  rect: function(r, e, t, i) {
    var n = r ? e.pointToData([t[0][0], t[1][0]], i) : e.dataToPoint([t[0][0], t[1][0]], i), a = r ? e.pointToData([t[0][1], t[1][1]], i) : e.dataToPoint([t[0][1], t[1][1]], i), o = [KC([n[0], a[0]]), KC([n[1], a[1]])];
    return {
      values: o,
      xyMinMax: o
    };
  },
  polygon: function(r, e, t, i) {
    var n = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = Y(t, function(o) {
      var s = r ? e.pointToData(o, i) : e.dataToPoint(o, i);
      return n[0][0] = Math.min(n[0][0], s[0]), n[1][0] = Math.min(n[1][0], s[1]), n[0][1] = Math.max(n[0][1], s[0]), n[1][1] = Math.max(n[1][1], s[1]), s;
    });
    return {
      values: a,
      xyMinMax: n
    };
  }
};
function HQ(r, e, t, i) {
  var n = t.getAxis(["x", "y"][r]), a = KC(Y([0, 1], function(s) {
    return e ? n.coordToData(n.toLocalCoord(i[s]), !0) : n.toGlobalCoord(n.dataToCoord(i[s]));
  })), o = [];
  return o[r] = a, o[1 - r] = [NaN, NaN], {
    values: a,
    xyMinMax: o
  };
}
var WQ = {
  lineX: Ie(zQ, 0),
  lineY: Ie(zQ, 1),
  rect: function(r, e, t) {
    return [[r[0][0] - t[0] * e[0][0], r[0][1] - t[0] * e[0][1]], [r[1][0] - t[1] * e[1][0], r[1][1] - t[1] * e[1][1]]];
  },
  polygon: function(r, e, t) {
    return Y(r, function(i, n) {
      return [i[0] - t[0] * e[n][0], i[1] - t[1] * e[n][1]];
    });
  }
};
function zQ(r, e, t, i) {
  return [e[0] - i[r] * t[0], e[1] - i[r] * t[1]];
}
function JTe(r, e) {
  var t = ZQ(r), i = ZQ(e), n = [t[0] / i[0], t[1] / i[1]];
  return isNaN(n[0]) && (n[0] = 1), isNaN(n[1]) && (n[1] = 1), n;
}
function ZQ(r) {
  return r ? [r[0][1] - r[0][0], r[1][1] - r[1][0]] : [NaN, NaN];
}
const Ow = jTe;
var JC = w, eye = Aie("toolbox-dataZoom_"), tye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, i, n, a) {
      this._brushController || (this._brushController = new jx(n.getZr()), this._brushController.on("brush", ae(this._onBrush, this)).mount()), nye(t, i, this, a, n), iye(t, i);
    }, e.prototype.onclick = function(t, i, n) {
      rye[n].call(this);
    }, e.prototype.remove = function(t, i) {
      this._brushController && this._brushController.unmount();
    }, e.prototype.dispose = function(t, i) {
      this._brushController && this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var i = t.areas;
      if (!t.isEnd || !i.length)
        return;
      var n = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var o = new Ow(mw(this.model), a, {
        include: ["grid"]
      });
      o.matchOutputRanges(i, a, function(u, h, c) {
        if (c.type === "cartesian2d") {
          var f = u.brushType;
          f === "rect" ? (s("x", c, h[0]), s("y", c, h[1])) : s({
            lineX: "x",
            lineY: "y"
          }[f], c, h);
        }
      }), XTe(a, n), this._dispatchZoomAction(n);
      function s(u, h, c) {
        var f = h.getAxis(u), d = f.model, p = l(u, d, a), g = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (c = Ch(0, c.slice(), f.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (n[p.id] = {
          dataZoomId: p.id,
          startValue: c[0],
          endValue: c[1]
        });
      }
      function l(u, h, c) {
        var f;
        return c.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, h.componentIndex);
          p && (f = d);
        }), f;
      }
    }, e.prototype._dispatchZoomAction = function(t) {
      var i = [];
      JC(t, function(n, a) {
        i.push(Se(n));
      }), i.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: i
      });
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: t.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return i;
    }, e;
  }(Ln)
), rye = {
  zoom: function() {
    var r = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: r
    });
  },
  back: function() {
    this._dispatchZoomAction(YTe(this.ecModel));
  }
};
function mw(r) {
  var e = {
    xAxisIndex: r.get("xAxisIndex", !0),
    yAxisIndex: r.get("yAxisIndex", !0),
    xAxisId: r.get("xAxisId", !0),
    yAxisId: r.get("yAxisId", !0)
  };
  return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e;
}
function iye(r, e) {
  r.setIconStatus("back", WTe(e) > 1 ? "emphasis" : "normal");
}
function nye(r, e, t, i, n) {
  var a = t._isZoomActive;
  i && i.type === "takeGlobalCursor" && (a = i.key === "dataZoomSelect" ? i.dataZoomSelectActive : !1), t._isZoomActive = a, r.setIconStatus("zoom", a ? "emphasis" : "normal");
  var o = new Ow(mw(r), e, {
    include: ["grid"]
  }), s = o.makePanelOpts(n, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  t._brushController.setPanels(s).enableBrush(a && s.length ? {
    brushType: "auto",
    brushStyle: r.getModel("brushStyle").getItemStyle()
  } : !1);
}
aoe("dataZoom", function(r) {
  var e = r.getComponent("toolbox", 0), t = ["feature", "dataZoom"];
  if (!e || e.get(t) == null)
    return;
  var i = e.getModel(t), n = [], a = mw(i), o = op(r, a);
  JC(o.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), JC(o.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, h) {
    var c = l.componentIndex, f = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: i.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: eye + u + c
    };
    f[h] = c, n.push(f);
  }
  return n;
});
const aye = tye;
function oye(r) {
  r.registerComponentModel(yTe), r.registerComponentView(_Te), hc("saveAsImage", xTe), hc("magicType", NTe), hc("dataView", FTe), hc("dataZoom", aye), hc("restore", ZTe), Ve(STe);
}
var sye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "tooltip", e.dependencies = ["axisPointer"], e.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(ot)
);
const lye = sye;
function n4(r) {
  var e = r.get("confine");
  return e != null ? !!e : r.get("renderMode") === "richText";
}
function a4(r) {
  if (st.domSupported) {
    for (var e = document.documentElement.style, t = 0, i = r.length; t < i; t++)
      if (r[t] in e)
        return r[t];
  }
}
var o4 = a4(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), uye = a4(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function s4(r, e) {
  if (!r)
    return e;
  e = DY(e, !0);
  var t = r.indexOf(e);
  return r = t === -1 ? e : "-" + r.slice(0, t) + "-" + e, r.toLowerCase();
}
function hye(r, e) {
  var t = r.currentStyle || document.defaultView && document.defaultView.getComputedStyle(r);
  return t ? e ? t[e] : t : null;
}
var cye = s4(uye, "transition"), Ew = s4(o4, "transform"), fye = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (st.transform3dSupported ? "will-change:transform;" : "");
function dye(r) {
  return r = r === "left" ? "right" : r === "right" ? "left" : r === "top" ? "bottom" : "top", r;
}
function pye(r, e, t) {
  if (!ne(t) || t === "inside")
    return "";
  var i = r.get("backgroundColor"), n = r.get("borderWidth");
  e = nh(e);
  var a = dye(t), o = Math.max(Math.round(n) * 1.5, 6), s = "", l = Ew + ":", u;
  Ge(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var h = u * Math.PI / 180, c = o + n, f = c * Math.abs(Math.cos(h)) + c * Math.abs(Math.sin(h)), d = Math.round(((f - Math.SQRT2 * n) / 2 + Math.SQRT2 * n - (f - c) / 2) * 100) / 100;
  s += ";" + a + ":-" + d + "px";
  var p = e + " solid " + n + "px;", g = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + i + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function gye(r, e) {
  var t = "cubic-bezier(0.23,1,0.32,1)", i = " " + r / 2 + "s " + t, n = "opacity" + i + ",visibility" + i;
  return e || (i = " " + r + "s " + t, n += st.transformSupported ? "," + Ew + i : ",left" + i + ",top" + i), cye + ":" + n;
}
function qQ(r, e, t) {
  var i = r.toFixed(0) + "px", n = e.toFixed(0) + "px";
  if (!st.transformSupported)
    return t ? "top:" + n + ";left:" + i + ";" : [["top", n], ["left", i]];
  var a = st.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + i + "," + n + (a ? ",0" : "") + ")";
  return t ? "top:0;left:0;" + Ew + ":" + o + ";" : [["top", 0], ["left", 0], [o4, o]];
}
function vye(r) {
  var e = [], t = r.get("fontSize"), i = r.getTextColor();
  i && e.push("color:" + i), e.push("font:" + r.getFont()), t && e.push("line-height:" + Math.round(t * 3 / 2) + "px");
  var n = r.get("textShadowColor"), a = r.get("textShadowBlur") || 0, o = r.get("textShadowOffsetX") || 0, s = r.get("textShadowOffsetY") || 0;
  return n && a && e.push("text-shadow:" + o + "px " + s + "px " + a + "px " + n), w(["decoration", "align"], function(l) {
    var u = r.get(l);
    u && e.push("text-" + l + ":" + u);
  }), e.join(";");
}
function Oye(r, e, t) {
  var i = [], n = r.get("transitionDuration"), a = r.get("backgroundColor"), o = r.get("shadowBlur"), s = r.get("shadowColor"), l = r.get("shadowOffsetX"), u = r.get("shadowOffsetY"), h = r.getModel("textStyle"), c = vH(r, "html"), f = l + "px " + u + "px " + o + "px " + s;
  return i.push("box-shadow:" + f), e && n && i.push(gye(n, t)), a && i.push("background-color:" + a), w(["width", "color", "radius"], function(d) {
    var p = "border-" + d, g = DY(p), v = r.get(g);
    v != null && i.push(p + ":" + v + (d === "color" ? "" : "px"));
  }), i.push(vye(h)), c != null && i.push("padding:" + Cf(c).join("px ") + "px"), i.join(";") + ";";
}
function jQ(r, e, t, i, n) {
  var a = e && e.painter;
  if (t) {
    var o = a && a.getViewportRoot();
    o && qte(r, o, document.body, i, n);
  } else {
    r[0] = i, r[1] = n;
    var s = a && a.getViewportRootOffset();
    s && (r[0] += s.offsetLeft, r[1] += s.offsetTop);
  }
  r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
}
var mye = (
  /** @class */
  function() {
    function r(e, t, i) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, st.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var a = this._zr = t.getZr(), o = this._appendToBody = i && i.appendToBody;
      jQ(this._styleCoord, a, o, t.getWidth() / 2, t.getHeight() / 2), o ? document.body.appendChild(n) : e.appendChild(n), this._container = e;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = a.handler, h = a.painter.getViewportRoot();
          _n(h, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return r.prototype.update = function(e) {
      var t = this._container, i = hye(t, "position"), n = t.style;
      n.position !== "absolute" && i !== "absolute" && (n.position = "relative");
      var a = e.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "";
    }, r.prototype.show = function(e, t) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var i = this.el, n = i.style, a = this._styleCoord;
      i.innerHTML ? n.cssText = fye + Oye(e, !this._firstShow, this._longHide) + qQ(a[0], a[1], !0) + ("border-color:" + nh(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : n.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, r.prototype.setContent = function(e, t, i, n, a) {
      var o = this.el;
      if (e == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (ne(a) && i.get("trigger") === "item" && !n4(i) && (s = pye(i, n, a)), ne(e))
        o.innerHTML = e + s;
      else if (e) {
        o.innerHTML = "", X(e) || (e = [e]);
        for (var l = 0; l < e.length; l++)
          Up(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el;
      return [e.offsetWidth, e.offsetHeight];
    }, r.prototype.moveTo = function(e, t) {
      var i = this._styleCoord;
      if (jQ(i, this._zr, this._appendToBody, e, t), i[0] != null && i[1] != null) {
        var n = this.el.style, a = qQ(i[0], i[1]);
        w(a, function(o) {
          n[o[0]] = o[1];
        });
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      var e = this, t = this.el.style;
      t.visibility = "hidden", t.opacity = "0", st.transform3dSupported && (t.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return e._longHide = !0;
      }, 500);
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(ae(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this.el.parentNode.removeChild(this.el);
    }, r;
  }()
);
const Eye = mye;
var bye = (
  /** @class */
  function() {
    function r(e) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = e.getZr(), JQ(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return r.prototype.update = function(e) {
      var t = e.get("alwaysShowContent");
      t && this._moveIfResized(), this._alwaysShowContent = t;
    }, r.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, r.prototype.setContent = function(e, t, i, n, a) {
      var o = this;
      be(e) && vt(""), this.el && this._zr.remove(this.el);
      var s = i.getModel("textStyle");
      this.el = new lt({
        style: {
          rich: t.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: n,
          textShadowColor: s.get("textShadowColor"),
          fill: i.get(["textStyle", "color"]),
          padding: vH(i, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: i.get("z")
      }), w(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = i.get(u);
      }), w(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el, t = this.el.getBoundingRect(), i = KQ(e.style);
      return [t.width + i.left + i.right, t.height + i.top + i.bottom];
    }, r.prototype.moveTo = function(e, t) {
      var i = this.el;
      if (i) {
        var n = this._styleCoord;
        JQ(n, this._zr, e, t), e = n[0], t = n[1];
        var a = i.style, o = Ss(a.borderWidth || 0), s = KQ(a);
        i.x = e + o + s.left, i.y = t + o + s.top, i.markRedraw();
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(ae(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, r;
  }()
);
function Ss(r) {
  return Math.max(0, r);
}
function KQ(r) {
  var e = Ss(r.shadowBlur || 0), t = Ss(r.shadowOffsetX || 0), i = Ss(r.shadowOffsetY || 0);
  return {
    left: Ss(e - t),
    right: Ss(e + t),
    top: Ss(e - i),
    bottom: Ss(e + i)
  };
}
function JQ(r, e, t, i) {
  r[0] = t, r[1] = i, r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
}
const Sye = bye;
var Tye = new nt({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), yye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      if (!(st.node || !i.getDom())) {
        var n = t.getComponent("tooltip"), a = this._renderMode = Nie(n.get("renderMode"));
        this._tooltipContent = a === "richText" ? new Sye(i) : new Eye(i.getDom(), i, {
          appendToBody: n.get("appendToBody", !0)
        });
      }
    }, e.prototype.render = function(t, i, n) {
      if (!(st.node || !n.getDom())) {
        this.group.removeAll(), this._tooltipModel = t, this._ecModel = i, this._api = n;
        var a = this._tooltipContent;
        a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? Pf(this, "_updatePosition", 50, "fixRate") : Kp(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var t = this._tooltipModel, i = t.get("triggerOn");
      Xz("itemTooltip", this._api, ae(function(n, a, o) {
        i !== "none" && (i.indexOf(n) >= 0 ? this._tryShow(a, o) : n === "leave" && this._hide(o));
      }, this));
    }, e.prototype._keepShow = function() {
      var t = this._tooltipModel, i = this._ecModel, n = this._api, a = t.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !n.isDisposed() && o.manuallyShowTip(t, i, n, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(t, i, n, a) {
      if (!(a.from === this.uid || st.node || !n.getDom())) {
        var o = eU(a, n);
        this._ticket = "";
        var s = a.dataByCoordSys, l = _ye(a, i, n);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var h = Tye;
          h.x = a.x, h.y = a.y, h.update(), _e(h).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: h
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, i, n, a))
            return;
          var c = Yz(a, i), f = c.point[0], d = c.point[1];
          f != null && d != null && this._tryShow({
            offsetX: f,
            offsetY: d,
            target: c.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else
          a.x != null && a.y != null && (n.dispatchAction({
            type: "updateAxisPointer",
            x: a.x,
            y: a.y
          }), this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            target: n.getZr().findHover(a.x, a.y).target
          }, o));
      }
    }, e.prototype.manuallyHideTip = function(t, i, n, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(eU(a, n));
    }, e.prototype._manuallyAxisShowTip = function(t, i, n, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = i.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = i.getSeriesByIndex(o);
        if (u) {
          var h = u.getData(), c = gd([h.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (c.get("trigger") === "axis")
            return n.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, e.prototype._tryShow = function(t, i) {
      var n = t.target, a = this._tooltipModel;
      if (a) {
        this._lastX = t.offsetX, this._lastY = t.offsetY;
        var o = t.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, t);
        else if (n) {
          this._lastDataByCoordSys = null;
          var s, l;
          Ru(n, function(u) {
            if (_e(u).dataIndex != null)
              return s = u, !0;
            if (_e(u).tooltipConfig != null)
              return l = u, !0;
          }, !0), s ? this._showSeriesItemTooltip(t, s, i) : l ? this._showComponentItemTooltip(t, l, i) : this._hide(i);
        } else
          this._lastDataByCoordSys = null, this._hide(i);
      }
    }, e.prototype._showOrMove = function(t, i) {
      var n = t.get("showDelay");
      i = ae(i, this), clearTimeout(this._showTimout), n > 0 ? this._showTimout = setTimeout(i, n) : i();
    }, e.prototype._showAxisTooltip = function(t, i) {
      var n = this._ecModel, a = this._tooltipModel, o = [i.offsetX, i.offsetY], s = gd([i.tooltipOption], a), l = this._renderMode, u = [], h = _r("section", {
        blocks: [],
        noHeader: !0
      }), c = [], f = new Dy();
      w(t, function(m) {
        w(m.dataByAxis, function(E) {
          var b = n.getComponent(E.axisDim + "Axis", E.axisIndex), T = E.value;
          if (!(!b || T == null)) {
            var S = Bz(T, b.axis, n, E.seriesDataIndices, E.valueLabelOpt), y = _r("section", {
              header: S,
              noHeader: !ha(S),
              sortBlocks: !0,
              blocks: []
            });
            h.blocks.push(y), w(E.seriesDataIndices, function(A) {
              var C = n.getSeriesByIndex(A.seriesIndex), _ = A.dataIndexInside, I = C.getDataParams(_);
              if (!(I.dataIndex < 0)) {
                I.axisDim = E.axisDim, I.axisIndex = E.axisIndex, I.axisType = E.axisType, I.axisId = E.axisId, I.axisValue = bx(b.axis, {
                  value: T
                }), I.axisValueLabel = S, I.marker = f.makeTooltipMarker("item", nh(I.color), l);
                var x = GD(C.formatTooltip(_, !0, null)), P = x.frag;
                if (P) {
                  var N = gd([C], a).get("valueFormatter");
                  y.blocks.push(N ? V({
                    valueFormatter: N
                  }, P) : P);
                }
                x.text && c.push(x.text), u.push(I);
              }
            });
          }
        });
      }), h.blocks.reverse(), c.reverse();
      var d = i.position, p = s.get("order"), g = HD(h, f, l, p, n.get("useUTC"), s.get("textStyle"));
      g && c.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", O = c.join(v);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, O, u, Math.random() + "", o[0], o[1], d, null, f);
      });
    }, e.prototype._showSeriesItemTooltip = function(t, i, n) {
      var a = this._ecModel, o = _e(i), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, h = o.dataIndex, c = o.dataType, f = u.getData(c), d = this._renderMode, p = t.positionDefault, g = gd([f.getItemModel(h), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var O = u.getDataParams(h, c), m = new Dy();
        O.marker = m.makeTooltipMarker("item", nh(O.color), d);
        var E = GD(u.formatTooltip(h, !1, c)), b = g.get("order"), T = g.get("valueFormatter"), S = E.frag, y = S ? HD(T ? V({
          valueFormatter: T
        }, S) : S, m, d, b, a.get("useUTC"), g.get("textStyle")) : E.text, A = "item_" + u.name + "_" + h;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, y, O, A, t.offsetX, t.offsetY, t.position, t.target, m);
        }), n({
          type: "showTip",
          dataIndexInside: h,
          dataIndex: f.getRawIndex(h),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(t, i, n) {
      var a = _e(i), o = a.tooltipConfig, s = o.option || {};
      if (ne(s)) {
        var l = s;
        s = {
          content: l,
          // Fixed formatter
          formatter: l
        };
      }
      var u = [s], h = this._ecModel.getComponent(a.componentMainType, a.componentIndex);
      h && u.push(h), u.push({
        formatter: s.content
      });
      var c = t.positionDefault, f = gd(u, this._tooltipModel, c ? {
        position: c
      } : null), d = f.get("content"), p = Math.random() + "", g = new Dy();
      this._showOrMove(f, function() {
        var v = Se(f.get("formatterParams") || {});
        this._showTooltipContent(f, d, v, p, t.offsetX, t.offsetY, t.position, i, g);
      }), n({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(t, i, n, a, o, s, l, u, h) {
      if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
        var c = this._tooltipContent;
        c.setEnterable(t.get("enterable"));
        var f = t.get("formatter");
        l = l || t.get("position");
        var d = i, p = this._getNearestPoint([o, s], n, t.get("trigger"), t.get("borderColor")), g = p.color;
        if (f)
          if (ne(f)) {
            var v = t.ecModel.get("useUTC"), O = X(n) ? n[0] : n, m = O && O.axisType && O.axisType.indexOf("time") >= 0;
            d = f, m && (d = xS(O.axisValue, d, v)), d = MY(d, n, !0);
          } else if (ve(f)) {
            var E = ae(function(b, T) {
              b === this._ticket && (c.setContent(T, h, t, g, l), this._updatePosition(t, l, o, s, c, n, u));
            }, this);
            this._ticket = a, d = f(n, a, E);
          } else
            d = f;
        c.setContent(d, h, t, g, l), c.show(t, g), this._updatePosition(t, l, o, s, c, n, u);
      }
    }, e.prototype._getNearestPoint = function(t, i, n, a) {
      if (n === "axis" || X(i))
        return {
          color: a || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!X(i))
        return {
          color: a || i.color || i.borderColor
        };
    }, e.prototype._updatePosition = function(t, i, n, a, o, s, l) {
      var u = this._api.getWidth(), h = this._api.getHeight();
      i = i || t.get("position");
      var c = o.getSize(), f = t.get("align"), d = t.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), ve(i) && (i = i([n, a], s, o.el, p, {
        viewSize: [u, h],
        contentSize: c.slice()
      })), X(i))
        n = K(i[0], u), a = K(i[1], h);
      else if (be(i)) {
        var g = i;
        g.width = c[0], g.height = c[1];
        var v = mr(g, {
          width: u,
          height: h
        });
        n = v.x, a = v.y, f = null, d = null;
      } else if (ne(i) && l) {
        var O = Cye(i, p, c, t.get("borderWidth"));
        n = O[0], a = O[1];
      } else {
        var O = Rye(n, a, o, u, h, f ? null : 20, d ? null : 20);
        n = O[0], a = O[1];
      }
      if (f && (n -= tU(f) ? c[0] / 2 : f === "right" ? c[0] : 0), d && (a -= tU(d) ? c[1] / 2 : d === "bottom" ? c[1] : 0), n4(t)) {
        var O = Aye(n, a, o, u, h);
        n = O[0], a = O[1];
      }
      o.moveTo(n, a);
    }, e.prototype._updateContentNotChangedOnAxis = function(t, i) {
      var n = this._lastDataByCoordSys, a = this._cbParamsList, o = !!n && n.length === t.length;
      return o && w(n, function(s, l) {
        var u = s.dataByAxis || [], h = t[l] || {}, c = h.dataByAxis || [];
        o = o && u.length === c.length, o && w(u, function(f, d) {
          var p = c[d] || {}, g = f.seriesDataIndices || [], v = p.seriesDataIndices || [];
          o = o && f.value === p.value && f.axisType === p.axisType && f.axisId === p.axisId && g.length === v.length, o && w(g, function(O, m) {
            var E = v[m];
            o = o && O.seriesIndex === E.seriesIndex && O.dataIndex === E.dataIndex;
          }), a && w(f.seriesDataIndices, function(O) {
            var m = O.seriesIndex, E = i[m], b = a[m];
            E && b && b.data !== E.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = t, this._cbParamsList = i, !!o;
    }, e.prototype._hide = function(t) {
      this._lastDataByCoordSys = null, t({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(t, i) {
      st.node || !i.getDom() || (Kp(this, "_updatePosition"), this._tooltipContent.dispose(), zC("itemTooltip", i));
    }, e.type = "tooltip", e;
  }(Zt)
);
function gd(r, e, t) {
  var i = e.ecModel, n;
  t ? (n = new Dt(t, i, i), n = new Dt(e.option, n, i)) : n = e;
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a];
    o && (o instanceof Dt && (o = o.get("tooltip", !0)), ne(o) && (o = {
      formatter: o
    }), o && (n = new Dt(o, n, i)));
  }
  return n;
}
function eU(r, e) {
  return r.dispatchAction || ae(e.dispatchAction, e);
}
function Rye(r, e, t, i, n, a, o) {
  var s = t.getSize(), l = s[0], u = s[1];
  return a != null && (r + l + a + 2 > i ? r -= l + a : r += a), o != null && (e + u + o > n ? e -= u + o : e += o), [r, e];
}
function Aye(r, e, t, i, n) {
  var a = t.getSize(), o = a[0], s = a[1];
  return r = Math.min(r + o, i) - o, e = Math.min(e + s, n) - s, r = Math.max(r, 0), e = Math.max(e, 0), [r, e];
}
function Cye(r, e, t, i) {
  var n = t[0], a = t[1], o = Math.ceil(Math.SQRT2 * i) + 8, s = 0, l = 0, u = e.width, h = e.height;
  switch (r) {
    case "inside":
      s = e.x + u / 2 - n / 2, l = e.y + h / 2 - a / 2;
      break;
    case "top":
      s = e.x + u / 2 - n / 2, l = e.y - a - o;
      break;
    case "bottom":
      s = e.x + u / 2 - n / 2, l = e.y + h + o;
      break;
    case "left":
      s = e.x - n - o, l = e.y + h / 2 - a / 2;
      break;
    case "right":
      s = e.x + u + o, l = e.y + h / 2 - a / 2;
  }
  return [s, l];
}
function tU(r) {
  return r === "center" || r === "middle";
}
function _ye(r, e, t) {
  var i = LI(r).queryOptionMap, n = i.keys()[0];
  if (!(!n || n === "series")) {
    var a = Ug(e, n, i.get(n), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = t.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var h = _e(u).tooltipConfig;
        if (h && h.name === r.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: n,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
const Iye = yye;
function xye(r) {
  Ve(rv), r.registerComponentModel(lye), r.registerComponentView(Iye), r.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, ar), r.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, ar);
}
var wye = ["rect", "polygon", "keep", "clear"];
function Pye(r, e) {
  var t = At(r ? r.brush : []);
  if (t.length) {
    var i = [];
    w(t, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (i = i.concat(u));
    });
    var n = r && r.toolbox;
    X(n) && (n = n[0]), n || (n = {
      feature: {}
    }, r.toolbox = [n]);
    var a = n.feature || (n.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
    s.push.apply(s, i), Nye(s), e && !s.length && s.push.apply(s, wye);
  }
}
function Nye(r) {
  var e = {};
  w(r, function(t) {
    e[t] = 1;
  }), r.length = 0, w(e, function(t, i) {
    r.push(i);
  });
}
var rU = w;
function iU(r) {
  if (r) {
    for (var e in r)
      if (r.hasOwnProperty(e))
        return !0;
  }
}
function e_(r, e, t) {
  var i = {};
  return rU(e, function(a) {
    var o = i[a] = n();
    rU(r[a], function(s, l) {
      if (Wr.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        t && t(u, a), o[l] = new Wr(u), l === "opacity" && (u = Se(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new Wr(u));
      }
    });
  }), i;
  function n() {
    var a = function() {
    };
    a.prototype.__hidden = a.prototype;
    var o = new a();
    return o;
  }
}
function l4(r, e, t) {
  var i;
  w(t, function(n) {
    e.hasOwnProperty(n) && iU(e[n]) && (i = !0);
  }), i && w(t, function(n) {
    e.hasOwnProperty(n) && iU(e[n]) ? r[n] = Se(e[n]) : delete r[n];
  });
}
function Lye(r, e, t, i, n, a) {
  var o = {};
  w(r, function(c) {
    var f = Wr.prepareVisualTypes(e[c]);
    o[c] = f;
  });
  var s;
  function l(c) {
    return hx(t, s, c);
  }
  function u(c, f) {
    CH(t, s, c, f);
  }
  a == null ? t.each(h) : t.each([a], h);
  function h(c, f) {
    s = a == null ? c : f;
    var d = t.getRawDataItem(s);
    if (!(d && d.visualMap === !1))
      for (var p = i.call(n, c), g = e[p], v = o[p], O = 0, m = v.length; O < m; O++) {
        var E = v[O];
        g[E] && g[E].applyVisual(c, l, u);
      }
  }
}
function Dye(r, e, t, i) {
  var n = {};
  return w(r, function(a) {
    var o = Wr.prepareVisualTypes(e[a]);
    n[a] = o;
  }), {
    progress: function(o, s) {
      var l;
      i != null && (l = s.getDimensionIndex(i));
      function u(T) {
        return hx(s, c, T);
      }
      function h(T, S) {
        CH(s, c, T, S);
      }
      for (var c, f = s.getStore(); (c = o.next()) != null; ) {
        var d = s.getRawDataItem(c);
        if (!(d && d.visualMap === !1))
          for (var p = i != null ? f.get(l, c) : c, g = t(p), v = e[g], O = n[g], m = 0, E = O.length; m < E; m++) {
            var b = O[m];
            v[b] && v[b].applyVisual(p, u, h);
          }
      }
    }
  };
}
function Mye(r) {
  var e = r.brushType, t = {
    point: function(i) {
      return nU[e].point(i, t, r);
    },
    rect: function(i) {
      return nU[e].rect(i, t, r);
    }
  };
  return t;
}
var nU = {
  lineX: aU(0),
  lineY: aU(1),
  rect: {
    point: function(r, e, t) {
      return r && t.boundingRect.contain(r[0], r[1]);
    },
    rect: function(r, e, t) {
      return r && t.boundingRect.intersect(r);
    }
  },
  polygon: {
    point: function(r, e, t) {
      return r && t.boundingRect.contain(r[0], r[1]) && fu(t.range, r[0], r[1]);
    },
    rect: function(r, e, t) {
      var i = t.range;
      if (!r || i.length <= 1)
        return !1;
      var n = r.x, a = r.y, o = r.width, s = r.height, l = i[0];
      if (fu(i, n, a) || fu(i, n + o, a) || fu(i, n, a + s) || fu(i, n + o, a + s) || Ue.create(r).contain(l[0], l[1]) || kd(n, a, n + o, a, i) || kd(n, a, n, a + s, i) || kd(n + o, a, n + o, a + s, i) || kd(n, a + s, n + o, a + s, i))
        return !0;
    }
  }
};
function aU(r) {
  var e = ["x", "y"], t = ["width", "height"];
  return {
    point: function(i, n, a) {
      if (i) {
        var o = a.range, s = i[r];
        return vd(s, o);
      }
    },
    rect: function(i, n, a) {
      if (i) {
        var o = a.range, s = [i[e[r]], i[e[r]] + i[t[r]]];
        return s[1] < s[0] && s.reverse(), vd(s[0], o) || vd(s[1], o) || vd(o[0], s) || vd(o[1], s);
      }
    }
  };
}
function vd(r, e) {
  return e[0] <= r && r <= e[1];
}
var oU = ["inBrush", "outOfBrush"], Z0 = "__ecBrushSelect", t_ = "__ecInBrushSelectEvent";
function u4(r) {
  r.eachComponent({
    mainType: "brush"
  }, function(e) {
    var t = e.brushTargetManager = new Ow(e.option, r);
    t.setInputRanges(e.areas, r);
  });
}
function kye(r, e, t) {
  var i = [], n, a;
  r.eachComponent({
    mainType: "brush"
  }, function(o) {
    t && t.type === "takeGlobalCursor" && o.setBrushOption(t.key === "brush" ? t.brushOption : {
      brushType: !1
    });
  }), u4(r), r.eachComponent({
    mainType: "brush"
  }, function(o, s) {
    var l = {
      brushId: o.id,
      brushIndex: s,
      brushName: o.name,
      areas: Se(o.areas),
      selected: []
    };
    i.push(l);
    var u = o.option, h = u.brushLink, c = [], f = [], d = [], p = !1;
    s || (n = u.throttleType, a = u.throttleDelay);
    var g = Y(o.areas, function(T) {
      var S = Gye[T.brushType], y = me({
        boundingRect: S ? S(T) : void 0
      }, T);
      return y.selectors = Mye(y), y;
    }), v = e_(o.option, oU, function(T) {
      T.mappingMethod = "fixed";
    });
    X(h) && w(h, function(T) {
      c[T] = 1;
    });
    function O(T) {
      return h === "all" || !!c[T];
    }
    function m(T) {
      return !!T.length;
    }
    r.eachSeries(function(T, S) {
      var y = d[S] = [];
      T.subType === "parallel" ? E(T, S) : b(T, S, y);
    });
    function E(T, S) {
      var y = T.coordinateSystem;
      p = p || y.hasAxisBrushed(), O(S) && y.eachActiveState(T.getData(), function(A, C) {
        A === "active" && (f[C] = 1);
      });
    }
    function b(T, S, y) {
      if (!(!T.brushSelector || $ye(o, S)) && (w(g, function(C) {
        o.brushTargetManager.controlSeries(C, T, r) && y.push(C), p = p || m(y);
      }), O(S) && m(y))) {
        var A = T.getData();
        A.each(function(C) {
          sU(T, y, A, C) && (f[C] = 1);
        });
      }
    }
    r.eachSeries(function(T, S) {
      var y = {
        seriesId: T.id,
        seriesIndex: S,
        seriesName: T.name,
        dataIndex: []
      };
      l.selected.push(y);
      var A = d[S], C = T.getData(), _ = O(S) ? function(I) {
        return f[I] ? (y.dataIndex.push(C.getRawIndex(I)), "inBrush") : "outOfBrush";
      } : function(I) {
        return sU(T, A, C, I) ? (y.dataIndex.push(C.getRawIndex(I)), "inBrush") : "outOfBrush";
      };
      (O(S) ? p : m(A)) && Lye(oU, v, C, _);
    });
  }), Qye(e, n, a, i, t);
}
function Qye(r, e, t, i, n) {
  if (n) {
    var a = r.getZr();
    if (!a[t_]) {
      a[Z0] || (a[Z0] = Uye);
      var o = Pf(a, Z0, t, e);
      o(r, i);
    }
  }
}
function Uye(r, e) {
  if (!r.isDisposed()) {
    var t = r.getZr();
    t[t_] = !0, r.dispatchAction({
      type: "brushSelect",
      batch: e
    }), t[t_] = !1;
  }
}
function sU(r, e, t, i) {
  for (var n = 0, a = e.length; n < a; n++) {
    var o = e[n];
    if (r.brushSelector(i, t, o.selectors, o))
      return !0;
  }
}
function $ye(r, e) {
  var t = r.option.seriesIndex;
  return t != null && t !== "all" && (X(t) ? Ge(t, e) < 0 : e !== t);
}
var Gye = {
  rect: function(r) {
    return lU(r.range);
  },
  polygon: function(r) {
    for (var e, t = r.range, i = 0, n = t.length; i < n; i++) {
      e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var a = t[i];
      a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]);
    }
    return e && lU(e);
  }
};
function lU(r) {
  return new Ue(r[0][0], r[1][0], r[0][1] - r[0][0], r[1][1] - r[1][0]);
}
var Bye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      this.ecModel = t, this.api = i, this.model, (this._brushController = new jx(i.getZr())).on("brush", ae(this._onBrush, this)).mount();
    }, e.prototype.render = function(t, i, n, a) {
      this.model = t, this._updateController(t, i, n, a);
    }, e.prototype.updateTransform = function(t, i, n, a) {
      u4(i), this._updateController(t, i, n, a);
    }, e.prototype.updateVisual = function(t, i, n, a) {
      this.updateTransform(t, i, n, a);
    }, e.prototype.updateView = function(t, i, n, a) {
      this._updateController(t, i, n, a);
    }, e.prototype._updateController = function(t, i, n, a) {
      (!a || a.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(n)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var i = this.model.id, n = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
      (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: i,
        areas: Se(n),
        $from: i
      }), t.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: i,
        areas: Se(n),
        $from: i
      });
    }, e.type = "brush", e;
  }(Zt)
);
const Vye = Bye;
var Fye = "#ddd", Xye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.areas = [], t.brushOption = {}, t;
    }
    return e.prototype.optionUpdated = function(t, i) {
      var n = this.option;
      !i && l4(n, t, ["inBrush", "outOfBrush"]);
      var a = n.inBrush = n.inBrush || {};
      n.outOfBrush = n.outOfBrush || {
        color: Fye
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, e.prototype.setAreas = function(t) {
      t && (this.areas = Y(t, function(i) {
        return uU(this.option, i);
      }, this));
    }, e.prototype.setBrushOption = function(t) {
      this.brushOption = uU(this.option, t), this.brushType = this.brushOption.brushType;
    }, e.type = "brush", e.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], e.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, e;
  }(ot)
);
function uU(r, e) {
  return Qe({
    brushType: r.brushType,
    brushMode: r.brushMode,
    transformable: r.transformable,
    brushStyle: new Dt(r.brushStyle).getItemStyle(),
    removeOnClick: r.removeOnClick,
    z: r.z
  }, e, !0);
}
const Yye = Xye;
var Hye = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], Wye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, i, n) {
      var a, o, s;
      i.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = a, this._brushMode = o, w(t.get("type", !0), function(l) {
        t.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
      });
    }, e.prototype.updateView = function(t, i, n) {
      this.render(t, i, n);
    }, e.prototype.getIcons = function() {
      var t = this.model, i = t.get("icon", !0), n = {};
      return w(t.get("type", !0), function(a) {
        i[a] && (n[a] = i[a]);
      }), n;
    }, e.prototype.onclick = function(t, i, n) {
      var a = this._brushType, o = this._brushMode;
      n === "clear" ? (i.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), i.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : i.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: n === "keep" ? a : a === n ? !1 : n,
          brushMode: n === "keep" ? o === "multiple" ? "single" : "multiple" : o
        }
      });
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        type: Hye.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: t.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return i;
    }, e;
  }(Ln)
);
const zye = Wye;
function Zye(r) {
  r.registerComponentView(Vye), r.registerComponentModel(Yye), r.registerPreprocessor(Pye), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, kye), r.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(e, t) {
    t.eachComponent({
      mainType: "brush",
      query: e
    }, function(i) {
      i.setAreas(e.areas);
    });
  }), r.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, ar), r.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, ar), hc("brush", zye);
}
var qye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t;
    }
    return e.type = "title", e.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(ot)
), jye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      if (this.group.removeAll(), !!t.get("show")) {
        var a = this.group, o = t.getModel("textStyle"), s = t.getModel("subtextStyle"), l = t.get("textAlign"), u = ke(t.get("textBaseline"), t.get("textVerticalAlign")), h = new lt({
          style: Lt(o, {
            text: t.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), c = h.getBoundingRect(), f = t.get("subtext"), d = new lt({
          style: Lt(s, {
            text: f,
            fill: s.getTextColor(),
            y: c.height + t.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), p = t.get("link"), g = t.get("sublink"), v = t.get("triggerEvent", !0);
        h.silent = !p && !v, d.silent = !g && !v, p && h.on("click", function() {
          CE(p, "_" + t.get("target"));
        }), g && d.on("click", function() {
          CE(g, "_" + t.get("subtarget"));
        }), _e(h).eventData = _e(d).eventData = v ? {
          componentType: "title",
          componentIndex: t.componentIndex
        } : null, a.add(h), f && a.add(d);
        var O = a.getBoundingRect(), m = t.getBoxLayoutParams();
        m.width = O.width, m.height = O.height;
        var E = mr(m, {
          width: n.getWidth(),
          height: n.getHeight()
        }, t.get("padding"));
        l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? E.x += E.width : l === "center" && (E.x += E.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? E.y += E.height : u === "middle" && (E.y += E.height / 2), u = u || "top"), a.x = E.x, a.y = E.y, a.markRedraw();
        var b = {
          align: l,
          verticalAlign: u
        };
        h.setStyle(b), d.setStyle(b), O = a.getBoundingRect();
        var T = E.margin, S = t.getItemStyle(["color", "opacity"]);
        S.fill = t.get("backgroundColor");
        var y = new nt({
          shape: {
            x: O.x - T[3],
            y: O.y - T[0],
            width: O.width + T[1] + T[3],
            height: O.height + T[0] + T[2],
            r: t.get("borderRadius")
          },
          style: S,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(y);
      }
    }, e.type = "title", e;
  }(Zt)
);
function Kye(r) {
  r.registerComponentModel(qye), r.registerComponentView(jye);
}
var Jye = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = "box", t;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n), this._initData();
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), this._initData();
    }, e.prototype.setCurrentIndex = function(t) {
      t == null && (t = this.option.currentIndex);
      var i = this._data.count();
      this.option.loop ? t = (t % i + i) % i : (t >= i && (t = i - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
    }, e.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, e.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, e.prototype.setPlayState = function(t) {
      this.option.autoPlay = !!t;
    }, e.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, e.prototype._initData = function() {
      var t = this.option, i = t.data || [], n = t.axisType, a = this._names = [], o;
      n === "category" ? (o = [], w(i, function(u, h) {
        var c = gr(bf(u), ""), f;
        be(u) ? (f = Se(u), f.value = h) : f = h, o.push(f), a.push(c);
      })) : o = i;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[n] || "number", l = this._data = new Ai([{
        name: "value",
        type: s
      }], this);
      l.initData(o, a);
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, e.type = "timeline", e.defaultOption = {
      // zlevel: 0,                  // 
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, e;
  }(ot)
);
const hU = Jye;
var h4 = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline.slider", e.defaultOption = yl(hU.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), e;
  }(hU)
);
hr(h4, ax.prototype);
const e0e = h4;
var t0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline", e;
  }(Zt)
);
const r0e = t0e;
var i0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e(t, i, n, a) {
      var o = r.call(this, t, i, n) || this;
      return o.type = a || "value", o;
    }
    return e.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, e.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, e;
  }(Ta)
);
const n0e = i0e;
var q0 = Math.PI, cU = at(), a0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      this.api = i;
    }, e.prototype.render = function(t, i, n) {
      if (this.model = t, this.api = n, this.ecModel = i, this.group.removeAll(), t.get("show", !0)) {
        var a = this._layout(t, n), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, t);
        t.formatTooltip = function(u) {
          var h = l.scale.getLabel({
            value: u
          });
          return _r("nameValue", {
            noName: !0,
            value: h
          });
        }, w(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](a, o, l, t);
        }, this), this._renderAxisLabel(a, s, l, t), this._position(a, t);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, e.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._clearTimer();
    }, e.prototype._layout = function(t, i) {
      var n = t.get(["label", "position"]), a = t.get("orient"), o = s0e(t, i), s;
      n == null || n === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < i.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < i.getWidth() / 2 ? "+" : "-" : ne(n) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][n] : s = n;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, h = {
        horizontal: 0,
        vertical: q0 / 2
      }, c = a === "vertical" ? o.height : o.width, f = t.getModel("controlStyle"), d = f.get("show", !0), p = d ? f.get("itemSize") : 0, g = d ? f.get("itemGap") : 0, v = p + g, O = t.get(["label", "rotate"]) || 0;
      O = O * q0 / 180;
      var m, E, b, T = f.get("position", !0), S = d && f.get("showPlayBtn", !0), y = d && f.get("showPrevBtn", !0), A = d && f.get("showNextBtn", !0), C = 0, _ = c;
      T === "left" || T === "bottom" ? (S && (m = [0, 0], C += v), y && (E = [C, 0], C += v), A && (b = [_ - p, 0], _ -= v)) : (S && (m = [_ - p, 0], _ -= v), y && (E = [0, 0], C += v), A && (b = [_ - p, 0], _ -= v));
      var I = [C, _];
      return t.get("inverse") && I.reverse(), {
        viewRect: o,
        mainLength: c,
        orient: a,
        rotation: h[a],
        labelRotation: O,
        labelPosOpt: s,
        labelAlign: t.get(["label", "align"]) || l[a],
        labelBaseline: t.get(["label", "verticalAlign"]) || t.get(["label", "baseline"]) || u[a],
        // Based on mainGroup.
        playPosition: m,
        prevBtnPosition: E,
        nextBtnPosition: b,
        axisExtent: I,
        controlSize: p,
        controlGap: g
      };
    }, e.prototype._position = function(t, i) {
      var n = this._mainGroup, a = this._labelGroup, o = t.viewRect;
      if (t.orient === "vertical") {
        var s = Zn(), l = o.x, u = o.y + o.height;
        ao(s, s, [-l, -u]), bh(s, s, -q0 / 2), ao(s, s, [l, u]), o = o.clone(), o.applyTransform(s);
      }
      var h = m(o), c = m(n.getBoundingRect()), f = m(a.getBoundingRect()), d = [n.x, n.y], p = [a.x, a.y];
      p[0] = d[0] = h[0][0];
      var g = t.labelPosOpt;
      if (g == null || ne(g)) {
        var v = g === "+" ? 0 : 1;
        E(d, c, h, 1, v), E(p, f, h, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        E(d, c, h, 1, v), p[1] = d[1] + g;
      }
      n.setPosition(d), a.setPosition(p), n.rotation = a.rotation = t.rotation, O(n), O(a);
      function O(b) {
        b.originX = h[0][0] - b.x, b.originY = h[1][0] - b.y;
      }
      function m(b) {
        return [[b.x, b.x + b.width], [b.y, b.y + b.height]];
      }
      function E(b, T, S, y, A) {
        b[y] += S[y][A] - T[y][A];
      }
    }, e.prototype._createAxis = function(t, i) {
      var n = i.getData(), a = i.get("axisType"), o = o0e(i, a);
      o.getTicks = function() {
        return n.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = n.getDataExtent("value");
      o.setExtent(s[0], s[1]), o.calcNiceTicks();
      var l = new n0e("value", o, t.axisExtent, a);
      return l.model = i, l;
    }, e.prototype._createGroup = function(t) {
      var i = this[t] = new ye();
      return this.group.add(i), i;
    }, e.prototype._renderAxisLine = function(t, i, n, a) {
      var o = n.getExtent();
      if (a.get(["lineStyle", "show"])) {
        var s = new Mr({
          shape: {
            x1: o[0],
            y1: 0,
            x2: o[1],
            y2: 0
          },
          style: V({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        i.add(s);
        var l = this._progressLine = new Mr({
          shape: {
            x1: o[0],
            x2: this._currentPointer ? this._currentPointer.x : o[0],
            y1: 0,
            y2: 0
          },
          style: me({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, a.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        i.add(l);
      }
    }, e.prototype._renderAxisTick = function(t, i, n, a) {
      var o = this, s = a.getData(), l = n.scale.getTicks();
      this._tickSymbols = [], w(l, function(u) {
        var h = n.dataToCoord(u.value), c = s.getItemModel(u.value), f = c.getModel("itemStyle"), d = c.getModel(["emphasis", "itemStyle"]), p = c.getModel(["progress", "itemStyle"]), g = {
          x: h,
          y: 0,
          onclick: ae(o._changeTimeline, o, u.value)
        }, v = fU(c, f, i, g);
        v.ensureState("emphasis").style = d.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), Bu(v);
        var O = _e(v);
        c.get("tooltip") ? (O.dataIndex = u.value, O.dataModel = a) : O.dataIndex = O.dataModel = null, o._tickSymbols.push(v);
      });
    }, e.prototype._renderAxisLabel = function(t, i, n, a) {
      var o = this, s = n.getLabelModel();
      if (s.get("show")) {
        var l = a.getData(), u = n.getViewLabels();
        this._tickLabels = [], w(u, function(h) {
          var c = h.tickValue, f = l.getItemModel(c), d = f.getModel("label"), p = f.getModel(["emphasis", "label"]), g = f.getModel(["progress", "label"]), v = n.dataToCoord(h.tickValue), O = new lt({
            x: v,
            y: 0,
            rotation: t.labelRotation - t.rotation,
            onclick: ae(o._changeTimeline, o, c),
            silent: !1,
            style: Lt(d, {
              text: h.formattedLabel,
              align: t.labelAlign,
              verticalAlign: t.labelBaseline
            })
          });
          O.ensureState("emphasis").style = Lt(p), O.ensureState("progress").style = Lt(g), i.add(O), Bu(O), cU(O).dataIndex = c, o._tickLabels.push(O);
        });
      }
    }, e.prototype._renderControl = function(t, i, n, a) {
      var o = t.controlSize, s = t.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), h = a.getPlayState(), c = a.get("inverse", !0);
      f(t.nextBtnPosition, "next", ae(this._changeTimeline, this, c ? "-" : "+")), f(t.prevBtnPosition, "prev", ae(this._changeTimeline, this, c ? "+" : "-")), f(t.playPosition, h ? "stop" : "play", ae(this._handlePlayClick, this, !h), !0);
      function f(d, p, g, v) {
        if (d) {
          var O = Ea(ke(a.get(["controlStyle", p + "BtnSize"]), o), o), m = [0, -O / 2, O, O], E = l0e(a, p + "Icon", m, {
            x: d[0],
            y: d[1],
            originX: o / 2,
            originY: 0,
            rotation: v ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: g
          });
          E.ensureState("emphasis").style = u, i.add(E), Bu(E);
        }
      }
    }, e.prototype._renderCurrentPointer = function(t, i, n, a) {
      var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, h = {
        onCreate: function(c) {
          c.draggable = !0, c.drift = ae(u._handlePointerDrag, u), c.ondragend = ae(u._handlePointerDragend, u), dU(c, u._progressLine, s, n, a, !0);
        },
        onUpdate: function(c) {
          dU(c, u._progressLine, s, n, a);
        }
      };
      this._currentPointer = fU(l, l, this._mainGroup, {}, this._currentPointer, h);
    }, e.prototype._handlePlayClick = function(t) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: t,
        from: this.uid
      });
    }, e.prototype._handlePointerDrag = function(t, i, n) {
      this._clearTimer(), this._pointerChangeTimeline([n.offsetX, n.offsetY]);
    }, e.prototype._handlePointerDragend = function(t) {
      this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
    }, e.prototype._pointerChangeTimeline = function(t, i) {
      var n = this._toAxisCoord(t)[0], a = this._axis, o = $n(a.getExtent().slice());
      n > o[1] && (n = o[1]), n < o[0] && (n = o[0]), this._currentPointer.x = n, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = n, s.dirty());
      var l = this._findNearestTick(n), u = this.model;
      (i || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, e.prototype._doPlayStop = function() {
      var t = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var i = t.model;
        t._changeTimeline(i.getCurrentIndex() + (i.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, e.prototype._toAxisCoord = function(t) {
      var i = this._mainGroup.getLocalTransform();
      return Oa(t, i, !0);
    }, e.prototype._findNearestTick = function(t) {
      var i = this.model.getData(), n = 1 / 0, a, o = this._axis;
      return i.each(["value"], function(s, l) {
        var u = o.dataToCoord(s), h = Math.abs(u - t);
        h < n && (n = h, a = l);
      }), a;
    }, e.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, e.prototype._changeTimeline = function(t) {
      var i = this.model.getCurrentIndex();
      t === "+" ? t = i + 1 : t === "-" && (t = i - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: t,
        from: this.uid
      });
    }, e.prototype._updateTicksStatus = function() {
      var t = this.model.getCurrentIndex(), i = this._tickSymbols, n = this._tickLabels;
      if (i)
        for (var a = 0; a < i.length; a++)
          i && i[a] && i[a].toggleState("progress", a < t);
      if (n)
        for (var a = 0; a < n.length; a++)
          n && n[a] && n[a].toggleState("progress", cU(n[a]).dataIndex <= t);
    }, e.type = "timeline.slider", e;
  }(r0e)
);
function o0e(r, e) {
  if (e = e || r.get("type"), e)
    switch (e) {
      case "category":
        return new vx({
          ordinalMeta: r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new dW({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new ll();
    }
}
function s0e(r, e) {
  return mr(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  }, r.get("padding"));
}
function l0e(r, e, t, i) {
  var n = i.style, a = Vg(r.get(["controlStyle", e]), i || {}, new Ue(t[0], t[1], t[2], t[3]));
  return n && a.setStyle(n), a;
}
function fU(r, e, t, i, n, a) {
  var o = e.get("color");
  if (n)
    n.setColor(o), t.add(n), a && a.onUpdate(n);
  else {
    var s = r.get("symbol");
    n = ur(s, -1, -1, 2, 2, o), n.setStyle("strokeNoScale", !0), t.add(n), a && a.onCreate(n);
  }
  var l = e.getItemStyle(["color"]);
  n.setStyle(l), i = Qe({
    rectHover: !0,
    z2: 100
  }, i, !0);
  var u = Nf(r.get("symbolSize"));
  i.scaleX = u[0] / 2, i.scaleY = u[1] / 2;
  var h = Th(r.get("symbolOffset"), u);
  h && (i.x = (i.x || 0) + h[0], i.y = (i.y || 0) + h[1]);
  var c = r.get("symbolRotate");
  return i.rotation = (c || 0) * Math.PI / 180 || 0, n.attr(i), n.updateTransform(), n;
}
function dU(r, e, t, i, n, a) {
  if (!r.dragging) {
    var o = n.getModel("checkpointStyle"), s = i.dataToCoord(n.getData().get("value", t));
    if (a || !o.get("animation", !0))
      r.attr({
        x: s,
        y: 0
      }), e && e.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: o.get("animationDuration", !0),
        easing: o.get("animationEasing", !0)
      };
      r.stopAnimation(null, !0), r.animateTo({
        x: s,
        y: 0
      }, l), e && e.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
const u0e = a0e;
function h0e(r) {
  r.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(e, t, i) {
    var n = t.getComponent("timeline");
    return n && e.currentIndex != null && (n.setCurrentIndex(e.currentIndex), !n.get("loop", !0) && n.isIndexMax() && n.getPlayState() && (n.setPlayState(!1), i.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: e.from
    }))), t.resetOption("timeline", {
      replaceMerge: n.get("replaceMerge", !0)
    }), me({
      currentIndex: n.option.currentIndex
    }, e);
  }), r.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(e, t) {
    var i = t.getComponent("timeline");
    i && e.playState != null && i.setPlayState(e.playState);
  });
}
function c0e(r) {
  var e = r && r.timeline;
  X(e) || (e = e ? [e] : []), w(e, function(t) {
    t && f0e(t);
  });
}
function f0e(r) {
  var e = r.type, t = {
    number: "value",
    time: "time"
  };
  if (t[e] && (r.axisType = t[e], delete r.type), pU(r), gu(r, "controlPosition")) {
    var i = r.controlStyle || (r.controlStyle = {});
    gu(i, "position") || (i.position = r.controlPosition), i.position === "none" && !gu(i, "show") && (i.show = !1, delete i.position), delete r.controlPosition;
  }
  w(r.data || [], function(n) {
    be(n) && !X(n) && (!gu(n, "value") && gu(n, "name") && (n.value = n.name), pU(n));
  });
}
function pU(r) {
  var e = r.itemStyle || (r.itemStyle = {}), t = e.emphasis || (e.emphasis = {}), i = r.label || r.label || {}, n = i.normal || (i.normal = {}), a = {
    normal: 1,
    emphasis: 1
  };
  w(i, function(o, s) {
    !a[s] && !gu(n, s) && (n[s] = o);
  }), t.label && !gu(i, "emphasis") && (i.emphasis = t.label, delete t.label);
}
function gu(r, e) {
  return r.hasOwnProperty(e);
}
function d0e(r) {
  r.registerComponentModel(e0e), r.registerComponentView(u0e), r.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), h0e(r), r.registerPreprocessor(c0e);
}
function bw(r, e) {
  if (!r)
    return !1;
  for (var t = X(r) ? r : [r], i = 0; i < t.length; i++)
    if (t[i] && t[i][e])
      return !0;
  return !1;
}
function IO(r) {
  eh(r, "label", ["show"]);
}
var xO = at(), c4 = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.createdBySelf = !1, t;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n), this._mergeOption(t, n, !1, !0);
    }, e.prototype.isAnimationEnabled = function() {
      if (st.node)
        return !1;
      var t = this.__hostSeries;
      return this.getShallow("animation") && t && t.isAnimationEnabled();
    }, e.prototype.mergeOption = function(t, i) {
      this._mergeOption(t, i, !1, !1);
    }, e.prototype._mergeOption = function(t, i, n, a) {
      var o = this.mainType;
      n || i.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = xO(s)[o];
        if (!l || !l.data) {
          xO(s)[o] = null;
          return;
        }
        u ? u._mergeOption(l, i, !0) : (a && IO(l), w(l.data, function(h) {
          h instanceof Array ? (IO(h[0]), IO(h[1])) : IO(h);
        }), u = this.createMarkerModelFromSeries(l, this, i), V(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), xO(s)[o] = u;
      }, this);
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return _r("section", {
        header: this.name,
        blocks: [_r("nameValue", {
          name: s,
          value: o,
          noName: !s,
          noValue: o == null
        })]
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.setData = function(t) {
      this._data = t;
    }, e.getMarkerModelFromSeries = function(t, i) {
      return xO(t)[i];
    }, e.type = "marker", e.dependencies = ["series", "grid", "polar", "geo"], e;
  }(ot)
);
hr(c4, ax.prototype);
const cl = c4;
var p0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, i, n) {
      return new e(t, i, n);
    }, e.type = "markPoint", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(cl)
);
const g0e = p0e;
function r_(r) {
  return !(isNaN(parseFloat(r.x)) && isNaN(parseFloat(r.y)));
}
function v0e(r) {
  return !isNaN(parseFloat(r.x)) && !isNaN(parseFloat(r.y));
}
function wO(r, e, t, i, n, a) {
  var o = [], s = sl(
    e,
    i
    /* , otherDataDim */
  ), l = s ? e.getCalculationInfo("stackResultDimension") : i, u = Sw(e, l, r), h = e.indicesOfNearest(l, u)[0];
  o[n] = e.get(t, h), o[a] = e.get(l, h);
  var c = e.get(i, h), f = Ya(e.get(i, h));
  return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, c];
}
var j0 = {
  min: Ie(wO, "min"),
  max: Ie(wO, "max"),
  average: Ie(wO, "average"),
  median: Ie(wO, "median")
};
function cg(r, e) {
  if (e) {
    var t = r.getData(), i = r.coordinateSystem, n = i && i.dimensions;
    if (!v0e(e) && !X(e.coord) && X(n)) {
      var a = f4(e, t, i, r);
      if (e = Se(e), e.type && j0[e.type] && a.baseAxis && a.valueAxis) {
        var o = Ge(n, a.baseAxis.dim), s = Ge(n, a.valueAxis.dim), l = j0[e.type](t, a.baseDataDim, a.valueDataDim, o, s);
        e.coord = l[0], e.value = l[1];
      } else
        e.coord = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis];
    }
    if (e.coord == null || !X(n))
      e.coord = [];
    else
      for (var u = e.coord, h = 0; h < 2; h++)
        j0[u[h]] && (u[h] = Sw(t, t.mapDimension(n[h]), u[h]));
    return e;
  }
}
function f4(r, e, t, i) {
  var n = {};
  return r.valueIndex != null || r.valueDim != null ? (n.valueDataDim = r.valueIndex != null ? e.getDimension(r.valueIndex) : r.valueDim, n.valueAxis = t.getAxis(O0e(i, n.valueDataDim)), n.baseAxis = t.getOtherAxis(n.valueAxis), n.baseDataDim = e.mapDimension(n.baseAxis.dim)) : (n.baseAxis = i.getBaseAxis(), n.valueAxis = t.getOtherAxis(n.baseAxis), n.baseDataDim = e.mapDimension(n.baseAxis.dim), n.valueDataDim = e.mapDimension(n.valueAxis.dim)), n;
}
function O0e(r, e) {
  var t = r.getData().getDimensionInfo(e);
  return t && t.coordDim;
}
function fg(r, e) {
  return r && r.containData && e.coord && !r_(e) ? r.containData(e.coord) : !0;
}
function m0e(r, e, t) {
  return r && r.containZone && e.coord && t.coord && !r_(e) && !r_(t) ? r.containZone(e.coord, t.coord) : !0;
}
function d4(r, e) {
  return r ? function(t, i, n, a) {
    var o = a < 2 ? t.coord && t.coord[a] : t.value;
    return Xs(o, e[a]);
  } : function(t, i, n, a) {
    return Xs(t.value, e[a]);
  };
}
function Sw(r, e, t) {
  if (t === "average") {
    var i = 0, n = 0;
    return r.each(e, function(a, o) {
      isNaN(a) || (i += a, n++);
    }), i / n;
  } else
    return t === "median" ? r.getMedian(e) : r.getDataExtent(e)[t === "max" ? 1 : 0];
}
var K0 = at(), E0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this.markerGroupMap = ce();
    }, e.prototype.render = function(t, i, n) {
      var a = this, o = this.markerGroupMap;
      o.each(function(s) {
        K0(s).keep = !1;
      }), i.eachSeries(function(s) {
        var l = cl.getMarkerModelFromSeries(s, a.type);
        l && a.renderSeries(s, l, i, n);
      }), o.each(function(s) {
        !K0(s).keep && a.group.remove(s.group);
      });
    }, e.prototype.markKeep = function(t) {
      K0(t).keep = !0;
    }, e.prototype.toggleBlurSeries = function(t, i) {
      var n = this;
      w(t, function(a) {
        var o = cl.getMarkerModelFromSeries(a, n.type);
        if (o) {
          var s = o.getData();
          s.eachItemGraphicEl(function(l) {
            l && (i ? VX(l) : $I(l));
          });
        }
      });
    }, e.type = "marker", e;
  }(Zt)
);
const Tw = E0e;
function gU(r, e, t) {
  var i = e.coordinateSystem;
  r.each(function(n) {
    var a = r.getItemModel(n), o, s = K(a.get("x"), t.getWidth()), l = K(a.get("y"), t.getHeight());
    if (!isNaN(s) && !isNaN(l))
      o = [s, l];
    else if (e.getMarkerPosition)
      o = e.getMarkerPosition(r.getValues(r.dimensions, n));
    else if (i) {
      var u = r.get(i.dimensions[0], n), h = r.get(i.dimensions[1], n);
      o = i.dataToPoint([u, h]);
    }
    isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), r.setItemLayout(n, o);
  });
}
var b0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, i, n) {
      i.eachSeries(function(a) {
        var o = cl.getMarkerModelFromSeries(a, "markPoint");
        o && (gU(o.getData(), a, n), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, e.prototype.renderSeries = function(t, i, n, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, new qg()), c = S0e(o, t, i);
      i.setData(c), gU(i.getData(), t, a), c.each(function(f) {
        var d = c.getItemModel(f), p = d.getShallow("symbol"), g = d.getShallow("symbolSize"), v = d.getShallow("symbolRotate"), O = d.getShallow("symbolOffset"), m = d.getShallow("symbolKeepAspect");
        if (ve(p) || ve(g) || ve(v) || ve(O)) {
          var E = i.getRawValue(f), b = i.getDataParams(f);
          ve(p) && (p = p(E, b)), ve(g) && (g = g(E, b)), ve(v) && (v = v(E, b)), ve(O) && (O = O(E, b));
        }
        var T = d.getModel("itemStyle").getItemStyle(), S = Yg(l, "color");
        T.fill || (T.fill = S), c.setItemVisual(f, {
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: O,
          symbolKeepAspect: m,
          style: T
        });
      }), h.updateData(c), this.group.add(h.group), c.eachItemGraphicEl(function(f) {
        f.traverse(function(d) {
          _e(d).dataModel = i;
        });
      }), this.markKeep(h), h.group.silent = i.get("silent") || t.get("silent");
    }, e.type = "markPoint", e;
  }(Tw)
);
function S0e(r, e, t) {
  var i;
  r ? i = Y(r && r.dimensions, function(s) {
    var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {};
    return V(V({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : i = [{
    name: "value",
    type: "float"
  }];
  var n = new Ai(i, t), a = Y(t.get("data"), Ie(cg, e));
  r && (a = yt(a, Ie(fg, r)));
  var o = d4(!!r, i);
  return n.initData(a, null, o), n;
}
const T0e = b0e;
function y0e(r) {
  r.registerComponentModel(g0e), r.registerComponentView(T0e), r.registerPreprocessor(function(e) {
    bw(e.series, "markPoint") && (e.markPoint = e.markPoint || {});
  });
}
var R0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, i, n) {
      return new e(t, i, n);
    }, e.type = "markLine", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, e;
  }(cl)
);
const A0e = R0e;
var PO = at(), C0e = function(r, e, t, i) {
  var n = r.getData(), a;
  if (X(i))
    a = i;
  else {
    var o = i.type;
    if (o === "min" || o === "max" || o === "average" || o === "median" || i.xAxis != null || i.yAxis != null) {
      var s = void 0, l = void 0;
      if (i.yAxis != null || i.xAxis != null)
        s = e.getAxis(i.yAxis != null ? "y" : "x"), l = Dr(i.yAxis, i.xAxis);
      else {
        var u = f4(i, n, e, r);
        s = u.valueAxis;
        var h = JH(n, u.valueDataDim);
        l = Sw(n, h, o);
      }
      var c = s.dim === "x" ? 0 : 1, f = 1 - c, d = Se(i), p = {
        coord: []
      };
      d.type = null, d.coord = [], d.coord[f] = -1 / 0, p.coord[f] = 1 / 0;
      var g = t.get("precision");
      g >= 0 && ut(l) && (l = +l.toFixed(Math.min(g, 20))), d.coord[c] = p.coord[c] = l, a = [d, p, {
        type: o,
        valueIndex: i.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      a = [];
  }
  var v = [cg(r, a[0]), cg(r, a[1]), V({}, a[2])];
  return v[2].type = v[2].type || null, Qe(v[2], v[0]), Qe(v[2], v[1]), v;
};
function JE(r) {
  return !isNaN(r) && !isFinite(r);
}
function vU(r, e, t, i) {
  var n = 1 - r, a = i.dimensions[r];
  return JE(e[n]) && JE(t[n]) && e[r] === t[r] && i.getAxis(a).containData(e[r]);
}
function _0e(r, e) {
  if (r.type === "cartesian2d") {
    var t = e[0].coord, i = e[1].coord;
    if (t && i && (vU(1, t, i, r) || vU(0, t, i, r)))
      return !0;
  }
  return fg(r, e[0]) && fg(r, e[1]);
}
function J0(r, e, t, i, n) {
  var a = i.coordinateSystem, o = r.getItemModel(e), s, l = K(o.get("x"), n.getWidth()), u = K(o.get("y"), n.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (i.getMarkerPosition)
      s = i.getMarkerPosition(r.getValues(r.dimensions, e));
    else {
      var h = a.dimensions, c = r.get(h[0], e), f = r.get(h[1], e);
      s = a.dataToPoint([c, f]);
    }
    if (Rh(a, "cartesian2d")) {
      var d = a.getAxis("x"), p = a.getAxis("y"), h = a.dimensions;
      JE(r.get(h[0], e)) ? s[0] = d.toGlobalCoord(d.getExtent()[t ? 0 : 1]) : JE(r.get(h[1], e)) && (s[1] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  r.setItemLayout(e, s);
}
var I0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, i, n) {
      i.eachSeries(function(a) {
        var o = cl.getMarkerModelFromSeries(a, "markLine");
        if (o) {
          var s = o.getData(), l = PO(o).from, u = PO(o).to;
          l.each(function(h) {
            J0(l, h, !0, a, n), J0(u, h, !1, a, n);
          }), s.each(function(h) {
            s.setItemLayout(h, [l.getItemLayout(h), u.getItemLayout(h)]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, e.prototype.renderSeries = function(t, i, n, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, new Yx());
      this.group.add(h.group);
      var c = x0e(o, t, i), f = c.from, d = c.to, p = c.line;
      PO(i).from = f, PO(i).to = d, i.setData(p);
      var g = i.get("symbol"), v = i.get("symbolSize"), O = i.get("symbolRotate"), m = i.get("symbolOffset");
      X(g) || (g = [g, g]), X(v) || (v = [v, v]), X(O) || (O = [O, O]), X(m) || (m = [m, m]), c.from.each(function(b) {
        E(f, b, !0), E(d, b, !1);
      }), p.each(function(b) {
        var T = p.getItemModel(b).getModel("lineStyle").getLineStyle();
        p.setItemLayout(b, [f.getItemLayout(b), d.getItemLayout(b)]), T.stroke == null && (T.stroke = f.getItemVisual(b, "style").fill), p.setItemVisual(b, {
          fromSymbolKeepAspect: f.getItemVisual(b, "symbolKeepAspect"),
          fromSymbolOffset: f.getItemVisual(b, "symbolOffset"),
          fromSymbolRotate: f.getItemVisual(b, "symbolRotate"),
          fromSymbolSize: f.getItemVisual(b, "symbolSize"),
          fromSymbol: f.getItemVisual(b, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(b, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(b, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(b, "symbolRotate"),
          toSymbolSize: d.getItemVisual(b, "symbolSize"),
          toSymbol: d.getItemVisual(b, "symbol"),
          style: T
        });
      }), h.updateData(p), c.line.eachItemGraphicEl(function(b) {
        _e(b).dataModel = i, b.traverse(function(T) {
          _e(T).dataModel = i;
        });
      });
      function E(b, T, S) {
        var y = b.getItemModel(T);
        J0(b, T, S, t, a);
        var A = y.getModel("itemStyle").getItemStyle();
        A.fill == null && (A.fill = Yg(l, "color")), b.setItemVisual(T, {
          symbolKeepAspect: y.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: ke(y.get("symbolOffset", !0), m[S ? 0 : 1]),
          symbolRotate: ke(y.get("symbolRotate", !0), O[S ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: ke(y.get("symbolSize"), v[S ? 0 : 1]),
          symbol: ke(y.get("symbol", !0), g[S ? 0 : 1]),
          style: A
        });
      }
      this.markKeep(h), h.group.silent = i.get("silent") || t.get("silent");
    }, e.type = "markLine", e;
  }(Tw)
);
function x0e(r, e, t) {
  var i;
  r ? i = Y(r && r.dimensions, function(u) {
    var h = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
    return V(V({}, h), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : i = [{
    name: "value",
    type: "float"
  }];
  var n = new Ai(i, t), a = new Ai(i, t), o = new Ai([], t), s = Y(t.get("data"), Ie(C0e, e, r, t));
  r && (s = yt(s, Ie(_0e, r)));
  var l = d4(!!r, i);
  return n.initData(Y(s, function(u) {
    return u[0];
  }), null, l), a.initData(Y(s, function(u) {
    return u[1];
  }), null, l), o.initData(Y(s, function(u) {
    return u[2];
  })), o.hasItemOption = !0, {
    from: n,
    to: a,
    line: o
  };
}
const w0e = I0e;
function P0e(r) {
  r.registerComponentModel(A0e), r.registerComponentView(w0e), r.registerPreprocessor(function(e) {
    bw(e.series, "markLine") && (e.markLine = e.markLine || {});
  });
}
var N0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, i, n) {
      return new e(t, i, n);
    }, e.type = "markArea", e.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, e;
  }(cl)
);
const L0e = N0e;
var NO = at(), D0e = function(r, e, t, i) {
  var n = i[0], a = i[1];
  if (!(!n || !a)) {
    var o = cg(r, n), s = cg(r, a), l = o.coord, u = s.coord;
    l[0] = Dr(l[0], -1 / 0), l[1] = Dr(l[1], -1 / 0), u[0] = Dr(u[0], 1 / 0), u[1] = Dr(u[1], 1 / 0);
    var h = SI([{}, o, s]);
    return h.coord = [o.coord, s.coord], h.x0 = o.x, h.y0 = o.y, h.x1 = s.x, h.y1 = s.y, h;
  }
};
function eb(r) {
  return !isNaN(r) && !isFinite(r);
}
function OU(r, e, t, i) {
  var n = 1 - r;
  return eb(e[n]) && eb(t[n]);
}
function M0e(r, e) {
  var t = e.coord[0], i = e.coord[1], n = {
    coord: t,
    x: e.x0,
    y: e.y0
  }, a = {
    coord: i,
    x: e.x1,
    y: e.y1
  };
  return Rh(r, "cartesian2d") ? t && i && (OU(1, t, i) || OU(0, t, i)) ? !0 : m0e(r, n, a) : fg(r, n) || fg(r, a);
}
function mU(r, e, t, i, n) {
  var a = i.coordinateSystem, o = r.getItemModel(e), s, l = K(o.get(t[0]), n.getWidth()), u = K(o.get(t[1]), n.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (i.getMarkerPosition) {
      var h = r.getValues(["x0", "y0"], e), c = r.getValues(["x1", "y1"], e), f = a.clampData(h), d = a.clampData(c), p = [];
      t[0] === "x0" ? p[0] = f[0] > d[0] ? c[0] : h[0] : p[0] = f[0] > d[0] ? h[0] : c[0], t[1] === "y0" ? p[1] = f[1] > d[1] ? c[1] : h[1] : p[1] = f[1] > d[1] ? h[1] : c[1], s = i.getMarkerPosition(p, t, !0);
    } else {
      var g = r.get(t[0], e), v = r.get(t[1], e), O = [g, v];
      a.clampData && a.clampData(O, O), s = a.dataToPoint(O, !0);
    }
    if (Rh(a, "cartesian2d")) {
      var m = a.getAxis("x"), E = a.getAxis("y"), g = r.get(t[0], e), v = r.get(t[1], e);
      eb(g) ? s[0] = m.toGlobalCoord(m.getExtent()[t[0] === "x0" ? 0 : 1]) : eb(v) && (s[1] = E.toGlobalCoord(E.getExtent()[t[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var EU = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], k0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, i, n) {
      i.eachSeries(function(a) {
        var o = cl.getMarkerModelFromSeries(a, "markArea");
        if (o) {
          var s = o.getData();
          s.each(function(l) {
            var u = Y(EU, function(c) {
              return mU(s, l, c, a, n);
            });
            s.setItemLayout(l, u);
            var h = s.getItemGraphicEl(l);
            h.setShape("points", u);
          });
        }
      }, this);
    }, e.prototype.renderSeries = function(t, i, n, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, h = u.get(s) || u.set(s, {
        group: new ye()
      });
      this.group.add(h.group), this.markKeep(h);
      var c = Q0e(o, t, i);
      i.setData(c), c.each(function(f) {
        var d = Y(EU, function(A) {
          return mU(c, f, A, t, a);
        }), p = o.getAxis("x").scale, g = o.getAxis("y").scale, v = p.getExtent(), O = g.getExtent(), m = [p.parse(c.get("x0", f)), p.parse(c.get("x1", f))], E = [g.parse(c.get("y0", f)), g.parse(c.get("y1", f))];
        $n(m), $n(E);
        var b = !(v[0] > m[1] || v[1] < m[0] || O[0] > E[1] || O[1] < E[0]), T = !b;
        c.setItemLayout(f, {
          points: d,
          allClipped: T
        });
        var S = c.getItemModel(f).getModel("itemStyle").getItemStyle(), y = Yg(l, "color");
        S.fill || (S.fill = y, ne(S.fill) && (S.fill = dE(S.fill, 0.4))), S.stroke || (S.stroke = y), c.setItemVisual(f, "style", S);
      }), c.diff(NO(h).data).add(function(f) {
        var d = c.getItemLayout(f);
        if (!d.allClipped) {
          var p = new Yi({
            shape: {
              points: d.points
            }
          });
          c.setItemGraphicEl(f, p), h.group.add(p);
        }
      }).update(function(f, d) {
        var p = NO(h).data.getItemGraphicEl(d), g = c.getItemLayout(f);
        g.allClipped ? p && h.group.remove(p) : (p ? ft(p, {
          shape: {
            points: g.points
          }
        }, i, f) : p = new Yi({
          shape: {
            points: g.points
          }
        }), c.setItemGraphicEl(f, p), h.group.add(p));
      }).remove(function(f) {
        var d = NO(h).data.getItemGraphicEl(f);
        h.group.remove(d);
      }).execute(), c.eachItemGraphicEl(function(f, d) {
        var p = c.getItemModel(d), g = c.getItemVisual(d, "style");
        f.useStyle(c.getItemVisual(d, "style")), Zr(f, Cr(p), {
          labelFetcher: i,
          labelDataIndex: d,
          defaultText: c.getName(d) || "",
          inheritColor: ne(g.fill) ? dE(g.fill, 1) : "#000"
        }), zr(f, p), zt(f, null, null, p.get(["emphasis", "disabled"])), _e(f).dataModel = i;
      }), NO(h).data = c, h.group.silent = i.get("silent") || t.get("silent");
    }, e.type = "markArea", e;
  }(Tw)
);
function Q0e(r, e, t) {
  var i, n, a = ["x0", "y0", "x1", "y1"];
  if (r) {
    var o = Y(r && r.dimensions, function(u) {
      var h = e.getData(), c = h.getDimensionInfo(h.mapDimension(u)) || {};
      return V(V({}, c), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    n = Y(a, function(u, h) {
      return {
        name: u,
        type: o[h % 2].type
      };
    }), i = new Ai(n, t);
  } else
    n = [{
      name: "value",
      type: "float"
    }], i = new Ai(n, t);
  var s = Y(t.get("data"), Ie(D0e, e, r, t));
  r && (s = yt(s, Ie(M0e, r)));
  var l = r ? function(u, h, c, f) {
    var d = u.coord[Math.floor(f / 2)][f % 2];
    return Xs(d, n[f]);
  } : function(u, h, c, f) {
    return Xs(u.value, n[f]);
  };
  return i.initData(s, null, l), i.hasItemOption = !0, i;
}
const U0e = k0e;
function $0e(r) {
  r.registerComponentModel(L0e), r.registerComponentView(U0e), r.registerPreprocessor(function(e) {
    bw(e.series, "markArea") && (e.markArea = e.markArea || {});
  });
}
var G0e = function(r, e) {
  if (e === "all")
    return {
      type: "all",
      title: r.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (e === "inverse")
    return {
      type: "inverse",
      title: r.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, B0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, t;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n), t.selected = t.selected || {}, this._updateSelector(t);
    }, e.prototype.mergeOption = function(t, i) {
      r.prototype.mergeOption.call(this, t, i), this._updateSelector(t);
    }, e.prototype._updateSelector = function(t) {
      var i = t.selector, n = this.ecModel;
      i === !0 && (i = t.selector = ["all", "inverse"]), X(i) && w(i, function(a, o) {
        ne(a) && (a = {
          type: a
        }), i[o] = Qe(a, G0e(n, a.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var t = this._data;
      if (t[0] && this.get("selectedMode") === "single") {
        for (var i = !1, n = 0; n < t.length; n++) {
          var a = t[n].get("name");
          if (this.isSelected(a)) {
            this.select(a), i = !0;
            break;
          }
        }
        !i && this.select(t[0].get("name"));
      }
    }, e.prototype._updateData = function(t) {
      var i = [], n = [];
      t.eachRawSeries(function(l) {
        var u = l.name;
        n.push(u);
        var h;
        if (l.legendVisualProvider) {
          var c = l.legendVisualProvider, f = c.getAllNames();
          t.isSeriesFiltered(l) || (n = n.concat(f)), f.length ? i = i.concat(f) : h = !0;
        } else
          h = !0;
        h && NI(l) && i.push(l.name);
      }), this._availableNames = n;
      var a = this.get("data") || i, o = ce(), s = Y(a, function(l) {
        return (ne(l) || ut(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, !0), new Dt(l, this, this.ecModel));
      }, this);
      this._data = yt(s, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(t) {
      var i = this.option.selected, n = this.get("selectedMode");
      if (n === "single") {
        var a = this._data;
        w(a, function(o) {
          i[o.get("name")] = !1;
        });
      }
      i[t] = !0;
    }, e.prototype.unSelect = function(t) {
      this.get("selectedMode") !== "single" && (this.option.selected[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      var i = this.option.selected;
      i.hasOwnProperty(t) || (i[t] = !0), this[i[t] ? "unSelect" : "select"](t);
    }, e.prototype.allSelect = function() {
      var t = this._data, i = this.option.selected;
      w(t, function(n) {
        i[n.get("name", !0)] = !0;
      });
    }, e.prototype.inverseSelect = function() {
      var t = this._data, i = this.option.selected;
      w(t, function(n) {
        var a = n.get("name", !0);
        i.hasOwnProperty(a) || (i[a] = !0), i[a] = !i[a];
      });
    }, e.prototype.isSelected = function(t) {
      var i = this.option.selected;
      return !(i.hasOwnProperty(t) && !i[t]) && Ge(this._availableNames, t) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = ["series"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, e;
  }(ot)
);
const i_ = B0e;
var Kh = Ie, n_ = w, LO = ye, V0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new LO()), this.group.add(this._selectorGroup = new LO()), this._isFirstRender = !0;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(t, i, n) {
      var a = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!t.get("show", !0)) {
        var o = t.get("align"), s = t.get("orient");
        (!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = t.get("selector", !0), u = t.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, i, n, l, s, u);
        var h = t.getBoxLayoutParams(), c = {
          width: n.getWidth(),
          height: n.getHeight()
        }, f = t.get("padding"), d = mr(h, c, f), p = this.layoutInner(t, o, d, a, l, u), g = mr(me({
          width: p.width,
          height: p.height
        }, h), c, f);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = t4(p, t));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(t, i, n, a, o, s, l) {
      var u = this.getContentGroup(), h = ce(), c = i.get("selectedMode"), f = [];
      n.eachRawSeries(function(d) {
        !d.get("legendHoverLink") && f.push(d.id);
      }), n_(i.getData(), function(d, p) {
        var g = d.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var v = new LO();
          v.newline = !0, u.add(v);
          return;
        }
        var O = n.getSeriesByName(g)[0];
        if (!h.get(g))
          if (O) {
            var m = O.getData(), E = m.getVisual("legendLineStyle") || {}, b = m.getVisual("legendIcon"), T = m.getVisual("style"), S = this._createItem(O, g, p, d, i, t, E, T, b, c, a);
            S.on("click", Kh(bU, g, null, a, f)).on("mouseover", Kh(a_, O.name, null, a, f)).on("mouseout", Kh(o_, O.name, null, a, f)), h.set(g, !0);
          } else
            n.eachRawSeries(function(y) {
              if (!h.get(g) && y.legendVisualProvider) {
                var A = y.legendVisualProvider;
                if (!A.containName(g))
                  return;
                var C = A.indexOfName(g), _ = A.getItemVisual(C, "style"), I = A.getItemVisual(C, "legendIcon"), x = pn(_.fill);
                x && x[3] === 0 && (x[3] = 0.2, _ = V(V({}, _), {
                  fill: ko(x, "rgba")
                }));
                var P = this._createItem(y, g, p, d, i, t, {}, _, I, c, a);
                P.on("click", Kh(bU, null, g, a, f)).on("mouseover", Kh(a_, null, g, a, f)).on("mouseout", Kh(o_, null, g, a, f)), h.set(g, !0);
              }
            }, this);
      }, this), o && this._createSelector(o, i, a, s, l);
    }, e.prototype._createSelector = function(t, i, n, a, o) {
      var s = this.getSelectorGroup();
      n_(t, function(u) {
        var h = u.type, c = new lt({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            n.dispatchAction({
              type: h === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        s.add(c);
        var f = i.getModel("selectorLabel"), d = i.getModel(["emphasis", "selectorLabel"]);
        Zr(c, {
          normal: f,
          emphasis: d
        }, {
          defaultText: u.title
        }), Bu(c);
      });
    }, e.prototype._createItem = function(t, i, n, a, o, s, l, u, h, c, f) {
      var d = t.visualDrawType, p = o.get("itemWidth"), g = o.get("itemHeight"), v = o.isSelected(i), O = a.get("symbolRotate"), m = a.get("symbolKeepAspect"), E = a.get("icon");
      h = E || h || "roundRect";
      var b = F0e(h, a, l, u, d, v, f), T = new LO(), S = a.getModel("textStyle");
      if (ve(t.getLegendIcon) && (!E || E === "inherit"))
        T.add(t.getLegendIcon({
          itemWidth: p,
          itemHeight: g,
          icon: h,
          iconRotate: O,
          itemStyle: b.itemStyle,
          lineStyle: b.lineStyle,
          symbolKeepAspect: m
        }));
      else {
        var y = E === "inherit" && t.getData().getVisual("symbol") ? O === "inherit" ? t.getData().getVisual("symbolRotate") : O : 0;
        T.add(X0e({
          itemWidth: p,
          itemHeight: g,
          icon: h,
          iconRotate: y,
          itemStyle: b.itemStyle,
          lineStyle: b.lineStyle,
          symbolKeepAspect: m
        }));
      }
      var A = s === "left" ? p + 5 : -5, C = s, _ = o.get("formatter"), I = i;
      ne(_) && _ ? I = _.replace("{name}", i ?? "") : ve(_) && (I = _(i));
      var x = v ? S.getTextColor() : a.get("inactiveColor");
      T.add(new lt({
        style: Lt(S, {
          text: I,
          x: A,
          y: g / 2,
          fill: x,
          align: C,
          verticalAlign: "middle"
        }, {
          inheritColor: x
        })
      }));
      var P = new nt({
        shape: T.getBoundingRect(),
        invisible: !0
      }), N = a.getModel("tooltip");
      return N.get("show") && yf({
        el: P,
        componentModel: o,
        itemName: i,
        itemTooltipOption: N.option
      }), T.add(P), T.eachChild(function(L) {
        L.silent = !0;
      }), P.silent = !c, this.getContentGroup().add(T), Bu(T), T.__legendDataIndex = n, T;
    }, e.prototype.layoutInner = function(t, i, n, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      Fu(t.get("orient"), l, t.get("itemGap"), n.width, n.height);
      var h = l.getBoundingRect(), c = [-h.x, -h.y];
      if (u.markRedraw(), l.markRedraw(), o) {
        Fu(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          t.get("selectorItemGap", !0)
        );
        var f = u.getBoundingRect(), d = [-f.x, -f.y], p = t.get("selectorButtonGap", !0), g = t.getOrient().index, v = g === 0 ? "width" : "height", O = g === 0 ? "height" : "width", m = g === 0 ? "y" : "x";
        s === "end" ? d[g] += h[v] + p : c[g] += f[v] + p, d[1 - g] += h[O] / 2 - f[O] / 2, u.x = d[0], u.y = d[1], l.x = c[0], l.y = c[1];
        var E = {
          x: 0,
          y: 0
        };
        return E[v] = h[v] + p + f[v], E[O] = Math.max(h[O], f[O]), E[m] = Math.min(0, f[m] + d[1 - g]), E;
      } else
        return l.x = c[0], l.y = c[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, e.type = "legend.plain", e;
  }(Zt)
);
function F0e(r, e, t, i, n, a, o) {
  function s(v, O) {
    v.lineWidth === "auto" && (v.lineWidth = O.lineWidth > 0 ? 2 : 0), n_(v, function(m, E) {
      v[E] === "inherit" && (v[E] = O[E]);
    });
  }
  var l = e.getModel("itemStyle"), u = l.getItemStyle(), h = r.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", c = l.getShallow("decal");
  u.decal = !c || c === "inherit" ? i.decal : Jc(c, o), u.fill === "inherit" && (u.fill = i[n]), u.stroke === "inherit" && (u.stroke = i[h]), u.opacity === "inherit" && (u.opacity = (n === "fill" ? i : t).opacity), s(u, i);
  var f = e.getModel("lineStyle"), d = f.getLineStyle();
  if (s(d, t), u.fill === "auto" && (u.fill = i.fill), u.stroke === "auto" && (u.stroke = i.fill), d.stroke === "auto" && (d.stroke = i.fill), !a) {
    var p = e.get("inactiveBorderWidth"), g = u[h];
    u.lineWidth = p === "auto" ? i.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), d.stroke = f.get("inactiveColor"), d.lineWidth = f.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: d
  };
}
function X0e(r) {
  var e = r.icon || "roundRect", t = ur(e, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill, r.symbolKeepAspect);
  return t.setStyle(r.itemStyle), t.rotation = (r.iconRotate || 0) * Math.PI / 180, t.setOrigin([r.itemWidth / 2, r.itemHeight / 2]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t;
}
function bU(r, e, t, i) {
  o_(r, e, t, i), t.dispatchAction({
    type: "legendToggleSelect",
    name: r ?? e
  }), a_(r, e, t, i);
}
function p4(r) {
  for (var e = r.getZr().storage.getDisplayList(), t, i = 0, n = e.length; i < n && !(t = e[i].states.emphasis); )
    i++;
  return t && t.hoverLayer;
}
function a_(r, e, t, i) {
  p4(t) || t.dispatchAction({
    type: "highlight",
    seriesName: r,
    name: e,
    excludeSeriesId: i
  });
}
function o_(r, e, t, i) {
  p4(t) || t.dispatchAction({
    type: "downplay",
    seriesName: r,
    name: e,
    excludeSeriesId: i
  });
}
const g4 = V0e;
function Y0e(r) {
  var e = r.findComponents({
    mainType: "legend"
  });
  e && e.length && r.filterSeries(function(t) {
    for (var i = 0; i < e.length; i++)
      if (!e[i].isSelected(t.name))
        return !1;
    return !0;
  });
}
function Od(r, e, t) {
  var i = {}, n = r === "toggleSelected", a;
  return t.eachComponent("legend", function(o) {
    n && a != null ? o[a ? "select" : "unSelect"](e.name) : r === "allSelect" || r === "inverseSelect" ? o[r]() : (o[r](e.name), a = o.isSelected(e.name));
    var s = o.getData();
    w(s, function(l) {
      var u = l.get("name");
      if (!(u === `
` || u === "")) {
        var h = o.isSelected(u);
        i.hasOwnProperty(u) ? i[u] = i[u] && h : i[u] = h;
      }
    });
  }), r === "allSelect" || r === "inverseSelect" ? {
    selected: i
  } : {
    name: e.name,
    selected: i
  };
}
function H0e(r) {
  r.registerAction("legendToggleSelect", "legendselectchanged", Ie(Od, "toggleSelected")), r.registerAction("legendAllSelect", "legendselectall", Ie(Od, "allSelect")), r.registerAction("legendInverseSelect", "legendinverseselect", Ie(Od, "inverseSelect")), r.registerAction("legendSelect", "legendselected", Ie(Od, "select")), r.registerAction("legendUnSelect", "legendunselected", Ie(Od, "unSelect"));
}
function v4(r) {
  r.registerComponentModel(i_), r.registerComponentView(g4), r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, Y0e), r.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), H0e(r);
}
var W0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.setScrollDataIndex = function(t) {
      this.option.scrollDataIndex = t;
    }, e.prototype.init = function(t, i, n) {
      var a = _f(t);
      r.prototype.init.call(this, t, i, n), SU(this, t, a);
    }, e.prototype.mergeOption = function(t, i) {
      r.prototype.mergeOption.call(this, t, i), SU(this, this.option, t);
    }, e.type = "legend.scroll", e.defaultOption = yl(i_.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }(i_)
);
function SU(r, e, t) {
  var i = r.getOrient(), n = [1, 1];
  n[i.index] = 0, ol(e, t, {
    type: "box",
    ignoreSize: !!n
  });
}
const z0e = W0e;
var TU = ye, eR = ["width", "height"], tR = ["x", "y"], Z0e = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !0, t._currentIndex = 0, t;
    }
    return e.prototype.init = function() {
      r.prototype.init.call(this), this.group.add(this._containerGroup = new TU()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new TU());
    }, e.prototype.resetInner = function() {
      r.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(t, i, n, a, o, s, l) {
      var u = this;
      r.prototype.renderInner.call(this, t, i, n, a, o, s, l);
      var h = this._controllerGroup, c = i.get("pageIconSize", !0), f = X(c) ? c : [c, c];
      p("pagePrev", 0);
      var d = i.getModel("pageTextStyle");
      h.add(new lt({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), p("pageNext", 1);
      function p(g, v) {
        var O = g + "DataIndex", m = Vg(i.get("pageIcons", !0)[i.getOrient().name][v], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: ae(u._pageGo, u, O, i, a)
        }, {
          x: -f[0] / 2,
          y: -f[1] / 2,
          width: f[0],
          height: f[1]
        });
        m.name = g, h.add(m);
      }
    }, e.prototype.layoutInner = function(t, i, n, a, o, s) {
      var l = this.getSelectorGroup(), u = t.getOrient().index, h = eR[u], c = tR[u], f = eR[1 - u], d = tR[1 - u];
      o && Fu(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        t.get("selectorItemGap", !0)
      );
      var p = t.get("selectorButtonGap", !0), g = l.getBoundingRect(), v = [-g.x, -g.y], O = Se(n);
      o && (O[h] = n[h] - g[h] - p);
      var m = this._layoutContentAndController(t, a, O, u, h, f, d, c);
      if (o) {
        if (s === "end")
          v[u] += m[h] + p;
        else {
          var E = g[h] + p;
          v[u] -= E, m[c] -= E;
        }
        m[h] += g[h] + p, v[1 - u] += m[d] + m[f] / 2 - g[f] / 2, m[f] = Math.max(m[f], g[f]), m[d] = Math.min(m[d], g[d] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return m;
    }, e.prototype._layoutContentAndController = function(t, i, n, a, o, s, l, u) {
      var h = this.getContentGroup(), c = this._containerGroup, f = this._controllerGroup;
      Fu(t.get("orient"), h, t.get("itemGap"), a ? n.width : null, a ? null : n.height), Fu(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        f,
        t.get("pageButtonItemGap", !0)
      );
      var d = h.getBoundingRect(), p = f.getBoundingRect(), g = this._showController = d[o] > n[o], v = [-d.x, -d.y];
      i || (v[a] = h[u]);
      var O = [0, 0], m = [-p.x, -p.y], E = ke(t.get("pageButtonGap", !0), t.get("itemGap", !0));
      if (g) {
        var b = t.get("pageButtonPosition", !0);
        b === "end" ? m[a] += n[o] - p[o] : O[a] += p[o] + E;
      }
      m[1 - a] += d[s] / 2 - p[s] / 2, h.setPosition(v), c.setPosition(O), f.setPosition(m);
      var T = {
        x: 0,
        y: 0
      };
      if (T[o] = g ? n[o] : d[o], T[s] = Math.max(d[s], p[s]), T[l] = Math.min(0, p[l] + m[1 - a]), c.__rectSize = n[o], g) {
        var S = {
          x: 0,
          y: 0
        };
        S[o] = Math.max(n[o] - p[o] - E, 0), S[s] = T[s], c.setClipPath(new nt({
          shape: S
        })), c.__rectSize = S[o];
      } else
        f.eachChild(function(A) {
          A.attr({
            invisible: !0,
            silent: !0
          });
        });
      var y = this._getPageInfo(t);
      return y.pageIndex != null && ft(
        h,
        {
          x: y.contentPosition[0],
          y: y.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? t : null
      ), this._updatePageInfoView(t, y), T;
    }, e.prototype._pageGo = function(t, i, n) {
      var a = this._getPageInfo(i)[t];
      a != null && n.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: i.id
      });
    }, e.prototype._updatePageInfoView = function(t, i) {
      var n = this._controllerGroup;
      w(["pagePrev", "pageNext"], function(h) {
        var c = h + "DataIndex", f = i[c] != null, d = n.childOfName(h);
        d && (d.setStyle("fill", f ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), d.cursor = f ? "pointer" : "default");
      });
      var a = n.childOfName("pageText"), o = t.get("pageFormatter"), s = i.pageIndex, l = s != null ? s + 1 : 0, u = i.pageCount;
      a && o && a.setStyle("text", ne(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(t) {
      var i = t.get("scrollDataIndex", !0), n = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = eR[o], l = tR[o], u = this._findTargetItemIndex(i), h = n.children(), c = h[u], f = h.length, d = f ? 1 : 0, p = {
        contentPosition: [n.x, n.y],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!c)
        return p;
      var g = b(c);
      p.contentPosition[o] = -g.s;
      for (var v = u + 1, O = g, m = g, E = null; v <= f; ++v)
        E = b(h[v]), // Half of the last item is out of the window.
        (!E && m.e > O.s + a || // If the current item does not intersect with the window, the new page
        // can be started at the current item or the last item.
        E && !T(E, O.s)) && (m.i > O.i ? O = m : O = E, O && (p.pageNextDataIndex == null && (p.pageNextDataIndex = O.i), ++p.pageCount)), m = E;
      for (var v = u - 1, O = g, m = g, E = null; v >= -1; --v)
        E = b(h[v]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!E || !T(m, E.s)) && // e.g., when page size is smaller than item size.
        O.i < m.i && (m = O, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = O.i), ++p.pageCount, ++p.pageIndex), O = E;
      return p;
      function b(S) {
        if (S) {
          var y = S.getBoundingRect(), A = y[l] + S[l];
          return {
            s: A,
            e: A + y[s],
            i: S.__legendDataIndex
          };
        }
      }
      function T(S, y) {
        return S.e >= y && S.s <= y + a;
      }
    }, e.prototype._findTargetItemIndex = function(t) {
      if (!this._showController)
        return 0;
      var i, n = this.getContentGroup(), a;
      return n.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === t && (i = s);
      }), i ?? a;
    }, e.type = "legend.scroll", e;
  }(g4)
);
const q0e = Z0e;
function j0e(r) {
  r.registerAction("legendScroll", "legendscroll", function(e, t) {
    var i = e.scrollDataIndex;
    i != null && t.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: e
    }, function(n) {
      n.setScrollDataIndex(i);
    });
  });
}
function K0e(r) {
  Ve(v4), r.registerComponentModel(z0e), r.registerComponentView(q0e), j0e(r);
}
function J0e(r) {
  Ve(v4), Ve(K0e);
}
var eRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.inside", e.defaultOption = yl(hg.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), e;
  }(hg)
);
const tRe = eRe;
var yw = at();
function rRe(r, e, t) {
  yw(r).coordSysRecordMap.each(function(i) {
    var n = i.dataZoomInfoMap.get(e.uid);
    n && (n.getRange = t);
  });
}
function iRe(r, e) {
  for (var t = yw(r).coordSysRecordMap, i = t.keys(), n = 0; n < i.length; n++) {
    var a = i[n], o = t.get(a), s = o.dataZoomInfoMap;
    if (s) {
      var l = e.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || O4(t, o));
    }
  }
}
function O4(r, e) {
  if (e) {
    r.removeKey(e.model.uid);
    var t = e.controller;
    t && t.dispose();
  }
}
function nRe(r, e) {
  var t = {
    model: e,
    containsPoint: Ie(oRe, e),
    dispatchAction: Ie(aRe, r),
    dataZoomInfoMap: null,
    controller: null
  }, i = t.controller = new ev(r.getZr());
  return w(["pan", "zoom", "scrollMove"], function(n) {
    i.on(n, function(a) {
      var o = [];
      t.dataZoomInfoMap.each(function(s) {
        if (a.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[n], u = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, a);
          !s.model.get("disabled", !0) && u && o.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), o.length && t.dispatchAction(o);
    });
  }), t;
}
function aRe(r, e) {
  r.isDisposed() || r.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: e
  });
}
function oRe(r, e, t, i) {
  return r.coordinateSystem.containPoint([t, i]);
}
function sRe(r) {
  var e, t = "type_", i = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, n = !0;
  return r.each(function(a) {
    var o = a.model, s = o.get("disabled", !0) ? !1 : o.get("zoomLock", !0) ? "move" : !0;
    i[t + s] > i[t + e] && (e = s), n = n && o.get("preventDefaultMouseMove", !0);
  }), {
    controlType: e,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!n
    }
  };
}
function lRe(r) {
  r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function(e, t) {
    var i = yw(t), n = i.coordSysRecordMap || (i.coordSysRecordMap = ce());
    n.each(function(a) {
      a.dataZoomInfoMap = null;
    }), e.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(a) {
      var o = Kz(a);
      w(o.infoList, function(s) {
        var l = s.model.uid, u = n.get(l) || n.set(l, nRe(t, s.model)), h = u.dataZoomInfoMap || (u.dataZoomInfoMap = ce());
        h.set(a.uid, {
          dzReferCoordSysInfo: s,
          model: a,
          getRange: null
        });
      });
    }), n.each(function(a) {
      var o = a.controller, s, l = a.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        O4(n, a);
        return;
      }
      var h = sRe(l);
      o.enable(h.controlType, h.opt), o.setPointerChecker(a.containsPoint), Pf(a, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var uRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataZoom.inside", t;
    }
    return e.prototype.render = function(t, i, n) {
      if (r.prototype.render.apply(this, arguments), t.noTarget()) {
        this._clear();
        return;
      }
      this.range = t.getPercentRange(), rRe(n, t, {
        pan: ae(rR.pan, this),
        zoom: ae(rR.zoom, this),
        scrollMove: ae(rR.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      iRe(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(pw)
), rR = {
  zoom: function(r, e, t, i) {
    var n = this.range, a = n.slice(), o = r.axisModels[0];
    if (o) {
      var s = iR[e](null, [i.originX, i.originY], o, t, r), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / i.scale, 0);
      a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
      var h = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (Ch(0, a, [0, 100], 0, h.minSpan, h.maxSpan), this.range = a, n[0] !== a[0] || n[1] !== a[1])
        return a;
    }
  },
  pan: yU(function(r, e, t, i, n, a) {
    var o = iR[i]([a.oldX, a.oldY], [a.newX, a.newY], e, n, t);
    return o.signal * (r[1] - r[0]) * o.pixel / o.pixelLength;
  }),
  scrollMove: yU(function(r, e, t, i, n, a) {
    var o = iR[i]([0, 0], [a.scrollDelta, a.scrollDelta], e, n, t);
    return o.signal * (r[1] - r[0]) * a.scrollDelta;
  })
};
function yU(r) {
  return function(e, t, i, n) {
    var a = this.range, o = a.slice(), s = e.axisModels[0];
    if (s) {
      var l = r(o, s, e, t, i, n);
      if (Ch(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1])
        return o;
    }
  };
}
var iR = {
  grid: function(r, e, t, i, n) {
    var a = t.axis, o = {}, s = n.model.coordinateSystem.getRect();
    return r = r || [0, 0], a.dim === "x" ? (o.pixel = e[0] - r[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
  },
  polar: function(r, e, t, i, n) {
    var a = t.axis, o = {}, s = n.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return r = r ? s.pointToCoord(r) : [0, 0], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (o.pixel = e[0] - r[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
  },
  singleAxis: function(r, e, t, i, n) {
    var a = t.axis, o = n.model.coordinateSystem.getRect(), s = {};
    return r = r || [0, 0], a.orient === "horizontal" ? (s.pixel = e[0] - r[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - r[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
  }
};
const hRe = uRe;
function m4(r) {
  gw(r), r.registerComponentModel(tRe), r.registerComponentView(hRe), lRe(r);
}
var cRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = yl(hg.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(hg)
);
const fRe = cRe;
var md = nt, RU = 7, dRe = 1, nR = 30, pRe = 7, Ed = "horizontal", AU = "vertical", gRe = 5, vRe = ["line", "bar", "candlestick", "scatter"], ORe = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, mRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._displayables = {}, t;
    }
    return e.prototype.init = function(t, i) {
      this.api = i, this._onBrush = ae(this._onBrush, this), this._onBrushEnd = ae(this._onBrushEnd, this);
    }, e.prototype.render = function(t, i, n, a) {
      if (r.prototype.render.apply(this, arguments), Pf(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (t.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      Kp(this, "_dispatchZoomAction");
      var t = this.api.getZr();
      t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var t = this.group;
      t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var i = this._displayables.sliderGroup = new ye();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(i), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var t = this.dataZoomModel, i = this.api, n = t.get("brushSelect"), a = n ? pRe : 0, o = this._findCoordRect(), s = {
        width: i.getWidth(),
        height: i.getHeight()
      }, l = this._orient === Ed ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: s.width - o.x - o.width,
        top: s.height - nR - RU - a,
        width: o.width,
        height: nR
      } : {
        right: RU,
        top: o.y,
        width: nR,
        height: o.height
      }, u = _f(t.option);
      w(["right", "top", "width", "height"], function(c) {
        u[c] === "ph" && (u[c] = l[c]);
      });
      var h = mr(u, s);
      this._location = {
        x: h.x,
        y: h.y
      }, this._size = [h.width, h.height], this._orient === AU && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var t = this.group, i = this._location, n = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(n === Ed && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : n === Ed && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : n === AU && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = t.getBoundingRect([s]);
      t.x = i.x - u.x, t.y = i.y - u.y, t.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, e.prototype._renderBackground = function() {
      var t = this.dataZoomModel, i = this._size, n = this._displayables.sliderGroup, a = t.get("brushSelect");
      n.add(new md({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: i[0],
          height: i[1]
        },
        style: {
          fill: t.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new md({
        shape: {
          x: 0,
          y: 0,
          width: i[0],
          height: i[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: ae(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), n.add(o);
    }, e.prototype._renderDataShadow = function() {
      var t = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !t)
        return;
      var i = this._size, n = this._shadowSize || [], a = t.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : t.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, h = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || i[0] !== n[0] || i[1] !== n[1]) {
        var c = o.getDataExtent(l), f = (c[1] - c[0]) * 0.3;
        c = [c[0] - f, c[1] + f];
        var d = [0, i[1]], p = [0, i[0]], g = [[i[0], 0], [0, 0]], v = [], O = p[1] / (o.count() - 1), m = 0, E = Math.round(o.count() / i[0]), b;
        o.each([l], function(C, _) {
          if (E > 0 && _ % E) {
            m += O;
            return;
          }
          var I = C == null || isNaN(C) || C === "", x = I ? 0 : Et(C, c, d, !0);
          I && !b && _ ? (g.push([g[g.length - 1][0], 0]), v.push([v[v.length - 1][0], 0])) : !I && b && (g.push([m, 0]), v.push([m, 0])), g.push([m, x]), v.push([m, x]), m += O, b = I;
        }), u = this._shadowPolygonPts = g, h = this._shadowPolylinePts = v;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [i[0], i[1]];
      var T = this.dataZoomModel;
      function S(C) {
        var _ = T.getModel(C ? "selectedDataBackground" : "dataBackground"), I = new ye(), x = new Yi({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: _.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), P = new Wi({
          shape: {
            points: h
          },
          segmentIgnoreThreshold: 1,
          style: _.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return I.add(x), I.add(P), I;
      }
      for (var y = 0; y < 3; y++) {
        var A = S(y === 1);
        this._displayables.sliderGroup.add(A), this._displayables.dataShadowSegs.push(A);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var t = this.dataZoomModel, i = t.get("showDataShadow");
      if (i !== !1) {
        var n, a = this.ecModel;
        return t.eachTargetAxis(function(o, s) {
          var l = t.getAxisProxy(o, s).getTargetSeriesModels();
          w(l, function(u) {
            if (!n && !(i !== !0 && Ge(vRe, u.get("type")) < 0)) {
              var h = a.getComponent(Qs(o), s).axis, c = ERe(o), f, d = u.coordinateSystem;
              c != null && d.getOtherAxis && (f = d.getOtherAxis(h).inverse), c = u.getData().mapDimension(c), n = {
                thisAxis: h,
                series: u,
                thisDim: o,
                otherDim: c,
                otherAxisInverse: f
              };
            }
          }, this);
        }, this), n;
      }
    }, e.prototype._renderHandle = function() {
      var t = this.group, i = this._displayables, n = i.handles = [null, null], a = i.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, h = l.get("borderRadius") || 0, c = l.get("brushSelect"), f = i.filler = new md({
        silent: c,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(f), o.add(new md({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: h
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: dRe,
          fill: "rgba(0,0,0,0)"
        }
      })), w([0, 1], function(E) {
        var b = l.get("handleIcon");
        !xE[b] && b.indexOf("path://") < 0 && b.indexOf("image://") < 0 && (b = "path://" + b);
        var T = ur(b, -1, 0, 2, 2, null, !0);
        T.attr({
          cursor: CU(this._orient),
          draggable: !0,
          drift: ae(this._onDragMove, this, E),
          ondragend: ae(this._onDragEnd, this),
          onmouseover: ae(this._showDataInfo, this, !0),
          onmouseout: ae(this._showDataInfo, this, !1),
          z2: 5
        });
        var S = T.getBoundingRect(), y = l.get("handleSize");
        this._handleHeight = K(y, this._size[1]), this._handleWidth = S.width / S.height * this._handleHeight, T.setStyle(l.getModel("handleStyle").getItemStyle()), T.style.strokeNoScale = !0, T.rectHover = !0, T.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), Bu(T);
        var A = l.get("handleColor");
        A != null && (T.style.fill = A), o.add(n[E] = T);
        var C = l.getModel("textStyle");
        t.add(a[E] = new lt({
          silent: !0,
          invisible: !0,
          style: Lt(C, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: C.getTextColor(),
            font: C.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = f;
      if (c) {
        var p = K(l.get("moveHandleSize"), s[1]), g = i.moveHandle = new nt({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, O = i.moveHandleIcon = ur(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, "#fff", !0);
        O.silent = !0, O.y = s[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var m = Math.min(s[1] / 2, Math.max(p, 10));
        d = i.moveZone = new nt({
          invisible: !0,
          shape: {
            y: s[1] - m,
            height: p + m
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), o.add(g), o.add(O), o.add(d);
      }
      d.attr({
        draggable: !0,
        cursor: CU(this._orient),
        drift: ae(this._onDragMove, this, "all"),
        ondragstart: ae(this._showDataInfo, this, !0),
        ondragend: ae(this._onDragEnd, this),
        onmouseover: ae(this._showDataInfo, this, !0),
        onmouseout: ae(this._showDataInfo, this, !1)
      });
    }, e.prototype._resetInterval = function() {
      var t = this._range = this.dataZoomModel.getPercentRange(), i = this._getViewExtent();
      this._handleEnds = [Et(t[0], [0, 100], i, !0), Et(t[1], [0, 100], i, !0)];
    }, e.prototype._updateInterval = function(t, i) {
      var n = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = n.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      Ch(i, a, o, n.get("zoomLock") ? "all" : t, s.minSpan != null ? Et(s.minSpan, l, o, !0) : null, s.maxSpan != null ? Et(s.maxSpan, l, o, !0) : null);
      var u = this._range, h = this._range = $n([Et(a[0], o, l, !0), Et(a[1], o, l, !0)]);
      return !u || u[0] !== h[0] || u[1] !== h[1];
    }, e.prototype._updateView = function(t) {
      var i = this._displayables, n = this._handleEnds, a = $n(n.slice()), o = this._size;
      w([0, 1], function(d) {
        var p = i.handles[d], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: n[d] + (d ? -1 : 1),
          y: o[1] / 2 - g / 2
        });
      }, this), i.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      i.moveHandle && (i.moveHandle.setShape(s), i.moveZone.setShape(s), i.moveZone.getBoundingRect(), i.moveHandleIcon && i.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = i.dataShadowSegs, u = [0, a[0], a[1], o[0]], h = 0; h < l.length; h++) {
        var c = l[h], f = c.getClipPath();
        f || (f = new nt(), c.setClipPath(f)), f.setShape({
          x: u[h],
          y: 0,
          width: u[h + 1] - u[h],
          height: o[1]
        });
      }
      this._updateDataInfo(t);
    }, e.prototype._updateDataInfo = function(t) {
      var i = this.dataZoomModel, n = this._displayables, a = n.handleLabels, o = this._orient, s = ["", ""];
      if (i.get("showDetail")) {
        var l = i.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, h = this._range, c = t ? l.calculateDataWindow({
            start: h[0],
            end: h[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(c[0], u), this._formatLabel(c[1], u)];
        }
      }
      var f = $n(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var g = Vu(n.handles[p].parent, this.group), v = _S(p === 0 ? "right" : "left", g), O = this._handleWidth / 2 + gRe, m = Oa([f[p] + (p === 0 ? -O : O), this._size[1] / 2], g);
        a[p].setStyle({
          x: m[0],
          y: m[1],
          verticalAlign: o === Ed ? "middle" : v,
          align: o === Ed ? v : "center",
          text: s[p]
        });
      }
    }, e.prototype._formatLabel = function(t, i) {
      var n = this.dataZoomModel, a = n.get("labelFormatter"), o = n.get("labelPrecision");
      (o == null || o === "auto") && (o = i.getPixelPrecision());
      var s = t == null || isNaN(t) ? "" : i.type === "category" || i.type === "time" ? i.scale.getLabel({
        value: Math.round(t)
      }) : t.toFixed(Math.min(o, 20));
      return ve(a) ? a(t, s) : ne(a) ? a.replace("{value}", s) : s;
    }, e.prototype._showDataInfo = function(t) {
      t = this._dragging || t;
      var i = this._displayables, n = i.handleLabels;
      n[0].attr("invisible", !t), n[1].attr("invisible", !t), i.moveHandle && this.api[t ? "enterEmphasis" : "leaveEmphasis"](i.moveHandle, 1);
    }, e.prototype._onDragMove = function(t, i, n, a) {
      this._dragging = !0, Vo(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = Oa([i, n], o, !0), l = this._updateInterval(t, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, e.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var t = this.dataZoomModel.get("realtime");
      !t && this._dispatchZoomAction(!1);
    }, e.prototype._onClickPanel = function(t) {
      var i = this._size, n = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
      if (!(n[0] < 0 || n[0] > i[0] || n[1] < 0 || n[1] > i[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", n[0] - o);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, e.prototype._onBrushStart = function(t) {
      var i = t.offsetX, n = t.offsetY;
      this._brushStart = new Le(i, n), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(t) {
      if (this._brushing) {
        var i = this._displayables.brushRect;
        if (this._brushing = !1, !!i) {
          i.attr("ignore", !0);
          var n = i.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(n.width) < 5)) {
            var o = this._getViewExtent(), s = [0, 100];
            this._range = $n([Et(n.x, o, s, !0), Et(n.x + n.width, o, s, !0)]), this._handleEnds = [n.x, n.x + n.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, e.prototype._onBrush = function(t) {
      this._brushing && (Vo(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
    }, e.prototype._updateBrushRect = function(t, i) {
      var n = this._displayables, a = this.dataZoomModel, o = n.brushRect;
      o || (o = n.brushRect = new md({
        silent: !0,
        style: a.getModel("brushStyle").getItemStyle()
      }), n.sliderGroup.add(o)), o.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(t, i), h = l.transformCoordToLocal(s.x, s.y), c = this._size;
      u[0] = Math.max(Math.min(c[0], u[0]), 0), o.setShape({
        x: h[0],
        y: 0,
        width: u[0] - h[0],
        height: c[1]
      });
    }, e.prototype._dispatchZoomAction = function(t) {
      var i = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: t ? ORe : null,
        start: i[0],
        end: i[1]
      });
    }, e.prototype._findCoordRect = function() {
      var t, i = Kz(this.dataZoomModel).infoList;
      if (!t && i.length) {
        var n = i[0].model.coordinateSystem;
        t = n.getRect && n.getRect();
      }
      if (!t) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        t = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return t;
    }, e.type = "dataZoom.slider", e;
  }(pw)
);
function ERe(r) {
  var e = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return e[r];
}
function CU(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
const bRe = mRe;
function E4(r) {
  r.registerComponentModel(fRe), r.registerComponentView(bRe), gw(r);
}
function SRe(r) {
  Ve(m4), Ve(E4);
}
var TRe = {
  /**
   * @public
   */
  get: function(r, e, t) {
    var i = Se((yRe[r] || {})[e]);
    return t && X(i) ? i[i.length - 1] : i;
  }
}, yRe = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
const b4 = TRe;
var _U = Wr.mapVisual, RRe = Wr.eachVisual, ARe = X, IU = w, CRe = $n, _Re = Et, IRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.stateList = ["inRange", "outOfRange"], t.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t.dataBound = [-1 / 0, 1 / 0], t.targetVisuals = {}, t.controllerVisuals = {}, t;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n);
    }, e.prototype.optionUpdated = function(t, i) {
      var n = this.option;
      !i && l4(n, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(t) {
      var i = this.stateList;
      t = ae(t, this), this.controllerVisuals = e_(this.option.controller, i, t), this.targetVisuals = e_(this.option.target, i, t);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var t = this.option.seriesIndex, i = [];
      return t == null || t === "all" ? this.ecModel.eachSeries(function(n, a) {
        i.push(a);
      }) : i = At(t), i;
    }, e.prototype.eachTargetSeries = function(t, i) {
      w(this.getTargetSeriesIndices(), function(n) {
        var a = this.ecModel.getSeriesByIndex(n);
        a && t.call(i, a);
      }, this);
    }, e.prototype.isTargetSeries = function(t) {
      var i = !1;
      return this.eachTargetSeries(function(n) {
        n === t && (i = !0);
      }), i;
    }, e.prototype.formatValueText = function(t, i, n) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      n = n || ["<", ">"], X(t) && (t = t.slice(), u = !0);
      var h = i ? t : u ? [c(t[0]), c(t[1])] : c(t);
      if (ne(l))
        return l.replace("{value}", u ? h[0] : h).replace("{value2}", u ? h[1] : h);
      if (ve(l))
        return u ? l(t[0], t[1]) : l(t);
      if (u)
        return t[0] === s[0] ? n[0] + " " + h[1] : t[1] === s[1] ? n[1] + " " + h[0] : h[0] + " - " + h[1];
      return h;
      function c(f) {
        return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20));
      }
    }, e.prototype.resetExtent = function() {
      var t = this.option, i = CRe([t.min, t.max]);
      this._dataExtent = i;
    }, e.prototype.getDataDimensionIndex = function(t) {
      var i = this.option.dimension;
      if (i != null)
        return t.getDimensionIndex(i);
      for (var n = t.dimensions, a = n.length - 1; a >= 0; a--) {
        var o = n[a], s = t.getDimensionInfo(o);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var t = this.ecModel, i = this.option, n = {
        inRange: i.inRange,
        outOfRange: i.outOfRange
      }, a = i.target || (i.target = {}), o = i.controller || (i.controller = {});
      Qe(a, n), Qe(o, n);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), h.call(this, o);
      function l(c) {
        ARe(i.color) && !c.inRange && (c.inRange = {
          color: i.color.slice().reverse()
        }), c.inRange = c.inRange || {
          color: t.get("gradientColor")
        };
      }
      function u(c, f, d) {
        var p = c[f], g = c[d];
        p && !g && (g = c[d] = {}, IU(p, function(v, O) {
          if (Wr.isValidType(O)) {
            var m = b4.get(O, "inactive", s);
            m != null && (g[O] = m, O === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function h(c) {
        var f = (c.inRange || {}).symbol || (c.outOfRange || {}).symbol, d = (c.inRange || {}).symbolSize || (c.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        IU(this.stateList, function(O) {
          var m = this.itemSize, E = c[O];
          E || (E = c[O] = {
            color: s ? p : [p]
          }), E.symbol == null && (E.symbol = f && Se(f) || (s ? v : [v])), E.symbolSize == null && (E.symbolSize = d && Se(d) || (s ? m[0] : [m[0], m[0]])), E.symbol = _U(E.symbol, function(S) {
            return S === "none" ? v : S;
          });
          var b = E.symbolSize;
          if (b != null) {
            var T = -1 / 0;
            RRe(b, function(S) {
              S > T && (T = S);
            }), E.symbolSize = _U(b, function(S) {
              return _Re(S, [0, T], [0, m[0]], !0);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(t) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(t) {
      return null;
    }, e.prototype.getVisualMeta = function(t) {
      return null;
    }, e.type = "visualMap", e.dependencies = ["series"], e.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 
      }
    }, e;
  }(ot)
);
const tb = IRe;
var xU = [20, 140], xRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function(t, i) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(n) {
        n.mappingMethod = "linear", n.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      r.prototype.resetItemSize.apply(this, arguments);
      var t = this.itemSize;
      (t[0] == null || isNaN(t[0])) && (t[0] = xU[0]), (t[1] == null || isNaN(t[1])) && (t[1] = xU[1]);
    }, e.prototype._resetRange = function() {
      var t = this.getExtent(), i = this.option.range;
      !i || i.auto ? (t.auto = 1, this.option.range = t) : X(i) && (i[0] > i[1] && i.reverse(), i[0] = Math.max(i[0], t[0]), i[1] = Math.min(i[1], t[1]));
    }, e.prototype.completeVisualOption = function() {
      r.prototype.completeVisualOption.apply(this, arguments), w(this.stateList, function(t) {
        var i = this.option.controller[t].symbolSize;
        i && i[0] !== i[1] && (i[0] = i[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(t) {
      this.option.range = t.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var t = this.getExtent(), i = $n((this.get("range") || []).slice());
      return i[0] > t[1] && (i[0] = t[1]), i[1] > t[1] && (i[1] = t[1]), i[0] < t[0] && (i[0] = t[0]), i[1] < t[0] && (i[1] = t[0]), i;
    }, e.prototype.getValueState = function(t) {
      var i = this.option.range, n = this.getExtent();
      return (i[0] <= n[0] || i[0] <= t) && (i[1] >= n[1] || t <= i[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var i = [];
      return this.eachTargetSeries(function(n) {
        var a = [], o = n.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          t[0] <= s && s <= t[1] && a.push(l);
        }, this), i.push({
          seriesId: n.id,
          dataIndex: a
        });
      }, this), i;
    }, e.prototype.getVisualMeta = function(t) {
      var i = wU(this, "outOfRange", this.getExtent()), n = wU(this, "inRange", this.option.range.slice()), a = [];
      function o(d, p) {
        a.push({
          value: d,
          color: t(d, p)
        });
      }
      for (var s = 0, l = 0, u = n.length, h = i.length; l < h && (!n.length || i[l] <= n[0]); l++)
        i[l] < n[s] && o(i[l], "outOfRange");
      for (var c = 1; s < u; s++, c = 0)
        c && a.length && o(n[s], "outOfRange"), o(n[s], "inRange");
      for (var c = 1; l < h; l++)
        (!n.length || n[n.length - 1] < i[l]) && (c && (a.length && o(a[a.length - 1].value, "outOfRange"), c = 0), o(i[l], "outOfRange"));
      var f = a.length;
      return {
        stops: a,
        outerColors: [f ? a[0].color : "transparent", f ? a[f - 1].color : "transparent"]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = yl(tb.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), e;
  }(tb)
);
function wU(r, e, t) {
  if (t[0] === t[1])
    return t.slice();
  for (var i = 200, n = (t[1] - t[0]) / i, a = t[0], o = [], s = 0; s <= i && a < t[1]; s++)
    o.push(a), a += n;
  return o.push(t[1]), o;
}
const wRe = xRe;
var PRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, t;
    }
    return e.prototype.init = function(t, i) {
      this.ecModel = t, this.api = i;
    }, e.prototype.render = function(t, i, n, a) {
      if (this.visualMapModel = t, t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(t, i, n, a);
    }, e.prototype.renderBackground = function(t) {
      var i = this.visualMapModel, n = Cf(i.get("padding") || 0), a = t.getBoundingRect();
      t.add(new nt({
        z2: -1,
        silent: !0,
        shape: {
          x: a.x - n[3],
          y: a.y - n[0],
          width: a.width + n[3] + n[1],
          height: a.height + n[0] + n[2]
        },
        style: {
          fill: i.get("backgroundColor"),
          stroke: i.get("borderColor"),
          lineWidth: i.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(t, i, n) {
      n = n || {};
      var a = n.forceState, o = this.visualMapModel, s = {};
      if (i === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(d) {
        return s[d];
      }
      function h(d, p) {
        s[d] = p;
      }
      var c = o.controllerVisuals[a || o.getValueState(t)], f = Wr.prepareVisualTypes(c);
      return w(f, function(d) {
        var p = c[d];
        n.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = c.__alphaForOpacity), Wr.dependsOn(d, i) && p && p.applyVisual(t, u, h);
      }), s[i];
    }, e.prototype.positionGroup = function(t) {
      var i = this.visualMapModel, n = this.api;
      DS(t, i.getBoxLayoutParams(), {
        width: n.getWidth(),
        height: n.getHeight()
      });
    }, e.prototype.doRender = function(t, i, n, a) {
    }, e.type = "visualMap", e;
  }(Zt)
);
const S4 = PRe;
var PU = [["left", "right", "width"], ["top", "bottom", "height"]];
function T4(r, e, t) {
  var i = r.option, n = i.align;
  if (n != null && n !== "auto")
    return n;
  for (var a = {
    width: e.getWidth(),
    height: e.getHeight()
  }, o = i.orient === "horizontal" ? 1 : 0, s = PU[o], l = [0, null, 10], u = {}, h = 0; h < 3; h++)
    u[PU[1 - o][h]] = l[h], u[s[h]] = h === 2 ? t[0] : i[s[h]];
  var c = [["x", "width", 3], ["y", "height", 0]][o], f = mr(u, a, i.padding);
  return s[(f.margin[c[2]] || 0) + f[c[0]] + f[c[1]] * 0.5 < a[c[1]] * 0.5 ? 0 : 1];
}
function Im(r, e) {
  return w(r || [], function(t) {
    t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "");
  }), r;
}
var Da = Et, NRe = w, NU = Math.min, aR = Math.max, LRe = 12, DRe = 6, MRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t;
    }
    return e.prototype.doRender = function(t, i, n, a) {
      this._api = n, (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var t = this.visualMapModel, i = this.group;
      this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(i);
      var n = t.get("text");
      this._renderEndsText(i, n, 0), this._renderEndsText(i, n, 1), this._updateView(!0), this.renderBackground(i), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(i);
    }, e.prototype._renderEndsText = function(t, i, n) {
      if (i) {
        var a = i[1 - n];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, h = this._applyTransform([l[0] / 2, n === 0 ? -s : l[1] + s], u), c = this._applyTransform(n === 0 ? "bottom" : "top", u), f = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new lt({
          style: Lt(d, {
            x: h[0],
            y: h[1],
            verticalAlign: f === "horizontal" ? "middle" : c,
            align: f === "horizontal" ? c : "center",
            text: a
          })
        }));
      }
    }, e.prototype._renderBar = function(t) {
      var i = this.visualMapModel, n = this._shapes, a = i.itemSize, o = this._orient, s = this._useHandle, l = T4(i, this.api, a), u = n.mainGroup = this._createBarGroup(l), h = new ye();
      u.add(h), h.add(n.outOfRange = LU()), h.add(n.inRange = LU(null, s ? MU(this._orient) : null, ae(this._dragHandle, this, "all", !1), ae(this._dragHandle, this, "all", !0))), h.setClipPath(new nt({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var c = i.textStyleModel.getTextRect(""), f = aR(c.width, c.height);
      s && (n.handleThumbs = [], n.handleLabels = [], n.handleLabelPoints = [], this._createHandle(i, u, 0, a, f, o), this._createHandle(i, u, 1, a, f, o)), this._createIndicator(i, u, a, f, o), t.add(u);
    }, e.prototype._createHandle = function(t, i, n, a, o, s) {
      var l = ae(this._dragHandle, this, n, !1), u = ae(this._dragHandle, this, n, !0), h = Ea(t.get("handleSize"), a[0]), c = ur(t.get("handleIcon"), -h / 2, -h / 2, h, h, null, !0), f = MU(this._orient);
      c.attr({
        cursor: f,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(O) {
          Vo(O.event);
        }
      }), c.x = a[0] / 2, c.useStyle(t.getModel("handleStyle").getItemStyle()), c.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), c.style.lineWidth *= 2, c.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), Tu(c, !0), i.add(c);
      var d = this.visualMapModel.textStyleModel, p = new lt({
        cursor: f,
        draggable: !0,
        drift: l,
        onmousemove: function(O) {
          Vo(O.event);
        },
        ondragend: u,
        style: Lt(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [h, 0], v = this._shapes;
      v.handleThumbs[n] = c, v.handleLabelPoints[n] = g, v.handleLabels[n] = p;
    }, e.prototype._createIndicator = function(t, i, n, a, o) {
      var s = Ea(t.get("indicatorSize"), n[0]), l = ur(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: n[0] / 2
      });
      var u = t.getModel("indicatorStyle").getItemStyle();
      if (l instanceof qr) {
        var h = l.style;
        l.useStyle(V({
          // TODO other properties like x, y ?
          image: h.image,
          x: h.x,
          y: h.y,
          width: h.width,
          height: h.height
        }, u));
      } else
        l.useStyle(u);
      i.add(l);
      var c = this.visualMapModel.textStyleModel, f = new lt({
        silent: !0,
        invisible: !0,
        style: Lt(c, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(f);
      var d = [(o === "horizontal" ? a / 2 : DRe) + n[0] / 2, 0], p = this._shapes;
      p.indicator = l, p.indicatorLabel = f, p.indicatorLabelPoint = d, this._firstShowIndicator = !0;
    }, e.prototype._dragHandle = function(t, i, n, a) {
      if (this._useHandle) {
        if (this._dragging = !i, !i) {
          var o = this._applyTransform([n, a], this._shapes.mainGroup, !0);
          this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView();
        }
        i === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), i ? !this._hovering && this._clearHoverLinkToSeries() : DU(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
      }
    }, e.prototype._resetInterval = function() {
      var t = this.visualMapModel, i = this._dataInterval = t.getSelected(), n = t.getExtent(), a = [0, t.itemSize[1]];
      this._handleEnds = [Da(i[0], n, a, !0), Da(i[1], n, a, !0)];
    }, e.prototype._updateInterval = function(t, i) {
      i = i || 0;
      var n = this.visualMapModel, a = this._handleEnds, o = [0, n.itemSize[1]];
      Ch(
        i,
        a,
        o,
        t,
        // cross is forbidden
        0
      );
      var s = n.getExtent();
      this._dataInterval = [Da(a[0], o, s, !0), Da(a[1], o, s, !0)];
    }, e.prototype._updateView = function(t) {
      var i = this.visualMapModel, n = i.getExtent(), a = this._shapes, o = [0, i.itemSize[1]], s = t ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, n, s, "inRange"), u = this._createBarVisual(n, n, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, e.prototype._createBarVisual = function(t, i, n, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(t, o), l = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)], u = this._createBarPoints(n, l);
      return {
        barColor: new Gg(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, e.prototype._makeColorGradient = function(t, i) {
      var n = 100, a = [], o = (t[1] - t[0]) / n;
      a.push({
        color: this.getControllerVisual(t[0], "color", i),
        offset: 0
      });
      for (var s = 1; s < n; s++) {
        var l = t[0] + o * s;
        if (l > t[1])
          break;
        a.push({
          color: this.getControllerVisual(l, "color", i),
          offset: s / n
        });
      }
      return a.push({
        color: this.getControllerVisual(t[1], "color", i),
        offset: 1
      }), a;
    }, e.prototype._createBarPoints = function(t, i) {
      var n = this.visualMapModel.itemSize;
      return [[n[0] - i[0], t[0]], [n[0], t[0]], [n[0], t[1]], [n[0] - i[1], t[1]]];
    }, e.prototype._createBarGroup = function(t) {
      var i = this._orient, n = this.visualMapModel.get("inverse");
      return new ye(i === "horizontal" && !n ? {
        scaleX: t === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : i === "horizontal" && n ? {
        scaleX: t === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : i === "vertical" && !n ? {
        scaleX: t === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: t === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(t, i) {
      if (this._useHandle) {
        var n = this._shapes, a = this.visualMapModel, o = n.handleThumbs, s = n.handleLabels, l = a.itemSize, u = a.getExtent();
        NRe([0, 1], function(h) {
          var c = o[h];
          c.setStyle("fill", i.handlesColor[h]), c.y = t[h];
          var f = Da(t[h], [0, l[1]], u, !0), d = this.getControllerVisual(f, "symbolSize");
          c.scaleX = c.scaleY = d / l[0], c.x = l[0] - d / 2;
          var p = Oa(n.handleLabelPoints[h], Vu(c, this.group));
          s[h].setStyle({
            x: p[0],
            y: p[1],
            text: a.formatValueText(this._dataInterval[h]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", n.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(t, i, n, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], h = this._shapes, c = h.indicator;
      if (c) {
        c.attr("invisible", !1);
        var f = {
          convertOpacityToAlpha: !0
        }, d = this.getControllerVisual(t, "color", f), p = this.getControllerVisual(t, "symbolSize"), g = Da(t, s, u, !0), v = l[0] - p / 2, O = {
          x: c.x,
          y: c.y
        };
        c.y = g, c.x = v;
        var m = Oa(h.indicatorLabelPoint, Vu(c, this.group)), E = h.indicatorLabel;
        E.attr("invisible", !1);
        var b = this._applyTransform("left", h.mainGroup), T = this._orient, S = T === "horizontal";
        E.setStyle({
          text: (n || "") + o.formatValueText(i),
          verticalAlign: S ? b : "middle",
          align: S ? "center" : b
        });
        var y = {
          x: v,
          y: g,
          style: {
            fill: d
          }
        }, A = {
          style: {
            x: m[0],
            y: m[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var C = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          c.x = O.x, c.y = O.y, c.animateTo(y, C), E.animateTo(A, C);
        } else
          c.attr(y), E.attr(A);
        this._firstShowIndicator = !1;
        var _ = this._shapes.handleLabels;
        if (_)
          for (var I = 0; I < _.length; I++)
            this._api.enterBlur(_[I]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var t = this;
      this._shapes.mainGroup.on("mousemove", function(i) {
        if (t._hovering = !0, !t._dragging) {
          var n = t.visualMapModel.itemSize, a = t._applyTransform([i.offsetX, i.offsetY], t._shapes.mainGroup, !0, !0);
          a[1] = NU(aR(0, a[1]), n[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= n[0]);
        }
      }).on("mouseout", function() {
        t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var t = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(t, i) {
      var n = this.visualMapModel, a = n.itemSize;
      if (n.option.hoverLink) {
        var o = [0, a[1]], s = n.getExtent();
        t = NU(aR(o[0], t), o[1]);
        var l = kRe(n, s, o), u = [t - l, t + l], h = Da(t, o, s, !0), c = [Da(u[0], o, s, !0), Da(u[1], o, s, !0)];
        u[0] < o[0] && (c[0] = -1 / 0), u[1] > o[1] && (c[1] = 1 / 0), i && (c[0] === -1 / 0 ? this._showIndicator(h, c[1], "< ", l) : c[1] === 1 / 0 ? this._showIndicator(h, c[0], "> ", l) : this._showIndicator(h, h, " ", l));
        var f = this._hoverLinkDataIndices, d = [];
        (i || DU(n)) && (d = this._hoverLinkDataIndices = n.findTargetDataIndices(c));
        var p = Iie(f, d);
        this._dispatchHighDown("downplay", Im(p[0], n)), this._dispatchHighDown("highlight", Im(p[1], n));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(t) {
      var i;
      if (Ru(t.target, function(l) {
        var u = _e(l);
        if (u.dataIndex != null)
          return i = u, !0;
      }, !0), !!i) {
        var n = this.ecModel.getSeriesByIndex(i.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(n)) {
          var o = n.getData(i.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), i.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var t = this._shapes;
      t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
      var i = this._shapes.handleLabels;
      if (i)
        for (var n = 0; n < i.length; n++)
          this._api.leaveBlur(i[n]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var t = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", Im(t, this.visualMapModel)), t.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var t = this.api.getZr();
      t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(t, i, n, a) {
      var o = Vu(i, a ? null : this.group);
      return X(t) ? Oa(t, o, n) : _S(t, o, n);
    }, e.prototype._dispatchHighDown = function(t, i) {
      i && i.length && this.api.dispatchAction({
        type: t,
        batch: i
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.prototype.remove = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(S4)
);
function LU(r, e, t, i) {
  return new Yi({
    shape: {
      points: r
    },
    draggable: !!t,
    cursor: e,
    drift: t,
    onmousemove: function(n) {
      Vo(n.event);
    },
    ondragend: i
  });
}
function kRe(r, e, t) {
  var i = LRe / 2, n = r.get("hoverLinkDataSize");
  return n && (i = Da(n, e, t, !0) / 2), i;
}
function DU(r) {
  var e = r.get("hoverLinkOnHandle");
  return !!(e ?? r.get("realtime"));
}
function MU(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
const QRe = MRe;
var URe = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, $Re = function(r, e) {
  e.eachComponent({
    mainType: "visualMap",
    query: r
  }, function(t) {
    t.setSelected(r.selected);
  });
}, GRe = [
  {
    createOnAllSeries: !0,
    reset: function(r, e) {
      var t = [];
      return e.eachComponent("visualMap", function(i) {
        var n = r.pipelineContext;
        !i.isTargetSeries(r) || n && n.large || t.push(Dye(i.stateList, i.targetVisuals, ae(i.getValueState, i), i.getDataDimensionIndex(r.getData())));
      }), t;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(r, e) {
      var t = r.getData(), i = [];
      e.eachComponent("visualMap", function(n) {
        if (n.isTargetSeries(r)) {
          var a = n.getVisualMeta(ae(BRe, null, r, n)) || {
            stops: [],
            outerColors: []
          }, o = n.getDataDimensionIndex(t);
          o >= 0 && (a.dimension = o, i.push(a));
        }
      }), r.getData().setVisual("visualMeta", i);
    }
  }
];
function BRe(r, e, t, i) {
  for (var n = e.targetVisuals[i], a = Wr.prepareVisualTypes(n), o = {
    color: Yg(r.getData(), "color")
    // default color.
  }, s = 0, l = a.length; s < l; s++) {
    var u = a[s], h = n[u === "opacity" ? "__alphaForOpacity" : u];
    h && h.applyVisual(t, c, f);
  }
  return o.color;
  function c(d) {
    return o[d];
  }
  function f(d, p) {
    o[d] = p;
  }
}
var kU = w;
function VRe(r) {
  var e = r && r.visualMap;
  X(e) || (e = e ? [e] : []), kU(e, function(t) {
    if (t) {
      Jh(t, "splitList") && !Jh(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
      var i = t.pieces;
      i && X(i) && kU(i, function(n) {
        be(n) && (Jh(n, "start") && !Jh(n, "min") && (n.min = n.start), Jh(n, "end") && !Jh(n, "max") && (n.max = n.end));
      });
    }
  });
}
function Jh(r, e) {
  return r && r.hasOwnProperty && r.hasOwnProperty(e);
}
var QU = !1;
function y4(r) {
  QU || (QU = !0, r.registerSubTypeDefaulter("visualMap", function(e) {
    return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
  }), r.registerAction(URe, $Re), w(GRe, function(e) {
    r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, e);
  }), r.registerPreprocessor(VRe));
}
function R4(r) {
  r.registerComponentModel(wRe), r.registerComponentView(QRe), y4(r);
}
var FRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._pieceList = [], t;
    }
    return e.prototype.optionUpdated = function(t, i) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var n = this._mode = this._determineMode();
      this._pieceList = [], XRe[this._mode].call(this, this._pieceList), this._resetSelected(t, i);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        n === "categories" ? (o.mappingMethod = "category", o.categories = Se(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = Y(this._pieceList, function(l) {
          return l = Se(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var t = this.option, i = {}, n = Wr.listVisualTypes(), a = this.isCategory();
      w(t.pieces, function(s) {
        w(n, function(l) {
          s.hasOwnProperty(l) && (i[l] = 1);
        });
      }), w(i, function(s, l) {
        var u = !1;
        w(this.stateList, function(h) {
          u = u || o(t, h, l) || o(t.target, h, l);
        }, this), !u && w(this.stateList, function(h) {
          (t[h] || (t[h] = {}))[l] = b4.get(l, h === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      r.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(t, i) {
      var n = this.option, a = this._pieceList, o = (i ? n : t).selected || {};
      if (n.selected = o, w(a, function(l, u) {
        var h = this.getSelectedMapKey(l);
        o.hasOwnProperty(h) || (o[h] = !0);
      }, this), n.selectedMode === "single") {
        var s = !1;
        w(a, function(l, u) {
          var h = this.getSelectedMapKey(l);
          o[h] && (s ? o[h] = !1 : s = !0);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(t) {
      return this._mode === "categories" ? t.value + "" : t.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var t = this.option;
      return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(t) {
      this.option.selected = Se(t);
    }, e.prototype.getValueState = function(t) {
      var i = Wr.findPieceIndex(t, this._pieceList);
      return i != null && this.option.selected[this.getSelectedMapKey(this._pieceList[i])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var i = [], n = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var h = Wr.findPieceIndex(l, n);
          h === t && o.push(u);
        }, this), i.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), i;
    }, e.prototype.getRepresentValue = function(t) {
      var i;
      if (this.isCategory())
        i = t.value;
      else if (t.value != null)
        i = t.value;
      else {
        var n = t.interval || [];
        i = n[0] === -1 / 0 && n[1] === 1 / 0 ? 0 : (n[0] + n[1]) / 2;
      }
      return i;
    }, e.prototype.getVisualMeta = function(t) {
      if (this.isCategory())
        return;
      var i = [], n = ["", ""], a = this;
      function o(h, c) {
        var f = a.getRepresentValue({
          interval: h
        });
        c || (c = a.getValueState(f));
        var d = t(f, c);
        h[0] === -1 / 0 ? n[0] = d : h[1] === 1 / 0 ? n[1] = d : i.push({
          value: h[0],
          color: d
        }, {
          value: h[1],
          color: d
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return w(s, function(h) {
        var c = h.interval;
        c && (c[0] > u && o([u, c[0]], "outOfRange"), o(c.slice()), u = c[1]);
      }, this), {
        stops: i,
        outerColors: n
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = yl(tb.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), e;
  }(tb)
), XRe = {
  splitNumber: function(r) {
    var e = this.option, t = Math.min(e.precision, 20), i = this.getExtent(), n = e.splitNumber;
    n = Math.max(parseInt(n, 10), 1), e.splitNumber = n;
    for (var a = (i[1] - i[0]) / n; +a.toFixed(t) !== a && t < 5; )
      t++;
    e.precision = t, a = +a.toFixed(t), e.minOpen && r.push({
      interval: [-1 / 0, i[0]],
      close: [0, 0]
    });
    for (var o = 0, s = i[0]; o < n; s += a, o++) {
      var l = o === n - 1 ? i[1] : s + a;
      r.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    e.maxOpen && r.push({
      interval: [i[1], 1 / 0],
      close: [0, 0]
    }), wL(r), w(r, function(u, h) {
      u.index = h, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(r) {
    var e = this.option;
    w(e.categories, function(t) {
      r.push({
        text: this.formatValueText(t, !0),
        value: t
      });
    }, this), UU(e, r);
  },
  pieces: function(r) {
    var e = this.option;
    w(e.pieces, function(t, i) {
      be(t) || (t = {
        value: t
      });
      var n = {
        text: "",
        index: i
      };
      if (t.label != null && (n.text = t.label), t.hasOwnProperty("value")) {
        var a = n.value = t.value;
        n.interval = [a, a], n.close = [1, 1];
      } else {
        for (var o = n.interval = [], s = n.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], h = [], c = 0; c < 2; c++) {
          for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][c], d = 0; d < 3 && o[c] == null; d++)
            o[c] = t[f[d]], s[c] = l[d], h[c] = d === 2;
          o[c] == null && (o[c] = u[c]);
        }
        h[0] && o[1] === 1 / 0 && (s[0] = 0), h[1] && o[0] === -1 / 0 && (s[1] = 0), o[0] === o[1] && s[0] && s[1] && (n.value = o[0]);
      }
      n.visual = Wr.retrieveVisuals(t), r.push(n);
    }, this), UU(e, r), wL(r), w(r, function(t) {
      var i = t.close, n = [["<", ""][i[1]], [">", ""][i[0]]];
      t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, n);
    }, this);
  }
};
function UU(r, e) {
  var t = r.inverse;
  (r.orient === "vertical" ? !t : t) && e.reverse();
}
const YRe = FRe;
var HRe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.doRender = function() {
      var t = this.group;
      t.removeAll();
      var i = this.visualMapModel, n = i.get("textGap"), a = i.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = i.itemSize, h = this._getViewData(), c = h.endsText, f = Dr(i.get("showLabel", !0), !c);
      c && this._renderEndsText(t, c[0], u, f, l), w(h.viewPieceList, function(d) {
        var p = d.piece, g = new ye();
        g.onclick = ae(this._onItemClick, this, p), this._enableHoverLink(g, d.indexInModelPieceList);
        var v = i.getRepresentValue(p);
        if (this._createItemSymbol(g, v, [0, 0, u[0], u[1]]), f) {
          var O = this.visualMapModel.getValueState(v);
          g.add(new lt({
            style: {
              x: l === "right" ? -n : u[0] + n,
              y: u[1] / 2,
              text: p.text,
              verticalAlign: "middle",
              align: l,
              font: o,
              fill: s,
              opacity: O === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        t.add(g);
      }, this), c && this._renderEndsText(t, c[1], u, f, l), Fu(i.get("orient"), t, i.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    }, e.prototype._enableHoverLink = function(t, i) {
      var n = this;
      t.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = n.visualMapModel;
        s.option.hoverLink && n.api.dispatchAction({
          type: o,
          batch: Im(s.findTargetDataIndices(i), s)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var t = this.visualMapModel, i = t.option;
      if (i.orient === "vertical")
        return T4(t, this.api, t.itemSize);
      var n = i.align;
      return (!n || n === "auto") && (n = "left"), n;
    }, e.prototype._renderEndsText = function(t, i, n, a, o) {
      if (i) {
        var s = new ye(), l = this.visualMapModel.textStyleModel;
        s.add(new lt({
          style: Lt(l, {
            x: a ? o === "right" ? n[0] : 0 : n[0] / 2,
            y: n[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: i
          })
        })), t.add(s);
      }
    }, e.prototype._getViewData = function() {
      var t = this.visualMapModel, i = Y(t.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), n = t.get("text"), a = t.get("orient"), o = t.get("inverse");
      return (a === "horizontal" ? o : !o) ? i.reverse() : n && (n = n.slice().reverse()), {
        viewPieceList: i,
        endsText: n
      };
    }, e.prototype._createItemSymbol = function(t, i, n) {
      t.add(ur(
        // symbol will be string
        this.getControllerVisual(i, "symbol"),
        n[0],
        n[1],
        n[2],
        n[3],
        // color will be string
        this.getControllerVisual(i, "color")
      ));
    }, e.prototype._onItemClick = function(t) {
      var i = this.visualMapModel, n = i.option, a = n.selectedMode;
      if (a) {
        var o = Se(n.selected), s = i.getSelectedMapKey(t);
        a === "single" || a === !0 ? (o[s] = !0, w(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(S4)
);
const WRe = HRe;
function A4(r) {
  r.registerComponentModel(YRe), r.registerComponentView(WRe), y4(r);
}
function zRe(r) {
  Ve(R4), Ve(A4);
}
var ZRe = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, $U = at(), qRe = {};
function jRe(r, e) {
  var t = r.getModel("aria");
  if (!t.get("enabled"))
    return;
  var i = Se(ZRe);
  Qe(i.label, r.getLocaleModel().get("aria"), !1), Qe(t.option, i, !1), n(), a();
  function n() {
    var u = t.getModel("decal"), h = u.get("show");
    if (h) {
      var c = ce();
      r.eachSeries(function(f) {
        if (!f.isColorBySeries()) {
          var d = c.get(f.type);
          d || (d = {}, c.set(f.type, d)), $U(f).scope = d;
        }
      }), r.eachRawSeries(function(f) {
        if (r.isSeriesFiltered(f))
          return;
        if (ve(f.enableAriaDecal)) {
          f.enableAriaDecal();
          return;
        }
        var d = f.getData();
        if (f.isColorBySeries()) {
          var m = lC(f.ecModel, f.name, qRe, r.getSeriesCount()), E = d.getVisual("decal");
          d.setVisual("decal", b(E, m));
        } else {
          var p = f.getRawData(), g = {}, v = $U(f).scope;
          d.each(function(T) {
            var S = d.getRawIndex(T);
            g[S] = T;
          });
          var O = p.count();
          p.each(function(T) {
            var S = g[T], y = p.getName(T) || T + "", A = lC(f.ecModel, y, v, O), C = d.getItemVisual(S, "decal");
            d.setItemVisual(S, "decal", b(C, A));
          });
        }
        function b(T, S) {
          var y = T ? V(V({}, S), T) : S;
          return y.dirty = !0, y;
        }
      });
    }
  }
  function a() {
    var u = r.getLocaleModel().get("aria"), h = t.getModel("label");
    if (h.option = me(h.option, u), !!h.get("enabled")) {
      var c = e.getZr().dom;
      if (h.get("description")) {
        c.setAttribute("aria-label", h.get("description"));
        return;
      }
      var f = r.getSeriesCount(), d = h.get(["data", "maxCount"]) || 10, p = h.get(["series", "maxCount"]) || 10, g = Math.min(f, p), v;
      if (!(f < 1)) {
        var O = s();
        if (O) {
          var m = h.get(["general", "withTitle"]);
          v = o(m, {
            title: O
          });
        } else
          v = h.get(["general", "withoutTitle"]);
        var E = [], b = f > 1 ? h.get(["series", "multiple", "prefix"]) : h.get(["series", "single", "prefix"]);
        v += o(b, {
          seriesCount: f
        }), r.eachSeries(function(A, C) {
          if (C < g) {
            var _ = void 0, I = A.get("name"), x = I ? "withName" : "withoutName";
            _ = f > 1 ? h.get(["series", "multiple", x]) : h.get(["series", "single", x]), _ = o(_, {
              seriesId: A.seriesIndex,
              seriesName: A.get("name"),
              seriesType: l(A.subType)
            });
            var P = A.getData();
            if (P.count() > d) {
              var N = h.get(["data", "partialData"]);
              _ += o(N, {
                displayCnt: d
              });
            } else
              _ += h.get(["data", "allData"]);
            for (var L = h.get(["data", "separator", "middle"]), D = h.get(["data", "separator", "end"]), $ = [], k = 0; k < P.count(); k++)
              if (k < d) {
                var G = P.getName(k), F = P.getValues(k), q = h.get(["data", G ? "withName" : "withoutName"]);
                $.push(o(q, {
                  name: G,
                  value: F.join(L)
                }));
              }
            _ += $.join(L) + D, E.push(_);
          }
        });
        var T = h.getModel(["series", "multiple", "separator"]), S = T.get("middle"), y = T.get("end");
        v += E.join(S) + y, c.setAttribute("aria-label", v);
      }
    }
  }
  function o(u, h) {
    if (!ne(u))
      return u;
    var c = u;
    return w(h, function(f, d) {
      c = c.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), f);
    }), c;
  }
  function s() {
    var u = r.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    return r.getLocaleModel().get(["series", "typeNames"])[u] || "";
  }
}
function KRe(r) {
  if (!(!r || !r.aria)) {
    var e = r.aria;
    e.show != null && (e.enabled = e.show), e.label = e.label || {}, w(["description", "general", "series", "data"], function(t) {
      e[t] != null && (e.label[t] = e[t]);
    });
  }
}
function JRe(r) {
  r.registerPreprocessor(KRe), r.registerVisual(r.PRIORITY.VISUAL.ARIA, jRe);
}
var GU = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, eAe = (
  /** @class */
  function() {
    function r(e) {
      var t = this._condVal = ne(e) ? new RegExp(e) : $te(e) ? e : null;
      if (t == null) {
        var i = "";
        vt(i);
      }
    }
    return r.prototype.evaluate = function(e) {
      var t = typeof e;
      return ne(t) ? this._condVal.test(e) : ut(t) ? this._condVal.test(e + "") : !1;
    }, r;
  }()
), tAe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return this.value;
    }, r;
  }()
), rAe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (!e[t].evaluate())
          return !1;
      return !0;
    }, r;
  }()
), iAe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (e[t].evaluate())
          return !0;
      return !1;
    }, r;
  }()
), nAe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, r;
  }()
), aAe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = !!this.valueParser, t = this.getValue, i = t(this.valueGetterParam), n = e ? this.valueParser(i) : null, a = 0; a < this.subCondList.length; a++)
        if (!this.subCondList[a].evaluate(e ? n : i))
          return !1;
      return !0;
    }, r;
  }()
);
function Rw(r, e) {
  if (r === !0 || r === !1) {
    var t = new tAe();
    return t.value = r, t;
  }
  var i = "";
  return C4(r) || vt(i), r.and ? BU("and", r, e) : r.or ? BU("or", r, e) : r.not ? oAe(r, e) : sAe(r, e);
}
function BU(r, e, t) {
  var i = e[r], n = "";
  X(i) || vt(n), i.length || vt(n);
  var a = r === "and" ? new rAe() : new iAe();
  return a.children = Y(i, function(o) {
    return Rw(o, t);
  }), a.children.length || vt(n), a;
}
function oAe(r, e) {
  var t = r.not, i = "";
  C4(t) || vt(i);
  var n = new nAe();
  return n.child = Rw(t, e), n.child || vt(i), n;
}
function sAe(r, e) {
  for (var t = "", i = e.prepareGetValue(r), n = [], a = He(r), o = r.parser, s = o ? iH(o) : null, l = 0; l < a.length; l++) {
    var u = a[l];
    if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
      var h = oe(GU, u) ? GU[u] : u, c = r[u], f = s ? s(c) : c, d = Foe(h, f) || h === "reg" && new eAe(f);
      d || vt(t), n.push(d);
    }
  }
  n.length || vt(t);
  var p = new aAe();
  return p.valueGetterParam = i, p.valueParser = s, p.getValue = e.getValue, p.subCondList = n, p;
}
function C4(r) {
  return be(r) && !ci(r);
}
var lAe = (
  /** @class */
  function() {
    function r(e, t) {
      this._cond = Rw(e, t);
    }
    return r.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, r;
  }()
);
function uAe(r, e) {
  return new lAe(r, e);
}
var hAe = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(r) {
    for (var e = r.upstream, t, i = uAe(r.config, {
      valueGetterAttrMap: ce({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        oe(s, "dimension") || vt(l);
        var h = e.getDimensionInfo(u);
        return h || vt(l), {
          dimIdx: h.index
        };
      },
      getValue: function(s) {
        return e.retrieveValueFromItem(t, s.dimIdx);
      }
    }), n = [], a = 0, o = e.count(); a < o; a++)
      t = e.getRawDataItem(a), i.evaluate() && n.push(t);
    return {
      data: n
    };
  }
}, cAe = {
  type: "echarts:sort",
  transform: function(r) {
    var e = r.upstream, t = r.config, i = "", n = At(t);
    n.length || vt(i);
    var a = [];
    w(n, function(h) {
      var c = h.dimension, f = h.order, d = h.parser, p = h.incomparable;
      if (c == null && vt(i), f !== "asc" && f !== "desc" && vt(i), p && p !== "min" && p !== "max") {
        var g = "";
        vt(g);
      }
      if (f !== "asc" && f !== "desc") {
        var v = "";
        vt(v);
      }
      var O = e.getDimensionInfo(c);
      O || vt(i);
      var m = d ? iH(d) : null;
      d && !m && vt(i), a.push({
        dimIdx: O.index,
        parser: m,
        comparator: new aH(f, p)
      });
    });
    var o = e.sourceFormat;
    o !== fi && o !== Jn && vt(i);
    for (var s = [], l = 0, u = e.count(); l < u; l++)
      s.push(e.getRawDataItem(l));
    return s.sort(function(h, c) {
      for (var f = 0; f < a.length; f++) {
        var d = a[f], p = e.retrieveValueFromItem(h, d.dimIdx), g = e.retrieveValueFromItem(c, d.dimIdx);
        d.parser && (p = d.parser(p), g = d.parser(g));
        var v = d.comparator.evaluate(p, g);
        if (v !== 0)
          return v;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function fAe(r) {
  r.registerTransform(hAe), r.registerTransform(cAe);
}
var dAe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.prototype.init = function(t, i, n) {
      r.prototype.init.call(this, t, i, n), this._sourceManager = new uH(this), XD(this);
    }, e.prototype.mergeOption = function(t, i) {
      r.prototype.mergeOption.call(this, t, i), XD(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: Ja
    }, e;
  }(ot)
), pAe = (
  /** @class */
  function(r) {
    U(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.type = "dataset", e;
  }(Zt)
);
function gAe(r) {
  r.registerComponentModel(dAe), r.registerComponentView(pAe);
}
var Ia = lo.CMD;
function mc(r, e) {
  return Math.abs(r - e) < 1e-5;
}
function s_(r) {
  var e = r.data, t = r.len(), i = [], n, a = 0, o = 0, s = 0, l = 0;
  function u(P, N) {
    n && n.length > 2 && i.push(n), n = [P, N];
  }
  function h(P, N, L, D) {
    mc(P, L) && mc(N, D) || n.push(P, N, L, D, L, D);
  }
  function c(P, N, L, D, $, k) {
    var G = Math.abs(N - P), F = Math.tan(G / 4) * 4 / 3, q = N < P ? -1 : 1, re = Math.cos(P), fe = Math.sin(P), de = Math.cos(N), $e = Math.sin(N), Pe = re * $ + L, Ne = fe * k + D, Ee = de * $ + L, xe = $e * k + D, Ce = $ * F * q, ue = k * F * q;
    n.push(Pe - Ce * fe, Ne + ue * re, Ee + Ce * $e, xe - ue * de, Ee, xe);
  }
  for (var f, d, p, g, v = 0; v < t; ) {
    var O = e[v++], m = v === 1;
    switch (m && (a = e[v], o = e[v + 1], s = a, l = o, (O === Ia.L || O === Ia.C || O === Ia.Q) && (n = [s, l])), O) {
      case Ia.M:
        a = s = e[v++], o = l = e[v++], u(s, l);
        break;
      case Ia.L:
        f = e[v++], d = e[v++], h(a, o, f, d), a = f, o = d;
        break;
      case Ia.C:
        n.push(e[v++], e[v++], e[v++], e[v++], a = e[v++], o = e[v++]);
        break;
      case Ia.Q:
        f = e[v++], d = e[v++], p = e[v++], g = e[v++], n.push(a + 2 / 3 * (f - a), o + 2 / 3 * (d - o), p + 2 / 3 * (f - p), g + 2 / 3 * (d - g), p, g), a = p, o = g;
        break;
      case Ia.A:
        var E = e[v++], b = e[v++], T = e[v++], S = e[v++], y = e[v++], A = e[v++] + y;
        v += 1;
        var C = !e[v++];
        f = Math.cos(y) * T + E, d = Math.sin(y) * S + b, m ? (s = f, l = d, u(s, l)) : h(a, o, f, d), a = Math.cos(A) * T + E, o = Math.sin(A) * S + b;
        for (var _ = (C ? -1 : 1) * Math.PI / 2, I = y; C ? I > A : I < A; I += _) {
          var x = C ? Math.max(I + _, A) : Math.min(I + _, A);
          c(I, x, E, b, T, S);
        }
        break;
      case Ia.R:
        s = a = e[v++], l = o = e[v++], f = s + e[v++], d = l + e[v++], u(f, l), h(f, l, f, d), h(f, d, s, d), h(s, d, s, l), h(s, l, f, l);
        break;
      case Ia.Z:
        n && h(a, o, s, l), a = s, o = l;
        break;
    }
  }
  return n && n.length > 2 && i.push(n), i;
}
function l_(r, e, t, i, n, a, o, s, l, u) {
  if (mc(r, t) && mc(e, i) && mc(n, o) && mc(a, s)) {
    l.push(o, s);
    return;
  }
  var h = 2 / u, c = h * h, f = o - r, d = s - e, p = Math.sqrt(f * f + d * d);
  f /= p, d /= p;
  var g = t - r, v = i - e, O = n - o, m = a - s, E = g * g + v * v, b = O * O + m * m;
  if (E < c && b < c) {
    l.push(o, s);
    return;
  }
  var T = f * g + d * v, S = -f * O - d * m, y = E - T * T, A = b - S * S;
  if (y < c && T >= 0 && A < c && S >= 0) {
    l.push(o, s);
    return;
  }
  var C = [], _ = [];
  nl(r, t, n, o, 0.5, C), nl(e, i, a, s, 0.5, _), l_(C[0], _[0], C[1], _[1], C[2], _[2], C[3], _[3], l, u), l_(C[4], _[4], C[5], _[5], C[6], _[6], C[7], _[7], l, u);
}
function vAe(r, e) {
  var t = s_(r), i = [];
  e = e || 1;
  for (var n = 0; n < t.length; n++) {
    var a = t[n], o = [], s = a[0], l = a[1];
    o.push(s, l);
    for (var u = 2; u < a.length; ) {
      var h = a[u++], c = a[u++], f = a[u++], d = a[u++], p = a[u++], g = a[u++];
      l_(s, l, h, c, f, d, p, g, o, e), s = p, l = g;
    }
    i.push(o);
  }
  return i;
}
function _4(r, e, t) {
  var i = r[e], n = r[1 - e], a = Math.abs(i / n), o = Math.ceil(Math.sqrt(a * t)), s = Math.floor(t / o);
  s === 0 && (s = 1, o = t);
  for (var l = [], u = 0; u < o; u++)
    l.push(s);
  var h = o * s, c = t - h;
  if (c > 0)
    for (var u = 0; u < c; u++)
      l[u % o] += 1;
  return l;
}
function VU(r, e, t) {
  for (var i = r.r0, n = r.r, a = r.startAngle, o = r.endAngle, s = Math.abs(o - a), l = s * n, u = n - i, h = l > Math.abs(u), c = _4([l, u], h ? 0 : 1, e), f = (h ? s : u) / c.length, d = 0; d < c.length; d++)
    for (var p = (h ? u : s) / c[d], g = 0; g < c[d]; g++) {
      var v = {};
      h ? (v.startAngle = a + f * d, v.endAngle = a + f * (d + 1), v.r0 = i + p * g, v.r = i + p * (g + 1)) : (v.startAngle = a + p * g, v.endAngle = a + p * (g + 1), v.r0 = i + f * d, v.r = i + f * (d + 1)), v.clockwise = r.clockwise, v.cx = r.cx, v.cy = r.cy, t.push(v);
    }
}
function OAe(r, e, t) {
  for (var i = r.width, n = r.height, a = i > n, o = _4([i, n], a ? 0 : 1, e), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", h = a ? "y" : "x", c = r[s] / o.length, f = 0; f < o.length; f++)
    for (var d = r[l] / o[f], p = 0; p < o[f]; p++) {
      var g = {};
      g[u] = f * c, g[h] = p * d, g[s] = c, g[l] = d, g.x += r.x, g.y += r.y, t.push(g);
    }
}
function FU(r, e, t, i) {
  return r * i - t * e;
}
function mAe(r, e, t, i, n, a, o, s) {
  var l = t - r, u = i - e, h = o - n, c = s - a, f = FU(h, c, l, u);
  if (Math.abs(f) < 1e-6)
    return null;
  var d = r - n, p = e - a, g = FU(d, p, h, c) / f;
  return g < 0 || g > 1 ? null : new Le(g * l + r, g * u + e);
}
function EAe(r, e, t) {
  var i = new Le();
  Le.sub(i, t, e), i.normalize();
  var n = new Le();
  Le.sub(n, r, e);
  var a = n.dot(i);
  return a;
}
function ec(r, e) {
  var t = r[r.length - 1];
  t && t[0] === e[0] && t[1] === e[1] || r.push(e);
}
function bAe(r, e, t) {
  for (var i = r.length, n = [], a = 0; a < i; a++) {
    var o = r[a], s = r[(a + 1) % i], l = mAe(o[0], o[1], s[0], s[1], e.x, e.y, t.x, t.y);
    l && n.push({
      projPt: EAe(l, e, t),
      pt: l,
      idx: a
    });
  }
  if (n.length < 2)
    return [{ points: r }, { points: r }];
  n.sort(function(v, O) {
    return v.projPt - O.projPt;
  });
  var u = n[0], h = n[n.length - 1];
  if (h.idx < u.idx) {
    var c = u;
    u = h, h = c;
  }
  for (var f = [u.pt.x, u.pt.y], d = [h.pt.x, h.pt.y], p = [f], g = [d], a = u.idx + 1; a <= h.idx; a++)
    ec(p, r[a].slice());
  ec(p, d), ec(p, f);
  for (var a = h.idx + 1; a <= u.idx + i; a++)
    ec(g, r[a % i].slice());
  return ec(g, f), ec(g, d), [{
    points: p
  }, {
    points: g
  }];
}
function XU(r) {
  var e = r.points, t = [], i = [];
  SS(e, t, i);
  var n = new Ue(t[0], t[1], i[0] - t[0], i[1] - t[1]), a = n.width, o = n.height, s = n.x, l = n.y, u = new Le(), h = new Le();
  return a > o ? (u.x = h.x = s + a / 2, u.y = l, h.y = l + o) : (u.y = h.y = l + o / 2, u.x = s, h.x = s + a), bAe(e, u, h);
}
function rb(r, e, t, i) {
  if (t === 1)
    i.push(e);
  else {
    var n = Math.floor(t / 2), a = r(e);
    rb(r, a[0], n, i), rb(r, a[1], t - n, i);
  }
  return i;
}
function SAe(r, e) {
  for (var t = [], i = 0; i < e; i++)
    t.push(BI(r));
  return t;
}
function TAe(r, e) {
  e.setStyle(r.style), e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel;
}
function yAe(r) {
  for (var e = [], t = 0; t < r.length; )
    e.push([r[t++], r[t++]]);
  return e;
}
function RAe(r, e) {
  var t = [], i = r.shape, n;
  switch (r.type) {
    case "rect":
      OAe(i, e, t), n = nt;
      break;
    case "sector":
      VU(i, e, t), n = Xi;
      break;
    case "circle":
      VU({
        r0: 0,
        r: i.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: i.cx,
        cy: i.cy
      }, e, t), n = Xi;
      break;
    default:
      var a = r.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = Y(vAe(r.getUpdatedPathProxy(), o), function(O) {
        return yAe(O);
      }), l = s.length;
      if (l === 0)
        rb(XU, {
          points: s[0]
        }, e, t);
      else if (l === e)
        for (var u = 0; u < l; u++)
          t.push({
            points: s[u]
          });
      else {
        var h = 0, c = Y(s, function(O) {
          var m = [], E = [];
          SS(O, m, E);
          var b = (E[1] - m[1]) * (E[0] - m[0]);
          return h += b, { poly: O, area: b };
        });
        c.sort(function(O, m) {
          return m.area - O.area;
        });
        for (var f = e, u = 0; u < l; u++) {
          var d = c[u];
          if (f <= 0)
            break;
          var p = u === l - 1 ? f : Math.ceil(d.area / h * e);
          p < 0 || (rb(XU, {
            points: d.poly
          }, p, t), f -= p);
        }
      }
      n = Yi;
      break;
  }
  if (!n)
    return SAe(r, e);
  for (var g = [], u = 0; u < t.length; u++) {
    var v = new n();
    v.setShape(t[u]), TAe(r, v), g.push(v);
  }
  return g;
}
function AAe(r, e) {
  var t = r.length, i = e.length;
  if (t === i)
    return [r, e];
  for (var n = [], a = [], o = t < i ? r : e, s = Math.min(t, i), l = Math.abs(i - t) / 6, u = (s - 2) / 6, h = Math.ceil(l / u) + 1, c = [o[0], o[1]], f = l, d = 2; d < s; ) {
    var p = o[d - 2], g = o[d - 1], v = o[d++], O = o[d++], m = o[d++], E = o[d++], b = o[d++], T = o[d++];
    if (f <= 0) {
      c.push(v, O, m, E, b, T);
      continue;
    }
    for (var S = Math.min(f, h - 1) + 1, y = 1; y <= S; y++) {
      var A = y / S;
      nl(p, v, m, b, A, n), nl(g, O, E, T, A, a), p = n[3], g = a[3], c.push(n[1], a[1], n[2], a[2], p, g), v = n[5], O = a[5], m = n[6], E = a[6];
    }
    f -= S - 1;
  }
  return o === r ? [c, e] : [r, c];
}
function YU(r, e) {
  for (var t = r.length, i = r[t - 2], n = r[t - 1], a = [], o = 0; o < e.length; )
    a[o++] = i, a[o++] = n;
  return a;
}
function CAe(r, e) {
  for (var t, i, n, a = [], o = [], s = 0; s < Math.max(r.length, e.length); s++) {
    var l = r[s], u = e[s], h = void 0, c = void 0;
    l ? u ? (t = AAe(l, u), h = t[0], c = t[1], i = h, n = c) : (c = YU(n || l, l), h = l) : (h = YU(i || u, u), c = u), a.push(h), o.push(c);
  }
  return [a, o];
}
function HU(r) {
  for (var e = 0, t = 0, i = 0, n = r.length, a = 0, o = n - 2; a < n; o = a, a += 2) {
    var s = r[o], l = r[o + 1], u = r[a], h = r[a + 1], c = s * h - u * l;
    e += c, t += (s + u) * c, i += (l + h) * c;
  }
  return e === 0 ? [r[0] || 0, r[1] || 0] : [t / e / 3, i / e / 3, e];
}
function _Ae(r, e, t, i) {
  for (var n = (r.length - 2) / 6, a = 1 / 0, o = 0, s = r.length, l = s - 2, u = 0; u < n; u++) {
    for (var h = u * 6, c = 0, f = 0; f < s; f += 2) {
      var d = f === 0 ? h : (h + f - 2) % l + 2, p = r[d] - t[0], g = r[d + 1] - t[1], v = e[f] - i[0], O = e[f + 1] - i[1], m = v - p, E = O - g;
      c += m * m + E * E;
    }
    c < a && (a = c, o = u);
  }
  return o;
}
function IAe(r) {
  for (var e = [], t = r.length, i = 0; i < t; i += 2)
    e[i] = r[t - i - 2], e[i + 1] = r[t - i - 1];
  return e;
}
function xAe(r, e, t, i) {
  for (var n = [], a, o = 0; o < r.length; o++) {
    var s = r[o], l = e[o], u = HU(s), h = HU(l);
    a == null && (a = u[2] < 0 != h[2] < 0);
    var c = [], f = [], d = 0, p = 1 / 0, g = [], v = s.length;
    a && (s = IAe(s));
    for (var O = _Ae(s, l, u, h) * 6, m = v - 2, E = 0; E < m; E += 2) {
      var b = (O + E) % m + 2;
      c[E + 2] = s[b] - u[0], c[E + 3] = s[b + 1] - u[1];
    }
    if (c[0] = s[O] - u[0], c[1] = s[O + 1] - u[1], t > 0)
      for (var T = i / t, S = -i / 2; S <= i / 2; S += T) {
        for (var y = Math.sin(S), A = Math.cos(S), C = 0, E = 0; E < s.length; E += 2) {
          var _ = c[E], I = c[E + 1], x = l[E] - h[0], P = l[E + 1] - h[1], N = x * A - P * y, L = x * y + P * A;
          g[E] = N, g[E + 1] = L;
          var D = N - _, $ = L - I;
          C += D * D + $ * $;
        }
        if (C < p) {
          p = C, d = S;
          for (var k = 0; k < g.length; k++)
            f[k] = g[k];
        }
      }
    else
      for (var G = 0; G < v; G += 2)
        f[G] = l[G] - h[0], f[G + 1] = l[G + 1] - h[1];
    n.push({
      from: c,
      to: f,
      fromCp: u,
      toCp: h,
      rotation: -d
    });
  }
  return n;
}
function ib(r) {
  return r.__isCombineMorphing;
}
var I4 = "__mOriginal_";
function nb(r, e, t) {
  var i = I4 + e, n = r[i] || r[e];
  r[i] || (r[i] = r[e]);
  var a = t.replace, o = t.after, s = t.before;
  r[e] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), a ? u = a.apply(this, l) : u = n.apply(this, l), o && o.apply(this, l), u;
  };
}
function gp(r, e) {
  var t = I4 + e;
  r[t] && (r[e] = r[t], r[t] = null);
}
function WU(r, e) {
  for (var t = 0; t < r.length; t++)
    for (var i = r[t], n = 0; n < i.length; ) {
      var a = i[n], o = i[n + 1];
      i[n++] = e[0] * a + e[2] * o + e[4], i[n++] = e[1] * a + e[3] * o + e[5];
    }
}
function x4(r, e) {
  var t = r.getUpdatedPathProxy(), i = e.getUpdatedPathProxy(), n = CAe(s_(t), s_(i)), a = n[0], o = n[1], s = r.getComputedTransform(), l = e.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && WU(a, s), l && WU(o, l), nb(e, "updateTransform", { replace: u }), e.transform = null;
  var h = xAe(a, o, 10, Math.PI), c = [];
  nb(e, "buildPath", { replace: function(f) {
    for (var d = e.__morphT, p = 1 - d, g = [], v = 0; v < h.length; v++) {
      var O = h[v], m = O.from, E = O.to, b = O.rotation * d, T = O.fromCp, S = O.toCp, y = Math.sin(b), A = Math.cos(b);
      hm(g, T, S, d);
      for (var C = 0; C < m.length; C += 2) {
        var _ = m[C], I = m[C + 1], x = E[C], P = E[C + 1], N = _ * p + x * d, L = I * p + P * d;
        c[C] = N * A - L * y + g[0], c[C + 1] = N * y + L * A + g[1];
      }
      var D = c[0], $ = c[1];
      f.moveTo(D, $);
      for (var C = 2; C < m.length; ) {
        var x = c[C++], P = c[C++], k = c[C++], G = c[C++], F = c[C++], q = c[C++];
        D === x && $ === P && k === F && G === q ? f.lineTo(F, q) : f.bezierCurveTo(x, P, k, G, F, q), D = F, $ = q;
      }
    }
  } });
}
function Aw(r, e, t) {
  if (!r || !e)
    return e;
  var i = t.done, n = t.during;
  x4(r, e), e.__morphT = 0;
  function a() {
    gp(e, "buildPath"), gp(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
  }
  return e.animateTo({
    __morphT: 1
  }, me({
    during: function(o) {
      e.dirtyShape(), n && n(o);
    },
    done: function() {
      a(), i && i();
    }
  }, t)), e;
}
function wAe(r, e, t, i, n, a) {
  var o = 16;
  r = n === t ? 0 : Math.round(32767 * (r - t) / (n - t)), e = a === i ? 0 : Math.round(32767 * (e - i) / (a - i));
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var h = 0, c = 0;
    (r & u) > 0 && (h = 1), (e & u) > 0 && (c = 1), s += u * u * (3 * h ^ c), c === 0 && (h === 1 && (r = u - 1 - r, e = u - 1 - e), l = r, r = e, e = l);
  }
  return s;
}
function ab(r) {
  var e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0, a = Y(r, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), h = l.x + l.width / 2 + (u ? u[4] : 0), c = l.y + l.height / 2 + (u ? u[5] : 0);
    return e = Math.min(h, e), t = Math.min(c, t), i = Math.max(h, i), n = Math.max(c, n), [h, c];
  }), o = Y(a, function(s, l) {
    return {
      cp: s,
      z: wAe(s[0], s[1], e, t, i, n),
      path: r[l]
    };
  });
  return o.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function w4(r) {
  return RAe(r.path, r.count);
}
function u_() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function PAe(r, e, t) {
  var i = [];
  function n(T) {
    for (var S = 0; S < T.length; S++) {
      var y = T[S];
      ib(y) ? n(y.childrenRef()) : y instanceof Fe && i.push(y);
    }
  }
  n(r);
  var a = i.length;
  if (!a)
    return u_();
  var o = t.dividePath || w4, s = o({
    path: e,
    count: a
  });
  if (s.length !== a)
    return console.error("Invalid morphing: unmatched splitted path"), u_();
  i = ab(i), s = ab(s);
  for (var l = t.done, u = t.during, h = t.individualDelay, c = new wo(), f = 0; f < a; f++) {
    var d = i[f], p = s[f];
    p.parent = e, p.copyTransform(c), h || x4(d, p);
  }
  e.__isCombineMorphing = !0, e.childrenRef = function() {
    return s;
  };
  function g(T) {
    for (var S = 0; S < s.length; S++)
      s[S].addSelfToZr(T);
  }
  nb(e, "addSelfToZr", {
    after: function(T) {
      g(T);
    }
  }), nb(e, "removeSelfFromZr", {
    after: function(T) {
      for (var S = 0; S < s.length; S++)
        s[S].removeSelfFromZr(T);
    }
  });
  function v() {
    e.__isCombineMorphing = !1, e.__morphT = -1, e.childrenRef = null, gp(e, "addSelfToZr"), gp(e, "removeSelfFromZr");
  }
  var O = s.length;
  if (h)
    for (var m = O, E = function() {
      m--, m === 0 && (v(), l && l());
    }, f = 0; f < O; f++) {
      var b = h ? me({
        delay: (t.delay || 0) + h(f, O, i[f], s[f]),
        done: E
      }, t) : t;
      Aw(i[f], s[f], b);
    }
  else
    e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, me({
      during: function(T) {
        for (var S = 0; S < O; S++) {
          var y = s[S];
          y.__morphT = e.__morphT, y.dirtyShape();
        }
        u && u(T);
      },
      done: function() {
        v();
        for (var T = 0; T < r.length; T++)
          gp(r[T], "updateTransform");
        l && l();
      }
    }, t));
  return e.__zr && g(e.__zr), {
    fromIndividuals: i,
    toIndividuals: s,
    count: O
  };
}
function NAe(r, e, t) {
  var i = e.length, n = [], a = t.dividePath || w4;
  function o(d) {
    for (var p = 0; p < d.length; p++) {
      var g = d[p];
      ib(g) ? o(g.childrenRef()) : g instanceof Fe && n.push(g);
    }
  }
  if (ib(r)) {
    o(r.childrenRef());
    var s = n.length;
    if (s < i)
      for (var l = 0, u = s; u < i; u++)
        n.push(BI(n[l++ % s]));
    n.length = i;
  } else {
    n = a({ path: r, count: i });
    for (var h = r.getComputedTransform(), u = 0; u < n.length; u++)
      n[u].setLocalTransform(h);
    if (n.length !== i)
      return console.error("Invalid morphing: unmatched splitted path"), u_();
  }
  n = ab(n), e = ab(e);
  for (var c = t.individualDelay, u = 0; u < i; u++) {
    var f = c ? me({
      delay: (t.delay || 0) + c(u, i, n[u], e[u])
    }, t) : t;
    Aw(n[u], e[u], f);
  }
  return {
    fromIndividuals: n,
    toIndividuals: e,
    count: e.length
  };
}
function zU(r) {
  return X(r[0]);
}
function ZU(r, e) {
  for (var t = [], i = r.length, n = 0; n < i; n++)
    t.push({
      one: r[n],
      many: []
    });
  for (var n = 0; n < e.length; n++) {
    var a = e[n].length, o = void 0;
    for (o = 0; o < a; o++)
      t[o % i].many.push(e[n][o]);
  }
  for (var s = 0, n = i - 1; n >= 0; n--)
    if (!t[n].many.length) {
      var l = t[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return t;
      var a = l.length, u = Math.ceil(a / 2);
      t[n].many = l.slice(u, a), t[s].many = l.slice(0, u), s++;
    }
  return t;
}
var LAe = {
  clone: function(r) {
    for (var e = [], t = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count), i = 0; i < r.count; i++) {
      var n = BI(r.path);
      n.setStyle("opacity", t), e.push(n);
    }
    return e;
  },
  // Use the default divider
  split: null
};
function oR(r, e, t, i, n, a) {
  if (!r.length || !e.length)
    return;
  var o = Tf("update", i, n);
  if (!(o && o.duration > 0))
    return;
  var s = i.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, o), u, h;
  zU(r) && (u = r, h = e), zU(e) && (u = e, h = r);
  function c(O, m, E, b, T) {
    var S = O.many, y = O.one;
    if (S.length === 1 && !T) {
      var A = m ? S[0] : y, C = m ? y : S[0];
      if (ib(A))
        c({
          many: [A],
          one: C
        }, !0, E, b, !0);
      else {
        var _ = s ? me({
          delay: s(E, b)
        }, l) : l;
        Aw(A, C, _), a(A, C, A, C, _);
      }
    } else
      for (var I = me({
        dividePath: LAe[t],
        individualDelay: s && function($, k, G, F) {
          return s($ + E, b);
        }
      }, l), x = m ? PAe(S, y, I) : NAe(y, S, I), P = x.fromIndividuals, N = x.toIndividuals, L = P.length, D = 0; D < L; D++) {
        var _ = s ? me({
          delay: s(D, L)
        }, l) : l;
        a(P[D], N[D], m ? S[D] : O.one, m ? O.one : S[D], _);
      }
  }
  for (var f = u ? u === r : r.length > e.length, d = u ? ZU(h, u) : ZU(f ? e : r, [f ? r : e]), p = 0, g = 0; g < d.length; g++)
    p += d[g].many.length;
  for (var v = 0, g = 0; g < d.length; g++)
    c(d[g], f, v, p), v += d[g].many.length;
}
function lu(r) {
  if (!r)
    return [];
  if (X(r)) {
    for (var e = [], t = 0; t < r.length; t++)
      e.push(lu(r[t]));
    return e;
  }
  var i = [];
  return r.traverse(function(n) {
    n instanceof Fe && !n.disableMorphing && !n.invisible && !n.ignore && i.push(n);
  }), i;
}
var P4 = 1e4, DAe = at();
function MAe(r) {
  for (var e = r.dimensions, t = 0; t < e.length; t++) {
    var i = r.getDimensionInfo(e[t]);
    if (i && i.otherDims.itemGroupId === 0)
      return e[t];
  }
}
function qU(r) {
  var e = [];
  return w(r, function(t) {
    var i = t.data;
    if (!(i.count() > P4))
      for (var n = i.getIndices(), a = MAe(i), o = 0; o < n.length; o++)
        e.push({
          dataGroupId: t.dataGroupId,
          data: i,
          dim: t.dim || a,
          divide: t.divide,
          dataIndex: o
        });
  }), e;
}
function sR(r, e, t) {
  r.traverse(function(i) {
    i instanceof Fe && Ut(i, {
      style: {
        opacity: 0
      }
    }, e, {
      dataIndex: t,
      isFrom: !0
    });
  });
}
function lR(r) {
  if (r.parent) {
    var e = r.getComputedTransform();
    r.setLocalTransform(e), r.parent.remove(r);
  }
}
function tc(r) {
  r.stopAnimation(), r.isGroup && r.traverse(function(e) {
    e.stopAnimation();
  });
}
function kAe(r, e, t) {
  var i = Tf("update", t, e);
  i && r.traverse(function(n) {
    if (n instanceof qn) {
      var a = Tae(n);
      a && n.animateFrom({
        style: a
      }, i);
    }
  });
}
function QAe(r, e) {
  var t = r.length;
  if (t !== e.length)
    return !1;
  for (var i = 0; i < t; i++) {
    var n = r[i], a = e[i];
    if (n.data.getId(n.dataIndex) !== a.data.getId(a.dataIndex))
      return !1;
  }
  return !0;
}
function N4(r, e, t) {
  var i = qU(r), n = qU(e);
  function a(O, m, E, b, T) {
    (E || O) && m.animateFrom({
      style: E && E !== O ? (
        // dividingMethod like clone may override the style(opacity)
        // So extend it to raw style.
        V(V({}, E.style), O.style)
      ) : O.style
    }, T);
  }
  function o(O) {
    for (var m = 0; m < O.length; m++)
      if (O[m].dim)
        return O[m].dim;
  }
  var s = o(i), l = o(n), u = !1;
  function h(O, m) {
    return function(E) {
      var b = E.data, T = E.dataIndex;
      if (m)
        return b.getId(T);
      var S = E.dataGroupId, y = O ? s || l : l || s, A = y && b.getDimensionInfo(y), C = A && A.ordinalMeta;
      if (A) {
        var _ = b.get(A.name, T);
        return C && C.categories[_] || _ + "";
      }
      var I = b.getRawDataItem(T);
      return I && I.groupId ? I.groupId + "" : S || b.getId(T);
    };
  }
  var c = QAe(i, n), f = {};
  if (!c)
    for (var d = 0; d < n.length; d++) {
      var p = n[d], g = p.data.getItemGraphicEl(p.dataIndex);
      g && (f[g.id] = !0);
    }
  function v(O, m) {
    var E = i[m], b = n[O], T = b.data.hostModel, S = E.data.getItemGraphicEl(E.dataIndex), y = b.data.getItemGraphicEl(b.dataIndex);
    if (S === y) {
      y && kAe(y, b.dataIndex, T);
      return;
    }
    // We can't use the elements that already being morphed
    S && f[S.id] || y && (tc(y), S ? (tc(S), lR(S), u = !0, oR(lu(S), lu(y), b.divide, T, O, a)) : sR(y, T, O));
  }
  new Ho(i, n, h(!0, c), h(!1, c), null, "multiple").update(v).updateManyToOne(function(O, m) {
    var E = n[O], b = E.data, T = b.hostModel, S = b.getItemGraphicEl(E.dataIndex), y = yt(Y(m, function(A) {
      return i[A].data.getItemGraphicEl(i[A].dataIndex);
    }), function(A) {
      return A && A !== S && !f[A.id];
    });
    S && (tc(S), y.length ? (w(y, function(A) {
      tc(A), lR(A);
    }), u = !0, oR(lu(y), lu(S), E.divide, T, O, a)) : sR(S, T, E.dataIndex));
  }).updateOneToMany(function(O, m) {
    var E = i[m], b = E.data.getItemGraphicEl(E.dataIndex);
    if (!(b && f[b.id])) {
      var T = yt(Y(O, function(y) {
        return n[y].data.getItemGraphicEl(n[y].dataIndex);
      }), function(y) {
        return y && y !== b;
      }), S = n[O[0]].data.hostModel;
      T.length && (w(T, function(y) {
        return tc(y);
      }), b ? (tc(b), lR(b), u = !0, oR(
        lu(b),
        lu(T),
        E.divide,
        // Use divide on old.
        S,
        O[0],
        a
      )) : w(T, function(y) {
        return sR(y, S, O[0]);
      }));
    }
  }).updateManyToMany(function(O, m) {
    new Ho(m, O, function(E) {
      return i[E].data.getId(i[E].dataIndex);
    }, function(E) {
      return n[E].data.getId(n[E].dataIndex);
    }).update(function(E, b) {
      v(O[E], m[b]);
    }).execute();
  }).execute(), u && w(e, function(O) {
    var m = O.data, E = m.hostModel, b = E && t.getViewOfSeriesModel(E), T = Tf("update", E, 0);
    b && E.isAnimationEnabled() && T && T.duration > 0 && b.group.traverse(function(S) {
      S instanceof Fe && !S.animators.length && S.animateFrom({
        style: {
          opacity: 0
        }
      }, T);
    });
  });
}
function jU(r) {
  var e = r.getModel("universalTransition").get("seriesKey");
  return e || r.id;
}
function KU(r) {
  return X(r) ? r.sort().join(",") : r;
}
function Rs(r) {
  if (r.hostModel)
    return r.hostModel.getModel("universalTransition").get("divideShape");
}
function UAe(r, e) {
  var t = ce(), i = ce(), n = ce();
  return w(r.oldSeries, function(a, o) {
    var s = r.oldDataGroupIds[o], l = r.oldData[o], u = jU(a), h = KU(u);
    i.set(h, {
      dataGroupId: s,
      data: l
    }), X(u) && w(u, function(c) {
      n.set(c, {
        key: h,
        dataGroupId: s,
        data: l
      });
    });
  }), w(e.updatedSeries, function(a) {
    if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) {
      var o = a.get("dataGroupId"), s = a.getData(), l = jU(a), u = KU(l), h = i.get(u);
      if (h)
        t.set(u, {
          oldSeries: [{
            dataGroupId: h.dataGroupId,
            divide: Rs(h.data),
            data: h.data
          }],
          newSeries: [{
            dataGroupId: o,
            divide: Rs(s),
            data: s
          }]
        });
      else if (X(l)) {
        var c = [];
        w(l, function(p) {
          var g = i.get(p);
          g.data && c.push({
            dataGroupId: g.dataGroupId,
            divide: Rs(g.data),
            data: g.data
          });
        }), c.length && t.set(u, {
          oldSeries: c,
          newSeries: [{
            dataGroupId: o,
            data: s,
            divide: Rs(s)
          }]
        });
      } else {
        var f = n.get(l);
        if (f) {
          var d = t.get(f.key);
          d || (d = {
            oldSeries: [{
              dataGroupId: f.dataGroupId,
              data: f.data,
              divide: Rs(f.data)
            }],
            newSeries: []
          }, t.set(f.key, d)), d.newSeries.push({
            dataGroupId: o,
            data: s,
            divide: Rs(s)
          });
        }
      }
    }
  }), t;
}
function JU(r, e) {
  for (var t = 0; t < r.length; t++) {
    var i = e.seriesIndex != null && e.seriesIndex === r[t].seriesIndex || e.seriesId != null && e.seriesId === r[t].id;
    if (i)
      return t;
  }
}
function $Ae(r, e, t, i) {
  var n = [], a = [];
  w(At(r.from), function(o) {
    var s = JU(e.oldSeries, o);
    s >= 0 && n.push({
      dataGroupId: e.oldDataGroupIds[s],
      data: e.oldData[s],
      // TODO can specify divideShape in transition.
      divide: Rs(e.oldData[s]),
      dim: o.dimension
    });
  }), w(At(r.to), function(o) {
    var s = JU(t.updatedSeries, o);
    if (s >= 0) {
      var l = t.updatedSeries[s].getData();
      a.push({
        dataGroupId: e.oldDataGroupIds[s],
        data: l,
        divide: Rs(l),
        dim: o.dimension
      });
    }
  }), n.length > 0 && a.length > 0 && N4(n, a, i);
}
function GAe(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(e, t, i) {
    w(At(i.seriesTransition), function(n) {
      w(At(n.to), function(a) {
        for (var o = i.updatedSeries, s = 0; s < o.length; s++)
          (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][Tm] = !0);
      });
    });
  }), r.registerUpdateLifecycle("series:transition", function(e, t, i) {
    var n = DAe(t);
    if (n.oldSeries && i.updatedSeries && i.optionChanged) {
      var a = i.seriesTransition;
      if (a)
        w(At(a), function(d) {
          $Ae(d, n, i, t);
        });
      else {
        var o = UAe(n, i);
        w(o.keys(), function(d) {
          var p = o.get(d);
          N4(p.oldSeries, p.newSeries, t);
        });
      }
      w(i.updatedSeries, function(d) {
        d[Tm] && (d[Tm] = !1);
      });
    }
    for (var s = e.getSeries(), l = n.oldSeries = [], u = n.oldDataGroupIds = [], h = n.oldData = [], c = 0; c < s.length; c++) {
      var f = s[c].getData();
      f.count() < P4 && (l.push(s[c]), u.push(s[c].get("dataGroupId")), h.push(f));
    }
  });
}
Ve([ice]);
Ve([qhe]);
Ve([_ce, Yce, nfe, Yfe, lde, rpe, Lpe, Ege, Wge, rve, dve, OOe, XOe, ime, yme, wme, zme, nEe, OEe, AEe, UEe, ybe]);
Ve(Hbe);
Ve(CSe);
Ve(_3);
Ve(FSe);
Ve(dz);
Ve(qSe);
Ve(aTe);
Ve(oye);
Ve(xye);
Ve(rv);
Ve(Zye);
Ve(Kye);
Ve(d0e);
Ve(y0e);
Ve(P0e);
Ve($0e);
Ve(J0e);
Ve(SRe);
Ve(m4);
Ve(E4);
Ve(zRe);
Ve(R4);
Ve(A4);
Ve(JRe);
Ve(fAe);
Ve(gAe);
Ve(GAe);
Ve(vhe);
function BAe(r) {
  const [e, t] = Object.prototype.toString.call(r).replace(/[\[|\]]/gi, "").split(" ");
  return t.toLocaleLowerCase();
}
const VAe = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjkxMzg2NDA5MzAwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjY0NzQiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTY0MCA2NGwwIDE4OS4xMiAxOTIgMEw2NDkuNDcyIDY0IDY0MCA2NHpNNjQwIDY0bDAgMTg5LjEyIDE5MiAwTDY0OS40NzIgNjQgNjQwIDY0ek02OTcuNiA3NjYuNGMtMTQuMDE2IDAtMjcuMTM2LTYuNTkyLTM1LjcxMi0xNy42TDUxNy43NiA1NjcuODcyQzUwMi45MTIgNTQ4LjIyNCA1MDYuNzUyIDUyMC4yNTYgNTI2LjQgNTA1LjM0NGMxOS43NzYtMTQuNzg0IDQ3LjYxNi0xMC45NDQgNjIuNDY0IDguNzA0bDEwNS4xNTIgMTI5LjE1MiAxODkuMjQ4LTMwMy43NDRjMTIuOTkyLTIwLjg2NCA0MC41MTItMjcuMjY0IDYxLjM3Ni0xNC4yNzIgMjAuOTkyIDEyLjk5MiAyNy4yNjQgNDAuNTEyIDE0LjI3MiA2MS40NGwtMjIzLjI5NiAzNTguNzJjLTcuNzQ0IDEyLjQxNi0yMS4yNDggMjAuMjI0LTM1Ljk2OCAyMC45OTJDNjk5LjAwOCA3NjYuNCA2OTguMjQgNzY2LjQgNjk3LjYgNzY2LjR6TTc4OS43NiA3NzkuMjY0Yy0xOC44MTYgMzAuMjcyLTUxLjM5MiA0OS4zNDQtODcuMTA0IDUxLjAwOGwtMS43OTIgMC4xMjhMNjk3LjYgODMwLjRjLTMzLjY2NCAwLTY1Ljk4NC0xNi04NS43Ni00MS43MjhMNDY2Ljc1MiA2MDYuNjU2QzQzMC42NTYgNTU4Ljg0OCA0NDAgNDkwLjYyNCA0ODggNDU0LjE0NGMxOS4wMDgtMTQuMjcyIDQxLjYtMjEuODI0IDY1LjM0NC0yMS44MjQgMzMuNzI4IDAgNjYuMTEyIDE2LjA2NCA4NS4yNDggNDEuMzQ0bDQ4LjM4NCA1OS41ODRMODE5LjkwNCAzMjAgNTc2IDMyMCA1NzYgNjQgOTUuMTY4IDY0Qzc2LjYwOCA2NCA2NCA3Ni42MDggNjQgOTIuMDMybDAgODQwQzY0IDk0Ny4zOTIgNzYuNjA4IDk2MCA5Mi4wMzIgOTYwbDcxMiAwQzgxOS4zOTIgOTYwIDgzMiA5NDcuMzkyIDgzMiA5MzEuOTY4bDAtMjIwLjU0NEw3ODkuNzYgNzc5LjI2NHpNMjI0IDI1NmwxOTIgMEM0MzMuNjY0IDI1NiA0NDggMjcwLjMzNiA0NDggMjg4UzQzMy42NjQgMzIwIDQxNiAzMjBsLTE5MiAwQzIwNi4zMzYgMzIwIDE5MiAzMDUuNjY0IDE5MiAyODhTMjA2LjMzNiAyNTYgMjI0IDI1NnpNMjI0IDM4NGwxOTIgMEM0MzMuNjY0IDM4NCA0NDggMzk4LjMzNiA0NDggNDE2UzQzMy42NjQgNDQ4IDQxNiA0NDhsLTE5MiAwQzIwNi4zMzYgNDQ4IDE5MiA0MzMuNjY0IDE5MiA0MTZTMjA2LjMzNiAzODQgMjI0IDM4NHpNMjI0IDUxMmwxMjggMEMzNjkuNjY0IDUxMiAzODQgNTI2LjMzNiAzODQgNTQ0IDM4NCA1NjEuNiAzNjkuNjY0IDU3NiAzNTIgNTc2bC0xMjggMEMyMDYuMzM2IDU3NiAxOTIgNTYxLjYgMTkyIDU0NCAxOTIgNTI2LjMzNiAyMDYuMzM2IDUxMiAyMjQgNTEyek0yMjQgNjQwbDE5MiAwQzQzMy42NjQgNjQwIDQ0OCA2NTQuNCA0NDggNjcyUzQzMy42NjQgNzA0IDQxNiA3MDRsLTE5MiAwQzIwNi4zMzYgNzA0IDE5MiA2ODkuNiAxOTIgNjcyUzIwNi4zMzYgNjQwIDIyNCA2NDB6TTQ4MCA4MzJsLTI1NiAwQzIwNi4zMzYgODMyIDE5MiA4MTcuNiAxOTIgODAwUzIwNi4zMzYgNzY4IDIyNCA3NjhsMjU2IDBDNDk3LjY2NCA3NjggNTEyIDc4Mi40IDUxMiA4MDBTNDk3LjY2NCA4MzIgNDgwIDgzMnoiIGZpbGw9IiMwMTAxMDEiIHAtaWQ9IjY0NzUiPjwvcGF0aD48L3N2Zz4=", FAe = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjkxMzg2OTA3NTE5IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9Ijc0NzkiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTYwMS4xNTIgNzA4LjI4OCA0MDAgNTY4IDM0NCA1NjhsMCAxMTItMjI0IDAgMCAxMTIgMjI0IDAgMCAxMTJMNDAwIDkwNGwyMDEuMTUyLTE0MC4yODhDNjI0IDc0OS41MDQgNjI0IDcyMi40OTYgNjAxLjE1MiA3MDguMjg4TDYwMS4xNTIgNzA4LjI4OHpNODkxLjI2NCAzMzEuMiA2MzguNjU2IDc2Ljg2NEM2MzAuNTI4IDY4LjYwOCA2MTkuNDU2IDY0IDYwNy45MzYgNjRMMjMyIDY0QzE5Ni4wMzIgNjQgMTc2IDgzLjcxMiAxNzYgMTIwTDE3NiA1MTIgMjg4IDUxMiAyODggMTc2bDI4MCAwIDAgMTY4YzAgMjQuMTkyIDMyIDU2IDU2IDU2bDE2OCAwIDAuNzY4IDQ0OEw2MjQgODQ4IDYyNCA5NjBsMjI0IDBjMzUuOTY4IDAgNTYtMTkuNzEyIDU2LTU2TDkwNCAzNjIuMTc2QzkwNCAzNTAuNTI4IDg5OS4zOTIgMzM5LjM5MiA4OTEuMjY0IDMzMS4yTDg5MS4yNjQgMzMxLjJ6IiBwLWlkPSI3NDgwIj48L3BhdGg+PC9zdmc+";
class Rt {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      n,
      1
      /* Open.From */
    ), Va.from(n, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    let i = [];
    return this.decompose(e, t, i, 0), Va.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), n = new vp(this), a = new vp(e);
    for (let o = t, s = t; ; ) {
      if (n.next(o), a.next(o), o = 0, n.lineBreak != a.lineBreak || n.done != a.done || n.value != a.value)
        return !1;
      if (s += n.value.length, n.done || s >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new vp(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new L4(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let n = this.line(e).from;
      i = this.iterRange(n, Math.max(n, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new D4(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Rt.empty : e.length <= 32 ? new sr(e) : Va.from(sr.split(e, []));
  }
}
class sr extends Rt {
  constructor(e, t = XAe(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, n) {
    for (let a = 0; ; a++) {
      let o = this.text[a], s = n + o.length;
      if ((t ? i : s) >= e)
        return new YAe(n, s, i, o);
      n = s + 1, i++;
    }
  }
  decompose(e, t, i, n) {
    let a = e <= 0 && t >= this.length ? this : new sr(e$(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (n & 1) {
      let o = i.pop(), s = xm(a.text, o.text.slice(), 0, a.length);
      if (s.length <= 32)
        i.push(new sr(s, o.length + a.length));
      else {
        let l = s.length >> 1;
        i.push(new sr(s.slice(0, l)), new sr(s.slice(l)));
      }
    } else
      i.push(a);
  }
  replace(e, t, i) {
    if (!(i instanceof sr))
      return super.replace(e, t, i);
    let n = xm(this.text, xm(i.text, e$(this.text, 0, e)), t), a = this.length + i.length - (t - e);
    return n.length <= 32 ? new sr(n, a) : Va.from(sr.split(n, []), a);
  }
  sliceString(e, t = this.length, i = `
`) {
    let n = "";
    for (let a = 0, o = 0; a <= t && o < this.text.length; o++) {
      let s = this.text[o], l = a + s.length;
      a > e && o && (n += i), e < l && t > a && (n += s.slice(Math.max(0, e - a), t - a)), a = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], n = -1;
    for (let a of e)
      i.push(a), n += a.length + 1, i.length == 32 && (t.push(new sr(i, n)), i = [], n = -1);
    return n > -1 && t.push(new sr(i, n)), t;
  }
}
class Va extends Rt {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, n) {
    for (let a = 0; ; a++) {
      let o = this.children[a], s = n + o.length, l = i + o.lines - 1;
      if ((t ? l : s) >= e)
        return o.lineInner(e, t, i, n);
      n = s + 1, i = l + 1;
    }
  }
  decompose(e, t, i, n) {
    for (let a = 0, o = 0; o <= t && a < this.children.length; a++) {
      let s = this.children[a], l = o + s.length;
      if (e <= l && t >= o) {
        let u = n & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0));
        o >= e && l <= t && !u ? i.push(s) : s.decompose(e - o, t - o, i, u);
      }
      o = l + 1;
    }
  }
  replace(e, t, i) {
    if (i.lines < this.lines)
      for (let n = 0, a = 0; n < this.children.length; n++) {
        let o = this.children[n], s = a + o.length;
        if (e >= a && t <= s) {
          let l = o.replace(e - a, t - a, i), u = this.lines - o.lines + l.lines;
          if (l.lines < u >> 5 - 1 && l.lines > u >> 5 + 1) {
            let h = this.children.slice();
            return h[n] = l, new Va(h, this.length - (t - e) + i.length);
          }
          return super.replace(a, s, l);
        }
        a = s + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    let n = "";
    for (let a = 0, o = 0; a < this.children.length && o <= t; a++) {
      let s = this.children[a], l = o + s.length;
      o > e && a && (n += i), e < l && t > o && (n += s.sliceString(e - o, t - o, i)), o = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Va))
      return 0;
    let i = 0, [n, a, o, s] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += t, a += t) {
      if (n == o || a == s)
        return i;
      let l = this.children[n], u = e.children[a];
      if (l != u)
        return i + l.scanIdentical(u, t);
      i += l.length + 1;
    }
  }
  static from(e, t = e.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let d of e)
      i += d.lines;
    if (i < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new sr(d, t);
    }
    let n = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), a = n << 1, o = n >> 1, s = [], l = 0, u = -1, h = [];
    function c(d) {
      let p;
      if (d.lines > a && d instanceof Va)
        for (let g of d.children)
          c(g);
      else
        d.lines > o && (l > o || !l) ? (f(), s.push(d)) : d instanceof sr && l && (p = h[h.length - 1]) instanceof sr && d.lines + p.lines <= 32 ? (l += d.lines, u += d.length + 1, h[h.length - 1] = new sr(p.text.concat(d.text), p.length + 1 + d.length)) : (l + d.lines > n && f(), l += d.lines, u += d.length + 1, h.push(d));
    }
    function f() {
      l != 0 && (s.push(h.length == 1 ? h[0] : Va.from(h, u)), u = -1, l = h.length = 0);
    }
    for (let d of e)
      c(d);
    return f(), s.length == 1 ? s[0] : new Va(s, t);
  }
}
Rt.empty = /* @__PURE__ */ new sr([""], 0);
function XAe(r) {
  let e = -1;
  for (let t of r)
    e += t.length + 1;
  return e;
}
function xm(r, e, t = 0, i = 1e9) {
  for (let n = 0, a = 0, o = !0; a < r.length && n <= i; a++) {
    let s = r[a], l = n + s.length;
    l >= t && (l > i && (s = s.slice(0, i - n)), n < t && (s = s.slice(t - n)), o ? (e[e.length - 1] += s, o = !1) : e.push(s)), n = l + 1;
  }
  return e;
}
function e$(r, e, t) {
  return xm(r, [""], e, t);
}
class vp {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof sr ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], a = this.offsets[i], o = a >> 1, s = n instanceof sr ? n.text.length : n.children.length;
      if (o == (t > 0 ? s : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((a & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (n instanceof sr) {
        let l = n.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = n.children[o + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof sr ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class L4 {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new vp(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * t, this.value = n.length <= i ? n : t < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class D4 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: n } = this.inner.next(e);
    return t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Rt.prototype[Symbol.iterator] = function() {
  return this.iter();
}, vp.prototype[Symbol.iterator] = L4.prototype[Symbol.iterator] = D4.prototype[Symbol.iterator] = function() {
  return this;
});
class YAe {
  /**
  @internal
  */
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.number = i, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
let Mc = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((r) => r ? parseInt(r, 36) : 1);
for (let r = 1; r < Mc.length; r++)
  Mc[r] += Mc[r - 1];
function HAe(r) {
  for (let e = 1; e < Mc.length; e += 2)
    if (Mc[e] > r)
      return Mc[e - 1] <= r;
  return !1;
}
function t$(r) {
  return r >= 127462 && r <= 127487;
}
const r$ = 8205;
function li(r, e, t = !0, i = !0) {
  return (t ? M4 : WAe)(r, e, i);
}
function M4(r, e, t) {
  if (e == r.length)
    return e;
  e && k4(r.charCodeAt(e)) && Q4(r.charCodeAt(e - 1)) && e--;
  let i = Fr(r, e);
  for (e += kn(i); e < r.length; ) {
    let n = Fr(r, e);
    if (i == r$ || n == r$ || t && HAe(n))
      e += kn(n), i = n;
    else if (t$(n)) {
      let a = 0, o = e - 2;
      for (; o >= 0 && t$(Fr(r, o)); )
        a++, o -= 2;
      if (a % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function WAe(r, e, t) {
  for (; e > 0; ) {
    let i = M4(r, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function k4(r) {
  return r >= 56320 && r < 57344;
}
function Q4(r) {
  return r >= 55296 && r < 56320;
}
function Fr(r, e) {
  let t = r.charCodeAt(e);
  if (!Q4(t) || e + 1 == r.length)
    return t;
  let i = r.charCodeAt(e + 1);
  return k4(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function Cw(r) {
  return r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
}
function kn(r) {
  return r < 65536 ? 1 : 2;
}
const h_ = /\r\n?|\n/;
var Yr = /* @__PURE__ */ function(r) {
  return r[r.Simple = 0] = "Simple", r[r.TrackDel = 1] = "TrackDel", r[r.TrackBefore = 2] = "TrackBefore", r[r.TrackAfter = 3] = "TrackAfter", r;
}(Yr || (Yr = {}));
class eo {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, n = 0; t < this.sections.length; ) {
      let a = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(i, n, a), n += a) : n += o, i += a;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    c_(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      n < 0 ? e.push(i, n) : e.push(n, i);
    }
    return new eo(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : U4(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : f_(this, e, t);
  }
  mapPos(e, t = -1, i = Yr.Simple) {
    let n = 0, a = 0;
    for (let o = 0; o < this.sections.length; ) {
      let s = this.sections[o++], l = this.sections[o++], u = n + s;
      if (l < 0) {
        if (u > e)
          return a + (e - n);
        a += s;
      } else {
        if (i != Yr.Simple && u >= e && (i == Yr.TrackDel && n < e && u > e || i == Yr.TrackBefore && n < e || i == Yr.TrackAfter && u > e))
          return null;
        if (u > e || u == e && t < 0 && !s)
          return e == n || t < 0 ? a : a + l;
        a += l;
      }
      n = u;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return a;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, n = 0; i < this.sections.length && n <= t; ) {
      let a = this.sections[i++], o = this.sections[i++], s = n + a;
      if (o >= 0 && n <= t && s >= e)
        return n < e && s > t ? "cover" : !0;
      n = s;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      e += (e ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new eo(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new eo(e);
  }
}
class br extends eo {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return c_(this, (t, i, n, a, o) => e = e.replace(n, n + (i - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return f_(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let n = 0, a = 0; n < t.length; n += 2) {
      let o = t[n], s = t[n + 1];
      if (s >= 0) {
        t[n] = s, t[n + 1] = o;
        let l = n >> 1;
        for (; i.length < l; )
          i.push(Rt.empty);
        i.push(o ? e.slice(a, a + o) : Rt.empty);
      }
      a += o;
    }
    return new br(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : U4(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : f_(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    c_(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return eo.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], n = [], a = new dg(this);
    e:
      for (let o = 0, s = 0; ; ) {
        let l = o == e.length ? 1e9 : e[o++];
        for (; s < l || s == l && a.len == 0; ) {
          if (a.done)
            break e;
          let h = Math.min(a.len, l - s);
          ni(n, h, -1);
          let c = a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0;
          ni(t, h, c), c > 0 && Us(i, t, a.text), a.forward(h), s += h;
        }
        let u = e[o++];
        for (; s < u; ) {
          if (a.done)
            break e;
          let h = Math.min(a.len, u - s);
          ni(t, h, -1), ni(n, h, a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0), a.forward(h), s += h;
        }
      }
    return {
      changes: new br(t, i),
      filtered: eo.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], n = this.sections[t + 1];
      n < 0 ? e.push(i) : n == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let n = [], a = [], o = 0, s = null;
    function l(h = !1) {
      if (!h && !n.length)
        return;
      o < t && ni(n, t - o, -1);
      let c = new br(n, a);
      s = s ? s.compose(c.map(s)) : c, n = [], a = [], o = 0;
    }
    function u(h) {
      if (Array.isArray(h))
        for (let c of h)
          u(c);
      else if (h instanceof br) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        l(), s = s ? s.compose(h.map(s)) : h;
      } else {
        let { from: c, to: f = c, insert: d } = h;
        if (c > f || c < 0 || f > t)
          throw new RangeError(`Invalid change range ${c} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? Rt.of(d.split(i || h_)) : d : Rt.empty, g = p.length;
        if (c == f && g == 0)
          return;
        c < o && l(), c > o && ni(n, c - o, -1), ni(n, f - c, g), Us(a, n, p), o = f;
      }
    }
    return u(e), l(!s), s;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new br(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let n = 0; n < e.length; n++) {
      let a = e[n];
      if (typeof a == "number")
        t.push(a, -1);
      else {
        if (!Array.isArray(a) || typeof a[0] != "number" || a.some((o, s) => s && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (a.length == 1)
          t.push(a[0], 0);
        else {
          for (; i.length < n; )
            i.push(Rt.empty);
          i[n] = Rt.of(a.slice(1)), t.push(a[0], i[n].length);
        }
      }
    }
    return new br(t, i);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new br(e, t);
  }
}
function ni(r, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let n = r.length - 2;
  n >= 0 && t <= 0 && t == r[n + 1] ? r[n] += e : e == 0 && r[n] == 0 ? r[n + 1] += t : i ? (r[n] += e, r[n + 1] += t) : r.push(e, t);
}
function Us(r, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < r.length)
    r[r.length - 1] = r[r.length - 1].append(t);
  else {
    for (; r.length < i; )
      r.push(Rt.empty);
    r.push(t);
  }
}
function c_(r, e, t) {
  let i = r.inserted;
  for (let n = 0, a = 0, o = 0; o < r.sections.length; ) {
    let s = r.sections[o++], l = r.sections[o++];
    if (l < 0)
      n += s, a += s;
    else {
      let u = n, h = a, c = Rt.empty;
      for (; u += s, h += l, l && i && (c = c.append(i[o - 2 >> 1])), !(t || o == r.sections.length || r.sections[o + 1] < 0); )
        s = r.sections[o++], l = r.sections[o++];
      e(n, u, a, h, c), n = u, a = h;
    }
  }
}
function f_(r, e, t, i = !1) {
  let n = [], a = i ? [] : null, o = new dg(r), s = new dg(e);
  for (let l = -1; ; )
    if (o.ins == -1 && s.ins == -1) {
      let u = Math.min(o.len, s.len);
      ni(n, u, -1), o.forward(u), s.forward(u);
    } else if (s.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (s.len < o.len || s.len == o.len && !t))) {
      let u = s.len;
      for (ni(n, s.ins, -1); u; ) {
        let h = Math.min(o.len, u);
        o.ins >= 0 && l < o.i && o.len <= h && (ni(n, 0, o.ins), a && Us(a, n, o.text), l = o.i), o.forward(h), u -= h;
      }
      s.next();
    } else if (o.ins >= 0) {
      let u = 0, h = o.len;
      for (; h; )
        if (s.ins == -1) {
          let c = Math.min(h, s.len);
          u += c, h -= c, s.forward(c);
        } else if (s.ins == 0 && s.len < h)
          h -= s.len, s.next();
        else
          break;
      ni(n, u, l < o.i ? o.ins : 0), a && l < o.i && Us(a, n, o.text), l = o.i, o.forward(o.len - h);
    } else {
      if (o.done && s.done)
        return a ? br.createSet(n, a) : eo.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function U4(r, e, t = !1) {
  let i = [], n = t ? [] : null, a = new dg(r), o = new dg(e);
  for (let s = !1; ; ) {
    if (a.done && o.done)
      return n ? br.createSet(i, n) : eo.create(i);
    if (a.ins == 0)
      ni(i, a.len, 0, s), a.next();
    else if (o.len == 0 && !o.done)
      ni(i, 0, o.ins, s), n && Us(n, i, o.text), o.next();
    else {
      if (a.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(a.len2, o.len), u = i.length;
        if (a.ins == -1) {
          let h = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          ni(i, l, h, s), n && h && Us(n, i, o.text);
        } else
          o.ins == -1 ? (ni(i, a.off ? 0 : a.len, l, s), n && Us(n, i, a.textBit(l))) : (ni(i, a.off ? 0 : a.len, o.off ? 0 : o.ins, s), n && !o.off && Us(n, i, o.text));
        s = (a.ins > l || o.ins >= 0 && o.len > l) && (s || i.length > u), a.forward2(l), o.forward(l);
      }
    }
  }
}
class dg {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? Rt.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? Rt.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class Iu {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, n;
    return this.empty ? i = n = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new Iu(i, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return z.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return z.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return z.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Iu(e, t, i);
  }
}
class z {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : z.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new z([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return z.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, z.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new z(e.ranges.map((t) => Iu.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new z([z.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < e.length; n++) {
      let a = e[n];
      if (a.empty ? a.from <= i : a.from < i)
        return z.normalized(e.slice(), t);
      i = a.to;
    }
    return new z(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, n) {
    return Iu.create(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (i == null ? 3 : Math.min(2, i)) | (n ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i, n) {
    let a = (i ?? 33554431) << 5 | (n == null ? 3 : Math.min(2, n));
    return t < e ? Iu.create(t, e, 24 | a) : Iu.create(e, t, (t > e ? 4 : 0) | a);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((n, a) => n.from - a.from), t = e.indexOf(i);
    for (let n = 1; n < e.length; n++) {
      let a = e[n], o = e[n - 1];
      if (a.empty ? a.from <= o.to : a.from < o.to) {
        let s = o.from, l = Math.max(a.to, o.to);
        n <= t && t--, e.splice(--n, 2, a.anchor > a.head ? z.range(l, s) : z.range(s, l));
      }
    }
    return new z(e, t);
  }
}
function $4(r, e) {
  for (let t of r.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let _w = 0;
class Re {
  constructor(e, t, i, n, a) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = n, this.id = _w++, this.default = e([]), this.extensions = typeof a == "function" ? a(this) : a;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Re(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : Iw), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new wm([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new wm(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new wm(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function Iw(r, e) {
  return r == e || r.length == e.length && r.every((t, i) => t === e[i]);
}
class wm {
  constructor(e, t, i, n) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = n, this.id = _w++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, n = this.facet.compareInput, a = this.id, o = e[a] >> 1, s = this.type == 2, l = !1, u = !1, h = [];
    for (let c of this.dependencies)
      c == "doc" ? l = !0 : c == "selection" ? u = !0 : ((t = e[c.id]) !== null && t !== void 0 ? t : 1) & 1 || h.push(e[c.id]);
    return {
      create(c) {
        return c.values[o] = i(c), 1;
      },
      update(c, f) {
        if (l && f.docChanged || u && (f.docChanged || f.selection) || d_(c, h)) {
          let d = i(c);
          if (s ? !i$(d, c.values[o], n) : !n(d, c.values[o]))
            return c.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (c, f) => {
        let d, p = f.config.address[a];
        if (p != null) {
          let g = sb(f, p);
          if (this.dependencies.every((v) => v instanceof Re ? f.facet(v) === c.facet(v) : v instanceof kr ? f.field(v, !1) == c.field(v, !1) : !0) || (s ? i$(d = i(c), g, n) : n(d = i(c), g)))
            return c.values[o] = g, 0;
        } else
          d = i(c);
        return c.values[o] = d, 1;
      }
    };
  }
}
function i$(r, e, t) {
  if (r.length != e.length)
    return !1;
  for (let i = 0; i < r.length; i++)
    if (!t(r[i], e[i]))
      return !1;
  return !0;
}
function d_(r, e) {
  let t = !1;
  for (let i of e)
    Op(r, i) & 1 && (t = !0);
  return t;
}
function zAe(r, e, t) {
  let i = t.map((l) => r[l.id]), n = t.map((l) => l.type), a = i.filter((l) => !(l & 1)), o = r[e.id] >> 1;
  function s(l) {
    let u = [];
    for (let h = 0; h < i.length; h++) {
      let c = sb(l, i[h]);
      if (n[h] == 2)
        for (let f of c)
          u.push(f);
      else
        u.push(c);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of i)
        Op(l, u);
      return l.values[o] = s(l), 1;
    },
    update(l, u) {
      if (!d_(l, a))
        return 0;
      let h = s(l);
      return e.compare(h, l.values[o]) ? 0 : (l.values[o] = h, 1);
    },
    reconfigure(l, u) {
      let h = d_(l, i), c = u.config.facets[e.id], f = u.facet(e);
      if (c && !h && Iw(t, c))
        return l.values[o] = f, 0;
      let d = s(l);
      return e.compare(d, f) ? (l.values[o] = f, 0) : (l.values[o] = d, 1);
    }
  };
}
const n$ = /* @__PURE__ */ Re.define({ static: !0 });
class kr {
  constructor(e, t, i, n, a) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = n, this.spec = a, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new kr(_w++, e.create, e.update, e.compare || ((i, n) => i === n), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(n$).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, n) => {
        let a = i.values[t], o = this.updateF(a, n);
        return this.compareF(a, o) ? 0 : (i.values[t] = o, 1);
      },
      reconfigure: (i, n) => n.config.address[this.id] != null ? (i.values[t] = n.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, n$.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const vu = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function bd(r) {
  return (e) => new G4(e, r);
}
const _h = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ bd(vu.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ bd(vu.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ bd(vu.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ bd(vu.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ bd(vu.lowest)
};
class G4 {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class KS {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new p_(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return KS.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class p_ {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class ob {
  constructor(e, t, i, n, a, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = n, this.staticValues = a, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let n = [], a = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of ZAe(e, t, o))
      f instanceof kr ? n.push(f) : (a[f.facet.id] || (a[f.facet.id] = [])).push(f);
    let s = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let f of n)
      s[f.id] = u.length << 1, u.push((d) => f.slot(d));
    let h = i == null ? void 0 : i.config.facets;
    for (let f in a) {
      let d = a[f], p = d[0].facet, g = h && h[f] || [];
      if (d.every(
        (v) => v.type == 0
        /* Provider.Static */
      ))
        if (s[p.id] = l.length << 1 | 1, Iw(g, d))
          l.push(i.facet(p));
        else {
          let v = p.combine(d.map((O) => O.value));
          l.push(i && p.compare(v, i.facet(p)) ? i.facet(p) : v);
        }
      else {
        for (let v of d)
          v.type == 0 ? (s[v.id] = l.length << 1 | 1, l.push(v.value)) : (s[v.id] = u.length << 1, u.push((O) => v.dynamicSlot(O)));
        s[p.id] = u.length << 1, u.push((v) => zAe(v, p, d));
      }
    }
    let c = u.map((f) => f(s));
    return new ob(e, o, c, s, l, a);
  }
}
function ZAe(r, e, t) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function a(o, s) {
    let l = n.get(o);
    if (l != null) {
      if (l <= s)
        return;
      let u = i[l].indexOf(o);
      u > -1 && i[l].splice(u, 1), o instanceof p_ && t.delete(o.compartment);
    }
    if (n.set(o, s), Array.isArray(o))
      for (let u of o)
        a(u, s);
    else if (o instanceof p_) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(o.compartment) || o.inner;
      t.set(o.compartment, u), a(u, s);
    } else if (o instanceof G4)
      a(o.inner, o.prec);
    else if (o instanceof kr)
      i[s].push(o), o.provides && a(o.provides, s);
    else if (o instanceof wm)
      i[s].push(o), o.facet.extensions && a(o.facet.extensions, vu.default);
    else {
      let u = o.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      a(u, s);
    }
  }
  return a(r, vu.default), i.reduce((o, s) => o.concat(s));
}
function Op(r, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = r.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  r.status[t] = 4;
  let n = r.computeSlot(r, r.config.dynamicSlots[t]);
  return r.status[t] = 2 | n;
}
function sb(r, e) {
  return e & 1 ? r.config.staticValues[e >> 1] : r.values[e >> 1];
}
const B4 = /* @__PURE__ */ Re.define(), V4 = /* @__PURE__ */ Re.define({
  combine: (r) => r.some((e) => e),
  static: !0
}), F4 = /* @__PURE__ */ Re.define({
  combine: (r) => r.length ? r[0] : void 0,
  static: !0
}), X4 = /* @__PURE__ */ Re.define(), Y4 = /* @__PURE__ */ Re.define(), H4 = /* @__PURE__ */ Re.define(), W4 = /* @__PURE__ */ Re.define({
  combine: (r) => r.length ? r[0] : !1
});
class is {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new qAe();
  }
}
class qAe {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new is(this, e);
  }
}
class jAe {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new rt(this, e);
  }
}
class rt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new rt(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new jAe(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let n of e) {
      let a = n.map(t);
      a && i.push(a);
    }
    return i;
  }
}
rt.reconfigure = /* @__PURE__ */ rt.define();
rt.appendConfig = /* @__PURE__ */ rt.define();
class Rr {
  constructor(e, t, i, n, a, o) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = n, this.annotations = a, this.scrollIntoView = o, this._doc = null, this._state = null, i && $4(i, t.newLength), a.some((s) => s.type == Rr.time) || (this.annotations = a.concat(Rr.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, i, n, a, o) {
    return new Rr(e, t, i, n, a, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(Rr.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
Rr.time = /* @__PURE__ */ is.define();
Rr.userEvent = /* @__PURE__ */ is.define();
Rr.addToHistory = /* @__PURE__ */ is.define();
Rr.remote = /* @__PURE__ */ is.define();
function KAe(r, e) {
  let t = [];
  for (let i = 0, n = 0; ; ) {
    let a, o;
    if (i < r.length && (n == e.length || e[n] >= r[i]))
      a = r[i++], o = r[i++];
    else if (n < e.length)
      a = e[n++], o = e[n++];
    else
      return t;
    !t.length || t[t.length - 1] < a ? t.push(a, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function z4(r, e, t) {
  var i;
  let n, a, o;
  return t ? (n = e.changes, a = br.empty(e.changes.length), o = r.changes.compose(e.changes)) : (n = e.changes.map(r.changes), a = r.changes.mapDesc(e.changes, !0), o = r.changes.compose(n)), {
    changes: o,
    selection: e.selection ? e.selection.map(a) : (i = r.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: rt.mapEffects(r.effects, n).concat(rt.mapEffects(e.effects, a)),
    annotations: r.annotations.length ? r.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: r.scrollIntoView || e.scrollIntoView
  };
}
function g_(r, e, t) {
  let i = e.selection, n = kc(e.annotations);
  return e.userEvent && (n = n.concat(Rr.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof br ? e.changes : br.of(e.changes || [], t, r.facet(F4)),
    selection: i && (i instanceof z ? i : z.single(i.anchor, i.head)),
    effects: kc(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function Z4(r, e, t) {
  let i = g_(r, e.length ? e[0] : {}, r.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let a = 1; a < e.length; a++) {
    e[a].filter === !1 && (t = !1);
    let o = !!e[a].sequential;
    i = z4(i, g_(r, e[a], o ? i.changes.newLength : r.doc.length), o);
  }
  let n = Rr.create(r, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return eCe(t ? JAe(n) : n);
}
function JAe(r) {
  let e = r.startState, t = !0;
  for (let n of e.facet(X4)) {
    let a = n(r);
    if (a === !1) {
      t = !1;
      break;
    }
    Array.isArray(a) && (t = t === !0 ? a : KAe(t, a));
  }
  if (t !== !0) {
    let n, a;
    if (t === !1)
      a = r.changes.invertedDesc, n = br.empty(e.doc.length);
    else {
      let o = r.changes.filter(t);
      n = o.changes, a = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    r = Rr.create(e, n, r.selection && r.selection.map(a), rt.mapEffects(r.effects, a), r.annotations, r.scrollIntoView);
  }
  let i = e.facet(Y4);
  for (let n = i.length - 1; n >= 0; n--) {
    let a = i[n](r);
    a instanceof Rr ? r = a : Array.isArray(a) && a.length == 1 && a[0] instanceof Rr ? r = a[0] : r = Z4(e, kc(a), !1);
  }
  return r;
}
function eCe(r) {
  let e = r.startState, t = e.facet(H4), i = r;
  for (let n = t.length - 1; n >= 0; n--) {
    let a = t[n](r);
    a && Object.keys(a).length && (i = z4(i, g_(e, a, r.changes.newLength), !0));
  }
  return i == r ? r : Rr.create(e, r.changes, r.selection, i.effects, i.annotations, i.scrollIntoView);
}
const tCe = [];
function kc(r) {
  return r == null ? tCe : Array.isArray(r) ? r : [r];
}
var Pt = /* @__PURE__ */ function(r) {
  return r[r.Word = 0] = "Word", r[r.Space = 1] = "Space", r[r.Other = 2] = "Other", r;
}(Pt || (Pt = {}));
const rCe = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let v_;
try {
  v_ = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function iCe(r) {
  if (v_)
    return v_.test(r);
  for (let e = 0; e < r.length; e++) {
    let t = r[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || rCe.test(t)))
      return !0;
  }
  return !1;
}
function nCe(r) {
  return (e) => {
    if (!/\S/.test(e))
      return Pt.Space;
    if (iCe(e))
      return Pt.Word;
    for (let t = 0; t < r.length; t++)
      if (e.indexOf(r[t]) > -1)
        return Pt.Word;
    return Pt.Other;
  };
}
class St {
  constructor(e, t, i, n, a, o) {
    this.config = e, this.doc = t, this.selection = i, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = a, o && (o._state = this);
    for (let s = 0; s < this.config.dynamicSlots.length; s++)
      Op(this, s << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Op(this, i), sb(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return Z4(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: n } = t;
    for (let o of e.effects)
      o.is(KS.reconfigure) ? (t && (n = /* @__PURE__ */ new Map(), t.compartments.forEach((s, l) => n.set(l, s)), t = null), n.set(o.value.compartment, o.value.extension)) : o.is(rt.reconfigure) ? (t = null, i = o.value) : o.is(rt.appendConfig) && (t = null, i = kc(i).concat(o.value));
    let a;
    t ? a = e.startState.values.slice() : (t = ob.resolve(i, n, this), a = new St(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (s, l) => l.reconfigure(s, this), null).values), new St(t, e.newDoc, e.newSelection, a, (o, s) => s.update(o, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: z.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), n = this.changes(i.changes), a = [i.range], o = kc(i.effects);
    for (let s = 1; s < t.ranges.length; s++) {
      let l = e(t.ranges[s]), u = this.changes(l.changes), h = u.map(n);
      for (let f = 0; f < s; f++)
        a[f] = a[f].map(h);
      let c = n.mapDesc(u, !0);
      a.push(l.range.map(c)), n = n.compose(h), o = rt.mapEffects(o, h).concat(rt.mapEffects(kc(l.effects), c));
    }
    return {
      changes: n,
      selection: z.create(a, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof br ? e : br.of(e, this.doc.length, this.facet(St.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Rt.of(e.split(this.facet(St.lineSeparator) || h_));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Op(this, t), sb(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let n = e[i];
        n instanceof kr && this.config.address[n.id] != null && (t[i] = n.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let a in i)
        if (Object.prototype.hasOwnProperty.call(e, a)) {
          let o = i[a], s = e[a];
          n.push(o.init((l) => o.spec.fromJSON(s, l)));
        }
    }
    return St.create({
      doc: e.doc,
      selection: z.fromJSON(e.selection),
      extensions: t.extensions ? n.concat([t.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = ob.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof Rt ? e.doc : Rt.of((e.doc || "").split(t.staticFacet(St.lineSeparator) || h_)), n = e.selection ? e.selection instanceof z ? e.selection : z.single(e.selection.anchor, e.selection.head) : z.single(0);
    return $4(n, i.length), t.staticFacet(V4) || (n = n.asSingle()), new St(t, i, n, t.dynamicSlots.map(() => null), (a, o) => o.create(a), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(St.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(St.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(W4);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let i of this.facet(St.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let a = +(n || 1);
      return !a || a > t.length ? i : t[a - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, i = -1) {
    let n = [];
    for (let a of this.facet(B4))
      for (let o of a(this, t, i))
        Object.prototype.hasOwnProperty.call(o, e) && n.push(o[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return nCe(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: n } = this.doc.lineAt(e), a = this.charCategorizer(e), o = e - i, s = e - i;
    for (; o > 0; ) {
      let l = li(t, o, !1);
      if (a(t.slice(l, o)) != Pt.Word)
        break;
      o = l;
    }
    for (; s < n; ) {
      let l = li(t, s);
      if (a(t.slice(s, l)) != Pt.Word)
        break;
      s = l;
    }
    return o == s ? null : z.range(o + i, s + i);
  }
}
St.allowMultipleSelections = V4;
St.tabSize = /* @__PURE__ */ Re.define({
  combine: (r) => r.length ? r[0] : 4
});
St.lineSeparator = F4;
St.readOnly = W4;
St.phrases = /* @__PURE__ */ Re.define({
  compare(r, e) {
    let t = Object.keys(r), i = Object.keys(e);
    return t.length == i.length && t.every((n) => r[n] == e[n]);
  }
});
St.languageData = B4;
St.changeFilter = X4;
St.transactionFilter = Y4;
St.transactionExtender = H4;
KS.reconfigure = /* @__PURE__ */ rt.define();
function mo(r, e, t = {}) {
  let i = {};
  for (let n of r)
    for (let a of Object.keys(n)) {
      let o = n[a], s = i[a];
      if (s === void 0)
        i[a] = o;
      else if (!(s === o || o === void 0))
        if (Object.hasOwnProperty.call(t, a))
          i[a] = t[a](s, o);
        else
          throw new Error("Config merge conflict for field " + a);
    }
  for (let n in e)
    i[n] === void 0 && (i[n] = e[n]);
  return i;
}
class sh {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return O_.create(e, t, this);
  }
}
sh.prototype.startSide = sh.prototype.endSide = 0;
sh.prototype.point = !1;
sh.prototype.mapMode = Yr.TrackDel;
let O_ = class q4 {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new q4(e, t, i);
  }
};
function m_(r, e) {
  return r.from - e.from || r.value.startSide - e.value.startSide;
}
class xw {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, n = 0) {
    let a = i ? this.to : this.from;
    for (let o = n, s = a.length; ; ) {
      if (o == s)
        return o;
      let l = o + s >> 1, u = a[l] - e || (i ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == o)
        return u >= 0 ? o : s;
      u >= 0 ? s = l : o = l + 1;
    }
  }
  between(e, t, i, n) {
    for (let a = this.findIndex(t, -1e9, !0), o = this.findIndex(i, 1e9, !1, a); a < o; a++)
      if (n(this.from[a] + e, this.to[a] + e, this.value[a]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], n = [], a = [], o = -1, s = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], h = this.from[l] + e, c = this.to[l] + e, f, d;
      if (h == c) {
        let p = t.mapPos(h, u.startSide, u.mapMode);
        if (p == null || (f = d = p, u.startSide != u.endSide && (d = t.mapPos(h, u.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(h, u.startSide), d = t.mapPos(c, u.endSide), f > d || f == d && u.startSide > 0 && u.endSide <= 0)
        continue;
      (d - f || u.endSide - u.startSide) < 0 || (o < 0 && (o = f), u.point && (s = Math.max(s, d - f)), i.push(u), n.push(f - o), a.push(d - o));
    }
    return { mapped: i.length ? new xw(n, a, i, s) : null, pos: o };
  }
}
class Nt {
  constructor(e, t, i, n) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, t, i, n) {
    return new Nt(e, t, i, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: n = 0, filterTo: a = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (i && (t = t.slice().sort(m_)), this.isEmpty)
      return t.length ? Nt.of(t) : this;
    let s = new j4(this, null, -1).goto(0), l = 0, u = [], h = new fl();
    for (; s.value || l < t.length; )
      if (l < t.length && (s.from - t[l].from || s.startSide - t[l].value.startSide) >= 0) {
        let c = t[l++];
        h.addInner(c.from, c.to, c.value) || u.push(c);
      } else
        s.rangeIndex == 1 && s.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(s.chunkIndex) < t[l].from) && (!o || n > this.chunkEnd(s.chunkIndex) || a < this.chunkPos[s.chunkIndex]) && h.addChunk(this.chunkPos[s.chunkIndex], this.chunk[s.chunkIndex]) ? s.nextChunk() : ((!o || n > s.to || a < s.from || o(s.from, s.to, s.value)) && (h.addInner(s.from, s.to, s.value) || u.push(O_.create(s.from, s.to, s.value))), s.next());
    return h.finishInner(this.nextLayer.isEmpty && !u.length ? Nt.empty : this.nextLayer.update({ add: u, filter: o, filterFrom: n, filterTo: a }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], n = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let s = this.chunkPos[o], l = this.chunk[o], u = e.touchesRange(s, s + l.length);
      if (u === !1)
        n = Math.max(n, l.maxPoint), t.push(l), i.push(e.mapPos(s));
      else if (u === !0) {
        let { mapped: h, pos: c } = l.map(s, e);
        h && (n = Math.max(n, h.maxPoint), t.push(h), i.push(c));
      }
    }
    let a = this.nextLayer.map(e);
    return t.length == 0 ? a : new Nt(i, t, a || Nt.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let a = this.chunkPos[n], o = this.chunk[n];
        if (t >= a && e <= a + o.length && o.between(a, e - a, t - a, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return pg.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return pg.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, n, a = -1) {
    let o = e.filter((c) => c.maxPoint > 0 || !c.isEmpty && c.maxPoint >= a), s = t.filter((c) => c.maxPoint > 0 || !c.isEmpty && c.maxPoint >= a), l = a$(o, s, i), u = new Sd(o, l, a), h = new Sd(s, l, a);
    i.iterGaps((c, f, d) => o$(u, c, h, f, d, n)), i.empty && i.length == 0 && o$(u, 0, h, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, n) {
    n == null && (n = 1e9 - 1);
    let a = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), o = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (a.length != o.length)
      return !1;
    if (!a.length)
      return !0;
    let s = a$(a, o), l = new Sd(a, s, 0).goto(i), u = new Sd(o, s, 0).goto(i);
    for (; ; ) {
      if (l.to != u.to || !E_(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > n)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, n, a = -1) {
    let o = new Sd(e, null, a).goto(t), s = t, l = o.openStart;
    for (; ; ) {
      let u = Math.min(o.to, i);
      if (o.point) {
        let h = o.activeForPoint(o.to), c = o.pointFrom < t ? h.length + 1 : Math.min(h.length, l);
        n.point(s, u, o.point, h, c, o.pointRank), l = Math.min(o.openEnd(u), h.length);
      } else
        u > s && (n.span(s, u, o.active, l), l = o.openEnd(u));
      if (o.to > i)
        return l + (o.point && o.to > i ? 1 : 0);
      s = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let i = new fl();
    for (let n of e instanceof O_ ? [e] : t ? aCe(e) : e)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
}
Nt.empty = /* @__PURE__ */ new Nt([], [], null, -1);
function aCe(r) {
  if (r.length > 1)
    for (let e = r[0], t = 1; t < r.length; t++) {
      let i = r[t];
      if (m_(e, i) > 0)
        return r.slice().sort(m_);
      e = i;
    }
  return r;
}
Nt.empty.nextLayer = Nt.empty;
class fl {
  finishChunk(e) {
    this.chunks.push(new xw(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new fl())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let n = e - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Nt.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Nt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function a$(r, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let a of r)
    for (let o = 0; o < a.chunk.length; o++)
      a.chunk[o].maxPoint <= 0 && i.set(a.chunk[o], a.chunkPos[o]);
  let n = /* @__PURE__ */ new Set();
  for (let a of e)
    for (let o = 0; o < a.chunk.length; o++) {
      let s = i.get(a.chunk[o]);
      s != null && (t ? t.mapPos(s) : s) == a.chunkPos[o] && !(t != null && t.touchesRange(s, s + a.chunk[o].length)) && n.add(a.chunk[o]);
    }
  return n;
}
class j4 {
  constructor(e, t, i, n = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class pg {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let n = [];
    for (let a = 0; a < e.length; a++)
      for (let o = e[a]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && n.push(new j4(o, t, i, a));
    return n.length == 1 ? n[0] : new pg(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      uR(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      uR(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), uR(this.heap, 0);
    }
  }
}
function uR(r, e) {
  for (let t = r[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= r.length)
      break;
    let n = r[i];
    if (i + 1 < r.length && n.compare(r[i + 1]) >= 0 && (n = r[i + 1], i++), t.compare(n) < 0)
      break;
    r[i] = t, r[e] = n, e = i;
  }
}
class Sd {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = pg.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    DO(this.active, e), DO(this.activeTo, e), DO(this.activeRank, e), this.minActive = s$(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: n, rank: a } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= a; )
      t++;
    MO(this.active, t, i), MO(this.activeTo, t, n), MO(this.activeRank, t, a), e && MO(e, t, this.cursor.from), this.minActive = s$(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && DO(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let a = this.cursor.value;
          if (!a.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = a, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = a.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let n = i.length - 1; n >= 0 && i[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function o$(r, e, t, i, n, a) {
  r.goto(e), t.goto(i);
  let o = i + n, s = i, l = i - e;
  for (; ; ) {
    let u = r.to + l - t.to || r.endSide - t.endSide, h = u < 0 ? r.to + l : t.to, c = Math.min(h, o);
    if (r.point || t.point ? r.point && t.point && (r.point == t.point || r.point.eq(t.point)) && E_(r.activeForPoint(r.to), t.activeForPoint(t.to)) || a.comparePoint(s, c, r.point, t.point) : c > s && !E_(r.active, t.active) && a.compareRange(s, c, r.active, t.active), h > o)
      break;
    s = h, u <= 0 && r.next(), u >= 0 && t.next();
  }
}
function E_(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] != e[t] && !r[t].eq(e[t]))
      return !1;
  return !0;
}
function DO(r, e) {
  for (let t = e, i = r.length - 1; t < i; t++)
    r[t] = r[t + 1];
  r.pop();
}
function MO(r, e, t) {
  for (let i = r.length - 1; i >= e; i--)
    r[i + 1] = r[i];
  r[e] = t;
}
function s$(r, e) {
  let t = -1, i = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - i || r[n].endSide - r[t].endSide) < 0 && (t = n, i = e[n]);
  return t;
}
function iv(r, e, t = r.length) {
  let i = 0;
  for (let n = 0; n < t; )
    r.charCodeAt(n) == 9 ? (i += e - i % e, n++) : (i++, n = li(r, n));
  return i;
}
function b_(r, e, t, i) {
  for (let n = 0, a = 0; ; ) {
    if (a >= e)
      return n;
    if (n == r.length)
      break;
    a += r.charCodeAt(n) == 9 ? t - a % t : 1, n = li(r, n);
  }
  return i === !0 ? -1 : r.length;
}
const S_ = "", l$ = typeof Symbol > "u" ? "__" + S_ : Symbol.for(S_), T_ = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), u$ = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class dl {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function n(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function a(o, s, l, u) {
      let h = [], c = /^@(\w+)\b/.exec(o[0]), f = c && c[1] == "keyframes";
      if (c && s == null)
        return l.push(o[0] + ";");
      for (let d in s) {
        let p = s[d];
        if (/&/.test(d))
          a(
            d.split(/,\s*/).map((g) => o.map((v) => g.replace(/&/, v))).reduce((g, v) => g.concat(v)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!c)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          a(n(d), p, h, f);
        } else
          p != null && h.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (h.length || f) && l.push((i && !c && !u ? o.map(i) : o).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let o in e)
      a(n(o), e[o], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = u$[l$] || 1;
    return u$[l$] = e + 1, S_ + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(e, t) {
    (e[T_] || new oCe(e)).mount(Array.isArray(t) ? t : [t]);
  }
}
let h$ = /* @__PURE__ */ new Map();
class oCe {
  constructor(e) {
    let t = e.ownerDocument || e, i = t.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let n = h$.get(t);
      if (n)
        return e.adoptedStyleSheets = [n.sheet, ...e.adoptedStyleSheets], e[T_] = n;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], h$.set(t, this);
    } else {
      this.styleTag = t.createElement("style");
      let n = e.head || e;
      n.insertBefore(this.styleTag, n.firstChild);
    }
    this.modules = [], e[T_] = this;
  }
  mount(e) {
    let t = this.sheet, i = 0, n = 0;
    for (let a = 0; a < e.length; a++) {
      let o = e[a], s = this.modules.indexOf(o);
      if (s < n && s > -1 && (this.modules.splice(s, 1), n--, s = -1), s == -1) {
        if (this.modules.splice(n++, 0, o), t)
          for (let l = 0; l < o.rules.length; l++)
            t.insertRule(o.rules[l], i++);
      } else {
        for (; n < s; )
          i += this.modules[n++].rules.length;
        i += o.rules.length, n++;
      }
    }
    if (!t) {
      let a = "";
      for (let o = 0; o < this.modules.length; o++)
        a += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = a;
    }
  }
}
var pl = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, gg = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, sCe = typeof navigator < "u" && /Mac/.test(navigator.platform), lCe = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var Xr = 0; Xr < 10; Xr++)
  pl[48 + Xr] = pl[96 + Xr] = String(Xr);
for (var Xr = 1; Xr <= 24; Xr++)
  pl[Xr + 111] = "F" + Xr;
for (var Xr = 65; Xr <= 90; Xr++)
  pl[Xr] = String.fromCharCode(Xr + 32), gg[Xr] = String.fromCharCode(Xr);
for (var hR in pl)
  gg.hasOwnProperty(hR) || (gg[hR] = pl[hR]);
function uCe(r) {
  var e = sCe && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey || lCe && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? gg : pl)[r.keyCode] || r.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function lb(r) {
  let e;
  return r.nodeType == 11 ? e = r.getSelection ? r : r.ownerDocument : e = r, e.getSelection();
}
function y_(r, e) {
  return e ? r == e || r.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function hCe(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Pm(r, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return y_(r, e.anchorNode);
  } catch {
    return !1;
  }
}
function vg(r) {
  return r.nodeType == 3 ? lh(r, 0, r.nodeValue.length).getClientRects() : r.nodeType == 1 ? r.getClientRects() : [];
}
function ub(r, e, t, i) {
  return t ? c$(r, e, t, i, -1) || c$(r, e, t, i, 1) : !1;
}
function hb(r) {
  for (var e = 0; ; e++)
    if (r = r.previousSibling, !r)
      return e;
}
function c$(r, e, t, i, n) {
  for (; ; ) {
    if (r == t && e == i)
      return !0;
    if (e == (n < 0 ? 0 : gl(r))) {
      if (r.nodeName == "DIV")
        return !1;
      let a = r.parentNode;
      if (!a || a.nodeType != 1)
        return !1;
      e = hb(r) + (n < 0 ? 0 : 1), r = a;
    } else if (r.nodeType == 1) {
      if (r = r.childNodes[e + (n < 0 ? -1 : 0)], r.nodeType == 1 && r.contentEditable == "false")
        return !1;
      e = n < 0 ? gl(r) : 0;
    } else
      return !1;
  }
}
function gl(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function ww(r, e) {
  let t = e ? r.left : r.right;
  return { left: t, right: t, top: r.top, bottom: r.bottom };
}
function cCe(r) {
  return {
    left: 0,
    right: r.innerWidth,
    top: 0,
    bottom: r.innerHeight
  };
}
function fCe(r, e, t, i, n, a, o, s) {
  let l = r.ownerDocument, u = l.defaultView || window;
  for (let h = r, c = !1; h && !c; )
    if (h.nodeType == 1) {
      let f, d = h == l.body;
      if (d)
        f = cCe(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(h).position) && (c = !0), h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let v = h.getBoundingClientRect();
        f = {
          left: v.left,
          right: v.left + h.clientWidth,
          top: v.top,
          bottom: v.top + h.clientHeight
        };
      }
      let p = 0, g = 0;
      if (n == "nearest")
        e.top < f.top ? (g = -(f.top - e.top + o), t > 0 && e.bottom > f.bottom + g && (g = e.bottom - f.bottom + g + o)) : e.bottom > f.bottom && (g = e.bottom - f.bottom + o, t < 0 && e.top - g < f.top && (g = -(f.top + g - e.top + o)));
      else {
        let v = e.bottom - e.top, O = f.bottom - f.top;
        g = (n == "center" && v <= O ? e.top + v / 2 - O / 2 : n == "start" || n == "center" && t < 0 ? e.top - o : e.bottom - O + o) - f.top;
      }
      if (i == "nearest" ? e.left < f.left ? (p = -(f.left - e.left + a), t > 0 && e.right > f.right + p && (p = e.right - f.right + p + a)) : e.right > f.right && (p = e.right - f.right + a, t < 0 && e.left < f.left + p && (p = -(f.left + p - e.left + a))) : p = (i == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : i == "start" == s ? e.left - a : e.right - (f.right - f.left) + a) - f.left, p || g)
        if (d)
          u.scrollBy(p, g);
        else {
          let v = 0, O = 0;
          if (g) {
            let m = h.scrollTop;
            h.scrollTop += g, O = h.scrollTop - m;
          }
          if (p) {
            let m = h.scrollLeft;
            h.scrollLeft += p, v = h.scrollLeft - m;
          }
          e = {
            left: e.left - v,
            top: e.top - O,
            right: e.right - v,
            bottom: e.bottom - O
          }, v && Math.abs(v - p) < 1 && (i = "nearest"), O && Math.abs(O - g) < 1 && (n = "nearest");
        }
      if (d)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function dCe(r) {
  let e = r.ownerDocument;
  for (let t = r.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class pCe {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? gl(t) : 0), i, Math.min(e.focusOffset, i ? gl(i) : 0));
  }
  set(e, t, i, n) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = n;
  }
}
let rc = null;
function K4(r) {
  if (r.setActive)
    return r.setActive();
  if (rc)
    return r.focus(rc);
  let e = [];
  for (let t = r; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (r.focus(rc == null ? {
    get preventScroll() {
      return rc = { preventScroll: !0 }, !0;
    }
  } : void 0), !rc) {
    rc = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], n = e[t++], a = e[t++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != a && (i.scrollLeft = a);
    }
  }
}
let f$;
function lh(r, e, t = e) {
  let i = f$ || (f$ = document.createRange());
  return i.setEnd(r, t), i.setStart(r, e), i;
}
function Qc(r, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, n = new KeyboardEvent("keydown", i);
  n.synthetic = !0, r.dispatchEvent(n);
  let a = new KeyboardEvent("keyup", i);
  return a.synthetic = !0, r.dispatchEvent(a), n.defaultPrevented || a.defaultPrevented;
}
function gCe(r) {
  for (; r; ) {
    if (r && (r.nodeType == 9 || r.nodeType == 11 && r.host))
      return r;
    r = r.assignedSlot || r.parentNode;
  }
  return null;
}
function J4(r) {
  for (; r.attributes.length; )
    r.removeAttributeNode(r.attributes[0]);
}
function vCe(r, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, gl(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let n = t.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (t = n, i = gl(t));
    } else {
      if (t == r)
        return !0;
      i = hb(t), t = t.parentNode;
    }
}
function e7(r) {
  return r.scrollTop > Math.max(1, r.scrollHeight - r.clientHeight - 4);
}
class yi {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new yi(e.parentNode, hb(e), t);
  }
  static after(e, t) {
    return new yi(e.parentNode, hb(e) + 1, t);
  }
}
const Pw = [];
class Ft {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let i = this.dom, n = null, a;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (a = n ? n.nextSibling : i.firstChild)) {
            let s = Ft.get(a);
            (!s || !s.parent && s.canReuseDOM(o)) && o.reuseDOM(a);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (a = n ? n.nextSibling : i.firstChild, t && !t.written && t.node == i && a != o.dom && (t.written = !0), o.dom.parentNode == i)
          for (; a && a != o.dom; )
            a = d$(a);
        else
          i.insertBefore(o.dom, a);
        n = o.dom;
      }
      for (a = n ? n.nextSibling : i.firstChild, a && t && t.node == i && (t.written = !0); a; )
        a = d$(a);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, t), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let n = gl(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let a = e.parentNode;
        if (a == this.dom)
          break;
        n == 0 && a.firstChild != a.lastChild && (e == a.firstChild ? n = -1 : n = 1), e = a;
      }
      n < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Ft.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, a = 0; ; n++) {
      let o = this.children[n];
      if (o.dom == i)
        return a;
      a += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let n = -1, a = -1, o = -1, s = -1;
    for (let l = 0, u = i, h = i; l < this.children.length; l++) {
      let c = this.children[l], f = u + c.length;
      if (u < e && f > t)
        return c.domBoundsAround(e, t, u);
      if (f >= e && n == -1 && (n = l, a = u), u > t && c.dom.parentNode == this.dom) {
        o = l, s = h;
        break;
      }
      h = f, u = f + c.breakAfter;
    }
    return {
      from: a,
      to: s < 0 ? i + this.length : s,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = Pw) {
    this.markDirty();
    for (let n = e; n < t; n++) {
      let a = this.children[n];
      a.parent == this && a.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new t7(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, n, a, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
Ft.prototype.breakAfter = 0;
function d$(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class t7 {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function r7(r, e, t, i, n, a, o, s, l) {
  let { children: u } = r, h = u.length ? u[e] : null, c = a.length ? a[a.length - 1] : null, f = c ? c.breakAfter : o;
  if (!(e == i && h && !o && !f && a.length < 2 && h.merge(t, n, a.length ? c : null, t == 0, s, l))) {
    if (i < u.length) {
      let d = u[i];
      d && n < d.length ? (e == i && (d = d.split(n), n = 0), !f && c && d.merge(0, n, c, !0, 0, l) ? a[a.length - 1] = d : (n && d.merge(0, n, null, !1, 0, l), a.push(d))) : d != null && d.breakAfter && (c ? c.breakAfter = 1 : o = 1), i++;
    }
    for (h && (h.breakAfter = o, t > 0 && (!o && a.length && h.merge(t, h.length, a[0], !1, s, 0) ? h.breakAfter = a.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, s, 0), e++)); e < i && a.length; )
      if (u[i - 1].become(a[a.length - 1]))
        i--, a.pop(), l = a.length ? 0 : s;
      else if (u[e].become(a[0]))
        e++, a.shift(), s = a.length ? 0 : l;
      else
        break;
    !a.length && e && i < u.length && !u[e - 1].breakAfter && u[i].merge(0, 0, u[e - 1], !1, s, l) && e--, (e < i || a.length) && r.replaceChildren(e, i, a);
  }
}
function i7(r, e, t, i, n, a) {
  let o = r.childCursor(), { i: s, off: l } = o.findPos(t, 1), { i: u, off: h } = o.findPos(e, -1), c = e - t;
  for (let f of i)
    c += f.length;
  r.length += c, r7(r, u, h, s, l, i, 0, n, a);
}
const Ec = "";
class n7 {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(St.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += Ec;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(i, n);
      let a = this.text.length;
      this.readNode(n);
      let o = n.nextSibling;
      if (o == t)
        break;
      let s = Ft.get(n), l = Ft.get(o);
      (s && l ? s.breakAfter : (s ? s.breakAfter : p$(n)) || p$(o) && (n.nodeName != "BR" || n.cmIgnore) && this.text.length > a) && this.lineBreak(), n = o;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let a = -1, o = 1, s;
      if (this.lineSeparator ? (a = t.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (s = n.exec(t)) && (a = s.index, o = s[0].length), this.append(t.slice(i, a < 0 ? t.length : a)), a < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      i = a + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Ft.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + Math.min(t, i.offset));
  }
}
function p$(r) {
  return r.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(r.nodeName);
}
class g$ {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
let hn = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, R_ = typeof document < "u" ? document : { documentElement: { style: {} } };
const A_ = /* @__PURE__ */ /Edge\/(\d+)/.exec(hn.userAgent), a7 = /* @__PURE__ */ /MSIE \d/.test(hn.userAgent), C_ = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(hn.userAgent), JS = !!(a7 || C_ || A_), v$ = !JS && /* @__PURE__ */ /gecko\/(\d+)/i.test(hn.userAgent), cR = !JS && /* @__PURE__ */ /Chrome\/(\d+)/.exec(hn.userAgent), O$ = "webkitFontSmoothing" in R_.documentElement.style, o7 = !JS && /* @__PURE__ */ /Apple Computer/.test(hn.vendor), m$ = o7 && (/* @__PURE__ */ /Mobile\/\w+/.test(hn.userAgent) || hn.maxTouchPoints > 2);
var Ae = {
  mac: m$ || /* @__PURE__ */ /Mac/.test(hn.platform),
  windows: /* @__PURE__ */ /Win/.test(hn.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(hn.platform),
  ie: JS,
  ie_version: a7 ? R_.documentMode || 6 : C_ ? +C_[1] : A_ ? +A_[1] : 0,
  gecko: v$,
  gecko_version: v$ ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(hn.userAgent) || [0, 0])[1] : 0,
  chrome: !!cR,
  chrome_version: cR ? +cR[1] : 0,
  ios: m$,
  android: /* @__PURE__ */ /Android\b/.test(hn.userAgent),
  webkit: O$,
  safari: o7,
  webkit_version: O$ ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: R_.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const OCe = 256;
class ho extends Ft {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return this.flags & 8 || i && (!(i instanceof ho) || this.length - (t - e) + i.length > OCe || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new ho(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new yi(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return mCe(this.dom, e, t);
  }
}
class Zo extends Ft {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let n of t)
      n.setParent(this);
  }
  setAttrs(e) {
    if (J4(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, n, a, o) {
    return i && (!(i instanceof Zo && i.mark.eq(this.mark)) || e && a <= 0 || t < this.length && o <= 0) ? !1 : (i7(this, e, t, i ? i.children : [], a - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, n = -1, a = 0;
    for (let s of this.children) {
      let l = i + s.length;
      l > e && t.push(i < e ? s.split(e - i) : s), n < 0 && i >= e && (n = a), i = l, a++;
    }
    let o = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new Zo(this.mark, t, o);
  }
  domAtPos(e) {
    return s7(this, e);
  }
  coordsAt(e, t) {
    return u7(this, e, t);
  }
}
function mCe(r, e, t) {
  let i = r.nodeValue.length;
  e > i && (e = i);
  let n = e, a = e, o = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? Ae.chrome || Ae.gecko || (e ? (n--, o = 1) : a < i && (a++, o = -1)) : t < 0 ? n-- : a < i && a++;
  let s = lh(r, n, a).getClientRects();
  if (!s.length)
    return null;
  let l = s[(o ? o < 0 : t >= 0) ? 0 : s.length - 1];
  return Ae.safari && !o && l.width == 0 && (l = Array.prototype.find.call(s, (u) => u.width) || l), o ? ww(l, o < 0) : l || null;
}
class xu extends Ft {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  static create(e, t, i) {
    return new xu(e, t, i);
  }
  split(e) {
    let t = xu.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, n, a, o) {
    return i && (!(i instanceof xu) || !this.widget.compare(i.widget) || e > 0 && a <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof xu && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Rt.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : Rt.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? yi.before(this.dom) : yi.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let n = this.dom.getClientRects(), a = null;
    if (!n.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let s = o ? n.length - 1 : 0; a = n[s], !(e > 0 ? s == 0 : s == n.length - 1 || a.top < a.bottom); s += o ? -1 : 1)
      ;
    return ww(a, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class sf extends Ft {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof sf && e.side == this.side;
  }
  split() {
    return new sf(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? yi.before(this.dom) : yi.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Rt.empty;
  }
  get isHidden() {
    return !0;
  }
}
ho.prototype.children = xu.prototype.children = sf.prototype.children = Pw;
function s7(r, e) {
  let t = r.dom, { children: i } = r, n = 0;
  for (let a = 0; n < i.length; n++) {
    let o = i[n], s = a + o.length;
    if (!(s == a && o.getSide() <= 0)) {
      if (e > a && e < s && o.dom.parentNode == t)
        return o.domAtPos(e - a);
      if (e <= a)
        break;
      a = s;
    }
  }
  for (let a = n; a > 0; a--) {
    let o = i[a - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let a = n; a < i.length; a++) {
    let o = i[a];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new yi(t, 0);
}
function l7(r, e, t) {
  let i, { children: n } = r;
  t > 0 && e instanceof Zo && n.length && (i = n[n.length - 1]) instanceof Zo && i.mark.eq(e.mark) ? l7(i, e.children[0], t - 1) : (n.push(e), e.setParent(r)), r.length += e.length;
}
function u7(r, e, t) {
  let i = null, n = -1, a = null, o = -1;
  function s(u, h) {
    for (let c = 0, f = 0; c < u.children.length && f <= h; c++) {
      let d = u.children[c], p = f + d.length;
      p >= h && (d.children.length ? s(d, h - f) : (!a || a.isHidden && t > 0) && (p > h || f == p && d.getSide() > 0) ? (a = d, o = h - f) : (f < h || f == p && d.getSide() < 0 && !d.isHidden) && (i = d, n = h - f)), f = p;
    }
  }
  s(r, e);
  let l = (t < 0 ? i : a) || i || a;
  return l ? l.coordsAt(Math.max(0, l == i ? n : o), t) : ECe(r);
}
function ECe(r) {
  let e = r.dom.lastChild;
  if (!e)
    return r.dom.getBoundingClientRect();
  let t = vg(e);
  return t[t.length - 1] || null;
}
function __(r, e) {
  for (let t in r)
    t == "class" && e.class ? e.class += " " + r.class : t == "style" && e.style ? e.style += ";" + r.style : e[t] = r[t];
  return e;
}
const E$ = /* @__PURE__ */ Object.create(null);
function Nw(r, e, t) {
  if (r == e)
    return !0;
  r || (r = E$), e || (e = E$);
  let i = Object.keys(r), n = Object.keys(e);
  if (i.length - (t && i.indexOf(t) > -1 ? 1 : 0) != n.length - (t && n.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let a of i)
    if (a != t && (n.indexOf(a) == -1 || r[a] !== e[a]))
      return !1;
  return !0;
}
function I_(r, e, t) {
  let i = null;
  if (e)
    for (let n in e)
      t && n in t || r.removeAttribute(i = n);
  if (t)
    for (let n in t)
      e && e[n] == t[n] || r.setAttribute(i = n, t[n]);
  return !!i;
}
function bCe(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < r.attributes.length; t++) {
    let i = r.attributes[t];
    e[i.name] = i.value;
  }
  return e;
}
class ns {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var tr = /* @__PURE__ */ function(r) {
  return r[r.Text = 0] = "Text", r[r.WidgetBefore = 1] = "WidgetBefore", r[r.WidgetAfter = 2] = "WidgetAfter", r[r.WidgetRange = 3] = "WidgetRange", r;
}(tr || (tr = {}));
class Be extends sh {
  constructor(e, t, i, n) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new nv(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new vl(e, t, t, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, n;
    if (e.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: a, end: o } = h7(e, t);
      i = (a ? t ? -3e8 : -1 : 5e8) - 1, n = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new vl(e, i, n, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new av(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Nt.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Be.none = Nt.empty;
class nv extends Be {
  constructor(e) {
    let { start: t, end: i } = h7(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, i;
    return this == e || e instanceof nv && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && Nw(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
nv.prototype.point = !1;
class av extends Be {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof av && this.spec.class == e.spec.class && Nw(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
av.prototype.mapMode = Yr.TrackBefore;
av.prototype.point = !0;
class vl extends Be {
  constructor(e, t, i, n, a, o) {
    super(t, i, a, e), this.block = n, this.isReplace = o, this.mapMode = n ? t <= 0 ? Yr.TrackBefore : Yr.TrackAfter : Yr.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? tr.WidgetRange : this.startSide <= 0 ? tr.WidgetBefore : tr.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof vl && SCe(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
vl.prototype.point = !0;
function h7(r, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = r;
  return t == null && (t = r.inclusive), i == null && (i = r.inclusive), { start: t ?? e, end: i ?? e };
}
function SCe(r, e) {
  return r == e || !!(r && e && r.compare(e));
}
function x_(r, e, t, i = 0) {
  let n = t.length - 1;
  n >= 0 && t[n] + i >= r ? t[n] = Math.max(t[n], e) : t.push(r, e);
}
class Si extends Ft {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, n, a, o) {
    if (i) {
      if (!(i instanceof Si))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), i7(this, e, t, i ? i.children : [], a, o), !0;
  }
  split(e) {
    let t = new Si();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: n } = this.childPos(e);
    n && (t.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, !1, 0, 0), i++);
    for (let a = i; a < this.children.length; a++)
      t.append(this.children[a], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Nw(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    l7(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = __(t, this.attrs || {})), i && (this.attrs = __({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return s7(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.flags & 4 && (J4(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (I_(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let n = this.dom.lastChild;
    for (; n && Ft.get(n) instanceof Zo; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((i = Ft.get(n)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!Ae.ios || !this.children.some((a) => a instanceof ho))) {
      let a = document.createElement("BR");
      a.cmIgnore = !0, this.dom.appendChild(a);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof ho) || /[^ -~]/.test(i.text))
        return null;
      let n = vg(i.dom);
      if (n.length != 1)
        return null;
      e += n[0].width, t = n[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = u7(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: n } = this.parent.view.viewState, a = i.bottom - i.top;
      if (Math.abs(a - n.lineHeight) < 2 && n.textHeight < a) {
        let o = (a - n.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  get type() {
    return tr.Text;
  }
  static find(e, t) {
    for (let i = 0, n = 0; i < e.children.length; i++) {
      let a = e.children[i], o = n + a.length;
      if (o >= t) {
        if (a instanceof Si)
          return a;
        if (o > t)
          break;
      }
      n = o + a.breakAfter;
    }
    return null;
  }
}
class Wu extends Ft {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.type = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, n, a, o) {
    return i && (!(i instanceof Wu) || !this.widget.compare(i.widget) || e > 0 && a <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? yi.before(this.dom) : yi.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new Wu(this.widget, t, this.type);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return Pw;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Rt.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Wu && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.type = e.type, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class mp {
  constructor(e, t, i, n) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof Wu && e.type == tr.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Si()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(kO(new sf(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: a, lineBreak: o, done: s } = this.cursor.next(this.skip);
        if (this.skip = 0, s)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = a, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* Chunk */
      );
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(kO(new ho(this.text.slice(this.textOff, this.textOff + n)), t), i), this.atCursorPos = !0, this.textOff += n, e -= n, i = 0;
    }
  }
  span(e, t, i, n) {
    this.buildText(t - e, i, n), this.pos = t, this.openStart < 0 && (this.openStart = n);
  }
  point(e, t, i, n, a, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof vl) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let s = t - e;
    if (i instanceof vl)
      if (i.block) {
        let { type: l } = i;
        l == tr.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new Wu(i.widget || new b$("div"), s, l));
      } else {
        let l = xu.create(i.widget || new b$("span"), s, s ? 0 : i.startSide), u = this.atCursorPos && !l.isEditable && a <= n.length && (e < t || i.startSide > 0), h = !l.isEditable && (e < t || a > n.length || i.startSide <= 0), c = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(n), u && (c.append(kO(new sf(1), n), a), a = n.length + Math.max(0, a - n.length)), c.append(kO(l, n), a), this.atCursorPos = h, this.pendingBuffer = h ? e < t || a > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = a);
  }
  static build(e, t, i, n, a) {
    let o = new mp(e, t, i, a);
    return o.openEnd = Nt.spans(n, t, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function kO(r, e) {
  for (let t of e)
    r = new Zo(t, [r], r.length);
  return r;
}
class b$ extends ns {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const c7 = /* @__PURE__ */ Re.define(), f7 = /* @__PURE__ */ Re.define(), d7 = /* @__PURE__ */ Re.define(), p7 = /* @__PURE__ */ Re.define(), w_ = /* @__PURE__ */ Re.define(), g7 = /* @__PURE__ */ Re.define(), v7 = /* @__PURE__ */ Re.define(), O7 = /* @__PURE__ */ Re.define({
  combine: (r) => r.some((e) => e)
}), m7 = /* @__PURE__ */ Re.define({
  combine: (r) => r.some((e) => e)
});
class cb {
  constructor(e, t = "nearest", i = "nearest", n = 5, a = 5) {
    this.range = e, this.y = t, this.x = i, this.yMargin = n, this.xMargin = a;
  }
  map(e) {
    return e.empty ? this : new cb(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const S$ = /* @__PURE__ */ rt.define({ map: (r, e) => r.map(e) });
function Xn(r, e, t) {
  let i = r.facet(p7);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const eT = /* @__PURE__ */ Re.define({ combine: (r) => r.length ? r[0] : !0 });
let TCe = 0;
const Xd = /* @__PURE__ */ Re.define();
class Ir {
  constructor(e, t, i, n) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.extension = n(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: i, provide: n, decorations: a } = t || {};
    return new Ir(TCe++, e, i, (o) => {
      let s = [Xd.of(o)];
      return a && s.push(Og.of((l) => {
        let u = l.plugin(o);
        return u ? a(u) : Be.none;
      })), n && s.push(n(o)), s;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Ir.define((i) => new e(i), t);
  }
}
class fR {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (Xn(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        Xn(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        Xn(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const E7 = /* @__PURE__ */ Re.define(), Lw = /* @__PURE__ */ Re.define(), Og = /* @__PURE__ */ Re.define(), Dw = /* @__PURE__ */ Re.define(), b7 = /* @__PURE__ */ Re.define();
function S7(r) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let a of r.state.facet(b7)) {
    let o = a(r);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (n = Math.max(n, o.bottom)));
  }
  return { left: e, right: t, top: i, bottom: n };
}
const Yd = /* @__PURE__ */ Re.define();
class Yn {
  constructor(e, t, i, n) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = n;
  }
  join(e) {
    return new Yn(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let n = e[t - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let n = 0, a = 0, o = 0, s = 0; ; n++) {
      let l = n == e.length ? null : e[n], u = o - s, h = l ? l.fromB : 1e9;
      for (; a < t.length && t[a] < h; ) {
        let c = t[a], f = t[a + 1], d = Math.max(s, c), p = Math.min(h, f);
        if (d <= p && new Yn(d + u, p + u, d, p).addToSet(i), f > h)
          break;
        a += 2;
      }
      if (!l)
        return i;
      new Yn(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), o = l.toA, s = l.toB;
    }
  }
}
class fb {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = br.empty(this.startState.doc.length);
    for (let a of i)
      this.changes = this.changes.compose(a.changes);
    let n = [];
    this.changes.iterChangedRanges((a, o, s, l) => n.push(new Yn(a, o, s, l))), this.changedRanges = n;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new fb(e, t, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Jt = /* @__PURE__ */ function(r) {
  return r[r.LTR = 0] = "LTR", r[r.RTL = 1] = "RTL", r;
}(Jt || (Jt = {}));
const P_ = Jt.LTR, yCe = Jt.RTL;
function T7(r) {
  let e = [];
  for (let t = 0; t < r.length; t++)
    e.push(1 << +r[t]);
  return e;
}
const RCe = /* @__PURE__ */ T7("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), ACe = /* @__PURE__ */ T7("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), N_ = /* @__PURE__ */ Object.create(null), xa = [];
for (let r of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ r.charCodeAt(0), t = /* @__PURE__ */ r.charCodeAt(1);
  N_[e] = t, N_[t] = -e;
}
function CCe(r) {
  return r <= 247 ? RCe[r] : 1424 <= r && r <= 1524 ? 2 : 1536 <= r && r <= 1785 ? ACe[r - 1536] : 1774 <= r && r <= 2220 ? 4 : 8192 <= r && r <= 8203 ? 256 : 64336 <= r && r <= 65023 ? 4 : r == 8204 ? 256 : 1;
}
const _Ce = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class Uc {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? yCe : P_;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, t, i, n) {
    let a = -1;
    for (let o = 0; o < e.length; o++) {
      let s = e[o];
      if (s.from <= t && s.to >= t) {
        if (s.level == i)
          return o;
        (a < 0 || (n != 0 ? n < 0 ? s.from < t : s.to > t : e[a].level > s.level)) && (a = o);
      }
    }
    if (a < 0)
      throw new RangeError("Index out of range");
    return a;
  }
}
const jt = [];
function ICe(r, e) {
  let t = r.length, i = e == P_ ? 1 : 2, n = e == P_ ? 2 : 1;
  if (!r || i == 1 && !_Ce.test(r))
    return y7(t);
  for (let o = 0, s = i, l = i; o < t; o++) {
    let u = CCe(r.charCodeAt(o));
    u == 512 ? u = s : u == 8 && l == 4 && (u = 16), jt[o] = u == 4 ? 2 : u, u & 7 && (l = u), s = u;
  }
  for (let o = 0, s = i, l = i; o < t; o++) {
    let u = jt[o];
    if (u == 128)
      o < t - 1 && s == jt[o + 1] && s & 24 ? u = jt[o] = s : jt[o] = 256;
    else if (u == 64) {
      let h = o + 1;
      for (; h < t && jt[h] == 64; )
        h++;
      let c = o && s == 8 || h < t && jt[h] == 8 ? l == 1 ? 1 : 8 : 256;
      for (let f = o; f < h; f++)
        jt[f] = c;
      o = h - 1;
    } else
      u == 8 && l == 1 && (jt[o] = 1);
    s = u, u & 7 && (l = u);
  }
  for (let o = 0, s = 0, l = 0, u, h, c; o < t; o++)
    if (h = N_[u = r.charCodeAt(o)])
      if (h < 0) {
        for (let f = s - 3; f >= 0; f -= 3)
          if (xa[f + 1] == -h) {
            let d = xa[f + 2], p = d & 2 ? i : d & 4 ? d & 1 ? n : i : 0;
            p && (jt[o] = jt[xa[f]] = p), s = f;
            break;
          }
      } else {
        if (xa.length == 189)
          break;
        xa[s++] = o, xa[s++] = u, xa[s++] = l;
      }
    else if ((c = jt[o]) == 2 || c == 1) {
      let f = c == i;
      l = f ? 0 : 1;
      for (let d = s - 3; d >= 0; d -= 3) {
        let p = xa[d + 2];
        if (p & 2)
          break;
        if (f)
          xa[d + 2] |= 2;
        else {
          if (p & 4)
            break;
          xa[d + 2] |= 4;
        }
      }
    }
  for (let o = 0; o < t; o++)
    if (jt[o] == 256) {
      let s = o + 1;
      for (; s < t && jt[s] == 256; )
        s++;
      let l = (o ? jt[o - 1] : i) == 1, u = (s < t ? jt[s] : i) == 1, h = l == u ? l ? 1 : 2 : i;
      for (let c = o; c < s; c++)
        jt[c] = h;
      o = s - 1;
    }
  let a = [];
  if (i == 1)
    for (let o = 0; o < t; ) {
      let s = o, l = jt[o++] != 1;
      for (; o < t && l == (jt[o] != 1); )
        o++;
      if (l)
        for (let u = o; u > s; ) {
          let h = u, c = jt[--u] != 2;
          for (; u > s && c == (jt[u - 1] != 2); )
            u--;
          a.push(new Uc(u, h, c ? 2 : 1));
        }
      else
        a.push(new Uc(s, o, 0));
    }
  else
    for (let o = 0; o < t; ) {
      let s = o, l = jt[o++] == 2;
      for (; o < t && l == (jt[o] == 2); )
        o++;
      a.push(new Uc(s, o, l ? 1 : 2));
    }
  return a;
}
function y7(r) {
  return [new Uc(0, r, 0)];
}
let R7 = "";
function xCe(r, e, t, i, n) {
  var a;
  let o = i.head - r.from, s = -1;
  if (o == 0) {
    if (!n || !r.length)
      return null;
    e[0].level != t && (o = e[0].side(!1, t), s = 0);
  } else if (o == r.length) {
    if (n)
      return null;
    let f = e[e.length - 1];
    f.level != t && (o = f.side(!0, t), s = e.length - 1);
  }
  s < 0 && (s = Uc.find(e, o, (a = i.bidiLevel) !== null && a !== void 0 ? a : -1, i.assoc));
  let l = e[s];
  o == l.side(n, t) && (l = e[s += n ? 1 : -1], o = l.side(!n, t));
  let u = n == (l.dir == t), h = li(r.text, o, u);
  if (R7 = r.text.slice(Math.min(o, h), Math.max(o, h)), h != l.side(n, t))
    return z.cursor(h + r.from, u ? -1 : 1, l.level);
  let c = s == (n ? e.length - 1 : 0) ? null : e[s + (n ? 1 : -1)];
  return !c && l.level != t ? z.cursor(n ? r.to : r.from, n ? -1 : 1, t) : c && c.level < l.level ? z.cursor(c.side(!n, t) + r.from, n ? 1 : -1, c.level) : z.cursor(h + r.from, n ? -1 : 1, l.level);
}
class T$ extends Ft {
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Si()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Yn(0, 0, 0, e.state.doc.length)], 0, null);
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state.
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: s, toA: l }) => l < this.minWidthFrom || s > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = this.view.inputState.composing < 0 ? null : PCe(this.view, e.changes);
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from: s, to: l } = this.hasComposition;
      t = new Yn(s, l, e.changes.mapPos(s, -1), e.changes.mapPos(l, 1)).addToSet(t.slice());
    }
    this.hasComposition = i ? { from: i.range.fromB, to: i.range.toB } : null, (Ae.ie || Ae.chrome) && !i && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let n = this.decorations, a = this.updateDeco(), o = DCe(n, a, e.changes);
    return t = Yn.extendWithRanges(t, o), !(this.flags & 7) && t.length == 0 ? !1 : (this.updateInner(t, e.startState.doc.length, i), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, i);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = Ae.chrome || Ae.ios ? { node: n.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || n.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* Composition */
    );
    let a = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof Wu && o.widget instanceof y$ && a.push(o.dom);
    n.updateGaps(a);
  }
  updateChildren(e, t, i) {
    let n = i ? i.range.addToSet(e.slice()) : e, a = this.childCursor(t);
    for (let o = n.length - 1; ; o--) {
      let s = o >= 0 ? n[o] : null;
      if (!s)
        break;
      let { fromA: l, toA: u, fromB: h, toB: c } = s, f, d, p, g;
      if (i && i.range.fromB < c && i.range.toB > h) {
        let b = mp.build(this.view.state.doc, h, i.range.fromB, this.decorations, this.dynamicDecorationMap), T = mp.build(this.view.state.doc, i.range.toB, c, this.decorations, this.dynamicDecorationMap);
        d = b.breakAtStart, p = b.openStart, g = T.openEnd;
        let S = this.compositionView(i);
        T.breakAtStart ? S.breakAfter = 1 : T.content.length && S.merge(S.length, S.length, T.content[0], !1, T.openStart, 0) && (S.breakAfter = T.content[0].breakAfter, T.content.shift()), b.content.length && S.merge(0, 0, b.content[b.content.length - 1], !0, 0, b.openEnd) && b.content.pop(), f = b.content.concat(S).concat(T.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: g } = mp.build(this.view.state.doc, h, c, this.decorations, this.dynamicDecorationMap));
      let { i: v, off: O } = a.findPos(u, 1), { i: m, off: E } = a.findPos(l, -1);
      r7(this, m, E, v, O, f, d, p, g);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let t = new ho(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: n } of e.marks)
      t = new Zo(n, [t], t.length);
    let i = new Si();
    return i.append(t, 0), i;
  }
  fixCompositionDOM(e) {
    let t = (a, o) => {
      o.flags |= 8, this.markedForComposition.add(o);
      let s = Ft.get(a);
      s != o && (s && (s.dom = null), o.setDOM(a));
    }, i = this.childPos(e.range.fromB, 1), n = this.children[i.i];
    t(e.line, n);
    for (let a = e.marks.length - 1; a >= -1; a--)
      i = n.childPos(i.off, 1), n = n.children[i.i], t(a >= 0 ? e.marks[a].node : e.text, n);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, n = i == this.dom, a = !n && Pm(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(n || t || a))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let s = this.view.state.selection.main, l = this.domAtPos(s.anchor), u = s.empty ? l : this.domAtPos(s.head);
    if (Ae.gecko && s.empty && !this.hasComposition && wCe(l)) {
      let c = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(c, l.node.childNodes[l.offset] || null)), l = u = new yi(c, 0), o = !0;
    }
    let h = this.view.observer.selectionRange;
    (o || !h.focusNode || !ub(l.node, l.offset, h.anchorNode, h.anchorOffset) || !ub(u.node, u.offset, h.focusNode, h.focusOffset)) && (this.view.observer.ignore(() => {
      Ae.android && Ae.chrome && this.dom.contains(h.focusNode) && MCe(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let c = lb(this.view.root);
      if (c)
        if (s.empty) {
          if (Ae.gecko) {
            let f = NCe(l.node, l.offset);
            if (f && f != 3) {
              let d = C7(l.node, l.offset, f == 1 ? 1 : -1);
              d && (l = new yi(d, f == 1 ? 0 : d.nodeValue.length));
            }
          }
          c.collapse(l.node, l.offset), s.bidiLevel != null && h.cursorBidiLevel != null && (h.cursorBidiLevel = s.bidiLevel);
        } else if (c.extend) {
          c.collapse(l.node, l.offset);
          try {
            c.extend(u.node, u.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          s.anchor > s.head && ([l, u] = [u, l]), f.setEnd(u.node, u.offset), f.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(f);
        }
      a && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new yi(h.anchorNode, h.anchorOffset), this.impreciseHead = u.precise ? null : new yi(h.focusNode, h.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, i = lb(e.root), { anchorNode: n, anchorOffset: a } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let o = Si.find(this, t.head);
    if (!o)
      return;
    let s = o.posAtStart;
    if (t.head == s || t.head == s + o.length)
      return;
    let l = this.coordsAt(t.head, -1), u = this.coordsAt(t.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    i.collapse(h.node, h.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let c = e.observer.selectionRange;
    e.docView.posFromDOM(c.anchorNode, c.anchorOffset) != t.from && i.collapse(n, a);
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = Ft.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let n = this.children[t];
      if (i < n.length || n instanceof Si)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    for (let i = this.length, n = this.children.length - 1; ; n--) {
      let a = this.children[n], o = i - a.breakAfter - a.length;
      if (e > o || e == o && a.type != tr.WidgetBefore && a.type != tr.WidgetAfter && (!n || t == 2 || this.children[n - 1].breakAfter || this.children[n - 1].type == tr.WidgetBefore && t > -2))
        return a.coordsAt(e - o, t);
      i = o;
    }
  }
  coordsForChar(e) {
    let { i: t, off: i } = this.childPos(e, 1), n = this.children[t];
    if (!(n instanceof Si))
      return null;
    for (; n.children.length; ) {
      let { i: s, off: l } = n.childPos(i, 1);
      for (; ; s++) {
        if (s == n.children.length)
          return null;
        if ((n = n.children[s]).length)
          break;
      }
      i = l;
    }
    if (!(n instanceof ho))
      return null;
    let a = li(n.text, i);
    if (a == i)
      return null;
    let o = lh(n.dom, i, a).getClientRects();
    return !o.length || o[0].top >= o[0].bottom ? null : o[0];
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: n } = e, a = this.view.contentDOM.clientWidth, o = a > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, s = -1, l = this.view.textDirection == Jt.LTR;
    for (let u = 0, h = 0; h < this.children.length; h++) {
      let c = this.children[h], f = u + c.length;
      if (f > n)
        break;
      if (u >= i) {
        let d = c.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = c.dom.lastChild, g = p ? vg(p) : [];
          if (g.length) {
            let v = g[g.length - 1], O = l ? v.right - d.left : d.right - v.left;
            O > s && (s = O, this.minWidth = a, this.minWidthFrom = u, this.minWidthTo = f);
          }
        }
      }
      u = f + c.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Jt.RTL : Jt.LTR;
  }
  measureTextSize() {
    for (let a of this.children)
      if (a instanceof Si) {
        let o = a.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, i, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let a = vg(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = a ? a.width / 27 : 7, n = a ? a.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: n };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new t7(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let a = n == t.viewports.length ? null : t.viewports[n], o = a ? a.from - 1 : this.length;
      if (o > i) {
        let s = t.lineBlockAt(o).bottom - t.lineBlockAt(i).top;
        e.push(Be.replace({
          widget: new y$(s),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!a)
        break;
      i = a.to + 1;
    }
    return Be.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(Og).map((t, i) => (this.dynamicDecorationMap[i] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), n;
    if (!i)
      return;
    !t.empty && (n = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let a = S7(this.view), o = {
      left: i.left - a.left,
      top: i.top - a.top,
      right: i.right + a.right,
      bottom: i.bottom + a.bottom
    };
    fCe(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == Jt.LTR);
  }
}
function wCe(r) {
  return r.node.nodeType == 1 && r.node.firstChild && (r.offset == 0 || r.node.childNodes[r.offset - 1].contentEditable == "false") && (r.offset == r.node.childNodes.length || r.node.childNodes[r.offset].contentEditable == "false");
}
class y$ extends ns {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function A7(r) {
  let e = r.observer.selectionRange, t = e.focusNode && C7(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let i = Ft.get(t), n, a;
  if (i instanceof ho)
    n = i.posAtStart, a = n + i.length;
  else
    e:
      for (let o = 0, s = t; ; ) {
        for (let u = s.previousSibling, h; u; u = u.previousSibling) {
          if (h = Ft.get(u)) {
            n = a = h.posAtEnd + o;
            break e;
          }
          let c = new n7([], r.state);
          if (c.readNode(u), c.text.indexOf(Ec) > -1)
            return null;
          o += c.text.length;
        }
        if (s = s.parentNode, !s)
          return null;
        let l = Ft.get(s);
        if (l) {
          n = a = l.posAtStart + o;
          break;
        }
      }
  return { from: n, to: a, node: t };
}
function PCe(r, e) {
  let t = A7(r);
  if (!t)
    return null;
  let { from: i, to: n, node: a } = t, o = e.mapPos(i, -1), s = e.mapPos(n, 1), l = a.nodeValue;
  if (/[\n\r]/.test(l))
    return null;
  if (s - o != l.length) {
    let f = e.mapPos(i, 1), d = e.mapPos(n, -1);
    if (d - f == l.length)
      o = f, s = d;
    else if (r.state.doc.sliceString(s - l.length, s) == l)
      o = s - l.length;
    else if (r.state.doc.sliceString(o, o + l.length) == l)
      s = o + l.length;
    else
      return null;
  }
  let { main: u } = r.state.selection;
  if (r.state.doc.sliceString(o, s) != l || o > u.head || s < u.head)
    return null;
  let h = [], c = new Yn(i, n, o, s);
  for (let f = a.parentNode; ; f = f.parentNode) {
    let d = Ft.get(f);
    if (d instanceof Zo)
      h.push({ node: f, deco: d.mark });
    else {
      if (d instanceof Si || f.nodeName == "DIV" && f.parentNode == r.contentDOM)
        return { range: c, text: a, marks: h, line: f };
      if (f != r.contentDOM)
        h.push({ node: f, deco: new nv({
          inclusive: !0,
          attributes: bCe(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function C7(r, e, t) {
  if (t <= 0)
    for (let i = r, n = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && n > 0)
        i = i.childNodes[n - 1], n = gl(i);
      else
        break;
    }
  if (t >= 0)
    for (let i = r, n = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && n < i.childNodes.length && t >= 0)
        i = i.childNodes[n], n = 0;
      else
        break;
    }
  return null;
}
function NCe(r, e) {
  return r.nodeType != 1 ? 0 : (e && r.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < r.childNodes.length && r.childNodes[e].contentEditable == "false" ? 2 : 0);
}
class LCe {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    x_(e, t, this.changes);
  }
  comparePoint(e, t) {
    x_(e, t, this.changes);
  }
}
function DCe(r, e, t) {
  let i = new LCe();
  return Nt.compare(r, e, t, i), i.changes;
}
function MCe(r, e) {
  for (let t = r; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function kCe(r, e, t = 1) {
  let i = r.charCategorizer(e), n = r.doc.lineAt(e), a = e - n.from;
  if (n.length == 0)
    return z.cursor(e);
  a == 0 ? t = 1 : a == n.length && (t = -1);
  let o = a, s = a;
  t < 0 ? o = li(n.text, a, !1) : s = li(n.text, a);
  let l = i(n.text.slice(o, s));
  for (; o > 0; ) {
    let u = li(n.text, o, !1);
    if (i(n.text.slice(u, o)) != l)
      break;
    o = u;
  }
  for (; s < n.length; ) {
    let u = li(n.text, s);
    if (i(n.text.slice(s, u)) != l)
      break;
    s = u;
  }
  return z.range(o + n.from, s + n.from);
}
function QCe(r, e) {
  return e.left > r ? e.left - r : Math.max(0, r - e.right);
}
function UCe(r, e) {
  return e.top > r ? e.top - r : Math.max(0, r - e.bottom);
}
function dR(r, e) {
  return r.top < e.bottom - 1 && r.bottom > e.top + 1;
}
function R$(r, e) {
  return e < r.top ? { top: e, left: r.left, right: r.right, bottom: r.bottom } : r;
}
function A$(r, e) {
  return e > r.bottom ? { top: r.top, left: r.left, right: r.right, bottom: e } : r;
}
function L_(r, e, t) {
  let i, n, a, o, s = !1, l, u, h, c;
  for (let p = r.firstChild; p; p = p.nextSibling) {
    let g = vg(p);
    for (let v = 0; v < g.length; v++) {
      let O = g[v];
      n && dR(n, O) && (O = R$(A$(O, n.bottom), n.top));
      let m = QCe(e, O), E = UCe(t, O);
      if (m == 0 && E == 0)
        return p.nodeType == 3 ? C$(p, e, t) : L_(p, e, t);
      if (!i || o > E || o == E && a > m) {
        i = p, n = O, a = m, o = E;
        let b = E ? t < O.top ? -1 : 1 : m ? e < O.left ? -1 : 1 : 0;
        s = !b || (b > 0 ? v < g.length - 1 : v > 0);
      }
      m == 0 ? t > O.bottom && (!h || h.bottom < O.bottom) ? (l = p, h = O) : t < O.top && (!c || c.top > O.top) && (u = p, c = O) : h && dR(h, O) ? h = A$(h, O.bottom) : c && dR(c, O) && (c = R$(c, O.top));
    }
  }
  if (h && h.bottom >= t ? (i = l, n = h) : c && c.top <= t && (i = u, n = c), !i)
    return { node: r, offset: 0 };
  let f = Math.max(n.left, Math.min(n.right, e));
  if (i.nodeType == 3)
    return C$(i, f, t);
  if (s && i.contentEditable != "false")
    return L_(i, f, t);
  let d = Array.prototype.indexOf.call(r.childNodes, i) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: r, offset: d };
}
function C$(r, e, t) {
  let i = r.nodeValue.length, n = -1, a = 1e9, o = 0;
  for (let s = 0; s < i; s++) {
    let l = lh(r, s, s + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let h = l[u];
      if (h.top == h.bottom)
        continue;
      o || (o = e - h.left);
      let c = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && c < a) {
        let f = e >= (h.left + h.right) / 2, d = f;
        if ((Ae.chrome || Ae.gecko) && lh(r, s).getBoundingClientRect().left == h.right && (d = !f), c <= 0)
          return { node: r, offset: s + (d ? 1 : 0) };
        n = s + (d ? 1 : 0), a = c;
      }
    }
  }
  return { node: r, offset: n > -1 ? n : o > 0 ? r.nodeValue.length : 0 };
}
function _7(r, e, t, i = -1) {
  var n, a;
  let o = r.contentDOM.getBoundingClientRect(), s = o.top + r.viewState.paddingTop, l, { docHeight: u } = r.viewState, { x: h, y: c } = e, f = c - s;
  if (f < 0)
    return 0;
  if (f > u)
    return r.state.doc.length;
  for (let b = r.viewState.heightOracle.textHeight / 2, T = !1; l = r.elementAtHeight(f), l.type != tr.Text; )
    for (; f = i > 0 ? l.bottom + b : l.top - b, !(f >= 0 && f <= u); ) {
      if (T)
        return t ? null : 0;
      T = !0, i = -i;
    }
  c = s + f;
  let d = l.from;
  if (d < r.viewport.from)
    return r.viewport.from == 0 ? 0 : t ? null : _$(r, o, l, h, c);
  if (d > r.viewport.to)
    return r.viewport.to == r.state.doc.length ? r.state.doc.length : t ? null : _$(r, o, l, h, c);
  let p = r.dom.ownerDocument, g = r.root.elementFromPoint ? r.root : p, v = g.elementFromPoint(h, c);
  v && !r.contentDOM.contains(v) && (v = null), v || (h = Math.max(o.left + 1, Math.min(o.right - 1, h)), v = g.elementFromPoint(h, c), v && !r.contentDOM.contains(v) && (v = null));
  let O, m = -1;
  if (v && ((n = r.docView.nearest(v)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let b = p.caretPositionFromPoint(h, c);
      b && ({ offsetNode: O, offset: m } = b);
    } else if (p.caretRangeFromPoint) {
      let b = p.caretRangeFromPoint(h, c);
      b && ({ startContainer: O, startOffset: m } = b, (!r.contentDOM.contains(O) || Ae.safari && $Ce(O, m, h) || Ae.chrome && GCe(O, m, h)) && (O = void 0));
    }
  }
  if (!O || !r.docView.dom.contains(O)) {
    let b = Si.find(r.docView, d);
    if (!b)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: O, offset: m } = L_(b.dom, h, c));
  }
  let E = r.docView.nearest(O);
  if (!E)
    return null;
  if (E.isWidget && ((a = E.dom) === null || a === void 0 ? void 0 : a.nodeType) == 1) {
    let b = E.dom.getBoundingClientRect();
    return e.y < b.top || e.y <= b.bottom && e.x <= (b.left + b.right) / 2 ? E.posAtStart : E.posAtEnd;
  } else
    return E.localPosFromDOM(O, m) + E.posAtStart;
}
function _$(r, e, t, i, n) {
  let a = Math.round((i - e.left) * r.defaultCharacterWidth);
  if (r.lineWrapping && t.height > r.defaultLineHeight * 1.5) {
    let s = r.viewState.heightOracle.textHeight, l = Math.floor((n - t.top - (r.defaultLineHeight - s) * 0.5) / s);
    a += l * r.viewState.heightOracle.lineLength;
  }
  let o = r.state.sliceDoc(t.from, t.to);
  return t.from + b_(o, a, r.state.tabSize);
}
function $Ce(r, e, t) {
  let i;
  if (r.nodeType != 3 || e != (i = r.nodeValue.length))
    return !1;
  for (let n = r.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return lh(r, i - 1, i).getBoundingClientRect().left > t;
}
function GCe(r, e, t) {
  if (e != 0)
    return !1;
  for (let n = r; ; ) {
    let a = n.parentNode;
    if (!a || a.nodeType != 1 || a.firstChild != n)
      return !1;
    if (a.classList.contains("cm-line"))
      break;
    n = a;
  }
  let i = r.nodeType == 1 ? r.getBoundingClientRect() : lh(r, 0, Math.max(r.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function D_(r, e) {
  let t = r.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == tr.Text))
        return i;
  }
  return t;
}
function BCe(r, e, t, i) {
  let n = D_(r, e.head), a = !i || n.type != tr.Text || !(r.lineWrapping || n.widgetLineBreaks) ? null : r.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (a) {
    let o = r.dom.getBoundingClientRect(), s = r.textDirectionAt(n.from), l = r.posAtCoords({
      x: t == (s == Jt.LTR) ? o.right - 1 : o.left + 1,
      y: (a.top + a.bottom) / 2
    });
    if (l != null)
      return z.cursor(l, t ? -1 : 1);
  }
  return z.cursor(t ? n.to : n.from, t ? -1 : 1);
}
function I$(r, e, t, i) {
  let n = r.state.doc.lineAt(e.head), a = r.bidiSpans(n), o = r.textDirectionAt(n.from);
  for (let s = e, l = null; ; ) {
    let u = xCe(n, a, o, s, t), h = R7;
    if (!u) {
      if (n.number == (t ? r.state.doc.lines : 1))
        return s;
      h = `
`, n = r.state.doc.line(n.number + (t ? 1 : -1)), a = r.bidiSpans(n), u = z.cursor(t ? n.from : n.to);
    }
    if (l) {
      if (!l(h))
        return s;
    } else {
      if (!i)
        return u;
      l = i(h);
    }
    s = u;
  }
}
function VCe(r, e, t) {
  let i = r.state.charCategorizer(e), n = i(t);
  return (a) => {
    let o = i(a);
    return n == Pt.Space && (n = o), n == o;
  };
}
function FCe(r, e, t, i) {
  let n = e.head, a = t ? 1 : -1;
  if (n == (t ? r.state.doc.length : 0))
    return z.cursor(n, e.assoc);
  let o = e.goalColumn, s, l = r.contentDOM.getBoundingClientRect(), u = r.coordsAtPos(n), h = r.documentTop;
  if (u)
    o == null && (o = u.left - l.left), s = a < 0 ? u.top : u.bottom;
  else {
    let d = r.viewState.lineBlockAt(n);
    o == null && (o = Math.min(l.right - l.left, r.defaultCharacterWidth * (n - d.from))), s = (a < 0 ? d.top : d.bottom) + h;
  }
  let c = l.left + o, f = i ?? r.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = s + (f + d) * a, g = _7(r, { x: c, y: p }, !1, a);
    if (p < l.top || p > l.bottom || (a < 0 ? g < n : g > n))
      return z.cursor(g, e.assoc, void 0, o);
  }
}
function Nm(r, e, t) {
  for (; ; ) {
    let i = 0;
    for (let n of r)
      n.between(e - 1, e + 1, (a, o, s) => {
        if (e > a && e < o) {
          let l = i || t || (e - a < o - e ? -1 : 1);
          e = l < 0 ? a : o, i = l;
        }
      });
    if (!i)
      return e;
  }
}
function pR(r, e, t) {
  let i = Nm(r.state.facet(Dw).map((n) => n(r)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : z.cursor(i, i < t.from ? 1 : -1);
}
class XCe {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null;
    let t = (i, n) => {
      this.ignoreDuringComposition(n) || n.type == "keydown" && this.keydown(e, n) || (this.mustFlushObserver(n) && e.observer.forceFlush(), this.runCustomHandlers(n.type, e, n) ? n.preventDefault() : i(e, n));
    };
    for (let i in vr) {
      let n = vr[i];
      e.contentDOM.addEventListener(i, (a) => {
        x$(e, a) && t(n, a);
      }, M_[i]), this.registeredEvents.push(i);
    }
    e.scrollDOM.addEventListener("mousedown", (i) => {
      if (i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && (t(vr.mousedown, i), !i.defaultPrevented && i.button == 2)) {
        let n = e.contentDOM.style.minHeight;
        e.contentDOM.style.minHeight = "100%", setTimeout(() => e.contentDOM.style.minHeight = n, 200);
      }
    }), e.scrollDOM.addEventListener("drop", (i) => {
      i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && t(vr.drop, i);
    }), Ae.chrome && Ae.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: !0 }), this.notifiedFocused = e.hasFocus, Ae.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e, t) {
    var i;
    let n;
    this.customHandlers = [];
    for (let a of t)
      if (n = (i = a.update(e).spec) === null || i === void 0 ? void 0 : i.domEventHandlers) {
        this.customHandlers.push({ plugin: a.value, handlers: n });
        for (let o in n)
          this.registeredEvents.indexOf(o) < 0 && o != "scroll" && (this.registeredEvents.push(o), e.contentDOM.addEventListener(o, (s) => {
            x$(e, s) && this.runCustomHandlers(o, e, s) && s.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, t, i) {
    for (let n of this.customHandlers) {
      let a = n.handlers[e];
      if (a)
        try {
          if (a.call(n.plugin, i, t) || i.defaultPrevented)
            return !0;
        } catch (o) {
          Xn(t.state, o);
        }
    }
    return !1;
  }
  runScrollHandlers(e, t) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let i of this.customHandlers) {
      let n = i.handlers.scroll;
      if (n)
        try {
          n.call(i.plugin, t, e);
        } catch (a) {
          Xn(e.state, a);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (t.keyCode != 27 && x7.indexOf(t.keyCode) < 0 && (e.inputState.lastEscPress = 0), Ae.android && Ae.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let i;
    return Ae.ios && !t.synthetic && !t.altKey && !t.metaKey && ((i = I7.find((n) => n.keyCode == t.keyCode)) && !t.ctrlKey || YCe.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = i || t, setTimeout(() => this.flushIOSKey(e), 250), !0) : !1;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, Qc(e.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : Ae.safari && !Ae.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const I7 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], YCe = "dthko", x7 = [16, 17, 18, 20, 91, 92, 224, 225], QO = 6;
function UO(r) {
  return Math.max(0, r) * 0.7 + 8;
}
function HCe(r, e) {
  return Math.max(Math.abs(r.clientX - e.clientX), Math.abs(r.clientY - e.clientY));
}
class WCe {
  constructor(e, t, i, n) {
    this.view = e, this.startEvent = t, this.style = i, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = dCe(e.contentDOM), this.atoms = e.state.facet(Dw).map((o) => o(e));
    let a = e.contentDOM.ownerDocument;
    a.addEventListener("mousemove", this.move = this.move.bind(this)), a.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(St.allowMultipleSelections) && zCe(e, t), this.dragging = qCe(e, t) && L7(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && (e.preventDefault(), this.select(e));
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && HCe(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, n = 0, a = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = S7(this.view);
    e.clientX - o.left <= a.left + QO ? i = -UO(a.left - e.clientX) : e.clientX + o.right >= a.right - QO && (i = UO(e.clientX - a.right)), e.clientY - o.top <= a.top + QO ? n = -UO(a.top - e.clientY) : e.clientY + o.bottom >= a.bottom - QO && (n = UO(e.clientY - a.bottom)), this.setScrollSpeed(i, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let n = e.ranges[i], a = null;
      if (n.empty) {
        let o = Nm(this.atoms, n.from, 0);
        o != n.from && (a = z.cursor(o, -1));
      } else {
        let o = Nm(this.atoms, n.from, -1), s = Nm(this.atoms, n.to, 1);
        (o != n.from || s != n.to) && (a = z.range(n.from == n.anchor ? o : s, n.from == n.head ? o : s));
      }
      a && (t || (t = e.ranges.slice()), t[i] = a);
    }
    return t ? z.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection) || i.main.assoc != t.state.selection.main.assoc && this.dragging === !1) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function zCe(r, e) {
  let t = r.state.facet(c7);
  return t.length ? t[0](e) : Ae.mac ? e.metaKey : e.ctrlKey;
}
function ZCe(r, e) {
  let t = r.state.facet(f7);
  return t.length ? t[0](e) : Ae.mac ? !e.altKey : !e.ctrlKey;
}
function qCe(r, e) {
  let { main: t } = r.state.selection;
  if (t.empty)
    return !1;
  let i = lb(r.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let n = i.getRangeAt(0).getClientRects();
  for (let a = 0; a < n.length; a++) {
    let o = n[a];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function x$(r, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != r.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = Ft.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const vr = /* @__PURE__ */ Object.create(null), M_ = /* @__PURE__ */ Object.create(null), w7 = Ae.ie && Ae.ie_version < 15 || Ae.ios && Ae.webkit_version < 604;
function jCe(r) {
  let e = r.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    r.focus(), t.remove(), P7(r, t.value);
  }, 50);
}
function P7(r, e) {
  let { state: t } = r, i, n = 1, a = t.toText(e), o = a.lines == t.selection.ranges.length;
  if (k_ != null && t.selection.ranges.every((l) => l.empty) && k_ == a.toString()) {
    let l = -1;
    i = t.changeByRange((u) => {
      let h = t.doc.lineAt(u.from);
      if (h.from == l)
        return { range: u };
      l = h.from;
      let c = t.toText((o ? a.line(n++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: c },
        range: z.cursor(u.from + c.length)
      };
    });
  } else
    o ? i = t.changeByRange((l) => {
      let u = a.line(n++);
      return {
        changes: { from: l.from, to: l.to, insert: u.text },
        range: z.cursor(l.from + u.length)
      };
    }) : i = t.replaceSelection(a);
  r.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
vr.keydown = (r, e) => {
  r.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (r.inputState.lastEscPress = Date.now());
};
vr.touchstart = (r, e) => {
  r.inputState.lastTouchTime = Date.now(), r.inputState.setSelectionOrigin("select.pointer");
};
vr.touchmove = (r) => {
  r.inputState.setSelectionOrigin("select.pointer");
};
M_.touchstart = M_.touchmove = { passive: !0 };
vr.mousedown = (r, e) => {
  if (r.observer.flush(), r.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let t = null;
  for (let i of r.state.facet(d7))
    if (t = i(r, e), t)
      break;
  if (!t && e.button == 0 && (t = e_e(r, e)), t) {
    let i = !r.hasFocus;
    r.inputState.startMouseSelection(new WCe(r, e, t, i)), i && r.observer.ignore(() => K4(r.contentDOM)), r.inputState.mouseSelection && r.inputState.mouseSelection.start(e);
  }
};
function w$(r, e, t, i) {
  if (i == 1)
    return z.cursor(e, t);
  if (i == 2)
    return kCe(r.state, e, t);
  {
    let n = Si.find(r.docView, e), a = r.state.doc.lineAt(n ? n.posAtEnd : e), o = n ? n.posAtStart : a.from, s = n ? n.posAtEnd : a.to;
    return s < r.state.doc.length && s == a.to && s++, z.range(o, s);
  }
}
let N7 = (r, e) => r >= e.top && r <= e.bottom, P$ = (r, e, t) => N7(e, t) && r >= t.left && r <= t.right;
function KCe(r, e, t, i) {
  let n = Si.find(r.docView, e);
  if (!n)
    return 1;
  let a = e - n.posAtStart;
  if (a == 0)
    return 1;
  if (a == n.length)
    return -1;
  let o = n.coordsAt(a, -1);
  if (o && P$(t, i, o))
    return -1;
  let s = n.coordsAt(a, 1);
  return s && P$(t, i, s) ? 1 : o && N7(i, o) ? -1 : 1;
}
function N$(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: KCe(r, t, e.clientX, e.clientY) };
}
const JCe = Ae.ie && Ae.ie_version <= 11;
let L$ = null, D$ = 0, M$ = 0;
function L7(r) {
  if (!JCe)
    return r.detail;
  let e = L$, t = M$;
  return L$ = r, M$ = Date.now(), D$ = !e || t > Date.now() - 400 && Math.abs(e.clientX - r.clientX) < 2 && Math.abs(e.clientY - r.clientY) < 2 ? (D$ + 1) % 3 : 1;
}
function e_e(r, e) {
  let t = N$(r, e), i = L7(e), n = r.state.selection;
  return {
    update(a) {
      a.docChanged && (t.pos = a.changes.mapPos(t.pos), n = n.map(a.changes));
    },
    get(a, o, s) {
      let l = N$(r, a), u, h = w$(r, l.pos, l.bias, i);
      if (t.pos != l.pos && !o) {
        let c = w$(r, t.pos, t.bias, i), f = Math.min(c.from, h.from), d = Math.max(c.to, h.to);
        h = f < h.from ? z.range(f, d) : z.range(d, f);
      }
      return o ? n.replaceRange(n.main.extend(h.from, h.to)) : s && i == 1 && n.ranges.length > 1 && (u = t_e(n, l.pos)) ? u : s ? n.addRange(h) : z.create([h]);
    }
  };
}
function t_e(r, e) {
  for (let t = 0; t < r.ranges.length; t++) {
    let { from: i, to: n } = r.ranges[t];
    if (i <= e && n >= e)
      return z.create(r.ranges.slice(0, t).concat(r.ranges.slice(t + 1)), r.mainIndex == t ? 0 : r.mainIndex - (r.mainIndex > t ? 1 : 0));
  }
  return null;
}
vr.dragstart = (r, e) => {
  let { selection: { main: t } } = r.state, { mouseSelection: i } = r.inputState;
  i && (i.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", r.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function k$(r, e, t, i) {
  if (!t)
    return;
  let n = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  e.preventDefault();
  let { mouseSelection: a } = r.inputState, o = i && a && a.dragging && ZCe(r, e) ? { from: a.dragging.from, to: a.dragging.to } : null, s = { from: n, insert: t }, l = r.state.changes(o ? [o, s] : s);
  r.focus(), r.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(n, -1), head: l.mapPos(n, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  });
}
vr.drop = (r, e) => {
  if (!e.dataTransfer)
    return;
  if (r.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let i = Array(t.length), n = 0, a = () => {
      ++n == t.length && k$(r, e, i.filter((o) => o != null).join(r.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let s = new FileReader();
      s.onerror = a, s.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(s.result) || (i[o] = s.result), a();
      }, s.readAsText(t[o]);
    }
  } else
    k$(r, e, e.dataTransfer.getData("Text"), !0);
};
vr.paste = (r, e) => {
  if (r.state.readOnly)
    return e.preventDefault();
  r.observer.flush();
  let t = w7 ? null : e.clipboardData;
  t ? (P7(r, t.getData("text/plain") || t.getData("text/uri-text")), e.preventDefault()) : jCe(r);
};
function r_e(r, e) {
  let t = r.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), r.focus();
  }, 50);
}
function i_e(r) {
  let e = [], t = [], i = !1;
  for (let n of r.selection.ranges)
    n.empty || (e.push(r.sliceDoc(n.from, n.to)), t.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: a } of r.selection.ranges) {
      let o = r.doc.lineAt(a);
      o.number > n && (e.push(o.text), t.push({ from: o.from, to: Math.min(r.doc.length, o.to + 1) })), n = o.number;
    }
    i = !0;
  }
  return { text: e.join(r.lineBreak), ranges: t, linewise: i };
}
let k_ = null;
vr.copy = vr.cut = (r, e) => {
  let { text: t, ranges: i, linewise: n } = i_e(r.state);
  if (!t && !n)
    return;
  k_ = n ? t : null;
  let a = w7 ? null : e.clipboardData;
  a ? (e.preventDefault(), a.clearData(), a.setData("text/plain", t)) : r_e(r, t), e.type == "cut" && !r.state.readOnly && r.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
const D7 = /* @__PURE__ */ is.define();
function M7(r, e) {
  let t = [];
  for (let i of r.facet(v7)) {
    let n = i(r, e);
    n && t.push(n);
  }
  return t ? r.update({ effects: t, annotations: D7.of(!0) }) : null;
}
function k7(r) {
  setTimeout(() => {
    let e = r.hasFocus;
    if (e != r.inputState.notifiedFocused) {
      let t = M7(r.state, e);
      t ? r.dispatch(t) : r.update([]);
    }
  }, 10);
}
vr.focus = (r) => {
  r.inputState.lastFocusTime = Date.now(), !r.scrollDOM.scrollTop && (r.inputState.lastScrollTop || r.inputState.lastScrollLeft) && (r.scrollDOM.scrollTop = r.inputState.lastScrollTop, r.scrollDOM.scrollLeft = r.inputState.lastScrollLeft), k7(r);
};
vr.blur = (r) => {
  r.observer.clearSelectionRange(), k7(r);
};
vr.compositionstart = vr.compositionupdate = (r) => {
  r.inputState.compositionFirstChange == null && (r.inputState.compositionFirstChange = !0), r.inputState.composing < 0 && (r.inputState.composing = 0);
};
vr.compositionend = (r) => {
  r.inputState.composing = -1, r.inputState.compositionEndedAt = Date.now(), r.inputState.compositionPendingKey = !0, r.inputState.compositionPendingChange = r.observer.pendingRecords().length > 0, r.inputState.compositionFirstChange = null, Ae.chrome && Ae.android ? r.observer.flushSoon() : r.inputState.compositionPendingChange ? Promise.resolve().then(() => r.observer.flush()) : setTimeout(() => {
    r.inputState.composing < 0 && r.docView.hasComposition && r.update([]);
  }, 50);
};
vr.contextmenu = (r) => {
  r.inputState.lastContextMenu = Date.now();
};
vr.beforeinput = (r, e) => {
  var t;
  let i;
  if (Ae.chrome && Ae.android && (i = I7.find((n) => n.inputType == e.inputType)) && (r.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > n + 10 && r.hasFocus && (r.contentDOM.blur(), r.focus());
    }, 100);
  }
};
const Q$ = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class n_e {
  constructor(e) {
    this.lineWrapping = e, this.doc = Rt.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return Q$.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (t = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, n, a, o) {
    let s = Q$.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != s;
    if (this.lineWrapping = s, this.lineHeight = t, this.charWidth = i, this.textHeight = n, this.lineLength = a, l) {
      this.heightSamples = {};
      for (let u = 0; u < o.length; u++) {
        let h = o[u];
        h < 0 ? u++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return l;
  }
}
class a_e {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class Fa {
  /**
  @internal
  */
  constructor(e, t, i, n, a) {
    this.from = e, this.length = t, this.top = i, this.height = n, this._content = a;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? tr.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof vl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new Fa(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Yt = /* @__PURE__ */ function(r) {
  return r[r.ByPos = 0] = "ByPos", r[r.ByHeight = 1] = "ByHeight", r[r.ByPosNoHeight = 2] = "ByPosNoHeight", r;
}(Yt || (Yt = {}));
const Lm = 1e-3;
class Ci {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > Lm && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return Ci.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, n) {
    let a = this, o = i.doc;
    for (let s = n.length - 1; s >= 0; s--) {
      let { fromA: l, toA: u, fromB: h, toB: c } = n[s], f = a.lineAt(l, Yt.ByPosNoHeight, i.setDoc(t), 0, 0), d = f.to >= u ? f : a.lineAt(u, Yt.ByPosNoHeight, i, 0, 0);
      for (c += d.to - u, u = d.to; s > 0 && f.from <= n[s - 1].toA; )
        l = n[s - 1].fromA, h = n[s - 1].fromB, s--, l < f.from && (f = a.lineAt(l, Yt.ByPosNoHeight, i, 0, 0));
      h += f.from - l, l = f.from;
      let p = Mw.build(i.setDoc(o), e, h, c);
      a = a.replace(l, u, p);
    }
    return a.updateHeight(i, 0);
  }
  static empty() {
    return new tn(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, n = 0, a = 0;
    for (; ; )
      if (t == i)
        if (n > a * 2) {
          let s = e[t - 1];
          s.break ? e.splice(--t, 1, s.left, null, s.right) : e.splice(--t, 1, s.left, s.right), i += 1 + s.break, n -= s.size;
        } else if (a > n * 2) {
          let s = e[i];
          s.break ? e.splice(i, 1, s.left, null, s.right) : e.splice(i, 1, s.left, s.right), i += 2 + s.break, a -= s.size;
        } else
          break;
      else if (n < a) {
        let s = e[t++];
        s && (n += s.size);
      } else {
        let s = e[--i];
        s && (a += s.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, i++), new o_e(Ci.of(e.slice(0, t)), o, Ci.of(e.slice(i)));
  }
}
Ci.prototype.size = 1;
class Q7 extends Ci {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, n) {
    return new Fa(n, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, n, a) {
    return this.blockAt(0, i, n, a);
  }
  forEachLine(e, t, i, n, a, o) {
    e <= a + this.length && t >= a && o(this.blockAt(0, i, n, a));
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more && this.setHeight(e, n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class tn extends Q7 {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, n) {
    return new Fa(n, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof tn || n instanceof Vr && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof Vr ? n = new tn(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : Ci.of(i);
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more ? this.setHeight(e, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class Vr extends Ci {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, n = e.doc.lineAt(t + this.length).number, a = n - i + 1, o, s = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * a);
      o = l / a, this.length > a + 1 && (s = (this.height - l) / (this.length - a - 1));
    } else
      o = this.height / a;
    return { firstLine: i, lastLine: n, perLine: o, perChar: s };
  }
  blockAt(e, t, i, n) {
    let { firstLine: a, lastLine: o, perLine: s, perChar: l } = this.heightMetrics(t, n);
    if (t.lineWrapping) {
      let u = n + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), h = t.doc.lineAt(u), c = s + h.length * l, f = Math.max(i, e - c / 2);
      return new Fa(h.from, h.length, f, c, 0);
    } else {
      let u = Math.max(0, Math.min(o - a, Math.floor((e - i) / s))), { from: h, length: c } = t.doc.line(a + u);
      return new Fa(h, c, i + s * u, s, 0);
    }
  }
  lineAt(e, t, i, n, a) {
    if (t == Yt.ByHeight)
      return this.blockAt(e, i, n, a);
    if (t == Yt.ByPosNoHeight) {
      let { from: d, to: p } = i.doc.lineAt(e);
      return new Fa(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: s, perChar: l } = this.heightMetrics(i, a), u = i.doc.lineAt(e), h = s + u.length * l, c = u.number - o, f = n + s * c + l * (u.from - a - c);
    return new Fa(u.from, u.length, Math.max(n, Math.min(f, n + this.height - h)), h, 0);
  }
  forEachLine(e, t, i, n, a, o) {
    e = Math.max(e, a), t = Math.min(t, a + this.length);
    let { firstLine: s, perLine: l, perChar: u } = this.heightMetrics(i, a);
    for (let h = e, c = n; h <= t; ) {
      let f = i.doc.lineAt(h);
      if (h == e) {
        let p = f.number - s;
        c += l * p + u * (e - a - p);
      }
      let d = l + u * f.length;
      o(new Fa(f.from, f.length, c, d, 0)), c += d, h = f.to + 1;
    }
  }
  replace(e, t, i) {
    let n = this.length - t;
    if (n > 0) {
      let a = i[i.length - 1];
      a instanceof Vr ? i[i.length - 1] = new Vr(a.length + n) : i.push(null, new Vr(n - 1));
    }
    if (e > 0) {
      let a = i[0];
      a instanceof Vr ? i[0] = new Vr(e + a.length) : i.unshift(new Vr(e - 1), null);
    }
    return Ci.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new Vr(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new Vr(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, n) {
    let a = t + this.length;
    if (n && n.from <= t + this.length && n.more) {
      let o = [], s = Math.max(t, n.from), l = -1;
      for (n.from > t && o.push(new Vr(n.from - t - 1).updateHeight(e, t)); s <= a && n.more; ) {
        let h = e.doc.lineAt(s).length;
        o.length && o.push(null);
        let c = n.heights[n.index++];
        l == -1 ? l = c : Math.abs(c - l) >= Lm && (l = -2);
        let f = new tn(h, c);
        f.outdated = !1, o.push(f), s += h + 1;
      }
      s <= a && o.push(null, new Vr(a - s).updateHeight(e, s));
      let u = Ci.of(o);
      return (l < 0 || Math.abs(u.height - this.height) >= Lm || Math.abs(l - this.heightMetrics(e, t).perLine) >= Lm) && (e.heightChanged = !0), u;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class o_e extends Ci {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, n) {
    let a = i + this.left.height;
    return e < a ? this.left.blockAt(e, t, i, n) : this.right.blockAt(e, t, a, n + this.left.length + this.break);
  }
  lineAt(e, t, i, n, a) {
    let o = n + this.left.height, s = a + this.left.length + this.break, l = t == Yt.ByHeight ? e < o : e < s, u = l ? this.left.lineAt(e, t, i, n, a) : this.right.lineAt(e, t, i, o, s);
    if (this.break || (l ? u.to < s : u.from > s))
      return u;
    let h = t == Yt.ByPosNoHeight ? Yt.ByPosNoHeight : Yt.ByPos;
    return l ? u.join(this.right.lineAt(s, h, i, o, s)) : this.left.lineAt(s, h, i, n, a).join(u);
  }
  forEachLine(e, t, i, n, a, o) {
    let s = n + this.left.height, l = a + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, i, n, a, o), t >= l && this.right.forEachLine(e, t, i, s, l, o);
    else {
      let u = this.lineAt(l, Yt.ByPos, i, n, a);
      e < u.from && this.left.forEachLine(e, u.from - 1, i, n, a, o), u.to >= e && u.from <= t && o(u), t > u.to && this.right.forEachLine(u.to + 1, t, i, s, l, o);
    }
  }
  replace(e, t, i) {
    let n = this.left.length + this.break;
    if (t < n)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, t - n, i));
    let a = [];
    e > 0 && this.decomposeLeft(e, a);
    let o = a.length;
    for (let s of i)
      a.push(s);
    if (e > 0 && U$(a, o - 1), t < this.length) {
      let s = a.length;
      this.decomposeRight(t, a), U$(a, s);
    }
    return Ci.of(a);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, n = i + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < n && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Ci.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, n) {
    let { left: a, right: o } = this, s = t + a.length + this.break, l = null;
    return n && n.from <= t + a.length && n.more ? l = a = a.updateHeight(e, t, i, n) : a.updateHeight(e, t, i), n && n.from <= s + o.length && n.more ? l = o = o.updateHeight(e, s, i, n) : o.updateHeight(e, s, i), l ? this.balanced(a, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function U$(r, e) {
  let t, i;
  r[e] == null && (t = r[e - 1]) instanceof Vr && (i = r[e + 1]) instanceof Vr && r.splice(e - 1, 3, new Vr(t.length + 1 + i.length));
}
const s_e = 5;
class Mw {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof tn ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new tn(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0, a = i.widget ? i.widget.lineBreaks : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let o = t - e;
      i.block ? this.addBlock(new Q7(o, n, i)) : (o || a || n >= s_e) && this.addLineDeco(n, a, o);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new tn(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new Vr(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof tn)
      return e;
    let t = new tn(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    var t;
    this.enterLine();
    let i = (t = e.deco) === null || t === void 0 ? void 0 : t.type;
    i == tr.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, i != tr.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let n = this.ensureLine();
    n.length += i, n.collapsed += i, n.widgetHeight = Math.max(n.widgetHeight, e), n.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof tn) && !this.isCovered ? this.nodes.push(new tn(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let n of this.nodes)
      n instanceof tn && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, n) {
    let a = new Mw(i, e);
    return Nt.spans(t, i, n, a, 0), a.finish(i);
  }
}
function l_e(r, e, t) {
  let i = new u_e();
  return Nt.compare(r, e, t, i, 0), i.changes;
}
class u_e {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, n) {
    (e < t || i && i.heightRelevant || n && n.heightRelevant) && x_(e, t, this.changes, 5);
  }
}
function h_e(r, e) {
  let t = r.getBoundingClientRect(), i = r.ownerDocument, n = i.defaultView || window, a = Math.max(0, t.left), o = Math.min(n.innerWidth, t.right), s = Math.max(0, t.top), l = Math.min(n.innerHeight, t.bottom);
  for (let u = r.parentNode; u && u != i.body; )
    if (u.nodeType == 1) {
      let h = u, c = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && c.overflow != "visible") {
        let f = h.getBoundingClientRect();
        a = Math.max(a, f.left), o = Math.min(o, f.right), s = Math.max(s, f.top), l = u == r.parentNode ? f.bottom : Math.min(l, f.bottom);
      }
      u = c.position == "absolute" || c.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: a - t.left,
    right: Math.max(a, o) - t.left,
    top: s - (t.top + e),
    bottom: Math.max(s, l) - (t.top + e)
  };
}
function c_e(r, e) {
  let t = r.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class gR {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i], a = t[i];
      if (n.from != a.from || n.to != a.to || n.size != a.size)
        return !1;
    }
    return !0;
  }
  draw(e) {
    return Be.replace({ widget: new f_e(this.size, e) }).range(this.from, this.to);
  }
}
class f_e extends ns {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class $$ {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = G$, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Jt.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Lw).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new n_e(t), this.stateDeco = e.facet(Og).filter((i) => typeof i != "function"), this.heightMap = Ci.empty().applyChanges(this.stateDeco, Rt.empty, this.heightOracle.setDoc(e.doc), [new Yn(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Be.set(this.lineGaps.map((i) => i.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? t.head : t.anchor;
      if (!e.some(({ from: a, to: o }) => n >= a && n <= o)) {
        let { from: a, to: o } = this.lineBlockAt(n);
        e.push(new $O(a, o));
      }
    }
    this.viewports = e.sort((i, n) => i.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? G$ : new g_e(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Hd(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(Og).filter((h) => typeof h != "function");
    let n = e.changedRanges, a = Yn.extendWithRanges(n, l_e(i, this.stateDeco, e ? e.changes : br.empty(this.state.doc.length))), o = this.heightMap.height, s = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), a), this.heightMap.height != o && (e.flags |= 2), s ? (this.scrollAnchorPos = e.changes.mapPos(s.from, -1), this.scrollAnchorHeight = s.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = a.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let u = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), u && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(m7) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), n = this.heightOracle, a = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Jt.RTL : Jt.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(a), s = t.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != s.height;
    this.contentDOMHeight = s.height, this.mustMeasureContent = !1;
    let u = 0, h = 0, c = parseInt(i.paddingTop) || 0, f = parseInt(i.paddingBottom) || 0;
    (this.paddingTop != c || this.paddingBottom != f) && (this.paddingTop = c, this.paddingBottom = f, u |= 10), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 8), this.scrollTop != e.scrollDOM.scrollTop && (this.scrollAnchorHeight = -1, this.scrollTop = e.scrollDOM.scrollTop), this.scrolledToBottom = e7(e.scrollDOM);
    let d = (this.printing ? c_e : h_e)(t, this.paddingTop), p = d.top - this.pixelViewport.top, g = d.bottom - this.pixelViewport.bottom;
    this.pixelViewport = d;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v != this.inView && (this.inView = v, v && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let O = s.width;
    if ((this.contentDOMWidth != O || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = s.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 8), l) {
      let E = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(E) && (o = !0), o || n.lineWrapping && Math.abs(O - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: b, charWidth: T, textHeight: S } = e.docView.measureTextSize();
        o = b > 0 && n.refresh(a, b, T, S, O / T, E), o && (e.docView.minWidth = 0, u |= 8);
      }
      p > 0 && g > 0 ? h = Math.max(p, g) : p < 0 && g < 0 && (h = Math.min(p, g)), n.heightChanged = !1;
      for (let b of this.viewports) {
        let T = b.from == this.viewport.from ? E : e.docView.measureVisibleLineHeights(b);
        this.heightMap = (o ? Ci.empty().applyChanges(this.stateDeco, Rt.empty, this.heightOracle, [new Yn(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, o, new a_e(b.from, T));
      }
      n.heightChanged && (u |= 2);
    }
    let m = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return m && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (u & 2 || m) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, a = this.heightOracle, { visibleTop: o, visibleBottom: s } = this, l = new $O(n.lineAt(o - i * 1e3, Yt.ByHeight, a, 0, 0).from, n.lineAt(s + (1 - i) * 1e3, Yt.ByHeight, a, 0, 0).to);
    if (t) {
      let { head: u } = t.range;
      if (u < l.from || u > l.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), c = n.lineAt(u, Yt.ByPos, a, 0, 0), f;
        t.y == "center" ? f = (c.top + c.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && u < l.from ? f = c.top : f = c.bottom - h, l = new $O(n.lineAt(f - 1e3 / 2, Yt.ByHeight, a, 0, 0).from, n.lineAt(f + h + 1e3 / 2, Yt.ByHeight, a, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), n = t.mapPos(e.to, 1);
    return new $O(this.heightMap.lineAt(i, Yt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(n, Yt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(e, Yt.ByPos, this.heightOracle, 0, 0), { bottom: a } = this.heightMap.lineAt(t, Yt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: s } = this;
    return (e == 0 || n <= o - Math.max(10, Math.min(
      -i,
      250
      /* MaxCoverMargin */
    ))) && (t == this.state.doc.length || a >= s + Math.max(10, Math.min(
      i,
      250
      /* MaxCoverMargin */
    ))) && n > o - 2 * 1e3 && a < s + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let n of e)
      t.touchesRange(n.from, n.to) || i.push(new gR(t.mapPos(n.from), t.mapPos(n.to), n.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, a = n >> 1, o = n << 1;
    if (this.defaultTextDirection != Jt.LTR && !i)
      return [];
    let s = [], l = (u, h, c, f) => {
      if (h - u < a)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let v of p)
        if (v > u && v < h) {
          l(u, v - 10, c, f), l(v + 10, h, c, f);
          return;
        }
      let g = p_e(e, (v) => v.from >= c.from && v.to <= c.to && Math.abs(v.from - u) < a && Math.abs(v.to - h) < a && !p.some((O) => v.from < O && v.to > O));
      if (!g) {
        if (h < c.to && t && i && t.visibleRanges.some((v) => v.from <= h && v.to >= h)) {
          let v = t.moveToLineBoundary(z.cursor(h), !1, !0).head;
          v > u && (h = v);
        }
        g = new gR(u, h, this.gapSize(c, u, h, f));
      }
      s.push(g);
    };
    for (let u of this.viewportLines) {
      if (u.length < o)
        continue;
      let h = d_e(u.from, u.to, this.stateDeco);
      if (h.total < o)
        continue;
      let c = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (i) {
        let p = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, v;
        if (c != null) {
          let O = BO(h, c), m = ((this.visibleBottom - this.visibleTop) / 2 + p) / u.height;
          g = O - m, v = O + m;
        } else
          g = (this.visibleTop - u.top - p) / u.height, v = (this.visibleBottom - u.top + p) / u.height;
        f = GO(h, g), d = GO(h, v);
      } else {
        let p = h.total * this.heightOracle.charWidth, g = n * this.heightOracle.charWidth, v, O;
        if (c != null) {
          let m = BO(h, c), E = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          v = m - E, O = m + E;
        } else
          v = (this.pixelViewport.left - g) / p, O = (this.pixelViewport.right + g) / p;
        f = GO(h, v), d = GO(h, O);
      }
      f > u.from && l(u.from, f, u, h), d < u.to && l(d, u.to, u, h);
    }
    return s;
  }
  gapSize(e, t, i, n) {
    let a = BO(n, i) - BO(n, t);
    return this.heightOracle.lineWrapping ? e.height * a : n.total * this.heightOracle.charWidth * a;
  }
  updateLineGaps(e) {
    gR.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Be.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    Nt.spans(e, this.viewport.from, this.viewport.to, {
      span(n, a) {
        t.push({ from: n, to: a });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((n, a) => n.from != t[a].from || n.to != t[a].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Hd(this.heightMap.lineAt(e, Yt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Hd(this.heightMap.lineAt(this.scaler.fromDOM(e), Yt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Hd(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class $O {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function d_e(r, e, t) {
  let i = [], n = r, a = 0;
  return Nt.spans(t, r, e, {
    span() {
    },
    point(o, s) {
      o > n && (i.push({ from: n, to: o }), a += o - n), n = s;
    }
  }, 20), n < e && (i.push({ from: n, to: e }), a += e - n), { total: a, ranges: i };
}
function GO({ total: r, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(r * t);
  for (let n = 0; ; n++) {
    let { from: a, to: o } = e[n], s = o - a;
    if (i <= s)
      return a + i;
    i -= s;
  }
}
function BO(r, e) {
  let t = 0;
  for (let { from: i, to: n } of r.ranges) {
    if (e <= n) {
      t += e - i;
      break;
    }
    t += n - i;
  }
  return t / r.total;
}
function p_e(r, e) {
  for (let t of r)
    if (e(t))
      return t;
}
const G$ = {
  toDOM(r) {
    return r;
  },
  fromDOM(r) {
    return r;
  },
  scale: 1
};
class g_e {
  constructor(e, t, i) {
    let n = 0, a = 0, o = 0;
    this.viewports = i.map(({ from: s, to: l }) => {
      let u = t.lineAt(s, Yt.ByPos, e, 0, 0).top, h = t.lineAt(l, Yt.ByPos, e, 0, 0).bottom;
      return n += h - u, { from: s, to: l, top: u, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (t.height - n);
    for (let s of this.viewports)
      s.domTop = o + (s.top - a) * this.scale, o = s.domBottom = s.domTop + (s.bottom - s.top), a = s.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let a = t < this.viewports.length ? this.viewports[t] : null;
      if (!a || e < a.top)
        return n + (e - i) * this.scale;
      if (e <= a.bottom)
        return a.domTop + (e - a.top);
      i = a.bottom, n = a.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let a = t < this.viewports.length ? this.viewports[t] : null;
      if (!a || e < a.domTop)
        return i + (e - n) / this.scale;
      if (e <= a.domBottom)
        return a.top + (e - a.domTop);
      i = a.bottom, n = a.domBottom;
    }
  }
}
function Hd(r, e) {
  if (e.scale == 1)
    return r;
  let t = e.toDOM(r.top), i = e.toDOM(r.bottom);
  return new Fa(r.from, r.length, t, i - t, Array.isArray(r._content) ? r._content.map((n) => Hd(n, e)) : r._content);
}
const VO = /* @__PURE__ */ Re.define({ combine: (r) => r.join(" ") }), Q_ = /* @__PURE__ */ Re.define({ combine: (r) => r.indexOf(!0) > -1 }), U_ = /* @__PURE__ */ dl.newName(), U7 = /* @__PURE__ */ dl.newName(), $7 = /* @__PURE__ */ dl.newName(), G7 = { "&light": "." + U7, "&dark": "." + $7 };
function $_(r, e, t) {
  return new dl(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return r;
        if (!t || !t[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return t[n];
      }) : r + " " + i;
    }
  });
}
const v_e = /* @__PURE__ */ $_("." + U_, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, G7);
class O_e {
  constructor(e, t, i, n) {
    this.typeOver = n, this.bounds = null, this.text = "";
    let { impreciseHead: a, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let s = a || o ? [] : E_e(e), l = new n7(s, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = b_e(s, this.bounds.from);
    } else {
      let s = e.observer.selectionRange, l = a && a.node == s.focusNode && a.offset == s.focusOffset || !y_(e.contentDOM, s.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(s.focusNode, s.focusOffset), u = o && o.node == s.anchorNode && o.offset == s.anchorOffset || !y_(e.contentDOM, s.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(s.anchorNode, s.anchorOffset);
      this.newSel = z.single(u, l);
    }
  }
}
function B7(r, e) {
  let t, { newSel: i } = e, n = r.state.selection.main, a = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: s } = e.bounds, l = n.from, u = null;
    (a === 8 || Ae.android && e.text.length < s - o) && (l = n.to, u = "end");
    let h = m_e(r.state.doc.sliceString(o, s, Ec), e.text, l - o, u);
    h && (Ae.chrome && a == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == Ec + Ec && h.toB--, t = {
      from: o + h.from,
      to: o + h.toA,
      insert: Rt.of(e.text.slice(h.from, h.toB).split(Ec))
    });
  } else
    i && (!r.hasFocus && r.state.facet(eT) || i.main.eq(n)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !n.empty && i && i.main.empty ? t = { from: n.from, to: n.to, insert: r.state.doc.slice(n.from, n.to) } : t && t.from >= n.from && t.to <= n.to && (t.from != n.from || t.to != n.to) && n.to - n.from - (t.to - t.from) <= 4 ? t = {
    from: n.from,
    to: n.to,
    insert: r.state.doc.slice(n.from, t.from).append(t.insert).append(r.state.doc.slice(t.to, n.to))
  } : (Ae.mac || Ae.android) && t && t.from == t.to && t.from == n.head - 1 && /^\. ?$/.test(t.insert.toString()) && r.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = z.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: Rt.of([" "]) }) : Ae.chrome && t && t.from == t.to && t.from == n.head && t.insert.toString() == `
 ` && r.lineWrapping && (i && (i = z.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: Rt.of([" "]) }), t) {
    let o = r.state;
    if (Ae.ios && r.inputState.flushIOSKey(r) || Ae.android && (t.from == n.from && t.to == n.to && t.insert.length == 1 && t.insert.lines == 2 && Qc(r.contentDOM, "Enter", 13) || (t.from == n.from - 1 && t.to == n.to && t.insert.length == 0 || a == 8 && t.insert.length < t.to - t.from) && Qc(r.contentDOM, "Backspace", 8) || t.from == n.from && t.to == n.to + 1 && t.insert.length == 0 && Qc(r.contentDOM, "Delete", 46)))
      return !0;
    let s = t.insert.toString();
    if (r.state.facet(g7).some((h) => h(r, t.from, t.to, s)))
      return !0;
    r.inputState.composing >= 0 && r.inputState.composing++;
    let l;
    if (t.from >= n.from && t.to <= n.to && t.to - t.from >= (n.to - n.from) / 3 && (!i || i.main.empty && i.main.from == t.from + t.insert.length) && r.inputState.composing < 0) {
      let h = n.from < t.from ? o.sliceDoc(n.from, t.from) : "", c = n.to > t.to ? o.sliceDoc(t.to, n.to) : "";
      l = o.replaceSelection(r.state.toText(h + t.insert.sliceString(0, void 0, r.state.lineBreak) + c));
    } else {
      let h = o.changes(t), c = i && i.main.to <= h.newLength ? i.main : void 0;
      if (o.selection.ranges.length > 1 && r.inputState.composing >= 0 && t.to <= n.to && t.to >= n.to - 10) {
        let f = r.state.sliceDoc(t.from, t.to), d = A7(r) || r.state.doc.lineAt(n.head), p = n.to - t.to, g = n.to - n.from;
        l = o.changeByRange((v) => {
          if (v.from == n.from && v.to == n.to)
            return { changes: h, range: c || v.map(h) };
          let O = v.to - p, m = O - f.length;
          if (v.to - v.from != g || r.state.sliceDoc(m, O) != f || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          d && v.to >= d.from && v.from <= d.to)
            return { range: v };
          let E = o.changes({ from: m, to: O, insert: t.insert }), b = v.to - n.to;
          return {
            changes: E,
            range: c ? z.range(Math.max(0, c.anchor + b), Math.max(0, c.head + b)) : v.map(E)
          };
        });
      } else
        l = {
          changes: h,
          selection: c && o.selection.replaceRange(c)
        };
    }
    let u = "input.type";
    return (r.composing || r.inputState.compositionPendingChange && r.inputState.compositionEndedAt > Date.now() - 50) && (r.inputState.compositionPendingChange = !1, u += ".compose", r.inputState.compositionFirstChange && (u += ".start", r.inputState.compositionFirstChange = !1)), r.dispatch(l, { scrollIntoView: !0, userEvent: u }), !0;
  } else if (i && !i.main.eq(n)) {
    let o = !1, s = "select";
    return r.inputState.lastSelectionTime > Date.now() - 50 && (r.inputState.lastSelectionOrigin == "select" && (o = !0), s = r.inputState.lastSelectionOrigin), r.dispatch({ selection: i, scrollIntoView: o, userEvent: s }), !0;
  } else
    return !1;
}
function m_e(r, e, t, i) {
  let n = Math.min(r.length, e.length), a = 0;
  for (; a < n && r.charCodeAt(a) == e.charCodeAt(a); )
    a++;
  if (a == n && r.length == e.length)
    return null;
  let o = r.length, s = e.length;
  for (; o > 0 && s > 0 && r.charCodeAt(o - 1) == e.charCodeAt(s - 1); )
    o--, s--;
  if (i == "end") {
    let l = Math.max(0, a - Math.min(o, s));
    t -= o + l - a;
  }
  if (o < a && r.length < e.length) {
    let l = t <= a && t >= o ? a - t : 0;
    a -= l, s = a + (s - o), o = a;
  } else if (s < a) {
    let l = t <= a && t >= s ? a - t : 0;
    a -= l, o = a + (o - s), s = a;
  }
  return { from: a, toA: o, toB: s };
}
function E_e(r) {
  let e = [];
  if (r.root.activeElement != r.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: n, focusOffset: a } = r.observer.selectionRange;
  return t && (e.push(new g$(t, i)), (n != t || a != i) && e.push(new g$(n, a))), e;
}
function b_e(r, e) {
  if (r.length == 0)
    return null;
  let t = r[0].pos, i = r.length == 2 ? r[1].pos : t;
  return t > -1 && i > -1 ? z.single(t + e, i + e) : null;
}
const S_e = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, vR = Ae.ie && Ae.ie_version <= 11;
class T_e {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new pCe(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (Ae.ie && Ae.ie_version <= 11 || Ae.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), vR && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(eT) ? i.root.activeElement != this.dom : !Pm(i.dom, n))
      return;
    let a = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (a && a.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (Ae.ie && Ae.ie_version <= 11 || Ae.android && Ae.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && ub(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = Ae.safari && e.root.nodeType == 11 && hCe(this.dom.ownerDocument) == this.dom && y_e(this.view) || lb(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let i = Pm(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && vCe(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, S_e), vR && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), vR && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let a = this.delayedAndroidKey;
        a && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = a.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && a.force && Qc(this.dom, a.key, a.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, n = !1;
    for (let a of e) {
      let o = this.readMutation(a);
      o && (o.typeOver && (n = !0), t == -1 ? { from: t, to: i } = o : (t = Math.min(o.from, t), i = Math.max(o.to, i)));
    }
    return { from: t, to: i, typeOver: n };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), n = this.selectionChanged && Pm(this.dom, this.selectionRange);
    return e < 0 && !n ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1, new O_e(this.view, e, t, i));
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return !1;
    let i = this.view.state, n = B7(this.view, t);
    return this.view.state == i && this.view.update([]), n;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let i = B$(t, e.previousSibling || e.target.previousSibling, -1), n = B$(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: n ? t.posBefore(n) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect(), (n = this.resizeContent) === null || n === void 0 || n.disconnect();
    for (let a of this.scrollTargets)
      a.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function B$(r, e, t) {
  for (; e; ) {
    let i = Ft.get(e);
    if (i && i.parent == r)
      return i;
    let n = e.parentNode;
    e = n != r.dom ? n : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function y_e(r) {
  let e = null;
  function t(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (r.contentDOM.addEventListener("beforeinput", t, !0), r.dom.ownerDocument.execCommand("indent"), r.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, n = e.startOffset, a = e.endContainer, o = e.endOffset, s = r.docView.domAtPos(r.state.selection.main.anchor);
  return ub(s.node, s.offset, a, o) && ([i, n, a, o] = [a, o, i, n]), { anchorNode: i, anchorOffset: n, focusNode: a, focusOffset: o };
}
class ge {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((t) => this.update([t])), this.dispatch = this.dispatch.bind(this), this._root = e.root || gCe(e.parent) || document, this.viewState = new $$(e.state || St.create(e)), this.plugins = this.state.facet(Xd).map((t) => new fR(t));
    for (let t of this.plugins)
      t.update(this);
    this.observer = new T_e(this), this.inputState = new XCe(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new T$(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Rr ? e[0] : this.state.update(...e);
    this._dispatch(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, n, a = this.state;
    for (let f of e) {
      if (f.startState != a)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      a = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = a;
      return;
    }
    let o = this.hasFocus, s = 0, l = null;
    e.some((f) => f.annotation(D7)) ? (this.inputState.notifiedFocused = o, s = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = M7(a, o), l || (s = 1));
    let u = this.observer.delayedAndroidKey, h = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(a.doc) || !this.state.selection.eq(a.selection)) && (h = null)) : this.observer.clear(), a.facet(St.phrases) != this.state.facet(St.phrases))
      return this.setState(a);
    n = fb.create(this, a, e), n.flags |= s;
    let c = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (c && (c = c.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          c = new cb(d.empty ? d : z.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(S$) && (c = d.value);
      }
      this.viewState.update(n, c), this.bidiCache = db.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), t = this.docView.update(n), this.state.facet(Yd) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(VO) != n.state.facet(VO) && (this.viewState.mustMeasureContent = !0), (t || i || c || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let f of this.state.facet(w_))
        f(n);
    (l || h) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), h && !B7(this, h) && u.force && Qc(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new $$(e), this.plugins = e.facet(Xd).map((i) => new fR(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new T$(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(Xd), i = e.state.facet(Xd);
    if (t != i) {
      let n = [];
      for (let a of i) {
        let o = t.indexOf(a);
        if (o < 0)
          n.push(new fR(a));
        else {
          let s = this.plugins[o];
          s.mustUpdate = e, n.push(s);
        }
      }
      for (let a of this.plugins)
        a.mustUpdate != e && a.destroy(this);
      this.plugins = n, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, { scrollTop: n } = i, { scrollAnchorPos: a, scrollAnchorHeight: o } = this.viewState;
    n != this.viewState.scrollTop && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let s = 0; ; s++) {
        if (o < 0)
          if (e7(i))
            a = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(n);
            a = d.from, o = d.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (s > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        l & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let h = u.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return Xn(this.state, p), V$;
          }
        }), c = fb.create(this, this.state, []), f = !1;
        c.flags |= l, t ? t.flags |= l : t = c, this.updateState = 2, c.empty || (this.updatePlugins(c), this.inputState.update(c), this.updateAttrs(), f = this.docView.update(c));
        for (let d = 0; d < u.length; d++)
          if (h[d] != V$)
            try {
              let p = u[d];
              p.write && p.write(h[d], this);
            } catch (p) {
              Xn(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !c.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null;
              continue;
            } else {
              let p = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - o;
              if (p > 1 || p < -1) {
                n = i.scrollTop = n + p, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let s of this.state.facet(w_))
        s(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return U_ + " " + (this.state.facet(Q_) ? $7 : U7) + " " + this.state.facet(VO);
  }
  updateAttrs() {
    let e = F$(this, E7, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(eT) ? "true" : "false",
      class: "cm-content",
      style: `${Ae.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), F$(this, Lw, t);
    let i = this.observer.ignore(() => {
      let n = I_(this.contentDOM, this.contentAttrs, t), a = I_(this.dom, this.editorAttrs, e);
      return n || a;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let n of i.effects)
        if (n.is(ge.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let a = this.announceDOM.appendChild(document.createElement("div"));
          a.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Yd), dl.mount(this.root, this.styleModules.concat(v_e).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return pR(this, e, I$(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return pR(this, e, I$(this, e, t, (i) => VCe(this, e.head, i)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = !0) {
    return BCe(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return pR(this, e, FCe(this, e, t, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), _7(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(e), a = this.bidiSpans(n), o = a[Uc.find(a, e - n.from, -1, t)];
    return ww(i, o.dir == Jt.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(O7) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > R_e)
      return y7(e.length);
    let t = this.textDirectionAt(e.from);
    for (let n of this.bidiCache)
      if (n.from == e.from && n.dir == t)
        return n.order;
    let i = ICe(e.text, t);
    return this.bidiCache.push(new db(e.from, e.to, t, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || Ae.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      K4(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return S$.of(new cb(typeof e == "number" ? z.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Ir.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = dl.newName(), n = [VO.of(i), Yd.of($_(`.${i}`, e))];
    return t && t.dark && n.push(Q_.of(!0)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return _h.lowest(Yd.of($_("." + U_, e, G7)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), n = i && Ft.get(i) || Ft.get(e);
    return ((t = n == null ? void 0 : n.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
ge.styleModule = Yd;
ge.inputHandler = g7;
ge.focusChangeEffect = v7;
ge.perLineTextDirection = O7;
ge.exceptionSink = p7;
ge.updateListener = w_;
ge.editable = eT;
ge.mouseSelectionStyle = d7;
ge.dragMovesSelection = f7;
ge.clickAddsSelectionRange = c7;
ge.decorations = Og;
ge.atomicRanges = Dw;
ge.scrollMargins = b7;
ge.darkTheme = Q_;
ge.contentAttributes = Lw;
ge.editorAttributes = E7;
ge.lineWrapping = /* @__PURE__ */ ge.contentAttributes.of({ class: "cm-lineWrapping" });
ge.announce = /* @__PURE__ */ rt.define();
const R_e = 4096, V$ = {};
class db {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.dir = i, this.order = n;
  }
  static update(e, t) {
    if (t.empty)
      return e;
    let i = [], n = e.length ? e[e.length - 1].dir : Jt.LTR;
    for (let a = Math.max(0, e.length - 10); a < e.length; a++) {
      let o = e[a];
      o.dir == n && !t.touchesRange(o.from, o.to) && i.push(new db(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.order));
    }
    return i;
  }
}
function F$(r, e, t) {
  for (let i = r.state.facet(e), n = i.length - 1; n >= 0; n--) {
    let a = i[n], o = typeof a == "function" ? a(r) : a;
    o && __(o, t);
  }
  return t;
}
const A_e = Ae.mac ? "mac" : Ae.windows ? "win" : Ae.linux ? "linux" : "key";
function C_e(r, e) {
  const t = r.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let n, a, o, s;
  for (let l = 0; l < t.length - 1; ++l) {
    const u = t[l];
    if (/^(cmd|meta|m)$/i.test(u))
      s = !0;
    else if (/^a(lt)?$/i.test(u))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      a = !0;
    else if (/^s(hift)?$/i.test(u))
      o = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? s = !0 : a = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return n && (i = "Alt-" + i), a && (i = "Ctrl-" + i), s && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function FO(r, e, t) {
  return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t !== !1 && e.shiftKey && (r = "Shift-" + r), r;
}
const __e = /* @__PURE__ */ _h.default(/* @__PURE__ */ ge.domEventHandlers({
  keydown(r, e) {
    return F7(V7(e.state), r, e, "editor");
  }
})), ov = /* @__PURE__ */ Re.define({ enables: __e }), X$ = /* @__PURE__ */ new WeakMap();
function V7(r) {
  let e = r.facet(ov), t = X$.get(e);
  return t || X$.set(e, t = w_e(e.reduce((i, n) => i.concat(n), []))), t;
}
function I_e(r, e, t) {
  return F7(V7(r.state), e, r, t);
}
let _s = null;
const x_e = 4e3;
function w_e(r, e = A_e) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (o, s) => {
    let l = i[o];
    if (l == null)
      i[o] = s;
    else if (l != s)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, a = (o, s, l, u, h) => {
    var c, f;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = s.split(/ (?!$)/).map((O) => C_e(O, e));
    for (let O = 1; O < p.length; O++) {
      let m = p.slice(0, O).join(" ");
      n(m, !0), d[m] || (d[m] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(E) => {
          let b = _s = { view: E, prefix: m, scope: o };
          return setTimeout(() => {
            _s == b && (_s = null);
          }, x_e), !0;
        }]
      });
    }
    let g = p.join(" ");
    n(g, !1);
    let v = d[g] || (d[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (c = d._any) === null || c === void 0 ? void 0 : c.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && v.run.push(l), u && (v.preventDefault = !0), h && (v.stopPropagation = !0);
  };
  for (let o of r) {
    let s = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let u of s) {
        let h = t[u] || (t[u] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let c in h)
          h[c].run.push(o.any);
      }
    let l = o[e] || o.key;
    if (l)
      for (let u of s)
        a(u, l, o.run, o.preventDefault, o.stopPropagation), o.shift && a(u, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
function F7(r, e, t, i) {
  let n = uCe(e), a = Fr(n, 0), o = kn(a) == n.length && n != " ", s = "", l = !1, u = !1, h = !1;
  _s && _s.view == t && _s.scope == i && (s = _s.prefix + " ", x7.indexOf(e.keyCode) < 0 && (u = !0, _s = null));
  let c = /* @__PURE__ */ new Set(), f = (v) => {
    if (v) {
      for (let O of v.run)
        if (!c.has(O) && (c.add(O), O(t, e)))
          return v.stopPropagation && (h = !0), !0;
      v.preventDefault && (v.stopPropagation && (h = !0), u = !0);
    }
    return !1;
  }, d = r[i], p, g;
  return d && (f(d[s + FO(n, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(Ae.windows && e.ctrlKey && e.altKey) && (p = pl[e.keyCode]) && p != n ? (f(d[s + FO(p, e, !0)]) || e.shiftKey && (g = gg[e.keyCode]) != n && g != p && f(d[s + FO(g, e, !1)])) && (l = !0) : o && e.shiftKey && f(d[s + FO(n, e, !0)]) && (l = !0), !l && f(d._any) && (l = !0)), u && (l = !0), l && h && e.stopPropagation(), l;
}
class sv {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, i, n, a) {
    this.className = e, this.left = t, this.top = i, this.width = n, this.height = a;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, i) {
    if (i.empty) {
      let n = e.coordsAtPos(i.head, i.assoc || 1);
      if (!n)
        return [];
      let a = X7(e);
      return [new sv(t, n.left - a.left, n.top - a.top, null, n.bottom - n.top)];
    } else
      return P_e(e, t, i);
  }
}
function X7(r) {
  let e = r.scrollDOM.getBoundingClientRect();
  return { left: (r.textDirection == Jt.LTR ? e.left : e.right - r.scrollDOM.clientWidth) - r.scrollDOM.scrollLeft, top: e.top - r.scrollDOM.scrollTop };
}
function Y$(r, e, t) {
  let i = z.cursor(e);
  return {
    from: Math.max(t.from, r.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(t.to, r.moveToLineBoundary(i, !0, !0).from),
    type: tr.Text
  };
}
function P_e(r, e, t) {
  if (t.to <= r.viewport.from || t.from >= r.viewport.to)
    return [];
  let i = Math.max(t.from, r.viewport.from), n = Math.min(t.to, r.viewport.to), a = r.textDirection == Jt.LTR, o = r.contentDOM, s = o.getBoundingClientRect(), l = X7(r), u = o.querySelector(".cm-line"), h = u && window.getComputedStyle(u), c = s.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), f = s.right - (h ? parseInt(h.paddingRight) : 0), d = D_(r, i), p = D_(r, n), g = d.type == tr.Text ? d : null, v = p.type == tr.Text ? p : null;
  if (g && (r.lineWrapping || d.widgetLineBreaks) && (g = Y$(r, i, g)), v && (r.lineWrapping || p.widgetLineBreaks) && (v = Y$(r, n, v)), g && v && g.from == v.from)
    return m(E(t.from, t.to, g));
  {
    let T = g ? E(t.from, null, g) : b(d, !1), S = v ? E(null, t.to, v) : b(p, !0), y = [];
    return (g || d).to < (v || p).from - (g && v ? 1 : 0) || d.widgetLineBreaks > 1 && T.bottom + r.defaultLineHeight / 2 < S.top ? y.push(O(c, T.bottom, f, S.top)) : T.bottom < S.top && r.elementAtHeight((T.bottom + S.top) / 2).type == tr.Text && (T.bottom = S.top = (T.bottom + S.top) / 2), m(T).concat(y).concat(m(S));
  }
  function O(T, S, y, A) {
    return new sv(
      e,
      T - l.left,
      S - l.top - 0.01,
      y - T,
      A - S + 0.01
      /* Epsilon */
    );
  }
  function m({ top: T, bottom: S, horizontal: y }) {
    let A = [];
    for (let C = 0; C < y.length; C += 2)
      A.push(O(y[C], T, y[C + 1], S));
    return A;
  }
  function E(T, S, y) {
    let A = 1e9, C = -1e9, _ = [];
    function I(N, L, D, $, k) {
      let G = r.coordsAtPos(N, N == y.to ? -2 : 2), F = r.coordsAtPos(D, D == y.from ? 2 : -2);
      !G || !F || (A = Math.min(G.top, F.top, A), C = Math.max(G.bottom, F.bottom, C), k == Jt.LTR ? _.push(a && L ? c : G.left, a && $ ? f : F.right) : _.push(!a && $ ? c : F.left, !a && L ? f : G.right));
    }
    let x = T ?? y.from, P = S ?? y.to;
    for (let N of r.visibleRanges)
      if (N.to > x && N.from < P)
        for (let L = Math.max(N.from, x), D = Math.min(N.to, P); ; ) {
          let $ = r.state.doc.lineAt(L);
          for (let k of r.bidiSpans($)) {
            let G = k.from + $.from, F = k.to + $.from;
            if (G >= D)
              break;
            F > L && I(Math.max(G, L), T == null && G <= x, Math.min(F, D), S == null && F >= P, k.dir);
          }
          if (L = $.to + 1, L >= D)
            break;
        }
    return _.length == 0 && I(x, T == null, P, S == null, r.textDirection), { top: A, bottom: C, horizontal: _ };
  }
  function b(T, S) {
    let y = s.top + (S ? T.top : T.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function N_e(r, e) {
  return r.constructor == e.constructor && r.eq(e);
}
class L_e {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(Dm) != e.state.facet(Dm) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, i = e.facet(Dm);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !N_e(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let n of e)
        n.update && t && n.constructor && this.drawn[i].constructor && n.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(n.draw(), t);
      for (; t; ) {
        let n = t.nextSibling;
        t.remove(), t = n;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const Dm = /* @__PURE__ */ Re.define();
function Y7(r) {
  return [
    Ir.define((e) => new L_e(e, r)),
    Dm.of(r)
  ];
}
const H7 = !Ae.ios, mg = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function D_e(r = {}) {
  return [
    mg.of(r),
    M_e,
    k_e,
    Q_e,
    m7.of(!0)
  ];
}
function W7(r) {
  return r.startState.facet(mg) != r.state.facet(mg);
}
const M_e = /* @__PURE__ */ Y7({
  above: !0,
  markers(r) {
    let { state: e } = r, t = e.facet(mg), i = [];
    for (let n of e.selection.ranges) {
      let a = n == e.selection.main;
      if (n.empty ? !a || H7 : t.drawRangeCursor) {
        let o = a ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", s = n.empty ? n : z.cursor(n.head, n.head > n.anchor ? -1 : 1);
        for (let l of sv.forRange(r, o, s))
          i.push(l);
      }
    }
    return i;
  },
  update(r, e) {
    r.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = W7(r);
    return t && H$(r.state, e), r.docChanged || r.selectionSet || t;
  },
  mount(r, e) {
    H$(e.state, r);
  },
  class: "cm-cursorLayer"
});
function H$(r, e) {
  e.style.animationDuration = r.facet(mg).cursorBlinkRate + "ms";
}
const k_e = /* @__PURE__ */ Y7({
  above: !1,
  markers(r) {
    return r.state.selection.ranges.map((e) => e.empty ? [] : sv.forRange(r, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(r, e) {
    return r.docChanged || r.selectionSet || r.viewportChanged || W7(r);
  },
  class: "cm-selectionLayer"
}), z7 = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
H7 && (z7[".cm-line"].caretColor = "transparent !important");
const Q_e = /* @__PURE__ */ _h.highest(/* @__PURE__ */ ge.theme(z7)), Z7 = /* @__PURE__ */ rt.define({
  map(r, e) {
    return r == null ? null : e.mapPos(r);
  }
}), Wd = /* @__PURE__ */ kr.define({
  create() {
    return null;
  },
  update(r, e) {
    return r != null && (r = e.changes.mapPos(r)), e.effects.reduce((t, i) => i.is(Z7) ? i.value : t, r);
  }
}), U_e = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.view = r, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(r) {
    var e;
    let t = r.state.field(Wd);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (r.startState.field(Wd) != t || r.docChanged || r.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let r = this.view.state.field(Wd), e = r != null && this.view.coordsAtPos(r);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(r) {
    this.cursor && (r ? (this.cursor.style.left = r.left + "px", this.cursor.style.top = r.top + "px", this.cursor.style.height = r.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(r) {
    this.view.state.field(Wd) != r && this.view.dispatch({ effects: Z7.of(r) });
  }
}, {
  eventHandlers: {
    dragover(r) {
      this.setDropPos(this.view.posAtCoords({ x: r.clientX, y: r.clientY }));
    },
    dragleave(r) {
      (r.target == this.view.contentDOM || !this.view.contentDOM.contains(r.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function $_e() {
  return [Wd, U_e];
}
function W$(r, e, t, i, n) {
  e.lastIndex = 0;
  for (let a = r.iterRange(t, i), o = t, s; !a.next().done; o += a.value.length)
    if (!a.lineBreak)
      for (; s = e.exec(a.value); )
        n(o + s.index, s);
}
function G_e(r, e) {
  let t = r.visibleRanges;
  if (t.length == 1 && t[0].from == r.viewport.from && t[0].to == r.viewport.to)
    return t;
  let i = [];
  for (let { from: n, to: a } of t)
    n = Math.max(r.state.doc.lineAt(n).from, n - e), a = Math.min(r.state.doc.lineAt(a).to, a + e), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = a : i.push({ from: n, to: a });
  return i;
}
class B_e {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: i, decorate: n, boundary: a, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, n)
      this.addMatch = (s, l, u, h) => n(h, u, u + s[0].length, s, l);
    else if (typeof i == "function")
      this.addMatch = (s, l, u, h) => {
        let c = i(s, l, u);
        c && h(u, u + s[0].length, c);
      };
    else if (i)
      this.addMatch = (s, l, u, h) => h(u, u + s[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = a, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new fl(), i = t.add.bind(t);
    for (let { from: n, to: a } of G_e(e, this.maxLength))
      W$(e.state.doc, this.regexp, n, a, (o, s) => this.addMatch(s, e, o, i));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((a, o, s, l) => {
      l > e.view.viewport.from && s < e.view.viewport.to && (i = Math.min(s, i), n = Math.max(l, n));
    }), e.viewportChanged || n - i > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, t.map(e.changes), i, n) : t;
  }
  updateRange(e, t, i, n) {
    for (let a of e.visibleRanges) {
      let o = Math.max(a.from, i), s = Math.min(a.to, n);
      if (s > o) {
        let l = e.state.doc.lineAt(o), u = l.to < s ? e.state.doc.lineAt(s) : l, h = Math.max(a.from, l.from), c = Math.min(a.to, u.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              h = o;
              break;
            }
          for (; s < u.to; s++)
            if (this.boundary.test(u.text[s - u.from])) {
              c = s;
              break;
            }
        }
        let f = [], d, p = (g, v, O) => f.push(O.range(g, v));
        if (l == u)
          for (this.regexp.lastIndex = h - l.from; (d = this.regexp.exec(l.text)) && d.index < c - l.from; )
            this.addMatch(d, e, d.index + l.from, p);
        else
          W$(e.state.doc, this.regexp, h, c, (g, v) => this.addMatch(v, e, g, p));
        t = t.update({ filterFrom: h, filterTo: c, filter: (g, v) => g < h || v > c, add: f });
      }
    }
    return t;
  }
}
const G_ = /x/.unicode != null ? "gu" : "g", V_e = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, G_), F_e = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let mR = null;
function X_e() {
  var r;
  if (mR == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    mR = ((r = e.tabSize) !== null && r !== void 0 ? r : e.MozTabSize) != null;
  }
  return mR || !1;
}
const Mm = /* @__PURE__ */ Re.define({
  combine(r) {
    let e = mo(r, {
      render: null,
      specialChars: V_e,
      addSpecialChars: null
    });
    return (e.replaceTabs = !X_e()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, G_)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, G_)), e;
  }
});
function Y_e(r = {}) {
  return [Mm.of(r), H_e()];
}
let z$ = null;
function H_e() {
  return z$ || (z$ = Ir.fromClass(class {
    constructor(r) {
      this.view = r, this.decorations = Be.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(r.state.facet(Mm)), this.decorations = this.decorator.createDeco(r);
    }
    makeDecorator(r) {
      return new B_e({
        regexp: r.specialChars,
        decoration: (e, t, i) => {
          let { doc: n } = t.state, a = Fr(e[0], 0);
          if (a == 9) {
            let o = n.lineAt(i), s = t.state.tabSize, l = iv(o.text, s, i - o.from);
            return Be.replace({ widget: new q_e((s - l % s) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[a] || (this.decorationCache[a] = Be.replace({ widget: new Z_e(r, a) }));
        },
        boundary: r.replaceTabs ? void 0 : /[^]/
      });
    }
    update(r) {
      let e = r.state.facet(Mm);
      r.startState.facet(Mm) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(r.view)) : this.decorations = this.decorator.updateDeco(r, this.decorations);
    }
  }, {
    decorations: (r) => r.decorations
  }));
}
const W_e = "";
function z_e(r) {
  return r >= 32 ? W_e : r == 10 ? "" : String.fromCharCode(9216 + r);
}
class Z_e extends ns {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = z_e(this.code), i = e.state.phrase("Control character") + " " + (F_e[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, t);
    if (n)
      return n;
    let a = document.createElement("span");
    return a.textContent = t, a.title = i, a.setAttribute("aria-label", i), a.className = "cm-specialChar", a;
  }
  ignoreEvent() {
    return !1;
  }
}
class q_e extends ns {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function j_e() {
  return J_e;
}
const K_e = /* @__PURE__ */ Be.line({ class: "cm-activeLine" }), J_e = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.docChanged || r.selectionSet) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = -1, t = [];
    for (let i of r.state.selection.ranges) {
      let n = r.lineBlockAt(i.head);
      n.from > e && (t.push(K_e.range(n.from)), e = n.from);
    }
    return Be.set(t);
  }
}, {
  decorations: (r) => r.decorations
}), B_ = 2e3;
function e1e(r, e, t) {
  let i = Math.min(e.line, t.line), n = Math.max(e.line, t.line), a = [];
  if (e.off > B_ || t.off > B_ || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), s = Math.max(e.off, t.off);
    for (let l = i; l <= n; l++) {
      let u = r.doc.line(l);
      u.length <= s && a.push(z.range(u.from + o, u.to + s));
    }
  } else {
    let o = Math.min(e.col, t.col), s = Math.max(e.col, t.col);
    for (let l = i; l <= n; l++) {
      let u = r.doc.line(l), h = b_(u.text, o, r.tabSize, !0);
      if (h < 0)
        a.push(z.cursor(u.to));
      else {
        let c = b_(u.text, s, r.tabSize);
        a.push(z.range(u.from + h, u.from + c));
      }
    }
  }
  return a;
}
function t1e(r, e) {
  let t = r.coordsAtPos(r.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / r.defaultCharacterWidth)) : -1;
}
function Z$(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = r.state.doc.lineAt(t), n = t - i.from, a = n > B_ ? -1 : n == i.length ? t1e(r, e.clientX) : iv(i.text, r.state.tabSize, t - i.from);
  return { line: i.number, col: a, off: n };
}
function r1e(r, e) {
  let t = Z$(r, e), i = r.state.selection;
  return t ? {
    update(n) {
      if (n.docChanged) {
        let a = n.changes.mapPos(n.startState.doc.line(t.line).from), o = n.state.doc.lineAt(a);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, i = i.map(n.changes);
      }
    },
    get(n, a, o) {
      let s = Z$(r, n);
      if (!s)
        return i;
      let l = e1e(r.state, t, s);
      return l.length ? o ? z.create(l.concat(i.ranges)) : z.create(l) : i;
    }
  } : null;
}
function i1e(r) {
  let e = (r == null ? void 0 : r.eventFilter) || ((t) => t.altKey && t.button == 0);
  return ge.mouseSelectionStyle.of((t, i) => e(i) ? r1e(t, i) : null);
}
const n1e = {
  Alt: [18, (r) => !!r.altKey],
  Control: [17, (r) => !!r.ctrlKey],
  Shift: [16, (r) => !!r.shiftKey],
  Meta: [91, (r) => !!r.metaKey]
}, a1e = { style: "cursor: crosshair" };
function o1e(r = {}) {
  let [e, t] = n1e[r.key || "Alt"], i = Ir.fromClass(class {
    constructor(n) {
      this.view = n, this.isDown = !1;
    }
    set(n) {
      this.isDown != n && (this.isDown = n, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(n) {
        this.set(n.keyCode == e || t(n));
      },
      keyup(n) {
        (n.keyCode == e || !t(n)) && this.set(!1);
      },
      mousemove(n) {
        this.set(t(n));
      }
    }
  });
  return [
    i,
    ge.contentAttributes.of((n) => {
      var a;
      return !((a = n.plugin(i)) === null || a === void 0) && a.isDown ? a1e : null;
    })
  ];
}
const XO = "-10000px";
class q7 {
  constructor(e, t, i) {
    this.facet = t, this.createTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((n) => n), this.tooltipViews = this.tooltips.map(i);
  }
  update(e) {
    var t;
    let i = e.state.facet(this.facet), n = i.filter((o) => o);
    if (i === this.input) {
      for (let o of this.tooltipViews)
        o.update && o.update(e);
      return !1;
    }
    let a = [];
    for (let o = 0; o < n.length; o++) {
      let s = n[o], l = -1;
      if (s) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let h = this.tooltips[u];
          h && h.create == s.create && (l = u);
        }
        if (l < 0)
          a[o] = this.createTooltipView(s);
        else {
          let u = a[o] = this.tooltipViews[l];
          u.update && u.update(e);
        }
      }
    }
    for (let o of this.tooltipViews)
      a.indexOf(o) < 0 && (o.dom.remove(), (t = o.destroy) === null || t === void 0 || t.call(o));
    return this.input = i, this.tooltips = n, this.tooltipViews = a, !0;
  }
}
function s1e(r) {
  let { win: e } = r;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const ER = /* @__PURE__ */ Re.define({
  combine: (r) => {
    var e, t, i;
    return {
      position: Ae.ios ? "absolute" : ((e = r.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = r.find((n) => n.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = r.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || s1e
    };
  }
}), q$ = /* @__PURE__ */ new WeakMap(), j7 = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.view = r, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = r.state.facet(ER);
    this.position = e.position, this.parent = e.parent, this.classes = r.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new q7(r, kw, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), r.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let r of this.manager.tooltipViews)
        this.intersectionObserver.observe(r.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(r) {
    r.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(r);
    e && this.observeIntersection();
    let t = e || r.geometryChanged, i = r.state.facet(ER);
    if (i.position != this.position) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(r) {
    let e = r.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), r.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = XO, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var r, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (r = t.destroy) === null || r === void 0 || r.call(t);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let r = this.view.dom.getBoundingClientRect();
    return {
      editor: r,
      parent: this.parent ? this.container.getBoundingClientRect() : r,
      pos: this.manager.tooltips.map((e, t) => {
        let i = this.manager.tooltipViews[t];
        return i.getCoords ? i.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(ER).tooltipSpace(this.view)
    };
  }
  writeMeasure(r) {
    var e;
    let { editor: t, space: i } = r, n = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let o = this.manager.tooltips[a], s = this.manager.tooltipViews[a], { dom: l } = s, u = r.pos[a], h = r.size[a];
      if (!u || u.bottom <= Math.max(t.top, i.top) || u.top >= Math.min(t.bottom, i.bottom) || u.right < Math.max(t.left, i.left) - 0.1 || u.left > Math.min(t.right, i.right) + 0.1) {
        l.style.top = XO;
        continue;
      }
      let c = o.arrow ? s.dom.querySelector(".cm-tooltip-arrow") : null, f = c ? 7 : 0, d = h.right - h.left, p = (e = q$.get(s)) !== null && e !== void 0 ? e : h.bottom - h.top, g = s.offset || u1e, v = this.view.textDirection == Jt.LTR, O = h.width > i.right - i.left ? v ? i.left : i.right - h.width : v ? Math.min(u.left - (c ? 14 : 0) + g.x, i.right - d) : Math.max(i.left, u.left - d + (c ? 14 : 0) - g.x), m = !!o.above;
      !o.strictSide && (m ? u.top - (h.bottom - h.top) - g.y < i.top : u.bottom + (h.bottom - h.top) + g.y > i.bottom) && m == i.bottom - u.bottom > u.top - i.top && (m = !m);
      let E = (m ? u.top - i.top : i.bottom - u.bottom) - f;
      if (E < p && s.resize !== !1) {
        if (E < this.view.defaultLineHeight) {
          l.style.top = XO;
          continue;
        }
        q$.set(s, p), l.style.height = (p = E) + "px";
      } else
        l.style.height && (l.style.height = "");
      let b = m ? u.top - p - f - g.y : u.bottom + f + g.y, T = O + d;
      if (s.overlap !== !0)
        for (let S of n)
          S.left < T && S.right > O && S.top < b + p && S.bottom > b && (b = m ? S.top - p - 2 - f : S.bottom + f + 2);
      this.position == "absolute" ? (l.style.top = b - r.parent.top + "px", l.style.left = O - r.parent.left + "px") : (l.style.top = b + "px", l.style.left = O + "px"), c && (c.style.left = `${u.left + (v ? g.x : -g.x) - (O + 14 - 7)}px`), s.overlap !== !0 && n.push({ left: O, top: b, right: T, bottom: b + p }), l.classList.toggle("cm-tooltip-above", m), l.classList.toggle("cm-tooltip-below", !m), s.positioned && s.positioned(r.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let r of this.manager.tooltipViews)
        r.dom.style.top = XO;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), l1e = /* @__PURE__ */ ge.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), u1e = { x: 0, y: 0 }, kw = /* @__PURE__ */ Re.define({
  enables: [j7, l1e]
}), pb = /* @__PURE__ */ Re.define();
class Qw {
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new q7(e, pb, (t) => this.createHostedView(t));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Qw(e);
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
}
const h1e = /* @__PURE__ */ kw.compute([pb], (r) => {
  let e = r.facet(pb).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: Qw.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class c1e {
  constructor(e, t, i, n, a) {
    this.view = e, this.source = t, this.field = i, this.setHover = n, this.hoverTime = a, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: e } = this, t = this.view.contentDOM.contains(e.target) ? this.view.posAtCoords(e) : null;
    if (t == null)
      return;
    let i = this.view.coordsAtPos(t);
    if (i == null || e.y < i.top || e.y > i.bottom || e.x < i.left - this.view.defaultCharacterWidth || e.x > i.right + this.view.defaultCharacterWidth)
      return;
    let n = this.view.bidiSpans(this.view.state.doc.lineAt(t)).find((s) => s.from <= t && s.to >= t), a = n && n.dir == Jt.RTL ? -1 : 1, o = this.source(this.view, t, e.x < i.left ? -a : a);
    if (o != null && o.then) {
      let s = this.pending = { pos: t };
      o.then((l) => {
        this.pending == s && (this.pending = null, l && this.view.dispatch({ effects: this.setHover.of(l) }));
      }, (l) => Xn(this.view.state, l, "hover tooltip"));
    } else
      o && this.view.dispatch({ effects: this.setHover.of(o) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let i = this.active;
    if (i && !j$(this.lastMove.target) || this.pending) {
      let { pos: n } = i || this.pending, a = (t = i == null ? void 0 : i.end) !== null && t !== void 0 ? t : n;
      (n == a ? this.view.posAtCoords(this.lastMove) != n : !f1e(
        this.view,
        n,
        a,
        e.clientX,
        e.clientY,
        6
        /* MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !j$(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function j$(r) {
  for (let e = r; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function f1e(r, e, t, i, n, a) {
  let o = document.createRange(), s = r.domAtPos(e), l = r.domAtPos(t);
  o.setEnd(l.node, l.offset), o.setStart(s.node, s.offset);
  let u = o.getClientRects();
  o.detach();
  for (let h = 0; h < u.length; h++) {
    let c = u[h];
    if (Math.max(c.top - n, n - c.bottom, c.left - i, i - c.right) <= a)
      return !0;
  }
  return !1;
}
function d1e(r, e = {}) {
  let t = rt.define(), i = kr.define({
    create() {
      return null;
    },
    update(n, a) {
      if (n && (e.hideOnChange && (a.docChanged || a.selection) || e.hideOn && e.hideOn(a, n)))
        return null;
      if (n && a.docChanged) {
        let o = a.changes.mapPos(n.pos, -1, Yr.TrackDel);
        if (o == null)
          return null;
        let s = Object.assign(/* @__PURE__ */ Object.create(null), n);
        s.pos = o, n.end != null && (s.end = a.changes.mapPos(n.end)), n = s;
      }
      for (let o of a.effects)
        o.is(t) && (n = o.value), o.is(p1e) && (n = null);
      return n;
    },
    provide: (n) => pb.from(n)
  });
  return [
    i,
    Ir.define((n) => new c1e(
      n,
      r,
      i,
      t,
      e.hoverTime || 300
      /* Time */
    )),
    h1e
  ];
}
function K7(r, e) {
  let t = r.plugin(j7);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const p1e = /* @__PURE__ */ rt.define(), K$ = /* @__PURE__ */ Re.define({
  combine(r) {
    let e, t;
    for (let i of r)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function Eg(r, e) {
  let t = r.plugin(J7), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const J7 = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.input = r.state.facet(bg), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(r));
    let e = r.state.facet(K$);
    this.top = new YO(r, !0, e.topContainer), this.bottom = new YO(r, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(r) {
    let e = r.state.facet(K$);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new YO(r.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new YO(r.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = r.state.facet(bg);
    if (t != this.input) {
      let i = t.filter((l) => l), n = [], a = [], o = [], s = [];
      for (let l of i) {
        let u = this.specs.indexOf(l), h;
        u < 0 ? (h = l(r.view), s.push(h)) : (h = this.panels[u], h.update && h.update(r)), n.push(h), (h.top ? a : o).push(h);
      }
      this.specs = i, this.panels = n, this.top.sync(a), this.bottom.sync(o);
      for (let l of s)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(r);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (r) => ge.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class YO {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = J$(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = J$(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function J$(r) {
  let e = r.nextSibling;
  return r.remove(), e;
}
const bg = /* @__PURE__ */ Re.define({
  enables: J7
});
class qo extends sh {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
qo.prototype.elementClass = "";
qo.prototype.toDOM = void 0;
qo.prototype.mapMode = Yr.TrackBefore;
qo.prototype.startSide = qo.prototype.endSide = -1;
qo.prototype.point = !0;
const km = /* @__PURE__ */ Re.define(), g1e = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Nt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Ep = /* @__PURE__ */ Re.define();
function v1e(r) {
  return [eZ(), Ep.of(Object.assign(Object.assign({}, g1e), r))];
}
const V_ = /* @__PURE__ */ Re.define({
  combine: (r) => r.some((e) => e)
});
function eZ(r) {
  let e = [
    O1e
  ];
  return r && r.fixed === !1 && e.push(V_.of(!0)), e;
}
const O1e = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.view = r, this.prevViewport = r.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = r.state.facet(Ep).map((e) => new tG(r, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !r.state.facet(V_), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), r.scrollDOM.insertBefore(this.dom, r.contentDOM);
  }
  update(r) {
    if (this.updateGutters(r)) {
      let e = this.prevViewport, t = r.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    r.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(V_) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = r.view.viewport;
  }
  syncGutters(r) {
    let e = this.dom.nextSibling;
    r && this.dom.remove();
    let t = Nt.iter(this.view.state.facet(km), this.view.viewport.from), i = [], n = this.gutters.map((a) => new m1e(a, this.view.viewport, -this.view.documentPadding.top));
    for (let a of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(a.type)) {
        let o = !0;
        for (let s of a.type)
          if (s.type == tr.Text && o) {
            F_(t, i, s.from);
            for (let l of n)
              l.line(this.view, s, i);
            o = !1;
          } else if (s.widget)
            for (let l of n)
              l.widget(this.view, s);
      } else if (a.type == tr.Text) {
        F_(t, i, a.from);
        for (let o of n)
          o.line(this.view, a, i);
      }
    for (let a of n)
      a.finish();
    r && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(r) {
    let e = r.startState.facet(Ep), t = r.state.facet(Ep), i = r.docChanged || r.heightChanged || r.viewportChanged || !Nt.eq(r.startState.facet(km), r.state.facet(km), r.view.viewport.from, r.view.viewport.to);
    if (e == t)
      for (let n of this.gutters)
        n.update(r) && (i = !0);
    else {
      i = !0;
      let n = [];
      for (let a of t) {
        let o = e.indexOf(a);
        o < 0 ? n.push(new tG(this.view, a)) : (this.gutters[o].update(r), n.push(this.gutters[o]));
      }
      for (let a of this.gutters)
        a.dom.remove(), n.indexOf(a) < 0 && a.destroy();
      for (let a of n)
        this.dom.appendChild(a.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let r of this.gutters)
      r.destroy();
    this.dom.remove();
  }
}, {
  provide: (r) => ge.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Jt.LTR ? { left: t.dom.offsetWidth } : { right: t.dom.offsetWidth };
  })
});
function eG(r) {
  return Array.isArray(r) ? r : [r];
}
function F_(r, e, t) {
  for (; r.value && r.from <= t; )
    r.from == t && e.push(r.value), r.next();
}
class m1e {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = Nt.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: n } = this, a = t.top - this.height;
    if (this.i == n.elements.length) {
      let o = new tZ(e, t.height, a, i);
      n.elements.push(o), n.dom.appendChild(o.dom);
    } else
      n.elements[this.i].update(e, t.height, a, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let n = [];
    F_(this.cursor, n, t.from), i.length && (n = n.concat(i));
    let a = this.gutter.config.lineMarker(e, t, n);
    a && n.unshift(a);
    let o = this.gutter;
    n.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, n);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t);
    i && this.addElement(e, t, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class tG {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let a = n.target, o;
        if (a != this.dom && this.dom.contains(a)) {
          for (; a.parentNode != this.dom; )
            a = a.parentNode;
          let l = a.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = n.clientY;
        let s = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[i](e, s, n) && n.preventDefault();
      });
    this.markers = eG(t.markers(e)), t.initialSpacer && (this.spacer = new tZ(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = eG(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let i = e.view.viewport;
    return !Nt.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class tZ {
  constructor(e, t, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, n);
  }
  update(e, t, i, n) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), E1e(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let a = 0, o = 0; ; ) {
      let s = o, l = a < t.length ? t[a++] : null, u = !1;
      if (l) {
        let h = l.elementClass;
        h && (i += " " + h);
        for (let c = o; c < this.markers.length; c++)
          if (this.markers[c].compare(l)) {
            s = c, u = !0;
            break;
          }
      } else
        s = this.markers.length;
      for (; o < s; ) {
        let h = this.markers[o++];
        if (h.toDOM) {
          h.destroy(n);
          let c = n.nextSibling;
          n.remove(), n = c;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? n = n.nextSibling : this.dom.insertBefore(l.toDOM(e), n)), u && o++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function E1e(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].compare(e[t]))
      return !1;
  return !0;
}
const b1e = /* @__PURE__ */ Re.define(), bc = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let n in t) {
          let a = i[n], o = t[n];
          i[n] = a ? (s, l, u) => a(s, l, u) || o(s, l, u) : o;
        }
        return i;
      }
    });
  }
});
class bR extends qo {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function SR(r, e) {
  return r.state.facet(bc).formatNumber(e, r.state);
}
const S1e = /* @__PURE__ */ Ep.compute([bc], (r) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(b1e);
  },
  lineMarker(e, t, i) {
    return i.some((n) => n.toDOM) ? null : new bR(SR(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(bc) != e.state.facet(bc),
  initialSpacer(e) {
    return new bR(SR(e, rG(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = SR(t.view, rG(t.view.state.doc.lines));
    return i == e.number ? e : new bR(i);
  },
  domEventHandlers: r.facet(bc).domEventHandlers
}));
function T1e(r = {}) {
  return [
    bc.of(r),
    eZ(),
    S1e
  ];
}
function rG(r) {
  let e = 9;
  for (; e < r; )
    e = e * 10 + 9;
  return e;
}
const y1e = /* @__PURE__ */ new class extends qo {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), R1e = /* @__PURE__ */ km.compute(["selection"], (r) => {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let n = r.doc.lineAt(i.head).from;
    n > t && (t = n, e.push(y1e.range(n)));
  }
  return Nt.of(e);
});
function A1e() {
  return R1e;
}
const rZ = 1024;
let C1e = 0;
class Gn {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class ht {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = C1e++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = On.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
ht.closedBy = new ht({ deserialize: (r) => r.split(" ") });
ht.openedBy = new ht({ deserialize: (r) => r.split(" ") });
ht.group = new ht({ deserialize: (r) => r.split(" ") });
ht.contextHash = new ht({ perNode: !0 });
ht.lookAhead = new ht({ perNode: !0 });
ht.mounted = new ht({ perNode: !0 });
class _1e {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
}
const I1e = /* @__PURE__ */ Object.create(null);
let On = class iZ {
  /**
  @internal
  */
  constructor(e, t, i, n = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : I1e, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new iZ(e.name || "", t, e.id, i);
    if (e.props) {
      for (let a of e.props)
        if (Array.isArray(a) || (a = a(n)), a) {
          if (a[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[a[0].id] = a[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(ht.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let n of i.split(" "))
        t[n] = e[i];
    return (i) => {
      for (let n = i.prop(ht.group), a = -1; a < (n ? n.length : 0); a++) {
        let o = t[a < 0 ? i.name : n[a]];
        if (o)
          return o;
      }
    };
  }
};
On.none = new On(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Uw {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let n = null;
      for (let a of e) {
        let o = a(i);
        o && (n || (n = Object.assign({}, i.props)), n[o[0].id] = o[1]);
      }
      t.push(n ? new On(i.name, n, i.id, i.flags) : i);
    }
    return new Uw(t);
  }
}
const HO = /* @__PURE__ */ new WeakMap(), iG = /* @__PURE__ */ new WeakMap();
var Bt;
(function(r) {
  r[r.ExcludeBuffers = 1] = "ExcludeBuffers", r[r.IncludeAnonymous = 2] = "IncludeAnonymous", r[r.IgnoreMounts = 4] = "IgnoreMounts", r[r.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Bt || (Bt = {}));
class er {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, i, n, a) {
    if (this.type = e, this.children = t, this.positions = i, this.length = n, this.props = null, a && a.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, s] of a)
        this.props[typeof o == "number" ? o : o.id] = s;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = this.prop(ht.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (t && (t += ","), t += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new Sg(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, i = 0) {
    let n = HO.get(this) || this.topNode, a = new Sg(n);
    return a.moveTo(e, t), HO.set(this, a._tree), a;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new Hn(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let i = lf(HO.get(this) || this.topNode, e, t, !1);
    return HO.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let i = lf(iG.get(this) || this.topNode, e, t, !0);
    return iG.set(this, i), i;
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: i, from: n = 0, to: a = this.length } = e, o = e.mode || 0, s = (o & Bt.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Bt.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= a && l.to >= n && (!s && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && i && (s || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Bw(On.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, n) => new er(this.type, t, i, n, this.propValues), e.makeTree || ((t, i, n) => new er(On.none, t, i, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return w1e(e);
  }
}
er.empty = new er(On.none, [], [], 0);
class $w {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new $w(this.buffer, this.index);
  }
}
class Ih {
  /**
  Create a tree buffer.
  */
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return On.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], n = this.set.types[t], a = n.name;
    if (/\W/.test(a) && !n.isError && (a = JSON.stringify(a)), e += 4, i == e)
      return a;
    let o = [];
    for (; e < i; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return a + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, i, n, a) {
    let { buffer: o } = this, s = -1;
    for (let l = e; l != t && !(nZ(a, n, o[l + 1], o[l + 2]) && (s = l, i > 0)); l = o[l + 3])
      ;
    return s;
  }
  /**
  @internal
  */
  slice(e, t, i) {
    let n = this.buffer, a = new Uint16Array(t - e), o = 0;
    for (let s = e, l = 0; s < t; ) {
      a[l++] = n[s++], a[l++] = n[s++] - i;
      let u = a[l++] = n[s++] - i;
      a[l++] = n[s++] - e, o = Math.max(o, u);
    }
    return new Ih(a, o, this.set);
  }
}
function nZ(r, e, t, i) {
  switch (r) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function aZ(r, e) {
  let t = r.childBefore(e);
  for (; t; ) {
    let i = t.lastChild;
    if (!i || i.to != t.to)
      break;
    i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
  }
  return r;
}
function lf(r, e, t, i) {
  for (var n; r.from == r.to || (t < 1 ? r.from >= e : r.from > e) || (t > -1 ? r.to <= e : r.to < e); ) {
    let o = !i && r instanceof Hn && r.index < 0 ? null : r.parent;
    if (!o)
      return r;
    r = o;
  }
  let a = i ? 0 : Bt.IgnoreOverlays;
  if (i)
    for (let o = r, s = o.parent; s; o = s, s = o.parent)
      o instanceof Hn && o.index < 0 && ((n = s.enter(e, t, a)) === null || n === void 0 ? void 0 : n.from) != o.from && (r = s);
  for (; ; ) {
    let o = r.enter(e, t, a);
    if (!o)
      return r;
    r = o;
  }
}
class Hn {
  constructor(e, t, i, n) {
    this._tree = e, this.from = t, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, n, a = 0) {
    for (let o = this; ; ) {
      for (let { children: s, positions: l } = o._tree, u = t > 0 ? s.length : -1; e != u; e += t) {
        let h = s[e], c = l[e] + o.from;
        if (nZ(n, i, c, c + h.length)) {
          if (h instanceof Ih) {
            if (a & Bt.ExcludeBuffers)
              continue;
            let f = h.findChild(0, h.buffer.length, t, i - c, n);
            if (f > -1)
              return new Za(new x1e(o, h, e, c), null, f);
          } else if (a & Bt.IncludeAnonymous || !h.type.isAnonymous || Gw(h)) {
            let f;
            if (!(a & Bt.IgnoreMounts) && h.props && (f = h.prop(ht.mounted)) && !f.overlay)
              return new Hn(f.tree, c, e, o);
            let d = new Hn(h, c, e, o);
            return a & Bt.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? h.children.length - 1 : 0, t, i, n);
          }
        }
      }
      if (a & Bt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    let n;
    if (!(i & Bt.IgnoreOverlays) && (n = this._tree.prop(ht.mounted)) && n.overlay) {
      let a = e - this.from;
      for (let { from: o, to: s } of n.overlay)
        if ((t > 0 ? o <= a : o < a) && (t < 0 ? s >= a : s > a))
          return new Hn(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(e = 0) {
    return new Sg(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, t = 0) {
    return lf(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return lf(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return aZ(this, e);
  }
  getChild(e, t = null, i = null) {
    let n = gb(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return gb(this, e, t, i);
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return vb(this, e);
  }
}
function gb(r, e, t, i) {
  let n = r.cursor(), a = [];
  if (!n.firstChild())
    return a;
  if (t != null) {
    for (; !n.type.is(t); )
      if (!n.nextSibling())
        return a;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return a;
    if (n.type.is(e) && a.push(n.node), !n.nextSibling())
      return i == null ? a : [];
  }
}
function vb(r, e, t = e.length - 1) {
  for (let i = r.parent; t >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class x1e {
  constructor(e, t, i, n) {
    this.parent = e, this.buffer = t, this.index = i, this.start = n;
  }
}
class Za {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: n } = this.context, a = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.context.start, i);
    return a < 0 ? null : new Za(this.context, this, a);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    if (i & Bt.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, a = n.findChild(this.index + 4, n.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return a < 0 ? null : new Za(this.context, this, a);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Za(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Za(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(e = 0) {
    return new Sg(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, n = this.index + 4, a = i.buffer[this.index + 3];
    if (a > n) {
      let o = i.buffer[this.index + 1];
      e.push(i.slice(n, a, o)), t.push(0);
    }
    return new er(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return lf(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return lf(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return aZ(this, e);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, i = null) {
    let n = gb(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return gb(this, e, t, i);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return vb(this, e);
  }
}
class Sg {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof Hn)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: n } = this.buffer;
    return this.type = t || n.set.types[n.buffer[e]], this.from = i + n.buffer[e + 1], this.to = i + n.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof Hn ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: n } = this.buffer, a = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.buffer.start, i);
    return a < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(a));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, i = this.mode) {
    return this.buffer ? i & Bt.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Bt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Bt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(t.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = t.buffer[this.index + 3];
      if (n < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let a = 0; a < this.index; a++)
          if (n.buffer.buffer[a + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = n);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let a = t + e, o = e < 0 ? -1 : i._tree.children.length; a != o; a += e) {
          let s = i._tree.children[a];
          if (this.mode & Bt.IncludeAnonymous || s instanceof Ih || !s.type.isAnonymous || Gw(s))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let n = this.index, a = this.stack.length; a >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == n) {
              if (n == this.index)
                return o;
              t = o, i = a + 1;
              break e;
            }
          n = this.stack[--a];
        }
    for (let n = i; n < this.stack.length; n++)
      t = new Za(this.buffer, t, this.stack[n]);
    return this.bufferNode = new Za(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let i = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; n && t && t(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return vb(this.node, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let n = e.length - 1, a = this.stack.length - 1; n >= 0; a--) {
      if (a < 0)
        return vb(this.node, e, n);
      let o = i[t.buffer[this.stack[a]]];
      if (!o.isAnonymous) {
        if (e[n] && e[n] != o.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function Gw(r) {
  return r.children.some((e) => e instanceof Ih || !e.type.isAnonymous || Gw(e));
}
function w1e(r) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: n = rZ, reused: a = [], minRepeatType: o = i.types.length } = r, s = Array.isArray(t) ? new $w(t, t.length) : t, l = i.types, u = 0, h = 0;
  function c(b, T, S, y, A) {
    let { id: C, start: _, end: I, size: x } = s, P = h;
    for (; x < 0; )
      if (s.next(), x == -1) {
        let k = a[C];
        S.push(k), y.push(_ - b);
        return;
      } else if (x == -3) {
        u = C;
        return;
      } else if (x == -4) {
        h = C;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${x}`);
    let N = l[C], L, D, $ = _ - b;
    if (I - _ <= n && (D = g(s.pos - T, A))) {
      let k = new Uint16Array(D.size - D.skip), G = s.pos - D.size, F = k.length;
      for (; s.pos > G; )
        F = v(D.start, k, F);
      L = new Ih(k, I - D.start, i), $ = D.start - b;
    } else {
      let k = s.pos - x;
      s.next();
      let G = [], F = [], q = C >= o ? C : -1, re = 0, fe = I;
      for (; s.pos > k; )
        q >= 0 && s.id == q && s.size >= 0 ? (s.end <= fe - n && (d(G, F, _, re, s.end, fe, q, P), re = G.length, fe = s.end), s.next()) : c(_, k, G, F, q);
      if (q >= 0 && re > 0 && re < G.length && d(G, F, _, re, _, fe, q, P), G.reverse(), F.reverse(), q > -1 && re > 0) {
        let de = f(N);
        L = Bw(N, G, F, 0, G.length, 0, I - _, de, de);
      } else
        L = p(N, G, F, I - _, P - I);
    }
    S.push(L), y.push($);
  }
  function f(b) {
    return (T, S, y) => {
      let A = 0, C = T.length - 1, _, I;
      if (C >= 0 && (_ = T[C]) instanceof er) {
        if (!C && _.type == b && _.length == y)
          return _;
        (I = _.prop(ht.lookAhead)) && (A = S[C] + _.length + I);
      }
      return p(b, T, S, y, A);
    };
  }
  function d(b, T, S, y, A, C, _, I) {
    let x = [], P = [];
    for (; b.length > y; )
      x.push(b.pop()), P.push(T.pop() + S - A);
    b.push(p(i.types[_], x, P, C - A, I - C)), T.push(A - S);
  }
  function p(b, T, S, y, A = 0, C) {
    if (u) {
      let _ = [ht.contextHash, u];
      C = C ? [_].concat(C) : [_];
    }
    if (A > 25) {
      let _ = [ht.lookAhead, A];
      C = C ? [_].concat(C) : [_];
    }
    return new er(b, T, S, y, C);
  }
  function g(b, T) {
    let S = s.fork(), y = 0, A = 0, C = 0, _ = S.end - n, I = { size: 0, start: 0, skip: 0 };
    e:
      for (let x = S.pos - b; S.pos > x; ) {
        let P = S.size;
        if (S.id == T && P >= 0) {
          I.size = y, I.start = A, I.skip = C, C += 4, y += 4, S.next();
          continue;
        }
        let N = S.pos - P;
        if (P < 0 || N < x || S.start < _)
          break;
        let L = S.id >= o ? 4 : 0, D = S.start;
        for (S.next(); S.pos > N; ) {
          if (S.size < 0)
            if (S.size == -3)
              L += 4;
            else
              break e;
          else
            S.id >= o && (L += 4);
          S.next();
        }
        A = D, y += P, C += L;
      }
    return (T < 0 || y == b) && (I.size = y, I.start = A, I.skip = C), I.size > 4 ? I : void 0;
  }
  function v(b, T, S) {
    let { id: y, start: A, end: C, size: _ } = s;
    if (s.next(), _ >= 0 && y < o) {
      let I = S;
      if (_ > 4) {
        let x = s.pos - (_ - 4);
        for (; s.pos > x; )
          S = v(b, T, S);
      }
      T[--S] = I, T[--S] = C - b, T[--S] = A - b, T[--S] = y;
    } else
      _ == -3 ? u = y : _ == -4 && (h = y);
    return S;
  }
  let O = [], m = [];
  for (; s.pos > 0; )
    c(r.start || 0, r.bufferStart || 0, O, m, -1);
  let E = (e = r.length) !== null && e !== void 0 ? e : O.length ? m[0] + O[0].length : 0;
  return new er(l[r.topID], O.reverse(), m.reverse(), E);
}
const nG = /* @__PURE__ */ new WeakMap();
function Qm(r, e) {
  if (!r.isAnonymous || e instanceof Ih || e.type != r)
    return 1;
  let t = nG.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != r || !(i instanceof er)) {
        t = 1;
        break;
      }
      t += Qm(r, i);
    }
    nG.set(e, t);
  }
  return t;
}
function Bw(r, e, t, i, n, a, o, s, l) {
  let u = 0;
  for (let p = i; p < n; p++)
    u += Qm(r, e[p]);
  let h = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), c = [], f = [];
  function d(p, g, v, O, m) {
    for (let E = v; E < O; ) {
      let b = E, T = g[E], S = Qm(r, p[E]);
      for (E++; E < O; E++) {
        let y = Qm(r, p[E]);
        if (S + y >= h)
          break;
        S += y;
      }
      if (E == b + 1) {
        if (S > h) {
          let y = p[b];
          d(y.children, y.positions, 0, y.children.length, g[b] + m);
          continue;
        }
        c.push(p[b]);
      } else {
        let y = g[E - 1] + p[E - 1].length - T;
        c.push(Bw(r, p, g, b, E, T, y, null, l));
      }
      f.push(T + m - a);
    }
  }
  return d(e, t, i, n, 0), (s || l)(c, f, o);
}
class oZ {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, i) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(t, i);
  }
  getBuffer(e, t) {
    let i = this.map.get(e);
    return i && i.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof Za ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof Hn && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof Za ? this.getBuffer(e.context.buffer, e.index) : e instanceof Hn ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class $o {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, i, n, a = !1, o = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = n, this.open = (a ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], i = !1) {
    let n = [new $o(0, e.length, e, 0, !1, i)];
    for (let a of t)
      a.to > e.length && n.push(a);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let n = [], a = 1, o = e.length ? e[0] : null;
    for (let s = 0, l = 0, u = 0; ; s++) {
      let h = s < t.length ? t[s] : null, c = h ? h.fromA : 1e9;
      if (c - l >= i)
        for (; o && o.from < c; ) {
          let f = o;
          if (l >= f.from || c <= f.to || u) {
            let d = Math.max(f.from, l) - u, p = Math.min(f.to, c) - u;
            f = d >= p ? null : new $o(d, p, f.tree, f.offset + u, s > 0, !!h);
          }
          if (f && n.push(f), o.to > c)
            break;
          o = a < e.length ? e[a++] : null;
        }
      if (!h)
        break;
      l = h.toA, u = h.toA - h.toB;
    }
    return n;
  }
}
class sZ {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, i) {
    return typeof e == "string" && (e = new P1e(e)), i = i ? i.length ? i.map((n) => new Gn(n.from, n.to)) : [new Gn(0, 0)] : [new Gn(0, e.length)], this.createParse(e, t || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, i) {
    let n = this.startParse(e, t, i);
    for (; ; ) {
      let a = n.advance();
      if (a)
        return a;
    }
  }
}
class P1e {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function N1e(r) {
  return (e, t, i, n) => new D1e(e, r, t, i, n);
}
class aG {
  constructor(e, t, i, n, a) {
    if (this.parser = e, this.parse = t, this.overlay = i, this.target = n, this.ranges = a, !a.length || a.some((o) => o.from >= o.to))
      throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(a));
  }
}
class L1e {
  constructor(e, t, i, n, a, o, s) {
    this.parser = e, this.predicate = t, this.mounts = i, this.index = n, this.start = a, this.target = o, this.prev = s, this.depth = 0, this.ranges = [];
  }
}
const X_ = new ht({ perNode: !0 });
class D1e {
  constructor(e, t, i, n, a) {
    this.nest = t, this.input = i, this.fragments = n, this.ranges = a, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new er(i.type, i.children, i.positions, i.length, i.propValues.concat([[X_, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[ht.mounted.id] = new _1e(t, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].ranges[0].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new Q1e(this.fragments), t = null, i = null, n = new Sg(new Hn(this.baseTree, this.ranges[0].from, 0, null), Bt.IncludeAnonymous | Bt.IgnoreMounts);
    e:
      for (let a, o; this.stoppedAt == null || n.from < this.stoppedAt; ) {
        let s = !0, l;
        if (e.hasNode(n)) {
          if (t) {
            let u = t.mounts.find((h) => h.frag.from <= n.from && h.frag.to >= n.to && h.mount.overlay);
            if (u)
              for (let h of u.mount.overlay) {
                let c = h.from + u.pos, f = h.to + u.pos;
                c >= n.from && f <= n.to && !t.ranges.some((d) => d.from < f && d.to > c) && t.ranges.push({ from: c, to: f });
              }
          }
          s = !1;
        } else if (i && (o = M1e(i.ranges, n.from, n.to)))
          s = o != 2;
        else if (!n.type.isAnonymous && n.from < n.to && (a = this.nest(n, this.input))) {
          n.tree || k1e(n);
          let u = e.findMounts(n.from, a.parser);
          if (typeof a.overlay == "function")
            t = new L1e(a.parser, a.overlay, u, this.inner.length, n.from, n.tree, t);
          else {
            let h = lG(this.ranges, a.overlay || [new Gn(n.from, n.to)]);
            h.length && this.inner.push(new aG(a.parser, a.parser.startParse(this.input, uG(u, h), h), a.overlay ? a.overlay.map((c) => new Gn(c.from - n.from, c.to - n.from)) : null, n.tree, h)), a.overlay ? h.length && (i = { ranges: h, depth: 0, prev: i }) : s = !1;
          }
        } else
          t && (l = t.predicate(n)) && (l === !0 && (l = new Gn(n.from, n.to)), l.from < l.to && t.ranges.push(l));
        if (s && n.firstChild())
          t && t.depth++, i && i.depth++;
        else
          for (; !n.nextSibling(); ) {
            if (!n.parent())
              break e;
            if (t && !--t.depth) {
              let u = lG(this.ranges, t.ranges);
              u.length && this.inner.splice(t.index, 0, new aG(t.parser, t.parser.startParse(this.input, uG(t.mounts, u), u), t.ranges.map((h) => new Gn(h.from - t.start, h.to - t.start)), t.target, u)), t = t.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
}
function M1e(r, e, t) {
  for (let i of r) {
    if (i.from >= t)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= t ? 2 : 1;
  }
  return 0;
}
function oG(r, e, t, i, n, a) {
  if (e < t) {
    let o = r.buffer[e + 1];
    i.push(r.slice(e, t, o)), n.push(o - a);
  }
}
function k1e(r) {
  let { node: e } = r, t = 0;
  do
    r.parent(), t++;
  while (!r.tree);
  let i = 0, n = r.tree, a = 0;
  for (; a = n.positions[i] + r.from, !(a <= e.from && a + n.children[i].length >= e.to); i++)
    ;
  let o = n.children[i], s = o.buffer;
  function l(u, h, c, f, d) {
    let p = u;
    for (; s[p + 2] + a <= e.from; )
      p = s[p + 3];
    let g = [], v = [];
    oG(o, u, p, g, v, f);
    let O = s[p + 1], m = s[p + 2], E = O + a == e.from && m + a == e.to && s[p] == e.type.id;
    return g.push(E ? e.toTree() : l(p + 4, s[p + 3], o.set.types[s[p]], O, m - O)), v.push(O - f), oG(o, s[p + 3], h, g, v, f), new er(c, g, v, d);
  }
  n.children[i] = l(0, s.length, On.none, 0, o.length);
  for (let u = 0; u <= t; u++)
    r.childAfter(e.from);
}
class sG {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Bt.IncludeAnonymous | Bt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, i = e - this.offset;
    for (; !this.done && t.from < i; )
      t.to >= e && t.enter(i, 1, Bt.IgnoreOverlays | Bt.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof er)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let Q1e = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (t = i.tree.prop(X_)) !== null && t !== void 0 ? t : i.to, this.inner = new sG(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(X_)) !== null && e !== void 0 ? e : t.to, this.inner = new sG(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var i;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let a = this.inner.cursor.node; a; a = a.parent) {
        let o = (i = a.tree) === null || i === void 0 ? void 0 : i.prop(ht.mounted);
        if (o && o.parser == t)
          for (let s = this.fragI; s < this.fragments.length; s++) {
            let l = this.fragments[s];
            if (l.from >= a.to)
              break;
            l.tree == this.curFrag.tree && n.push({
              frag: l,
              pos: a.from - l.offset,
              mount: o
            });
          }
      }
    }
    return n;
  }
};
function lG(r, e) {
  let t = null, i = e;
  for (let n = 1, a = 0; n < r.length; n++) {
    let o = r[n - 1].to, s = r[n].from;
    for (; a < i.length; a++) {
      let l = i[a];
      if (l.from >= s)
        break;
      l.to <= o || (t || (i = t = e.slice()), l.from < o ? (t[a] = new Gn(l.from, o), l.to > s && t.splice(a + 1, 0, new Gn(s, l.to))) : l.to > s ? t[a--] = new Gn(s, l.to) : t.splice(a--, 1));
    }
  }
  return i;
}
function U1e(r, e, t, i) {
  let n = 0, a = 0, o = !1, s = !1, l = -1e9, u = [];
  for (; ; ) {
    let h = n == r.length ? 1e9 : o ? r[n].to : r[n].from, c = a == e.length ? 1e9 : s ? e[a].to : e[a].from;
    if (o != s) {
      let f = Math.max(l, t), d = Math.min(h, c, i);
      f < d && u.push(new Gn(f, d));
    }
    if (l = Math.min(h, c), l == 1e9)
      break;
    h == l && (o ? (o = !1, n++) : o = !0), c == l && (s ? (s = !1, a++) : s = !0);
  }
  return u;
}
function uG(r, e) {
  let t = [];
  for (let { pos: i, mount: n, frag: a } of r) {
    let o = i + (n.overlay ? n.overlay[0].from : 0), s = o + n.tree.length, l = Math.max(a.from, o), u = Math.min(a.to, s);
    if (n.overlay) {
      let h = n.overlay.map((f) => new Gn(f.from + i, f.to + i)), c = U1e(e, h, l, u);
      for (let f = 0, d = l; ; f++) {
        let p = f == c.length, g = p ? u : c[f].from;
        if (g > d && t.push(new $o(d, g, n.tree, -o, a.from >= d || a.openStart, a.to <= g || a.openEnd)), p)
          break;
        d = c[f].to;
      }
    } else
      t.push(new $o(l, u, n.tree, -o, a.from >= o || a.openStart, a.to <= s || a.openEnd));
  }
  return t;
}
let $1e = 0;
class Ua {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = $1e++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Ua([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new Ob();
    return (t) => t.modified.indexOf(e) > -1 ? t : Ob.get(t.base || t, t.modified.concat(e).sort((i, n) => i.id - n.id));
  }
}
let G1e = 0;
class Ob {
  constructor() {
    this.instances = [], this.id = G1e++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((s) => s.base == e && B1e(t, s.modified));
    if (i)
      return i;
    let n = [], a = new Ua(n, e, t);
    for (let s of t)
      s.instances.push(a);
    let o = V1e(t);
    for (let s of e.set)
      if (!s.modified.length)
        for (let l of o)
          n.push(Ob.get(s, l));
    return a;
  }
}
function B1e(r, e) {
  return r.length == e.length && r.every((t, i) => t == e[i]);
}
function V1e(r) {
  let e = [[]];
  for (let t = 0; t < r.length; t++)
    for (let i = 0, n = e.length; i < n; i++)
      e.push(e[i].concat(r[t]));
  return e.sort((t, i) => i.length - t.length);
}
function Rl(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r) {
    let i = r[t];
    Array.isArray(i) || (i = [i]);
    for (let n of t.split(" "))
      if (n) {
        let a = [], o = 2, s = n;
        for (let c = 0; ; ) {
          if (s == "..." && c > 0 && c + 3 == n.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(s);
          if (!f)
            throw new RangeError("Invalid path: " + n);
          if (a.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), c += f[0].length, c == n.length)
            break;
          let d = n[c++];
          if (c == n.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + n);
          s = n.slice(c);
        }
        let l = a.length - 1, u = a[l];
        if (!u)
          throw new RangeError("Invalid path: " + n);
        let h = new mb(i, o, l > 0 ? a.slice(0, l) : null);
        e[u] = h.sort(e[u]);
      }
  }
  return lZ.add(e);
}
const lZ = new ht();
class mb {
  constructor(e, t, i, n) {
    this.tags = e, this.mode = t, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
mb.empty = new mb([], 2, null);
function uZ(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let a of r)
    if (!Array.isArray(a.tag))
      t[a.tag.id] = a.class;
    else
      for (let o of a.tag)
        t[o.id] = a.class;
  let { scope: i, all: n = null } = e || {};
  return {
    style: (a) => {
      let o = n;
      for (let s of a)
        for (let l of s.set) {
          let u = t[l.id];
          if (u) {
            o = o ? o + " " + u : u;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function F1e(r, e) {
  let t = null;
  for (let i of r) {
    let n = i.style(e);
    n && (t = t ? t + " " + n : n);
  }
  return t;
}
function X1e(r, e, t, i = 0, n = r.length) {
  let a = new Y1e(i, Array.isArray(e) ? e : [e], t);
  a.highlightRange(r.cursor(), i, n, "", a.highlighters), a.flush(n);
}
class Y1e {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, n, a) {
    let { type: o, from: s, to: l } = e;
    if (s >= i || l <= t)
      return;
    o.isTop && (a = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let u = n, h = H1e(e) || mb.empty, c = F1e(a, h.tags);
    if (c && (u && (u += " "), u += c, h.mode == 1 && (n += (n ? " " : "") + c)), this.startSpan(Math.max(t, s), u), h.opaque)
      return;
    let f = e.tree && e.tree.prop(ht.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + s, 1), p = this.highlighters.filter((v) => !v.scope || v.scope(f.tree.type)), g = e.firstChild();
      for (let v = 0, O = s; ; v++) {
        let m = v < f.overlay.length ? f.overlay[v] : null, E = m ? m.from + s : l, b = Math.max(t, O), T = Math.min(i, E);
        if (b < T && g)
          for (; e.from < T && (this.highlightRange(e, b, T, n, a), this.startSpan(Math.min(T, e.to), u), !(e.to >= E || !e.nextSibling())); )
            ;
        if (!m || E > i)
          break;
        O = m.to + s, O > t && (this.highlightRange(d.cursor(), Math.max(t, m.from + s), Math.min(i, O), "", p), this.startSpan(Math.min(i, O), u));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      f && (n = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, n, a), this.startSpan(Math.min(i, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function H1e(r) {
  let e = r.type.prop(lZ);
  for (; e && e.context && !r.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const he = Ua.define, WO = he(), As = he(), hG = he(As), cG = he(As), Cs = he(), zO = he(Cs), TR = he(Cs), Ma = he(), eu = he(Ma), wa = he(), Pa = he(), Y_ = he(), Td = he(Y_), ZO = he(), R = {
  /**
  A comment.
  */
  comment: WO,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: he(WO),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: he(WO),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: he(WO),
  /**
  Any kind of identifier.
  */
  name: As,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: he(As),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: hG,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: he(hG),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: cG,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: he(cG),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: he(As),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: he(As),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: he(As),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: he(As),
  /**
  A literal value.
  */
  literal: Cs,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: zO,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: he(zO),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: he(zO),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: he(zO),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: TR,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: he(TR),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: he(TR),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: he(Cs),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: he(Cs),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: he(Cs),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: he(Cs),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: he(Cs),
  /**
  A language keyword.
  */
  keyword: wa,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: he(wa),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: he(wa),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: he(wa),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: he(wa),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: he(wa),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: he(wa),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: he(wa),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: he(wa),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: he(wa),
  /**
  An operator.
  */
  operator: Pa,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: he(Pa),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: he(Pa),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: he(Pa),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: he(Pa),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: he(Pa),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: he(Pa),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: he(Pa),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: he(Pa),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: he(Pa),
  /**
  Program or markup punctuation.
  */
  punctuation: Y_,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: he(Y_),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: Td,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: he(Td),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: he(Td),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: he(Td),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: he(Td),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Ma,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: eu,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: he(eu),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: he(eu),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: he(eu),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: he(eu),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: he(eu),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: he(eu),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: he(Ma),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: he(Ma),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: he(Ma),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: he(Ma),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: he(Ma),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: he(Ma),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: he(Ma),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: he(Ma),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: he(),
  /**
  Deleted text.
  */
  deleted: he(),
  /**
  Changed text.
  */
  changed: he(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: he(),
  /**
  Metadata or meta-instruction.
  */
  meta: ZO,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: he(ZO),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: he(ZO),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: he(ZO),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Ua.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Ua.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Ua.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Ua.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Ua.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Ua.defineModifier()
};
uZ([
  { tag: R.link, class: "tok-link" },
  { tag: R.heading, class: "tok-heading" },
  { tag: R.emphasis, class: "tok-emphasis" },
  { tag: R.strong, class: "tok-strong" },
  { tag: R.keyword, class: "tok-keyword" },
  { tag: R.atom, class: "tok-atom" },
  { tag: R.bool, class: "tok-bool" },
  { tag: R.url, class: "tok-url" },
  { tag: R.labelName, class: "tok-labelName" },
  { tag: R.inserted, class: "tok-inserted" },
  { tag: R.deleted, class: "tok-deleted" },
  { tag: R.literal, class: "tok-literal" },
  { tag: R.string, class: "tok-string" },
  { tag: R.number, class: "tok-number" },
  { tag: [R.regexp, R.escape, R.special(R.string)], class: "tok-string2" },
  { tag: R.variableName, class: "tok-variableName" },
  { tag: R.local(R.variableName), class: "tok-variableName tok-local" },
  { tag: R.definition(R.variableName), class: "tok-variableName tok-definition" },
  { tag: R.special(R.variableName), class: "tok-variableName2" },
  { tag: R.definition(R.propertyName), class: "tok-propertyName tok-definition" },
  { tag: R.typeName, class: "tok-typeName" },
  { tag: R.namespace, class: "tok-namespace" },
  { tag: R.className, class: "tok-className" },
  { tag: R.macroName, class: "tok-macroName" },
  { tag: R.propertyName, class: "tok-propertyName" },
  { tag: R.operator, class: "tok-operator" },
  { tag: R.comment, class: "tok-comment" },
  { tag: R.meta, class: "tok-meta" },
  { tag: R.invalid, class: "tok-invalid" },
  { tag: R.punctuation, class: "tok-punctuation" }
]);
var yR;
const Sc = /* @__PURE__ */ new ht();
function W1e(r) {
  return Re.define({
    combine: r ? (e) => e.concat(r) : void 0
  });
}
const z1e = /* @__PURE__ */ new ht();
class da {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, i = [], n = "") {
    this.data = e, this.name = n, St.prototype.hasOwnProperty("tree") || Object.defineProperty(St.prototype, "tree", { get() {
      return qt(this);
    } }), this.parser = t, this.extension = [
      Ol.of(this),
      St.languageData.of((a, o, s) => {
        let l = fG(a, o, s), u = l.type.prop(Sc);
        if (!u)
          return [];
        let h = a.facet(u), c = l.type.prop(z1e);
        if (c) {
          let f = l.resolve(o - l.from, s);
          for (let d of c)
            if (d.test(f, a)) {
              let p = a.facet(d.facet);
              return d.type == "replace" ? p : p.concat(h);
            }
        }
        return h;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return fG(e, t, i).type.prop(Sc) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(Ol);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], n = (a, o) => {
      if (a.prop(Sc) == this.data) {
        i.push({ from: o, to: o + a.length });
        return;
      }
      let s = a.prop(ht.mounted);
      if (s) {
        if (s.tree.prop(Sc) == this.data) {
          if (s.overlay)
            for (let l of s.overlay)
              i.push({ from: l.from + o, to: l.to + o });
          else
            i.push({ from: o, to: o + a.length });
          return;
        } else if (s.overlay) {
          let l = i.length;
          if (n(s.tree, s.overlay[0].from + o), i.length > l)
            return;
        }
      }
      for (let l = 0; l < a.children.length; l++) {
        let u = a.children[l];
        u instanceof er && n(u, a.positions[l] + o);
      }
    };
    return n(qt(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
da.setState = /* @__PURE__ */ rt.define();
function fG(r, e, t) {
  let i = r.facet(Ol), n = qt(r).topNode;
  if (!i || i.allowsNesting)
    for (let a = n; a; a = a.enter(e, t, Bt.ExcludeBuffers))
      a.type.isTop && (n = a);
  return n;
}
class co extends da {
  constructor(e, t, i) {
    super(e, t, [], i), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = W1e(e.languageData);
    return new co(t, e.parser.configure({
      props: [Sc.add((i) => i.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new co(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function qt(r) {
  let e = r.field(da.state, !1);
  return e ? e.tree : er.empty;
}
class Z1e {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let yd = null;
class Eb {
  constructor(e, t, i = [], n, a, o, s, l) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = n, this.treeLen = a, this.viewport = o, this.skipped = s, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Eb(e, t, [], er.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new Z1e(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != er.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped($o.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped($o.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = yd;
    yd = this;
    try {
      return e();
    } finally {
      yd = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = dG(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: n, treeLen: a, viewport: o, skipped: s } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, h, c, f) => l.push({ fromA: u, toA: h, fromB: c, toB: f })), i = $o.applyChanges(i, l), n = er.empty, a = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        s = [];
        for (let u of this.skipped) {
          let h = e.mapPos(u.from, 1), c = e.mapPos(u.to, -1);
          h < c && s.push({ from: h, to: c });
        }
      }
    }
    return new Eb(this.parser, t, i, n, a, o, s, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: a } = this.skipped[i];
      n < e.to && a > e.from && (this.fragments = dG(this.fragments, n, a), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends sZ {
      createParse(t, i, n) {
        let a = n[0].from, o = n[n.length - 1].to;
        return {
          parsedPos: a,
          advance() {
            let l = yd;
            if (l) {
              for (let u of n)
                l.tempSkipped.push(u);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new er(On.none, [], [], o - a);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return yd;
  }
}
function dG(r, e, t) {
  return $o.applyChanges(r, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class uf {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new uf(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = Eb.create(e.facet(Ol).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new uf(i);
  }
}
da.state = /* @__PURE__ */ kr.define({
  create: uf.init,
  update(r, e) {
    for (let t of e.effects)
      if (t.is(da.setState))
        return t.value;
    return e.startState.facet(Ol) != e.state.facet(Ol) ? uf.init(e.state) : r.apply(e);
  }
});
let hZ = (r) => {
  let e = setTimeout(
    () => r(),
    500
    /* MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (hZ = (r) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(r, {
        timeout: 500 - 100
        /* MinPause */
      });
    },
    100
    /* MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const RR = typeof navigator < "u" && (!((yR = navigator.scheduling) === null || yR === void 0) && yR.isInputPending) ? () => navigator.scheduling.isInputPending() : null, q1e = /* @__PURE__ */ Ir.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(da.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(da.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = hZ(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, a = i.field(da.state);
    if (a.tree == a.context.tree && a.context.isDone(
      n + 1e5
      /* MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !RR ? Math.max(25, e.timeRemaining() - 5) : 1e9), s = a.context.treeLen < n && i.doc.length > n + 1e3, l = a.context.work(() => RR && RR() || Date.now() > o, n + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (a.context.takeTree(), this.view.dispatch({ effects: da.setState.of(new uf(a.context)) })), this.chunkBudget > 0 && !(l && !s) && this.scheduleWork(), this.checkAsyncSchedule(a.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => Xn(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Ol = /* @__PURE__ */ Re.define({
  combine(r) {
    return r.length ? r[0] : null;
  },
  enables: (r) => [
    da.state,
    q1e,
    ge.contentAttributes.compute([r], (e) => {
      let t = e.facet(r);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class xh {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const j1e = /* @__PURE__ */ Re.define(), tT = /* @__PURE__ */ Re.define({
  combine: (r) => {
    if (!r.length)
      return "  ";
    let e = r[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(r[0]));
    return e;
  }
});
function bb(r) {
  let e = r.facet(tT);
  return e.charCodeAt(0) == 9 ? r.tabSize * e.length : e.length;
}
function Tg(r, e) {
  let t = "", i = r.tabSize, n = r.facet(tT)[0];
  if (n == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    n = " ";
  }
  for (let a = 0; a < e; a++)
    t += n;
  return t;
}
function Vw(r, e) {
  r instanceof St && (r = new rT(r));
  for (let i of r.state.facet(j1e)) {
    let n = i(r, e);
    if (n !== void 0)
      return n;
  }
  let t = qt(r.state);
  return t.length >= e ? K1e(r, t, e) : null;
}
class rT {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = bb(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: a } = this.options;
    return n != null && n >= i.from && n <= i.to ? a && n == e ? { text: "", from: e } : (t < 0 ? n < e : n <= e) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(e, t);
    return i.slice(e - n, Math.min(i.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), a = this.countColumn(i, e - n), o = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return o > -1 && (a += o - this.countColumn(i, i.search(/\S|$/))), a;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return iv(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), a = this.options.overrideIndentation;
    if (a) {
      let o = a(n);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Al = /* @__PURE__ */ new ht();
function K1e(r, e, t) {
  return cZ(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, r);
}
function J1e(r) {
  return r.pos == r.options.simulateBreak && r.options.simulateDoubleBreak;
}
function eIe(r) {
  let e = r.type.prop(Al);
  if (e)
    return e;
  let t = r.firstChild, i;
  if (t && (i = t.type.prop(ht.closedBy))) {
    let n = r.lastChild, a = n && i.indexOf(n.name) > -1;
    return (o) => fZ(o, !0, 1, void 0, a && !J1e(o) ? n.from : void 0);
  }
  return r.parent == null ? tIe : null;
}
function cZ(r, e, t) {
  for (; r; r = r.parent) {
    let i = eIe(r);
    if (i)
      return i(Fw.create(t, e, r));
  }
  return null;
}
function tIe() {
  return 0;
}
class Fw extends rT {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Fw(e, t, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(t.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (rIe(i, e))
        break;
      t = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? cZ(e, this.pos, this.base) : 0;
  }
}
function rIe(r, e) {
  for (let t = e; t; t = t.parent)
    if (r == t)
      return !0;
  return !1;
}
function iIe(r) {
  let e = r.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let n = r.options.simulateBreak, a = r.state.doc.lineAt(t.from), o = n == null || n <= a.from ? a.to : Math.min(a.to, n);
  for (let s = t.to; ; ) {
    let l = e.childAfter(s);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped)
      return l.from < o ? t : null;
    s = l.to;
  }
}
function bp({ closing: r, align: e = !0, units: t = 1 }) {
  return (i) => fZ(i, e, t, r);
}
function fZ(r, e, t, i, n) {
  let a = r.textAfter, o = a.match(/^\s*/)[0].length, s = i && a.slice(o, o + i.length) == i || n == r.pos + o, l = e ? iIe(r) : null;
  return l ? s ? r.column(l.from) : r.column(l.to) : r.baseIndent + (s ? 0 : r.unit * t);
}
const dZ = (r) => r.baseIndent;
function to({ except: r, units: e = 1 } = {}) {
  return (t) => {
    let i = r && r.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
const nIe = 200;
function aIe() {
  return St.transactionFilter.of((r) => {
    if (!r.docChanged || !r.isUserEvent("input.type") && !r.isUserEvent("input.complete"))
      return r;
    let e = r.startState.languageDataAt("indentOnInput", r.startState.selection.main.head);
    if (!e.length)
      return r;
    let t = r.newDoc, { head: i } = r.newSelection.main, n = t.lineAt(i);
    if (i > n.from + nIe)
      return r;
    let a = t.sliceString(n.from, i);
    if (!e.some((u) => u.test(a)))
      return r;
    let { state: o } = r, s = -1, l = [];
    for (let { head: u } of o.selection.ranges) {
      let h = o.doc.lineAt(u);
      if (h.from == s)
        continue;
      s = h.from;
      let c = Vw(o, h.from);
      if (c == null)
        continue;
      let f = /^\s*/.exec(h.text)[0], d = Tg(o, c);
      f != d && l.push({ from: h.from, to: h.from + f.length, insert: d });
    }
    return l.length ? [r, { changes: l, sequential: !0 }] : r;
  });
}
const oIe = /* @__PURE__ */ Re.define(), Cl = /* @__PURE__ */ new ht();
function lv(r) {
  let e = r.firstChild, t = r.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? r.to : t.from } : null;
}
function sIe(r, e, t) {
  let i = qt(r);
  if (i.length < t)
    return null;
  let n = i.resolveInner(t, 1), a = null;
  for (let o = n; o; o = o.parent) {
    if (o.to <= t || o.from > t)
      continue;
    if (a && o.from < e)
      break;
    let s = o.type.prop(Cl);
    if (s && (o.to < i.length - 50 || i.length == r.doc.length || !lIe(o))) {
      let l = s(o, r);
      l && l.from <= t && l.from >= e && l.to > t && (a = l);
    }
  }
  return a;
}
function lIe(r) {
  let e = r.lastChild;
  return e && e.to == r.to && e.type.isError;
}
function Sb(r, e, t) {
  for (let i of r.facet(oIe)) {
    let n = i(r, e, t);
    if (n)
      return n;
  }
  return sIe(r, e, t);
}
function pZ(r, e) {
  let t = e.mapPos(r.from, 1), i = e.mapPos(r.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const iT = /* @__PURE__ */ rt.define({ map: pZ }), uv = /* @__PURE__ */ rt.define({ map: pZ });
function gZ(r) {
  let e = [];
  for (let { head: t } of r.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(r.lineBlockAt(t));
  return e;
}
const uh = /* @__PURE__ */ kr.define({
  create() {
    return Be.none;
  },
  update(r, e) {
    r = r.map(e.changes);
    for (let t of e.effects)
      if (t.is(iT) && !uIe(r, t.value.from, t.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(Xw), n = i ? Be.replace({ widget: new vIe(i(e.state, t.value)) }) : pG;
        r = r.update({ add: [n.range(t.value.from, t.value.to)] });
      } else
        t.is(uv) && (r = r.update({
          filter: (i, n) => t.value.from != i || t.value.to != n,
          filterFrom: t.value.from,
          filterTo: t.value.to
        }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      r.between(i, i, (n, a) => {
        n < i && a > i && (t = !0);
      }), t && (r = r.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, a) => a <= i || n >= i
      }));
    }
    return r;
  },
  provide: (r) => ge.decorations.from(r),
  toJSON(r, e) {
    let t = [];
    return r.between(0, e.doc.length, (i, n) => {
      t.push(i, n);
    }), t;
  },
  fromJSON(r) {
    if (!Array.isArray(r) || r.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < r.length; ) {
      let i = r[t++], n = r[t++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(pG.range(i, n));
    }
    return Be.set(e, !0);
  }
});
function Tb(r, e, t) {
  var i;
  let n = null;
  return (i = r.field(uh, !1)) === null || i === void 0 || i.between(e, t, (a, o) => {
    (!n || n.from > a) && (n = { from: a, to: o });
  }), n;
}
function uIe(r, e, t) {
  let i = !1;
  return r.between(e, e, (n, a) => {
    n == e && a == t && (i = !0);
  }), i;
}
function vZ(r, e) {
  return r.field(uh, !1) ? e : e.concat(rt.appendConfig.of(mZ()));
}
const hIe = (r) => {
  for (let e of gZ(r)) {
    let t = Sb(r.state, e.from, e.to);
    if (t)
      return r.dispatch({ effects: vZ(r.state, [iT.of(t), OZ(r, t)]) }), !0;
  }
  return !1;
}, cIe = (r) => {
  if (!r.state.field(uh, !1))
    return !1;
  let e = [];
  for (let t of gZ(r)) {
    let i = Tb(r.state, t.from, t.to);
    i && e.push(uv.of(i), OZ(r, i, !1));
  }
  return e.length && r.dispatch({ effects: e }), e.length > 0;
};
function OZ(r, e, t = !0) {
  let i = r.state.doc.lineAt(e.from).number, n = r.state.doc.lineAt(e.to).number;
  return ge.announce.of(`${r.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${r.state.phrase("to")} ${n}.`);
}
const fIe = (r) => {
  let { state: e } = r, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let n = r.lineBlockAt(i), a = Sb(e, n.from, n.to);
    a && t.push(iT.of(a)), i = (a ? r.lineBlockAt(a.to) : n).to + 1;
  }
  return t.length && r.dispatch({ effects: vZ(r.state, t) }), !!t.length;
}, dIe = (r) => {
  let e = r.state.field(uh, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, r.state.doc.length, (i, n) => {
    t.push(uv.of({ from: i, to: n }));
  }), r.dispatch({ effects: t }), !0;
}, pIe = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: hIe },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: cIe },
  { key: "Ctrl-Alt-[", run: fIe },
  { key: "Ctrl-Alt-]", run: dIe }
], gIe = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, Xw = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, gIe);
  }
});
function mZ(r) {
  let e = [uh, EIe];
  return r && e.push(Xw.of(r)), e;
}
function EZ(r, e) {
  let { state: t } = r, i = t.facet(Xw), n = (o) => {
    let s = r.lineBlockAt(r.posAtDOM(o.target)), l = Tb(r.state, s.from, s.to);
    l && r.dispatch({ effects: uv.of(l) }), o.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(r, n, e);
  let a = document.createElement("span");
  return a.textContent = i.placeholderText, a.setAttribute("aria-label", t.phrase("folded code")), a.title = t.phrase("unfold"), a.className = "cm-foldPlaceholder", a.onclick = n, a;
}
const pG = /* @__PURE__ */ Be.replace({ widget: /* @__PURE__ */ new class extends ns {
  toDOM(r) {
    return EZ(r, null);
  }
}() });
class vIe extends ns {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return EZ(e, this.value);
  }
}
const OIe = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class AR extends qo {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function mIe(r = {}) {
  let e = Object.assign(Object.assign({}, OIe), r), t = new AR(e, !0), i = new AR(e, !1), n = Ir.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Ol) != o.state.facet(Ol) || o.startState.field(uh, !1) != o.state.field(uh, !1) || qt(o.startState) != qt(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let s = new fl();
      for (let l of o.viewportLineBlocks) {
        let u = Tb(o.state, l.from, l.to) ? i : Sb(o.state, l.from, l.to) ? t : null;
        u && s.add(l.from, l.from, u);
      }
      return s.finish();
    }
  }), { domEventHandlers: a } = e;
  return [
    n,
    v1e({
      class: "cm-foldGutter",
      markers(o) {
        var s;
        return ((s = o.plugin(n)) === null || s === void 0 ? void 0 : s.markers) || Nt.empty;
      },
      initialSpacer() {
        return new AR(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, a), { click: (o, s, l) => {
        if (a.click && a.click(o, s, l))
          return !0;
        let u = Tb(o.state, s.from, s.to);
        if (u)
          return o.dispatch({ effects: uv.of(u) }), !0;
        let h = Sb(o.state, s.from, s.to);
        return h ? (o.dispatch({ effects: iT.of(h) }), !0) : !1;
      } })
    }),
    mZ()
  ];
}
const EIe = /* @__PURE__ */ ge.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class En {
  constructor(e, t) {
    this.specs = e;
    let i;
    function n(s) {
      let l = dl.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = s, l;
    }
    const a = typeof t.all == "string" ? t.all : t.all ? n(t.all) : void 0, o = t.scope;
    this.scope = o instanceof da ? (s) => s.prop(Sc) == o.data : o ? (s) => s == o : void 0, this.style = uZ(e.map((s) => ({
      tag: s.tag,
      class: s.class || n(Object.assign({}, s, { tag: null }))
    })), {
      all: a
    }).style, this.module = i ? new dl(i) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new En(e, t || {});
  }
}
const H_ = /* @__PURE__ */ Re.define(), bZ = /* @__PURE__ */ Re.define({
  combine(r) {
    return r.length ? [r[0]] : null;
  }
});
function CR(r) {
  let e = r.facet(H_);
  return e.length ? e : r.facet(bZ);
}
function Eo(r, e) {
  let t = [SIe], i;
  return r instanceof En && (r.module && t.push(ge.styleModule.of(r.module)), i = r.themeType), e != null && e.fallback ? t.push(bZ.of(r)) : i ? t.push(H_.computeN([ge.darkTheme], (n) => n.facet(ge.darkTheme) == (i == "dark") ? [r] : [])) : t.push(H_.of(r)), t;
}
class bIe {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = qt(e.state), this.decorations = this.buildDeco(e, CR(e.state));
  }
  update(e) {
    let t = qt(e.state), i = CR(e.state), n = i != CR(e.startState);
    t.length < e.view.viewport.to && !n && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || n) && (this.tree = t, this.decorations = this.buildDeco(e.view, i));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return Be.none;
    let i = new fl();
    for (let { from: n, to: a } of e.visibleRanges)
      X1e(this.tree, t, (o, s, l) => {
        i.add(o, s, this.markCache[l] || (this.markCache[l] = Be.mark({ class: l })));
      }, n, a);
    return i.finish();
  }
}
const SIe = /* @__PURE__ */ _h.high(/* @__PURE__ */ Ir.fromClass(bIe, {
  decorations: (r) => r.decorations
})), TIe = /* @__PURE__ */ En.define([
  {
    tag: R.meta,
    color: "#404740"
  },
  {
    tag: R.link,
    textDecoration: "underline"
  },
  {
    tag: R.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: R.emphasis,
    fontStyle: "italic"
  },
  {
    tag: R.strong,
    fontWeight: "bold"
  },
  {
    tag: R.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: R.keyword,
    color: "#708"
  },
  {
    tag: [R.atom, R.bool, R.url, R.contentSeparator, R.labelName],
    color: "#219"
  },
  {
    tag: [R.literal, R.inserted],
    color: "#164"
  },
  {
    tag: [R.string, R.deleted],
    color: "#a11"
  },
  {
    tag: [R.regexp, R.escape, /* @__PURE__ */ R.special(R.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ R.definition(R.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ R.local(R.variableName),
    color: "#30a"
  },
  {
    tag: [R.typeName, R.namespace],
    color: "#085"
  },
  {
    tag: R.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ R.special(R.variableName), R.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ R.definition(R.propertyName),
    color: "#00c"
  },
  {
    tag: R.comment,
    color: "#940"
  },
  {
    tag: R.invalid,
    color: "#f00"
  }
]), yIe = /* @__PURE__ */ ge.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), SZ = 1e4, TZ = "()[]{}", yZ = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, {
      afterCursor: !0,
      brackets: TZ,
      maxScanDistance: SZ,
      renderMatch: CIe
    });
  }
}), RIe = /* @__PURE__ */ Be.mark({ class: "cm-matchingBracket" }), AIe = /* @__PURE__ */ Be.mark({ class: "cm-nonmatchingBracket" });
function CIe(r) {
  let e = [], t = r.matched ? RIe : AIe;
  return e.push(t.range(r.start.from, r.start.to)), r.end && e.push(t.range(r.end.from, r.end.to)), e;
}
const _Ie = /* @__PURE__ */ kr.define({
  create() {
    return Be.none;
  },
  update(r, e) {
    if (!e.docChanged && !e.selection)
      return r;
    let t = [], i = e.state.facet(yZ);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let a = qa(e.state, n.head, -1, i) || n.head > 0 && qa(e.state, n.head - 1, 1, i) || i.afterCursor && (qa(e.state, n.head, 1, i) || n.head < e.state.doc.length && qa(e.state, n.head + 1, -1, i));
      a && (t = t.concat(i.renderMatch(a, e.state)));
    }
    return Be.set(t, !0);
  },
  provide: (r) => ge.decorations.from(r)
}), IIe = [
  _Ie,
  yIe
];
function xIe(r = {}) {
  return [yZ.of(r), IIe];
}
const wIe = /* @__PURE__ */ new ht();
function W_(r, e, t) {
  let i = r.prop(e < 0 ? ht.openedBy : ht.closedBy);
  if (i)
    return i;
  if (r.name.length == 1) {
    let n = t.indexOf(r.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [t[n + e]];
  }
  return null;
}
function z_(r) {
  let e = r.type.prop(wIe);
  return e ? e(r.node) : r;
}
function qa(r, e, t, i = {}) {
  let n = i.maxScanDistance || SZ, a = i.brackets || TZ, o = qt(r), s = o.resolveInner(e, t);
  for (let l = s; l; l = l.parent) {
    let u = W_(l.type, t, a);
    if (u && l.from < l.to) {
      let h = z_(l);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return PIe(r, e, t, l, h, u, a);
    }
  }
  return NIe(r, e, t, o, s.type, n, a);
}
function PIe(r, e, t, i, n, a, o) {
  let s = i.parent, l = { from: n.from, to: n.to }, u = 0, h = s == null ? void 0 : s.cursor();
  if (h && (t < 0 ? h.childBefore(i.from) : h.childAfter(i.to)))
    do
      if (t < 0 ? h.to <= i.from : h.from >= i.to) {
        if (u == 0 && a.indexOf(h.type.name) > -1 && h.from < h.to) {
          let c = z_(h);
          return { start: l, end: c ? { from: c.from, to: c.to } : void 0, matched: !0 };
        } else if (W_(h.type, t, o))
          u++;
        else if (W_(h.type, -t, o)) {
          if (u == 0) {
            let c = z_(h);
            return {
              start: l,
              end: c && c.from < c.to ? { from: c.from, to: c.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: l, matched: !1 };
}
function NIe(r, e, t, i, n, a, o) {
  let s = t < 0 ? r.sliceDoc(e - 1, e) : r.sliceDoc(e, e + 1), l = o.indexOf(s);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let u = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = r.doc.iterRange(e, t > 0 ? r.doc.length : 0), c = 0;
  for (let f = 0; !h.next().done && f <= a; ) {
    let d = h.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let g = t > 0 ? 0 : d.length - 1, v = t > 0 ? d.length : -1; g != v; g += t) {
      let O = o.indexOf(d[g]);
      if (!(O < 0 || i.resolveInner(p + g, 1).type != n))
        if (O % 2 == 0 == t > 0)
          c++;
        else {
          if (c == 1)
            return { start: u, end: { from: p + g, to: p + g + 1 }, matched: O >> 1 == l >> 1 };
          c--;
        }
    }
    t > 0 && (f += d.length);
  }
  return h.done ? { start: u, matched: !1 } : null;
}
const LIe = /* @__PURE__ */ Object.create(null), gG = [On.none], vG = [], DIe = /* @__PURE__ */ Object.create(null);
for (let [r, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  DIe[r] = /* @__PURE__ */ MIe(LIe, e);
function _R(r, e) {
  vG.indexOf(r) > -1 || (vG.push(r), console.warn(e));
}
function MIe(r, e) {
  let t = null;
  for (let a of e.split(".")) {
    let o = r[a] || R[a];
    o ? typeof o == "function" ? t ? t = o(t) : _R(a, `Modifier ${a} used at start of tag`) : t ? _R(a, `Tag ${a} used as modifier`) : t = o : _R(a, `Unknown highlighting tag ${a}`);
  }
  if (!t)
    return 0;
  let i = e.replace(/ /g, "_"), n = On.define({
    id: gG.length,
    name: i,
    props: [Rl({ [i]: t })]
  });
  return gG.push(n), n.id;
}
const RZ = (r) => {
  let { state: e } = r, t = e.doc.lineAt(e.selection.main.from), i = Yw(r.state, t.from);
  return i.line ? AZ(r) : i.block ? _Z(r) : !1;
};
function wh(r, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let n = r(e, t);
    return n ? (i(t.update(n)), !0) : !1;
  };
}
const AZ = /* @__PURE__ */ wh(
  Hw,
  0
  /* CommentOption.Toggle */
), kIe = /* @__PURE__ */ wh(
  Hw,
  1
  /* CommentOption.Comment */
), QIe = /* @__PURE__ */ wh(
  Hw,
  2
  /* CommentOption.Uncomment */
), CZ = /* @__PURE__ */ wh(
  nT,
  0
  /* CommentOption.Toggle */
), UIe = /* @__PURE__ */ wh(
  nT,
  1
  /* CommentOption.Comment */
), $Ie = /* @__PURE__ */ wh(
  nT,
  2
  /* CommentOption.Uncomment */
), _Z = /* @__PURE__ */ wh(
  (r, e) => nT(r, e, BIe(e)),
  0
  /* CommentOption.Toggle */
);
function Yw(r, e) {
  let t = r.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const Rd = 50;
function GIe(r, { open: e, close: t }, i, n) {
  let a = r.sliceDoc(i - Rd, i), o = r.sliceDoc(n, n + Rd), s = /\s*$/.exec(a)[0].length, l = /^\s*/.exec(o)[0].length, u = a.length - s;
  if (a.slice(u - e.length, u) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: i - s, margin: s && 1 },
      close: { pos: n + l, margin: l && 1 }
    };
  let h, c;
  n - i <= 2 * Rd ? h = c = r.sliceDoc(i, n) : (h = r.sliceDoc(i, i + Rd), c = r.sliceDoc(n - Rd, n));
  let f = /^\s*/.exec(h)[0].length, d = /\s*$/.exec(c)[0].length, p = c.length - d - t.length;
  return h.slice(f, f + e.length) == e && c.slice(p, p + t.length) == t ? {
    open: {
      pos: i + f + e.length,
      margin: /\s/.test(h.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: n - d - t.length,
      margin: /\s/.test(c.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function BIe(r) {
  let e = [];
  for (let t of r.selection.ranges) {
    let i = r.doc.lineAt(t.from), n = t.to <= i.to ? i : r.doc.lineAt(t.to), a = e.length - 1;
    a >= 0 && e[a].to > i.from ? e[a].to = n.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: n.to });
  }
  return e;
}
function nT(r, e, t = e.selection.ranges) {
  let i = t.map((a) => Yw(e, a.from).block);
  if (!i.every((a) => a))
    return null;
  let n = t.map((a, o) => GIe(e, i[o], a.from, a.to));
  if (r != 2 && !n.every((a) => a))
    return { changes: e.changes(t.map((a, o) => n[o] ? [] : [{ from: a.from, insert: i[o].open + " " }, { from: a.to, insert: " " + i[o].close }])) };
  if (r != 1 && n.some((a) => a)) {
    let a = [];
    for (let o = 0, s; o < n.length; o++)
      if (s = n[o]) {
        let l = i[o], { open: u, close: h } = s;
        a.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: h.pos - h.margin, to: h.pos + l.close.length });
      }
    return { changes: a };
  }
  return null;
}
function Hw(r, e, t = e.selection.ranges) {
  let i = [], n = -1;
  for (let { from: a, to: o } of t) {
    let s = i.length, l = 1e9, u = Yw(e, a).line;
    if (u) {
      for (let h = a; h <= o; ) {
        let c = e.doc.lineAt(h);
        if (c.from > n && (a == o || o > c.from)) {
          n = c.from;
          let f = /^\s*/.exec(c.text)[0].length, d = f == c.length, p = c.text.slice(f, f + u.length) == u ? f : -1;
          f < c.text.length && f < l && (l = f), i.push({ line: c, comment: p, token: u, indent: f, empty: d, single: !1 });
        }
        h = c.to + 1;
      }
      if (l < 1e9)
        for (let h = s; h < i.length; h++)
          i[h].indent < i[h].line.text.length && (i[h].indent = l);
      i.length == s + 1 && (i[s].single = !0);
    }
  }
  if (r != 2 && i.some((a) => a.comment < 0 && (!a.empty || a.single))) {
    let a = [];
    for (let { line: s, token: l, indent: u, empty: h, single: c } of i)
      (c || !h) && a.push({ from: s.from + u, insert: l + " " });
    let o = e.changes(a);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (r != 1 && i.some((a) => a.comment >= 0)) {
    let a = [];
    for (let { line: o, comment: s, token: l } of i)
      if (s >= 0) {
        let u = o.from + s, h = u + l.length;
        o.text[h - o.from] == " " && h++, a.push({ from: u, to: h });
      }
    return { changes: a };
  }
  return null;
}
const Z_ = /* @__PURE__ */ is.define(), IZ = /* @__PURE__ */ is.define(), xZ = /* @__PURE__ */ Re.define(), wZ = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, n) => e(i, n) || t(i, n)
    });
  }
});
function VIe(r) {
  let e = 0;
  return r.iterChangedRanges((t, i) => e = i), e;
}
const aT = /* @__PURE__ */ kr.define({
  create() {
    return ja.empty;
  },
  update(r, e) {
    let t = e.state.facet(wZ), i = e.annotation(Z_);
    if (i) {
      let l = e.docChanged ? z.single(VIe(e.changes)) : void 0, u = Bi.fromTransaction(e, l), h = i.side, c = h == 0 ? r.undone : r.done;
      return u ? c = Rb(c, c.length, t.minDepth, u) : c = kZ(c, e.startState.selection), new ja(h == 0 ? i.rest : c, h == 0 ? c : i.rest);
    }
    let n = e.annotation(IZ);
    if ((n == "full" || n == "before") && (r = r.isolate()), e.annotation(Rr.addToHistory) === !1)
      return e.changes.empty ? r : r.addMapping(e.changes.desc);
    let a = Bi.fromTransaction(e), o = e.annotation(Rr.time), s = e.annotation(Rr.userEvent);
    return a ? r = r.addChanges(a, o, s, t, e) : e.selection && (r = r.addSelection(e.startState.selection, o, s, t.newGroupDelay)), (n == "full" || n == "after") && (r = r.isolate()), r;
  },
  toJSON(r) {
    return { done: r.done.map((e) => e.toJSON()), undone: r.undone.map((e) => e.toJSON()) };
  },
  fromJSON(r) {
    return new ja(r.done.map(Bi.fromJSON), r.undone.map(Bi.fromJSON));
  }
});
function PZ(r = {}) {
  return [
    aT,
    wZ.of(r),
    ge.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? Ww : e.inputType == "historyRedo" ? yb : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
const FIe = aT;
function oT(r, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let n = t.field(aT, !1);
    if (!n)
      return !1;
    let a = n.pop(r, t, e);
    return a ? (i(a), !0) : !1;
  };
}
const Ww = /* @__PURE__ */ oT(0, !1), yb = /* @__PURE__ */ oT(1, !1), NZ = /* @__PURE__ */ oT(0, !0), LZ = /* @__PURE__ */ oT(1, !0);
function DZ(r) {
  return function(e) {
    let t = e.field(aT, !1);
    if (!t)
      return 0;
    let i = r == 0 ? t.done : t.undone;
    return i.length - (i.length && !i[0].changes ? 1 : 0);
  };
}
const XIe = /* @__PURE__ */ DZ(
  0
  /* BranchName.Done */
), YIe = /* @__PURE__ */ DZ(
  1
  /* BranchName.Undone */
);
class Bi {
  constructor(e, t, i, n, a) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = n, this.selectionsAfter = a;
  }
  setSelAfter(e) {
    return new Bi(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(e) {
    return new Bi(e.changes && br.fromJSON(e.changes), [], e.mapped && eo.fromJSON(e.mapped), e.startSelection && z.fromJSON(e.startSelection), e.selectionsAfter.map(z.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = Bn;
    for (let n of e.startState.facet(xZ)) {
      let a = n(e);
      a.length && (i = i.concat(a));
    }
    return !i.length && e.changes.empty ? null : new Bi(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, Bn);
  }
  static selection(e) {
    return new Bi(void 0, Bn, void 0, void 0, e);
  }
}
function Rb(r, e, t, i) {
  let n = e + 1 > t + 20 ? e - t - 1 : 0, a = r.slice(n, e);
  return a.push(i), a;
}
function HIe(r, e) {
  let t = [], i = !1;
  return r.iterChangedRanges((n, a) => t.push(n, a)), e.iterChangedRanges((n, a, o, s) => {
    for (let l = 0; l < t.length; ) {
      let u = t[l++], h = t[l++];
      s >= u && o <= h && (i = !0);
    }
  }), i;
}
function WIe(r, e) {
  return r.ranges.length == e.ranges.length && r.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function MZ(r, e) {
  return r.length ? e.length ? r.concat(e) : r : e;
}
const Bn = [], zIe = 200;
function kZ(r, e) {
  if (r.length) {
    let t = r[r.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - zIe));
    return i.length && i[i.length - 1].eq(e) ? r : (i.push(e), Rb(r, r.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [Bi.selection([e])];
}
function ZIe(r) {
  let e = r[r.length - 1], t = r.slice();
  return t[r.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function IR(r, e) {
  if (!r.length)
    return r;
  let t = r.length, i = Bn;
  for (; t; ) {
    let n = qIe(r[t - 1], e, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let a = r.slice(0, t);
      return a[t - 1] = n, a;
    } else
      e = n.mapped, t--, i = n.selectionsAfter;
  }
  return i.length ? [Bi.selection(i)] : Bn;
}
function qIe(r, e, t) {
  let i = MZ(r.selectionsAfter.length ? r.selectionsAfter.map((s) => s.map(e)) : Bn, t);
  if (!r.changes)
    return Bi.selection(i);
  let n = r.changes.map(e), a = e.mapDesc(r.changes, !0), o = r.mapped ? r.mapped.composeDesc(a) : a;
  return new Bi(n, rt.mapEffects(r.effects, e), o, r.startSelection.map(a), i);
}
const jIe = /^(input\.type|delete)($|\.)/;
class ja {
  constructor(e, t, i = 0, n = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new ja(this.done, this.undone) : this;
  }
  addChanges(e, t, i, n, a) {
    let o = this.done, s = o[o.length - 1];
    return s && s.changes && !s.changes.empty && e.changes && (!i || jIe.test(i)) && (!s.selectionsAfter.length && t - this.prevTime < n.newGroupDelay && n.joinToEvent(a, HIe(s.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? o = Rb(o, o.length - 1, n.minDepth, new Bi(e.changes.compose(s.changes), MZ(e.effects, s.effects), s.mapped, s.startSelection, Bn)) : o = Rb(o, o.length, n.minDepth, e), new ja(o, Bn, t, i);
  }
  addSelection(e, t, i, n) {
    let a = this.done.length ? this.done[this.done.length - 1].selectionsAfter : Bn;
    return a.length > 0 && t - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && WIe(a[a.length - 1], e) ? this : new ja(kZ(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new ja(IR(this.done, e), IR(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let n = e == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let a = n[n.length - 1];
    if (i && a.selectionsAfter.length)
      return t.update({
        selection: a.selectionsAfter[a.selectionsAfter.length - 1],
        annotations: Z_.of({ side: e, rest: ZIe(n) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (a.changes) {
      let o = n.length == 1 ? Bn : n.slice(0, n.length - 1);
      return a.mapped && (o = IR(o, a.mapped)), t.update({
        changes: a.changes,
        selection: a.startSelection,
        effects: a.effects,
        annotations: Z_.of({ side: e, rest: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
ja.empty = /* @__PURE__ */ new ja(Bn, Bn);
const QZ = [
  { key: "Mod-z", run: Ww, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: yb, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: yb, preventDefault: !0 },
  { key: "Mod-u", run: NZ, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: LZ, preventDefault: !0 }
];
function Df(r, e) {
  return z.create(r.ranges.map(e), r.mainIndex);
}
function bo(r, e) {
  return r.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ea({ state: r, dispatch: e }, t) {
  let i = Df(r.selection, t);
  return i.eq(r.selection) ? !1 : (e(bo(r, i)), !0);
}
function hv(r, e) {
  return z.cursor(e ? r.to : r.from);
}
function sT(r, e) {
  return ea(r, (t) => t.empty ? r.moveByChar(t, e) : hv(t, e));
}
function di(r) {
  return r.textDirectionAt(r.state.selection.main.head) == Jt.LTR;
}
const zw = (r) => sT(r, !di(r)), Zw = (r) => sT(r, di(r)), KIe = (r) => sT(r, !0), JIe = (r) => sT(r, !1);
function lT(r, e) {
  return ea(r, (t) => t.empty ? r.moveByGroup(t, e) : hv(t, e));
}
const UZ = (r) => lT(r, !di(r)), $Z = (r) => lT(r, di(r)), exe = (r) => lT(r, !0), txe = (r) => lT(r, !1);
function GZ(r, e, t) {
  let i = r.state.charCategorizer(e.from);
  return r.moveByChar(e, t, (n) => {
    let a = Pt.Space, o = e.from, s = !1, l = !1, u = !1, h = (c) => {
      if (s)
        return !1;
      o += t ? c.length : -c.length;
      let f = i(c), d;
      if (f == Pt.Word && c.charCodeAt(0) < 128 && /[\W_]/.test(c) && (f = -1), a == Pt.Space && (a = f), a != f)
        return !1;
      if (a == Pt.Word)
        if (c.toLowerCase() == c) {
          if (!t && l)
            return !1;
          u = !0;
        } else if (u) {
          if (t)
            return !1;
          s = !0;
        } else {
          if (l && t && i(d = r.state.sliceDoc(o, o + 1)) == Pt.Word && d.toLowerCase() == d)
            return !1;
          l = !0;
        }
      return !0;
    };
    return h(n), h;
  });
}
function BZ(r, e) {
  return ea(r, (t) => t.empty ? GZ(r, t, e) : hv(t, e));
}
const rxe = (r) => BZ(r, !0), ixe = (r) => BZ(r, !1);
function nxe(r, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(r.sliceDoc(e.from, e.to))) || e.firstChild;
}
function uT(r, e, t) {
  let i = qt(r).resolveInner(e.head), n = t ? ht.closedBy : ht.openedBy;
  for (let l = e.head; ; ) {
    let u = t ? i.childAfter(l) : i.childBefore(l);
    if (!u)
      break;
    nxe(r, u, n) ? i = u : l = t ? u.to : u.from;
  }
  let a = i.type.prop(n), o, s;
  return a && (o = t ? qa(r, i.from, 1) : qa(r, i.to, -1)) && o.matched ? s = t ? o.end.to : o.end.from : s = t ? i.to : i.from, z.cursor(s, t ? -1 : 1);
}
const VZ = (r) => ea(r, (e) => uT(r.state, e, !di(r))), FZ = (r) => ea(r, (e) => uT(r.state, e, di(r)));
function XZ(r, e) {
  return ea(r, (t) => {
    if (!t.empty)
      return hv(t, e);
    let i = r.moveVertically(t, e);
    return i.head != t.head ? i : r.moveToLineBoundary(t, e);
  });
}
const qw = (r) => XZ(r, !1), jw = (r) => XZ(r, !0);
function YZ(r) {
  let e = r.scrollDOM.clientHeight < r.scrollDOM.scrollHeight - 2, t = 0, i = 0, n;
  if (e) {
    for (let a of r.state.facet(ge.scrollMargins)) {
      let o = a(r);
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)), o != null && o.bottom && (i = Math.max(o == null ? void 0 : o.bottom, i));
    }
    n = r.scrollDOM.clientHeight - t - i;
  } else
    n = (r.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(r.defaultLineHeight, n - 5)
  };
}
function HZ(r, e) {
  let t = YZ(r), { state: i } = r, n = Df(i.selection, (o) => o.empty ? r.moveVertically(o, e, t.height) : hv(o, e));
  if (n.eq(i.selection))
    return !1;
  let a;
  if (t.selfScroll) {
    let o = r.coordsAtPos(i.selection.main.head), s = r.scrollDOM.getBoundingClientRect(), l = s.top + t.marginTop, u = s.bottom - t.marginBottom;
    o && o.top > l && o.bottom < u && (a = ge.scrollIntoView(n.main.head, { y: "start", yMargin: o.top - l }));
  }
  return r.dispatch(bo(i, n), { effects: a }), !0;
}
const q_ = (r) => HZ(r, !1), Ab = (r) => HZ(r, !0);
function _l(r, e, t) {
  let i = r.lineBlockAt(e.head), n = r.moveToLineBoundary(e, t);
  if (n.head == e.head && n.head != (t ? i.to : i.from) && (n = r.moveToLineBoundary(e, t, !1)), !t && n.head == i.from && i.length) {
    let a = /^\s*/.exec(r.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    a && e.head != i.from + a && (n = z.cursor(i.from + a));
  }
  return n;
}
const WZ = (r) => ea(r, (e) => _l(r, e, !0)), zZ = (r) => ea(r, (e) => _l(r, e, !1)), ZZ = (r) => ea(r, (e) => _l(r, e, !di(r))), qZ = (r) => ea(r, (e) => _l(r, e, di(r))), jZ = (r) => ea(r, (e) => z.cursor(r.lineBlockAt(e.head).from, 1)), KZ = (r) => ea(r, (e) => z.cursor(r.lineBlockAt(e.head).to, -1));
function JZ(r, e, t) {
  let i = !1, n = Df(r.selection, (a) => {
    let o = qa(r, a.head, -1) || qa(r, a.head, 1) || a.head > 0 && qa(r, a.head - 1, 1) || a.head < r.doc.length && qa(r, a.head + 1, -1);
    if (!o || !o.end)
      return a;
    i = !0;
    let s = o.start.from == a.head ? o.end.to : o.end.from;
    return t ? z.range(a.anchor, s) : z.cursor(s);
  });
  return i ? (e(bo(r, n)), !0) : !1;
}
const e6 = ({ state: r, dispatch: e }) => JZ(r, e, !1), axe = ({ state: r, dispatch: e }) => JZ(r, e, !0);
function bn(r, e) {
  let t = Df(r.state.selection, (i) => {
    let n = e(i);
    return z.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return t.eq(r.state.selection) ? !1 : (r.dispatch(bo(r.state, t)), !0);
}
function hT(r, e) {
  return bn(r, (t) => r.moveByChar(t, e));
}
const Kw = (r) => hT(r, !di(r)), Jw = (r) => hT(r, di(r)), oxe = (r) => hT(r, !0), sxe = (r) => hT(r, !1);
function cT(r, e) {
  return bn(r, (t) => r.moveByGroup(t, e));
}
const t6 = (r) => cT(r, !di(r)), r6 = (r) => cT(r, di(r)), lxe = (r) => cT(r, !0), uxe = (r) => cT(r, !1);
function i6(r, e) {
  return bn(r, (t) => GZ(r, t, e));
}
const hxe = (r) => i6(r, !0), cxe = (r) => i6(r, !1), n6 = (r) => bn(r, (e) => uT(r.state, e, !di(r))), a6 = (r) => bn(r, (e) => uT(r.state, e, di(r)));
function o6(r, e) {
  return bn(r, (t) => r.moveVertically(t, e));
}
const eP = (r) => o6(r, !1), tP = (r) => o6(r, !0);
function s6(r, e) {
  return bn(r, (t) => r.moveVertically(t, e, YZ(r).height));
}
const j_ = (r) => s6(r, !1), K_ = (r) => s6(r, !0), l6 = (r) => bn(r, (e) => _l(r, e, !0)), u6 = (r) => bn(r, (e) => _l(r, e, !1)), h6 = (r) => bn(r, (e) => _l(r, e, !di(r))), c6 = (r) => bn(r, (e) => _l(r, e, di(r))), f6 = (r) => bn(r, (e) => z.cursor(r.lineBlockAt(e.head).from)), d6 = (r) => bn(r, (e) => z.cursor(r.lineBlockAt(e.head).to)), J_ = ({ state: r, dispatch: e }) => (e(bo(r, { anchor: 0 })), !0), e1 = ({ state: r, dispatch: e }) => (e(bo(r, { anchor: r.doc.length })), !0), t1 = ({ state: r, dispatch: e }) => (e(bo(r, { anchor: r.selection.main.anchor, head: 0 })), !0), r1 = ({ state: r, dispatch: e }) => (e(bo(r, { anchor: r.selection.main.anchor, head: r.doc.length })), !0), p6 = ({ state: r, dispatch: e }) => (e(r.update({ selection: { anchor: 0, head: r.doc.length }, userEvent: "select" })), !0), g6 = ({ state: r, dispatch: e }) => {
  let t = dT(r).map(({ from: i, to: n }) => z.range(i, Math.min(n + 1, r.doc.length)));
  return e(r.update({ selection: z.create(t), userEvent: "select" })), !0;
}, v6 = ({ state: r, dispatch: e }) => {
  let t = Df(r.selection, (i) => {
    var n;
    let a = qt(r).resolveInner(i.head, 1);
    for (; !(a.from < i.from && a.to >= i.to || a.to > i.to && a.from <= i.from || !(!((n = a.parent) === null || n === void 0) && n.parent)); )
      a = a.parent;
    return z.range(a.to, a.from);
  });
  return e(bo(r, t)), !0;
}, O6 = ({ state: r, dispatch: e }) => {
  let t = r.selection, i = null;
  return t.ranges.length > 1 ? i = z.create([t.main]) : t.main.empty || (i = z.create([z.cursor(t.main.head)])), i ? (e(bo(r, i)), !0) : !1;
};
function fT(r, e) {
  if (r.state.readOnly)
    return !1;
  let t = "delete.selection", { state: i } = r, n = i.changeByRange((a) => {
    let { from: o, to: s } = a;
    if (o == s) {
      let l = e(o);
      l < o ? (t = "delete.backward", l = qO(r, l, !1)) : l > o && (t = "delete.forward", l = qO(r, l, !0)), o = Math.min(o, l), s = Math.max(s, l);
    } else
      o = qO(r, o, !1), s = qO(r, s, !0);
    return o == s ? { range: a } : { changes: { from: o, to: s }, range: z.cursor(o) };
  });
  return n.changes.empty ? !1 : (r.dispatch(i.update(n, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? ge.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function qO(r, e, t) {
  if (r instanceof ge)
    for (let i of r.state.facet(ge.atomicRanges).map((n) => n(r)))
      i.between(e, e, (n, a) => {
        n < e && a > e && (e = t ? a : n);
      });
  return e;
}
const m6 = (r, e) => fT(r, (t) => {
  let { state: i } = r, n = i.doc.lineAt(t), a, o;
  if (!e && t > n.from && t < n.from + 200 && !/[^ \t]/.test(a = n.text.slice(0, t - n.from))) {
    if (a[a.length - 1] == "	")
      return t - 1;
    let s = iv(a, i.tabSize), l = s % bb(i) || bb(i);
    for (let u = 0; u < l && a[a.length - 1 - u] == " "; u++)
      t--;
    o = t;
  } else
    o = li(n.text, t - n.from, e, e) + n.from, o == t && n.number != (e ? i.doc.lines : 1) && (o += e ? 1 : -1);
  return o;
}), Cb = (r) => m6(r, !1), rP = (r) => m6(r, !0), E6 = (r, e) => fT(r, (t) => {
  let i = t, { state: n } = r, a = n.doc.lineAt(i), o = n.charCategorizer(i);
  for (let s = null; ; ) {
    if (i == (e ? a.to : a.from)) {
      i == t && a.number != (e ? n.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let l = li(a.text, i - a.from, e) + a.from, u = a.text.slice(Math.min(i, l) - a.from, Math.max(i, l) - a.from), h = o(u);
    if (s != null && h != s)
      break;
    (u != " " || i != t) && (s = h), i = l;
  }
  return i;
}), iP = (r) => E6(r, !1), b6 = (r) => E6(r, !0), nP = (r) => fT(r, (e) => {
  let t = r.lineBlockAt(e).to;
  return e < t ? t : Math.min(r.state.doc.length, e + 1);
}), S6 = (r) => fT(r, (e) => {
  let t = r.lineBlockAt(e).from;
  return e > t ? t : Math.max(0, e - 1);
}), fxe = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = [];
  for (let i = 0, n = "", a = r.doc.iter(); ; ) {
    if (a.next(), a.lineBreak || a.done) {
      let o = n.search(/\s+$/);
      if (o > -1 && t.push({ from: i - (n.length - o), to: i }), a.done)
        break;
      n = "";
    } else
      n = a.value;
    i += a.value.length;
  }
  return t.length ? (e(r.update({ changes: t, userEvent: "delete" })), !0) : !1;
}, T6 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: Rt.of(["", ""]) },
    range: z.cursor(i.from)
  }));
  return e(r.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, y6 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == r.doc.length)
      return { range: i };
    let n = i.from, a = r.doc.lineAt(n), o = n == a.from ? n - 1 : li(a.text, n - a.from, !1) + a.from, s = n == a.to ? n + 1 : li(a.text, n - a.from, !0) + a.from;
    return {
      changes: { from: o, to: s, insert: r.doc.slice(n, s).append(r.doc.slice(o, n)) },
      range: z.cursor(s)
    };
  });
  return t.changes.empty ? !1 : (e(r.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function dT(r) {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let n = r.doc.lineAt(i.from), a = r.doc.lineAt(i.to);
    if (!i.empty && i.to == a.from && (a = r.doc.lineAt(i.to - 1)), t >= n.number) {
      let o = e[e.length - 1];
      o.to = a.to, o.ranges.push(i);
    } else
      e.push({ from: n.from, to: a.to, ranges: [i] });
    t = a.number + 1;
  }
  return e;
}
function R6(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [], n = [];
  for (let a of dT(r)) {
    if (t ? a.to == r.doc.length : a.from == 0)
      continue;
    let o = r.doc.lineAt(t ? a.to + 1 : a.from - 1), s = o.length + 1;
    if (t) {
      i.push({ from: a.to, to: o.to }, { from: a.from, insert: o.text + r.lineBreak });
      for (let l of a.ranges)
        n.push(z.range(Math.min(r.doc.length, l.anchor + s), Math.min(r.doc.length, l.head + s)));
    } else {
      i.push({ from: o.from, to: a.from }, { from: a.to, insert: r.lineBreak + o.text });
      for (let l of a.ranges)
        n.push(z.range(l.anchor - s, l.head - s));
    }
  }
  return i.length ? (e(r.update({
    changes: i,
    scrollIntoView: !0,
    selection: z.create(n, r.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const A6 = ({ state: r, dispatch: e }) => R6(r, e, !1), C6 = ({ state: r, dispatch: e }) => R6(r, e, !0);
function _6(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [];
  for (let n of dT(r))
    t ? i.push({ from: n.from, insert: r.doc.slice(n.from, n.to) + r.lineBreak }) : i.push({ from: n.to, insert: r.lineBreak + r.doc.slice(n.from, n.to) });
  return e(r.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const I6 = ({ state: r, dispatch: e }) => _6(r, e, !1), x6 = ({ state: r, dispatch: e }) => _6(r, e, !0), w6 = (r) => {
  if (r.state.readOnly)
    return !1;
  let { state: e } = r, t = e.changes(dT(e).map(({ from: n, to: a }) => (n > 0 ? n-- : a < e.doc.length && a++, { from: n, to: a }))), i = Df(e.selection, (n) => r.moveVertically(n, !0)).map(t);
  return r.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
}, dxe = ({ state: r, dispatch: e }) => (e(r.update(r.replaceSelection(r.lineBreak), { scrollIntoView: !0, userEvent: "input" })), !0);
function pxe(r, e) {
  if (/\(\)|\[\]|\{\}/.test(r.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = qt(r).resolveInner(e), i = t.childBefore(e), n = t.childAfter(e), a;
  return i && n && i.to <= e && n.from >= e && (a = i.type.prop(ht.closedBy)) && a.indexOf(n.name) > -1 && r.doc.lineAt(i.to).from == r.doc.lineAt(n.from).from ? { from: i.to, to: n.from } : null;
}
const P6 = /* @__PURE__ */ L6(!1), N6 = /* @__PURE__ */ L6(!0);
function L6(r) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((n) => {
      let { from: a, to: o } = n, s = e.doc.lineAt(a), l = !r && a == o && pxe(e, a);
      r && (a = o = (o <= s.to ? s : e.doc.lineAt(o)).to);
      let u = new rT(e, { simulateBreak: a, simulateDoubleBreak: !!l }), h = Vw(u, a);
      for (h == null && (h = /^\s*/.exec(e.doc.lineAt(a).text)[0].length); o < s.to && /\s/.test(s.text[o - s.from]); )
        o++;
      l ? { from: a, to: o } = l : a > s.from && a < s.from + 100 && !/\S/.test(s.text.slice(0, a)) && (a = s.from);
      let c = ["", Tg(e, h)];
      return l && c.push(Tg(e, u.lineIndent(s.from, -1))), {
        changes: { from: a, to: o, insert: Rt.of(c) },
        range: z.cursor(a + 1 + c[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function aP(r, e) {
  let t = -1;
  return r.changeByRange((i) => {
    let n = [];
    for (let o = i.from; o <= i.to; ) {
      let s = r.doc.lineAt(o);
      s.number > t && (i.empty || i.to > s.from) && (e(s, n, i), t = s.number), o = s.to + 1;
    }
    let a = r.changes(n);
    return {
      changes: n,
      range: z.range(a.mapPos(i.anchor, 1), a.mapPos(i.head, 1))
    };
  });
}
const D6 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new rT(r, { overrideIndentation: (a) => {
    let o = t[a];
    return o ?? -1;
  } }), n = aP(r, (a, o, s) => {
    let l = Vw(i, a.from);
    if (l == null)
      return;
    /\S/.test(a.text) || (l = 0);
    let u = /^\s*/.exec(a.text)[0], h = Tg(r, l);
    (u != h || s.from < a.from + u.length) && (t[a.from] = l, o.push({ from: a.from, to: a.from + u.length, insert: h }));
  });
  return n.changes.empty || e(r.update(n, { userEvent: "indent" })), !0;
}, pT = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(aP(r, (t, i) => {
  i.push({ from: t.from, insert: r.facet(tT) });
}), { userEvent: "input.indent" })), !0), oP = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(aP(r, (t, i) => {
  let n = /^\s*/.exec(t.text)[0];
  if (!n)
    return;
  let a = iv(n, r.tabSize), o = 0, s = Tg(r, Math.max(0, a - bb(r)));
  for (; o < n.length && o < s.length && n.charCodeAt(o) == s.charCodeAt(o); )
    o++;
  i.push({ from: t.from + o, to: t.from + n.length, insert: s.slice(o) });
}), { userEvent: "delete.dedent" })), !0), gxe = ({ state: r, dispatch: e }) => r.selection.ranges.some((t) => !t.empty) ? pT({ state: r, dispatch: e }) : (e(r.update(r.replaceSelection("	"), { scrollIntoView: !0, userEvent: "input" })), !0), M6 = [
  { key: "Ctrl-b", run: zw, shift: Kw, preventDefault: !0 },
  { key: "Ctrl-f", run: Zw, shift: Jw },
  { key: "Ctrl-p", run: qw, shift: eP },
  { key: "Ctrl-n", run: jw, shift: tP },
  { key: "Ctrl-a", run: jZ, shift: f6 },
  { key: "Ctrl-e", run: KZ, shift: d6 },
  { key: "Ctrl-d", run: rP },
  { key: "Ctrl-h", run: Cb },
  { key: "Ctrl-k", run: nP },
  { key: "Ctrl-Alt-h", run: iP },
  { key: "Ctrl-o", run: T6 },
  { key: "Ctrl-t", run: y6 },
  { key: "Ctrl-v", run: Ab }
], k6 = /* @__PURE__ */ [
  { key: "ArrowLeft", run: zw, shift: Kw, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: UZ, shift: t6, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: ZZ, shift: h6, preventDefault: !0 },
  { key: "ArrowRight", run: Zw, shift: Jw, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: $Z, shift: r6, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: qZ, shift: c6, preventDefault: !0 },
  { key: "ArrowUp", run: qw, shift: eP, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: J_, shift: t1 },
  { mac: "Ctrl-ArrowUp", run: q_, shift: j_ },
  { key: "ArrowDown", run: jw, shift: tP, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: e1, shift: r1 },
  { mac: "Ctrl-ArrowDown", run: Ab, shift: K_ },
  { key: "PageUp", run: q_, shift: j_ },
  { key: "PageDown", run: Ab, shift: K_ },
  { key: "Home", run: zZ, shift: u6, preventDefault: !0 },
  { key: "Mod-Home", run: J_, shift: t1 },
  { key: "End", run: WZ, shift: l6, preventDefault: !0 },
  { key: "Mod-End", run: e1, shift: r1 },
  { key: "Enter", run: P6 },
  { key: "Mod-a", run: p6 },
  { key: "Backspace", run: Cb, shift: Cb },
  { key: "Delete", run: rP },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: iP },
  { key: "Mod-Delete", mac: "Alt-Delete", run: b6 },
  { mac: "Mod-Backspace", run: S6 },
  { mac: "Mod-Delete", run: nP }
].concat(/* @__PURE__ */ M6.map((r) => ({ mac: r.key, run: r.run, shift: r.shift }))), Q6 = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: VZ, shift: n6 },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: FZ, shift: a6 },
  { key: "Alt-ArrowUp", run: A6 },
  { key: "Shift-Alt-ArrowUp", run: I6 },
  { key: "Alt-ArrowDown", run: C6 },
  { key: "Shift-Alt-ArrowDown", run: x6 },
  { key: "Escape", run: O6 },
  { key: "Mod-Enter", run: N6 },
  { key: "Alt-l", mac: "Ctrl-l", run: g6 },
  { key: "Mod-i", run: v6, preventDefault: !0 },
  { key: "Mod-[", run: oP },
  { key: "Mod-]", run: pT },
  { key: "Mod-Alt-\\", run: D6 },
  { key: "Shift-Mod-k", run: w6 },
  { key: "Shift-Mod-\\", run: e6 },
  { key: "Mod-/", run: RZ },
  { key: "Alt-A", run: CZ }
].concat(k6), vxe = { key: "Tab", run: pT, shift: oP }, OG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  blockComment: UIe,
  blockUncomment: $Ie,
  copyLineDown: x6,
  copyLineUp: I6,
  cursorCharBackward: JIe,
  cursorCharForward: KIe,
  cursorCharLeft: zw,
  cursorCharRight: Zw,
  cursorDocEnd: e1,
  cursorDocStart: J_,
  cursorGroupBackward: txe,
  cursorGroupForward: exe,
  cursorGroupLeft: UZ,
  cursorGroupRight: $Z,
  cursorLineBoundaryBackward: zZ,
  cursorLineBoundaryForward: WZ,
  cursorLineBoundaryLeft: ZZ,
  cursorLineBoundaryRight: qZ,
  cursorLineDown: jw,
  cursorLineEnd: KZ,
  cursorLineStart: jZ,
  cursorLineUp: qw,
  cursorMatchingBracket: e6,
  cursorPageDown: Ab,
  cursorPageUp: q_,
  cursorSubwordBackward: ixe,
  cursorSubwordForward: rxe,
  cursorSyntaxLeft: VZ,
  cursorSyntaxRight: FZ,
  defaultKeymap: Q6,
  deleteCharBackward: Cb,
  deleteCharForward: rP,
  deleteGroupBackward: iP,
  deleteGroupForward: b6,
  deleteLine: w6,
  deleteToLineEnd: nP,
  deleteToLineStart: S6,
  deleteTrailingWhitespace: fxe,
  emacsStyleKeymap: M6,
  history: PZ,
  historyField: FIe,
  historyKeymap: QZ,
  indentLess: oP,
  indentMore: pT,
  indentSelection: D6,
  indentWithTab: vxe,
  insertBlankLine: N6,
  insertNewline: dxe,
  insertNewlineAndIndent: P6,
  insertTab: gxe,
  invertedEffects: xZ,
  isolateHistory: IZ,
  lineComment: kIe,
  lineUncomment: QIe,
  moveLineDown: C6,
  moveLineUp: A6,
  redo: yb,
  redoDepth: YIe,
  redoSelection: LZ,
  selectAll: p6,
  selectCharBackward: sxe,
  selectCharForward: oxe,
  selectCharLeft: Kw,
  selectCharRight: Jw,
  selectDocEnd: r1,
  selectDocStart: t1,
  selectGroupBackward: uxe,
  selectGroupForward: lxe,
  selectGroupLeft: t6,
  selectGroupRight: r6,
  selectLine: g6,
  selectLineBoundaryBackward: u6,
  selectLineBoundaryForward: l6,
  selectLineBoundaryLeft: h6,
  selectLineBoundaryRight: c6,
  selectLineDown: tP,
  selectLineEnd: d6,
  selectLineStart: f6,
  selectLineUp: eP,
  selectMatchingBracket: axe,
  selectPageDown: K_,
  selectPageUp: j_,
  selectParentSyntax: v6,
  selectSubwordBackward: cxe,
  selectSubwordForward: hxe,
  selectSyntaxLeft: n6,
  selectSyntaxRight: a6,
  simplifySelection: O6,
  splitLine: T6,
  standardKeymap: k6,
  toggleBlockComment: CZ,
  toggleBlockCommentByLine: _Z,
  toggleComment: RZ,
  toggleLineComment: AZ,
  transposeChars: y6,
  undo: Ww,
  undoDepth: XIe,
  undoSelection: NZ
}, Symbol.toStringTag, { value: "Module" }));
function Gt() {
  var r = arguments[0];
  typeof r == "string" && (r = document.createElement(r));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var n = t[i];
        typeof n == "string" ? r.setAttribute(i, n) : n != null && (r[i] = n);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    U6(r, arguments[e]);
  return r;
}
function U6(r, e) {
  if (typeof e == "string")
    r.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      r.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        U6(r, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const mG = typeof String.prototype.normalize == "function" ? (r) => r.normalize("NFKD") : (r) => r;
class hf {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, n = e.length, a, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, n), this.bufferStart = i, this.normalize = a ? (s) => a(mG(s)) : mG, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Fr(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = Cw(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += kn(e);
      let n = this.normalize(t);
      for (let a = 0, o = i; ; a++) {
        let s = n.charCodeAt(a), l = this.match(s, o);
        if (a == n.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        o == i && a < t.length && t.charCodeAt(a) == s && o++;
      }
    }
  }
  match(e, t) {
    let i = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let a = this.matches[n], o = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? i = { from: this.matches[n + 1], to: t + 1 } : (this.matches[n]++, o = !0)), o || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: t + 1 } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferPos) && (i = null), i;
  }
}
typeof Symbol < "u" && (hf.prototype[Symbol.iterator] = function() {
  return this;
});
const $6 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, sP = "gm" + (/x/.unicode == null ? "" : "u");
class G6 {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, n = 0, a = e.length) {
    if (this.text = e, this.to = a, this.curLine = "", this.done = !1, this.value = $6, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new B6(e, t, i, n, a);
    this.re = new RegExp(t, sP + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let o = e.lineAt(n);
    this.curLineStart = o.from, this.matchPos = _b(e, n), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, n = i + t[0].length;
        if (this.matchPos = _b(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const xR = /* @__PURE__ */ new WeakMap();
class $c {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let n = xR.get(e);
    if (!n || n.from >= i || n.to <= t) {
      let s = new $c(t, e.sliceString(t, i));
      return xR.set(e, s), s;
    }
    if (n.from == t && n.to == i)
      return n;
    let { text: a, from: o } = n;
    return o > t && (a = e.sliceString(t, o) + a, o = t), n.to < i && (a += e.sliceString(n.to, i)), xR.set(e, new $c(o, a)), new $c(t, a.slice(t - o, i - o));
  }
}
class B6 {
  constructor(e, t, i, n, a) {
    this.text = e, this.to = a, this.done = !1, this.value = $6, this.matchPos = _b(e, n), this.re = new RegExp(t, sP + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = $c.get(e, n, this.chunkEnd(
      n + 5e3
      /* Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, n = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this.matchPos = _b(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = $c.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (G6.prototype[Symbol.iterator] = B6.prototype[Symbol.iterator] = function() {
  return this;
});
function Oxe(r) {
  try {
    return new RegExp(r, sP), !0;
  } catch {
    return !1;
  }
}
function _b(r, e) {
  if (e >= r.length)
    return e;
  let t = r.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function i1(r) {
  let e = Gt("input", { class: "cm-textfield", name: "line" }), t = Gt("form", {
    class: "cm-gotoLine",
    onkeydown: (n) => {
      n.keyCode == 27 ? (n.preventDefault(), r.dispatch({ effects: Ib.of(!1) }), r.focus()) : n.keyCode == 13 && (n.preventDefault(), i());
    },
    onsubmit: (n) => {
      n.preventDefault(), i();
    }
  }, Gt("label", r.state.phrase("Go to line"), ": ", e), " ", Gt("button", { class: "cm-button", type: "submit" }, r.state.phrase("go")));
  function i() {
    let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!n)
      return;
    let { state: a } = r, o = a.doc.lineAt(a.selection.main.head), [, s, l, u, h] = n, c = u ? +u.slice(1) : 0, f = l ? +l : o.number;
    if (l && h) {
      let g = f / 100;
      s && (g = g * (s == "-" ? -1 : 1) + o.number / a.doc.lines), f = Math.round(a.doc.lines * g);
    } else
      l && s && (f = f * (s == "-" ? -1 : 1) + o.number);
    let d = a.doc.line(Math.max(1, Math.min(a.doc.lines, f))), p = z.cursor(d.from + Math.max(0, Math.min(c, d.length)));
    r.dispatch({
      effects: [Ib.of(!1), ge.scrollIntoView(p.from, { y: "center" })],
      selection: p
    }), r.focus();
  }
  return { dom: t };
}
const Ib = /* @__PURE__ */ rt.define(), EG = /* @__PURE__ */ kr.define({
  create() {
    return !0;
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(Ib) && (r = t.value);
    return r;
  },
  provide: (r) => bg.from(r, (e) => e ? i1 : null)
}), mxe = (r) => {
  let e = Eg(r, i1);
  if (!e) {
    let t = [Ib.of(!0)];
    r.state.field(EG, !1) == null && t.push(rt.appendConfig.of([EG, Exe])), r.dispatch({ effects: t }), e = Eg(r, i1);
  }
  return e && e.dom.querySelector("input").focus(), !0;
}, Exe = /* @__PURE__ */ ge.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), bxe = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, V6 = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, bxe, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Sxe(r) {
  let e = [Cxe, Axe];
  return r && e.push(V6.of(r)), e;
}
const Txe = /* @__PURE__ */ Be.mark({ class: "cm-selectionMatch" }), yxe = /* @__PURE__ */ Be.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function bG(r, e, t, i) {
  return (t == 0 || r(e.sliceDoc(t - 1, t)) != Pt.Word) && (i == e.doc.length || r(e.sliceDoc(i, i + 1)) != Pt.Word);
}
function Rxe(r, e, t, i) {
  return r(e.sliceDoc(t, t + 1)) == Pt.Word && r(e.sliceDoc(i - 1, i)) == Pt.Word;
}
const Axe = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.selectionSet || r.docChanged || r.viewportChanged) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = r.state.facet(V6), { state: t } = r, i = t.selection;
    if (i.ranges.length > 1)
      return Be.none;
    let n = i.main, a, o = null;
    if (n.empty) {
      if (!e.highlightWordAroundCursor)
        return Be.none;
      let l = t.wordAt(n.head);
      if (!l)
        return Be.none;
      o = t.charCategorizer(n.head), a = t.sliceDoc(l.from, l.to);
    } else {
      let l = n.to - n.from;
      if (l < e.minSelectionLength || l > 200)
        return Be.none;
      if (e.wholeWords) {
        if (a = t.sliceDoc(n.from, n.to), o = t.charCategorizer(n.head), !(bG(o, t, n.from, n.to) && Rxe(o, t, n.from, n.to)))
          return Be.none;
      } else if (a = t.sliceDoc(n.from, n.to).trim(), !a)
        return Be.none;
    }
    let s = [];
    for (let l of r.visibleRanges) {
      let u = new hf(t.doc, a, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: h, to: c } = u.value;
        if ((!o || bG(o, t, h, c)) && (n.empty && h <= n.from && c >= n.to ? s.push(yxe.range(h, c)) : (h >= n.to || c <= n.from) && s.push(Txe.range(h, c)), s.length > e.maxMatches))
          return Be.none;
      }
    }
    return Be.set(s);
  }
}, {
  decorations: (r) => r.decorations
}), Cxe = /* @__PURE__ */ ge.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), _xe = ({ state: r, dispatch: e }) => {
  let { selection: t } = r, i = z.create(t.ranges.map((n) => r.wordAt(n.head) || z.cursor(n.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(r.update({ selection: i })), !0);
};
function Ixe(r, e) {
  let { main: t, ranges: i } = r.selection, n = r.wordAt(t.head), a = n && n.from == t.from && n.to == t.to;
  for (let o = !1, s = new hf(r.doc, e, i[i.length - 1].to); ; )
    if (s.next(), s.done) {
      if (o)
        return null;
      s = new hf(r.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((l) => l.from == s.value.from))
        continue;
      if (a) {
        let l = r.wordAt(s.value.from);
        if (!l || l.from != s.value.from || l.to != s.value.to)
          continue;
      }
      return s.value;
    }
}
const xxe = ({ state: r, dispatch: e }) => {
  let { ranges: t } = r.selection;
  if (t.some((a) => a.from === a.to))
    return _xe({ state: r, dispatch: e });
  let i = r.sliceDoc(t[0].from, t[0].to);
  if (r.selection.ranges.some((a) => r.sliceDoc(a.from, a.to) != i))
    return !1;
  let n = Ixe(r, i);
  return n ? (e(r.update({
    selection: r.selection.addRange(z.range(n.from, n.to), !1),
    effects: ge.scrollIntoView(n.to)
  })), !0) : !1;
}, Mf = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Bxe(e),
      scrollToMatch: (e) => ge.scrollIntoView(e)
    });
  }
});
class F6 {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Oxe(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Lxe(this) : new Pxe(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, i) {
    let n = e.doc ? e : St.create({ doc: e });
    return i == null && (i = n.doc.length), this.regexp ? fc(this, n, t, i) : cc(this, n, t, i);
  }
}
class X6 {
  constructor(e) {
    this.spec = e;
  }
}
function cc(r, e, t, i) {
  return new hf(e.doc, r.unquoted, t, i, r.caseSensitive ? void 0 : (n) => n.toLowerCase(), r.wholeWord ? wxe(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function wxe(r, e) {
  return (t, i, n, a) => ((a > t || a + n.length < i) && (a = Math.max(0, t - 2), n = r.sliceString(a, Math.min(r.length, i + 2))), (e(xb(n, t - a)) != Pt.Word || e(wb(n, t - a)) != Pt.Word) && (e(wb(n, i - a)) != Pt.Word || e(xb(n, i - a)) != Pt.Word));
}
class Pxe extends X6 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let n = cc(this.spec, e, i, e.doc.length).nextOverlapping();
    return n.done && (n = cc(this.spec, e, 0, t).nextOverlapping()), n.done ? null : n.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let n = i; ; ) {
      let a = Math.max(t, n - 1e4 - this.spec.unquoted.length), o = cc(this.spec, e, a, n), s = null;
      for (; !o.nextOverlapping().done; )
        s = o.value;
      if (s)
        return s;
      if (a == t)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = cc(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let a = cc(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !a.next().done; )
      n(a.value.from, a.value.to);
  }
}
function fc(r, e, t, i) {
  return new G6(e.doc, r.search, {
    ignoreCase: !r.caseSensitive,
    test: r.wholeWord ? Nxe(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function xb(r, e) {
  return r.slice(li(r, e, !1), e);
}
function wb(r, e) {
  return r.slice(e, li(r, e));
}
function Nxe(r) {
  return (e, t, i) => !i[0].length || (r(xb(i.input, i.index)) != Pt.Word || r(wb(i.input, i.index)) != Pt.Word) && (r(wb(i.input, i.index + i[0].length)) != Pt.Word || r(xb(i.input, i.index + i[0].length)) != Pt.Word);
}
class Lxe extends X6 {
  nextMatch(e, t, i) {
    let n = fc(this.spec, e, i, e.doc.length).next();
    return n.done && (n = fc(this.spec, e, 0, t).next()), n.done ? null : n.value;
  }
  prevMatchInRange(e, t, i) {
    for (let n = 1; ; n++) {
      let a = Math.max(
        t,
        i - n * 1e4
        /* ChunkSize */
      ), o = fc(this.spec, e, a, i), s = null;
      for (; !o.next().done; )
        s = o.value;
      if (s && (a == t || s.from > a + 10))
        return s;
      if (a == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t));
  }
  matchAll(e, t) {
    let i = fc(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let a = fc(this.spec, e, Math.max(
      0,
      t - 250
      /* HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !a.next().done; )
      n(a.value.from, a.value.to);
  }
}
const yg = /* @__PURE__ */ rt.define(), lP = /* @__PURE__ */ rt.define(), Hs = /* @__PURE__ */ kr.define({
  create(r) {
    return new wR(n1(r).create(), null);
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(yg) ? r = new wR(t.value.create(), r.panel) : t.is(lP) && (r = new wR(r.query, t.value ? uP : null));
    return r;
  },
  provide: (r) => bg.from(r, (e) => e.panel)
});
class wR {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const Dxe = /* @__PURE__ */ Be.mark({ class: "cm-searchMatch" }), Mxe = /* @__PURE__ */ Be.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), kxe = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.view = r, this.decorations = this.highlight(r.state.field(Hs));
  }
  update(r) {
    let e = r.state.field(Hs);
    (e != r.startState.field(Hs) || r.docChanged || r.selectionSet || r.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: r, panel: e }) {
    if (!e || !r.spec.valid)
      return Be.none;
    let { view: t } = this, i = new fl();
    for (let n = 0, a = t.visibleRanges, o = a.length; n < o; n++) {
      let { from: s, to: l } = a[n];
      for (; n < o - 1 && l > a[n + 1].from - 2 * 250; )
        l = a[++n].to;
      r.highlight(t.state, s, l, (u, h) => {
        let c = t.state.selection.ranges.some((f) => f.from == u && f.to == h);
        i.add(u, h, c ? Mxe : Dxe);
      });
    }
    return i.finish();
  }
}, {
  decorations: (r) => r.decorations
});
function cv(r) {
  return (e) => {
    let t = e.state.field(Hs, !1);
    return t && t.query.spec.valid ? r(e, t) : W6(e);
  };
}
const Pb = /* @__PURE__ */ cv((r, { query: e }) => {
  let { to: t } = r.state.selection.main, i = e.nextMatch(r.state, t, t);
  if (!i)
    return !1;
  let n = z.single(i.from, i.to), a = r.state.facet(Mf);
  return r.dispatch({
    selection: n,
    effects: [hP(r, i), a.scrollToMatch(n.main, r)],
    userEvent: "select.search"
  }), H6(r), !0;
}), Nb = /* @__PURE__ */ cv((r, { query: e }) => {
  let { state: t } = r, { from: i } = t.selection.main, n = e.prevMatch(t, i, i);
  if (!n)
    return !1;
  let a = z.single(n.from, n.to), o = r.state.facet(Mf);
  return r.dispatch({
    selection: a,
    effects: [hP(r, n), o.scrollToMatch(a.main, r)],
    userEvent: "select.search"
  }), H6(r), !0;
}), Qxe = /* @__PURE__ */ cv((r, { query: e }) => {
  let t = e.matchAll(r.state, 1e3);
  return !t || !t.length ? !1 : (r.dispatch({
    selection: z.create(t.map((i) => z.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), Uxe = ({ state: r, dispatch: e }) => {
  let t = r.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: n } = t.main, a = [], o = 0;
  for (let s = new hf(r.doc, r.sliceDoc(i, n)); !s.next().done; ) {
    if (a.length > 1e3)
      return !1;
    s.value.from == i && (o = a.length), a.push(z.range(s.value.from, s.value.to));
  }
  return e(r.update({
    selection: z.create(a, o),
    userEvent: "select.search.matches"
  })), !0;
}, SG = /* @__PURE__ */ cv((r, { query: e }) => {
  let { state: t } = r, { from: i, to: n } = t.selection.main;
  if (t.readOnly)
    return !1;
  let a = e.nextMatch(t, i, i);
  if (!a)
    return !1;
  let o = [], s, l, u = [];
  if (a.from == i && a.to == n && (l = t.toText(e.getReplacement(a)), o.push({ from: a.from, to: a.to, insert: l }), a = e.nextMatch(t, a.from, a.to), u.push(ge.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + "."))), a) {
    let h = o.length == 0 || o[0].from >= a.to ? 0 : a.to - a.from - l.length;
    s = z.single(a.from - h, a.to - h), u.push(hP(r, a)), u.push(t.facet(Mf).scrollToMatch(s.main, r));
  }
  return r.dispatch({
    changes: o,
    selection: s,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), $xe = /* @__PURE__ */ cv((r, { query: e }) => {
  if (r.state.readOnly)
    return !1;
  let t = e.matchAll(r.state, 1e9).map((n) => {
    let { from: a, to: o } = n;
    return { from: a, to: o, insert: e.getReplacement(n) };
  });
  if (!t.length)
    return !1;
  let i = r.state.phrase("replaced $ matches", t.length) + ".";
  return r.dispatch({
    changes: t,
    effects: ge.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function uP(r) {
  return r.state.facet(Mf).createPanel(r);
}
function n1(r, e) {
  var t, i, n, a, o;
  let s = r.selection.main, l = s.empty || s.to > s.from + 100 ? "" : r.sliceDoc(s.from, s.to);
  if (e && !l)
    return e;
  let u = r.facet(Mf);
  return new F6({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : u.caseSensitive,
    literal: (n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : u.literal,
    regexp: (a = e == null ? void 0 : e.regexp) !== null && a !== void 0 ? a : u.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : u.wholeWord
  });
}
function Y6(r) {
  let e = Eg(r, uP);
  return e && e.dom.querySelector("[main-field]");
}
function H6(r) {
  let e = Y6(r);
  e && e == r.root.activeElement && e.select();
}
const W6 = (r) => {
  let e = r.state.field(Hs, !1);
  if (e && e.panel) {
    let t = Y6(r);
    if (t && t != r.root.activeElement) {
      let i = n1(r.state, e.query.spec);
      i.valid && r.dispatch({ effects: yg.of(i) }), t.focus(), t.select();
    }
  } else
    r.dispatch({ effects: [
      lP.of(!0),
      e ? yg.of(n1(r.state, e.query.spec)) : rt.appendConfig.of(Fxe)
    ] });
  return !0;
}, z6 = (r) => {
  let e = r.state.field(Hs, !1);
  if (!e || !e.panel)
    return !1;
  let t = Eg(r, uP);
  return t && t.dom.contains(r.root.activeElement) && r.focus(), r.dispatch({ effects: lP.of(!1) }), !0;
}, Gxe = [
  { key: "Mod-f", run: W6, scope: "editor search-panel" },
  { key: "F3", run: Pb, shift: Nb, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Pb, shift: Nb, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: z6, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: Uxe },
  { key: "Alt-g", run: mxe },
  { key: "Mod-d", run: xxe, preventDefault: !0 }
];
class Bxe {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Hs).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Gt("input", {
      value: t.search,
      placeholder: ji(e, "Find"),
      "aria-label": ji(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Gt("input", {
      value: t.replace,
      placeholder: ji(e, "Replace"),
      "aria-label": ji(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Gt("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Gt("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Gt("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(n, a, o) {
      return Gt("button", { class: "cm-button", name: n, onclick: a, type: "button" }, o);
    }
    this.dom = Gt("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => Pb(e), [ji(e, "next")]),
      i("prev", () => Nb(e), [ji(e, "previous")]),
      i("select", () => Qxe(e), [ji(e, "all")]),
      Gt("label", null, [this.caseField, ji(e, "match case")]),
      Gt("label", null, [this.reField, ji(e, "regexp")]),
      Gt("label", null, [this.wordField, ji(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Gt("br"),
        this.replaceField,
        i("replace", () => SG(e), [ji(e, "replace")]),
        i("replaceAll", () => $xe(e), [ji(e, "replace all")])
      ],
      Gt("button", {
        name: "close",
        onclick: () => z6(e),
        "aria-label": ji(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new F6({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: yg.of(e) }));
  }
  keydown(e) {
    I_e(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Nb : Pb)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), SG(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(yg) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(Mf).top;
  }
}
function ji(r, e) {
  return r.state.phrase(e);
}
const jO = 30, KO = /[\s\.,:;?!]/;
function hP(r, { from: e, to: t }) {
  let i = r.state.doc.lineAt(e), n = r.state.doc.lineAt(t).to, a = Math.max(i.from, e - jO), o = Math.min(n, t + jO), s = r.state.sliceDoc(a, o);
  if (a != i.from) {
    for (let l = 0; l < jO; l++)
      if (!KO.test(s[l + 1]) && KO.test(s[l])) {
        s = s.slice(l);
        break;
      }
  }
  if (o != n) {
    for (let l = s.length - 1; l > s.length - jO; l--)
      if (!KO.test(s[l - 1]) && KO.test(s[l])) {
        s = s.slice(0, l);
        break;
      }
  }
  return ge.announce.of(`${r.state.phrase("current match")}. ${s} ${r.state.phrase("on line")} ${i.number}.`);
}
const Vxe = /* @__PURE__ */ ge.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), Fxe = [
  Hs,
  /* @__PURE__ */ _h.lowest(kxe),
  Vxe
];
class Z6 {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = qt(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), n = t.text.slice(i - t.from, this.pos - t.from), a = n.search(q6(e, !1));
    return a < 0 ? null : { from: i + a, to: this.pos, text: n.slice(a) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function TG(r) {
  let e = Object.keys(r).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function Xxe(r) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of r) {
    e[n[0]] = !0;
    for (let a = 1; a < n.length; a++)
      t[n[a]] = !0;
  }
  let i = TG(e) + TG(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function gT(r) {
  let e = r.map((n) => typeof n == "string" ? { label: n } : n), [t, i] = e.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : Xxe(e);
  return (n) => {
    let a = n.matchBefore(i);
    return a || n.explicit ? { from: a ? a.from : n.pos, options: e, validFor: t } : null;
  };
}
function cP(r, e) {
  return (t) => {
    for (let i = qt(t.state).resolveInner(t.pos, -1); i; i = i.parent) {
      if (r.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(t);
  };
}
class yG {
  constructor(e, t, i, n) {
    this.completion = e, this.source = t, this.match = i, this.score = n;
  }
}
function Ws(r) {
  return r.selection.main.from;
}
function q6(r, e) {
  var t;
  let { source: i } = r, n = e && i[0] != "^", a = i[i.length - 1] != "$";
  return !n && !a ? r : new RegExp(`${n ? "^" : ""}(?:${i})${a ? "$" : ""}`, (t = r.flags) !== null && t !== void 0 ? t : r.ignoreCase ? "i" : "");
}
const j6 = /* @__PURE__ */ is.define();
function Yxe(r, e, t, i) {
  let { main: n } = r.selection, a = t - n.from, o = i - n.from;
  return Object.assign(Object.assign({}, r.changeByRange((s) => s != n && t != i && r.sliceDoc(s.from + a, s.from + o) != r.sliceDoc(t, i) ? { range: s } : {
    changes: { from: s.from + a, to: i == n.from ? s.to : s.from + o, insert: e },
    range: z.cursor(s.from + a + e.length)
  })), { userEvent: "input.complete" });
}
const RG = /* @__PURE__ */ new WeakMap();
function Hxe(r) {
  if (!Array.isArray(r))
    return r;
  let e = RG.get(r);
  return e || RG.set(r, e = gT(r)), e;
}
const fP = /* @__PURE__ */ rt.define(), Rg = /* @__PURE__ */ rt.define();
class Wxe {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let i = Fr(e, t), n = kn(i);
      this.chars.push(i);
      let a = e.slice(t, t + n), o = a.toUpperCase();
      this.folded.push(Fr(o == a ? a.toLowerCase() : o, 0)), t += n;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: t, folded: i, any: n, precise: a, byWord: o } = this;
    if (t.length == 1) {
      let m = Fr(e, 0), E = kn(m), b = E == e.length ? 0 : -100;
      if (m != t[0])
        if (m == i[0])
          b += -200;
        else
          return !1;
      return this.ret(b, [0, E]);
    }
    let s = e.indexOf(this.pattern);
    if (s == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, u = 0;
    if (s < 0) {
      for (let m = 0, E = Math.min(e.length, 200); m < E && u < l; ) {
        let b = Fr(e, m);
        (b == t[u] || b == i[u]) && (n[u++] = m), m += kn(b);
      }
      if (u < l)
        return !1;
    }
    let h = 0, c = 0, f = !1, d = 0, p = -1, g = -1, v = /[a-z]/.test(e), O = !0;
    for (let m = 0, E = Math.min(e.length, 200), b = 0; m < E && c < l; ) {
      let T = Fr(e, m);
      s < 0 && (h < l && T == t[h] && (a[h++] = m), d < l && (T == t[d] || T == i[d] ? (d == 0 && (p = m), g = m + 1, d++) : d = 0));
      let S, y = T < 255 ? T >= 48 && T <= 57 || T >= 97 && T <= 122 ? 2 : T >= 65 && T <= 90 ? 1 : 0 : (S = Cw(T)) != S.toLowerCase() ? 1 : S != S.toUpperCase() ? 2 : 0;
      (!m || y == 1 && v || b == 0 && y != 0) && (t[c] == T || i[c] == T && (f = !0) ? o[c++] = m : o.length && (O = !1)), b = y, m += kn(T);
    }
    return c == l && o[0] == 0 && O ? this.result(-100 + (f ? -200 : 0), o, e) : d == l && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : s > -1 ? this.ret(-700 - e.length, [s, s + this.pattern.length]) : d == l ? this.ret(-200 + -700 - e.length, [p, g]) : c == l ? this.result(-100 + (f ? -200 : 0) + -700 + (O ? 0 : -1100), o, e) : t.length == 2 ? !1 : this.result((n[0] ? -700 : 0) + -200 + -1100, n, e);
  }
  result(e, t, i) {
    let n = [], a = 0;
    for (let o of t) {
      let s = o + (this.astral ? kn(Fr(i, o)) : 1);
      a && n[a - 1] == o ? n[a - 1] = s : (n[a++] = o, n[a++] = s);
    }
    return this.ret(e - i.length, n);
  }
}
const Vi = /* @__PURE__ */ Re.define({
  combine(r) {
    return mo(r, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: zxe,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => AG(e(i), t(i)),
      optionClass: (e, t) => (i) => AG(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function AG(r, e) {
  return r ? e ? r + " " + e : r : e;
}
function zxe(r, e, t, i, n) {
  let a = r.textDirection == Jt.RTL, o = a, s = !1, l = "top", u, h, c = e.left - n.left, f = n.right - e.right, d = i.right - i.left, p = i.bottom - i.top;
  if (o && c < Math.min(d, f) ? o = !1 : !o && f < Math.min(d, c) && (o = !0), d <= (o ? c : f))
    u = Math.max(n.top, Math.min(t.top, n.bottom - p)) - e.top, h = Math.min(400, o ? c : f);
  else {
    s = !0, h = Math.min(
      400,
      (a ? e.right : n.right - e.left) - 30
      /* Margin */
    );
    let g = n.bottom - e.bottom;
    g >= p || g > e.top ? u = t.bottom - e.top : (l = "bottom", u = e.bottom - t.top);
  }
  return {
    style: `${l}: ${u}px; max-width: ${h}px`,
    class: "cm-completionInfo-" + (s ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
function Zxe(r) {
  let e = r.addToOptions.slice();
  return r.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, n) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = t.displayLabel || t.label, s = 0;
      for (let l = 0; l < n.length; ) {
        let u = n[l++], h = n[l++];
        u > s && a.appendChild(document.createTextNode(o.slice(s, u)));
        let c = a.appendChild(document.createElement("span"));
        c.appendChild(document.createTextNode(o.slice(u, h))), c.className = "cm-completionMatchedText", s = h;
      }
      return s < o.length && a.appendChild(document.createTextNode(o.slice(s))), a;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function CG(r, e, t) {
  if (r <= t)
    return { from: 0, to: r };
  if (e < 0 && (e = 0), e <= r >> 1) {
    let n = Math.floor(e / t);
    return { from: n * t, to: (n + 1) * t };
  }
  let i = Math.floor((r - e) / t);
  return { from: r - (i + 1) * t, to: r - i * t };
}
class qxe {
  constructor(e, t, i) {
    this.view = e, this.stateField = t, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = e.state.field(t), { options: a, selected: o } = n.open, s = e.state.facet(Vi);
    this.optionContent = Zxe(s), this.optionClass = s.optionClass, this.tooltipClass = s.tooltipClass, this.range = CG(a.length, o, s.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < a.length) {
          this.applyCompletion(e, a[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(Vi).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: Rg.of(null) });
    }), this.list = this.dom.appendChild(this.createListBox(a, n.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var t, i, n;
    let a = e.state.field(this.stateField), o = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), a != o && (this.updateSel(), ((t = a.open) === null || t === void 0 ? void 0 : t.disabled) != ((i = o.open) === null || i === void 0 ? void 0 : i.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((n = a.open) === null || n === void 0) && n.disabled)));
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = CG(t.options.length, t.selected, this.view.state.facet(Vi).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    })), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: i } = t.options[t.selected], { info: n } = i;
      if (!n)
        return;
      let a = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!a)
        return;
      "then" in a ? a.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, i);
      }).catch((o) => Xn(this.view.state, o, "completion info")) : this.addInfoPane(a, i);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: n, destroy: a } = e;
      i.appendChild(n), this.infoDestroy = a || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      i.nodeName != "LI" || !i.id ? n-- : n == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && Kxe(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = e.getBoundingClientRect(), a = this.space;
    if (!a) {
      let o = this.dom.ownerDocument.defaultView || window;
      a = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return n.top > Math.min(a.bottom, t.bottom) - 10 || n.bottom < Math.max(a.top, t.top) + 10 ? null : this.view.state.facet(Vi).positionInfo(this.view, t, n, i, a);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, i) {
    const n = document.createElement("ul");
    n.id = t, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let a = null;
    for (let o = i.from; o < i.to; o++) {
      let { completion: s, match: l } = e[o], { section: u } = s;
      if (u) {
        let f = typeof u == "string" ? u : u.name;
        if (f != a && (o > i.from || i.from == 0))
          if (a = f, typeof u != "string" && u.header)
            n.appendChild(u.header(u));
          else {
            let d = n.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const h = n.appendChild(document.createElement("li"));
      h.id = t + "-" + o, h.setAttribute("role", "option");
      let c = this.optionClass(s);
      c && (h.className = c);
      for (let f of this.optionContent) {
        let d = f(s, this.view.state, l);
        d && h.appendChild(d);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function jxe(r, e) {
  return (t) => new qxe(t, r, e);
}
function Kxe(r, e) {
  let t = r.getBoundingClientRect(), i = e.getBoundingClientRect();
  i.top < t.top ? r.scrollTop -= t.top - i.top : i.bottom > t.bottom && (r.scrollTop += i.bottom - t.bottom);
}
function _G(r) {
  return (r.boost || 0) * 100 + (r.apply ? 10 : 0) + (r.info ? 5 : 0) + (r.type ? 1 : 0);
}
function Jxe(r, e) {
  let t = [], i = null, n = (l) => {
    t.push(l);
    let { section: u } = l.completion;
    if (u) {
      i || (i = []);
      let h = typeof u == "string" ? u : u.name;
      i.some((c) => c.name == h) || i.push(typeof u == "string" ? { name: h } : u);
    }
  };
  for (let l of r)
    if (l.hasResult()) {
      let u = l.result.getMatch;
      if (l.result.filter === !1)
        for (let h of l.result.options)
          n(new yG(h, l.source, u ? u(h) : [], 1e9 - t.length));
      else {
        let h = new Wxe(e.sliceDoc(l.from, l.to));
        for (let c of l.result.options)
          if (h.match(c.label)) {
            let f = c.displayLabel ? u ? u(c, h.matched) : [] : h.matched;
            n(new yG(c, l.source, f, h.score + (c.boost || 0)));
          }
      }
    }
  if (i) {
    let l = /* @__PURE__ */ Object.create(null), u = 0, h = (c, f) => {
      var d, p;
      return ((d = c.rank) !== null && d !== void 0 ? d : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (c.name < f.name ? -1 : 1);
    };
    for (let c of i.sort(h))
      u -= 1e5, l[c.name] = u;
    for (let c of t) {
      let { section: f } = c.completion;
      f && (c.score += l[typeof f == "string" ? f : f.name]);
    }
  }
  let a = [], o = null, s = e.facet(Vi).compareCompletions;
  for (let l of t.sort((u, h) => h.score - u.score || s(u.completion, h.completion))) {
    let u = l.completion;
    !o || o.label != u.label || o.detail != u.detail || o.type != null && u.type != null && o.type != u.type || o.apply != u.apply || o.boost != u.boost ? a.push(l) : _G(l.completion) > _G(o) && (a[a.length - 1] = l), o = l.completion;
  }
  return a;
}
class Tc {
  constructor(e, t, i, n, a, o) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = n, this.selected = a, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Tc(this.options, IG(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, n, a) {
    let o = Jxe(e, t);
    if (!o.length)
      return n && e.some(
        (l) => l.state == 1
        /* Pending */
      ) ? new Tc(n.options, n.attrs, n.tooltip, n.timestamp, n.selected, !0) : null;
    let s = t.facet(Vi).selectOnOpen ? 0 : -1;
    if (n && n.selected != s && n.selected != -1) {
      let l = n.options[n.selected].completion;
      for (let u = 0; u < o.length; u++)
        if (o[u].completion == l) {
          s = u;
          break;
        }
    }
    return new Tc(o, IG(i, s), {
      pos: e.reduce((l, u) => u.hasResult() ? Math.min(l, u.from) : l, 1e8),
      create: jxe(on, e9),
      above: a.aboveCursor
    }, n ? n.timestamp : Date.now(), s, !1);
  }
  map(e) {
    return new Tc(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class Lb {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new Lb(rwe, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(Vi), a = (i.override || t.languageDataAt("autocomplete", Ws(t)).map(Hxe)).map((s) => (this.active.find((u) => u.source == s) || new Qi(
      s,
      this.active.some(
        (u) => u.state != 0
        /* Inactive */
      ) ? 1 : 0
      /* Inactive */
    )).update(e, i));
    a.length == this.active.length && a.every((s, l) => s == this.active[l]) && (a = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || a.some((s) => s.hasResult() && e.changes.touchesRange(s.from, s.to)) || !ewe(a, this.active) ? o = Tc.build(a, t, this.id, o, i) : o && o.disabled && !a.some(
      (s) => s.state == 1
      /* Pending */
    ) && (o = null), !o && a.every(
      (s) => s.state != 1
      /* Pending */
    ) && a.some((s) => s.hasResult()) && (a = a.map((s) => s.hasResult() ? new Qi(
      s.source,
      0
      /* Inactive */
    ) : s));
    for (let s of e.effects)
      s.is(J6) && (o = o && o.setSelected(s.value, this.id));
    return a == this.active && o == this.open ? this : new Lb(a, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : twe;
  }
}
function ewe(r, e) {
  if (r == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < r.length && !r[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let n = t == r.length, a = i == e.length;
    if (n || a)
      return n == a;
    if (r[t++].result != e[i++].result)
      return !1;
  }
}
const twe = {
  "aria-autocomplete": "list"
};
function IG(r, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": r
  };
  return e > -1 && (t["aria-activedescendant"] = r + "-" + e), t;
}
const rwe = [];
function a1(r) {
  return r.isUserEvent("input.type") ? "input" : r.isUserEvent("delete.backward") ? "delete" : null;
}
class Qi {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let i = a1(e), n = this;
    i ? n = n.handleUserEvent(e, i, t) : e.docChanged ? n = n.handleChange(e) : e.selection && n.state != 0 && (n = new Qi(
      n.source,
      0
      /* Inactive */
    ));
    for (let a of e.effects)
      if (a.is(fP))
        n = new Qi(n.source, 1, a.value ? Ws(e.state) : -1);
      else if (a.is(Rg))
        n = new Qi(
          n.source,
          0
          /* Inactive */
        );
      else if (a.is(K6))
        for (let o of a.value)
          o.source == n.source && (n = o);
    return n;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new Qi(
      this.source,
      1
      /* Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Ws(e.startState)) ? new Qi(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new Qi(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class Gc extends Qi {
  constructor(e, t, i, n, a) {
    super(e, 2, t), this.result = i, this.from = n, this.to = a;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, i) {
    var n;
    let a = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), s = Ws(e.state);
    if ((this.explicitPos < 0 ? s <= a : s < this.from) || s > o || t == "delete" && Ws(e.startState) == this.from)
      return new Qi(
        this.source,
        t == "input" && i.activateOnTyping ? 1 : 0
        /* Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), u;
    return iwe(this.result.validFor, e.state, a, o) ? new Gc(this.source, l, this.result, a, o) : this.result.update && (u = this.result.update(this.result, a, o, new Z6(e.state, s, l >= 0))) ? new Gc(this.source, l, u, u.from, (n = u.to) !== null && n !== void 0 ? n : Ws(e.state)) : new Qi(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new Qi(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new Gc(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function iwe(r, e, t, i) {
  if (!r)
    return !1;
  let n = e.sliceDoc(t, i);
  return typeof r == "function" ? r(n, t, i, e) : q6(r, !0).test(n);
}
const K6 = /* @__PURE__ */ rt.define({
  map(r, e) {
    return r.map((t) => t.map(e));
  }
}), J6 = /* @__PURE__ */ rt.define(), on = /* @__PURE__ */ kr.define({
  create() {
    return Lb.start();
  },
  update(r, e) {
    return r.update(e);
  },
  provide: (r) => [
    kw.from(r, (e) => e.tooltip),
    ge.contentAttributes.from(r, (e) => e.attrs)
  ]
});
function e9(r, e) {
  const t = e.completion.apply || e.completion.label;
  let i = r.state.field(on).active.find((n) => n.source == e.source);
  return i instanceof Gc ? (typeof t == "string" ? r.dispatch(Object.assign(Object.assign({}, Yxe(r.state, t, i.from, i.to)), { annotations: j6.of(e.completion) })) : t(r, e.completion, i.from, i.to), !0) : !1;
}
function JO(r, e = "option") {
  return (t) => {
    let i = t.state.field(on, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(Vi).interactionDelay)
      return !1;
    let n = 1, a;
    e == "page" && (a = K7(t, i.open.tooltip)) && (n = Math.max(2, Math.floor(a.dom.offsetHeight / a.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = i.open.options, s = i.open.selected > -1 ? i.open.selected + n * (r ? 1 : -1) : r ? 0 : o - 1;
    return s < 0 ? s = e == "page" ? 0 : o - 1 : s >= o && (s = e == "page" ? o - 1 : 0), t.dispatch({ effects: J6.of(s) }), !0;
  };
}
const nwe = (r) => {
  let e = r.state.field(on, !1);
  return r.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < r.state.facet(Vi).interactionDelay ? !1 : e9(r, e.open.options[e.open.selected]);
}, awe = (r) => r.state.field(on, !1) ? (r.dispatch({ effects: fP.of(!0) }), !0) : !1, owe = (r) => {
  let e = r.state.field(on, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* Inactive */
  ) ? !1 : (r.dispatch({ effects: Rg.of(null) }), !0);
};
class swe {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const xG = 50, lwe = 50, uwe = 1e3, hwe = /* @__PURE__ */ Ir.fromClass(class {
  constructor(r) {
    this.view = r, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of r.state.field(on).active)
      e.state == 1 && this.startQuery(e);
  }
  update(r) {
    let e = r.state.field(on);
    if (!r.selectionSet && !r.docChanged && r.startState.field(on) == e)
      return;
    let t = r.transactions.some((i) => (i.selection || i.docChanged) && !a1(i));
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (t || n.updates.length + r.transactions.length > lwe && Date.now() - n.time > uwe) {
        for (let a of n.context.abortListeners)
          try {
            a();
          } catch (o) {
            Xn(this.view.state, o);
          }
        n.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        n.updates.push(...r.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((n) => n.active.source == i.source)) ? setTimeout(() => this.startUpdate(), xG) : -1, this.composing != 0)
      for (let i of r.transactions)
        a1(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: r } = this.view, e = r.field(on);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(r) {
    let { state: e } = this.view, t = Ws(e), i = new Z6(e, t, r.explicitPos == t), n = new swe(r, i);
    this.running.push(n), Promise.resolve(r.source(i)).then((a) => {
      n.context.aborted || (n.done = a || null, this.scheduleAccept());
    }, (a) => {
      this.view.dispatch({ effects: Rg.of(null) }), Xn(this.view.state, a);
    });
  }
  scheduleAccept() {
    this.running.every((r) => r.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), xG));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var r;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Vi);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let o = new Gc(n.active.source, n.active.explicitPos, n.done, n.done.from, (r = n.done.to) !== null && r !== void 0 ? r : Ws(n.updates.length ? n.updates[0].startState : this.view.state));
        for (let s of n.updates)
          o = o.update(s, t);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let a = this.view.state.field(on).active.find((o) => o.source == n.active.source);
      if (a && a.state == 1)
        if (n.done == null) {
          let o = new Qi(
            n.active.source,
            0
            /* Inactive */
          );
          for (let s of n.updates)
            o = o.update(s, t);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(a);
    }
    e.length && this.view.dispatch({ effects: K6.of(e) });
  }
}, {
  eventHandlers: {
    blur(r) {
      let e = this.view.state.field(on, !1);
      if (e && e.tooltip && this.view.state.facet(Vi).closeOnBlur) {
        let t = e.open && K7(this.view, e.open.tooltip);
        (!t || !t.dom.contains(r.relatedTarget)) && this.view.dispatch({ effects: Rg.of(null) });
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: fP.of(!1) }), 20), this.composing = 0;
    }
  }
}), t9 = /* @__PURE__ */ ge.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class cwe {
  constructor(e, t, i, n) {
    this.field = e, this.line = t, this.from = i, this.to = n;
  }
}
class dP {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, Yr.TrackDel), i = e.mapPos(this.to, 1, Yr.TrackDel);
    return t == null || i == null ? null : new dP(this.field, t, i);
  }
}
class pP {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], n = [t], a = e.doc.lineAt(t), o = /^\s*/.exec(a.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let u = o, h = /^\t*/.exec(l)[0].length;
        for (let c = 0; c < h; c++)
          u += e.facet(tT);
        n.push(t + u.length - h), l = u + l.slice(h);
      }
      i.push(l), t += l.length + 1;
    }
    let s = this.fieldPositions.map((l) => new dP(l.field, n[l.line] + l.from, n[l.line] + l.to));
    return { text: i, ranges: s };
  }
  static parse(e) {
    let t = [], i = [], n = [], a;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; a = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let s = a[1] ? +a[1] : null, l = a[2] || a[3] || "", u = -1;
        for (let h = 0; h < t.length; h++)
          (s != null ? t[h].seq == s : l && t[h].name == l) && (u = h);
        if (u < 0) {
          let h = 0;
          for (; h < t.length && (s == null || t[h].seq != null && t[h].seq < s); )
            h++;
          t.splice(h, 0, { seq: s, name: l }), u = h;
          for (let c of n)
            c.field >= u && c.field++;
        }
        n.push(new cwe(u, i.length, a.index, a.index + l.length)), o = o.slice(0, a.index) + l + o.slice(a.index + a[0].length);
      }
      for (let s; s = /\\([{}])/.exec(o); ) {
        o = o.slice(0, s.index) + s[1] + o.slice(s.index + s[0].length);
        for (let l of n)
          l.line == i.length && l.from > s.index && (l.from--, l.to--);
      }
      i.push(o);
    }
    return new pP(i, n);
  }
}
let fwe = /* @__PURE__ */ Be.widget({ widget: /* @__PURE__ */ new class extends ns {
  toDOM() {
    let r = document.createElement("span");
    return r.className = "cm-snippetFieldPosition", r;
  }
  ignoreEvent() {
    return !1;
  }
}() }), dwe = /* @__PURE__ */ Be.mark({ class: "cm-snippetField" });
class kf {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = Be.set(e.map((i) => (i.from == i.to ? fwe : dwe).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let n = i.map(e);
      if (!n)
        return null;
      t.push(n);
    }
    return new kf(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
}
const fv = /* @__PURE__ */ rt.define({
  map(r, e) {
    return r && r.map(e);
  }
}), pwe = /* @__PURE__ */ rt.define(), Ag = /* @__PURE__ */ kr.define({
  create() {
    return null;
  },
  update(r, e) {
    for (let t of e.effects) {
      if (t.is(fv))
        return t.value;
      if (t.is(pwe) && r)
        return new kf(r.ranges, t.value);
    }
    return r && e.docChanged && (r = r.map(e.changes)), r && e.selection && !r.selectionInsideField(e.selection) && (r = null), r;
  },
  provide: (r) => ge.decorations.from(r, (e) => e ? e.deco : Be.none)
});
function gP(r, e) {
  return z.create(r.filter((t) => t.field == e).map((t) => z.range(t.from, t.to)));
}
function gwe(r) {
  let e = pP.parse(r);
  return (t, i, n, a) => {
    let { text: o, ranges: s } = e.instantiate(t.state, n), l = {
      changes: { from: n, to: a, insert: Rt.of(o) },
      scrollIntoView: !0,
      annotations: i ? j6.of(i) : void 0
    };
    if (s.length && (l.selection = gP(s, 0)), s.length > 1) {
      let u = new kf(s, 0), h = l.effects = [fv.of(u)];
      t.state.field(Ag, !1) === void 0 && h.push(rt.appendConfig.of([Ag, bwe, Swe, t9]));
    }
    t.dispatch(t.state.update(l));
  };
}
function r9(r) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(Ag, !1);
    if (!i || r < 0 && i.active == 0)
      return !1;
    let n = i.active + r, a = r > 0 && !i.ranges.some((o) => o.field == n + r);
    return t(e.update({
      selection: gP(i.ranges, n),
      effects: fv.of(a ? null : new kf(i.ranges, n))
    })), !0;
  };
}
const vwe = ({ state: r, dispatch: e }) => r.field(Ag, !1) ? (e(r.update({ effects: fv.of(null) })), !0) : !1, Owe = /* @__PURE__ */ r9(1), mwe = /* @__PURE__ */ r9(-1), Ewe = [
  { key: "Tab", run: Owe, shift: mwe },
  { key: "Escape", run: vwe }
], wG = /* @__PURE__ */ Re.define({
  combine(r) {
    return r.length ? r[0] : Ewe;
  }
}), bwe = /* @__PURE__ */ _h.highest(/* @__PURE__ */ ov.compute([wG], (r) => r.facet(wG)));
function fr(r, e) {
  return Object.assign(Object.assign({}, e), { apply: gwe(r) });
}
const Swe = /* @__PURE__ */ ge.domEventHandlers({
  mousedown(r, e) {
    let t = e.state.field(Ag, !1), i;
    if (!t || (i = e.posAtCoords({ x: r.clientX, y: r.clientY })) == null)
      return !1;
    let n = t.ranges.find((a) => a.from <= i && a.to >= i);
    return !n || n.field == t.active ? !1 : (e.dispatch({
      selection: gP(t.ranges, n.field),
      effects: fv.of(t.ranges.some((a) => a.field > n.field) ? new kf(t.ranges, n.field) : null)
    }), !0);
  }
}), Cg = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, wu = /* @__PURE__ */ rt.define({
  map(r, e) {
    let t = e.mapPos(r, -1, Yr.TrackAfter);
    return t ?? void 0;
  }
}), vP = /* @__PURE__ */ new class extends sh {
}();
vP.startSide = 1;
vP.endSide = -1;
const i9 = /* @__PURE__ */ kr.define({
  create() {
    return Nt.empty;
  },
  update(r, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, i = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(i, -1) && (r = Nt.empty);
    }
    r = r.map(e.changes);
    for (let t of e.effects)
      t.is(wu) && (r = r.update({ add: [vP.range(t.value, t.value + 1)] }));
    return r;
  }
});
function Twe() {
  return [Rwe, i9];
}
const PR = "()[]{}<>";
function n9(r) {
  for (let e = 0; e < PR.length; e += 2)
    if (PR.charCodeAt(e) == r)
      return PR.charAt(e + 1);
  return Cw(r < 128 ? r : r + 1);
}
function a9(r, e) {
  return r.languageDataAt("closeBrackets", e)[0] || Cg;
}
const ywe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), Rwe = /* @__PURE__ */ ge.inputHandler.of((r, e, t, i) => {
  if ((ywe ? r.composing : r.compositionStarted) || r.state.readOnly)
    return !1;
  let n = r.state.selection.main;
  if (i.length > 2 || i.length == 2 && kn(Fr(i, 0)) == 1 || e != n.from || t != n.to)
    return !1;
  let a = _we(r.state, i);
  return a ? (r.dispatch(a), !0) : !1;
}), Awe = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let i = a9(r, r.selection.main.head).brackets || Cg.brackets, n = null, a = r.changeByRange((o) => {
    if (o.empty) {
      let s = Iwe(r.doc, o.head);
      for (let l of i)
        if (l == s && vT(r.doc, o.head) == n9(Fr(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: z.cursor(o.head - l.length)
          };
    }
    return { range: n = o };
  });
  return n || e(r.update(a, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, Cwe = [
  { key: "Backspace", run: Awe }
];
function _we(r, e) {
  let t = a9(r, r.selection.main.head), i = t.brackets || Cg.brackets;
  for (let n of i) {
    let a = n9(Fr(n, 0));
    if (e == n)
      return a == n ? Pwe(r, n, i.indexOf(n + n + n) > -1, t) : xwe(r, n, a, t.before || Cg.before);
    if (e == a && o9(r, r.selection.main.from))
      return wwe(r, n, a);
  }
  return null;
}
function o9(r, e) {
  let t = !1;
  return r.field(i9).between(0, r.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function vT(r, e) {
  let t = r.sliceString(e, e + 2);
  return t.slice(0, kn(Fr(t, 0)));
}
function Iwe(r, e) {
  let t = r.sliceString(e - 2, e);
  return kn(Fr(t, 0)) == t.length ? t : t.slice(1);
}
function xwe(r, e, t, i) {
  let n = null, a = r.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: wu.of(o.to + e.length),
        range: z.range(o.anchor + e.length, o.head + e.length)
      };
    let s = vT(r.doc, o.head);
    return !s || /\s/.test(s) || i.indexOf(s) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: wu.of(o.head + e.length),
      range: z.cursor(o.head + e.length)
    } : { range: n = o };
  });
  return n ? null : r.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function wwe(r, e, t) {
  let i = null, n = r.changeByRange((a) => a.empty && vT(r.doc, a.head) == t ? {
    changes: { from: a.head, to: a.head + t.length, insert: t },
    range: z.cursor(a.head + t.length)
  } : i = { range: a });
  return i ? null : r.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function Pwe(r, e, t, i) {
  let n = i.stringPrefixes || Cg.stringPrefixes, a = null, o = r.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: e, from: s.to }],
        effects: wu.of(s.to + e.length),
        range: z.range(s.anchor + e.length, s.head + e.length)
      };
    let l = s.head, u = vT(r.doc, l), h;
    if (u == e) {
      if (PG(r, l))
        return {
          changes: { insert: e + e, from: l },
          effects: wu.of(l + e.length),
          range: z.cursor(l + e.length)
        };
      if (o9(r, l)) {
        let f = t && r.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + f.length, insert: f },
          range: z.cursor(l + f.length)
        };
      }
    } else {
      if (t && r.sliceDoc(l - 2 * e.length, l) == e + e && (h = NG(r, l - 2 * e.length, n)) > -1 && PG(r, h))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: wu.of(l + e.length),
          range: z.cursor(l + e.length)
        };
      if (r.charCategorizer(l)(u) != Pt.Word && NG(r, l, n) > -1 && !Nwe(r, l, e, n))
        return {
          changes: { insert: e + e, from: l },
          effects: wu.of(l + e.length),
          range: z.cursor(l + e.length)
        };
    }
    return { range: a = s };
  });
  return a ? null : r.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function PG(r, e) {
  let t = qt(r).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function Nwe(r, e, t, i) {
  let n = qt(r).resolveInner(e, -1), a = i.reduce((o, s) => Math.max(o, s.length), 0);
  for (let o = 0; o < 5; o++) {
    let s = r.sliceDoc(n.from, Math.min(n.to, n.from + t.length + a)), l = s.indexOf(t);
    if (!l || l > -1 && i.indexOf(s.slice(0, l)) > -1) {
      let h = n.firstChild;
      for (; h && h.from == n.from && h.to - h.from > t.length + l; ) {
        if (r.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let u = n.to == e && n.parent;
    if (!u)
      break;
    n = u;
  }
  return !1;
}
function NG(r, e, t) {
  let i = r.charCategorizer(e);
  if (i(r.sliceDoc(e - 1, e)) != Pt.Word)
    return e;
  for (let n of t) {
    let a = e - n.length;
    if (r.sliceDoc(a, e) == n && i(r.sliceDoc(a - 1, a)) != Pt.Word)
      return a;
  }
  return -1;
}
function s9(r = {}) {
  return [
    on,
    Vi.of(r),
    hwe,
    Lwe,
    t9
  ];
}
const l9 = [
  { key: "Ctrl-Space", run: awe },
  { key: "Escape", run: owe },
  { key: "ArrowDown", run: /* @__PURE__ */ JO(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ JO(!1) },
  { key: "PageDown", run: /* @__PURE__ */ JO(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ JO(!1, "page") },
  { key: "Enter", run: nwe }
], Lwe = /* @__PURE__ */ _h.highest(/* @__PURE__ */ ov.computeN([Vi], (r) => r.facet(Vi).defaultKeymap ? [l9] : []));
class Dwe {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class Ou {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let n = e, a = i.facet(c9).markerFilter;
    a && (n = a(n));
    let o = Be.set(n.map((s) => s.from == s.to || s.from == s.to - 1 && i.doc.lineAt(s.from).to == s.from ? Be.widget({
      widget: new Fwe(s),
      diagnostic: s
    }).range(s.from) : Be.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + s.severity + (s.markClass ? " " + s.markClass : "") },
      diagnostic: s
    }).range(s.from, s.to)), !0);
    return new Ou(o, t, cf(o));
  }
}
function cf(r, e = null, t = 0) {
  let i = null;
  return r.between(t, 1e9, (n, a, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return i = new Dwe(n, a, o.diagnostic), !1;
  }), i;
}
function Mwe(r, e) {
  let t = r.startState.doc.lineAt(e.pos);
  return !!(r.effects.some((i) => i.is(u9)) || r.changes.touchesRange(t.from, t.to));
}
function kwe(r, e) {
  return r.field(cn, !1) ? e : e.concat(rt.appendConfig.of(Hwe));
}
const u9 = /* @__PURE__ */ rt.define(), OP = /* @__PURE__ */ rt.define(), h9 = /* @__PURE__ */ rt.define(), cn = /* @__PURE__ */ kr.define({
  create() {
    return new Ou(Be.none, null, null);
  },
  update(r, e) {
    if (e.docChanged) {
      let t = r.diagnostics.map(e.changes), i = null;
      if (r.selected) {
        let n = e.changes.mapPos(r.selected.from, 1);
        i = cf(t, r.selected.diagnostic, n) || cf(t, null, n);
      }
      r = new Ou(t, r.panel, i);
    }
    for (let t of e.effects)
      t.is(u9) ? r = Ou.init(t.value, r.panel, e.state) : t.is(OP) ? r = new Ou(r.diagnostics, t.value ? OT.open : null, r.selected) : t.is(h9) && (r = new Ou(r.diagnostics, r.panel, t.value));
    return r;
  },
  provide: (r) => [
    bg.from(r, (e) => e.panel),
    ge.decorations.from(r, (e) => e.diagnostics)
  ]
}), Qwe = /* @__PURE__ */ Be.mark({ class: "cm-lintRange cm-lintRange-active" });
function Uwe(r, e, t) {
  let { diagnostics: i } = r.state.field(cn), n = [], a = 2e8, o = 0;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, u, { spec: h }) => {
    e >= l && e <= u && (l == u || (e > l || t > 0) && (e < u || t < 0)) && (n.push(h.diagnostic), a = Math.min(l, a), o = Math.max(u, o));
  });
  let s = r.state.facet(c9).tooltipFilter;
  return s && (n = s(n)), n.length ? {
    pos: a,
    end: o,
    above: r.state.doc.lineAt(a).to < o,
    create() {
      return { dom: $we(r, n) };
    }
  } : null;
}
function $we(r, e) {
  return Gt("ul", { class: "cm-tooltip-lint" }, e.map((t) => d9(r, t, !1)));
}
const Gwe = (r) => {
  let e = r.state.field(cn, !1);
  (!e || !e.panel) && r.dispatch({ effects: kwe(r.state, [OP.of(!0)]) });
  let t = Eg(r, OT.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, LG = (r) => {
  let e = r.state.field(cn, !1);
  return !e || !e.panel ? !1 : (r.dispatch({ effects: OP.of(!1) }), !0);
}, Bwe = (r) => {
  let e = r.state.field(cn, !1);
  if (!e)
    return !1;
  let t = r.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (r.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, Vwe = [
  { key: "Mod-Shift-m", run: Gwe, preventDefault: !0 },
  { key: "F8", run: Bwe }
], c9 = /* @__PURE__ */ Re.define({
  combine(r) {
    return Object.assign({ sources: r.map((e) => e.source) }, mo(r.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (i) => e(i) || t(i) : e : t
    }));
  }
});
function f9(r) {
  let e = [];
  if (r)
    e:
      for (let { name: t } of r) {
        for (let i = 0; i < t.length; i++) {
          let n = t[i];
          if (/[a-zA-Z]/.test(n) && !e.some((a) => a.toLowerCase() == n.toLowerCase())) {
            e.push(n);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function d9(r, e, t) {
  var i;
  let n = t ? f9(e.actions) : [];
  return Gt("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Gt("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((a, o) => {
    let s = !1, l = (f) => {
      if (f.preventDefault(), s)
        return;
      s = !0;
      let d = cf(r.state.field(cn).diagnostics, e);
      d && a.apply(r, d.from, d.to);
    }, { name: u } = a, h = n[o] ? u.indexOf(n[o]) : -1, c = h < 0 ? u : [
      u.slice(0, h),
      Gt("u", u.slice(h, h + 1)),
      u.slice(h + 1)
    ];
    return Gt("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${h < 0 ? "" : ` (access key "${n[o]})"`}.`
    }, c);
  }), e.source && Gt("div", { class: "cm-diagnosticSource" }, e.source));
}
class Fwe extends ns {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Gt("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class DG {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = d9(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class OT {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (n) => {
      if (n.keyCode == 27)
        LG(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: a } = this.items[this.selectedIndex], o = f9(a.actions);
        for (let s = 0; s < o.length; s++)
          if (o[s].toUpperCase().charCodeAt(0) == n.keyCode) {
            let l = cf(this.view.state.field(cn).diagnostics, a);
            l && a.actions[s].apply(e, l.from, l.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let a = 0; a < this.items.length; a++)
        this.items[a].dom.contains(n.target) && this.moveSelection(a);
    };
    this.list = Gt("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = Gt("div", { class: "cm-panel-lint" }, this.list, Gt("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => LG(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(cn).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(cn), i = 0, n = !1, a = null;
    for (e.between(0, this.view.state.doc.length, (o, s, { spec: l }) => {
      let u = -1, h;
      for (let c = i; c < this.items.length; c++)
        if (this.items[c].diagnostic == l.diagnostic) {
          u = c;
          break;
        }
      u < 0 ? (h = new DG(this.view, l.diagnostic), this.items.splice(i, 0, h), n = !0) : (h = this.items[u], u > i && (this.items.splice(i, u - i), n = !0)), t && h.diagnostic == t.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), a = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new DG(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = !0), a ? (this.list.setAttribute("aria-activedescendant", a.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: a.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: s }) => {
        o.top < s.top ? this.list.scrollTop -= s.top - o.top : o.bottom > s.bottom && (this.list.scrollTop += o.bottom - s.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(cn), i = cf(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: h9.of(i)
    });
  }
  static open(e) {
    return new OT(e);
  }
}
function Xwe(r, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(r)}</svg>')`;
}
function em(r) {
  return Xwe(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${r}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const Ywe = /* @__PURE__ */ ge.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ em("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ em("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ em("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ em("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), Hwe = [
  cn,
  /* @__PURE__ */ ge.decorations.compute([cn], (r) => {
    let { selected: e, panel: t } = r.field(cn);
    return !e || !t || e.from == e.to ? Be.none : Be.set([
      Qwe.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ d1e(Uwe, { hideOn: Mwe }),
  Ywe
], Wwe = /* @__PURE__ */ (() => [
  T1e(),
  A1e(),
  Y_e(),
  PZ(),
  mIe(),
  D_e(),
  $_e(),
  St.allowMultipleSelections.of(!0),
  aIe(),
  Eo(TIe, { fallback: !0 }),
  xIe(),
  Twe(),
  s9(),
  i1e(),
  o1e(),
  j_e(),
  Sxe(),
  ov.of([
    ...Cwe,
    ...Q6,
    ...Gxe,
    ...QZ,
    ...pIe,
    ...l9,
    ...Vwe
  ])
])(), zwe = "#e5c07b", MG = "#e06c75", Zwe = "#56b6c2", qwe = "#ffffff", Um = "#abb2bf", o1 = "#7d8799", jwe = "#61afef", Kwe = "#98c379", kG = "#d19a66", Jwe = "#c678dd", ePe = "#21252b", QG = "#2c313a", UG = "#282c34", NR = "#353a42", tPe = "#3E4451", $G = "#528bff", rPe = /* @__PURE__ */ ge.theme({
  "&": {
    color: Um,
    backgroundColor: UG
  },
  ".cm-content": {
    caretColor: $G
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: $G },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: tPe },
  ".cm-panels": { backgroundColor: ePe, color: Um },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: UG,
    color: o1,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: QG
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: NR
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: NR,
    borderBottomColor: NR
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: QG,
      color: Um
    }
  }
}, { dark: !0 }), iPe = /* @__PURE__ */ En.define([
  {
    tag: R.keyword,
    color: Jwe
  },
  {
    tag: [R.name, R.deleted, R.character, R.propertyName, R.macroName],
    color: MG
  },
  {
    tag: [/* @__PURE__ */ R.function(R.variableName), R.labelName],
    color: jwe
  },
  {
    tag: [R.color, /* @__PURE__ */ R.constant(R.name), /* @__PURE__ */ R.standard(R.name)],
    color: kG
  },
  {
    tag: [/* @__PURE__ */ R.definition(R.name), R.separator],
    color: Um
  },
  {
    tag: [R.typeName, R.className, R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace],
    color: zwe
  },
  {
    tag: [R.operator, R.operatorKeyword, R.url, R.escape, R.regexp, R.link, /* @__PURE__ */ R.special(R.string)],
    color: Zwe
  },
  {
    tag: [R.meta, R.comment],
    color: o1
  },
  {
    tag: R.strong,
    fontWeight: "bold"
  },
  {
    tag: R.emphasis,
    fontStyle: "italic"
  },
  {
    tag: R.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: R.link,
    color: o1,
    textDecoration: "underline"
  },
  {
    tag: R.heading,
    fontWeight: "bold",
    color: MG
  },
  {
    tag: [R.atom, R.bool, /* @__PURE__ */ R.special(R.variableName)],
    color: kG
  },
  {
    tag: [R.processingInstruction, R.string, R.inserted],
    color: Kwe
  },
  {
    tag: R.invalid,
    color: qwe
  }
]), GG = [rPe, /* @__PURE__ */ Eo(iPe)], ze = {
  name: "materialLight",
  dark: !1,
  background: "#FAFAFA",
  foreground: "#90A4AE",
  selection: "#80CBC440",
  cursor: "#272727",
  dropdownBackground: "#FAFAFA",
  dropdownBorder: "#00000010",
  activeLine: "#c2c2c222",
  matchingBracket: "#FAFAFA",
  keyword: "#39ADB5",
  storage: "#39ADB5",
  variable: "#90A4AE",
  parameter: "#90A4AE",
  function: "#6182B8",
  string: "#91B859",
  constant: "#39ADB5",
  type: "#E2931D",
  class: "#E2931D",
  number: "#F76D47",
  comment: "#90A4AE",
  heading: "#39ADB5",
  invalid: "#E5393570",
  regexp: "#91B859"
}, nPe = ge.theme({
  "&": {
    color: ze.foreground,
    backgroundColor: ze.background
  },
  ".cm-content": { caretColor: ze.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: ze.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: ze.selection },
  ".cm-panels": { backgroundColor: ze.dropdownBackground, color: ze.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: ze.dropdownBackground,
    outline: `1px solid ${ze.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: ze.selection
  },
  ".cm-activeLine": { backgroundColor: ze.activeLine },
  ".cm-selectionMatch": { backgroundColor: ze.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: ze.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: ze.background,
    color: ze.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: ze.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: ze.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${ze.dropdownBorder}`,
    backgroundColor: ze.dropdownBackground,
    color: ze.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: ze.foreground,
    borderBottomColor: ze.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: ze.selection,
      color: ze.foreground
    }
  }
}, { dark: ze.dark }), aPe = En.define([
  { tag: R.keyword, color: ze.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: ze.variable },
  { tag: [R.propertyName], color: ze.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: ze.string },
  { tag: [R.function(R.variableName), R.labelName], color: ze.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: ze.constant },
  { tag: [R.definition(R.name), R.separator], color: ze.variable },
  { tag: [R.className], color: ze.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: ze.number },
  { tag: [R.typeName], color: ze.type, fontStyle: ze.type },
  { tag: [R.operator, R.operatorKeyword], color: ze.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: ze.regexp },
  { tag: [R.meta, R.comment], color: ze.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: ze.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: ze.variable },
  { tag: R.invalid, color: ze.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), oPe = [
  nPe,
  Eo(aPe)
], Ze = {
  name: "materialDark",
  dark: !0,
  background: "#263238",
  foreground: "#EEFFFF",
  selection: "#80CBC420",
  cursor: "#FFCC00",
  dropdownBackground: "#263238",
  dropdownBorder: "#FFFFFF10",
  activeLine: "#4c616c22",
  matchingBracket: "#263238",
  keyword: "#89DDFF",
  storage: "#89DDFF",
  variable: "#EEFFFF",
  parameter: "#EEFFFF",
  function: "#82AAFF",
  string: "#C3E88D",
  constant: "#89DDFF",
  type: "#FFCB6B",
  class: "#FFCB6B",
  number: "#F78C6C",
  comment: "#546E7A",
  heading: "#89DDFF",
  invalid: "#f0717870",
  regexp: "#C3E88D"
}, sPe = ge.theme({
  "&": {
    color: Ze.foreground,
    backgroundColor: Ze.background
  },
  ".cm-content": { caretColor: Ze.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Ze.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: Ze.selection },
  ".cm-panels": { backgroundColor: Ze.dropdownBackground, color: Ze.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: Ze.dropdownBackground,
    outline: `1px solid ${Ze.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: Ze.selection
  },
  ".cm-activeLine": { backgroundColor: Ze.activeLine },
  ".cm-selectionMatch": { backgroundColor: Ze.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: Ze.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: Ze.background,
    color: Ze.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: Ze.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: Ze.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${Ze.dropdownBorder}`,
    backgroundColor: Ze.dropdownBackground,
    color: Ze.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Ze.foreground,
    borderBottomColor: Ze.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: Ze.selection,
      color: Ze.foreground
    }
  }
}, { dark: Ze.dark }), lPe = En.define([
  { tag: R.keyword, color: Ze.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: Ze.variable },
  { tag: [R.propertyName], color: Ze.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: Ze.string },
  { tag: [R.function(R.variableName), R.labelName], color: Ze.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: Ze.constant },
  { tag: [R.definition(R.name), R.separator], color: Ze.variable },
  { tag: [R.className], color: Ze.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: Ze.number },
  { tag: [R.typeName], color: Ze.type, fontStyle: Ze.type },
  { tag: [R.operator, R.operatorKeyword], color: Ze.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: Ze.regexp },
  { tag: [R.meta, R.comment], color: Ze.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: Ze.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: Ze.variable },
  { tag: R.invalid, color: Ze.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), uPe = [
  sPe,
  Eo(lPe)
], qe = {
  name: "solarizedLight",
  dark: !1,
  background: "#FDF6E3",
  foreground: "#586E75",
  selection: "#EEE8D5",
  cursor: "#657B83",
  dropdownBackground: "#FDF6E3",
  dropdownBorder: "#D3AF86",
  activeLine: "#d5bd5c22",
  matchingBracket: "#EEE8D5",
  keyword: "#859900",
  storage: "#586E75",
  variable: "#268BD2",
  parameter: "#268BD2",
  function: "#268BD2",
  string: "#2AA198",
  constant: "#CB4B16",
  type: "#CB4B16",
  class: "#CB4B16",
  number: "#D33682",
  comment: "#93A1A1",
  heading: "#268BD2",
  invalid: "#DC322F",
  regexp: "#DC322F"
}, hPe = ge.theme({
  "&": {
    color: qe.foreground,
    backgroundColor: qe.background
  },
  ".cm-content": { caretColor: qe.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: qe.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: qe.selection },
  ".cm-panels": { backgroundColor: qe.dropdownBackground, color: qe.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: qe.dropdownBackground,
    outline: `1px solid ${qe.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: qe.selection
  },
  ".cm-activeLine": { backgroundColor: qe.activeLine },
  ".cm-selectionMatch": { backgroundColor: qe.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: qe.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: qe.background,
    color: qe.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: qe.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: qe.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${qe.dropdownBorder}`,
    backgroundColor: qe.dropdownBackground,
    color: qe.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: qe.foreground,
    borderBottomColor: qe.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: qe.selection,
      color: qe.foreground
    }
  }
}, { dark: qe.dark }), cPe = En.define([
  { tag: R.keyword, color: qe.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: qe.variable },
  { tag: [R.propertyName], color: qe.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: qe.string },
  { tag: [R.function(R.variableName), R.labelName], color: qe.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: qe.constant },
  { tag: [R.definition(R.name), R.separator], color: qe.variable },
  { tag: [R.className], color: qe.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: qe.number },
  { tag: [R.typeName], color: qe.type, fontStyle: qe.type },
  { tag: [R.operator, R.operatorKeyword], color: qe.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: qe.regexp },
  { tag: [R.meta, R.comment], color: qe.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: qe.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: qe.variable },
  { tag: R.invalid, color: qe.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), fPe = [
  hPe,
  Eo(cPe)
], je = {
  name: "solarizedDark",
  dark: !0,
  background: "#002B36",
  foreground: "#93A1A1",
  selection: "#274642",
  cursor: "#D30102",
  dropdownBackground: "#002B36",
  dropdownBorder: "#2AA19899",
  activeLine: "#005b7022",
  matchingBracket: "#073642",
  keyword: "#859900",
  storage: "#93A1A1",
  variable: "#268BD2",
  parameter: "#268BD2",
  function: "#268BD2",
  string: "#2AA198",
  constant: "#CB4B16",
  type: "#CB4B16",
  class: "#CB4B16",
  number: "#D33682",
  comment: "#586E75",
  heading: "#268BD2",
  invalid: "#DC322F",
  regexp: "#DC322F"
}, dPe = ge.theme({
  "&": {
    color: je.foreground,
    backgroundColor: je.background
  },
  ".cm-content": { caretColor: je.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: je.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: je.selection },
  ".cm-panels": { backgroundColor: je.dropdownBackground, color: je.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: je.dropdownBackground,
    outline: `1px solid ${je.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: je.selection
  },
  ".cm-activeLine": { backgroundColor: je.activeLine },
  ".cm-selectionMatch": { backgroundColor: je.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: je.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: je.background,
    color: je.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: je.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: je.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${je.dropdownBorder}`,
    backgroundColor: je.dropdownBackground,
    color: je.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: je.foreground,
    borderBottomColor: je.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: je.selection,
      color: je.foreground
    }
  }
}, { dark: je.dark }), pPe = En.define([
  { tag: R.keyword, color: je.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: je.variable },
  { tag: [R.propertyName], color: je.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: je.string },
  { tag: [R.function(R.variableName), R.labelName], color: je.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: je.constant },
  { tag: [R.definition(R.name), R.separator], color: je.variable },
  { tag: [R.className], color: je.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: je.number },
  { tag: [R.typeName], color: je.type, fontStyle: je.type },
  { tag: [R.operator, R.operatorKeyword], color: je.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: je.regexp },
  { tag: [R.meta, R.comment], color: je.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: je.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: je.variable },
  { tag: R.invalid, color: je.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), gPe = [
  dPe,
  Eo(pPe)
], Ke = {
  name: "dracula",
  dark: !0,
  background: "#282A36",
  foreground: "#F8F8F2",
  selection: "#44475A",
  cursor: "#F8F8F2",
  dropdownBackground: "#282A36",
  dropdownBorder: "#191A21",
  activeLine: "#53576c22",
  matchingBracket: "#44475A",
  keyword: "#FF79C6",
  storage: "#FF79C6",
  variable: "#F8F8F2",
  parameter: "#F8F8F2",
  function: "#50FA7B",
  string: "#F1FA8C",
  constant: "#BD93F9",
  type: "#8BE9FD",
  class: "#8BE9FD",
  number: "#BD93F9",
  comment: "#6272A4",
  heading: "#BD93F9",
  invalid: "#FF5555",
  regexp: "#F1FA8C"
}, vPe = ge.theme({
  "&": {
    color: Ke.foreground,
    backgroundColor: Ke.background
  },
  ".cm-content": { caretColor: Ke.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Ke.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: Ke.selection },
  ".cm-panels": { backgroundColor: Ke.dropdownBackground, color: Ke.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: Ke.dropdownBackground,
    outline: `1px solid ${Ke.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: Ke.selection
  },
  ".cm-activeLine": { backgroundColor: Ke.activeLine },
  ".cm-selectionMatch": { backgroundColor: Ke.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: Ke.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: Ke.background,
    color: Ke.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: Ke.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: Ke.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${Ke.dropdownBorder}`,
    backgroundColor: Ke.dropdownBackground,
    color: Ke.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Ke.foreground,
    borderBottomColor: Ke.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: Ke.selection,
      color: Ke.foreground
    }
  }
}, { dark: Ke.dark }), OPe = En.define([
  { tag: R.keyword, color: Ke.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: Ke.variable },
  { tag: [R.propertyName], color: Ke.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: Ke.string },
  { tag: [R.function(R.variableName), R.labelName], color: Ke.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: Ke.constant },
  { tag: [R.definition(R.name), R.separator], color: Ke.variable },
  { tag: [R.className], color: Ke.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: Ke.number },
  { tag: [R.typeName], color: Ke.type, fontStyle: Ke.type },
  { tag: [R.operator, R.operatorKeyword], color: Ke.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: Ke.regexp },
  { tag: [R.meta, R.comment], color: Ke.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: Ke.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: Ke.variable },
  { tag: R.invalid, color: Ke.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), mPe = [
  vPe,
  Eo(OPe)
], Je = {
  name: "githubLight",
  dark: !1,
  background: "#fff",
  foreground: "#444d56",
  selection: "#0366d625",
  cursor: "#044289",
  dropdownBackground: "#fff",
  dropdownBorder: "#e1e4e8",
  activeLine: "#c6c6c622",
  matchingBracket: "#34d05840",
  keyword: "#d73a49",
  storage: "#d73a49",
  variable: "#e36209",
  parameter: "#24292e",
  function: "#005cc5",
  string: "#032f62",
  constant: "#005cc5",
  type: "#005cc5",
  class: "#6f42c1",
  number: "#005cc5",
  comment: "#6a737d",
  heading: "#005cc5",
  invalid: "#cb2431",
  regexp: "#032f62"
}, EPe = ge.theme({
  "&": {
    color: Je.foreground,
    backgroundColor: Je.background
  },
  ".cm-content": { caretColor: Je.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Je.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: Je.selection },
  ".cm-panels": { backgroundColor: Je.dropdownBackground, color: Je.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: Je.dropdownBackground,
    outline: `1px solid ${Je.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: Je.selection
  },
  ".cm-activeLine": { backgroundColor: Je.activeLine },
  ".cm-selectionMatch": { backgroundColor: Je.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: Je.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: Je.background,
    color: Je.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: Je.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: Je.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${Je.dropdownBorder}`,
    backgroundColor: Je.dropdownBackground,
    color: Je.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Je.foreground,
    borderBottomColor: Je.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: Je.selection,
      color: Je.foreground
    }
  }
}, { dark: Je.dark }), bPe = En.define([
  { tag: R.keyword, color: Je.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: Je.variable },
  { tag: [R.propertyName], color: Je.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: Je.string },
  { tag: [R.function(R.variableName), R.labelName], color: Je.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: Je.constant },
  { tag: [R.definition(R.name), R.separator], color: Je.variable },
  { tag: [R.className], color: Je.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: Je.number },
  { tag: [R.typeName], color: Je.type, fontStyle: Je.type },
  { tag: [R.operator, R.operatorKeyword], color: Je.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: Je.regexp },
  { tag: [R.meta, R.comment], color: Je.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: Je.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: Je.variable },
  { tag: R.invalid, color: Je.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), SPe = [
  EPe,
  Eo(bPe)
], et = {
  name: "tokyoNight",
  dark: !0,
  background: "#1a1b26",
  foreground: "#787c99",
  selection: "#515c7e40",
  cursor: "#c0caf5",
  dropdownBackground: "#1a1b26",
  dropdownBorder: "#787c99",
  activeLine: "#43455c22",
  matchingBracket: "#16161e",
  keyword: "#bb9af7",
  storage: "#bb9af7",
  variable: "#c0caf5",
  parameter: "#c0caf5",
  function: "#7aa2f7",
  string: "#9ece6a",
  constant: "#bb9af7",
  type: "#0db9d7",
  class: "#c0caf5",
  number: "#ff9e64",
  comment: "#444b6a",
  heading: "#89ddff",
  invalid: "#ff5370",
  regexp: "#b4f9f8"
}, TPe = ge.theme({
  "&": {
    color: et.foreground,
    backgroundColor: et.background
  },
  ".cm-content": { caretColor: et.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: et.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: et.selection },
  ".cm-panels": { backgroundColor: et.dropdownBackground, color: et.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: et.dropdownBackground,
    outline: `1px solid ${et.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: et.selection
  },
  ".cm-activeLine": { backgroundColor: et.activeLine },
  ".cm-selectionMatch": { backgroundColor: et.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: et.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: et.background,
    color: et.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: et.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: et.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${et.dropdownBorder}`,
    backgroundColor: et.dropdownBackground,
    color: et.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: et.foreground,
    borderBottomColor: et.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: et.selection,
      color: et.foreground
    }
  }
}, { dark: et.dark }), yPe = En.define([
  { tag: R.keyword, color: et.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: et.variable },
  { tag: [R.propertyName], color: et.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: et.string },
  { tag: [R.function(R.variableName), R.labelName], color: et.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: et.constant },
  { tag: [R.definition(R.name), R.separator], color: et.variable },
  { tag: [R.className], color: et.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: et.number },
  { tag: [R.typeName], color: et.type, fontStyle: et.type },
  { tag: [R.operator, R.operatorKeyword], color: et.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: et.regexp },
  { tag: [R.meta, R.comment], color: et.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: et.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: et.variable },
  { tag: R.invalid, color: et.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), RPe = [
  TPe,
  Eo(yPe)
], tt = {
  name: "tokyoNightStorm",
  dark: !0,
  background: "#24283b",
  foreground: "#7982a9",
  selection: "#6f7bb630",
  cursor: "#c0caf5",
  dropdownBackground: "#24283b",
  dropdownBorder: "#7982a9",
  activeLine: "#4d547722",
  matchingBracket: "#1f2335",
  keyword: "#bb9af7",
  storage: "#bb9af7",
  variable: "#c0caf5",
  parameter: "#c0caf5",
  function: "#7aa2f7",
  string: "#9ece6a",
  constant: "#bb9af7",
  type: "#2ac3de",
  class: "#c0caf5",
  number: "#ff9e64",
  comment: "#565f89",
  heading: "#89ddff",
  invalid: "#ff5370",
  regexp: "#b4f9f8"
}, APe = ge.theme({
  "&": {
    color: tt.foreground,
    backgroundColor: tt.background
  },
  ".cm-content": { caretColor: tt.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: tt.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: tt.selection },
  ".cm-panels": { backgroundColor: tt.dropdownBackground, color: tt.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: tt.dropdownBackground,
    outline: `1px solid ${tt.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: tt.selection
  },
  ".cm-activeLine": { backgroundColor: tt.activeLine },
  ".cm-selectionMatch": { backgroundColor: tt.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: tt.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: tt.background,
    color: tt.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: tt.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: tt.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${tt.dropdownBorder}`,
    backgroundColor: tt.dropdownBackground,
    color: tt.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tt.foreground,
    borderBottomColor: tt.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: tt.selection,
      color: tt.foreground
    }
  }
}, { dark: tt.dark }), CPe = En.define([
  { tag: R.keyword, color: tt.keyword },
  { tag: [R.name, R.deleted, R.character, R.macroName], color: tt.variable },
  { tag: [R.propertyName], color: tt.function },
  { tag: [R.processingInstruction, R.string, R.inserted, R.special(R.string)], color: tt.string },
  { tag: [R.function(R.variableName), R.labelName], color: tt.function },
  { tag: [R.color, R.constant(R.name), R.standard(R.name)], color: tt.constant },
  { tag: [R.definition(R.name), R.separator], color: tt.variable },
  { tag: [R.className], color: tt.class },
  { tag: [R.number, R.changed, R.annotation, R.modifier, R.self, R.namespace], color: tt.number },
  { tag: [R.typeName], color: tt.type, fontStyle: tt.type },
  { tag: [R.operator, R.operatorKeyword], color: tt.keyword },
  { tag: [R.url, R.escape, R.regexp, R.link], color: tt.regexp },
  { tag: [R.meta, R.comment], color: tt.comment },
  { tag: R.strong, fontWeight: "bold" },
  { tag: R.emphasis, fontStyle: "italic" },
  { tag: R.link, textDecoration: "underline" },
  { tag: R.heading, fontWeight: "bold", color: tt.heading },
  { tag: [R.atom, R.bool, R.special(R.variableName)], color: tt.variable },
  { tag: R.invalid, color: tt.invalid },
  { tag: R.strikethrough, textDecoration: "line-through" }
]), _Pe = [
  APe,
  Eo(CPe)
];
class Db {
  /**
  @internal
  */
  constructor(e, t, i, n, a, o, s, l, u, h = 0, c) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = n, this.pos = a, this.score = o, this.buffer = s, this.bufferBase = l, this.curContext = u, this.lookAhead = h, this.parent = c;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, i = 0) {
    let n = e.parser.context;
    return new Db(e, [], t, i, i, 0, [], 0, n ? new BG(n, n.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let i = e >> 19, n = e & 65535, { parser: a } = this.p, o = a.dynamicPrecedence(n);
    if (o && (this.score += o), i == 0) {
      this.pushState(a.getGoto(this.state, n, !0), this.reducePos), n < a.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, 4, !0), this.reduceContext(n, this.reducePos);
      return;
    }
    let s = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), l = s ? this.stack[s - 2] : this.p.ranges[0].from, u = this.reducePos - l;
    u >= 2e3 && !(!((t = this.p.parser.nodeSet.types[n]) === null || t === void 0) && t.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = u));
    let h = s ? this.stack[s - 1] : 0, c = this.bufferBase + this.buffer.length - h;
    if (n < a.minRepeatTerm || e & 131072) {
      let f = a.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, l, f, c + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[s];
    else {
      let f = this.stack[s - 3];
      this.state = a.getGoto(f, n, !0);
    }
    for (; this.stack.length > s; )
      this.stack.pop();
    this.reduceContext(n, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, i, n = 4, a = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, s = this.buffer.length;
      if (s == 0 && o.parent && (s = o.bufferBase - o.parent.bufferBase, o = o.parent), s > 0 && o.buffer[s - 4] == 0 && o.buffer[s - 1] > -1) {
        if (t == i)
          return;
        if (o.buffer[s - 2] >= t) {
          o.buffer[s - 2] = i;
          return;
        }
      }
    }
    if (!a || this.pos == i)
      this.buffer.push(e, t, i, n);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > i; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, n > 4 && (n -= 4);
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = i, this.buffer[o + 3] = n;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, i) {
    let n = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(t, n), t <= this.p.parser.maxNode && this.buffer.push(t, n, i, 4);
    else {
      let a = e, { parser: o } = this.p;
      (i > this.pos || t <= o.maxNode) && (this.pos = i, o.stateFlag(
        a,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(a, n), this.shiftContext(t, n), t <= o.maxNode && this.buffer.push(t, n, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + e.length, this.pushState(t, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), n = e.bufferBase + t;
    for (; e && n == e.bufferBase; )
      e = e.parent;
    return new Db(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new IPe(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let n = [];
      for (let a = 0, o; a < t.length; a += 2)
        (o = t[a + 1]) != this.state && this.p.parser.hasAction(o, e) && n.push(t[a], o);
      if (this.stack.length < 120)
        for (let a = 0; n.length < 8 && a < t.length; a += 2) {
          let o = t[a + 1];
          n.some((s, l) => l & 1 && s == o) || n.push(t[a], o);
        }
      t = n;
    }
    let i = [];
    for (let n = 0; n < t.length && i.length < 4; n += 2) {
      let a = t[n + 1];
      if (a == this.state)
        continue;
      let o = this.split();
      o.pushState(a, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(t[n], this.pos), o.score -= 200, i.push(o);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(t & 65536))
      return !1;
    if (!e.validAction(this.state, t)) {
      let i = t >> 19, n = t & 65535, a = this.stack.length - i * 3;
      if (a < 0 || e.getGoto(this.stack[a], n, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        t = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], i = (n, a) => {
      if (!t.includes(n))
        return t.push(n), e.allActions(n, (o) => {
          if (!(o & 393216))
            if (o & 65536) {
              let s = (o >> 19) - a;
              if (s > 1) {
                let l = o & 65535, u = this.stack.length - s * 3;
                if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                  return s << 19 | 65536 | l;
              }
            } else {
              let s = i(o, a + 1);
              if (s != null)
                return s;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new BG(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class BG {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class IPe {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = n;
  }
}
class Mb {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new Mb(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new Mb(this.stack, this.pos, this.index);
  }
}
function zd(r, e = Uint16Array) {
  if (typeof r != "string")
    return r;
  let t = null;
  for (let i = 0, n = 0; i < r.length; ) {
    let a = 0;
    for (; ; ) {
      let o = r.charCodeAt(i++), s = !1;
      if (o == 126) {
        a = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, s = !0), a += l, s)
        break;
      a *= 46;
    }
    t ? t[n++] = a : t = new e(a);
  }
  return t;
}
class $m {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const VG = new $m();
class xPe {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = VG, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let i = this.range, n = this.rangeIndex, a = this.pos + e;
    for (; a < i.from; ) {
      if (!n)
        return null;
      let o = this.ranges[--n];
      a -= i.from - o.to, i = o;
    }
    for (; t < 0 ? a > i.to : a >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let o = this.ranges[++n];
      a += o.from - i.to, i = o;
    }
    return a;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, i, n;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, n = this.chunk.charCodeAt(t);
    else {
      let a = this.resolveOffset(e, 1);
      if (a == null)
        return -1;
      if (i = a, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, s = this.range;
        for (; s.to <= i; )
          s = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > s.to && (this.chunk2 = this.chunk2.slice(0, s.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = VG, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= t)
        break;
      n.to > e && (i += this.input.read(Math.max(n.from, e), Math.min(n.to, t)));
    }
    return i;
  }
}
class Bc {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: i } = t.p;
    p9(this.data, e, t, this.id, i.data, i.tokenPrecTable);
  }
}
Bc.prototype.contextual = Bc.prototype.fallback = Bc.prototype.extend = !1;
class kb {
  constructor(e, t, i) {
    this.precTable = t, this.elseToken = i, this.data = typeof e == "string" ? zd(e) : e;
  }
  token(e, t) {
    let i = e.pos, n = 0;
    for (; ; ) {
      let a = e.next < 0, o = e.resolveOffset(1, 1);
      if (p9(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (a || n++, o == null)
        break;
      e.reset(o, e.token);
    }
    n && (e.reset(i, e.token), e.acceptToken(this.elseToken, n));
  }
}
kb.prototype.contextual = Bc.prototype.fallback = Bc.prototype.extend = !1;
class wi {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function p9(r, e, t, i, n, a) {
  let o = 0, s = 1 << i, { dialect: l } = t.p.parser;
  e:
    for (; s & r[o]; ) {
      let u = r[o + 1];
      for (let d = o + 3; d < u; d += 2)
        if ((r[d + 1] & s) > 0) {
          let p = r[d];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || wPe(p, e.token.value, n, a))) {
            e.acceptToken(p);
            break;
          }
        }
      let h = e.next, c = 0, f = r[o + 2];
      if (e.next < 0 && f > c && r[u + f * 3 - 3] == 65535 && r[u + f * 3 - 3] == 65535) {
        o = r[u + f * 3 - 1];
        continue e;
      }
      for (; c < f; ) {
        let d = c + f >> 1, p = u + d + (d << 1), g = r[p], v = r[p + 1] || 65536;
        if (h < g)
          f = d;
        else if (h >= v)
          c = d + 1;
        else {
          o = r[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function FG(r, e, t) {
  for (let i = e, n; (n = r[i]) != 65535; i++)
    if (n == t)
      return i - e;
  return -1;
}
function wPe(r, e, t, i) {
  let n = FG(t, i, e);
  return n < 0 || FG(t, i, r) < n;
}
const Ki = typeof process < "u" && { NODE_ENV: "production" } && /\bparse\b/.test({ NODE_ENV: "production" }.LOG);
let LR = null;
function XG(r, e, t) {
  let i = r.cursor(Bt.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(r.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : r.length;
      }
}
class PPe {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? XG(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? XG(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], n = this.index[t];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let a = i.children[n], o = this.start[t] + i.positions[n];
      if (o > e)
        return this.nextStart = o, null;
      if (a instanceof er) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let s = o + a.length;
          if (s <= this.safeTo) {
            let l = a.prop(ht.lookAhead);
            if (!l || s + l < this.fragment.to)
              return a;
          }
        }
        this.index[t]++, o + a.length >= Math.max(this.safeFrom, e) && (this.trees.push(a), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + a.length;
    }
  }
}
class NPe {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new $m());
  }
  getActions(e) {
    let t = 0, i = null, { parser: n } = e.p, { tokenizers: a } = n, o = n.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), s = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < a.length; u++) {
      if (!(1 << u & o))
        continue;
      let h = a[u], c = this.tokens[u];
      if (!(i && !h.fallback) && ((h.contextual || c.start != e.pos || c.mask != o || c.context != s) && (this.updateCachedToken(c, h, e), c.mask = o, c.context = s), c.lookAhead > c.end + 25 && (l = Math.max(c.lookAhead, l)), c.value != 0)) {
        let f = t;
        if (c.extended > -1 && (t = this.addActions(e, c.extended, c.end, t)), t = this.addActions(e, c.value, c.end, t), !h.extend && (i = c, t > f))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !i && e.pos == this.stream.end && (i = new $m(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new $m(), { pos: i, p: n } = e;
    return t.start = i, t.end = Math.min(i + 1, n.stream.end), t.value = i == n.stream.end ? n.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    let n = this.stream.clipPos(i.pos);
    if (t.token(this.stream.reset(n, e), i), e.value > -1) {
      let { parser: a } = i.p;
      for (let o = 0; o < a.specialized.length; o++)
        if (a.specialized[o] == e.value) {
          let s = a.specializers[o](this.stream.read(e.start, e.end), i);
          if (s >= 0 && i.p.parser.dialect.allows(s >> 1)) {
            s & 1 ? e.extended = s >> 1 : e.value = s >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(n + 1);
  }
  putAction(e, t, i, n) {
    for (let a = 0; a < n; a += 3)
      if (this.actions[a] == e)
        return n;
    return this.actions[n++] = e, this.actions[n++] = t, this.actions[n++] = i, n;
  }
  addActions(e, t, i, n) {
    let { state: a } = e, { parser: o } = e.p, { data: s } = o;
    for (let l = 0; l < 2; l++)
      for (let u = o.stateSlot(
        a,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (s[u] == 65535)
          if (s[u + 1] == 1)
            u = Io(s, u + 2);
          else {
            n == 0 && s[u + 1] == 2 && (n = this.putAction(Io(s, u + 2), t, i, n));
            break;
          }
        s[u] == t && (n = this.putAction(Io(s, u + 1), t, i, n));
      }
    return n;
  }
}
class LPe {
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new xPe(t, n), this.tokens = new NPe(e, this.stream), this.topTerm = e.top[1];
    let { from: a } = n[0];
    this.stacks = [Db.start(this, e.top[0], a)], this.fragments = i.length && this.stream.end - a > e.bufferLength * 4 ? new PPe(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], n, a;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let s = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, s.pos > t)
          i.push(s);
        else {
          if (this.advanceStack(s, i, e))
            continue;
          {
            n || (n = [], a = []), n.push(s);
            let l = this.tokens.getMainToken(s);
            a.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = n && MPe(n);
      if (o)
        return Ki && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw Ki && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let o = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, a, i);
      if (o)
        return Ki && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((s, l) => l.score - s.score); i.length > o; )
          i.pop();
      i.some((s) => s.reducePos > t) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let o = 0; o < i.length - 1; o++) {
          let s = i[o];
          for (let l = o + 1; l < i.length; l++) {
            let u = i[l];
            if (s.sameState(u) || s.buffer.length > 500 && u.buffer.length > 500)
              if ((s.score - u.score || s.buffer.length - u.buffer.length) > 0)
                i.splice(l--, 1);
              else {
                i.splice(o--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let n = e.pos, { parser: a } = this, o = Ki ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, h = u ? e.curContext.hash : 0;
      for (let c = this.fragments.nodeAt(n); c; ) {
        let f = this.parser.nodeSet.types[c.type.id] == c.type ? a.getGoto(e.state, c.type.id) : -1;
        if (f > -1 && c.length && (!u || (c.prop(ht.contextHash) || 0) == h))
          return e.useNode(c, f), Ki && console.log(o + this.stackID(e) + ` (via reuse of ${a.getName(c.type.id)})`), !0;
        if (!(c instanceof er) || c.children.length == 0 || c.positions[0] > 0)
          break;
        let d = c.children[0];
        if (d instanceof er && c.positions[0] == 0)
          c = d;
        else
          break;
      }
    }
    let s = a.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (s > 0)
      return e.reduce(s), Ki && console.log(o + this.stackID(e) + ` (via always-reduce ${a.getName(
        s & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let h = l[u++], c = l[u++], f = l[u++], d = u == l.length || !i, p = d ? e : e.split();
      if (p.apply(h, c, f), Ki && console.log(o + this.stackID(p) + ` (via ${h & 65536 ? `reduce of ${a.getName(
        h & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${a.getName(c)} @ ${n}${p == e ? "" : ", split"})`), d)
        return !0;
      p.pos > n ? t.push(p) : i.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return YG(e, t), !0;
    }
  }
  runRecovery(e, t, i) {
    let n = null, a = !1;
    for (let o = 0; o < e.length; o++) {
      let s = e[o], l = t[o << 1], u = t[(o << 1) + 1], h = Ki ? this.stackID(s) + " -> " : "";
      if (s.deadEnd && (a || (a = !0, s.restart(), Ki && console.log(h + this.stackID(s) + " (restarted)"), this.advanceFully(s, i))))
        continue;
      let c = s.split(), f = h;
      for (let d = 0; c.forceReduce() && d < 10 && (Ki && console.log(f + this.stackID(c) + " (via force-reduce)"), !this.advanceFully(c, i)); d++)
        Ki && (f = this.stackID(c) + " -> ");
      for (let d of s.recoverByInsert(l))
        Ki && console.log(h + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, i);
      this.stream.end > s.pos ? (u == s.pos && (u++, l = 0), s.recoverByDelete(l, u), Ki && console.log(h + this.stackID(s) + ` (via recover-delete ${this.parser.getName(l)})`), YG(s, i)) : (!n || n.score < s.score) && (n = s);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), er.build({
      buffer: Mb.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (LR || (LR = /* @__PURE__ */ new WeakMap())).get(e);
    return t || LR.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function YG(r, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == r.pos && i.sameState(r)) {
      e[t].score < r.score && (e[t] = r);
      return;
    }
  }
  e.push(r);
}
class DPe {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const DR = (r) => r;
class mP {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || DR, this.reduce = e.reduce || DR, this.reuse = e.reuse || DR, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class fo extends sZ {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let s = 0; s < e.repeatNodeCount; s++)
      t.push("");
    let i = Object.keys(e.topRules).map((s) => e.topRules[s][1]), n = [];
    for (let s = 0; s < t.length; s++)
      n.push([]);
    function a(s, l, u) {
      n[s].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let s of e.nodeProps) {
        let l = s[0];
        typeof l == "string" && (l = ht[l]);
        for (let u = 1; u < s.length; ) {
          let h = s[u++];
          if (h >= 0)
            a(h, l, s[u++]);
          else {
            let c = s[u + -h];
            for (let f = -h; f > 0; f--)
              a(s[u++], l, c);
            u++;
          }
        }
      }
    this.nodeSet = new Uw(t.map((s, l) => On.define({
      name: l >= this.minRepeatTerm ? void 0 : s,
      id: l,
      props: n[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = rZ;
    let o = zd(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let s = 0; s < this.specializerSpecs.length; s++)
      this.specialized[s] = this.specializerSpecs[s].term;
    this.specializers = this.specializerSpecs.map(HG), this.states = zd(e.states, Uint32Array), this.data = zd(e.stateData), this.goto = zd(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((s) => typeof s == "number" ? new Bc(o, s) : s), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let n = new LPe(this, e, t, i);
    for (let a of this.wrappers)
      n = a(n, e, t, i);
    return n;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, i = !1) {
    let n = this.goto;
    if (t >= n[0])
      return -1;
    for (let a = n[t + 1]; ; ) {
      let o = n[a++], s = o & 1, l = n[a++];
      if (s && i)
        return l;
      for (let u = a + (o >> 1); a < u; a++)
        if (n[a] == e)
          return l;
      if (s)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let a = this.stateSlot(
        e,
        n ? 2 : 1
        /* ParseState.Actions */
      ), o; ; a += 3) {
        if ((o = i[a]) == 65535)
          if (i[a + 1] == 1)
            o = i[a = Io(i, a + 2)];
          else {
            if (i[a + 1] == 2)
              return Io(i, a + 2);
            break;
          }
        if (o == t || o == 0)
          return Io(i, a + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (i) => i == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), n = i ? t(i) : void 0;
    for (let a = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); n == null; a += 3) {
      if (this.data[a] == 65535)
        if (this.data[a + 1] == 1)
          a = Io(this.data, a + 2);
        else
          break;
      n = t(Io(this.data, a + 1));
    }
    return n;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Io(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let n = this.data[i + 1];
        t.some((a, o) => o & 1 && a == n) || t.push(this.data[i], n);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(fo.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let n = e.tokenizers.find((a) => a.from == i);
      return n ? n.to : i;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let a = e.specializers.find((s) => s.from == i.external);
      if (!a)
        return i;
      let o = Object.assign(Object.assign({}, i), { external: a.to });
      return t.specializers[n] = HG(o), o;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => !1);
    if (e)
      for (let a of e.split(" ")) {
        let o = t.indexOf(a);
        o >= 0 && (i[o] = !0);
      }
    let n = null;
    for (let a = 0; a < t.length; a++)
      if (!i[a])
        for (let o = this.dialects[t[a]], s; (s = this.data[o++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[s] = 1;
    return new DPe(e, i, n);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new fo(e);
  }
}
function Io(r, e) {
  return r[e] | r[e + 1] << 16;
}
function MPe(r) {
  let e = null;
  for (let t of r) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function HG(r) {
  if (r.external) {
    let e = r.extend ? 1 : 0;
    return (t, i) => r.external(t, i) << 1 | e;
  }
  return r.get;
}
const kPe = 54, QPe = 1, UPe = 55, $Pe = 2, GPe = 56, BPe = 3, WG = 4, VPe = 5, Qb = 6, g9 = 7, v9 = 8, O9 = 9, m9 = 10, FPe = 11, XPe = 12, YPe = 13, MR = 57, HPe = 14, zG = 58, E9 = 20, WPe = 22, b9 = 23, zPe = 24, s1 = 26, S9 = 27, ZPe = 28, qPe = 31, jPe = 34, KPe = 36, JPe = 37, eNe = 0, tNe = 1, rNe = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, iNe = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, ZG = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function nNe(r) {
  return r == 45 || r == 46 || r == 58 || r >= 65 && r <= 90 || r == 95 || r >= 97 && r <= 122 || r >= 161;
}
function T9(r) {
  return r == 9 || r == 10 || r == 13 || r == 32;
}
let qG = null, jG = null, KG = 0;
function l1(r, e) {
  let t = r.pos + e;
  if (KG == t && jG == r)
    return qG;
  let i = r.peek(e);
  for (; T9(i); )
    i = r.peek(++e);
  let n = "";
  for (; nNe(i); )
    n += String.fromCharCode(i), i = r.peek(++e);
  return jG = r, KG = t, qG = n ? n.toLowerCase() : i == aNe || i == oNe ? void 0 : null;
}
const y9 = 60, Ub = 62, EP = 47, aNe = 63, oNe = 33, sNe = 45;
function JG(r, e) {
  this.name = r, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < r.length; t++)
    this.hash += (this.hash << 4) + r.charCodeAt(t) + (r.charCodeAt(t) << 8);
}
const lNe = [Qb, m9, g9, v9, O9], uNe = new mP({
  start: null,
  shift(r, e, t, i) {
    return lNe.indexOf(e) > -1 ? new JG(l1(i, 1) || "", r) : r;
  },
  reduce(r, e) {
    return e == E9 && r ? r.parent : r;
  },
  reuse(r, e, t, i) {
    let n = e.type.id;
    return n == Qb || n == KPe ? new JG(l1(i, 1) || "", r) : r;
  },
  hash(r) {
    return r ? r.hash : 0;
  },
  strict: !1
}), hNe = new wi((r, e) => {
  if (r.next != y9) {
    r.next < 0 && e.context && r.acceptToken(MR);
    return;
  }
  r.advance();
  let t = r.next == EP;
  t && r.advance();
  let i = l1(r, 0);
  if (i === void 0)
    return;
  if (!i)
    return r.acceptToken(t ? HPe : Qb);
  let n = e.context ? e.context.name : null;
  if (t) {
    if (i == n)
      return r.acceptToken(FPe);
    if (n && iNe[n])
      return r.acceptToken(MR, -2);
    if (e.dialectEnabled(eNe))
      return r.acceptToken(XPe);
    for (let a = e.context; a; a = a.parent)
      if (a.name == i)
        return;
    r.acceptToken(YPe);
  } else {
    if (i == "script")
      return r.acceptToken(g9);
    if (i == "style")
      return r.acceptToken(v9);
    if (i == "textarea")
      return r.acceptToken(O9);
    if (rNe.hasOwnProperty(i))
      return r.acceptToken(m9);
    n && ZG[n] && ZG[n][i] ? r.acceptToken(MR, -1) : r.acceptToken(Qb);
  }
}, { contextual: !0 }), cNe = new wi((r) => {
  for (let e = 0, t = 0; ; t++) {
    if (r.next < 0) {
      t && r.acceptToken(zG);
      break;
    }
    if (r.next == sNe)
      e++;
    else if (r.next == Ub && e >= 2) {
      t > 3 && r.acceptToken(zG, -2);
      break;
    } else
      e = 0;
    r.advance();
  }
});
function fNe(r) {
  for (; r; r = r.parent)
    if (r.name == "svg" || r.name == "math")
      return !0;
  return !1;
}
const dNe = new wi((r, e) => {
  if (r.next == EP && r.peek(1) == Ub) {
    let t = e.dialectEnabled(tNe) || fNe(e.context);
    r.acceptToken(t ? VPe : WG, 2);
  } else
    r.next == Ub && r.acceptToken(WG, 1);
});
function bP(r, e, t) {
  let i = 2 + r.length;
  return new wi((n) => {
    for (let a = 0, o = 0, s = 0; ; s++) {
      if (n.next < 0) {
        s && n.acceptToken(e);
        break;
      }
      if (a == 0 && n.next == y9 || a == 1 && n.next == EP || a >= 2 && a < i && n.next == r.charCodeAt(a - 2))
        a++, o++;
      else if ((a == 2 || a == i) && T9(n.next))
        o++;
      else if (a == i && n.next == Ub) {
        s > o ? n.acceptToken(e, -o) : n.acceptToken(t, -(o - 2));
        break;
      } else if ((n.next == 10 || n.next == 13) && s) {
        n.acceptToken(e, 1);
        break;
      } else
        a = o = 0;
      n.advance();
    }
  });
}
const pNe = bP("script", kPe, QPe), gNe = bP("style", UPe, $Pe), vNe = bP("textarea", GPe, BPe), ONe = Rl({
  "Text RawText": R.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": R.angleBracket,
  TagName: R.tagName,
  "MismatchedCloseTag/TagName": [R.tagName, R.invalid],
  AttributeName: R.attributeName,
  "AttributeValue UnquotedAttributeValue": R.attributeValue,
  Is: R.definitionOperator,
  "EntityReference CharacterReference": R.character,
  Comment: R.blockComment,
  ProcessingInst: R.processingInstruction,
  DoctypeDecl: R.documentMeta
}), mNe = fo.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: uNe,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [ONe],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [pNe, gNe, vNe, dNe, hNe, cNe, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function R9(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i of r.getChildren(b9)) {
    let n = i.getChild(zPe), a = i.getChild(s1) || i.getChild(S9);
    n && (t[e.read(n.from, n.to)] = a ? a.type.id == s1 ? e.read(a.from + 1, a.to - 1) : e.read(a.from, a.to) : "");
  }
  return t;
}
function eB(r, e) {
  let t = r.getChild(WPe);
  return t ? e.read(t.from, t.to) : " ";
}
function kR(r, e, t) {
  let i;
  for (let n of t)
    if (!n.attrs || n.attrs(i || (i = R9(r.node.parent.firstChild, e))))
      return { parser: n.parser };
  return null;
}
function ENe(r = [], e = []) {
  let t = [], i = [], n = [], a = [];
  for (let s of r)
    (s.tag == "script" ? t : s.tag == "style" ? i : s.tag == "textarea" ? n : a).push(s);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let s of e)
    (o[s.name] || (o[s.name] = [])).push(s);
  return N1e((s, l) => {
    let u = s.type.id;
    if (u == ZPe)
      return kR(s, l, t);
    if (u == qPe)
      return kR(s, l, i);
    if (u == jPe)
      return kR(s, l, n);
    if (u == E9 && a.length) {
      let h = s.node, c = h.firstChild, f = c && eB(c, l), d;
      if (f) {
        for (let p of a)
          if (p.tag == f && (!p.attrs || p.attrs(d || (d = R9(h, l))))) {
            let g = h.lastChild;
            return { parser: p.parser, overlay: [{ from: c.to, to: g.type.id == JPe ? g.from : h.to }] };
          }
      }
    }
    if (o && u == b9) {
      let h = s.node, c;
      if (c = h.firstChild) {
        let f = o[l.read(c.from, c.to)];
        if (f)
          for (let d of f) {
            if (d.tagName && d.tagName != eB(h.parent, l))
              continue;
            let p = h.lastChild;
            if (p.type.id == s1) {
              let g = p.from + 1, v = p.lastChild, O = p.to - (v && v.isError ? 0 : 1);
              if (O > g)
                return { parser: d.parser, overlay: [{ from: g, to: O }] };
            } else if (p.type.id == S9)
              return { parser: d.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const bNe = 96, tB = 1, SNe = 97, TNe = 98, rB = 2, A9 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], yNe = 58, RNe = 40, C9 = 95, ANe = 91, Gm = 45, CNe = 46, _Ne = 35, INe = 37;
function $b(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 161;
}
function xNe(r) {
  return r >= 48 && r <= 57;
}
const wNe = new wi((r, e) => {
  for (let t = !1, i = 0, n = 0; ; n++) {
    let { next: a } = r;
    if ($b(a) || a == Gm || a == C9 || t && xNe(a))
      !t && (a != Gm || n > 0) && (t = !0), i === n && a == Gm && i++, r.advance();
    else {
      t && r.acceptToken(a == RNe ? SNe : i == 2 && e.canShift(rB) ? rB : TNe);
      break;
    }
  }
}), PNe = new wi((r) => {
  if (A9.includes(r.peek(-1))) {
    let { next: e } = r;
    ($b(e) || e == C9 || e == _Ne || e == CNe || e == ANe || e == yNe || e == Gm) && r.acceptToken(bNe);
  }
}), NNe = new wi((r) => {
  if (!A9.includes(r.peek(-1))) {
    let { next: e } = r;
    if (e == INe && (r.advance(), r.acceptToken(tB)), $b(e)) {
      do
        r.advance();
      while ($b(r.next));
      r.acceptToken(tB);
    }
  }
}), LNe = Rl({
  "AtKeyword import charset namespace keyframes media supports": R.definitionKeyword,
  "from to selector": R.keyword,
  NamespaceName: R.namespace,
  KeyframeName: R.labelName,
  KeyframeRangeName: R.operatorKeyword,
  TagName: R.tagName,
  ClassName: R.className,
  PseudoClassName: R.constant(R.className),
  IdName: R.labelName,
  "FeatureName PropertyName": R.propertyName,
  AttributeName: R.attributeName,
  NumberLiteral: R.number,
  KeywordQuery: R.keyword,
  UnaryQueryOp: R.operatorKeyword,
  "CallTag ValueName": R.atom,
  VariableName: R.variableName,
  Callee: R.operatorKeyword,
  Unit: R.unit,
  "UniversalSelector NestingSelector": R.definitionOperator,
  MatchOp: R.compareOperator,
  "ChildOp SiblingOp, LogicOp": R.logicOperator,
  BinOp: R.arithmeticOperator,
  Important: R.modifier,
  Comment: R.blockComment,
  ColorLiteral: R.color,
  "ParenthesizedContent StringLiteral": R.string,
  ":": R.punctuation,
  "PseudoOp #": R.derefOperator,
  "; ,": R.separator,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace
}), DNe = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, MNe = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, kNe = { __proto__: null, not: 128, only: 128 }, QNe = fo.deserialize({
  version: 14,
  states: "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c",
  stateData: ":k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~",
  goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`",
  nodeNames: " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 114,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [LNe],
  skippedNodes: [0, 3, 85],
  repeatNodeCount: 10,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [PNe, NNe, wNe, 1, 2, 3, 4, new kb("m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~", 28, 102)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 97, get: (r) => DNe[r] || -1 }, { term: 56, get: (r) => MNe[r] || -1 }, { term: 98, get: (r) => kNe[r] || -1 }],
  tokenPrec: 1169
});
let QR = null;
function UR() {
  if (!QR && typeof document == "object" && document.body) {
    let r = [];
    for (let e in document.body.style)
      /[A-Z]|^-|^(item|length)$/.test(e) || r.push(e);
    QR = r.sort().map((e) => ({ type: "property", label: e }));
  }
  return QR || [];
}
const iB = /* @__PURE__ */ [
  "active",
  "after",
  "before",
  "checked",
  "default",
  "disabled",
  "empty",
  "enabled",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "lang",
  "last-child",
  "last-of-type",
  "link",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-of-type",
  "only-child",
  "optional",
  "out-of-range",
  "placeholder",
  "read-only",
  "read-write",
  "required",
  "root",
  "selection",
  "target",
  "valid",
  "visited"
].map((r) => ({ type: "class", label: r })), nB = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((r) => ({ type: "keyword", label: r })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((r) => ({ type: "constant", label: r }))), UNe = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((r) => ({ type: "type", label: r })), ms = /^[\w-]*/, $Ne = (r) => {
  let { state: e, pos: t } = r, i = qt(e).resolveInner(t, -1);
  if (i.name == "PropertyName")
    return { from: i.from, options: UR(), validFor: ms };
  if (i.name == "ValueName")
    return { from: i.from, options: nB, validFor: ms };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: iB, validFor: ms };
  if (i.name == "TagName") {
    for (let { parent: o } = i; o; o = o.parent)
      if (o.name == "Block")
        return { from: i.from, options: UR(), validFor: ms };
    return { from: i.from, options: UNe, validFor: ms };
  }
  if (!r.explicit)
    return null;
  let n = i.resolve(t), a = n.childBefore(t);
  return a && a.name == ":" && n.name == "PseudoClassSelector" ? { from: t, options: iB, validFor: ms } : a && a.name == ":" && n.name == "Declaration" || n.name == "ArgList" ? { from: t, options: nB, validFor: ms } : n.name == "Block" ? { from: t, options: UR(), validFor: ms } : null;
}, u1 = /* @__PURE__ */ co.define({
  parser: /* @__PURE__ */ QNe.configure({
    props: [
      /* @__PURE__ */ Al.add({
        Declaration: /* @__PURE__ */ to()
      }),
      /* @__PURE__ */ Cl.add({
        Block: lv
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function h1() {
  return new xh(u1, u1.data.of({ autocomplete: $Ne }));
}
const GNe = 303, aB = 1, BNe = 2, VNe = 304, FNe = 306, XNe = 307, YNe = 3, HNe = 4, WNe = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], _9 = 125, zNe = 59, oB = 47, ZNe = 42, qNe = 43, jNe = 45, KNe = new mP({
  start: !1,
  shift(r, e) {
    return e == YNe || e == HNe || e == FNe ? r : e == XNe;
  },
  strict: !1
}), JNe = new wi((r, e) => {
  let { next: t } = r;
  (t == _9 || t == -1 || e.context) && r.acceptToken(VNe);
}, { contextual: !0, fallback: !0 }), eLe = new wi((r, e) => {
  let { next: t } = r, i;
  WNe.indexOf(t) > -1 || t == oB && ((i = r.peek(1)) == oB || i == ZNe) || t != _9 && t != zNe && t != -1 && !e.context && r.acceptToken(GNe);
}, { contextual: !0 }), tLe = new wi((r, e) => {
  let { next: t } = r;
  if ((t == qNe || t == jNe) && (r.advance(), t == r.next)) {
    r.advance();
    let i = !e.context && e.canShift(aB);
    r.acceptToken(i ? aB : BNe);
  }
}, { contextual: !0 }), rLe = Rl({
  "get set async static": R.modifier,
  "for while do if else switch try catch finally return throw break continue default case": R.controlKeyword,
  "in of await yield void typeof delete instanceof": R.operatorKeyword,
  "let var const function class extends": R.definitionKeyword,
  "import export from": R.moduleKeyword,
  "with debugger as new": R.keyword,
  TemplateString: R.special(R.string),
  super: R.atom,
  BooleanLiteral: R.bool,
  this: R.self,
  null: R.null,
  Star: R.modifier,
  VariableName: R.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": R.function(R.variableName),
  VariableDefinition: R.definition(R.variableName),
  Label: R.labelName,
  PropertyName: R.propertyName,
  PrivatePropertyName: R.special(R.propertyName),
  "CallExpression/MemberExpression/PropertyName": R.function(R.propertyName),
  "FunctionDeclaration/VariableDefinition": R.function(R.definition(R.variableName)),
  "ClassDeclaration/VariableDefinition": R.definition(R.className),
  PropertyDefinition: R.definition(R.propertyName),
  PrivatePropertyDefinition: R.definition(R.special(R.propertyName)),
  UpdateOp: R.updateOperator,
  LineComment: R.lineComment,
  BlockComment: R.blockComment,
  Number: R.number,
  String: R.string,
  Escape: R.escape,
  ArithOp: R.arithmeticOperator,
  LogicOp: R.logicOperator,
  BitOp: R.bitwiseOperator,
  CompareOp: R.compareOperator,
  RegExp: R.regexp,
  Equals: R.definitionOperator,
  Arrow: R.function(R.punctuation),
  ": Spread": R.punctuation,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace,
  "InterpolationStart InterpolationEnd": R.special(R.brace),
  ".": R.derefOperator,
  ", ;": R.separator,
  "@": R.meta,
  TypeName: R.typeName,
  TypeDefinition: R.definition(R.typeName),
  "type enum interface implements namespace module declare": R.definitionKeyword,
  "abstract global Privacy readonly override": R.modifier,
  "is keyof unique infer": R.operatorKeyword,
  JSXAttributeValue: R.attributeValue,
  JSXText: R.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": R.angleBracket,
  "JSXIdentifier JSXNameSpacedName": R.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": R.attributeName,
  "JSXBuiltin/JSXIdentifier": R.standard(R.tagName)
}), iLe = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 221, private: 221, protected: 221, readonly: 223, instanceof: 242, satisfies: 245, in: 246, const: 248, import: 280, keyof: 335, unique: 339, infer: 345, is: 381, abstract: 401, implements: 403, type: 405, let: 408, var: 410, using: 413, interface: 419, enum: 423, namespace: 429, module: 431, declare: 435, global: 439, for: 458, of: 467, while: 470, with: 474, do: 478, if: 482, else: 484, switch: 488, case: 494, try: 500, catch: 504, finally: 508, return: 512, throw: 516, break: 520, continue: 524, debugger: 528 }, nLe = { __proto__: null, async: 117, get: 119, set: 121, declare: 181, public: 183, private: 183, protected: 183, static: 185, abstract: 187, override: 189, readonly: 195, accessor: 197, new: 385 }, aLe = { __proto__: null, "<": 137 }, oLe = fo.deserialize({
  version: 14,
  states: "$6tO`QUOOO%TQUOOO'WQWOOP(eOSOOO*sQ(CjO'#CfO*zOpO'#CgO+YO!bO'#CgO+hO07`O'#DZO-yQUO'#DaO.ZQUO'#DlO%TQUO'#DvO0_QUO'#EOOOQ(CY'#EW'#EWO0xQSO'#ETOOQO'#Ei'#EiOOQO'#Ic'#IcO1QQSO'#GkO1]QSO'#EhO1bQSO'#EhO3dQ(CjO'#JdO6TQ(CjO'#JeO6qQSO'#FWO6vQ#tO'#FoOOQ(CY'#F`'#F`O7RO&jO'#F`O7aQ,UO'#FvO8wQSO'#FuOOQ(CY'#Je'#JeOOQ(CW'#Jd'#JdO8|QSO'#GoOOQQ'#KP'#KPO9XQSO'#IPO9^Q(C[O'#IQOOQQ'#JQ'#JQOOQQ'#IU'#IUQ`QUOOO%TQUO'#DnO9fQUO'#DzO9mQUO'#D|O9SQSO'#GkO9tQ,UO'#ClO:SQSO'#EgO:_QSO'#ErO:dQ,UO'#F_O;RQSO'#GkOOQO'#KQ'#KQO;WQSO'#KQO;fQSO'#GsO;fQSO'#GtO;fQSO'#GvO9SQSO'#GyO<]QSO'#G|O=tQSO'#CbO>UQSO'#HYO>^QSO'#H`O>^QSO'#HbO`QUO'#HdO>^QSO'#HfO>^QSO'#HiO>cQSO'#HoO>hQ(C]O'#HuO%TQUO'#HwO>sQ(C]O'#HyO?OQ(C]O'#H{O9^Q(C[O'#H}O?ZQ(CjO'#CfO@]QWO'#DfQOQSOOO%TQUO'#D|O@sQSO'#EPO9tQ,UO'#EgOAOQSO'#EgOAZQ`O'#F_OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jh'#JhO%TQUO'#JhOOQO'#Jl'#JlOOQO'#I`'#I`OBZQWO'#E`OOQ(CW'#E_'#E_OCVQ(C`O'#E`OCaQWO'#ESOOQO'#Jk'#JkOCuQWO'#JlOESQWO'#ESOCaQWO'#E`PEaO?MpO'#C`POOO)CDo)CDoOOOO'#IV'#IVOElOpO,59ROOQ(CY,59R,59ROOOO'#IW'#IWOEzO!bO,59RO%TQUO'#D]OOOO'#IY'#IYOFYO07`O,59uOOQ(CY,59u,59uOFhQUO'#IZOF{QSO'#JfOH}QbO'#JfO+vQUO'#JfOIUQSO,59{OIlQSO'#EiOIyQSO'#JtOJUQSO'#JsOJUQSO'#JsOJ^QSO,5;VOJcQSO'#JrOOQ(CY,5:W,5:WOJjQUO,5:WOLkQ(CjO,5:bOM[QSO,5:jOMuQ(C[O'#JqOM|QSO'#JpO8|QSO'#JpONbQSO'#JpONjQSO,5;UONoQSO'#JpO!!wQbO'#JeOOQ(CY'#Cf'#CfO%TQUO'#EOO!#gQ`O,5:oOOQO'#Jm'#JmOOQO-E<a-E<aO9SQSO,5=VO!#}QSO,5=VO!$SQUO,5;SO!&VQ,UO'#EdO!'jQSO,5;SO!)SQ,UO'#DpO!)ZQUO'#DuO!)eQWO,5;]O!)mQWO,5;]O%TQUO,5;]OOQQ'#FO'#FOOOQQ'#FQ'#FQO%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^OOQQ'#FU'#FUO!){QUO,5;oOOQ(CY,5;t,5;tOOQ(CY,5;u,5;uO!,OQSO,5;uOOQ(CY,5;v,5;vO%TQUO'#IgO!,WQ(C[O,5<cO!&VQ,UO,5;^O!,uQ,UO,5;^O%TQUO,5;rO!,|Q#tO'#FeO!-yQ#tO'#JxO!-eQ#tO'#JxO!.QQ#tO'#JxOOQO'#Jx'#JxO!.fQ#tO,5;}OOOO,5<Z,5<ZO!.wQUO'#FqOOOO'#If'#IfO7RO&jO,5;zO!/OQ#tO'#FsOOQ(CY,5;z,5;zO!/oQ7[O'#CrOOQ(CY'#Cv'#CvO!0SQSO'#CvO!0XO07`O'#CzO!0uQ,UO,5<`O!0|QSO,5<bO!2cQMhO'#GQO!2pQSO'#GRO!2uQSO'#GRO!2zQMhO'#GVO!3yQWO'#GZO!4lQ7[O'#J_OOQ(CY'#J_'#J_O!4vQSO'#J^O!5UQSO'#J]O!5^QSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0{QSO'#DSO!'oQ,UO'#FxO!'oQ,UO'#FzO!5fQSO'#F|O!5kQSO'#F}O!2uQSO'#GTO!'oQ,UO'#GYO!5pQSO'#EjO!6_QSO,5<aOOQ(CW'#Co'#CoO!6gQSO'#EkO!7aQWO'#ElOOQ(CW'#Jr'#JrO!7hQ(C[O'#KRO9^Q(C[O,5=ZO`QUO,5>kOOQQ'#JY'#JYOOQQ,5>l,5>lOOQQ-E<S-E<SO!9jQ(CjO,5:YO!<WQ(CjO,5:fO%TQUO,5:fO!>qQ(CjO,5:hOOQO,5@l,5@lO!?bQ,UO,5=VO!?pQ(C[O'#JZO8wQSO'#JZO!@RQ(C[O,59WO!@^QWO,59WO!@fQ,UO,59WO9tQ,UO,59WO!@qQSO,5;SO!@yQSO'#HXO!A[QSO'#KUO%TQUO,5;wO!7[QWO,5;yO!AdQSO,5=rO!AiQSO,5=rO!AnQSO,5=rO9^Q(C[O,5=rO;fQSO,5=bOOQO'#Cr'#CrO!A|QWO,5=_O!BUQ,UO,5=`O!BaQSO,5=bO!BfQ`O,5=eO!BnQSO'#KQO>cQSO'#HOO9SQSO'#HQO!BsQSO'#HQO9tQ,UO'#HSO!BxQSO'#HSOOQQ,5=h,5=hO!B}QSO'#HTO!CVQSO'#ClO!C[QSO,58|O!CfQSO,58|O!EkQUO,58|OOQQ,58|,58|O!E{Q(C[O,58|O%TQUO,58|O!HWQUO'#H[OOQQ'#H]'#H]OOQQ'#H^'#H^O`QUO,5=tO!HnQSO,5=tO`QUO,5=zO`QUO,5=|O!HsQSO,5>OO`QUO,5>QO!HxQSO,5>TO!H}QUO,5>ZOOQQ,5>a,5>aO%TQUO,5>aO9^Q(C[O,5>cOOQQ,5>e,5>eO!MXQSO,5>eOOQQ,5>g,5>gO!MXQSO,5>gOOQQ,5>i,5>iO!M^QWO'#DXO%TQUO'#JhO!M{QWO'#JhO!NjQWO'#DgO!N{QWO'#DgO##^QUO'#DgO##eQSO'#JgO##mQSO,5:QO##rQSO'#EmO#$QQSO'#JuO#$YQSO,5;WO#$_QWO'#DgO#$lQWO'#EROOQ(CY,5:k,5:kO%TQUO,5:kO#$sQSO,5:kO>cQSO,5;RO!@^QWO,5;RO!@fQ,UO,5;RO9tQ,UO,5;RO#${QSO,5@SO#%QQ!LQO,5:oOOQO-E<^-E<^O#&WQ(C`O,5:zOCaQWO,5:nO#&bQWO,5:nOCaQWO,5:zO!@RQ(C[O,5:nOOQ(CW'#Ec'#EcOOQO,5:z,5:zO%TQUO,5:zO#&oQ(C[O,5:zO#&zQ(C[O,5:zO!@^QWO,5:nOOQO,5;Q,5;QO#'YQ(C[O,5:zPOOO'#IT'#ITP#'nO?MpO,58zPOOO,58z,58zOOOO-E<T-E<TOOQ(CY1G.m1G.mOOOO-E<U-E<UO#'yQ`O,59wOOOO-E<W-E<WOOQ(CY1G/a1G/aO#(OQbO,5>uO+vQUO,5>uOOQO,5>{,5>{O#(YQUO'#IZOOQO-E<X-E<XO#(gQSO,5@QO#(oQbO,5@QO#(vQSO,5@_OOQ(CY1G/g1G/gO%TQUO,5@`O#)OQSO'#IaOOQO-E<_-E<_O#(vQSO,5@_OOQ(CW1G0q1G0qOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO%TQUO,5@]O#)dQ(C[O,5@]O#)uQ(C[O,5@]O#)|QSO,5@[O8|QSO,5@[O#*UQSO,5@[O#*dQSO'#IdO#)|QSO,5@[OOQ(CW1G0p1G0pO!)eQWO,5:qO!)pQWO,5:qOOQO,5:s,5:sO#+UQSO,5:sO#+^Q,UO1G2qO9SQSO1G2qOOQ(CY1G0n1G0nO#+lQ(CjO1G0nO#,qQ(ChO,5;OOOQ(CY'#GP'#GPO#-_Q(CjO'#J_O!$SQUO1G0nO#/gQ,UO'#JiO#/qQSO,5:[O#/vQbO'#JjO%TQUO'#JjO#0QQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0w1G0wO%TQUO1G0wOOQ(CY1G1a1G1aO#0VQSO1G0wO#2nQ(CjO1G0xO#2uQ(CjO1G0xO#5`Q(CjO1G0xO#5gQ(CjO1G0xO#7qQ(CjO1G0xO#8XQ(CjO1G0xO#;RQ(CjO1G0xO#;YQ(CjO1G0xO#=sQ(CjO1G0xO#=zQ(CjO1G0xO#?rQ(CjO1G0xO#BrQ$IUO'#CfO#DpQ$IUO1G1ZO#DwQ$IUO'#JeO!,RQSO1G1aO#EXQ(CjO,5?ROOQ(CW-E<e-E<eO#E{Q(CjO1G0xOOQ(CY1G0x1G0xO#HWQ(CjO1G1^O#HzQ#tO,5<RO#ISQ#tO,5<SO#I[Q#tO'#FjO#IsQSO'#FiOOQO'#Jy'#JyOOQO'#Ie'#IeO#IxQ#tO1G1iOOQ(CY1G1i1G1iOOOO1G1t1G1tO#JZQ$IUO'#JdO#JeQSO,5<]O!){QUO,5<]OOOO-E<d-E<dOOQ(CY1G1f1G1fO#JjQWO'#JxOOQ(CY,5<_,5<_O#JrQWO,5<_OOQ(CY,59b,59bO!&VQ,UO'#C|OOOO'#IX'#IXO#JwO07`O,59fOOQ(CY,59f,59fO%TQUO1G1zO!5kQSO'#IiO#KSQ,UO,5<sOOQ(CY,5<p,5<pOOQO'#Gf'#GfO!'oQ,UO,5=POOQO'#Gh'#GhO!'oQ,UO,5=RO!&VQ,UO,5=TOOQO1G1|1G1|O#KZQ`O'#CoO#KnQ`O,5<lO#KuQSO'#J|O9SQSO'#J|O#LTQSO,5<nO!'oQ,UO,5<mO#LYQSO'#GSO#LeQSO,5<mO#LjQ`O'#GPO#LwQ`O'#J}O#MRQSO'#J}O!&VQ,UO'#J}O#MWQSO,5<qO#M]QWO'#G[O!3tQWO'#G[O#MnQSO'#G^O#MsQSO'#G`O!2uQSO'#GcO#MxQ(C[O'#IkO#NTQWO,5<uOOQ(CY,5<u,5<uO#N[QWO'#G[O#NjQWO'#G]O#NrQWO'#G]OOQ(CY,5=U,5=UO!'oQ,UO,5?xO!'oQ,UO,5?xO#NwQSO'#IlO$ SQSO,5?wO$ [QSO,59]O$ {Q,UO,59nOOQ(CY,59n,59nO$!nQ,UO,5<dO$#aQ,UO,5<fO@TQSO,5<hOOQ(CY,5<i,5<iO$#kQSO,5<oO$#pQ,UO,5<tO$$QQSO'#JpO!$SQUO1G1{O$$VQSO1G1{O8|QSO'#JsO8|QSO'#EmO%TQUO'#EmO8|QSO'#InO$$[Q(C[O,5@mOOQQ1G2u1G2uOOQQ1G4V1G4VOOQ(CY1G/t1G/tO!,OQSO1G/tO$&aQ(CjO1G0QOOQQ1G2q1G2qO!&VQ,UO1G2qO%TQUO1G2qO$'QQSO1G2qO$']Q,UO'#EdOOQ(CW,5?u,5?uO$'gQ(C[O,5?uOOQQ1G.r1G.rO!@RQ(C[O1G.rO!@^QWO1G.rO!@fQ,UO1G.rO$'xQSO1G0nO$'}QSO'#CfO$(YQSO'#KVO$(bQSO,5=sO$(gQSO'#KVO$(lQSO'#KVO$(wQSO'#ItO$)VQSO,5@pO$)_QbO1G1cOOQ(CY1G1e1G1eO9SQSO1G3^O@TQSO1G3^O$)fQSO1G3^O$)kQSO1G3^OOQQ1G3^1G3^O!BaQSO1G2|O!&VQ,UO1G2yO$)pQSO1G2yOOQQ1G2z1G2zO!&VQ,UO1G2zO$)uQSO1G2zO$)}QWO'#GxOOQQ1G2|1G2|O!3tQWO'#IpO!BfQ`O1G3POOQQ1G3P1G3POOQQ,5=j,5=jO$*VQ,UO,5=lO9SQSO,5=lO#MsQSO,5=nO8wQSO,5=nO!@^QWO,5=nO!@fQ,UO,5=nO9tQ,UO,5=nO$*eQSO'#KTO$*pQSO,5=oOOQQ1G.h1G.hO$*uQ(C[O1G.hO@TQSO1G.hO$+QQSO1G.hO9^Q(C[O1G.hO$-VQbO,5@rO$-gQSO,5@rO8|QSO,5@rO$-rQUO,5=vO$-yQSO,5=vOOQQ1G3`1G3`O`QUO1G3`OOQQ1G3f1G3fOOQQ1G3h1G3hO>^QSO1G3jO$.OQUO1G3lO$2SQUO'#HkOOQQ1G3o1G3oO$2aQSO'#HqO>cQSO'#HsOOQQ1G3u1G3uO$2iQUO1G3uO9^Q(C[O1G3{OOQQ1G3}1G3}OOQ(CW'#GW'#GWO9^Q(C[O1G4PO9^Q(C[O1G4RO$6pQSO,5@SO!){QUO,5;XO8|QSO,5;XO>cQSO,5:RO!){QUO,5:RO!@^QWO,5:RO$6uQ$IUO,5:ROOQO,5;X,5;XO$7PQWO'#I[O$7gQSO,5@ROOQ(CY1G/l1G/lO$7oQWO'#IbO$7yQSO,5@aOOQ(CW1G0r1G0rO!N{QWO,5:ROOQO'#I_'#I_O$8RQWO,5:mOOQ(CY,5:m,5:mO#$vQSO1G0VOOQ(CY1G0V1G0VO%TQUO1G0VOOQ(CY1G0m1G0mO>cQSO1G0mO!@^QWO1G0mO!@fQ,UO1G0mOOQ(CW1G5n1G5nO!@RQ(C[O1G0YOOQO1G0f1G0fO%TQUO1G0fO$8YQ(C[O1G0fO$8eQ(C[O1G0fO!@^QWO1G0YOCaQWO1G0YO$8sQ(C[O1G0fOOQO1G0Y1G0YO$9XQ(CjO1G0fPOOO-E<R-E<RPOOO1G.f1G.fOOOO1G/c1G/cO$9cQ`O,5<cO$9kQbO1G4aOOQO1G4g1G4gO%TQUO,5>uO$9uQSO1G5lO$9}QSO1G5yO$:VQbO1G5zO8|QSO,5>{O$:aQ(CjO1G5wO%TQUO1G5wO$:qQ(C[O1G5wO$;SQSO1G5vO$;SQSO1G5vO8|QSO1G5vO$;[QSO,5?OO8|QSO,5?OOOQO,5?O,5?OO$;pQSO,5?OO$$QQSO,5?OOOQO-E<b-E<bOOQO1G0]1G0]OOQO1G0_1G0_O!,RQSO1G0_OOQQ7+(]7+(]O!&VQ,UO7+(]O%TQUO7+(]O$<OQSO7+(]O$<ZQ,UO7+(]O$<iQ(CjO,59nO$>qQ(CjO,5<dO$@|Q(CjO,5<fO$CXQ(CjO,5<tOOQ(CY7+&Y7+&YO$EjQ(CjO7+&YO$F^Q,UO'#I]O$FhQSO,5@TOOQ(CY1G/v1G/vO$FpQUO'#I^O$F}QSO,5@UO$GVQbO,5@UOOQ(CY1G/{1G/{O$GaQSO7+&cOOQ(CY7+&c7+&cO$GfQ$IUO,5:bO%TQUO7+&uO$GpQ$IUO,5:YO$G}Q$IUO,5:fO$HXQ$IUO,5:hOOQ(CY7+&{7+&{OOQO1G1m1G1mOOQO1G1n1G1nO$HcQ#tO,5<UO!){QUO,5<TOOQO-E<c-E<cOOQ(CY7+'T7+'TOOOO7+'`7+'`OOOO1G1w1G1wO$HnQSO1G1wOOQ(CY1G1y1G1yO$HsQ`O,59hOOOO-E<V-E<VOOQ(CY1G/Q1G/QO$HzQ(CjO7+'fOOQ(CY,5?T,5?TO$InQ`O,5?TOOQ(CY1G2_1G2_P!&VQ,UO'#IiPOQ(CY-E<g-E<gO$J^Q,UO1G2kO$KPQ,UO1G2mO$KZQ`O1G2oOOQ(CY1G2W1G2WO$KbQSO'#IhO$KpQSO,5@hO$KpQSO,5@hO$KxQSO,5@hO$LTQSO,5@hOOQO1G2Y1G2YO$LcQ,UO1G2XO!'oQ,UO1G2XO$LsQMhO'#IjO$MTQSO,5@iO!&VQ,UO,5@iO$M]Q`O,5@iOOQ(CY1G2]1G2]OOQ(CW,5<v,5<vOOQ(CW,5<w,5<wO$$QQSO,5<wOCQQSO,5<wO!@^QWO,5<vOOQO'#G_'#G_O$MgQSO,5<xOOQ(CW,5<z,5<zO$$QQSO,5<}OOQO,5?V,5?VOOQO-E<i-E<iOOQ(CY1G2a1G2aO!3tQWO,5<vO$MoQSO,5<wO#MnQSO,5<xO!3tQWO,5<wO$MzQ,UO1G5dO$NUQ,UO1G5dOOQO,5?W,5?WOOQO-E<j-E<jOOQO1G.w1G.wO!7[QWO,59pO%TQUO,59pO$NcQSO1G2SO!'oQ,UO1G2ZO$NhQ(CjO7+'gOOQ(CY7+'g7+'gO!$SQUO7+'gO% [QSO,5;XOOQ(CW,5?Y,5?YOOQ(CW-E<l-E<lOOQ(CY7+%`7+%`O% aQ`O'#KOO#$vQSO7+(]O% kQbO7+(]O$<RQSO7+(]O% rQ(ChO'#CfO%!VQ(ChO,5<{O%!wQSO,5<{OOQ(CW1G5a1G5aOOQQ7+$^7+$^O!@RQ(C[O7+$^O!@^QWO7+$^O!$SQUO7+&YO%!|QSO'#IsO%#bQSO,5@qOOQO1G3_1G3_O9SQSO,5@qO%#bQSO,5@qO%#jQSO,5@qOOQO,5?`,5?`OOQO-E<r-E<rOOQ(CY7+&}7+&}O%#oQSO7+(xO9^Q(C[O7+(xO9SQSO7+(xO@TQSO7+(xOOQQ7+(h7+(hO%#tQ(ChO7+(eO!&VQ,UO7+(eO%$OQ`O7+(fOOQQ7+(f7+(fO!&VQ,UO7+(fO%$VQSO'#KSO%$bQSO,5=dOOQO,5?[,5?[OOQO-E<n-E<nOOQQ7+(k7+(kO%%qQWO'#HROOQQ1G3W1G3WO!&VQ,UO1G3WO%TQUO1G3WO%%xQSO1G3WO%&TQ,UO1G3WO9^Q(C[O1G3YO#MsQSO1G3YO8wQSO1G3YO!@^QWO1G3YO!@fQ,UO1G3YO%&cQSO'#IrO%&nQSO,5@oO%&vQWO,5@oOOQ(CW1G3Z1G3ZOOQQ7+$S7+$SO@TQSO7+$SO9^Q(C[O7+$SO%'RQSO7+$SO%TQUO1G6^O%TQUO1G6_O%'WQ(C[O1G6^O%'bQUO1G3bO%'iQSO1G3bO%'nQUO1G3bOOQQ7+(z7+(zO9^Q(C[O7+)UO`QUO7+)WOOQQ'#KY'#KYOOQQ'#Iu'#IuO%'uQUO,5>VOOQQ,5>V,5>VO%TQUO'#HlO%(SQSO'#HnOOQQ,5>],5>]O8|QSO,5>]OOQQ,5>_,5>_OOQQ7+)a7+)aOOQQ7+)g7+)gOOQQ7+)k7+)kOOQQ7+)m7+)mO%(XQWO1G5nO%(mQ$IUO1G0sO%(wQSO1G0sOOQO1G/m1G/mO%)SQ$IUO1G/mO>cQSO1G/mO!){QUO'#DgOOQO,5>v,5>vOOQO-E<Y-E<YOOQO,5>|,5>|OOQO-E<`-E<`O!@^QWO1G/mOOQO-E<]-E<]OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO#$vQSO7+%qOOQ(CY7+&X7+&XO>cQSO7+&XO!@^QWO7+&XOOQO7+%t7+%tO$9XQ(CjO7+&QOOQO7+&Q7+&QO%TQUO7+&QO%)^Q(C[O7+&QO!@RQ(C[O7+%tO!@^QWO7+%tO%)iQ(C[O7+&QO%)wQ(CjO7++cO%TQUO7++cO%*XQSO7++bO%*XQSO7++bOOQO1G4j1G4jO8|QSO1G4jO%*aQSO1G4jOOQO7+%y7+%yO#$vQSO<<KwO% kQbO<<KwO%*oQSO<<KwOOQQ<<Kw<<KwO!&VQ,UO<<KwO%TQUO<<KwO%*wQSO<<KwO%+SQ(CjO1G2kO%-_Q(CjO1G2mO%/jQ(CjO1G2XO%1{Q,UO,5>wOOQO-E<Z-E<ZO%2VQbO,5>xO%TQUO,5>xOOQO-E<[-E<[O%2aQSO1G5pOOQ(CY<<I}<<I}O%2iQ$IUO1G0nO%4sQ$IUO1G0xO%4zQ$IUO1G0xO%7OQ$IUO1G0xO%7VQ$IUO1G0xO%8zQ$IUO1G0xO%9bQ$IUO1G0xO%;uQ$IUO1G0xO%;|Q$IUO1G0xO%>QQ$IUO1G0xO%>XQ$IUO1G0xO%@PQ$IUO1G0xO%@dQ(CjO<<JaO%AiQ$IUO1G0xO%C_Q$IUO'#J_O%EbQ$IUO1G1^O%EoQ$IUO1G0QO!){QUO'#FlOOQO'#Jz'#JzOOQO1G1p1G1pO%EyQSO1G1oO%FOQ$IUO,5?ROOOO7+'c7+'cOOOO1G/S1G/SOOQ(CY1G4o1G4oO!'oQ,UO7+(ZO%FYQSO,5?SO9SQSO,5?SOOQO-E<f-E<fO%FhQSO1G6SO%FhQSO1G6SO%FpQSO1G6SO%F{Q,UO7+'sO%G]Q`O,5?UO%GgQSO,5?UO!&VQ,UO,5?UOOQO-E<h-E<hO%GlQ`O1G6TO%GvQSO1G6TOOQ(CW1G2c1G2cO$$QQSO1G2cOOQ(CW1G2b1G2bO%HOQSO1G2dO!&VQ,UO1G2dOOQ(CW1G2i1G2iO!@^QWO1G2bOCQQSO1G2cO%HTQSO1G2dO%H]QSO1G2cO!'oQ,UO7++OOOQ(CY1G/[1G/[O%HhQSO1G/[OOQ(CY7+'n7+'nO%HmQ,UO7+'uO%H}Q(CjO<<KROOQ(CY<<KR<<KRO%IqQSO1G0sO!&VQ,UO'#ImO%IvQSO,5@jO!&VQ,UO1G2gOOQQ<<Gx<<GxO!@RQ(C[O<<GxO%JOQ(CjO<<ItOOQ(CY<<It<<ItOOQO,5?_,5?_O%JrQSO,5?_O$(lQSO,5?_OOQO-E<q-E<qO%JwQSO1G6]O%JwQSO1G6]O9SQSO1G6]O@TQSO<<LdOOQQ<<Ld<<LdO%KPQSO<<LdO9^Q(C[O<<LdOOQQ<<LP<<LPO%#tQ(ChO<<LPOOQQ<<LQ<<LQO%$OQ`O<<LQO%KUQWO'#IoO%KaQSO,5@nO!){QUO,5@nOOQQ1G3O1G3OO%KiQUO'#JhOOQO'#Iq'#IqO9^Q(C[O'#IqO%KsQWO,5=mOOQQ,5=m,5=mO%KzQWO'#E`O%L`QSO7+(rO%LeQSO7+(rOOQQ7+(r7+(rO!&VQ,UO7+(rO%TQUO7+(rO%LmQSO7+(rOOQQ7+(t7+(tO9^Q(C[O7+(tO#MsQSO7+(tO8wQSO7+(tO!@^QWO7+(tO%LxQSO,5?^OOQO-E<p-E<pOOQO'#HU'#HUO%MTQSO1G6ZO9^Q(C[O<<GnOOQQ<<Gn<<GnO@TQSO<<GnO%M]QSO7++xO%MbQSO7++yO%TQUO7++xO%TQUO7++yOOQQ7+(|7+(|O%MgQSO7+(|O%MlQUO7+(|O%MsQSO7+(|OOQQ<<Lp<<LpOOQQ<<Lr<<LrOOQQ-E<s-E<sOOQQ1G3q1G3qO%MxQSO,5>WOOQQ,5>Y,5>YO%M}QSO1G3wO8|QSO7+&_O!){QUO7+&_OOQO7+%X7+%XO%NSQ$IUO1G5zO>cQSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Is<<IsO>cQSO<<IsOOQO<<Il<<IlO$9XQ(CjO<<IlO%TQUO<<IlOOQO<<I`<<I`O!@RQ(C[O<<I`O%N^Q(C[O<<IlO%NiQ(CjO<<N}O%NyQSO<<N|OOQO7+*U7+*UO8|QSO7+*UOOQQANAcANAcO& RQSOANAcO!&VQ,UOANAcO#$vQSOANAcO% kQbOANAcO%TQUOANAcO& ZQ(CjO7+'sO&#lQ(CjO7+'uO&%}QbO1G4dO&&XQ$IUO7+&YO&&fQ$IUO,59nO&(iQ$IUO,5<dO&*lQ$IUO,5<fO&,oQ$IUO,5<tO&.eQ$IUO7+'fO&.rQ$IUO7+'gO&/PQSO,5<WOOQO7+'Z7+'ZO&/UQ,UO<<KuOOQO1G4n1G4nO&/]QSO1G4nO&/hQSO1G4nO&/vQSO7++nO&/vQSO7++nO!&VQ,UO1G4pO&0OQ`O1G4pO&0YQSO7++oOOQ(CW7+'}7+'}O$$QQSO7+(OO&0bQ`O7+(OOOQ(CW7+'|7+'|O$$QQSO7+'}O&0iQSO7+(OO!&VQ,UO7+(OOCQQSO7+'}O&0nQ,UO<<NjOOQ(CY7+$v7+$vO&0xQ`O,5?XOOQO-E<k-E<kO&1SQ(ChO7+(ROOQQAN=dAN=dO9SQSO1G4yOOQO1G4y1G4yO&1dQSO1G4yO&1iQSO7++wO&1iQSO7++wO9^Q(C[OANBOO@TQSOANBOOOQQANBOANBOOOQQANAkANAkOOQQANAlANAlO&1qQSO,5?ZOOQO-E<m-E<mO&1|Q$IUO1G6YO&4^QbO'#CfOOQO,5?],5?]OOQO-E<o-E<oOOQQ1G3X1G3XO%KiQUO,5<xOOQQ<<L^<<L^O!&VQ,UO<<L^O%L`QSO<<L^O&4hQSO<<L^O%TQUO<<L^OOQQ<<L`<<L`O9^Q(C[O<<L`O#MsQSO<<L`O8wQSO<<L`O&4pQWO1G4xO&4{QSO7++uOOQQAN=YAN=YO9^Q(C[OAN=YOOQQ<= d<= dOOQQ<= e<= eO&5TQSO<= dO&5YQSO<= eOOQQ<<Lh<<LhO&5_QSO<<LhO&5dQUO<<LhOOQQ1G3r1G3rO>cQSO7+)cO&5kQSO<<IyO&5vQ$IUO<<IyOOQO<<Hs<<HsOOQ(CYAN?_AN?_OOQOAN?WAN?WO$9XQ(CjOAN?WOOQOAN>zAN>zO%TQUOAN?WOOQO<<Mp<<MpOOQQG26}G26}O!&VQ,UOG26}O#$vQSOG26}O&6QQSOG26}O% kQbOG26}O&6YQ$IUO<<JaO&6gQ$IUO1G2XO&8]Q$IUO1G2kO&:`Q$IUO1G2mO&<cQ$IUO<<KRO&<pQ$IUO<<ItOOQO1G1r1G1rO!'oQ,UOANAaOOQO7+*Y7+*YO&<}QSO7+*YO&=YQSO<= YO&=bQ`O7+*[OOQ(CW<<Kj<<KjO$$QQSO<<KjOOQ(CW<<Ki<<KiO&=lQ`O<<KjO$$QQSO<<KiOOQO7+*e7+*eO9SQSO7+*eO&=sQSO<= cOOQQG27jG27jO9^Q(C[OG27jO!){QUO1G4uO&={QSO7++tO%L`QSOANAxOOQQANAxANAxO!&VQ,UOANAxO&>TQSOANAxOOQQANAzANAzO9^Q(C[OANAzO#MsQSOANAzOOQO'#HV'#HVOOQO7+*d7+*dOOQQG22tG22tOOQQANEOANEOOOQQANEPANEPOOQQANBSANBSO&>]QSOANBSOOQQ<<L}<<L}O!){QUOAN?eOOQOG24rG24rO$9XQ(CjOG24rO#$vQSOLD,iOOQQLD,iLD,iO!&VQ,UOLD,iO&>bQSOLD,iO&>jQ$IUO7+'sO&@`Q$IUO7+'uO&BUQ,UOG26{OOQO<<Mt<<MtOOQ(CWANAUANAUO$$QQSOANAUOOQ(CWANATANATOOQO<<NP<<NPOOQQLD-ULD-UO&BfQ$IUO7+*aOOQQG27dG27dO%L`QSOG27dO!&VQ,UOG27dOOQQG27fG27fO9^Q(C[OG27fOOQQG27nG27nO&BpQ$IUOG25POOQOLD*^LD*^OOQQ!$(!T!$(!TO#$vQSO!$(!TO!&VQ,UO!$(!TO&BzQ(CjOG26{OOQ(CWG26pG26pOOQQLD-OLD-OO%L`QSOLD-OOOQQLD-QLD-QOOQQ!)9Eo!)9EoO#$vQSO!)9EoOOQQ!$(!j!$(!jOOQQ!.K;Z!.K;ZO&E]Q$IUOG26{O!){QUO'#DvO0xQSO'#ETO&GRQbO'#JdO!){QUO'#DnO&GYQUO'#DzO&GaQbO'#CfO&IwQbO'#CfO!){QUO'#D|O&JXQUO,5;SO!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO'#IgO&L[QSO,5<cO&LdQ,UO,5;^O&MwQ,UO,5;^O!){QUO,5;rO0{QSO'#DSO0{QSO'#DSO!&VQ,UO'#FxO&LdQ,UO'#FxO!&VQ,UO'#FzO&LdQ,UO'#FzO!&VQ,UO'#GYO&LdQ,UO'#GYO!){QUO,5:fO!){QUO,5@`O&JXQUO1G0nO&NOQ$IUO'#CfO!){QUO1G1zO!&VQ,UO,5=PO&LdQ,UO,5=PO!&VQ,UO,5=RO&LdQ,UO,5=RO!&VQ,UO,5<mO&LdQ,UO,5<mO&JXQUO1G1{O!){QUO7+&uO!&VQ,UO1G2XO&LdQ,UO1G2XO!&VQ,UO1G2ZO&LdQ,UO1G2ZO&JXQUO7+'gO&JXQUO7+&YO!&VQ,UOANAaO&LdQ,UOANAaO&NYQSO'#EhO&N_QSO'#EhO&NgQSO'#FWO&NlQSO'#ErO&NqQSO'#JtO&N|QSO'#JrO' XQSO,5;SO' ^Q,UO,5<`O' eQSO'#GRO' jQSO'#GRO' oQSO,5<aO' wQSO,5;SO'!PQ$IUO1G1ZO'!WQSO,5<mO'!]QSO,5<mO'!bQSO,5<oO'!gQSO,5<oO'!lQSO1G1{O'!qQSO1G0nO'!vQ,UO<<KuO'!}Q,UO<<KuO7aQ,UO'#FvO8wQSO'#FuOAOQSO'#EgO!){QUO,5;oO!2uQSO'#GRO!2uQSO'#GRO!2uQSO'#GTO!2uQSO'#GTO!'oQ,UO7+(ZO!'oQ,UO7+(ZO$KZQ`O1G2oO$KZQ`O1G2oO!&VQ,UO,5=TO!&VQ,UO,5=T",
  stateData: "'$W~O'nOS'oOSROS'pRQ~OPYOQYOV!UO^qOayObxOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!ctO!hZO!kYO!lYO!mYO!ouO!qvO!twO!x]O#p!OO$Q{O$UfO%`|O%b!PO%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO%q!TO%}!VO&T!WO&V!XO&X!YO&Z!ZO&^![O&d!]O&j!^O&l!_O&n!`O&p!aO&r!bO'uSO'wTO'zUO(SVO(b[O(oiO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~O^!uOl!mO|!nO![!wO!]!tO!^!tO!x9qO!|!oO!}!oO#O!vO#P!oO#Q!oO#T!xO#U!xO'v!kO'wTO'zUO(V!lO(b!rO~O'p!yO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX'lYX(SYX(cYX(jYX(kYX~O!a$zX~P(jO[!{O'w!}O'x!{O'y!}O~O[#OO'y!}O'z!}O'{#OO~Oq#QO!O#RO(T#RO(U#TO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u9uO'wTO'zUO(SVO(b[O(oiO~O!U#XO!V#UO!S(YP!S(gP~P+vO!W#aO~P`OPYOQYOa!iOb!hOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'wTO'zUO(SVO(b[O(oiO~Oi#kO!U#gO!x]O#b#jO#c#gO'u9vO!g(dP~P.bO!h#mO'u#lO~O!t#qO!x]O%`#rO~O#d#sO~O!a#tO#d#sO~OP$[OX$cOk$POy#xOz#yO|#zO!V$`O!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O^(WX'l(WX'j(WX!g(WX!S(WX!X(WX%a(WX!a(WX~P1jO#X$dO#{$dOP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#o(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX!X(XX%a(XX~O^(XX!f(XX'l(XX'j(XX!S(XX!g(XXo(XX!a(XX~P4QO#X$dO~O$W$fO$Y$eO$a$kO~O!X$lO$UfO$d$mO$f$oO~Oi%ROk$sOl$rOm$rOs%SOu%TOw%UO|$zO!X${O!c%ZO!h$wO#c%[O$Q%XO$m%VO$o%WO$r%YO'u$qO'wTO'zUO(O%QO(S$tOd(PP~O!h%]O~O|%`O!X%aO'u%_O~O!a%eO~O^%fO'l%fO~O'v!kO~P%TO%f%mO~P%TO!h%]O'u%_O'v!kO(O%QO~Ob%tO!h%]O'u%_O~O#o$RO~Oy%yO!X%vO!h%xO%b%|O'u%_O'v!kO'wTO'zUO](xP~O!t#qO~O%k&OO|(tX!X(tX'u(tX~O'u&PO~O!q&UO#p!OO%b!PO%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO~Oa&ZOb&YO!t&WO%`&XO%s&VO~P;kOa&^ObxO!X&]O!q&UO!twO!x]O#p!OO%`|O%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO%q!TO~O_&aO#X&dO%b&_O'v!kO~P<pO!h&eO!q&iO~O!h#mO~O!XXO~O^%fO'k&qO'l%fO~O^%fO'k&tO'l%fO~O^%fO'k&vO'l%fO~O'jYX!SYXoYX!gYX&RYX!XYX%aYX!aYX~P(jO!['TO!]&|O!^&|O'v!kO'wTO'zUO~Ol&zO|&yO!U&}O(V&xO!W(ZP!W(iP~P?wOg'WO!X'UO'u%_O~Ob']O!h%]O'u%_O~Oy%yO!h%xO~Ol!mO|!nO!x9qO!|!oO!}!oO#P!oO#Q!oO'v!kO'wTO'zUO(V!lO(b!rO~O!['cO!]'bO!^'bO#O!oO#T'dO#U'dO~PAcO^%fO!a#tO!h%]O'l%fO(O%QO(c'fO~O!l'jO#X'hO~PBqOl!mO|!nO'wTO'zUO(V!lO(b!rO~O!XXOl(`X|(`X![(`X!](`X!^(`X!x(`X!|(`X!}(`X#O(`X#P(`X#Q(`X#T(`X#U(`X'v(`X'w(`X'z(`X(V(`X(b(`X~O!]'bO!^'bO'v!kO~PCaO'q'nO'r'nO's'pO~O[!{O'w'rO'x!{O'y'rO~O[#OO'y'rO'z'rO'{#OO~Oq#QO!O#RO(T#RO(U'vO~O!U'xO!S&}X!S'TX!V&}X!V'TX~P+vO!V'zO!S(YX~OP$[OX$cOk$POy#xOz#yO|#zO!V'zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O!S(YX~PGTO!S(PO~O!S(fX!V(fX!a(fX!g(fX(c(fX~O#X(fX#d#]X!W(fX~PIZO#X(QO!S(hX!V(hX~O!V(RO!S(gX~O!S(UO~O#X$dO~PIZO!W(VO~P`Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!jaX!jak!ja!V!ja!e!ja!l!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#o!ja#q!ja#s!ja#u!ja#v!ja(c!ja(j!ja(k!ja~O^!ja'l!ja'j!ja!S!ja!g!jao!ja!X!ja%a!ja!a!ja~PJqO!g(WO~O!a#tO#X(XO(c'fO!V(eX^(eX'l(eX~O!g(eX~PMaO|%`O!X%aO!x]O#b(^O#c(]O'u%_O~O!V(_O!g(dX~O!g(aO~O|%`O!X%aO#c(]O'u%_O~OP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!f(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#o(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX~O!a#tO!g(XX~PN}Oy(bOz(cO!f#vO!h#wO!x!wa|!wa~O!t!wa%`!wa!X!wa#b!wa#c!wa'u!wa~P!#RO!t(gO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~Oi%ROk$sOl$rOm$rOs%SOu%TOw:ZO|$zO!X${O!c;eO!h$wO#c:aO$Q%XO$m:]O$o:_O$r%YO'u(kO'wTO'zUO(O%QO(S$tO~O#d(mO~Oi%ROk$sOl$rOm$rOs%SOu%TOw%UO|$zO!X${O!c%ZO!h$wO#c%[O$Q%XO$m%VO$o%WO$r%YO'u(kO'wTO'zUO(O%QO(S$tO~Od(]P~P!'oO!U(qO!g(^P~P%TO(V(sO(b[O~O|(uO!h#wO(V(sO(b[O~OP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!X!dO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'u)TO'wTO'zUO(SVO(b[O(o;_O~Oz)WO!h#wO~O!V$`O^$ka'l$ka'j$ka!g$ka!S$ka!X$ka%a$ka!a$ka~O#p)[O~P!&VOy)_O!a)^O!X$XX$T$XX$W$XX$Y$XX$a$XX~O!a)^O!X(lX$T(lX$W(lX$Y(lX$a(lX~Oy)_O~P!-eOy)_O!X(lX$T(lX$W(lX$Y(lX$a(lX~O!X)aO$T)eO$W)`O$Y)`O$a)fO~O!U)iO~P!){O$W$fO$Y$eO$a)mO~Og$sXy$sX|$sX!f$sX(j$sX(k$sX~OdfXd$sXgfX!VfX#XfX~P!/ZOl)oO~Oq)pO(T)qO(U)sO~Og)|Oy)uO|)vO(j)xO(k)zO~Od)tO~P!0dOd)}O~Oi%ROk$sOl$rOm$rOs%SOu%TOw:ZO|$zO!X${O!c;eO!h$wO#c:aO$Q%XO$m:]O$o:_O$r%YO'wTO'zUO(O%QO(S$tO~O!U*RO'u*OO!g(pP~P!1RO#d*TO~O!h*UO~O!U*ZO'u*WO!S(qP~P!1ROk*gO|*_O![*eO!]*^O!^*^O!h*UO#T*fO%W*aO'v!kO(V!lO~O!W*dO~P!3XO!f#vOg(RXy(RX|(RX(j(RX(k(RX!V(RX#X(RX~Od(RX#y(RX~P!4QOg*jO#X*iOd(QX!V(QX~O!V*kOd(PX~O'u&POd(PP~O!h*rO~O'u(kO~Oi*vO|%`O!U#gO!X%aO!x]O#b#jO#c#gO'u%_O!g(dP~O!a#tO#d*wO~O|%`O!U*yO!V(RO!X%aO'u%_O!S(gP~Ol'QO|*{O!U*zO'wTO'zUO(V(sO~O!W(iP~P!6{O!V*|O^(uX'l(uX~OP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O^!ba!V!ba'l!ba'j!ba!S!ba!g!bao!ba!X!ba%a!ba!a!ba~P!7sOy#xOz#yO|#zO!f#vO!h#wO(SVOP!naX!nak!na!V!na!e!na!l!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#o!na#q!na#s!na#u!na#v!na(c!na(j!na(k!na~O^!na'l!na'j!na!S!na!g!nao!na!X!na%a!na!a!na~P!:^Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!paX!pak!pa!V!pa!e!pa!l!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#o!pa#q!pa#s!pa#u!pa#v!pa(c!pa(j!pa(k!pa~O^!pa'l!pa'j!pa!S!pa!g!pao!pa!X!pa%a!pa!a!pa~P!<wOg+VO!X'UO%a+UO(O%QO~O!a+XO^'}X!X'}X'l'}X!V'}X~O^%fO!XXO'l%fO~O!h%]O(O%QO~O!h%]O'u%_O(O%QO~O!a#tO#d(mO~O%b+eO'u+aO'wTO'zUO!W(yP~O!V+fO](xX~OX+jO~O]+kO~O!X%vO'u%_O'v!kO](xP~O#X+pO(O%QO~Og+sO!X${O(O%QO~O!X+uO~Oy+wO!XXO~O%f%mO~O!t+|O~Ob,RO~O'u#lO!W(wP~Ob%tO~O%b!PO'u&PO~P<pOX,XO],WO~OPYOQYOayObxOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!ctO!hZO!kYO!lYO!mYO!ouO!twO!x]O$UfO%`|O'wTO'zUO(SVO(b[O(oiO~O!X!dO!q!fO$Q!jO'u!cO~P!CnO],WO^%fO'l%fO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~O^,^O!qvO#p}O%d}O%e}O%f}O~P!FWO!h&eO~O&T,dO~O!X,fO~O&f,hO&h,iOP&caQ&caV&ca^&caa&cab&cai&cak&cal&cam&cas&cau&caw&ca|&ca!Q&ca!R&ca!X&ca!c&ca!h&ca!k&ca!l&ca!m&ca!o&ca!q&ca!t&ca!x&ca#p&ca$Q&ca$U&ca%`&ca%b&ca%d&ca%e&ca%f&ca%i&ca%k&ca%n&ca%o&ca%q&ca%}&ca&T&ca&V&ca&X&ca&Z&ca&^&ca&d&ca&j&ca&l&ca&n&ca&p&ca&r&ca'j&ca'u&ca'w&ca'z&ca(S&ca(b&ca(o&ca!W&ca&[&ca_&ca&a&ca~O'u,nO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#X{X(O!_X~O!a,sO#X,rO!V#aX!V([X!W#aX!W([X!a([X!h([X(O([X~O!a,uO!h%]O(O%QO!V!ZX!W!ZX~Ol!mO|!nO'wTO'zUO(V!lO~OP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!X!dO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'wTO'zUO(SVO(b[O(o;_O~O'u:fO~P# ^O!V,yO!W(ZX~O!W,{O~O!a,sO#X,rO!V#aX!W#aX~O!V,|O!W(iX~O!W-OO~O!]-PO!^-PO'v!kO~P!N{O!W-SO~P'WOg-VO!X'UO~O!S-[O~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#Q!wa#T!wa#U!wa'v!wa'w!wa'z!wa(V!wa(b!wa~P!#RO!l-aO#X-_O~PBqO!]-cO!^-cO'v!kO~PCaO^%fO#X-_O'l%fO~O^%fO!a#tO#X-_O'l%fO~O^%fO!a#tO!l-aO#X-_O'l%fO(c'fO~O'q'nO'r'nO's-hO~Oo-iO~O!S&}a!V&}a~P!7sO!U-mO!S&}X!V&}X~P%TO!V'zO!S(Ya~O!S(Ya~PGTO!V(RO!S(ga~O|%`O!U-qO!X%aO'u%_O!S'TX!V'TX~O#X-sO!V(ea!g(ea^(ea'l(ea~O!a#tO~P#)dO!V(_O!g(da~O|%`O!X%aO#c-wO'u%_O~Oi-|O|%`O!U-yO!X%aO!x]O#b-{O#c-yO'u%_O!V'WX!g'WX~Oz.QO!h#wO~Og.TO!X'UO%a.SO(O%QO~O^#[i!V#[i'l#[i'j#[i!S#[i!g#[io#[i!X#[i%a#[i!a#[i~P!7sOg;kOy)uO|)vO(j)xO(k)zO~O#d#Wa^#Wa#X#Wa'l#Wa!V#Wa!g#Wa!X#Wa!S#Wa~P#,`O#d(RXP(RXX(RX^(RXk(RXz(RX!e(RX!h(RX!l(RX#g(RX#h(RX#i(RX#j(RX#k(RX#l(RX#m(RX#n(RX#o(RX#q(RX#s(RX#u(RX#v(RX'l(RX(S(RX(c(RX!g(RX!S(RX'j(RXo(RX!X(RX%a(RX!a(RX~P!4QO!V.^Od(]X~P!0dOd.`O~O!V.aO!g(^X~P!7sO!g.dO~O!S.fO~OP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O(SVOX#fi^#fik#fi!V#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O#g#fi~P#0[O#g#}O~P#0[OP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO(SVOX#fi^#fi!V#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~Ok#fi~P#2|Ok$PO~P#2|OP$[Ok$POy#xOz#yO|#zO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO(SVO^#fi!V#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P#5nOX$cO!e$RO#l$RO#m$RO#n$bO#o$RO~P#5nOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO(SVO^#fi!V#fi#s#fi#u#fi#v#fi'l#fi(c#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(j#fi~P#8oO(j#{O~P#8oOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO(SVO(j#{O^#fi!V#fi#u#fi#v#fi'l#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(k#fi~P#;aO(k#|O~P#;aOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO(SVO(j#{O(k#|O~O^#fi!V#fi#v#fi'l#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#>ROPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX!VYX!WYX~O#yYX~P#@lOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO#u:SO#v:TO(SVO(c$YO(j#{O(k#|O~O#y.hO~P#ByO#X:YO#{:YO#y(XX!W(XX~PN}O^'Za!V'Za'l'Za'j'Za!g'Za!S'Zao'Za!X'Za%a'Za!a'Za~P!7sOP#fiX#fi^#fik#fiz#fi!V#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(S#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#,`O^#zi!V#zi'l#zi'j#zi!S#zi!g#zio#zi!X#zi%a#zi!a#zi~P!7sO$W.mO$Y.mO~O$W.nO$Y.nO~O!a)^O#X.oO!X$^X$T$^X$W$^X$Y$^X$a$^X~O!U.pO~O!X)aO$T.rO$W)`O$Y)`O$a.sO~O!V:UO!W(WX~P#ByO!W.tO~O!a)^O$a(lX~O$a.vO~Oq)pO(T)qO(U.yO~O!S.}O~P!&VO!VcX!acX!gcX!g$sX(ccX~P!/ZO!g/TO~P#,`O!V/UO!a#tO(c'fO!g(pX~O!g/ZO~O!U*RO'u%_O!g(pP~O#d/]O~O!S$sX!V$sX!a$zX~P!/ZO!V/^O!S(qX~P#,`O!a/`O~O!S/bO~Ok/fO!a#tO!h%]O(O%QO(c'fO~O'u/hO~O!a+XO~O^%fO!V/lO'l%fO~O!W/nO~P!3XO!]/oO!^/oO'v!kO(V!lO~O|/qO(V!lO~O#T/rO~O'u&POd'`X!V'`X~O!V*kOd(Pa~Od/wO~Oy/xOz/xO|/yOgva(jva(kva!Vva#Xva~Odva#yva~P$ aOy)uO|)vOg$la(j$la(k$la!V$la#X$la~Od$la#y$la~P$!VOy)uO|)vOg$na(j$na(k$na!V$na#X$na~Od$na#y$na~P$!xO#d/{O~Od$|a!V$|a#X$|a#y$|a~P!0dO!a#tO~O#d0OO~O!V*|O^(ua'l(ua~Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!niX!nik!ni!V!ni!e!ni!l!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#o!ni#q!ni#s!ni#u!ni#v!ni(c!ni(j!ni(k!ni~O^!ni'l!ni'j!ni!S!ni!g!nio!ni!X!ni%a!ni!a!ni~P$$gOg.TO!X'UO%a.SO~Oi0YO'u0XO~P!1UO!a+XO^'}a!X'}a'l'}a!V'}a~O#d0`O~OXYX!VcX!WcX~O!V0aO!W(yX~O!W0cO~OX0dO~O'u+aO'wTO'zUO~O!X%vO'u%_O]'hX!V'hX~O!V+fO](xa~O!g0iO~P!7sOX0lO~O]0mO~O#X0pO~Og0sO!X${O~O(V(sO!W(vP~Og0|O!X0yO%a0{O(O%QO~OX1WO!V1UO!W(wX~O!W1XO~O]1ZO^%fO'l%fO~O'u#lO'wTO'zUO~O#X$dO#{$dOP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX~O#o1^O&R1_O^(XX!f(XX~P$+]O#X$dO#o1^O&R1_O~O^1aO~P%TO^1cO~O&[1fOP&YiQ&YiV&Yi^&Yia&Yib&Yii&Yik&Yil&Yim&Yis&Yiu&Yiw&Yi|&Yi!Q&Yi!R&Yi!X&Yi!c&Yi!h&Yi!k&Yi!l&Yi!m&Yi!o&Yi!q&Yi!t&Yi!x&Yi#p&Yi$Q&Yi$U&Yi%`&Yi%b&Yi%d&Yi%e&Yi%f&Yi%i&Yi%k&Yi%n&Yi%o&Yi%q&Yi%}&Yi&T&Yi&V&Yi&X&Yi&Z&Yi&^&Yi&d&Yi&j&Yi&l&Yi&n&Yi&p&Yi&r&Yi'j&Yi'u&Yi'w&Yi'z&Yi(S&Yi(b&Yi(o&Yi!W&Yi_&Yi&a&Yi~O_1lO!W1jO&a1kO~P`O!XXO!h1nO~O&h,iOP&ciQ&ciV&ci^&cia&cib&cii&cik&cil&cim&cis&ciu&ciw&ci|&ci!Q&ci!R&ci!X&ci!c&ci!h&ci!k&ci!l&ci!m&ci!o&ci!q&ci!t&ci!x&ci#p&ci$Q&ci$U&ci%`&ci%b&ci%d&ci%e&ci%f&ci%i&ci%k&ci%n&ci%o&ci%q&ci%}&ci&T&ci&V&ci&X&ci&Z&ci&^&ci&d&ci&j&ci&l&ci&n&ci&p&ci&r&ci'j&ci'u&ci'w&ci'z&ci(S&ci(b&ci(o&ci!W&ci&[&ci_&ci&a&ci~O!S1tO~O!V!Za!W!Za~P#ByOl!mO|!nO!U1zO(V!lO!V'OX!W'OX~P?wO!V,yO!W(Za~O!V'UX!W'UX~P!6{O!V,|O!W(ia~O!W2RO~P'WO^%fO#X2[O'l%fO~O^%fO!a#tO#X2[O'l%fO~O^%fO!a#tO!l2`O#X2[O'l%fO(c'fO~O^%fO'l%fO~P!7sO!V$`Oo$ka~O!S&}i!V&}i~P!7sO!V'zO!S(Yi~O!V(RO!S(gi~O!S(hi!V(hi~P!7sO!V(ei!g(ei^(ei'l(ei~P!7sO#X2bO!V(ei!g(ei^(ei'l(ei~O!V(_O!g(di~O|%`O!X%aO!x]O#b2gO#c2fO'u%_O~O|%`O!X%aO#c2fO'u%_O~Og2nO!X'UO%a2mO~Og2nO!X'UO%a2mO(O%QO~O#dvaPvaXva^vakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva'lva(Sva(cva!gva!Sva'jvaova!Xva%ava!ava~P$ aO#d$laP$laX$la^$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la'l$la(S$la(c$la!g$la!S$la'j$lao$la!X$la%a$la!a$la~P$!VO#d$naP$naX$na^$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na'l$na(S$na(c$na!g$na!S$na'j$nao$na!X$na%a$na!a$na~P$!xO#d$|aP$|aX$|a^$|ak$|az$|a!V$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a'l$|a(S$|a(c$|a!g$|a!S$|a'j$|a#X$|ao$|a!X$|a%a$|a!a$|a~P#,`O^#[q!V#[q'l#[q'j#[q!S#[q!g#[qo#[q!X#[q%a#[q!a#[q~P!7sOd'PX!V'PX~P!'oO!V.^Od(]a~O!U2vO!V'QX!g'QX~P%TO!V.aO!g(^a~O!V.aO!g(^a~P!7sO!S2yO~O#y!ja!W!ja~PJqO#y!ba!V!ba!W!ba~P#ByO#y!na!W!na~P!:^O#y!pa!W!pa~P!<wO!X3]O$UfO$_3^O~O!W3bO~Oo3cO~P#,`O^$hq!V$hq'l$hq'j$hq!S$hq!g$hqo$hq!X$hq%a$hq!a$hq~P!7sO!S3dO~P#,`Oy)uO|)vO(k)zOg%Xi(j%Xi!V%Xi#X%Xi~Od%Xi#y%Xi~P$IuOy)uO|)vOg%Zi(j%Zi(k%Zi!V%Zi#X%Zi~Od%Zi#y%Zi~P$JhO(c$YO~P#,`O!U3gO'u%_O!V'[X!g'[X~O!V/UO!g(pa~O!V/UO!a#tO!g(pa~O!V/UO!a#tO(c'fO!g(pa~Od$ui!V$ui#X$ui#y$ui~P!0dO!U3oO'u*WO!S'^X!V'^X~P!1RO!V/^O!S(qa~O!V/^O!S(qa~P#,`O!a#tO#o3wO~Ok3zO!a#tO(c'fO~Od(Qi!V(Qi~P!0dO#X3}Od(Qi!V(Qi~P!0dO!g4QO~O^$iq!V$iq'l$iq'j$iq!S$iq!g$iqo$iq!X$iq%a$iq!a$iq~P!7sO!S4UO~O!V4VO!X(rX~P#,`O!f#vO~P4QO^$sX!X$sX%UYX'l$sX!V$sX~P!/ZO%U4XO^hXghXyhX|hX!XhX'lhX(jhX(khX!VhX~O%U4XO~O%b4`O'u+aO'wTO'zUO!V'gX!W'gX~O!V0aO!W(ya~OX4dO~O]4eO~O^%fO'l%fO~P#,`O!X${O~P#,`O!V4mO#X4oO!W(vX~O!W4pO~Ol!mO|4qO![!wO!]!tO!^!tO!x9qO!|!oO!}!oO#O!oO#P!oO#Q!oO#T4vO#U!xO'v!kO'wTO'zUO(V!lO(b!rO~O!W4uO~P%$gOg4{O!X0yO%a4zO~Og4{O!X0yO%a4zO(O%QO~O'u#lO!V'fX!W'fX~O!V1UO!W(wa~O'wTO'zUO(V5UO~O]5YO~O#o5]O&R5^O~PMaO!g5_O~P%TO^5aO~O^5aO~P%TO_1lO!W5fO&a1kO~P`O!a5hO~O!a5jO!V([i!W([i!a([i!h([i(O([i~O!V#ai!W#ai~P#ByO#X5kO!V#ai!W#ai~O!V!Zi!W!Zi~P#ByO^%fO#X5tO'l%fO~O^%fO!a#tO#X5tO'l%fO~O!V(eq!g(eq^(eq'l(eq~P!7sO!V(_O!g(dq~O|%`O!X%aO#c5{O'u%_O~O!X'UO%a6OO~Og6RO!X'UO%a6OO~O#d%XiP%XiX%Xi^%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi'l%Xi(S%Xi(c%Xi!g%Xi!S%Xi'j%Xio%Xi!X%Xi%a%Xi!a%Xi~P$IuO#d%ZiP%ZiX%Zi^%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi'l%Zi(S%Zi(c%Zi!g%Zi!S%Zi'j%Zio%Zi!X%Zi%a%Zi!a%Zi~P$JhO#d$uiP$uiX$ui^$uik$uiz$ui!V$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui'l$ui(S$ui(c$ui!g$ui!S$ui'j$ui#X$uio$ui!X$ui%a$ui!a$ui~P#,`Od'Pa!V'Pa~P!0dO!V'Qa!g'Qa~P!7sO!V.aO!g(^i~O#y#[i!V#[i!W#[i~P#ByOP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O(SVOX#fik#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~O#g#fi~P%2vO#g9yO~P%2vOP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO(SVOX#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~Ok#fi~P%5ROk9{O~P%5ROP$[Ok9{Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O(SVO#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P%7^OX:XO!e9}O#l9}O#m9}O#n:WO#o9}O~P%7^OP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO(SVO#s#fi#u#fi#v#fi#y#fi(c#fi(k#fi!V#fi!W#fi~O(j#fi~P%9xO(j#{O~P%9xOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO(SVO(j#{O#u#fi#v#fi#y#fi(c#fi!V#fi!W#fi~O(k#fi~P%<TO(k#|O~P%<TOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO#u:SO(SVO(j#{O(k#|O~O#v#fi#y#fi(c#fi!V#fi!W#fi~P%>`O^#wy!V#wy'l#wy'j#wy!S#wy!g#wyo#wy!X#wy%a#wy!a#wy~P!7sOg;lOy)uO|)vO(j)xO(k)zO~OP#fiX#fik#fiz#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(S#fi(c#fi!V#fi!W#fi~P%AWO!f#vOP(RXX(RXg(RXk(RXy(RXz(RX|(RX!e(RX!h(RX!l(RX#g(RX#h(RX#i(RX#j(RX#k(RX#l(RX#m(RX#n(RX#o(RX#q(RX#s(RX#u(RX#v(RX#y(RX(S(RX(c(RX(j(RX(k(RX!V(RX!W(RX~O#y#zi!V#zi!W#zi~P#ByO#y!ni!W!ni~P$$gO!W6_O~O!V'Za!W'Za~P#ByO!a#tO(c'fO!V'[a!g'[a~O!V/UO!g(pi~O!V/UO!a#tO!g(pi~Od$uq!V$uq#X$uq#y$uq~P!0dO!S'^a!V'^a~P#,`O!a6fO~O!V/^O!S(qi~P#,`O!V/^O!S(qi~O!S6jO~O!a#tO#o6oO~Ok6pO!a#tO(c'fO~O!S6rO~Od$wq!V$wq#X$wq#y$wq~P!0dO^$iy!V$iy'l$iy'j$iy!S$iy!g$iyo$iy!X$iy%a$iy!a$iy~P!7sO!a5jO~O!V4VO!X(ra~O^#[y!V#[y'l#[y'j#[y!S#[y!g#[yo#[y!X#[y%a#[y!a#[y~P!7sOX6wO~O!V0aO!W(yi~O]6}O~O(V(sO!V'cX!W'cX~O!V4mO!W(va~OikO'u7UO~P.bO!W7XO~P%$gOl!mO|7YO'wTO'zUO(V!lO(b!rO~O!X0yO~O!X0yO%a7[O~Og7_O!X0yO%a7[O~OX7dO!V'fa!W'fa~O!V1UO!W(wi~O!g7hO~O!g7iO~O!g7lO~O!g7lO~P%TO^7nO~O!a7oO~O!g7pO~O!V(hi!W(hi~P#ByO^%fO#X7xO'l%fO~O!V(ey!g(ey^(ey'l(ey~P!7sO!V(_O!g(dy~O!X'UO%a7{O~O#d$uqP$uqX$uq^$uqk$uqz$uq!V$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq'l$uq(S$uq(c$uq!g$uq!S$uq'j$uq#X$uqo$uq!X$uq%a$uq!a$uq~P#,`O#d$wqP$wqX$wq^$wqk$wqz$wq!V$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq'l$wq(S$wq(c$wq!g$wq!S$wq'j$wq#X$wqo$wq!X$wq%a$wq!a$wq~P#,`O!V'Qi!g'Qi~P!7sO#y#[q!V#[q!W#[q~P#ByOy/xOz/xO|/yOPvaXvagvakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva#yva(Sva(cva(jva(kva!Vva!Wva~Oy)uO|)vOP$laX$lag$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la#y$la(S$la(c$la(j$la(k$la!V$la!W$la~Oy)uO|)vOP$naX$nag$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na#y$na(S$na(c$na(j$na(k$na!V$na!W$na~OP$|aX$|ak$|az$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a#y$|a(S$|a(c$|a!V$|a!W$|a~P%AWO#y$hq!V$hq!W$hq~P#ByO#y$iq!V$iq!W$iq~P#ByO!W8VO~O#y8WO~P!0dO!a#tO!V'[i!g'[i~O!a#tO(c'fO!V'[i!g'[i~O!V/UO!g(pq~O!S'^i!V'^i~P#,`O!V/^O!S(qq~O!S8^O~P#,`O!S8^O~Od(Qy!V(Qy~P!0dO!V'aa!X'aa~P#,`O^%Tq!X%Tq'l%Tq!V%Tq~P#,`OX8cO~O!V0aO!W(yq~O#X8gO!V'ca!W'ca~O!V4mO!W(vi~P#ByOPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX~O!a%RX#o%RX~P&2WO!X0yO%a8kO~O'wTO'zUO(V8pO~O!V1UO!W(wq~O!g8sO~O!g8tO~O!g8uO~O!g8uO~P%TO#X8xO!V#ay!W#ay~O!V#ay!W#ay~P#ByO!X'UO%a8}O~O#y#wy!V#wy!W#wy~P#ByOP$uiX$uik$uiz$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui#y$ui(S$ui(c$ui!V$ui!W$ui~P%AWOy)uO|)vO(k)zOP%XiX%Xig%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi#y%Xi(S%Xi(c%Xi(j%Xi!V%Xi!W%Xi~Oy)uO|)vOP%ZiX%Zig%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi#y%Zi(S%Zi(c%Zi(j%Zi(k%Zi!V%Zi!W%Zi~O#y$iy!V$iy!W$iy~P#ByO#y#[y!V#[y!W#[y~P#ByO!a#tO!V'[q!g'[q~O!V/UO!g(py~O!S'^q!V'^q~P#,`O!S9UO~P#,`O!V0aO!W(yy~O!V4mO!W(vq~O!X0yO%a9]O~O!g9`O~O!X'UO%a9eO~OP$uqX$uqk$uqz$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq#y$uq(S$uq(c$uq!V$uq!W$uq~P%AWOP$wqX$wqk$wqz$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq#y$wq(S$wq(c$wq!V$wq!W$wq~P%AWOd%]!Z!V%]!Z#X%]!Z#y%]!Z~P!0dO!V'cq!W'cq~P#ByO!V#a!Z!W#a!Z~P#ByO#d%]!ZP%]!ZX%]!Z^%]!Zk%]!Zz%]!Z!V%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z'l%]!Z(S%]!Z(c%]!Z!g%]!Z!S%]!Z'j%]!Z#X%]!Zo%]!Z!X%]!Z%a%]!Z!a%]!Z~P#,`OP%]!ZX%]!Zk%]!Zz%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z#y%]!Z(S%]!Z(c%]!Z!V%]!Z!W%]!Z~P%AWOo(WX~P1jO'v!kO~P!){O!ScX!VcX#XcX~P&2WOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#XYX#XcX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX~O!acX!gYX!gcX(ccX~P&GnOP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!XXO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'u)TO'wTO'zUO(SVO(b[O(o;_O~O!V:UO!W$ka~Oi%ROk$sOl$rOm$rOs%SOu%TOw:[O|$zO!X${O!c;fO!h$wO#c:bO$Q%XO$m:^O$o:`O$r%YO'u(kO'wTO'zUO(O%QO(S$tO~O#p)[O~P&LdO!WYX!WcX~P&GnO#d9xO~O!a#tO#d9xO~O#X:YO~O#o9}O~O#X:dO!V(hX!W(hX~O#X:YO!V(fX!W(fX~O#d:eO~Od:gO~P!0dO#d:lO~O#d:mO~O!a#tO#d:nO~O!a#tO#d:eO~O#y:oO~P#ByO#d:pO~O#d:qO~O#d:rO~O#d:sO~O#d:tO~O#d:uO~O#y:vO~P!0dO#y:wO~P!0dO$U~!f!|!}#P#Q#T#b#c#n(o$m$o$r%U%`%a%b%i%k%n%o%q%s~'pR$U(o#h!R'n'v#il#g#jky'o(V'o'u$W$Y$W~",
  goto: "$&a(}PPPP)OP)RP)cP*r.uPPPP5UPP5kP;f>mP?QP?QPPP?QP@rP?QP?QP?QP@vPP@{PAfPF]PPPFaPPPPFaIaPPPIgJbPFaPLoPPPPN}FaPPPFaPFaP!#]FaP!&p!'r!'{P!(n!(r!(nPPPPP!+|!'rPP!,j!-dP!0WFaFa!0]!3f!7z!7z!;oPPP!;vFaPPPPPPPPPPP!?SP!@ePPFa!ArPFaPFaFaFaFaPFa!CUPP!F]P!I`P!Id!In!Ir!IrP!FYP!Iv!IvP!LyP!L}FaFa!MT#!V?QP?QP?Q?QP##a?Q?Q#%]?Q#'l?Q#)b?Q?Q#*O#+|#+|#,Q#,Y#+|#,bP#+|P?Q#,z?Q#.T?Q?Q5UPPP#/aPPP#/y#/yP#/yP#0`#/yPP#0fP#0]P#0]#0x#0]#1d#1j5R)R#1m)RP#1t#1t#1tP)RP)RP)RP)RPP)RP#1z#1}P#1})RP#2RP#2UP)RP)RP)RP)RP)RP)R)RPP#2[#2b#2l#2r#2x#3O#3U#3d#3j#3p#3z#4Q#4[#4k#4q#5b#5t#5z#6Q#6`#6u#8W#8f#8l#8r#8x#9O#9Y#9`#9f#9p#:S#:YPPPPPPPPPP#:`PPPPPPP#;S#>ZP#?j#?q#?yPPPP#DX#F}#Me#Mh#Mk#Nd#Ng#Nj#Nq#NyPP$ P$ T$ {$!z$#O$#dPP$#h$#n$#rP$#u$#y$#|$$r$%Y$%p$%t$%w$%z$&Q$&T$&X$&]R!zRmqOXs!Y#b%e&h&j&k&m,a,f1f1iY!tQ'U-R0y4tQ%kuQ%sxQ%z{Q&`!US&|!d,yQ'[!hS'b!q!wS*^${*cQ+_%tQ+l%|Q,Q&YQ-P'TQ-Z']Q-c'cQ/o*eQ1T,RR:c9t$|dOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{,^,a,f-V-_-m-s.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2v4q4{5]5^5a5t7Y7_7n7xS#o]9q!r)V$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ*n%UQ+d%vQ,S&]Q,Z&eQ.W:ZQ0V+VQ0Z+XQ0f+eQ1],XQ2j.TQ4_0aQ5S1UQ6Q2nQ6W:[Q6y4`R8O6R&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bt!mQ!q!t!w!x&|'T'U'b'c'd,y-P-R-c0y4t4v$^$ri#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lQ%}{Q&z!dS'Q%a,|Q+d%vQ/z*rQ0f+eQ0k+kQ1[,WQ1],XQ4_0aQ4h0mQ5V1WQ5W1ZQ6y4`Q6|4eQ7g5YQ8f6}R8q7dpnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iR,U&a&t^OPXYstuvy!Y!_!f!i!n#Q#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y'W'h'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;a;b[#ZWZ#U#X&}'x!S%bm#f#g#j%]%`(R(](^(_*y*z*|,],s-q-w-x-y-{1n2f2g5j5{Q%nwQ%rxS%w{%|Q&T!SQ'X!gQ'Z!hQ(f#qS*Q$w*US+^%s%tQ+b%vQ+{&WQ,P&YS-Y'[']Q.V(gQ/Y*RQ0_+_Q0e+eQ0g+fQ0j+jQ1O+|S1S,Q,RQ2W-ZQ3f/UQ4^0aQ4b0dQ4g0lQ5R1TQ6c3gQ6x4`Q6{4dQ8b6wR9W8cv$yi#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h!S%px!h!s%r%s%t&{'Z'[']'a'k*]+^+_,v-Y-Z-b/g0_2P2W2_3yQ+W%nQ+q&QQ+t&RQ,O&YQ.U(fQ0}+{U1R,P,Q,RQ2o.VQ4|1OS5Q1S1TQ7c5R#O;c#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lg;d:W:X:^:`:b:i:k:m:q:s:wW%Oi%Q*k;_S&Q!P&_Q&R!QQ&S!RR+o&O$_$}i#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lT)q$t)rV*o%U:Z:[U'Q!d%a,|S(t#x#yQ+i%yS.O(b(cQ0t+uQ4O/xR7R4m&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;b$i$_c#W#c%i%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.i.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;UT#RV#S&{kOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ'O!dR1{,yv!mQ!d!q!t!w!x&|'T'U'b'c'd,y-P-R-c0y4t4vS*]${*cS/g*^*eQ/p*fQ0v+wQ3y/oR3|/rlqOXs!Y#b%e&h&j&k&m,a,f1f1iQ&o!]Q'l!vS(h#s9xQ+[%qQ+y&TQ+z&VQ-W'YQ-e'eS.[(m:eS/}*w:nQ0]+]Q0x+xQ1m,hQ1o,iQ1w,tQ2U-XQ2X-]S4T0O:tQ4Y0^S4]0`:uQ5l1yQ5p2VQ5u2^Q6v4ZQ7s5nQ7t5qQ7w5vR8w7p$d$^c#W#c%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;US(e#n'_U*h$|(l3YS+R%i.iQ2k0VQ5}2jQ7}6QR9O8O$d$]c#W#c%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;US(d#n'_S(v#y$^S+Q%i.iS.P(c(eQ.l)WQ0S+RR2h.Q&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bS#o]9qQ&j!WQ&k!XQ&m!ZQ&n![R1e,dQ'V!gQ+T%nQ-U'XS.R(f+WQ2S-TW2l.U.V0U0WQ5o2TU5|2i2k2oS7z5}6PS8|7|7}S9c8{9OQ9k9dR9n9lU!uQ'U-RT4r0y4t!O_OXZ`s!U!Y#b#f%]%e&_&a&h&j&k&m(_,a,f-x1f1i]!oQ!q'U-R0y4tT#o]9q%WzOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xS(t#x#yS.O(b(c!s:{$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bY!sQ'U-R0y4tQ'a!qS'k!t!wS'm!x4vS-b'b'cQ-d'dR2_-cQ'j!sS(Z#e1`S-a'a'mQ/X*QQ/e*]Q2`-dQ3k/YS3t/f/pQ6b3fS6m3z3|Q8Y6cR8a6pQ#ubQ'i!sS(Y#e1`S([#k*vQ*x%^Q+Y%oQ+`%uU-`'a'j'mQ-t(ZQ/W*QQ/d*]Q/j*`Q0[+ZQ1P+}S2]-a-dQ2e-|S3j/X/YS3s/e/pQ3v/iQ3x/kQ5O1QQ5w2`Q6a3fQ6e3kS6i3t3|Q6n3{Q7a5PS8X6b6cQ8]6jQ8_6mQ8n7bQ9S8YQ9T8^Q9V8aQ9_8oQ9g9UQ;O:yQ;Z;SR;[;TV!uQ'U-R%WaOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xS#uy!i!r:x$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bR;O;a%WbOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xQ%^j!S%ox!h!s%r%s%t&{'Z'[']'a'k*]+^+_,v-Y-Z-b/g0_2P2W2_3yS%uy!iQ+Z%pQ+}&YW1Q,O,P,Q,RU5P1R1S1TS7b5Q5RQ8o7c!r:y$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ;S;`R;T;a$zeOPXYstuv!Y!_!f!n#Q#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xY#`WZ#U#X'x!S%bm#f#g#j%]%`(R(](^(_*y*z*|,],s-q-w-x-y-{1n2f2g5j5{Q,[&e!p:z$Z$l)i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bR:}&}S'R!d%aR1},|$|dOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{,^,a,f-V-_-m-s.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2v4q4{5]5^5a5t7Y7_7n7x!r)V$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ,Z&eQ0V+VQ2j.TQ6Q2nR8O6R!f$Tc#W%i'w'}(i(p)P)Q)R)S)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9r!T:P)U)g,w.i1u1x2z3S3T3U3V3Z3a5m6V6[6]7T7r8P8T8U9Y9a;U!b$Vc#W%i'w'}(i(p)R)S)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9r!P:R)U)g,w.i1u1x2z3U3V3Z3a5m6V6[6]7T7r8P8T8U9Y9a;U!^$Zc#W%i'w'}(i(p)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9rQ3e/Sz;b)U)g,w.i1u1x2z3Z3a5m6V6[6]7T7r8P8T8U9Y9a;UQ;g;iR;h;j&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bS$mh$nR3^.o'RgOPWXYZhstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l$n%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.o.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bT$if$oQ$gfS)`$j)dR)l$oT$hf$oT)b$j)d'RhOPWXYZhstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l$n%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.o.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bT$mh$nQ$phR)k$n%WjOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7x!s;`$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;b#alOPXZs!Y!_!n#Q#b#m#z$l%e&a&d&e&h&j&k&m&q&y'W(u)i*{+V,^,a,f-V.T.p/y0|1^1_1a1c1f1i1k2n3]4q4{5]5^5a6R7Y7_7nv$|i#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h#O(l#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lQ*s%YQ.{)ug3Y:W:X:^:`:b:i:k:m:q:s:wv$xi#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;hQ*V$yS*`${*cQ*t%ZQ/k*a#O;Q#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lf;R:W:X:^:`:b:i:k:m:q:s:wQ;V;cQ;W;dQ;X;eR;Y;fv$|i#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h#O(l#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lg3Y:W:X:^:`:b:i:k:m:q:s:wloOXs!Y#b%e&h&j&k&m,a,f1f1iQ*Y$zQ,o&tQ,p&vR3n/^$^$}i#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lQ+r&RQ0r+tQ4k0qR7Q4lT*b${*cS*b${*cT4s0y4tS/i*_4qT3{/q7YQ+Y%oQ/j*`Q0[+ZQ1P+}Q5O1QQ7a5PQ8n7bR9_8on)y$u(n*u/[/s/t2s3l4R6`6q9R;P;];^!Y:h(j)Z*P*X.Z.w.|/S/a0T0o0q2r3m3q4j4l6S6T6g6k6s6u8[8`9f;i;j]:i3X6Z8Q9P9Q9op){$u(n*u/Q/[/s/t2s3l4R6`6q9R;P;];^![:j(j)Z*P*X.Z.w.|/S/a0T0o0q2p2r3m3q4j4l6S6T6g6k6s6u8[8`9f;i;j_:k3X6Z8Q8R9P9Q9opnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iQ&[!TR,^&epnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iR&[!TQ+v&SR0n+oqnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iQ0z+{S4y0}1OU7Z4w4x4|S8j7]7^S9Z8i8lQ9h9[R9m9iQ&c!UR,V&_R5V1WS%w{%|R0g+fQ&h!VR,a&iR,g&nT1g,f1iR,k&oQ,j&oR1p,kQ'o!yR-g'oQsOQ#bXT%hs#bQ!|TR'q!|Q#PUR's#PQ)r$tR.x)rQ#SVR'u#SQ#VWU'{#V'|-nQ'|#WR-n'}Q,z'OR1|,zQ._(nR2t._Q.b(pS2w.b2xR2x.cQ-R'UR2Q-RY!qQ'U-R0y4tR'`!qS#]W%`U(S#](T-oQ(T#^R-o(OQ,}'RR2O,}r`OXs!U!Y#b%e&_&a&h&j&k&m,a,f1f1iS#fZ%]U#p`#f-xR-x(_Q(`#hQ-u([W-}(`-u2c5yQ2c-vR5y2dQ)d$jR.q)dQ$nhR)j$nQ$acU)Y$a-j:VQ-j9rR:V)gQ/V*QW3h/V3i6d8ZU3i/W/X/YS6d3j3kR8Z6e#o)w$u(j(n)Z*P*X*p*q*u.X.Y.Z.w.|/Q/R/S/[/a/s/t0T0o0q2p2q2r2s3X3l3m3q4R4j4l6S6T6X6Y6Z6`6g6k6q6s6u8Q8R8S8[8`9P9Q9R9f9o;P;];^;i;jQ/_*XU3p/_3r6hQ3r/aR6h3qQ*c${R/m*cQ*l%PR/v*lQ4W0TR6t4WQ*}%cR0R*}Q4n0tS7S4n8hR8h7TQ+x&TR0w+xQ4t0yR7W4tQ1V,SS5T1V7eR7e5VQ0b+bW4a0b4c6z8dQ4c0eQ6z4bR8d6{Q+g%wR0h+gQ1i,fR5e1iWrOXs#bQ&l!YQ+P%eQ,`&hQ,b&jQ,c&kQ,e&mQ1d,aS1g,f1iR5d1fQ%gpQ&p!^Q&s!`Q&u!aQ&w!bQ'g!sQ+O%dQ+[%qQ+n%}Q,U&cQ,m&rW-^'a'i'j'mQ-e'eQ/l*bQ0]+]S1Y,V,YQ1q,lQ1r,oQ1s,pQ2X-]W2Z-`-a-d-fQ4Y0^Q4f0kQ4i0oQ4}1PQ5X1[Q5c1eU5r2Y2]2`Q5u2^Q6v4ZQ7O4hQ7P4jQ7V4sQ7`5OQ7f5WS7u5s5wQ7w5vQ8e6|Q8m7aQ8r7gQ8y7vQ9X8fQ9^8nQ9b8zR9j9_Q%qxQ'Y!hQ'e!sU+]%r%s%tQ,t&{U-X'Z'[']S-]'a'kQ/c*]S0^+^+_Q1y,vS2V-Y-ZQ2^-bQ3u/gQ4Z0_Q5n2PQ5q2WQ5v2_R6l3yS$vi;_R*m%QU%Pi%Q;_R/u*kQ$uiS(j#t+XQ(n#vS)Z$b$cQ*P$wQ*X$zQ*p%VQ*q%WQ*u%[Q.X:]Q.Y:_Q.Z:aQ.w)pS.|)v/OQ/Q)yQ/R){Q/S)|Q/[*TQ/a*ZQ/s*iQ/t*jh0T+U.S0{2m4z6O7[7{8k8}9]9eQ0o+pQ0q+sQ2p:hQ2q:jQ2r:lQ2s.^S3X:W:XQ3l/]Q3m/^Q3q/`Q4R/{Q4j0pQ4l0sQ6S:pQ6T:rQ6X:^Q6Y:`Q6Z:bQ6`3eQ6g3oQ6k3wQ6q3}Q6s4VQ6u4XQ8Q:mQ8R:iQ8S:kQ8[6fQ8`6oQ9P:qQ9Q:sQ9R8WQ9f:vQ9o:wQ;P;_Q;];gQ;^;hQ;i;kR;j;llpOXs!Y#b%e&h&j&k&m,a,f1f1iQ!ePS#dZ#mQ&r!_U'^!n4q7YQ't#QQ(w#zQ)h$lS,Y&a&dQ,_&eQ,l&qQ,q&yQ-T'WQ.e(uQ.u)iQ0P*{Q0W+VQ1b,^Q2T-VQ2k.TQ3`.pQ4P/yQ4x0|Q5Z1^Q5[1_Q5`1aQ5b1cQ5g1kQ5}2nQ6^3]Q7^4{Q7j5]Q7k5^Q7m5aQ7}6RQ8l7_R8v7n#UcOPXZs!Y!_!n#b#m#z%e&a&d&e&h&j&k&m&q&y'W(u*{+V,^,a,f-V.T/y0|1^1_1a1c1f1i1k2n4q4{5]5^5a6R7Y7_7nQ#WWQ#cYQ%itQ%juS%lv!fS'w#U'zQ'}#XQ(i#sQ(p#wQ(x#}Q(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)R$WQ)S$XQ)U$ZQ)X$`Q)]$dW)g$l)i.p3]Q+S%kQ+h%xS,w&}1zQ-f'hS-k'x-mQ-p(QQ-r(XQ.](mQ.c(qQ.g9pQ.i9sQ.j9tQ.k9wQ.z)tQ/|*wQ1u,rQ1x,uQ2Y-_Q2a-sQ2u.aQ2z9xQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S:QQ3T:RQ3U:SQ3V:TQ3W.hQ3Z:YQ3[:cQ3a:UQ4S0OQ4[0`Q5m:dQ5s2[Q5x2bQ6U2vQ6V:eQ6[:gQ6]:nQ7T4oQ7r5kQ7v5tQ8P:oQ8T:tQ8U:uQ8z7xQ9Y8gQ9a8xQ9r#QR;U;bR#YWR'P!dY!sQ'U-R0y4tS&{!d,yQ'a!qS'k!t!wS'm!x4vS,v&|'TS-b'b'cQ-d'dQ2P-PR2_-cR(o#vR(r#wQ!eQT-Q'U-R]!pQ!q'U-R0y4tQ#n]R'_9qT#iZ%]S#hZ%]S%cm,]U([#f#g#jS-v(](^Q-z(_Q0Q*|Q2d-wU2e-x-y-{S5z2f2gR7y5{`#[W#U#X%`'x(R*y-qr#eZm#f#g#j%](](^(_*|-w-x-y-{2f2g5{Q1`,]Q1v,sQ5i1nQ7q5jT:|&}*zT#_W%`S#^W%`S'y#U(RS(O#X*yS,x&}*zT-l'x-qT'S!d%aQ$jfR)n$oT)c$j)dR3_.oT*S$w*UR*[$zQ0U+UQ2i.SQ4w0{Q6P2mQ7]4zQ7|6OQ8i7[Q8{7{Q9[8kQ9d8}Q9i9]R9l9elqOXs!Y#b%e&h&j&k&m,a,f1f1iQ&b!UR,U&_rmOXs!T!U!Y#b%e&_&h&j&k&m,a,f1f1iR,]&eT%dm,]R0u+uR,T&]Q%{{R+m%|R+c%vT&f!V&iT&g!V&iT1h,f1i",
  nodeNames: " ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 366,
  context: KNe,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 199, 203, 207, 208, 210, 213, 216, 226, 228, 234, 236, 238, 240, 243, 249, 255, 257, 259, 261, 263, 265, 266, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 103, 104, 113, 114, 131, 134, 136, 137, 138, 139, 141, 142, 162, 163, 165, "Expression", -23, 24, 26, 30, 34, 36, 38, 166, 168, 170, 171, 173, 174, 175, 177, 178, 179, 181, 182, 183, 193, 195, 197, 198, "Type", -3, 84, 96, 102, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 143, "JSXStartTag", 155, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 144, "JSXSelfCloseEndTag JSXEndTag", 160, "JSXEndTag"]
  ],
  propSources: [rLe],
  skippedNodes: [0, 3, 4, 269],
  repeatNodeCount: 33,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$d&j'{!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'{!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$d&j'xpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'xpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$d&j'xp'{!b'n(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'y#S$d&j'o(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$d&j'xp'{!b'o(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$d&j!l$Ip'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#q$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#q$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'w$(n$d&j'{!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$d&j'{!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$d&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$_#t$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$_#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$_#t$d&j'{!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'{!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$_#t'{!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$d&j(b!L^'xp'{!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$d&j'xp'{!b(V!LY'u&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$d&j'xp'{!b$W#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$d&j'xp'{!b#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$d&j#{$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(k%<v$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$d&j#u$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'z$)`$d&j'xpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$d&j'xpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$d&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$_#t$d&j'xpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'xpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$_#t'xpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$d&j'xp'{!b'v#)d#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$d&j'xp'{!b#g$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$d&j'xp'{!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$d&j'xp'{!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$d&j'xp'{!b#h$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$d&j'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$d&j'{!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$d&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$d&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$d&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$d&j'{!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'{!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'{!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'{!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$d&j'{!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$d&j'xp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$d&j'xp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'xp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'xp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'xpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$d&j'xpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$d&j'xp'{!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'xp'{!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'xp'{!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'xp'{!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$d&j'xp'{!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$d&j'xp'{!b'p(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$d&j'xp'{!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$d&j'{!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$d&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'{!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$d&j'xpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'xpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'xp'{!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$d&j#{$Id'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$T#t$d&j'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$d&j#y%<f'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^(O!*v!e'.r'xp'{!b$U)d(oSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$f&j'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#k$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#{$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#l$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#X%?x$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#d$Ih$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#l$Id$a#|$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#l$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#k$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#k$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(c$Ip$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$d&j#v$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$d&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$d&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$d&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$d&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$d&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!2r$-S_!S!+S$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#s$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$d&j'xp'{!b(S&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$d&j'xp'{!b(V!LY'u&;d$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$d&j'xp'{!b$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(j%<v$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$d&j'xp'{!b'n(;d(V!LY'u&;d$W#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$d&j'xp'{!b'o(;d(V!LY'u&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [eLe, tLe, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, JNe, new kb("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(U~~", 141, 327), new kb("j~RQYZXz{^~^O'r~~aP!P!Qd~iO's~~", 25, 309)],
  topRules: { Script: [0, 5], SingleExpression: [1, 267], SingleClassItem: [2, 268] },
  dialects: { jsx: 12794, ts: 12796 },
  dynamicPrecedences: { 76: 1, 78: 1, 163: 1, 191: 1 },
  specialized: [{ term: 313, get: (r) => iLe[r] || -1 }, { term: 329, get: (r) => nLe[r] || -1 }, { term: 67, get: (r) => aLe[r] || -1 }],
  tokenPrec: 12820
}), sLe = [
  /* @__PURE__ */ fr("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fr(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ fr(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ fr(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fr('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ fr('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], sB = /* @__PURE__ */ new oZ(), I9 = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function Ad(r) {
  return (e, t) => {
    let i = e.node.getChild("VariableDefinition");
    return i && t(i, r), !0;
  };
}
const lLe = ["FunctionDeclaration"], uLe = {
  FunctionDeclaration: /* @__PURE__ */ Ad("function"),
  ClassDeclaration: /* @__PURE__ */ Ad("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ Ad("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ Ad("type"),
  NamespaceDeclaration: /* @__PURE__ */ Ad("namespace"),
  VariableDefinition(r, e) {
    r.matchContext(lLe) || e(r, "variable");
  },
  TypeDefinition(r, e) {
    e(r, "type");
  },
  __proto__: null
};
function x9(r, e) {
  let t = sB.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function a(o, s) {
    let l = r.sliceString(o.from, o.to);
    i.push({ label: l, type: s });
  }
  return e.cursor(Bt.IncludeAnonymous).iterate((o) => {
    if (n)
      n = !1;
    else if (o.name) {
      let s = uLe[o.name];
      if (s && s(o, a) || I9.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let s of x9(r, o.node))
        i.push(s);
      return !1;
    }
  }), sB.set(e, i), i;
}
const lB = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, w9 = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function hLe(r) {
  let e = qt(r.state).resolveInner(r.pos, -1);
  if (w9.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && lB.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    I9.has(n.name) && (i = i.concat(x9(r.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : r.pos,
    validFor: lB
  };
}
const zs = /* @__PURE__ */ co.define({
  name: "javascript",
  parser: /* @__PURE__ */ oLe.configure({
    props: [
      /* @__PURE__ */ Al.add({
        IfStatement: /* @__PURE__ */ to({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ to({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: dZ,
        SwitchBody: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : i ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ bp({ closing: "}" }),
        ArrowFunction: (r) => r.baseIndent + r.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ to({ except: /^{/ }),
        JSXElement(r) {
          let e = /^\s*<\//.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        JSXEscape(r) {
          let e = /\s*\}/.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        }
      }),
      /* @__PURE__ */ Cl.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": lv,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), cLe = /* @__PURE__ */ zs.configure({ dialect: "ts" }, "typescript"), fLe = /* @__PURE__ */ zs.configure({ dialect: "jsx" }), dLe = /* @__PURE__ */ zs.configure({ dialect: "jsx ts" }, "typescript"), pLe = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((r) => ({ label: r, type: "keyword" }));
function Bm(r = {}) {
  let e = r.jsx ? r.typescript ? dLe : fLe : r.typescript ? cLe : zs;
  return new xh(e, [
    zs.data.of({
      autocomplete: cP(w9, gT(sLe.concat(pLe)))
    }),
    zs.data.of({
      autocomplete: hLe
    }),
    r.jsx ? vLe : []
  ]);
}
function uB(r, e, t = r.length) {
  if (!e)
    return "";
  let i = e.getChild("JSXIdentifier");
  return i ? r.sliceString(i.from, Math.min(i.to, t)) : "";
}
const gLe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), vLe = /* @__PURE__ */ ge.inputHandler.of((r, e, t, i) => {
  if ((gLe ? r.composing : r.compositionStarted) || r.state.readOnly || e != t || i != ">" && i != "/" || !zs.isActiveAt(r.state, e, -1))
    return !1;
  let { state: n } = r, a = n.changeByRange((o) => {
    var s, l, u;
    let { head: h } = o, c = qt(n).resolveInner(h, -1), f;
    if (c.name == "JSXStartTag" && (c = c.parent), i == ">" && c.name == "JSXFragmentTag")
      return { range: z.cursor(h + 1), changes: { from: h, insert: "><>" } };
    if (i == ">" && c.name == "JSXIdentifier") {
      if (((l = (s = c.parent) === null || s === void 0 ? void 0 : s.lastChild) === null || l === void 0 ? void 0 : l.name) != "JSXEndTag" && (f = uB(n.doc, c.parent, h)))
        return { range: z.cursor(h + 1), changes: { from: h, insert: `></${f}>` } };
    } else if (i == "/" && c.name == "JSXFragmentTag") {
      let d = c.parent, p = d == null ? void 0 : d.parent;
      if (d.from == h - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "JSXEndTag" && (f = uB(n.doc, p == null ? void 0 : p.firstChild, h))) {
        let g = `/${f}>`;
        return { range: z.cursor(h + g.length), changes: { from: h, insert: g } };
      }
    }
    return { range: o };
  });
  return a.changes.empty ? !1 : (r.dispatch(a, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), Cd = ["_blank", "_self", "_top", "_parent"], $R = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], GR = ["get", "post", "put", "delete"], BR = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], Ji = ["true", "false"], pe = {}, mT = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: Cd,
      hreflang: null
    }
  },
  abbr: pe,
  acronym: pe,
  address: pe,
  applet: pe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: pe,
  aside: pe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: pe,
  base: { attrs: { href: null, target: Cd } },
  basefont: pe,
  bdi: pe,
  bdo: pe,
  big: pe,
  blockquote: { attrs: { cite: null } },
  body: pe,
  br: pe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: BR,
      formmethod: GR,
      formnovalidate: ["novalidate"],
      formtarget: Cd,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: pe,
  center: pe,
  cite: pe,
  code: pe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: pe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: pe,
  dir: pe,
  div: pe,
  dl: pe,
  dt: pe,
  em: pe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: pe,
  figure: pe,
  font: pe,
  footer: pe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": $R,
      autocomplete: ["on", "off"],
      enctype: BR,
      method: GR,
      novalidate: ["novalidate"],
      target: Cd
    }
  },
  frame: pe,
  frameset: pe,
  h1: pe,
  h2: pe,
  h3: pe,
  h4: pe,
  h5: pe,
  h6: pe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: pe,
  hgroup: pe,
  hr: pe,
  html: {
    attrs: { manifest: null }
  },
  i: pe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: BR,
      formmethod: GR,
      formnovalidate: ["novalidate"],
      formtarget: Cd,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: pe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: pe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: pe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: $R,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: pe,
  noframes: pe,
  noscript: pe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: pe,
  param: { attrs: { name: null, value: null } },
  pre: pe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: pe,
  rt: pe,
  ruby: pe,
  s: pe,
  samp: pe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: $R
    }
  },
  section: pe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: pe,
  source: { attrs: { src: null, type: null, media: null } },
  span: pe,
  strike: pe,
  strong: pe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: pe,
  summary: pe,
  sup: pe,
  table: pe,
  tbody: pe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: pe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: pe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: pe,
  time: { attrs: { datetime: null } },
  title: pe,
  tr: pe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  tt: pe,
  u: pe,
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: pe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: pe
}, P9 = {
  accesskey: null,
  class: null,
  contenteditable: Ji,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: Ji,
  autocorrect: Ji,
  autocapitalize: Ji,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  onclick: null,
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": Ji,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": Ji,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": Ji,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": Ji,
  "aria-hidden": Ji,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": Ji,
  "aria-multiselectable": Ji,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": Ji,
  "aria-relevant": null,
  "aria-required": Ji,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, OLe = /* @__PURE__ */ Object.keys(mT), hB = /* @__PURE__ */ Object.keys(P9);
function ff(r, e, t = r.length) {
  if (!e)
    return "";
  let i = e.firstChild, n = i && i.getChild("TagName");
  return n ? r.sliceString(n.from, Math.min(n.to, t)) : "";
}
function ET(r, e = !1) {
  for (let t = r.parent; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function N9(r, e) {
  let t = mT[ff(r, ET(e, !0))];
  return (t == null ? void 0 : t.children) || OLe;
}
function SP(r, e) {
  let t = [];
  for (let i = e; i = ET(i); ) {
    let n = ff(r, i);
    if (n && i.lastChild.name == "CloseTag")
      break;
    n && t.indexOf(n) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && t.push(n);
  }
  return t;
}
const L9 = /^[:\-\.\w\u00b7-\uffff]*$/;
function cB(r, e, t, i) {
  let n = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: N9(r.doc, e).map((a) => ({ label: a, type: "type" })).concat(SP(r.doc, e).map((a, o) => ({ label: "/" + a, apply: "/" + a + n, type: "type", boost: 99 - o }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function fB(r, e, t, i) {
  let n = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: SP(r.doc, e).map((a, o) => ({ label: a, apply: a + n, type: "type", boost: 99 - o })),
    validFor: L9
  };
}
function mLe(r, e, t) {
  let i = [], n = 0;
  for (let a of N9(r.doc, e))
    i.push({ label: "<" + a, type: "type" });
  for (let a of SP(r.doc, e))
    i.push({ label: "</" + a + ">", type: "type", boost: 99 - n++ });
  return { from: t, to: t, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function ELe(r, e, t, i) {
  let n = ET(e), a = n ? mT[ff(r.doc, n)] : null, o = a && a.attrs ? Object.keys(a.attrs).concat(hB) : hB;
  return {
    from: t,
    to: i,
    options: o.map((s) => ({ label: s, type: "property" })),
    validFor: L9
  };
}
function bLe(r, e, t, i) {
  var n;
  let a = (n = e.parent) === null || n === void 0 ? void 0 : n.getChild("AttributeName"), o = [], s;
  if (a) {
    let l = r.sliceDoc(a.from, a.to), u = P9[l];
    if (!u) {
      let h = ET(e), c = h ? mT[ff(r.doc, h)] : null;
      u = (c == null ? void 0 : c.attrs) && c.attrs[l];
    }
    if (u) {
      let h = r.sliceDoc(t, i).toLowerCase(), c = '"', f = '"';
      /^['"]/.test(h) ? (s = h[0] == '"' ? /^[^"]*$/ : /^[^']*$/, c = "", f = r.sliceDoc(i, i + 1) == h[0] ? "" : h[0], h = h.slice(1), t++) : s = /^[^\s<>='"]*$/;
      for (let d of u)
        o.push({ label: d, apply: c + d + f, type: "constant" });
    }
  }
  return { from: t, to: i, options: o, validFor: s };
}
function SLe(r) {
  let { state: e, pos: t } = r, i = qt(e).resolveInner(t), n = i.resolve(t, -1);
  for (let a = t, o; i == n && (o = n.childBefore(a)); ) {
    let s = o.lastChild;
    if (!s || !s.type.isError || s.from < s.to)
      break;
    i = n = o, a = s.from;
  }
  return n.name == "TagName" ? n.parent && /CloseTag$/.test(n.parent.name) ? fB(e, n, n.from, t) : cB(e, n, n.from, t) : n.name == "StartTag" ? cB(e, n, t, t) : n.name == "StartCloseTag" || n.name == "IncompleteCloseTag" ? fB(e, n, t, t) : r.explicit && (n.name == "OpenTag" || n.name == "SelfClosingTag") || n.name == "AttributeName" ? ELe(e, n, n.name == "AttributeName" ? n.from : t, t) : n.name == "Is" || n.name == "AttributeValue" || n.name == "UnquotedAttributeValue" ? bLe(e, n, n.name == "Is" ? t : n.from, t) : r.explicit && (i.name == "Element" || i.name == "Text" || i.name == "Document") ? mLe(e, n, t) : null;
}
const c1 = /* @__PURE__ */ co.define({
  parser: /* @__PURE__ */ mNe.configure({
    props: [
      /* @__PURE__ */ Al.add({
        Element(r) {
          let e = /^(\s*)(<\/)?/.exec(r.textAfter);
          return r.node.to <= r.pos + e[0].length ? r.continue() : r.lineIndent(r.node.from) + (e[2] ? 0 : r.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        },
        Document(r) {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length < r.node.to)
            return r.continue();
          let e = null, t;
          for (let i = r.node; ; ) {
            let n = i.lastChild;
            if (!n || n.name != "Element" || n.to != i.to)
              break;
            e = i = n;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? r.lineIndent(e.from) + r.unit : null;
        }
      }),
      /* @__PURE__ */ Cl.add({
        Element(r) {
          let e = r.firstChild, t = r.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : r.to };
        }
      })
    ],
    wrap: /* @__PURE__ */ ENe([
      {
        tag: "script",
        attrs(r) {
          return !r.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(r.type);
        },
        parser: zs.parser
      },
      {
        tag: "style",
        attrs(r) {
          return (!r.lang || r.lang == "css") && (!r.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(r.type));
        },
        parser: u1.parser
      }
    ])
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function TLe(r = {}) {
  let e = c1;
  return r.matchClosingTags === !1 && (e = e.configure({ dialect: "noMatch" })), new xh(e, [
    c1.data.of({ autocomplete: SLe }),
    r.autoCloseTags !== !1 ? yLe : [],
    Bm().support,
    h1().support
  ]);
}
const yLe = /* @__PURE__ */ ge.inputHandler.of((r, e, t, i) => {
  if (r.composing || r.state.readOnly || e != t || i != ">" && i != "/" || !c1.isActiveAt(r.state, e, -1))
    return !1;
  let { state: n } = r, a = n.changeByRange((o) => {
    var s, l, u;
    let { head: h } = o, c = qt(n).resolveInner(h, -1), f;
    if ((c.name == "TagName" || c.name == "StartTag") && (c = c.parent), i == ">" && c.name == "OpenTag") {
      if (((l = (s = c.parent) === null || s === void 0 ? void 0 : s.lastChild) === null || l === void 0 ? void 0 : l.name) != "CloseTag" && (f = ff(n.doc, c.parent, h)))
        return { range: z.cursor(h + 1), changes: { from: h, insert: `></${f}>` } };
    } else if (i == "/" && c.name == "OpenTag") {
      let d = c.parent, p = d == null ? void 0 : d.parent;
      if (d.from == h - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (f = ff(n.doc, p, h))) {
        let g = `/${f}>`;
        return { range: z.cursor(h + g.length), changes: { from: h, insert: g } };
      }
    }
    return { range: o };
  });
  return a.changes.empty ? !1 : (r.dispatch(a, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), RLe = Rl({
  String: R.string,
  Number: R.number,
  "True False": R.bool,
  PropertyName: R.propertyName,
  Null: R.null,
  ",": R.separator,
  "[ ]": R.squareBracket,
  "{ }": R.brace
}), ALe = fo.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [RLe],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), CLe = /* @__PURE__ */ co.define({
  parser: /* @__PURE__ */ ALe.configure({
    props: [
      /* @__PURE__ */ Al.add({
        Object: /* @__PURE__ */ to({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ to({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Cl.add({
        "Object Array": lv
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function _Le() {
  return new xh(CLe);
}
const ILe = 34, dB = 1, xLe = 2, VR = 3, tm = 4, wLe = 5, PLe = 6, NLe = 7, LLe = 8, DLe = 9, MLe = 10, kLe = 11, QLe = 12, ULe = 13, $Le = 14, GLe = 15, BLe = 16, VLe = 17, FLe = 18, XLe = 19, D9 = 20, M9 = 21, YLe = 22;
function f1(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 48 && r <= 57;
}
function HLe(r) {
  return r >= 48 && r <= 57 || r >= 97 && r <= 102 || r >= 65 && r <= 70;
}
function dc(r, e, t) {
  for (let i = !1; ; ) {
    if (r.next < 0)
      return;
    if (r.next == e && !i) {
      r.advance();
      return;
    }
    i = t && !i && r.next == 92, r.advance();
  }
}
function k9(r, e) {
  for (; !(r.next != 95 && !f1(r.next)); )
    e != null && (e += String.fromCharCode(r.next)), r.advance();
  return e;
}
function WLe(r) {
  if (r.next == 39 || r.next == 34 || r.next == 96) {
    let e = r.next;
    r.advance(), dc(r, e, !1);
  } else
    k9(r);
}
function pB(r, e) {
  for (; ; ) {
    if (r.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (r.next < 48 || r.next > 57)
      break;
    r.advance();
  }
  if (r.next == 69 || r.next == 101)
    for (r.advance(), (r.next == 43 || r.next == 45) && r.advance(); r.next >= 48 && r.next <= 57; )
      r.advance();
}
function gB(r) {
  for (; !(r.next < 0 || r.next == 10); )
    r.advance();
}
function ic(r, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == r)
      return !0;
  return !1;
}
const vB = ` 	\r
`;
function Q9(r, e, t) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = wLe, i.null = i.unknown = PLe;
  for (let n of r.split(" "))
    n && (i[n] = D9);
  for (let n of e.split(" "))
    n && (i[n] = M9);
  for (let n of (t || "").split(" "))
    n && (i[n] = YLe);
  return i;
}
const zLe = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", ZLe = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", d1 = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  charSetCasts: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: /* @__PURE__ */ Q9(ZLe, zLe)
};
function qLe(r, e, t, i) {
  let n = {};
  for (let a in d1)
    n[a] = (r.hasOwnProperty(a) ? r : d1)[a];
  return e && (n.words = Q9(e, t || "", i)), n;
}
function U9(r) {
  return new wi((e) => {
    var t;
    let { next: i } = e;
    if (e.advance(), ic(i, vB)) {
      for (; ic(e.next, vB); )
        e.advance();
      e.acceptToken(ILe);
    } else if (i == 39 || i == 34 && r.doubleQuotedStrings)
      dc(e, i, r.backslashEscapes), e.acceptToken(VR);
    else if (i == 35 && r.hashComments || i == 47 && e.next == 47 && r.slashComments)
      gB(e), e.acceptToken(dB);
    else if (i == 45 && e.next == 45 && (!r.spaceAfterDashes || e.peek(2) == 32))
      gB(e), e.acceptToken(dB);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let n = -1, a = 1; !(e.next < 0); )
        if (e.advance(), n == 42 && e.next == 47) {
          if (a--, !a) {
            e.advance();
            break;
          }
          n = -1;
        } else
          n == 47 && e.next == 42 ? (a++, n = -1) : n = e.next;
      e.acceptToken(xLe);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), dc(e, 39, !0);
    else if ((i == 110 || i == 78) && e.next == 39 && r.charSetCasts)
      e.advance(), dc(e, 39, r.backslashEscapes), e.acceptToken(VR);
    else if (i == 95 && r.charSetCasts)
      for (let n = 0; ; n++) {
        if (e.next == 39 && n > 1) {
          e.advance(), dc(e, 39, r.backslashEscapes), e.acceptToken(VR);
          break;
        }
        if (!f1(e.next))
          break;
        e.advance();
      }
    else if (i == 40)
      e.acceptToken(NLe);
    else if (i == 41)
      e.acceptToken(LLe);
    else if (i == 123)
      e.acceptToken(DLe);
    else if (i == 125)
      e.acceptToken(MLe);
    else if (i == 91)
      e.acceptToken(kLe);
    else if (i == 93)
      e.acceptToken(QLe);
    else if (i == 59)
      e.acceptToken(ULe);
    else if (i == 48 && (e.next == 98 || e.next == 66) || (i == 98 || i == 66) && e.next == 39) {
      let n = e.next == 39;
      for (e.advance(); e.next == 48 || e.next == 49; )
        e.advance();
      n && e.next == 39 && e.advance(), e.acceptToken(tm);
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let n = e.next == 39;
      for (e.advance(); HLe(e.next); )
        e.advance();
      n && e.next == 39 && e.advance(), e.acceptToken(tm);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      pB(e, !0), e.acceptToken(tm);
    else if (i == 46)
      e.acceptToken($Le);
    else if (i >= 48 && i <= 57)
      pB(e, !1), e.acceptToken(tm);
    else if (ic(i, r.operatorChars)) {
      for (; ic(e.next, r.operatorChars); )
        e.advance();
      e.acceptToken(GLe);
    } else if (ic(i, r.specialVar))
      e.next == i && e.advance(), WLe(e), e.acceptToken(VLe);
    else if (ic(i, r.identifierQuotes))
      dc(e, i, !1), e.acceptToken(XLe);
    else if (i == 58 || i == 44)
      e.acceptToken(BLe);
    else if (f1(i)) {
      let n = k9(e, String.fromCharCode(i));
      e.acceptToken((t = r.words[n.toLowerCase()]) !== null && t !== void 0 ? t : FLe);
    }
  });
}
const $9 = /* @__PURE__ */ U9(d1), jLe = /* @__PURE__ */ fo.deserialize({
  version: 14,
  states: "%dQ]QQOOO#kQRO'#DQO#rQQO'#CuO%RQQO'#CvO%YQQO'#CwO%aQQO'#CxOOQQ'#DQ'#DQOOQQ'#C{'#C{O&lQRO'#CyOOQQ'#Ct'#CtOOQQ'#Cz'#CzQ]QQOOQOQQOOO&vQQO,59aO'RQQO,59aO'WQQO'#DQOOQQ,59b,59bO'eQQO,59bOOQQ,59c,59cO'lQQO,59cOOQQ,59d,59dO'sQQO,59dOOQQ-E6y-E6yOOQQ,59`,59`OOQQ-E6x-E6xOOQQ'#C|'#C|OOQQ1G.{1G.{O&vQQO1G.{OOQQ1G.|1G.|OOQQ1G.}1G.}OOQQ1G/O1G/OP'zQQO'#C{POQQ-E6z-E6zOOQQ7+$g7+$g",
  stateData: "(R~OrOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUO~O^]ORtXStXTtXUtXVtXXtXZtX]tX_tX`tXatXbtXctXdtXetXftX~OqtX~P!dOa^Ob^Oc^O~ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOa_Ob_Oc_OdUOeUOfUO~OW`O~P#}OYbO~P#}O[dO~P#}ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUO~O]gOqmX~P%hOaiObiOciO~O^kO~OWtXYtX[tX~P!dOWlO~P#}OYmO~P#}O[nO~P#}O]gO~P#}O",
  goto: "#YuPPPPPPPPPPPPPPPPPPPPPPPPvzzzz!W![!b!vPPP!|TYOZeUORSTWZaceoT[OZQZORhZSWOZQaRQcSQeTZfWaceoQj]RqkeVORSTWZaceo",
  nodeNames: " LineComment BlockComment String Number Bool Null ( ) [ ] { } ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 36,
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, $9],
  topRules: { Script: [0, 23] },
  tokenPrec: 0
});
function p1(r) {
  let e = r.cursor().moveTo(r.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function KLe(r) {
  let e = /^[`'"](.*)[`'"]$/.exec(r);
  return e ? e[1] : r;
}
function JLe(r, e) {
  return e.name == "Identifier" || e.name == "QuotedIdentifier" || e.name == "Keyword" && /^public$/i.test(r.sliceDoc(e.from, e.to));
}
function OB(r, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let i = p1(e);
    if (!i || !JLe(r, i))
      return t;
    t.unshift(KLe(r.sliceDoc(i.from, i.to))), e = p1(i);
  }
}
function eDe(r, e) {
  let t = qt(r).resolveInner(e, -1);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? r.sliceDoc(t.from, t.from + 1) : null,
    parents: OB(r, p1(t))
  } : t.name == "." ? {
    from: e,
    quoted: null,
    parents: OB(r, t)
  } : { from: e, quoted: null, parents: [], empty: !0 };
}
function tDe(r, e) {
  return r ? e.map((t) => Object.assign(Object.assign({}, t), { label: r + t.label + r, apply: void 0 })) : e;
}
const rDe = /^\w*$/, iDe = /^[`'"]?\w*[`'"]?$/;
class TP {
  constructor() {
    this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return t[e] || (t[e] = new TP());
  }
  childCompletions(e) {
    return this.children ? Object.keys(this.children).filter((t) => t).map((t) => ({ label: t, type: e })) : [];
  }
}
function nDe(r, e, t, i) {
  let n = new TP(), a = n.child(i || "");
  for (let o in r) {
    let s = o.indexOf("."), u = (s > -1 ? n.child(o.slice(0, s)) : a).child(s > -1 ? o.slice(s + 1) : o);
    u.list = r[o].map((h) => typeof h == "string" ? { label: h, type: "property" } : h);
  }
  a.list = (e || a.childCompletions("type")).concat(t ? a.child(t).list : []);
  for (let o in n.children) {
    let s = n.child(o);
    s.list.length || (s.list = s.childCompletions("type"));
  }
  return n.list = a.list.concat(n.childCompletions("type")), (o) => {
    let { parents: s, from: l, quoted: u, empty: h } = eDe(o.state, o.pos);
    if (h && !o.explicit)
      return null;
    let c = n;
    for (let d of s) {
      for (; !c.children || !c.children[d]; )
        if (c == n)
          c = a;
        else if (c == a && t)
          c = c.child(t);
        else
          return null;
      c = c.child(d);
    }
    let f = u && o.state.sliceDoc(o.pos, o.pos + 1) == u;
    return {
      from: l,
      to: f ? o.pos + 1 : void 0,
      options: tDe(u, c.list),
      validFor: u ? iDe : rDe
    };
  };
}
function aDe(r, e) {
  let t = Object.keys(r).map((i) => ({
    label: e ? i.toUpperCase() : i,
    type: r[i] == M9 ? "type" : r[i] == D9 ? "keyword" : "variable",
    boost: -1
  }));
  return cP(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], gT(t));
}
let oDe = /* @__PURE__ */ jLe.configure({
  props: [
    /* @__PURE__ */ Al.add({
      Statement: /* @__PURE__ */ to()
    }),
    /* @__PURE__ */ Cl.add({
      Statement(r) {
        return { from: r.firstChild.to, to: r.to };
      },
      BlockComment(r) {
        return { from: r.from + 2, to: r.to - 2 };
      }
    }),
    /* @__PURE__ */ Rl({
      Keyword: R.keyword,
      Type: R.typeName,
      Builtin: /* @__PURE__ */ R.standard(R.name),
      Bool: R.bool,
      Null: R.null,
      Number: R.number,
      String: R.string,
      Identifier: R.name,
      QuotedIdentifier: /* @__PURE__ */ R.special(R.string),
      SpecialVar: /* @__PURE__ */ R.special(R.name),
      LineComment: R.lineComment,
      BlockComment: R.blockComment,
      Operator: R.operator,
      "Semi Punctuation": R.punctuation,
      "( )": R.paren,
      "{ }": R.brace,
      "[ ]": R.squareBracket
    })
  ]
});
class yP {
  constructor(e, t) {
    this.dialect = e, this.language = t;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = qLe(e, e.keywords, e.types, e.builtin), i = co.define({
      parser: oDe.configure({
        tokenizers: [{ from: $9, to: U9(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new yP(t, i);
  }
}
function sDe(r, e = !1) {
  return aDe(r.dialect.words, e);
}
function lDe(r, e = !1) {
  return r.language.data.of({
    autocomplete: sDe(r, e)
  });
}
function uDe(r) {
  return r.schema ? nDe(r.schema, r.tables, r.defaultTable, r.defaultSchema) : () => null;
}
function hDe(r) {
  return r.schema ? (r.dialect || G9).language.data.of({
    autocomplete: uDe(r)
  }) : [];
}
function cDe(r = {}) {
  let e = r.dialect || G9;
  return new xh(e.language, [hDe(r), lDe(e, !!r.upperCaseKeywords)]);
}
const G9 = /* @__PURE__ */ yP.define({}), fDe = 1, B9 = 196, V9 = 197, dDe = 198, mB = 199, pDe = 200, gDe = 201, vDe = 202, ODe = 2, mDe = 203, EDe = 204, bDe = 3, SDe = 205, TDe = 206, yDe = 4, RDe = 207, ADe = 208, CDe = 5, _De = 209, IDe = 26, xDe = 27, wDe = 51, PDe = 52, NDe = 57, LDe = 58, DDe = 59, MDe = 61, kDe = 62, QDe = 63, UDe = 64, $De = 65, GDe = 67, BDe = 246, VDe = 74, FDe = 265, XDe = 129, YDe = 150, HDe = 151, WDe = 154, _g = 10, Ig = 13, RP = 32, bT = 9, AP = 35, zDe = 40, ZDe = 46, EB = 123, F9 = 39, X9 = 34, qDe = 92, jDe = /* @__PURE__ */ new Set([
  xDe,
  wDe,
  PDe,
  FDe,
  GDe,
  XDe,
  LDe,
  DDe,
  BDe,
  UDe,
  $De,
  VDe,
  kDe,
  QDe,
  YDe,
  HDe,
  WDe
]);
function FR(r) {
  return r == _g || r == Ig;
}
const KDe = new wi((r, e) => {
  let t;
  if (r.next < 0)
    r.acceptToken(gDe);
  else if (e.context.depth < 0)
    FR(r.next) && r.acceptToken(pDe, 1);
  else if (((t = r.peek(-1)) < 0 || FR(t)) && e.canShift(mB)) {
    let i = 0;
    for (; r.next == RP || r.next == bT; )
      r.advance(), i++;
    (r.next == _g || r.next == Ig || r.next == AP) && r.acceptToken(mB, -i);
  } else
    FR(r.next) && r.acceptToken(dDe, 1);
}, { contextual: !0 }), JDe = new wi((r, e) => {
  let t = e.context.depth;
  if (t < 0)
    return;
  let i = r.peek(-1);
  if (i == _g || i == Ig) {
    let n = 0, a = 0;
    for (; ; ) {
      if (r.next == RP)
        n++;
      else if (r.next == bT)
        n += 8 - n % 8;
      else
        break;
      r.advance(), a++;
    }
    n != t && r.next != _g && r.next != Ig && r.next != AP && (n < t ? r.acceptToken(V9, -a) : r.acceptToken(B9));
  }
});
function g1(r, e) {
  this.parent = r, this.depth = e, this.hash = (r ? r.hash + r.hash << 8 : 0) + e + (e << 4);
}
const eMe = new g1(null, 0);
function tMe(r) {
  let e = 0;
  for (let t = 0; t < r.length; t++)
    e += r.charCodeAt(t) == bT ? 8 - e % 8 : 1;
  return e;
}
const rMe = new mP({
  start: eMe,
  reduce(r, e) {
    return r.depth < 0 && jDe.has(e) ? r.parent : r;
  },
  shift(r, e, t, i) {
    return e == B9 ? new g1(r, tMe(i.read(i.pos, t.pos))) : e == V9 ? r.parent : e == IDe || e == NDe || e == MDe ? new g1(r, -1) : r;
  },
  hash(r) {
    return r.hash;
  }
}), iMe = new wi((r) => {
  for (let e = 0; e < 5; e++) {
    if (r.next != "print".charCodeAt(e))
      return;
    r.advance();
  }
  if (!/\w/.test(String.fromCharCode(r.next)))
    for (let e = 0; ; e++) {
      let t = r.peek(e);
      if (!(t == RP || t == bT)) {
        t != zDe && t != ZDe && t != _g && t != Ig && t != AP && r.acceptToken(fDe);
        return;
      }
    }
});
function ST(r, e, t, i, n) {
  return new wi((a) => {
    let o = a.pos;
    for (; !(a.next < 0); )
      if (a.next == EB)
        if (a.peek(1) == EB)
          a.advance(2);
        else {
          if (a.pos == o) {
            a.acceptToken(i, 1);
            return;
          }
          break;
        }
      else if (a.next == qDe)
        a.advance(), a.next >= 0 && a.advance();
      else if (a.next == r && (e == 1 || a.peek(1) == r && a.peek(2) == r)) {
        if (a.pos == o) {
          a.acceptToken(n, e);
          return;
        }
        break;
      } else
        a.advance();
    a.pos > o && a.acceptToken(t);
  });
}
const nMe = ST(F9, 1, vDe, ODe, mDe), aMe = ST(X9, 1, EDe, bDe, SDe), oMe = ST(F9, 3, TDe, yDe, RDe), sMe = ST(X9, 3, ADe, CDe, _De), lMe = Rl({
  'async "*" "**" FormatConversion FormatSpec': R.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": R.controlKeyword,
  "in not and or is del": R.operatorKeyword,
  "from def class global nonlocal lambda": R.definitionKeyword,
  import: R.moduleKeyword,
  "with as print": R.keyword,
  Boolean: R.bool,
  None: R.null,
  VariableName: R.variableName,
  "CallExpression/VariableName": R.function(R.variableName),
  "FunctionDefinition/VariableName": R.function(R.definition(R.variableName)),
  "ClassDefinition/VariableName": R.definition(R.className),
  PropertyName: R.propertyName,
  "CallExpression/MemberExpression/PropertyName": R.function(R.propertyName),
  Comment: R.lineComment,
  Number: R.number,
  String: R.string,
  FormatString: R.special(R.string),
  UpdateOp: R.updateOperator,
  "ArithOp!": R.arithmeticOperator,
  BitOp: R.bitwiseOperator,
  CompareOp: R.compareOperator,
  AssignOp: R.definitionOperator,
  Ellipsis: R.punctuation,
  At: R.meta,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace,
  ".": R.derefOperator,
  ", ;": R.separator
}), uMe = { __proto__: null, await: 48, or: 58, and: 60, in: 64, not: 66, is: 68, if: 74, else: 76, lambda: 80, yield: 98, from: 100, async: 106, for: 108, None: 168, True: 170, False: 170, del: 184, pass: 188, break: 192, continue: 196, return: 200, raise: 208, import: 212, as: 214, global: 218, nonlocal: 220, assert: 224, elif: 234, while: 238, try: 244, except: 246, finally: 248, with: 252, def: 256, class: 266, match: 277, case: 283 }, hMe = fo.deserialize({
  version: 14,
  states: "#!OO`Q#yOOP$_OSOOO%hQ&nO'#H^OOQS'#Cq'#CqOOQS'#Cr'#CrO'WQ#xO'#CpO(yQ&nO'#H]OOQS'#H^'#H^OOQS'#DW'#DWOOQS'#H]'#H]O)gQ#xO'#DaO)zQ#xO'#DhO*[Q#xO'#DlOOQS'#Dw'#DwO*oO,UO'#DwO*wO7[O'#DwO+POWO'#DxO+[O`O'#DxO+gOpO'#DxO+rO!bO'#DxO-tQ&nO'#G}OOQS'#G}'#G}O'WQ#xO'#G|O/WQ&nO'#G|OOQS'#Ee'#EeO/oQ#xO'#EfOOQS'#G{'#G{O/yQ#xO'#GzOOQV'#Gz'#GzO0UQ#xO'#FXOOQS'#G`'#G`O0ZQ#xO'#FWOOQV'#IS'#ISOOQV'#Gy'#GyOOQV'#Fp'#FpQ`Q#yOOO'WQ#xO'#CsO0iQ#xO'#DPO0pQ#xO'#DTO1OQ#xO'#HbO1`Q&nO'#EYO'WQ#xO'#EZOOQS'#E]'#E]OOQS'#E_'#E_OOQS'#Ea'#EaO1tQ#xO'#EcO2[Q#xO'#EgO0UQ#xO'#EiO2oQ&nO'#EiO0UQ#xO'#ElO/oQ#xO'#EoO/oQ#xO'#EsO/oQ#xO'#EvO2zQ#xO'#ExO3RQ#xO'#E}O3^Q#xO'#EyO/oQ#xO'#E}O0UQ#xO'#FPO0UQ#xO'#FUO3cQ#xO'#FZP3jO#xO'#GxPOOO)CBl)CBlOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Ck'#CkOOQS'#Cl'#ClOOQS'#Cn'#CnO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO3uQ#xO'#DqOOQS,5:[,5:[O4YQ#xO'#HlOOQS,5:_,5:_O4gQMlO,5:_O4lQ&nO,59[O0iQ#xO,59dO0iQ#xO,59dO0iQ#xO,59dO7[Q#xO,59dO7aQ#xO,59dO7hQ#xO,59lO7oQ#xO'#H]O8uQ#xO'#H[OOQS'#H['#H[OOQS'#D^'#D^O9^Q#xO,59cO'WQ#xO,59cO9lQ#xO,59cOOQS,59{,59{O9qQ#xO,5:TO'WQ#xO,5:TOOQS,5:S,5:SO:PQ#xO,5:SO:UQ#xO,5:ZO'WQ#xO,5:ZO'WQ#xO,5:XOOQS,5:W,5:WO:gQ#xO,5:WO:lQ#xO,5:YOOOO'#Fx'#FxO:qO,UO,5:cOOQS,5:c,5:cOOOO'#Fy'#FyO:yO7[O,5:cO;RQ#xO'#DyOOOW'#Fz'#FzO;cOWO,5:dOOQS,5:d,5:dO;RQ#xO'#D}OOO`'#F}'#F}O;nO`O,5:dO;RQ#xO'#EOOOOp'#GO'#GOO;yOpO,5:dO;RQ#xO'#EPOOO!b'#GP'#GPO<UO!bO,5:dOOQS'#GQ'#GQO<aQ&nO,5:lO?RQ&nO,5=hO?lQ!LUO,5=hO@]Q&nO,5=hOOQS,5;Q,5;QO@tQ#yO'#GYOBTQ#xO,5;]OOQV,5=f,5=fOB`Q&nO'#IOOBwQ#xO,5;sOOQS-E:^-E:^OOQV,5;r,5;rO3XQ#xO'#FPOOQV-E9n-E9nOCPQ&nO,59_OEWQ&nO,59kOEqQ#xO'#H_OE|Q#xO'#H_O0UQ#xO'#H_OFXQ#xO'#DVOFaQ#xO,59oOFfQ#xO'#HcO'WQ#xO'#HcO/oQ#xO,5=|OOQS,5=|,5=|O/oQ#xO'#EUOOQS'#EV'#EVOGTQ#xO'#GSOGeQ#xO,59OOGeQ#xO,59OO)mQ#xO,5:rOGsQ&nO'#HeOOQS,5:u,5:uOOQS,5:},5:}OHWQ#xO,5;ROHiQ#xO,5;TOOQS'#GV'#GVOHwQ&nO,5;TOIVQ#xO,5;TOI[Q#xO'#IROOQS,5;W,5;WOIjQ#xO'#H}OOQS,5;Z,5;ZO3^Q#xO,5;_O3^Q#xO,5;bOI{Q&nO'#ITO'WQ#xO'#ITOJVQ#xO,5;dO2zQ#xO,5;dO/oQ#xO,5;iO0UQ#xO,5;kOJ[Q#yO'#EtOKeQ#{O,5;eONvQ#xO'#IUO3^Q#xO,5;iO! RQ#xO,5;kO! WQ#xO,5;pO! `Q&nO,5;uO'WQ#xO,5;uPOOO,5=d,5=dP! gOSO,5=dP! lO#xO,5=dO!$aQ&nO1G.lO!$hQ&nO1G.lO!'XQ&nO1G.lO!'cQ&nO1G.lO!)|Q&nO1G.lO!*aQ&nO1G.lO!*tQ#xO'#HkO!+SQ&nO'#G}O/oQ#xO'#HkO!+^Q#xO'#HjOOQS,5:],5:]O!+fQ#xO,5:]O!+kQ#xO'#HmO!+vQ#xO'#HmO!,ZQ#xO,5>WOOQS'#Du'#DuOOQS1G/y1G/yOOQS1G/O1G/OO!-ZQ&nO1G/OO!-bQ&nO1G/OO0iQ#xO1G/OO!-}Q#xO1G/WOOQS'#D]'#D]O/oQ#xO,59vOOQS1G.}1G.}O!.UQ#xO1G/gO!.fQ#xO1G/gO!.nQ#xO1G/hO'WQ#xO'#HdO!.sQ#xO'#HdO!.xQ&nO1G.}O!/YQ#xO,59kO!0`Q#xO,5>SO!0pQ#xO,5>SO!0xQ#xO1G/oO!0}Q&nO1G/oOOQS1G/n1G/nO!1_Q#xO,5=}O!2UQ#xO,5=}O/oQ#xO1G/sO!2sQ#xO1G/uO!2xQ&nO1G/uO!3YQ&nO1G/sOOQS1G/r1G/rOOQS1G/t1G/tOOOO-E9v-E9vOOQS1G/}1G/}OOOO-E9w-E9wO!3jQ#xO'#HwO/oQ#xO'#HwO!3xQ#xO,5:eOOOW-E9x-E9xOOQS1G0O1G0OO!4TQ#xO,5:iOOO`-E9{-E9{O!4`Q#xO,5:jOOOp-E9|-E9|O!4kQ#xO,5:kOOO!b-E9}-E9}OOQS-E:O-E:OO!4vQ!LUO1G3SO!5gQ&nO1G3SO'WQ#xO,5<mOOQS,5<m,5<mOOQS-E:P-E:POOQS,5<t,5<tOOQS-E:W-E:WOOQV1G0w1G0wO0UQ#xO'#GUO!6OQ&nO,5>jOOQS1G1_1G1_O!6gQ#xO1G1_OOQS'#DX'#DXO/oQ#xO,5=yOOQS,5=y,5=yO!6lQ#xO'#FqO!6wQ#xO,59qO!7PQ#xO1G/ZO!7ZQ&nO,5=}OOQS1G3h1G3hOOQS,5:p,5:pO!7zQ#xO'#G|OOQS,5<n,5<nOOQS-E:Q-E:QO!8]Q#xO1G.jOOQS1G0^1G0^O!8kQ#xO,5>PO!8{Q#xO,5>PO/oQ#xO1G0mO/oQ#xO1G0mO0UQ#xO1G0oOOQS-E:T-E:TO!9^Q#xO1G0oO!9iQ#xO1G0oO!9nQ#xO,5>mO!9|Q#xO,5>mO!:[Q#xO,5>iO!:rQ#xO,5>iO!;TQ#{O1G0yO!>cQ#{O1G0|O!AnQ#xO,5>oO!AxQ#xO,5>oO!BQQ&nO,5>oO/oQ#xO1G1OO!B[Q#xO1G1OO3^Q#xO1G1TO! RQ#xO1G1VOOQV,5;`,5;`O!BaQ#zO,5;`O!BfQ#{O1G1PO!EwQ#xO'#G]O3^Q#xO1G1PO3^Q#xO1G1PO!FUQ#xO,5>pO!FcQ#xO,5>pO0UQ#xO,5>pOOQV1G1T1G1TO!FkQ#xO'#FRO!F|QMlO1G1VOOQV1G1[1G1[O3^Q#xO1G1[O!GUQ#xO'#F]OOQV1G1a1G1aO! `Q&nO1G1aPOOO1G3O1G3OP!GZOSO1G3OOOQS,5>V,5>VOOQS'#Dr'#DrO/oQ#xO,5>VO!G`Q#xO,5>UO!GsQ#xO,5>UOOQS1G/w1G/wO!G{Q#xO,5>XO!H]Q#xO,5>XO!HeQ#xO,5>XO!HxQ#xO,5>XO!IYQ#xO,5>XOOQS1G3r1G3rOOQS7+$j7+$jO!7PQ#xO7+$rO!J{Q#xO1G/OO!KSQ#xO1G/OOOQS1G/b1G/bOOQS,5<_,5<_O'WQ#xO,5<_OOQS7+%R7+%RO!KZQ#xO7+%ROOQS-E9q-E9qOOQS7+%S7+%SO!KkQ#xO,5>OO'WQ#xO,5>OOOQS7+$i7+$iO!KpQ#xO7+%RO!KxQ#xO7+%SO!K}Q#xO1G3nOOQS7+%Z7+%ZO!L_Q#xO1G3nO!LgQ#xO7+%ZOOQS,5<^,5<^O'WQ#xO,5<^O!LlQ#xO1G3iOOQS-E9p-E9pO!McQ#xO7+%_OOQS7+%a7+%aO!MqQ#xO1G3iO!N`Q#xO7+%aO!NeQ#xO1G3oO!NuQ#xO1G3oO!N}Q#xO7+%_O# SQ#xO,5>cO# jQ#xO,5>cO# jQ#xO,5>cO# xO$ISO'#D{O#!TO#tO'#HxOOOW1G0P1G0PO#!YQ#xO1G0POOO`1G0T1G0TO#!bQ#xO1G0TOOOp1G0U1G0UO#!jQ#xO1G0UOOO!b1G0V1G0VO#!rQ#xO1G0VO#!zQ!LUO7+(nO##kQ&nO1G2XP#$UQ#xO'#GROOQS,5<p,5<pOOQS-E:S-E:SOOQS7+&y7+&yOOQS1G3e1G3eOOQS,5<],5<]OOQS-E9o-E9oOOQS7+$u7+$uO#$cQ#xO,5=hO#$|Q#xO,5=hO#%_Q&nO,5<`O#%rQ#xO1G3kOOQS-E9r-E9rOOQS7+&X7+&XO#&SQ#xO7+&XOOQS7+&Z7+&ZO#&bQ#xO'#IQO0UQ#xO'#IPO#&vQ#xO7+&ZOOQS,5<s,5<sO#'RQ#xO1G4XOOQS-E:V-E:VOOQS,5<o,5<oO#'aQ#xO1G4TOOQS-E:R-E:RO#'wQ#{O7+&eO!EwQ#xO'#GZO3^Q#xO7+&eO3^Q#xO7+&hO#+VQ&nO,5<vO'WQ#xO,5<vO#+aQ#xO1G4ZOOQS-E:Y-E:YO#+kQ#xO1G4ZO3^Q#xO7+&jO/oQ#xO7+&jOOQV7+&o7+&oO!F|QMlO7+&qO`Q#yO1G0zOOQV-E:Z-E:ZO3^Q#xO7+&kO3^Q#xO7+&kOOQV,5<w,5<wO#+sQ#xO,5<wOOQV7+&k7+&kO#,OQ#{O7+&kO#/ZQ#xO,5<xO#/fQ#xO1G4[OOQS-E:[-E:[O#/sQ#xO1G4[O#/{Q#xO'#IWO#0ZQ#xO'#IWO0UQ#xO'#IWOOQS'#IW'#IWO#0fQ#xO'#IVOOQS,5;m,5;mO#0nQ#xO,5;mO/oQ#xO'#FTOOQV7+&q7+&qO3^Q#xO7+&qOOQV7+&v7+&vO#0sQ#zO,5;wOOQV7+&{7+&{POOO7+(j7+(jOOQS1G3q1G3qOOQS,5<b,5<bO#0xQ#xO1G3pOOQS-E9t-E9tO#1]Q#xO,5<cO#1hQ#xO,5<cO#1{Q#xO1G3sOOQS-E9u-E9uO#2]Q#xO1G3sO#2eQ#xO1G3sO#2uQ#xO1G3sO#2]Q#xO1G3sOOQS<<H^<<H^O#3QQ&nO1G1yOOQS<<Hm<<HmP#3_Q#xO'#FsO7hQ#xO1G3jO#3lQ#xO1G3jO#3qQ#xO<<HmOOQS<<Hn<<HnO#4RQ#xO7+)YOOQS<<Hu<<HuO#4cQ&nO1G1xP#5SQ#xO'#FrO#5aQ#xO7+)ZO#5qQ#xO7+)ZO#5yQ#xO<<HyO#6OQ#xO7+)TOOQS<<H{<<H{O#6uQ#xO,5<aO'WQ#xO,5<aOOQS-E9s-E9sOOQS<<Hy<<HyOOQS,5<g,5<gO/oQ#xO,5<gO#6zQ#xO1G3}OOQS-E9y-E9yO#7bQ#xO1G3}O;RQ#xO'#D|OOOO'#F|'#F|O#7pO$ISO,5:gOOO#l,5>d,5>dOOOW7+%k7+%kOOO`7+%o7+%oOOOp7+%p7+%pOOO!b7+%q7+%qO#7{Q#xO1G3SO#8fQ#xO1G3SP'WQ#xO'#FtO/oQ#xO<<IsO#8wQ#xO,5>lO#9YQ#xO,5>lO0UQ#xO,5>lO#9kQ#xO,5>kOOQS<<Iu<<IuP0UQ#xO'#GXP/oQ#xO'#GTOOQV-E:X-E:XO3^Q#xO<<JPOOQV,5<u,5<uO3^Q#xO,5<uOOQV<<JP<<JPOOQV<<JS<<JSO#9pQ&nO1G2bP#9zQ#xO'#G[O#:RQ#xO7+)uO#:]Q#{O<<JUO3^Q#xO<<JUOOQV<<J]<<J]O3^Q#xO<<J]O#=hQ#{O7+&fOOQV<<JV<<JVO#=rQ#{O<<JVOOQV1G2c1G2cO0UQ#xO1G2cO3^Q#xO<<JVO0UQ#xO1G2dP/oQ#xO'#G^O#@}Q#xO7+)vO#A[Q#xO7+)vOOQS'#FS'#FSO/oQ#xO,5>rO#AdQ#xO,5>rOOQS,5>r,5>rO#AoQ#xO,5>qO#BQQ#xO,5>qOOQS1G1X1G1XOOQS,5;o,5;oO#BYQ#xO1G1cP#B_Q#xO'#FvO#BoQ#xO1G1}O#CSQ#xO1G1}O#CdQ#xO1G1}P#CoQ#xO'#FwO#C|Q#xO7+)_O#D^Q#xO7+)_O#D^Q#xO7+)_O#DfQ#xO7+)_O#DvQ#xO7+)UO7hQ#xO7+)UOOQSAN>XAN>XO#EaQ#xO<<LuOOQSAN>eAN>eO/oQ#xO1G1{O#EqQ&nO1G1{P#E{Q#xO'#FuOOQS1G2R1G2RP#FYQ#xO'#F{O#FgQ#xO7+)iO#F}Q#xO,5:hOOOO-E9z-E9zO#GYQ#xO7+(nOOQSAN?_AN?_O#GsQ#xO,5<rO#HXQ#xO1G4WOOQS-E:U-E:UO#HjQ#xO1G4WOOQS1G4V1G4VOOQVAN?kAN?kOOQV1G2a1G2aO3^Q#xOAN?pO#H{Q#{OAN?pOOQVAN?wAN?wOOQV<<JQ<<JQO3^Q#xOAN?qO3^Q#xO7+'}OOQVAN?qAN?qOOQS7+(O7+(OO#LWQ#xO<<MbOOQS1G4^1G4^O/oQ#xO1G4^OOQS,5<y,5<yO#LeQ#xO1G4]OOQS-E:]-E:]OOQU'#Ga'#GaO#LvQ#zO7+&}O#MRQ#xO'#F^O#MyQ#xO7+'iO#NZQ#xO7+'iOOQS7+'i7+'iO#NfQ#xO<<LyO#NvQ#xO<<LyO#NvQ#xO<<LyO$ OQ#xO'#HfOOQS<<Lp<<LpO$ YQ#xO<<LpOOQS7+'g7+'gOOOO1G0S1G0SO$ sQ#xO1G0SO0UQ#xO1G2^P0UQ#xO'#GWO$ {Q#xO7+)rO$!^Q#xO7+)rOOQVG25[G25[O3^Q#xOG25[OOQVG25]G25]OOQV<<Ki<<KiOOQS7+)x7+)xP$!oQ#xO'#G_OOQU-E:_-E:_OOQV<<Ji<<JiO$#cQ&nO'#F`OOQS'#Fb'#FbO$#sQ#xO'#FaO$$eQ#xO'#FaOOQS'#Fa'#FaO$$jQ#xO'#IYO#MRQ#xO'#FhO#MRQ#xO'#FhO$%RQ#xO'#FiO#MRQ#xO'#FjO$%YQ#xO'#IZOOQS'#IZ'#IZO$%wQ#xO,5;xOOQS<<KT<<KTO$&PQ#xO<<KTO$&aQ#xOANBeO$&qQ#xOANBeO$&yQ#xO'#HgOOQS'#Hg'#HgO0pQ#xO'#DeO$'dQ#xO,5>QOOQSANB[ANB[OOOO7+%n7+%nOOQS7+'x7+'xO$'{Q#xO<<M^OOQVLD*vLD*vO4gQMlO'#GcO$(^Q&nO,5<RO#MRQ#xO'#FlOOQS,5<V,5<VOOQS'#Fc'#FcO$)OQ#xO,5;{O$)TQ#xO,5;{OOQS'#Ff'#FfO#MRQ#xO'#GbO$)uQ#xO,5<PO$*aQ#xO,5>tO$*qQ#xO,5>tO0UQ#xO,5<OO$+SQ#xO,5<SO$+XQ#xO,5<SO#MRQ#xO'#I[O$+^Q#xO'#I[O$+cQ#xO,5<TOOQS,5<U,5<UO'WQ#xO'#FoOOQU1G1d1G1dO3^Q#xO1G1dOOQSAN@oAN@oO$+hQ#xOG28PO$+xQ#xO,5:POOQS1G3l1G3lOOQS,5<},5<}OOQS-E:a-E:aO$+}Q&nO'#F`O$,UQ#xO'#I]O$,dQ#xO'#I]O$,lQ#xO,5<WOOQS1G1g1G1gO$,qQ#xO1G1gO$,vQ#xO,5<|OOQS-E:`-E:`O$-bQ#xO,5=QO$-yQ#xO1G4`OOQS-E:d-E:dOOQS1G1j1G1jOOQS1G1n1G1nO$.ZQ#xO,5>vO#MRQ#xO,5>vOOQS1G1o1G1oO$.iQ&nO,5<ZOOQU7+'O7+'OO$ OQ#xO1G/kO#MRQ#xO,5<XO$.pQ#xO,5>wO$.wQ#xO,5>wOOQS1G1r1G1rOOQS7+'R7+'RP#MRQ#xO'#GfO$/PQ#xO1G4bO$/ZQ#xO1G4bO$/cQ#xO1G4bOOQS7+%V7+%VO$/qQ#xO1G1sO$0PQ&nO'#F`O$0WQ#xO,5=POOQS,5=P,5=PO$0fQ#xO1G4cOOQS-E:c-E:cO#MRQ#xO,5=OO$0mQ#xO,5=OO$0rQ#xO7+)|OOQS-E:b-E:bO$0|Q#xO7+)|O#MRQ#xO,5<YP#MRQ#xO'#GeO$1UQ#xO1G2jO#MRQ#xO1G2jP$1dQ#xO'#GdO$1kQ#xO<<MhO$1uQ#xO1G1tO$2TQ#xO7+(UO7hQ#xO'#DPO7hQ#xO,59dO7hQ#xO,59dO7hQ#xO,59dO$2cQ&nO,5=hO7hQ#xO1G/OO/oQ#xO1G/ZO/oQ#xO7+$rP$2vQ#xO'#GRO'WQ#xO'#G|O$3TQ#xO,59dO$3YQ#xO,59dO$3aQ#xO,59oO$3fQ#xO1G/WO0pQ#xO'#DTO7hQ#xO,59l",
  stateData: "$3w~O%kOS%`OSUOS%_PQ~OPiOXfOhtOjYOquOu!TOxvO!RwO!S!QO!V!WO!W!VO!ZZO!_[O!jeO!ueO!veO!weO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#k!UO#n!XO#r!YO#t!ZO#y![O#|mO$O!]O%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O%_!^O~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%r!`O%s!aO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eO~Om&QXn&QXo&QXp&QXq&QXr&QXu&QX|&QX}&QX!{&QX#f&QX%^&QX%a&QX&S&QXi&QX!V&QX!W&QX&T&QX!Y&QX!^&QX!S&QX#_&QXv&QX!n&QX~P$dOhtOjYO!ZZO!_[O!jeO!ueO!veO!weO%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O|&PX}&PX#f&PX%^&PX%a&PX&S&PX~Om!tOn!uOo!sOp!sOq!vOr!wOu!xO!{&PX~P(eOX#OOi#QOq0VOx0eO!RwO~P'WOX#SOq0VOx0eO!Y#TO~P'WOX#WOc#XOq0VOx0eO!^#YO~P'WO&e#]O&f#_O~O&h#`O&i#_O~OQ#bO%b#cO%c#eO~OR#fO%d#gO%e#eO~OS#iO%f#jO%g#eO~OT#lO%h#mO%i#eO~OX%qXa%qXc%qXj%qXm%qXn%qXo%qXp%qXq%qXr%qXu%qX|%qX!Z%qX!h%qX%r%qX%s%qX%t%qX%u%qX%v%qX%w%qX%x%qX%y%qX%z%qX%{%qXi%qX!V%qX!W%qX~O&c]O&d^O&g_O&j`O&naO&obO&pcO}%qX!{%qX#f%qX%^%qX%a%qX&S%qX&T%qX!Y%qX!^%qX!S%qX#_%qXv%qX!n%qX~P+}O|#rO}%pX!{%pX#f%pX%^%pX%a%pX&S%pX~Oq0VOx0eO~P'WO#f#uO%^#wO%a#wO~O%}WO~O!V#|O#t!ZO#y![O#|mO~OquO~P'WOX$ROc$SO%}WO}yP~OX$WOq0VOx0eO!S$XO~P'WO}$ZO!{$`O&S$[O#f!|X%^!|X%a!|X~OX$WOq0VOx0eO#f#VX%^#VX%a#VX~P'WOq0VOx0eO#f#ZX%^#ZX%a#ZX~P'WO!h$fO!u$fO%}WO~OX$pO~P'WO!W$rO#r$sO#t$tO~O}$uO~OX$|O~P'WOU%OO%^$}O%k%PO~OX%YOc%YOi%[Oq0VOx0eO~P'WOq0VOx0eO}%_O~P'WO&b%aO~Oc!fOj!mO!Z!oO!h!qOXdaadamdandaodapdaqdardauda|da}da!{da#fda%^da%ada%rda%sda%tda%uda%vda%wda%xda%yda%zda%{da&Sdaida!Vda!Wda&Tda!Yda!^da!Sda#_davda!nda~Op%fO~Oq%fO~P'WOq0VO~P'WOm0XOn0YOo0WOp0WOq0aOr0bOu0fOi&PX!V&PX!W&PX&T&PX!Y&PX!^&PX!S&PX#_&PX!n&PX~P(eO&T%hOi&OX|&OX!V&OX!W&OX!Y&OX}&OX~Oi%jO|%kO!V%oO!W%nO~Oi%jO~O|%rO!V%oO!W%nO!Y&[X~O!Y%vO~O|%wO}%yO!V%oO!W%nO!^&VX~O!^%}O~O!^&OO~O&e#]O&f&QO~O&h#`O&i&QO~OX&TOq0VOx0eO!RwO~P'WOQ#bO%b#cO%c&WO~OR#fO%d#gO%e&WO~OS#iO%f#jO%g&WO~OT#lO%h#mO%i&WO~OX!taa!tac!taj!tam!tan!tao!tap!taq!tar!tau!ta|!ta}!ta!Z!ta!h!ta!{!ta#f!ta%^!ta%a!ta%r!ta%s!ta%t!ta%u!ta%v!ta%w!ta%x!ta%y!ta%z!ta%{!ta&S!tai!ta!V!ta!W!ta&T!ta!Y!ta!^!ta!S!ta#_!tav!ta!n!ta~P#vO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P$dOX&bOquOxvO}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P'WO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#f$|X%^$|X%a$|X~P'WO#f#uO%^&gO%a&gO~O!h&hOj&rX%^&rX#_&rX#f&rX%a&rX#^&rX~Oj!mO%^&jO~Omgangaogapgaqgargauga|ga}ga!{ga#fga%^ga%aga&Sgaiga!Vga!Wga&Tga!Yga!^ga!Sga#_gavga!nga~P$dOusa|sa}sa#fsa%^sa%asa&Ssa~Om!tOn!uOo!sOp!sOq!vOr!wO!{sa~PDoO&S&lO|&RX}&RX~O%}WO|&RX}&RX~O|&oO}yX~O}&qO~O|%wO#f&VX%^&VX%a&VXi&VX}&VX!^&VX!n&VX&S&VX~OX0`Oq0VOx0eO!RwO~P'WO&S$[O#fWa%^Wa%aWa~O|&zO#f&XX%^&XX%a&XXp&XX~P$dO|&}O!S&|O#f#Za%^#Za%a#Za~O#_'OO#f#]a%^#]a%a#]a~O!h$fO!u$fO#^'QO%}WO~O#^'QO~O|'SO#f&uX%^&uX%a&uX~O|'UO#f&qX%^&qX%a&qX}&qX~O|'YOp&wX~P$dOp']O~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO%^'bO~P'WOv'fO#o'dO#p'eOP#maX#mah#maj#maq#mau#max#ma!R#ma!S#ma!V#ma!W#ma!Z#ma!_#ma!j#ma!u#ma!v#ma!w#ma#O#ma#Q#ma#S#ma#U#ma#W#ma#[#ma#^#ma#a#ma#b#ma#d#ma#k#ma#n#ma#r#ma#t#ma#y#ma#|#ma$O#ma%Z#ma%w#ma%x#ma%|#ma%}#ma&c#ma&d#ma&g#ma&j#ma&n#ma&o#ma&p#ma%]#ma%a#ma~O|'gO#_'iO}&xX~Oj'kO~Oj!mO}$uO~O}'oO~P$dO%^'rO~OU'sO%^'rO~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%s!aO~P! tO%sYi~P! tOX!eOa!eOc!fOj!mO!Z!oO!h!qO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%u!cO%v!cO~P!$oO%uYi%vYi~P!$oOc!fOj!mO!Z!oO!h!qOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi%uYi%vYi%wYi%xYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~OX!eOa!eO%y!eO%z!eO%{!eO~P!'mOXYiaYi%yYi%zYi%{Yi~P!'mO!V%oO!W%nOi&_X|&_X~O&S'uO&T'uO~P+}O|'wOi&^X~Oi'yO~O|'zO}'|O!Y&aX~Oq0VOx0eO|'zO}'}O!Y&aX~P'WO!Y(PO~Oo!sOp!sOq!vOr!wOmliuli|li}li!{li#fli%^li%ali&Sli~On!uO~P!,`Onli~P!,`Om0XOn0YOo0WOp0WOq0aOr0bO~Ov(RO~P!-iOX(WOi(XOq0VOx0eO~P'WOi(XO|(YO~Oi([O~O!W(^O~Oi(_O|(YO!V%oO!W%nO~P$dOm0XOn0YOo0WOp0WOq0aOr0bOisa!Vsa!Wsa&Tsa!Ysa!^sa!Ssa#_savsa!nsa~PDoOX(WOq0VOx0eO!Y&[a~P'WO|(bO!Y&[a~O!Y(cO~O|(bO!V%oO!W%nO!Y&[a~P$dOX(gOq0VOx0eO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~P'WO|(hO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~O!^(kO~O|(hO!V%oO!W%nO!^&Va~P$dO|(nO!V%oO!W%nO!^&]a~P$dO|(qO}&kX!^&kX!n&kX~O}(tO!^(vO!n(wO~O}(tO!^(xO!n(yO~O}(tO!^(zO!n({O~O}(tO!^(|O!n(}O~OX&bOquOxvO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~P'WO|)OO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~O!h&hOj&ra%^&ra#_&ra#f&ra%a&ra#^&ra~O%^)TO~OX$ROc$SO%}WO~O|&oO}ya~OquOxvO~P'WO|(hO#f&Va%^&Va%a&Vai&Va}&Va!^&Va!n&Va&S&Va~P$dO|)YO#f%pX%^%pX%a%pX&S%pX~O&S$[O#fWi%^Wi%aWi~O#f&Xa%^&Xa%a&Xap&Xa~P'WO|)]O#f&Xa%^&Xa%a&Xap&Xa~OX)aOj)cO%}WO~O#^)dO~O%}WO#f&ua%^&ua%a&ua~O|)fO#f&ua%^&ua%a&ua~Oq0VOx0eO#f&qa%^&qa%a&qa}&qa~P'WO|)iO#f&qa%^&qa%a&qa}&qa~Ov)mO#i)lOP#giX#gih#gij#giq#giu#gix#gi!R#gi!S#gi!V#gi!W#gi!Z#gi!_#gi!j#gi!u#gi!v#gi!w#gi#O#gi#Q#gi#S#gi#U#gi#W#gi#[#gi#^#gi#a#gi#b#gi#d#gi#k#gi#n#gi#r#gi#t#gi#y#gi#|#gi$O#gi%Z#gi%w#gi%x#gi%|#gi%}#gi&c#gi&d#gi&g#gi&j#gi&n#gi&o#gi&p#gi%]#gi%a#gi~Ov)nOP#jiX#jih#jij#jiq#jiu#jix#ji!R#ji!S#ji!V#ji!W#ji!Z#ji!_#ji!j#ji!u#ji!v#ji!w#ji#O#ji#Q#ji#S#ji#U#ji#W#ji#[#ji#^#ji#a#ji#b#ji#d#ji#k#ji#n#ji#r#ji#t#ji#y#ji#|#ji$O#ji%Z#ji%w#ji%x#ji%|#ji%}#ji&c#ji&d#ji&g#ji&j#ji&n#ji&o#ji&p#ji%]#ji%a#ji~OX)pOp&wa~P'WO|)qOp&wa~O|)qOp&wa~P$dOp)uO~O%[)xO~Ov){O#o'dO#p)zOP#miX#mih#mij#miq#miu#mix#mi!R#mi!S#mi!V#mi!W#mi!Z#mi!_#mi!j#mi!u#mi!v#mi!w#mi#O#mi#Q#mi#S#mi#U#mi#W#mi#[#mi#^#mi#a#mi#b#mi#d#mi#k#mi#n#mi#r#mi#t#mi#y#mi#|#mi$O#mi%Z#mi%w#mi%x#mi%|#mi%}#mi&c#mi&d#mi&g#mi&j#mi&n#mi&o#mi&p#mi%]#mi%a#mi~Oq0VOx0eO}$uO~P'WOq0VOx0eO}&xa~P'WO|*RO}&xa~OX*VOc*WOi*ZO%y*XO%}WO~O}$uO&{*]O~O%^*aO~O%^*cO~OX%YOc%YOq0VOx0eOi&^a~P'WO|*fOi&^a~Oq0VOx0eO}*iO!Y&aa~P'WO|*jO!Y&aa~Oq0VOx0eO|*jO}*mO!Y&aa~P'WOq0VOx0eO|*jO!Y&aa~P'WO|*jO}*mO!Y&aa~Oo0WOp0WOq0aOr0bOilimliuli|li!Vli!Wli&Tli!Yli}li!^li#fli%^li%ali!Sli#_livli!nli&Sli~On0YO~P!IeOnli~P!IeOX(WOi*rOq0VOx0eO~P'WOp*tO~Oi*rO|*vO~Oi*wO~OX(WOq0VOx0eO!Y&[i~P'WO|*xO!Y&[i~O!Y*yO~OX(gOq0VOx0eO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~P'WO|*|O!V%oO!W%nO!^&]i~O|+PO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~O!^+QO~Oc+SOq0VOx0eO!^&]i~P'WO|*|O!^&]i~O!^+UO~OX+WOq0VOx0eO}&ka!^&ka!n&ka~P'WO|+XO}&ka!^&ka!n&ka~O!_+[O&m+]O!^!oX~O!^+_O~O}(tO!^+`O~O}(tO!^+aO~O}(tO!^+bO~O}(tO!^+cO~OX&bOquOxvO}%pq!{%pq#f%pq%^%pq%a%pq&S%pq~P'WO|$ui}$ui!{$ui#f$ui%^$ui%a$ui&S$ui~P$dOX&bOquOxvO~P'WOX&bOq0VOx0eO#f%pa%^%pa%a%pa&S%pa~P'WO|+dO#f%pa%^%pa%a%pa&S%pa~O|$ha#f$ha%^$ha%a$hap$ha~P$dO#f&Xi%^&Xi%a&Xip&Xi~P'WO|+gO#f#Zq%^#Zq%a#Zq~O|+hO#_+jO#f&tX%^&tX%a&tXi&tX~OX+lOj)cO%}WO~O%}WO#f&ui%^&ui%a&ui~Oq0VOx0eO#f&qi%^&qi%a&qi}&qi~P'WOv+pO#i)lOP#gqX#gqh#gqj#gqq#gqu#gqx#gq!R#gq!S#gq!V#gq!W#gq!Z#gq!_#gq!j#gq!u#gq!v#gq!w#gq#O#gq#Q#gq#S#gq#U#gq#W#gq#[#gq#^#gq#a#gq#b#gq#d#gq#k#gq#n#gq#r#gq#t#gq#y#gq#|#gq$O#gq%Z#gq%w#gq%x#gq%|#gq%}#gq&c#gq&d#gq&g#gq&j#gq&n#gq&o#gq&p#gq%]#gq%a#gq~Op%Oa|%Oa~P$dOX)pOp&wi~P'WO|+wOp&wi~O|,QO}$uO#_,QO~O#p,ROP#mqX#mqh#mqj#mqq#mqu#mqx#mq!R#mq!S#mq!V#mq!W#mq!Z#mq!_#mq!j#mq!u#mq!v#mq!w#mq#O#mq#Q#mq#S#mq#U#mq#W#mq#[#mq#^#mq#a#mq#b#mq#d#mq#k#mq#n#mq#r#mq#t#mq#y#mq#|#mq$O#mq%Z#mq%w#mq%x#mq%|#mq%}#mq&c#mq&d#mq&g#mq&j#mq&n#mq&o#mq&p#mq%]#mq%a#mq~O#_,SO|%Qa}%Qa~Oq0VOx0eO}&xi~P'WO|,UO}&xi~O}$ZO&S,WOi&zX|&zX~O%}WOi&zX|&zX~O|,[Oi&yX~Oi,^O~O%[,`O~OX%YOc%YOq0VOx0eOi&^i~P'WO},bO|$ka!Y$ka~Oq0VOx0eO},cO|$ka!Y$ka~P'WOq0VOx0eO}*iO!Y&ai~P'WO|,fO!Y&ai~Oq0VOx0eO|,fO!Y&ai~P'WO|,fO},iO!Y&ai~Oi$gi|$gi!Y$gi~P$dOX(WOq0VOx0eO~P'WOp,kO~OX(WOi,lOq0VOx0eO~P'WOX(WOq0VOx0eO!Y&[q~P'WO|$fi!^$fi#f$fi%^$fi%a$fii$fi}$fi!n$fi&S$fi~P$dOX(gOq0VOx0eO~P'WOc+SOq0VOx0eO!^&]q~P'WO|,mO!^&]q~O!^,nO~OX(gOq0VOx0eO!^&Vq#f&Vq%^&Vq%a&Vqi&Vq}&Vq!n&Vq&S&Vq~P'WO},oO~OX+WOq0VOx0eO}&ki!^&ki!n&ki~P'WO|,tO}&ki!^&ki!n&ki~O!_+[O&m+]O!^!oa~OX&bOq0VOx0eO#f%pi%^%pi%a%pi&S%pi~P'WO|,wO#f%pi%^%pi%a%pi&S%pi~O%}WO#f&ta%^&ta%a&tai&ta~O|,zO#f&ta%^&ta%a&tai&ta~Oi,}O~Op%Oi|%Oi~P$dOX)pO~P'WOX)pOp&wq~P'WOv-QOP#lyX#lyh#lyj#lyq#lyu#lyx#ly!R#ly!S#ly!V#ly!W#ly!Z#ly!_#ly!j#ly!u#ly!v#ly!w#ly#O#ly#Q#ly#S#ly#U#ly#W#ly#[#ly#^#ly#a#ly#b#ly#d#ly#k#ly#n#ly#r#ly#t#ly#y#ly#|#ly$O#ly%Z#ly%w#ly%x#ly%|#ly%}#ly&c#ly&d#ly&g#ly&j#ly&n#ly&o#ly&p#ly%]#ly%a#ly~O%]-TO%a-TO~P`O#p-UOP#myX#myh#myj#myq#myu#myx#my!R#my!S#my!V#my!W#my!Z#my!_#my!j#my!u#my!v#my!w#my#O#my#Q#my#S#my#U#my#W#my#[#my#^#my#a#my#b#my#d#my#k#my#n#my#r#my#t#my#y#my#|#my$O#my%Z#my%w#my%x#my%|#my%}#my&c#my&d#my&g#my&j#my&n#my&o#my&p#my%]#my%a#my~Oq0VOx0eO}&xq~P'WO|-YO}&xq~O&S,WOi&za|&za~OX*VOc*WO%y*XO%}WOi&ya~O|-^Oi&ya~O$R-bO~OX%YOc%YOq0VOx0eO~P'WOq0VOx0eO}-cO|$ki!Y$ki~P'WOq0VOx0eO|$ki!Y$ki~P'WO}-cO|$ki!Y$ki~Oq0VOx0eO}*iO~P'WOq0VOx0eO}*iO!Y&aq~P'WO|-fO!Y&aq~Oq0VOx0eO|-fO!Y&aq~P'WOu-iO!V%oO!W%nOi&Wq!Y&Wq!^&Wq|&Wq~P!-iOc+SOq0VOx0eO!^&]y~P'WO|$ii!^$ii~P$dOc+SOq0VOx0eO~P'WOX+WOq0VOx0eO~P'WOX+WOq0VOx0eO}&kq!^&kq!n&kq~P'WO}(tO!^-mO!n-nO~OX&bOq0VOx0eO#f%pq%^%pq%a%pq&S%pq~P'WO#_-oO|$za#f$za%^$za%a$zai$za~O%}WO#f&ti%^&ti%a&tii&ti~O|-qO#f&ti%^&ti%a&tii&ti~Ov-tOP#l!RX#l!Rh#l!Rj#l!Rq#l!Ru#l!Rx#l!R!R#l!R!S#l!R!V#l!R!W#l!R!Z#l!R!_#l!R!j#l!R!u#l!R!v#l!R!w#l!R#O#l!R#Q#l!R#S#l!R#U#l!R#W#l!R#[#l!R#^#l!R#a#l!R#b#l!R#d#l!R#k#l!R#n#l!R#r#l!R#t#l!R#y#l!R#|#l!R$O#l!R%Z#l!R%w#l!R%x#l!R%|#l!R%}#l!R&c#l!R&d#l!R&g#l!R&j#l!R&n#l!R&o#l!R&p#l!R%]#l!R%a#l!R~Oq0VOx0eO}&xy~P'WOX*VOc*WO%y*XO%}WOi&yi~O$R-bO%]-zO%a-zO~OX.UOj.SO!Z.RO!_.TO!j-}O!v.PO!w.PO%x-|O%}WO&c]O&d^O&g_O~Oq0VOx0eO|$kq!Y$kq~P'WO}.ZO|$kq!Y$kq~Oq0VOx0eO}*iO!Y&ay~P'WO|.[O!Y&ay~Oq0VOx.`O~P'WOu-iO!V%oO!W%nOi&Wy!Y&Wy!^&Wy|&Wy~P!-iO}(tO!^.cO~O%}WO#f&tq%^&tq%a&tqi&tq~O|.eO#f&tq%^&tq%a&tqi&tq~OX*VOc*WO%y*XO%}WO~Oj.iO!h.gO|$SX#_$SX%r$SXi$SX~Ou$SX}$SX!Y$SX!^$SX~P$!}O%w.kO%x.kOu$TX|$TX}$TX#_$TX%r$TX!Y$TXi$TX!^$TX~O!j.mO~O|.qO#_.sO%r.nOu&|X}&|X!Y&|Xi&|X~Oc.vO~P#M_Oj.iOu&}X|&}X}&}X#_&}X%r&}X!Y&}Xi&}X!^&}X~Ou.zO}$uO~Oq0VOx0eO|$ky!Y$ky~P'WOq0VOx0eO}*iO!Y&a!R~P'WO|/OO!Y&a!R~Oi&ZXu&ZX!V&ZX!W&ZX!Y&ZX!^&ZX|&ZX~P!-iOu-iO!V%oO!W%nOi&Ya!Y&Ya!^&Ya|&Ya~O%}WO#f&ty%^&ty%a&tyi&ty~O!h.gOj$Zau$Za|$Za}$Za#_$Za%r$Za!Y$Zai$Za!^$Za~O!j/XO~O%w.kO%x.kOu$Ta|$Ta}$Ta#_$Ta%r$Ta!Y$Tai$Ta!^$Ta~O%r.nOu$Xa|$Xa}$Xa#_$Xa!Y$Xai$Xa!^$Xa~Ou&|a}&|a!Y&|ai&|a~P#MRO|/^Ou&|a}&|a!Y&|ai&|a~O!Y/aO~Oi/aO~O}/cO~O!^/dO~Oq0VOx0eO}*iO!Y&a!Z~P'WO}/gO~O&S/hO~P$!}O|/iO#_.sO%r.nOi'PX~O|/iOi'PX~Oi/kO~O!j/lO~O#_.sOu%Ua|%Ua}%Ua%r%Ua!Y%Uai%Ua!^%Ua~O#_.sO%r.nOu%Ya|%Ya}%Ya!Y%Yai%Ya~Ou&|i}&|i!Y&|ii&|i~P#MRO|/nO#_.sO%r.nO!^'Oa~O}$ca~P$dOi'Pa~P#MRO|/vOi'Pa~Oc/xO!^'Oi~P#M_O|/zO!^'Oi~O|/zO#_.sO%r.nO!^'Oi~O#_.sO%r.nOi$ai|$ai~O&S/}O~P$!}O#_.sO%r.nOi%Xa|%Xa~Oi'Pi~P#MRO}0QO~Oc/xO!^'Oq~P#M_O|0SO!^'Oq~O#_.sO%r.nO|%Wi!^%Wi~Oc/xO~P#M_Oc/xO!^'Oy~P#M_O#_.sO%r.nOi$bi|$bi~O#_.sO%r.nO|%Wq!^%Wq~O|+dO#f%pa%^%pa%a%pa&S%pa~P$dOX&bOq0VOx0eO~P'WOp0[O~Oq0[O~P'WO}0]O~Ov0^O~P!-iO&d&g&o&p&c&j&n%}&c~",
  goto: "!<w'QPPPPPPPP'RP'Z*s+]+v,b,}-kP.YP'Z.y.y'ZPPP'Z2cPPPPPP2c5VPP5VP7g7p=pPP=s>e>hPP'Z'ZPP?QPP'Z'ZPP'Z'Z'Z'Z'Z?U?{'ZP@OP@UD]GyPG}HZH_HcHg'ZPPPHkHq'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RPHwPIOIUPIOPIOIOPPPIOPKTPK^KdKjKTPIOKpPIOPKwK}PLRLgMUMoLRLRMuNSLRLRLRLRNhNnNqNvNy! T! Z! g! y!!P!!Z!!a!!}!#T!#Z!#a!#k!#q!#w!#}!$T!$Z!$m!$w!$}!%T!%Z!%e!%k!%q!%w!&R!&X!&c!&i!&r!&x!'X!'a!'k!'rPPPPPPPPPPPPPPPPP!'x!'{!(R!([!(f!(qPPPPPPPPPPPP!-e!.y!2s!6TPP!6]!6o!6x!7n!7e!7w!7}!8Q!8T!8W!8`!9PPPPPPPPPP!9S!9cPPPP!:R!:_!:k!:q!:z!:}!;T!;Z!;a!;dP!;l!;u!<q!<t]jOs#u$u)x+|'}eOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f}!gQ#q$O$a$o${%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!P!hQ#q$O$a$o${%Q%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!R!iQ#q$O$a$o${%Q%R%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!T!jQ#q$O$a$o${%Q%R%S%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!V!kQ#q$O$a$o${%Q%R%S%T%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!X!lQ#q$O$a$o${%Q%R%S%T%U%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!]!lQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z'}TOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f&cVOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0f%mXOYZ[isw}!O!S!T!U!Y!m!o#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$UvQ/P.`R0c0e'teOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fW#xm!P!Q$gW$Qv&o.`0eQ$i!RQ$y!ZQ$z![W%X!m'w*f,aS&n$R$SQ'`$tQ)R&hQ)a'OU)b'Q)c)dU)e'S)f+mQ*T'iW*U'k,[-^-xS,Z*V*WY,y+h,z-p-q.eQ,|+jQ-V,QQ-X,Sl-{-b.R.S.U.o.q.v/^/c/h/m/x/}0QQ.d-oQ.w.TQ/T.iQ/`.sU/s/i/v0OX/y/n/z0R0SR&m$Q!_!{YZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OR%i!zQ#PYQ&U#bQ&X#fQ&Z#iQ&]#lQ&v$]Q&y$`R,u+[T._-i/g![!nQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZQ&k#yR'n$zR'v%XQ%b!qR/R.g'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fS#od#p!P.P-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0S'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fT#od#pT#c`#de(u&U&X&Z&](w(y({(},u-nT+](t+^T#ga#hT#jb#kT#mc#nQ$_xR,Y*UX$]x$^$_&xZlOs$u)x+|XpOs)x+|Q$v!XQ'W$mQ'X$nQ'j$xQ'm$zQ)v'_Q)|'dQ*O'eQ*P'fQ*^'lQ*`'nQ+q)lQ+s)mQ+t)nQ+x)tS+z)w*_Q+})zQ,O){Q,P)}Q-O+pQ-P+rQ-R+yQ-S+{Q-W,RQ-s-QQ-u-UQ-v-VQ.f-tQ.{.XR/f.|WpOs)x+|R#{oQ'l$yR)w'`Q,X*UR-[,YQ*_'lR+{)wZnOos)x+|Q'p${R*b'qT-`,`-au.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0Qt.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QQ.w.TX/y/n/z0R0S!P.O-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0SQ.l-}R/Y.mg.o.Q.p/U/]/b/p/r/t0P0T0Uu.V-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QX.j-{.V/T/sR/V.iV/u/i/v0OR.|.XQsOS#}s+|R+|)xQ&p$TR)W&pS%x#V$VS(i%x(lT(l%{&rQ%l!}Q%s#RW(Z%l%s(`(dQ(`%pR(d%uQ&{$aR)^&{Q(o%|Q*}(jT+T(o*}Q'x%ZR*g'xS'{%^%_Y*k'{*l,g-g.]U*l'|'}(OU,g*m*n*oS-g,h,iR.]-hQ#^^R&P#^Q#a_R&R#aQ#d`R&V#dQ(r&SS+Y(r+ZR+Z(sQ+^(tR,v+^Q#haR&Y#hQ#kbR&[#kQ#ncR&^#nQ#pdR&_#pQ#sgQ&a#qW&d#s&a)Z+eQ)Z&uR+e0ZQ$^xS&w$^&xR&x$_Q'V$kR)j'VQ&i#xR)S&iQ$g!QR'P$gQ+i)bS,{+i-rR-r,|Q'T$iR)g'TQ#vkR&f#vQ)k'WR+o)kQ'Z$oS)r'Z)sR)s'[Q'c$vR)y'cQ'h$wS*S'h,VR,V*TQ,]*YR-_,]WoOs)x+|R#zoQ-a,`R-y-ad.p.Q/U/]/b/p/r/t0P0T0UR/[.pU.h-{/T/sR/S.hQ/o/bS/{/o/|R/|/pS/j/U/VR/w/jQ.r.QR/_.rR!_PXrOs)x+|WqOs)x+|R'a$uYkOs$u)x+|R&e#u[xOs#u$u)x+|R&v$]&bQOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0fQ!rTQ#qfQ$OtU$ay%n(^S$o!V$rQ${!]Q%Q!gQ%R!hQ%S!iQ%T!jQ%U!kQ%V!lQ%p#OQ%u#SQ%{#WQ%|#XQ&r$WQ'[$pQ'q$|Q)P&bU)[&z)]+fW)o'Y)q+v+wQ*q(WQ*z(gQ+u)pQ,p+SQ/e.zR0Z0`Q!}YQ#RZQ$m!TQ$n!UQ%^!oQ(O%_^(V%k%r(Y(b*s*v*x^*h'z*j,e,f-f.[/OQ*n'|Q*o'}Q+r)lQ,d*iQ,h*mQ-d,bQ-e,cQ-h,iQ.Y-cR.}.Z[gOs#u$u)x+|!^!zYZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OQ#V[Q#tiS$Vw}Q$d!OW$k!S$`'])uS$w!Y$sW%W!m'w*f,aY&S#b#f#i#l+[`&c#r&`)O)Q)Y+d,w0_Q&s$XQ&t$ZQ&u$]Q't%YQ(U%iW(f%w(h*{+PQ(j%yQ(s&TQ)U&mS)X&q0]Q)_&|Q)`&}U)h'U)i+nQ)}'dY*Q'g*R,T,U-YQ*d'vS*p(R0^W+R(n*|,m,qW+V(q+X,s,tQ,_*]Q,r+WQ,x+gQ-Z,XQ-l,oR-w-[hUOs#r#u$u&`&q(R)O)Q)x+|%S!yYZ[iw}!O!S!T!U!Y!m!o#b#f#i#l$X$Z$]$`$s%Y%_%i%k%r%w%y&T&m&|&}'U']'d'g'v'w'z'|'}(Y(b(h(n(q)Y)i)l)u*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$PuW%c!s!w0W0bQ%d!tQ%e!uQ%g!xQ%q0VS(Q%f0[Q(S0XQ(T0YQ,j*tQ-k,kS.^-i/gR0d0fU$Tv.`0eR)V&o[hOs#u$u)x+|a!|Y#b#f#i#l$]$`+[Q#[[Q$YwR$c}Q%m!}Q%t#RQ%z#VQ't%WQ(a%pQ(e%uQ(m%{Q(p%|Q+O(jQ-j,jQ.b-kR/Q.aQ$byQ(]%nR*u(^Q.a-iR/q/gR#UZR#Z[R%]!mQ%Z!mV*e'w*f,a!]!pQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZR%`!oQ&U#bQ&X#fQ&Z#iQ&]#lR,u+[Q(v&UQ(x&XQ(z&ZQ(|&]Q+`(wQ+a(yQ+b({Q+c(}Q-m,uR.c-nQ$l!SQ&y$`Q)t']R+y)uQ#ymQ$e!PQ$h!QR'R$gQ)a'QR+l)dQ)a'QQ+k)cR+l)dR$j!RXqOs)x+|Q$q!VR'^$rQ$x!YR'_$sR*['kQ*Y'kV-],[-^-xQ.X-bQ.t.RR.u.SU.Q-b.R.SQ.y.UQ/U.iQ/Z.oU/].q/^/mQ/b.vQ/p/cQ/r/hU/t/i/v0OQ0P/xQ0T/}R0U0QR.x.TR/W.i",
  nodeNames: " print { { { { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec FormatReplacement FormatReplacement FormatReplacement FormatReplacement ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: rMe,
  nodeProps: [
    ["group", -14, 8, 88, 90, 91, 93, 95, 97, 99, 101, 102, 103, 105, 108, 111, "Statement Statement", -22, 10, 20, 23, 27, 42, 51, 52, 58, 59, 62, 63, 64, 65, 66, 69, 72, 73, 74, 82, 83, 84, 85, "Expression", -10, 113, 115, 118, 120, 121, 125, 127, 132, 134, 137, "Statement", -9, 142, 143, 146, 147, 149, 150, 151, 152, 153, "Pattern"],
    ["openedBy", 25, "(", 56, "[", 60, "{"],
    ["closedBy", 26, ")", 57, "]", 61, "}"]
  ],
  propSources: [lMe],
  skippedNodes: [0, 6],
  repeatNodeCount: 37,
  tokenData: "%-W#sR!`OX%TXY=|Y[%T[]=|]p%Tpq=|qr@_rsDOst!+|tu%Tuv!Nnvw#!|wx#$Wxy#:Uyz#;Yz{#<^{|#>x|}#@S}!O#AW!O!P#Ci!P!Q#N_!Q!R$!y!R![$&w![!]$1e!]!^$3s!^!_$4w!_!`$7c!`!a$8m!a!b%T!b!c$;U!c!d$<b!d!e$>W!e!h$<b!h!i$H[!i!t$<b!t!u%#r!u!w$<b!w!x$Fl!x!}$<b!}#O%%z#O#P?d#P#Q%'O#Q#R%(S#R#S$<b#S#T%T#T#U$<b#U#V$>W#V#Y$<b#Y#Z$H[#Z#f$<b#f#g%#r#g#i$<b#i#j$Fl#j#o$<b#o#p%)^#p#q%*S#q#r%+^#r#s%,S#s$g%T$g;'S$<b;'S;=`$>Q<%lO$<b!n%^]&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n&^]&m!b&eSOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n'^]&m!b&eSOr%Trs(Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!f(^Z&m!b&eSOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)UZ&m!bOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)|Z&m!bOw(Vwx*ox#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!b*tT&m!bO#o*o#p#q*o#r;'S*o;'S;=`+T<%lO*o!b+WP;=`<%l*o!f+`W&m!bO#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`.d;=`<%l+x<%lO(VS+}V&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS,gVOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-PUOw+xx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-fRO;'S+x;'S;=`-o;=`O+xS-tW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l+x<%lO+xS.aP;=`<%l+x!f.iW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l(V<%lO+x!f/UP;=`<%l(V!n/`]&m!b&hWOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n0`]&m!b&hWOr%Trs&Vsw%Twx1Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!j1`Z&m!b&hWOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j2WZ&m!bOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3OZ&m!bOr1Xrs*os#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3vW&m!bO#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`6z;=`<%l4`<%lO1XW4eV&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W4}VOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5gUOr4`s#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5|RO;'S4`;'S;=`6V;=`O4`W6[W&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`W6wP;=`<%l4`!j7PW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l1X<%lO4`!j7lP;=`<%l1X!n7tW&m!bO#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T[8eX&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9VX&eSOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9wX&eSOr8^rs+xsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[:iX&hWOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;ZX&hWOr8^rs9Qsw8^wx4`x#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;yRO;'S8^;'S;=`<S;=`O8^[<ZY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l8^<%lO8^[<|P;=`<%l8^!n=WY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l%T<%lO8^!n=yP;=`<%l%T#s>Xc&m!b&eS&hW%k!TOX%TXY=|Y[%T[]=|]p%Tpq=|qr%Trs&Vsw%Twx/Xx#O%T#O#P?d#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s?i[&m!bOY%TYZ=|Z]%T]^=|^#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T!q@hd&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#T%T#T#UBz#U#f%T#f#gBz#g#hBz#h#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qBR]oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qCV]!nR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cDXa&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs!)|swE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cEia&m!b&eS&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cFw]&m!b&eS&csOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cGya&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxIOx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cIXa&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxJ^x#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#_Jg_&m!b&hW&csOYJ^YZ1XZ]J^]^1X^rJ^rsKfs#OJ^#O#PL`#P#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`!!o<%lOJ^#_KmZ&m!b&csOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#_LeW&m!bO#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`! r;=`<%lL}<%lOJ^{MUZ&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l<%lOL}{M|V&csOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`{NfRO;'SL};'S;=`No;=`OL}{Nv[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lL}<%lOL}{! oP;=`<%lL}#_! y[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lJ^<%lOL}#_!!rP;=`<%lJ^#c!!zW&m!bO#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!(q;=`<%l!#d<%lOE^!P!#m]&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!$mX&eS&csOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P!%a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!&Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!&a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwxL}x#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!']RO;'S!#d;'S;=`!'f;=`O!#d!P!'o^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%l!#d<%lO!#d!P!(nP;=`<%l!#d#c!(z^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%lE^<%lO!#d#c!)yP;=`<%lE^#c!*V]&m!b&eS&csOr%Trs!+Osw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c!+ZZ&iW&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#s!,XaU!T&m!b&eS&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!-gaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!.lsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!.uaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!/zsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#k!0T_U!T&m!b&eSOY!/zYZ(VZ]!/z]^(V^w!/zwx!1Sx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!1Z_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!2Yx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!2a_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!3`x#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#g!3gZU!T&m!bOY!3`YZ*oZ]!3`]^*o^#o!3`#o#p!4Y#p#q!3`#q#r!4Y#r;'S!3`;'S;=`!4t<%lO!3`!T!4_TU!TOY!4YZ]!4Y^;'S!4Y;'S;=`!4n<%lO!4Y!T!4qP;=`<%l!4Y#g!4wP;=`<%l!3`#k!5R[U!T&m!bOY!/zYZ(VZ]!/z]^(V^#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!9s;=`<%l+x<%lO!/z!X!6OZU!T&eSOY!5wYZ+xZ]!5w]^+x^w!5wwx!6qx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!6vZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!7ix#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!7nZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!4Yx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!8fWU!TOY!5wYZ+xZ]!5w]^+x^;'S!5w;'S;=`!9O;=`<%l+x<%lO!5w!X!9TW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!5w<%lO+x!X!9pP;=`<%l!5w#k!9xW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!/z<%lO+x#k!:eP;=`<%l!/z#s!:qaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!;vx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!<PaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!=Ux#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#o!=__U!T&m!b&hWOY!=UYZ1XZ]!=U]^1X^r!=Urs!>^s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!>e_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!?ds#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!?k_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!3`s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!@q[U!T&m!bOY!=UYZ1XZ]!=U]^1X^#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!Ec;=`<%l4`<%lO!=U!]!AnZU!T&hWOY!AgYZ4`Z]!Ag]^4`^r!Agrs!Bas#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!BfZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!CXs#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!C^ZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!4Ys#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!DUWU!TOY!AgYZ4`Z]!Ag]^4`^;'S!Ag;'S;=`!Dn;=`<%l4`<%lO!Ag!]!DsW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!Ag<%lO4`!]!E`P;=`<%l!Ag#o!EhW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!=U<%lO4`#o!FTP;=`<%l!=U#s!F_[U!T&m!bOY!+|YZ%TZ]!+|]^%T^#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Mq;=`<%l8^<%lO!+|!a!G^]U!T&eS&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!H^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!IVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!I^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!5wsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!J^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!KVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!K^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!Agx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!L[WU!TOY!GTYZ8^Z]!GT]^8^^;'S!GT;'S;=`!Lt;=`<%l8^<%lO!GT!a!L{Y&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!GT<%lO8^!a!MnP;=`<%l!GT#s!MxY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!+|<%lO8^#s!NkP;=`<%l!+|#b!Ny_%zQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b#!T]!{r&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b##X_%tQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#$aa&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#8Ux#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#%qa&m!b&eS&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#'Pa&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#(Usw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#(_a&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#)dsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#Z#)m_&m!b&eS&csOY#)dYZ(VZ]#)d]^(V^w#)dwx#*lx#O#)d#O#P#+f#P#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#/u<%lO#)d#Z#*sZ&m!b&csOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#Z#+kW&m!bO#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#.x;=`<%l#,T<%lO#)dw#,[Z&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r<%lO#,Tw#-SV&csOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xw#-lRO;'S#,T;'S;=`#-u;=`O#,Tw#-|[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#,T<%lO#,Tw#.uP;=`<%l#,T#Z#/P[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#)d<%lO#,T#Z#/xP;=`<%l#)d#c#0U]&m!b&hW&csOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#1SW&m!bO#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#6y;=`<%l#1l<%lO#%f!P#1u]&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#2u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#3nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#3u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#,Tsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#4uX&hW&csOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P#5eRO;'S#1l;'S;=`#5n;=`O#1l!P#5w^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#1l<%lO#1l!P#6vP;=`<%l#1l#c#7S^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#%f<%lO#1l#c#8RP;=`<%l#%f#c#8_]&m!b&hW&csOr%Trs&Vsw%Twx#9Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#9cZ&fS&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#c#:a]js&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#;e]iR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#<iaXs&m!b&eS&hWOr%Trs&Vsw%Twx/Xxz%Tz{#=n{!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#=y_cR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#?T_%ws&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#@_]|R&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s#Ac`%xs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`!a#Be!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#O#Bp]&{`&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Cta!hQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#Dy!P!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#ES_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#FR!P#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#F^]!us&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Gbi!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#GV#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#IYc&m!b&eS&hWOr%Trs&Vsw%Twx/Xx{%T{|#Je|}%T}!O#Je!O!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Jn_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Kxe!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#Km#S#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Mf]!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Nja%yR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!P%T!P!Q$ o!Q!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$ z_%{Q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$#Uw!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!d%T!d!e$(w!e!g%T!g!h#IP!h!l%T!l!m#MZ!m!q%T!q!r$+m!r!z%T!z!{$.]!{#O%T#O#P7o#P#R%T#R#S$&w#S#U%T#U#V$(w#V#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#c%T#c#d$+m#d#l%T#l#m$.]#m#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$%x_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$'Sk!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S$&w#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$)Qb&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$*eb!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$+va&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$-Wa!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$.fe&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$0Se!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$1p_}!T&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`$2o!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q$2z]&TR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$4O]#fs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$5SaoR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!^%T!^!_$6X!_!`Av!`!aAv!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$6d_%uQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$7n_&Ss&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$8x`oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`!a$9z!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$:V_%vQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$;c_aQ#|P&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$<oe&m!b&eS&hW&b`%}sOr%Trs&Vsw%Twx/Xx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$>TP;=`<%l$<b#s$>ei&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g$Fl#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$@]a&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs$AbswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#c$Ak]&m!b&eS&csOr%Trs$Bdsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$BmZ&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$Cia&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx$Dnx#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c$Dw]&m!b&hW&csOr%Trs&Vsw%Twx$Epx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_$EyZ&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s$Fye&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$Hii&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!t$<b!t!u%!S!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g%!S#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$Ja]&m!b&eS&nsOr%Trs$KYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$Ka]&m!b&eSOr%Trs$LYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$LcZ&m!b&eS&psOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$M_]&m!b&hW&jsOr%Trs&Vsw%Twx$NWx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$N_]&m!b&hWOr%Trs&Vsw%Twx% Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_% aZ&m!b&hW&osOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s%!ae&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s%$Pm&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!h$<b!h!i%!S!i!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#U$<b#U#V$Fl#V#Y$<b#Y#Z%!S#Z#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c%&V]!Zs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%'Z]!YR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b%(__%sQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a%)gX!_#T&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#c%*__%rR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%+gX!^!e&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#a%,_]%|q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T",
  tokenizers: [iMe, JDe, KDe, nMe, aMe, oMe, sMe, 0, 1, 2, 3, 4, 5, 6],
  topRules: { Script: [0, 7] },
  specialized: [{ term: 229, get: (r) => uMe[r] || -1 }],
  tokenPrec: 7205
}), bB = /* @__PURE__ */ new oZ(), Y9 = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function rm(r) {
  return (e, t, i) => {
    if (i)
      return !1;
    let n = e.node.getChild("VariableName");
    return n && t(n, r), !0;
  };
}
const cMe = {
  FunctionDefinition: /* @__PURE__ */ rm("function"),
  ClassDefinition: /* @__PURE__ */ rm("class"),
  ForStatement(r, e, t) {
    if (t) {
      for (let i = r.node.firstChild; i; i = i.nextSibling)
        if (i.name == "VariableName")
          e(i, "variable");
        else if (i.name == "in")
          break;
    }
  },
  ImportStatement(r, e) {
    var t, i;
    let { node: n } = r, a = ((t = n.firstChild) === null || t === void 0 ? void 0 : t.name) == "from";
    for (let o = n.getChild("import"); o; o = o.nextSibling)
      o.name == "VariableName" && ((i = o.nextSibling) === null || i === void 0 ? void 0 : i.name) != "as" && e(o, a ? "variable" : "namespace");
  },
  AssignStatement(r, e) {
    for (let t = r.node.firstChild; t; t = t.nextSibling)
      if (t.name == "VariableName")
        e(t, "variable");
      else if (t.name == ":" || t.name == "AssignOp")
        break;
  },
  ParamList(r, e) {
    for (let t = null, i = r.node.firstChild; i; i = i.nextSibling)
      i.name == "VariableName" && (!t || !/\*|AssignOp/.test(t.name)) && e(i, "variable"), t = i;
  },
  CapturePattern: /* @__PURE__ */ rm("variable"),
  AsPattern: /* @__PURE__ */ rm("variable"),
  __proto__: null
};
function H9(r, e) {
  let t = bB.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function a(o, s) {
    let l = r.sliceString(o.from, o.to);
    i.push({ label: l, type: s });
  }
  return e.cursor(Bt.IncludeAnonymous).iterate((o) => {
    if (o.name) {
      let s = cMe[o.name];
      if (s && s(o, a, n) || !n && Y9.has(o.name))
        return !1;
      n = !1;
    } else if (o.to - o.from > 8192) {
      for (let s of H9(r, o.node))
        i.push(s);
      return !1;
    }
  }), bB.set(e, i), i;
}
const SB = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, W9 = ["String", "FormatString", "Comment", "PropertyName"];
function fMe(r) {
  let e = qt(r.state).resolveInner(r.pos, -1);
  if (W9.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && SB.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    Y9.has(n.name) && (i = i.concat(H9(r.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : r.pos,
    validFor: SB
  };
}
const dMe = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((r) => ({ label: r, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((r) => ({ label: r, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((r) => ({ label: r, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((r) => ({ label: r, type: "function" }))), pMe = [
  /* @__PURE__ */ fr("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ fr(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ fr("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], gMe = /* @__PURE__ */ cP(W9, /* @__PURE__ */ gT(/* @__PURE__ */ dMe.concat(pMe)));
function TB(r, e) {
  let t = r.baseIndentFor(e), i = r.lineAt(r.pos, -1), n = i.from + i.text.length;
  return /^\s*($|#)/.test(i.text) && r.node.to < n + 100 && !/\S/.test(r.state.sliceDoc(n, r.node.to)) && r.lineIndent(r.pos, -1) <= t || /^\s*(else:|elif |except |finally:)/.test(r.textAfter) && r.lineIndent(r.pos, -1) > t ? null : t + r.unit;
}
const XR = /* @__PURE__ */ co.define({
  name: "python",
  parser: /* @__PURE__ */ hMe.configure({
    props: [
      /* @__PURE__ */ Al.add({
        Body: (r) => {
          var e;
          return (e = TB(r, r.node)) !== null && e !== void 0 ? e : r.continue();
        },
        IfStatement: (r) => /^\s*(else:|elif )/.test(r.textAfter) ? r.baseIndent : r.continue(),
        TryStatement: (r) => /^\s*(except |finally:|else:)/.test(r.textAfter) ? r.baseIndent : r.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ bp({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ bp({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ bp({ closing: "]" }),
        "String FormatString": () => null,
        Script: (r) => {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length >= r.node.to) {
            let e = null;
            for (let t = r.node, i = t.to; t = t.lastChild, !(!t || t.to != i); )
              t.type.name == "Body" && (e = t);
            if (e) {
              let t = TB(r, e);
              if (t != null)
                return t;
            }
          }
          return r.continue();
        }
      }),
      /* @__PURE__ */ Cl.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": lv,
        Body: (r, e) => ({ from: r.from + 1, to: r.to - (r.to == e.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function vMe() {
  return new xh(XR, [
    XR.data.of({ autocomplete: fMe }),
    XR.data.of({ autocomplete: gMe })
  ]);
}
const OMe = Rl({
  null: R.null,
  instanceof: R.operatorKeyword,
  this: R.self,
  "new super assert open to with void": R.keyword,
  "class interface extends implements enum var": R.definitionKeyword,
  "module package import": R.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": R.controlKeyword,
  "requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws": R.modifier,
  IntegerLiteral: R.integer,
  FloatingPointLiteral: R.float,
  "StringLiteral TextBlock": R.string,
  CharacterLiteral: R.character,
  LineComment: R.lineComment,
  BlockComment: R.blockComment,
  BooleanLiteral: R.bool,
  PrimitiveType: R.standard(R.typeName),
  TypeName: R.typeName,
  Identifier: R.variableName,
  "MethodName/Identifier": R.function(R.variableName),
  Definition: R.definition(R.variableName),
  ArithOp: R.arithmeticOperator,
  LogicOp: R.logicOperator,
  BitOp: R.bitwiseOperator,
  CompareOp: R.compareOperator,
  AssignOp: R.definitionOperator,
  UpdateOp: R.updateOperator,
  Asterisk: R.punctuation,
  Label: R.labelName,
  "( )": R.paren,
  "[ ]": R.squareBracket,
  "{ }": R.brace,
  ".": R.derefOperator,
  ", ;": R.separator
}), mMe = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 236, open: 265, module: 267, requires: 272, transitive: 274, exports: 276, to: 278, opens: 280, uses: 282, provides: 284, with: 286, package: 290, import: 294, if: 306, else: 308, while: 312, for: 316, var: 323, assert: 330, switch: 334, case: 340, do: 344, break: 348, continue: 352, return: 356, throw: 362, try: 366, catch: 370, finally: 378 }, EMe = fo.deserialize({
  version: 14,
  states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
  stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
  goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
  nodeNames: " LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
  maxTerm: 274,
  nodeProps: [
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [OMe],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "#$f_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixyAQyzAnz{B[{|CQ|}Dh}!OEU!O!PFo!P!Q! i!Q!R!,_!R![!0V![!]!>g!]!^!?w!^!_!@e!_!`!BO!`!a!Br!a!b!D`!b!c!EO!c!}!Kz!}#O!MW#O#P%Q#P#Q!Mt#Q#R!Nb#R#S4e#S#T%Q#T#o4e#o#p# U#p#q# r#q#r##[#r#s##x#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&WSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&WS%wZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&WS%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#sP&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&WSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&WSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&WSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&USXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&VP_4la%}Z&WSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#gQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&lR&WSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&WSOY9aYZ%lZr9ars:osw9awx%Qx#O9a#O#P;y#P;'S9a;'S;=`@z<%lO9aT9fX&WSOY%QYZ%lZr%Qrs%qsw%Qwx:Rx;'S%Q;'S;=`&s<%lO%QT:YVbP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT:rXOY&ZYZ%lZr&Zrs&ysw&Zwx;_x;'S&Z;'S;=`'`<%lO&ZT;dVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<OZ&WSOY<qYZ%lZr<qrs=isw<qwx9ax#O<q#O#P9a#P;'S<q;'S;=`?T<%lO<qT<vZ&WSOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT=lZOY>_YZ%lZr>_rs?Zsw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_T>bZOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT?WP;=`<%l<qT?^ZOY>_YZ%lZr>_rs@Psw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_P@SVOY@PZw@Pwx@ix#O@P#P;'S@P;'S;=`@n<%lO@PP@nObPP@qP;=`<%l@PT@wP;=`<%l>_T@}P;=`<%l9a_AXVZZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAuVYR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVBeX$YP&WS#fQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCXZ#eR&WSOY%QYZ%lZr%Qrs%qs{%Q{|Cz|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVDRV#qR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDoVqR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVE][#eR&WSOY%QYZ%lZr%Qrs%qs}%Q}!OCz!O!_%Q!_!`6e!`!aFR!a;'S%Q;'S;=`&s<%lO%QVFYV&vR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FvZWY&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGi!P!Q%Q!Q![Hw![;'S%Q;'S;=`&s<%lO%QVGnX&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHZ!P;'S%Q;'S;=`&s<%lO%QVHbV&oR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTIOc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#R%Q#R#SNq#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTJbV&WS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJ|]&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ku|}%Q}!OKu!O!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTKzX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTLnc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![!f%Q!f!gJZ!g!h%Q!h!iJZ!i#R%Q#R#SMy#S#W%Q#W#XJZ#X#Y%Q#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTNOZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![#R%Q#R#SMy#S;'S%Q;'S;=`&s<%lO%QTNvZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![#R%Q#R#SNq#S;'S%Q;'S;=`&s<%lO%Q_! p]&WS#fQOY%QYZ%lZr%Qrs%qsz%Qz{!!i{!P%Q!P!Q!)[!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_!!nX&WSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!#`T&WSOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!#rTOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!$UVOz!#oz{!$R{!P!#o!P!Q!$k!Q;'S!#o;'S;=`!$p<%lO!#oZ!$pOQZZ!$sP;=`<%l!#o_!$yXOY!%fYZ!#ZZr!%frs!'psz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!%iXOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!&ZZ&WSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!'TV&WSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!'mP;=`<%l!!i_!'sXOY!%fYZ!#ZZr!%frs!#osz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!(cZOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!)XP;=`<%l!%f_!)cV&WSPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!)}VPZOY!*dYZ%lZr!*drs!+Us;'S!*d;'S;=`!,X<%lO!*d_!*iVPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!+RP;=`<%l!)[_!+ZVPZOY!*dYZ%lZr!*drs!+ps;'S!*d;'S;=`!,X<%lO!*dZ!+uSPZOY!+pZ;'S!+p;'S;=`!,R<%lO!+pZ!,UP;=`<%l!+p_!,[P;=`<%l!*dT!,fu&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!d%Q!d!e!3a!e!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o!q%Q!q!r!5_!r!z%Q!z!{!7V!{#R%Q#R#S!2i#S#U%Q#U#V!3a#V#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a#c%Q#c#d!5_#d#l%Q#l#m!7V#m;'S%Q;'S;=`&s<%lO%QT!/Qa&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QT!0^i&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o#R%Q#R#S!2i#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!2SV&WS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!2nZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!0V![#R%Q#R#S!2i#S;'S%Q;'S;=`&s<%lO%QT!3fY&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S;'S%Q;'S;=`&s<%lO%QT!4]`&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S!n%Q!n!o!1{!o#R%Q#R#S!3a#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!5dX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y;'S%Q;'S;=`&s<%lO%QT!6W_&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y!n%Q!n!o!1{!o#R%Q#R#S!5_#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!7[_&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!8Z!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QT!8`]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i#T%Q#T#Z!9X#Z;'S%Q;'S;=`&s<%lO%QT!9^c&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#R%Q#R#S!8Z#S#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!:pi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!<_!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i!n%Q!n!o!1{!o!r%Q!r!sJw!s#R%Q#R#S!=i#S#T%Q#T#Z!:i#Z#`%Q#`#a!1{#a#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!<da&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!=n]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QV!>nX#oR&WSOY%QYZ%lZr%Qrs%qs![%Q![!]!?Z!];'S%Q;'S;=`&s<%lO%QV!?bV&tR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!@OV!PR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!@lY&]Z&WSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!A[!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!AcX#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!BVX!bR&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!ByY&[R&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!Ci!a;'S%Q;'S;=`&s<%lO%QU!CpY#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!A[!a;'S%Q;'S;=`&s<%lO%Q_!DiV&`X#nQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!EVX%{Z&WSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!Er#^;'S%Q;'S;=`&s<%lO%QV!EwX&WSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!Fd#c;'S%Q;'S;=`&s<%lO%QV!FiX&WSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!GU#i;'S%Q;'S;=`&s<%lO%QV!GZX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Gv#Y;'S%Q;'S;=`&s<%lO%QV!G{X&WSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!Hh#g;'S%Q;'S;=`&s<%lO%QV!HmX&WSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!IY#Z;'S%Q;'S;=`&s<%lO%QV!I_X&WSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!Iz#U;'S%Q;'S;=`&s<%lO%QV!JPX&WSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Jl#W;'S%Q;'S;=`&s<%lO%QV!JqX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!K^#Y;'S%Q;'S;=`&s<%lO%QV!KeV&rR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!LRa&PZ&WSOY%QYZ%lZr%Qrs%qst%Qtu!Kzu!Q%Q!Q![!Kz![!c%Q!c!}!Kz!}#R%Q#R#S!Kz#S#T%Q#T#o!Kz#o;'S%Q;'S;=`&s<%lO%Q_!M_VuZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!M{VsR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!NiX#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV# ]V}R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_# {Z&|X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q#!n#q;'S%Q;'S;=`&s<%lO%QU#!uV#dQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV##cV|R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT#$PV#tP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3] },
  dynamicPrecedences: { 27: 1, 230: -1, 241: -1 },
  specialized: [{ term: 229, get: (r) => mMe[r] || -1 }],
  tokenPrec: 7067
}), bMe = /* @__PURE__ */ co.define({
  parser: /* @__PURE__ */ EMe.configure({
    props: [
      /* @__PURE__ */ Al.add({
        IfStatement: /* @__PURE__ */ to({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ to({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: dZ,
        SwitchBlock: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : i ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ bp({ closing: "}" }),
        BlockComment: () => -1,
        Statement: /* @__PURE__ */ to({ except: /^{/ })
      }),
      /* @__PURE__ */ Cl.add({
        "Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer": lv,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function SMe() {
  return new xh(bMe);
}
let te;
(function(r) {
  r.QUOTED_IDENTIFIER = "QUOTED_IDENTIFIER", r.IDENTIFIER = "IDENTIFIER", r.STRING = "STRING", r.VARIABLE = "VARIABLE", r.RESERVED_KEYWORD = "RESERVED_KEYWORD", r.RESERVED_FUNCTION_NAME = "RESERVED_FUNCTION_NAME", r.RESERVED_PHRASE = "RESERVED_PHRASE", r.RESERVED_SET_OPERATION = "RESERVED_SET_OPERATION", r.RESERVED_CLAUSE = "RESERVED_CLAUSE", r.RESERVED_SELECT = "RESERVED_SELECT", r.RESERVED_JOIN = "RESERVED_JOIN", r.ARRAY_IDENTIFIER = "ARRAY_IDENTIFIER", r.ARRAY_KEYWORD = "ARRAY_KEYWORD", r.CASE = "CASE", r.END = "END", r.WHEN = "WHEN", r.ELSE = "ELSE", r.THEN = "THEN", r.LIMIT = "LIMIT", r.BETWEEN = "BETWEEN", r.AND = "AND", r.OR = "OR", r.XOR = "XOR", r.OPERATOR = "OPERATOR", r.COMMA = "COMMA", r.ASTERISK = "ASTERISK", r.DOT = "DOT", r.OPEN_PAREN = "OPEN_PAREN", r.CLOSE_PAREN = "CLOSE_PAREN", r.LINE_COMMENT = "LINE_COMMENT", r.BLOCK_COMMENT = "BLOCK_COMMENT", r.NUMBER = "NUMBER", r.NAMED_PARAMETER = "NAMED_PARAMETER", r.QUOTED_PARAMETER = "QUOTED_PARAMETER", r.NUMBERED_PARAMETER = "NUMBERED_PARAMETER", r.POSITIONAL_PARAMETER = "POSITIONAL_PARAMETER", r.CUSTOM_PARAMETER = "CUSTOM_PARAMETER", r.DELIMITER = "DELIMITER", r.EOF = "EOF";
})(te || (te = {}));
const z9 = (r) => ({
  type: te.EOF,
  raw: "EOF",
  text: "EOF",
  start: r
}), hh = z9(1 / 0), _d = (r) => (e) => e.type === r.type && e.text === r.text, ml = {
  ARRAY: _d({
    text: "ARRAY",
    type: te.RESERVED_KEYWORD
  }),
  BY: _d({
    text: "BY",
    type: te.RESERVED_KEYWORD
  }),
  SET: _d({
    text: "SET",
    type: te.RESERVED_CLAUSE
  }),
  STRUCT: _d({
    text: "STRUCT",
    type: te.RESERVED_KEYWORD
  }),
  WINDOW: _d({
    text: "WINDOW",
    type: te.RESERVED_CLAUSE
  })
}, Z9 = (r) => r === te.RESERVED_KEYWORD || r === te.RESERVED_FUNCTION_NAME || r === te.RESERVED_PHRASE || r === te.RESERVED_CLAUSE || r === te.RESERVED_SELECT || r === te.RESERVED_SET_OPERATION || r === te.RESERVED_JOIN || r === te.ARRAY_KEYWORD || r === te.CASE || r === te.END || r === te.WHEN || r === te.ELSE || r === te.THEN || r === te.LIMIT || r === te.BETWEEN || r === te.AND || r === te.OR || r === te.XOR, TMe = (r) => r === te.AND || r === te.OR || r === te.XOR, ie = (r) => r.flatMap(yMe), yMe = (r) => q9(RMe(r)).map((e) => e.trim()), yB = /[^[\]{}]+/y, RB = /\{.*?\}/y, AB = /\[.*?\]/y, RMe = (r) => {
  let e = 0;
  const t = [];
  for (; e < r.length; ) {
    yB.lastIndex = e;
    const i = yB.exec(r);
    i && (t.push([i[0].trim()]), e += i[0].length), AB.lastIndex = e;
    const n = AB.exec(r);
    if (n) {
      const o = n[0].slice(1, -1).split("|").map((s) => s.trim());
      t.push(["", ...o]), e += n[0].length;
    }
    RB.lastIndex = e;
    const a = RB.exec(r);
    if (a) {
      const o = a[0].slice(1, -1).split("|").map((s) => s.trim());
      t.push(o), e += a[0].length;
    }
    if (!i && !n && !a)
      throw new Error(`Unbalanced parenthesis in: ${r}`);
  }
  return t;
}, q9 = ([r, ...e]) => r === void 0 ? [""] : q9(e).flatMap((t) => r.map((i) => i.trim() + " " + t.trim())), AMe = (r) => [...new Set(r)], Sp = (r) => r[r.length - 1], j9 = (r) => r.sort((e, t) => t.length - e.length || e.localeCompare(t)), K9 = (r) => r.reduce((e, t) => Math.max(e, t.length), 0), J9 = (r) => r.replace(/\s+/gu, " "), Ct = (r) => AMe(Object.values(r).flat()), YR = (r) => /\n/.test(r), CMe = Ct({
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#reserved_keywords
  keywords: ["ALL", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSERT_ROWS_MODIFIED", "AT", "BETWEEN", "BY", "CASE", "CAST", "COLLATE", "CONTAINS", "CREATE", "CROSS", "CUBE", "CURRENT", "DEFAULT", "DEFINE", "DESC", "DISTINCT", "ELSE", "END", "ENUM", "ESCAPE", "EXCEPT", "EXCLUDE", "EXISTS", "EXTRACT", "FALSE", "FETCH", "FOLLOWING", "FOR", "FROM", "FULL", "GROUP", "GROUPING", "GROUPS", "HASH", "HAVING", "IF", "IGNORE", "IN", "INNER", "INTERSECT", "INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LIKE", "LIMIT", "LOOKUP", "MERGE", "NATURAL", "NEW", "NO", "NOT", "NULL", "NULLS", "OF", "ON", "OR", "ORDER", "OUTER", "OVER", "PARTITION", "PRECEDING", "PROTO", "RANGE", "RECURSIVE", "RESPECT", "RIGHT", "ROLLUP", "ROWS", "SELECT", "SET", "SOME", "STRUCT", "TABLE", "TABLESAMPLE", "THEN", "TO", "TREAT", "TRUE", "UNBOUNDED", "UNION", "UNNEST", "USING", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN"],
  datatypes: [
    "ARRAY",
    // parametric, ARRAY<T>
    "BOOL",
    "BYTES",
    // parameterised, BYTES(Length)
    "DATE",
    "DATETIME",
    "GEOGRAPHY",
    "INTERVAL",
    "INT64",
    "INT",
    "SMALLINT",
    "INTEGER",
    "BIGINT",
    "TINYINT",
    "BYTEINT",
    "NUMERIC",
    // parameterised, NUMERIC(Precision[, Scale])
    "DECIMAL",
    // parameterised, DECIMAL(Precision[, Scale])
    "BIGNUMERIC",
    // parameterised, BIGNUMERIC(Precision[, Scale])
    "BIGDECIMAL",
    // parameterised, BIGDECIMAL(Precision[, Scale])
    "FLOAT64",
    "STRING",
    // parameterised, STRING(Length)
    "STRUCT",
    // parametric, STRUCT<T>
    "TIME",
    "TIMEZONE"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions#formatting_syntax
  stringFormat: ["HEX", "BASEX", "BASE64M", "ASCII", "UTF-8", "UTF8"],
  misc: ["SAFE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  ddl: [
    "LIKE",
    // CREATE TABLE LIKE
    "COPY",
    // CREATE TABLE COPY
    "CLONE",
    // CREATE TABLE CLONE
    "IN",
    "OUT",
    "INOUT",
    "RETURNS",
    "LANGUAGE",
    "CASCADE",
    "RESTRICT",
    "DETERMINISTIC"
  ]
}), _Me = Ct({
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions
  aead: ["KEYS.NEW_KEYSET", "KEYS.ADD_KEY_FROM_RAW_BYTES", "AEAD.DECRYPT_BYTES", "AEAD.DECRYPT_STRING", "AEAD.ENCRYPT", "KEYS.KEYSET_CHAIN", "KEYS.KEYSET_FROM_JSON", "KEYS.KEYSET_TO_JSON", "KEYS.ROTATE_KEYSET", "KEYS.KEYSET_LENGTH"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_analytic_functions
  aggregateAnalytic: ["ANY_VALUE", "ARRAY_AGG", "AVG", "CORR", "COUNT", "COUNTIF", "COVAR_POP", "COVAR_SAMP", "MAX", "MIN", "ST_CLUSTERDBSCAN", "STDDEV_POP", "STDDEV_SAMP", "STRING_AGG", "SUM", "VAR_POP", "VAR_SAMP"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions
  aggregate: ["ANY_VALUE", "ARRAY_AGG", "ARRAY_CONCAT_AGG", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "COUNTIF", "LOGICAL_AND", "LOGICAL_OR", "MAX", "MIN", "STRING_AGG", "SUM"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions
  approximateAggregate: ["APPROX_COUNT_DISTINCT", "APPROX_QUANTILES", "APPROX_TOP_COUNT", "APPROX_TOP_SUM"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions
  array: [
    // 'ARRAY',
    "ARRAY_CONCAT",
    "ARRAY_LENGTH",
    "ARRAY_TO_STRING",
    "GENERATE_ARRAY",
    "GENERATE_DATE_ARRAY",
    "GENERATE_TIMESTAMP_ARRAY",
    "ARRAY_REVERSE",
    "OFFSET",
    "SAFE_OFFSET",
    "ORDINAL",
    "SAFE_ORDINAL"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/bit_functions
  bitwise: ["BIT_COUNT"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions
  conversion: [
    // 'CASE',
    "PARSE_BIGNUMERIC",
    "PARSE_NUMERIC",
    "SAFE_CAST"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions
  date: ["CURRENT_DATE", "EXTRACT", "DATE", "DATE_ADD", "DATE_SUB", "DATE_DIFF", "DATE_TRUNC", "DATE_FROM_UNIX_DATE", "FORMAT_DATE", "LAST_DAY", "PARSE_DATE", "UNIX_DATE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/datetime_functions
  datetime: ["CURRENT_DATETIME", "DATETIME", "EXTRACT", "DATETIME_ADD", "DATETIME_SUB", "DATETIME_DIFF", "DATETIME_TRUNC", "FORMAT_DATETIME", "LAST_DAY", "PARSE_DATETIME"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging_functions
  debugging: ["ERROR"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/federated_query_functions
  federatedQuery: ["EXTERNAL_QUERY"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions
  geography: ["S2_CELLIDFROMPOINT", "S2_COVERINGCELLIDS", "ST_ANGLE", "ST_AREA", "ST_ASBINARY", "ST_ASGEOJSON", "ST_ASTEXT", "ST_AZIMUTH", "ST_BOUNDARY", "ST_BOUNDINGBOX", "ST_BUFFER", "ST_BUFFERWITHTOLERANCE", "ST_CENTROID", "ST_CENTROID_AGG", "ST_CLOSESTPOINT", "ST_CLUSTERDBSCAN", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DUMP", "ST_DWITHIN", "ST_ENDPOINT", "ST_EQUALS", "ST_EXTENT", "ST_EXTERIORRING", "ST_GEOGFROM", "ST_GEOGFROMGEOJSON", "ST_GEOGFROMTEXT", "ST_GEOGFROMWKB", "ST_GEOGPOINT", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOHASH", "ST_GEOMETRYTYPE", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_INTERSECTSBOX", "ST_ISCOLLECTION", "ST_ISEMPTY", "ST_LENGTH", "ST_MAKELINE", "ST_MAKEPOLYGON", "ST_MAKEPOLYGONORIENTED", "ST_MAXDISTANCE", "ST_NPOINTS", "ST_NUMGEOMETRIES", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SIMPLIFY", "ST_SNAPTOGRID", "ST_STARTPOINT", "ST_TOUCHES", "ST_UNION", "ST_UNION_AGG", "ST_WITHIN", "ST_X", "ST_Y"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions
  hash: ["FARM_FINGERPRINT", "MD5", "SHA1", "SHA256", "SHA512"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions
  hll: ["HLL_COUNT.INIT", "HLL_COUNT.MERGE", "HLL_COUNT.MERGE_PARTIAL", "HLL_COUNT.EXTRACT"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/interval_functions
  interval: ["MAKE_INTERVAL", "EXTRACT", "JUSTIFY_DAYS", "JUSTIFY_HOURS", "JUSTIFY_INTERVAL"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions
  json: ["JSON_EXTRACT", "JSON_QUERY", "JSON_EXTRACT_SCALAR", "JSON_VALUE", "JSON_EXTRACT_ARRAY", "JSON_QUERY_ARRAY", "JSON_EXTRACT_STRING_ARRAY", "JSON_VALUE_ARRAY", "TO_JSON_STRING"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/mathematical_functions
  math: ["ABS", "SIGN", "IS_INF", "IS_NAN", "IEEE_DIVIDE", "RAND", "SQRT", "POW", "POWER", "EXP", "LN", "LOG", "LOG10", "GREATEST", "LEAST", "DIV", "SAFE_DIVIDE", "SAFE_MULTIPLY", "SAFE_NEGATE", "SAFE_ADD", "SAFE_SUBTRACT", "MOD", "ROUND", "TRUNC", "CEIL", "CEILING", "FLOOR", "COS", "COSH", "ACOS", "ACOSH", "SIN", "SINH", "ASIN", "ASINH", "TAN", "TANH", "ATAN", "ATANH", "ATAN2", "RANGE_BUCKET"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions
  navigation: ["FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "LEAD", "LAG", "PERCENTILE_CONT", "PERCENTILE_DISC"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/net_functions
  net: ["NET.IP_FROM_STRING", "NET.SAFE_IP_FROM_STRING", "NET.IP_TO_STRING", "NET.IP_NET_MASK", "NET.IP_TRUNC", "NET.IPV4_FROM_INT64", "NET.IPV4_TO_INT64", "NET.HOST", "NET.PUBLIC_SUFFIX", "NET.REG_DOMAIN"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/numbering_functions
  numbering: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "NTILE", "ROW_NUMBER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/security_functions
  security: ["SESSION_USER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/statistical_aggregate_functions
  statisticalAggregate: ["CORR", "COVAR_POP", "COVAR_SAMP", "STDDEV_POP", "STDDEV_SAMP", "STDDEV", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions
  string: ["ASCII", "BYTE_LENGTH", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CODE_POINTS_TO_BYTES", "CODE_POINTS_TO_STRING", "CONCAT", "CONTAINS_SUBSTR", "ENDS_WITH", "FORMAT", "FROM_BASE32", "FROM_BASE64", "FROM_HEX", "INITCAP", "INSTR", "LEFT", "LENGTH", "LPAD", "LOWER", "LTRIM", "NORMALIZE", "NORMALIZE_AND_CASEFOLD", "OCTET_LENGTH", "REGEXP_CONTAINS", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "REPEAT", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SAFE_CONVERT_BYTES_TO_STRING", "SOUNDEX", "SPLIT", "STARTS_WITH", "STRPOS", "SUBSTR", "SUBSTRING", "TO_BASE32", "TO_BASE64", "TO_CODE_POINTS", "TO_HEX", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/time_functions
  time: ["CURRENT_TIME", "TIME", "EXTRACT", "TIME_ADD", "TIME_SUB", "TIME_DIFF", "TIME_TRUNC", "FORMAT_TIME", "PARSE_TIME"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/timestamp_functions
  timestamp: ["CURRENT_TIMESTAMP", "EXTRACT", "STRING", "TIMESTAMP", "TIMESTAMP_ADD", "TIMESTAMP_SUB", "TIMESTAMP_DIFF", "TIMESTAMP_TRUNC", "FORMAT_TIMESTAMP", "PARSE_TIMESTAMP", "TIMESTAMP_SECONDS", "TIMESTAMP_MILLIS", "TIMESTAMP_MICROS", "UNIX_SECONDS", "UNIX_MILLIS", "UNIX_MICROS"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/uuid_functions
  uuid: ["GENERATE_UUID"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conditional_expressions
  conditional: ["COALESCE", "IF", "IFNULL", "NULLIF"],
  // https://cloud.google.com/bigquery/docs/reference/legacy-sql
  legacyAggregate: ["AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "EXACT_COUNT_DISTINCT", "FIRST", "GROUP_CONCAT", "GROUP_CONCAT_UNQUOTED", "LAST", "MAX", "MIN", "NEST", "NTH", "QUANTILES", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "TOP", "UNIQUE", "VARIANCE", "VAR_POP", "VAR_SAMP"],
  legacyBitwise: ["BIT_COUNT"],
  legacyCasting: ["BOOLEAN", "BYTES", "CAST", "FLOAT", "HEX_STRING", "INTEGER", "STRING"],
  legacyComparison: [
    // expr 'IN',
    "COALESCE",
    "GREATEST",
    "IFNULL",
    "IS_INF",
    "IS_NAN",
    "IS_EXPLICITLY_DEFINED",
    "LEAST",
    "NVL"
  ],
  legacyDatetime: ["CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE", "DATE_ADD", "DATEDIFF", "DAY", "DAYOFWEEK", "DAYOFYEAR", "FORMAT_UTC_USEC", "HOUR", "MINUTE", "MONTH", "MSEC_TO_TIMESTAMP", "NOW", "PARSE_UTC_USEC", "QUARTER", "SEC_TO_TIMESTAMP", "SECOND", "STRFTIME_UTC_USEC", "TIME", "TIMESTAMP", "TIMESTAMP_TO_MSEC", "TIMESTAMP_TO_SEC", "TIMESTAMP_TO_USEC", "USEC_TO_TIMESTAMP", "UTC_USEC_TO_DAY", "UTC_USEC_TO_HOUR", "UTC_USEC_TO_MONTH", "UTC_USEC_TO_WEEK", "UTC_USEC_TO_YEAR", "WEEK", "YEAR"],
  legacyIp: ["FORMAT_IP", "PARSE_IP", "FORMAT_PACKED_IP", "PARSE_PACKED_IP"],
  legacyJson: ["JSON_EXTRACT", "JSON_EXTRACT_SCALAR"],
  legacyMath: ["ABS", "ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATANH", "ATAN2", "CEIL", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG2", "LOG10", "PI", "POW", "RADIANS", "RAND", "ROUND", "SIN", "SINH", "SQRT", "TAN", "TANH"],
  legacyRegex: ["REGEXP_MATCH", "REGEXP_EXTRACT", "REGEXP_REPLACE"],
  legacyString: [
    "CONCAT",
    // expr CONTAINS 'str'
    "INSTR",
    "LEFT",
    "LENGTH",
    "LOWER",
    "LPAD",
    "LTRIM",
    "REPLACE",
    "RIGHT",
    "RPAD",
    "RTRIM",
    "SPLIT",
    "SUBSTR",
    "UPPER"
  ],
  legacyTableWildcard: ["TABLE_DATE_RANGE", "TABLE_DATE_RANGE_STRICT", "TABLE_QUERY"],
  legacyUrl: ["HOST", "DOMAIN", "TLD"],
  legacyWindow: ["AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER"],
  legacyMisc: ["CURRENT_USER", "EVERY", "FROM_BASE64", "HASH", "FARM_FINGERPRINT", "IF", "POSITION", "SHA1", "SOME", "TO_BASE64"],
  other: ["BQ.JOBS.CANCEL", "BQ.REFRESH_MATERIALIZED_VIEW"],
  ddl: ["OPTIONS"],
  pivot: ["PIVOT", "UNPIVOT"],
  // Data types with parameters like VARCHAR(100)
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#parameterized_data_types
  dataTypes: ["BYTES", "NUMERIC", "DECIMAL", "BIGNUMERIC", "BIGDECIMAL", "STRING"]
}), IMe = ie(["SELECT [ALL | DISTINCT] [AS STRUCT | AS VALUE]"]), xMe = ie([
  // Queries: https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "QUALIFY",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "OMIT RECORD IF",
  // legacy
  // Data modification: https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY SOURCE | BY TARGET] [THEN]",
  "UPDATE SET",
  // Data definition, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|SNAPSHOT|EXTERNAL] TABLE [IF NOT EXISTS]",
  "CLUSTER BY",
  "FOR SYSTEM_TIME AS OF",
  // CREATE SNAPSHOT TABLE
  "WITH CONNECTION",
  "WITH PARTITION COLUMNS",
  "REMOTE WITH CONNECTION"
]), CB = ie([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [SNAPSHOT | EXTERNAL] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME TO",
  "ALTER COLUMN [IF EXISTS]",
  "SET DEFAULT COLLATE",
  // for alter column
  "SET OPTIONS",
  // for alter column
  "DROP NOT NULL",
  // for alter column
  "SET DATA TYPE",
  // for alter column
  // - alter schema
  "ALTER SCHEMA [IF EXISTS]",
  // - alter view
  "ALTER [MATERIALIZED] VIEW [IF EXISTS]",
  // - alter bi_capacity
  "ALTER BI_CAPACITY",
  // - truncate:
  "TRUNCATE TABLE",
  // - create schema
  "CREATE SCHEMA [IF NOT EXISTS]",
  "DEFAULT COLLATE",
  // stored procedures
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|TABLE] FUNCTION [IF NOT EXISTS]",
  "CREATE [OR REPLACE] PROCEDURE [IF NOT EXISTS]",
  // row access policy
  "CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]",
  "GRANT TO",
  "FILTER USING",
  // capacity
  "CREATE CAPACITY",
  "AS JSON",
  // reservation
  "CREATE RESERVATION",
  // assignment
  "CREATE ASSIGNMENT",
  // search index
  "CREATE SEARCH INDEX [IF NOT EXISTS]",
  // drop
  "DROP SCHEMA [IF EXISTS]",
  "DROP [MATERIALIZED] VIEW [IF EXISTS]",
  "DROP [TABLE] FUNCTION [IF EXISTS]",
  "DROP PROCEDURE [IF EXISTS]",
  "DROP ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "DROP CAPACITY [IF EXISTS]",
  "DROP RESERVATION [IF EXISTS]",
  "DROP ASSIGNMENT [IF EXISTS]",
  "DROP SEARCH INDEX [IF EXISTS]",
  "DROP [IF EXISTS]",
  // DCL, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-control-language
  "GRANT",
  "REVOKE",
  // Script, https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting
  "DECLARE",
  "EXECUTE IMMEDIATE",
  "LOOP",
  "END LOOP",
  "REPEAT",
  "END REPEAT",
  "WHILE",
  "END WHILE",
  "BREAK",
  "LEAVE",
  "CONTINUE",
  "ITERATE",
  "FOR",
  "END FOR",
  "BEGIN",
  "BEGIN TRANSACTION",
  "COMMIT TRANSACTION",
  "ROLLBACK TRANSACTION",
  "RAISE",
  "RETURN",
  "CALL",
  // Debug, https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging-statements
  "ASSERT",
  // Other, https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements
  "EXPORT DATA"
]), wMe = ie(["UNION {ALL | DISTINCT}", "EXCEPT DISTINCT", "INTERSECT DISTINCT"]), PMe = ie(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]), NMe = ie([
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#tablesample_operator
  "TABLESAMPLE SYSTEM",
  // From DDL: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "ANY TYPE",
  "ALL COLUMNS",
  "NOT DETERMINISTIC",
  // inside window definitions
  "{ROWS | RANGE} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), LMe = {
  tokenizerOptions: {
    reservedSelect: IMe,
    reservedClauses: [...xMe, ...CB],
    reservedSetOperations: wMe,
    reservedJoins: PMe,
    reservedPhrases: NMe,
    reservedKeywords: CMe,
    reservedFunctionNames: _Me,
    extraParens: ["[]"],
    stringTypes: [
      // The triple-quoted strings are listed first, so they get matched first.
      // Otherwise the first two quotes of """ will get matched as an empty "" string.
      {
        quote: '""".."""',
        prefixes: ["R", "B", "RB", "BR"]
      },
      {
        quote: "'''..'''",
        prefixes: ["R", "B", "RB", "BR"]
      },
      '""-bs',
      "''-bs",
      {
        quote: '""-raw',
        prefixes: ["R", "B", "RB", "BR"],
        requirePrefix: !0
      },
      {
        quote: "''-raw",
        prefixes: ["R", "B", "RB", "BR"],
        requirePrefix: !0
      }
    ],
    identTypes: ["``"],
    identChars: {
      dashes: !0
    },
    paramTypes: {
      positional: !0,
      named: ["@"],
      quoted: ["@"]
    },
    variableTypes: [{
      regex: String.raw`@@\w+`
    }],
    lineCommentTypes: ["--", "#"],
    operators: ["&", "|", "^", "~", ">>", "<<", "||", "=>"],
    postProcess: DMe
  },
  formatOptions: {
    onelineClauses: CB
  }
};
function DMe(r) {
  return MMe(kMe(r));
}
function MMe(r) {
  let e = hh;
  return r.map((t) => t.text === "OFFSET" && e.text === "[" ? (e = t, {
    ...t,
    type: te.RESERVED_FUNCTION_NAME
  }) : (e = t, t));
}
function kMe(r) {
  const e = [];
  for (let i = 0; i < r.length; i++) {
    var t;
    const n = r[i];
    if ((ml.ARRAY(n) || ml.STRUCT(n)) && ((t = r[i + 1]) === null || t === void 0 ? void 0 : t.text) === "<") {
      const a = QMe(r, i + 1), o = r.slice(i, a + 1);
      e.push({
        type: te.IDENTIFIER,
        raw: o.map(_B("raw")).join(""),
        text: o.map(_B("text")).join(""),
        start: n.start
      }), i = a;
    } else
      e.push(n);
  }
  return e;
}
const _B = (r) => (e) => e.type === te.IDENTIFIER || e.type === te.COMMA ? e[r] + " " : e[r];
function QMe(r, e) {
  let t = 0;
  for (let i = e; i < r.length; i++) {
    const n = r[i];
    if (n.text === "<" ? t++ : n.text === ">" ? t-- : n.text === ">>" && (t -= 2), t === 0)
      return i;
  }
  return r.length - 1;
}
const UMe = Ct({
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-aggregate
  aggregate: ["ARRAY_AGG", "AVG", "CORR", "CORRELATION", "COUNT", "COUNT_BIG", "COVAR_POP", "COVARIANCE", "COVAR", "COVAR_SAMP", "COVARIANCE_SAMP", "CUME_DIST", "GROUPING", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_ICPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV", "STDDEV_SAMP", "SUM", "VAR_POP", "VARIANCE", "VAR", "VAR_SAMP", "VARIANCE_SAMP", "XMLAGG"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-scalar
  scalar: ["ABS", "ABSVAL", "ACOS", "ADD_DAYS", "ADD_MONTHS", "ARRAY_DELETE", "ARRAY_FIRST", "ARRAY_LAST", "ARRAY_NEXT", "ARRAY_PRIOR", "ARRAY_TRIM", "ASCII", "ASCII_CHR", "ASCII_STR", "ASCIISTR", "ASIN", "ATAN", "ATANH", "ATAN2", "BIGINT", "BINARY", "BITAND", "BITANDNOT", "BITOR", "BITXOR", "BITNOT", "BLOB", "BTRIM", "CARDINALITY", "CCSID_ENCODING", "CEILING", "CEIL", "CHAR", "CHAR9", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CLOB", "COALESCE", "COLLATION_KEY", "COMPARE_DECFLOAT", "CONCAT", "CONTAINS", "COS", "COSH", "DATE", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEK_ISO", "DAYOFYEAR", "DAYS", "DAYS_BETWEEN", "DBCLOB", "DECFLOAT", "DECFLOAT_FORMAT", "DECFLOAT_SORTKEY", "DECIMAL", "DEC", "DECODE", "DECRYPT_BINARY", "DECRYPT_BIT", "DECRYPT_CHAR", "DECRYPT_DB", "DECRYPT_DATAKEY_BIGINT", "DECRYPT_DATAKEY_BIT", "DECRYPT_DATAKEY_CLOB", "DECRYPT_DATAKEY_DBCLOB", "DECRYPT_DATAKEY_DECIMAL", "DECRYPT_DATAKEY_INTEGER", "DECRYPT_DATAKEY_VARCHAR", "DECRYPT_DATAKEY_VARGRAPHIC", "DEGREES", "DIFFERENCE", "DIGITS", "DOUBLE_PRECISION", "DOUBLE", "DSN_XMLVALIDATE", "EBCDIC_CHR", "EBCDIC_STR", "ENCRYPT_DATAKEY", "ENCRYPT_TDES", "EXP", "EXTRACT", "FLOAT", "FLOOR", "GENERATE_UNIQUE", "GENERATE_UNIQUE_BINARY", "GETHINT", "GETVARIABLE", "GRAPHIC", "GREATEST", "HASH", "HASH_CRC32", "HASH_MD5", "HASH_SHA1", "HASH_SHA256", "HEX", "HOUR", "IDENTITY_VAL_LOCAL", "IFNULL", "INSERT", "INSTR", "INTEGER", "INT", "JULIAN_DAY", "LAST_DAY", "LCASE", "LEAST", "LEFT", "LENGTH", "LN", "LOCATE", "LOCATE_IN_STRING", "LOG10", "LOWER", "LPAD", "LTRIM", "MAX", "MAX_CARDINALITY", "MICROSECOND", "MIDNIGHT_SECONDS", "MIN", "MINUTE", "MOD", "MONTH", "MONTHS_BETWEEN", "MQREAD", "MQREADCLOB", "MQRECEIVE", "MQRECEIVECLOB", "MQSEND", "MULTIPLY_ALT", "NEXT_DAY", "NEXT_MONTH", "NORMALIZE_DECFLOAT", "NORMALIZE_STRING", "NULLIF", "NVL", "OVERLAY", "PACK", "POSITION", "POSSTR", "POWER", "POW", "QUANTIZE", "QUARTER", "RADIANS", "RAISE_ERROR", "RANDOM", "RAND", "REAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "RID", "RIGHT", "ROUND", "ROUND_TIMESTAMP", "ROWID", "RPAD", "RTRIM", "SCORE", "SECOND", "SIGN", "SIN", "SINH", "SMALLINT", "SOUNDEX", "SOAPHTTPC", "SOAPHTTPV", "SOAPHTTPNC", "SOAPHTTPNV", "SPACE", "SQRT", "STRIP", "STRLEFT", "STRPOS", "STRRIGHT", "SUBSTR", "SUBSTRING", "TAN", "TANH", "TIME", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIMESTAMP_FORMAT", "TIMESTAMP_ISO", "TIMESTAMP_TZ", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_NUMBER", "TOTALORDER", "TO_TIMESTAMP", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRUNC", "TRUNC_TIMESTAMP", "UCASE", "UNICODE", "UNICODE_STR", "UNISTR", "UPPER", "VALUE", "VARBINARY", "VARCHAR", "VARCHAR9", "VARCHAR_BIT_FORMAT", "VARCHAR_FORMAT", "VARGRAPHIC", "VERIFY_GROUP_FOR_USER", "VERIFY_ROLE_FOR_USER", "VERIFY_TRUSTED_CONTEXT_ROLE_FOR_USER", "WEEK", "WEEK_ISO", "WRAP", "XMLATTRIBUTES", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLFOREST", "XMLMODIFY", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLSERIALIZE", "XMLTEXT", "XMLXSROBJECTID", "XSLTRANSFORM", "YEAR"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-table
  table: ["ADMIN_TASK_LIST", "ADMIN_TASK_OUTPUT", "ADMIN_TASK_STATUS", "BLOCKING_THREADS", "MQREADALL", "MQREADALLCLOB", "MQRECEIVEALL", "MQRECEIVEALLCLOB", "XMLTABLE"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-row
  row: ["UNPACK"],
  // https://www.ibm.com/docs/en/db2-for-zos/12?topic=expressions-olap-specification
  olap: ["CUME_DIST", "PERCENT_RANK", "RANK", "DENSE_RANK", "NTILE", "LAG", "LEAD", "ROW_NUMBER", "FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "RATIO_TO_REPORT"],
  // Type casting
  cast: ["CAST"]
}), $Me = Ct({
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=words-reserved#db2z_reservedwords__newresword
  standard: ["ALL", "ALLOCATE", "ALLOW", "ALTERAND", "ANY", "AS", "ARRAY", "ARRAY_EXISTS", "ASENSITIVE", "ASSOCIATE", "ASUTIME", "AT", "AUDIT", "AUX", "AUXILIARY", "BEFORE", "BEGIN", "BETWEEN", "BUFFERPOOL", "BY", "CAPTURE", "CASCADED", "CAST", "CCSID", "CHARACTER", "CHECK", "CLONE", "CLUSTER", "COLLECTION", "COLLID", "COLUMN", "CONDITION", "CONNECTION", "CONSTRAINT", "CONTENT", "CONTINUE", "CREATE", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_LC_CTYPE", "CURRENT_PATH", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRVAL", "CURSOR", "DATA", "DATABASE", "DBINFO", "DECLARE", "DEFAULT", "DESCRIPTOR", "DETERMINISTIC", "DISABLE", "DISALLOW", "DISTINCT", "DO", "DOCUMENT", "DSSIZE", "DYNAMIC", "EDITPROC", "ELSE", "ELSEIF", "ENCODING", "ENCRYPTION", "ENDING", "END-EXEC", "ERASE", "ESCAPE", "EXCEPTION", "EXISTS", "EXIT", "EXTERNAL", "FENCED", "FIELDPROC", "FINAL", "FIRST", "FOR", "FREE", "FULL", "FUNCTION", "GENERATED", "GET", "GLOBAL", "GOTO", "GROUP", "HANDLER", "HOLD", "HOURS", "IF", "IMMEDIATE", "IN", "INCLUSIVE", "INDEX", "INHERIT", "INNER", "INOUT", "INSENSITIVE", "INTO", "IS", "ISOBID", "ITERATE", "JAR", "KEEP", "KEY", "LANGUAGE", "LAST", "LC_CTYPE", "LEAVE", "LIKE", "LOCAL", "LOCALE", "LOCATOR", "LOCATORS", "LOCK", "LOCKMAX", "LOCKSIZE", "LONG", "LOOP", "MAINTAINED", "MATERIALIZED", "MICROSECONDS", "MINUTEMINUTES", "MODIFIES", "MONTHS", "NEXT", "NEXTVAL", "NO", "NONE", "NOT", "NULL", "NULLS", "NUMPARTS", "OBID", "OF", "OLD", "ON", "OPTIMIZATION", "OPTIMIZE", "ORDER", "ORGANIZATION", "OUT", "OUTER", "PACKAGE", "PARAMETER", "PART", "PADDED", "PARTITION", "PARTITIONED", "PARTITIONING", "PATH", "PIECESIZE", "PERIOD", "PLAN", "PRECISION", "PREVVAL", "PRIOR", "PRIQTY", "PRIVILEGES", "PROCEDURE", "PROGRAM", "PSID", "PUBLIC", "QUERY", "QUERYNO", "READS", "REFERENCES", "RESIGNAL", "RESTRICT", "RESULT", "RESULT_SET_LOCATOR", "RETURN", "RETURNS", "ROLE", "ROLLUP", "ROUND_CEILING", "ROUND_DOWN", "ROUND_FLOOR", "ROUND_HALF_DOWN", "ROUND_HALF_EVEN", "ROUND_HALF_UP", "ROUND_UP", "ROW", "ROWSET", "SCHEMA", "SCRATCHPAD", "SECONDS", "SECQTY", "SECURITY", "SEQUENCE", "SENSITIVE", "SESSION_USER", "SIMPLE", "SOME", "SOURCE", "SPECIFIC", "STANDARD", "STATIC", "STATEMENT", "STAY", "STOGROUP", "STORES", "STYLE", "SUMMARY", "SYNONYM", "SYSDATE", "SYSTEM", "SYSTIMESTAMP", "TABLE", "TABLESPACE", "THEN", "TO", "TRIGGER", "TYPE", "UNDO", "UNIQUE", "UNTIL", "USER", "USING", "VALIDPROC", "VARIABLE", "VARIANT", "VCAT", "VERSIONING", "VIEW", "VOLATILE", "VOLUMES", "WHILE", "WLM", "XMLEXISTS", "XMLCAST", "YEARS", "ZONE"]
}), GMe = ie(["SELECT [ALL | DISTINCT]"]), BMe = ie([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY [INPUT SEQUENCE]",
  "FETCH FIRST",
  // Data modification
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT",
  // Data definition
  "CREATE [OR REPLACE] VIEW",
  "CREATE [GLOBAL TEMPORARY] TABLE"
]), IB = ie([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  "WITH {RR | RS | CS | UR}",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [HIERARCHY]",
  // alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [COLUMN]",
  "ALTER [COLUMN]",
  "SET DATA TYPE",
  // for alter column
  "SET NOT NULL",
  // for alter column
  "DROP {IDENTITY | EXPRESSION | DEFAULT | NOT NULL}",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "SET [CURRENT] SCHEMA",
  "AFTER",
  "GO",
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=statements-list-supported
  "ALLOCATE CURSOR",
  "ALTER DATABASE",
  "ALTER FUNCTION",
  "ALTER INDEX",
  "ALTER MASK",
  "ALTER PERMISSION",
  "ALTER PROCEDURE",
  "ALTER SEQUENCE",
  "ALTER STOGROUP",
  "ALTER TABLESPACE",
  "ALTER TRIGGER",
  "ALTER TRUSTED CONTEXT",
  "ALTER VIEW",
  "ASSOCIATE LOCATORS",
  "BEGIN DECLARE SECTION",
  "CALL",
  "CLOSE",
  "COMMENT",
  "COMMIT",
  "CONNECT",
  "CREATE ALIAS",
  "CREATE AUXILIARY TABLE",
  "CREATE DATABASE",
  "CREATE FUNCTION",
  "CREATE GLOBAL TEMPORARY TABLE",
  "CREATE INDEX",
  "CREATE LOB TABLESPACE",
  "CREATE MASK",
  "CREATE PERMISSION",
  "CREATE PROCEDURE",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE STOGROUP",
  "CREATE SYNONYM",
  "CREATE TABLESPACE",
  "CREATE TRIGGER",
  "CREATE TRUSTED CONTEXT",
  "CREATE TYPE",
  "CREATE VARIABLE",
  "DECLARE CURSOR",
  "DECLARE GLOBAL TEMPORARY TABLE",
  "DECLARE STATEMENT",
  "DECLARE TABLE",
  "DECLARE VARIABLE",
  "DESCRIBE CURSOR",
  "DESCRIBE INPUT",
  "DESCRIBE OUTPUT",
  "DESCRIBE PROCEDURE",
  "DESCRIBE TABLE",
  "DROP",
  "END DECLARE SECTION",
  "EXCHANGE",
  "EXECUTE",
  "EXECUTE IMMEDIATE",
  "EXPLAIN",
  "FETCH",
  "FREE LOCATOR",
  "GET DIAGNOSTICS",
  "GRANT",
  "HOLD LOCATOR",
  "INCLUDE",
  "LABEL",
  "LOCK TABLE",
  "OPEN",
  "PREPARE",
  "REFRESH",
  "RELEASE",
  "RELEASE SAVEPOINT",
  "RENAME",
  "REVOKE",
  "ROLLBACK",
  "SAVEPOINT",
  "SELECT INTO",
  "SET CONNECTION",
  "SET CURRENT ACCELERATOR",
  "SET CURRENT APPLICATION COMPATIBILITY",
  "SET CURRENT APPLICATION ENCODING SCHEME",
  "SET CURRENT DEBUG MODE",
  "SET CURRENT DECFLOAT ROUNDING MODE",
  "SET CURRENT DEGREE",
  "SET CURRENT EXPLAIN MODE",
  "SET CURRENT GET_ACCEL_ARCHIVE",
  "SET CURRENT LOCALE LC_CTYPE",
  "SET CURRENT MAINTAINED TABLE TYPES FOR OPTIMIZATION",
  "SET CURRENT OPTIMIZATION HINT",
  "SET CURRENT PACKAGE PATH",
  "SET CURRENT PACKAGESET",
  "SET CURRENT PRECISION",
  "SET CURRENT QUERY ACCELERATION",
  "SET CURRENT QUERY ACCELERATION WAITFORDATA",
  "SET CURRENT REFRESH AGE",
  "SET CURRENT ROUTINE VERSION",
  "SET CURRENT RULES",
  "SET CURRENT SQLID",
  "SET CURRENT TEMPORAL BUSINESS_TIME",
  "SET CURRENT TEMPORAL SYSTEM_TIME",
  "SET ENCRYPTION PASSWORD",
  "SET PATH",
  "SET SESSION TIME ZONE",
  "SIGNAL",
  "VALUES INTO",
  "WHENEVER"
]), VMe = ie(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]), FMe = ie(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]), XMe = ie(["ON DELETE", "ON UPDATE", "SET NULL", "{ROWS | RANGE} BETWEEN"]), YMe = {
  tokenizerOptions: {
    reservedSelect: GMe,
    reservedClauses: [...BMe, ...IB],
    reservedSetOperations: VMe,
    reservedJoins: FMe,
    reservedPhrases: XMe,
    reservedKeywords: $Me,
    reservedFunctionNames: UMe,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["G", "N", "U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X", "BX", "GX", "UX"],
      requirePrefix: !0
    }],
    identTypes: ['""-qq'],
    identChars: {
      first: "@#$"
    },
    paramTypes: {
      positional: !0,
      named: [":"]
    },
    paramChars: {
      first: "@#$",
      rest: "@#$"
    },
    operators: ["**", "=", ">", "<", "!>", "!<", "||"]
  },
  formatOptions: {
    onelineClauses: IB
  }
}, HMe = Ct({
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF
  math: [
    "ABS",
    "ACOS",
    "ASIN",
    "ATAN",
    "BIN",
    "BROUND",
    "CBRT",
    "CEIL",
    "CEILING",
    "CONV",
    "COS",
    "DEGREES",
    // 'E',
    "EXP",
    "FACTORIAL",
    "FLOOR",
    "GREATEST",
    "HEX",
    "LEAST",
    "LN",
    "LOG",
    "LOG10",
    "LOG2",
    "NEGATIVE",
    "PI",
    "PMOD",
    "POSITIVE",
    "POW",
    "POWER",
    "RADIANS",
    "RAND",
    "ROUND",
    "SHIFTLEFT",
    "SHIFTRIGHT",
    "SHIFTRIGHTUNSIGNED",
    "SIGN",
    "SIN",
    "SQRT",
    "TAN",
    "UNHEX",
    "WIDTH_BUCKET"
  ],
  array: ["ARRAY_CONTAINS", "MAP_KEYS", "MAP_VALUES", "SIZE", "SORT_ARRAY"],
  conversion: ["BINARY", "CAST"],
  date: ["ADD_MONTHS", "DATE", "DATE_ADD", "DATE_FORMAT", "DATE_SUB", "DATEDIFF", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "QUARTER", "SECOND", "TIMESTAMP", "TO_DATE", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_TIMESTAMP", "WEEKOFYEAR", "YEAR"],
  conditional: ["ASSERT_TRUE", "COALESCE", "IF", "ISNOTNULL", "ISNULL", "NULLIF", "NVL"],
  string: ["ASCII", "BASE64", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "CONTEXT_NGRAMS", "DECODE", "ELT", "ENCODE", "FIELD", "FIND_IN_SET", "FORMAT_NUMBER", "GET_JSON_OBJECT", "IN_FILE", "INITCAP", "INSTR", "LCASE", "LENGTH", "LEVENSHTEIN", "LOCATE", "LOWER", "LPAD", "LTRIM", "NGRAMS", "OCTET_LENGTH", "PARSE_URL", "PRINTF", "QUOTE", "REGEXP_EXTRACT", "REGEXP_REPLACE", "REPEAT", "REVERSE", "RPAD", "RTRIM", "SENTENCES", "SOUNDEX", "SPACE", "SPLIT", "STR_TO_MAP", "SUBSTR", "SUBSTRING", "TRANSLATE", "TRIM", "UCASE", "UNBASE64", "UPPER"],
  masking: ["MASK", "MASK_FIRST_N", "MASK_HASH", "MASK_LAST_N", "MASK_SHOW_FIRST_N", "MASK_SHOW_LAST_N"],
  misc: ["AES_DECRYPT", "AES_ENCRYPT", "CRC32", "CURRENT_DATABASE", "CURRENT_USER", "HASH", "JAVA_METHOD", "LOGGED_IN_USER", "MD5", "REFLECT", "SHA", "SHA1", "SHA2", "SURROGATE_KEY", "VERSION"],
  aggregate: ["AVG", "COLLECT_LIST", "COLLECT_SET", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "HISTOGRAM_NUMERIC", "MAX", "MIN", "NTILE", "PERCENTILE", "PERCENTILE_APPROX", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  table: ["EXPLODE", "INLINE", "JSON_TUPLE", "PARSE_URL_TUPLE", "POSEXPLODE", "STACK"],
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics
  window: ["LEAD", "LAG", "FIRST_VALUE", "LAST_VALUE", "RANK", "ROW_NUMBER", "DENSE_RANK", "CUME_DIST", "PERCENT_RANK", "NTILE"],
  // Parameterized data types
  // https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=82706456
  // Though in reality Hive only supports parameters for DECIMAL(),
  // it doesn't hurt to allow others in here as well.
  dataTypes: ["DECIMAL", "NUMERIC", "VARCHAR", "CHAR"]
}), WMe = Ct({
  // https://cwiki.apache.org/confluence/display/hive/languagemanual+ddl
  // Non-reserved keywords have proscribed meanings in. HiveQL, but can still be used as table or column names
  nonReserved: ["ADD", "ADMIN", "AFTER", "ANALYZE", "ARCHIVE", "ASC", "BEFORE", "BUCKET", "BUCKETS", "CASCADE", "CHANGE", "CLUSTER", "CLUSTERED", "CLUSTERSTATUS", "COLLECTION", "COLUMNS", "COMMENT", "COMPACT", "COMPACTIONS", "COMPUTE", "CONCATENATE", "CONTINUE", "DATA", "DATABASES", "DATETIME", "DAY", "DBPROPERTIES", "DEFERRED", "DEFINED", "DELIMITED", "DEPENDENCY", "DESC", "DIRECTORIES", "DIRECTORY", "DISABLE", "DISTRIBUTE", "ELEM_TYPE", "ENABLE", "ESCAPED", "EXCLUSIVE", "EXPLAIN", "EXPORT", "FIELDS", "FILE", "FILEFORMAT", "FIRST", "FORMAT", "FORMATTED", "FUNCTIONS", "HOLD_DDLTIME", "HOUR", "IDXPROPERTIES", "IGNORE", "INDEX", "INDEXES", "INPATH", "INPUTDRIVER", "INPUTFORMAT", "ITEMS", "JAR", "KEYS", "KEY_TYPE", "LIMIT", "LINES", "LOAD", "LOCATION", "LOCK", "LOCKS", "LOGICAL", "LONG", "MAPJOIN", "MATERIALIZED", "METADATA", "MINUS", "MINUTE", "MONTH", "MSCK", "NOSCAN", "NO_DROP", "OFFLINE", "OPTION", "OUTPUTDRIVER", "OUTPUTFORMAT", "OVERWRITE", "OWNER", "PARTITIONED", "PARTITIONS", "PLUS", "PRETTY", "PRINCIPALS", "PROTECTION", "PURGE", "READ", "READONLY", "REBUILD", "RECORDREADER", "RECORDWRITER", "RELOAD", "RENAME", "REPAIR", "REPLACE", "REPLICATION", "RESTRICT", "REWRITE", "ROLE", "ROLES", "SCHEMA", "SCHEMAS", "SECOND", "SEMI", "SERDE", "SERDEPROPERTIES", "SERVER", "SETS", "SHARED", "SHOW", "SHOW_DATABASE", "SKEWED", "SORT", "SORTED", "SSL", "STATISTICS", "STORED", "STREAMTABLE", "STRING", "STRUCT", "TABLES", "TBLPROPERTIES", "TEMPORARY", "TERMINATED", "TINYINT", "TOUCH", "TRANSACTIONS", "UNARCHIVE", "UNDO", "UNIONTYPE", "UNLOCK", "UNSET", "UNSIGNED", "URI", "USE", "UTC", "UTCTIMESTAMP", "VALUE_TYPE", "VIEW", "WHILE", "YEAR", "AUTOCOMMIT", "ISOLATION", "LEVEL", "OFFSET", "SNAPSHOT", "TRANSACTION", "WORK", "WRITE", "ABORT", "KEY", "LAST", "NORELY", "NOVALIDATE", "NULLS", "RELY", "VALIDATE", "DETAIL", "DOW", "EXPRESSION", "OPERATOR", "QUARTER", "SUMMARY", "VECTORIZATION", "WEEK", "YEARS", "MONTHS", "WEEKS", "DAYS", "HOURS", "MINUTES", "SECONDS", "TIMESTAMPTZ", "ZONE"],
  reserved: ["ALL", "ALTER", "AND", "ARRAY", "AS", "AUTHORIZATION", "BETWEEN", "BIGINT", "BINARY", "BOOLEAN", "BOTH", "BY", "CASE", "CAST", "CHAR", "COLUMN", "CONF", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURSOR", "DATABASE", "DATE", "DECIMAL", "DELETE", "DESCRIBE", "DISTINCT", "DOUBLE", "DROP", "ELSE", "END", "EXCHANGE", "EXISTS", "EXTENDED", "EXTERNAL", "FALSE", "FETCH", "FLOAT", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTION", "GRANT", "GROUP", "GROUPING", "HAVING", "IF", "IMPORT", "IN", "INNER", "INSERT", "INT", "INTERSECT", "INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LESS", "LIKE", "LOCAL", "MACRO", "MAP", "MORE", "NONE", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "OUT", "OUTER", "OVER", "PARTIALSCAN", "PARTITION", "PERCENT", "PRECEDING", "PRESERVE", "PROCEDURE", "RANGE", "READS", "REDUCE", "REVOKE", "RIGHT", "ROLLUP", "ROW", "ROWS", "SELECT", "SET", "SMALLINT", "TABLE", "TABLESAMPLE", "THEN", "TIMESTAMP", "TO", "TRANSFORM", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNION", "UNIQUEJOIN", "UPDATE", "USER", "USING", "UTC_TMESTAMP", "VALUES", "VARCHAR", "WHEN", "WHERE", "WINDOW", "WITH", "COMMIT", "ONLY", "REGEXP", "RLIKE", "ROLLBACK", "START", "CACHE", "CONSTRAINT", "FOREIGN", "PRIMARY", "REFERENCES", "DAYOFWEEK", "EXTRACT", "FLOOR", "INTEGER", "PRECISION", "VIEWS", "TIME", "NUMERIC", "SYNC"],
  fileTypes: ["TEXTFILE", "SEQUENCEFILE", "ORC", "CSV", "TSV", "PARQUET", "AVRO", "RCFILE", "JSONFILE", "INPUTFORMAT", "OUTPUTFORMAT"]
}), zMe = ie(["SELECT [ALL | DISTINCT]"]), ZMe = ie([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  //   Hive does not actually support plain INSERT INTO, only INSERT INTO TABLE
  //   but it's a nuisance to not support it, as all other dialects do.
  "INSERT INTO [TABLE]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT [VALUES]",
  // - insert overwrite directory:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Writingdataintothefilesystemfromqueries
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Loadingfilesintotables
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE",
  // Data definition
  "CREATE [MATERIALIZED] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS]"
]), xB = ie([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "RENAME TO",
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "ALTER",
  "CREATE",
  "USE",
  "DESCRIBE",
  "DROP",
  "FETCH",
  "SHOW",
  "STORED AS",
  "STORED BY",
  "ROW FORMAT"
]), qMe = ie(["UNION [ALL | DISTINCT]"]), jMe = ie([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "LEFT SEMI JOIN"
]), KMe = ie(["{ROWS | RANGE} BETWEEN"]), JMe = {
  tokenizerOptions: {
    reservedSelect: zMe,
    reservedClauses: [...ZMe, ...xB],
    reservedSetOperations: qMe,
    reservedJoins: jMe,
    reservedPhrases: KMe,
    reservedKeywords: WMe,
    reservedFunctionNames: HMe,
    extraParens: ["[]"],
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    variableTypes: [{
      quote: "{}",
      prefixes: ["$"],
      requirePrefix: !0
    }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||"]
  },
  formatOptions: {
    onelineClauses: xB
  }
}, eke = Ct({
  // https://mariadb.com/kb/en/information-schema-keywords-table/
  all: [
    "ACCESSIBLE",
    "ACCOUNT",
    "ACTION",
    "ADD",
    "ADMIN",
    "AFTER",
    "AGAINST",
    "AGGREGATE",
    "ALL",
    "ALGORITHM",
    "ALTER",
    "ALWAYS",
    "ANALYZE",
    "AND",
    "ANY",
    "AS",
    "ASC",
    "ASCII",
    "ASENSITIVE",
    "AT",
    "ATOMIC",
    "AUTHORS",
    "AUTO_INCREMENT",
    "AUTOEXTEND_SIZE",
    "AUTO",
    "AVG",
    "AVG_ROW_LENGTH",
    "BACKUP",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BINLOG",
    "BIT",
    "BLOB",
    "BLOCK",
    "BODY",
    "BOOL",
    "BOOLEAN",
    "BOTH",
    "BTREE",
    "BY",
    "BYTE",
    "CACHE",
    "CALL",
    "CASCADE",
    "CASCADED",
    "CASE",
    "CATALOG_NAME",
    "CHAIN",
    "CHANGE",
    "CHANGED",
    "CHAR",
    "CHARACTER",
    "CHARSET",
    "CHECK",
    "CHECKPOINT",
    "CHECKSUM",
    "CIPHER",
    "CLASS_ORIGIN",
    "CLIENT",
    "CLOB",
    "CLOSE",
    "COALESCE",
    "CODE",
    "COLLATE",
    "COLLATION",
    "COLUMN",
    "COLUMN_NAME",
    "COLUMNS",
    "COLUMN_ADD",
    "COLUMN_CHECK",
    "COLUMN_CREATE",
    "COLUMN_DELETE",
    "COLUMN_GET",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPACT",
    "COMPLETION",
    "COMPRESSED",
    "CONCURRENT",
    "CONDITION",
    "CONNECTION",
    "CONSISTENT",
    "CONSTRAINT",
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONTAINS",
    "CONTEXT",
    "CONTINUE",
    "CONTRIBUTORS",
    "CONVERT",
    "CPU",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_POS",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURSOR",
    "CURSOR_NAME",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DATAFILE",
    "DATE",
    "DATETIME",
    "DAY",
    "DAY_HOUR",
    "DAY_MICROSECOND",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFINER",
    "DELAYED",
    "DELAY_KEY_WRITE",
    "DELETE",
    "DELETE_DOMAIN_ID",
    "DESC",
    "DESCRIBE",
    "DES_KEY_FILE",
    "DETERMINISTIC",
    "DIAGNOSTICS",
    "DIRECTORY",
    "DISABLE",
    "DISCARD",
    "DISK",
    "DISTINCT",
    "DISTINCTROW",
    "DIV",
    "DO",
    "DOUBLE",
    "DO_DOMAIN_IDS",
    "DROP",
    "DUAL",
    "DUMPFILE",
    "DUPLICATE",
    "DYNAMIC",
    "EACH",
    "ELSE",
    "ELSEIF",
    "ELSIF",
    "EMPTY",
    "ENABLE",
    "ENCLOSED",
    "END",
    "ENDS",
    "ENGINE",
    "ENGINES",
    "ENUM",
    "ERROR",
    "ERRORS",
    "ESCAPE",
    "ESCAPED",
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXAMINED",
    "EXCEPT",
    "EXCHANGE",
    "EXCLUDE",
    "EXECUTE",
    "EXCEPTION",
    "EXISTS",
    "EXIT",
    "EXPANSION",
    "EXPIRE",
    "EXPORT",
    "EXPLAIN",
    "EXTENDED",
    "EXTENT_SIZE",
    "FALSE",
    "FAST",
    "FAULTS",
    "FEDERATED",
    "FETCH",
    "FIELDS",
    "FILE",
    "FIRST",
    "FIXED",
    "FLOAT",
    "FLOAT4",
    "FLOAT8",
    "FLUSH",
    "FOLLOWING",
    "FOLLOWS",
    "FOR",
    "FORCE",
    "FOREIGN",
    "FORMAT",
    "FOUND",
    "FROM",
    "FULL",
    "FULLTEXT",
    "FUNCTION",
    "GENERAL",
    "GENERATED",
    "GET_FORMAT",
    "GET",
    "GLOBAL",
    "GOTO",
    "GRANT",
    "GRANTS",
    "GROUP",
    "HANDLER",
    "HARD",
    "HASH",
    "HAVING",
    "HELP",
    "HIGH_PRIORITY",
    "HISTORY",
    "HOST",
    "HOSTS",
    "HOUR",
    "HOUR_MICROSECOND",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    // 'ID', // conflicts with common column name
    "IDENTIFIED",
    "IF",
    "IGNORE",
    "IGNORED",
    "IGNORE_DOMAIN_IDS",
    "IGNORE_SERVER_IDS",
    "IMMEDIATE",
    "IMPORT",
    "INTERSECT",
    "IN",
    "INCREMENT",
    "INDEX",
    "INDEXES",
    "INFILE",
    "INITIAL_SIZE",
    "INNER",
    "INOUT",
    "INSENSITIVE",
    "INSERT",
    "INSERT_METHOD",
    "INSTALL",
    "INT",
    "INT1",
    "INT2",
    "INT3",
    "INT4",
    "INT8",
    "INTEGER",
    "INTERVAL",
    "INVISIBLE",
    "INTO",
    "IO",
    "IO_THREAD",
    "IPC",
    "IS",
    "ISOLATION",
    "ISOPEN",
    "ISSUER",
    "ITERATE",
    "INVOKER",
    "JOIN",
    "JSON",
    "JSON_TABLE",
    "KEY",
    "KEYS",
    "KEY_BLOCK_SIZE",
    "KILL",
    "LANGUAGE",
    "LAST",
    "LAST_VALUE",
    "LASTVAL",
    "LEADING",
    "LEAVE",
    "LEAVES",
    "LEFT",
    "LESS",
    "LEVEL",
    "LIKE",
    "LIMIT",
    "LINEAR",
    "LINES",
    "LIST",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCK",
    "LOCKED",
    "LOCKS",
    "LOGFILE",
    "LOGS",
    "LONG",
    "LONGBLOB",
    "LONGTEXT",
    "LOOP",
    "LOW_PRIORITY",
    "MASTER",
    "MASTER_CONNECT_RETRY",
    "MASTER_DELAY",
    "MASTER_GTID_POS",
    "MASTER_HOST",
    "MASTER_LOG_FILE",
    "MASTER_LOG_POS",
    "MASTER_PASSWORD",
    "MASTER_PORT",
    "MASTER_SERVER_ID",
    "MASTER_SSL",
    "MASTER_SSL_CA",
    "MASTER_SSL_CAPATH",
    "MASTER_SSL_CERT",
    "MASTER_SSL_CIPHER",
    "MASTER_SSL_CRL",
    "MASTER_SSL_CRLPATH",
    "MASTER_SSL_KEY",
    "MASTER_SSL_VERIFY_SERVER_CERT",
    "MASTER_USER",
    "MASTER_USE_GTID",
    "MASTER_HEARTBEAT_PERIOD",
    "MATCH",
    "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR",
    "MAX_ROWS",
    "MAX_SIZE",
    "MAX_STATEMENT_TIME",
    "MAX_UPDATES_PER_HOUR",
    "MAX_USER_CONNECTIONS",
    "MAXVALUE",
    "MEDIUM",
    "MEDIUMBLOB",
    "MEDIUMINT",
    "MEDIUMTEXT",
    "MEMORY",
    "MERGE",
    "MESSAGE_TEXT",
    "MICROSECOND",
    "MIDDLEINT",
    "MIGRATE",
    "MINUS",
    "MINUTE",
    "MINUTE_MICROSECOND",
    "MINUTE_SECOND",
    "MINVALUE",
    "MIN_ROWS",
    "MOD",
    "MODE",
    "MODIFIES",
    "MODIFY",
    "MONITOR",
    "MONTH",
    "MUTEX",
    "MYSQL",
    "MYSQL_ERRNO",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NESTED",
    "NEVER",
    "NEW",
    "NEXT",
    "NEXTVAL",
    "NO",
    "NOMAXVALUE",
    "NOMINVALUE",
    "NOCACHE",
    "NOCYCLE",
    "NO_WAIT",
    "NOWAIT",
    "NODEGROUP",
    "NONE",
    "NOT",
    "NOTFOUND",
    "NO_WRITE_TO_BINLOG",
    "NULL",
    "NUMBER",
    "NUMERIC",
    "NVARCHAR",
    "OF",
    "OFFSET",
    "OLD_PASSWORD",
    "ON",
    "ONE",
    "ONLINE",
    "ONLY",
    "OPEN",
    "OPTIMIZE",
    "OPTIONS",
    "OPTION",
    "OPTIONALLY",
    "OR",
    "ORDER",
    "ORDINALITY",
    "OTHERS",
    "OUT",
    "OUTER",
    "OUTFILE",
    "OVER",
    "OVERLAPS",
    "OWNER",
    "PACKAGE",
    "PACK_KEYS",
    "PAGE",
    "PAGE_CHECKSUM",
    "PARSER",
    "PARSE_VCOL_EXPR",
    "PATH",
    "PERIOD",
    "PARTIAL",
    "PARTITION",
    "PARTITIONING",
    "PARTITIONS",
    "PASSWORD",
    "PERSISTENT",
    "PHASE",
    "PLUGIN",
    "PLUGINS",
    "PORT",
    "PORTION",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    "PREPARE",
    "PRESERVE",
    "PREV",
    "PREVIOUS",
    "PRIMARY",
    "PRIVILEGES",
    "PROCEDURE",
    "PROCESS",
    "PROCESSLIST",
    "PROFILE",
    "PROFILES",
    "PROXY",
    "PURGE",
    "QUARTER",
    "QUERY",
    "QUICK",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "READ_ONLY",
    "READ_WRITE",
    "READS",
    "REAL",
    "REBUILD",
    "RECOVER",
    "RECURSIVE",
    "REDO_BUFFER_SIZE",
    "REDOFILE",
    "REDUNDANT",
    "REFERENCES",
    "REGEXP",
    "RELAY",
    "RELAYLOG",
    "RELAY_LOG_FILE",
    "RELAY_LOG_POS",
    "RELAY_THREAD",
    "RELEASE",
    "RELOAD",
    "REMOVE",
    "RENAME",
    "REORGANIZE",
    "REPAIR",
    "REPEATABLE",
    "REPLACE",
    "REPLAY",
    "REPLICA",
    "REPLICAS",
    "REPLICA_POS",
    "REPLICATION",
    "REPEAT",
    "REQUIRE",
    "RESET",
    "RESIGNAL",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    "RESUME",
    "RETURNED_SQLSTATE",
    "RETURN",
    "RETURNING",
    "RETURNS",
    "REUSE",
    "REVERSE",
    "REVOKE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROUTINE",
    "ROW",
    "ROWCOUNT",
    "ROWNUM",
    "ROWS",
    "ROWTYPE",
    "ROW_COUNT",
    "ROW_FORMAT",
    "RTREE",
    "SAVEPOINT",
    "SCHEDULE",
    "SCHEMA",
    "SCHEMA_NAME",
    "SCHEMAS",
    "SECOND",
    "SECOND_MICROSECOND",
    "SECURITY",
    "SELECT",
    "SENSITIVE",
    "SEPARATOR",
    "SEQUENCE",
    "SERIAL",
    "SERIALIZABLE",
    "SESSION",
    "SERVER",
    "SET",
    "SETVAL",
    "SHARE",
    "SHOW",
    "SHUTDOWN",
    "SIGNAL",
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SLAVE",
    "SLAVES",
    "SLAVE_POS",
    "SLOW",
    "SNAPSHOT",
    "SMALLINT",
    "SOCKET",
    "SOFT",
    "SOME",
    "SONAME",
    "SOUNDS",
    "SOURCE",
    "STAGE",
    "STORED",
    "SPATIAL",
    "SPECIFIC",
    "REF_SYSTEM_ID",
    "SQL",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "SQL_BIG_RESULT",
    "SQL_BUFFER_RESULT",
    "SQL_CACHE",
    "SQL_CALC_FOUND_ROWS",
    "SQL_NO_CACHE",
    "SQL_SMALL_RESULT",
    "SQL_THREAD",
    "SQL_TSI_SECOND",
    "SQL_TSI_MINUTE",
    "SQL_TSI_HOUR",
    "SQL_TSI_DAY",
    "SQL_TSI_WEEK",
    "SQL_TSI_MONTH",
    "SQL_TSI_QUARTER",
    "SQL_TSI_YEAR",
    "SSL",
    "START",
    "STARTING",
    "STARTS",
    "STATEMENT",
    "STATS_AUTO_RECALC",
    "STATS_PERSISTENT",
    "STATS_SAMPLE_PAGES",
    "STATUS",
    "STOP",
    "STORAGE",
    "STRAIGHT_JOIN",
    "STRING",
    "SUBCLASS_ORIGIN",
    "SUBJECT",
    "SUBPARTITION",
    "SUBPARTITIONS",
    "SUPER",
    "SUSPEND",
    "SWAPS",
    "SWITCHES",
    "SYSDATE",
    "SYSTEM",
    "SYSTEM_TIME",
    "TABLE",
    "TABLE_NAME",
    "TABLES",
    "TABLESPACE",
    "TABLE_CHECKSUM",
    "TEMPORARY",
    "TEMPTABLE",
    "TERMINATED",
    "TEXT",
    "THAN",
    "THEN",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TINYBLOB",
    "TINYINT",
    "TINYTEXT",
    "TO",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONAL",
    "THREADS",
    "TRIGGER",
    "TRIGGERS",
    "TRUE",
    "TRUNCATE",
    "TYPE",
    "TYPES",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNDEFINED",
    "UNDO_BUFFER_SIZE",
    "UNDOFILE",
    "UNDO",
    "UNICODE",
    "UNION",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNINSTALL",
    "UNSIGNED",
    "UNTIL",
    "UPDATE",
    "UPGRADE",
    "USAGE",
    "USE",
    "USER",
    "USER_RESOURCES",
    "USE_FRM",
    "USING",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "VALUE",
    "VALUES",
    "VARBINARY",
    "VARCHAR",
    "VARCHARACTER",
    "VARCHAR2",
    "VARIABLES",
    "VARYING",
    "VIA",
    "VIEW",
    "VIRTUAL",
    "VISIBLE",
    "VERSIONING",
    "WAIT",
    "WARNINGS",
    "WEEK",
    "WEIGHT_STRING",
    "WHEN",
    "WHERE",
    "WHILE",
    "WINDOW",
    "WITH",
    "WITHIN",
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    "X509",
    "XOR",
    "XA",
    "XML",
    "YEAR",
    "YEAR_MONTH",
    "ZEROFILL"
  ]
}), tke = Ct({
  // https://mariadb.com/kb/en/information-schema-sql_functions-table/
  all: [
    "ADDDATE",
    "ADD_MONTHS",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "CAST",
    "COUNT",
    "CUME_DIST",
    "CURDATE",
    "CURTIME",
    "DATE_ADD",
    "DATE_SUB",
    "DATE_FORMAT",
    "DECODE",
    "DENSE_RANK",
    "EXTRACT",
    "FIRST_VALUE",
    "GROUP_CONCAT",
    "JSON_ARRAYAGG",
    "JSON_OBJECTAGG",
    "LAG",
    "LEAD",
    "MAX",
    "MEDIAN",
    "MID",
    "MIN",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "POSITION",
    "PERCENT_RANK",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "RANK",
    "ROW_NUMBER",
    "SESSION_USER",
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUM",
    "SYSTEM_USER",
    "TRIM",
    "TRIM_ORACLE",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "ABS",
    "ACOS",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    "ASIN",
    "ATAN",
    "ATAN2",
    "BENCHMARK",
    "BIN",
    "BINLOG_GTID_POS",
    "BIT_COUNT",
    "BIT_LENGTH",
    "CEIL",
    "CEILING",
    "CHARACTER_LENGTH",
    "CHAR_LENGTH",
    "CHR",
    "COERCIBILITY",
    "COLUMN_CHECK",
    "COLUMN_EXISTS",
    "COLUMN_LIST",
    "COLUMN_JSON",
    "COMPRESS",
    "CONCAT",
    "CONCAT_OPERATOR_ORACLE",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT_TZ",
    "COS",
    "COT",
    "CRC32",
    "DATEDIFF",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DEGREES",
    "DECODE_HISTOGRAM",
    "DECODE_ORACLE",
    "DES_DECRYPT",
    "DES_ENCRYPT",
    "ELT",
    "ENCODE",
    "ENCRYPT",
    "EXP",
    "EXPORT_SET",
    "EXTRACTVALUE",
    "FIELD",
    "FIND_IN_SET",
    "FLOOR",
    "FORMAT",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GET_LOCK",
    "GREATEST",
    "HEX",
    "IFNULL",
    "INSTR",
    "ISNULL",
    "IS_FREE_LOCK",
    "IS_USED_LOCK",
    "JSON_ARRAY",
    "JSON_ARRAY_APPEND",
    "JSON_ARRAY_INSERT",
    "JSON_COMPACT",
    "JSON_CONTAINS",
    "JSON_CONTAINS_PATH",
    "JSON_DEPTH",
    "JSON_DETAILED",
    "JSON_EXISTS",
    "JSON_EXTRACT",
    "JSON_INSERT",
    "JSON_KEYS",
    "JSON_LENGTH",
    "JSON_LOOSE",
    "JSON_MERGE",
    "JSON_MERGE_PATCH",
    "JSON_MERGE_PRESERVE",
    "JSON_QUERY",
    "JSON_QUOTE",
    "JSON_OBJECT",
    "JSON_REMOVE",
    "JSON_REPLACE",
    "JSON_SET",
    "JSON_SEARCH",
    "JSON_TYPE",
    "JSON_UNQUOTE",
    "JSON_VALID",
    "JSON_VALUE",
    "LAST_DAY",
    "LAST_INSERT_ID",
    "LCASE",
    "LEAST",
    "LENGTH",
    "LENGTHB",
    "LN",
    "LOAD_FILE",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LOWER",
    "LPAD",
    "LPAD_ORACLE",
    "LTRIM",
    "LTRIM_ORACLE",
    "MAKEDATE",
    "MAKETIME",
    "MAKE_SET",
    "MASTER_GTID_WAIT",
    "MASTER_POS_WAIT",
    "MD5",
    "MONTHNAME",
    "NAME_CONST",
    "NVL",
    "NVL2",
    "OCT",
    "OCTET_LENGTH",
    "ORD",
    "PERIOD_ADD",
    "PERIOD_DIFF",
    "PI",
    "POW",
    "POWER",
    "QUOTE",
    "REGEXP_INSTR",
    "REGEXP_REPLACE",
    "REGEXP_SUBSTR",
    "RADIANS",
    "RAND",
    "RELEASE_ALL_LOCKS",
    "RELEASE_LOCK",
    "REPLACE_ORACLE",
    "REVERSE",
    "ROUND",
    "RPAD",
    "RPAD_ORACLE",
    "RTRIM",
    "RTRIM_ORACLE",
    "SEC_TO_TIME",
    "SHA",
    "SHA1",
    "SHA2",
    "SIGN",
    "SIN",
    "SLEEP",
    "SOUNDEX",
    "SPACE",
    "SQRT",
    "STRCMP",
    "STR_TO_DATE",
    "SUBSTR_ORACLE",
    "SUBSTRING_INDEX",
    "SUBTIME",
    "SYS_GUID",
    "TAN",
    "TIMEDIFF",
    "TIME_FORMAT",
    "TIME_TO_SEC",
    "TO_BASE64",
    "TO_CHAR",
    "TO_DAYS",
    "TO_SECONDS",
    "UCASE",
    "UNCOMPRESS",
    "UNCOMPRESSED_LENGTH",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "UUID",
    "UUID_SHORT",
    "VERSION",
    "WEEKDAY",
    "WEEKOFYEAR",
    "WSREP_LAST_WRITTEN_GTID",
    "WSREP_LAST_SEEN_GTID",
    "WSREP_SYNC_WAIT_UPTO_GTID",
    "YEARWEEK",
    // CASE expression shorthands
    "COALESCE",
    "NULLIF",
    // Data types with parameters
    // https://mariadb.com/kb/en/data-types/
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    // 'NUMBER', // ?? In oracle mode only
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "BIT",
    "BINARY",
    "BLOB",
    "CHAR",
    "NATIONAL CHAR",
    "CHAR BYTE",
    "ENUM",
    "VARBINARY",
    "VARCHAR",
    "NATIONAL VARCHAR",
    // 'SET' // handled as special-case in postProcess
    "TIME",
    "DATETIME",
    "TIMESTAMP",
    "YEAR"
  ]
}), rke = ie(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), ike = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMPORARY] TABLE [IF NOT EXISTS]",
  // other
  "RETURNING"
]), wB = ie([
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] [IGNORE] TABLE [IF EXISTS]",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "{CHANGE | MODIFY} [COLUMN] [IF EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "RENAME [TO]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  "SET {VISIBLE | INVISIBLE}",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://mariadb.com/docs/reference/mdb/sql-statements/
  "ALTER DATABASE",
  "ALTER DATABASE COMMENT",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER SCHEMA COMMENT",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE",
  "ANALYZE TABLE",
  "BACKUP LOCK",
  "BACKUP STAGE",
  "BACKUP UNLOCK",
  "BEGIN",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHECK TABLE",
  "CHECK VIEW",
  "CHECKSUM TABLE",
  "COMMIT",
  "CREATE AGGREGATE FUNCTION",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PROCEDURE",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE SERVER",
  "CREATE SPATIAL INDEX",
  "CREATE TRIGGER",
  "CREATE UNIQUE INDEX",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PREPARE",
  "DROP PROCEDURE",
  "DROP ROLE",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GET DIAGNOSTICS",
  "GET DIAGNOSTICS CONDITION",
  "GRANT",
  "HANDLER",
  "HELP",
  "INSTALL PLUGIN",
  "INSTALL SONAME",
  "KILL",
  "LOAD DATA INFILE",
  "LOAD INDEX INTO CACHE",
  "LOAD XML INFILE",
  "LOCK TABLE",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "PURGE MASTER LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "REPAIR VIEW",
  "RESET MASTER",
  "RESET QUERY CACHE",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESIGNAL",
  "REVOKE",
  "ROLLBACK",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET GLOBAL TRANSACTION",
  "SET NAMES",
  "SET PASSWORD",
  "SET ROLE",
  "SET STATEMENT",
  "SET TRANSACTION",
  "SHOW",
  "SHOW ALL REPLICAS STATUS",
  "SHOW ALL SLAVES STATUS",
  "SHOW AUTHORS",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW BINLOG STATUS",
  "SHOW CHARACTER SET",
  "SHOW CLIENT_STATISTICS",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CONTRIBUTORS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PACKAGE",
  "SHOW CREATE PACKAGE BODY",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE SEQUENCE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINE INNODB STATUS",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW EXPLAIN",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW INDEXES",
  "SHOW INDEX_STATISTICS",
  "SHOW KEYS",
  "SHOW LOCALES",
  "SHOW MASTER LOGS",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PACKAGE BODY CODE",
  "SHOW PACKAGE BODY STATUS",
  "SHOW PACKAGE STATUS",
  "SHOW PLUGINS",
  "SHOW PLUGINS SONAME",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW QUERY_RESPONSE_TIME",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA",
  "SHOW REPLICA HOSTS",
  "SHOW REPLICA STATUS",
  "SHOW SCHEMAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW SLAVE STATUS",
  "SHOW STATUS",
  "SHOW STORAGE ENGINES",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW USER_STATISTICS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHOW WSREP_MEMBERSHIP",
  "SHOW WSREP_STATUS",
  "SHUTDOWN",
  "SIGNAL",
  "START ALL REPLICAS",
  "START ALL SLAVES",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP ALL REPLICAS",
  "STOP ALL SLAVES",
  "STOP REPLICA",
  "STOP SLAVE",
  "UNINSTALL PLUGIN",
  "UNINSTALL SONAME",
  "UNLOCK TABLE",
  "USE",
  "XA BEGIN",
  "XA COMMIT",
  "XA END",
  "XA PREPARE",
  "XA RECOVER",
  "XA ROLLBACK",
  "XA START"
]), nke = ie(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]", "MINUS [ALL | DISTINCT]"]), ake = ie([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), oke = ie(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), ske = {
  tokenizerOptions: {
    reservedSelect: rke,
    reservedClauses: [...ike, ...wB],
    reservedSetOperations: nke,
    reservedJoins: ake,
    reservedPhrases: oke,
    supportsXor: !0,
    reservedKeywords: eke,
    reservedFunctionNames: tke,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: ['""-qq-bs', "''-qq-bs", {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_.$]+"
    }, {
      quote: '""-qq-bs',
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "''-qq-bs",
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    paramTypes: {
      positional: !0
    },
    lineCommentTypes: ["--", "#"],
    operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "!"],
    postProcess: lke
  },
  formatOptions: {
    onelineClauses: wB
  }
};
function lke(r) {
  return r.map((e, t) => {
    const i = r[t + 1] || hh;
    return ml.SET(e) && i.text === "(" ? {
      ...e,
      type: te.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const uke = Ct({
  // https://dev.mysql.com/doc/refman/8.0/en/keywords.html
  all: [
    "ACCESSIBLE",
    // (R)
    "ACCOUNT",
    "ACTION",
    "ACTIVE",
    "ADD",
    // (R)
    "ADMIN",
    "AFTER",
    "AGAINST",
    "AGGREGATE",
    "ALGORITHM",
    "ALL",
    // (R)
    "ALTER",
    // (R)
    "ALWAYS",
    "ANALYZE",
    // (R)
    "AND",
    // (R)
    "ANY",
    "ARRAY",
    "AS",
    // (R)
    "ASC",
    // (R)
    "ASCII",
    "ASENSITIVE",
    // (R)
    "AT",
    "ATTRIBUTE",
    "AUTHENTICATION",
    "AUTOEXTEND_SIZE",
    "AUTO_INCREMENT",
    "AVG",
    "AVG_ROW_LENGTH",
    "BACKUP",
    "BEFORE",
    // (R)
    "BEGIN",
    "BETWEEN",
    // (R)
    "BIGINT",
    // (R)
    "BINARY",
    // (R)
    "BINLOG",
    "BIT",
    "BLOB",
    // (R)
    "BLOCK",
    "BOOL",
    "BOOLEAN",
    "BOTH",
    // (R)
    "BTREE",
    "BUCKETS",
    "BY",
    // (R)
    "BYTE",
    "CACHE",
    "CALL",
    // (R)
    "CASCADE",
    // (R)
    "CASCADED",
    "CASE",
    // (R)
    "CATALOG_NAME",
    "CHAIN",
    "CHALLENGE_RESPONSE",
    "CHANGE",
    // (R)
    "CHANGED",
    "CHANNEL",
    "CHAR",
    // (R)
    "CHARACTER",
    // (R)
    "CHARSET",
    "CHECK",
    // (R)
    "CHECKSUM",
    "CIPHER",
    "CLASS_ORIGIN",
    "CLIENT",
    "CLONE",
    "CLOSE",
    "COALESCE",
    "CODE",
    "COLLATE",
    // (R)
    "COLLATION",
    "COLUMN",
    // (R)
    "COLUMNS",
    "COLUMN_FORMAT",
    "COLUMN_NAME",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPACT",
    "COMPLETION",
    "COMPONENT",
    "COMPRESSED",
    "COMPRESSION",
    "CONCURRENT",
    "CONDITION",
    // (R)
    "CONNECTION",
    "CONSISTENT",
    "CONSTRAINT",
    // (R)
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONTAINS",
    "CONTEXT",
    "CONTINUE",
    // (R)
    "CONVERT",
    // (R)
    "CPU",
    "CREATE",
    // (R)
    "CROSS",
    // (R)
    "CUBE",
    // (R)
    "CUME_DIST",
    // (R)
    "CURRENT",
    "CURRENT_DATE",
    // (R)
    "CURRENT_TIME",
    // (R)
    "CURRENT_TIMESTAMP",
    // (R)
    "CURRENT_USER",
    // (R)
    "CURSOR",
    // (R)
    "CURSOR_NAME",
    "DATA",
    "DATABASE",
    // (R)
    "DATABASES",
    // (R)
    "DATAFILE",
    "DATE",
    "DATETIME",
    "DAY",
    "DAY_HOUR",
    // (R)
    "DAY_MICROSECOND",
    // (R)
    "DAY_MINUTE",
    // (R)
    "DAY_SECOND",
    // (R)
    "DEALLOCATE",
    "DEC",
    // (R)
    "DECIMAL",
    // (R)
    "DECLARE",
    // (R)
    "DEFAULT",
    // (R)
    "DEFAULT_AUTH",
    "DEFINER",
    "DEFINITION",
    "DELAYED",
    // (R)
    "DELAY_KEY_WRITE",
    "DELETE",
    // (R)
    "DENSE_RANK",
    // (R)
    "DESC",
    // (R)
    "DESCRIBE",
    // (R)
    "DESCRIPTION",
    "DETERMINISTIC",
    // (R)
    "DIAGNOSTICS",
    "DIRECTORY",
    "DISABLE",
    "DISCARD",
    "DISK",
    "DISTINCT",
    // (R)
    "DISTINCTROW",
    // (R)
    "DIV",
    // (R)
    "DO",
    "DOUBLE",
    // (R)
    "DROP",
    // (R)
    "DUAL",
    // (R)
    "DUMPFILE",
    "DUPLICATE",
    "DYNAMIC",
    "EACH",
    // (R)
    "ELSE",
    // (R)
    "ELSEIF",
    // (R)
    "EMPTY",
    // (R)
    "ENABLE",
    "ENCLOSED",
    // (R)
    "ENCRYPTION",
    "END",
    "ENDS",
    "ENFORCED",
    "ENGINE",
    "ENGINES",
    "ENGINE_ATTRIBUTE",
    "ENUM",
    "ERROR",
    "ERRORS",
    "ESCAPE",
    "ESCAPED",
    // (R)
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXCEPT",
    // (R)
    "EXCHANGE",
    "EXCLUDE",
    "EXECUTE",
    "EXISTS",
    // (R)
    "EXIT",
    // (R)
    "EXPANSION",
    "EXPIRE",
    "EXPLAIN",
    // (R)
    "EXPORT",
    "EXTENDED",
    "EXTENT_SIZE",
    "FACTOR",
    "FAILED_LOGIN_ATTEMPTS",
    "FALSE",
    // (R)
    "FAST",
    "FAULTS",
    "FETCH",
    // (R)
    "FIELDS",
    "FILE",
    "FILE_BLOCK_SIZE",
    "FILTER",
    "FINISH",
    "FIRST",
    "FIRST_VALUE",
    // (R)
    "FIXED",
    "FLOAT",
    // (R)
    "FLOAT4",
    // (R)
    "FLOAT8",
    // (R)
    "FLUSH",
    "FOLLOWING",
    "FOLLOWS",
    "FOR",
    // (R)
    "FORCE",
    // (R)
    "FOREIGN",
    // (R)
    "FORMAT",
    "FOUND",
    "FROM",
    // (R)
    "FULL",
    "FULLTEXT",
    // (R)
    "FUNCTION",
    // (R)
    "GENERAL",
    "GENERATED",
    // (R)
    "GEOMCOLLECTION",
    "GEOMETRY",
    "GEOMETRYCOLLECTION",
    "GET",
    // (R)
    "GET_FORMAT",
    "GET_MASTER_PUBLIC_KEY",
    "GET_SOURCE_PUBLIC_KEY",
    "GLOBAL",
    "GRANT",
    // (R)
    "GRANTS",
    "GROUP",
    // (R)
    "GROUPING",
    // (R)
    "GROUPS",
    // (R)
    "GROUP_REPLICATION",
    "GTID_ONLY",
    "HANDLER",
    "HASH",
    "HAVING",
    // (R)
    "HELP",
    "HIGH_PRIORITY",
    // (R)
    "HISTOGRAM",
    "HISTORY",
    "HOST",
    "HOSTS",
    "HOUR",
    "HOUR_MICROSECOND",
    // (R)
    "HOUR_MINUTE",
    // (R)
    "HOUR_SECOND",
    // (R)
    "IDENTIFIED",
    "IF",
    // (R)
    "IGNORE",
    // (R)
    "IGNORE_SERVER_IDS",
    "IMPORT",
    "IN",
    // (R)
    "INACTIVE",
    "INDEX",
    // (R)
    "INDEXES",
    "INFILE",
    // (R)
    "INITIAL",
    "INITIAL_SIZE",
    "INITIATE",
    "INNER",
    // (R)
    "INOUT",
    // (R)
    "INSENSITIVE",
    // (R)
    "INSERT",
    // (R)
    "INSERT_METHOD",
    "INSTALL",
    "INSTANCE",
    "IN",
    // <-- moved over from functions
    "INT",
    // (R)
    "INT1",
    // (R)
    "INT2",
    // (R)
    "INT3",
    // (R)
    "INT4",
    // (R)
    "INT8",
    // (R)
    "INTEGER",
    // (R)
    "INTERSECT",
    // (R)
    "INTERVAL",
    // (R)
    "INTO",
    // (R)
    "INVISIBLE",
    "INVOKER",
    "IO",
    "IO_AFTER_GTIDS",
    // (R)
    "IO_BEFORE_GTIDS",
    // (R)
    "IO_THREAD",
    "IPC",
    "IS",
    // (R)
    "ISOLATION",
    "ISSUER",
    "ITERATE",
    // (R)
    "JOIN",
    // (R)
    "JSON",
    "JSON_TABLE",
    // (R)
    "JSON_VALUE",
    "KEY",
    // (R)
    "KEYRING",
    "KEYS",
    // (R)
    "KEY_BLOCK_SIZE",
    "KILL",
    // (R)
    "LAG",
    // (R)
    "LANGUAGE",
    "LAST",
    "LAST_VALUE",
    // (R)
    "LATERAL",
    // (R)
    "LEAD",
    // (R)
    "LEADING",
    // (R)
    "LEAVE",
    // (R)
    "LEAVES",
    "LEFT",
    // (R)
    "LESS",
    "LEVEL",
    "LIKE",
    // (R)
    "LIMIT",
    // (R)
    "LINEAR",
    // (R)
    "LINES",
    // (R)
    "LINESTRING",
    "LIST",
    "LOAD",
    // (R)
    "LOCAL",
    "LOCALTIME",
    // (R)
    "LOCALTIMESTAMP",
    // (R)
    "LOCK",
    // (R)
    "LOCKED",
    "LOCKS",
    "LOGFILE",
    "LOGS",
    "LONG",
    // (R)
    "LONGBLOB",
    // (R)
    "LONGTEXT",
    // (R)
    "LOOP",
    // (R)
    "LOW_PRIORITY",
    // (R)
    "MASTER",
    "MASTER_AUTO_POSITION",
    "MASTER_BIND",
    // (R)
    "MASTER_COMPRESSION_ALGORITHMS",
    "MASTER_CONNECT_RETRY",
    "MASTER_DELAY",
    "MASTER_HEARTBEAT_PERIOD",
    "MASTER_HOST",
    "MASTER_LOG_FILE",
    "MASTER_LOG_POS",
    "MASTER_PASSWORD",
    "MASTER_PORT",
    "MASTER_PUBLIC_KEY_PATH",
    "MASTER_RETRY_COUNT",
    "MASTER_SSL",
    "MASTER_SSL_CA",
    "MASTER_SSL_CAPATH",
    "MASTER_SSL_CERT",
    "MASTER_SSL_CIPHER",
    "MASTER_SSL_CRL",
    "MASTER_SSL_CRLPATH",
    "MASTER_SSL_KEY",
    "MASTER_SSL_VERIFY_SERVER_CERT",
    // (R)
    "MASTER_TLS_CIPHERSUITES",
    "MASTER_TLS_VERSION",
    "MASTER_USER",
    "MASTER_ZSTD_COMPRESSION_LEVEL",
    "MATCH",
    // (R)
    "MAXVALUE",
    // (R)
    "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR",
    "MAX_ROWS",
    "MAX_SIZE",
    "MAX_UPDATES_PER_HOUR",
    "MAX_USER_CONNECTIONS",
    "MEDIUM",
    "MEDIUMBLOB",
    // (R)
    "MEDIUMINT",
    // (R)
    "MEDIUMTEXT",
    // (R)
    "MEMBER",
    "MEMORY",
    "MERGE",
    "MESSAGE_TEXT",
    "MICROSECOND",
    "MIDDLEINT",
    // (R)
    "MIGRATE",
    "MINUTE",
    "MINUTE_MICROSECOND",
    // (R)
    "MINUTE_SECOND",
    // (R)
    "MIN_ROWS",
    "MOD",
    // (R)
    "MODE",
    "MODIFIES",
    // (R)
    "MODIFY",
    "MONTH",
    "MULTILINESTRING",
    "MULTIPOINT",
    "MULTIPOLYGON",
    "MUTEX",
    "MYSQL_ERRNO",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    // (R)
    "NCHAR",
    "NDB",
    "NDBCLUSTER",
    "NESTED",
    "NETWORK_NAMESPACE",
    "NEVER",
    "NEW",
    "NEXT",
    "NO",
    "NODEGROUP",
    "NONE",
    "NOT",
    // (R)
    "NOWAIT",
    "NO_WAIT",
    "NO_WRITE_TO_BINLOG",
    // (R)
    "NTH_VALUE",
    // (R)
    "NTILE",
    // (R)
    "NULL",
    // (R)
    "NULLS",
    "NUMBER",
    "NUMERIC",
    // (R)
    "NVARCHAR",
    "OF",
    // (R)
    "OFF",
    "OFFSET",
    "OJ",
    "OLD",
    "ON",
    // (R)
    "ONE",
    "ONLY",
    "OPEN",
    "OPTIMIZE",
    // (R)
    "OPTIMIZER_COSTS",
    // (R)
    "OPTION",
    // (R)
    "OPTIONAL",
    "OPTIONALLY",
    // (R)
    "OPTIONS",
    "OR",
    // (R)
    "ORDER",
    // (R)
    "ORDINALITY",
    "ORGANIZATION",
    "OTHERS",
    "OUT",
    // (R)
    "OUTER",
    // (R)
    "OUTFILE",
    // (R)
    "OVER",
    // (R)
    "OWNER",
    "PACK_KEYS",
    "PAGE",
    "PARSER",
    "PARTIAL",
    "PARTITION",
    // (R)
    "PARTITIONING",
    "PARTITIONS",
    "PASSWORD",
    "PASSWORD_LOCK_TIME",
    "PATH",
    "PERCENT_RANK",
    // (R)
    "PERSIST",
    "PERSIST_ONLY",
    "PHASE",
    "PLUGIN",
    "PLUGINS",
    "PLUGIN_DIR",
    "POINT",
    "POLYGON",
    "PORT",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    // (R)
    "PREPARE",
    "PRESERVE",
    "PREV",
    "PRIMARY",
    // (R)
    "PRIVILEGES",
    "PRIVILEGE_CHECKS_USER",
    "PROCEDURE",
    // (R)
    "PROCESS",
    "PROCESSLIST",
    "PROFILE",
    "PROFILES",
    "PROXY",
    "PURGE",
    // (R)
    "QUARTER",
    "QUERY",
    "QUICK",
    "RANDOM",
    "RANGE",
    // (R)
    "RANK",
    // (R)
    "READ",
    // (R)
    "READS",
    // (R)
    "READ_ONLY",
    "READ_WRITE",
    // (R)
    "REAL",
    // (R)
    "REBUILD",
    "RECOVER",
    "RECURSIVE",
    // (R)
    "REDO_BUFFER_SIZE",
    "REDUNDANT",
    "REFERENCE",
    "REFERENCES",
    // (R)
    "REGEXP",
    // (R)
    "REGISTRATION",
    "RELAY",
    "RELAYLOG",
    "RELAY_LOG_FILE",
    "RELAY_LOG_POS",
    "RELAY_THREAD",
    "RELEASE",
    // (R)
    "RELOAD",
    "REMOVE",
    "RENAME",
    // (R)
    "REORGANIZE",
    "REPAIR",
    "REPEAT",
    // (R)
    "REPEATABLE",
    "REPLACE",
    // (R)
    "REPLICA",
    "REPLICAS",
    "REPLICATE_DO_DB",
    "REPLICATE_DO_TABLE",
    "REPLICATE_IGNORE_DB",
    "REPLICATE_IGNORE_TABLE",
    "REPLICATE_REWRITE_DB",
    "REPLICATE_WILD_DO_TABLE",
    "REPLICATE_WILD_IGNORE_TABLE",
    "REPLICATION",
    "REQUIRE",
    // (R)
    "REQUIRE_ROW_FORMAT",
    "RESET",
    "RESIGNAL",
    // (R)
    "RESOURCE",
    "RESPECT",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    // (R)
    "RESUME",
    "RETAIN",
    "RETURN",
    // (R)
    "RETURNED_SQLSTATE",
    "RETURNING",
    "RETURNS",
    "REUSE",
    "REVERSE",
    "REVOKE",
    // (R)
    "RIGHT",
    // (R)
    "RLIKE",
    // (R)
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROTATE",
    "ROUTINE",
    "ROW",
    // (R)
    "ROWS",
    // (R)
    "ROW_COUNT",
    "ROW_FORMAT",
    "ROW_NUMBER",
    // (R)
    "RTREE",
    "SAVEPOINT",
    "SCHEDULE",
    "SCHEMA",
    // (R)
    "SCHEMAS",
    // (R)
    "SCHEMA_NAME",
    "SECOND",
    "SECONDARY",
    "SECONDARY_ENGINE",
    "SECONDARY_ENGINE_ATTRIBUTE",
    "SECONDARY_LOAD",
    "SECONDARY_UNLOAD",
    "SECOND_MICROSECOND",
    // (R)
    "SECURITY",
    "SELECT",
    // (R)
    "SENSITIVE",
    // (R)
    "SEPARATOR",
    // (R)
    "SERIAL",
    "SERIALIZABLE",
    "SERVER",
    "SESSION",
    "SET",
    // (R)
    "SHARE",
    "SHOW",
    // (R)
    "SHUTDOWN",
    "SIGNAL",
    // (R)
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SLAVE",
    "SLOW",
    "SMALLINT",
    // (R)
    "SNAPSHOT",
    "SOCKET",
    "SOME",
    "SONAME",
    "SOUNDS",
    "SOURCE",
    "SOURCE_AUTO_POSITION",
    "SOURCE_BIND",
    "SOURCE_COMPRESSION_ALGORITHMS",
    "SOURCE_CONNECT_RETRY",
    "SOURCE_DELAY",
    "SOURCE_HEARTBEAT_PERIOD",
    "SOURCE_HOST",
    "SOURCE_LOG_FILE",
    "SOURCE_LOG_POS",
    "SOURCE_PASSWORD",
    "SOURCE_PORT",
    "SOURCE_PUBLIC_KEY_PATH",
    "SOURCE_RETRY_COUNT",
    "SOURCE_SSL",
    "SOURCE_SSL_CA",
    "SOURCE_SSL_CAPATH",
    "SOURCE_SSL_CERT",
    "SOURCE_SSL_CIPHER",
    "SOURCE_SSL_CRL",
    "SOURCE_SSL_CRLPATH",
    "SOURCE_SSL_KEY",
    "SOURCE_SSL_VERIFY_SERVER_CERT",
    "SOURCE_TLS_CIPHERSUITES",
    "SOURCE_TLS_VERSION",
    "SOURCE_USER",
    "SOURCE_ZSTD_COMPRESSION_LEVEL",
    "SPATIAL",
    // (R)
    "SPECIFIC",
    // (R)
    "SQL",
    // (R)
    "SQLEXCEPTION",
    // (R)
    "SQLSTATE",
    // (R)
    "SQLWARNING",
    // (R)
    "SQL_AFTER_GTIDS",
    "SQL_AFTER_MTS_GAPS",
    "SQL_BEFORE_GTIDS",
    "SQL_BIG_RESULT",
    // (R)
    "SQL_BUFFER_RESULT",
    "SQL_CALC_FOUND_ROWS",
    // (R)
    "SQL_NO_CACHE",
    "SQL_SMALL_RESULT",
    // (R)
    "SQL_THREAD",
    "SQL_TSI_DAY",
    "SQL_TSI_HOUR",
    "SQL_TSI_MINUTE",
    "SQL_TSI_MONTH",
    "SQL_TSI_QUARTER",
    "SQL_TSI_SECOND",
    "SQL_TSI_WEEK",
    "SQL_TSI_YEAR",
    "SRID",
    "SSL",
    // (R)
    "STACKED",
    "START",
    "STARTING",
    // (R)
    "STARTS",
    "STATS_AUTO_RECALC",
    "STATS_PERSISTENT",
    "STATS_SAMPLE_PAGES",
    "STATUS",
    "STOP",
    "STORAGE",
    "STORED",
    // (R)
    "STRAIGHT_JOIN",
    // (R)
    "STREAM",
    "STRING",
    "SUBCLASS_ORIGIN",
    "SUBJECT",
    "SUBPARTITION",
    "SUBPARTITIONS",
    "SUPER",
    "SUSPEND",
    "SWAPS",
    "SWITCHES",
    "SYSTEM",
    // (R)
    "TABLE",
    // (R)
    "TABLES",
    "TABLESPACE",
    "TABLE_CHECKSUM",
    "TABLE_NAME",
    "TEMPORARY",
    "TEMPTABLE",
    "TERMINATED",
    // (R)
    "TEXT",
    "THAN",
    "THEN",
    // (R)
    "THREAD_PRIORITY",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TINYBLOB",
    // (R)
    "TINYINT",
    // (R)
    "TINYTEXT",
    // (R)
    "TLS",
    "TO",
    // (R)
    "TRAILING",
    // (R)
    "TRANSACTION",
    "TRIGGER",
    // (R)
    "TRIGGERS",
    "TRUE",
    // (R)
    "TRUNCATE",
    "TYPE",
    "TYPES",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNDEFINED",
    "UNDO",
    // (R)
    "UNDOFILE",
    "UNDO_BUFFER_SIZE",
    "UNICODE",
    "UNINSTALL",
    "UNION",
    // (R)
    "UNIQUE",
    // (R)
    "UNKNOWN",
    "UNLOCK",
    // (R)
    "UNREGISTER",
    "UNSIGNED",
    // (R)
    "UNTIL",
    "UPDATE",
    // (R)
    "UPGRADE",
    "USAGE",
    // (R)
    "USE",
    // (R)
    "USER",
    "USER_RESOURCES",
    "USE_FRM",
    "USING",
    // (R)
    "UTC_DATE",
    // (R)
    "UTC_TIME",
    // (R)
    "UTC_TIMESTAMP",
    // (R)
    "VALIDATION",
    "VALUE",
    "VALUES",
    // (R)
    "VARBINARY",
    // (R)
    "VARCHAR",
    // (R)
    "VARCHARACTER",
    // (R)
    "VARIABLES",
    "VARYING",
    // (R)
    "VCPU",
    "VIEW",
    "VIRTUAL",
    // (R)
    "VISIBLE",
    "WAIT",
    "WARNINGS",
    "WEEK",
    "WEIGHT_STRING",
    "WHEN",
    // (R)
    "WHERE",
    // (R)
    "WHILE",
    // (R)
    "WINDOW",
    // (R)
    "WITH",
    // (R)
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    // (R)
    "X509",
    "XA",
    "XID",
    "XML",
    "XOR",
    // (R)
    "YEAR",
    "YEAR_MONTH",
    // (R)
    "ZEROFILL",
    // (R)
    "ZONE"
  ]
}), hke = Ct({
  // https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html
  all: [
    "ABS",
    "ACOS",
    "ADDDATE",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    // 'AND',
    "ANY_VALUE",
    "ASCII",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BENCHMARK",
    "BIN",
    "BIN_TO_UUID",
    "BINARY",
    "BIT_AND",
    "BIT_COUNT",
    "BIT_LENGTH",
    "BIT_OR",
    "BIT_XOR",
    "CAN_ACCESS_COLUMN",
    "CAN_ACCESS_DATABASE",
    "CAN_ACCESS_TABLE",
    "CAN_ACCESS_USER",
    "CAN_ACCESS_VIEW",
    "CAST",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHAR_LENGTH",
    "CHARACTER_LENGTH",
    "CHARSET",
    "COALESCE",
    "COERCIBILITY",
    "COLLATION",
    "COMPRESS",
    "CONCAT",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT",
    "CONVERT_TZ",
    "COS",
    "COT",
    "COUNT",
    "CRC32",
    "CUME_DIST",
    "CURDATE",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURTIME",
    "DATABASE",
    "DATE",
    "DATE_ADD",
    "DATE_FORMAT",
    "DATE_SUB",
    "DATEDIFF",
    "DAY",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DEFAULT",
    "DEGREES",
    "DENSE_RANK",
    "DIV",
    "ELT",
    "EXP",
    "EXPORT_SET",
    "EXTRACT",
    "EXTRACTVALUE",
    "FIELD",
    "FIND_IN_SET",
    "FIRST_VALUE",
    "FLOOR",
    "FORMAT",
    "FORMAT_BYTES",
    "FORMAT_PICO_TIME",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GEOMCOLLECTION",
    "GEOMETRYCOLLECTION",
    "GET_DD_COLUMN_PRIVILEGES",
    "GET_DD_CREATE_OPTIONS",
    "GET_DD_INDEX_SUB_PART_LENGTH",
    "GET_FORMAT",
    "GET_LOCK",
    "GREATEST",
    "GROUP_CONCAT",
    "GROUPING",
    "GTID_SUBSET",
    "GTID_SUBTRACT",
    "HEX",
    "HOUR",
    "ICU_VERSION",
    "IF",
    "IFNULL",
    // 'IN',
    "INET_ATON",
    "INET_NTOA",
    "INET6_ATON",
    "INET6_NTOA",
    "INSERT",
    "INSTR",
    "INTERNAL_AUTO_INCREMENT",
    "INTERNAL_AVG_ROW_LENGTH",
    "INTERNAL_CHECK_TIME",
    "INTERNAL_CHECKSUM",
    "INTERNAL_DATA_FREE",
    "INTERNAL_DATA_LENGTH",
    "INTERNAL_DD_CHAR_LENGTH",
    "INTERNAL_GET_COMMENT_OR_ERROR",
    "INTERNAL_GET_ENABLED_ROLE_JSON",
    "INTERNAL_GET_HOSTNAME",
    "INTERNAL_GET_USERNAME",
    "INTERNAL_GET_VIEW_WARNING_OR_ERROR",
    "INTERNAL_INDEX_COLUMN_CARDINALITY",
    "INTERNAL_INDEX_LENGTH",
    "INTERNAL_IS_ENABLED_ROLE",
    "INTERNAL_IS_MANDATORY_ROLE",
    "INTERNAL_KEYS_DISABLED",
    "INTERNAL_MAX_DATA_LENGTH",
    "INTERNAL_TABLE_ROWS",
    "INTERNAL_UPDATE_TIME",
    "INTERVAL",
    "IS",
    "IS_FREE_LOCK",
    "IS_IPV4",
    "IS_IPV4_COMPAT",
    "IS_IPV4_MAPPED",
    "IS_IPV6",
    "IS NOT",
    "IS NOT NULL",
    "IS NULL",
    "IS_USED_LOCK",
    "IS_UUID",
    "ISNULL",
    "JSON_ARRAY",
    "JSON_ARRAY_APPEND",
    "JSON_ARRAY_INSERT",
    "JSON_ARRAYAGG",
    "JSON_CONTAINS",
    "JSON_CONTAINS_PATH",
    "JSON_DEPTH",
    "JSON_EXTRACT",
    "JSON_INSERT",
    "JSON_KEYS",
    "JSON_LENGTH",
    "JSON_MERGE",
    "JSON_MERGE_PATCH",
    "JSON_MERGE_PRESERVE",
    "JSON_OBJECT",
    "JSON_OBJECTAGG",
    "JSON_OVERLAPS",
    "JSON_PRETTY",
    "JSON_QUOTE",
    "JSON_REMOVE",
    "JSON_REPLACE",
    "JSON_SCHEMA_VALID",
    "JSON_SCHEMA_VALIDATION_REPORT",
    "JSON_SEARCH",
    "JSON_SET",
    "JSON_STORAGE_FREE",
    "JSON_STORAGE_SIZE",
    "JSON_TABLE",
    "JSON_TYPE",
    "JSON_UNQUOTE",
    "JSON_VALID",
    "JSON_VALUE",
    "LAG",
    "LAST_DAY",
    "LAST_INSERT_ID",
    "LAST_VALUE",
    "LCASE",
    "LEAD",
    "LEAST",
    "LEFT",
    "LENGTH",
    "LIKE",
    "LINESTRING",
    "LN",
    "LOAD_FILE",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LOWER",
    "LPAD",
    "LTRIM",
    "MAKE_SET",
    "MAKEDATE",
    "MAKETIME",
    "MASTER_POS_WAIT",
    "MATCH",
    "MAX",
    "MBRCONTAINS",
    "MBRCOVEREDBY",
    "MBRCOVERS",
    "MBRDISJOINT",
    "MBREQUALS",
    "MBRINTERSECTS",
    "MBROVERLAPS",
    "MBRTOUCHES",
    "MBRWITHIN",
    "MD5",
    "MEMBER OF",
    "MICROSECOND",
    "MID",
    "MIN",
    "MINUTE",
    "MOD",
    "MONTH",
    "MONTHNAME",
    "MULTILINESTRING",
    "MULTIPOINT",
    "MULTIPOLYGON",
    "NAME_CONST",
    "NOT",
    "NOT IN",
    "NOT LIKE",
    "NOT REGEXP",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "OCT",
    "OCTET_LENGTH",
    // 'OR',
    "ORD",
    "PERCENT_RANK",
    "PERIOD_ADD",
    "PERIOD_DIFF",
    "PI",
    "POINT",
    "POLYGON",
    "POSITION",
    "POW",
    "POWER",
    "PS_CURRENT_THREAD_ID",
    "PS_THREAD_ID",
    "QUARTER",
    "QUOTE",
    "RADIANS",
    "RAND",
    "RANDOM_BYTES",
    "RANK",
    "REGEXP",
    "REGEXP_INSTR",
    "REGEXP_LIKE",
    "REGEXP_REPLACE",
    "REGEXP_SUBSTR",
    "RELEASE_ALL_LOCKS",
    "RELEASE_LOCK",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RLIKE",
    "ROLES_GRAPHML",
    "ROUND",
    "ROW_COUNT",
    "ROW_NUMBER",
    "RPAD",
    "RTRIM",
    "SCHEMA",
    "SEC_TO_TIME",
    "SECOND",
    "SESSION_USER",
    "SHA1",
    "SHA2",
    "SIGN",
    "SIN",
    "SLEEP",
    "SOUNDEX",
    "SOUNDS LIKE",
    "SOURCE_POS_WAIT",
    "SPACE",
    "SQRT",
    "ST_AREA",
    "ST_ASBINARY",
    "ST_ASGEOJSON",
    "ST_ASTEXT",
    "ST_BUFFER",
    "ST_BUFFER_STRATEGY",
    "ST_CENTROID",
    "ST_COLLECT",
    "ST_CONTAINS",
    "ST_CONVEXHULL",
    "ST_CROSSES",
    "ST_DIFFERENCE",
    "ST_DIMENSION",
    "ST_DISJOINT",
    "ST_DISTANCE",
    "ST_DISTANCE_SPHERE",
    "ST_ENDPOINT",
    "ST_ENVELOPE",
    "ST_EQUALS",
    "ST_EXTERIORRING",
    "ST_FRECHETDISTANCE",
    "ST_GEOHASH",
    "ST_GEOMCOLLFROMTEXT",
    "ST_GEOMCOLLFROMWKB",
    "ST_GEOMETRYN",
    "ST_GEOMETRYTYPE",
    "ST_GEOMFROMGEOJSON",
    "ST_GEOMFROMTEXT",
    "ST_GEOMFROMWKB",
    "ST_HAUSDORFFDISTANCE",
    "ST_INTERIORRINGN",
    "ST_INTERSECTION",
    "ST_INTERSECTS",
    "ST_ISCLOSED",
    "ST_ISEMPTY",
    "ST_ISSIMPLE",
    "ST_ISVALID",
    "ST_LATFROMGEOHASH",
    "ST_LATITUDE",
    "ST_LENGTH",
    "ST_LINEFROMTEXT",
    "ST_LINEFROMWKB",
    "ST_LINEINTERPOLATEPOINT",
    "ST_LINEINTERPOLATEPOINTS",
    "ST_LONGFROMGEOHASH",
    "ST_LONGITUDE",
    "ST_MAKEENVELOPE",
    "ST_MLINEFROMTEXT",
    "ST_MLINEFROMWKB",
    "ST_MPOINTFROMTEXT",
    "ST_MPOINTFROMWKB",
    "ST_MPOLYFROMTEXT",
    "ST_MPOLYFROMWKB",
    "ST_NUMGEOMETRIES",
    "ST_NUMINTERIORRING",
    "ST_NUMPOINTS",
    "ST_OVERLAPS",
    "ST_POINTATDISTANCE",
    "ST_POINTFROMGEOHASH",
    "ST_POINTFROMTEXT",
    "ST_POINTFROMWKB",
    "ST_POINTN",
    "ST_POLYFROMTEXT",
    "ST_POLYFROMWKB",
    "ST_SIMPLIFY",
    "ST_SRID",
    "ST_STARTPOINT",
    "ST_SWAPXY",
    "ST_SYMDIFFERENCE",
    "ST_TOUCHES",
    "ST_TRANSFORM",
    "ST_UNION",
    "ST_VALIDATE",
    "ST_WITHIN",
    "ST_X",
    "ST_Y",
    "STATEMENT_DIGEST",
    "STATEMENT_DIGEST_TEXT",
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DATE",
    "STRCMP",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "SUBTIME",
    "SUM",
    "SYSDATE",
    "SYSTEM_USER",
    "TAN",
    "TIME",
    "TIME_FORMAT",
    "TIME_TO_SEC",
    "TIMEDIFF",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TO_BASE64",
    "TO_DAYS",
    "TO_SECONDS",
    "TRIM",
    "TRUNCATE",
    "UCASE",
    "UNCOMPRESS",
    "UNCOMPRESSED_LENGTH",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "USER",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "UUID",
    "UUID_SHORT",
    "UUID_TO_BIN",
    "VALIDATE_PASSWORD_STRENGTH",
    "VALUES",
    "VAR_POP",
    "VAR_SAMP",
    "VARIANCE",
    "VERSION",
    "WAIT_FOR_EXECUTED_GTID_SET",
    "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS",
    "WEEK",
    "WEEKDAY",
    "WEEKOFYEAR",
    "WEIGHT_STRING",
    // 'XOR',
    "YEAR",
    "YEARWEEK",
    // Data types with parameters
    // https://dev.mysql.com/doc/refman/8.0/en/data-types.html
    "BIT",
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "DATETIME",
    "TIMESTAMP",
    "TIME",
    "YEAR",
    "CHAR",
    "NATIONAL CHAR",
    "VARCHAR",
    "NATIONAL VARCHAR",
    "BINARY",
    "VARBINARY",
    "BLOB",
    "TEXT",
    "ENUM"
    // 'SET' // handled as special-case in postProcess
  ]
}), cke = ie(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), fke = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY] TABLE [IF NOT EXISTS]"
]), PB = ie([
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "{CHANGE | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [TO | AS]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html
  "ALTER DATABASE",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER INSTANCE",
  "ALTER LOGFILE GROUP",
  "ALTER PROCEDURE",
  "ALTER RESOURCE GROUP",
  "ALTER SERVER",
  "ALTER TABLESPACE",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE LOGFILE GROUP",
  "CREATE PROCEDURE",
  "CREATE RESOURCE GROUP",
  "CREATE ROLE",
  "CREATE SERVER",
  "CREATE SPATIAL REFERENCE SYSTEM",
  "CREATE TABLESPACE",
  "CREATE TRIGGER",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LOGFILE GROUP",
  "DROP PROCEDURE",
  "DROP RESOURCE GROUP",
  "DROP ROLE",
  "DROP SERVER",
  "DROP SPATIAL REFERENCE SYSTEM",
  "DROP TABLESPACE",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GRANT",
  "HANDLER",
  "HELP",
  "IMPORT TABLE",
  "INSTALL COMPONENT",
  "INSTALL PLUGIN",
  "KILL",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP REPLICA",
  "STOP SLAVE",
  "TABLE",
  "UNINSTALL COMPONENT",
  "UNINSTALL PLUGIN",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  // 'IF',
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]), dke = ie(["UNION [ALL | DISTINCT]"]), pke = ie([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), gke = ie(["ON {UPDATE | DELETE} [SET NULL]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), vke = {
  tokenizerOptions: {
    reservedSelect: cke,
    reservedClauses: [...fke, ...PB],
    reservedSetOperations: dke,
    reservedJoins: pke,
    reservedPhrases: gke,
    supportsXor: !0,
    reservedKeywords: uke,
    reservedFunctionNames: hke,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: ['""-qq-bs', {
      quote: "''-qq-bs",
      prefixes: ["N"]
    }, {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_.$]+"
    }, {
      quote: '""-qq-bs',
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "''-qq-bs",
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    paramTypes: {
      positional: !0
    },
    lineCommentTypes: ["--", "#"],
    operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "->", "->>", "&&", "||", "!"],
    postProcess: Oke
  },
  formatOptions: {
    onelineClauses: PB
  }
};
function Oke(r) {
  return r.map((e, t) => {
    const i = r[t + 1] || hh;
    return ml.SET(e) && i.text === "(" ? {
      ...e,
      type: te.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const mke = Ct({
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/functions.html
  all: [
    "ABORT",
    "ABS",
    "ACOS",
    "ADVISOR",
    "ARRAY_AGG",
    "ARRAY_AGG",
    "ARRAY_APPEND",
    "ARRAY_AVG",
    "ARRAY_BINARY_SEARCH",
    "ARRAY_CONCAT",
    "ARRAY_CONTAINS",
    "ARRAY_COUNT",
    "ARRAY_DISTINCT",
    "ARRAY_EXCEPT",
    "ARRAY_FLATTEN",
    "ARRAY_IFNULL",
    "ARRAY_INSERT",
    "ARRAY_INTERSECT",
    "ARRAY_LENGTH",
    "ARRAY_MAX",
    "ARRAY_MIN",
    "ARRAY_MOVE",
    "ARRAY_POSITION",
    "ARRAY_PREPEND",
    "ARRAY_PUT",
    "ARRAY_RANGE",
    "ARRAY_REMOVE",
    "ARRAY_REPEAT",
    "ARRAY_REPLACE",
    "ARRAY_REVERSE",
    "ARRAY_SORT",
    "ARRAY_STAR",
    "ARRAY_SUM",
    "ARRAY_SYMDIFF",
    "ARRAY_SYMDIFF1",
    "ARRAY_SYMDIFFN",
    "ARRAY_UNION",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BASE64",
    "BASE64_DECODE",
    "BASE64_ENCODE",
    "BITAND ",
    "BITCLEAR ",
    "BITNOT ",
    "BITOR ",
    "BITSET ",
    "BITSHIFT ",
    "BITTEST ",
    "BITXOR ",
    "CEIL",
    "CLOCK_LOCAL",
    "CLOCK_MILLIS",
    "CLOCK_STR",
    "CLOCK_TZ",
    "CLOCK_UTC",
    "COALESCE",
    "CONCAT",
    "CONCAT2",
    "CONTAINS",
    "CONTAINS_TOKEN",
    "CONTAINS_TOKEN_LIKE",
    "CONTAINS_TOKEN_REGEXP",
    "COS",
    "COUNT",
    "COUNT",
    "COUNTN",
    "CUME_DIST",
    "CURL",
    "DATE_ADD_MILLIS",
    "DATE_ADD_STR",
    "DATE_DIFF_MILLIS",
    "DATE_DIFF_STR",
    "DATE_FORMAT_STR",
    "DATE_PART_MILLIS",
    "DATE_PART_STR",
    "DATE_RANGE_MILLIS",
    "DATE_RANGE_STR",
    "DATE_TRUNC_MILLIS",
    "DATE_TRUNC_STR",
    "DECODE",
    "DECODE_JSON",
    "DEGREES",
    "DENSE_RANK",
    "DURATION_TO_STR",
    // 'E',
    "ENCODED_SIZE",
    "ENCODE_JSON",
    "EXP",
    "FIRST_VALUE",
    "FLOOR",
    "GREATEST",
    "HAS_TOKEN",
    "IFINF",
    "IFMISSING",
    "IFMISSINGORNULL",
    "IFNAN",
    "IFNANORINF",
    "IFNULL",
    "INITCAP",
    "ISARRAY",
    "ISATOM",
    "ISBITSET",
    "ISBOOLEAN",
    "ISNUMBER",
    "ISOBJECT",
    "ISSTRING",
    "LAG",
    "LAST_VALUE",
    "LEAD",
    "LEAST",
    "LENGTH",
    "LN",
    "LOG",
    "LOWER",
    "LTRIM",
    "MAX",
    "MEAN",
    "MEDIAN",
    "META",
    "MILLIS",
    "MILLIS_TO_LOCAL",
    "MILLIS_TO_STR",
    "MILLIS_TO_TZ",
    "MILLIS_TO_UTC",
    "MILLIS_TO_ZONE_NAME",
    "MIN",
    "MISSINGIF",
    "NANIF",
    "NEGINFIF",
    "NOW_LOCAL",
    "NOW_MILLIS",
    "NOW_STR",
    "NOW_TZ",
    "NOW_UTC",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "NVL",
    "NVL2",
    "OBJECT_ADD",
    "OBJECT_CONCAT",
    "OBJECT_INNER_PAIRS",
    "OBJECT_INNER_VALUES",
    "OBJECT_LENGTH",
    "OBJECT_NAMES",
    "OBJECT_PAIRS",
    "OBJECT_PUT",
    "OBJECT_REMOVE",
    "OBJECT_RENAME",
    "OBJECT_REPLACE",
    "OBJECT_UNWRAP",
    "OBJECT_VALUES",
    "PAIRS",
    "PERCENT_RANK",
    "PI",
    "POLY_LENGTH",
    "POSINFIF",
    "POSITION",
    "POWER",
    "RADIANS",
    "RANDOM",
    "RANK",
    "RATIO_TO_REPORT",
    "REGEXP_CONTAINS",
    "REGEXP_LIKE",
    "REGEXP_MATCHES",
    "REGEXP_POSITION",
    "REGEXP_REPLACE",
    "REGEXP_SPLIT",
    "REGEX_CONTAINS",
    "REGEX_LIKE",
    "REGEX_MATCHES",
    "REGEX_POSITION",
    "REGEX_REPLACE",
    "REGEX_SPLIT",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "ROUND",
    "ROW_NUMBER",
    "RTRIM",
    "SEARCH",
    "SEARCH_META",
    "SEARCH_SCORE",
    "SIGN",
    "SIN",
    "SPLIT",
    "SQRT",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DURATION",
    "STR_TO_MILLIS",
    "STR_TO_TZ",
    "STR_TO_UTC",
    "STR_TO_ZONE_NAME",
    "SUBSTR",
    "SUFFIXES",
    "SUM",
    "TAN",
    "TITLE",
    "TOARRAY",
    "TOATOM",
    "TOBOOLEAN",
    "TOKENS",
    "TOKENS",
    "TONUMBER",
    "TOOBJECT",
    "TOSTRING",
    "TRIM",
    "TRUNC",
    // 'TYPE', // disabled
    "UPPER",
    "UUID",
    "VARIANCE",
    "VARIANCE_POP",
    "VARIANCE_SAMP",
    "VAR_POP",
    "VAR_SAMP",
    "WEEKDAY_MILLIS",
    "WEEKDAY_STR",
    // type casting
    // not implemented in N1QL, but added here now for the sake of tests
    // https://docs.couchbase.com/server/current/analytics/3_query.html#Vs_SQL-92
    "CAST"
  ]
}), Eke = Ct({
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  all: ["ADVISE", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "BEGIN", "BETWEEN", "BINARY", "BOOLEAN", "BREAK", "BUCKET", "BUILD", "BY", "CALL", "CASE", "CAST", "CLUSTER", "COLLATE", "COLLECTION", "COMMIT", "COMMITTED", "CONNECT", "CONTINUE", "CORRELATED", "COVER", "CREATE", "CURRENT", "DATABASE", "DATASET", "DATASTORE", "DECLARE", "DECREMENT", "DELETE", "DERIVED", "DESC", "DESCRIBE", "DISTINCT", "DO", "DROP", "EACH", "ELEMENT", "ELSE", "END", "EVERY", "EXCEPT", "EXCLUDE", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FILTER", "FIRST", "FLATTEN", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FROM", "FTS", "FUNCTION", "GOLANG", "GRANT", "GROUP", "GROUPS", "GSI", "HASH", "HAVING", "IF", "ISOLATION", "IGNORE", "ILIKE", "IN", "INCLUDE", "INCREMENT", "INDEX", "INFER", "INLINE", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JAVASCRIPT", "JOIN", "KEY", "KEYS", "KEYSPACE", "KNOWN", "LANGUAGE", "LAST", "LEFT", "LET", "LETTING", "LEVEL", "LIKE", "LIMIT", "LSM", "MAP", "MAPPING", "MATCHED", "MATERIALIZED", "MERGE", "MINUS", "MISSING", "NAMESPACE", "NEST", "NL", "NO", "NOT", "NTH_VALUE", "NULL", "NULLS", "NUMBER", "OBJECT", "OFFSET", "ON", "OPTION", "OPTIONS", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARSE", "PARTITION", "PASSWORD", "PATH", "POOL", "PRECEDING", "PREPARE", "PRIMARY", "PRIVATE", "PRIVILEGE", "PROBE", "PROCEDURE", "PUBLIC", "RANGE", "RAW", "REALM", "REDUCE", "RENAME", "RESPECT", "RETURN", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROW", "ROWS", "SATISFIES", "SAVEPOINT", "SCHEMA", "SCOPE", "SELECT", "SELF", "SEMI", "SET", "SHOW", "SOME", "START", "STATISTICS", "STRING", "SYSTEM", "THEN", "TIES", "TO", "TRAN", "TRANSACTION", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNKNOWN", "UNNEST", "UNSET", "UPDATE", "UPSERT", "USE", "USER", "USING", "VALIDATE", "VALUE", "VALUED", "VALUES", "VIA", "VIEW", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WITHIN", "WORK", "XOR"]
}), bke = ie(["SELECT [ALL | DISTINCT]"]), Ske = ie([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED THEN",
  "UPDATE SET",
  "INSERT",
  // other
  "NEST",
  "UNNEST",
  "RETURNING"
]), NB = ie([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - set schema:
  "SET SCHEMA",
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  "ADVISE",
  "ALTER INDEX",
  "BEGIN TRANSACTION",
  "BUILD INDEX",
  "COMMIT TRANSACTION",
  "CREATE COLLECTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PRIMARY INDEX",
  "CREATE SCOPE",
  "DROP COLLECTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PRIMARY INDEX",
  "DROP SCOPE",
  "EXECUTE",
  "EXECUTE FUNCTION",
  "EXPLAIN",
  "GRANT",
  "INFER",
  "PREPARE",
  "REVOKE",
  "ROLLBACK TRANSACTION",
  "SAVEPOINT",
  "SET TRANSACTION",
  "UPDATE STATISTICS",
  "UPSERT",
  // other
  "LET",
  "SET CURRENT SCHEMA",
  "SHOW",
  "USE [PRIMARY] KEYS"
]), Tke = ie(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]), yke = ie(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "INNER JOIN"]), Rke = ie(["{ROWS | RANGE | GROUPS} BETWEEN"]), Ake = {
  tokenizerOptions: {
    reservedSelect: bke,
    reservedClauses: [...Ske, ...NB],
    reservedSetOperations: Tke,
    reservedJoins: yke,
    reservedPhrases: Rke,
    supportsXor: !0,
    reservedKeywords: Eke,
    reservedFunctionNames: mke,
    // NOTE: single quotes are actually not supported in N1QL,
    // but we support them anyway as all other SQL dialects do,
    // which simplifies writing tests that are shared between all dialects.
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    extraParens: ["[]", "{}"],
    paramTypes: {
      positional: !0,
      numbered: ["$"],
      named: ["$"]
    },
    lineCommentTypes: ["#", "--"],
    operators: ["%", "==", ":", "||"]
  },
  formatOptions: {
    onelineClauses: NB
  }
}, Cke = Ct({
  // https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/reservewords.htm
  all: [
    // 'A',
    "ADD",
    "AGENT",
    "AGGREGATE",
    "ALL",
    "ALTER",
    "AND",
    "ANY",
    "ARRAY",
    "ARROW",
    "AS",
    "ASC",
    "AT",
    "ATTRIBUTE",
    "AUTHID",
    "AVG",
    "BEGIN",
    "BETWEEN",
    "BFILE_BASE",
    "BINARY",
    "BLOB_BASE",
    "BLOCK",
    "BODY",
    "BOTH",
    "BOUND",
    "BULK",
    "BY",
    "BYTE",
    // 'C',
    "CALL",
    "CALLING",
    "CASCADE",
    "CASE",
    "CHAR",
    "CHAR_BASE",
    "CHARACTER",
    "CHARSET",
    "CHARSETFORM",
    "CHARSETID",
    "CHECK",
    "CLOB_BASE",
    "CLOSE",
    "CLUSTER",
    "CLUSTERS",
    "COLAUTH",
    "COLLECT",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPILED",
    "COMPRESS",
    "CONNECT",
    "CONSTANT",
    "CONSTRUCTOR",
    "CONTEXT",
    "CONVERT",
    "COUNT",
    "CRASH",
    "CREATE",
    "CURRENT",
    "CURSOR",
    "CUSTOMDATUM",
    "DANGLING",
    "DATA",
    "DATE",
    "DATE_BASE",
    "DAY",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFINE",
    "DELETE",
    "DESC",
    "DETERMINISTIC",
    "DISTINCT",
    "DOUBLE",
    "DROP",
    "DURATION",
    "ELEMENT",
    "ELSE",
    "ELSIF",
    "EMPTY",
    "END",
    "ESCAPE",
    "EXCEPT",
    "EXCEPTION",
    "EXCEPTIONS",
    "EXCLUSIVE",
    "EXECUTE",
    "EXISTS",
    "EXIT",
    "EXTERNAL",
    "FETCH",
    "FINAL",
    "FIXED",
    "FLOAT",
    "FOR",
    "FORALL",
    "FORCE",
    "FORM",
    "FROM",
    "FUNCTION",
    "GENERAL",
    "GOTO",
    "GRANT",
    "GROUP",
    "HASH",
    "HAVING",
    "HEAP",
    "HIDDEN",
    "HOUR",
    "IDENTIFIED",
    "IF",
    "IMMEDIATE",
    "IN",
    "INCLUDING",
    "INDEX",
    "INDEXES",
    "INDICATOR",
    "INDICES",
    "INFINITE",
    "INSERT",
    "INSTANTIABLE",
    "INT",
    "INTERFACE",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "INVALIDATE",
    "IS",
    "ISOLATION",
    "JAVA",
    "LANGUAGE",
    "LARGE",
    "LEADING",
    "LENGTH",
    "LEVEL",
    "LIBRARY",
    "LIKE",
    "LIKE2",
    "LIKE4",
    "LIKEC",
    "LIMIT",
    "LIMITED",
    "LOCAL",
    "LOCK",
    "LONG",
    "LOOP",
    "MAP",
    "MAX",
    "MAXLEN",
    "MEMBER",
    "MERGE",
    "MIN",
    "MINUS",
    "MINUTE",
    "MOD",
    "MODE",
    "MODIFY",
    "MONTH",
    "MULTISET",
    "NAME",
    "NAN",
    "NATIONAL",
    "NATIVE",
    "NCHAR",
    "NEW",
    "NOCOMPRESS",
    "NOCOPY",
    "NOT",
    "NOWAIT",
    "NULL",
    "NUMBER_BASE",
    "OBJECT",
    "OCICOLL",
    "OCIDATE",
    "OCIDATETIME",
    "OCIDURATION",
    "OCIINTERVAL",
    "OCILOBLOCATOR",
    "OCINUMBER",
    "OCIRAW",
    "OCIREF",
    "OCIREFCURSOR",
    "OCIROWID",
    "OCISTRING",
    "OCITYPE",
    "OF",
    "ON",
    "ONLY",
    "OPAQUE",
    "OPEN",
    "OPERATOR",
    "OPTION",
    "OR",
    "ORACLE",
    "ORADATA",
    "ORDER",
    "OVERLAPS",
    "ORGANIZATION",
    "ORLANY",
    "ORLVARY",
    "OTHERS",
    "OUT",
    "OVERRIDING",
    "PACKAGE",
    "PARALLEL_ENABLE",
    "PARAMETER",
    "PARAMETERS",
    "PARTITION",
    "PASCAL",
    "PIPE",
    "PIPELINED",
    "PRAGMA",
    "PRECISION",
    "PRIOR",
    "PRIVATE",
    "PROCEDURE",
    "PUBLIC",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "RECORD",
    "REF",
    "REFERENCE",
    "REM",
    "REMAINDER",
    "RENAME",
    "RESOURCE",
    "RESULT",
    "RETURN",
    "RETURNING",
    "REVERSE",
    "REVOKE",
    "ROLLBACK",
    "ROW",
    "SAMPLE",
    "SAVE",
    "SAVEPOINT",
    "SB1",
    "SB2",
    "SB4",
    "SECOND",
    "SEGMENT",
    "SELECT",
    "SELF",
    "SEPARATE",
    "SEQUENCE",
    "SERIALIZABLE",
    "SET",
    "SHARE",
    "SHORT",
    "SIZE",
    "SIZE_T",
    "SOME",
    "SPARSE",
    "SQL",
    "SQLCODE",
    "SQLDATA",
    "SQLNAME",
    "SQLSTATE",
    "STANDARD",
    "START",
    "STATIC",
    "STDDEV",
    "STORED",
    "STRING",
    "STRUCT",
    "STYLE",
    "SUBMULTISET",
    "SUBPARTITION",
    "SUBSTITUTABLE",
    "SUBTYPE",
    "SUM",
    "SYNONYM",
    "TABAUTH",
    "TABLE",
    "TDO",
    "THE",
    "THEN",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_ABBR",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TIMEZONE_REGION",
    "TO",
    "TRAILING",
    "TRANSAC",
    "TRANSACTIONAL",
    "TRUSTED",
    "TYPE",
    "UB1",
    "UB2",
    "UB4",
    "UNDER",
    "UNION",
    "UNIQUE",
    "UNSIGNED",
    "UNTRUSTED",
    "UPDATE",
    "USE",
    "USING",
    "VALIST",
    "VALUE",
    "VALUES",
    "VARIABLE",
    "VARIANCE",
    "VARRAY",
    "VARYING",
    "VIEW",
    "VIEWS",
    "VOID",
    "WHEN",
    "WHERE",
    "WHILE",
    "WITH",
    "WORK",
    "WRAPPED",
    "WRITE",
    "YEAR",
    "ZONE"
  ]
}), _ke = Ct({
  // https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions001.htm
  numeric: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "BITAND", "CEIL", "COS", "COSH", "EXP", "FLOOR", "LN", "LOG", "MOD", "NANVL", "POWER", "REMAINDER", "ROUND", "SIGN", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC", "WIDTH_BUCKET"],
  character: ["CHR", "CONCAT", "INITCAP", "LOWER", "LPAD", "LTRIM", "NLS_INITCAP", "NLS_LOWER", "NLSSORT", "NLS_UPPER", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "RPAD", "RTRIM", "SOUNDEX", "SUBSTR", "TRANSLATE", "TREAT", "TRIM", "UPPER", "NLS_CHARSET_DECL_LEN", "NLS_CHARSET_ID", "NLS_CHARSET_NAME", "ASCII", "INSTR", "LENGTH", "REGEXP_INSTR"],
  datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_TIMESTAMP", "DBTIMEZONE", "EXTRACT", "FROM_TZ", "LAST_DAY", "LOCALTIMESTAMP", "MONTHS_BETWEEN", "NEW_TIME", "NEXT_DAY", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "ROUND", "SESSIONTIMEZONE", "SYS_EXTRACT_UTC", "SYSDATE", "SYSTIMESTAMP", "TO_CHAR", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_DSINTERVAL", "TO_YMINTERVAL", "TRUNC", "TZ_OFFSET"],
  comparison: ["GREATEST", "LEAST"],
  conversion: ["ASCIISTR", "BIN_TO_NUM", "CAST", "CHARTOROWID", "COMPOSE", "CONVERT", "DECOMPOSE", "HEXTORAW", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "RAWTOHEX", "RAWTONHEX", "ROWIDTOCHAR", "ROWIDTONCHAR", "SCN_TO_TIMESTAMP", "TIMESTAMP_TO_SCN", "TO_BINARY_DOUBLE", "TO_BINARY_FLOAT", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_DSINTERVAL", "TO_LOB", "TO_MULTI_BYTE", "TO_NCHAR", "TO_NCLOB", "TO_NUMBER", "TO_DSINTERVAL", "TO_SINGLE_BYTE", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_YMINTERVAL", "TO_YMINTERVAL", "TRANSLATE", "UNISTR"],
  largeObject: ["BFILENAME", "EMPTY_BLOB,", "EMPTY_CLOB"],
  collection: ["CARDINALITY", "COLLECT", "POWERMULTISET", "POWERMULTISET_BY_CARDINALITY", "SET"],
  hierarchical: ["SYS_CONNECT_BY_PATH"],
  dataMining: ["CLUSTER_ID", "CLUSTER_PROBABILITY", "CLUSTER_SET", "FEATURE_ID", "FEATURE_SET", "FEATURE_VALUE", "PREDICTION", "PREDICTION_COST", "PREDICTION_DETAILS", "PREDICTION_PROBABILITY", "PREDICTION_SET"],
  xml: ["APPENDCHILDXML", "DELETEXML", "DEPTH", "EXTRACT", "EXISTSNODE", "EXTRACTVALUE", "INSERTCHILDXML", "INSERTXMLBEFORE", "PATH", "SYS_DBURIGEN", "SYS_XMLAGG", "SYS_XMLGEN", "UPDATEXML", "XMLAGG", "XMLCDATA", "XMLCOLATTVAL", "XMLCOMMENT", "XMLCONCAT", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", "XMLSEQUENCE", "XMLSERIALIZE", "XMLTABLE", "XMLTRANSFORM"],
  encoding: ["DECODE", "DUMP", "ORA_HASH", "VSIZE"],
  nullRelated: ["COALESCE", "LNNVL", "NULLIF", "NVL", "NVL2"],
  env: ["SYS_CONTEXT", "SYS_GUID", "SYS_TYPEID", "UID", "USER", "USERENV"],
  aggregate: ["AVG", "COLLECT", "CORR", "CORR_S", "CORR_K", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "DENSE_RANK", "FIRST", "GROUP_ID", "GROUPING", "GROUPING_ID", "LAST", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "RANK", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT", "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY", "REGR_SXY", "STATS_BINOMIAL_TEST", "STATS_CROSSTAB", "STATS_F_TEST", "STATS_KS_TEST", "STATS_MODE", "STATS_MW_TEST", "STATS_ONE_WAY_ANOVA", "STATS_T_TEST_ONE", "STATS_T_TEST_PAIRED", "STATS_T_TEST_INDEP", "STATS_T_TEST_INDEPU", "STATS_WSR_TEST", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  // Windowing functions (minus the ones already listed in aggregates)
  window: ["FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTILE", "RATIO_TO_REPORT", "ROW_NUMBER"],
  objectReference: ["DEREF", "MAKE_REF", "REF", "REFTOHEX", "VALUE"],
  model: ["CV", "ITERATION_NUMBER", "PRESENTNNV", "PRESENTV", "PREVIOUS"],
  // Parameterized data types
  // https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html
  dataTypes: [
    // Oracle builtin data types
    "VARCHAR2",
    "NVARCHAR2",
    "NUMBER",
    "FLOAT",
    "TIMESTAMP",
    "INTERVAL YEAR",
    "INTERVAL DAY",
    "RAW",
    "UROWID",
    "NCHAR",
    // ANSI Data Types
    "CHARACTER",
    "CHAR",
    "CHARACTER VARYING",
    "CHAR VARYING",
    "NATIONAL CHARACTER",
    "NATIONAL CHAR",
    "NATIONAL CHARACTER VARYING",
    "NATIONAL CHAR VARYING",
    "NCHAR VARYING",
    "NUMERIC",
    "DECIMAL",
    "FLOAT",
    // SQL/DS and DB2 Data Types
    "VARCHAR"
  ]
}), Ike = ie(["SELECT [ALL | DISTINCT | UNIQUE]"]), xke = ie([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER [SIBLINGS] BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR UPDATE [OF]",
  // Data manipulation
  // - insert:
  "INSERT [INTO | ALL INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  // Data definition
  "CREATE [OR REPLACE] [NO FORCE | FORCE] [EDITIONING | EDITIONABLE | EDITIONABLE EDITIONING | NONEDITIONABLE] VIEW",
  "CREATE MATERIALIZED VIEW",
  "CREATE [GLOBAL TEMPORARY | PRIVATE TEMPORARY | SHARDED | DUPLICATED | IMMUTABLE BLOCKCHAIN | BLOCKCHAIN | IMMUTABLE] TABLE",
  // other
  "RETURNING"
]), LB = ie([
  // - update:
  "UPDATE [ONLY]",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP {COLUMN | UNUSED COLUMNS | COLUMNS CONTINUE}",
  "MODIFY",
  "RENAME TO",
  "RENAME COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA",
  "BEGIN",
  "CONNECT BY",
  "DECLARE",
  "EXCEPT",
  "EXCEPTION",
  "LOOP",
  "START WITH"
]), wke = ie(["UNION [ALL]", "EXCEPT", "INTERSECT"]), Pke = ie([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]), Nke = ie(["ON {UPDATE | DELETE} [SET NULL]", "ON COMMIT", "{ROWS | RANGE} BETWEEN"]), Lke = {
  tokenizerOptions: {
    reservedSelect: Ike,
    reservedClauses: [...xke, ...LB],
    reservedSetOperations: wke,
    reservedJoins: Pke,
    reservedPhrases: Nke,
    supportsXor: !0,
    reservedKeywords: Cke,
    reservedFunctionNames: _ke,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["N"]
    }, {
      quote: "q''",
      prefixes: ["N"]
    }],
    // PL/SQL doesn't actually support escaping of quotes in identifiers,
    // but for the sake of simpler testing we'll support this anyway
    // as all other SQL dialects with "identifiers" do.
    identTypes: ['""-qq'],
    identChars: {
      rest: "$#"
    },
    variableTypes: [{
      regex: "&{1,2}[A-Za-z][A-Za-z0-9_$#]*"
    }],
    paramTypes: {
      numbered: [":"],
      named: [":"]
    },
    paramChars: {},
    // Empty object used on purpose to not allow $ and # chars as specified in identChars
    operators: [
      "**",
      ":=",
      "%",
      "~=",
      "^=",
      // '..', // Conflicts with float followed by dot (so "2..3" gets parsed as ["2.", ".", "3"])
      ">>",
      "<<",
      "=>",
      "@",
      "||"
    ],
    postProcess: Dke
  },
  formatOptions: {
    alwaysDenseOperators: ["@"],
    onelineClauses: LB
  }
};
function Dke(r) {
  let e = hh;
  return r.map((t) => ml.SET(t) && ml.BY(e) ? {
    ...t,
    type: te.RESERVED_KEYWORD
  } : (Z9(t.type) && (e = t), t));
}
const Mke = Ct({
  // https://www.postgresql.org/docs/14/functions.html
  //
  // https://www.postgresql.org/docs/14/functions-math.html
  math: ["ABS", "ACOS", "ACOSD", "ACOSH", "ASIN", "ASIND", "ASINH", "ATAN", "ATAN2", "ATAN2D", "ATAND", "ATANH", "CBRT", "CEIL", "CEILING", "COS", "COSD", "COSH", "COT", "COTD", "DEGREES", "DIV", "EXP", "FACTORIAL", "FLOOR", "GCD", "LCM", "LN", "LOG", "LOG10", "MIN_SCALE", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SCALE", "SETSEED", "SIGN", "SIN", "SIND", "SINH", "SQRT", "TAN", "TAND", "TANH", "TRIM_SCALE", "TRUNC", "WIDTH_BUCKET"],
  // https://www.postgresql.org/docs/14/functions-string.html
  string: ["ABS", "ASCII", "BIT_LENGTH", "BTRIM", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "FORMAT", "INITCAP", "LEFT", "LENGTH", "LOWER", "LPAD", "LTRIM", "MD5", "NORMALIZE", "OCTET_LENGTH", "OVERLAY", "PARSE_IDENT", "PG_CLIENT_ENCODING", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "QUOTE_NULLABLE", "REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SPLIT_PART", "SPRINTF", "STARTS_WITH", "STRING_AGG", "STRING_TO_ARRAY", "STRING_TO_TABLE", "STRPOS", "SUBSTR", "SUBSTRING", "TO_ASCII", "TO_HEX", "TRANSLATE", "TRIM", "UNISTR", "UPPER"],
  // https://www.postgresql.org/docs/14/functions-binarystring.html
  binary: ["BIT_COUNT", "BIT_LENGTH", "BTRIM", "CONVERT", "CONVERT_FROM", "CONVERT_TO", "DECODE", "ENCODE", "GET_BIT", "GET_BYTE", "LENGTH", "LTRIM", "MD5", "OCTET_LENGTH", "OVERLAY", "POSITION", "RTRIM", "SET_BIT", "SET_BYTE", "SHA224", "SHA256", "SHA384", "SHA512", "STRING_AGG", "SUBSTR", "SUBSTRING", "TRIM"],
  // https://www.postgresql.org/docs/14/functions-bitstring.html
  bitstring: ["BIT_COUNT", "BIT_LENGTH", "GET_BIT", "LENGTH", "OCTET_LENGTH", "OVERLAY", "POSITION", "SET_BIT", "SUBSTRING"],
  // https://www.postgresql.org/docs/14/functions-matching.html
  pattern: ["REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE"],
  // https://www.postgresql.org/docs/14/functions-formatting.html
  datatype: ["TO_CHAR", "TO_DATE", "TO_NUMBER", "TO_TIMESTAMP"],
  // https://www.postgresql.org/docs/14/functions-datetime.html
  datetime: [
    // 'AGE',
    "CLOCK_TIMESTAMP",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "DATE_BIN",
    "DATE_PART",
    "DATE_TRUNC",
    "EXTRACT",
    "ISFINITE",
    "JUSTIFY_DAYS",
    "JUSTIFY_HOURS",
    "JUSTIFY_INTERVAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "MAKE_DATE",
    "MAKE_INTERVAL",
    "MAKE_TIME",
    "MAKE_TIMESTAMP",
    "MAKE_TIMESTAMPTZ",
    "NOW",
    "PG_SLEEP",
    "PG_SLEEP_FOR",
    "PG_SLEEP_UNTIL",
    "STATEMENT_TIMESTAMP",
    "TIMEOFDAY",
    "TO_TIMESTAMP",
    "TRANSACTION_TIMESTAMP"
  ],
  // https://www.postgresql.org/docs/14/functions-enum.html
  enum: ["ENUM_FIRST", "ENUM_LAST", "ENUM_RANGE"],
  // https://www.postgresql.org/docs/14/functions-geometry.html
  geometry: ["AREA", "BOUND_BOX", "BOX", "CENTER", "CIRCLE", "DIAGONAL", "DIAMETER", "HEIGHT", "ISCLOSED", "ISOPEN", "LENGTH", "LINE", "LSEG", "NPOINTS", "PATH", "PCLOSE", "POINT", "POLYGON", "POPEN", "RADIUS", "SLOPE", "WIDTH"],
  // https://www.postgresql.org/docs/14/functions-net.html
  network: ["ABBREV", "BROADCAST", "FAMILY", "HOST", "HOSTMASK", "INET_MERGE", "INET_SAME_FAMILY", "MACADDR8_SET7BIT", "MASKLEN", "NETMASK", "NETWORK", "SET_MASKLEN", "TEXT", "TRUNC"],
  // https://www.postgresql.org/docs/14/functions-textsearch.html
  textsearch: ["ARRAY_TO_TSVECTOR", "GET_CURRENT_TS_CONFIG", "JSONB_TO_TSVECTOR", "JSON_TO_TSVECTOR", "LENGTH", "NUMNODE", "PHRASETO_TSQUERY", "PLAINTO_TSQUERY", "QUERYTREE", "SETWEIGHT", "STRIP", "TO_TSQUERY", "TO_TSVECTOR", "TSQUERY_PHRASE", "TSVECTOR_TO_ARRAY", "TS_DEBUG", "TS_DELETE", "TS_FILTER", "TS_HEADLINE", "TS_LEXIZE", "TS_PARSE", "TS_RANK", "TS_RANK_CD", "TS_REWRITE", "TS_STAT", "TS_TOKEN_TYPE", "WEBSEARCH_TO_TSQUERY"],
  // https://www.postgresql.org/docs/14/functions-uuid.html
  uuid: ["UUID"],
  // https://www.postgresql.org/docs/14/functions-xml.html
  xml: ["CURSOR_TO_XML", "CURSOR_TO_XMLSCHEMA", "DATABASE_TO_XML", "DATABASE_TO_XMLSCHEMA", "DATABASE_TO_XML_AND_XMLSCHEMA", "NEXTVAL", "QUERY_TO_XML", "QUERY_TO_XMLSCHEMA", "QUERY_TO_XML_AND_XMLSCHEMA", "SCHEMA_TO_XML", "SCHEMA_TO_XMLSCHEMA", "SCHEMA_TO_XML_AND_XMLSCHEMA", "STRING", "TABLE_TO_XML", "TABLE_TO_XMLSCHEMA", "TABLE_TO_XML_AND_XMLSCHEMA", "XMLAGG", "XMLCOMMENT", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE", "XML_IS_WELL_FORMED", "XML_IS_WELL_FORMED_CONTENT", "XML_IS_WELL_FORMED_DOCUMENT", "XPATH", "XPATH_EXISTS"],
  // https://www.postgresql.org/docs/14/functions-json.html
  json: ["ARRAY_TO_JSON", "JSONB_AGG", "JSONB_ARRAY_ELEMENTS", "JSONB_ARRAY_ELEMENTS_TEXT", "JSONB_ARRAY_LENGTH", "JSONB_BUILD_ARRAY", "JSONB_BUILD_OBJECT", "JSONB_EACH", "JSONB_EACH_TEXT", "JSONB_EXTRACT_PATH", "JSONB_EXTRACT_PATH_TEXT", "JSONB_INSERT", "JSONB_OBJECT", "JSONB_OBJECT_AGG", "JSONB_OBJECT_KEYS", "JSONB_PATH_EXISTS", "JSONB_PATH_EXISTS_TZ", "JSONB_PATH_MATCH", "JSONB_PATH_MATCH_TZ", "JSONB_PATH_QUERY", "JSONB_PATH_QUERY_ARRAY", "JSONB_PATH_QUERY_ARRAY_TZ", "JSONB_PATH_QUERY_FIRST", "JSONB_PATH_QUERY_FIRST_TZ", "JSONB_PATH_QUERY_TZ", "JSONB_POPULATE_RECORD", "JSONB_POPULATE_RECORDSET", "JSONB_PRETTY", "JSONB_SET", "JSONB_SET_LAX", "JSONB_STRIP_NULLS", "JSONB_TO_RECORD", "JSONB_TO_RECORDSET", "JSONB_TYPEOF", "JSON_AGG", "JSON_ARRAY_ELEMENTS", "JSON_ARRAY_ELEMENTS_TEXT", "JSON_ARRAY_LENGTH", "JSON_BUILD_ARRAY", "JSON_BUILD_OBJECT", "JSON_EACH", "JSON_EACH_TEXT", "JSON_EXTRACT_PATH", "JSON_EXTRACT_PATH_TEXT", "JSON_OBJECT", "JSON_OBJECT_AGG", "JSON_OBJECT_KEYS", "JSON_POPULATE_RECORD", "JSON_POPULATE_RECORDSET", "JSON_STRIP_NULLS", "JSON_TO_RECORD", "JSON_TO_RECORDSET", "JSON_TYPEOF", "ROW_TO_JSON", "TO_JSON", "TO_JSONB", "TO_TIMESTAMP"],
  // https://www.postgresql.org/docs/14/functions-sequence.html
  sequence: ["CURRVAL", "LASTVAL", "NEXTVAL", "SETVAL"],
  // https://www.postgresql.org/docs/14/functions-conditional.html
  conditional: [
    // 'CASE',
    "COALESCE",
    "GREATEST",
    "LEAST",
    "NULLIF"
  ],
  // https://www.postgresql.org/docs/14/functions-array.html
  array: ["ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_DIMS", "ARRAY_FILL", "ARRAY_LENGTH", "ARRAY_LOWER", "ARRAY_NDIMS", "ARRAY_POSITION", "ARRAY_POSITIONS", "ARRAY_PREPEND", "ARRAY_REMOVE", "ARRAY_REPLACE", "ARRAY_TO_STRING", "ARRAY_UPPER", "CARDINALITY", "STRING_TO_ARRAY", "TRIM_ARRAY", "UNNEST"],
  // https://www.postgresql.org/docs/14/functions-range.html
  range: ["ISEMPTY", "LOWER", "LOWER_INC", "LOWER_INF", "MULTIRANGE", "RANGE_MERGE", "UPPER", "UPPER_INC", "UPPER_INF"],
  // https://www.postgresql.org/docs/14/functions-aggregate.html
  aggregate: [
    // 'ANY',
    "ARRAY_AGG",
    "AVG",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "BOOL_AND",
    "BOOL_OR",
    "COALESCE",
    "CORR",
    "COUNT",
    "COVAR_POP",
    "COVAR_SAMP",
    "CUME_DIST",
    "DENSE_RANK",
    "EVERY",
    "GROUPING",
    "JSONB_AGG",
    "JSONB_OBJECT_AGG",
    "JSON_AGG",
    "JSON_OBJECT_AGG",
    "MAX",
    "MIN",
    "MODE",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "PERCENT_RANK",
    "RANGE_AGG",
    "RANGE_INTERSECT_AGG",
    "RANK",
    "REGR_AVGX",
    "REGR_AVGY",
    "REGR_COUNT",
    "REGR_INTERCEPT",
    "REGR_R2",
    "REGR_SLOPE",
    "REGR_SXX",
    "REGR_SXY",
    "REGR_SYY",
    // 'SOME',
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STRING_AGG",
    "SUM",
    "TO_JSON",
    "TO_JSONB",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "XMLAGG"
  ],
  // https://www.postgresql.org/docs/14/functions-window.html
  window: ["CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
  // https://www.postgresql.org/docs/14/functions-srf.html
  set: ["GENERATE_SERIES", "GENERATE_SUBSCRIPTS"],
  // https://www.postgresql.org/docs/14/functions-info.html
  sysInfo: ["ACLDEFAULT", "ACLEXPLODE", "COL_DESCRIPTION", "CURRENT_CATALOG", "CURRENT_DATABASE", "CURRENT_QUERY", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "FORMAT_TYPE", "HAS_ANY_COLUMN_PRIVILEGE", "HAS_COLUMN_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE", "HAS_FUNCTION_PRIVILEGE", "HAS_LANGUAGE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_SEQUENCE_PRIVILEGE", "HAS_SERVER_PRIVILEGE", "HAS_TABLESPACE_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "HAS_TYPE_PRIVILEGE", "INET_CLIENT_ADDR", "INET_CLIENT_PORT", "INET_SERVER_ADDR", "INET_SERVER_PORT", "MAKEACLITEM", "OBJ_DESCRIPTION", "PG_BACKEND_PID", "PG_BLOCKING_PIDS", "PG_COLLATION_IS_VISIBLE", "PG_CONF_LOAD_TIME", "PG_CONTROL_CHECKPOINT", "PG_CONTROL_INIT", "PG_CONTROL_SYSTEM", "PG_CONVERSION_IS_VISIBLE", "PG_CURRENT_LOGFILE", "PG_CURRENT_SNAPSHOT", "PG_CURRENT_XACT_ID", "PG_CURRENT_XACT_ID_IF_ASSIGNED", "PG_DESCRIBE_OBJECT", "PG_FUNCTION_IS_VISIBLE", "PG_GET_CATALOG_FOREIGN_KEYS", "PG_GET_CONSTRAINTDEF", "PG_GET_EXPR", "PG_GET_FUNCTIONDEF", "PG_GET_FUNCTION_ARGUMENTS", "PG_GET_FUNCTION_IDENTITY_ARGUMENTS", "PG_GET_FUNCTION_RESULT", "PG_GET_INDEXDEF", "PG_GET_KEYWORDS", "PG_GET_OBJECT_ADDRESS", "PG_GET_OWNED_SEQUENCE", "PG_GET_RULEDEF", "PG_GET_SERIAL_SEQUENCE", "PG_GET_STATISTICSOBJDEF", "PG_GET_TRIGGERDEF", "PG_GET_USERBYID", "PG_GET_VIEWDEF", "PG_HAS_ROLE", "PG_IDENTIFY_OBJECT", "PG_IDENTIFY_OBJECT_AS_ADDRESS", "PG_INDEXAM_HAS_PROPERTY", "PG_INDEX_COLUMN_HAS_PROPERTY", "PG_INDEX_HAS_PROPERTY", "PG_IS_OTHER_TEMP_SCHEMA", "PG_JIT_AVAILABLE", "PG_LAST_COMMITTED_XACT", "PG_LISTENING_CHANNELS", "PG_MY_TEMP_SCHEMA", "PG_NOTIFICATION_QUEUE_USAGE", "PG_OPCLASS_IS_VISIBLE", "PG_OPERATOR_IS_VISIBLE", "PG_OPFAMILY_IS_VISIBLE", "PG_OPTIONS_TO_TABLE", "PG_POSTMASTER_START_TIME", "PG_SAFE_SNAPSHOT_BLOCKING_PIDS", "PG_SNAPSHOT_XIP", "PG_SNAPSHOT_XMAX", "PG_SNAPSHOT_XMIN", "PG_STATISTICS_OBJ_IS_VISIBLE", "PG_TABLESPACE_DATABASES", "PG_TABLESPACE_LOCATION", "PG_TABLE_IS_VISIBLE", "PG_TRIGGER_DEPTH", "PG_TS_CONFIG_IS_VISIBLE", "PG_TS_DICT_IS_VISIBLE", "PG_TS_PARSER_IS_VISIBLE", "PG_TS_TEMPLATE_IS_VISIBLE", "PG_TYPEOF", "PG_TYPE_IS_VISIBLE", "PG_VISIBLE_IN_SNAPSHOT", "PG_XACT_COMMIT_TIMESTAMP", "PG_XACT_COMMIT_TIMESTAMP_ORIGIN", "PG_XACT_STATUS", "PQSERVERVERSION", "ROW_SECURITY_ACTIVE", "SESSION_USER", "SHOBJ_DESCRIPTION", "TO_REGCLASS", "TO_REGCOLLATION", "TO_REGNAMESPACE", "TO_REGOPER", "TO_REGOPERATOR", "TO_REGPROC", "TO_REGPROCEDURE", "TO_REGROLE", "TO_REGTYPE", "TXID_CURRENT", "TXID_CURRENT_IF_ASSIGNED", "TXID_CURRENT_SNAPSHOT", "TXID_SNAPSHOT_XIP", "TXID_SNAPSHOT_XMAX", "TXID_SNAPSHOT_XMIN", "TXID_STATUS", "TXID_VISIBLE_IN_SNAPSHOT", "USER", "VERSION"],
  // https://www.postgresql.org/docs/14/functions-admin.html
  sysAdmin: ["BRIN_DESUMMARIZE_RANGE", "BRIN_SUMMARIZE_NEW_VALUES", "BRIN_SUMMARIZE_RANGE", "CONVERT_FROM", "CURRENT_SETTING", "GIN_CLEAN_PENDING_LIST", "PG_ADVISORY_LOCK", "PG_ADVISORY_LOCK_SHARED", "PG_ADVISORY_UNLOCK", "PG_ADVISORY_UNLOCK_ALL", "PG_ADVISORY_UNLOCK_SHARED", "PG_ADVISORY_XACT_LOCK", "PG_ADVISORY_XACT_LOCK_SHARED", "PG_BACKUP_START_TIME", "PG_CANCEL_BACKEND", "PG_COLLATION_ACTUAL_VERSION", "PG_COLUMN_COMPRESSION", "PG_COLUMN_SIZE", "PG_COPY_LOGICAL_REPLICATION_SLOT", "PG_COPY_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_LOGICAL_REPLICATION_SLOT", "PG_CREATE_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_RESTORE_POINT", "PG_CURRENT_WAL_FLUSH_LSN", "PG_CURRENT_WAL_INSERT_LSN", "PG_CURRENT_WAL_LSN", "PG_DATABASE_SIZE", "PG_DROP_REPLICATION_SLOT", "PG_EXPORT_SNAPSHOT", "PG_FILENODE_RELATION", "PG_GET_WAL_REPLAY_PAUSE_STATE", "PG_IMPORT_SYSTEM_COLLATIONS", "PG_INDEXES_SIZE", "PG_IS_IN_BACKUP", "PG_IS_IN_RECOVERY", "PG_IS_WAL_REPLAY_PAUSED", "PG_LAST_WAL_RECEIVE_LSN", "PG_LAST_WAL_REPLAY_LSN", "PG_LAST_XACT_REPLAY_TIMESTAMP", "PG_LOGICAL_EMIT_MESSAGE", "PG_LOGICAL_SLOT_GET_BINARY_CHANGES", "PG_LOGICAL_SLOT_GET_CHANGES", "PG_LOGICAL_SLOT_PEEK_BINARY_CHANGES", "PG_LOGICAL_SLOT_PEEK_CHANGES", "PG_LOG_BACKEND_MEMORY_CONTEXTS", "PG_LS_ARCHIVE_STATUSDIR", "PG_LS_DIR", "PG_LS_LOGDIR", "PG_LS_TMPDIR", "PG_LS_WALDIR", "PG_PARTITION_ANCESTORS", "PG_PARTITION_ROOT", "PG_PARTITION_TREE", "PG_PROMOTE", "PG_READ_BINARY_FILE", "PG_READ_FILE", "PG_RELATION_FILENODE", "PG_RELATION_FILEPATH", "PG_RELATION_SIZE", "PG_RELOAD_CONF", "PG_REPLICATION_ORIGIN_ADVANCE", "PG_REPLICATION_ORIGIN_CREATE", "PG_REPLICATION_ORIGIN_DROP", "PG_REPLICATION_ORIGIN_OID", "PG_REPLICATION_ORIGIN_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_IS_SETUP", "PG_REPLICATION_ORIGIN_SESSION_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_RESET", "PG_REPLICATION_ORIGIN_SESSION_SETUP", "PG_REPLICATION_ORIGIN_XACT_RESET", "PG_REPLICATION_ORIGIN_XACT_SETUP", "PG_REPLICATION_SLOT_ADVANCE", "PG_ROTATE_LOGFILE", "PG_SIZE_BYTES", "PG_SIZE_PRETTY", "PG_START_BACKUP", "PG_STAT_FILE", "PG_STOP_BACKUP", "PG_SWITCH_WAL", "PG_TABLESPACE_SIZE", "PG_TABLE_SIZE", "PG_TERMINATE_BACKEND", "PG_TOTAL_RELATION_SIZE", "PG_TRY_ADVISORY_LOCK", "PG_TRY_ADVISORY_LOCK_SHARED", "PG_TRY_ADVISORY_XACT_LOCK", "PG_TRY_ADVISORY_XACT_LOCK_SHARED", "PG_WALFILE_NAME", "PG_WALFILE_NAME_OFFSET", "PG_WAL_LSN_DIFF", "PG_WAL_REPLAY_PAUSE", "PG_WAL_REPLAY_RESUME", "SET_CONFIG"],
  // https://www.postgresql.org/docs/14/functions-trigger.html
  trigger: ["SUPPRESS_REDUNDANT_UPDATES_TRIGGER", "TSVECTOR_UPDATE_TRIGGER", "TSVECTOR_UPDATE_TRIGGER_COLUMN"],
  // https://www.postgresql.org/docs/14/functions-event-triggers.html
  eventTrigger: ["PG_EVENT_TRIGGER_DDL_COMMANDS", "PG_EVENT_TRIGGER_DROPPED_OBJECTS", "PG_EVENT_TRIGGER_TABLE_REWRITE_OID", "PG_EVENT_TRIGGER_TABLE_REWRITE_REASON", "PG_GET_OBJECT_ADDRESS"],
  // https://www.postgresql.org/docs/14/functions-statistics.html
  stats: ["PG_MCV_LIST_ITEMS"],
  cast: ["CAST"],
  // Parameterized data types
  // https://www.postgresql.org/docs/current/datatype.html
  dataTypes: ["BIT", "BIT VARYING", "CHARACTER", "CHARACTER VARYING", "VARCHAR", "CHAR", "DECIMAL", "NUMERIC", "TIME", "TIMESTAMP", "ENUM"]
}), kke = Ct({
  // https://www.postgresql.org/docs/14/sql-keywords-appendix.html
  all: [
    "ABORT",
    "ABSOLUTE",
    "ACCESS",
    "ACTION",
    "ADD",
    "ADMIN",
    "AFTER",
    "AGGREGATE",
    "ALL",
    // reserved
    "ALSO",
    "ALTER",
    "ALWAYS",
    "ANALYSE",
    // reserved
    "ANALYZE",
    // reserved
    "AND",
    // reserved
    "ANY",
    // reserved
    "ARRAY",
    // reserved, requires AS
    "AS",
    // reserved, requires AS
    "ASC",
    // reserved
    "ASENSITIVE",
    "ASSERTION",
    "ASSIGNMENT",
    "ASYMMETRIC",
    // reserved
    "AT",
    "ATOMIC",
    "ATTACH",
    "ATTRIBUTE",
    "AUTHORIZATION",
    // reserved (can be function or type)
    "BACKWARD",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    // (cannot be function or type)
    "BIGINT",
    // (cannot be function or type)
    "BINARY",
    // reserved (can be function or type)
    "BIT",
    // (cannot be function or type)
    "BOOLEAN",
    // (cannot be function or type)
    "BOTH",
    // reserved
    "BREADTH",
    "BY",
    "CACHE",
    "CALL",
    "CALLED",
    "CASCADE",
    "CASCADED",
    "CASE",
    // reserved
    "CAST",
    // reserved
    "CATALOG",
    "CHAIN",
    "CHAR",
    // (cannot be function or type), requires AS
    "CHARACTER",
    // (cannot be function or type), requires AS
    "CHARACTERISTICS",
    "CHECK",
    // reserved
    "CHECKPOINT",
    "CLASS",
    "CLOSE",
    "CLUSTER",
    "COALESCE",
    // (cannot be function or type)
    "COLLATE",
    // reserved
    "COLLATION",
    // reserved (can be function or type)
    "COLUMN",
    // reserved
    "COLUMNS",
    "COMMENT",
    "COMMENTS",
    "COMMIT",
    "COMMITTED",
    "COMPRESSION",
    "CONCURRENTLY",
    // reserved (can be function or type)
    "CONFIGURATION",
    "CONFLICT",
    "CONNECTION",
    "CONSTRAINT",
    // reserved
    "CONSTRAINTS",
    "CONTENT",
    "CONTINUE",
    "CONVERSION",
    "COPY",
    "COST",
    "CREATE",
    // reserved, requires AS
    "CROSS",
    // reserved (can be function or type)
    "CSV",
    "CUBE",
    "CURRENT",
    "CURRENT_CATALOG",
    // reserved
    "CURRENT_DATE",
    // reserved
    "CURRENT_ROLE",
    // reserved
    "CURRENT_SCHEMA",
    // reserved (can be function or type)
    "CURRENT_TIME",
    // reserved
    "CURRENT_TIMESTAMP",
    // reserved
    "CURRENT_USER",
    // reserved
    "CURSOR",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DAY",
    // requires AS
    "DEALLOCATE",
    "DEC",
    // (cannot be function or type)
    "DECIMAL",
    // (cannot be function or type)
    "DECLARE",
    "DEFAULT",
    // reserved
    "DEFAULTS",
    "DEFERRABLE",
    // reserved
    "DEFERRED",
    "DEFINER",
    "DELETE",
    "DELIMITER",
    "DELIMITERS",
    "DEPENDS",
    "DEPTH",
    "DESC",
    // reserved
    "DETACH",
    "DICTIONARY",
    "DISABLE",
    "DISCARD",
    "DISTINCT",
    // reserved
    "DO",
    // reserved
    "DOCUMENT",
    "DOMAIN",
    "DOUBLE",
    "DROP",
    "EACH",
    "ELSE",
    // reserved
    "ENABLE",
    "ENCODING",
    "ENCRYPTED",
    "END",
    // reserved
    "ENUM",
    "ESCAPE",
    "EVENT",
    "EXCEPT",
    // reserved, requires AS
    "EXCLUDE",
    "EXCLUDING",
    "EXCLUSIVE",
    "EXECUTE",
    "EXISTS",
    // (cannot be function or type)
    "EXPLAIN",
    "EXPRESSION",
    "EXTENSION",
    "EXTERNAL",
    "EXTRACT",
    // (cannot be function or type)
    "FALSE",
    // reserved
    "FAMILY",
    "FETCH",
    // reserved, requires AS
    "FILTER",
    // requires AS
    "FINALIZE",
    "FIRST",
    "FLOAT",
    // (cannot be function or type)
    "FOLLOWING",
    "FOR",
    // reserved, requires AS
    "FORCE",
    "FOREIGN",
    // reserved
    "FORWARD",
    "FREEZE",
    // reserved (can be function or type)
    "FROM",
    // reserved, requires AS
    "FULL",
    // reserved (can be function or type)
    "FUNCTION",
    "FUNCTIONS",
    "GENERATED",
    "GLOBAL",
    "GRANT",
    // reserved, requires AS
    "GRANTED",
    "GREATEST",
    // (cannot be function or type)
    "GROUP",
    // reserved, requires AS
    "GROUPING",
    // (cannot be function or type)
    "GROUPS",
    "HANDLER",
    "HAVING",
    // reserved, requires AS
    "HEADER",
    "HOLD",
    "HOUR",
    // requires AS
    "IDENTITY",
    "IF",
    "ILIKE",
    // reserved (can be function or type)
    "IMMEDIATE",
    "IMMUTABLE",
    "IMPLICIT",
    "IMPORT",
    "IN",
    // reserved
    "INCLUDE",
    "INCLUDING",
    "INCREMENT",
    "INDEX",
    "INDEXES",
    "INHERIT",
    "INHERITS",
    "INITIALLY",
    // reserved
    "INLINE",
    "INNER",
    // reserved (can be function or type)
    "INOUT",
    // (cannot be function or type)
    "INPUT",
    "INSENSITIVE",
    "INSERT",
    "INSTEAD",
    "INT",
    // (cannot be function or type)
    "INTEGER",
    // (cannot be function or type)
    "INTERSECT",
    // reserved, requires AS
    "INTERVAL",
    // (cannot be function or type)
    "INTO",
    // reserved, requires AS
    "INVOKER",
    "IS",
    // reserved (can be function or type)
    "ISNULL",
    // reserved (can be function or type), requires AS
    "ISOLATION",
    "JOIN",
    // reserved (can be function or type)
    "KEY",
    "LABEL",
    "LANGUAGE",
    "LARGE",
    "LAST",
    "LATERAL",
    // reserved
    "LEADING",
    // reserved
    "LEAKPROOF",
    "LEAST",
    // (cannot be function or type)
    "LEFT",
    // reserved (can be function or type)
    "LEVEL",
    "LIKE",
    // reserved (can be function or type)
    "LIMIT",
    // reserved, requires AS
    "LISTEN",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    // reserved
    "LOCALTIMESTAMP",
    // reserved
    "LOCATION",
    "LOCK",
    "LOCKED",
    "LOGGED",
    "MAPPING",
    "MATCH",
    "MATERIALIZED",
    "MAXVALUE",
    "METHOD",
    "MINUTE",
    // requires AS
    "MINVALUE",
    "MODE",
    "MONTH",
    // requires AS
    "MOVE",
    "NAME",
    "NAMES",
    "NATIONAL",
    // (cannot be function or type)
    "NATURAL",
    // reserved (can be function or type)
    "NCHAR",
    // (cannot be function or type)
    "NEW",
    "NEXT",
    "NFC",
    "NFD",
    "NFKC",
    "NFKD",
    "NO",
    "NONE",
    // (cannot be function or type)
    "NORMALIZE",
    // (cannot be function or type)
    "NORMALIZED",
    "NOT",
    // reserved
    "NOTHING",
    "NOTIFY",
    "NOTNULL",
    // reserved (can be function or type), requires AS
    "NOWAIT",
    "NULL",
    // reserved
    "NULLIF",
    // (cannot be function or type)
    "NULLS",
    "NUMERIC",
    // (cannot be function or type)
    "OBJECT",
    "OF",
    "OFF",
    "OFFSET",
    // reserved, requires AS
    "OIDS",
    "OLD",
    "ON",
    // reserved, requires AS
    "ONLY",
    // reserved
    "OPERATOR",
    "OPTION",
    "OPTIONS",
    "OR",
    // reserved
    "ORDER",
    // reserved, requires AS
    "ORDINALITY",
    "OTHERS",
    "OUT",
    // (cannot be function or type)
    "OUTER",
    // reserved (can be function or type)
    "OVER",
    // requires AS
    "OVERLAPS",
    // reserved (can be function or type), requires AS
    "OVERLAY",
    // (cannot be function or type)
    "OVERRIDING",
    "OWNED",
    "OWNER",
    "PARALLEL",
    "PARSER",
    "PARTIAL",
    "PARTITION",
    "PASSING",
    "PASSWORD",
    "PLACING",
    // reserved
    "PLANS",
    "POLICY",
    "POSITION",
    // (cannot be function or type)
    "PRECEDING",
    "PRECISION",
    // (cannot be function or type), requires AS
    "PREPARE",
    "PREPARED",
    "PRESERVE",
    "PRIMARY",
    // reserved
    "PRIOR",
    "PRIVILEGES",
    "PROCEDURAL",
    "PROCEDURE",
    "PROCEDURES",
    "PROGRAM",
    "PUBLICATION",
    "QUOTE",
    "RANGE",
    "READ",
    "REAL",
    // (cannot be function or type)
    "REASSIGN",
    "RECHECK",
    "RECURSIVE",
    "REF",
    "REFERENCES",
    // reserved
    "REFERENCING",
    "REFRESH",
    "REINDEX",
    "RELATIVE",
    "RELEASE",
    "RENAME",
    "REPEATABLE",
    "REPLACE",
    "REPLICA",
    "RESET",
    "RESTART",
    "RESTRICT",
    "RETURN",
    "RETURNING",
    // reserved, requires AS
    "RETURNS",
    "REVOKE",
    "RIGHT",
    // reserved (can be function or type)
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROUTINE",
    "ROUTINES",
    "ROW",
    // (cannot be function or type)
    "ROWS",
    "RULE",
    "SAVEPOINT",
    "SCHEMA",
    "SCHEMAS",
    "SCROLL",
    "SEARCH",
    "SECOND",
    // requires AS
    "SECURITY",
    "SELECT",
    // reserved
    "SEQUENCE",
    "SEQUENCES",
    "SERIALIZABLE",
    "SERVER",
    "SESSION",
    "SESSION_USER",
    // reserved
    "SET",
    "SETOF",
    // (cannot be function or type)
    "SETS",
    "SHARE",
    "SHOW",
    "SIMILAR",
    // reserved (can be function or type)
    "SIMPLE",
    "SKIP",
    "SMALLINT",
    // (cannot be function or type)
    "SNAPSHOT",
    "SOME",
    // reserved
    "SQL",
    "STABLE",
    "STANDALONE",
    "START",
    "STATEMENT",
    "STATISTICS",
    "STDIN",
    "STDOUT",
    "STORAGE",
    "STORED",
    "STRICT",
    "STRIP",
    "SUBSCRIPTION",
    "SUBSTRING",
    // (cannot be function or type)
    "SUPPORT",
    "SYMMETRIC",
    // reserved
    "SYSID",
    "SYSTEM",
    "TABLE",
    // reserved
    "TABLES",
    "TABLESAMPLE",
    // reserved (can be function or type)
    "TABLESPACE",
    "TEMP",
    "TEMPLATE",
    "TEMPORARY",
    "TEXT",
    "THEN",
    // reserved
    "TIES",
    "TIME",
    // (cannot be function or type)
    "TIMESTAMP",
    // (cannot be function or type)
    "TO",
    // reserved, requires AS
    "TRAILING",
    // reserved
    "TRANSACTION",
    "TRANSFORM",
    "TREAT",
    // (cannot be function or type)
    "TRIGGER",
    "TRIM",
    // (cannot be function or type)
    "TRUE",
    // reserved
    "TRUNCATE",
    "TRUSTED",
    "TYPE",
    "TYPES",
    "UESCAPE",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNENCRYPTED",
    "UNION",
    // reserved, requires AS
    "UNIQUE",
    // reserved
    "UNKNOWN",
    "UNLISTEN",
    "UNLOGGED",
    "UNTIL",
    "UPDATE",
    "USER",
    // reserved
    "USING",
    // reserved
    "VACUUM",
    "VALID",
    "VALIDATE",
    "VALIDATOR",
    "VALUE",
    "VALUES",
    // (cannot be function or type)
    "VARCHAR",
    // (cannot be function or type)
    "VARIADIC",
    // reserved
    "VARYING",
    // requires AS
    "VERBOSE",
    // reserved (can be function or type)
    "VERSION",
    "VIEW",
    "VIEWS",
    "VOLATILE",
    "WHEN",
    // reserved
    "WHERE",
    // reserved, requires AS
    "WHITESPACE",
    "WINDOW",
    // reserved, requires AS
    "WITH",
    // reserved, requires AS
    "WITHIN",
    // requires AS
    "WITHOUT",
    // requires AS
    "WORK",
    "WRAPPER",
    "WRITE",
    "XML",
    "XMLATTRIBUTES",
    // (cannot be function or type)
    "XMLCONCAT",
    // (cannot be function or type)
    "XMLELEMENT",
    // (cannot be function or type)
    "XMLEXISTS",
    // (cannot be function or type)
    "XMLFOREST",
    // (cannot be function or type)
    "XMLNAMESPACES",
    // (cannot be function or type)
    "XMLPARSE",
    // (cannot be function or type)
    "XMLPI",
    // (cannot be function or type)
    "XMLROOT",
    // (cannot be function or type)
    "XMLSERIALIZE",
    // (cannot be function or type)
    "XMLTABLE",
    // (cannot be function or type)
    "YEAR",
    // requires AS
    "YES",
    "ZONE"
  ]
}), Qke = ie(["SELECT [ALL | DISTINCT]"]), Uke = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR {UPDATE | NO KEY UPDATE | SHARE | KEY SHARE} [OF]",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [TEMP | TEMPORARY] [RECURSIVE] VIEW",
  "CREATE MATERIALIZED VIEW [IF NOT EXISTS]",
  "CREATE [GLOBAL | LOCAL] [TEMPORARY | TEMP | UNLOGGED] TABLE [IF NOT EXISTS]",
  // other
  "RETURNING"
]), DB = ie([
  // - update:
  "UPDATE [ONLY]",
  "WHERE CURRENT OF",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS] [ONLY]",
  "ALTER TABLE ALL IN TABLESPACE",
  "RENAME [COLUMN]",
  "RENAME TO",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "ALTER [COLUMN]",
  "[SET DATA] TYPE",
  // for alter column
  "{SET | DROP} DEFAULT",
  // for alter column
  "{SET | DROP} NOT NULL",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE] [ONLY]",
  // other
  "SET SCHEMA",
  "AFTER",
  // https://www.postgresql.org/docs/14/sql-commands.html
  "ABORT",
  "ALTER AGGREGATE",
  "ALTER COLLATION",
  "ALTER CONVERSION",
  "ALTER DATABASE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER DOMAIN",
  "ALTER EVENT TRIGGER",
  "ALTER EXTENSION",
  "ALTER FOREIGN DATA WRAPPER",
  "ALTER FOREIGN TABLE",
  "ALTER FUNCTION",
  "ALTER GROUP",
  "ALTER INDEX",
  "ALTER LANGUAGE",
  "ALTER LARGE OBJECT",
  "ALTER MATERIALIZED VIEW",
  "ALTER OPERATOR",
  "ALTER OPERATOR CLASS",
  "ALTER OPERATOR FAMILY",
  "ALTER POLICY",
  "ALTER PROCEDURE",
  "ALTER PUBLICATION",
  "ALTER ROLE",
  "ALTER ROUTINE",
  "ALTER RULE",
  "ALTER SCHEMA",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER STATISTICS",
  "ALTER SUBSCRIPTION",
  "ALTER SYSTEM",
  "ALTER TABLESPACE",
  "ALTER TEXT SEARCH CONFIGURATION",
  "ALTER TEXT SEARCH DICTIONARY",
  "ALTER TEXT SEARCH PARSER",
  "ALTER TEXT SEARCH TEMPLATE",
  "ALTER TRIGGER",
  "ALTER TYPE",
  "ALTER USER",
  "ALTER USER MAPPING",
  "ALTER VIEW",
  "ANALYZE",
  "BEGIN",
  "CALL",
  "CHECKPOINT",
  "CLOSE",
  "CLUSTER",
  "COMMENT",
  "COMMIT",
  "COMMIT PREPARED",
  "COPY",
  "CREATE ACCESS METHOD",
  "CREATE AGGREGATE",
  "CREATE CAST",
  "CREATE COLLATION",
  "CREATE CONVERSION",
  "CREATE DATABASE",
  "CREATE DOMAIN",
  "CREATE EVENT TRIGGER",
  "CREATE EXTENSION",
  "CREATE FOREIGN DATA WRAPPER",
  "CREATE FOREIGN TABLE",
  "CREATE FUNCTION",
  "CREATE GROUP",
  "CREATE INDEX",
  "CREATE LANGUAGE",
  "CREATE OPERATOR",
  "CREATE OPERATOR CLASS",
  "CREATE OPERATOR FAMILY",
  "CREATE POLICY",
  "CREATE PROCEDURE",
  "CREATE PUBLICATION",
  "CREATE ROLE",
  "CREATE RULE",
  "CREATE SCHEMA",
  "CREATE SEQUENCE",
  "CREATE SERVER",
  "CREATE STATISTICS",
  "CREATE SUBSCRIPTION",
  "CREATE TABLESPACE",
  "CREATE TEXT SEARCH CONFIGURATION",
  "CREATE TEXT SEARCH DICTIONARY",
  "CREATE TEXT SEARCH PARSER",
  "CREATE TEXT SEARCH TEMPLATE",
  "CREATE TRANSFORM",
  "CREATE TRIGGER",
  "CREATE TYPE",
  "CREATE USER",
  "CREATE USER MAPPING",
  "DEALLOCATE",
  "DECLARE",
  "DISCARD",
  "DROP ACCESS METHOD",
  "DROP AGGREGATE",
  "DROP CAST",
  "DROP COLLATION",
  "DROP CONVERSION",
  "DROP DATABASE",
  "DROP DOMAIN",
  "DROP EVENT TRIGGER",
  "DROP EXTENSION",
  "DROP FOREIGN DATA WRAPPER",
  "DROP FOREIGN TABLE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP INDEX",
  "DROP LANGUAGE",
  "DROP MATERIALIZED VIEW",
  "DROP OPERATOR",
  "DROP OPERATOR CLASS",
  "DROP OPERATOR FAMILY",
  "DROP OWNED",
  "DROP POLICY",
  "DROP PROCEDURE",
  "DROP PUBLICATION",
  "DROP ROLE",
  "DROP ROUTINE",
  "DROP RULE",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP STATISTICS",
  "DROP SUBSCRIPTION",
  "DROP TABLESPACE",
  "DROP TEXT SEARCH CONFIGURATION",
  "DROP TEXT SEARCH DICTIONARY",
  "DROP TEXT SEARCH PARSER",
  "DROP TEXT SEARCH TEMPLATE",
  "DROP TRANSFORM",
  "DROP TRIGGER",
  "DROP TYPE",
  "DROP USER",
  "DROP USER MAPPING",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "IMPORT FOREIGN SCHEMA",
  "LISTEN",
  "LOAD",
  "LOCK",
  "MOVE",
  "NOTIFY",
  "PREPARE",
  "PREPARE TRANSACTION",
  "REASSIGN OWNED",
  "REFRESH MATERIALIZED VIEW",
  "REINDEX",
  "RELEASE SAVEPOINT",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK PREPARED",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SECURITY LABEL",
  "SELECT INTO",
  "SET CONSTRAINTS",
  "SET ROLE",
  "SET SESSION AUTHORIZATION",
  "SET TRANSACTION",
  "SHOW",
  "START TRANSACTION",
  "UNLISTEN",
  "VACUUM"
]), $ke = ie(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), Gke = ie(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), Bke = ie([
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]",
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // https://www.postgresql.org/docs/current/datatype-datetime.html
  "{TIMESTAMP | TIME} {WITH | WITHOUT} TIME ZONE",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), Vke = {
  tokenizerOptions: {
    reservedSelect: Qke,
    reservedClauses: [...Uke, ...DB],
    reservedSetOperations: $ke,
    reservedJoins: Gke,
    reservedPhrases: Bke,
    reservedKeywords: kke,
    reservedFunctionNames: Mke,
    nestedBlockComments: !0,
    extraParens: ["[]"],
    stringTypes: ["$$", {
      quote: "''-qq",
      prefixes: ["U&"]
    }, {
      quote: "''-bs",
      prefixes: ["E"],
      requirePrefix: !0
    }, {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: [{
      quote: '""-qq',
      prefixes: ["U&"]
    }],
    identChars: {
      rest: "$"
    },
    paramTypes: {
      numbered: ["$"]
    },
    operators: [
      // Arithmetic
      "%",
      "^",
      "|/",
      "||/",
      "@",
      // Assignment
      ":=",
      // Bitwise
      "&",
      "|",
      "#",
      "~",
      "<<",
      ">>",
      // Byte comparison
      "~>~",
      "~<~",
      "~>=~",
      "~<=~",
      // Geometric
      "@-@",
      "@@",
      "##",
      "<->",
      "&&",
      "&<",
      "&>",
      "<<|",
      "&<|",
      "|>>",
      "|&>",
      "<^",
      "^>",
      "?#",
      "?-",
      "?|",
      "?-|",
      "?||",
      "@>",
      "<@",
      "~=",
      // JSON
      "?",
      "@?",
      "?&",
      "->",
      "->>",
      "#>",
      "#>>",
      "#-",
      // Named function params
      "=>",
      // Network address
      ">>=",
      "<<=",
      // Pattern matching
      "~~",
      "~~*",
      "!~~",
      "!~~*",
      // POSIX RegExp
      "~",
      "~*",
      "!~",
      "!~*",
      // Range/multirange
      "-|-",
      // String concatenation
      "||",
      // Text search
      "@@@",
      "!!",
      // Trigram/trigraph
      "<%",
      "%>",
      "<<%",
      "%>>",
      "<<->",
      "<->>",
      "<<<->",
      "<->>>",
      // Type cast
      "::"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: DB
  }
}, Fke = Ct({
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Aggregate_Functions.html
  aggregate: ["ANY_VALUE", "APPROXIMATE PERCENTILE_DISC", "AVG", "COUNT", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Array_Functions.html
  array: ["array", "array_concat", "array_flatten", "get_array_length", "split_to_array", "subarray"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_bitwise_aggregate_functions.html
  bitwise: ["BIT_AND", "BIT_OR", "BOOL_AND", "BOOL_OR"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_conditional_expressions.html
  conditional: ["COALESCE", "DECODE", "GREATEST", "LEAST", "NVL", "NVL2", "NULLIF"],
  // https://docs.aws.amazon.com/redshift/latest/dg/Date_functions_header.html
  dateTime: ["ADD_MONTHS", "AT TIME ZONE", "CONVERT_TIMEZONE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE_CMP", "DATE_CMP_TIMESTAMP", "DATE_CMP_TIMESTAMPTZ", "DATE_PART_YEAR", "DATEADD", "DATEDIFF", "DATE_PART", "DATE_TRUNC", "EXTRACT", "GETDATE", "INTERVAL_CMP", "LAST_DAY", "MONTHS_BETWEEN", "NEXT_DAY", "SYSDATE", "TIMEOFDAY", "TIMESTAMP_CMP", "TIMESTAMP_CMP_DATE", "TIMESTAMP_CMP_TIMESTAMPTZ", "TIMESTAMPTZ_CMP", "TIMESTAMPTZ_CMP_DATE", "TIMESTAMPTZ_CMP_TIMESTAMP", "TIMEZONE", "TO_TIMESTAMP", "TRUNC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/geospatial-functions.html
  spatial: ["AddBBox", "DropBBox", "GeometryType", "ST_AddPoint", "ST_Angle", "ST_Area", "ST_AsBinary", "ST_AsEWKB", "ST_AsEWKT", "ST_AsGeoJSON", "ST_AsText", "ST_Azimuth", "ST_Boundary", "ST_Collect", "ST_Contains", "ST_ContainsProperly", "ST_ConvexHull", "ST_CoveredBy", "ST_Covers", "ST_Crosses", "ST_Dimension", "ST_Disjoint", "ST_Distance", "ST_DistanceSphere", "ST_DWithin", "ST_EndPoint", "ST_Envelope", "ST_Equals", "ST_ExteriorRing", "ST_Force2D", "ST_Force3D", "ST_Force3DM", "ST_Force3DZ", "ST_Force4D", "ST_GeometryN", "ST_GeometryType", "ST_GeomFromEWKB", "ST_GeomFromEWKT", "ST_GeomFromText", "ST_GeomFromWKB", "ST_InteriorRingN", "ST_Intersects", "ST_IsPolygonCCW", "ST_IsPolygonCW", "ST_IsClosed", "ST_IsCollection", "ST_IsEmpty", "ST_IsSimple", "ST_IsValid", "ST_Length", "ST_LengthSphere", "ST_Length2D", "ST_LineFromMultiPoint", "ST_LineInterpolatePoint", "ST_M", "ST_MakeEnvelope", "ST_MakeLine", "ST_MakePoint", "ST_MakePolygon", "ST_MemSize", "ST_MMax", "ST_MMin", "ST_Multi", "ST_NDims", "ST_NPoints", "ST_NRings", "ST_NumGeometries", "ST_NumInteriorRings", "ST_NumPoints", "ST_Perimeter", "ST_Perimeter2D", "ST_Point", "ST_PointN", "ST_Points", "ST_Polygon", "ST_RemovePoint", "ST_Reverse", "ST_SetPoint", "ST_SetSRID", "ST_Simplify", "ST_SRID", "ST_StartPoint", "ST_Touches", "ST_Within", "ST_X", "ST_XMax", "ST_XMin", "ST_Y", "ST_YMax", "ST_YMin", "ST_Z", "ST_ZMax", "ST_ZMin", "SupportsBBox"],
  // https://docs.aws.amazon.com/redshift/latest/dg/hash-functions.html
  hash: ["CHECKSUM", "FUNC_SHA1", "FNV_HASH", "MD5", "SHA", "SHA1", "SHA2"],
  // https://docs.aws.amazon.com/redshift/latest/dg/hyperloglog-functions.html
  hyperLogLog: ["HLL", "HLL_CREATE_SKETCH", "HLL_CARDINALITY", "HLL_COMBINE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/json-functions.html
  json: ["IS_VALID_JSON", "IS_VALID_JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_EXTRACT_ARRAY_ELEMENT_TEXT", "JSON_EXTRACT_PATH_TEXT", "JSON_PARSE", "JSON_SERIALIZE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/Math_functions.html
  math: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CBRT", "CEILING", "CEIL", "COS", "COT", "DEGREES", "DEXP", "DLOG1", "DLOG10", "EXP", "FLOOR", "LN", "LOG", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SIN", "SIGN", "SQRT", "TAN", "TO_HEX", "TRUNC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/ml-function.html
  machineLearning: ["EXPLAIN_MODEL"],
  // https://docs.aws.amazon.com/redshift/latest/dg/String_functions_header.html
  string: ["ASCII", "BPCHARCMP", "BTRIM", "BTTEXT_PATTERN_CMP", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARINDEX", "CHR", "COLLATE", "CONCAT", "CRC32", "DIFFERENCE", "INITCAP", "LEFT", "RIGHT", "LEN", "LENGTH", "LOWER", "LPAD", "RPAD", "LTRIM", "OCTETINDEX", "OCTET_LENGTH", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "REPLICATE", "REVERSE", "RTRIM", "SOUNDEX", "SPLIT_PART", "STRPOS", "STRTOL", "SUBSTRING", "TEXTLEN", "TRANSLATE", "TRIM", "UPPER"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Type_Info_Functions.html
  superType: ["decimal_precision", "decimal_scale", "is_array", "is_bigint", "is_boolean", "is_char", "is_decimal", "is_float", "is_integer", "is_object", "is_scalar", "is_smallint", "is_varchar", "json_typeof"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Window_functions.html
  window: ["AVG", "COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAST_VALUE", "LAG", "LEAD", "LISTAGG", "MAX", "MEDIAN", "MIN", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Data_type_formatting.html
  dataType: ["CAST", "CONVERT", "TO_CHAR", "TO_DATE", "TO_NUMBER", "TEXT_TO_INT_ALT", "TEXT_TO_NUMERIC_ALT"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_administration_functions.html
  sysAdmin: ["CHANGE_QUERY_PRIORITY", "CHANGE_SESSION_PRIORITY", "CHANGE_USER_PRIORITY", "CURRENT_SETTING", "PG_CANCEL_BACKEND", "PG_TERMINATE_BACKEND", "REBOOT_CLUSTER", "SET_CONFIG"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_information_functions.html
  sysInfo: ["CURRENT_AWS_ACCOUNT", "CURRENT_DATABASE", "CURRENT_NAMESPACE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "CURRENT_USER_ID", "HAS_ASSUMEROLE_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "PG_BACKEND_PID", "PG_GET_COLS", "PG_GET_GRANTEE_BY_IAM_ROLE", "PG_GET_IAM_ROLE_BY_USER", "PG_GET_LATE_BINDING_VIEW_COLS", "PG_LAST_COPY_COUNT", "PG_LAST_COPY_ID", "PG_LAST_UNLOAD_ID", "PG_LAST_QUERY_ID", "PG_LAST_UNLOAD_COUNT", "SESSION_USER", "SLICE_NUM", "USER", "VERSION"],
  dataTypes: ["DECIMAL", "NUMERIC", "CHAR", "CHARACTER", "VARCHAR", "CHARACTER VARYING", "NCHAR", "NVARCHAR", "VARBYTE"]
}), Xke = Ct({
  // https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html
  standard: ["AES128", "AES256", "ALL", "ALLOWOVERWRITE", "ANY", "ARRAY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BETWEEN", "BINARY", "BOTH", "CHECK", "COLUMN", "CONSTRAINT", "CREATE", "CROSS", "DEFAULT", "DEFERRABLE", "DEFLATE", "DEFRAG", "DESC", "DISABLE", "DISTINCT", "DO", "ENABLE", "ENCODE", "ENCRYPT", "ENCRYPTION", "EXPLICIT", "FALSE", "FOR", "FOREIGN", "FREEZE", "FROM", "FULL", "GLOBALDICT256", "GLOBALDICT64K", "GROUP", "IDENTITY", "IGNORE", "ILIKE", "IN", "INITIALLY", "INNER", "INTO", "IS", "ISNULL", "LANGUAGE", "LEADING", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LUN", "LUNS", "MINUS", "NATURAL", "NEW", "NOT", "NOTNULL", "NULL", "NULLS", "OFF", "OFFLINE", "OFFSET", "OID", "OLD", "ON", "ONLY", "OPEN", "ORDER", "OUTER", "OVERLAPS", "PARALLEL", "PARTITION", "PERCENT", "PERMISSIONS", "PLACING", "PRIMARY", "RECOVER", "REFERENCES", "REJECTLOG", "RESORT", "RESPECT", "RESTORE", "SIMILAR", "SNAPSHOT", "SOME", "SYSTEM", "TABLE", "TAG", "TDES", "THEN", "TIMESTAMP", "TO", "TOP", "TRAILING", "TRUE", "UNIQUE", "USING", "VERBOSE", "WALLET", "WITHOUT"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  dataConversionParams: ["ACCEPTANYDATE", "ACCEPTINVCHARS", "BLANKSASNULL", "DATEFORMAT", "EMPTYASNULL", "ENCODING", "ESCAPE", "EXPLICIT_IDS", "FILLRECORD", "IGNOREBLANKLINES", "IGNOREHEADER", "REMOVEQUOTES", "ROUNDEC", "TIMEFORMAT", "TRIMBLANKS", "TRUNCATECOLUMNS"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-load.html
  dataLoadParams: ["COMPROWS", "COMPUPDATE", "MAXERROR", "NOLOAD", "STATUPDATE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-format.html
  dataFormatParams: ["FORMAT", "CSV", "DELIMITER", "FIXEDWIDTH", "SHAPEFILE", "AVRO", "JSON", "PARQUET", "ORC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-authorization.html
  copyAuthParams: ["ACCESS_KEY_ID", "CREDENTIALS", "ENCRYPTED", "IAM_ROLE", "MASTER_SYMMETRIC_KEY", "SECRET_ACCESS_KEY", "SESSION_TOKEN"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-file-compression.html
  copyCompressionParams: ["BZIP2", "GZIP", "LZOP", "ZSTD"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_COPY-alphabetical-parm-list.html
  copyMiscParams: ["MANIFEST", "READRATIO", "REGION", "SSH"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html
  compressionEncodings: ["RAW", "AZ64", "BYTEDICT", "DELTA", "DELTA32K", "LZO", "MOSTLY8", "MOSTLY16", "MOSTLY32", "RUNLENGTH", "TEXT255", "TEXT32K"],
  misc: [
    // CREATE EXTERNAL SCHEMA (https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html)
    "CATALOG_ROLE",
    "SECRET_ARN",
    "EXTERNAL",
    // https://docs.aws.amazon.com/redshift/latest/dg/c_choosing_dist_sort.html
    "AUTO",
    "EVEN",
    "KEY",
    "PREDICATE",
    // ANALYZE | ANALYSE (https://docs.aws.amazon.com/redshift/latest/dg/r_ANALYZE.html)
    // unknown
    "COMPRESSION"
  ],
  /**
   * Other keywords not included:
   * STL: https://docs.aws.amazon.com/redshift/latest/dg/c_intro_STL_tables.html
   * SVCS: https://docs.aws.amazon.com/redshift/latest/dg/svcs_views.html
   * SVL: https://docs.aws.amazon.com/redshift/latest/dg/svl_views.html
   * SVV: https://docs.aws.amazon.com/redshift/latest/dg/svv_views.html
   */
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Character_types.html#r_Character_types-text-and-bpchar-types
  dataTypes: ["BPCHAR", "TEXT"]
}), Yke = ie(["SELECT [ALL | DISTINCT]"]), Hke = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE | MATERIALIZED] VIEW",
  "CREATE [TEMPORARY | TEMP | LOCAL TEMPORARY | LOCAL TEMP] TABLE [IF NOT EXISTS]"
]), MB = ie([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ALTER TABLE APPEND",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  "TYPE",
  // for alter column
  "ENCODE",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_SQL_commands.html
  "ABORT",
  "ALTER DATABASE",
  "ALTER DATASHARE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER GROUP",
  "ALTER MATERIALIZED VIEW",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER USER",
  "ANALYSE",
  "ANALYZE",
  "ANALYSE COMPRESSION",
  "ANALYZE COMPRESSION",
  "BEGIN",
  "CALL",
  "CANCEL",
  "CLOSE",
  "COMMENT",
  "COMMIT",
  "COPY",
  "CREATE DATABASE",
  "CREATE DATASHARE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL SCHEMA",
  "CREATE EXTERNAL TABLE",
  "CREATE FUNCTION",
  "CREATE GROUP",
  "CREATE LIBRARY",
  "CREATE MODEL",
  "CREATE PROCEDURE",
  "CREATE SCHEMA",
  "CREATE USER",
  "DEALLOCATE",
  "DECLARE",
  "DESC DATASHARE",
  "DROP DATABASE",
  "DROP DATASHARE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP LIBRARY",
  "DROP MODEL",
  "DROP MATERIALIZED VIEW",
  "DROP PROCEDURE",
  "DROP SCHEMA",
  "DROP USER",
  "DROP VIEW",
  "DROP",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "LOCK",
  "PREPARE",
  "REFRESH MATERIALIZED VIEW",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "SELECT INTO",
  "SET SESSION AUTHORIZATION",
  "SET SESSION CHARACTERISTICS",
  "SHOW",
  "SHOW EXTERNAL TABLE",
  "SHOW MODEL",
  "SHOW DATASHARES",
  "SHOW PROCEDURE",
  "SHOW TABLE",
  "SHOW VIEW",
  "START TRANSACTION",
  "UNLOAD",
  "VACUUM"
]), Wke = ie(["UNION [ALL]", "EXCEPT", "INTERSECT", "MINUS"]), zke = ie(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), Zke = ie([
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  "NULL AS",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html
  "DATA CATALOG",
  "HIVE METASTORE",
  // in window specifications
  "{ROWS | RANGE} BETWEEN"
]), qke = {
  tokenizerOptions: {
    reservedSelect: Yke,
    reservedClauses: [...Hke, ...MB],
    reservedSetOperations: Wke,
    reservedJoins: zke,
    reservedPhrases: Zke,
    reservedKeywords: Xke,
    reservedFunctionNames: Fke,
    stringTypes: ["''-qq"],
    identTypes: ['""-qq'],
    identChars: {
      first: "#"
    },
    paramTypes: {
      numbered: ["$"]
    },
    operators: [
      "^",
      "%",
      "@",
      "|/",
      "||/",
      "&",
      "|",
      // '#', conflicts with first char of identifier
      "~",
      "<<",
      ">>",
      "||",
      "::"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: MB
  }
}, jke = Ct({
  // https://deepkb.com/CO_000013/en/kb/IMPORT-fbfa59f0-2bf1-31fe-bb7b-0f9efe9932c6/spark-sql-keywords
  all: [
    "ADD",
    "AFTER",
    "ALL",
    "ALTER",
    "ANALYZE",
    "AND",
    "ANTI",
    "ANY",
    "ARCHIVE",
    "ARRAY",
    "AS",
    "ASC",
    "AT",
    "AUTHORIZATION",
    "BETWEEN",
    "BOTH",
    "BUCKET",
    "BUCKETS",
    "BY",
    "CACHE",
    "CASCADE",
    "CAST",
    "CHANGE",
    "CHECK",
    "CLEAR",
    "CLUSTER",
    "CLUSTERED",
    "CODEGEN",
    "COLLATE",
    "COLLECTION",
    "COLUMN",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMPACT",
    "COMPACTIONS",
    "COMPUTE",
    "CONCATENATE",
    "CONSTRAINT",
    "COST",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DAY",
    "DBPROPERTIES",
    "DEFINED",
    "DELETE",
    "DELIMITED",
    "DESC",
    "DESCRIBE",
    "DFS",
    "DIRECTORIES",
    "DIRECTORY",
    "DISTINCT",
    "DISTRIBUTE",
    "DIV",
    "DROP",
    "ESCAPE",
    "ESCAPED",
    "EXCEPT",
    "EXCHANGE",
    "EXISTS",
    "EXPORT",
    "EXTENDED",
    "EXTERNAL",
    "EXTRACT",
    "FALSE",
    "FETCH",
    "FIELDS",
    "FILTER",
    "FILEFORMAT",
    "FIRST",
    "FIRST_VALUE",
    "FOLLOWING",
    "FOR",
    "FOREIGN",
    "FORMAT",
    "FORMATTED",
    "FULL",
    "FUNCTION",
    "FUNCTIONS",
    "GLOBAL",
    "GRANT",
    "GROUP",
    "GROUPING",
    "HOUR",
    "IF",
    "IGNORE",
    "IMPORT",
    "IN",
    "INDEX",
    "INDEXES",
    "INNER",
    "INPATH",
    "INPUTFORMAT",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "ITEMS",
    "KEYS",
    "LAST",
    "LAST_VALUE",
    "LATERAL",
    "LAZY",
    "LEADING",
    "LEFT",
    "LIKE",
    "LINES",
    "LIST",
    "LOCAL",
    "LOCATION",
    "LOCK",
    "LOCKS",
    "LOGICAL",
    "MACRO",
    "MAP",
    "MATCHED",
    "MERGE",
    "MINUTE",
    "MONTH",
    "MSCK",
    "NAMESPACE",
    "NAMESPACES",
    "NATURAL",
    "NO",
    "NOT",
    "NULL",
    "NULLS",
    "OF",
    "ONLY",
    "OPTION",
    "OPTIONS",
    "OR",
    "ORDER",
    "OUT",
    "OUTER",
    "OUTPUTFORMAT",
    "OVER",
    "OVERLAPS",
    "OVERLAY",
    "OVERWRITE",
    "OWNER",
    "PARTITION",
    "PARTITIONED",
    "PARTITIONS",
    "PERCENT",
    "PLACING",
    "POSITION",
    "PRECEDING",
    "PRIMARY",
    "PRINCIPALS",
    "PROPERTIES",
    "PURGE",
    "QUERY",
    "RANGE",
    "RECORDREADER",
    "RECORDWRITER",
    "RECOVER",
    "REDUCE",
    "REFERENCES",
    "RENAME",
    "REPAIR",
    "REPLACE",
    "RESPECT",
    "RESTRICT",
    "REVOKE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLES",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SCHEMA",
    "SECOND",
    "SELECT",
    "SEMI",
    "SEPARATED",
    "SERDE",
    "SERDEPROPERTIES",
    "SESSION_USER",
    "SETS",
    "SHOW",
    "SKEWED",
    "SOME",
    "SORT",
    "SORTED",
    "START",
    "STATISTICS",
    "STORED",
    "STRATIFY",
    "STRUCT",
    "SUBSTR",
    "SUBSTRING",
    "TABLE",
    "TABLES",
    "TBLPROPERTIES",
    "TEMPORARY",
    "TERMINATED",
    "THEN",
    "TO",
    "TOUCH",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONS",
    "TRIM",
    "TRUE",
    "TRUNCATE",
    "UNARCHIVE",
    "UNBOUNDED",
    "UNCACHE",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNSET",
    "USE",
    "USER",
    "USING",
    "VIEW",
    "WINDOW",
    "YEAR",
    // other
    "ANALYSE",
    "ARRAY_ZIP",
    "COALESCE",
    "CONTAINS",
    "CONVERT",
    "DAYS",
    "DAY_HOUR",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DECODE",
    "DEFAULT",
    "DISTINCTROW",
    "ENCODE",
    "EXPLODE",
    "EXPLODE_OUTER",
    "FIXED",
    "GREATEST",
    "GROUP_CONCAT",
    "HOURS",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    "IFNULL",
    "LEAST",
    "LEVEL",
    "MINUTE_SECOND",
    "NULLIF",
    "OFFSET",
    "ON",
    "OPTIMIZE",
    "REGEXP",
    "SEPARATOR",
    "SIZE",
    "STRING",
    "TYPE",
    "TYPES",
    "UNSIGNED",
    "VARIABLES",
    "YEAR_MONTH"
  ]
}), Kke = Ct({
  // http://spark.apache.org/docs/latest/sql-ref-functions.html
  //
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#aggregate-functions
  aggregate: [
    // 'ANY',
    "APPROX_COUNT_DISTINCT",
    "APPROX_PERCENTILE",
    "AVG",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "BOOL_AND",
    "BOOL_OR",
    "COLLECT_LIST",
    "COLLECT_SET",
    "CORR",
    "COUNT",
    "COUNT",
    "COUNT",
    "COUNT_IF",
    "COUNT_MIN_SKETCH",
    "COVAR_POP",
    "COVAR_SAMP",
    "EVERY",
    "FIRST",
    "FIRST_VALUE",
    "GROUPING",
    "GROUPING_ID",
    "KURTOSIS",
    "LAST",
    "LAST_VALUE",
    "MAX",
    "MAX_BY",
    "MEAN",
    "MIN",
    "MIN_BY",
    "PERCENTILE",
    "PERCENTILE",
    "PERCENTILE_APPROX",
    "SKEWNESS",
    // 'SOME',
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "SUM",
    "VAR_POP",
    "VAR_SAMP",
    "VARIANCE"
  ],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#window-functions
  window: ["CUME_DIST", "DENSE_RANK", "LAG", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#array-functions
  array: ["ARRAY", "ARRAY_CONTAINS", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_REPEAT", "ARRAY_UNION", "ARRAYS_OVERLAP", "ARRAYS_ZIP", "FLATTEN", "SEQUENCE", "SHUFFLE", "SLICE", "SORT_ARRAY"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#map-functions
  map: ["ELEMENT_AT", "ELEMENT_AT", "MAP", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FROM_ARRAYS", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_VALUES", "STR_TO_MAP"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#date-and-timestamp-functions
  datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "DATE_ADD", "DATE_FORMAT", "DATE_FROM_UNIX_DATE", "DATE_PART", "DATE_SUB", "DATE_TRUNC", "DATEDIFF", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MAKE_DATE", "MAKE_DT_INTERVAL", "MAKE_INTERVAL", "MAKE_TIMESTAMP", "MAKE_YM_INTERVAL", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "NOW", "QUARTER", "SECOND", "SESSION_WINDOW", "TIMESTAMP_MICROS", "TIMESTAMP_MILLIS", "TIMESTAMP_SECONDS", "TO_DATE", "TO_TIMESTAMP", "TO_UNIX_TIMESTAMP", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_DATE", "UNIX_MICROS", "UNIX_MILLIS", "UNIX_SECONDS", "UNIX_TIMESTAMP", "WEEKDAY", "WEEKOFYEAR", "WINDOW", "YEAR"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#json-functions
  json: ["FROM_JSON", "GET_JSON_OBJECT", "JSON_ARRAY_LENGTH", "JSON_OBJECT_KEYS", "JSON_TUPLE", "SCHEMA_OF_JSON", "TO_JSON"],
  // http://spark.apache.org/docs/latest/api/sql/index.html
  misc: [
    "ABS",
    "ACOS",
    "ACOSH",
    "AGGREGATE",
    "ARRAY_SORT",
    "ASCII",
    "ASIN",
    "ASINH",
    "ASSERT_TRUE",
    "ATAN",
    "ATAN2",
    "ATANH",
    "BASE64",
    "BIGINT",
    "BIN",
    "BINARY",
    "BIT_COUNT",
    "BIT_GET",
    "BIT_LENGTH",
    "BOOLEAN",
    "BROUND",
    "BTRIM",
    "CARDINALITY",
    "CBRT",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHAR_LENGTH",
    "CHARACTER_LENGTH",
    "CHR",
    "CONCAT",
    "CONCAT_WS",
    "CONV",
    "COS",
    "COSH",
    "COT",
    "CRC32",
    "CURRENT_CATALOG",
    "CURRENT_DATABASE",
    "CURRENT_USER",
    "DATE",
    "DECIMAL",
    "DEGREES",
    "DOUBLE",
    // 'E',
    "ELT",
    "EXP",
    "EXPM1",
    "FACTORIAL",
    "FIND_IN_SET",
    "FLOAT",
    "FLOOR",
    "FORALL",
    "FORMAT_NUMBER",
    "FORMAT_STRING",
    "FROM_CSV",
    "GETBIT",
    "HASH",
    "HEX",
    "HYPOT",
    "INITCAP",
    "INLINE",
    "INLINE_OUTER",
    "INPUT_FILE_BLOCK_LENGTH",
    "INPUT_FILE_BLOCK_START",
    "INPUT_FILE_NAME",
    "INSTR",
    "INT",
    "ISNAN",
    "ISNOTNULL",
    "ISNULL",
    "JAVA_METHOD",
    "LCASE",
    "LEFT",
    "LENGTH",
    "LEVENSHTEIN",
    "LN",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG1P",
    "LOG2",
    "LOWER",
    "LPAD",
    "LTRIM",
    "MAP_FILTER",
    "MAP_ZIP_WITH",
    "MD5",
    "MOD",
    "MONOTONICALLY_INCREASING_ID",
    "NAMED_STRUCT",
    "NANVL",
    "NEGATIVE",
    "NVL",
    "NVL2",
    "OCTET_LENGTH",
    "OVERLAY",
    "PARSE_URL",
    "PI",
    "PMOD",
    "POSEXPLODE",
    "POSEXPLODE_OUTER",
    "POSITION",
    "POSITIVE",
    "POW",
    "POWER",
    "PRINTF",
    "RADIANS",
    "RAISE_ERROR",
    "RAND",
    "RANDN",
    "RANDOM",
    "REFLECT",
    "REGEXP_EXTRACT",
    "REGEXP_EXTRACT_ALL",
    "REGEXP_LIKE",
    "REGEXP_REPLACE",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RINT",
    "ROUND",
    "RPAD",
    "RTRIM",
    "SCHEMA_OF_CSV",
    "SENTENCES",
    "SHA",
    "SHA1",
    "SHA2",
    "SHIFTLEFT",
    "SHIFTRIGHT",
    "SHIFTRIGHTUNSIGNED",
    "SIGN",
    "SIGNUM",
    "SIN",
    "SINH",
    "SMALLINT",
    "SOUNDEX",
    "SPACE",
    "SPARK_PARTITION_ID",
    "SPLIT",
    "SQRT",
    "STACK",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "TAN",
    "TANH",
    "TIMESTAMP",
    "TINYINT",
    "TO_CSV",
    "TRANSFORM_KEYS",
    "TRANSFORM_VALUES",
    "TRANSLATE",
    "TRIM",
    "TRY_ADD",
    "TRY_DIVIDE",
    "TYPEOF",
    "UCASE",
    "UNBASE64",
    "UNHEX",
    "UPPER",
    "UUID",
    "VERSION",
    "WIDTH_BUCKET",
    "XPATH",
    "XPATH_BOOLEAN",
    "XPATH_DOUBLE",
    "XPATH_FLOAT",
    "XPATH_INT",
    "XPATH_LONG",
    "XPATH_NUMBER",
    "XPATH_SHORT",
    "XPATH_STRING",
    "XXHASH64",
    "ZIP_WITH"
  ],
  cast: ["CAST"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Parameterized data types
  // https://spark.apache.org/docs/latest/sql-ref-datatypes.html
  dataTypes: [
    "DECIMAL",
    "DEC",
    "NUMERIC",
    // No varchar type in Spark, only STRING. Added for the sake of tests
    "VARCHAR"
  ]
}), Jke = ie(["SELECT [ALL | DISTINCT]"]), e2e = ie([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  "INSERT [INTO | OVERWRITE] [TABLE]",
  "VALUES",
  // - insert overwrite directory:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-insert-overwrite-directory.html
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-load.html
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE",
  // Data definition
  "CREATE [OR REPLACE] [GLOBAL TEMPORARY | TEMPORARY] VIEW [IF NOT EXISTS]",
  "CREATE [EXTERNAL] TABLE [IF NOT EXISTS]"
]), kB = ie([
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMNS",
  "DROP {COLUMN | COLUMNS}",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "LATERAL VIEW",
  "ALTER DATABASE",
  "ALTER VIEW",
  "CREATE DATABASE",
  "CREATE FUNCTION",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP VIEW",
  "REPAIR TABLE",
  "USE DATABASE",
  // Data Retrieval
  "TABLESAMPLE",
  "PIVOT",
  "TRANSFORM",
  "EXPLAIN",
  // Auxiliary
  "ADD FILE",
  "ADD JAR",
  "ANALYZE TABLE",
  "CACHE TABLE",
  "CLEAR CACHE",
  "DESCRIBE DATABASE",
  "DESCRIBE FUNCTION",
  "DESCRIBE QUERY",
  "DESCRIBE TABLE",
  "LIST FILE",
  "LIST JAR",
  "REFRESH",
  "REFRESH TABLE",
  "REFRESH FUNCTION",
  "RESET",
  "SHOW COLUMNS",
  "SHOW CREATE TABLE",
  "SHOW DATABASES",
  "SHOW FUNCTIONS",
  "SHOW PARTITIONS",
  "SHOW TABLE EXTENDED",
  "SHOW TABLES",
  "SHOW TBLPROPERTIES",
  "SHOW VIEWS",
  "UNCACHE TABLE"
]), t2e = ie(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), r2e = ie([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard-joins
  "[LEFT] {ANTI | SEMI} JOIN",
  "NATURAL [LEFT] {ANTI | SEMI} JOIN"
]), i2e = ie(["ON DELETE", "ON UPDATE", "CURRENT ROW", "{ROWS | RANGE} BETWEEN"]), n2e = {
  tokenizerOptions: {
    reservedSelect: Jke,
    reservedClauses: [...e2e, ...kB],
    reservedSetOperations: t2e,
    reservedJoins: r2e,
    reservedPhrases: i2e,
    supportsXor: !0,
    reservedKeywords: jke,
    reservedFunctionNames: Kke,
    extraParens: ["[]"],
    stringTypes: ["''-bs", '""-bs', {
      quote: "''-raw",
      prefixes: ["R", "X"],
      requirePrefix: !0
    }, {
      quote: '""-raw',
      prefixes: ["R", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    variableTypes: [{
      quote: "{}",
      prefixes: ["$"],
      requirePrefix: !0
    }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||", "->"],
    postProcess: a2e
  },
  formatOptions: {
    onelineClauses: kB
  }
};
function a2e(r) {
  return r.map((e, t) => {
    const i = r[t - 1] || hh, n = r[t + 1] || hh;
    return ml.WINDOW(e) && n.type === te.OPEN_PAREN ? {
      ...e,
      type: te.RESERVED_FUNCTION_NAME
    } : e.text === "ITEMS" && e.type === te.RESERVED_KEYWORD && !(i.text === "COLLECTION" && n.text === "TERMINATED") ? {
      ...e,
      type: te.IDENTIFIER,
      text: e.raw
    } : e;
  });
}
const o2e = Ct({
  // https://www.sqlite.org/lang_corefunc.html
  scalar: ["ABS", "CHANGES", "CHAR", "COALESCE", "FORMAT", "GLOB", "HEX", "IFNULL", "IIF", "INSTR", "LAST_INSERT_ROWID", "LENGTH", "LIKE", "LIKELIHOOD", "LIKELY", "LOAD_EXTENSION", "LOWER", "LTRIM", "NULLIF", "PRINTF", "QUOTE", "RANDOM", "RANDOMBLOB", "REPLACE", "ROUND", "RTRIM", "SIGN", "SOUNDEX", "SQLITE_COMPILEOPTION_GET", "SQLITE_COMPILEOPTION_USED", "SQLITE_OFFSET", "SQLITE_SOURCE_ID", "SQLITE_VERSION", "SUBSTR", "SUBSTRING", "TOTAL_CHANGES", "TRIM", "TYPEOF", "UNICODE", "UNLIKELY", "UPPER", "ZEROBLOB"],
  // https://www.sqlite.org/lang_aggfunc.html
  aggregate: ["AVG", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "SUM", "TOTAL"],
  // https://www.sqlite.org/lang_datefunc.html
  datetime: ["DATE", "TIME", "DATETIME", "JULIANDAY", "UNIXEPOCH", "STRFTIME"],
  // https://www.sqlite.org/windowfunctions.html#biwinfunc
  window: ["row_number", "rank", "dense_rank", "percent_rank", "cume_dist", "ntile", "lag", "lead", "first_value", "last_value", "nth_value"],
  // https://www.sqlite.org/lang_mathfunc.html
  math: ["ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "CEIL", "CEILING", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG", "LOG10", "LOG2", "MOD", "PI", "POW", "POWER", "RADIANS", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC"],
  // https://www.sqlite.org/json1.html
  json: ["JSON", "JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_ARRAY_LENGTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_OBJECT", "JSON_PATCH", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_TYPE", "JSON_TYPE", "JSON_VALID", "JSON_QUOTE", "JSON_GROUP_ARRAY", "JSON_GROUP_OBJECT", "JSON_EACH", "JSON_TREE"],
  cast: ["CAST"],
  // SQLite allows parameters for all data types
  // Well, in fact it allows any word as a data type, e.g. CREATE TABLE foo (col1 madeupname(123));
  // https://www.sqlite.org/datatype3.html
  dataTypes: ["CHARACTER", "VARCHAR", "VARYING CHARACTER", "NCHAR", "NATIVE CHARACTER", "NVARCHAR", "NUMERIC", "DECIMAL"]
}), s2e = Ct({
  // https://www.sqlite.org/lang_keywords.html
  all: ["ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "AND", "ANY", "ARE", "ARRAY", "ALWAYS", "ANALYZE", "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DETACH", "DISTINCT", "DO", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDE", "EXCLUSIVE", "EXISTS", "EXPLAIN", "FAIL", "FILTER", "FIRST", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL", "GENERATED", "GLOB", "GROUP", "GROUPS", "HAVING", "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LAST", "LEFT", "LIKE", "LIMIT", "MATCH", "MATERIALIZED", "NATURAL", "NO", "NOT", "NOTHING", "NOTNULL", "NULL", "NULLS", "OF", "OFFSET", "ON", "ONLY", "OPEN", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARTITION", "PLAN", "PRAGMA", "PRECEDING", "PRIMARY", "QUERY", "RAISE", "RANGE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME", "REPLACE", "RESTRICT", "RETURNING", "RIGHT", "ROLLBACK", "ROW", "ROWS", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP", "TEMPORARY", "THEN", "TIES", "TO", "TRANSACTION", "TRIGGER", "UNBOUNDED", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT"]
}), l2e = ie(["SELECT [ALL | DISTINCT]"]), u2e = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK] INTO",
  "REPLACE INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [TEMPORARY | TEMP] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY | TEMP] TABLE [IF NOT EXISTS]"
]), QB = ie([
  // - update:
  "UPDATE [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK]",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [COLUMN]",
  "RENAME TO",
  // - set schema
  "SET SCHEMA"
]), h2e = ie(["UNION [ALL]", "EXCEPT", "INTERSECT"]), c2e = ie(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), f2e = ie(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE | GROUPS} BETWEEN"]), d2e = {
  tokenizerOptions: {
    reservedSelect: l2e,
    reservedClauses: [...u2e, ...QB],
    reservedSetOperations: h2e,
    reservedJoins: c2e,
    reservedPhrases: f2e,
    reservedKeywords: s2e,
    reservedFunctionNames: o2e,
    stringTypes: [
      "''-qq",
      {
        quote: "''-raw",
        prefixes: ["X"],
        requirePrefix: !0
      }
      // Depending on context SQLite also supports double-quotes for strings,
      // and single-quotes for identifiers.
    ],
    identTypes: ['""-qq', "``", "[]"],
    // https://www.sqlite.org/lang_expr.html#parameters
    paramTypes: {
      positional: !0,
      numbered: ["?"],
      named: [":", "@", "$"]
    },
    operators: ["%", "~", "&", "|", "<<", ">>", "==", "->", "->>", "||"]
  },
  formatOptions: {
    onelineClauses: QB
  }
}, p2e = Ct({
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_9_set_function_specification
  set: ["GROUPING"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_10_window_function
  window: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "ROW_NUMBER"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_27_numeric_value_function
  numeric: ["POSITION", "OCCURRENCES_REGEX", "POSITION_REGEX", "EXTRACT", "CHAR_LENGTH", "CHARACTER_LENGTH", "OCTET_LENGTH", "CARDINALITY", "ABS", "MOD", "LN", "EXP", "POWER", "SQRT", "FLOOR", "CEIL", "CEILING", "WIDTH_BUCKET"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_29_string_value_function
  string: ["SUBSTRING", "SUBSTRING_REGEX", "UPPER", "LOWER", "CONVERT", "TRANSLATE", "TRANSLATE_REGEX", "TRIM", "OVERLAY", "NORMALIZE", "SPECIFICTYPE"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_31_datetime_value_function
  datetime: ["CURRENT_DATE", "CURRENT_TIME", "LOCALTIME", "CURRENT_TIMESTAMP", "LOCALTIMESTAMP"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_38_multiset_value_function
  // SET serves multiple roles: a SET() function and a SET keyword e.g. in UPDATE table SET ...
  // multiset: ['SET'], (disabled for now)
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_10_9_aggregate_function
  aggregate: [
    "COUNT",
    "AVG",
    "MAX",
    "MIN",
    "SUM",
    // 'EVERY',
    // 'ANY',
    // 'SOME',
    "STDDEV_POP",
    "STDDEV_SAMP",
    "VAR_SAMP",
    "VAR_POP",
    "COLLECT",
    "FUSION",
    "INTERSECTION",
    "COVAR_POP",
    "COVAR_SAMP",
    "CORR",
    "REGR_SLOPE",
    "REGR_INTERCEPT",
    "REGR_COUNT",
    "REGR_R2",
    "REGR_AVGX",
    "REGR_AVGY",
    "REGR_SXX",
    "REGR_SYY",
    "REGR_SXY",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC"
  ],
  // CAST is a pretty complex case, involving multiple forms:
  // - CAST(col AS int)
  // - CAST(...) WITH ...
  // - CAST FROM int
  // - CREATE CAST(mycol AS int) WITH ...
  cast: ["CAST"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Non-standard functions that have widespread support
  nonStandard: ["ROUND", "SIN", "COS", "TAN", "ASIN", "ACOS", "ATAN"],
  // Data types with parameters like VARCHAR(100)
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#predefined-type
  dataTypes: ["CHARACTER", "CHAR", "CHARACTER VARYING", "CHAR VARYING", "VARCHAR", "CHARACTER LARGE OBJECT", "CHAR LARGE OBJECT", "CLOB", "NATIONAL CHARACTER", "NATIONAL CHAR", "NCHAR", "NATIONAL CHARACTER VARYING", "NATIONAL CHAR VARYING", "NCHAR VARYING", "NATIONAL CHARACTER LARGE OBJECT", "NCHAR LARGE OBJECT", "NCLOB", "BINARY", "BINARY VARYING", "VARBINARY", "BINARY LARGE OBJECT", "BLOB", "NUMERIC", "DECIMAL", "DEC", "TIME", "TIMESTAMP"]
}), g2e = Ct({
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#reserved-word
  all: [
    "ALL",
    "ALLOCATE",
    "ALTER",
    "ANY",
    // <- moved over from functions
    "ARE",
    "ARRAY",
    "AS",
    "ASENSITIVE",
    "ASYMMETRIC",
    "AT",
    "ATOMIC",
    "AUTHORIZATION",
    "BEGIN",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BLOB",
    "BOOLEAN",
    "BOTH",
    "BY",
    "CALL",
    "CALLED",
    "CASCADED",
    "CAST",
    "CHAR",
    "CHARACTER",
    "CHECK",
    "CLOB",
    "CLOSE",
    "COALESCE",
    "COLLATE",
    "COLUMN",
    "COMMIT",
    "CONDITION",
    "CONNECT",
    "CONSTRAINT",
    "CORRESPONDING",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_CATALOG",
    "CURRENT_DEFAULT_TRANSFORM_GROUP",
    "CURRENT_PATH",
    "CURRENT_ROLE",
    "CURRENT_SCHEMA",
    "CURRENT_TRANSFORM_GROUP_FOR_TYPE",
    "CURRENT_USER",
    "CURSOR",
    "CYCLE",
    "DATE",
    "DAY",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DELETE",
    "DEREF",
    "DESCRIBE",
    "DETERMINISTIC",
    "DISCONNECT",
    "DISTINCT",
    "DOUBLE",
    "DROP",
    "DYNAMIC",
    "EACH",
    "ELEMENT",
    "END-EXEC",
    "ESCAPE",
    "EVERY",
    // <- moved over from functions
    "EXCEPT",
    "EXEC",
    "EXECUTE",
    "EXISTS",
    "EXTERNAL",
    "FALSE",
    "FETCH",
    "FILTER",
    "FLOAT",
    "FOR",
    "FOREIGN",
    "FREE",
    "FROM",
    "FULL",
    "FUNCTION",
    "GET",
    "GLOBAL",
    "GRANT",
    "GROUP",
    "HAVING",
    "HOLD",
    "HOUR",
    "IDENTITY",
    "IN",
    "INDICATOR",
    "INNER",
    "INOUT",
    "INSENSITIVE",
    "INSERT",
    "INT",
    "INTEGER",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "LANGUAGE",
    "LARGE",
    "LATERAL",
    "LEADING",
    "LEFT",
    "LIKE",
    "LIKE_REGEX",
    "LOCAL",
    "MATCH",
    "MEMBER",
    "MERGE",
    "METHOD",
    "MINUTE",
    "MODIFIES",
    "MODULE",
    "MONTH",
    "MULTISET",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NCLOB",
    "NEW",
    "NO",
    "NONE",
    "NOT",
    "NULL",
    "NULLIF",
    "NUMERIC",
    "OF",
    "OLD",
    "ON",
    "ONLY",
    "OPEN",
    "ORDER",
    "OUT",
    "OUTER",
    "OVER",
    "OVERLAPS",
    "PARAMETER",
    "PARTITION",
    "PRECISION",
    "PREPARE",
    "PRIMARY",
    "PROCEDURE",
    "RANGE",
    "READS",
    "REAL",
    "RECURSIVE",
    "REF",
    "REFERENCES",
    "REFERENCING",
    "RELEASE",
    "RESULT",
    "RETURN",
    "RETURNS",
    "REVOKE",
    "RIGHT",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SAVEPOINT",
    "SCOPE",
    "SCROLL",
    "SEARCH",
    "SECOND",
    "SELECT",
    "SENSITIVE",
    "SESSION_USER",
    "SET",
    "SIMILAR",
    "SMALLINT",
    "SOME",
    // <- moved over from functions
    "SPECIFIC",
    "SQL",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "START",
    "STATIC",
    "SUBMULTISET",
    "SYMMETRIC",
    "SYSTEM",
    "SYSTEM_USER",
    "TABLE",
    "TABLESAMPLE",
    "THEN",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TO",
    "TRAILING",
    "TRANSLATION",
    "TREAT",
    "TRIGGER",
    "TRUE",
    "UESCAPE",
    "UNION",
    "UNIQUE",
    "UNKNOWN",
    "UNNEST",
    "UPDATE",
    "USER",
    "USING",
    "VALUE",
    "VALUES",
    "VARBINARY",
    "VARCHAR",
    "VARYING",
    "WHENEVER",
    "WINDOW",
    "WITHIN",
    "WITHOUT",
    "YEAR"
  ]
}), v2e = ie(["SELECT [ALL | DISTINCT]"]), O2e = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [RECURSIVE] VIEW",
  "CREATE [GLOBAL TEMPORARY | LOCAL TEMPORARY] TABLE"
]), UB = ie([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMN",
  "DROP [COLUMN]",
  "RENAME COLUMN",
  "RENAME TO",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  "ADD SCOPE",
  // for alter column
  "DROP SCOPE {CASCADE | RESTRICT}",
  // for alter column
  "RESTART WITH",
  // for alter column
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA"
]), m2e = ie(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), E2e = ie(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), b2e = ie(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]), S2e = {
  tokenizerOptions: {
    reservedSelect: v2e,
    reservedClauses: [...O2e, ...UB],
    reservedSetOperations: m2e,
    reservedJoins: E2e,
    reservedPhrases: b2e,
    reservedKeywords: g2e,
    reservedFunctionNames: p2e,
    stringTypes: [{
      quote: "''-qq-bs",
      prefixes: ["N", "U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X"],
      requirePrefix: !0
    }],
    identTypes: ['""-qq', "``"],
    paramTypes: {
      positional: !0
    },
    operators: ["||"]
  },
  formatOptions: {
    onelineClauses: UB
  }
}, T2e = Ct({
  // https://github.com/trinodb/trino/tree/432d2897bdef99388c1a47188743a061c4ac1f34/docs/src/main/sphinx/functions
  // rg '^\.\. function::' ./docs/src/main/sphinx/functions | cut -d' ' -f 3 | cut -d '(' -f 1 | sort | uniq
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep    '\* :func:' | cut -d'`' -f 2
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep -v '\* :func:'
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep  -e '^- :func:' | cut -d'`' -f2
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep -ve '^- :func:'
  all: ["ABS", "ACOS", "ALL_MATCH", "ANY_MATCH", "APPROX_DISTINCT", "APPROX_MOST_FREQUENT", "APPROX_PERCENTILE", "APPROX_SET", "ARBITRARY", "ARRAYS_OVERLAP", "ARRAY_AGG", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_SORT", "ARRAY_UNION", "ASIN", "ATAN", "ATAN2", "AT_TIMEZONE", "AVG", "BAR", "BETA_CDF", "BING_TILE", "BING_TILES_AROUND", "BING_TILE_AT", "BING_TILE_COORDINATES", "BING_TILE_POLYGON", "BING_TILE_QUADKEY", "BING_TILE_ZOOM_LEVEL", "BITWISE_AND", "BITWISE_AND_AGG", "BITWISE_LEFT_SHIFT", "BITWISE_NOT", "BITWISE_OR", "BITWISE_OR_AGG", "BITWISE_RIGHT_SHIFT", "BITWISE_RIGHT_SHIFT_ARITHMETIC", "BITWISE_XOR", "BIT_COUNT", "BOOL_AND", "BOOL_OR", "CARDINALITY", "CAST", "CBRT", "CEIL", "CEILING", "CHAR2HEXINT", "CHECKSUM", "CHR", "CLASSIFY", "COALESCE", "CODEPOINT", "COLOR", "COMBINATIONS", "CONCAT", "CONCAT_WS", "CONTAINS", "CONTAINS_SEQUENCE", "CONVEX_HULL_AGG", "CORR", "COS", "COSH", "COSINE_SIMILARITY", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CRC32", "CUME_DIST", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_GROUPS", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_USER", "DATE", "DATE_ADD", "DATE_DIFF", "DATE_FORMAT", "DATE_PARSE", "DATE_TRUNC", "DAY", "DAY_OF_MONTH", "DAY_OF_WEEK", "DAY_OF_YEAR", "DEGREES", "DENSE_RANK", "DOW", "DOY", "E", "ELEMENT_AT", "EMPTY_APPROX_SET", "EVALUATE_CLASSIFIER_PREDICTIONS", "EVERY", "EXP", "EXTRACT", "FEATURES", "FILTER", "FIRST_VALUE", "FLATTEN", "FLOOR", "FORMAT", "FORMAT_DATETIME", "FORMAT_NUMBER", "FROM_BASE", "FROM_BASE32", "FROM_BASE64", "FROM_BASE64URL", "FROM_BIG_ENDIAN_32", "FROM_BIG_ENDIAN_64", "FROM_ENCODED_POLYLINE", "FROM_GEOJSON_GEOMETRY", "FROM_HEX", "FROM_IEEE754_32", "FROM_IEEE754_64", "FROM_ISO8601_DATE", "FROM_ISO8601_TIMESTAMP", "FROM_ISO8601_TIMESTAMP_NANOS", "FROM_UNIXTIME", "FROM_UNIXTIME_NANOS", "FROM_UTF8", "GEOMETRIC_MEAN", "GEOMETRY_FROM_HADOOP_SHAPE", "GEOMETRY_INVALID_REASON", "GEOMETRY_NEAREST_POINTS", "GEOMETRY_TO_BING_TILES", "GEOMETRY_UNION", "GEOMETRY_UNION_AGG", "GREATEST", "GREAT_CIRCLE_DISTANCE", "HAMMING_DISTANCE", "HASH_COUNTS", "HISTOGRAM", "HMAC_MD5", "HMAC_SHA1", "HMAC_SHA256", "HMAC_SHA512", "HOUR", "HUMAN_READABLE_SECONDS", "IF", "INDEX", "INFINITY", "INTERSECTION_CARDINALITY", "INVERSE_BETA_CDF", "INVERSE_NORMAL_CDF", "IS_FINITE", "IS_INFINITE", "IS_JSON_SCALAR", "IS_NAN", "JACCARD_INDEX", "JSON_ARRAY_CONTAINS", "JSON_ARRAY_GET", "JSON_ARRAY_LENGTH", "JSON_EXISTS", "JSON_EXTRACT", "JSON_EXTRACT_SCALAR", "JSON_FORMAT", "JSON_PARSE", "JSON_QUERY", "JSON_SIZE", "JSON_VALUE", "KURTOSIS", "LAG", "LAST_DAY_OF_MONTH", "LAST_VALUE", "LEAD", "LEARN_CLASSIFIER", "LEARN_LIBSVM_CLASSIFIER", "LEARN_LIBSVM_REGRESSOR", "LEARN_REGRESSOR", "LEAST", "LENGTH", "LEVENSHTEIN_DISTANCE", "LINE_INTERPOLATE_POINT", "LINE_INTERPOLATE_POINTS", "LINE_LOCATE_POINT", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LTRIM", "LUHN_CHECK", "MAKE_SET_DIGEST", "MAP", "MAP_AGG", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FILTER", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_UNION", "MAP_VALUES", "MAP_ZIP_WITH", "MAX", "MAX_BY", "MD5", "MERGE", "MERGE_SET_DIGEST", "MILLISECOND", "MIN", "MINUTE", "MIN_BY", "MOD", "MONTH", "MULTIMAP_AGG", "MULTIMAP_FROM_ENTRIES", "MURMUR3", "NAN", "NGRAMS", "NONE_MATCH", "NORMALIZE", "NORMAL_CDF", "NOW", "NTH_VALUE", "NTILE", "NULLIF", "NUMERIC_HISTOGRAM", "OBJECTID", "OBJECTID_TIMESTAMP", "PARSE_DATA_SIZE", "PARSE_DATETIME", "PARSE_DURATION", "PERCENT_RANK", "PI", "POSITION", "POW", "POWER", "QDIGEST_AGG", "QUARTER", "RADIANS", "RAND", "RANDOM", "RANK", "REDUCE", "REDUCE_AGG", "REGEXP_COUNT", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_LIKE", "REGEXP_POSITION", "REGEXP_REPLACE", "REGEXP_SPLIT", "REGRESS", "REGR_INTERCEPT", "REGR_SLOPE", "RENDER", "REPEAT", "REPLACE", "REVERSE", "RGB", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "SECOND", "SEQUENCE", "SHA1", "SHA256", "SHA512", "SHUFFLE", "SIGN", "SIMPLIFY_GEOMETRY", "SIN", "SKEWNESS", "SLICE", "SOUNDEX", "SPATIAL_PARTITIONING", "SPATIAL_PARTITIONS", "SPLIT", "SPLIT_PART", "SPLIT_TO_MAP", "SPLIT_TO_MULTIMAP", "SPOOKY_HASH_V2_32", "SPOOKY_HASH_V2_64", "SQRT", "STARTS_WITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRPOS", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_BOUNDARY", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COORDDIM", "ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE", "ST_ENVELOPEASPTS", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMETRIES", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMBINARY", "ST_INTERIORRINGN", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISRING", "ST_ISSIMPLE", "ST_ISVALID", "ST_LENGTH", "ST_LINEFROMTEXT", "ST_LINESTRING", "ST_MULTIPOINT", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINT", "ST_POINTN", "ST_POINTS", "ST_POLYGON", "ST_RELATE", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "SUBSTR", "SUBSTRING", "SUM", "TAN", "TANH", "TDIGEST_AGG", "TIMESTAMP_OBJECTID", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO_BASE", "TO_BASE32", "TO_BASE64", "TO_BASE64URL", "TO_BIG_ENDIAN_32", "TO_BIG_ENDIAN_64", "TO_CHAR", "TO_DATE", "TO_ENCODED_POLYLINE", "TO_GEOJSON_GEOMETRY", "TO_GEOMETRY", "TO_HEX", "TO_IEEE754_32", "TO_IEEE754_64", "TO_ISO8601", "TO_MILLISECONDS", "TO_SPHERICAL_GEOGRAPHY", "TO_TIMESTAMP", "TO_UNIXTIME", "TO_UTF8", "TRANSFORM", "TRANSFORM_KEYS", "TRANSFORM_VALUES", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRY", "TRY_CAST", "TYPEOF", "UPPER", "URL_DECODE", "URL_ENCODE", "URL_EXTRACT_FRAGMENT", "URL_EXTRACT_HOST", "URL_EXTRACT_PARAMETER", "URL_EXTRACT_PATH", "URL_EXTRACT_PORT", "URL_EXTRACT_PROTOCOL", "URL_EXTRACT_QUERY", "UUID", "VALUES_AT_QUANTILES", "VALUE_AT_QUANTILE", "VARIANCE", "VAR_POP", "VAR_SAMP", "VERSION", "WEEK", "WEEK_OF_YEAR", "WIDTH_BUCKET", "WILSON_INTERVAL_LOWER", "WILSON_INTERVAL_UPPER", "WITH_TIMEZONE", "WORD_STEM", "XXHASH64", "YEAR", "YEAR_OF_WEEK", "YOW", "ZIP", "ZIP_WITH"],
  // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-recognition-expressions
  rowPattern: ["CLASSIFIER", "FIRST", "LAST", "MATCH_NUMBER", "NEXT", "PERMUTE", "PREV"]
}), y2e = Ct({
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-parser/src/main/antlr4/io/trino/sql/parser/SqlBase.g4#L858-L1128
  all: ["ABSENT", "ADD", "ADMIN", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "AUTHORIZATION", "BERNOULLI", "BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CATALOGS", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "CONDITIONAL", "CONSTRAINT", "COPARTITION", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_PATH", "CURRENT_ROLE", "DATA", "DEALLOCATE", "DEFAULT", "DEFINE", "DEFINER", "DELETE", "DENY", "DESC", "DESCRIBE", "DESCRIPTOR", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DROP", "ELSE", "EMPTY", "ENCODING", "END", "ERROR", "ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FINAL", "FIRST", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTIONS", "GRANT", "GRANTED", "GRANTS", "GRAPHVIZ", "GROUP", "GROUPING", "GROUPS", "HAVING", "IGNORE", "IN", "INCLUDING", "INITIAL", "INNER", "INPUT", "INSERT", "INTERSECT", "INTERVAL", "INTO", "INVOKER", "IO", "IS", "ISOLATION", "JOIN", "JSON", "JSON_ARRAY", "JSON_OBJECT", "KEEP", "KEY", "KEYS", "LAST", "LATERAL", "LEADING", "LEFT", "LEVEL", "LIKE", "LIMIT", "LOCAL", "LOGICAL", "MATCH", "MATCHED", "MATCHES", "MATCH_RECOGNIZE", "MATERIALIZED", "MEASURES", "NATURAL", "NEXT", "NFC", "NFD", "NFKC", "NFKD", "NO", "NONE", "NOT", "NULL", "NULLS", "OBJECT", "OF", "OFFSET", "OMIT", "ON", "ONE", "ONLY", "OPTION", "OR", "ORDER", "ORDINALITY", "OUTER", "OUTPUT", "OVER", "OVERFLOW", "PARTITION", "PARTITIONS", "PASSING", "PAST", "PATH", "PATTERN", "PER", "PERMUTE", "PRECEDING", "PRECISION", "PREPARE", "PRIVILEGES", "PROPERTIES", "PRUNE", "QUOTES", "RANGE", "READ", "RECURSIVE", "REFRESH", "RENAME", "REPEATABLE", "RESET", "RESPECT", "RESTRICT", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "RUNNING", "SCALAR", "SCHEMA", "SCHEMAS", "SECURITY", "SEEK", "SELECT", "SERIALIZABLE", "SESSION", "SET", "SETS", "SHOW", "SKIP", "SOME", "START", "STATS", "STRING", "SUBSET", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TEXT", "THEN", "TIES", "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION", "TRUE", "TYPE", "UESCAPE", "UNBOUNDED", "UNCOMMITTED", "UNCONDITIONAL", "UNION", "UNIQUE", "UNKNOWN", "UNMATCHED", "UNNEST", "UPDATE", "USE", "USER", "USING", "UTF16", "UTF32", "UTF8", "VALIDATE", "VALUE", "VALUES", "VERBOSE", "VIEW", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPER", "WRITE", "ZONE"],
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-main/src/main/java/io/trino/metadata/TypeRegistry.java#L131-L168
  // or https://trino.io/docs/current/language/types.html
  types: ["BIGINT", "INT", "INTEGER", "SMALLINT", "TINYINT", "BOOLEAN", "DATE", "DECIMAL", "REAL", "DOUBLE", "HYPERLOGLOG", "QDIGEST", "TDIGEST", "P4HYPERLOGLOG", "INTERVAL", "TIMESTAMP", "TIME", "VARBINARY", "VARCHAR", "CHAR", "ROW", "ARRAY", "MAP", "JSON", "JSON2016", "IPADDRESS", "GEOMETRY", "UUID", "SETDIGEST", "JONIREGEXP", "RE2JREGEXP", "LIKEPATTERN", "COLOR", "CODEPOINTS", "FUNCTION", "JSONPATH"]
}), R2e = ie(["SELECT [ALL | DISTINCT]"]), A2e = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW",
  "CREATE TABLE [IF NOT EXISTS]",
  // MATCH_RECOGNIZE
  "MATCH_RECOGNIZE",
  "MEASURES",
  "ONE ROW PER MATCH",
  "ALL ROWS PER MATCH",
  "AFTER MATCH",
  "PATTERN",
  "SUBSET",
  "DEFINE"
]), $B = ie([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME COLUMN [IF EXISTS]",
  "RENAME TO",
  "SET AUTHORIZATION [USER | ROLE]",
  "SET PROPERTIES",
  "EXECUTE",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "ALTER SCHEMA",
  "ALTER MATERIALIZED VIEW",
  "ALTER VIEW",
  "CREATE SCHEMA",
  "CREATE ROLE",
  "DROP SCHEMA",
  "DROP MATERIALIZED VIEW",
  "DROP VIEW",
  "DROP ROLE",
  // Auxiliary
  "EXPLAIN",
  "ANALYZE",
  "EXPLAIN ANALYZE",
  "EXPLAIN ANALYZE VERBOSE",
  "USE",
  "COMMENT ON TABLE",
  "COMMENT ON COLUMN",
  "DESCRIBE INPUT",
  "DESCRIBE OUTPUT",
  "REFRESH MATERIALIZED VIEW",
  "RESET SESSION",
  "SET SESSION",
  "SET PATH",
  "SET TIME ZONE",
  "SHOW GRANTS",
  "SHOW CREATE TABLE",
  "SHOW CREATE SCHEMA",
  "SHOW CREATE VIEW",
  "SHOW CREATE MATERIALIZED VIEW",
  "SHOW TABLES",
  "SHOW SCHEMAS",
  "SHOW CATALOGS",
  "SHOW COLUMNS",
  "SHOW STATS FOR",
  "SHOW ROLES",
  "SHOW CURRENT ROLES",
  "SHOW ROLE GRANTS",
  "SHOW FUNCTIONS",
  "SHOW SESSION"
]), C2e = ie(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), _2e = ie(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), I2e = ie([
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), x2e = {
  tokenizerOptions: {
    reservedSelect: R2e,
    reservedClauses: [...A2e, ...$B],
    reservedSetOperations: C2e,
    reservedJoins: _2e,
    reservedPhrases: I2e,
    reservedKeywords: y2e,
    reservedFunctionNames: T2e,
    // Trino also supports {- ... -} parenthesis.
    // The formatting of these currently works out as a result of { and -
    // not getting a space added in-between.
    // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-syntax
    extraParens: ["[]", "{}"],
    // https://trino.io/docs/current/language/types.html#string
    // https://trino.io/docs/current/language/types.html#varbinary
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X"],
      requirePrefix: !0
    }],
    // https://trino.io/docs/current/language/reserved.html
    identTypes: ['""-qq'],
    paramTypes: {
      positional: !0
    },
    operators: [
      "%",
      "->",
      "=>",
      ":",
      "||",
      // Row pattern syntax
      "|",
      "^",
      "$"
      // '?', conflicts with positional placeholders
    ]
  },
  formatOptions: {
    onelineClauses: $B
  }
}, w2e = Ct({
  // https://docs.microsoft.com/en-us/sql/t-sql/functions/functions?view=sql-server-ver15
  aggregate: ["APPROX_COUNT_DISTINCT", "AVG", "CHECKSUM_AGG", "COUNT", "COUNT_BIG", "GROUPING", "GROUPING_ID", "MAX", "MIN", "STDEV", "STDEVP", "SUM", "VAR", "VARP"],
  analytic: ["CUME_DIST", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "Collation - COLLATIONPROPERTY", "Collation - TERTIARY_WEIGHTS"],
  configuration: ["@@DBTS", "@@LANGID", "@@LANGUAGE", "@@LOCK_TIMEOUT", "@@MAX_CONNECTIONS", "@@MAX_PRECISION", "@@NESTLEVEL", "@@OPTIONS", "@@REMSERVER", "@@SERVERNAME", "@@SERVICENAME", "@@SPID", "@@TEXTSIZE", "@@VERSION"],
  conversion: ["CAST", "CONVERT", "PARSE", "TRY_CAST", "TRY_CONVERT", "TRY_PARSE"],
  cryptographic: ["ASYMKEY_ID", "ASYMKEYPROPERTY", "CERTPROPERTY", "CERT_ID", "CRYPT_GEN_RANDOM", "DECRYPTBYASYMKEY", "DECRYPTBYCERT", "DECRYPTBYKEY", "DECRYPTBYKEYAUTOASYMKEY", "DECRYPTBYKEYAUTOCERT", "DECRYPTBYPASSPHRASE", "ENCRYPTBYASYMKEY", "ENCRYPTBYCERT", "ENCRYPTBYKEY", "ENCRYPTBYPASSPHRASE", "HASHBYTES", "IS_OBJECTSIGNED", "KEY_GUID", "KEY_ID", "KEY_NAME", "SIGNBYASYMKEY", "SIGNBYCERT", "SYMKEYPROPERTY", "VERIFYSIGNEDBYCERT", "VERIFYSIGNEDBYASYMKEY"],
  cursor: ["@@CURSOR_ROWS", "@@FETCH_STATUS", "CURSOR_STATUS"],
  dataType: ["DATALENGTH", "IDENT_CURRENT", "IDENT_INCR", "IDENT_SEED", "IDENTITY", "SQL_VARIANT_PROPERTY"],
  datetime: ["@@DATEFIRST", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_TIMEZONE_ID", "DATEADD", "DATEDIFF", "DATEDIFF_BIG", "DATEFROMPARTS", "DATENAME", "DATEPART", "DATETIME2FROMPARTS", "DATETIMEFROMPARTS", "DATETIMEOFFSETFROMPARTS", "DAY", "EOMONTH", "GETDATE", "GETUTCDATE", "ISDATE", "MONTH", "SMALLDATETIMEFROMPARTS", "SWITCHOFFSET", "SYSDATETIME", "SYSDATETIMEOFFSET", "SYSUTCDATETIME", "TIMEFROMPARTS", "TODATETIMEOFFSET", "YEAR", "JSON", "ISJSON", "JSON_VALUE", "JSON_QUERY", "JSON_MODIFY"],
  mathematical: ["ABS", "ACOS", "ASIN", "ATAN", "ATN2", "CEILING", "COS", "COT", "DEGREES", "EXP", "FLOOR", "LOG", "LOG10", "PI", "POWER", "RADIANS", "RAND", "ROUND", "SIGN", "SIN", "SQRT", "SQUARE", "TAN", "CHOOSE", "GREATEST", "IIF", "LEAST"],
  metadata: ["@@PROCID", "APP_NAME", "APPLOCK_MODE", "APPLOCK_TEST", "ASSEMBLYPROPERTY", "COL_LENGTH", "COL_NAME", "COLUMNPROPERTY", "DATABASEPROPERTYEX", "DB_ID", "DB_NAME", "FILE_ID", "FILE_IDEX", "FILE_NAME", "FILEGROUP_ID", "FILEGROUP_NAME", "FILEGROUPPROPERTY", "FILEPROPERTY", "FILEPROPERTYEX", "FULLTEXTCATALOGPROPERTY", "FULLTEXTSERVICEPROPERTY", "INDEX_COL", "INDEXKEY_PROPERTY", "INDEXPROPERTY", "NEXT VALUE FOR", "OBJECT_DEFINITION", "OBJECT_ID", "OBJECT_NAME", "OBJECT_SCHEMA_NAME", "OBJECTPROPERTY", "OBJECTPROPERTYEX", "ORIGINAL_DB_NAME", "PARSENAME", "SCHEMA_ID", "SCHEMA_NAME", "SCOPE_IDENTITY", "SERVERPROPERTY", "STATS_DATE", "TYPE_ID", "TYPE_NAME", "TYPEPROPERTY"],
  ranking: ["DENSE_RANK", "NTILE", "RANK", "ROW_NUMBER", "PUBLISHINGSERVERNAME"],
  security: ["CERTENCODED", "CERTPRIVATEKEY", "CURRENT_USER", "DATABASE_PRINCIPAL_ID", "HAS_DBACCESS", "HAS_PERMS_BY_NAME", "IS_MEMBER", "IS_ROLEMEMBER", "IS_SRVROLEMEMBER", "LOGINPROPERTY", "ORIGINAL_LOGIN", "PERMISSIONS", "PWDENCRYPT", "PWDCOMPARE", "SESSION_USER", "SESSIONPROPERTY", "SUSER_ID", "SUSER_NAME", "SUSER_SID", "SUSER_SNAME", "SYSTEM_USER", "USER", "USER_ID", "USER_NAME"],
  string: ["ASCII", "CHAR", "CHARINDEX", "CONCAT", "CONCAT_WS", "DIFFERENCE", "FORMAT", "LEFT", "LEN", "LOWER", "LTRIM", "NCHAR", "PATINDEX", "QUOTENAME", "REPLACE", "REPLICATE", "REVERSE", "RIGHT", "RTRIM", "SOUNDEX", "SPACE", "STR", "STRING_AGG", "STRING_ESCAPE", "STUFF", "SUBSTRING", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
  system: ["$PARTITION", "@@ERROR", "@@IDENTITY", "@@PACK_RECEIVED", "@@ROWCOUNT", "@@TRANCOUNT", "BINARY_CHECKSUM", "CHECKSUM", "COMPRESS", "CONNECTIONPROPERTY", "CONTEXT_INFO", "CURRENT_REQUEST_ID", "CURRENT_TRANSACTION_ID", "DECOMPRESS", "ERROR_LINE", "ERROR_MESSAGE", "ERROR_NUMBER", "ERROR_PROCEDURE", "ERROR_SEVERITY", "ERROR_STATE", "FORMATMESSAGE", "GET_FILESTREAM_TRANSACTION_CONTEXT", "GETANSINULL", "HOST_ID", "HOST_NAME", "ISNULL", "ISNUMERIC", "MIN_ACTIVE_ROWVERSION", "NEWID", "NEWSEQUENTIALID", "ROWCOUNT_BIG", "SESSION_CONTEXT", "XACT_STATE"],
  statistical: ["@@CONNECTIONS", "@@CPU_BUSY", "@@IDLE", "@@IO_BUSY", "@@PACK_SENT", "@@PACKET_ERRORS", "@@TIMETICKS", "@@TOTAL_ERRORS", "@@TOTAL_READ", "@@TOTAL_WRITE", "TEXTPTR", "TEXTVALID"],
  trigger: ["COLUMNS_UPDATED", "EVENTDATA", "TRIGGER_NESTLEVEL", "UPDATE"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Parameterized types
  // https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
  dataTypes: ["DECIMAL", "NUMERIC", "FLOAT", "REAL", "DATETIME2", "DATETIMEOFFSET", "TIME", "CHAR", "VARCHAR", "NCHAR", "NVARCHAR", "BINARY", "VARBINARY"]
}), P2e = Ct({
  // https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?view=sql-server-ver15
  standard: ["ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BEGIN", "BETWEEN", "BREAK", "BROWSE", "BULK", "BY", "CASCADE", "CHECK", "CHECKPOINT", "CLOSE", "CLUSTERED", "COALESCE", "COLLATE", "COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", "CONTAINS", "CONTAINSTABLE", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", "DELETE", "DENY", "DESC", "DISK", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DROP", "DUMP", "ERRLVL", "ESCAPE", "EXEC", "EXECUTE", "EXISTS", "EXIT", "EXTERNAL", "FETCH", "FILE", "FILLFACTOR", "FOR", "FOREIGN", "FREETEXT", "FREETEXTTABLE", "FROM", "FULL", "FUNCTION", "GOTO", "GRANT", "GROUP", "HAVING", "HOLDLOCK", "IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", "IF", "IN", "INDEX", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "KEY", "KILL", "LEFT", "LIKE", "LINENO", "LOAD", "MERGE", "NATIONAL", "NOCHECK", "NONCLUSTERED", "NOT", "NULL", "NULLIF", "OF", "OFF", "OFFSETS", "ON", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", "OPTION", "OR", "ORDER", "OUTER", "OVER", "PERCENT", "PIVOT", "PLAN", "PRECISION", "PRIMARY", "PRINT", "PROC", "PROCEDURE", "PUBLIC", "RAISERROR", "READ", "READTEXT", "RECONFIGURE", "REFERENCES", "REPLICATION", "RESTORE", "RESTRICT", "RETURN", "REVERT", "REVOKE", "RIGHT", "ROLLBACK", "ROWCOUNT", "ROWGUIDCOL", "RULE", "SAVE", "SCHEMA", "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", "SEMANTICSIMILARITYTABLE", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", "SOME", "STATISTICS", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "TEXTSIZE", "THEN", "TO", "TOP", "TRAN", "TRANSACTION", "TRIGGER", "TRUNCATE", "TRY_CONVERT", "TSEQUAL", "UNION", "UNIQUE", "UNPIVOT", "UPDATE", "UPDATETEXT", "USE", "USER", "VALUES", "VARYING", "VIEW", "WAITFOR", "WHERE", "WHILE", "WITH", "WITHIN GROUP", "WRITETEXT"],
  odbc: ["ABSOLUTE", "ACTION", "ADA", "ADD", "ALL", "ALLOCATE", "ALTER", "AND", "ANY", "ARE", "AS", "ASC", "ASSERTION", "AT", "AUTHORIZATION", "AVG", "BEGIN", "BETWEEN", "BIT", "BIT_LENGTH", "BOTH", "BY", "CASCADE", "CASCADED", "CAST", "CATALOG", "CHAR", "CHARACTER", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHECK", "CLOSE", "COALESCE", "COLLATE", "COLLATION", "COLUMN", "COMMIT", "CONNECT", "CONNECTION", "CONSTRAINT", "CONSTRAINTS", "CONTINUE", "CONVERT", "CORRESPONDING", "COUNT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATE", "DAY", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DESCRIBE", "DESCRIPTOR", "DIAGNOSTICS", "DISCONNECT", "DISTINCT", "DOMAIN", "DOUBLE", "DROP", "END-EXEC", "ESCAPE", "EXCEPTION", "EXEC", "EXECUTE", "EXISTS", "EXTERNAL", "EXTRACT", "FALSE", "FETCH", "FIRST", "FLOAT", "FOR", "FOREIGN", "FORTRAN", "FOUND", "FROM", "FULL", "GET", "GLOBAL", "GO", "GOTO", "GRANT", "GROUP", "HAVING", "HOUR", "IDENTITY", "IMMEDIATE", "IN", "INCLUDE", "INDEX", "INDICATOR", "INITIALLY", "INNER", "INPUT", "INSENSITIVE", "INSERT", "INT", "INTEGER", "INTERSECT", "INTERVAL", "INTO", "IS", "ISOLATION", "JOIN", "KEY", "LANGUAGE", "LAST", "LEADING", "LEFT", "LEVEL", "LIKE", "LOCAL", "LOWER", "MATCH", "MAX", "MIN", "MINUTE", "MODULE", "MONTH", "NAMES", "NATIONAL", "NATURAL", "NCHAR", "NEXT", "NO", "NONE", "NOT", "NULL", "NULLIF", "NUMERIC", "OCTET_LENGTH", "OF", "ONLY", "OPEN", "OPTION", "OR", "ORDER", "OUTER", "OUTPUT", "OVERLAPS", "PAD", "PARTIAL", "PASCAL", "POSITION", "PRECISION", "PREPARE", "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURE", "PUBLIC", "READ", "REAL", "REFERENCES", "RELATIVE", "RESTRICT", "REVOKE", "RIGHT", "ROLLBACK", "ROWS", "SCHEMA", "SCROLL", "SECOND", "SECTION", "SELECT", "SESSION", "SESSION_USER", "SET", "SIZE", "SMALLINT", "SOME", "SPACE", "SQL", "SQLCA", "SQLCODE", "SQLERROR", "SQLSTATE", "SQLWARNING", "SUBSTRING", "SUM", "SYSTEM_USER", "TABLE", "TEMPORARY", "TIME", "TIMESTAMP", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TRANSLATION", "TRIM", "TRUE", "UNION", "UNIQUE", "UNKNOWN", "UPDATE", "UPPER", "USAGE", "USER", "VALUE", "VALUES", "VARCHAR", "VARYING", "VIEW", "WHENEVER", "WHERE", "WITH", "WORK", "WRITE", "YEAR", "ZONE"]
}), N2e = ie(["SELECT [ALL | DISTINCT]"]), L2e = ie([
  // queries
  "WITH",
  "INTO",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY TARGET | BY SOURCE] [THEN]",
  "UPDATE SET",
  // Data definition
  "CREATE [OR ALTER] [MATERIALIZED] VIEW",
  "CREATE TABLE",
  "CREATE [OR ALTER] {PROC | PROCEDURE}"
]), GB = ie([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP COLUMN [IF EXISTS]",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // https://docs.microsoft.com/en-us/sql/t-sql/statements/statements?view=sql-server-ver15
  "ADD SENSITIVITY CLASSIFICATION",
  "ADD SIGNATURE",
  "AGGREGATE",
  "ANSI_DEFAULTS",
  "ANSI_NULLS",
  "ANSI_NULL_DFLT_OFF",
  "ANSI_NULL_DFLT_ON",
  "ANSI_PADDING",
  "ANSI_WARNINGS",
  "APPLICATION ROLE",
  "ARITHABORT",
  "ARITHIGNORE",
  "ASSEMBLY",
  "ASYMMETRIC KEY",
  "AUTHORIZATION",
  "AVAILABILITY GROUP",
  "BACKUP",
  "BACKUP CERTIFICATE",
  "BACKUP MASTER KEY",
  "BACKUP SERVICE MASTER KEY",
  "BEGIN CONVERSATION TIMER",
  "BEGIN DIALOG CONVERSATION",
  "BROKER PRIORITY",
  "BULK INSERT",
  "CERTIFICATE",
  "CLOSE MASTER KEY",
  "CLOSE SYMMETRIC KEY",
  "COLLATE",
  "COLUMN ENCRYPTION KEY",
  "COLUMN MASTER KEY",
  "COLUMNSTORE INDEX",
  "CONCAT_NULL_YIELDS_NULL",
  "CONTEXT_INFO",
  "CONTRACT",
  "CREDENTIAL",
  "CRYPTOGRAPHIC PROVIDER",
  "CURSOR_CLOSE_ON_COMMIT",
  "DATABASE",
  "DATABASE AUDIT SPECIFICATION",
  "DATABASE ENCRYPTION KEY",
  "DATABASE HADR",
  "DATABASE SCOPED CONFIGURATION",
  "DATABASE SCOPED CREDENTIAL",
  "DATABASE SET",
  "DATEFIRST",
  "DATEFORMAT",
  "DEADLOCK_PRIORITY",
  "DENY",
  "DENY XML",
  "DISABLE TRIGGER",
  "ENABLE TRIGGER",
  "END CONVERSATION",
  "ENDPOINT",
  "EVENT NOTIFICATION",
  "EVENT SESSION",
  "EXECUTE AS",
  "EXTERNAL DATA SOURCE",
  "EXTERNAL FILE FORMAT",
  "EXTERNAL LANGUAGE",
  "EXTERNAL LIBRARY",
  "EXTERNAL RESOURCE POOL",
  "EXTERNAL TABLE",
  "FIPS_FLAGGER",
  "FMTONLY",
  "FORCEPLAN",
  "FULLTEXT CATALOG",
  "FULLTEXT INDEX",
  "FULLTEXT STOPLIST",
  "FUNCTION",
  "GET CONVERSATION GROUP",
  "GET_TRANSMISSION_STATUS",
  "GRANT",
  "GRANT XML",
  "IDENTITY_INSERT",
  "IMPLICIT_TRANSACTIONS",
  "INDEX",
  "LANGUAGE",
  "LOCK_TIMEOUT",
  "LOGIN",
  "MASTER KEY",
  "MESSAGE TYPE",
  "MOVE CONVERSATION",
  "NOCOUNT",
  "NOEXEC",
  "NUMERIC_ROUNDABORT",
  "OFFSETS",
  "OPEN MASTER KEY",
  "OPEN SYMMETRIC KEY",
  "PARSEONLY",
  "PARTITION FUNCTION",
  "PARTITION SCHEME",
  "PROCEDURE",
  "QUERY_GOVERNOR_COST_LIMIT",
  "QUEUE",
  "QUOTED_IDENTIFIER",
  "RECEIVE",
  "REMOTE SERVICE BINDING",
  "REMOTE_PROC_TRANSACTIONS",
  "RESOURCE GOVERNOR",
  "RESOURCE POOL",
  "RESTORE",
  "RESTORE FILELISTONLY",
  "RESTORE HEADERONLY",
  "RESTORE LABELONLY",
  "RESTORE MASTER KEY",
  "RESTORE REWINDONLY",
  "RESTORE SERVICE MASTER KEY",
  "RESTORE VERIFYONLY",
  "REVERT",
  "REVOKE",
  "REVOKE XML",
  "ROLE",
  "ROUTE",
  "ROWCOUNT",
  "RULE",
  "SCHEMA",
  "SEARCH PROPERTY LIST",
  "SECURITY POLICY",
  "SELECTIVE XML INDEX",
  "SEND",
  "SENSITIVITY CLASSIFICATION",
  "SEQUENCE",
  "SERVER AUDIT",
  "SERVER AUDIT SPECIFICATION",
  "SERVER CONFIGURATION",
  "SERVER ROLE",
  "SERVICE",
  "SERVICE MASTER KEY",
  "SETUSER",
  "SHOWPLAN_ALL",
  "SHOWPLAN_TEXT",
  "SHOWPLAN_XML",
  "SIGNATURE",
  "SPATIAL INDEX",
  "STATISTICS",
  "STATISTICS IO",
  "STATISTICS PROFILE",
  "STATISTICS TIME",
  "STATISTICS XML",
  "SYMMETRIC KEY",
  "SYNONYM",
  "TABLE",
  "TABLE IDENTITY",
  "TEXTSIZE",
  "TRANSACTION ISOLATION LEVEL",
  "TRIGGER",
  "TYPE",
  "UPDATE STATISTICS",
  "USER",
  "WORKLOAD GROUP",
  "XACT_ABORT",
  "XML INDEX",
  "XML SCHEMA COLLECTION"
]), D2e = ie(["UNION [ALL]", "EXCEPT", "INTERSECT"]), M2e = ie([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]), k2e = ie(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]), Q2e = {
  tokenizerOptions: {
    reservedSelect: N2e,
    reservedClauses: [...L2e, ...GB],
    reservedSetOperations: D2e,
    reservedJoins: M2e,
    reservedPhrases: k2e,
    reservedKeywords: P2e,
    reservedFunctionNames: w2e,
    nestedBlockComments: !0,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["N"]
    }],
    identTypes: ['""-qq', "[]"],
    identChars: {
      first: "#@",
      rest: "#@$"
    },
    paramTypes: {
      named: ["@"],
      quoted: ["@"]
    },
    operators: ["%", "&", "|", "^", "~", "!<", "!>", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "^=", "::"]
    // TODO: Support for money constants
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: GB
  }
}, U2e = Ct({
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/restricted-keywords/list-of-restricted-keywords.html
  all: ["ABORT", "ABSOLUTE", "ACCESS", "ACCESSIBLE", "ACCOUNT", "ACTION", "ACTIVE", "ADD", "ADMIN", "AFTER", "AGAINST", "AGGREGATE", "AGGREGATES", "AGGREGATOR", "AGGREGATOR_ID", "AGGREGATOR_PLAN_HASH", "AGGREGATORS", "ALGORITHM", "ALL", "ALSO", "ALTER", "ALWAYS", "ANALYZE", "AND", "ANY", "ARGHISTORY", "ARRANGE", "ARRANGEMENT", "ARRAY", "AS", "ASC", "ASCII", "ASENSITIVE", "ASM", "ASSERTION", "ASSIGNMENT", "AST", "ASYMMETRIC", "ASYNC", "AT", "ATTACH", "ATTRIBUTE", "AUTHORIZATION", "AUTO", "AUTO_INCREMENT", "AUTO_REPROVISION", "AUTOSTATS", "AUTOSTATS_CARDINALITY_MODE", "AUTOSTATS_ENABLED", "AUTOSTATS_HISTOGRAM_MODE", "AUTOSTATS_SAMPLING", "AVAILABILITY", "AVG", "AVG_ROW_LENGTH", "AVRO", "AZURE", "BACKGROUND", "_BACKGROUND_THREADS_FOR_CLEANUP", "BACKUP", "BACKUP_HISTORY", "BACKUP_ID", "BACKWARD", "BATCH", "BATCHES", "BATCH_INTERVAL", "_BATCH_SIZE_LIMIT", "BEFORE", "BEGIN", "BETWEEN", "BIGINT", "BINARY", "_BINARY", "BIT", "BLOB", "BOOL", "BOOLEAN", "BOOTSTRAP", "BOTH", "_BT", "BTREE", "BUCKET_COUNT", "BUCKETS", "BY", "BYTE", "BYTE_LENGTH", "CACHE", "CALL", "CALL_FOR_PIPELINE", "CALLED", "CAPTURE", "CASCADE", "CASCADED", "CASE", "CATALOG", "CHAIN", "CHANGE", "CHAR", "CHARACTER", "CHARACTERISTICS", "CHARSET", "CHECK", "CHECKPOINT", "_CHECK_CAN_CONNECT", "_CHECK_CONSISTENCY", "CHECKSUM", "_CHECKSUM", "CLASS", "CLEAR", "CLIENT", "CLIENT_FOUND_ROWS", "CLOSE", "CLUSTER", "CLUSTERED", "CNF", "COALESCE", "COLLATE", "COLLATION", "COLUMN", "COLUMNAR", "COLUMNS", "COLUMNSTORE", "COLUMNSTORE_SEGMENT_ROWS", "COMMENT", "COMMENTS", "COMMIT", "COMMITTED", "_COMMIT_LOG_TAIL", "COMPACT", "COMPILE", "COMPRESSED", "COMPRESSION", "CONCURRENT", "CONCURRENTLY", "CONDITION", "CONFIGURATION", "CONNECTION", "CONNECTIONS", "CONFIG", "CONSTRAINT", "CONTAINS", "CONTENT", "CONTINUE", "_CONTINUE_REPLAY", "CONVERSION", "CONVERT", "COPY", "_CORE", "COST", "CREATE", "CREDENTIALS", "CROSS", "CUBE", "CSV", "CUME_DIST", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_SCHEMA", "CURRENT_SECURITY_GROUPS", "CURRENT_SECURITY_ROLES", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DATABASES", "DATE", "DATETIME", "DAY", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFAULTS", "DEFERRABLE", "DEFERRED", "DEFINED", "DEFINER", "DELAYED", "DELAY_KEY_WRITE", "DELETE", "DELIMITER", "DELIMITERS", "DENSE_RANK", "DESC", "DESCRIBE", "DETACH", "DETERMINISTIC", "DICTIONARY", "DIFFERENTIAL", "DIRECTORY", "DISABLE", "DISCARD", "_DISCONNECT", "DISK", "DISTINCT", "DISTINCTROW", "DISTRIBUTED_JOINS", "DIV", "DO", "DOCUMENT", "DOMAIN", "DOUBLE", "DROP", "_DROP_PROFILE", "DUAL", "DUMP", "DUPLICATE", "DURABILITY", "DYNAMIC", "EARLIEST", "EACH", "ECHO", "ELECTION", "ELSE", "ELSEIF", "ENABLE", "ENCLOSED", "ENCODING", "ENCRYPTED", "END", "ENGINE", "ENGINES", "ENUM", "ERRORS", "ESCAPE", "ESCAPED", "ESTIMATE", "EVENT", "EVENTS", "EXCEPT", "EXCLUDE", "EXCLUDING", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTENDED", "EXTENSION", "EXTERNAL", "EXTERNAL_HOST", "EXTERNAL_PORT", "EXTRACTOR", "EXTRACTORS", "EXTRA_JOIN", "_FAILOVER", "FAILED_LOGIN_ATTEMPTS", "FAILURE", "FALSE", "FAMILY", "FAULT", "FETCH", "FIELDS", "FILE", "FILES", "FILL", "FIX_ALTER", "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FORCE_COMPILED_MODE", "FORCE_INTERPRETER_MODE", "FOREGROUND", "FOREIGN", "FORMAT", "FORWARD", "FREEZE", "FROM", "FS", "_FSYNC", "FULL", "FULLTEXT", "FUNCTION", "FUNCTIONS", "GC", "GCS", "GET_FORMAT", "_GC", "_GCX", "GENERATE", "GEOGRAPHY", "GEOGRAPHYPOINT", "GEOMETRY", "GEOMETRYPOINT", "GLOBAL", "_GLOBAL_VERSION_TIMESTAMP", "GRANT", "GRANTED", "GRANTS", "GROUP", "GROUPING", "GROUPS", "GZIP", "HANDLE", "HANDLER", "HARD_CPU_LIMIT_PERCENTAGE", "HASH", "HAS_TEMP_TABLES", "HAVING", "HDFS", "HEADER", "HEARTBEAT_NO_LOGGING", "HIGH_PRIORITY", "HISTOGRAM", "HOLD", "HOLDING", "HOST", "HOSTS", "HOUR", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IDENTIFIED", "IDENTITY", "IF", "IGNORE", "ILIKE", "IMMEDIATE", "IMMUTABLE", "IMPLICIT", "IMPORT", "IN", "INCLUDING", "INCREMENT", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INHERIT", "INHERITS", "_INIT_PROFILE", "INIT", "INITIALIZE", "INITIALLY", "INJECT", "INLINE", "INNER", "INOUT", "INPUT", "INSENSITIVE", "INSERT", "INSERT_METHOD", "INSTANCE", "INSTEAD", "IN", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "_INTERNAL_DYNAMIC_TYPECAST", "INTERPRETER_MODE", "INTERSECT", "INTERVAL", "INTO", "INVOKER", "ISOLATION", "ITERATE", "JOIN", "JSON", "KAFKA", "KEY", "KEY_BLOCK_SIZE", "KEYS", "KILL", "KILLALL", "LABEL", "LAG", "LANGUAGE", "LARGE", "LAST", "LAST_VALUE", "LATERAL", "LATEST", "LC_COLLATE", "LC_CTYPE", "LEAD", "LEADING", "LEAF", "LEAKPROOF", "LEAVE", "LEAVES", "LEFT", "LEVEL", "LICENSE", "LIKE", "LIMIT", "LINES", "LISTEN", "LLVM", "LOADDATA_WHERE", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATION", "LOCK", "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY", "_LS", "LZ4", "MANAGEMENT", "_MANAGEMENT_THREAD", "MAPPING", "MASTER", "MATCH", "MATERIALIZED", "MAXVALUE", "MAX_CONCURRENCY", "MAX_ERRORS", "MAX_PARTITIONS_PER_BATCH", "MAX_QUEUE_DEPTH", "MAX_RETRIES_PER_BATCH_PARTITION", "MAX_ROWS", "MBC", "MPL", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MEMBER", "MEMORY", "MEMORY_PERCENTAGE", "_MEMSQL_TABLE_ID_LOOKUP", "MEMSQL", "MEMSQL_DESERIALIZE", "MEMSQL_IMITATING_KAFKA", "MEMSQL_SERIALIZE", "MERGE", "METADATA", "MICROSECOND", "MIDDLEINT", "MIN_ROWS", "MINUS", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MINVALUE", "MOD", "MODE", "MODEL", "MODIFIES", "MODIFY", "MONTH", "MOVE", "MPL", "NAMES", "NAMED", "NAMESPACE", "NATIONAL", "NATURAL", "NCHAR", "NEXT", "NO", "NODE", "NONE", "NO_QUERY_REWRITE", "NOPARAM", "NOT", "NOTHING", "NOTIFY", "NOWAIT", "NO_WRITE_TO_BINLOG", "NO_QUERY_REWRITE", "NORELY", "NTH_VALUE", "NTILE", "NULL", "NULLCOLS", "NULLS", "NUMERIC", "NVARCHAR", "OBJECT", "OF", "OFF", "OFFLINE", "OFFSET", "OFFSETS", "OIDS", "ON", "ONLINE", "ONLY", "OPEN", "OPERATOR", "OPTIMIZATION", "OPTIMIZE", "OPTIMIZER", "OPTIMIZER_STATE", "OPTION", "OPTIONS", "OPTIONALLY", "OR", "ORDER", "ORDERED_SERIALIZE", "ORPHAN", "OUT", "OUT_OF_ORDER", "OUTER", "OUTFILE", "OVER", "OVERLAPS", "OVERLAY", "OWNED", "OWNER", "PACK_KEYS", "PAIRED", "PARSER", "PARQUET", "PARTIAL", "PARTITION", "PARTITION_ID", "PARTITIONING", "PARTITIONS", "PASSING", "PASSWORD", "PASSWORD_LOCK_TIME", "PAUSE", "_PAUSE_REPLAY", "PERIODIC", "PERSISTED", "PIPELINE", "PIPELINES", "PLACING", "PLAN", "PLANS", "PLANCACHE", "PLUGINS", "POOL", "POOLS", "PORT", "PRECEDING", "PRECISION", "PREPARE", "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURAL", "PROCEDURE", "PROCEDURES", "PROCESS", "PROCESSLIST", "PROFILE", "PROFILES", "PROGRAM", "PROMOTE", "PROXY", "PURGE", "QUARTER", "QUERIES", "QUERY", "QUERY_TIMEOUT", "QUEUE", "RANGE", "RANK", "READ", "_READ", "READS", "REAL", "REASSIGN", "REBALANCE", "RECHECK", "RECORD", "RECURSIVE", "REDUNDANCY", "REDUNDANT", "REF", "REFERENCE", "REFERENCES", "REFRESH", "REGEXP", "REINDEX", "RELATIVE", "RELEASE", "RELOAD", "RELY", "REMOTE", "REMOVE", "RENAME", "REPAIR", "_REPAIR_TABLE", "REPEAT", "REPEATABLE", "_REPL", "_REPROVISIONING", "REPLACE", "REPLICA", "REPLICATE", "REPLICATING", "REPLICATION", "REQUIRE", "RESOURCE", "RESOURCE_POOL", "RESET", "RESTART", "RESTORE", "RESTRICT", "RESULT", "_RESURRECT", "RETRY", "RETURN", "RETURNING", "RETURNS", "REVERSE", "RG_POOL", "REVOKE", "RIGHT", "RIGHT_ANTI_JOIN", "RIGHT_SEMI_JOIN", "RIGHT_STRAIGHT_JOIN", "RLIKE", "ROLES", "ROLLBACK", "ROLLUP", "ROUTINE", "ROW", "ROW_COUNT", "ROW_FORMAT", "ROW_NUMBER", "ROWS", "ROWSTORE", "RULE", "_RPC", "RUNNING", "S3", "SAFE", "SAVE", "SAVEPOINT", "SCALAR", "SCHEMA", "SCHEMAS", "SCHEMA_BINDING", "SCROLL", "SEARCH", "SECOND", "SECOND_MICROSECOND", "SECURITY", "SELECT", "SEMI_JOIN", "_SEND_THREADS", "SENSITIVE", "SEPARATOR", "SEQUENCE", "SEQUENCES", "SERIAL", "SERIALIZABLE", "SERIES", "SERVICE_USER", "SERVER", "SESSION", "SESSION_USER", "SET", "SETOF", "SECURITY_LISTS_INTERSECT", "SHA", "SHARD", "SHARDED", "SHARDED_ID", "SHARE", "SHOW", "SHUTDOWN", "SIGNAL", "SIGNED", "SIMILAR", "SIMPLE", "SITE", "SKIP", "SKIPPED_BATCHES", "__SLEEP", "SMALLINT", "SNAPSHOT", "_SNAPSHOT", "_SNAPSHOTS", "SOFT_CPU_LIMIT_PERCENTAGE", "SOME", "SONAME", "SPARSE", "SPATIAL", "SPATIAL_CHECK_INDEX", "SPECIFIC", "SQL", "SQL_BIG_RESULT", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS", "SQLEXCEPTION", "SQL_MODE", "SQL_NO_CACHE", "SQL_NO_LOGGING", "SQL_SMALL_RESULT", "SQLSTATE", "SQLWARNING", "STDIN", "STDOUT", "STOP", "STORAGE", "STRAIGHT_JOIN", "STRICT", "STRING", "STRIP", "SUCCESS", "SUPER", "SYMMETRIC", "SYNC_SNAPSHOT", "SYNC", "_SYNC", "_SYNC2", "_SYNC_PARTITIONS", "_SYNC_SNAPSHOT", "SYNCHRONIZE", "SYSID", "SYSTEM", "TABLE", "TABLE_CHECKSUM", "TABLES", "TABLESPACE", "TAGS", "TARGET_SIZE", "TASK", "TEMP", "TEMPLATE", "TEMPORARY", "TEMPTABLE", "_TERM_BUMP", "TERMINATE", "TERMINATED", "TEXT", "THEN", "TIME", "TIMEOUT", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIMEZONE", "TINYBLOB", "TINYINT", "TINYTEXT", "TO", "TRACELOGS", "TRADITIONAL", "TRAILING", "TRANSFORM", "TRANSACTION", "_TRANSACTIONS_EXPERIMENTAL", "TREAT", "TRIGGER", "TRIGGERS", "TRUE", "TRUNC", "TRUNCATE", "TRUSTED", "TWO_PHASE", "_TWOPCID", "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNDEFINED", "UNDO", "UNENCRYPTED", "UNENFORCED", "UNHOLD", "UNICODE", "UNION", "UNIQUE", "_UNITTEST", "UNKNOWN", "UNLISTEN", "_UNLOAD", "UNLOCK", "UNLOGGED", "UNPIVOT", "UNSIGNED", "UNTIL", "UPDATE", "UPGRADE", "USAGE", "USE", "USER", "USERS", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "_UTF8", "VACUUM", "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARCHARACTER", "VARIABLES", "VARIADIC", "VARYING", "VERBOSE", "VIEW", "VOID", "VOLATILE", "VOTING", "WAIT", "_WAKE", "WARNINGS", "WEEK", "WHEN", "WHERE", "WHILE", "WHITESPACE", "WINDOW", "WITH", "WITHOUT", "WITHIN", "_WM_HEARTBEAT", "WORK", "WORKLOAD", "WRAPPER", "WRITE", "XACT_ID", "XOR", "YEAR", "YEAR_MONTH", "YES", "ZEROFILL", "ZONE"]
}), $2e = Ct({
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/vector-functions/vector-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/window-functions/window-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/string-functions/string-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/conditional-functions/conditional-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/numeric-functions/numeric-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/geospatial-functions/geospatial-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/json-functions/json-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/information-functions/information-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/aggregate-functions/aggregate-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/time-series-functions/time-series-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/identifier-generation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/date-and-time-functions/date-and-time-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/distinct-count-estimation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/full-text-search-functions/full-text-search-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/regular-expression-functions.html
  all: [
    "ABS",
    "ACOS",
    "ADDDATE",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    "ANY_VALUE",
    "APPROX_COUNT_DISTINCT",
    "APPROX_COUNT_DISTINCT_ACCUMULATE",
    "APPROX_COUNT_DISTINCT_COMBINE",
    "APPROX_COUNT_DISTINCT_ESTIMATE",
    "APPROX_GEOGRAPHY_INTERSECTS",
    "APPROX_PERCENTILE",
    "ASCII",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BIN",
    "BINARY",
    "BIT_AND",
    "BIT_COUNT",
    "BIT_OR",
    "BIT_XOR",
    "CAST",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHARACTER_LENGTH",
    "CHAR_LENGTH",
    "CHARSET",
    "COALESCE",
    "COERCIBILITY",
    "COLLATION",
    "COLLECT",
    "CONCAT",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT",
    "CONVERT_TZ",
    "COS",
    "COT",
    "COUNT",
    "CUME_DIST",
    "CURDATE",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURTIME",
    "DATABASE",
    "DATE",
    "DATE_ADD",
    "DATEDIFF",
    "DATE_FORMAT",
    "DATE_SUB",
    "DATE_TRUNC",
    "DAY",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DECODE",
    "DEFAULT",
    "DEGREES",
    "DENSE_RANK",
    "DIV",
    "DOT_PRODUCT",
    "ELT",
    "EUCLIDEAN_DISTANCE",
    "EXP",
    "EXTRACT",
    "FIELD",
    "FIRST",
    "FIRST_VALUE",
    "FLOOR",
    "FORMAT",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GEOGRAPHY_AREA",
    "GEOGRAPHY_CONTAINS",
    "GEOGRAPHY_DISTANCE",
    "GEOGRAPHY_INTERSECTS",
    "GEOGRAPHY_LATITUDE",
    "GEOGRAPHY_LENGTH",
    "GEOGRAPHY_LONGITUDE",
    "GEOGRAPHY_POINT",
    "GEOGRAPHY_WITHIN_DISTANCE",
    "GEOMETRY_AREA",
    "GEOMETRY_CONTAINS",
    "GEOMETRY_DISTANCE",
    "GEOMETRY_FILTER",
    "GEOMETRY_INTERSECTS",
    "GEOMETRY_LENGTH",
    "GEOMETRY_POINT",
    "GEOMETRY_WITHIN_DISTANCE",
    "GEOMETRY_X",
    "GEOMETRY_Y",
    "GREATEST",
    "GROUPING",
    "GROUP_CONCAT",
    "HEX",
    "HIGHLIGHT",
    "HOUR",
    "ICU_VERSION",
    "IF",
    "IFNULL",
    "INET_ATON",
    "INET_NTOA",
    "INET6_ATON",
    "INET6_NTOA",
    "INITCAP",
    "INSERT",
    "INSTR",
    "INTERVAL",
    "IS",
    "IS NULL",
    "JSON_AGG",
    "JSON_ARRAY_CONTAINS_DOUBLE",
    "JSON_ARRAY_CONTAINS_JSON",
    "JSON_ARRAY_CONTAINS_STRING",
    "JSON_ARRAY_PUSH_DOUBLE",
    "JSON_ARRAY_PUSH_JSON",
    "JSON_ARRAY_PUSH_STRING",
    "JSON_DELETE_KEY",
    "JSON_EXTRACT_DOUBLE",
    "JSON_EXTRACT_JSON",
    "JSON_EXTRACT_STRING",
    "JSON_EXTRACT_BIGINT",
    "JSON_GET_TYPE",
    "JSON_LENGTH",
    "JSON_SET_DOUBLE",
    "JSON_SET_JSON",
    "JSON_SET_STRING",
    "JSON_SPLICE_DOUBLE",
    "JSON_SPLICE_JSON",
    "JSON_SPLICE_STRING",
    "LAG",
    "LAST_DAY",
    "LAST_VALUE",
    "LCASE",
    "LEAD",
    "LEAST",
    "LEFT",
    "LENGTH",
    "LIKE",
    "LN",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LPAD",
    "LTRIM",
    "MATCH",
    "MAX",
    "MD5",
    "MEDIAN",
    "MICROSECOND",
    "MIN",
    "MINUTE",
    "MOD",
    "MONTH",
    "MONTHNAME",
    "MONTHS_BETWEEN",
    "NOT",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "OCTET_LENGTH",
    "PERCENT_RANK",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "PI",
    "PIVOT",
    "POSITION",
    "POW",
    "POWER",
    "QUARTER",
    "QUOTE",
    "RADIANS",
    "RAND",
    "RANK",
    "REGEXP",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RLIKE",
    "ROUND",
    "ROW_COUNT",
    "ROW_NUMBER",
    "RPAD",
    "RTRIM",
    "SCALAR",
    "SCHEMA",
    "SEC_TO_TIME",
    "SHA1",
    "SHA2",
    "SIGMOID",
    "SIGN",
    "SIN",
    "SLEEP",
    "SPLIT",
    "SOUNDEX",
    "SOUNDS LIKE",
    "SOURCE_POS_WAIT",
    "SPACE",
    "SQRT",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DATE",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "SUM",
    "SYS_GUID",
    "TAN",
    "TIME",
    "TIMEDIFF",
    "TIME_BUCKET",
    "TIME_FORMAT",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TIME_TO_SEC",
    "TO_BASE64",
    "TO_CHAR",
    "TO_DAYS",
    "TO_JSON",
    "TO_NUMBER",
    "TO_SECONDS",
    "TO_TIMESTAMP",
    "TRIM",
    "TRUNC",
    "TRUNCATE",
    "UCASE",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "USER",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "UUID",
    "VALUES",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "VECTOR_SUB",
    "VERSION",
    "WEEK",
    "WEEKDAY",
    "WEEKOFYEAR",
    "YEAR",
    // Data types with parameters
    // https://docs.singlestore.com/managed-service/en/reference/sql-reference/data-types.html
    "BIT",
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "DATETIME",
    "TIMESTAMP",
    "TIME",
    "YEAR",
    "CHAR",
    "NATIONAL CHAR",
    "VARCHAR",
    "NATIONAL VARCHAR",
    "BINARY",
    "VARBINARY",
    "BLOB",
    "TEXT",
    "ENUM"
  ]
}), G2e = ie(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), B2e = ie([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [IGNORE] [INTO]",
  "VALUES",
  "REPLACE [INTO]",
  // - update:
  "SET",
  // Data definition
  "CREATE VIEW",
  "CREATE [ROWSTORE] [REFERENCE | TEMPORARY | GLOBAL TEMPORARY] TABLE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMPORARY] PROCEDURE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [EXTERNAL] FUNCTION"
]), BB = ie([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] TABLE",
  "ADD [COLUMN]",
  "ADD [UNIQUE] {INDEX | KEY}",
  "DROP [COLUMN]",
  "MODIFY [COLUMN]",
  "CHANGE",
  "RENAME [TO | AS]",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference.html
  "ADD AGGREGATOR",
  "ADD LEAF",
  "AGGREGATOR SET AS MASTER",
  "ALTER DATABASE",
  "ALTER PIPELINE",
  "ALTER RESOURCE POOL",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "ATTACH DATABASE",
  "ATTACH LEAF",
  "ATTACH LEAF ALL",
  "BACKUP DATABASE",
  "BINLOG",
  "BOOTSTRAP AGGREGATOR",
  "CACHE INDEX",
  "CALL",
  "CHANGE",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK BLOB CHECKSUM",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLEAR ORPHAN DATABASES",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE GROUP",
  "CREATE INDEX",
  "CREATE LINK",
  "CREATE MILESTONE",
  "CREATE PIPELINE",
  "CREATE RESOURCE POOL",
  "CREATE ROLE",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DETACH DATABASE",
  "DETACH PIPELINE",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LINK",
  "DROP PIPELINE",
  "DROP PROCEDURE",
  "DROP RESOURCE POOL",
  "DROP ROLE",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "FORCE",
  "GRANT",
  "HANDLER",
  "HELP",
  "KILL CONNECTION",
  "KILLALL QUERIES",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "REBALANCE PARTITIONS",
  "RELEASE SAVEPOINT",
  "REMOVE AGGREGATOR",
  "REMOVE LEAF",
  "REPAIR TABLE",
  "REPLACE",
  "REPLICATE DATABASE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "RESTORE DATABASE",
  "RESTORE REDUNDANCY",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PIPELINE",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SNAPSHOT DATABASE",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START PIPELINE",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP PIPELINE",
  "STOP REPLICA",
  "STOP REPLICATING",
  "STOP SLAVE",
  "TEST PIPELINE",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]), V2e = ie(["UNION [ALL | DISTINCT]", "EXCEPT", "INTERSECT", "MINUS"]), F2e = ie([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), X2e = ie(["ON DELETE", "ON UPDATE", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), Y2e = {
  tokenizerOptions: {
    reservedSelect: G2e,
    reservedClauses: [...B2e, ...BB],
    reservedSetOperations: V2e,
    reservedJoins: F2e,
    reservedPhrases: X2e,
    reservedKeywords: U2e,
    reservedFunctionNames: $2e,
    // TODO: support _binary"some string" prefix
    stringTypes: ['""-qq-bs', "''-qq-bs", {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_$]+"
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    lineCommentTypes: ["--", "#"],
    operators: [":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "::", "::$", "::%", ":>", "!:>"],
    postProcess: H2e
  },
  formatOptions: {
    alwaysDenseOperators: ["::", "::$", "::%"],
    onelineClauses: BB
  }
};
function H2e(r) {
  return r.map((e, t) => {
    const i = r[t + 1] || hh;
    return ml.SET(e) && i.text === "(" ? {
      ...e,
      type: te.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const W2e = Ct({
  // https://docs.snowflake.com/en/sql-reference-functions.html
  //
  // https://docs.snowflake.com/en/sql-reference/functions-all.html
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. split all lines that contain ',' or '/' into multiple lines
  // 3. remove all ' Deprecated' parts from the strings
  // 4. delete all strings that end with '<object_type>', they are already covered in the list
  // 5. remove all strings that contain '[', they are operators not functions
  // 6. fix all values that contain '*'
  // 7. delete operatos ':', '::', '||'
  //
  // Steps 1-5 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   .map(x => x.split(x.includes(',') ? ',' : '/')).flat().map(x => x.trim()) // Step 2
  //   .map(x => x.replace(' Deprecated', '')) // Step 3
  //   .filter(x => !x.endsWith('<object_type>')) // Step 4
  //   .filter(x => !x.includes('[')) // Step 5
  all: ["ABS", "ACOS", "ACOSH", "ADD_MONTHS", "ALL_USER_NAMES", "ANY_VALUE", "APPROX_COUNT_DISTINCT", "APPROX_PERCENTILE", "APPROX_PERCENTILE_ACCUMULATE", "APPROX_PERCENTILE_COMBINE", "APPROX_PERCENTILE_ESTIMATE", "APPROX_TOP_K", "APPROX_TOP_K_ACCUMULATE", "APPROX_TOP_K_COMBINE", "APPROX_TOP_K_ESTIMATE", "APPROXIMATE_JACCARD_INDEX", "APPROXIMATE_SIMILARITY", "ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_COMPACT", "ARRAY_CONSTRUCT", "ARRAY_CONSTRUCT_COMPACT", "ARRAY_CONTAINS", "ARRAY_INSERT", "ARRAY_INTERSECTION", "ARRAY_POSITION", "ARRAY_PREPEND", "ARRAY_SIZE", "ARRAY_SLICE", "ARRAY_TO_STRING", "ARRAY_UNION_AGG", "ARRAY_UNIQUE_AGG", "ARRAYS_OVERLAP", "AS_ARRAY", "AS_BINARY", "AS_BOOLEAN", "AS_CHAR", "AS_VARCHAR", "AS_DATE", "AS_DECIMAL", "AS_NUMBER", "AS_DOUBLE", "AS_REAL", "AS_INTEGER", "AS_OBJECT", "AS_TIME", "AS_TIMESTAMP_LTZ", "AS_TIMESTAMP_NTZ", "AS_TIMESTAMP_TZ", "ASCII", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "AUTO_REFRESH_REGISTRATION_HISTORY", "AUTOMATIC_CLUSTERING_HISTORY", "AVG", "BASE64_DECODE_BINARY", "BASE64_DECODE_STRING", "BASE64_ENCODE", "BIT_LENGTH", "BITAND", "BITAND_AGG", "BITMAP_BIT_POSITION", "BITMAP_BUCKET_NUMBER", "BITMAP_CONSTRUCT_AGG", "BITMAP_COUNT", "BITMAP_OR_AGG", "BITNOT", "BITOR", "BITOR_AGG", "BITSHIFTLEFT", "BITSHIFTRIGHT", "BITXOR", "BITXOR_AGG", "BOOLAND", "BOOLAND_AGG", "BOOLNOT", "BOOLOR", "BOOLOR_AGG", "BOOLXOR", "BOOLXOR_AGG", "BUILD_SCOPED_FILE_URL", "BUILD_STAGE_FILE_URL", "CASE", "CAST", "CBRT", "CEIL", "CHARINDEX", "CHECK_JSON", "CHECK_XML", "CHR", "CHAR", "COALESCE", "COLLATE", "COLLATION", "COMPLETE_TASK_GRAPHS", "COMPRESS", "CONCAT", "CONCAT_WS", "CONDITIONAL_CHANGE_EVENT", "CONDITIONAL_TRUE_EVENT", "CONTAINS", "CONVERT_TIMEZONE", "COPY_HISTORY", "CORR", "COS", "COSH", "COT", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "CURRENT_ACCOUNT", "CURRENT_AVAILABLE_ROLES", "CURRENT_CLIENT", "CURRENT_DATABASE", "CURRENT_DATE", "CURRENT_IP_ADDRESS", "CURRENT_REGION", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_SECONDARY_ROLES", "CURRENT_SESSION", "CURRENT_STATEMENT", "CURRENT_TASK_GRAPHS", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TRANSACTION", "CURRENT_USER", "CURRENT_VERSION", "CURRENT_WAREHOUSE", "DATA_TRANSFER_HISTORY", "DATABASE_REFRESH_HISTORY", "DATABASE_REFRESH_PROGRESS", "DATABASE_REFRESH_PROGRESS_BY_JOB", "DATABASE_STORAGE_USAGE_HISTORY", "DATE_FROM_PARTS", "DATE_PART", "DATE_TRUNC", "DATEADD", "DATEDIFF", "DAYNAME", "DECODE", "DECOMPRESS_BINARY", "DECOMPRESS_STRING", "DECRYPT", "DECRYPT_RAW", "DEGREES", "DENSE_RANK", "DIV0", "EDITDISTANCE", "ENCRYPT", "ENCRYPT_RAW", "ENDSWITH", "EQUAL_NULL", "EXP", "EXPLAIN_JSON", "EXTERNAL_FUNCTIONS_HISTORY", "EXTERNAL_TABLE_FILES", "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY", "EXTRACT", "EXTRACT_SEMANTIC_CATEGORIES", "FACTORIAL", "FIRST_VALUE", "FLATTEN", "FLOOR", "GENERATE_COLUMN_DESCRIPTION", "GENERATOR", "GET", "GET_ABSOLUTE_PATH", "GET_DDL", "GET_IGNORE_CASE", "GET_OBJECT_REFERENCES", "GET_PATH", "GET_PRESIGNED_URL", "GET_RELATIVE_PATH", "GET_STAGE_LOCATION", "GETBIT", "GREATEST", "GROUPING", "GROUPING_ID", "HASH", "HASH_AGG", "HAVERSINE", "HEX_DECODE_BINARY", "HEX_DECODE_STRING", "HEX_ENCODE", "HLL", "HLL_ACCUMULATE", "HLL_COMBINE", "HLL_ESTIMATE", "HLL_EXPORT", "HLL_IMPORT", "HOUR", "MINUTE", "SECOND", "IFF", "IFNULL", "ILIKE", "ILIKE ANY", "INFER_SCHEMA", "INITCAP", "INSERT", "INVOKER_ROLE", "INVOKER_SHARE", "IS_ARRAY", "IS_BINARY", "IS_BOOLEAN", "IS_CHAR", "IS_VARCHAR", "IS_DATE", "IS_DATE_VALUE", "IS_DECIMAL", "IS_DOUBLE", "IS_REAL", "IS_GRANTED_TO_INVOKER_ROLE", "IS_INTEGER", "IS_NULL_VALUE", "IS_OBJECT", "IS_ROLE_IN_SESSION", "IS_TIME", "IS_TIMESTAMP_LTZ", "IS_TIMESTAMP_NTZ", "IS_TIMESTAMP_TZ", "JAROWINKLER_SIMILARITY", "JSON_EXTRACT_PATH_TEXT", "KURTOSIS", "LAG", "LAST_DAY", "LAST_QUERY_ID", "LAST_TRANSACTION", "LAST_VALUE", "LEAD", "LEAST", "LEFT", "LENGTH", "LEN", "LIKE", "LIKE ALL", "LIKE ANY", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOGIN_HISTORY", "LOGIN_HISTORY_BY_USER", "LOWER", "LPAD", "LTRIM", "MATERIALIZED_VIEW_REFRESH_HISTORY", "MD5", "MD5_HEX", "MD5_BINARY", "MD5_NUMBER  Obsoleted", "MD5_NUMBER_LOWER64", "MD5_NUMBER_UPPER64", "MEDIAN", "MIN", "MAX", "MINHASH", "MINHASH_COMBINE", "MOD", "MODE", "MONTHNAME", "MONTHS_BETWEEN", "NEXT_DAY", "NORMAL", "NTH_VALUE", "NTILE", "NULLIF", "NULLIFZERO", "NVL", "NVL2", "OBJECT_AGG", "OBJECT_CONSTRUCT", "OBJECT_CONSTRUCT_KEEP_NULL", "OBJECT_DELETE", "OBJECT_INSERT", "OBJECT_KEYS", "OBJECT_PICK", "OCTET_LENGTH", "PARSE_IP", "PARSE_JSON", "PARSE_URL", "PARSE_XML", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "PI", "PIPE_USAGE_HISTORY", "POLICY_CONTEXT", "POLICY_REFERENCES", "POSITION", "POW", "POWER", "PREVIOUS_DAY", "QUERY_ACCELERATION_HISTORY", "QUERY_HISTORY", "QUERY_HISTORY_BY_SESSION", "QUERY_HISTORY_BY_USER", "QUERY_HISTORY_BY_WAREHOUSE", "RADIANS", "RANDOM", "RANDSTR", "RANK", "RATIO_TO_REPORT", "REGEXP", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REGEXP_SUBSTR_ALL", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "REGR_VALX", "REGR_VALY", "REPEAT", "REPLACE", "REPLICATION_GROUP_REFRESH_HISTORY", "REPLICATION_GROUP_REFRESH_PROGRESS", "REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB", "REPLICATION_GROUP_USAGE_HISTORY", "REPLICATION_USAGE_HISTORY", "REST_EVENT_HISTORY", "RESULT_SCAN", "REVERSE", "RIGHT", "RLIKE", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "RTRIMMED_LENGTH", "SEARCH_OPTIMIZATION_HISTORY", "SEQ1", "SEQ2", "SEQ4", "SEQ8", "SERVERLESS_TASK_HISTORY", "SHA1", "SHA1_HEX", "SHA1_BINARY", "SHA2", "SHA2_HEX", "SHA2_BINARY", "SIGN", "SIN", "SINH", "SKEW", "SOUNDEX", "SPACE", "SPLIT", "SPLIT_PART", "SPLIT_TO_TABLE", "SQRT", "SQUARE", "ST_AREA", "ST_ASEWKB", "ST_ASEWKT", "ST_ASGEOJSON", "ST_ASWKB", "ST_ASBINARY", "ST_ASWKT", "ST_ASTEXT", "ST_AZIMUTH", "ST_CENTROID", "ST_COLLECT", "ST_CONTAINS", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DWITHIN", "ST_ENDPOINT", "ST_ENVELOPE", "ST_GEOGFROMGEOHASH", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOGRAPHYFROMWKB", "ST_GEOGRAPHYFROMWKT", "ST_GEOHASH", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYFROMWKT", "ST_HAUSDORFFDISTANCE", "ST_INTERSECTION", "ST_INTERSECTS", "ST_LENGTH", "ST_MAKEGEOMPOINT", "ST_GEOM_POINT", "ST_MAKELINE", "ST_MAKEPOINT", "ST_POINT", "ST_MAKEPOLYGON", "ST_POLYGON", "ST_NPOINTS", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SETSRID", "ST_SIMPLIFY", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY", "STAGE_STORAGE_USAGE_HISTORY", "STARTSWITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRIP_NULL_VALUE", "STRTOK", "STRTOK_SPLIT_TO_TABLE", "STRTOK_TO_ARRAY", "SUBSTR", "SUBSTRING", "SUM", "SYSDATE", "SYSTEM$ABORT_SESSION", "SYSTEM$ABORT_TRANSACTION", "SYSTEM$AUTHORIZE_PRIVATELINK", "SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS", "SYSTEM$CANCEL_ALL_QUERIES", "SYSTEM$CANCEL_QUERY", "SYSTEM$CLUSTERING_DEPTH", "SYSTEM$CLUSTERING_INFORMATION", "SYSTEM$CLUSTERING_RATIO ", "SYSTEM$CURRENT_USER_TASK_NAME", "SYSTEM$DATABASE_REFRESH_HISTORY ", "SYSTEM$DATABASE_REFRESH_PROGRESS", "SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB ", "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$DISABLE_DATABASE_REPLICATION", "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$ESTIMATE_QUERY_ACCELERATION", "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS", "SYSTEM$EXPLAIN_JSON_TO_TEXT", "SYSTEM$EXPLAIN_PLAN_JSON", "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS", "SYSTEM$GENERATE_SAML_CSR", "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN", "SYSTEM$GET_AWS_SNS_IAM_POLICY", "SYSTEM$GET_PREDECESSOR_RETURN_VALUE", "SYSTEM$GET_PRIVATELINK", "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS", "SYSTEM$GET_PRIVATELINK_CONFIG", "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO", "SYSTEM$GET_TAG", "SYSTEM$GET_TAG_ALLOWED_VALUES", "SYSTEM$GET_TAG_ON_CURRENT_COLUMN", "SYSTEM$GET_TAG_ON_CURRENT_TABLE", "SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER", "SYSTEM$LAST_CHANGE_COMMIT_TIME", "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME", "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION", "SYSTEM$PIPE_FORCE_RESUME", "SYSTEM$PIPE_STATUS", "SYSTEM$REVOKE_PRIVATELINK", "SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$SET_RETURN_VALUE", "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS", "SYSTEM$STREAM_GET_TABLE_TIMESTAMP", "SYSTEM$STREAM_HAS_DATA", "SYSTEM$TASK_DEPENDENTS_ENABLE", "SYSTEM$TYPEOF", "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS", "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN", "SYSTEM$WAIT", "SYSTEM$WHITELIST", "SYSTEM$WHITELIST_PRIVATELINK", "TAG_REFERENCES", "TAG_REFERENCES_ALL_COLUMNS", "TAG_REFERENCES_WITH_LINEAGE", "TAN", "TANH", "TASK_DEPENDENTS", "TASK_HISTORY", "TIME_FROM_PARTS", "TIME_SLICE", "TIMEADD", "TIMEDIFF", "TIMESTAMP_FROM_PARTS", "TIMESTAMPADD", "TIMESTAMPDIFF", "TO_ARRAY", "TO_BINARY", "TO_BOOLEAN", "TO_CHAR", "TO_VARCHAR", "TO_DATE", "DATE", "TO_DECIMAL", "TO_NUMBER", "TO_NUMERIC", "TO_DOUBLE", "TO_GEOGRAPHY", "TO_GEOMETRY", "TO_JSON", "TO_OBJECT", "TO_TIME", "TIME", "TO_TIMESTAMP", "TO_TIMESTAMP_LTZ", "TO_TIMESTAMP_NTZ", "TO_TIMESTAMP_TZ", "TO_VARIANT", "TO_XML", "TRANSLATE", "TRIM", "TRUNCATE", "TRUNC", "TRUNC", "TRY_BASE64_DECODE_BINARY", "TRY_BASE64_DECODE_STRING", "TRY_CAST", "TRY_HEX_DECODE_BINARY", "TRY_HEX_DECODE_STRING", "TRY_PARSE_JSON", "TRY_TO_BINARY", "TRY_TO_BOOLEAN", "TRY_TO_DATE", "TRY_TO_DECIMAL", "TRY_TO_NUMBER", "TRY_TO_NUMERIC", "TRY_TO_DOUBLE", "TRY_TO_GEOGRAPHY", "TRY_TO_GEOMETRY", "TRY_TO_TIME", "TRY_TO_TIMESTAMP", "TRY_TO_TIMESTAMP_LTZ", "TRY_TO_TIMESTAMP_NTZ", "TRY_TO_TIMESTAMP_TZ", "TYPEOF", "UNICODE", "UNIFORM", "UPPER", "UUID_STRING", "VALIDATE", "VALIDATE_PIPE_LOAD", "VAR_POP", "VAR_SAMP", "VARIANCE", "VARIANCE_SAMP", "VARIANCE_POP", "WAREHOUSE_LOAD_HISTORY", "WAREHOUSE_METERING_HISTORY", "WIDTH_BUCKET", "XMLGET", "YEAR", "YEAROFWEEK", "YEAROFWEEKISO", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEKISO", "DAYOFYEAR", "WEEK", "WEEK", "WEEKOFYEAR", "WEEKISO", "MONTH", "QUARTER", "ZEROIFNULL", "ZIPF"]
}), z2e = Ct({
  // https://docs.snowflake.com/en/sql-reference/reserved-keywords.html
  //
  // run in console on this page: $x('//tbody/tr/*[1]/p/text()').map(x => x.nodeValue)
  all: ["ACCOUNT", "ALL", "ALTER", "AND", "ANY", "AS", "BETWEEN", "BY", "CASE", "CAST", "CHECK", "COLUMN", "CONNECT", "CONNECTION", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DATABASE", "DELETE", "DISTINCT", "DROP", "ELSE", "EXISTS", "FALSE", "FOLLOWING", "FOR", "FROM", "FULL", "GRANT", "GROUP", "GSCLUSTER", "HAVING", "ILIKE", "IN", "INCREMENT", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "ISSUE", "JOIN", "LATERAL", "LEFT", "LIKE", "LOCALTIME", "LOCALTIMESTAMP", "MINUS", "NATURAL", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "ORGANIZATION", "QUALIFY", "REGEXP", "REVOKE", "RIGHT", "RLIKE", "ROW", "ROWS", "SAMPLE", "SCHEMA", "SELECT", "SET", "SOME", "START", "TABLE", "TABLESAMPLE", "THEN", "TO", "TRIGGER", "TRUE", "TRY_CAST", "UNION", "UNIQUE", "UPDATE", "USING", "VALUES", "VIEW", "WHEN", "WHENEVER", "WHERE", "WITH"]
}), Z2e = ie(["SELECT [ALL | DISTINCT]"]), q2e = ie([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "QUALIFY",
  "LIMIT",
  "OFFSET",
  "FETCH [FIRST | NEXT]",
  // Data manipulation
  // - insert:
  "INSERT [OVERWRITE] [ALL INTO | INTO | ALL | FIRST]",
  "{THEN | ELSE} INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  // - view
  "CREATE [OR REPLACE] [SECURE] [RECURSIVE] VIEW [IF NOT EXISTS]",
  // - create/drop/merge table
  "CREATE [OR REPLACE] [VOLATILE] TABLE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [LOCAL | GLOBAL] {TEMP|TEMPORARY} TABLE [IF NOT EXISTS]",
  "CLUSTER BY",
  "[WITH] {MASKING POLICY | TAG | ROW ACCESS POLICY}",
  "COPY GRANTS",
  "USING TEMPLATE",
  "MERGE INTO",
  "WHEN MATCHED [AND]",
  "THEN {UPDATE SET | DELETE}",
  "WHEN NOT MATCHED THEN INSERT"
]), VB = ie([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "RENAME TO",
  "SWAP WITH",
  "[SUSPEND | RESUME] RECLUSTER",
  "DROP CLUSTERING KEY",
  "ADD [COLUMN]",
  "RENAME COLUMN",
  "{ALTER | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "{ADD | ALTER | MODIFY | DROP} [CONSTRAINT]",
  "RENAME CONSTRAINT",
  "{ADD | DROP} SEARCH OPTIMIZATION",
  "{SET | UNSET} TAG",
  // Actually TAG is optional, but that conflicts with UPDATE..SET statement
  "{ADD | DROP} ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "{SET | DROP} DEFAULT",
  // for alter column
  "{SET | DROP} NOT NULL",
  // for alter column
  "[SET DATA] TYPE",
  // for alter column
  "[UNSET] COMMENT",
  // for alter column
  "{SET | UNSET} MASKING POLICY",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE] [IF EXISTS]",
  // other
  // https://docs.snowflake.com/en/sql-reference/sql-all.html
  //
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. delete all lines that contain a sting like '(.*)', they are already covered in the list
  // 3. delete all lines that contain a sting like '<.*>', they are already covered in the list
  // 4. delete all lines that contain '', they are part of a regex statement that can't be covered here
  // 5. Manually add 'COPY INTO'
  // 6. Remove all lines that are already in `reservedClauses`
  //
  // Steps 1-4 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   filter(x => !x.match(/\(.*\)/) && !x.match(//) && !x.match(/<.*>/)) // Step 2-4
  "ALTER ACCOUNT",
  "ALTER API INTEGRATION",
  "ALTER CONNECTION",
  "ALTER DATABASE",
  "ALTER EXTERNAL TABLE",
  "ALTER FAILOVER GROUP",
  "ALTER FILE FORMAT",
  "ALTER FUNCTION",
  "ALTER INTEGRATION",
  "ALTER MASKING POLICY",
  "ALTER MATERIALIZED VIEW",
  "ALTER NETWORK POLICY",
  "ALTER NOTIFICATION INTEGRATION",
  "ALTER PIPE",
  "ALTER PROCEDURE",
  "ALTER REPLICATION GROUP",
  "ALTER RESOURCE MONITOR",
  "ALTER ROLE",
  "ALTER ROW ACCESS POLICY",
  "ALTER SCHEMA",
  "ALTER SECURITY INTEGRATION",
  "ALTER SEQUENCE",
  "ALTER SESSION",
  "ALTER SESSION POLICY",
  "ALTER SHARE",
  "ALTER STAGE",
  "ALTER STORAGE INTEGRATION",
  "ALTER STREAM",
  "ALTER TAG",
  "ALTER TASK",
  "ALTER USER",
  "ALTER VIEW",
  "ALTER WAREHOUSE",
  "BEGIN",
  "CALL",
  "COMMIT",
  "COPY INTO",
  "CREATE ACCOUNT",
  "CREATE API INTEGRATION",
  "CREATE CONNECTION",
  "CREATE DATABASE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL TABLE",
  "CREATE FAILOVER GROUP",
  "CREATE FILE FORMAT",
  "CREATE FUNCTION",
  "CREATE INTEGRATION",
  "CREATE MANAGED ACCOUNT",
  "CREATE MASKING POLICY",
  "CREATE MATERIALIZED VIEW",
  "CREATE NETWORK POLICY",
  "CREATE NOTIFICATION INTEGRATION",
  "CREATE PIPE",
  "CREATE PROCEDURE",
  "CREATE REPLICATION GROUP",
  "CREATE RESOURCE MONITOR",
  "CREATE ROLE",
  "CREATE ROW ACCESS POLICY",
  "CREATE SCHEMA",
  "CREATE SECURITY INTEGRATION",
  "CREATE SEQUENCE",
  "CREATE SESSION POLICY",
  "CREATE SHARE",
  "CREATE STAGE",
  "CREATE STORAGE INTEGRATION",
  "CREATE STREAM",
  "CREATE TAG",
  "CREATE TASK",
  "CREATE USER",
  "CREATE WAREHOUSE",
  "DELETE",
  "DESCRIBE DATABASE",
  "DESCRIBE EXTERNAL TABLE",
  "DESCRIBE FILE FORMAT",
  "DESCRIBE FUNCTION",
  "DESCRIBE INTEGRATION",
  "DESCRIBE MASKING POLICY",
  "DESCRIBE MATERIALIZED VIEW",
  "DESCRIBE NETWORK POLICY",
  "DESCRIBE PIPE",
  "DESCRIBE PROCEDURE",
  "DESCRIBE RESULT",
  "DESCRIBE ROW ACCESS POLICY",
  "DESCRIBE SCHEMA",
  "DESCRIBE SEQUENCE",
  "DESCRIBE SESSION POLICY",
  "DESCRIBE SHARE",
  "DESCRIBE STAGE",
  "DESCRIBE STREAM",
  "DESCRIBE TABLE",
  "DESCRIBE TASK",
  "DESCRIBE TRANSACTION",
  "DESCRIBE USER",
  "DESCRIBE VIEW",
  "DESCRIBE WAREHOUSE",
  "DROP CONNECTION",
  "DROP DATABASE",
  "DROP EXTERNAL TABLE",
  "DROP FAILOVER GROUP",
  "DROP FILE FORMAT",
  "DROP FUNCTION",
  "DROP INTEGRATION",
  "DROP MANAGED ACCOUNT",
  "DROP MASKING POLICY",
  "DROP MATERIALIZED VIEW",
  "DROP NETWORK POLICY",
  "DROP PIPE",
  "DROP PROCEDURE",
  "DROP REPLICATION GROUP",
  "DROP RESOURCE MONITOR",
  "DROP ROLE",
  "DROP ROW ACCESS POLICY",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SESSION POLICY",
  "DROP SHARE",
  "DROP STAGE",
  "DROP STREAM",
  "DROP TAG",
  "DROP TASK",
  "DROP USER",
  "DROP VIEW",
  "DROP WAREHOUSE",
  "EXECUTE IMMEDIATE",
  "EXECUTE TASK",
  "EXPLAIN",
  "GET",
  "GRANT OWNERSHIP",
  "GRANT ROLE",
  "INSERT",
  "LIST",
  "MERGE",
  "PUT",
  "REMOVE",
  "REVOKE ROLE",
  "ROLLBACK",
  "SHOW COLUMNS",
  "SHOW CONNECTIONS",
  "SHOW DATABASES",
  "SHOW DATABASES IN FAILOVER GROUP",
  "SHOW DATABASES IN REPLICATION GROUP",
  "SHOW DELEGATED AUTHORIZATIONS",
  "SHOW EXTERNAL FUNCTIONS",
  "SHOW EXTERNAL TABLES",
  "SHOW FAILOVER GROUPS",
  "SHOW FILE FORMATS",
  "SHOW FUNCTIONS",
  "SHOW GLOBAL ACCOUNTS",
  "SHOW GRANTS",
  "SHOW INTEGRATIONS",
  "SHOW LOCKS",
  "SHOW MANAGED ACCOUNTS",
  "SHOW MASKING POLICIES",
  "SHOW MATERIALIZED VIEWS",
  "SHOW NETWORK POLICIES",
  "SHOW OBJECTS",
  "SHOW ORGANIZATION ACCOUNTS",
  "SHOW PARAMETERS",
  "SHOW PIPES",
  "SHOW PRIMARY KEYS",
  "SHOW PROCEDURES",
  "SHOW REGIONS",
  "SHOW REPLICATION ACCOUNTS",
  "SHOW REPLICATION DATABASES",
  "SHOW REPLICATION GROUPS",
  "SHOW RESOURCE MONITORS",
  "SHOW ROLES",
  "SHOW ROW ACCESS POLICIES",
  "SHOW SCHEMAS",
  "SHOW SEQUENCES",
  "SHOW SESSION POLICIES",
  "SHOW SHARES",
  "SHOW SHARES IN FAILOVER GROUP",
  "SHOW SHARES IN REPLICATION GROUP",
  "SHOW STAGES",
  "SHOW STREAMS",
  "SHOW TABLES",
  "SHOW TAGS",
  "SHOW TASKS",
  "SHOW TRANSACTIONS",
  "SHOW USER FUNCTIONS",
  "SHOW USERS",
  "SHOW VARIABLES",
  "SHOW VIEWS",
  "SHOW WAREHOUSES",
  "TRUNCATE MATERIALIZED VIEW",
  "UNDROP DATABASE",
  "UNDROP SCHEMA",
  "UNDROP TABLE",
  "UNDROP TAG",
  "UNSET",
  "USE DATABASE",
  "USE ROLE",
  "USE SCHEMA",
  "USE SECONDARY ROLES",
  "USE WAREHOUSE"
]), j2e = ie(["UNION [ALL]", "MINUS", "EXCEPT", "INTERSECT"]), K2e = ie(["[INNER] JOIN", "[NATURAL] {LEFT | RIGHT | FULL} [OUTER] JOIN", "{CROSS | NATURAL} JOIN"]), J2e = ie(["{ROWS | RANGE} BETWEEN", "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]"]), eQe = {
  tokenizerOptions: {
    reservedSelect: Z2e,
    reservedClauses: [...q2e, ...VB],
    reservedSetOperations: j2e,
    reservedJoins: K2e,
    reservedPhrases: J2e,
    reservedKeywords: z2e,
    reservedFunctionNames: W2e,
    stringTypes: ["$$", "''-qq-bs"],
    identTypes: ['""-qq'],
    variableTypes: [
      // for accessing columns at certain positons in the table
      {
        regex: "[$][1-9]\\d*"
      },
      // identifier style syntax
      {
        regex: "[$][_a-zA-Z][_a-zA-Z0-9$]*"
      }
    ],
    extraParens: ["[]"],
    identChars: {
      rest: "$"
    },
    lineCommentTypes: ["--", "//"],
    operators: [
      // Modulo
      "%",
      // Type cast
      "::",
      // String concat
      "||",
      // Get Path
      ":",
      // Generators: https://docs.snowflake.com/en/sql-reference/functions/generator.html#generator
      "=>"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: [":", "::"],
    onelineClauses: VB
  }
}, tQe = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bigquery: LMe,
  db2: YMe,
  hive: JMe,
  mariadb: ske,
  mysql: vke,
  n1ql: Ake,
  plsql: Lke,
  postgresql: Vke,
  redshift: qke,
  singlestoredb: Y2e,
  snowflake: eQe,
  spark: n2e,
  sql: S2e,
  sqlite: d2e,
  transactsql: Q2e,
  trino: x2e
}, Symbol.toStringTag, { value: "Module" })), ma = (r) => r.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&"), FB = /\s+/uy, Ph = (r) => new RegExp(`(?:${r})`, "uy"), rQe = (r) => r.split("").map((e) => / /gu.test(e) ? "\\s+" : `[${e.toUpperCase()}${e.toLowerCase()}]`).join(""), iQe = (r) => r + "(?:-" + r + ")*", nQe = ({
  prefixes: r,
  requirePrefix: e
}) => `(?:${r.map(rQe).join("|")}${e ? "" : "|"})`, aQe = (r) => new RegExp(`(?:${r.map(ma).join("|")}).*?(?=\r
|\r|
|$)`, "uy"), XB = (r, e = []) => {
  const t = r === "open" ? 0 : 1, i = ["()", ...e].map((n) => n[t]);
  return Ph(i.map(ma).join("|"));
}, oQe = (r) => Ph(`${j9(r).map(ma).join("|")}`), sQe = ({
  rest: r,
  dashes: e
}) => r || e ? `(?![${r || ""}${e ? "-" : ""}])` : "", tu = (r, e = {}) => {
  if (r.length === 0)
    return /^\b$/u;
  const t = sQe(e), i = j9(r).map(ma).join("|").replace(/ /gu, "\\s+");
  return new RegExp(`(?:${i})${t}\\b`, "iuy");
}, HR = (r, e) => {
  if (!r.length)
    return;
  const t = r.map(ma).join("|");
  return Ph(`(?:${t})(?:${e})`);
}, lQe = () => {
  const r = {
    "<": ">",
    "[": "]",
    "(": ")",
    "{": "}"
  }, e = "{left}(?:(?!{right}').)*?{right}", t = Object.entries(r).map(([o, s]) => e.replace(/{left}/g, ma(o)).replace(/{right}/g, ma(s))), i = ma(Object.keys(r).join(""));
  return `[Qq]'(?:${String.raw`(?<tag>[^\s${i}])(?:(?!\k<tag>').)*?\k<tag>`}|${t.join("|")})'`;
}, YB = {
  // - backtick quoted (using `` to escape)
  "``": "(?:`[^`]*`)+",
  // - Transact-SQL square bracket quoted (using ]] to escape)
  "[]": String.raw`(?:\[[^\]]*\])(?:\][^\]]*\])*`,
  // double-quoted
  '""-qq': String.raw`(?:"[^"]*")+`,
  // with repeated quote escapes
  '""-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")`,
  // with backslash escapes
  '""-qq-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")+`,
  // with repeated quote or backslash escapes
  '""-raw': String.raw`(?:"[^"]*")`,
  // no escaping
  // single-quoted
  "''-qq": String.raw`(?:'[^']*')+`,
  // with repeated quote escapes
  "''-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')`,
  // with backslash escapes
  "''-qq-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')+`,
  // with repeated quote or backslash escapes
  "''-raw": String.raw`(?:'[^']*')`,
  // no escaping
  // PostgreSQL dollar-quoted
  $$: String.raw`(?<tag>\$\w*\$)[\s\S]*?\k<tag>`,
  // BigQuery '''triple-quoted''' (using \' to escape)
  "'''..'''": String.raw`'''[^\\]*?(?:\\.[^\\]*?)*?'''`,
  // BigQuery """triple-quoted""" (using \" to escape)
  '""".."""': String.raw`"""[^\\]*?(?:\\.[^\\]*?)*?"""`,
  // Hive and Spark variables: ${name}
  "{}": String.raw`(?:\{[^\}]*\})`,
  // Oracle q'' strings: q'<text>' q'|text|' ...
  "q''": lQe()
}, e8 = (r) => typeof r == "string" ? YB[r] : "regex" in r ? r.regex : nQe(r) + YB[r.quote], uQe = (r) => Ph(r.map((e) => "regex" in e ? e.regex : e8(e)).join("|")), t8 = (r) => r.map(e8).join("|"), HB = (r) => Ph(t8(r)), hQe = (r = {}) => Ph(r8(r)), r8 = ({
  first: r,
  rest: e,
  dashes: t,
  allowFirstCharNumber: i
} = {}) => {
  const n = "\\p{Alphabetic}\\p{Mark}_", a = "\\p{Decimal_Number}", o = ma(r ?? ""), s = ma(e ?? ""), l = i ? `[${n}${a}${o}][${n}${a}${s}]*` : `[${n}${o}][${n}${a}${s}]*`;
  return t ? iQe(l) : l;
};
function i8(r, e) {
  const t = r.slice(0, e).split(/\n/);
  return {
    line: t.length,
    col: t[t.length - 1].length + 1
  };
}
class cQe {
  // Current position in string
  constructor(e) {
    xr(this, "input", "");
    // The input SQL string to process
    xr(this, "index", 0);
    this.rules = e;
  }
  /**
   * Takes a SQL string and breaks it into tokens.
   * Each token is an object with type and value.
   *
   * @param {string} input - The SQL string
   * @returns {Token[]} output token stream
   */
  tokenize(e) {
    this.input = e, this.index = 0;
    const t = [];
    let i;
    for (; this.index < this.input.length; ) {
      const n = this.getWhitespace();
      if (this.index < this.input.length) {
        if (i = this.getNextToken(), !i)
          throw this.createParseError();
        t.push({
          ...i,
          precedingWhitespace: n
        });
      }
    }
    return t;
  }
  createParseError() {
    const e = this.input.slice(this.index, this.index + 10), {
      line: t,
      col: i
    } = i8(this.input, this.index);
    return new Error(`Parse error: Unexpected "${e}" at line ${t} column ${i}`);
  }
  getWhitespace() {
    FB.lastIndex = this.index;
    const e = FB.exec(this.input);
    if (e)
      return this.index += e[0].length, e[0];
  }
  getNextToken() {
    for (const e of this.rules) {
      const t = this.match(e);
      if (t)
        return t;
    }
  }
  // Attempts to match token rule regex at current position in input
  match(e) {
    e.regex.lastIndex = this.index;
    const t = e.regex.exec(this.input);
    if (t) {
      const i = t[0], n = {
        type: e.type,
        raw: i,
        text: e.text ? e.text(i) : i,
        start: this.index
      };
      return e.key && (n.key = e.key(i)), this.index += i.length, n;
    }
  }
}
const WB = /\/\*/uy, fQe = /([^/*]|\*[^/]|\/[^*])+/uy, dQe = /\*\//uy;
class pQe {
  constructor() {
    xr(this, "lastIndex", 0);
  }
  exec(e) {
    let t = "", i, n = 0;
    if (i = this.matchSection(WB, e))
      t += i, n++;
    else
      return null;
    for (; n > 0; )
      if (i = this.matchSection(WB, e))
        t += i, n++;
      else if (i = this.matchSection(dQe, e))
        t += i, n--;
      else if (i = this.matchSection(fQe, e))
        t += i;
      else
        return null;
    return [t];
  }
  matchSection(e, t) {
    e.lastIndex = this.lastIndex;
    const i = e.exec(t);
    return i && (this.lastIndex += i[0].length), i ? i[0] : null;
  }
}
class gQe {
  constructor(e) {
    this.cfg = e, this.rulesBeforeParams = this.buildRulesBeforeParams(e), this.rulesAfterParams = this.buildRulesAfterParams(e);
  }
  tokenize(e, t) {
    const i = [...this.rulesBeforeParams, ...this.buildParamRules(this.cfg, t), ...this.rulesAfterParams], n = new cQe(i).tokenize(e);
    return this.cfg.postProcess ? this.cfg.postProcess(n) : n;
  }
  // These rules can be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesBeforeParams(e) {
    return this.validRules([
      {
        type: te.BLOCK_COMMENT,
        regex: e.nestedBlockComments ? new pQe() : /(\/\*[^]*?\*\/)/uy
      },
      {
        type: te.LINE_COMMENT,
        regex: aQe(e.lineCommentTypes ?? ["--"])
      },
      {
        type: te.QUOTED_IDENTIFIER,
        regex: HB(e.identTypes)
      },
      {
        type: te.NUMBER,
        regex: /(?:0x[0-9a-fA-F]+|0b[01]+|(?:-\s*)?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+(?:\.[0-9]+)?)?)(?!\w)/uy
      },
      // RESERVED_PHRASE is matched before all other keyword tokens
      // to e.g. prioritize matching "TIMESTAMP WITH TIME ZONE" phrase over "WITH" clause.
      {
        type: te.RESERVED_PHRASE,
        regex: tu(e.reservedPhrases ?? [], e.identChars),
        text: Qr
      },
      {
        type: te.CASE,
        regex: /CASE\b/iuy,
        text: Qr
      },
      {
        type: te.END,
        regex: /END\b/iuy,
        text: Qr
      },
      {
        type: te.BETWEEN,
        regex: /BETWEEN\b/iuy,
        text: Qr
      },
      {
        type: te.LIMIT,
        regex: e.reservedClauses.includes("LIMIT") ? /LIMIT\b/iuy : void 0,
        text: Qr
      },
      {
        type: te.RESERVED_CLAUSE,
        regex: tu(e.reservedClauses, e.identChars),
        text: Qr
      },
      {
        type: te.RESERVED_SELECT,
        regex: tu(e.reservedSelect, e.identChars),
        text: Qr
      },
      {
        type: te.RESERVED_SET_OPERATION,
        regex: tu(e.reservedSetOperations, e.identChars),
        text: Qr
      },
      {
        type: te.WHEN,
        regex: /WHEN\b/iuy,
        text: Qr
      },
      {
        type: te.ELSE,
        regex: /ELSE\b/iuy,
        text: Qr
      },
      {
        type: te.THEN,
        regex: /THEN\b/iuy,
        text: Qr
      },
      {
        type: te.RESERVED_JOIN,
        regex: tu(e.reservedJoins, e.identChars),
        text: Qr
      },
      {
        type: te.AND,
        regex: /AND\b/iuy,
        text: Qr
      },
      {
        type: te.OR,
        regex: /OR\b/iuy,
        text: Qr
      },
      {
        type: te.XOR,
        regex: e.supportsXor ? /XOR\b/iuy : void 0,
        text: Qr
      },
      {
        type: te.RESERVED_FUNCTION_NAME,
        regex: tu(e.reservedFunctionNames, e.identChars),
        text: Qr
      },
      {
        type: te.RESERVED_KEYWORD,
        regex: tu(e.reservedKeywords, e.identChars),
        text: Qr
      }
    ]);
  }
  // These rules can also be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesAfterParams(e) {
    return this.validRules([{
      type: te.VARIABLE,
      regex: e.variableTypes ? uQe(e.variableTypes) : void 0
    }, {
      type: te.STRING,
      regex: HB(e.stringTypes)
    }, {
      type: te.IDENTIFIER,
      regex: hQe(e.identChars)
    }, {
      type: te.DELIMITER,
      regex: /[;]/uy
    }, {
      type: te.COMMA,
      regex: /[,]/y
    }, {
      type: te.OPEN_PAREN,
      regex: XB("open", e.extraParens)
    }, {
      type: te.CLOSE_PAREN,
      regex: XB("close", e.extraParens)
    }, {
      type: te.OPERATOR,
      regex: oQe([
        // standard operators
        "+",
        "-",
        "/",
        ">",
        "<",
        "=",
        "<>",
        "<=",
        ">=",
        "!=",
        ...e.operators ?? []
      ])
    }, {
      type: te.ASTERISK,
      regex: /[*]/uy
    }, {
      type: te.DOT,
      regex: /[.]/uy
    }]);
  }
  // These rules can't be blindly cached as the paramTypesOverrides object
  // can differ on each invocation of the format() function.
  buildParamRules(e, t) {
    var i, n, a, o, s;
    const l = {
      named: (t == null ? void 0 : t.named) || ((i = e.paramTypes) === null || i === void 0 ? void 0 : i.named) || [],
      quoted: (t == null ? void 0 : t.quoted) || ((n = e.paramTypes) === null || n === void 0 ? void 0 : n.quoted) || [],
      numbered: (t == null ? void 0 : t.numbered) || ((a = e.paramTypes) === null || a === void 0 ? void 0 : a.numbered) || [],
      positional: typeof (t == null ? void 0 : t.positional) == "boolean" ? t.positional : (o = e.paramTypes) === null || o === void 0 ? void 0 : o.positional,
      custom: (t == null ? void 0 : t.custom) || ((s = e.paramTypes) === null || s === void 0 ? void 0 : s.custom) || []
    };
    return this.validRules([{
      type: te.NAMED_PARAMETER,
      regex: HR(l.named, r8(e.paramChars || e.identChars)),
      key: (u) => u.slice(1)
    }, {
      type: te.QUOTED_PARAMETER,
      regex: HR(l.quoted, t8(e.identTypes)),
      key: (u) => (({
        tokenKey: h,
        quoteChar: c
      }) => h.replace(new RegExp(ma("\\" + c), "gu"), c))({
        tokenKey: u.slice(2, -1),
        quoteChar: u.slice(-1)
      })
    }, {
      type: te.NUMBERED_PARAMETER,
      regex: HR(l.numbered, "[0-9]+"),
      key: (u) => u.slice(1)
    }, {
      type: te.POSITIONAL_PARAMETER,
      regex: l.positional ? /[?]/y : void 0
    }, ...l.custom.map((u) => ({
      type: te.CUSTOM_PARAMETER,
      regex: Ph(u.regex),
      key: u.key ?? ((h) => h)
    }))]);
  }
  // filters out rules for token types whose regex is undefined
  validRules(e) {
    return e.filter((t) => !!t.regex);
  }
}
const Qr = (r) => J9(r.toUpperCase()), zB = /* @__PURE__ */ new Map(), vQe = (r) => {
  let e = zB.get(r);
  return e || (e = OQe(r), zB.set(r, e)), e;
}, OQe = (r) => ({
  tokenizer: new gQe(r.tokenizerOptions),
  formatOptions: mQe(r.formatOptions)
}), mQe = (r) => ({
  alwaysDenseOperators: r.alwaysDenseOperators || [],
  onelineClauses: Object.fromEntries(r.onelineClauses.map((e) => [e, !0]))
});
function ZB(r) {
  return r.indentStyle === "tabularLeft" || r.indentStyle === "tabularRight" ? " ".repeat(10) : r.useTabs ? "	" : " ".repeat(r.tabWidth);
}
function Id(r) {
  return r.indentStyle === "tabularLeft" || r.indentStyle === "tabularRight";
}
class EQe {
  constructor(e) {
    this.params = e, this.index = 0;
  }
  /**
   * Returns param value that matches given placeholder with param key.
   */
  get({
    key: e,
    text: t
  }) {
    return this.params ? e ? this.params[e] : this.params[this.index++] : t;
  }
  /**
   * Returns index of current positional parameter.
   */
  getPositionalParameterIndex() {
    return this.index;
  }
  /**
   * Sets index of current positional parameter.
   */
  setPositionalParameterIndex(e) {
    this.index = e;
  }
}
var bQe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function SQe(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var n8 = { exports: {} };
(function(r) {
  (function(e, t) {
    r.exports ? r.exports = t() : e.nearley = t();
  })(bQe, function() {
    function e(u, h, c) {
      return this.id = ++e.highestId, this.name = u, this.symbols = h, this.postprocess = c, this;
    }
    e.highestId = 0, e.prototype.toString = function(u) {
      var h = typeof u > "u" ? this.symbols.map(l).join(" ") : this.symbols.slice(0, u).map(l).join(" ") + "  " + this.symbols.slice(u).map(l).join(" ");
      return this.name + "  " + h;
    };
    function t(u, h, c, f) {
      this.rule = u, this.dot = h, this.reference = c, this.data = [], this.wantedBy = f, this.isComplete = this.dot === u.symbols.length;
    }
    t.prototype.toString = function() {
      return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
    }, t.prototype.nextState = function(u) {
      var h = new t(this.rule, this.dot + 1, this.reference, this.wantedBy);
      return h.left = this, h.right = u, h.isComplete && (h.data = h.build(), h.right = void 0), h;
    }, t.prototype.build = function() {
      var u = [], h = this;
      do
        u.push(h.right.data), h = h.left;
      while (h.left);
      return u.reverse(), u;
    }, t.prototype.finish = function() {
      this.rule.postprocess && (this.data = this.rule.postprocess(this.data, this.reference, o.fail));
    };
    function i(u, h) {
      this.grammar = u, this.index = h, this.states = [], this.wants = {}, this.scannable = [], this.completed = {};
    }
    i.prototype.process = function(u) {
      for (var h = this.states, c = this.wants, f = this.completed, d = 0; d < h.length; d++) {
        var p = h[d];
        if (p.isComplete) {
          if (p.finish(), p.data !== o.fail) {
            for (var g = p.wantedBy, v = g.length; v--; ) {
              var O = g[v];
              this.complete(O, p);
            }
            if (p.reference === this.index) {
              var m = p.rule.name;
              (this.completed[m] = this.completed[m] || []).push(p);
            }
          }
        } else {
          var m = p.rule.symbols[p.dot];
          if (typeof m != "string") {
            this.scannable.push(p);
            continue;
          }
          if (c[m]) {
            if (c[m].push(p), f.hasOwnProperty(m))
              for (var E = f[m], v = 0; v < E.length; v++) {
                var b = E[v];
                this.complete(p, b);
              }
          } else
            c[m] = [p], this.predict(m);
        }
      }
    }, i.prototype.predict = function(u) {
      for (var h = this.grammar.byName[u] || [], c = 0; c < h.length; c++) {
        var f = h[c], d = this.wants[u], p = new t(f, 0, this.index, d);
        this.states.push(p);
      }
    }, i.prototype.complete = function(u, h) {
      var c = u.nextState(h);
      this.states.push(c);
    };
    function n(u, h) {
      this.rules = u, this.start = h || this.rules[0].name;
      var c = this.byName = {};
      this.rules.forEach(function(f) {
        c.hasOwnProperty(f.name) || (c[f.name] = []), c[f.name].push(f);
      });
    }
    n.fromCompiled = function(f, h) {
      var c = f.Lexer;
      f.ParserStart && (h = f.ParserStart, f = f.ParserRules);
      var f = f.map(function(p) {
        return new e(p.name, p.symbols, p.postprocess);
      }), d = new n(f, h);
      return d.lexer = c, d;
    };
    function a() {
      this.reset("");
    }
    a.prototype.reset = function(u, h) {
      this.buffer = u, this.index = 0, this.line = h ? h.line : 1, this.lastLineBreak = h ? -h.col : 0;
    }, a.prototype.next = function() {
      if (this.index < this.buffer.length) {
        var u = this.buffer[this.index++];
        return u === `
` && (this.line += 1, this.lastLineBreak = this.index), { value: u };
      }
    }, a.prototype.save = function() {
      return {
        line: this.line,
        col: this.index - this.lastLineBreak
      };
    }, a.prototype.formatError = function(u, h) {
      var c = this.buffer;
      if (typeof c == "string") {
        var f = c.split(`
`).slice(
          Math.max(0, this.line - 5),
          this.line
        ), d = c.indexOf(`
`, this.index);
        d === -1 && (d = c.length);
        var p = this.index - this.lastLineBreak, g = String(this.line).length;
        return h += " at line " + this.line + " col " + p + `:

`, h += f.map(function(O, m) {
          return v(this.line - f.length + m + 1, g) + " " + O;
        }, this).join(`
`), h += `
` + v("", g + p) + `^
`, h;
      } else
        return h + " at index " + (this.index - 1);
      function v(O, m) {
        var E = String(O);
        return Array(m - E.length + 1).join(" ") + E;
      }
    };
    function o(u, h, c) {
      if (u instanceof n)
        var f = u, c = h;
      else
        var f = n.fromCompiled(u, h);
      this.grammar = f, this.options = {
        keepHistory: !1,
        lexer: f.lexer || new a()
      };
      for (var d in c || {})
        this.options[d] = c[d];
      this.lexer = this.options.lexer, this.lexerState = void 0;
      var p = new i(f, 0);
      this.table = [p], p.wants[f.start] = [], p.predict(f.start), p.process(), this.current = 0;
    }
    o.fail = {}, o.prototype.feed = function(u) {
      var h = this.lexer;
      h.reset(u, this.lexerState);
      for (var c; ; ) {
        try {
          if (c = h.next(), !c)
            break;
        } catch (y) {
          var g = new i(this.grammar, this.current + 1);
          this.table.push(g);
          var f = new Error(this.reportLexerError(y));
          throw f.offset = this.current, f.token = y.token, f;
        }
        var d = this.table[this.current];
        this.options.keepHistory || delete this.table[this.current - 1];
        var p = this.current + 1, g = new i(this.grammar, p);
        this.table.push(g);
        for (var v = c.text !== void 0 ? c.text : c.value, O = h.constructor === a ? c.value : c, m = d.scannable, E = m.length; E--; ) {
          var b = m[E], T = b.rule.symbols[b.dot];
          if (T.test ? T.test(O) : T.type ? T.type === c.type : T.literal === v) {
            var S = b.nextState({ data: O, token: c, isToken: !0, reference: p - 1 });
            g.states.push(S);
          }
        }
        if (g.process(), g.states.length === 0) {
          var f = new Error(this.reportError(c));
          throw f.offset = this.current, f.token = c, f;
        }
        this.options.keepHistory && (d.lexerState = h.save()), this.current++;
      }
      return d && (this.lexerState = h.save()), this.results = this.finish(), this;
    }, o.prototype.reportLexerError = function(u) {
      var h, c, f = u.token;
      return f ? (h = "input " + JSON.stringify(f.text[0]) + " (lexer error)", c = this.lexer.formatError(f, "Syntax error")) : (h = "input (lexer error)", c = u.message), this.reportErrorCommon(c, h);
    }, o.prototype.reportError = function(u) {
      var h = (u.type ? u.type + " token: " : "") + JSON.stringify(u.value !== void 0 ? u.value : u), c = this.lexer.formatError(u, "Syntax error");
      return this.reportErrorCommon(c, h);
    }, o.prototype.reportErrorCommon = function(u, h) {
      var c = [];
      c.push(u);
      var f = this.table.length - 2, d = this.table[f], p = d.states.filter(function(v) {
        var O = v.rule.symbols[v.dot];
        return O && typeof O != "string";
      });
      if (p.length === 0)
        c.push("Unexpected " + h + `. I did not expect any more input. Here is the state of my parse table:
`), this.displayStateStack(d.states, c);
      else {
        c.push("Unexpected " + h + `. Instead, I was expecting to see one of the following:
`);
        var g = p.map(function(v) {
          return this.buildFirstStateStack(v, []) || [v];
        }, this);
        g.forEach(function(v) {
          var O = v[0], m = O.rule.symbols[O.dot], E = this.getSymbolDisplay(m);
          c.push("A " + E + " based on:"), this.displayStateStack(v, c);
        }, this);
      }
      return c.push(""), c.join(`
`);
    }, o.prototype.displayStateStack = function(u, h) {
      for (var c, f = 0, d = 0; d < u.length; d++) {
        var p = u[d], g = p.rule.toString(p.dot);
        g === c ? f++ : (f > 0 && h.push("    ^ " + f + " more lines identical to this"), f = 0, h.push("    " + g)), c = g;
      }
    }, o.prototype.getSymbolDisplay = function(u) {
      return s(u);
    }, o.prototype.buildFirstStateStack = function(u, h) {
      if (h.indexOf(u) !== -1)
        return null;
      if (u.wantedBy.length === 0)
        return [u];
      var c = u.wantedBy[0], f = [u].concat(h), d = this.buildFirstStateStack(c, f);
      return d === null ? null : [u].concat(d);
    }, o.prototype.save = function() {
      var u = this.table[this.current];
      return u.lexerState = this.lexerState, u;
    }, o.prototype.restore = function(u) {
      var h = u.index;
      this.current = h, this.table[h] = u, this.table.splice(h + 1), this.lexerState = u.lexerState, this.results = this.finish();
    }, o.prototype.rewind = function(u) {
      if (!this.options.keepHistory)
        throw new Error("set option `keepHistory` to enable rewinding");
      this.restore(this.table[u]);
    }, o.prototype.finish = function() {
      var u = [], h = this.grammar.start, c = this.table[this.table.length - 1];
      return c.states.forEach(function(f) {
        f.rule.name === h && f.dot === f.rule.symbols.length && f.reference === 0 && f.data !== o.fail && u.push(f);
      }), u.map(function(f) {
        return f.data;
      });
    };
    function s(u) {
      var h = typeof u;
      if (h === "string")
        return u;
      if (h === "object") {
        if (u.literal)
          return JSON.stringify(u.literal);
        if (u instanceof RegExp)
          return "character matching " + u;
        if (u.type)
          return u.type + " token";
        if (u.test)
          return "token matching " + String(u.test);
        throw new Error("Unknown symbol type: " + u);
      }
    }
    function l(u) {
      var h = typeof u;
      if (h === "string")
        return u;
      if (h === "object") {
        if (u.literal)
          return JSON.stringify(u.literal);
        if (u instanceof RegExp)
          return u.toString();
        if (u.type)
          return "%" + u.type;
        if (u.test)
          return "<" + String(u.test) + ">";
        throw new Error("Unknown symbol type: " + u);
      }
    }
    return {
      Parser: o,
      Grammar: n,
      Rule: e
    };
  });
})(n8);
var TQe = n8.exports;
const yQe = /* @__PURE__ */ SQe(TQe);
function RQe(r) {
  return r.map(AQe).map(CQe).map(_Qe).map(IQe);
}
const AQe = (r, e, t) => {
  if (Z9(r.type)) {
    const i = xQe(t, e);
    if (i && i.text === ".")
      return {
        ...r,
        type: te.IDENTIFIER,
        text: r.raw
      };
  }
  return r;
}, CQe = (r, e, t) => {
  if (r.type === te.RESERVED_FUNCTION_NAME) {
    const i = TT(t, e);
    if (!i || !wQe(i))
      return {
        ...r,
        type: te.RESERVED_KEYWORD
      };
  }
  return r;
}, _Qe = (r, e, t) => {
  if (r.type === te.IDENTIFIER) {
    const i = TT(t, e);
    if (i && a8(i))
      return {
        ...r,
        type: te.ARRAY_IDENTIFIER
      };
  }
  return r;
}, IQe = (r, e, t) => {
  if (r.type === te.RESERVED_KEYWORD) {
    const i = TT(t, e);
    if (i && a8(i))
      return {
        ...r,
        type: te.ARRAY_KEYWORD
      };
  }
  return r;
}, xQe = (r, e) => TT(r, e, -1), TT = (r, e, t = 1) => {
  let i = 1;
  for (; r[e + i * t] && PQe(r[e + i * t]); )
    i++;
  return r[e + i * t];
}, wQe = (r) => r.type === te.OPEN_PAREN && r.text === "(", a8 = (r) => r.type === te.OPEN_PAREN && r.text === "[", PQe = (r) => r.type === te.BLOCK_COMMENT || r.type === te.LINE_COMMENT;
class o8 {
  constructor(e) {
    xr(this, "index", 0);
    xr(this, "tokens", []);
    xr(this, "input", "");
    this.tokenize = e;
  }
  reset(e, t) {
    this.input = e, this.index = 0, this.tokens = this.tokenize(e);
  }
  next() {
    return this.tokens[this.index++];
  }
  save() {
  }
  formatError(e) {
    const {
      line: t,
      col: i
    } = i8(this.input, e.start);
    return `Parse error at token: ${e.text} at line ${t} column ${i}`;
  }
  has(e) {
    return e in te;
  }
}
let Me;
(function(r) {
  r.statement = "statement", r.clause = "clause", r.set_operation = "set_operation", r.function_call = "function_call", r.array_subscript = "array_subscript", r.property_access = "property_access", r.parenthesis = "parenthesis", r.between_predicate = "between_predicate", r.case_expression = "case_expression", r.case_when = "case_when", r.case_else = "case_else", r.limit_clause = "limit_clause", r.all_columns_asterisk = "all_columns_asterisk", r.literal = "literal", r.identifier = "identifier", r.keyword = "keyword", r.parameter = "parameter", r.operator = "operator", r.comma = "comma", r.line_comment = "line_comment", r.block_comment = "block_comment";
})(Me || (Me = {}));
function WR(r) {
  return r[0];
}
const Ye = new o8((r) => []), nc = ([[r]]) => r, wr = (r) => ({
  type: Me.keyword,
  tokenType: r.type,
  text: r.text,
  raw: r.raw
}), $r = (r, {
  leading: e,
  trailing: t
}) => (e != null && e.length && (r = {
  ...r,
  leadingComments: e
}), t != null && t.length && (r = {
  ...r,
  trailingComments: t
}), r), NQe = (r, {
  leading: e,
  trailing: t
}) => {
  if (e != null && e.length) {
    const [i, ...n] = r;
    r = [$r(i, {
      leading: e
    }), ...n];
  }
  if (t != null && t.length) {
    const i = r.slice(0, -1), n = r[r.length - 1];
    r = [...i, $r(n, {
      trailing: t
    })];
  }
  return r;
}, LQe = {
  Lexer: Ye,
  ParserRules: [{
    name: "main$ebnf$1",
    symbols: []
  }, {
    name: "main$ebnf$1",
    symbols: ["main$ebnf$1", "statement"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "main",
    symbols: ["main$ebnf$1"],
    postprocess: ([r]) => {
      const e = r[r.length - 1];
      return e && !e.hasSemicolon ? e.children.length > 0 ? r : r.slice(0, -1) : r;
    }
  }, {
    name: "statement$subexpression$1",
    symbols: [Ye.has("DELIMITER") ? {
      type: "DELIMITER"
    } : DELIMITER]
  }, {
    name: "statement$subexpression$1",
    symbols: [Ye.has("EOF") ? {
      type: "EOF"
    } : EOF]
  }, {
    name: "statement",
    symbols: ["expressions_or_clauses", "statement$subexpression$1"],
    postprocess: ([r, [e]]) => ({
      type: Me.statement,
      children: r,
      hasSemicolon: e.type === te.DELIMITER
    })
  }, {
    name: "expressions_or_clauses$ebnf$1",
    symbols: []
  }, {
    name: "expressions_or_clauses$ebnf$1",
    symbols: ["expressions_or_clauses$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expressions_or_clauses$ebnf$2",
    symbols: []
  }, {
    name: "expressions_or_clauses$ebnf$2",
    symbols: ["expressions_or_clauses$ebnf$2", "clause"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expressions_or_clauses",
    symbols: ["expressions_or_clauses$ebnf$1", "expressions_or_clauses$ebnf$2"],
    postprocess: ([r, e]) => [...r, ...e]
  }, {
    name: "clause$subexpression$1",
    symbols: ["limit_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["select_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["other_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["set_operation"]
  }, {
    name: "clause",
    symbols: ["clause$subexpression$1"],
    postprocess: nc
  }, {
    name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
    symbols: ["free_form_sql"]
  }, {
    name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
    symbols: ["limit_clause$ebnf$1$subexpression$1$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "limit_clause$ebnf$1$subexpression$1",
    symbols: [Ye.has("COMMA") ? {
      type: "COMMA"
    } : COMMA, "limit_clause$ebnf$1$subexpression$1$ebnf$1"]
  }, {
    name: "limit_clause$ebnf$1",
    symbols: ["limit_clause$ebnf$1$subexpression$1"],
    postprocess: WR
  }, {
    name: "limit_clause$ebnf$1",
    symbols: [],
    postprocess: () => null
  }, {
    name: "limit_clause",
    symbols: [Ye.has("LIMIT") ? {
      type: "LIMIT"
    } : LIMIT, "_", "expression_chain_", "limit_clause$ebnf$1"],
    postprocess: ([r, e, t, i]) => {
      if (i) {
        const [n, a] = i;
        return {
          type: Me.limit_clause,
          limitKw: $r(wr(r), {
            trailing: e
          }),
          offset: t,
          count: a
        };
      } else
        return {
          type: Me.limit_clause,
          limitKw: $r(wr(r), {
            trailing: e
          }),
          count: t
        };
    }
  }, {
    name: "select_clause$subexpression$1$ebnf$1",
    symbols: []
  }, {
    name: "select_clause$subexpression$1$ebnf$1",
    symbols: ["select_clause$subexpression$1$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "select_clause$subexpression$1",
    symbols: ["all_columns_asterisk", "select_clause$subexpression$1$ebnf$1"]
  }, {
    name: "select_clause$subexpression$1$ebnf$2",
    symbols: []
  }, {
    name: "select_clause$subexpression$1$ebnf$2",
    symbols: ["select_clause$subexpression$1$ebnf$2", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "select_clause$subexpression$1",
    symbols: ["asteriskless_free_form_sql", "select_clause$subexpression$1$ebnf$2"]
  }, {
    name: "select_clause",
    symbols: [Ye.has("RESERVED_SELECT") ? {
      type: "RESERVED_SELECT"
    } : RESERVED_SELECT, "select_clause$subexpression$1"],
    postprocess: ([r, [e, t]]) => ({
      type: Me.clause,
      nameKw: wr(r),
      children: [e, ...t]
    })
  }, {
    name: "select_clause",
    symbols: [Ye.has("RESERVED_SELECT") ? {
      type: "RESERVED_SELECT"
    } : RESERVED_SELECT],
    postprocess: ([r]) => ({
      type: Me.clause,
      nameKw: wr(r),
      children: []
    })
  }, {
    name: "all_columns_asterisk",
    symbols: [Ye.has("ASTERISK") ? {
      type: "ASTERISK"
    } : ASTERISK],
    postprocess: () => ({
      type: Me.all_columns_asterisk
    })
  }, {
    name: "other_clause$ebnf$1",
    symbols: []
  }, {
    name: "other_clause$ebnf$1",
    symbols: ["other_clause$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "other_clause",
    symbols: [Ye.has("RESERVED_CLAUSE") ? {
      type: "RESERVED_CLAUSE"
    } : RESERVED_CLAUSE, "other_clause$ebnf$1"],
    postprocess: ([r, e]) => ({
      type: Me.clause,
      nameKw: wr(r),
      children: e
    })
  }, {
    name: "set_operation$ebnf$1",
    symbols: []
  }, {
    name: "set_operation$ebnf$1",
    symbols: ["set_operation$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "set_operation",
    symbols: [Ye.has("RESERVED_SET_OPERATION") ? {
      type: "RESERVED_SET_OPERATION"
    } : RESERVED_SET_OPERATION, "set_operation$ebnf$1"],
    postprocess: ([r, e]) => ({
      type: Me.set_operation,
      nameKw: wr(r),
      children: e
    })
  }, {
    name: "expression_chain_$ebnf$1",
    symbols: ["expression_with_comments_"]
  }, {
    name: "expression_chain_$ebnf$1",
    symbols: ["expression_chain_$ebnf$1", "expression_with_comments_"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expression_chain_",
    symbols: ["expression_chain_$ebnf$1"],
    postprocess: WR
  }, {
    name: "expression_chain$ebnf$1",
    symbols: []
  }, {
    name: "expression_chain$ebnf$1",
    symbols: ["expression_chain$ebnf$1", "_expression_with_comments"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expression_chain",
    symbols: ["expression", "expression_chain$ebnf$1"],
    postprocess: ([r, e]) => [r, ...e]
  }, {
    name: "andless_expression_chain$ebnf$1",
    symbols: []
  }, {
    name: "andless_expression_chain$ebnf$1",
    symbols: ["andless_expression_chain$ebnf$1", "_andless_expression_with_comments"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "andless_expression_chain",
    symbols: ["andless_expression", "andless_expression_chain$ebnf$1"],
    postprocess: ([r, e]) => [r, ...e]
  }, {
    name: "expression_with_comments_",
    symbols: ["expression", "_"],
    postprocess: ([r, e]) => $r(r, {
      trailing: e
    })
  }, {
    name: "_expression_with_comments",
    symbols: ["_", "expression"],
    postprocess: ([r, e]) => $r(e, {
      leading: r
    })
  }, {
    name: "_andless_expression_with_comments",
    symbols: ["_", "andless_expression"],
    postprocess: ([r, e]) => $r(e, {
      leading: r
    })
  }, {
    name: "free_form_sql$subexpression$1",
    symbols: ["asteriskless_free_form_sql"]
  }, {
    name: "free_form_sql$subexpression$1",
    symbols: ["asterisk"]
  }, {
    name: "free_form_sql",
    symbols: ["free_form_sql$subexpression$1"],
    postprocess: nc
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["asteriskless_andless_expression"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["logic_operator"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["between_predicate"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["comma"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["comment"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["other_keyword"]
  }, {
    name: "asteriskless_free_form_sql",
    symbols: ["asteriskless_free_form_sql$subexpression$1"],
    postprocess: nc
  }, {
    name: "expression$subexpression$1",
    symbols: ["andless_expression"]
  }, {
    name: "expression$subexpression$1",
    symbols: ["logic_operator"]
  }, {
    name: "expression",
    symbols: ["expression$subexpression$1"],
    postprocess: nc
  }, {
    name: "andless_expression$subexpression$1",
    symbols: ["asteriskless_andless_expression"]
  }, {
    name: "andless_expression$subexpression$1",
    symbols: ["asterisk"]
  }, {
    name: "andless_expression",
    symbols: ["andless_expression$subexpression$1"],
    postprocess: nc
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["array_subscript"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["case_expression"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["function_call"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["property_access"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["parenthesis"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["curly_braces"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["square_brackets"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["operator"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["identifier"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["parameter"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["literal"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["keyword"]
  }, {
    name: "asteriskless_andless_expression",
    symbols: ["asteriskless_andless_expression$subexpression$1"],
    postprocess: nc
  }, {
    name: "array_subscript",
    symbols: [Ye.has("ARRAY_IDENTIFIER") ? {
      type: "ARRAY_IDENTIFIER"
    } : ARRAY_IDENTIFIER, "_", "square_brackets"],
    postprocess: ([r, e, t]) => ({
      type: Me.array_subscript,
      array: $r({
        type: Me.identifier,
        text: r.text
      }, {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "array_subscript",
    symbols: [Ye.has("ARRAY_KEYWORD") ? {
      type: "ARRAY_KEYWORD"
    } : ARRAY_KEYWORD, "_", "square_brackets"],
    postprocess: ([r, e, t]) => ({
      type: Me.array_subscript,
      array: $r(wr(r), {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "function_call",
    symbols: [Ye.has("RESERVED_FUNCTION_NAME") ? {
      type: "RESERVED_FUNCTION_NAME"
    } : RESERVED_FUNCTION_NAME, "_", "parenthesis"],
    postprocess: ([r, e, t]) => ({
      type: Me.function_call,
      nameKw: $r(wr(r), {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "parenthesis",
    symbols: [{
      literal: "("
    }, "expressions_or_clauses", {
      literal: ")"
    }],
    postprocess: ([r, e, t]) => ({
      type: Me.parenthesis,
      children: e,
      openParen: "(",
      closeParen: ")"
    })
  }, {
    name: "curly_braces$ebnf$1",
    symbols: []
  }, {
    name: "curly_braces$ebnf$1",
    symbols: ["curly_braces$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "curly_braces",
    symbols: [{
      literal: "{"
    }, "curly_braces$ebnf$1", {
      literal: "}"
    }],
    postprocess: ([r, e, t]) => ({
      type: Me.parenthesis,
      children: e,
      openParen: "{",
      closeParen: "}"
    })
  }, {
    name: "square_brackets$ebnf$1",
    symbols: []
  }, {
    name: "square_brackets$ebnf$1",
    symbols: ["square_brackets$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "square_brackets",
    symbols: [{
      literal: "["
    }, "square_brackets$ebnf$1", {
      literal: "]"
    }],
    postprocess: ([r, e, t]) => ({
      type: Me.parenthesis,
      children: e,
      openParen: "[",
      closeParen: "]"
    })
  }, {
    name: "property_access$subexpression$1",
    symbols: ["identifier"]
  }, {
    name: "property_access$subexpression$1",
    symbols: ["array_subscript"]
  }, {
    name: "property_access$subexpression$1",
    symbols: ["all_columns_asterisk"]
  }, {
    name: "property_access",
    symbols: ["expression", "_", Ye.has("DOT") ? {
      type: "DOT"
    } : DOT, "_", "property_access$subexpression$1"],
    postprocess: (
      // Allowing property to be <array_subscript> is currently a hack.
      // A better way would be to allow <property_access> on the left side of array_subscript,
      // but we currently can't do that because of another hack that requires
      // %ARRAY_IDENTIFIER on the left side of <array_subscript>.
      ([r, e, t, i, [n]]) => ({
        type: Me.property_access,
        object: $r(r, {
          trailing: e
        }),
        property: $r(n, {
          leading: i
        })
      })
    )
  }, {
    name: "between_predicate",
    symbols: [Ye.has("BETWEEN") ? {
      type: "BETWEEN"
    } : BETWEEN, "_", "andless_expression_chain", "_", Ye.has("AND") ? {
      type: "AND"
    } : AND, "_", "andless_expression"],
    postprocess: ([r, e, t, i, n, a, o]) => ({
      type: Me.between_predicate,
      betweenKw: wr(r),
      expr1: NQe(t, {
        leading: e,
        trailing: i
      }),
      andKw: wr(n),
      expr2: [$r(o, {
        leading: a
      })]
    })
  }, {
    name: "case_expression$ebnf$1",
    symbols: ["expression_chain_"],
    postprocess: WR
  }, {
    name: "case_expression$ebnf$1",
    symbols: [],
    postprocess: () => null
  }, {
    name: "case_expression$ebnf$2",
    symbols: []
  }, {
    name: "case_expression$ebnf$2",
    symbols: ["case_expression$ebnf$2", "case_clause"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "case_expression",
    symbols: [Ye.has("CASE") ? {
      type: "CASE"
    } : CASE, "_", "case_expression$ebnf$1", "case_expression$ebnf$2", Ye.has("END") ? {
      type: "END"
    } : END],
    postprocess: ([r, e, t, i, n]) => ({
      type: Me.case_expression,
      caseKw: $r(wr(r), {
        trailing: e
      }),
      endKw: wr(n),
      expr: t || [],
      clauses: i
    })
  }, {
    name: "case_clause",
    symbols: [Ye.has("WHEN") ? {
      type: "WHEN"
    } : WHEN, "_", "expression_chain_", Ye.has("THEN") ? {
      type: "THEN"
    } : THEN, "_", "expression_chain_"],
    postprocess: ([r, e, t, i, n, a]) => ({
      type: Me.case_when,
      whenKw: $r(wr(r), {
        trailing: e
      }),
      thenKw: $r(wr(i), {
        trailing: n
      }),
      condition: t,
      result: a
    })
  }, {
    name: "case_clause",
    symbols: [Ye.has("ELSE") ? {
      type: "ELSE"
    } : ELSE, "_", "expression_chain_"],
    postprocess: ([r, e, t]) => ({
      type: Me.case_else,
      elseKw: $r(wr(r), {
        trailing: e
      }),
      result: t
    })
  }, {
    name: "comma$subexpression$1",
    symbols: [Ye.has("COMMA") ? {
      type: "COMMA"
    } : COMMA]
  }, {
    name: "comma",
    symbols: ["comma$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Me.comma
    })
  }, {
    name: "asterisk$subexpression$1",
    symbols: [Ye.has("ASTERISK") ? {
      type: "ASTERISK"
    } : ASTERISK]
  }, {
    name: "asterisk",
    symbols: ["asterisk$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Me.operator,
      text: r.text
    })
  }, {
    name: "operator$subexpression$1",
    symbols: [Ye.has("OPERATOR") ? {
      type: "OPERATOR"
    } : OPERATOR]
  }, {
    name: "operator",
    symbols: ["operator$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Me.operator,
      text: r.text
    })
  }, {
    name: "identifier$subexpression$1",
    symbols: [Ye.has("IDENTIFIER") ? {
      type: "IDENTIFIER"
    } : IDENTIFIER]
  }, {
    name: "identifier$subexpression$1",
    symbols: [Ye.has("QUOTED_IDENTIFIER") ? {
      type: "QUOTED_IDENTIFIER"
    } : QUOTED_IDENTIFIER]
  }, {
    name: "identifier$subexpression$1",
    symbols: [Ye.has("VARIABLE") ? {
      type: "VARIABLE"
    } : VARIABLE]
  }, {
    name: "identifier",
    symbols: ["identifier$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Me.identifier,
      text: r.text
    })
  }, {
    name: "parameter$subexpression$1",
    symbols: [Ye.has("NAMED_PARAMETER") ? {
      type: "NAMED_PARAMETER"
    } : NAMED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [Ye.has("QUOTED_PARAMETER") ? {
      type: "QUOTED_PARAMETER"
    } : QUOTED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [Ye.has("NUMBERED_PARAMETER") ? {
      type: "NUMBERED_PARAMETER"
    } : NUMBERED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [Ye.has("POSITIONAL_PARAMETER") ? {
      type: "POSITIONAL_PARAMETER"
    } : POSITIONAL_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [Ye.has("CUSTOM_PARAMETER") ? {
      type: "CUSTOM_PARAMETER"
    } : CUSTOM_PARAMETER]
  }, {
    name: "parameter",
    symbols: ["parameter$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Me.parameter,
      key: r.key,
      text: r.text
    })
  }, {
    name: "literal$subexpression$1",
    symbols: [Ye.has("NUMBER") ? {
      type: "NUMBER"
    } : NUMBER]
  }, {
    name: "literal$subexpression$1",
    symbols: [Ye.has("STRING") ? {
      type: "STRING"
    } : STRING]
  }, {
    name: "literal",
    symbols: ["literal$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Me.literal,
      text: r.text
    })
  }, {
    name: "keyword$subexpression$1",
    symbols: [Ye.has("RESERVED_KEYWORD") ? {
      type: "RESERVED_KEYWORD"
    } : RESERVED_KEYWORD]
  }, {
    name: "keyword$subexpression$1",
    symbols: [Ye.has("RESERVED_PHRASE") ? {
      type: "RESERVED_PHRASE"
    } : RESERVED_PHRASE]
  }, {
    name: "keyword$subexpression$1",
    symbols: [Ye.has("RESERVED_JOIN") ? {
      type: "RESERVED_JOIN"
    } : RESERVED_JOIN]
  }, {
    name: "keyword",
    symbols: ["keyword$subexpression$1"],
    postprocess: ([[r]]) => wr(r)
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [Ye.has("AND") ? {
      type: "AND"
    } : AND]
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [Ye.has("OR") ? {
      type: "OR"
    } : OR]
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [Ye.has("XOR") ? {
      type: "XOR"
    } : XOR]
  }, {
    name: "logic_operator",
    symbols: ["logic_operator$subexpression$1"],
    postprocess: ([[r]]) => wr(r)
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [Ye.has("WHEN") ? {
      type: "WHEN"
    } : WHEN]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [Ye.has("THEN") ? {
      type: "THEN"
    } : THEN]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [Ye.has("ELSE") ? {
      type: "ELSE"
    } : ELSE]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [Ye.has("END") ? {
      type: "END"
    } : END]
  }, {
    name: "other_keyword",
    symbols: ["other_keyword$subexpression$1"],
    postprocess: ([[r]]) => wr(r)
  }, {
    name: "_$ebnf$1",
    symbols: []
  }, {
    name: "_$ebnf$1",
    symbols: ["_$ebnf$1", "comment"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "_",
    symbols: ["_$ebnf$1"],
    postprocess: ([r]) => r
  }, {
    name: "comment",
    symbols: [Ye.has("LINE_COMMENT") ? {
      type: "LINE_COMMENT"
    } : LINE_COMMENT],
    postprocess: ([r]) => ({
      type: Me.line_comment,
      text: r.text,
      precedingWhitespace: r.precedingWhitespace
    })
  }, {
    name: "comment",
    symbols: [Ye.has("BLOCK_COMMENT") ? {
      type: "BLOCK_COMMENT"
    } : BLOCK_COMMENT],
    postprocess: ([r]) => ({
      type: Me.block_comment,
      text: r.text,
      precedingWhitespace: r.precedingWhitespace
    })
  }],
  ParserStart: "main"
}, DQe = LQe, {
  Parser: MQe,
  Grammar: kQe
} = yQe;
function QQe(r) {
  let e = {};
  const t = new o8((n) => [...RQe(r.tokenize(n, e)), z9(n.length)]), i = new MQe(kQe.fromCompiled(DQe), {
    lexer: t
  });
  return {
    parse: (n, a) => {
      e = a;
      const {
        results: o
      } = i.feed(n);
      if (o.length === 1)
        return o[0];
      throw o.length === 0 ? new Error("Parse error: Invalid SQL") : new Error(`Parse error: Ambiguous grammar
${JSON.stringify(o, void 0, 2)}`);
    }
  };
}
const UQe = /^\s+/u;
function $Qe(r, e, t) {
  return GQe(r.split(`
`)).flatMap((i) => {
    if (i.length === 1)
      return i;
    if (e === "tabular")
      return BQe(i);
    if (e === "before")
      return FQe(i, t);
    throw new Error(`Unexpected commaPosition: ${e}`);
  }).join(`
`);
}
function GQe(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) {
    const i = [r[t]];
    for (; r[t].match(/.*,(\s*(--.*)?$)/); )
      t++, i.push(r[t]);
    e.push(i);
  }
  return e;
}
function BQe(r) {
  const e = K9(HQe(r)) - 1;
  return r.map((t, i) => i === r.length - 1 ? t : VQe(t, e));
}
function VQe(r, e) {
  const [, t, i] = r.match(/^(.*?),(\s*--.*)?$/) || [], n = " ".repeat(e - t.length);
  return `${t}${n},${i ?? ""}`;
}
function FQe(r, e) {
  return YQe(r).map((t, i) => {
    if (i === 0)
      return t;
    const [n] = t.match(UQe) || [""];
    return XQe(n, e) + e.replace(/ {2}$/, ", ") + // add comma to the end of last indent
    t.trimStart();
  });
}
function XQe(r, e) {
  return r.replace(new RegExp(e + "$"), "");
}
function YQe(r) {
  return r.map((e) => e.replace(/,(\s*(--.*)?$)/, "$1"));
}
function HQe(r) {
  return r.map((e) => e.replace(/\s*--.*/, ""));
}
function WQe(r) {
  const e = r.split(`
`);
  let t = [];
  for (let i = 0; i < e.length; i++) {
    if (e[i].match(/^\s*SELECT/i)) {
      let n = [];
      if (e[i].match(/.*,$/))
        n = [e[i]];
      else {
        if (t.push(e[i]), e[i].match(/^\s*SELECT\s+.+(?!,$)/i))
          continue;
        n.push(e[++i]);
      }
      for (; e[i++].match(/.*,$/); )
        n.push(e[i]);
      const a = n.map((s) => ({
        line: s,
        matches: s.match(/(^.*?\S) (AS )?(\S+,?$)/i)
      })).map(({
        line: s,
        matches: l
      }) => l ? {
        precedingText: l[1],
        as: l[2],
        alias: l[3]
      } : {
        precedingText: s
      }), o = K9(a.map(({
        precedingText: s
      }) => s.replace(/\s*,\s*$/, "")));
      n = a.map(({
        precedingText: s,
        as: l,
        alias: u
      }) => s + (u ? " ".repeat(o - s.length + 1) + (l ?? "") + u : "")), t = [...t, ...n];
    }
    t.push(e[i]);
  }
  return t.join(`
`);
}
let Z;
(function(r) {
  r[r.SPACE = 0] = "SPACE", r[r.NO_SPACE = 1] = "NO_SPACE", r[r.NO_NEWLINE = 2] = "NO_NEWLINE", r[r.NEWLINE = 3] = "NEWLINE", r[r.MANDATORY_NEWLINE = 4] = "MANDATORY_NEWLINE", r[r.INDENT = 5] = "INDENT", r[r.SINGLE_INDENT = 6] = "SINGLE_INDENT";
})(Z || (Z = {}));
let s8 = class {
  constructor(e) {
    xr(this, "items", []);
    this.indentation = e;
  }
  /**
   * Appends token strings and whitespace modifications to SQL string.
   */
  add(...e) {
    for (const t of e)
      switch (t) {
        case Z.SPACE:
          this.items.push(Z.SPACE);
          break;
        case Z.NO_SPACE:
          this.trimHorizontalWhitespace();
          break;
        case Z.NO_NEWLINE:
          this.trimWhitespace();
          break;
        case Z.NEWLINE:
          this.trimHorizontalWhitespace(), this.addNewline(Z.NEWLINE);
          break;
        case Z.MANDATORY_NEWLINE:
          this.trimHorizontalWhitespace(), this.addNewline(Z.MANDATORY_NEWLINE);
          break;
        case Z.INDENT:
          this.addIndentation();
          break;
        case Z.SINGLE_INDENT:
          this.items.push(Z.SINGLE_INDENT);
          break;
        default:
          this.items.push(t);
      }
  }
  trimHorizontalWhitespace() {
    for (; zQe(Sp(this.items)); )
      this.items.pop();
  }
  trimWhitespace() {
    for (; ZQe(Sp(this.items)); )
      this.items.pop();
  }
  addNewline(e) {
    if (this.items.length > 0)
      switch (Sp(this.items)) {
        case Z.NEWLINE:
          this.items.pop(), this.items.push(e);
          break;
        case Z.MANDATORY_NEWLINE:
          break;
        default:
          this.items.push(e);
          break;
      }
  }
  addIndentation() {
    for (let e = 0; e < this.indentation.getLevel(); e++)
      this.items.push(Z.SINGLE_INDENT);
  }
  /**
   * Returns the final SQL string.
   */
  toString() {
    return this.items.map((e) => this.itemToString(e)).join("");
  }
  /**
   * Returns the internal layout data
   */
  getLayoutItems() {
    return this.items;
  }
  itemToString(e) {
    switch (e) {
      case Z.SPACE:
        return " ";
      case Z.NEWLINE:
      case Z.MANDATORY_NEWLINE:
        return `
`;
      case Z.SINGLE_INDENT:
        return this.indentation.getSingleIndent();
      default:
        return e;
    }
  }
};
const zQe = (r) => r === Z.SPACE || r === Z.SINGLE_INDENT, ZQe = (r) => r === Z.SPACE || r === Z.SINGLE_INDENT || r === Z.NEWLINE;
function qQe(r, e) {
  if (e === "standard")
    return r;
  let t = [];
  return r.length >= 10 && r.includes(" ") && ([r, ...t] = r.split(" ")), e === "tabularLeft" ? r = r.padEnd(9, " ") : r = r.padStart(9, " "), r + ["", ...t].join(" ");
}
function jQe(r) {
  return TMe(r) || r === te.RESERVED_CLAUSE || r === te.RESERVED_SELECT || r === te.RESERVED_SET_OPERATION || r === te.RESERVED_JOIN || r === te.LIMIT;
}
const zR = "top-level", KQe = "block-level";
class l8 {
  /**
   * @param {string} indent A string to indent with
   */
  constructor(e) {
    xr(this, "indentTypes", []);
    this.indent = e;
  }
  /**
   * Returns indentation string for single indentation step.
   */
  getSingleIndent() {
    return this.indent;
  }
  /**
   * Returns current indentation level
   */
  getLevel() {
    return this.indentTypes.length;
  }
  /**
   * Increases indentation by one top-level indent.
   */
  increaseTopLevel() {
    this.indentTypes.push(zR);
  }
  /**
   * Increases indentation by one block-level indent.
   */
  increaseBlockLevel() {
    this.indentTypes.push(KQe);
  }
  /**
   * Decreases indentation by one top-level indent.
   * Does nothing when the previous indent is not top-level.
   */
  decreaseTopLevel() {
    this.indentTypes.length > 0 && Sp(this.indentTypes) === zR && this.indentTypes.pop();
  }
  /**
   * Decreases indentation by one block-level indent.
   * If there are top-level indents within the block-level indent,
   * throws away these as well.
   */
  decreaseBlockLevel() {
    for (; this.indentTypes.length > 0 && this.indentTypes.pop() === zR; )
      ;
  }
}
class JQe extends s8 {
  constructor(t) {
    super(new l8(""));
    xr(this, "length", 0);
    // Keeps track of the trailing whitespace,
    // so that we can decrease length when encountering WS.NO_SPACE,
    // but only when there actually is a space to remove.
    xr(this, "trailingSpace", !1);
    this.expressionWidth = t;
  }
  add(...t) {
    if (t.forEach((i) => this.addToLength(i)), this.length > this.expressionWidth)
      throw new v1();
    super.add(...t);
  }
  addToLength(t) {
    if (typeof t == "string")
      this.length += t.length, this.trailingSpace = !1;
    else {
      if (t === Z.MANDATORY_NEWLINE || t === Z.NEWLINE)
        throw new v1();
      t === Z.INDENT || t === Z.SINGLE_INDENT || t === Z.SPACE ? this.trailingSpace || (this.length++, this.trailingSpace = !0) : (t === Z.NO_NEWLINE || t === Z.NO_SPACE) && this.trailingSpace && (this.trailingSpace = !1, this.length--);
    }
  }
}
class v1 extends Error {
}
class Gb {
  constructor({
    cfg: e,
    dialectCfg: t,
    params: i,
    layout: n,
    inline: a = !1
  }) {
    xr(this, "inline", !1);
    xr(this, "nodes", []);
    xr(this, "index", -1);
    this.cfg = e, this.dialectCfg = t, this.inline = a, this.params = i, this.layout = n;
  }
  format(e) {
    for (this.nodes = e, this.index = 0; this.index < this.nodes.length; this.index++)
      this.formatNode(this.nodes[this.index]);
    return this.layout;
  }
  formatNode(e) {
    this.formatComments(e.leadingComments), this.formatNodeWithoutComments(e), this.formatComments(e.trailingComments);
  }
  formatNodeWithoutComments(e) {
    switch (e.type) {
      case Me.function_call:
        return this.formatFunctionCall(e);
      case Me.array_subscript:
        return this.formatArraySubscript(e);
      case Me.property_access:
        return this.formatPropertyAccess(e);
      case Me.parenthesis:
        return this.formatParenthesis(e);
      case Me.between_predicate:
        return this.formatBetweenPredicate(e);
      case Me.case_expression:
        return this.formatCaseExpression(e);
      case Me.case_when:
        return this.formatCaseWhen(e);
      case Me.case_else:
        return this.formatCaseElse(e);
      case Me.clause:
        return this.formatClause(e);
      case Me.set_operation:
        return this.formatSetOperation(e);
      case Me.limit_clause:
        return this.formatLimitClause(e);
      case Me.all_columns_asterisk:
        return this.formatAllColumnsAsterisk(e);
      case Me.literal:
        return this.formatLiteral(e);
      case Me.identifier:
        return this.formatIdentifier(e);
      case Me.parameter:
        return this.formatParameter(e);
      case Me.operator:
        return this.formatOperator(e);
      case Me.comma:
        return this.formatComma(e);
      case Me.line_comment:
        return this.formatLineComment(e);
      case Me.block_comment:
        return this.formatBlockComment(e);
      case Me.keyword:
        return this.formatKeywordNode(e);
    }
  }
  formatFunctionCall(e) {
    this.withComments(e.nameKw, () => {
      this.layout.add(this.showKw(e.nameKw));
    }), this.formatNode(e.parenthesis);
  }
  formatArraySubscript(e) {
    this.withComments(e.array, () => {
      this.layout.add(e.array.type === Me.keyword ? this.showKw(e.array) : e.array.text);
    }), this.formatNode(e.parenthesis);
  }
  formatPropertyAccess(e) {
    this.formatNode(e.object), this.layout.add(Z.NO_SPACE, "."), this.formatNode(e.property);
  }
  formatParenthesis(e) {
    const t = this.formatInlineExpression(e.children);
    t ? (this.layout.add(e.openParen), this.layout.add(...t.getLayoutItems()), this.layout.add(Z.NO_SPACE, e.closeParen, Z.SPACE)) : (this.layout.add(e.openParen, Z.NEWLINE), Id(this.cfg) ? (this.layout.add(Z.INDENT), this.layout = this.formatSubExpression(e.children)) : (this.layout.indentation.increaseBlockLevel(), this.layout.add(Z.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseBlockLevel()), this.layout.add(Z.NEWLINE, Z.INDENT, e.closeParen, Z.SPACE));
  }
  formatBetweenPredicate(e) {
    this.layout.add(this.showKw(e.betweenKw), Z.SPACE), this.layout = this.formatSubExpression(e.expr1), this.layout.add(Z.NO_SPACE, Z.SPACE, this.showNonTabularKw(e.andKw), Z.SPACE), this.layout = this.formatSubExpression(e.expr2), this.layout.add(Z.SPACE);
  }
  formatCaseExpression(e) {
    this.formatNode(e.caseKw), this.layout.indentation.increaseBlockLevel(), this.layout = this.formatSubExpression(e.expr), this.layout = this.formatSubExpression(e.clauses), this.layout.indentation.decreaseBlockLevel(), this.layout.add(Z.NEWLINE, Z.INDENT), this.formatNode(e.endKw);
  }
  formatCaseWhen(e) {
    this.layout.add(Z.NEWLINE, Z.INDENT), this.formatNode(e.whenKw), this.layout = this.formatSubExpression(e.condition), this.formatNode(e.thenKw), this.layout = this.formatSubExpression(e.result);
  }
  formatCaseElse(e) {
    this.layout.add(Z.NEWLINE, Z.INDENT), this.formatNode(e.elseKw), this.layout = this.formatSubExpression(e.result);
  }
  formatClause(e) {
    this.isOnelineClause(e) ? this.formatClauseInOnelineStyle(e) : Id(this.cfg) ? this.formatClauseInTabularStyle(e) : this.formatClauseInIndentedStyle(e);
  }
  isOnelineClause(e) {
    return this.dialectCfg.onelineClauses[e.nameKw.text];
  }
  formatClauseInIndentedStyle(e) {
    this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e.nameKw), Z.NEWLINE), this.layout.indentation.increaseTopLevel(), this.layout.add(Z.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel();
  }
  formatClauseInOnelineStyle(e) {
    this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e.nameKw), Z.SPACE), this.layout = this.formatSubExpression(e.children);
  }
  formatClauseInTabularStyle(e) {
    this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e.nameKw), Z.SPACE), this.layout.indentation.increaseTopLevel(), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel();
  }
  formatSetOperation(e) {
    this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e.nameKw), Z.NEWLINE), this.layout.add(Z.INDENT), this.layout = this.formatSubExpression(e.children);
  }
  formatLimitClause(e) {
    this.withComments(e.limitKw, () => {
      this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e.limitKw));
    }), this.layout.indentation.increaseTopLevel(), Id(this.cfg) ? this.layout.add(Z.SPACE) : this.layout.add(Z.NEWLINE, Z.INDENT), e.offset ? (this.layout = this.formatSubExpression(e.offset), this.layout.add(Z.NO_SPACE, ",", Z.SPACE), this.layout = this.formatSubExpression(e.count)) : this.layout = this.formatSubExpression(e.count), this.layout.indentation.decreaseTopLevel();
  }
  formatAllColumnsAsterisk(e) {
    this.layout.add("*", Z.SPACE);
  }
  formatLiteral(e) {
    this.layout.add(e.text, Z.SPACE);
  }
  formatIdentifier(e) {
    this.layout.add(e.text, Z.SPACE);
  }
  formatParameter(e) {
    this.layout.add(this.params.get(e), Z.SPACE);
  }
  formatOperator({
    text: e
  }) {
    this.cfg.denseOperators || this.dialectCfg.alwaysDenseOperators.includes(e) ? this.layout.add(Z.NO_SPACE, e) : e === ":" ? this.layout.add(Z.NO_SPACE, e, Z.SPACE) : this.layout.add(e, Z.SPACE);
  }
  formatComma(e) {
    this.inline ? this.layout.add(Z.NO_SPACE, ",", Z.SPACE) : this.layout.add(Z.NO_SPACE, ",", Z.NEWLINE, Z.INDENT);
  }
  withComments(e, t) {
    this.formatComments(e.leadingComments), t(), this.formatComments(e.trailingComments);
  }
  formatComments(e) {
    e && e.forEach((t) => {
      t.type === Me.line_comment ? this.formatLineComment(t) : this.formatBlockComment(t);
    });
  }
  formatLineComment(e) {
    YR(e.precedingWhitespace || "") ? this.layout.add(Z.NEWLINE, Z.INDENT, e.text, Z.MANDATORY_NEWLINE, Z.INDENT) : this.layout.getLayoutItems().length > 0 ? this.layout.add(Z.NO_NEWLINE, Z.SPACE, e.text, Z.MANDATORY_NEWLINE, Z.INDENT) : this.layout.add(e.text, Z.MANDATORY_NEWLINE, Z.INDENT);
  }
  formatBlockComment(e) {
    this.isMultilineBlockComment(e) ? (this.splitBlockComment(e.text).forEach((t) => {
      this.layout.add(Z.NEWLINE, Z.INDENT, t);
    }), this.layout.add(Z.NEWLINE, Z.INDENT)) : this.layout.add(e.text, Z.SPACE);
  }
  isMultilineBlockComment(e) {
    return YR(e.text) || YR(e.precedingWhitespace || "");
  }
  isDocComment(e) {
    const t = e.split(/\n/);
    return (
      // first line starts with /* or /**
      /^\/\*\*?$/.test(t[0]) && // intermediate lines start with *
      t.slice(1, t.length - 1).every((i) => /^\s*\*/.test(i)) && // last line ends with */
      /^\s*\*\/$/.test(Sp(t))
    );
  }
  // Breaks up block comment to multiple lines.
  // For example this doc-comment (dots representing leading whitespace):
  //
  //   ..../**
  //   .....* Some description here
  //   .....* and here too
  //   .....*/
  //
  // gets broken to this array (note the leading single spaces):
  //
  //   [ '/**',
  //     '.* Some description here',
  //     '.* and here too',
  //     '.*/' ]
  //
  // However, a normal comment (non-doc-comment) like this:
  //
  //   ..../*
  //   ....Some description here
  //   ....*/
  //
  // gets broken to this array (no leading spaces):
  //
  //   [ '/*',
  //     'Some description here',
  //     '*/' ]
  //
  splitBlockComment(e) {
    return this.isDocComment(e) ? e.split(/\n/).map((t) => /^\s*\*/.test(t) ? " " + t.replace(/^\s*/, "") : t) : e.split(/\n/).map((t) => t.replace(/^\s*/, ""));
  }
  formatSubExpression(e) {
    return new Gb({
      cfg: this.cfg,
      dialectCfg: this.dialectCfg,
      params: this.params,
      layout: this.layout,
      inline: this.inline
    }).format(e);
  }
  formatInlineExpression(e) {
    const t = this.params.getPositionalParameterIndex();
    try {
      return new Gb({
        cfg: this.cfg,
        dialectCfg: this.dialectCfg,
        params: this.params,
        layout: new JQe(this.cfg.expressionWidth),
        inline: !0
      }).format(e);
    } catch (i) {
      if (i instanceof v1) {
        this.params.setPositionalParameterIndex(t);
        return;
      } else
        throw i;
    }
  }
  formatKeywordNode(e) {
    switch (e.tokenType) {
      case te.RESERVED_JOIN:
        return this.formatJoin(e);
      case te.AND:
      case te.OR:
      case te.XOR:
        return this.formatLogicalOperator(e);
      default:
        return this.formatKeyword(e);
    }
  }
  formatJoin(e) {
    Id(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e), Z.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e), Z.SPACE);
  }
  formatKeyword(e) {
    this.layout.add(this.showKw(e), Z.SPACE);
  }
  formatLogicalOperator(e) {
    this.cfg.logicalOperatorNewline === "before" ? Id(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e), Z.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(Z.NEWLINE, Z.INDENT, this.showKw(e), Z.SPACE) : this.layout.add(this.showKw(e), Z.NEWLINE, Z.INDENT);
  }
  showKw(e) {
    return jQe(e.tokenType) ? qQe(this.showNonTabularKw(e), this.cfg.indentStyle) : this.showNonTabularKw(e);
  }
  // Like showKw(), but skips tabular formatting
  showNonTabularKw(e) {
    switch (this.cfg.keywordCase) {
      case "preserve":
        return J9(e.raw);
      case "upper":
        return e.text;
      case "lower":
        return e.text.toLowerCase();
    }
  }
}
class eUe {
  constructor(e, t) {
    this.dialect = e, this.cfg = t, this.params = new EQe(this.cfg.params);
  }
  /**
   * Formats an SQL query.
   * @param {string} query - The SQL query string to be formatted
   * @return {string} The formatter query
   */
  format(e) {
    const t = this.parse(e), i = this.formatAst(t);
    return this.postFormat(i).trimEnd();
  }
  parse(e) {
    return QQe(this.dialect.tokenizer).parse(e, this.cfg.paramTypes || {});
  }
  formatAst(e) {
    return e.map((t) => this.formatStatement(t)).join(`
`.repeat(this.cfg.linesBetweenQueries + 1));
  }
  formatStatement(e) {
    const t = new Gb({
      cfg: this.cfg,
      dialectCfg: this.dialect.formatOptions,
      params: this.params,
      layout: new s8(new l8(ZB(this.cfg)))
    }).format(e.children);
    return e.hasSemicolon && (this.cfg.newlineBeforeSemicolon ? t.add(Z.NEWLINE, ";") : t.add(Z.NO_NEWLINE, ";")), t.toString();
  }
  postFormat(e) {
    return this.cfg.tabulateAlias && (e = WQe(e)), (this.cfg.commaPosition === "before" || this.cfg.commaPosition === "tabular") && (e = $Qe(e, this.cfg.commaPosition, ZB(this.cfg))), e;
  }
}
class uu extends Error {
}
function tUe(r) {
  if ("multilineLists" in r)
    throw new uu("multilineLists config is no more supported.");
  if ("newlineBeforeOpenParen" in r)
    throw new uu("newlineBeforeOpenParen config is no more supported.");
  if ("newlineBeforeCloseParen" in r)
    throw new uu("newlineBeforeCloseParen config is no more supported.");
  if ("aliasAs" in r)
    throw new uu("aliasAs config is no more supported.");
  if (r.expressionWidth <= 0)
    throw new uu(`expressionWidth config must be positive number. Received ${r.expressionWidth} instead.`);
  if (r.commaPosition === "before" && r.useTabs)
    throw new uu("commaPosition: before does not work when tabs are used for indentation.");
  return r.params && !rUe(r.params) && console.warn('WARNING: All "params" option values should be strings.'), r;
}
function rUe(r) {
  return (r instanceof Array ? r : Object.values(r)).every((t) => typeof t == "string");
}
const u8 = {
  bigquery: "bigquery",
  db2: "db2",
  hive: "hive",
  mariadb: "mariadb",
  mysql: "mysql",
  n1ql: "n1ql",
  plsql: "plsql",
  postgresql: "postgresql",
  redshift: "redshift",
  spark: "spark",
  sqlite: "sqlite",
  sql: "sql",
  trino: "trino",
  transactsql: "transactsql",
  tsql: "transactsql",
  // alias for transactsq
  singlestoredb: "singlestoredb",
  snowflake: "snowflake"
}, iUe = Object.keys(u8), nUe = {
  tabWidth: 2,
  useTabs: !1,
  keywordCase: "preserve",
  indentStyle: "standard",
  logicalOperatorNewline: "before",
  tabulateAlias: !1,
  commaPosition: "after",
  expressionWidth: 50,
  linesBetweenQueries: 1,
  denseOperators: !1,
  newlineBeforeSemicolon: !1
}, aUe = (r, e = {}) => {
  if (typeof e.language == "string" && !iUe.includes(e.language))
    throw new uu(`Unsupported SQL dialect: ${e.language}`);
  const t = u8[e.language || "sql"];
  return oUe(r, {
    ...e,
    dialect: tQe[t]
  });
}, oUe = (r, {
  dialect: e,
  ...t
}) => {
  if (typeof r != "string")
    throw new Error("Invalid query argument. Expected string, instead got " + typeof r);
  const i = tUe({
    ...nUe,
    ...t
  });
  return new eUe(vQe(e), i).format(r);
}, sUe = (r) => (_V("data-v-2c7105e7"), r = r(), IV(), r), lUe = { class: "ns-codeide-option-box" }, uUe = { class: "ns-codeide-optionleft-box" }, hUe = ["src"], cUe = ["src"], fUe = { class: "ns-codeide-optionright-box" }, dUe = /* @__PURE__ */ sUe(() => /* @__PURE__ */ dt("div", { id: "code" }, null, -1)), pUe = { class: "ns-codeide-hide" }, gUe = /* @__PURE__ */ xi({
  __name: "codeide",
  props: {
    code: {
      type: String,
      default: ""
    },
    language: {
      type: String,
      default: "javascript"
    },
    formatterFn: {
      type: Function,
      default: void 0
    },
    theme: {
      type: String,
      default: "oneDark"
    }
  },
  emits: ["change", "keypress", "keydown"],
  setup(r, { emit: e }) {
    const t = r, i = Sr(), n = Sr();
    let a = null;
    function o(f) {
      switch (f) {
        case "java":
          return [SMe()];
        case "javascript":
          return [Bm()];
        case "css":
          return [h1()];
        case "html":
          return [h1(), TLe(), Bm()];
        case "json":
          return [_Le()];
        case "sql":
          return [cDe()];
        case "python":
          return [vMe()];
        default:
          return [Bm()];
      }
    }
    function s(f, d) {
      if (!a)
        return;
      const p = a.state.update({
        changes: f,
        selection: d
      });
      a.dispatch(p);
    }
    function l() {
      n.value && n.value.click();
    }
    function u() {
      if (!n.value) {
        setTimeout(() => {
          u();
        }, 200);
        return;
      }
      n.value.addEventListener("change", (f) => {
        const d = f.target.files;
        if (!d)
          return;
        const p = d[0], g = new FileReader();
        g.onload = (v) => {
          var m;
          const O = (m = v.target) == null ? void 0 : m.result;
          if (O && a) {
            const { doc: E, selection: b } = a == null ? void 0 : a.state, T = { from: 0, to: E ? E.length : 0, insert: O };
            b.ranges[0] && (b.ranges[0].to = 0, b.ranges[0].from = 0), s(T, b);
          }
        }, g.readAsText(p);
      });
    }
    function h() {
      if (!a)
        return;
      function f(v) {
        const O = { from: 0, to: p ? p.length : 0, insert: v };
        e("change", v), s(O);
      }
      const { doc: d } = a.state, p = d.toString();
      let g = "";
      if (t.formatterFn)
        g = t.formatterFn(p);
      else
        switch (t.language) {
          case "sql":
            g = aUe(p, { language: "sql" });
            break;
          default:
            console.warn(`ns-codeide: don't supported this language[${t.language}] code formatter!`);
            break;
        }
      if (g)
        switch (BAe(g)) {
          case "promise":
            g.then((v) => {
              f(v);
            });
            break;
          default:
            f(g);
        }
    }
    function c() {
      switch (t.theme) {
        case "oneDark":
          return GG;
        case "materialLight":
          return oPe;
        case "materialDark":
          return uPe;
        case "solarizedLight":
          return fPe;
        case "solarizedDark":
          return gPe;
        case "dracula":
          return mPe;
        case "githubLight":
          return SPe;
        case "tokyoNight":
          return RPe;
        case "tokyoNightStorm":
          return _Pe;
        default:
          return console.warn(`ns-codeide don't supported: set theme is ${t.theme}`), GG;
      }
    }
    return Vn(() => t.code, (f, d) => {
      if (a && f !== d) {
        const { doc: p, selection: g } = a.state, v = { from: 0, to: p ? p.length : 0, insert: f };
        s(v, g);
      }
    }), po(() => {
      var p;
      u();
      const f = [];
      Object.keys(OG).forEach((g) => {
        f.push(OG[g]);
      });
      const d = St.create({
        doc: `${t.code}`,
        extensions: [
          Wwe,
          ov.of(f),
          s9({
            defaultKeymap: !0
          }),
          ...o(t.language),
          c()
        ]
      });
      a = new ge({
        state: d,
        parent: ((p = i.value) == null ? void 0 : p.children).code
      }), a == null || a.dom.addEventListener("keyup", (g) => {
        e("change", a == null ? void 0 : a.state.doc.toString());
      });
    }), (f, d) => (Tt(), ir("div", {
      class: "ns-code-ide-box",
      ref_key: "RefMainBox",
      ref: i
    }, [
      dt("div", lUe, [
        dt("div", uUe, [
          dt("img", {
            src: Fc(VAe),
            onClick: h
          }, null, 8, hUe),
          dt("img", {
            src: Fc(FAe),
            onClick: l
          }, null, 8, cUe),
          oi(f.$slots, "left-option", {}, void 0, !0)
        ]),
        dt("div", fUe, [
          oi(f.$slots, "right-option", {}, void 0, !0)
        ])
      ]),
      dUe,
      dt("div", pUe, [
        dt("input", {
          type: "file",
          ref_key: "RefInput",
          ref: n
        }, null, 512)
      ])
    ], 512));
  }
}), vUe = `.ns-code-ide-box[data-v-2c7105e7]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;overflow-y:auto}.ns-code-ide-box .ns-codeide-option-box[data-v-2c7105e7]{width:100%;height:24px;overflow:hidden;box-sizing:border-box;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--ns-border-color);border-bottom:0;background-color:var(--ns-background-gray)}.ns-code-ide-box .ns-codeide-option-box[data-v-2c7105e7] img{width:16px;height:16px;margin:0 5px}.ns-code-ide-box .ns-codeide-option-box[data-v-2c7105e7] img:hover{cursor:pointer;filter:drop-shadow(0 0 1px var(--ns-primary-light-1))}.ns-code-ide-box .ns-codeide-option-box .ns-codeide-optionleft-box[data-v-2c7105e7]{width:50%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:flex-start;align-items:center}.ns-code-ide-box .ns-codeide-option-box .ns-codeide-optionright-box[data-v-2c7105e7]{width:50%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:flex-end;align-items:center}.ns-code-ide-box .ns-codeide-hide[data-v-2c7105e7]{display:none}.ns-code-ide-box #code[data-v-2c7105e7]{width:100%;height:calc(100% - 24px);overflow:hidden;box-sizing:border-box;overflow-y:auto;text-align:left}
`, OUe = `#code{background-color:#f7f7f7}#code .cm-editor{height:100%!important;width:100%}#code .cm-editor .cm-scroller{height:100%;overflow-y:auto}
`, mUe = /* @__PURE__ */ go(gUe, [["styles", [vUe, OUe]], ["__scopeId", "data-v-2c7105e7"]]);
class zi {
  constructor(e) {
    this.table = e;
  }
  //////////////////////////////////////////
  /////////////// DataLoad /////////////////
  //////////////////////////////////////////
  reloadData(e, t, i) {
    return this.table.dataLoader.load(e, void 0, void 0, void 0, t, i);
  }
  //////////////////////////////////////////
  ///////////// Localization ///////////////
  //////////////////////////////////////////
  langText() {
    return this.table.modules.localize.getText(...arguments);
  }
  langBind() {
    return this.table.modules.localize.bind(...arguments);
  }
  langLocale() {
    return this.table.modules.localize.getLocale(...arguments);
  }
  //////////////////////////////////////////
  ////////// Inter Table Comms /////////////
  //////////////////////////////////////////
  commsConnections() {
    return this.table.modules.comms.getConnections(...arguments);
  }
  commsSend() {
    return this.table.modules.comms.send(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Layout  /////////////////
  //////////////////////////////////////////
  layoutMode() {
    return this.table.modules.layout.getMode();
  }
  layoutRefresh(e) {
    return this.table.modules.layout.layout(e);
  }
  //////////////////////////////////////////
  /////////////// Event Bus ////////////////
  //////////////////////////////////////////
  subscribe() {
    return this.table.eventBus.subscribe(...arguments);
  }
  unsubscribe() {
    return this.table.eventBus.unsubscribe(...arguments);
  }
  subscribed(e) {
    return this.table.eventBus.subscribed(e);
  }
  subscriptionChange() {
    return this.table.eventBus.subscriptionChange(...arguments);
  }
  dispatch() {
    return this.table.eventBus.dispatch(...arguments);
  }
  chain() {
    return this.table.eventBus.chain(...arguments);
  }
  confirm() {
    return this.table.eventBus.confirm(...arguments);
  }
  dispatchExternal() {
    return this.table.externalEvents.dispatch(...arguments);
  }
  subscribedExternal(e) {
    return this.table.externalEvents.subscribed(e);
  }
  subscriptionChangeExternal() {
    return this.table.externalEvents.subscriptionChange(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Options /////////////////
  //////////////////////////////////////////
  options(e) {
    return this.table.options[e];
  }
  setOption(e, t) {
    return typeof t < "u" && (this.table.options[e] = t), this.table.options[e];
  }
  //////////////////////////////////////////
  /////////// Deprecation Checks ///////////
  //////////////////////////////////////////
  deprecationCheck(e, t) {
    return this.table.deprecationAdvisor.check(e, t);
  }
  deprecationCheckMsg(e, t) {
    return this.table.deprecationAdvisor.checkMsg(e, t);
  }
  deprecationMsg(e) {
    return this.table.deprecationAdvisor.msg(e);
  }
  //////////////////////////////////////////
  //////////////// Modules /////////////////
  //////////////////////////////////////////
  module(e) {
    return this.table.module(e);
  }
}
class Wt {
  static elVisible(e) {
    return !(e.offsetWidth <= 0 && e.offsetHeight <= 0);
  }
  static elOffset(e) {
    var t = e.getBoundingClientRect();
    return {
      top: t.top + window.pageYOffset - document.documentElement.clientTop,
      left: t.left + window.pageXOffset - document.documentElement.clientLeft
    };
  }
  static deepClone(e, t, i = []) {
    var n = {}.__proto__, a = [].__proto__;
    t || (t = Object.assign(Array.isArray(e) ? [] : {}, e));
    for (var o in e) {
      let s = e[o], l, u;
      s != null && typeof s == "object" && (s.__proto__ === n || s.__proto__ === a) && (l = i.findIndex((h) => h.subject === s), l > -1 ? t[o] = i[l].copy : (u = Object.assign(Array.isArray(s) ? [] : {}, s), i.unshift({ subject: s, copy: u }), t[o] = this.deepClone(s, u, i)));
    }
    return t;
  }
}
class CP extends zi {
  constructor(e, t, i) {
    super(e), this.element = t, this.container = this._lookupContainer(), this.parent = i, this.reversedX = !1, this.childPopup = null, this.blurable = !1, this.blurCallback = null, this.blurEventsBound = !1, this.renderedCallback = null, this.visible = !1, this.hideable = !0, this.element.classList.add("tabulator-popup-container"), this.blurEvent = this.hide.bind(this, !1), this.escEvent = this._escapeCheck.bind(this), this.destroyBinding = this.tableDestroyed.bind(this), this.destroyed = !1;
  }
  tableDestroyed() {
    this.destroyed = !0, this.hide(!0);
  }
  _lookupContainer() {
    var e = this.table.options.popupContainer;
    return typeof e == "string" ? (e = document.querySelector(e), e || console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)")) : e === !0 && (e = this.table.element), e && !this._checkContainerIsParent(e) && (e = !1, console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)")), e || (e = document.body), e;
  }
  _checkContainerIsParent(e, t = this.table.element) {
    return e === t ? !0 : t.parentNode ? this._checkContainerIsParent(e, t.parentNode) : !1;
  }
  renderCallback(e) {
    this.renderedCallback = e;
  }
  containerEventCoords(e) {
    var t = !(e instanceof MouseEvent), i = t ? e.touches[0].pageX : e.pageX, n = t ? e.touches[0].pageY : e.pageY;
    if (this.container !== document.body) {
      let a = Wt.elOffset(this.container);
      i -= a.left, n -= a.top;
    }
    return { x: i, y: n };
  }
  elementPositionCoords(e, t = "right") {
    var i = Wt.elOffset(e), n, a, o;
    switch (this.container !== document.body && (n = Wt.elOffset(this.container), i.left -= n.left, i.top -= n.top), t) {
      case "right":
        a = i.left + e.offsetWidth, o = i.top - 1;
        break;
      case "bottom":
        a = i.left, o = i.top + e.offsetHeight;
        break;
      case "left":
        a = i.left, o = i.top - 1;
        break;
      case "top":
        a = i.left, o = i.top;
        break;
      case "center":
        a = i.left + e.offsetWidth / 2, o = i.top + e.offsetHeight / 2;
        break;
    }
    return { x: a, y: o, offset: i };
  }
  show(e, t) {
    var i, n, a, o, s;
    return this.destroyed || this.table.destroyed ? this : (e instanceof HTMLElement ? (a = e, s = this.elementPositionCoords(e, t), o = s.offset, i = s.x, n = s.y) : typeof e == "number" ? (o = { top: 0, left: 0 }, i = e, n = t) : (s = this.containerEventCoords(e), i = s.x, n = s.y, this.reversedX = !1), this.element.style.top = n + "px", this.element.style.left = i + "px", this.container.appendChild(this.element), typeof this.renderedCallback == "function" && this.renderedCallback(), this._fitToScreen(i, n, a, o, t), this.visible = !0, this.subscribe("table-destroy", this.destroyBinding), this.element.addEventListener("mousedown", (l) => {
      l.stopPropagation();
    }), this);
  }
  _fitToScreen(e, t, i, n, a) {
    var o = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
    if ((e + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) && (this.element.style.left = "", i ? this.element.style.right = this.container.offsetWidth - n.left + "px" : this.element.style.right = this.container.offsetWidth - e + "px", this.reversedX = !0), t + this.element.offsetHeight > Math.max(this.container.offsetHeight, o ? this.container.scrollHeight : 0))
      if (i)
        switch (a) {
          case "bottom":
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - i.offsetHeight - 1 + "px";
            break;
          default:
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + i.offsetHeight + 1 + "px";
        }
      else
        this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + "px";
  }
  isVisible() {
    return this.visible;
  }
  hideOnBlur(e) {
    return this.blurable = !0, this.visible && (setTimeout(() => {
      this.visible && (this.table.rowManager.element.addEventListener("scroll", this.blurEvent), this.subscribe("cell-editing", this.blurEvent), document.body.addEventListener("click", this.blurEvent), document.body.addEventListener("contextmenu", this.blurEvent), document.body.addEventListener("mousedown", this.blurEvent), window.addEventListener("resize", this.blurEvent), document.body.addEventListener("keydown", this.escEvent), this.blurEventsBound = !0);
    }, 100), this.blurCallback = e), this;
  }
  _escapeCheck(e) {
    e.keyCode == 27 && this.hide();
  }
  blockHide() {
    this.hideable = !1;
  }
  restoreHide() {
    this.hideable = !0;
  }
  hide(e = !1) {
    return this.visible && this.hideable && (this.blurable && this.blurEventsBound && (document.body.removeEventListener("keydown", this.escEvent), document.body.removeEventListener("click", this.blurEvent), document.body.removeEventListener("contextmenu", this.blurEvent), document.body.removeEventListener("mousedown", this.blurEvent), window.removeEventListener("resize", this.blurEvent), this.table.rowManager.element.removeEventListener("scroll", this.blurEvent), this.unsubscribe("cell-editing", this.blurEvent), this.blurEventsBound = !1), this.childPopup && this.childPopup.hide(), this.parent && (this.parent.childPopup = null), this.element.parentNode && this.element.parentNode.removeChild(this.element), this.visible = !1, this.blurCallback && !e && this.blurCallback(), this.unsubscribe("table-destroy", this.destroyBinding)), this;
  }
  child(e) {
    return this.childPopup && this.childPopup.hide(), this.childPopup = new CP(this.table, e, this), this.childPopup;
  }
}
class pt extends zi {
  constructor(e, t) {
    super(e), this._handler = null;
  }
  initialize() {
  }
  ///////////////////////////////////
  ////// Options Registration ///////
  ///////////////////////////////////
  registerTableOption(e, t) {
    this.table.optionsList.register(e, t);
  }
  registerColumnOption(e, t) {
    this.table.columnManager.optionsList.register(e, t);
  }
  ///////////////////////////////////
  /// Public Function Registration ///
  ///////////////////////////////////
  registerTableFunction(e, t) {
    typeof this.table[e] > "u" ? this.table[e] = (...i) => (this.table.initGuard(e), t(...i)) : console.warn("Unable to bind table function, name already in use", e);
  }
  registerComponentFunction(e, t, i) {
    return this.table.componentFunctionBinder.bind(e, t, i);
  }
  ///////////////////////////////////
  ////////// Data Pipeline //////////
  ///////////////////////////////////
  registerDataHandler(e, t) {
    this.table.rowManager.registerDataPipelineHandler(e, t), this._handler = e;
  }
  registerDisplayHandler(e, t) {
    this.table.rowManager.registerDisplayPipelineHandler(e, t), this._handler = e;
  }
  displayRows(e) {
    var t = this.table.rowManager.displayRows.length - 1, i;
    if (this._handler && (i = this.table.rowManager.displayPipeline.findIndex((n) => n.handler === this._handler), i > -1 && (t = i)), e && (t = t + e), this._handler)
      return t > -1 ? this.table.rowManager.getDisplayRows(t) : this.activeRows();
  }
  activeRows() {
    return this.table.rowManager.activeRows;
  }
  refreshData(e, t) {
    t || (t = this._handler), t && this.table.rowManager.refreshActiveData(t, !1, e);
  }
  ///////////////////////////////////
  //////// Footer Management ////////
  ///////////////////////////////////
  footerAppend(e) {
    return this.table.footerManager.append(e);
  }
  footerPrepend(e) {
    return this.table.footerManager.prepend(e);
  }
  footerRemove(e) {
    return this.table.footerManager.remove(e);
  }
  ///////////////////////////////////
  //////// Popups Management ////////
  ///////////////////////////////////
  popup(e, t) {
    return new CP(this.table, e, t);
  }
  ///////////////////////////////////
  //////// Alert Management ////////
  ///////////////////////////////////
  alert(e, t) {
    return this.table.alertManager.alert(e, t);
  }
  clearAlert() {
    return this.table.alertManager.clear();
  }
}
var EUe = {};
class ch extends pt {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"], this.registerColumnOption("accessor"), this.registerColumnOption("accessorParams"), this.registerColumnOption("accessorData"), this.registerColumnOption("accessorDataParams"), this.registerColumnOption("accessorDownload"), this.registerColumnOption("accessorDownloadParams"), this.registerColumnOption("accessorClipboard"), this.registerColumnOption("accessorClipboardParams"), this.registerColumnOption("accessorPrint"), this.registerColumnOption("accessorPrintParams"), this.registerColumnOption("accessorHtmlOutput"), this.registerColumnOption("accessorHtmlOutputParams");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-retrieve", this.transformRow.bind(this));
  }
  //initialize column accessor
  initializeColumn(e) {
    var t = !1, i = {};
    this.allowedTypes.forEach((n) => {
      var a = "accessor" + (n.charAt(0).toUpperCase() + n.slice(1)), o;
      e.definition[a] && (o = this.lookupAccessor(e.definition[a]), o && (t = !0, i[a] = {
        accessor: o,
        params: e.definition[a + "Params"] || {}
      }));
    }), t && (e.modules.accessor = i);
  }
  lookupAccessor(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        ch.accessors[e] ? t = ch.accessors[e] : console.warn("Accessor Error - No such accessor found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply accessor to row
  transformRow(e, t) {
    var i = "accessor" + (t.charAt(0).toUpperCase() + t.slice(1)), n = e.getComponent(), a = Wt.deepClone(e.data || {});
    return this.table.columnManager.traverse(function(o) {
      var s, l, u, h;
      o.modules.accessor && (l = o.modules.accessor[i] || o.modules.accessor.accessor || !1, l && (s = o.getFieldValue(a), s != "undefined" && (h = o.getComponent(), u = typeof l.params == "function" ? l.params(s, a, t, h, n) : l.params, o.setFieldValue(a, l.accessor(s, a, t, u, h, n)))));
    }), a;
  }
}
ch.moduleName = "accessor";
ch.accessors = EUe;
var bUe = {
  method: "GET"
};
function O1(r, e) {
  var t = [];
  if (e = e || "", Array.isArray(r))
    r.forEach((n, a) => {
      t = t.concat(O1(n, e ? e + "[" + a + "]" : a));
    });
  else if (typeof r == "object")
    for (var i in r)
      t = t.concat(O1(r[i], e ? e + "[" + i + "]" : i));
  else
    t.push({ key: e, value: r });
  return t;
}
function SUe(r) {
  var e = O1(r), t = [];
  return e.forEach(function(i) {
    t.push(encodeURIComponent(i.key) + "=" + encodeURIComponent(i.value));
  }), t.join("&");
}
function h8(r, e, t) {
  return r && t && Object.keys(t).length && (!e.method || e.method.toLowerCase() == "get") && (e.method = "get", r += (r.includes("?") ? "&" : "?") + SUe(t)), r;
}
function TUe(r, e, t) {
  var i;
  return new Promise((n, a) => {
    if (r = this.urlGenerator.call(this.table, r, e, t), e.method.toUpperCase() != "GET")
      if (i = typeof this.table.options.ajaxContentType == "object" ? this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType], i) {
        for (var o in i.headers)
          e.headers || (e.headers = {}), typeof e.headers[o] > "u" && (e.headers[o] = i.headers[o]);
        e.body = i.body.call(this, r, e, t);
      } else
        console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
    r ? (typeof e.headers > "u" && (e.headers = {}), typeof e.headers.Accept > "u" && (e.headers.Accept = "application/json"), typeof e.headers["X-Requested-With"] > "u" && (e.headers["X-Requested-With"] = "XMLHttpRequest"), typeof e.mode > "u" && (e.mode = "cors"), e.mode == "cors" ? (typeof e.headers.Origin > "u" && (e.headers.Origin = window.location.origin), typeof e.credentials > "u" && (e.credentials = "same-origin")) : typeof e.credentials > "u" && (e.credentials = "include"), fetch(r, e).then((s) => {
      s.ok ? s.json().then((l) => {
        n(l);
      }).catch((l) => {
        a(l), console.warn("Ajax Load Error - Invalid JSON returned", l);
      }) : (console.error("Ajax Load Error - Connection Error: " + s.status, s.statusText), a(s));
    }).catch((s) => {
      console.error("Ajax Load Error - Connection Error: ", s), a(s);
    })) : (console.warn("Ajax Load Error - No URL Set"), n([]));
  });
}
function m1(r, e) {
  var t = [];
  if (e = e || "", Array.isArray(r))
    r.forEach((n, a) => {
      t = t.concat(m1(n, e ? e + "[" + a + "]" : a));
    });
  else if (typeof r == "object")
    for (var i in r)
      t = t.concat(m1(r[i], e ? e + "[" + i + "]" : i));
  else
    t.push({ key: e, value: r });
  return t;
}
var yUe = {
  json: {
    headers: {
      "Content-Type": "application/json"
    },
    body: function(r, e, t) {
      return JSON.stringify(t);
    }
  },
  form: {
    headers: {},
    body: function(r, e, t) {
      var i = m1(t), n = new FormData();
      return i.forEach(function(a) {
        n.append(a.key, a.value);
      }), n;
    }
  }
};
class pa extends pt {
  constructor(e) {
    super(e), this.config = {}, this.url = "", this.urlGenerator = !1, this.params = !1, this.loaderPromise = !1, this.registerTableOption("ajaxURL", !1), this.registerTableOption("ajaxURLGenerator", !1), this.registerTableOption("ajaxParams", {}), this.registerTableOption("ajaxConfig", "get"), this.registerTableOption("ajaxContentType", "form"), this.registerTableOption("ajaxRequestFunc", !1), this.registerTableOption("ajaxRequesting", function() {
    }), this.registerTableOption("ajaxResponse", !1), this.contentTypeFormatters = pa.contentTypeFormatters;
  }
  //initialize setup options
  initialize() {
    this.loaderPromise = this.table.options.ajaxRequestFunc || pa.defaultLoaderPromise, this.urlGenerator = this.table.options.ajaxURLGenerator || pa.defaultURLGenerator, this.table.options.ajaxURL && this.setUrl(this.table.options.ajaxURL), this.setDefaultConfig(this.table.options.ajaxConfig), this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this)), this.subscribe("data-loading", this.requestDataCheck.bind(this)), this.subscribe("data-params", this.requestParams.bind(this)), this.subscribe("data-load", this.requestData.bind(this));
  }
  requestParams(e, t, i, n) {
    var a = this.table.options.ajaxParams;
    return a && (typeof a == "function" && (a = a.call(this.table)), n = Object.assign(n, a)), n;
  }
  requestDataCheck(e, t, i, n) {
    return !!(!e && this.url || typeof e == "string");
  }
  requestData(e, t, i, n, a) {
    var o;
    return !a && this.requestDataCheck(e) ? (e && this.setUrl(e), o = this.generateConfig(i), this.sendRequest(this.url, t, o)) : a;
  }
  setDefaultConfig(e = {}) {
    this.config = Object.assign({}, pa.defaultConfig), typeof e == "string" ? this.config.method = e : Object.assign(this.config, e);
  }
  //load config object
  generateConfig(e = {}) {
    var t = Object.assign({}, this.config);
    return typeof e == "string" ? t.method = e : Object.assign(t, e), t;
  }
  //set request url
  setUrl(e) {
    this.url = e;
  }
  //get request url
  getUrl() {
    return this.url;
  }
  //send ajax request
  sendRequest(e, t, i) {
    return this.table.options.ajaxRequesting.call(this.table, e, t) !== !1 ? this.loaderPromise(e, i, t).then((n) => (this.table.options.ajaxResponse && (n = this.table.options.ajaxResponse.call(this.table, e, t, n)), n)) : Promise.reject();
  }
}
pa.moduleName = "ajax";
pa.defaultConfig = bUe;
pa.defaultURLGenerator = h8;
pa.defaultLoaderPromise = TUe;
pa.contentTypeFormatters = yUe;
var RUe = {
  replace: function(r) {
    return this.table.setData(r);
  },
  update: function(r) {
    return this.table.updateOrAddData(r);
  },
  insert: function(r) {
    return this.table.addData(r);
  }
}, AUe = {
  table: function(r) {
    var e = [], t = !0, i = this.table.columnManager.columns, n = [], a = [];
    return r = r.split(`
`), r.forEach(function(o) {
      e.push(o.split("	"));
    }), e.length && !(e.length === 1 && e[0].length < 2) ? (e[0].forEach(function(o) {
      var s = i.find(function(l) {
        return o && l.definition.title && o.trim() && l.definition.title.trim() === o.trim();
      });
      s ? n.push(s) : t = !1;
    }), t || (t = !0, n = [], e[0].forEach(function(o) {
      var s = i.find(function(l) {
        return o && l.field && o.trim() && l.field.trim() === o.trim();
      });
      s ? n.push(s) : t = !1;
    }), t || (n = this.table.columnManager.columnsByIndex)), t && e.shift(), e.forEach(function(o) {
      var s = {};
      o.forEach(function(l, u) {
        n[u] && (s[n[u].field] = l);
      }), a.push(s);
    }), a) : !1;
  }
};
class El extends pt {
  constructor(e) {
    super(e), this.mode = !0, this.pasteParser = function() {
    }, this.pasteAction = function() {
    }, this.customSelection = !1, this.rowRange = !1, this.blocked = !0, this.registerTableOption("clipboard", !1), this.registerTableOption("clipboardCopyStyled", !0), this.registerTableOption("clipboardCopyConfig", !1), this.registerTableOption("clipboardCopyFormatter", !1), this.registerTableOption("clipboardCopyRowRange", "active"), this.registerTableOption("clipboardPasteParser", "table"), this.registerTableOption("clipboardPasteAction", "insert"), this.registerColumnOption("clipboard"), this.registerColumnOption("titleClipboard");
  }
  initialize() {
    this.mode = this.table.options.clipboard, this.rowRange = this.table.options.clipboardCopyRowRange, (this.mode === !0 || this.mode === "copy") && this.table.element.addEventListener("copy", (e) => {
      var t, i, n;
      this.blocked || (e.preventDefault(), this.customSelection ? (t = this.customSelection, this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t))) : (n = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard"), i = this.table.modules.export.generateHTMLTable(n), t = i ? this.generatePlainContent(n) : "", this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t), i = this.table.options.clipboardCopyFormatter("html", i))), window.clipboardData && window.clipboardData.setData ? window.clipboardData.setData("Text", t) : e.clipboardData && e.clipboardData.setData ? (e.clipboardData.setData("text/plain", t), i && e.clipboardData.setData("text/html", i)) : e.originalEvent && e.originalEvent.clipboardData.setData && (e.originalEvent.clipboardData.setData("text/plain", t), i && e.originalEvent.clipboardData.setData("text/html", i)), this.dispatchExternal("clipboardCopied", t, i), this.reset());
    }), (this.mode === !0 || this.mode === "paste") && this.table.element.addEventListener("paste", (e) => {
      this.paste(e);
    }), this.setPasteParser(this.table.options.clipboardPasteParser), this.setPasteAction(this.table.options.clipboardPasteAction), this.registerTableFunction("copyToClipboard", this.copy.bind(this));
  }
  reset() {
    this.blocked = !0, this.customSelection = !1;
  }
  generatePlainContent(e) {
    var t = [];
    return e.forEach((i) => {
      var n = [];
      i.columns.forEach((a) => {
        var o = "";
        if (a)
          if (i.type === "group" && (a.value = a.component.getKey()), a.value === null)
            o = "";
          else
            switch (typeof a.value) {
              case "object":
                o = JSON.stringify(a.value);
                break;
              case "undefined":
                o = "";
                break;
              default:
                o = a.value;
            }
        n.push(o);
      }), t.push(n.join("	"));
    }), t.join(`
`);
  }
  copy(e, t) {
    var i, n;
    this.blocked = !1, this.customSelection = !1, (this.mode === !0 || this.mode === "copy") && (this.rowRange = e || this.table.options.clipboardCopyRowRange, typeof window.getSelection < "u" && typeof document.createRange < "u" ? (e = document.createRange(), e.selectNodeContents(this.table.element), i = window.getSelection(), i.toString() && t && (this.customSelection = i.toString()), i.removeAllRanges(), i.addRange(e)) : typeof document.selection < "u" && typeof document.body.createTextRange < "u" && (n = document.body.createTextRange(), n.moveToElementText(this.table.element), n.select()), document.execCommand("copy"), i && i.removeAllRanges());
  }
  //PASTE EVENT HANDLING
  setPasteAction(e) {
    switch (typeof e) {
      case "string":
        this.pasteAction = El.pasteActions[e], this.pasteAction || console.warn("Clipboard Error - No such paste action found:", e);
        break;
      case "function":
        this.pasteAction = e;
        break;
    }
  }
  setPasteParser(e) {
    switch (typeof e) {
      case "string":
        this.pasteParser = El.pasteParsers[e], this.pasteParser || console.warn("Clipboard Error - No such paste parser found:", e);
        break;
      case "function":
        this.pasteParser = e;
        break;
    }
  }
  paste(e) {
    var t, i, n;
    this.checkPaseOrigin(e) && (t = this.getPasteData(e), i = this.pasteParser.call(this, t), i ? (e.preventDefault(), this.table.modExists("mutator") && (i = this.mutateData(i)), n = this.pasteAction.call(this, i), this.dispatchExternal("clipboardPasted", t, i, n)) : this.dispatchExternal("clipboardPasteError", t));
  }
  mutateData(e) {
    var t = [];
    return Array.isArray(e) ? e.forEach((i) => {
      t.push(this.table.modules.mutator.transformRow(i, "clipboard"));
    }) : t = e, t;
  }
  checkPaseOrigin(e) {
    var t = !0;
    return (e.target.tagName != "DIV" || this.table.modules.edit.currentCell) && (t = !1), t;
  }
  getPasteData(e) {
    var t;
    return window.clipboardData && window.clipboardData.getData ? t = window.clipboardData.getData("Text") : e.clipboardData && e.clipboardData.getData ? t = e.clipboardData.getData("text/plain") : e.originalEvent && e.originalEvent.clipboardData.getData && (t = e.originalEvent.clipboardData.getData("text/plain")), t;
  }
}
El.moduleName = "clipboard";
El.pasteActions = RUe;
El.pasteParsers = AUe;
class CUe {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._row.table.componentFunctionBinder.handle("row", t._row, i);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getTable() {
    return this._row.table;
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  _getSelf() {
    return this._row;
  }
}
class c8 {
  constructor(e) {
    return this._cell = e, new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._cell.table.componentFunctionBinder.handle("cell", t._cell, i);
      }
    });
  }
  getValue() {
    return this._cell.getValue();
  }
  getOldValue() {
    return this._cell.getOldValue();
  }
  getInitialValue() {
    return this._cell.initialValue;
  }
  getElement() {
    return this._cell.getElement();
  }
  getRow() {
    return this._cell.row.getComponent();
  }
  getData(e) {
    return this._cell.row.getData(e);
  }
  getType() {
    return "cell";
  }
  getField() {
    return this._cell.column.getField();
  }
  getColumn() {
    return this._cell.column.getComponent();
  }
  setValue(e, t) {
    typeof t > "u" && (t = !0), this._cell.setValue(e, t);
  }
  restoreOldValue() {
    this._cell.setValueActual(this._cell.getOldValue());
  }
  restoreInitialValue() {
    this._cell.setValueActual(this._cell.initialValue);
  }
  checkHeight() {
    this._cell.checkHeight();
  }
  getTable() {
    return this._cell.table;
  }
  _getSelf() {
    return this._cell;
  }
}
class dv extends zi {
  constructor(e, t) {
    super(e.table), this.table = e.table, this.column = e, this.row = t, this.element = null, this.value = null, this.initialValue, this.oldValue = null, this.modules = {}, this.height = null, this.width = null, this.minWidth = null, this.component = null, this.loaded = !1, this.build();
  }
  //////////////// Setup Functions /////////////////
  //generate element
  build() {
    this.generateElement(), this.setWidth(), this._configureCell(), this.setValueActual(this.column.getFieldValue(this.row.data)), this.initialValue = this.value;
  }
  generateElement() {
    this.element = document.createElement("div"), this.element.className = "tabulator-cell", this.element.setAttribute("role", "gridcell");
  }
  _configureCell() {
    var e = this.element, t = this.column.getField(), i = {
      top: "flex-start",
      bottom: "flex-end",
      middle: "center"
    }, n = {
      left: "flex-start",
      right: "flex-end",
      center: "center"
    };
    if (e.style.textAlign = this.column.hozAlign, this.column.vertAlign && (e.style.display = "inline-flex", e.style.alignItems = i[this.column.vertAlign] || "", this.column.hozAlign && (e.style.justifyContent = n[this.column.hozAlign] || "")), t && e.setAttribute("tabulator-field", t), this.column.definition.cssClass) {
      var a = this.column.definition.cssClass.split(" ");
      a.forEach((o) => {
        e.classList.add(o);
      });
    }
    this.dispatch("cell-init", this), this.column.visible || this.hide();
  }
  //generate cell contents
  _generateContents() {
    var e;
    switch (e = this.chain("cell-format", this, null, () => this.element.innerHTML = this.value), typeof e) {
      case "object":
        if (e instanceof Node) {
          for (; this.element.firstChild; )
            this.element.removeChild(this.element.firstChild);
          this.element.appendChild(e);
        } else
          this.element.innerHTML = "", e != null && console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", e);
        break;
      case "undefined":
        this.element.innerHTML = "";
        break;
      default:
        this.element.innerHTML = e;
    }
  }
  cellRendered() {
    this.dispatch("cell-rendered", this);
  }
  //////////////////// Getters ////////////////////
  getElement(e) {
    return this.loaded || (this.loaded = !0, e || this.layoutElement()), this.element;
  }
  getValue() {
    return this.value;
  }
  getOldValue() {
    return this.oldValue;
  }
  //////////////////// Actions ////////////////////
  setValue(e, t, i) {
    var n = this.setValueProcessData(e, t, i);
    n && (this.dispatch("cell-value-updated", this), this.cellRendered(), this.column.definition.cellEdited && this.column.definition.cellEdited.call(this.table, this.getComponent()), this.dispatchExternal("cellEdited", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()));
  }
  setValueProcessData(e, t, i) {
    var n = !1;
    return (this.value !== e || i) && (n = !0, t && (e = this.chain("cell-value-changing", [this, e], null, e))), this.setValueActual(e), n && this.dispatch("cell-value-changed", this), n;
  }
  setValueActual(e) {
    this.oldValue = this.value, this.value = e, this.dispatch("cell-value-save-before", this), this.column.setFieldValue(this.row.data, e), this.dispatch("cell-value-save-after", this), this.loaded && this.layoutElement();
  }
  layoutElement() {
    this._generateContents(), this.dispatch("cell-layout", this);
  }
  setWidth() {
    this.width = this.column.width, this.element.style.width = this.column.widthStyled;
  }
  clearWidth() {
    this.width = "", this.element.style.width = "";
  }
  getWidth() {
    return this.width || this.element.offsetWidth;
  }
  setMinWidth() {
    this.minWidth = this.column.minWidth, this.element.style.minWidth = this.column.minWidthStyled;
  }
  setMaxWidth() {
    this.maxWidth = this.column.maxWidth, this.element.style.maxWidth = this.column.maxWidthStyled;
  }
  checkHeight() {
    this.row.reinitializeHeight();
  }
  clearHeight() {
    this.element.style.height = "", this.height = null, this.dispatch("cell-height", this, "");
  }
  setHeight() {
    this.height = this.row.height, this.element.style.height = this.row.heightStyled, this.dispatch("cell-height", this, this.row.heightStyled);
  }
  getHeight() {
    return this.height || this.element.offsetHeight;
  }
  show() {
    this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
  }
  hide() {
    this.element.style.display = "none";
  }
  delete() {
    this.dispatch("cell-delete", this), !this.table.rowManager.redrawBlock && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.column.deleteCell(this), this.row.deleteCell(this), this.calcs = {};
  }
  getIndex() {
    return this.row.getCellIndex(this);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new c8(this)), this.component;
  }
}
class f8 {
  constructor(e) {
    return this._column = e, this.type = "ColumnComponent", new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._column.table.componentFunctionBinder.handle("column", t._column, i);
      }
    });
  }
  getElement() {
    return this._column.getElement();
  }
  getDefinition() {
    return this._column.getDefinition();
  }
  getField() {
    return this._column.getField();
  }
  getTitleDownload() {
    return this._column.getTitleDownload();
  }
  getCells() {
    var e = [];
    return this._column.cells.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  isVisible() {
    return this._column.visible;
  }
  show() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.show();
    }) : this._column.show();
  }
  hide() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.hide();
    }) : this._column.hide();
  }
  toggle() {
    this._column.visible ? this.hide() : this.show();
  }
  delete() {
    return this._column.delete();
  }
  getSubColumns() {
    var e = [];
    return this._column.columns.length && this._column.columns.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getParentColumn() {
    return this._column.parent instanceof ro ? this._column.parent.getComponent() : !1;
  }
  _getSelf() {
    return this._column;
  }
  scrollTo(e, t) {
    return this._column.table.columnManager.scrollToColumn(this._column, e, t);
  }
  getTable() {
    return this._column.table;
  }
  move(e, t) {
    var i = this._column.table.columnManager.findColumn(e);
    i ? this._column.table.columnManager.moveColumn(this._column, i, t) : console.warn("Move Error - No matching column found:", i);
  }
  getNextColumn() {
    var e = this._column.nextColumn();
    return e ? e.getComponent() : !1;
  }
  getPrevColumn() {
    var e = this._column.prevColumn();
    return e ? e.getComponent() : !1;
  }
  updateDefinition(e) {
    return this._column.updateDefinition(e);
  }
  getWidth() {
    return this._column.getWidth();
  }
  setWidth(e) {
    var t;
    return e === !0 ? t = this._column.reinitializeWidth(!0) : t = this._column.setWidth(e), this._column.table.columnManager.rerenderColumns(!0), t;
  }
}
var d8 = {
  title: void 0,
  field: void 0,
  columns: void 0,
  visible: void 0,
  hozAlign: void 0,
  vertAlign: void 0,
  width: void 0,
  minWidth: 40,
  maxWidth: void 0,
  maxInitialWidth: void 0,
  cssClass: void 0,
  variableHeight: void 0,
  headerVertical: void 0,
  headerHozAlign: void 0,
  headerWordWrap: !1,
  editableTitle: void 0
};
class ro extends zi {
  constructor(e, t) {
    super(t.table), this.definition = e, this.parent = t, this.type = "column", this.columns = [], this.cells = [], this.element = this.createElement(), this.contentElement = !1, this.titleHolderElement = !1, this.titleElement = !1, this.groupElement = this.createGroupElement(), this.isGroup = !1, this.hozAlign = "", this.vertAlign = "", this.field = "", this.fieldStructure = "", this.getFieldValue = "", this.setFieldValue = "", this.titleDownload = null, this.titleFormatterRendered = !1, this.mapDefinitions(), this.setField(this.definition.field), this.modules = {}, this.width = null, this.widthStyled = "", this.maxWidth = null, this.maxWidthStyled = "", this.maxInitialWidth = null, this.minWidth = null, this.minWidthStyled = "", this.widthFixed = !1, this.visible = !0, this.component = null, this.definition.columns ? (this.isGroup = !0, this.definition.columns.forEach((i, n) => {
      var a = new ro(i, this);
      this.attachColumn(a);
    }), this.checkColumnVisibility()) : t.registerColumnField(this), this._initialize();
  }
  createElement() {
    var e = document.createElement("div");
    switch (e.classList.add("tabulator-col"), e.setAttribute("role", "columnheader"), e.setAttribute("aria-sort", "none"), this.table.options.columnHeaderVertAlign) {
      case "middle":
        e.style.justifyContent = "center";
        break;
      case "bottom":
        e.style.justifyContent = "flex-end";
        break;
    }
    return e;
  }
  createGroupElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-group-cols"), e;
  }
  mapDefinitions() {
    var e = this.table.options.columnDefaults;
    if (e)
      for (let t in e)
        typeof this.definition[t] > "u" && (this.definition[t] = e[t]);
    this.definition = this.table.columnManager.optionsList.generate(ro.defaultOptionList, this.definition);
  }
  checkDefinition() {
    Object.keys(this.definition).forEach((e) => {
      ro.defaultOptionList.indexOf(e) === -1 && console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", e);
    });
  }
  setField(e) {
    this.field = e, this.fieldStructure = e ? this.table.options.nestedFieldSeparator ? e.split(this.table.options.nestedFieldSeparator) : [e] : [], this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData, this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
  }
  //register column position with column manager
  registerColumnPosition(e) {
    this.parent.registerColumnPosition(e);
  }
  //register column position with column manager
  registerColumnField(e) {
    this.parent.registerColumnField(e);
  }
  //trigger position registration
  reRegisterPosition() {
    this.isGroup ? this.columns.forEach(function(e) {
      e.reRegisterPosition();
    }) : this.registerColumnPosition(this);
  }
  //build header element
  _initialize() {
    for (var e = this.definition; this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    e.headerVertical && (this.element.classList.add("tabulator-col-vertical"), e.headerVertical === "flip" && this.element.classList.add("tabulator-col-vertical-flip")), this.contentElement = this._buildColumnHeaderContent(), this.element.appendChild(this.contentElement), this.isGroup ? this._buildGroupHeader() : this._buildColumnHeader(), this.dispatch("column-init", this);
  }
  //build header element for header
  _buildColumnHeader() {
    var e = this.definition;
    if (this.dispatch("column-layout", this), typeof e.visible < "u" && (e.visible ? this.show(!0) : this.hide(!0)), e.cssClass) {
      var t = e.cssClass.split(" ");
      t.forEach((i) => {
        this.element.classList.add(i);
      });
    }
    e.field && this.element.setAttribute("tabulator-field", e.field), this.setMinWidth(parseInt(e.minWidth)), e.maxInitialWidth && (this.maxInitialWidth = parseInt(e.maxInitialWidth)), e.maxWidth && this.setMaxWidth(parseInt(e.maxWidth)), this.reinitializeWidth(), this.hozAlign = this.definition.hozAlign, this.vertAlign = this.definition.vertAlign, this.titleElement.style.textAlign = this.definition.headerHozAlign;
  }
  _buildColumnHeaderContent() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-content"), this.titleHolderElement = document.createElement("div"), this.titleHolderElement.classList.add("tabulator-col-title-holder"), e.appendChild(this.titleHolderElement), this.titleElement = this._buildColumnHeaderTitle(), this.titleHolderElement.appendChild(this.titleElement), e;
  }
  //build title element of column
  _buildColumnHeaderTitle() {
    var e = this.definition, t = document.createElement("div");
    if (t.classList.add("tabulator-col-title"), e.headerWordWrap && t.classList.add("tabulator-col-title-wrap"), e.editableTitle) {
      var i = document.createElement("input");
      i.classList.add("tabulator-title-editor"), i.addEventListener("click", (n) => {
        n.stopPropagation(), i.focus();
      }), i.addEventListener("change", () => {
        e.title = i.value, this.dispatchExternal("columnTitleChanged", this.getComponent());
      }), t.appendChild(i), e.field ? this.langBind("columns|" + e.field, (n) => {
        i.value = n || e.title || "&nbsp;";
      }) : i.value = e.title || "&nbsp;";
    } else
      e.field ? this.langBind("columns|" + e.field, (n) => {
        this._formatColumnHeaderTitle(t, n || e.title || "&nbsp;");
      }) : this._formatColumnHeaderTitle(t, e.title || "&nbsp;");
    return t;
  }
  _formatColumnHeaderTitle(e, t) {
    var i = this.chain("column-format", [this, t, e], null, () => t);
    switch (typeof i) {
      case "object":
        i instanceof Node ? e.appendChild(i) : (e.innerHTML = "", console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", i));
        break;
      case "undefined":
        e.innerHTML = "";
        break;
      default:
        e.innerHTML = i;
    }
  }
  //build header element for column group
  _buildGroupHeader() {
    if (this.element.classList.add("tabulator-col-group"), this.element.setAttribute("role", "columngroup"), this.element.setAttribute("aria-title", this.definition.title), this.definition.cssClass) {
      var e = this.definition.cssClass.split(" ");
      e.forEach((t) => {
        this.element.classList.add(t);
      });
    }
    this.titleElement.style.textAlign = this.definition.headerHozAlign, this.element.appendChild(this.groupElement);
  }
  //flat field lookup
  _getFlatData(e) {
    return e[this.field];
  }
  //nested field lookup
  _getNestedData(e) {
    var t = e, i = this.fieldStructure, n = i.length, a;
    for (let o = 0; o < n && (t = t[i[o]], a = t, !!t); o++)
      ;
    return a;
  }
  //flat field set
  _setFlatData(e, t) {
    this.field && (e[this.field] = t);
  }
  //nested field set
  _setNestedData(e, t) {
    var i = e, n = this.fieldStructure, a = n.length;
    for (let o = 0; o < a; o++)
      if (o == a - 1)
        i[n[o]] = t;
      else {
        if (!i[n[o]])
          if (typeof t < "u")
            i[n[o]] = {};
          else
            break;
        i = i[n[o]];
      }
  }
  //attach column to this group
  attachColumn(e) {
    this.groupElement ? (this.columns.push(e), this.groupElement.appendChild(e.getElement()), e.columnRendered()) : console.warn("Column Warning - Column being attached to another column instead of column group");
  }
  //vertically align header in column
  verticalAlign(e, t) {
    var i = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : t || this.parent.getHeadersElement().clientHeight;
    this.element.style.height = i + "px", this.dispatch("column-height", this, this.element.style.height), this.isGroup && (this.groupElement.style.minHeight = i - this.contentElement.offsetHeight + "px"), this.columns.forEach(function(n) {
      n.verticalAlign(e);
    });
  }
  //clear vertical alignment
  clearVerticalAlign() {
    this.element.style.paddingTop = "", this.element.style.height = "", this.element.style.minHeight = "", this.groupElement.style.minHeight = "", this.columns.forEach(function(e) {
      e.clearVerticalAlign();
    }), this.dispatch("column-height", this, "");
  }
  //// Retrieve Column Information ////
  //return column header element
  getElement() {
    return this.element;
  }
  //return column group element
  getGroupElement() {
    return this.groupElement;
  }
  //return field name
  getField() {
    return this.field;
  }
  getTitleDownload() {
    return this.titleDownload;
  }
  //return the first column in a group
  getFirstColumn() {
    return this.isGroup ? this.columns.length ? this.columns[0].getFirstColumn() : !1 : this;
  }
  //return the last column in a group
  getLastColumn() {
    return this.isGroup ? this.columns.length ? this.columns[this.columns.length - 1].getLastColumn() : !1 : this;
  }
  //return all columns in a group
  getColumns(e) {
    var t = [];
    return e ? this.columns.forEach((i) => {
      t.push(i), t = t.concat(i.getColumns(!0));
    }) : t = this.columns, t;
  }
  //return all columns in a group
  getCells() {
    return this.cells;
  }
  //retrieve the top column in a group of columns
  getTopColumn() {
    return this.parent.isGroup ? this.parent.getTopColumn() : this;
  }
  //return column definition object
  getDefinition(e) {
    var t = [];
    return this.isGroup && e && (this.columns.forEach(function(i) {
      t.push(i.getDefinition(!0));
    }), this.definition.columns = t), this.definition;
  }
  //////////////////// Actions ////////////////////
  checkColumnVisibility() {
    var e = !1;
    this.columns.forEach(function(t) {
      t.visible && (e = !0);
    }), e ? (this.show(), this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1)) : this.hide();
  }
  //show column
  show(e, t) {
    this.visible || (this.visible = !0, this.element.style.display = "", this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(i) {
      i.show();
    }), !this.isGroup && this.width === null && this.reinitializeWidth(), this.table.columnManager.verticalAlignHeaders(), this.dispatch("column-show", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !0), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  //hide column
  hide(e, t) {
    this.visible && (this.visible = !1, this.element.style.display = "none", this.table.columnManager.verticalAlignHeaders(), this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(i) {
      i.hide();
    }), this.dispatch("column-hide", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  matchChildWidths() {
    var e = 0;
    this.contentElement && this.columns.length && (this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }), this.contentElement.style.maxWidth = e - 1 + "px", this.parent.isGroup && this.parent.matchChildWidths());
  }
  removeChild(e) {
    var t = this.columns.indexOf(e);
    t > -1 && this.columns.splice(t, 1), this.columns.length || this.delete();
  }
  setWidth(e) {
    this.widthFixed = !0, this.setWidthActual(e);
  }
  setWidthActual(e) {
    isNaN(e) && (e = Math.floor(this.table.element.clientWidth / 100 * parseInt(e))), e = Math.max(this.minWidth, e), this.maxWidth && (e = Math.min(this.maxWidth, e)), this.width = e, this.widthStyled = e ? e + "px" : "", this.element.style.width = this.widthStyled, this.isGroup || this.cells.forEach(function(t) {
      t.setWidth();
    }), this.parent.isGroup && this.parent.matchChildWidths(), this.dispatch("column-width", this);
  }
  checkCellHeights() {
    var e = [];
    this.cells.forEach(function(t) {
      t.row.heightInitialized && (t.row.getElement().offsetParent !== null ? (e.push(t.row), t.row.clearCellHeight()) : t.row.heightInitialized = !1);
    }), e.forEach(function(t) {
      t.calcHeight();
    }), e.forEach(function(t) {
      t.setCellHeight();
    });
  }
  getWidth() {
    var e = 0;
    return this.isGroup ? this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }) : e = this.width, e;
  }
  getLeftOffset() {
    var e = this.element.offsetLeft;
    return this.parent.isGroup && (e += this.parent.getLeftOffset()), e;
  }
  getHeight() {
    return Math.ceil(this.element.getBoundingClientRect().height);
  }
  setMinWidth(e) {
    this.maxWidth && e > this.maxWidth && (e = this.maxWidth, console.warn("the minWidth (" + e + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")")), this.minWidth = e, this.minWidthStyled = e ? e + "px" : "", this.element.style.minWidth = this.minWidthStyled, this.cells.forEach(function(t) {
      t.setMinWidth();
    });
  }
  setMaxWidth(e) {
    this.minWidth && e < this.minWidth && (e = this.minWidth, console.warn("the maxWidth (" + e + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")")), this.maxWidth = e, this.maxWidthStyled = e ? e + "px" : "", this.element.style.maxWidth = this.maxWidthStyled, this.cells.forEach(function(t) {
      t.setMaxWidth();
    });
  }
  delete() {
    return new Promise((e, t) => {
      this.isGroup && this.columns.forEach(function(n) {
        n.delete();
      }), this.dispatch("column-delete", this);
      var i = this.cells.length;
      for (let n = 0; n < i; n++)
        this.cells[0].delete();
      this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.contentElement = !1, this.titleElement = !1, this.groupElement = !1, this.parent.isGroup && this.parent.removeChild(this), this.table.columnManager.deregisterColumn(this), this.table.columnManager.rerenderColumns(!0), e();
    });
  }
  columnRendered() {
    this.titleFormatterRendered && this.titleFormatterRendered(), this.dispatch("column-rendered", this);
  }
  //////////////// Cell Management /////////////////
  //generate cell for this column
  generateCell(e) {
    var t = new dv(this, e);
    return this.cells.push(t), t;
  }
  nextColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._nextVisibleColumn(e + 1) : !1;
  }
  _nextVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._nextVisibleColumn(e + 1);
  }
  prevColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._prevVisibleColumn(e - 1) : !1;
  }
  _prevVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._prevVisibleColumn(e - 1);
  }
  reinitializeWidth(e) {
    this.widthFixed = !1, typeof this.definition.width < "u" && !e && this.setWidth(this.definition.width), this.dispatch("column-width-fit-before", this), this.fitToData(e), this.dispatch("column-width-fit-after", this);
  }
  //set column width to maximum cell width for non group columns
  fitToData(e) {
    if (!this.isGroup) {
      this.widthFixed || (this.element.style.width = "", this.cells.forEach((n) => {
        n.clearWidth();
      }));
      var t = this.element.offsetWidth;
      if ((!this.width || !this.widthFixed) && (this.cells.forEach((n) => {
        var a = n.getWidth();
        a > t && (t = a);
      }), t)) {
        var i = t + 1;
        this.maxInitialWidth && !e && (i = Math.min(i, this.maxInitialWidth)), this.setWidthActual(i);
      }
    }
  }
  updateDefinition(e) {
    var t;
    return this.isGroup || this.parent.isGroup ? (console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns"), Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups")) : (t = Object.assign({}, this.getDefinition()), t = Object.assign(t, e), this.table.columnManager.addColumn(t, !1, this).then((i) => (t.field == this.field && (this.field = !1), this.delete().then(() => i.getComponent()))));
  }
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new f8(this)), this.component;
  }
}
ro.defaultOptionList = d8;
class yT {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._row.table.componentFunctionBinder.handle("row", t._row, i);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  getIndex() {
    return this._row.getData("data")[this._row.table.options.index];
  }
  getPosition() {
    return this._row.getPosition();
  }
  watchPosition(e) {
    return this._row.watchPosition(e);
  }
  delete() {
    return this._row.delete();
  }
  scrollTo(e, t) {
    return this._row.table.rowManager.scrollToRow(this._row, e, t);
  }
  move(e, t) {
    this._row.moveToRow(e, t);
  }
  update(e) {
    return this._row.updateData(e);
  }
  normalizeHeight() {
    this._row.normalizeHeight(!0);
  }
  _getSelf() {
    return this._row;
  }
  reformat() {
    return this._row.reinitialize();
  }
  getTable() {
    return this._row.table;
  }
  getNextRow() {
    var e = this._row.nextRow();
    return e && e.getComponent();
  }
  getPrevRow() {
    var e = this._row.prevRow();
    return e && e.getComponent();
  }
}
class Ti extends zi {
  constructor(e, t, i = "row") {
    super(t.table), this.parent = t, this.data = {}, this.type = i, this.element = !1, this.modules = {}, this.cells = [], this.height = 0, this.heightStyled = "", this.manualHeight = !1, this.outerHeight = 0, this.initialized = !1, this.heightInitialized = !1, this.position = 0, this.positionWatchers = [], this.component = null, this.created = !1, this.setData(e);
  }
  create() {
    this.created || (this.created = !0, this.generateElement());
  }
  createElement() {
    var e = document.createElement("div");
    e.classList.add("tabulator-row"), e.setAttribute("role", "row"), this.element = e;
  }
  getElement() {
    return this.create(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  generateElement() {
    this.createElement(), this.dispatch("row-init", this);
  }
  generateCells() {
    this.cells = this.table.columnManager.generateCells(this);
  }
  //functions to setup on first render
  initialize(e) {
    if (this.create(), !this.initialized || e) {
      for (this.deleteCells(); this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.dispatch("row-layout-before", this), this.generateCells(), this.initialized = !0, this.table.columnManager.renderer.renderRowCells(this), e && this.normalizeHeight(), this.dispatch("row-layout", this), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent()), this.dispatch("row-layout-after", this);
    } else
      this.table.columnManager.renderer.rerenderRowCells(this);
  }
  reinitializeHeight() {
    this.heightInitialized = !1, this.element && this.element.offsetParent !== null && this.normalizeHeight(!0);
  }
  deinitialize() {
    this.initialized = !1;
  }
  deinitializeHeight() {
    this.heightInitialized = !1;
  }
  reinitialize(e) {
    this.initialized = !1, this.heightInitialized = !1, this.manualHeight || (this.height = 0, this.heightStyled = ""), this.element && this.element.offsetParent !== null && this.initialize(!0), this.dispatch("row-relayout", this);
  }
  //get heights when doing bulk row style calcs in virtual DOM
  calcHeight(e) {
    var t = 0, i;
    this.table.options.rowHeight ? this.height = this.table.options.rowHeight : (i = this.table.options.resizableRows ? this.element.clientHeight : 0, this.cells.forEach(function(n) {
      var a = n.getHeight();
      a > t && (t = a);
    }), e ? this.height = Math.max(t, i) : this.height = this.manualHeight ? this.height : Math.max(t, i)), this.heightStyled = this.height ? this.height + "px" : "", this.outerHeight = this.element.offsetHeight;
  }
  //set of cells
  setCellHeight() {
    this.cells.forEach(function(e) {
      e.setHeight();
    }), this.heightInitialized = !0;
  }
  clearCellHeight() {
    this.cells.forEach(function(e) {
      e.clearHeight();
    });
  }
  //normalize the height of elements in the row
  normalizeHeight(e) {
    e && !this.table.options.rowHeight && this.clearCellHeight(), this.calcHeight(e), this.setCellHeight();
  }
  //set height of rows
  setHeight(e, t) {
    (this.height != e || t) && (this.manualHeight = !0, this.height = e, this.heightStyled = e ? e + "px" : "", this.setCellHeight(), this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  //return rows outer Width
  getWidth() {
    return this.element.offsetWidth;
  }
  //////////////// Cell Management /////////////////
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Data Management /////////////////
  setData(e) {
    this.data = this.chain("row-data-init-before", [this, e], void 0, e), this.dispatch("row-data-init-after", this);
  }
  //update the rows data
  updateData(e) {
    var t = this.element && Wt.elVisible(this.element), i = {}, n;
    return new Promise((a, o) => {
      typeof e == "string" && (e = JSON.parse(e)), this.dispatch("row-data-save-before", this), this.subscribed("row-data-changing") && (i = Object.assign(i, this.data), i = Object.assign(i, e)), n = this.chain("row-data-changing", [this, i, e], null, e);
      for (let s in n)
        this.data[s] = n[s];
      this.dispatch("row-data-save-after", this);
      for (let s in e)
        this.table.columnManager.getColumnsByFieldRoot(s).forEach((u) => {
          let h = this.getCell(u.getField());
          if (h) {
            let c = u.getFieldValue(n);
            h.getValue() !== c && (h.setValueProcessData(c), t && h.cellRendered());
          }
        });
      t ? (this.normalizeHeight(!0), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent())) : (this.initialized = !1, this.height = 0, this.heightStyled = ""), this.dispatch("row-data-changed", this, t, e), this.dispatchExternal("rowUpdated", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), a();
    });
  }
  getData(e) {
    return e ? this.chain("row-data-retrieve", [this, e], null, this.data) : this.data;
  }
  getCell(e) {
    var t = !1;
    return e = this.table.columnManager.findColumn(e), !this.initialized && this.cells.length === 0 && this.generateCells(), t = this.cells.find(function(i) {
      return i.column === e;
    }), t;
  }
  getCellIndex(e) {
    return this.cells.findIndex(function(t) {
      return t === e;
    });
  }
  findCell(e) {
    return this.cells.find((t) => t.element === e);
  }
  getCells() {
    return !this.initialized && this.cells.length === 0 && this.generateCells(), this.cells;
  }
  nextRow() {
    var e = this.table.rowManager.nextDisplayRow(this, !0);
    return e || !1;
  }
  prevRow() {
    var e = this.table.rowManager.prevDisplayRow(this, !0);
    return e || !1;
  }
  moveToRow(e, t) {
    var i = this.table.rowManager.findRow(e);
    i ? (this.table.rowManager.moveRowActual(this, i, !t), this.table.rowManager.refreshActiveData("display", !1, !0)) : console.warn("Move Error - No matching row found:", e);
  }
  ///////////////////// Actions  /////////////////////
  delete() {
    return this.dispatch("row-delete", this), this.deleteActual(), Promise.resolve();
  }
  deleteActual(e) {
    this.detachModules(), this.table.rowManager.deleteRow(this, e), this.deleteCells(), this.initialized = !1, this.heightInitialized = !1, this.element = !1, this.dispatch("row-deleted", this);
  }
  detachModules() {
    this.dispatch("row-deleting", this);
  }
  deleteCells() {
    var e = this.cells.length;
    for (let t = 0; t < e; t++)
      this.cells[0].delete();
  }
  wipe() {
    if (this.detachModules(), this.deleteCells(), this.element) {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.element.parentNode && this.element.parentNode.removeChild(this.element);
    }
    this.element = !1, this.modules = {};
  }
  isDisplayed() {
    return this.table.rowManager.getDisplayRows().includes(this);
  }
  getPosition() {
    return this.isDisplayed() ? this.position : !1;
  }
  setPosition(e) {
    e != this.position && (this.position = e, this.positionWatchers.forEach((t) => {
      t(this.position);
    }));
  }
  watchPosition(e) {
    this.positionWatchers.push(e), e(this.position);
  }
  getGroup() {
    return this.modules.group || !1;
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new yT(this)), this.component;
  }
}
var _Ue = {
  avg: function(r, e, t) {
    var i = 0, n = typeof t.precision < "u" ? t.precision : 2;
    return r.length && (i = r.reduce(function(a, o) {
      return Number(a) + Number(o);
    }), i = i / r.length, i = n !== !1 ? i.toFixed(n) : i), parseFloat(i).toString();
  },
  max: function(r, e, t) {
    var i = null, n = typeof t.precision < "u" ? t.precision : !1;
    return r.forEach(function(a) {
      a = Number(a), (a > i || i === null) && (i = a);
    }), i !== null ? n !== !1 ? i.toFixed(n) : i : "";
  },
  min: function(r, e, t) {
    var i = null, n = typeof t.precision < "u" ? t.precision : !1;
    return r.forEach(function(a) {
      a = Number(a), (a < i || i === null) && (i = a);
    }), i !== null ? n !== !1 ? i.toFixed(n) : i : "";
  },
  sum: function(r, e, t) {
    var i = 0, n = typeof t.precision < "u" ? t.precision : !1;
    return r.length && r.forEach(function(a) {
      a = Number(a), i += isNaN(a) ? 0 : Number(a);
    }), n !== !1 ? i.toFixed(n) : i;
  },
  concat: function(r, e, t) {
    var i = 0;
    return r.length && (i = r.reduce(function(n, a) {
      return String(n) + String(a);
    })), i;
  },
  count: function(r, e, t) {
    var i = 0;
    return r.length && r.forEach(function(n) {
      n && i++;
    }), i;
  },
  unique: function(r, e, t) {
    var i = r.filter((n, a) => (r || n === 0) && r.indexOf(n) === a);
    return i.length;
  }
};
class No extends pt {
  constructor(e) {
    super(e), this.topCalcs = [], this.botCalcs = [], this.genColumn = !1, this.topElement = this.createElement(), this.botElement = this.createElement(), this.topRow = !1, this.botRow = !1, this.topInitialized = !1, this.botInitialized = !1, this.blocked = !1, this.recalcAfterBlock = !1, this.registerTableOption("columnCalcs", !0), this.registerColumnOption("topCalc"), this.registerColumnOption("topCalcParams"), this.registerColumnOption("topCalcFormatter"), this.registerColumnOption("topCalcFormatterParams"), this.registerColumnOption("bottomCalc"), this.registerColumnOption("bottomCalcParams"), this.registerColumnOption("bottomCalcFormatter"), this.registerColumnOption("bottomCalcFormatterParams");
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-calcs-holder"), e;
  }
  initialize() {
    this.genColumn = new ro({ field: "value" }, this), this.subscribe("cell-value-changed", this.cellValueChanged.bind(this)), this.subscribe("column-init", this.initializeColumnCheck.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("column-moved", this.recalcActiveRows.bind(this)), this.subscribe("column-add", this.recalcActiveRows.bind(this)), this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this)), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this)), this.subscribe("redraw-blocked", this.blockRedraw.bind(this)), this.subscribe("redraw-restored", this.restoreRedraw.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this)), this.registerTableFunction("getCalcResults", this.getResults.bind(this)), this.registerTableFunction("recalc", this.userRecalc.bind(this)), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  tableRedraw(e) {
    this.recalc(this.table.rowManager.activeRows), e && this.redraw();
  }
  blockRedraw() {
    this.blocked = !0, this.recalcAfterBlock = !1;
  }
  restoreRedraw() {
    this.blocked = !1, this.recalcAfterBlock && (this.recalcAfterBlock = !1, this.recalcActiveRowsRefresh());
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userRecalc() {
    this.recalc(this.table.rowManager.activeRows);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  blockCheck() {
    return this.blocked && (this.recalcAfterBlock = !0), this.blocked;
  }
  visibleRows(e, t) {
    return this.topRow && t.unshift(this.topRow), this.botRow && t.push(this.botRow), t;
  }
  rowsUpdated(e) {
    this.table.options.groupBy ? this.recalcRowGroup(e) : this.recalcActiveRows();
  }
  recalcActiveRowsRefresh() {
    this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree ? this.recalcAll() : this.recalcActiveRows();
  }
  recalcActiveRows() {
    this.recalc(this.table.rowManager.activeRows);
  }
  cellValueChanged(e) {
    (e.column.definition.topCalc || e.column.definition.bottomCalc) && (this.table.options.groupBy ? ((this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") && this.recalcActiveRows(), this.table.options.columnCalcs != "table" && this.recalcRowGroup(e.row)) : this.recalcActiveRows());
  }
  initializeColumnCheck(e) {
    (e.definition.topCalc || e.definition.bottomCalc) && this.initializeColumn(e);
  }
  //initialize column calcs
  initializeColumn(e) {
    var t = e.definition, i = {
      topCalcParams: t.topCalcParams || {},
      botCalcParams: t.bottomCalcParams || {}
    };
    if (t.topCalc) {
      switch (typeof t.topCalc) {
        case "string":
          No.calculations[t.topCalc] ? i.topCalc = No.calculations[t.topCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.topCalc);
          break;
        case "function":
          i.topCalc = t.topCalc;
          break;
      }
      i.topCalc && (e.modules.columnCalcs = i, this.topCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeTopRow());
    }
    if (t.bottomCalc) {
      switch (typeof t.bottomCalc) {
        case "string":
          No.calculations[t.bottomCalc] ? i.botCalc = No.calculations[t.bottomCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.bottomCalc);
          break;
        case "function":
          i.botCalc = t.bottomCalc;
          break;
      }
      i.botCalc && (e.modules.columnCalcs = i, this.botCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeBottomRow());
    }
  }
  //dummy functions to handle being mock column manager
  registerColumnField() {
  }
  removeCalcs() {
    var e = !1;
    this.topInitialized && (this.topInitialized = !1, this.topElement.parentNode.removeChild(this.topElement), e = !0), this.botInitialized && (this.botInitialized = !1, this.footerRemove(this.botElement), e = !0), e && this.table.rowManager.adjustTableSize();
  }
  reinitializeCalcs() {
    this.topCalcs.length && this.initializeTopRow(), this.botCalcs.length && this.initializeBottomRow();
  }
  initializeTopRow() {
    this.topInitialized || (this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.topInitialized = !0);
  }
  initializeBottomRow() {
    this.botInitialized || (this.footerPrepend(this.botElement), this.botInitialized = !0);
  }
  scrollHorizontal(e) {
    this.botInitialized && this.botRow && (this.botElement.scrollLeft = e);
  }
  recalc(e) {
    var t, i;
    if (!this.blockCheck() && (this.topInitialized || this.botInitialized)) {
      if (t = this.rowsToData(e), this.topInitialized) {
        for (this.topRow && this.topRow.deleteCells(), i = this.generateRow("top", t), this.topRow = i; this.topElement.firstChild; )
          this.topElement.removeChild(this.topElement.firstChild);
        this.topElement.appendChild(i.getElement()), i.initialize(!0);
      }
      if (this.botInitialized) {
        for (this.botRow && this.botRow.deleteCells(), i = this.generateRow("bottom", t), this.botRow = i; this.botElement.firstChild; )
          this.botElement.removeChild(this.botElement.firstChild);
        this.botElement.appendChild(i.getElement()), i.initialize(!0);
      }
      this.table.rowManager.adjustTableSize(), this.table.modExists("frozenColumns") && this.table.modules.frozenColumns.layout();
    }
  }
  recalcRowGroup(e) {
    this.recalcGroup(this.table.modules.groupRows.getRowGroup(e));
  }
  recalcAll() {
    if ((this.topCalcs.length || this.botCalcs.length) && (this.table.options.columnCalcs !== "group" && this.recalcActiveRows(), this.table.options.groupBy && this.table.options.columnCalcs !== "table")) {
      var e = this.table.modules.groupRows.getChildGroups();
      e.forEach((t) => {
        this.recalcGroup(t);
      });
    }
  }
  recalcGroup(e) {
    var t, i;
    this.blockCheck() || e && e.calcs && (e.calcs.bottom && (t = this.rowsToData(e.rows), i = this.generateRowData("bottom", t), e.calcs.bottom.updateData(i), e.calcs.bottom.reinitialize()), e.calcs.top && (t = this.rowsToData(e.rows), i = this.generateRowData("top", t), e.calcs.top.updateData(i), e.calcs.top.reinitialize()));
  }
  //generate top stats row
  generateTopRow(e) {
    return this.generateRow("top", this.rowsToData(e));
  }
  //generate bottom stats row
  generateBottomRow(e) {
    return this.generateRow("bottom", this.rowsToData(e));
  }
  rowsToData(e) {
    var t = [];
    return e.forEach((i) => {
      if (t.push(i.getData()), this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs && i.modules.dataTree && i.modules.dataTree.open) {
        var n = this.rowsToData(this.table.modules.dataTree.getFilteredTreeChildren(i));
        t = t.concat(n);
      }
    }), t;
  }
  //generate stats row
  generateRow(e, t) {
    var i = this.generateRowData(e, t), n;
    return this.table.modExists("mutator") && this.table.modules.mutator.disable(), n = new Ti(i, this, "calc"), this.table.modExists("mutator") && this.table.modules.mutator.enable(), n.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + e), n.component = !1, n.getComponent = () => (n.component || (n.component = new CUe(n)), n.component), n.generateCells = () => {
      var a = [];
      this.table.columnManager.columnsByIndex.forEach((o) => {
        this.genColumn.setField(o.getField()), this.genColumn.hozAlign = o.hozAlign, o.definition[e + "CalcFormatter"] && this.table.modExists("format") ? this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter(o.definition[e + "CalcFormatter"]),
          params: o.definition[e + "CalcFormatterParams"] || {}
        } : this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter("plaintext"),
          params: {}
        }, this.genColumn.definition.cssClass = o.definition.cssClass;
        var s = new dv(this.genColumn, n);
        s.getElement(), s.column = o, s.setWidth(), o.cells.push(s), a.push(s), o.visible || s.hide();
      }), n.cells = a;
    }, n;
  }
  //generate stats row
  generateRowData(e, t) {
    var i = {}, n = e == "top" ? this.topCalcs : this.botCalcs, a = e == "top" ? "topCalc" : "botCalc", o, s;
    return n.forEach(function(l) {
      var u = [];
      l.modules.columnCalcs && l.modules.columnCalcs[a] && (t.forEach(function(h) {
        u.push(l.getFieldValue(h));
      }), s = a + "Params", o = typeof l.modules.columnCalcs[s] == "function" ? l.modules.columnCalcs[s](u, t) : l.modules.columnCalcs[s], l.setFieldValue(i, l.modules.columnCalcs[a](u, t, o)));
    }), i;
  }
  hasTopCalcs() {
    return !!this.topCalcs.length;
  }
  hasBottomCalcs() {
    return !!this.botCalcs.length;
  }
  //handle table redraw
  redraw() {
    this.topRow && this.topRow.normalizeHeight(!0), this.botRow && this.botRow.normalizeHeight(!0);
  }
  //return the calculated
  getResults() {
    var e = {}, t;
    return this.table.options.groupBy && this.table.modExists("groupRows") ? (t = this.table.modules.groupRows.getGroups(!0), t.forEach((i) => {
      e[i.getKey()] = this.getGroupResults(i);
    })) : e = {
      top: this.topRow ? this.topRow.getData() : {},
      bottom: this.botRow ? this.botRow.getData() : {}
    }, e;
  }
  //get results from a group
  getGroupResults(e) {
    var t = e._getSelf(), i = e.getSubGroups(), n = {}, a = {};
    return i.forEach((o) => {
      n[o.getKey()] = this.getGroupResults(o);
    }), a = {
      top: t.calcs.top ? t.calcs.top.getData() : {},
      bottom: t.calcs.bottom ? t.calcs.bottom.getData() : {},
      groups: n
    }, a;
  }
  adjustForScrollbar(e) {
    this.botRow && (this.table.rtl ? this.botElement.style.paddingLeft = e + "px" : this.botElement.style.paddingRight = e + "px");
  }
}
No.moduleName = "columnCalcs";
No.calculations = _Ue;
class _P extends pt {
  constructor(e) {
    super(e), this.indent = 10, this.field = "", this.collapseEl = null, this.expandEl = null, this.branchEl = null, this.elementField = !1, this.startOpen = function() {
    }, this.registerTableOption("dataTree", !1), this.registerTableOption("dataTreeFilter", !0), this.registerTableOption("dataTreeSort", !0), this.registerTableOption("dataTreeElementColumn", !1), this.registerTableOption("dataTreeBranchElement", !0), this.registerTableOption("dataTreeChildIndent", 9), this.registerTableOption("dataTreeChildField", "_children"), this.registerTableOption("dataTreeCollapseElement", !1), this.registerTableOption("dataTreeExpandElement", !1), this.registerTableOption("dataTreeStartExpanded", !1), this.registerTableOption("dataTreeChildColumnCalcs", !1), this.registerTableOption("dataTreeSelectPropagate", !1), this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this)), this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this)), this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this)), this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this)), this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this)), this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this)), this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
  }
  initialize() {
    if (this.table.options.dataTree) {
      var e = null, t = this.table.options;
      switch (this.field = t.dataTreeChildField, this.indent = t.dataTreeChildIndent, this.options("movableRows") && console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior"), t.dataTreeBranchElement && (t.dataTreeBranchElement === !0 ? (this.branchEl = document.createElement("div"), this.branchEl.classList.add("tabulator-data-tree-branch")) : typeof t.dataTreeBranchElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeBranchElement, this.branchEl = e.firstChild) : this.branchEl = t.dataTreeBranchElement), t.dataTreeCollapseElement ? typeof t.dataTreeCollapseElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeCollapseElement, this.collapseEl = e.firstChild) : this.collapseEl = t.dataTreeCollapseElement : (this.collapseEl = document.createElement("div"), this.collapseEl.classList.add("tabulator-data-tree-control"), this.collapseEl.tabIndex = 0, this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>"), t.dataTreeExpandElement ? typeof t.dataTreeExpandElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeExpandElement, this.expandEl = e.firstChild) : this.expandEl = t.dataTreeExpandElement : (this.expandEl = document.createElement("div"), this.expandEl.classList.add("tabulator-data-tree-control"), this.expandEl.tabIndex = 0, this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>"), typeof t.dataTreeStartExpanded) {
        case "boolean":
          this.startOpen = function(i, n) {
            return t.dataTreeStartExpanded;
          };
          break;
        case "function":
          this.startOpen = t.dataTreeStartExpanded;
          break;
        default:
          this.startOpen = function(i, n) {
            return t.dataTreeStartExpanded[n];
          };
          break;
      }
      this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("row-deleted", this.rowDelete.bind(this), 0), this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10), this.subscribe("cell-value-updated", this.cellValueChanged.bind(this)), this.subscribe("edit-cancelled", this.cellValueChanged.bind(this)), this.subscribe("column-moving-rows", this.columnMoving.bind(this)), this.subscribe("table-built", this.initializeElementField.bind(this)), this.subscribe("table-redrawing", this.tableRedrawing.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 30);
    }
  }
  tableRedrawing(e) {
    var t;
    e && (t = this.table.rowManager.getRows(), t.forEach((i) => {
      this.reinitializeRowChildren(i);
    }));
  }
  initializeElementField() {
    var e = this.table.columnManager.getFirstVisibleColumn();
    this.elementField = this.table.options.dataTreeElementColumn || (e ? e.field : !1);
  }
  getRowChildren(e) {
    return this.getTreeChildren(e, !0);
  }
  columnMoving() {
    var e = [];
    return this.table.rowManager.rows.forEach((t) => {
      e = e.concat(this.getTreeChildren(t, !1, !0));
    }), e;
  }
  rowDataChanged(e, t, i) {
    this.redrawNeeded(i) && (this.initializeRow(e), t && (this.layoutRow(e), this.refreshData(!0)));
  }
  cellValueChanged(e) {
    var t = e.column.getField();
    t === this.elementField && this.layoutRow(e.row);
  }
  initializeRow(e) {
    var t = e.getData()[this.field], i = Array.isArray(t), n = i || !i && typeof t == "object" && t !== null;
    !n && e.modules.dataTree && e.modules.dataTree.branchEl && e.modules.dataTree.branchEl.parentNode.removeChild(e.modules.dataTree.branchEl), !n && e.modules.dataTree && e.modules.dataTree.controlEl && e.modules.dataTree.controlEl.parentNode.removeChild(e.modules.dataTree.controlEl), e.modules.dataTree = {
      index: e.modules.dataTree ? e.modules.dataTree.index : 0,
      open: n ? e.modules.dataTree ? e.modules.dataTree.open : this.startOpen(e.getComponent(), 0) : !1,
      controlEl: e.modules.dataTree && n ? e.modules.dataTree.controlEl : !1,
      branchEl: e.modules.dataTree && n ? e.modules.dataTree.branchEl : !1,
      parent: e.modules.dataTree ? e.modules.dataTree.parent : !1,
      children: n
    };
  }
  reinitializeRowChildren(e) {
    var t = this.getTreeChildren(e, !1, !0);
    t.forEach(function(i) {
      i.reinitialize(!0);
    });
  }
  layoutRow(e) {
    var t = this.elementField ? e.getCell(this.elementField) : e.getCells()[0], i = t.getElement(), n = e.modules.dataTree;
    n.branchEl && (n.branchEl.parentNode && n.branchEl.parentNode.removeChild(n.branchEl), n.branchEl = !1), n.controlEl && (n.controlEl.parentNode && n.controlEl.parentNode.removeChild(n.controlEl), n.controlEl = !1), this.generateControlElement(e, i), e.getElement().classList.add("tabulator-tree-level-" + n.index), n.index && (this.branchEl ? (n.branchEl = this.branchEl.cloneNode(!0), i.insertBefore(n.branchEl, i.firstChild), this.table.rtl ? n.branchEl.style.marginRight = (n.branchEl.offsetWidth + n.branchEl.style.marginLeft) * (n.index - 1) + n.index * this.indent + "px" : n.branchEl.style.marginLeft = (n.branchEl.offsetWidth + n.branchEl.style.marginRight) * (n.index - 1) + n.index * this.indent + "px") : this.table.rtl ? i.style.paddingRight = parseInt(window.getComputedStyle(i, null).getPropertyValue("padding-right")) + n.index * this.indent + "px" : i.style.paddingLeft = parseInt(window.getComputedStyle(i, null).getPropertyValue("padding-left")) + n.index * this.indent + "px");
  }
  generateControlElement(e, t) {
    var i = e.modules.dataTree, n = i.controlEl;
    t = t || e.getCells()[0].getElement(), i.children !== !1 && (i.open ? (i.controlEl = this.collapseEl.cloneNode(!0), i.controlEl.addEventListener("click", (a) => {
      a.stopPropagation(), this.collapseRow(e);
    })) : (i.controlEl = this.expandEl.cloneNode(!0), i.controlEl.addEventListener("click", (a) => {
      a.stopPropagation(), this.expandRow(e);
    })), i.controlEl.addEventListener("mousedown", (a) => {
      a.stopPropagation();
    }), n && n.parentNode === t ? n.parentNode.replaceChild(i.controlEl, n) : t.insertBefore(i.controlEl, t.firstChild));
  }
  getRows(e) {
    var t = [];
    return e.forEach((i, n) => {
      var a, o;
      t.push(i), i instanceof Ti && (i.create(), a = i.modules.dataTree, !a.index && a.children !== !1 && (o = this.getChildren(i), o.forEach((s) => {
        s.create(), t.push(s);
      })));
    }), t;
  }
  getChildren(e, t) {
    var i = e.modules.dataTree, n = [], a = [];
    return i.children !== !1 && (i.open || t) && (Array.isArray(i.children) || (i.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? n = this.table.modules.filter.filter(i.children) : n = i.children, this.table.modExists("sort") && this.table.options.dataTreeSort && this.table.modules.sort.sort(n), n.forEach((o) => {
      a.push(o);
      var s = this.getChildren(o);
      s.forEach((l) => {
        a.push(l);
      });
    })), a;
  }
  generateChildren(e) {
    var t = [], i = e.getData()[this.field];
    return Array.isArray(i) || (i = [i]), i.forEach((n) => {
      var a = new Ti(n || {}, this.table.rowManager);
      a.create(), a.modules.dataTree.index = e.modules.dataTree.index + 1, a.modules.dataTree.parent = e, a.modules.dataTree.children && (a.modules.dataTree.open = this.startOpen(a.getComponent(), a.modules.dataTree.index)), t.push(a);
    }), t;
  }
  expandRow(e, t) {
    var i = e.modules.dataTree;
    i.children !== !1 && (i.open = !0, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowExpanded", e.getComponent(), e.modules.dataTree.index));
  }
  collapseRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open = !1, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowCollapsed", e.getComponent(), e.modules.dataTree.index));
  }
  toggleRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open ? this.collapseRow(e) : this.expandRow(e));
  }
  isRowExpanded(e) {
    return e.modules.dataTree.open;
  }
  getTreeParent(e) {
    return e.modules.dataTree.parent ? e.modules.dataTree.parent.getComponent() : !1;
  }
  getTreeParentRoot(e) {
    return e.modules.dataTree && e.modules.dataTree.parent ? this.getTreeParentRoot(e.modules.dataTree.parent) : e;
  }
  getFilteredTreeChildren(e) {
    var t = e.modules.dataTree, i = [], n;
    return t.children && (Array.isArray(t.children) || (t.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? n = this.table.modules.filter.filter(t.children) : n = t.children, n.forEach((a) => {
      a instanceof Ti && i.push(a);
    })), i;
  }
  rowDelete(e) {
    var t = e.modules.dataTree.parent, i;
    t && (i = this.findChildIndex(e, t), i !== !1 && t.data[this.field].splice(i, 1), t.data[this.field].length || delete t.data[this.field], this.initializeRow(t), this.layoutRow(t)), this.refreshData(!0);
  }
  addTreeChildRow(e, t, i, n) {
    var a = !1;
    typeof t == "string" && (t = JSON.parse(t)), Array.isArray(e.data[this.field]) || (e.data[this.field] = [], e.modules.dataTree.open = this.startOpen(e.getComponent(), e.modules.dataTree.index)), typeof n < "u" && (a = this.findChildIndex(n, e), a !== !1 && e.data[this.field].splice(i ? a : a + 1, 0, t)), a === !1 && (i ? e.data[this.field].unshift(t) : e.data[this.field].push(t)), this.initializeRow(e), this.layoutRow(e), this.refreshData(!0);
  }
  findChildIndex(e, t) {
    var i = !1;
    return typeof e == "object" ? e instanceof Ti ? i = e.data : e instanceof yT ? i = e._getSelf().data : typeof HTMLElement < "u" && e instanceof HTMLElement ? t.modules.dataTree && (i = t.modules.dataTree.children.find((n) => n instanceof Ti ? n.element === e : !1), i && (i = i.data)) : e === null && (i = !1) : typeof e > "u" ? i = !1 : i = t.data[this.field].find((n) => n.data[this.table.options.index] == e), i && (Array.isArray(t.data[this.field]) && (i = t.data[this.field].indexOf(i)), i == -1 && (i = !1)), i;
  }
  getTreeChildren(e, t, i) {
    var n = e.modules.dataTree, a = [];
    return n.children && (Array.isArray(n.children) || (n.children = this.generateChildren(e)), n.children.forEach((o) => {
      o instanceof Ti && (a.push(t ? o.getComponent() : o), i && (a = a.concat(this.getTreeChildren(o, t, i))));
    })), a;
  }
  getChildField() {
    return this.field;
  }
  redrawNeeded(e) {
    return (this.field ? typeof e[this.field] < "u" : !1) || (this.elementField ? typeof e[this.elementField] < "u" : !1);
  }
}
_P.moduleName = "dataTree";
function IUe(r, e = {}, t) {
  var i = e.delimiter ? e.delimiter : ",", n = [], a = [];
  r.forEach((o) => {
    var s = [];
    switch (o.type) {
      case "group":
        console.warn("Download Warning - CSV downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - CSV downloader cannot process column calculations");
        break;
      case "header":
        o.columns.forEach((l, u) => {
          l && l.depth === 1 && (a[u] = typeof l.value > "u" || l.value === null ? "" : '"' + String(l.value).split('"').join('""') + '"');
        });
        break;
      case "row":
        o.columns.forEach((l) => {
          if (l) {
            switch (typeof l.value) {
              case "object":
                l.value = l.value !== null ? JSON.stringify(l.value) : "";
                break;
              case "undefined":
                l.value = "";
                break;
            }
            s.push('"' + String(l.value).split('"').join('""') + '"');
          }
        }), n.push(s.join(i));
        break;
    }
  }), a.length && n.unshift(a.join(i)), n = n.join(`
`), e.bom && (n = "\uFEFF" + n), t(n, "text/csv");
}
function xUe(r, e, t) {
  var i = [];
  r.forEach((n) => {
    var a = {};
    switch (n.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        n.columns.forEach((o) => {
          o && (a[o.component.getTitleDownload() || o.component.getField()] = o.value);
        }), i.push(a);
        break;
    }
  }), i = JSON.stringify(i, null, "	"), t(i, "application/json");
}
function wUe(r, e = {}, t) {
  var i = [], n = [], a = {}, o = e.rowGroupStyles || {
    fontStyle: "bold",
    fontSize: 12,
    cellPadding: 6,
    fillColor: 220
  }, s = e.rowCalcStyles || {
    fontStyle: "bold",
    fontSize: 10,
    cellPadding: 4,
    fillColor: 232
  }, l = e.jsPDF || {}, u = e.title ? e.title : "";
  l.orientation || (l.orientation = e.orientation || "landscape"), l.unit || (l.unit = "pt"), r.forEach((f) => {
    switch (f.type) {
      case "header":
        i.push(h(f));
        break;
      case "group":
        n.push(h(f, o));
        break;
      case "calc":
        n.push(h(f, s));
        break;
      case "row":
        n.push(h(f));
        break;
    }
  });
  function h(f, d) {
    var p = [];
    return f.columns.forEach((g) => {
      var v;
      if (g) {
        switch (typeof g.value) {
          case "object":
            g.value = g.value !== null ? JSON.stringify(g.value) : "";
            break;
          case "undefined":
            g.value = "";
            break;
        }
        v = {
          content: g.value,
          colSpan: g.width,
          rowSpan: g.height
        }, d && (v.styles = d), p.push(v);
      }
    }), p;
  }
  var c = new jspdf.jsPDF(l);
  e.autoTable && (typeof e.autoTable == "function" ? a = e.autoTable(c) || {} : a = e.autoTable), u && (a.didDrawPage = function(f) {
    c.text(u, 40, 30);
  }), a.head = i, a.body = n, c.autoTable(a), e.documentProcessing && e.documentProcessing(c), t(c.output("arraybuffer"), "application/pdf");
}
function PUe(r, e, t) {
  var i = this, n = e.sheetName || "Sheet1", a = XLSX.utils.book_new(), o = new zi(this), s = "compress" in e ? e.compress : !0, l = e.writeOptions || { bookType: "xlsx", bookSST: !0, compression: s }, u;
  l.type = "binary", a.SheetNames = [], a.Sheets = {};
  function h() {
    var d = [], p = [], g = {}, v = { s: { c: 0, r: 0 }, e: { c: r[0] ? r[0].columns.reduce((O, m) => O + (m && m.width ? m.width : 1), 0) : 0, r: r.length } };
    return r.forEach((O, m) => {
      var E = [];
      O.columns.forEach(function(b, T) {
        b ? (E.push(!(b.value instanceof Date) && typeof b.value == "object" ? JSON.stringify(b.value) : b.value), (b.width > 1 || b.height > -1) && (b.height > 1 || b.width > 1) && p.push({ s: { r: m, c: T }, e: { r: m + b.height - 1, c: T + b.width - 1 } })) : E.push("");
      }), d.push(E);
    }), XLSX.utils.sheet_add_aoa(g, d), g["!ref"] = XLSX.utils.encode_range(v), p.length && (g["!merges"] = p), g;
  }
  if (e.sheetOnly) {
    t(h());
    return;
  }
  if (e.sheets)
    for (var c in e.sheets)
      e.sheets[c] === !0 ? (a.SheetNames.push(c), a.Sheets[c] = h()) : (a.SheetNames.push(c), o.commsSend(e.sheets[c], "download", "intercept", {
        type: "xlsx",
        options: { sheetOnly: !0 },
        active: i.active,
        intercept: function(d) {
          a.Sheets[c] = d;
        }
      }));
  else
    a.SheetNames.push(n), a.Sheets[n] = h();
  e.documentProcessing && (a = e.documentProcessing(a));
  function f(d) {
    for (var p = new ArrayBuffer(d.length), g = new Uint8Array(p), v = 0; v != d.length; ++v)
      g[v] = d.charCodeAt(v) & 255;
    return p;
  }
  u = XLSX.write(a, l), t(f(u), "application/octet-stream");
}
function NUe(r, e, t) {
  this.modExists("export", !0) && t(this.modules.export.generateHTMLTable(r), "text/html");
}
function LUe(r, e, t) {
  const i = [];
  r.forEach((n) => {
    const a = {};
    switch (n.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        n.columns.forEach((o) => {
          o && (a[o.component.getTitleDownload() || o.component.getField()] = o.value);
        }), i.push(JSON.stringify(a));
        break;
    }
  }), t(i.join(`
`), "application/x-ndjson");
}
var DUe = {
  csv: IUe,
  json: xUe,
  jsonLines: LUe,
  pdf: wUe,
  xlsx: PUe,
  html: NUe
};
class fh extends pt {
  constructor(e) {
    super(e), this.registerTableOption("downloadEncoder", function(t, i) {
      return new Blob([t], { type: i });
    }), this.registerTableOption("downloadReady", void 0), this.registerTableOption("downloadConfig", {}), this.registerTableOption("downloadRowRange", "active"), this.registerColumnOption("download"), this.registerColumnOption("titleDownload");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.registerTableFunction("download", this.download.bind(this)), this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("downloadReady", "downloadEncoder");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  downloadToTab(e, t, i, n) {
    this.download(e, t, i, n, !0);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //trigger file download
  download(e, t, i, n, a) {
    var o = !1;
    function s(u, h) {
      a ? a === !0 ? this.triggerDownload(u, h, e, t, !0) : a(u) : this.triggerDownload(u, h, e, t);
    }
    if (typeof e == "function" ? o = e : fh.downloaders[e] ? o = fh.downloaders[e] : console.warn("Download Error - No such download type found: ", e), o) {
      var l = this.generateExportList(n);
      o.call(this.table, l, i || {}, s.bind(this));
    }
  }
  generateExportList(e) {
    var t = this.table.modules.export.generateExportList(this.table.options.downloadConfig, !1, e || this.table.options.downloadRowRange, "download"), i = this.table.options.groupHeaderDownload;
    return i && !Array.isArray(i) && (i = [i]), t.forEach((n) => {
      var a;
      n.type === "group" && (a = n.columns[0], i && i[n.indent] && (a.value = i[n.indent](a.value, n.component._group.getRowCount(), n.component._group.getData(), n.component)));
    }), t;
  }
  triggerDownload(e, t, i, n, a) {
    var o = document.createElement("a"), s = this.table.options.downloadEncoder(e, t);
    s && (a ? window.open(window.URL.createObjectURL(s)) : (n = n || "Tabulator." + (typeof i == "function" ? "txt" : i), navigator.msSaveOrOpenBlob ? navigator.msSaveOrOpenBlob(s, n) : (o.setAttribute("href", window.URL.createObjectURL(s)), o.setAttribute("download", n), o.style.display = "none", document.body.appendChild(o), o.click(), document.body.removeChild(o))), this.dispatchExternal("downloadComplete"));
  }
  commsReceived(e, t, i) {
    switch (t) {
      case "intercept":
        this.download(i.type, "", i.options, i.active, i.intercept);
        break;
    }
  }
}
fh.moduleName = "download";
fh.downloaders = DUe;
function RT(r, e) {
  var t = e.mask, i = typeof e.maskLetterChar < "u" ? e.maskLetterChar : "A", n = typeof e.maskNumberChar < "u" ? e.maskNumberChar : "9", a = typeof e.maskWildcardChar < "u" ? e.maskWildcardChar : "*";
  function o(s) {
    var l = t[s];
    typeof l < "u" && l !== a && l !== i && l !== n && (r.value = r.value + "" + l, o(s + 1));
  }
  r.addEventListener("keydown", (s) => {
    var l = r.value.length, u = s.key;
    if (s.keyCode > 46 && !s.ctrlKey && !s.metaKey) {
      if (l >= t.length)
        return s.preventDefault(), s.stopPropagation(), !1;
      switch (t[l]) {
        case i:
          if (u.toUpperCase() == u.toLowerCase())
            return s.preventDefault(), s.stopPropagation(), !1;
          break;
        case n:
          if (isNaN(u))
            return s.preventDefault(), s.stopPropagation(), !1;
          break;
        case a:
          break;
        default:
          if (u !== t[l])
            return s.preventDefault(), s.stopPropagation(), !1;
      }
    }
  }), r.addEventListener("keyup", (s) => {
    s.keyCode > 46 && e.maskAutoFill && o(r.value.length);
  }), r.placeholder || (r.placeholder = t), e.maskAutoFill && o(r.value.length);
}
function MUe(r, e, t, i, n) {
  var a = r.getValue(), o = document.createElement("input");
  if (o.setAttribute("type", n.search ? "search" : "text"), o.style.padding = "4px", o.style.width = "100%", o.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let l in n.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), o.setAttribute(l, o.getAttribute(l) + n.elementAttributes["+" + l])) : o.setAttribute(l, n.elementAttributes[l]);
  o.value = typeof a < "u" ? a : "", e(function() {
    r.getType() === "cell" && (o.focus({ preventScroll: !0 }), o.style.height = "100%", n.selectContents && o.select());
  });
  function s(l) {
    (a === null || typeof a > "u") && o.value !== "" || o.value !== a ? t(o.value) && (a = o.value) : i();
  }
  return o.addEventListener("change", s), o.addEventListener("blur", s), o.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        s();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        l.stopPropagation();
        break;
    }
  }), n.mask && RT(o, n), o;
}
function kUe(r, e, t, i, n) {
  var a = r.getValue(), o = n.verticalNavigation || "hybrid", s = String(a !== null && typeof a < "u" ? a : ""), l = document.createElement("textarea"), u = 0;
  if (l.style.display = "block", l.style.padding = "2px", l.style.height = "100%", l.style.width = "100%", l.style.boxSizing = "border-box", l.style.whiteSpace = "pre-wrap", l.style.resize = "none", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let c in n.elementAttributes)
      c.charAt(0) == "+" ? (c = c.slice(1), l.setAttribute(c, l.getAttribute(c) + n.elementAttributes["+" + c])) : l.setAttribute(c, n.elementAttributes[c]);
  l.value = s, e(function() {
    r.getType() === "cell" && (l.focus({ preventScroll: !0 }), l.style.height = "100%", l.scrollHeight, l.style.height = l.scrollHeight + "px", r.getRow().normalizeHeight(), n.selectContents && l.select());
  });
  function h(c) {
    (a === null || typeof a > "u") && l.value !== "" || l.value !== a ? (t(l.value) && (a = l.value), setTimeout(function() {
      r.getRow().normalizeHeight();
    }, 300)) : i();
  }
  return l.addEventListener("change", h), l.addEventListener("blur", h), l.addEventListener("keyup", function() {
    l.style.height = "";
    var c = l.scrollHeight;
    l.style.height = c + "px", c != u && (u = c, r.getRow().normalizeHeight());
  }), l.addEventListener("keydown", function(c) {
    switch (c.keyCode) {
      case 13:
        c.shiftKey && n.shiftEnterSubmit && h();
        break;
      case 27:
        i();
        break;
      case 38:
        (o == "editor" || o == "hybrid" && l.selectionStart) && (c.stopImmediatePropagation(), c.stopPropagation());
        break;
      case 40:
        (o == "editor" || o == "hybrid" && l.selectionStart !== l.value.length) && (c.stopImmediatePropagation(), c.stopPropagation());
        break;
      case 35:
      case 36:
        c.stopPropagation();
        break;
    }
  }), n.mask && RT(l, n), l;
}
function QUe(r, e, t, i, n) {
  var a = r.getValue(), o = n.verticalNavigation || "editor", s = document.createElement("input");
  if (s.setAttribute("type", "number"), typeof n.max < "u" && s.setAttribute("max", n.max), typeof n.min < "u" && s.setAttribute("min", n.min), typeof n.step < "u" && s.setAttribute("step", n.step), s.style.padding = "4px", s.style.width = "100%", s.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let h in n.elementAttributes)
      h.charAt(0) == "+" ? (h = h.slice(1), s.setAttribute(h, s.getAttribute(h) + n.elementAttributes["+" + h])) : s.setAttribute(h, n.elementAttributes[h]);
  s.value = a;
  var l = function(h) {
    u();
  };
  e(function() {
    r.getType() === "cell" && (s.removeEventListener("blur", l), s.focus({ preventScroll: !0 }), s.style.height = "100%", s.addEventListener("blur", l), n.selectContents && s.select());
  });
  function u() {
    var h = s.value;
    !isNaN(h) && h !== "" && (h = Number(h)), h !== a ? t(h) && (a = h) : i();
  }
  return s.addEventListener("keydown", function(h) {
    switch (h.keyCode) {
      case 13:
        u();
        break;
      case 27:
        i();
        break;
      case 38:
      case 40:
        o == "editor" && (h.stopImmediatePropagation(), h.stopPropagation());
        break;
      case 35:
      case 36:
        h.stopPropagation();
        break;
    }
  }), n.mask && RT(s, n), s;
}
function UUe(r, e, t, i, n) {
  var a = r.getValue(), o = document.createElement("input");
  if (o.setAttribute("type", "range"), typeof n.max < "u" && o.setAttribute("max", n.max), typeof n.min < "u" && o.setAttribute("min", n.min), typeof n.step < "u" && o.setAttribute("step", n.step), o.style.padding = "4px", o.style.width = "100%", o.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let l in n.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), o.setAttribute(l, o.getAttribute(l) + n.elementAttributes["+" + l])) : o.setAttribute(l, n.elementAttributes[l]);
  o.value = a, e(function() {
    r.getType() === "cell" && (o.focus({ preventScroll: !0 }), o.style.height = "100%");
  });
  function s() {
    var l = o.value;
    !isNaN(l) && l !== "" && (l = Number(l)), l != a ? t(l) && (a = l) : i();
  }
  return o.addEventListener("blur", function(l) {
    s();
  }), o.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        s();
        break;
      case 27:
        i();
        break;
    }
  }), o;
}
function $Ue(r, e, t, i, n) {
  var a = n.format, o = n.verticalNavigation || "editor", s = a ? window.DateTime || luxon.DateTime : null, l = r.getValue(), u = document.createElement("input");
  function h(f) {
    var d;
    return s.isDateTime(f) ? d = f : a === "iso" ? d = s.fromISO(String(f)) : d = s.fromFormat(String(f), a), d.toFormat("yyyy-MM-dd");
  }
  if (u.type = "date", u.style.padding = "4px", u.style.width = "100%", u.style.boxSizing = "border-box", n.max && u.setAttribute("max", a ? h(n.max) : n.max), n.min && u.setAttribute("min", a ? h(n.min) : n.min), n.elementAttributes && typeof n.elementAttributes == "object")
    for (let f in n.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), u.setAttribute(f, u.getAttribute(f) + n.elementAttributes["+" + f])) : u.setAttribute(f, n.elementAttributes[f]);
  l = typeof l < "u" ? l : "", a && (s ? l = h(l) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), u.value = l, e(function() {
    r.getType() === "cell" && (u.focus({ preventScroll: !0 }), u.style.height = "100%", n.selectContents && u.select());
  });
  function c() {
    var f = u.value, d;
    if ((l === null || typeof l > "u") && f !== "" || f !== l) {
      if (f && a)
        switch (d = s.fromFormat(String(f), "yyyy-MM-dd"), a) {
          case !0:
            f = d;
            break;
          case "iso":
            f = d.toISO();
            break;
          default:
            f = d.toFormat(a);
        }
      t(f) && (l = u.value);
    } else
      i();
  }
  return u.addEventListener("blur", function(f) {
    (f.relatedTarget || f.rangeParent || f.explicitOriginalTarget !== u) && c();
  }), u.addEventListener("keydown", function(f) {
    switch (f.keyCode) {
      case 13:
        c();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        f.stopPropagation();
        break;
      case 38:
      case 40:
        o == "editor" && (f.stopImmediatePropagation(), f.stopPropagation());
        break;
    }
  }), u;
}
function GUe(r, e, t, i, n) {
  var a = n.format, o = n.verticalNavigation || "editor", s = a ? window.DateTime || luxon.DateTime : null, l, u = r.getValue(), h = document.createElement("input");
  if (h.type = "time", h.style.padding = "4px", h.style.width = "100%", h.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let f in n.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), h.setAttribute(f, h.getAttribute(f) + n.elementAttributes["+" + f])) : h.setAttribute(f, n.elementAttributes[f]);
  u = typeof u < "u" ? u : "", a && (s ? (s.isDateTime(u) ? l = u : a === "iso" ? l = s.fromISO(String(u)) : l = s.fromFormat(String(u), a), u = l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), h.value = u, e(function() {
    r.getType() == "cell" && (h.focus({ preventScroll: !0 }), h.style.height = "100%", n.selectContents && h.select());
  });
  function c() {
    var f = h.value, d;
    if ((u === null || typeof u > "u") && f !== "" || f !== u) {
      if (f && a)
        switch (d = s.fromFormat(String(f), "hh:mm"), a) {
          case !0:
            f = d;
            break;
          case "iso":
            f = d.toISO();
            break;
          default:
            f = d.toFormat(a);
        }
      t(f) && (u = h.value);
    } else
      i();
  }
  return h.addEventListener("blur", function(f) {
    (f.relatedTarget || f.rangeParent || f.explicitOriginalTarget !== h) && c();
  }), h.addEventListener("keydown", function(f) {
    switch (f.keyCode) {
      case 13:
        c();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        f.stopPropagation();
        break;
      case 38:
      case 40:
        o == "editor" && (f.stopImmediatePropagation(), f.stopPropagation());
        break;
    }
  }), h;
}
function BUe(r, e, t, i, n) {
  var a = n.format, o = n.verticalNavigation || "editor", s = a ? window.DateTime || luxon.DateTime : null, l, u = r.getValue(), h = document.createElement("input");
  if (h.type = "datetime-local", h.style.padding = "4px", h.style.width = "100%", h.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let f in n.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), h.setAttribute(f, h.getAttribute(f) + n.elementAttributes["+" + f])) : h.setAttribute(f, n.elementAttributes[f]);
  u = typeof u < "u" ? u : "", a && (s ? (s.isDateTime(u) ? l = u : a === "iso" ? l = s.fromISO(String(u)) : l = s.fromFormat(String(u), a), u = l.toFormat("yyyy-MM-dd") + "T" + l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), h.value = u, e(function() {
    r.getType() === "cell" && (h.focus({ preventScroll: !0 }), h.style.height = "100%", n.selectContents && h.select());
  });
  function c() {
    var f = h.value, d;
    if ((u === null || typeof u > "u") && f !== "" || f !== u) {
      if (f && a)
        switch (d = s.fromISO(String(f)), a) {
          case !0:
            f = d;
            break;
          case "iso":
            f = d.toISO();
            break;
          default:
            f = d.toFormat(a);
        }
      t(f) && (u = h.value);
    } else
      i();
  }
  return h.addEventListener("blur", function(f) {
    (f.relatedTarget || f.rangeParent || f.explicitOriginalTarget !== h) && c();
  }), h.addEventListener("keydown", function(f) {
    switch (f.keyCode) {
      case 13:
        c();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        f.stopPropagation();
        break;
      case 38:
      case 40:
        o == "editor" && (f.stopImmediatePropagation(), f.stopPropagation());
        break;
    }
  }), h;
}
class IP {
  constructor(e, t, i, n, a, o) {
    this.edit = e, this.table = e.table, this.cell = t, this.params = this._initializeParams(o), this.data = [], this.displayItems = [], this.currentItems = [], this.focusedItem = null, this.input = this._createInputElement(), this.listEl = this._createListElement(), this.initialValues = null, this.isFilter = t.getType() === "header", this.filterTimeout = null, this.filtered = !1, this.typing = !1, this.values = [], this.popup = null, this.listIteration = 0, this.lastAction = "", this.filterTerm = "", this.blurable = !0, this.actions = {
      success: n,
      cancel: a
    }, this._deprecatedOptionsCheck(), this._initializeValue(), i(this._onRendered.bind(this));
  }
  _deprecatedOptionsCheck() {
    this.params.listItemFormatter && this.cell.getTable().deprecationAdvisor.msg("The listItemFormatter editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.sortValuesList && this.cell.getTable().deprecationAdvisor.msg("The sortValuesList editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchFunc && this.cell.getTable().deprecationAdvisor.msg("The searchFunc editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchingPlaceholder && this.cell.getTable().deprecationAdvisor.msg("The searchingPlaceholder editor param has been deprecated, please see the latest editor documentation for updated options");
  }
  _initializeValue() {
    var e = this.cell.getValue();
    typeof e > "u" && typeof this.params.defaultValue < "u" && (e = this.params.defaultValue), this.initialValues = this.params.multiselect ? e : [e], this.isFilter && (this.input.value = this.initialValues ? this.initialValues.join(",") : "", this.headerFilterInitialListGen());
  }
  _onRendered() {
    var e = this.cell.getElement();
    function t(i) {
      i.stopPropagation();
    }
    this.isFilter || (this.input.style.height = "100%", this.input.focus({ preventScroll: !0 })), e.addEventListener("click", t), setTimeout(() => {
      e.removeEventListener("click", t);
    }, 1e3), this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
  }
  _createListElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-edit-list"), e.addEventListener("mousedown", this._preventBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e;
  }
  _setListWidth() {
    var e = this.isFilter ? this.input : this.cell.getElement();
    this.listEl.style.minWidth = e.offsetWidth + "px", this.params.maxWidth && (this.params.maxWidth === !0 ? this.listEl.style.maxWidth = e.offsetWidth + "px" : typeof this.params.maxWidth == "number" ? this.listEl.style.maxWidth = this.params.maxWidth + "px" : this.listEl.style.maxWidth = this.params.maxWidth);
  }
  _createInputElement() {
    var e = this.params.elementAttributes, t = document.createElement("input");
    if (t.setAttribute("type", this.params.clearable ? "search" : "text"), t.style.padding = "4px", t.style.width = "100%", t.style.boxSizing = "border-box", this.params.autocomplete || (t.style.cursor = "default", t.style.caretColor = "transparent"), e && typeof e == "object")
      for (let i in e)
        i.charAt(0) == "+" ? (i = i.slice(1), t.setAttribute(i, t.getAttribute(i) + e["+" + i])) : t.setAttribute(i, e[i]);
    return this.params.mask && RT(t, this.params), this._bindInputEvents(t), t;
  }
  _initializeParams(e) {
    var t = ["values", "valuesURL", "valuesLookup"], i;
    return e = Object.assign({}, e), e.verticalNavigation = e.verticalNavigation || "editor", e.placeholderLoading = typeof e.placeholderLoading > "u" ? "Searching ..." : e.placeholderLoading, e.placeholderEmpty = typeof e.placeholderEmpty > "u" ? "No Results Found" : e.placeholderEmpty, e.filterDelay = typeof e.filterDelay > "u" ? 300 : e.filterDelay, e.emptyValue = Object.keys(e).includes("emptyValue") ? e.emptyValue : "", i = Object.keys(e).filter((n) => t.includes(n)).length, i ? i > 1 && console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor") : console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set"), e.autocomplete ? e.multiselect && (e.multiselect = !1, console.warn("list editor config error - multiselect option is not available when autocomplete is enabled")) : (e.freetext && (e.freetext = !1, console.warn("list editor config error - freetext option is only available when autocomplete is enabled")), e.filterFunc && (e.filterFunc = !1, console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled")), e.filterRemote && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled")), e.mask && (e.mask = !1, console.warn("list editor config error - mask option is only available when autocomplete is enabled")), e.allowEmpty && (e.allowEmpty = !1, console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled")), e.listOnEmpty && (e.listOnEmpty = !1, console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled"))), e.filterRemote && !(typeof e.valuesLookup == "function" || e.valuesURL) && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source")), e;
  }
  //////////////////////////////////////
  ////////// Event Handling ////////////
  //////////////////////////////////////
  _bindInputEvents(e) {
    e.addEventListener("focus", this._inputFocus.bind(this)), e.addEventListener("click", this._inputClick.bind(this)), e.addEventListener("blur", this._inputBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e.addEventListener("search", this._inputSearch.bind(this)), this.params.autocomplete && e.addEventListener("keyup", this._inputKeyUp.bind(this));
  }
  _inputFocus(e) {
    this.rebuildOptionsList();
  }
  _filter() {
    this.params.filterRemote ? (clearTimeout(this.filterTimeout), this.filterTimeout = setTimeout(() => {
      this.rebuildOptionsList();
    }, this.params.filterDelay)) : this._filterList();
  }
  _inputClick(e) {
    e.stopPropagation();
  }
  _inputBlur(e) {
    this.blurable && (this.popup ? this.popup.hide() : this._resolveValue(!0));
  }
  _inputSearch() {
    this._clearChoices();
  }
  _inputKeyDown(e) {
    switch (e.keyCode) {
      case 38:
        this._keyUp(e);
        break;
      case 40:
        this._keyDown(e);
        break;
      case 37:
      case 39:
        this._keySide(e);
        break;
      case 13:
        this._keyEnter();
        break;
      case 27:
        this._keyEsc();
        break;
      case 36:
      case 35:
        this._keyHomeEnd(e);
        break;
      case 9:
        this._keyTab(e);
        break;
      default:
        this._keySelectLetter(e);
    }
  }
  _inputKeyUp(e) {
    switch (e.keyCode) {
      case 38:
      case 37:
      case 39:
      case 40:
      case 13:
      case 27:
        break;
      default:
        this._keyAutoCompLetter(e);
    }
  }
  _preventPopupBlur() {
    this.popup && this.popup.blockHide(), setTimeout(() => {
      this.popup && this.popup.restoreHide();
    }, 10);
  }
  _preventBlur() {
    this.blurable = !1, setTimeout(() => {
      this.blurable = !0;
    }, 10);
  }
  //////////////////////////////////////
  //////// Keyboard Navigation /////////
  //////////////////////////////////////
  _keyTab(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem, !0);
  }
  _keyUp(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t > 0 && this._focusItem(this.displayItems[t - 1]));
  }
  _keyDown(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t < this.displayItems.length - 1) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t < this.displayItems.length - 1 && (t == -1 ? this._focusItem(this.displayItems[0]) : this._focusItem(this.displayItems[t + 1])));
  }
  _keySide(e) {
    this.params.autocomplete || (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault());
  }
  _keyEnter(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem);
  }
  _keyEsc(e) {
    this._cancel();
  }
  _keyHomeEnd(e) {
    this.params.autocomplete && e.stopImmediatePropagation();
  }
  _keySelectLetter(e) {
    this.params.autocomplete || (e.preventDefault(), e.keyCode >= 38 && e.keyCode <= 90 && this._scrollToValue(e.keyCode));
  }
  _keyAutoCompLetter(e) {
    this._filter(), this.lastAction = "typing", this.typing = !0;
  }
  _scrollToValue(e) {
    clearTimeout(this.filterTimeout);
    var t = String.fromCharCode(e).toLowerCase();
    this.filterTerm += t.toLowerCase();
    var i = this.displayItems.find((n) => typeof n.label < "u" && n.label.toLowerCase().startsWith(this.filterTerm));
    i && this._focusItem(i), this.filterTimeout = setTimeout(() => {
      this.filterTerm = "";
    }, 800);
  }
  _focusItem(e) {
    this.lastAction = "focus", this.focusedItem && this.focusedItem.element && this.focusedItem.element.classList.remove("focused"), this.focusedItem = e, e && e.element && (e.element.classList.add("focused"), e.element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" }));
  }
  //////////////////////////////////////
  /////// Data List Generation /////////
  //////////////////////////////////////
  headerFilterInitialListGen() {
    this._generateOptions(!0);
  }
  rebuildOptionsList() {
    this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch((e) => {
      Number.isInteger(e) || console.error("List generation error", e);
    });
  }
  _filterList() {
    this._buildList(this._filterOptions()), this._showList();
  }
  _generateOptions(e) {
    var t = [], i = ++this.listIteration;
    return this.filtered = !1, this.params.values ? t = this.params.values : this.params.valuesURL ? t = this._ajaxRequest(this.params.valuesURL, this.input.value) : typeof this.params.valuesLookup == "function" ? t = this.params.valuesLookup(this.cell, this.input.value) : this.params.valuesLookup && (t = this._uniqueColumnValues(this.params.valuesLookupField)), t instanceof Promise ? (e || this._addPlaceholder(this.params.placeholderLoading), t.then().then((n) => this.listIteration === i ? this._parseList(n) : Promise.reject(i))) : Promise.resolve(this._parseList(t));
  }
  _addPlaceholder(e) {
    var t = document.createElement("div");
    typeof e == "function" && (e = e(this.cell.getComponent(), this.listEl)), e && (this._clearList(), e instanceof HTMLElement ? t = e : (t.classList.add("tabulator-edit-list-placeholder"), t.innerHTML = e), this.listEl.appendChild(t), this._showList());
  }
  _ajaxRequest(e, t) {
    var i = this.params.filterRemote ? { term: t } : {};
    return e = h8(e, {}, i), fetch(e).then((n) => n.ok ? n.json().catch((a) => (console.warn("List Ajax Load Error - Invalid JSON returned", a), Promise.reject(a))) : (console.error("List Ajax Load Error - Connection Error: " + n.status, n.statusText), Promise.reject(n))).catch((n) => (console.error("List Ajax Load Error - Connection Error: ", n), Promise.reject(n)));
  }
  _uniqueColumnValues(e) {
    var t = {}, i = this.table.getData(this.params.valuesLookup), n;
    return e ? n = this.table.columnManager.getColumnByField(e) : n = this.cell.getColumn()._getSelf(), n ? i.forEach((a) => {
      var o = n.getFieldValue(a);
      o !== null && typeof o < "u" && o !== "" && (t[o] = !0);
    }) : (console.warn("unable to find matching column to create select lookup list:", e), t = []), Object.keys(t);
  }
  _parseList(e) {
    var t = [];
    return Array.isArray(e) || (e = Object.entries(e).map(([i, n]) => ({
      label: n,
      value: i
    }))), e.forEach((i) => {
      typeof i != "object" && (i = {
        label: i,
        value: i
      }), this._parseListItem(i, t, 0);
    }), !this.currentItems.length && this.params.freetext && (this.input.value = this.initialValues, this.typing = !0, this.lastAction = "typing"), this.data = t, t;
  }
  _parseListItem(e, t, i) {
    var n = {};
    e.options ? n = this._parseListGroup(e, i + 1) : (n = {
      label: e.label,
      value: e.value,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      selected: !1,
      visible: !0,
      level: i,
      original: e
    }, this.initialValues && this.initialValues.indexOf(e.value) > -1 && this._chooseItem(n, !0)), t.push(n);
  }
  _parseListGroup(e, t) {
    var i = {
      label: e.label,
      group: !0,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      visible: !0,
      level: t,
      options: [],
      original: e
    };
    return e.options.forEach((n) => {
      this._parseListItem(n, i.options, t);
    }), i;
  }
  _sortOptions(e) {
    var t;
    return this.params.sort && (t = typeof this.params.sort == "function" ? this.params.sort : this._defaultSortFunction.bind(this), this._sortGroup(t, e)), e;
  }
  _sortGroup(e, t) {
    t.sort((i, n) => e(i.label, n.label, i.value, n.value, i.original, n.original)), t.forEach((i) => {
      i.group && this._sortGroup(e, i.options);
    });
  }
  _defaultSortFunction(e, t) {
    var i, n, a, o, s = 0, l, u = /(\d+)|(\D+)/g, h = /\d/, c = 0;
    if (this.params.sort === "desc" && ([e, t] = [t, e]), !e && e !== 0)
      c = !t && t !== 0 ? 0 : -1;
    else if (!t && t !== 0)
      c = 1;
    else {
      if (isFinite(e) && isFinite(t))
        return e - t;
      if (i = String(e).toLowerCase(), n = String(t).toLowerCase(), i === n)
        return 0;
      if (!(h.test(i) && h.test(n)))
        return i > n ? 1 : -1;
      for (i = i.match(u), n = n.match(u), l = i.length > n.length ? n.length : i.length; s < l; )
        if (a = i[s], o = n[s++], a !== o)
          return isFinite(a) && isFinite(o) ? (a.charAt(0) === "0" && (a = "." + a), o.charAt(0) === "0" && (o = "." + o), a - o) : a > o ? 1 : -1;
      return i.length > n.length;
    }
    return c;
  }
  _filterOptions() {
    var e = this.params.filterFunc || this._defaultFilterFunc, t = this.input.value;
    return t ? (this.filtered = !0, this.data.forEach((i) => {
      this._filterItem(e, t, i);
    })) : this.filtered = !1, this.data;
  }
  _filterItem(e, t, i) {
    var n = !1;
    return i.group ? (i.options.forEach((a) => {
      this._filterItem(e, t, a) && (n = !0);
    }), i.visible = n) : i.visible = e(t, i.label, i.value, i.original), i.visible;
  }
  _defaultFilterFunc(e, t, i, n) {
    return e = String(e).toLowerCase(), t !== null && typeof t < "u" && (String(t).toLowerCase().indexOf(e) > -1 || String(i).toLowerCase().indexOf(e) > -1);
  }
  //////////////////////////////////////
  /////////// Display List /////////////
  //////////////////////////////////////
  _clearList() {
    for (; this.listEl.firstChild; )
      this.listEl.removeChild(this.listEl.firstChild);
    this.displayItems = [];
  }
  _buildList(e) {
    this._clearList(), e.forEach((t) => {
      this._buildItem(t);
    }), this.displayItems.length || this._addPlaceholder(this.params.placeholderEmpty);
  }
  _buildItem(e) {
    var t = e.element, i;
    if (!this.filtered || e.visible) {
      if (!t) {
        if (t = document.createElement("div"), t.tabIndex = 0, i = this.params.itemFormatter ? this.params.itemFormatter(e.label, e.value, e.original, t) : e.label, i instanceof HTMLElement ? t.appendChild(i) : t.innerHTML = i, e.group ? t.classList.add("tabulator-edit-list-group") : t.classList.add("tabulator-edit-list-item"), t.classList.add("tabulator-edit-list-group-level-" + e.level), e.elementAttributes && typeof e.elementAttributes == "object")
          for (let n in e.elementAttributes)
            n.charAt(0) == "+" ? (n = n.slice(1), t.setAttribute(n, this.input.getAttribute(n) + e.elementAttributes["+" + n])) : t.setAttribute(n, e.elementAttributes[n]);
        e.group ? t.addEventListener("click", this._groupClick.bind(this, e)) : t.addEventListener("click", this._itemClick.bind(this, e)), t.addEventListener("mousedown", this._preventBlur.bind(this)), e.element = t;
      }
      this._styleItem(e), this.listEl.appendChild(t), e.group ? e.options.forEach((n) => {
        this._buildItem(n);
      }) : this.displayItems.push(e);
    }
  }
  _showList() {
    var e = this.popup && this.popup.isVisible();
    if (this.input.parentNode) {
      if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
        this.popup && this.popup.hide(!0);
        return;
      }
      this._setListWidth(), this.popup || (this.popup = this.edit.popup(this.listEl)), this.popup.show(this.cell.getElement(), "bottom"), e || setTimeout(() => {
        this.popup.hideOnBlur(this._resolveValue.bind(this, !0));
      }, 10);
    }
  }
  _styleItem(e) {
    e && e.element && (e.selected ? e.element.classList.add("active") : e.element.classList.remove("active"));
  }
  //////////////////////////////////////
  ///////// User Interaction ///////////
  //////////////////////////////////////
  _itemClick(e, t) {
    t.stopPropagation(), this._chooseItem(e);
  }
  _groupClick(e, t) {
    t.stopPropagation();
  }
  //////////////////////////////////////
  ////// Current Item Management ///////
  //////////////////////////////////////
  _cancel() {
    this.popup.hide(!0), this.actions.cancel();
  }
  _clearChoices() {
    this.typing = !0, this.currentItems.forEach((e) => {
      e.selected = !1, this._styleItem(e);
    }), this.currentItems = [], this.focusedItem = null;
  }
  _chooseItem(e, t) {
    var i;
    this.typing = !1, this.params.multiselect ? (i = this.currentItems.indexOf(e), i > -1 ? (this.currentItems.splice(i, 1), e.selected = !1) : (this.currentItems.push(e), e.selected = !0), this.input.value = this.currentItems.map((n) => n.label).join(","), this._styleItem(e)) : (this.currentItems = [e], e.selected = !0, this.input.value = e.label, this._styleItem(e), t || this._resolveValue()), this._focusItem(e);
  }
  _resolveValue(e) {
    var t, i;
    if (this.popup && this.popup.hide(!0), this.params.multiselect)
      t = this.currentItems.map((n) => n.value);
    else if (e && this.params.autocomplete && this.typing)
      if (this.params.freetext || this.params.allowEmpty && this.input.value === "")
        t = this.input.value;
      else {
        this.actions.cancel();
        return;
      }
    else
      this.currentItems[0] ? t = this.currentItems[0].value : (i = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues, i === null || typeof i > "u" || i === "" ? t = i : t = this.params.emptyValue);
    t === "" && (t = this.params.emptyValue), this.actions.success(t), this.isFilter && (this.initialValues = t && !Array.isArray(t) ? [t] : t, this.currentItems = []);
  }
}
function VUe(r, e, t, i, n) {
  this.deprecationMsg("The select editor has been deprecated, please use the new list editor");
  var a = new IP(this, r, e, t, i, n);
  return a.input;
}
function FUe(r, e, t, i, n) {
  var a = new IP(this, r, e, t, i, n);
  return a.input;
}
function XUe(r, e, t, i, n) {
  this.deprecationMsg("The autocomplete editor has been deprecated, please use the new list editor with the 'autocomplete' editorParam"), n.autocomplete = !0;
  var a = new IP(this, r, e, t, i, n);
  return a.input;
}
function YUe(r, e, t, i, n) {
  var a = this, o = r.getElement(), s = r.getValue(), l = o.getElementsByTagName("svg").length || 5, u = o.getElementsByTagName("svg")[0] ? o.getElementsByTagName("svg")[0].getAttribute("width") : 14, h = [], c = document.createElement("div"), f = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  function d(O) {
    h.forEach(function(m, E) {
      E < O ? (a.table.browser == "ie" ? m.setAttribute("class", "tabulator-star-active") : m.classList.replace("tabulator-star-inactive", "tabulator-star-active"), m.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>') : (a.table.browser == "ie" ? m.setAttribute("class", "tabulator-star-inactive") : m.classList.replace("tabulator-star-active", "tabulator-star-inactive"), m.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>');
    });
  }
  function p(O) {
    var m = document.createElement("span"), E = f.cloneNode(!0);
    h.push(E), m.addEventListener("mouseenter", function(b) {
      b.stopPropagation(), b.stopImmediatePropagation(), d(O);
    }), m.addEventListener("mousemove", function(b) {
      b.stopPropagation(), b.stopImmediatePropagation();
    }), m.addEventListener("click", function(b) {
      b.stopPropagation(), b.stopImmediatePropagation(), t(O), o.blur();
    }), m.appendChild(E), c.appendChild(m);
  }
  function g(O) {
    s = O, d(O);
  }
  if (o.style.whiteSpace = "nowrap", o.style.overflow = "hidden", o.style.textOverflow = "ellipsis", c.style.verticalAlign = "middle", c.style.display = "inline-block", c.style.padding = "4px", f.setAttribute("width", u), f.setAttribute("height", u), f.setAttribute("viewBox", "0 0 512 512"), f.setAttribute("xml:space", "preserve"), f.style.padding = "0 1px", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let O in n.elementAttributes)
      O.charAt(0) == "+" ? (O = O.slice(1), c.setAttribute(O, c.getAttribute(O) + n.elementAttributes["+" + O])) : c.setAttribute(O, n.elementAttributes[O]);
  for (var v = 1; v <= l; v++)
    p(v);
  return s = Math.min(parseInt(s), l), d(s), c.addEventListener("mousemove", function(O) {
    d(0);
  }), c.addEventListener("click", function(O) {
    t(0);
  }), o.addEventListener("blur", function(O) {
    i();
  }), o.addEventListener("keydown", function(O) {
    switch (O.keyCode) {
      case 39:
        g(s + 1);
        break;
      case 37:
        g(s - 1);
        break;
      case 13:
        t(s);
        break;
      case 27:
        i();
        break;
    }
  }), c;
}
function HUe(r, e, t, i, n) {
  var a = r.getElement(), o = typeof n.max > "u" ? a.getElementsByTagName("div")[0] && a.getElementsByTagName("div")[0].getAttribute("max") || 100 : n.max, s = typeof n.min > "u" ? a.getElementsByTagName("div")[0] && a.getElementsByTagName("div")[0].getAttribute("min") || 0 : n.min, l = (o - s) / 100, u = r.getValue() || 0, h = document.createElement("div"), c = document.createElement("div"), f, d;
  function p() {
    var g = window.getComputedStyle(a, null), v = l * Math.round(c.offsetWidth / ((a.clientWidth - parseInt(g.getPropertyValue("padding-left")) - parseInt(g.getPropertyValue("padding-right"))) / 100)) + s;
    t(v), a.setAttribute("aria-valuenow", v), a.setAttribute("aria-label", u);
  }
  if (h.style.position = "absolute", h.style.right = "0", h.style.top = "0", h.style.bottom = "0", h.style.width = "5px", h.classList.add("tabulator-progress-handle"), c.style.display = "inline-block", c.style.position = "relative", c.style.height = "100%", c.style.backgroundColor = "#488CE9", c.style.maxWidth = "100%", c.style.minWidth = "0%", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let g in n.elementAttributes)
      g.charAt(0) == "+" ? (g = g.slice(1), c.setAttribute(g, c.getAttribute(g) + n.elementAttributes["+" + g])) : c.setAttribute(g, n.elementAttributes[g]);
  return a.style.padding = "4px 4px", u = Math.min(parseFloat(u), o), u = Math.max(parseFloat(u), s), u = Math.round((u - s) / l), c.style.width = u + "%", a.setAttribute("aria-valuemin", s), a.setAttribute("aria-valuemax", o), c.appendChild(h), h.addEventListener("mousedown", function(g) {
    f = g.screenX, d = c.offsetWidth;
  }), h.addEventListener("mouseover", function() {
    h.style.cursor = "ew-resize";
  }), a.addEventListener("mousemove", function(g) {
    f && (c.style.width = d + g.screenX - f + "px");
  }), a.addEventListener("mouseup", function(g) {
    f && (g.stopPropagation(), g.stopImmediatePropagation(), f = !1, d = !1, p());
  }), a.addEventListener("keydown", function(g) {
    switch (g.keyCode) {
      case 39:
        g.preventDefault(), c.style.width = c.clientWidth + a.clientWidth / 100 + "px";
        break;
      case 37:
        g.preventDefault(), c.style.width = c.clientWidth - a.clientWidth / 100 + "px";
        break;
      case 9:
      case 13:
        p();
        break;
      case 27:
        i();
        break;
    }
  }), a.addEventListener("blur", function() {
    i();
  }), c;
}
function WUe(r, e, t, i, n) {
  var a = r.getValue(), o = document.createElement("input"), s = n.tristate, l = typeof n.indeterminateValue > "u" ? null : n.indeterminateValue, u = !1, h = Object.keys(n).includes("trueValue"), c = Object.keys(n).includes("falseValue");
  if (o.setAttribute("type", "checkbox"), o.style.marginTop = "5px", o.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let d in n.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), o.setAttribute(d, o.getAttribute(d) + n.elementAttributes["+" + d])) : o.setAttribute(d, n.elementAttributes[d]);
  o.value = a, s && (typeof a > "u" || a === l || a === "") && (u = !0, o.indeterminate = !0), this.table.browser != "firefox" && this.table.browser != "safari" && e(function() {
    r.getType() === "cell" && o.focus({ preventScroll: !0 });
  }), o.checked = h ? a === n.trueValue : a === !0 || a === "true" || a === "True" || a === 1;
  function f(d) {
    var p = o.checked;
    return h && p ? p = n.trueValue : c && !p && (p = n.falseValue), s ? d ? u ? l : p : o.checked && !u ? (o.checked = !1, o.indeterminate = !0, u = !0, l) : (u = !1, p) : p;
  }
  return o.addEventListener("change", function(d) {
    t(f());
  }), o.addEventListener("blur", function(d) {
    t(f(!0));
  }), o.addEventListener("keydown", function(d) {
    d.keyCode == 13 && t(f()), d.keyCode == 27 && i();
  }), o;
}
var zUe = {
  input: MUe,
  textarea: kUe,
  number: QUe,
  range: UUe,
  date: $Ue,
  time: GUe,
  datetime: BUe,
  select: VUe,
  list: FUe,
  autocomplete: XUe,
  star: YUe,
  progress: HUe,
  tickCross: WUe
};
class Qf extends pt {
  constructor(e) {
    super(e), this.currentCell = !1, this.mouseClick = !1, this.recursionBlock = !1, this.invalidEdit = !1, this.editedCells = [], this.editors = Qf.editors, this.registerColumnOption("editable"), this.registerColumnOption("editor"), this.registerColumnOption("editorParams"), this.registerColumnOption("cellEditing"), this.registerColumnOption("cellEdited"), this.registerColumnOption("cellEditCancelled"), this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this)), this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this)), this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this)), this.registerTableFunction("navigateNext", this.navigateNext.bind(this)), this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this)), this.registerTableFunction("navigateRight", this.navigateRight.bind(this)), this.registerTableFunction("navigateUp", this.navigateUp.bind(this)), this.registerTableFunction("navigateDown", this.navigateDown.bind(this)), this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this)), this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this)), this.registerComponentFunction("cell", "edit", this.editCell.bind(this)), this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this)), this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this)), this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this)), this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this)), this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this)), this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this)), this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
  }
  initialize() {
    this.subscribe("cell-init", this.bindEditor.bind(this)), this.subscribe("cell-delete", this.clearEdited.bind(this)), this.subscribe("cell-value-changed", this.updateCellClass.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("column-delete", this.columnDeleteCheck.bind(this)), this.subscribe("row-deleting", this.rowDeleteCheck.bind(this)), this.subscribe("row-layout", this.rowEditableCheck.bind(this)), this.subscribe("data-refreshing", this.cancelEdit.bind(this)), this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, void 0)), this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this)), this.subscribe("keybinding-nav-left", this.navigateLeft.bind(this, void 0)), this.subscribe("keybinding-nav-right", this.navigateRight.bind(this, void 0)), this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, void 0)), this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, void 0));
  }
  ///////////////////////////////////
  ////// Keybinding Functions ///////
  ///////////////////////////////////
  keybindingNavigateNext(e) {
    var t = this.currentCell, i = this.options("tabEndNewRow");
    t && (this.navigateNext(t, e) || i && (t.getElement().firstChild.blur(), i === !0 ? i = this.table.addRow({}) : typeof i == "function" ? i = this.table.addRow(i(t.row.getComponent())) : i = this.table.addRow(Object.assign({}, i)), i.then(() => {
      setTimeout(() => {
        t.getComponent().navigateNext();
      });
    })));
  }
  ///////////////////////////////////
  ///////// Cell Functions //////////
  ///////////////////////////////////
  cellIsEdited(e) {
    return !!e.modules.edit && e.modules.edit.edited;
  }
  cellCancelEdit(e) {
    e === this.currentCell ? this.table.modules.edit.cancelEdit() : console.warn("Cancel Editor Error - This cell is not currently being edited ");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  updateCellClass(e) {
    this.allowEdit(e) ? e.getElement().classList.add("tabulator-editable") : e.getElement().classList.remove("tabulator-editable");
  }
  clearCellEdited(e) {
    e || (e = this.table.modules.edit.getEditedCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.table.modules.edit.clearEdited(t._getSelf());
    });
  }
  navigatePrev(e = this.currentCell, t) {
    var i, n;
    if (e) {
      if (t && t.preventDefault(), i = this.navigateLeft(), i)
        return !0;
      if (n = this.table.rowManager.prevDisplayRow(e.row, !0), n && (i = this.findPrevEditableCell(n, n.cells.length), i))
        return i.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateNext(e = this.currentCell, t) {
    var i, n;
    if (e) {
      if (t && t.preventDefault(), i = this.navigateRight(), i)
        return !0;
      if (n = this.table.rowManager.nextDisplayRow(e.row, !0), n && (i = this.findNextEditableCell(n, -1), i))
        return i.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateLeft(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.findPrevEditableCell(e.row, i), n) ? (n.getComponent().edit(), !0) : !1;
  }
  navigateRight(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.findNextEditableCell(e.row, i), n) ? (n.getComponent().edit(), !0) : !1;
  }
  navigateUp(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.table.rowManager.prevDisplayRow(e.row, !0), n) ? (n.cells[i].getComponent().edit(), !0) : !1;
  }
  navigateDown(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.table.rowManager.nextDisplayRow(e.row, !0), n) ? (n.cells[i].getComponent().edit(), !0) : !1;
  }
  findNextEditableCell(e, t) {
    var i = !1;
    if (t < e.cells.length - 1)
      for (var n = t + 1; n < e.cells.length; n++) {
        let a = e.cells[n];
        if (a.column.modules.edit && Wt.elVisible(a.getElement()) && this.allowEdit(a)) {
          i = a;
          break;
        }
      }
    return i;
  }
  findPrevEditableCell(e, t) {
    var i = !1;
    if (t > 0)
      for (var n = t - 1; n >= 0; n--) {
        let a = e.cells[n];
        if (a.column.modules.edit && Wt.elVisible(a.getElement()) && this.allowEdit(a)) {
          i = a;
          break;
        }
      }
    return i;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.editor < "u" && this.initializeColumn(e);
  }
  columnDeleteCheck(e) {
    this.currentCell && this.currentCell.column === e && this.cancelEdit();
  }
  rowDeleteCheck(e) {
    this.currentCell && this.currentCell.row === e && this.cancelEdit();
  }
  rowEditableCheck(e) {
    e.getCells().forEach((t) => {
      t.column.modules.edit && typeof t.column.modules.edit.check == "function" && this.updateCellClass(t);
    });
  }
  //initialize column editor
  initializeColumn(e) {
    var t = {
      editor: !1,
      blocked: !1,
      check: e.definition.editable,
      params: e.definition.editorParams || {}
    };
    switch (typeof e.definition.editor) {
      case "string":
        this.editors[e.definition.editor] ? t.editor = this.editors[e.definition.editor] : console.warn("Editor Error - No such editor found: ", e.definition.editor);
        break;
      case "function":
        t.editor = e.definition.editor;
        break;
      case "boolean":
        e.definition.editor === !0 && (typeof e.definition.formatter != "function" ? this.editors[e.definition.formatter] ? t.editor = this.editors[e.definition.formatter] : t.editor = this.editors.input : console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", e.definition.formatter));
        break;
    }
    t.editor && (e.modules.edit = t);
  }
  getCurrentCell() {
    return this.currentCell ? this.currentCell.getComponent() : !1;
  }
  clearEditor(e) {
    var t = this.currentCell, i;
    if (this.invalidEdit = !1, t) {
      for (this.currentCell = !1, i = t.getElement(), this.dispatch("edit-editor-clear", t, e), i.classList.remove("tabulator-editing"); i.firstChild; )
        i.removeChild(i.firstChild);
      t.row.getElement().classList.remove("tabulator-editing"), t.table.element.classList.remove("tabulator-editing");
    }
  }
  cancelEdit() {
    if (this.currentCell) {
      var e = this.currentCell, t = this.currentCell.getComponent();
      this.clearEditor(!0), e.setValueActual(e.getValue()), e.cellRendered(), (e.column.definition.editor == "textarea" || e.column.definition.variableHeight) && e.row.normalizeHeight(!0), e.column.definition.cellEditCancelled && e.column.definition.cellEditCancelled.call(this.table, t), this.dispatch("edit-cancelled", e), this.dispatchExternal("cellEditCancelled", t);
    }
  }
  //return a formatted value for a cell
  bindEditor(e) {
    if (e.column.modules.edit) {
      var t = this, i = e.getElement(!0);
      this.updateCellClass(e), i.setAttribute("tabindex", 0), i.addEventListener("click", function(n) {
        i.classList.contains("tabulator-editing") || i.focus({ preventScroll: !0 });
      }), i.addEventListener("mousedown", function(n) {
        n.button === 2 ? n.preventDefault() : t.mouseClick = !0;
      }), i.addEventListener("focus", function(n) {
        t.recursionBlock || t.edit(e, n, !1);
      });
    }
  }
  focusCellNoEvent(e, t) {
    this.recursionBlock = !0, t && this.table.browser === "ie" || e.getElement().focus({ preventScroll: !0 }), this.recursionBlock = !1;
  }
  editCell(e, t) {
    this.focusCellNoEvent(e), this.edit(e, !1, t);
  }
  focusScrollAdjust(e) {
    if (this.table.rowManager.getRenderMode() == "virtual") {
      var t = this.table.rowManager.element.scrollTop, i = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop, n = e.row.getElement();
      n.offsetTop < t ? this.table.rowManager.element.scrollTop -= t - n.offsetTop : n.offsetTop + n.offsetHeight > i && (this.table.rowManager.element.scrollTop += n.offsetTop + n.offsetHeight - i);
      var a = this.table.rowManager.element.scrollLeft, o = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft, s = e.getElement();
      this.table.modExists("frozenColumns") && (a += parseInt(this.table.modules.frozenColumns.leftMargin || 0), o -= parseInt(this.table.modules.frozenColumns.rightMargin || 0)), this.table.options.renderHorizontal === "virtual" && (a -= parseInt(this.table.columnManager.renderer.vDomPadLeft), o -= parseInt(this.table.columnManager.renderer.vDomPadLeft)), s.offsetLeft < a ? this.table.rowManager.element.scrollLeft -= a - s.offsetLeft : s.offsetLeft + s.offsetWidth > o && (this.table.rowManager.element.scrollLeft += s.offsetLeft + s.offsetWidth - o);
    }
  }
  allowEdit(e) {
    var t = !!e.column.modules.edit;
    if (e.column.modules.edit)
      switch (typeof e.column.modules.edit.check) {
        case "function":
          e.row.initialized && (t = e.column.modules.edit.check(e.getComponent()));
          break;
        case "string":
          t = !!e.row.data[e.column.modules.edit.check];
          break;
        case "boolean":
          t = e.column.modules.edit.check;
          break;
      }
    return t;
  }
  edit(e, t, i) {
    var n = this, a = !0, o = function() {
    }, s = e.getElement(), l, u, h;
    if (this.currentCell) {
      !this.invalidEdit && this.currentCell !== e && this.cancelEdit();
      return;
    }
    function c(v) {
      if (n.currentCell === e) {
        var O = n.chain("edit-success", [e, v], !0, !0);
        return O === !0 || n.table.options.validationMode === "highlight" ? (n.clearEditor(), e.modules.edit || (e.modules.edit = {}), e.modules.edit.edited = !0, n.editedCells.indexOf(e) == -1 && n.editedCells.push(e), e.setValue(v, !0), O === !0) : (n.invalidEdit = !0, n.focusCellNoEvent(e, !0), o(), !1);
      }
    }
    function f() {
      n.currentCell === e && n.cancelEdit();
    }
    function d(v) {
      o = v;
    }
    if (e.column.modules.edit.blocked)
      return this.mouseClick = !1, s.blur(), !1;
    if (t && t.stopPropagation(), a = this.allowEdit(e), a || i) {
      if (n.cancelEdit(), n.currentCell = e, this.focusScrollAdjust(e), u = e.getComponent(), this.mouseClick && (this.mouseClick = !1, e.column.definition.cellClick && e.column.definition.cellClick.call(this.table, t, u)), e.column.definition.cellEditing && e.column.definition.cellEditing.call(this.table, u), this.dispatch("cell-editing", e), this.dispatchExternal("cellEditing", u), h = typeof e.column.modules.edit.params == "function" ? e.column.modules.edit.params(u) : e.column.modules.edit.params, l = e.column.modules.edit.editor.call(n, u, d, c, f, h), this.currentCell && l !== !1)
        if (l instanceof Node) {
          for (s.classList.add("tabulator-editing"), e.row.getElement().classList.add("tabulator-editing"), e.table.element.classList.add("tabulator-editing"); s.firstChild; )
            s.removeChild(s.firstChild);
          s.appendChild(l), o();
          for (var p = s.children, g = 0; g < p.length; g++)
            p[g].addEventListener("click", function(v) {
              v.stopPropagation();
            });
        } else
          return console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", l), s.blur(), !1;
      else
        return s.blur(), !1;
      return !0;
    } else
      return this.mouseClick = !1, s.blur(), !1;
  }
  getEditedCells() {
    var e = [];
    return this.editedCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearEdited(e) {
    var t;
    e.modules.edit && e.modules.edit.edited && (e.modules.edit.edited = !1, this.dispatch("edit-edited-clear", e)), t = this.editedCells.indexOf(e), t > -1 && this.editedCells.splice(t, 1);
  }
}
Qf.moduleName = "edit";
Qf.editors = zUe;
class qB {
  constructor(e, t, i, n) {
    this.type = e, this.columns = t, this.component = i || !1, this.indent = n || 0;
  }
}
class ZR {
  constructor(e, t, i, n, a) {
    this.value = e, this.component = t || !1, this.width = i, this.height = n, this.depth = a;
  }
}
class xP extends pt {
  constructor(e) {
    super(e), this.config = {}, this.cloneTableStyle = !0, this.colVisProp = "", this.registerTableOption("htmlOutputConfig", !1), this.registerColumnOption("htmlOutput"), this.registerColumnOption("titleHtmlOutput");
  }
  initialize() {
    this.registerTableFunction("getHtml", this.getHtml.bind(this));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  generateExportList(e, t, i, n) {
    this.cloneTableStyle = t, this.config = e || {}, this.colVisProp = n;
    var a = this.config.columnHeaders !== !1 ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [], o = this.bodyToExportRows(this.rowLookup(i));
    return a.concat(o);
  }
  generateTable(e, t, i, n) {
    var a = this.generateExportList(e, t, i, n);
    return this.generateTableElement(a);
  }
  rowLookup(e) {
    var t = [];
    if (typeof e == "function")
      e.call(this.table).forEach((i) => {
        i = this.table.rowManager.findRow(i), i && t.push(i);
      });
    else
      switch (e) {
        case !0:
        case "visible":
          t = this.table.rowManager.getVisibleRows(!1, !0);
          break;
        case "all":
          t = this.table.rowManager.rows;
          break;
        case "selected":
          t = this.table.modules.selectRow.selectedRows;
          break;
        case "active":
        default:
          this.table.options.pagination ? t = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2) : t = this.table.rowManager.getDisplayRows();
      }
    return Object.assign([], t);
  }
  generateColumnGroupHeaders() {
    var e = [], t = this.config.columnGroups !== !1 ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
    return t.forEach((i) => {
      var n = this.processColumnGroup(i);
      n && e.push(n);
    }), e;
  }
  processColumnGroup(e) {
    var t = e.columns, i = 0, n = e.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || e.definition.title, a = {
      title: n,
      column: e,
      depth: 1
    };
    if (t.length) {
      if (a.subGroups = [], a.width = 0, t.forEach((o) => {
        var s = this.processColumnGroup(o);
        s && (a.width += s.width, a.subGroups.push(s), s.depth > i && (i = s.depth));
      }), a.depth += i, !a.width)
        return !1;
    } else if (this.columnVisCheck(e))
      a.width = 1;
    else
      return !1;
    return a;
  }
  columnVisCheck(e) {
    var t = e.definition[this.colVisProp];
    return typeof t == "function" && (t = t.call(this.table, e.getComponent())), t !== !1 && (e.visible || !e.visible && t);
  }
  headersToExportRows(e) {
    var t = [], i = 0, n = [];
    function a(o, s) {
      var l = i - s;
      if (typeof t[s] > "u" && (t[s] = []), o.height = o.subGroups ? 1 : l - o.depth + 1, t[s].push(o), o.height > 1)
        for (let u = 1; u < o.height; u++)
          typeof t[s + u] > "u" && (t[s + u] = []), t[s + u].push(!1);
      if (o.width > 1)
        for (let u = 1; u < o.width; u++)
          t[s].push(!1);
      o.subGroups && o.subGroups.forEach(function(u) {
        a(u, s + 1);
      });
    }
    return e.forEach(function(o) {
      o.depth > i && (i = o.depth);
    }), e.forEach(function(o) {
      a(o, 0);
    }), t.forEach((o) => {
      var s = [];
      o.forEach((l) => {
        if (l) {
          let u = typeof l.title > "u" ? "" : l.title;
          s.push(new ZR(u, l.column.getComponent(), l.width, l.height, l.depth));
        } else
          s.push(null);
      }), n.push(new qB("header", s));
    }), n;
  }
  bodyToExportRows(e) {
    var t = [], i = [];
    return this.table.columnManager.columnsByIndex.forEach((n) => {
      this.columnVisCheck(n) && t.push(n.getComponent());
    }), this.config.columnCalcs !== !1 && this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && e.unshift(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && e.push(this.table.modules.columnCalcs.botRow)), e = e.filter((n) => {
      switch (n.type) {
        case "group":
          return this.config.rowGroups !== !1;
        case "calc":
          return this.config.columnCalcs !== !1;
        case "row":
          return !(this.table.options.dataTree && this.config.dataTree === !1 && n.modules.dataTree.parent);
      }
      return !0;
    }), e.forEach((n, a) => {
      var o = n.getData(this.colVisProp), s = [], l = 0;
      switch (n.type) {
        case "group":
          l = n.level, s.push(new ZR(n.key, n.getComponent(), t.length, 1));
          break;
        case "calc":
        case "row":
          t.forEach((u) => {
            s.push(new ZR(u._column.getFieldValue(o), u, 1, 1));
          }), this.table.options.dataTree && this.config.dataTree !== !1 && (l = n.modules.dataTree.index);
          break;
      }
      i.push(new qB(n.type, s, n.getComponent(), l));
    }), i;
  }
  generateTableElement(e) {
    var t = document.createElement("table"), i = document.createElement("thead"), n = document.createElement("tbody"), a = this.lookupTableStyles(), o = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], s = {};
    return s.rowFormatter = o !== null ? o : this.table.options.rowFormatter, this.table.options.dataTree && this.config.dataTree !== !1 && this.table.modExists("columnCalcs") && (s.treeElementField = this.table.modules.dataTree.elementField), s.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], s.groupHeader && !Array.isArray(s.groupHeader) && (s.groupHeader = [s.groupHeader]), t.classList.add("tabulator-print-table"), this.mapElementStyles(this.table.columnManager.getHeadersElement(), i, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), e.length > 1e3 && console.warn("It may take a long time to render an HTML table with more than 1000 rows"), e.forEach((l, u) => {
      let h;
      switch (l.type) {
        case "header":
          i.appendChild(this.generateHeaderElement(l, s, a));
          break;
        case "group":
          n.appendChild(this.generateGroupElement(l, s, a));
          break;
        case "calc":
          n.appendChild(this.generateCalcElement(l, s, a));
          break;
        case "row":
          h = this.generateRowElement(l, s, a), this.mapElementStyles(u % 2 && a.evenRow ? a.evenRow : a.oddRow, h, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), n.appendChild(h);
          break;
      }
    }), i.innerHTML && t.appendChild(i), t.appendChild(n), this.mapElementStyles(this.table.element, t, ["border-top", "border-left", "border-right", "border-bottom"]), t;
  }
  lookupTableStyles() {
    var e = {};
    return this.cloneTableStyle && window.getComputedStyle && (e.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)"), e.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)"), e.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs"), e.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)"), e.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0], e.firstRow && (e.styleCells = e.firstRow.getElementsByClassName("tabulator-cell"), e.firstCell = e.styleCells[0], e.lastCell = e.styleCells[e.styleCells.length - 1])), e;
  }
  generateHeaderElement(e, t, i) {
    var n = document.createElement("tr");
    return e.columns.forEach((a) => {
      if (a) {
        var o = document.createElement("th"), s = a.component._column.definition.cssClass ? a.component._column.definition.cssClass.split(" ") : [];
        o.colSpan = a.width, o.rowSpan = a.height, o.innerHTML = a.value, this.cloneTableStyle && (o.style.boxSizing = "border-box"), s.forEach(function(l) {
          o.classList.add(l);
        }), this.mapElementStyles(a.component.getElement(), o, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), this.mapElementStyles(a.component._column.contentElement, o, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), a.component._column.visible ? this.mapElementStyles(a.component.getElement(), o, ["width"]) : a.component._column.definition.width && (o.style.width = a.component._column.definition.width + "px"), a.component._column.parent && this.mapElementStyles(a.component._column.parent.groupElement, o, ["border-top"]), n.appendChild(o);
      }
    }), n;
  }
  generateGroupElement(e, t, i) {
    var n = document.createElement("tr"), a = document.createElement("td"), o = e.columns[0];
    return n.classList.add("tabulator-print-table-row"), t.groupHeader && t.groupHeader[e.indent] ? o.value = t.groupHeader[e.indent](o.value, e.component._group.getRowCount(), e.component._group.getData(), e.component) : t.groupHeader !== !1 && (o.value = e.component._group.generator(o.value, e.component._group.getRowCount(), e.component._group.getData(), e.component)), a.colSpan = o.width, a.innerHTML = o.value, n.classList.add("tabulator-print-table-group"), n.classList.add("tabulator-group-level-" + e.indent), o.component.isVisible() && n.classList.add("tabulator-group-visible"), this.mapElementStyles(i.firstGroup, n, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), this.mapElementStyles(i.firstGroup, a, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), n.appendChild(a), n;
  }
  generateCalcElement(e, t, i) {
    var n = this.generateRowElement(e, t, i);
    return n.classList.add("tabulator-print-table-calcs"), this.mapElementStyles(i.calcRow, n, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), n;
  }
  generateRowElement(e, t, i) {
    var n = document.createElement("tr");
    if (n.classList.add("tabulator-print-table-row"), e.columns.forEach((a, o) => {
      if (a) {
        var s = document.createElement("td"), l = a.component._column, u = this.table.columnManager.findColumnIndex(l), h = a.value, c, f = {
          modules: {},
          getValue: function() {
            return h;
          },
          getField: function() {
            return l.definition.field;
          },
          getElement: function() {
            return s;
          },
          getType: function() {
            return "cell";
          },
          getColumn: function() {
            return l.getComponent();
          },
          getData: function() {
            return e.component.getData();
          },
          getRow: function() {
            return e.component;
          },
          getComponent: function() {
            return f;
          },
          column: l
        }, d = l.definition.cssClass ? l.definition.cssClass.split(" ") : [];
        if (d.forEach(function(p) {
          s.classList.add(p);
        }), this.table.modExists("format") && this.config.formatCells !== !1)
          h = this.table.modules.format.formatExportValue(f, this.colVisProp);
        else
          switch (typeof h) {
            case "object":
              h = h !== null ? JSON.stringify(h) : "";
              break;
            case "undefined":
              h = "";
              break;
          }
        h instanceof Node ? s.appendChild(h) : s.innerHTML = h, c = i.styleCells && i.styleCells[u] ? i.styleCells[u] : i.firstCell, c && (this.mapElementStyles(c, s, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"]), l.definition.align && (s.style.textAlign = l.definition.align)), this.table.options.dataTree && this.config.dataTree !== !1 && (t.treeElementField && t.treeElementField == l.field || !t.treeElementField && o == 0) && (e.component._row.modules.dataTree.controlEl && s.insertBefore(e.component._row.modules.dataTree.controlEl.cloneNode(!0), s.firstChild), e.component._row.modules.dataTree.branchEl && s.insertBefore(e.component._row.modules.dataTree.branchEl.cloneNode(!0), s.firstChild)), n.appendChild(s), f.modules.format && f.modules.format.renderedCallback && f.modules.format.renderedCallback();
      }
    }), t.rowFormatter && e.type === "row" && this.config.formatCells !== !1) {
      let a = Object.assign(e.component);
      a.getElement = function() {
        return n;
      }, t.rowFormatter(e.component);
    }
    return n;
  }
  generateHTMLTable(e) {
    var t = document.createElement("div");
    return t.appendChild(this.generateTableElement(e)), t.innerHTML;
  }
  getHtml(e, t, i, n) {
    var a = this.generateExportList(i || this.table.options.htmlOutputConfig, t, e, n || "htmlOutput");
    return this.generateHTMLTable(a);
  }
  mapElementStyles(e, t, i) {
    if (this.cloneTableStyle && e && t) {
      var n = {
        "background-color": "backgroundColor",
        color: "fontColor",
        width: "width",
        "font-weight": "fontWeight",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "text-align": "textAlign",
        "border-top": "borderTop",
        "border-left": "borderLeft",
        "border-right": "borderRight",
        "border-bottom": "borderBottom",
        "padding-top": "paddingTop",
        "padding-left": "paddingLeft",
        "padding-right": "paddingRight",
        "padding-bottom": "paddingBottom"
      };
      if (window.getComputedStyle) {
        var a = window.getComputedStyle(e);
        i.forEach(function(o) {
          t.style[n[o]] || (t.style[n[o]] = a.getPropertyValue(o));
        });
      }
    }
  }
}
xP.moduleName = "export";
var ZUe = {
  //equal to
  "=": function(r, e, t, i) {
    return e == r;
  },
  //less than
  "<": function(r, e, t, i) {
    return e < r;
  },
  //less than or equal to
  "<=": function(r, e, t, i) {
    return e <= r;
  },
  //greater than
  ">": function(r, e, t, i) {
    return e > r;
  },
  //greater than or equal to
  ">=": function(r, e, t, i) {
    return e >= r;
  },
  //not equal to
  "!=": function(r, e, t, i) {
    return e != r;
  },
  regex: function(r, e, t, i) {
    return typeof r == "string" && (r = new RegExp(r)), r.test(e);
  },
  //contains the string
  like: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().indexOf(r.toLowerCase()) > -1 : !1;
  },
  //contains the keywords
  keywords: function(r, e, t, i) {
    var n = r.toLowerCase().split(typeof i.separator > "u" ? " " : i.separator), a = String(e === null || typeof e > "u" ? "" : e).toLowerCase(), o = [];
    return n.forEach((s) => {
      a.includes(s) && o.push(!0);
    }), i.matchAll ? o.length === n.length : !!o.length;
  },
  //starts with the string
  starts: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().startsWith(r.toLowerCase()) : !1;
  },
  //ends with the string
  ends: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().endsWith(r.toLowerCase()) : !1;
  },
  //in array
  in: function(r, e, t, i) {
    return Array.isArray(r) ? r.length ? r.indexOf(e) > -1 : !0 : (console.warn("Filter Error - filter value is not an array:", r), !1);
  }
};
class Xa extends pt {
  constructor(e) {
    super(e), this.filterList = [], this.headerFilters = {}, this.headerFilterColumns = [], this.prevHeaderFilterChangeCheck = "", this.prevHeaderFilterChangeCheck = "{}", this.changed = !1, this.tableInitialized = !1, this.registerTableOption("filterMode", "local"), this.registerTableOption("initialFilter", !1), this.registerTableOption("initialHeaderFilter", !1), this.registerTableOption("headerFilterLiveFilterDelay", 300), this.registerTableOption("placeholderHeaderFilter", !1), this.registerColumnOption("headerFilter"), this.registerColumnOption("headerFilterPlaceholder"), this.registerColumnOption("headerFilterParams"), this.registerColumnOption("headerFilterEmptyCheck"), this.registerColumnOption("headerFilterFunc"), this.registerColumnOption("headerFilterFuncParams"), this.registerColumnOption("headerFilterLiveFilter"), this.registerTableFunction("searchRows", this.searchRows.bind(this)), this.registerTableFunction("searchData", this.searchData.bind(this)), this.registerTableFunction("setFilter", this.userSetFilter.bind(this)), this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this)), this.registerTableFunction("addFilter", this.userAddFilter.bind(this)), this.registerTableFunction("getFilters", this.getFilters.bind(this)), this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this)), this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this)), this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this)), this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this)), this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this)), this.registerTableFunction("clearFilter", this.userClearFilter.bind(this)), this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this)), this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this)), this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this)), this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this)), this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
  }
  initialize() {
    this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this)), this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this)), this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.subscribe("placeholder", this.generatePlaceholder.bind(this)), this.table.options.filterMode === "remote" && this.subscribe("data-params", this.remoteFilterParams.bind(this)), this.registerDataHandler(this.filter.bind(this), 10);
  }
  tableBuilt() {
    this.table.options.initialFilter && this.setFilter(this.table.options.initialFilter), this.table.options.initialHeaderFilter && this.table.options.initialHeaderFilter.forEach((e) => {
      var t = this.table.columnManager.findColumn(e.field);
      if (t)
        this.setHeaderFilterValue(t, e.value);
      else
        return console.warn("Column Filter Error - No matching column found:", e.field), !1;
    }), this.tableInitialized = !0;
  }
  remoteFilterParams(e, t, i, n) {
    return n.filter = this.getFilters(!0, !0), n;
  }
  generatePlaceholder(e) {
    if (this.table.options.placeholderHeaderFilter && Object.keys(this.headerFilters).length)
      return this.table.options.placeholderHeaderFilter;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  //set standard filters
  userSetFilter(e, t, i, n) {
    this.setFilter(e, t, i, n), this.refreshFilter();
  }
  //set standard filters
  userRefreshFilter() {
    this.refreshFilter();
  }
  //add filter to array
  userAddFilter(e, t, i, n) {
    this.addFilter(e, t, i, n), this.refreshFilter();
  }
  userSetHeaderFilterFocus(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      this.setHeaderFilterFocus(t);
    else
      return console.warn("Column Filter Focus Error - No matching column found:", e), !1;
  }
  userGetHeaderFilterValue(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      return this.getHeaderFilterValue(t);
    console.warn("Column Filter Error - No matching column found:", e);
  }
  userSetHeaderFilterValue(e, t) {
    var i = this.table.columnManager.findColumn(e);
    if (i)
      this.setHeaderFilterValue(i, t);
    else
      return console.warn("Column Filter Error - No matching column found:", e), !1;
  }
  //remove filter from array
  userRemoveFilter(e, t, i) {
    this.removeFilter(e, t, i), this.refreshFilter();
  }
  //clear filters
  userClearFilter(e) {
    this.clearFilter(e), this.refreshFilter();
  }
  //clear header filters
  userClearHeaderFilter() {
    this.clearHeaderFilter(), this.refreshFilter();
  }
  //search for specific row components
  searchRows(e, t, i) {
    return this.search("rows", e, t, i);
  }
  //search for specific data
  searchData(e, t, i) {
    return this.search("data", e, t, i);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnHeaderFilter(e) {
    var t = e.definition;
    t.headerFilter && this.initializeColumn(e);
  }
  //initialize column header filter
  initializeColumn(e, t) {
    var i = this, n = e.getField();
    function a(o) {
      var s = e.modules.filter.tagType == "input" && e.modules.filter.attrType == "text" || e.modules.filter.tagType == "textarea" ? "partial" : "match", l = "", u = "", h;
      if (typeof e.modules.filter.prevSuccess > "u" || e.modules.filter.prevSuccess !== o) {
        if (e.modules.filter.prevSuccess = o, e.modules.filter.emptyFunc(o))
          delete i.headerFilters[n];
        else {
          switch (e.modules.filter.value = o, typeof e.definition.headerFilterFunc) {
            case "string":
              Xa.filters[e.definition.headerFilterFunc] ? (l = e.definition.headerFilterFunc, h = function(c) {
                var f = e.definition.headerFilterFuncParams || {}, d = e.getFieldValue(c);
                return f = typeof f == "function" ? f(o, d, c) : f, Xa.filters[e.definition.headerFilterFunc](o, d, c, f);
              }) : console.warn("Header Filter Error - Matching filter function not found: ", e.definition.headerFilterFunc);
              break;
            case "function":
              h = function(c) {
                var f = e.definition.headerFilterFuncParams || {}, d = e.getFieldValue(c);
                return f = typeof f == "function" ? f(o, d, c) : f, e.definition.headerFilterFunc(o, d, c, f);
              }, l = h;
              break;
          }
          if (!h)
            switch (s) {
              case "partial":
                h = function(c) {
                  var f = e.getFieldValue(c);
                  return typeof f < "u" && f !== null ? String(f).toLowerCase().indexOf(String(o).toLowerCase()) > -1 : !1;
                }, l = "like";
                break;
              default:
                h = function(c) {
                  return e.getFieldValue(c) == o;
                }, l = "=";
            }
          i.headerFilters[n] = { value: o, func: h, type: l };
        }
        e.modules.filter.value = o, u = JSON.stringify(i.headerFilters), i.prevHeaderFilterChangeCheck !== u && (i.prevHeaderFilterChangeCheck = u, i.trackChanges(), i.refreshFilter());
      }
      return !0;
    }
    e.modules.filter = {
      success: a,
      attrType: !1,
      tagType: !1,
      emptyFunc: !1
    }, this.generateHeaderFilterElement(e);
  }
  generateHeaderFilterElement(e, t, i) {
    var n = this, a = e.modules.filter.success, o = e.getField(), s, l, u, h, c, f, d, p;
    e.modules.filter.value = t;
    function g() {
    }
    function v(O) {
      p = O;
    }
    if (e.modules.filter.headerElement && e.modules.filter.headerElement.parentNode && e.contentElement.removeChild(e.modules.filter.headerElement.parentNode), o) {
      switch (e.modules.filter.emptyFunc = e.definition.headerFilterEmptyCheck || function(O) {
        return !O && O !== 0;
      }, s = document.createElement("div"), s.classList.add("tabulator-header-filter"), typeof e.definition.headerFilter) {
        case "string":
          n.table.modules.edit.editors[e.definition.headerFilter] ? (l = n.table.modules.edit.editors[e.definition.headerFilter], (e.definition.headerFilter === "tick" || e.definition.headerFilter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(O) {
            return O !== !0 && O !== !1;
          })) : console.warn("Filter Error - Cannot build header filter, No such editor found: ", e.definition.editor);
          break;
        case "function":
          l = e.definition.headerFilter;
          break;
        case "boolean":
          e.modules.edit && e.modules.edit.editor ? l = e.modules.edit.editor : e.definition.formatter && n.table.modules.edit.editors[e.definition.formatter] ? (l = n.table.modules.edit.editors[e.definition.formatter], (e.definition.formatter === "tick" || e.definition.formatter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(O) {
            return O !== !0 && O !== !1;
          })) : l = n.table.modules.edit.editors.input;
          break;
      }
      if (l) {
        if (h = {
          getValue: function() {
            return typeof t < "u" ? t : "";
          },
          getField: function() {
            return e.definition.field;
          },
          getElement: function() {
            return s;
          },
          getColumn: function() {
            return e.getComponent();
          },
          getTable: () => this.table,
          getType: () => "header",
          getRow: function() {
            return {
              normalizeHeight: function() {
              }
            };
          }
        }, d = e.definition.headerFilterParams || {}, d = typeof d == "function" ? d.call(n.table, h) : d, u = l.call(this.table.modules.edit, h, v, a, g, d), !u) {
          console.warn("Filter Error - Cannot add filter to " + o + " column, editor returned a value of false");
          return;
        }
        if (!(u instanceof Node)) {
          console.warn("Filter Error - Cannot add filter to " + o + " column, editor should return an instance of Node, the editor returned:", u);
          return;
        }
        n.langBind("headerFilters|columns|" + e.definition.field, function(O) {
          u.setAttribute("placeholder", typeof O < "u" && O ? O : e.definition.headerFilterPlaceholder || n.langText("headerFilters|default"));
        }), u.addEventListener("click", function(O) {
          O.stopPropagation(), u.focus();
        }), u.addEventListener("focus", (O) => {
          var m = this.table.columnManager.contentsElement.scrollLeft, E = this.table.rowManager.element.scrollLeft;
          m !== E && (this.table.rowManager.scrollHorizontal(m), this.table.columnManager.scrollHorizontal(m));
        }), c = !1, f = function(O) {
          c && clearTimeout(c), c = setTimeout(function() {
            a(u.value);
          }, n.table.options.headerFilterLiveFilterDelay);
        }, e.modules.filter.headerElement = u, e.modules.filter.attrType = u.hasAttribute("type") ? u.getAttribute("type").toLowerCase() : "", e.modules.filter.tagType = u.tagName.toLowerCase(), e.definition.headerFilterLiveFilter !== !1 && (e.definition.headerFilter === "autocomplete" || e.definition.headerFilter === "tickCross" || (e.definition.editor === "autocomplete" || e.definition.editor === "tickCross") && e.definition.headerFilter === !0 || (u.addEventListener("keyup", f), u.addEventListener("search", f), e.modules.filter.attrType == "number" && u.addEventListener("change", function(O) {
          a(u.value);
        }), e.modules.filter.attrType == "text" && this.table.browser !== "ie" && u.setAttribute("type", "search")), (e.modules.filter.tagType == "input" || e.modules.filter.tagType == "select" || e.modules.filter.tagType == "textarea") && u.addEventListener("mousedown", function(O) {
          O.stopPropagation();
        })), s.appendChild(u), e.contentElement.appendChild(s), i || n.headerFilterColumns.push(e), p && p();
      }
    } else
      console.warn("Filter Error - Cannot add header filter, column has no field set:", e.definition.title);
  }
  //hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  hideHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "none");
    });
  }
  //show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  showHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "");
    });
  }
  //programmatically set focus of header filter
  setHeaderFilterFocus(e) {
    e.modules.filter && e.modules.filter.headerElement ? e.modules.filter.headerElement.focus() : console.warn("Column Filter Focus Error - No header filter set on column:", e.getField());
  }
  //programmatically get value of header filter
  getHeaderFilterValue(e) {
    if (e.modules.filter && e.modules.filter.headerElement)
      return e.modules.filter.value;
    console.warn("Column Filter Error - No header filter set on column:", e.getField());
  }
  //programmatically set value of header filter
  setHeaderFilterValue(e, t) {
    e && (e.modules.filter && e.modules.filter.headerElement ? (this.generateHeaderFilterElement(e, t, !0), e.modules.filter.success(t)) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  reloadHeaderFilter(e) {
    e && (e.modules.filter && e.modules.filter.headerElement ? this.generateHeaderFilterElement(e, e.modules.filter.value, !0) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  refreshFilter() {
    this.tableInitialized && (this.table.options.filterMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0));
  }
  //check if the filters has changed since last use
  trackChanges() {
    this.changed = !0, this.dispatch("filter-changed");
  }
  //check if the filters has changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //set standard filters
  setFilter(e, t, i, n) {
    this.filterList = [], Array.isArray(e) || (e = [{ field: e, type: t, value: i, params: n }]), this.addFilter(e);
  }
  //add filter to array
  addFilter(e, t, i, n) {
    var a = !1;
    Array.isArray(e) || (e = [{ field: e, type: t, value: i, params: n }]), e.forEach((o) => {
      o = this.findFilter(o), o && (this.filterList.push(o), a = !0);
    }), a && this.trackChanges();
  }
  findFilter(e) {
    var t;
    if (Array.isArray(e))
      return this.findSubFilters(e);
    var i = !1;
    return typeof e.field == "function" ? i = function(n) {
      return e.field(n, e.type || {});
    } : Xa.filters[e.type] ? (t = this.table.columnManager.getColumnByField(e.field), t ? i = function(n) {
      return Xa.filters[e.type](e.value, t.getFieldValue(n), n, e.params || {});
    } : i = function(n) {
      return Xa.filters[e.type](e.value, n[e.field], n, e.params || {});
    }) : console.warn("Filter Error - No such filter type found, ignoring: ", e.type), e.func = i, e.func ? e : !1;
  }
  findSubFilters(e) {
    var t = [];
    return e.forEach((i) => {
      i = this.findFilter(i), i && t.push(i);
    }), t.length ? t : !1;
  }
  //get all filters
  getFilters(e, t) {
    var i = [];
    return e && (i = this.getHeaderFilters()), t && i.forEach(function(n) {
      typeof n.type == "function" && (n.type = "function");
    }), i = i.concat(this.filtersToArray(this.filterList, t)), i;
  }
  //filter to Object
  filtersToArray(e, t) {
    var i = [];
    return e.forEach((n) => {
      var a;
      Array.isArray(n) ? i.push(this.filtersToArray(n, t)) : (a = { field: n.field, type: n.type, value: n.value }, t && typeof a.type == "function" && (a.type = "function"), i.push(a));
    }), i;
  }
  //get all filters
  getHeaderFilters() {
    var e = [];
    for (var t in this.headerFilters)
      e.push({ field: t, type: this.headerFilters[t].type, value: this.headerFilters[t].value });
    return e;
  }
  //remove filter from array
  removeFilter(e, t, i) {
    Array.isArray(e) || (e = [{ field: e, type: t, value: i }]), e.forEach((n) => {
      var a = -1;
      typeof n.field == "object" ? a = this.filterList.findIndex((o) => n === o) : a = this.filterList.findIndex((o) => n.field === o.field && n.type === o.type && n.value === o.value), a > -1 ? this.filterList.splice(a, 1) : console.warn("Filter Error - No matching filter type found, ignoring: ", n.type);
    }), this.trackChanges();
  }
  //clear filters
  clearFilter(e) {
    this.filterList = [], e && this.clearHeaderFilter(), this.trackChanges();
  }
  //clear header filters
  clearHeaderFilter() {
    this.headerFilters = {}, this.prevHeaderFilterChangeCheck = "{}", this.headerFilterColumns.forEach((e) => {
      typeof e.modules.filter.value < "u" && delete e.modules.filter.value, e.modules.filter.prevSuccess = void 0, this.reloadHeaderFilter(e);
    }), this.trackChanges();
  }
  //search data and return matching rows
  search(e, t, i, n) {
    var a = [], o = [];
    return Array.isArray(t) || (t = [{ field: t, type: i, value: n }]), t.forEach((s) => {
      s = this.findFilter(s), s && o.push(s);
    }), this.table.rowManager.rows.forEach((s) => {
      var l = !0;
      o.forEach((u) => {
        this.filterRecurse(u, s.getData()) || (l = !1);
      }), l && a.push(e === "data" ? s.getData("data") : s.getComponent());
    }), a;
  }
  //filter row array
  filter(e, t) {
    var i = [], n = [];
    return this.subscribedExternal("dataFiltering") && this.dispatchExternal("dataFiltering", this.getFilters(!0)), this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length) ? e.forEach((a) => {
      this.filterRow(a) && i.push(a);
    }) : i = e.slice(0), this.subscribedExternal("dataFiltered") && (i.forEach((a) => {
      n.push(a.getComponent());
    }), this.dispatchExternal("dataFiltered", this.getFilters(!0), n)), i;
  }
  //filter individual row
  filterRow(e, t) {
    var i = !0, n = e.getData();
    this.filterList.forEach((o) => {
      this.filterRecurse(o, n) || (i = !1);
    });
    for (var a in this.headerFilters)
      this.headerFilters[a].func(n) || (i = !1);
    return i;
  }
  filterRecurse(e, t) {
    var i = !1;
    return Array.isArray(e) ? e.forEach((n) => {
      this.filterRecurse(n, t) && (i = !0);
    }) : i = e.func(t), i;
  }
}
Xa.moduleName = "filter";
Xa.filters = ZUe;
function qUe(r, e, t) {
  return this.emptyToSpace(this.sanitizeHTML(r.getValue()));
}
function jUe(r, e, t) {
  return r.getValue();
}
function KUe(r, e, t) {
  return r.getElement().style.whiteSpace = "pre-wrap", this.emptyToSpace(this.sanitizeHTML(r.getValue()));
}
function JUe(r, e, t) {
  var i = parseFloat(r.getValue()), n = "", a, o, s, l, u, h = e.decimal || ".", c = e.thousand || ",", f = e.negativeSign || "-", d = e.symbol || "", p = !!e.symbolAfter, g = typeof e.precision < "u" ? e.precision : 2;
  if (isNaN(i))
    return this.emptyToSpace(this.sanitizeHTML(r.getValue()));
  if (i < 0 && (i = Math.abs(i), n = f), a = g !== !1 ? i.toFixed(g) : i, a = String(a).split("."), o = a[0], s = a.length > 1 ? h + a[1] : "", e.thousand !== !1)
    for (l = /(\d+)(\d{3})/; l.test(o); )
      o = o.replace(l, "$1" + c + "$2");
  return u = o + s, n === !0 ? (u = "(" + u + ")", p ? u + d : d + u) : p ? n + u + d : n + d + u;
}
function e$e(r, e, t) {
  var i = r.getValue(), n = e.urlPrefix || "", a = e.download, o = i, s = document.createElement("a"), l;
  function u(h, c) {
    var f = h.shift(), d = c[f];
    return h.length && typeof d == "object" ? u(h, d) : d;
  }
  if (e.labelField && (l = r.getData(), o = u(e.labelField.split(this.table.options.nestedFieldSeparator), l)), e.label)
    switch (typeof e.label) {
      case "string":
        o = e.label;
        break;
      case "function":
        o = e.label(r);
        break;
    }
  if (o) {
    if (e.urlField && (l = r.getData(), i = l[e.urlField]), e.url)
      switch (typeof e.url) {
        case "string":
          i = e.url;
          break;
        case "function":
          i = e.url(r);
          break;
      }
    return s.setAttribute("href", n + i), e.target && s.setAttribute("target", e.target), e.download && (typeof a == "function" ? a = a(r) : a = a === !0 ? "" : a, s.setAttribute("download", a)), s.innerHTML = this.emptyToSpace(this.sanitizeHTML(o)), s;
  } else
    return "&nbsp;";
}
function t$e(r, e, t) {
  var i = document.createElement("img"), n = r.getValue();
  switch (e.urlPrefix && (n = e.urlPrefix + r.getValue()), e.urlSuffix && (n = n + e.urlSuffix), i.setAttribute("src", n), typeof e.height) {
    case "number":
      i.style.height = e.height + "px";
      break;
    case "string":
      i.style.height = e.height;
      break;
  }
  switch (typeof e.width) {
    case "number":
      i.style.width = e.width + "px";
      break;
    case "string":
      i.style.width = e.width;
      break;
  }
  return i.addEventListener("load", function() {
    r.getRow().normalizeHeight();
  }), i;
}
function r$e(r, e, t) {
  var i = r.getValue(), n = r.getElement(), a = e.allowEmpty, o = e.allowTruthy, s = Object.keys(e).includes("trueValue"), l = typeof e.tickElement < "u" ? e.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>', u = typeof e.crossElement < "u" ? e.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
  return s && i === e.trueValue || !s && (o && i || i === !0 || i === "true" || i === "True" || i === 1 || i === "1") ? (n.setAttribute("aria-checked", !0), l || "") : a && (i === "null" || i === "" || i === null || typeof i > "u") ? (n.setAttribute("aria-checked", "mixed"), "") : (n.setAttribute("aria-checked", !1), u || "");
}
function i$e(r, e, t) {
  var i = window.DateTime || luxon.DateTime, n = e.inputFormat || "yyyy-MM-dd HH:mm:ss", a = e.outputFormat || "dd/MM/yyyy HH:mm:ss", o = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", s = r.getValue();
  if (typeof i < "u") {
    var l;
    return i.isDateTime(s) ? l = s : n === "iso" ? l = i.fromISO(String(s)) : l = i.fromFormat(String(s), n), l.isValid ? (e.timezone && (l = l.setZone(e.timezone)), l.toFormat(a)) : o === !0 || !s ? s : typeof o == "function" ? o(s) : o;
  } else
    console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
}
function n$e(r, e, t) {
  var i = window.DateTime || luxon.DateTime, n = e.inputFormat || "yyyy-MM-dd HH:mm:ss", a = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", o = typeof e.suffix < "u" ? e.suffix : !1, s = typeof e.unit < "u" ? e.unit : "days", l = typeof e.humanize < "u" ? e.humanize : !1, u = typeof e.date < "u" ? e.date : i.now(), h = r.getValue();
  if (typeof i < "u") {
    var c;
    return i.isDateTime(h) ? c = h : n === "iso" ? c = i.fromISO(String(h)) : c = i.fromFormat(String(h), n), c.isValid ? l ? c.diff(u, s).toHuman() + (o ? " " + o : "") : parseInt(c.diff(u, s)[s]) + (o ? " " + o : "") : a === !0 ? h : typeof a == "function" ? a(h) : a;
  } else
    console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
}
function a$e(r, e, t) {
  var i = r.getValue();
  return typeof e[i] > "u" ? (console.warn("Missing display value for " + i), i) : e[i];
}
function o$e(r, e, t) {
  var i = r.getValue(), n = r.getElement(), a = e && e.stars ? e.stars : 5, o = document.createElement("span"), s = document.createElementNS("http://www.w3.org/2000/svg", "svg"), l = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>', u = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
  o.style.verticalAlign = "middle", s.setAttribute("width", "14"), s.setAttribute("height", "14"), s.setAttribute("viewBox", "0 0 512 512"), s.setAttribute("xml:space", "preserve"), s.style.padding = "0 1px", i = i && !isNaN(i) ? parseInt(i) : 0, i = Math.max(0, Math.min(i, a));
  for (var h = 1; h <= a; h++) {
    var c = s.cloneNode(!0);
    c.innerHTML = h <= i ? l : u, o.appendChild(c);
  }
  return n.style.whiteSpace = "nowrap", n.style.overflow = "hidden", n.style.textOverflow = "ellipsis", n.setAttribute("aria-label", i), o;
}
function s$e(r, e, t) {
  var i = this.sanitizeHTML(r.getValue()) || 0, n = document.createElement("span"), a = e && e.max ? e.max : 100, o = e && e.min ? e.min : 0, s = e && typeof e.color < "u" ? e.color : ["red", "orange", "green"], l = "#666666", u, h;
  if (!(isNaN(i) || typeof r.getValue() > "u")) {
    switch (n.classList.add("tabulator-traffic-light"), h = parseFloat(i) <= a ? parseFloat(i) : a, h = parseFloat(h) >= o ? parseFloat(h) : o, u = (a - o) / 100, h = Math.round((h - o) / u), typeof s) {
      case "string":
        l = s;
        break;
      case "function":
        l = s(i);
        break;
      case "object":
        if (Array.isArray(s)) {
          var c = 100 / s.length, f = Math.floor(h / c);
          f = Math.min(f, s.length - 1), f = Math.max(f, 0), l = s[f];
          break;
        }
    }
    return n.style.backgroundColor = l, n;
  }
}
function l$e(r, e = {}, t) {
  var i = this.sanitizeHTML(r.getValue()) || 0, n = r.getElement(), a = e.max ? e.max : 100, o = e.min ? e.min : 0, s = e.legendAlign ? e.legendAlign : "center", l, u, h, c, f;
  switch (u = parseFloat(i) <= a ? parseFloat(i) : a, u = parseFloat(u) >= o ? parseFloat(u) : o, l = (a - o) / 100, u = Math.round((u - o) / l), typeof e.color) {
    case "string":
      h = e.color;
      break;
    case "function":
      h = e.color(i);
      break;
    case "object":
      if (Array.isArray(e.color)) {
        let v = 100 / e.color.length, O = Math.floor(u / v);
        O = Math.min(O, e.color.length - 1), O = Math.max(O, 0), h = e.color[O];
        break;
      }
    default:
      h = "#2DC214";
  }
  switch (typeof e.legend) {
    case "string":
      c = e.legend;
      break;
    case "function":
      c = e.legend(i);
      break;
    case "boolean":
      c = i;
      break;
    default:
      c = !1;
  }
  switch (typeof e.legendColor) {
    case "string":
      f = e.legendColor;
      break;
    case "function":
      f = e.legendColor(i);
      break;
    case "object":
      if (Array.isArray(e.legendColor)) {
        let v = 100 / e.legendColor.length, O = Math.floor(u / v);
        O = Math.min(O, e.legendColor.length - 1), O = Math.max(O, 0), f = e.legendColor[O];
      }
      break;
    default:
      f = "#000";
  }
  n.style.minWidth = "30px", n.style.position = "relative", n.setAttribute("aria-label", u);
  var d = document.createElement("div");
  d.style.display = "inline-block", d.style.width = u + "%", d.style.backgroundColor = h, d.style.height = "100%", d.setAttribute("data-max", a), d.setAttribute("data-min", o);
  var p = document.createElement("div");
  if (p.style.position = "relative", p.style.width = "100%", p.style.height = "100%", c) {
    var g = document.createElement("div");
    g.style.position = "absolute", g.style.top = 0, g.style.left = 0, g.style.textAlign = s, g.style.width = "100%", g.style.color = f, g.innerHTML = c;
  }
  return t(function() {
    if (!(r instanceof c8)) {
      var v = document.createElement("div");
      v.style.position = "absolute", v.style.top = "4px", v.style.bottom = "4px", v.style.left = "4px", v.style.right = "4px", n.appendChild(v), n = v;
    }
    n.appendChild(p), p.appendChild(d), c && p.appendChild(g);
  }), "";
}
function u$e(r, e, t) {
  return r.getElement().style.backgroundColor = this.sanitizeHTML(r.getValue()), "";
}
function h$e(r, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}
function c$e(r, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}
function f$e(r, e, t) {
  var i = document.createElement("span"), n = r.getRow();
  return n.watchPosition((a) => {
    i.innerText = a;
  }), i;
}
function d$e(r, e, t) {
  return r.getElement().classList.add("tabulator-row-handle"), "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}
function p$e(r, e, t) {
  var i = document.createElement("div"), n = r.getRow()._row.modules.responsiveLayout;
  i.classList.add("tabulator-responsive-collapse-toggle"), i.innerHTML = `<svg class='tabulator-responsive-collapse-toggle-open' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12" fill="none" stroke-width="3" stroke-linecap="round" />
  <line y1="7" x1="12" y2="17" x2="12" fill="none" stroke-width="3" stroke-linecap="round" />
</svg>

<svg class='tabulator-responsive-collapse-toggle-close' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12"  fill="none" stroke-width="3" stroke-linecap="round" />
</svg>`, r.getElement().classList.add("tabulator-row-handle");
  function a(o) {
    var s = n.element;
    n.open = o, s && (n.open ? (i.classList.add("open"), s.style.display = "") : (i.classList.remove("open"), s.style.display = "none"));
  }
  return i.addEventListener("click", function(o) {
    o.stopImmediatePropagation(), a(!n.open), r.getTable().rowManager.adjustTableSize();
  }), a(n.open), i;
}
function g$e(r, e, t) {
  var i = document.createElement("input"), n = !1;
  if (i.type = "checkbox", i.setAttribute("aria-label", "Select Row"), this.table.modExists("selectRow", !0))
    if (i.addEventListener("click", (o) => {
      o.stopPropagation();
    }), typeof r.getRow == "function") {
      var a = r.getRow();
      a instanceof yT ? (i.addEventListener("change", (o) => {
        this.table.options.selectableRangeMode === "click" && n ? n = !1 : a.toggleSelect();
      }), this.table.options.selectableRangeMode === "click" && i.addEventListener("click", (o) => {
        n = !0, this.table.modules.selectRow.handleComplexRowClick(a._row, o);
      }), i.checked = a.isSelected && a.isSelected(), this.table.modules.selectRow.registerRowSelectCheckbox(a, i)) : i = "";
    } else
      i.addEventListener("change", (o) => {
        this.table.modules.selectRow.selectedRows.length ? this.table.deselectRow() : this.table.selectRow(e.rowRange);
      }), this.table.modules.selectRow.registerHeaderSelectCheckbox(i);
  return i;
}
var v$e = {
  plaintext: qUe,
  html: jUe,
  textarea: KUe,
  money: JUe,
  link: e$e,
  image: t$e,
  tickCross: r$e,
  datetime: i$e,
  datetimediff: n$e,
  lookup: a$e,
  star: o$e,
  traffic: s$e,
  progress: l$e,
  color: u$e,
  buttonTick: h$e,
  buttonCross: c$e,
  rownum: f$e,
  handle: d$e,
  responsiveCollapse: p$e,
  rowSelection: g$e
};
class rn extends pt {
  constructor(e) {
    super(e), this.registerColumnOption("formatter"), this.registerColumnOption("formatterParams"), this.registerColumnOption("formatterPrint"), this.registerColumnOption("formatterPrintParams"), this.registerColumnOption("formatterClipboard"), this.registerColumnOption("formatterClipboardParams"), this.registerColumnOption("formatterHtmlOutput"), this.registerColumnOption("formatterHtmlOutputParams"), this.registerColumnOption("titleFormatter"), this.registerColumnOption("titleFormatterParams");
  }
  initialize() {
    this.subscribe("cell-format", this.formatValue.bind(this)), this.subscribe("cell-rendered", this.cellRendered.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-format", this.formatHeader.bind(this));
  }
  //initialize column formatter
  initializeColumn(e) {
    e.modules.format = this.lookupFormatter(e, ""), typeof e.definition.formatterPrint < "u" && (e.modules.format.print = this.lookupFormatter(e, "Print")), typeof e.definition.formatterClipboard < "u" && (e.modules.format.clipboard = this.lookupFormatter(e, "Clipboard")), typeof e.definition.formatterHtmlOutput < "u" && (e.modules.format.htmlOutput = this.lookupFormatter(e, "HtmlOutput"));
  }
  lookupFormatter(e, t) {
    var i = { params: e.definition["formatter" + t + "Params"] || {} }, n = e.definition["formatter" + t];
    switch (typeof n) {
      case "string":
        rn.formatters[n] ? i.formatter = rn.formatters[n] : (console.warn("Formatter Error - No such formatter found: ", n), i.formatter = rn.formatters.plaintext);
        break;
      case "function":
        i.formatter = n;
        break;
      default:
        i.formatter = rn.formatters.plaintext;
        break;
    }
    return i;
  }
  cellRendered(e) {
    e.modules.format && e.modules.format.renderedCallback && !e.modules.format.rendered && (e.modules.format.renderedCallback(), e.modules.format.rendered = !0);
  }
  //return a formatted value for a column header
  formatHeader(e, t, i) {
    var n, a, o, s;
    return e.definition.titleFormatter ? (n = this.getFormatter(e.definition.titleFormatter), o = (l) => {
      e.titleFormatterRendered = l;
    }, s = {
      getValue: function() {
        return t;
      },
      getElement: function() {
        return i;
      },
      getType: function() {
        return "header";
      },
      getColumn: function() {
        return e.getComponent();
      },
      getTable: () => this.table
    }, a = e.definition.titleFormatterParams || {}, a = typeof a == "function" ? a() : a, n.call(this, s, a, o)) : t;
  }
  //return a formatted value for a cell
  formatValue(e) {
    var t = e.getComponent(), i = typeof e.column.modules.format.params == "function" ? e.column.modules.format.params(t) : e.column.modules.format.params;
    function n(a) {
      e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = a, e.modules.format.rendered = !1;
    }
    return e.column.modules.format.formatter.call(this, t, i, n);
  }
  formatExportValue(e, t) {
    var i = e.column.modules.format[t], n;
    if (i) {
      let o = function(s) {
        e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = s, e.modules.format.rendered = !1;
      };
      var a = o;
      return n = typeof i.params == "function" ? i.params(e.getComponent()) : i.params, i.formatter.call(this, e.getComponent(), n, o);
    } else
      return this.formatValue(e);
  }
  sanitizeHTML(e) {
    if (e) {
      var t = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      return String(e).replace(/[&<>"'`=/]/g, function(i) {
        return t[i];
      });
    } else
      return e;
  }
  emptyToSpace(e) {
    return e === null || typeof e > "u" || e === "" ? "&nbsp;" : e;
  }
  //get formatter for cell
  getFormatter(e) {
    switch (typeof e) {
      case "string":
        rn.formatters[e] ? e = rn.formatters[e] : (console.warn("Formatter Error - No such formatter found: ", e), e = rn.formatters.plaintext);
        break;
      case "function":
        break;
      default:
        e = rn.formatters.plaintext;
        break;
    }
    return e;
  }
}
rn.moduleName = "format";
rn.formatters = v$e;
class wP extends pt {
  constructor(e) {
    super(e), this.leftColumns = [], this.rightColumns = [], this.initializationMode = "left", this.active = !1, this.blocked = !0, this.registerColumnOption("frozen");
  }
  //reset initial state
  reset() {
    this.initializationMode = "left", this.leftColumns = [], this.rightColumns = [], this.active = !1;
  }
  initialize() {
    this.subscribe("cell-layout", this.layoutCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-width", this.layout.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("table-layout", this.layout.bind(this)), this.subscribe("columns-loading", this.reset.bind(this)), this.subscribe("column-add", this.reinitializeColumns.bind(this)), this.subscribe("column-delete", this.reinitializeColumns.bind(this)), this.subscribe("table-redraw", this.layout.bind(this)), this.subscribe("layout-refreshing", this.blockLayout.bind(this)), this.subscribe("layout-refreshed", this.unblockLayout.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
  }
  blockLayout() {
    this.blocked = !0;
  }
  unblockLayout() {
    this.blocked = !1;
  }
  layoutCell(e) {
    this.layoutElement(e.element, e.column);
  }
  reinitializeColumns() {
    this.reset(), this.table.columnManager.columnsByIndex.forEach((e) => {
      this.initializeColumn(e);
    });
  }
  //initialize specific column
  initializeColumn(e) {
    var t = { margin: 0, edge: !1 };
    e.isGroup || (this.frozenCheck(e) ? (t.position = this.initializationMode, this.initializationMode == "left" ? this.leftColumns.push(e) : this.rightColumns.unshift(e), this.active = !0, e.modules.frozen = t) : this.initializationMode = "right");
  }
  frozenCheck(e) {
    return e.parent.isGroup && e.definition.frozen && console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups"), e.parent.isGroup ? this.frozenCheck(e.parent) : e.definition.frozen;
  }
  //layout calculation rows
  layoutCalcRows() {
    this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow && this.layoutRow(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow && this.layoutRow(this.table.modules.columnCalcs.botRow), this.table.modExists("groupRows") && this.layoutGroupCalcs(this.table.modules.groupRows.getGroups()));
  }
  layoutGroupCalcs(e) {
    e.forEach((t) => {
      t.calcs.top && this.layoutRow(t.calcs.top), t.calcs.bottom && this.layoutRow(t.calcs.bottom), t.groupList && t.groupList.length && this.layoutGroupCalcs(t.groupList);
    });
  }
  //calculate column positions and layout headers
  layoutColumnPosition(e) {
    var t = [], i = 0, n = 0;
    this.leftColumns.forEach((a, o) => {
      if (a.modules.frozen.marginValue = i, a.modules.frozen.margin = a.modules.frozen.marginValue + "px", a.visible && (i += a.getWidth()), o == this.leftColumns.length - 1 ? a.modules.frozen.edge = !0 : a.modules.frozen.edge = !1, a.parent.isGroup) {
        var s = this.getColGroupParentElement(a);
        t.includes(s) || (this.layoutElement(s, a), t.push(s)), a.modules.frozen.edge && s.classList.add("tabulator-frozen-" + a.modules.frozen.position);
      } else
        this.layoutElement(a.getElement(), a);
      e && a.cells.forEach((l) => {
        this.layoutElement(l.getElement(!0), a);
      });
    }), this.rightColumns.forEach((a, o) => {
      a.modules.frozen.marginValue = n, a.modules.frozen.margin = a.modules.frozen.marginValue + "px", a.visible && (n += a.getWidth()), o == this.rightColumns.length - 1 ? a.modules.frozen.edge = !0 : a.modules.frozen.edge = !1, a.parent.isGroup ? this.layoutElement(this.getColGroupParentElement(a), a) : this.layoutElement(a.getElement(), a), e && a.cells.forEach((s) => {
        this.layoutElement(s.getElement(!0), a);
      });
    });
  }
  getColGroupParentElement(e) {
    return e.parent.isGroup ? this.getColGroupParentElement(e.parent) : e.getElement();
  }
  //layout columns appropriately
  layout() {
    this.active && !this.blocked && (this.layoutColumnPosition(), this.reinitializeRows(), this.layoutCalcRows());
  }
  reinitializeRows() {
    var e = this.table.rowManager.getVisibleRows(!0), t = this.table.rowManager.getRows().filter((i) => !e.includes(i));
    t.forEach((i) => {
      i.deinitialize();
    }), e.forEach((i) => {
      i.type === "row" && this.layoutRow(i);
    });
  }
  layoutRow(e) {
    this.table.options.layout === "fitDataFill" && this.rightColumns.length && (this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")"), this.leftColumns.forEach((t) => {
      var i = e.getCell(t);
      i && this.layoutElement(i.getElement(!0), t);
    }), this.rightColumns.forEach((t) => {
      var i = e.getCell(t);
      i && this.layoutElement(i.getElement(!0), t);
    });
  }
  layoutElement(e, t) {
    var i;
    t.modules.frozen && e && (e.style.position = "sticky", this.table.rtl ? i = t.modules.frozen.position === "left" ? "right" : "left" : i = t.modules.frozen.position, e.style[i] = t.modules.frozen.margin, e.classList.add("tabulator-frozen"), t.modules.frozen.edge && e.classList.add("tabulator-frozen-" + t.modules.frozen.position));
  }
  adjustForScrollbar(e) {
    this.rightColumns.length && (this.table.columnManager.getContentsElement().style.width = "calc(100% - " + e + "px)");
  }
  _calcSpace(e, t) {
    var i = 0;
    for (let n = 0; n < t; n++)
      e[n].visible && (i += e[n].getWidth());
    return i;
  }
}
wP.moduleName = "frozenColumns";
class PP extends pt {
  constructor(e) {
    super(e), this.topElement = document.createElement("div"), this.rows = [], this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this)), this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this)), this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this)), this.registerTableOption("frozenRowsField", "id"), this.registerTableOption("frozenRows", !1);
  }
  initialize() {
    this.rows = [], this.topElement.classList.add("tabulator-frozen-rows-holder"), this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.subscribe("row-deleting", this.detachRow.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 10), this.table.options.frozenRows && (this.subscribe("data-processed", this.initializeRows.bind(this)), this.subscribe("row-added", this.initializeRow.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this))), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  initializeRows() {
    this.table.rowManager.getRows().forEach((e) => {
      this.initializeRow(e);
    });
  }
  initializeRow(e) {
    var t = this.table.options.frozenRows, i = typeof t;
    i === "number" ? e.getPosition() && e.getPosition() + this.rows.length <= t && this.freezeRow(e) : i === "function" ? t.call(this.table, e.getComponent()) && this.freezeRow(e) : Array.isArray(t) && t.includes(e.data[this.options("frozenRowsField")]) && this.freezeRow(e);
  }
  isRowFrozen(e) {
    var t = this.rows.indexOf(e);
    return t > -1;
  }
  isFrozen() {
    return !!this.rows.length;
  }
  visibleRows(e, t) {
    return this.rows.forEach((i) => {
      t.push(i);
    }), t;
  }
  //filter frozen rows out of display data
  getRows(e) {
    var t = e.slice(0);
    return this.rows.forEach(function(i) {
      var n = t.indexOf(i);
      n > -1 && t.splice(n, 1);
    }), t;
  }
  freezeRow(e) {
    e.modules.frozen ? console.warn("Freeze Error - Row is already frozen") : (e.modules.frozen = !0, this.topElement.appendChild(e.getElement()), e.initialize(), e.normalizeHeight(), this.rows.push(e), this.refreshData(!1, "display"), this.table.rowManager.adjustTableSize(), this.styleRows());
  }
  unfreezeRow(e) {
    e.modules.frozen ? (e.modules.frozen = !1, this.detachRow(e), this.table.rowManager.adjustTableSize(), this.refreshData(!1, "display"), this.rows.length && this.styleRows()) : console.warn("Freeze Error - Row is already unfrozen");
  }
  detachRow(e) {
    var t = this.rows.indexOf(e);
    if (t > -1) {
      var i = e.getElement();
      i.parentNode && i.parentNode.removeChild(i), this.rows.splice(t, 1);
    }
  }
  styleRows(e) {
    this.rows.forEach((t, i) => {
      this.table.rowManager.styleRow(t, i);
    });
  }
}
PP.moduleName = "frozenRows";
class O$e {
  constructor(e) {
    return this._group = e, this.type = "GroupComponent", new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._group.groupManager.table.componentFunctionBinder.handle("group", t._group, i);
      }
    });
  }
  getKey() {
    return this._group.key;
  }
  getField() {
    return this._group.field;
  }
  getElement() {
    return this._group.element;
  }
  getRows() {
    return this._group.getRows(!0);
  }
  getSubGroups() {
    return this._group.getSubGroups(!0);
  }
  getParentGroup() {
    return this._group.parent ? this._group.parent.getComponent() : !1;
  }
  isVisible() {
    return this._group.visible;
  }
  show() {
    this._group.show();
  }
  hide() {
    this._group.hide();
  }
  toggle() {
    this._group.toggleVisibility();
  }
  scrollTo(e, t) {
    return this._group.groupManager.table.rowManager.scrollToRow(this._group, e, t);
  }
  _getSelf() {
    return this._group;
  }
  getTable() {
    return this._group.groupManager.table;
  }
}
class yc {
  constructor(e, t, i, n, a, o, s) {
    this.groupManager = e, this.parent = t, this.key = n, this.level = i, this.field = a, this.hasSubGroups = i < e.groupIDLookups.length - 1, this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow, this.type = "group", this.old = s, this.rows = [], this.groups = [], this.groupList = [], this.generator = o, this.element = !1, this.elementContents = !1, this.height = 0, this.outerHeight = 0, this.initialized = !1, this.calcs = {}, this.initialized = !1, this.modules = {}, this.arrowElement = !1, this.visible = s ? s.visible : typeof e.startOpen[i] < "u" ? e.startOpen[i] : e.startOpen[0], this.component = null, this.createElements(), this.addBindings(), this.createValueGroups();
  }
  wipe(e) {
    e || (this.groupList.length ? this.groupList.forEach(function(t) {
      t.wipe();
    }) : this.rows.forEach((t) => {
      t.modules && delete t.modules.group;
    })), this.element = !1, this.arrowElement = !1, this.elementContents = !1;
  }
  createElements() {
    var e = document.createElement("div");
    e.classList.add("tabulator-arrow"), this.element = document.createElement("div"), this.element.classList.add("tabulator-row"), this.element.classList.add("tabulator-group"), this.element.classList.add("tabulator-group-level-" + this.level), this.element.setAttribute("role", "rowgroup"), this.arrowElement = document.createElement("div"), this.arrowElement.classList.add("tabulator-group-toggle"), this.arrowElement.appendChild(e), this.groupManager.table.options.movableRows !== !1 && this.groupManager.table.modExists("moveRow") && this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
  }
  createValueGroups() {
    var e = this.level + 1;
    this.groupManager.allowedValues && this.groupManager.allowedValues[e] && this.groupManager.allowedValues[e].forEach((t) => {
      this._createGroup(t, e);
    });
  }
  addBindings() {
    var e;
    this.groupManager.table.options.groupToggleElement && (e = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element, e.addEventListener("click", (t) => {
      t.stopPropagation(), t.stopImmediatePropagation(), this.toggleVisibility();
    }));
  }
  _createGroup(e, t) {
    var i = t + "_" + e, n = new yc(this.groupManager, this, t, e, this.groupManager.groupIDLookups[t].field, this.groupManager.headerGenerator[t] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[i] : !1);
    this.groups[i] = n, this.groupList.push(n);
  }
  _addRowToGroup(e) {
    var t = this.level + 1;
    if (this.hasSubGroups) {
      var i = this.groupManager.groupIDLookups[t].func(e.getData()), n = t + "_" + i;
      this.groupManager.allowedValues && this.groupManager.allowedValues[t] ? this.groups[n] && this.groups[n].addRow(e) : (this.groups[n] || this._createGroup(i, t), this.groups[n].addRow(e));
    }
  }
  _addRow(e) {
    this.rows.push(e), e.modules.group = this;
  }
  insertRow(e, t, i) {
    var n = this.conformRowData({});
    e.updateData(n);
    var a = this.rows.indexOf(t);
    a > -1 ? i ? this.rows.splice(a + 1, 0, e) : this.rows.splice(a, 0, e) : i ? this.rows.push(e) : this.rows.unshift(e), e.modules.group = this, this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this), this.groupManager.updateGroupRows(!0);
  }
  scrollHeader(e) {
    this.arrowElement && (this.arrowElement.style.marginLeft = e, this.groupList.forEach(function(t) {
      t.scrollHeader(e);
    }));
  }
  getRowIndex(e) {
  }
  //update row data to match grouping constraints
  conformRowData(e) {
    return this.field ? e[this.field] = this.key : console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function"), this.parent && (e = this.parent.conformRowData(e)), e;
  }
  removeRow(e) {
    var t = this.rows.indexOf(e), i = e.getElement();
    t > -1 && this.rows.splice(t, 1), !this.groupManager.table.options.groupValues && !this.rows.length ? (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this), this.groupManager.updateGroupRows(!0)) : (i.parentNode && i.parentNode.removeChild(i), this.groupManager.blockRedraw || (this.generateGroupHeaderContents(), this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this)));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, i;
    this.groups[t] && (delete this.groups[t], i = this.groupList.indexOf(e), i > -1 && this.groupList.splice(i, 1), this.groupList.length || (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this)));
  }
  getHeadersAndRows() {
    var e = [];
    return e.push(this), this._visSet(), this.calcs.top && (this.calcs.top.detachElement(), this.calcs.top.deleteCells()), this.calcs.bottom && (this.calcs.bottom.detachElement(), this.calcs.bottom.deleteCells()), this.visible ? this.groupList.length ? this.groupList.forEach(function(t) {
      e = e.concat(t.getHeadersAndRows());
    }) : (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs() && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), e = e.concat(this.rows), this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))) : !this.groupList.length && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && (this.groupManager.table.modules.columnCalcs.hasTopCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))), e;
  }
  getData(e, t) {
    var i = [];
    return this._visSet(), (!e || e && this.visible) && this.rows.forEach((n) => {
      i.push(n.getData(t || "data"));
    }), i;
  }
  getRowCount() {
    var e = 0;
    return this.groupList.length ? this.groupList.forEach((t) => {
      e += t.getRowCount();
    }) : e = this.rows.length, e;
  }
  toggleVisibility() {
    this.visible ? this.hide() : this.show();
  }
  hide() {
    this.visible = !1, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination ? (this.element.classList.remove("tabulator-group-visible"), this.groupList.length ? this.groupList.forEach((e) => {
      var t = e.getHeadersAndRows();
      t.forEach((i) => {
        i.detachElement();
      });
    }) : this.rows.forEach((e) => {
      var t = e.getElement();
      t.parentNode.removeChild(t);
    }), this.groupManager.updateGroupRows(!0)) : this.groupManager.updateGroupRows(!0), this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !1);
  }
  show() {
    if (this.visible = !0, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.add("tabulator-group-visible");
      var e = this.generateElement();
      this.groupList.length ? this.groupList.forEach((t) => {
        var i = t.getHeadersAndRows();
        i.forEach((n) => {
          var a = n.getElement();
          e.parentNode.insertBefore(a, e.nextSibling), n.initialize(), e = a;
        });
      }) : this.rows.forEach((t) => {
        var i = t.getElement();
        e.parentNode.insertBefore(i, e.nextSibling), t.initialize(), e = i;
      }), this.groupManager.updateGroupRows(!0);
    } else
      this.groupManager.updateGroupRows(!0);
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !0);
  }
  _visSet() {
    var e = [];
    typeof this.visible == "function" && (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.visible = this.visible(this.key, this.getRowCount(), e, this.getComponent()));
  }
  getRowGroup(e) {
    var t = !1;
    return this.groupList.length ? this.groupList.forEach(function(i) {
      var n = i.getRowGroup(e);
      n && (t = n);
    }) : this.rows.find(function(i) {
      return i === e;
    }) && (t = this), t;
  }
  getSubGroups(e) {
    var t = [];
    return this.groupList.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  getRows(e) {
    var t = [];
    return this.rows.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  generateGroupHeaderContents() {
    var e = [];
    for (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.elementContents = this.generator(this.key, this.getRowCount(), e, this.getComponent()); this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    typeof this.elementContents == "string" ? this.element.innerHTML = this.elementContents : this.element.appendChild(this.elementContents), this.element.insertBefore(this.arrowElement, this.element.firstChild);
  }
  getPath(e = []) {
    return e.unshift(this.key), this.parent && this.parent.getPath(e), e;
  }
  ////////////// Standard Row Functions //////////////
  getElement() {
    return this.elementContents ? this.element : this.generateElement();
  }
  generateElement() {
    this.addBindings = !1, this._visSet(), this.visible ? this.element.classList.add("tabulator-group-visible") : this.element.classList.remove("tabulator-group-visible");
    for (var e = 0; e < this.element.childNodes.length; ++e)
      this.element.childNodes[e].parentNode.removeChild(this.element.childNodes[e]);
    return this.generateGroupHeaderContents(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  //normalize the height of elements in the row
  normalizeHeight() {
    this.setHeight(this.element.clientHeight);
  }
  initialize(e) {
    (!this.initialized || e) && (this.normalizeHeight(), this.initialized = !0);
  }
  reinitialize() {
    this.initialized = !1, this.height = 0, Wt.elVisible(this.element) && this.initialize(!0);
  }
  setHeight(e) {
    this.height != e && (this.height = e, this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  getGroup() {
    return this;
  }
  reinitializeHeight() {
  }
  calcHeight() {
  }
  setCellHeight() {
  }
  clearCellHeight() {
  }
  deinitializeHeight() {
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new O$e(this)), this.component;
  }
}
class NP extends pt {
  constructor(e) {
    super(e), this.groupIDLookups = !1, this.startOpen = [function() {
      return !1;
    }], this.headerGenerator = [function() {
      return "";
    }], this.groupList = [], this.allowedValues = !1, this.groups = {}, this.displayHandler = this.getRows.bind(this), this.blockRedraw = !1, this.registerTableOption("groupBy", !1), this.registerTableOption("groupStartOpen", !0), this.registerTableOption("groupValues", !1), this.registerTableOption("groupUpdateOnCellEdit", !1), this.registerTableOption("groupHeader", !1), this.registerTableOption("groupHeaderPrint", null), this.registerTableOption("groupHeaderClipboard", null), this.registerTableOption("groupHeaderHtmlOutput", null), this.registerTableOption("groupHeaderDownload", null), this.registerTableOption("groupToggleElement", "arrow"), this.registerTableOption("groupClosedShowCalcs", !1), this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this)), this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this)), this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this)), this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this)), this.registerTableFunction("getGroups", this.userGetGroups.bind(this)), this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this)), this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
  }
  //initialize group configuration
  initialize() {
    this.subscribe("table-destroy", this._blockRedrawing.bind(this)), this.subscribe("rows-wipe", this._blockRedrawing.bind(this)), this.subscribe("rows-wiped", this._restore_redrawing.bind(this)), this.table.options.groupBy && (this.table.options.groupUpdateOnCellEdit && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0)), this.subscribe("table-built", this.configureGroupSetup.bind(this)), this.subscribe("row-deleting", this.rowDeleting.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this)), this.subscribe("rows-wipe", this.wipe.bind(this)), this.subscribe("rows-added", this.rowsUpdated.bind(this)), this.subscribe("row-moving", this.rowMoving.bind(this)), this.subscribe("row-adding-index", this.rowAddingIndex.bind(this)), this.subscribe("rows-sample", this.rowSample.bind(this)), this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this)), this.registerDisplayHandler(this.displayHandler, 20), this.initialized = !0);
  }
  _blockRedrawing() {
    this.blockRedraw = !0;
  }
  _restore_redrawing() {
    this.blockRedraw = !1;
  }
  configureGroupSetup() {
    if (this.table.options.groupBy) {
      var e = this.table.options.groupBy, t = this.table.options.groupStartOpen, i = this.table.options.groupHeader;
      if (this.allowedValues = this.table.options.groupValues, Array.isArray(e) && Array.isArray(i) && e.length > i.length && console.warn("Error creating group headers, groupHeader array is shorter than groupBy array"), this.headerGenerator = [function() {
        return "";
      }], this.startOpen = [function() {
        return !1;
      }], this.langBind("groups|item", (a, o) => {
        this.headerGenerator[0] = (s, l, u) => (typeof s > "u" ? "" : s) + "<span>(" + l + " " + (l === 1 ? a : o.groups.items) + ")</span>";
      }), this.groupIDLookups = [], e)
        this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both" && this.table.modules.columnCalcs.removeCalcs();
      else if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {
        var n = this.table.columnManager.getRealColumns();
        n.forEach((a) => {
          a.definition.topCalc && this.table.modules.columnCalcs.initializeTopRow(), a.definition.bottomCalc && this.table.modules.columnCalcs.initializeBottomRow();
        });
      }
      Array.isArray(e) || (e = [e]), e.forEach((a, o) => {
        var s, l;
        typeof a == "function" ? s = a : (l = this.table.columnManager.getColumnByField(a), l ? s = function(u) {
          return l.getFieldValue(u);
        } : s = function(u) {
          return u[a];
        }), this.groupIDLookups.push({
          field: typeof a == "function" ? !1 : a,
          func: s,
          values: this.allowedValues ? this.allowedValues[o] : !1
        });
      }), t && (Array.isArray(t) || (t = [t]), t.forEach((a) => {
      }), this.startOpen = t), i && (this.headerGenerator = Array.isArray(i) ? i : [i]);
    } else
      this.groupList = [], this.groups = {};
  }
  rowSample(e, t) {
    if (this.table.options.groupBy) {
      var i = this.getGroups(!1)[0];
      t.push(i.getRows(!1)[0]);
    }
    return t;
  }
  virtualRenderFill() {
    var e = this.table.rowManager.tableElement, t = this.table.rowManager.getVisibleRows();
    if (this.table.options.groupBy)
      t = t.filter((i) => i.type !== "group"), e.style.minWidth = t.length ? "" : this.table.columnManager.getWidth() + "px";
    else
      return t;
  }
  rowAddingIndex(e, t, i) {
    if (this.table.options.groupBy) {
      this.assignRowToGroup(e);
      var n = e.modules.group.rows;
      return n.length > 1 && (!t || t && n.indexOf(t) == -1 ? i ? n[0] !== e && (t = n[0], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)) : n[n.length - 1] !== e && (t = n[n.length - 1], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)) : this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)), t;
    }
  }
  trackChanges() {
    this.dispatch("group-changed");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  setGroupBy(e) {
    this.table.options.groupBy = e, this.initialized || this.initialize(), this.configureGroupSetup(), !e && this.table.modExists("columnCalcs") && this.table.options.columnCalcs === !0 && this.table.modules.columnCalcs.reinitializeCalcs(), this.refreshData(), this.trackChanges();
  }
  setGroupValues(e) {
    this.table.options.groupValues = e, this.configureGroupSetup(), this.refreshData(), this.trackChanges();
  }
  setGroupStartOpen(e) {
    this.table.options.groupStartOpen = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  setGroupHeader(e) {
    this.table.options.groupHeader = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  userGetGroups(e) {
    return this.getGroups(!0);
  }
  // get grouped table data in the same format as getData()
  userGetGroupedData() {
    return this.table.options.groupBy ? this.getGroupedData() : this.getData();
  }
  ///////////////////////////////////////
  ///////// Component Functions /////////
  ///////////////////////////////////////
  rowGetGroup(e) {
    return e.modules.group ? e.modules.group.getComponent() : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  rowMoving(e, t, i) {
    if (this.table.options.groupBy) {
      !i && t instanceof yc && (t = this.table.rowManager.prevDisplayRow(e) || t);
      var n = t instanceof yc ? t : t.modules.group, a = e instanceof yc ? e : e.modules.group;
      n === a ? this.table.rowManager.moveRowInArray(n.rows, e, t, i) : (a && a.removeRow(e), n.insertRow(e, t, i));
    }
  }
  rowDeleting(e) {
    this.table.options.groupBy && e.modules.group && e.modules.group.removeRow(e);
  }
  rowsUpdated(e) {
    this.table.options.groupBy && this.updateGroupRows(!0);
  }
  cellUpdated(e) {
    this.table.options.groupBy && this.reassignRowToGroup(e.row);
  }
  //return appropriate rows with group headers
  getRows(e) {
    return this.table.options.groupBy && this.groupIDLookups.length ? (this.dispatchExternal("dataGrouping"), this.generateGroups(e), this.subscribedExternal("dataGrouped") && this.dispatchExternal("dataGrouped", this.getGroups(!0)), this.updateGroupRows()) : e.slice(0);
  }
  getGroups(e) {
    var t = [];
    return this.groupList.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  getChildGroups(e) {
    var t = [];
    return e || (e = this), e.groupList.forEach((i) => {
      i.groupList.length ? t = t.concat(this.getChildGroups(i)) : t.push(i);
    }), t;
  }
  wipe() {
    this.table.options.groupBy && (this.groupList.forEach(function(e) {
      e.wipe();
    }), this.groupList = [], this.groups = {});
  }
  pullGroupListData(e) {
    var t = [];
    return e.forEach((i) => {
      var n = {};
      n.level = 0, n.rowCount = 0, n.headerContent = "";
      var a = [];
      i.hasSubGroups ? (a = this.pullGroupListData(i.groupList), n.level = i.level, n.rowCount = a.length - i.groupList.length, n.headerContent = i.generator(i.key, n.rowCount, i.rows, i), t.push(n), t = t.concat(a)) : (n.level = i.level, n.headerContent = i.generator(i.key, i.rows.length, i.rows, i), n.rowCount = i.getRows().length, t.push(n), i.getRows().forEach((o) => {
        t.push(o.getData("data"));
      }));
    }), t;
  }
  getGroupedData() {
    return this.pullGroupListData(this.groupList);
  }
  getRowGroup(e) {
    var t = !1;
    return this.options("dataTree") && (e = this.table.modules.dataTree.getTreeParentRoot(e)), this.groupList.forEach((i) => {
      var n = i.getRowGroup(e);
      n && (t = n);
    }), t;
  }
  countGroups() {
    return this.groupList.length;
  }
  generateGroups(e) {
    var t = this.groups;
    this.groups = {}, this.groupList = [], this.allowedValues && this.allowedValues[0] ? (this.allowedValues[0].forEach((i) => {
      this.createGroup(i, 0, t);
    }), e.forEach((i) => {
      this.assignRowToExistingGroup(i, t);
    })) : e.forEach((i) => {
      this.assignRowToGroup(i, t);
    }), Object.values(t).forEach((i) => {
      i.wipe(!0);
    });
  }
  createGroup(e, t, i) {
    var n = t + "_" + e, a;
    i = i || [], a = new yc(this, !1, t, e, this.groupIDLookups[0].field, this.headerGenerator[0], i[n]), this.groups[n] = a, this.groupList.push(a);
  }
  assignRowToExistingGroup(e, t) {
    var i = this.groupIDLookups[0].func(e.getData()), n = "0_" + i;
    this.groups[n] && this.groups[n].addRow(e);
  }
  assignRowToGroup(e, t) {
    var i = this.groupIDLookups[0].func(e.getData()), n = !this.groups["0_" + i];
    return n && this.createGroup(i, 0, t), this.groups["0_" + i].addRow(e), !n;
  }
  reassignRowToGroup(e) {
    if (e.type === "row") {
      var t = e.modules.group, i = t.getPath(), n = this.getExpectedPath(e), a;
      a = i.length == n.length && i.every((o, s) => o === n[s]), a || (t.removeRow(e), this.assignRowToGroup(e, this.groups), this.refreshData(!0));
    }
  }
  getExpectedPath(e) {
    var t = [], i = e.getData();
    return this.groupIDLookups.forEach((n) => {
      t.push(n.func(i));
    }), t;
  }
  updateGroupRows(e) {
    var t = [];
    return this.blockRedraw || (this.groupList.forEach((i) => {
      t = t.concat(i.getHeadersAndRows());
    }), e && this.refreshData(!0)), t;
  }
  scrollHeaders(e) {
    this.table.options.groupBy && (this.table.options.renderHorizontal === "virtual" && (e -= this.table.columnManager.renderer.vDomPadLeft), e = e + "px", this.groupList.forEach((t) => {
      t.scrollHeader(e);
    }));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, i;
    this.groups[t] && (delete this.groups[t], i = this.groupList.indexOf(e), i > -1 && this.groupList.splice(i, 1));
  }
  checkBasicModeGroupHeaderWidth() {
    var e = this.table.rowManager.tableElement, t = !0;
    this.table.rowManager.getDisplayRows().forEach((i, n) => {
      this.table.rowManager.styleRow(i, n), e.appendChild(i.getElement()), i.initialize(!0), i.type !== "group" && (t = !1);
    }), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
}
NP.moduleName = "groupRows";
var m$e = {
  cellEdit: function(r) {
    r.component.setValueProcessData(r.data.oldValue), r.component.cellRendered();
  },
  rowAdd: function(r) {
    r.component.deleteActual();
  },
  rowDelete: function(r) {
    var e = this.table.rowManager.addRowActual(r.data.data, r.data.pos, r.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(r.component, e);
  },
  rowMove: function(r) {
    this.table.rowManager.moveRowActual(r.component, this.table.rowManager.rows[r.data.posFrom], !r.data.after), this.table.rowManager.redraw();
  }
}, E$e = {
  cellEdit: function(r) {
    r.component.setValueProcessData(r.data.newValue), r.component.cellRendered();
  },
  rowAdd: function(r) {
    var e = this.table.rowManager.addRowActual(r.data.data, r.data.pos, r.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(r.component, e);
  },
  rowDelete: function(r) {
    r.component.deleteActual();
  },
  rowMove: function(r) {
    this.table.rowManager.moveRowActual(r.component, this.table.rowManager.rows[r.data.posTo], r.data.after), this.table.rowManager.redraw();
  }
};
class bl extends pt {
  constructor(e) {
    super(e), this.history = [], this.index = -1, this.registerTableOption("history", !1);
  }
  initialize() {
    this.table.options.history && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("cell-delete", this.clearComponentHistory.bind(this)), this.subscribe("row-delete", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clear.bind(this)), this.subscribe("row-added", this.rowAdded.bind(this)), this.subscribe("row-move", this.rowMoved.bind(this))), this.registerTableFunction("undo", this.undo.bind(this)), this.registerTableFunction("redo", this.redo.bind(this)), this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this)), this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this)), this.registerTableFunction("clearHistory", this.clear.bind(this));
  }
  rowMoved(e, t, i) {
    this.action("rowMove", e, { posFrom: e.getPosition(), posTo: t.getPosition(), to: t, after: i });
  }
  rowAdded(e, t, i, n) {
    this.action("rowAdd", e, { data: t, pos: i, index: n });
  }
  rowDeleted(e) {
    var t, i;
    this.table.options.groupBy ? (i = e.getComponent().getGroup()._getSelf().rows, t = i.indexOf(e), t && (t = i[t - 1])) : (t = e.table.rowManager.getRowIndex(e), t && (t = e.table.rowManager.rows[t - 1])), this.action("rowDelete", e, { data: e.getData(), pos: !t, index: t });
  }
  cellUpdated(e) {
    this.action("cellEdit", e, { oldValue: e.oldValue, newValue: e.value });
  }
  clear() {
    this.history = [], this.index = -1;
  }
  action(e, t, i) {
    this.history = this.history.slice(0, this.index + 1), this.history.push({
      type: e,
      component: t,
      data: i
    }), this.index++;
  }
  getHistoryUndoSize() {
    return this.index + 1;
  }
  getHistoryRedoSize() {
    return this.history.length - (this.index + 1);
  }
  clearComponentHistory(e) {
    var t = this.history.findIndex(function(i) {
      return i.component === e;
    });
    t > -1 && (this.history.splice(t, 1), t <= this.index && this.index--, this.clearComponentHistory(e));
  }
  undo() {
    if (this.index > -1) {
      let e = this.history[this.index];
      return bl.undoers[e.type].call(this, e), this.index--, this.dispatchExternal("historyUndo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Undo Error - No more history to undo"), !1;
  }
  redo() {
    if (this.history.length - 1 > this.index) {
      this.index++;
      let e = this.history[this.index];
      return bl.redoers[e.type].call(this, e), this.dispatchExternal("historyRedo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Redo Error - No more history to redo"), !1;
  }
  //rebind rows to new element after deletion
  _rebindRow(e, t) {
    this.history.forEach(function(i) {
      if (i.component instanceof Ti)
        i.component === e && (i.component = t);
      else if (i.component instanceof dv && i.component.row === e) {
        var n = i.component.column.getField();
        n && (i.component = t.getCell(n));
      }
    });
  }
}
bl.moduleName = "history";
bl.undoers = m$e;
bl.redoers = E$e;
class LP extends pt {
  constructor(e) {
    super(e), this.fieldIndex = [], this.hasIndex = !1;
  }
  initialize() {
    this.tableElementCheck();
  }
  tableElementCheck() {
    this.table.originalElement && this.table.originalElement.tagName === "TABLE" && (this.table.originalElement.childNodes.length ? this.parseTable() : console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element."));
  }
  parseTable() {
    var e = this.table.originalElement, t = this.table.options, i = e.getElementsByTagName("th"), n = e.getElementsByTagName("tbody")[0], a = [];
    this.hasIndex = !1, this.dispatchExternal("htmlImporting"), n = n ? n.getElementsByTagName("tr") : [], this._extractOptions(e, t), i.length ? this._extractHeaders(i, n) : this._generateBlankHeaders(i, n);
    for (var o = 0; o < n.length; o++) {
      var s = n[o], l = s.getElementsByTagName("td"), u = {};
      this.hasIndex || (u[t.index] = o);
      for (var h = 0; h < l.length; h++) {
        var c = l[h];
        typeof this.fieldIndex[h] < "u" && (u[this.fieldIndex[h]] = c.innerHTML);
      }
      a.push(u);
    }
    t.data = a, this.dispatchExternal("htmlImported");
  }
  //extract tabulator attribute options
  _extractOptions(e, t, i) {
    var n = e.attributes, a = Object.keys(i || t), o = {};
    a.forEach((h) => {
      o[h.toLowerCase()] = h;
    });
    for (var s in n) {
      var l = n[s], u;
      l && typeof l == "object" && l.name && l.name.indexOf("tabulator-") === 0 && (u = l.name.replace("tabulator-", ""), typeof o[u] < "u" && (t[o[u]] = this._attribValue(l.value)));
    }
  }
  //get value of attribute
  _attribValue(e) {
    return e === "true" ? !0 : e === "false" ? !1 : e;
  }
  //find column if it has already been defined
  _findCol(e) {
    var t = this.table.options.columns.find((i) => i.title === e);
    return t || !1;
  }
  //extract column from headers
  _extractHeaders(e, t) {
    for (var i = 0; i < e.length; i++) {
      var n = e[i], a = !1, o = this._findCol(n.textContent), s;
      o ? a = !0 : o = { title: n.textContent.trim() }, o.field || (o.field = n.textContent.trim().toLowerCase().replace(" ", "_")), s = n.getAttribute("width"), s && !o.width && (o.width = s), this._extractOptions(n, o, this.table.columnManager.optionsList.registeredDefaults), this.fieldIndex[i] = o.field, o.field == this.table.options.index && (this.hasIndex = !0), a || this.table.options.columns.push(o);
    }
  }
  //generate blank headers
  _generateBlankHeaders(e, t) {
    for (var i = 0; i < e.length; i++) {
      var n = e[i], a = { title: "", field: "col" + i };
      this.fieldIndex[i] = a.field;
      var o = n.getAttribute("width");
      o && (a.width = o), this.table.options.columns.push(a);
    }
  }
}
LP.moduleName = "htmlTableImport";
function b$e(r) {
  var e = [], t = 0, i = 0, n = !1;
  for (let a = 0; a < r.length; a++) {
    let o = r[a], s = r[a + 1];
    if (e[t] || (e[t] = []), e[t][i] || (e[t][i] = ""), o == '"' && n && s == '"') {
      e[t][i] += o, a++;
      continue;
    }
    if (o == '"') {
      n = !n;
      continue;
    }
    if (o == "," && !n) {
      i++;
      continue;
    }
    if (o == "\r" && s == `
` && !n) {
      i = 0, t++, a++;
      continue;
    }
    if ((o == "\r" || o == `
`) && !n) {
      i = 0, t++;
      continue;
    }
    e[t][i] += o;
  }
  return e;
}
function S$e(r) {
  try {
    return JSON.parse(r);
  } catch (e) {
    return console.warn("JSON Import Error - File contents is invalid JSON", e), Promise.reject();
  }
}
function T$e(r) {
  return r;
}
var y$e = {
  csv: b$e,
  json: S$e,
  array: T$e
};
class Uf extends pt {
  constructor(e) {
    super(e), this.registerTableOption("importFormat"), this.registerTableOption("importReader", "text");
  }
  initialize() {
    this.registerTableFunction("import", this.importFromFile.bind(this)), this.table.options.importFormat && (this.subscribe("data-loading", this.loadDataCheck.bind(this), 10), this.subscribe("data-load", this.loadData.bind(this), 10));
  }
  loadDataCheck(e) {
    return this.table.options.importFormat && (typeof e == "string" || Array.isArray(e) && e.length && Array.isArray(e));
  }
  loadData(e, t, i, n, a) {
    return this.importData(this.lookupImporter(), e).then(this.structureData.bind(this)).catch((o) => (console.error("Import Error:", o || "Unable to import data"), Promise.reject(o)));
  }
  lookupImporter(e) {
    var t;
    return e || (e = this.table.options.importFormat), typeof e == "string" ? t = Uf.importers[e] : t = e, t || console.error("Import Error - Importer not found:", e), t;
  }
  importFromFile(e, t) {
    var i = this.lookupImporter(e);
    if (i)
      return this.pickFile(t).then(this.importData.bind(this, i)).then(this.structureData.bind(this)).then(this.setData.bind(this)).catch((n) => (console.error("Import Error:", n || "Unable to import file"), Promise.reject(n)));
  }
  pickFile(e) {
    return new Promise((t, i) => {
      var n = document.createElement("input");
      n.type = "file", n.accept = e, n.addEventListener("change", (a) => {
        var o = n.files[0], s = new FileReader();
        switch (this.table.options.importReader) {
          case "buffer":
            s.readAsArrayBuffer(o);
            break;
          case "binary":
            s.readAsBinaryString(o);
            break;
          case "url":
            s.readAsDataURL(o);
            break;
          case "text":
          default:
            s.readAsText(o);
        }
        s.onload = (l) => {
          t(s.result);
        }, s.onerror = (l) => {
          console.warn("File Load Error - Unable to read file"), i();
        };
      }), n.click();
    });
  }
  importData(e, t) {
    var i = e.call(this.table, t);
    return i instanceof Promise ? i : i ? Promise.resolve(i) : Promise.reject();
  }
  structureData(e) {
    var t = [];
    return Array.isArray(e) && e.length && Array.isArray(e[0]) ? (this.table.options.autoColumns ? t = this.structureArrayToObject(e) : t = this.structureArrayToColumns(e), t) : e;
  }
  structureArrayToObject(e) {
    var t = e.shift(), i = e.map((n) => {
      var a = {};
      return t.forEach((o, s) => {
        a[o] = n[s];
      }), a;
    });
    return i;
  }
  structureArrayToColumns(e) {
    var t = [], i = this.table.getColumns();
    return i[0] && e[0][0] && i[0].getDefinition().title === e[0][0] && e.shift(), e.forEach((n) => {
      var a = {};
      n.forEach((o, s) => {
        var l = i[s];
        l && (a[l.getField()] = o);
      }), t.push(a);
    }), t;
  }
  setData(e) {
    return this.table.setData(e);
  }
}
Uf.moduleName = "import";
Uf.importers = y$e;
class DP extends pt {
  constructor(e) {
    super(e), this.eventMap = {
      //row events
      rowClick: "row-click",
      rowDblClick: "row-dblclick",
      rowContext: "row-contextmenu",
      rowMouseEnter: "row-mouseenter",
      rowMouseLeave: "row-mouseleave",
      rowMouseOver: "row-mouseover",
      rowMouseOut: "row-mouseout",
      rowMouseMove: "row-mousemove",
      rowMouseDown: "row-mousedown",
      rowMouseUp: "row-mouseup",
      rowTap: "row",
      rowDblTap: "row",
      rowTapHold: "row",
      //cell events
      cellClick: "cell-click",
      cellDblClick: "cell-dblclick",
      cellContext: "cell-contextmenu",
      cellMouseEnter: "cell-mouseenter",
      cellMouseLeave: "cell-mouseleave",
      cellMouseOver: "cell-mouseover",
      cellMouseOut: "cell-mouseout",
      cellMouseMove: "cell-mousemove",
      cellMouseDown: "cell-mousedown",
      cellMouseUp: "cell-mouseup",
      cellTap: "cell",
      cellDblTap: "cell",
      cellTapHold: "cell",
      //column header events
      headerClick: "column-click",
      headerDblClick: "column-dblclick",
      headerContext: "column-contextmenu",
      headerMouseEnter: "column-mouseenter",
      headerMouseLeave: "column-mouseleave",
      headerMouseOver: "column-mouseover",
      headerMouseOut: "column-mouseout",
      headerMouseMove: "column-mousemove",
      headerMouseDown: "column-mousedown",
      headerMouseUp: "column-mouseup",
      headerTap: "column",
      headerDblTap: "column",
      headerTapHold: "column",
      //group header
      groupClick: "group-click",
      groupDblClick: "group-dblclick",
      groupContext: "group-contextmenu",
      groupMouseEnter: "group-mouseenter",
      groupMouseLeave: "group-mouseleave",
      groupMouseOver: "group-mouseover",
      groupMouseOut: "group-mouseout",
      groupMouseMove: "group-mousemove",
      groupMouseDown: "group-mousedown",
      groupMouseUp: "group-mouseup",
      groupTap: "group",
      groupDblTap: "group",
      groupTapHold: "group"
    }, this.subscribers = {}, this.touchSubscribers = {}, this.columnSubscribers = {}, this.touchWatchers = {
      row: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      cell: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      column: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      group: {
        tap: null,
        tapDbl: null,
        tapHold: null
      }
    }, this.registerColumnOption("headerClick"), this.registerColumnOption("headerDblClick"), this.registerColumnOption("headerContext"), this.registerColumnOption("headerMouseEnter"), this.registerColumnOption("headerMouseLeave"), this.registerColumnOption("headerMouseOver"), this.registerColumnOption("headerMouseOut"), this.registerColumnOption("headerMouseMove"), this.registerColumnOption("headerMouseDown"), this.registerColumnOption("headerMouseUp"), this.registerColumnOption("headerTap"), this.registerColumnOption("headerDblTap"), this.registerColumnOption("headerTapHold"), this.registerColumnOption("cellClick"), this.registerColumnOption("cellDblClick"), this.registerColumnOption("cellContext"), this.registerColumnOption("cellMouseEnter"), this.registerColumnOption("cellMouseLeave"), this.registerColumnOption("cellMouseOver"), this.registerColumnOption("cellMouseOut"), this.registerColumnOption("cellMouseMove"), this.registerColumnOption("cellMouseDown"), this.registerColumnOption("cellMouseUp"), this.registerColumnOption("cellTap"), this.registerColumnOption("cellDblTap"), this.registerColumnOption("cellTapHold");
  }
  initialize() {
    this.initializeExternalEvents(), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this)), this.subscribe("scroll-horizontal", this.clearTouchWatchers.bind(this)), this.subscribe("scroll-vertical", this.clearTouchWatchers.bind(this));
  }
  clearTouchWatchers() {
    var e = Object.values(this.touchWatchers);
    e.forEach((t) => {
      for (let i in t)
        t[i] = null;
    });
  }
  cellContentsSelectionFixer(e, t) {
    var i;
    if (!(this.table.modExists("edit") && this.table.modules.edit.currentCell === t)) {
      e.preventDefault();
      try {
        document.selection ? (i = document.body.createTextRange(), i.moveToElementText(t.getElement()), i.select()) : window.getSelection && (i = document.createRange(), i.selectNode(t.getElement()), window.getSelection().removeAllRanges(), window.getSelection().addRange(i));
      } catch {
      }
    }
  }
  initializeExternalEvents() {
    for (let e in this.eventMap)
      this.subscriptionChangeExternal(e, this.subscriptionChanged.bind(this, e));
  }
  subscriptionChanged(e, t) {
    t ? this.subscribers[e] || (this.eventMap[e].includes("-") ? (this.subscribers[e] = this.handle.bind(this, e), this.subscribe(this.eventMap[e], this.subscribers[e])) : this.subscribeTouchEvents(e)) : this.eventMap[e].includes("-") ? this.subscribers[e] && !this.columnSubscribers[e] && !this.subscribedExternal(e) && (this.unsubscribe(this.eventMap[e], this.subscribers[e]), delete this.subscribers[e]) : this.unsubscribeTouchEvents(e);
  }
  subscribeTouchEvents(e) {
    var t = this.eventMap[e];
    this.touchSubscribers[t + "-touchstart"] || (this.touchSubscribers[t + "-touchstart"] = this.handleTouch.bind(this, t, "start"), this.touchSubscribers[t + "-touchend"] = this.handleTouch.bind(this, t, "end"), this.subscribe(t + "-touchstart", this.touchSubscribers[t + "-touchstart"]), this.subscribe(t + "-touchend", this.touchSubscribers[t + "-touchend"])), this.subscribers[e] = !0;
  }
  unsubscribeTouchEvents(e) {
    var t = !0, i = this.eventMap[e];
    if (this.subscribers[e] && !this.subscribedExternal(e)) {
      delete this.subscribers[e];
      for (let n in this.eventMap)
        this.eventMap[n] === i && this.subscribers[n] && (t = !1);
      t && (this.unsubscribe(i + "-touchstart", this.touchSubscribers[i + "-touchstart"]), this.unsubscribe(i + "-touchend", this.touchSubscribers[i + "-touchend"]), delete this.touchSubscribers[i + "-touchstart"], delete this.touchSubscribers[i + "-touchend"]);
    }
  }
  initializeColumn(e) {
    var t = e.definition;
    for (let i in this.eventMap)
      t[i] && (this.subscriptionChanged(i, !0), this.columnSubscribers[i] || (this.columnSubscribers[i] = []), this.columnSubscribers[i].push(e));
  }
  handle(e, t, i) {
    this.dispatchEvent(e, t, i);
  }
  handleTouch(e, t, i, n) {
    var a = this.touchWatchers[e];
    switch (e === "column" && (e = "header"), t) {
      case "start":
        a.tap = !0, clearTimeout(a.tapHold), a.tapHold = setTimeout(() => {
          clearTimeout(a.tapHold), a.tapHold = null, a.tap = null, clearTimeout(a.tapDbl), a.tapDbl = null, this.dispatchEvent(e + "TapHold", i, n);
        }, 1e3);
        break;
      case "end":
        a.tap && (a.tap = null, this.dispatchEvent(e + "Tap", i, n)), a.tapDbl ? (clearTimeout(a.tapDbl), a.tapDbl = null, this.dispatchEvent(e + "DblTap", i, n)) : a.tapDbl = setTimeout(() => {
          clearTimeout(a.tapDbl), a.tapDbl = null;
        }, 300), clearTimeout(a.tapHold), a.tapHold = null;
        break;
    }
  }
  dispatchEvent(e, t, i) {
    var n = i.getComponent(), a;
    this.columnSubscribers[e] && (i instanceof dv ? a = i.column.definition[e] : i instanceof ro && (a = i.definition[e]), a && a(t, n)), this.dispatchExternal(e, t, n);
  }
}
DP.moduleName = "interaction";
var R$e = {
  navPrev: "shift + 9",
  navNext: 9,
  navUp: 38,
  navDown: 40,
  scrollPageUp: 33,
  scrollPageDown: 34,
  scrollToStart: 36,
  scrollToEnd: 35,
  undo: ["ctrl + 90", "meta + 90"],
  redo: ["ctrl + 89", "meta + 89"],
  copyToClipboard: ["ctrl + 67", "meta + 89"]
}, A$e = {
  keyBlock: function(r) {
    r.stopPropagation(), r.preventDefault();
  },
  scrollPageUp: function(r) {
    var e = this.table.rowManager, t = e.scrollTop - e.element.clientHeight;
    r.preventDefault(), e.displayRowsCount && (t >= 0 ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[0])), this.table.element.focus();
  },
  scrollPageDown: function(r) {
    var e = this.table.rowManager, t = e.scrollTop + e.element.clientHeight, i = e.element.scrollHeight;
    r.preventDefault(), e.displayRowsCount && (t <= i ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1])), this.table.element.focus();
  },
  scrollToStart: function(r) {
    var e = this.table.rowManager;
    r.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[0]), this.table.element.focus();
  },
  scrollToEnd: function(r) {
    var e = this.table.rowManager;
    r.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1]), this.table.element.focus();
  },
  navPrev: function(r) {
    this.dispatch("keybinding-nav-prev", r);
  },
  navNext: function(r) {
    this.dispatch("keybinding-nav-next", r);
  },
  navLeft: function(r) {
    this.dispatch("keybinding-nav-left", r);
  },
  navRight: function(r) {
    this.dispatch("keybinding-nav-right", r);
  },
  navUp: function(r) {
    this.dispatch("keybinding-nav-up", r);
  },
  navDown: function(r) {
    this.dispatch("keybinding-nav-down", r);
  },
  undo: function(r) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (r.preventDefault(), this.table.modules.history.undo()));
  },
  redo: function(r) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (r.preventDefault(), this.table.modules.history.redo()));
  },
  copyToClipboard: function(r) {
    this.table.modules.edit.currentCell || this.table.modExists("clipboard", !0) && this.table.modules.clipboard.copy(!1, !0);
  }
};
class Go extends pt {
  constructor(e) {
    super(e), this.watchKeys = null, this.pressedKeys = null, this.keyupBinding = !1, this.keydownBinding = !1, this.registerTableOption("keybindings", {}), this.registerTableOption("tabEndNewRow", !1);
  }
  initialize() {
    var e = this.table.options.keybindings, t = {};
    this.watchKeys = {}, this.pressedKeys = [], e !== !1 && (Object.assign(t, Go.bindings), Object.assign(t, e), this.mapBindings(t), this.bindEvents()), this.subscribe("table-destroy", this.clearBindings.bind(this));
  }
  mapBindings(e) {
    for (let t in e)
      Go.actions[t] ? e[t] && (typeof e[t] != "object" && (e[t] = [e[t]]), e[t].forEach((i) => {
        var n = Array.isArray(i) ? i : [i];
        n.forEach((a) => {
          this.mapBinding(t, a);
        });
      })) : console.warn("Key Binding Error - no such action:", t);
  }
  mapBinding(e, t) {
    var i = {
      action: Go.actions[e],
      keys: [],
      ctrl: !1,
      shift: !1,
      meta: !1
    }, n = t.toString().toLowerCase().split(" ").join("").split("+");
    n.forEach((a) => {
      switch (a) {
        case "ctrl":
          i.ctrl = !0;
          break;
        case "shift":
          i.shift = !0;
          break;
        case "meta":
          i.meta = !0;
          break;
        default:
          a = isNaN(a) ? a.toUpperCase().charCodeAt(0) : parseInt(a), i.keys.push(a), this.watchKeys[a] || (this.watchKeys[a] = []), this.watchKeys[a].push(i);
      }
    });
  }
  bindEvents() {
    var e = this;
    this.keyupBinding = function(t) {
      var i = t.keyCode, n = e.watchKeys[i];
      n && (e.pressedKeys.push(i), n.forEach(function(a) {
        e.checkBinding(t, a);
      }));
    }, this.keydownBinding = function(t) {
      var i = t.keyCode, n = e.watchKeys[i];
      if (n) {
        var a = e.pressedKeys.indexOf(i);
        a > -1 && e.pressedKeys.splice(a, 1);
      }
    }, this.table.element.addEventListener("keydown", this.keyupBinding), this.table.element.addEventListener("keyup", this.keydownBinding);
  }
  clearBindings() {
    this.keyupBinding && this.table.element.removeEventListener("keydown", this.keyupBinding), this.keydownBinding && this.table.element.removeEventListener("keyup", this.keydownBinding);
  }
  checkBinding(e, t) {
    var i = !0;
    return e.ctrlKey == t.ctrl && e.shiftKey == t.shift && e.metaKey == t.meta ? (t.keys.forEach((n) => {
      var a = this.pressedKeys.indexOf(n);
      a == -1 && (i = !1);
    }), i && t.action.call(this, e), !0) : !1;
  }
}
Go.moduleName = "keybindings";
Go.bindings = R$e;
Go.actions = A$e;
class p8 extends pt {
  constructor(e) {
    super(e), this.menuContainer = null, this.nestedMenuBlock = !1, this.currentComponent = null, this.rootPopup = null, this.columnSubscribers = {}, this.registerTableOption("menuContainer", void 0), this.registerTableOption("rowContextMenu", !1), this.registerTableOption("rowClickMenu", !1), this.registerTableOption("rowDblClickMenu", !1), this.registerTableOption("groupContextMenu", !1), this.registerTableOption("groupClickMenu", !1), this.registerTableOption("groupDblClickMenu", !1), this.registerColumnOption("headerContextMenu"), this.registerColumnOption("headerClickMenu"), this.registerColumnOption("headerDblClickMenu"), this.registerColumnOption("headerMenu"), this.registerColumnOption("headerMenuIcon"), this.registerColumnOption("contextMenu"), this.registerColumnOption("clickMenu"), this.registerColumnOption("dblClickMenu");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("menuContainer", "popupContainer") || (this.table.options.popupContainer = this.table.options.menuContainer);
  }
  initializeRowWatchers() {
    this.table.options.rowContextMenu && (this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu)), this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu))), this.table.options.rowClickMenu && this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu)), this.table.options.rowDblClickMenu && this.subscribe("row-dblclick", this.loadMenuEvent.bind(this, this.table.options.rowDblClickMenu));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextMenu && (this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu)), this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu))), this.table.options.groupClickMenu && this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu)), this.table.options.groupDblClickMenu && this.subscribe("group-dblclick", this.loadMenuEvent.bind(this, this.table.options.groupDblClickMenu));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextMenu && !this.columnSubscribers.headerContextMenu && (this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu), this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"))), t.headerClickMenu && !this.columnSubscribers.headerClickMenu && (this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu"), this.subscribe("column-click", this.columnSubscribers.headerClickMenu)), t.headerDblClickMenu && !this.columnSubscribers.headerDblClickMenu && (this.columnSubscribers.headerDblClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerDblClickMenu"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickMenu)), t.headerMenu && this.initializeColumnHeaderMenu(e), t.contextMenu && !this.columnSubscribers.contextMenu && (this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu), this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"))), t.clickMenu && !this.columnSubscribers.clickMenu && (this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu"), this.subscribe("cell-click", this.columnSubscribers.clickMenu)), t.dblClickMenu && !this.columnSubscribers.dblClickMenu && (this.columnSubscribers.dblClickMenu = this.loadMenuTableCellEvent.bind(this, "dblClickMenu"), this.subscribe("cell-dblclick", this.columnSubscribers.dblClickMenu));
  }
  initializeColumnHeaderMenu(e) {
    var t = e.definition.headerMenuIcon, i;
    i = document.createElement("span"), i.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? i.appendChild(t) : i.innerHTML = t) : i.innerHTML = "&vellip;", i.addEventListener("click", (n) => {
      n.stopPropagation(), n.preventDefault(), this.loadMenuEvent(e.definition.headerMenu, n, e);
    }), e.titleElement.insertBefore(i, e.titleElement.firstChild);
  }
  loadMenuTableCellEvent(e, t, i) {
    i._cell && (i = i._cell), i.column.definition[e] && this.loadMenuEvent(i.column.definition[e], t, i);
  }
  loadMenuTableColumnEvent(e, t, i) {
    i._column && (i = i._column), i.definition[e] && this.loadMenuEvent(i.definition[e], t, i);
  }
  loadMenuEvent(e, t, i) {
    i._group ? i = i._group : i._row && (i = i._row), e = typeof e == "function" ? e.call(this.table, t, i.getComponent()) : e, this.loadMenu(t, i, e);
  }
  loadMenu(e, t, i, n, a) {
    var o = !(e instanceof MouseEvent), s = document.createElement("div"), l;
    if (s.classList.add("tabulator-menu"), o || e.preventDefault(), !(!i || !i.length)) {
      if (n)
        l = a.child(s);
      else {
        if (this.nestedMenuBlock) {
          if (this.rootPopup)
            return;
        } else
          this.nestedMenuBlock = setTimeout(() => {
            this.nestedMenuBlock = !1;
          }, 100);
        this.rootPopup && this.rootPopup.hide(), this.rootPopup = l = this.popup(s);
      }
      i.forEach((u) => {
        var h = document.createElement("div"), c = u.label, f = u.disabled;
        u.separator ? h.classList.add("tabulator-menu-separator") : (h.classList.add("tabulator-menu-item"), typeof c == "function" && (c = c.call(this.table, t.getComponent())), c instanceof Node ? h.appendChild(c) : h.innerHTML = c, typeof f == "function" && (f = f.call(this.table, t.getComponent())), f ? (h.classList.add("tabulator-menu-item-disabled"), h.addEventListener("click", (d) => {
          d.stopPropagation();
        })) : u.menu && u.menu.length ? h.addEventListener("click", (d) => {
          d.stopPropagation(), this.loadMenu(d, t, u.menu, h, l);
        }) : u.action && h.addEventListener("click", (d) => {
          u.action(d, t.getComponent());
        }), u.menu && u.menu.length && h.classList.add("tabulator-menu-item-submenu")), s.appendChild(h);
      }), s.addEventListener("click", (u) => {
        this.rootPopup && this.rootPopup.hide();
      }), l.show(n || e), l === this.rootPopup && (this.rootPopup.hideOnBlur(() => {
        this.rootPopup = null, this.currentComponent && (this.dispatchExternal("menuClosed", this.currentComponent.getComponent()), this.currentComponent = null);
      }), this.currentComponent = t, this.dispatchExternal("menuOpened", t.getComponent()));
    }
  }
}
p8.moduleName = "menu";
class MP extends pt {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 250, this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.startX = 0, this.autoScrollMargin = 40, this.autoScrollStep = 5, this.autoScrollTimeout = !1, this.touchMove = !1, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.registerTableOption("movableColumns", !1);
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col"), e.classList.add("tabulator-col-placeholder"), e;
  }
  initialize() {
    this.table.options.movableColumns && this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  initializeColumn(e) {
    var t = this, i = {}, n;
    !e.modules.frozen && !e.isGroup && (n = e.getElement(), i.mousemove = (function(a) {
      e.parent === t.moving.parent && ((t.touchMove ? a.touches[0].pageX : a.pageX) - Wt.elOffset(n).left + t.table.columnManager.contentsElement.scrollLeft > e.getWidth() / 2 ? (t.toCol !== e || !t.toColAfter) && (n.parentNode.insertBefore(t.placeholderElement, n.nextSibling), t.moveColumn(e, !0)) : (t.toCol !== e || t.toColAfter) && (n.parentNode.insertBefore(t.placeholderElement, n), t.moveColumn(e, !1)));
    }).bind(t), n.addEventListener("mousedown", function(a) {
      t.touchMove = !1, a.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(a, e);
      }, t.checkPeriod));
    }), n.addEventListener("mouseup", function(a) {
      a.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), t.bindTouchEvents(e)), e.modules.moveColumn = i;
  }
  bindTouchEvents(e) {
    var t = e.getElement(), i = !1, n, a, o, s, l, u;
    t.addEventListener("touchstart", (h) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, n = e.nextColumn(), o = n ? n.getWidth() / 2 : 0, a = e.prevColumn(), s = a ? a.getWidth() / 2 : 0, l = 0, u = 0, i = !1, this.startMove(h, e);
      }, this.checkPeriod);
    }, { passive: !0 }), t.addEventListener("touchmove", (h) => {
      var c, f;
      this.moving && (this.moveHover(h), i || (i = h.touches[0].pageX), c = h.touches[0].pageX - i, c > 0 ? n && c - l > o && (f = n, f !== e && (i = h.touches[0].pageX, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement().nextSibling), this.moveColumn(f, !0))) : a && -c - u > s && (f = a, f !== e && (i = h.touches[0].pageX, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement()), this.moveColumn(f, !1))), f && (n = f.nextColumn(), l = o, o = n ? n.getWidth() / 2 : 0, a = f.prevColumn(), u = s, s = a ? a.getWidth() / 2 : 0));
    }, { passive: !0 }), t.addEventListener("touchend", (h) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && this.endMove(h);
    });
  }
  startMove(e, t) {
    var i = t.getElement(), n = this.table.columnManager.getContentsElement(), a = this.table.columnManager.getHeadersElement();
    this.moving = t, this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - Wt.elOffset(i).left, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", i.parentNode.insertBefore(this.placeholderElement, i), i.parentNode.removeChild(i), this.hoverElement = i.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), n.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.bottom = n.clientHeight - a.offsetHeight + "px", this.touchMove || (this._bindMouseMove(), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove)), this.moveHover(e);
  }
  _bindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  moveColumn(e, t) {
    var i = this.moving.getCells();
    this.toCol = e, this.toColAfter = t, t ? e.getCells().forEach(function(n, a) {
      var o = n.getElement(!0);
      o.parentNode && i[a] && o.parentNode.insertBefore(i[a].getElement(), o.nextSibling);
    }) : e.getCells().forEach(function(n, a) {
      var o = n.getElement(!0);
      o.parentNode && i[a] && o.parentNode.insertBefore(i[a].getElement(), o);
    });
  }
  endMove(e) {
    (e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toCol && this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter), this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.touchMove || (document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove)));
  }
  moveHover(e) {
    var t = this.table.columnManager.getContentsElement(), i = t.scrollLeft, n = (this.touchMove ? e.touches[0].pageX : e.pageX) - Wt.elOffset(t).left + i, a;
    this.hoverElement.style.left = n - this.startX + "px", n - i < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      a = Math.max(0, i - 5), this.table.rowManager.getElement().scrollLeft = a, this.autoScrollTimeout = !1;
    }, 1))), i + t.clientWidth - n < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      a = Math.min(t.clientWidth, i + 5), this.table.rowManager.getElement().scrollLeft = a, this.autoScrollTimeout = !1;
    }, 1)));
  }
}
MP.moduleName = "moveColumn";
class pv extends pt {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 150, this.moving = !1, this.toRow = !1, this.toRowAfter = !1, this.hasHandle = !1, this.startY = 0, this.startX = 0, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.tableRowDropEvent = !1, this.touchMove = !1, this.connection = !1, this.connectionSelectorsTables = !1, this.connectionSelectorsElements = !1, this.connectionElements = [], this.connections = [], this.connectedTable = !1, this.connectedRow = !1, this.registerTableOption("movableRows", !1), this.registerTableOption("movableRowsConnectedTables", !1), this.registerTableOption("movableRowsConnectedElements", !1), this.registerTableOption("movableRowsSender", !1), this.registerTableOption("movableRowsReceiver", "insert"), this.registerColumnOption("rowHandle");
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-row"), e.classList.add("tabulator-row-placeholder"), e;
  }
  initialize() {
    this.table.options.movableRows && (this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables, this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements, this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements, this.subscribe("cell-init", this.initializeCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)));
  }
  initializeGroupHeader(e) {
    var t = this, i = {};
    i.mouseup = (function(n) {
      t.tableRowDrop(n, e);
    }).bind(t), i.mousemove = (function(n) {
      var a;
      n.pageY - Wt.elOffset(e.element).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (a = e.getElement(), a.parentNode.insertBefore(t.placeholderElement, a.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (a = e.getElement(), a.previousSibling && (a.parentNode.insertBefore(t.placeholderElement, a), t.moveRow(e, !1)));
    }).bind(t), e.modules.moveRow = i;
  }
  initializeRow(e) {
    var t = this, i = {}, n;
    i.mouseup = (function(a) {
      t.tableRowDrop(a, e);
    }).bind(t), i.mousemove = (function(a) {
      var o = e.getElement();
      a.pageY - Wt.elOffset(o).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (o.parentNode.insertBefore(t.placeholderElement, o.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (o.parentNode.insertBefore(t.placeholderElement, o), t.moveRow(e, !1));
    }).bind(t), this.hasHandle || (n = e.getElement(), n.addEventListener("mousedown", function(a) {
      a.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(a, e);
      }, t.checkPeriod));
    }), n.addEventListener("mouseup", function(a) {
      a.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), this.bindTouchEvents(e, e.getElement())), e.modules.moveRow = i;
  }
  initializeColumn(e) {
    e.definition.rowHandle && this.table.options.movableRows !== !1 && (this.hasHandle = !0);
  }
  initializeCell(e) {
    if (e.column.definition.rowHandle && this.table.options.movableRows !== !1) {
      var t = this, i = e.getElement(!0);
      i.addEventListener("mousedown", function(n) {
        n.which === 1 && (t.checkTimeout = setTimeout(function() {
          t.startMove(n, e.row);
        }, t.checkPeriod));
      }), i.addEventListener("mouseup", function(n) {
        n.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
      }), this.bindTouchEvents(e.row, i);
    }
  }
  bindTouchEvents(e, t) {
    var i = !1, n, a, o, s, l, u;
    t.addEventListener("touchstart", (h) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, n = e.nextRow(), o = n ? n.getHeight() / 2 : 0, a = e.prevRow(), s = a ? a.getHeight() / 2 : 0, l = 0, u = 0, i = !1, this.startMove(h, e);
      }, this.checkPeriod);
    }, { passive: !0 }), this.moving, this.toRow, this.toRowAfter, t.addEventListener("touchmove", (h) => {
      var c, f;
      this.moving && (h.preventDefault(), this.moveHover(h), i || (i = h.touches[0].pageY), c = h.touches[0].pageY - i, c > 0 ? n && c - l > o && (f = n, f !== e && (i = h.touches[0].pageY, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement().nextSibling), this.moveRow(f, !0))) : a && -c - u > s && (f = a, f !== e && (i = h.touches[0].pageY, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement()), this.moveRow(f, !1))), f && (n = f.nextRow(), l = o, o = n ? n.getHeight() / 2 : 0, a = f.prevRow(), u = s, s = a ? a.getHeight() / 2 : 0));
    }), t.addEventListener("touchend", (h) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && (this.endMove(h), this.touchMove = !1);
    });
  }
  _bindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  startMove(e, t) {
    var i = t.getElement();
    this.setStartPosition(e, t), this.moving = t, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", this.connection ? (this.table.element.classList.add("tabulator-movingrow-sending"), this.connectToTables(t)) : (i.parentNode.insertBefore(this.placeholderElement, i), i.parentNode.removeChild(i)), this.hoverElement = i.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), this.connection ? (document.body.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this.hoverElement.style.width = this.table.element.clientWidth + "px", this.hoverElement.style.whiteSpace = "nowrap", this.hoverElement.style.overflow = "hidden", this.hoverElement.style.pointerEvents = "none") : (this.table.rowManager.getTableElement().appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this._bindMouseMove()), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove), this.dispatchExternal("rowMoving", t.getComponent()), this.moveHover(e);
  }
  setStartPosition(e, t) {
    var i = this.touchMove ? e.touches[0].pageX : e.pageX, n = this.touchMove ? e.touches[0].pageY : e.pageY, a, o;
    a = t.getElement(), this.connection ? (o = a.getBoundingClientRect(), this.startX = o.left - i + window.pageXOffset, this.startY = o.top - n + window.pageYOffset) : this.startY = n - a.getBoundingClientRect().top;
  }
  endMove(e) {
    (!e || e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.connection || (this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement)), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toRow ? this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter) : this.dispatchExternal("rowMoveCancelled", this.moving.getComponent()), this.moving = !1, this.toRow = !1, this.toRowAfter = !1, document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove), this.connection && (this.table.element.classList.remove("tabulator-movingrow-sending"), this.disconnectFromTables()));
  }
  moveRow(e, t) {
    this.toRow = e, this.toRowAfter = t;
  }
  moveHover(e) {
    this.connection ? this.moveHoverConnections.call(this, e) : this.moveHoverTable.call(this, e);
  }
  moveHoverTable(e) {
    var t = this.table.rowManager.getElement(), i = t.scrollTop, n = (this.touchMove ? e.touches[0].pageY : e.pageY) - t.getBoundingClientRect().top + i;
    this.hoverElement.style.top = Math.min(n - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
  }
  moveHoverConnections(e) {
    this.hoverElement.style.left = this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX) + "px", this.hoverElement.style.top = this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY) + "px";
  }
  elementRowDrop(e, t, i) {
    this.dispatchExternal("movableRowsElementDrop", e, t, i ? i.getComponent() : !1);
  }
  //establish connection with other tables
  connectToTables(e) {
    var t;
    this.connectionSelectorsTables && (t = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStart", t), this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
      row: e
    })), this.connectionSelectorsElements && (this.connectionElements = [], Array.isArray(this.connectionSelectorsElements) || (this.connectionSelectorsElements = [this.connectionSelectorsElements]), this.connectionSelectorsElements.forEach((i) => {
      typeof i == "string" ? this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(i))) : this.connectionElements.push(i);
    }), this.connectionElements.forEach((i) => {
      var n = (a) => {
        this.elementRowDrop(a, i, this.moving);
      };
      i.addEventListener("mouseup", n), i.tabulatorElementDropEvent = n, i.classList.add("tabulator-movingrow-receiving");
    }));
  }
  //disconnect from other tables
  disconnectFromTables() {
    var e;
    this.connectionSelectorsTables && (e = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStop", e), this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect")), this.connectionElements.forEach((t) => {
      t.classList.remove("tabulator-movingrow-receiving"), t.removeEventListener("mouseup", t.tabulatorElementDropEvent), delete t.tabulatorElementDropEvent;
    });
  }
  //accept incomming connection
  connect(e, t) {
    return this.connectedTable ? (console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable), !1) : (this.connectedTable = e, this.connectedRow = t, this.table.element.classList.add("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((i) => {
      i.type === "row" && i.modules.moveRow && i.modules.moveRow.mouseup && i.getElement().addEventListener("mouseup", i.modules.moveRow.mouseup);
    }), this.tableRowDropEvent = this.tableRowDrop.bind(this), this.table.element.addEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStart", t, e), !0);
  }
  //close incoming connection
  disconnect(e) {
    e === this.connectedTable ? (this.connectedTable = !1, this.connectedRow = !1, this.table.element.classList.remove("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((t) => {
      t.type === "row" && t.modules.moveRow && t.modules.moveRow.mouseup && t.getElement().removeEventListener("mouseup", t.modules.moveRow.mouseup);
    }), this.table.element.removeEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStop", e)) : console.warn("Move Row Error - trying to disconnect from non connected table");
  }
  dropComplete(e, t, i) {
    var n = !1;
    if (i) {
      switch (typeof this.table.options.movableRowsSender) {
        case "string":
          n = this.senders[this.table.options.movableRowsSender];
          break;
        case "function":
          n = this.table.options.movableRowsSender;
          break;
      }
      n ? n.call(this, this.moving ? this.moving.getComponent() : void 0, t ? t.getComponent() : void 0, e) : this.table.options.movableRowsSender && console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender), this.dispatchExternal("movableRowsSent", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    } else
      this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    this.endMove();
  }
  tableRowDrop(e, t) {
    var i = !1, n = !1;
    switch (e.stopImmediatePropagation(), typeof this.table.options.movableRowsReceiver) {
      case "string":
        i = this.receivers[this.table.options.movableRowsReceiver];
        break;
      case "function":
        i = this.table.options.movableRowsReceiver;
        break;
    }
    i ? n = i.call(this, this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver), n ? this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable), this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
      row: t,
      success: n
    });
  }
  commsReceived(e, t, i) {
    switch (t) {
      case "connect":
        return this.connect(e, i.row);
      case "disconnect":
        return this.disconnect(e);
      case "dropcomplete":
        return this.dropComplete(e, i.row, i.success);
    }
  }
}
pv.prototype.receivers = {
  insert: function(r, e, t) {
    return this.table.addRow(r.getData(), void 0, e), !0;
  },
  add: function(r, e, t) {
    return this.table.addRow(r.getData()), !0;
  },
  update: function(r, e, t) {
    return e ? (e.update(r.getData()), !0) : !1;
  },
  replace: function(r, e, t) {
    return e ? (this.table.addRow(r.getData(), void 0, e), e.delete(), !0) : !1;
  }
};
pv.prototype.senders = {
  delete: function(r, e, t) {
    r.delete();
  }
};
pv.moduleName = "moveRow";
var C$e = {};
class dh extends pt {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "edit", "clipboard"], this.enabled = !0, this.registerColumnOption("mutator"), this.registerColumnOption("mutatorParams"), this.registerColumnOption("mutatorData"), this.registerColumnOption("mutatorDataParams"), this.registerColumnOption("mutatorEdit"), this.registerColumnOption("mutatorEditParams"), this.registerColumnOption("mutatorClipboard"), this.registerColumnOption("mutatorClipboardParams"), this.registerColumnOption("mutateLink");
  }
  initialize() {
    this.subscribe("cell-value-changing", this.transformCell.bind(this)), this.subscribe("cell-value-changed", this.mutateLink.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-init-before", this.rowDataChanged.bind(this)), this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
  }
  rowDataChanged(e, t, i) {
    return this.transformRow(t, "data", i);
  }
  //initialize column mutator
  initializeColumn(e) {
    var t = !1, i = {};
    this.allowedTypes.forEach((n) => {
      var a = "mutator" + (n.charAt(0).toUpperCase() + n.slice(1)), o;
      e.definition[a] && (o = this.lookupMutator(e.definition[a]), o && (t = !0, i[a] = {
        mutator: o,
        params: e.definition[a + "Params"] || {}
      }));
    }), t && (e.modules.mutate = i);
  }
  lookupMutator(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        dh.mutators[e] ? t = dh.mutators[e] : console.warn("Mutator Error - No such mutator found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply mutator to row
  transformRow(e, t, i) {
    var n = "mutator" + (t.charAt(0).toUpperCase() + t.slice(1)), a;
    return this.enabled && this.table.columnManager.traverse((o) => {
      var s, l, u;
      o.modules.mutate && (s = o.modules.mutate[n] || o.modules.mutate.mutator || !1, s && (a = o.getFieldValue(typeof i < "u" ? i : e), (t == "data" && !i || typeof a < "u") && (u = o.getComponent(), l = typeof s.params == "function" ? s.params(a, e, t, u) : s.params, o.setFieldValue(e, s.mutator(a, e, t, l, u)))));
    }), e;
  }
  //apply mutator to new cell value
  transformCell(e, t) {
    if (e.column.modules.mutate) {
      var i = e.column.modules.mutate.mutatorEdit || e.column.modules.mutate.mutator || !1, n = {};
      if (i)
        return n = Object.assign(n, e.row.getData()), e.column.setFieldValue(n, t), i.mutator(t, n, "edit", i.params, e.getComponent());
    }
    return t;
  }
  mutateLink(e) {
    var t = e.column.definition.mutateLink;
    t && (Array.isArray(t) || (t = [t]), t.forEach((i) => {
      var n = e.row.getCell(i);
      n && n.setValue(n.getValue(), !0, !0);
    }));
  }
  enable() {
    this.enabled = !0;
  }
  disable() {
    this.enabled = !1;
  }
}
dh.moduleName = "mutator";
dh.mutators = C$e;
function _$e(r, e, t, i, n) {
  var a = document.createElement("span"), o = document.createElement("span"), s = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), h = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (c) => {
    o.innerHTML = c;
  }), this.table.modules.localize.langBind("pagination|counter|of", (c) => {
    l.innerHTML = c;
  }), this.table.modules.localize.langBind("pagination|counter|rows", (c) => {
    h.innerHTML = c;
  }), i ? (s.innerHTML = " " + e + "-" + Math.min(e + r - 1, i) + " ", u.innerHTML = " " + i + " ", a.appendChild(o), a.appendChild(s), a.appendChild(l), a.appendChild(u), a.appendChild(h)) : (s.innerHTML = " 0 ", a.appendChild(o), a.appendChild(s), a.appendChild(h)), a;
}
function I$e(r, e, t, i, n) {
  var a = document.createElement("span"), o = document.createElement("span"), s = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), h = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (c) => {
    o.innerHTML = c;
  }), s.innerHTML = " " + t + " ", this.table.modules.localize.langBind("pagination|counter|of", (c) => {
    l.innerHTML = c;
  }), u.innerHTML = " " + n + " ", this.table.modules.localize.langBind("pagination|counter|pages", (c) => {
    h.innerHTML = c;
  }), a.appendChild(o), a.appendChild(s), a.appendChild(l), a.appendChild(u), a.appendChild(h), a;
}
var x$e = {
  rows: _$e,
  pages: I$e
};
class $f extends pt {
  constructor(e) {
    super(e), this.mode = "local", this.progressiveLoad = !1, this.element = null, this.pageCounterElement = null, this.pageCounter = null, this.size = 0, this.page = 1, this.count = 5, this.max = 1, this.remoteRowCountEstimate = null, this.initialLoad = !0, this.dataChanging = !1, this.pageSizes = [], this.registerTableOption("pagination", !1), this.registerTableOption("paginationMode", "local"), this.registerTableOption("paginationSize", !1), this.registerTableOption("paginationInitialPage", 1), this.registerTableOption("paginationCounter", !1), this.registerTableOption("paginationCounterElement", !1), this.registerTableOption("paginationButtonCount", 5), this.registerTableOption("paginationSizeSelector", !1), this.registerTableOption("paginationElement", !1), this.registerTableOption("paginationAddRow", "page"), this.registerTableOption("progressiveLoad", !1), this.registerTableOption("progressiveLoadDelay", 0), this.registerTableOption("progressiveLoadScrollMargin", 0), this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this)), this.registerTableFunction("setPage", this.setPage.bind(this)), this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this)), this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this)), this.registerTableFunction("getPageSize", this.getPageSize.bind(this)), this.registerTableFunction("previousPage", this.previousPage.bind(this)), this.registerTableFunction("nextPage", this.nextPage.bind(this)), this.registerTableFunction("getPage", this.getPage.bind(this)), this.registerTableFunction("getPageMax", this.getPageMax.bind(this)), this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
  }
  initialize() {
    this.table.options.pagination ? (this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("footer-redraw", this.footerRedraw.bind(this)), this.table.options.paginationAddRow == "page" && this.subscribe("row-adding-position", this.rowAddingPosition.bind(this)), this.table.options.paginationMode === "remote" && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this))), this.table.options.progressiveLoad && console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time"), this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40), this.registerDisplayHandler(this.getRows.bind(this), 50), this.createElements(), this.initializePageCounter(), this.initializePaginator()) : this.table.options.progressiveLoad && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.initializeProgressive(this.table.options.progressiveLoad), this.table.options.progressiveLoad === "scroll" && this.subscribe("scroll-vertical", this.scrollVertical.bind(this)));
  }
  rowAddingPosition(e, t) {
    var i = this.table.rowManager, n = i.getDisplayRows(), a;
    return t ? n.length ? a = n[0] : i.activeRows.length && (a = i.activeRows[i.activeRows.length - 1], t = !1) : n.length && (a = n[n.length - 1], t = !(n.length < this.size)), { index: a, top: t };
  }
  calculatePageSizes() {
    var e, t;
    this.table.options.paginationSize ? this.size = this.table.options.paginationSize : (e = document.createElement("div"), e.classList.add("tabulator-row"), e.style.visibility = "hidden", t = document.createElement("div"), t.classList.add("tabulator-cell"), t.innerHTML = "Page Row Test", e.appendChild(t), this.table.rowManager.getTableElement().appendChild(e), this.size = Math.floor(this.table.rowManager.getElement().clientHeight / e.offsetHeight), this.table.rowManager.getTableElement().removeChild(e)), this.dispatchExternal("pageSizeChanged", this.size), this.generatePageSizeSelectList();
  }
  initialLoadComplete() {
    this.initialLoad = !1;
  }
  remotePageParams(e, t, i, n) {
    return this.initialLoad || (this.progressiveLoad && !i || !this.progressiveLoad && !this.dataChanging) && this.reset(!0), n.page = this.page, this.size && (n.size = this.size), n;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetPageToRow(e) {
    return this.table.options.pagination && (e = this.rowManager.findRow(e), e) ? this.setPageToRow(e) : Promise.reject();
  }
  userSetPageSize(e) {
    return this.table.options.pagination ? (this.setPageSize(e), this.setPage(1)) : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  scrollVertical(e, t) {
    var i, n, a;
    !t && !this.table.dataLoader.loading && (i = this.table.rowManager.getElement(), n = i.scrollHeight - i.clientHeight - e, a = this.table.options.progressiveLoadScrollMargin || i.clientHeight * 2, n < a && this.nextPage().catch(() => {
    }));
  }
  restOnRenderBefore(e, t) {
    return t || this.mode === "local" && this.reset(), e;
  }
  rowsUpdated() {
    this.refreshData(!0, "all");
  }
  createElements() {
    var e;
    this.element = document.createElement("span"), this.element.classList.add("tabulator-paginator"), this.pagesElement = document.createElement("span"), this.pagesElement.classList.add("tabulator-pages"), e = document.createElement("button"), e.classList.add("tabulator-page"), e.setAttribute("type", "button"), e.setAttribute("role", "button"), e.setAttribute("aria-label", ""), e.setAttribute("title", ""), this.firstBut = e.cloneNode(!0), this.firstBut.setAttribute("data-page", "first"), this.prevBut = e.cloneNode(!0), this.prevBut.setAttribute("data-page", "prev"), this.nextBut = e.cloneNode(!0), this.nextBut.setAttribute("data-page", "next"), this.lastBut = e.cloneNode(!0), this.lastBut.setAttribute("data-page", "last"), this.table.options.paginationSizeSelector && (this.pageSizeSelect = document.createElement("select"), this.pageSizeSelect.classList.add("tabulator-page-size"));
  }
  generatePageSizeSelectList() {
    var e = [];
    if (this.pageSizeSelect) {
      if (Array.isArray(this.table.options.paginationSizeSelector))
        e = this.table.options.paginationSizeSelector, this.pageSizes = e, this.pageSizes.indexOf(this.size) == -1 && e.unshift(this.size);
      else if (this.pageSizes.indexOf(this.size) == -1) {
        e = [];
        for (let t = 1; t < 5; t++)
          e.push(this.size * t);
        this.pageSizes = e;
      } else
        e = this.pageSizes;
      for (; this.pageSizeSelect.firstChild; )
        this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
      e.forEach((t) => {
        var i = document.createElement("option");
        i.value = t, t === !0 ? this.langBind("pagination|all", function(n) {
          i.innerHTML = n;
        }) : i.innerHTML = t, this.pageSizeSelect.appendChild(i);
      }), this.pageSizeSelect.value = this.size;
    }
  }
  initializePageCounter() {
    var e = this.table.options.paginationCounter, t = null;
    e && (typeof e == "function" ? t = e : t = $f.pageCounters[e], t ? (this.pageCounter = t, this.pageCounterElement = document.createElement("span"), this.pageCounterElement.classList.add("tabulator-page-counter")) : console.warn("Pagination Error - No such page counter found: ", e));
  }
  //setup pagination
  initializePaginator(e) {
    var t, i;
    e || (this.langBind("pagination|first", (n) => {
      this.firstBut.innerHTML = n;
    }), this.langBind("pagination|first_title", (n) => {
      this.firstBut.setAttribute("aria-label", n), this.firstBut.setAttribute("title", n);
    }), this.langBind("pagination|prev", (n) => {
      this.prevBut.innerHTML = n;
    }), this.langBind("pagination|prev_title", (n) => {
      this.prevBut.setAttribute("aria-label", n), this.prevBut.setAttribute("title", n);
    }), this.langBind("pagination|next", (n) => {
      this.nextBut.innerHTML = n;
    }), this.langBind("pagination|next_title", (n) => {
      this.nextBut.setAttribute("aria-label", n), this.nextBut.setAttribute("title", n);
    }), this.langBind("pagination|last", (n) => {
      this.lastBut.innerHTML = n;
    }), this.langBind("pagination|last_title", (n) => {
      this.lastBut.setAttribute("aria-label", n), this.lastBut.setAttribute("title", n);
    }), this.firstBut.addEventListener("click", () => {
      this.setPage(1);
    }), this.prevBut.addEventListener("click", () => {
      this.previousPage();
    }), this.nextBut.addEventListener("click", () => {
      this.nextPage();
    }), this.lastBut.addEventListener("click", () => {
      this.setPage(this.max);
    }), this.table.options.paginationElement && (this.element = this.table.options.paginationElement), this.pageSizeSelect && (t = document.createElement("label"), this.langBind("pagination|page_size", (n) => {
      this.pageSizeSelect.setAttribute("aria-label", n), this.pageSizeSelect.setAttribute("title", n), t.innerHTML = n;
    }), this.element.appendChild(t), this.element.appendChild(this.pageSizeSelect), this.pageSizeSelect.addEventListener("change", (n) => {
      this.setPageSize(this.pageSizeSelect.value == "true" ? !0 : this.pageSizeSelect.value), this.setPage(1);
    })), this.element.appendChild(this.firstBut), this.element.appendChild(this.prevBut), this.element.appendChild(this.pagesElement), this.element.appendChild(this.nextBut), this.element.appendChild(this.lastBut), this.table.options.paginationElement || (this.table.options.paginationCounter && (this.table.options.paginationCounterElement ? this.table.options.paginationCounterElement instanceof HTMLElement ? this.table.options.paginationCounterElement.appendChild(this.pageCounterElement) : typeof this.table.options.paginationCounterElement == "string" && (i = document.querySelector(this.table.options.paginationCounterElement), i ? i.appendChild(this.pageCounterElement) : console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement)) : this.footerAppend(this.pageCounterElement)), this.footerAppend(this.element)), this.page = this.table.options.paginationInitialPage, this.count = this.table.options.paginationButtonCount), this.mode = this.table.options.paginationMode;
  }
  initializeProgressive(e) {
    this.initializePaginator(!0), this.mode = "progressive_" + e, this.progressiveLoad = !0;
  }
  trackChanges() {
    this.dispatch("page-changed");
  }
  //calculate maximum page from number of rows
  setMaxRows(e) {
    e ? this.max = this.size === !0 ? 1 : Math.ceil(e / this.size) : this.max = 1, this.page > this.max && (this.page = this.max);
  }
  //reset to first page without triggering action
  reset(e) {
    this.initialLoad || (this.mode == "local" || e) && (this.page = 1, this.trackChanges());
  }
  //set the maximum page
  setMaxPage(e) {
    e = parseInt(e), this.max = e || 1, this.page > this.max && (this.page = this.max, this.trigger());
  }
  //set current page number
  setPage(e) {
    switch (e) {
      case "first":
        return this.setPage(1);
      case "prev":
        return this.previousPage();
      case "next":
        return this.nextPage();
      case "last":
        return this.setPage(this.max);
    }
    return e = parseInt(e), e > 0 && e <= this.max || this.mode !== "local" ? (this.page = e, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", e), Promise.reject());
  }
  setPageToRow(e) {
    var t = this.displayRows(-1), i = t.indexOf(e);
    if (i > -1) {
      var n = this.size === !0 ? 1 : Math.ceil((i + 1) / this.size);
      return this.setPage(n);
    } else
      return console.warn("Pagination Error - Requested row is not visible"), Promise.reject();
  }
  setPageSize(e) {
    e !== !0 && (e = parseInt(e)), e > 0 && (this.size = e, this.dispatchExternal("pageSizeChanged", e)), this.pageSizeSelect && this.generatePageSizeSelectList(), this.trackChanges();
  }
  _setPageCounter(e, t, i) {
    var n;
    if (this.pageCounter)
      switch (this.mode === "remote" && (t = this.size, i = (this.page - 1) * this.size + 1, e = this.remoteRowCountEstimate), n = this.pageCounter.call(this, t, i, this.page, e, this.max), typeof n) {
        case "object":
          if (n instanceof Node) {
            for (; this.pageCounterElement.firstChild; )
              this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);
            this.pageCounterElement.appendChild(n);
          } else
            this.pageCounterElement.innerHTML = "", n != null && console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", n);
          break;
        case "undefined":
          this.pageCounterElement.innerHTML = "";
          break;
        default:
          this.pageCounterElement.innerHTML = n;
      }
  }
  //setup the pagination buttons
  _setPageButtons() {
    let e = Math.floor((this.count - 1) / 2), t = Math.ceil((this.count - 1) / 2), i = this.max - this.page + e + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - e, 1), n = this.page <= t ? Math.min(this.count, this.max) : Math.min(this.page + t, this.max);
    for (; this.pagesElement.firstChild; )
      this.pagesElement.removeChild(this.pagesElement.firstChild);
    this.page == 1 ? (this.firstBut.disabled = !0, this.prevBut.disabled = !0) : (this.firstBut.disabled = !1, this.prevBut.disabled = !1), this.page == this.max ? (this.lastBut.disabled = !0, this.nextBut.disabled = !0) : (this.lastBut.disabled = !1, this.nextBut.disabled = !1);
    for (let a = i; a <= n; a++)
      a > 0 && a <= this.max && this.pagesElement.appendChild(this._generatePageButton(a));
    this.footerRedraw();
  }
  _generatePageButton(e) {
    var t = document.createElement("button");
    return t.classList.add("tabulator-page"), e == this.page && t.classList.add("active"), t.setAttribute("type", "button"), t.setAttribute("role", "button"), this.langBind("pagination|page_title", (i) => {
      t.setAttribute("aria-label", i + " " + e), t.setAttribute("title", i + " " + e);
    }), t.setAttribute("data-page", e), t.textContent = e, t.addEventListener("click", (i) => {
      this.setPage(e);
    }), t;
  }
  //previous page
  previousPage() {
    return this.page > 1 ? (this.page--, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Previous page would be less than page 1:", 0), Promise.reject());
  }
  //next page
  nextPage() {
    return this.page < this.max ? (this.page++, this.trackChanges(), this.trigger()) : (this.progressiveLoad || console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1), Promise.reject());
  }
  //return current page number
  getPage() {
    return this.page;
  }
  //return max page number
  getPageMax() {
    return this.max;
  }
  getPageSize(e) {
    return this.size;
  }
  getMode() {
    return this.mode;
  }
  //return appropriate rows for current page
  getRows(e) {
    var t = 0, i, n, a, o, s = e.filter((l) => l.type === "row");
    if (this.mode == "local") {
      i = [], this.setMaxRows(e.length), this.size === !0 ? (n = 0, a = e.length) : (n = this.size * (this.page - 1), a = n + parseInt(this.size)), this._setPageButtons();
      for (let l = n; l < a; l++) {
        let u = e[l];
        u && (i.push(u), u.type === "row" && (o || (o = u), t++));
      }
      return this._setPageCounter(s.length, t, o ? s.indexOf(o) + 1 : 0), i;
    } else
      return this._setPageButtons(), this._setPageCounter(s.length), e.slice(0);
  }
  trigger() {
    var e;
    switch (this.mode) {
      case "local":
        return e = this.table.rowManager.scrollLeft, this.refreshData(), this.table.rowManager.scrollHorizontal(e), this.dispatchExternal("pageLoaded", this.getPage()), Promise.resolve();
      case "remote":
        return this.dataChanging = !0, this.reloadData(null).finally(() => {
          this.dataChanging = !1;
        });
      case "progressive_load":
      case "progressive_scroll":
        return this.reloadData(null, !0);
      default:
        return console.warn("Pagination Error - no such pagination mode:", this.mode), Promise.reject();
    }
  }
  _parseRemoteData(e) {
    var t;
    if (typeof e.last_page > "u" && console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property"), e.data)
      if (this.max = parseInt(e.last_page) || 1, this.remoteRowCountEstimate = typeof e.last_row < "u" ? e.last_row : e.last_page * this.size - (this.page == e.last_page ? this.size - e.data.length : 0), this.progressiveLoad) {
        switch (this.mode) {
          case "progressive_load":
            this.page == 1 ? this.table.rowManager.setData(e.data, !1, this.page == 1) : this.table.rowManager.addRows(e.data), this.page < this.max && setTimeout(() => {
              this.nextPage();
            }, this.table.options.progressiveLoadDelay);
            break;
          case "progressive_scroll":
            e = this.page === 1 ? e.data : this.table.rowManager.getData().concat(e.data), this.table.rowManager.setData(e, this.page !== 1, this.page == 1), t = this.table.options.progressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2, this.table.rowManager.element.scrollHeight <= this.table.rowManager.element.clientHeight + t && this.page < this.max && setTimeout(() => {
              this.nextPage();
            });
            break;
        }
        return !1;
      } else
        this.dispatchExternal("pageLoaded", this.getPage());
    else
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
    return e.data;
  }
  //handle the footer element being redrawn
  footerRedraw() {
    var e = this.table.footerManager.containerElement;
    Math.ceil(e.clientWidth) - e.scrollWidth < 0 ? this.pagesElement.style.display = "none" : (this.pagesElement.style.display = "", Math.ceil(e.clientWidth) - e.scrollWidth < 0 && (this.pagesElement.style.display = "none"));
  }
}
$f.moduleName = "page";
$f.pageCounters = x$e;
var w$e = {
  local: function(r, e) {
    var t = localStorage.getItem(r + "-" + e);
    return t ? JSON.parse(t) : !1;
  },
  cookie: function(r, e) {
    var t = document.cookie, i = r + "-" + e, n = t.indexOf(i + "="), a, o;
    return n > -1 && (t = t.slice(n), a = t.indexOf(";"), a > -1 && (t = t.slice(0, a)), o = t.replace(i + "=", "")), o ? JSON.parse(o) : !1;
  }
}, P$e = {
  local: function(r, e, t) {
    localStorage.setItem(r + "-" + e, JSON.stringify(t));
  },
  cookie: function(r, e, t) {
    var i = /* @__PURE__ */ new Date();
    i.setDate(i.getDate() + 1e4), document.cookie = r + "-" + e + "=" + JSON.stringify(t) + "; expires=" + i.toUTCString();
  }
};
class bi extends pt {
  constructor(e) {
    super(e), this.mode = "", this.id = "", this.defWatcherBlock = !1, this.config = {}, this.readFunc = !1, this.writeFunc = !1, this.registerTableOption("persistence", !1), this.registerTableOption("persistenceID", ""), this.registerTableOption("persistenceMode", !0), this.registerTableOption("persistenceReaderFunc", !1), this.registerTableOption("persistenceWriterFunc", !1);
  }
  // Test for whether localStorage is available for use.
  localStorageTest() {
    var e = "_tabulator_test";
    try {
      return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0;
    } catch {
      return !1;
    }
  }
  //setup parameters
  initialize() {
    if (this.table.options.persistence) {
      var e = this.table.options.persistenceMode, t = this.table.options.persistenceID, i;
      this.mode = e !== !0 ? e : this.localStorageTest() ? "local" : "cookie", this.table.options.persistenceReaderFunc ? typeof this.table.options.persistenceReaderFunc == "function" ? this.readFunc = this.table.options.persistenceReaderFunc : bi.readers[this.table.options.persistenceReaderFunc] ? this.readFunc = bi.readers[this.table.options.persistenceReaderFunc] : console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc) : bi.readers[this.mode] ? this.readFunc = bi.readers[this.mode] : console.warn("Persistence Read Error - invalid reader set", this.mode), this.table.options.persistenceWriterFunc ? typeof this.table.options.persistenceWriterFunc == "function" ? this.writeFunc = this.table.options.persistenceWriterFunc : bi.writers[this.table.options.persistenceWriterFunc] ? this.writeFunc = bi.writers[this.table.options.persistenceWriterFunc] : console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc) : bi.writers[this.mode] ? this.writeFunc = bi.writers[this.mode] : console.warn("Persistence Write Error - invalid writer set", this.mode), this.id = "tabulator-" + (t || this.table.element.getAttribute("id") || ""), this.config = {
        sort: this.table.options.persistence === !0 || this.table.options.persistence.sort,
        filter: this.table.options.persistence === !0 || this.table.options.persistence.filter,
        headerFilter: this.table.options.persistence === !0 || this.table.options.persistence.headerFilter,
        group: this.table.options.persistence === !0 || this.table.options.persistence.group,
        page: this.table.options.persistence === !0 || this.table.options.persistence.page,
        columns: this.table.options.persistence === !0 ? ["title", "width", "visible"] : this.table.options.persistence.columns
      }, this.config.page && (i = this.retrieveData("page"), i && (typeof i.paginationSize < "u" && (this.config.page === !0 || this.config.page.size) && (this.table.options.paginationSize = i.paginationSize), typeof i.paginationInitialPage < "u" && (this.config.page === !0 || this.config.page.page) && (this.table.options.paginationInitialPage = i.paginationInitialPage))), this.config.group && (i = this.retrieveData("group"), i && (typeof i.groupBy < "u" && (this.config.group === !0 || this.config.group.groupBy) && (this.table.options.groupBy = i.groupBy), typeof i.groupStartOpen < "u" && (this.config.group === !0 || this.config.group.groupStartOpen) && (this.table.options.groupStartOpen = i.groupStartOpen), typeof i.groupHeader < "u" && (this.config.group === !0 || this.config.group.groupHeader) && (this.table.options.groupHeader = i.groupHeader))), this.config.columns && (this.table.options.columns = this.load("columns", this.table.options.columns), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-show", this.save.bind(this, "columns")), this.subscribe("column-hide", this.save.bind(this, "columns")), this.subscribe("column-moved", this.save.bind(this, "columns"))), this.subscribe("table-built", this.tableBuilt.bind(this), 0), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("filter-changed", this.eventSave.bind(this, "filter")), this.subscribe("filter-changed", this.eventSave.bind(this, "headerFilter")), this.subscribe("sort-changed", this.eventSave.bind(this, "sort")), this.subscribe("group-changed", this.eventSave.bind(this, "group")), this.subscribe("page-changed", this.eventSave.bind(this, "page")), this.subscribe("column-resized", this.eventSave.bind(this, "columns")), this.subscribe("column-width", this.eventSave.bind(this, "columns")), this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
    }
    this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this)), this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
  }
  eventSave(e) {
    this.config[e] && this.save(e);
  }
  tableBuilt() {
    var e, t, i;
    this.config.sort && (e = this.load("sort"), e && (this.table.options.initialSort = e)), this.config.filter && (t = this.load("filter"), t && (this.table.options.initialFilter = t)), this.config.headerFilter && (i = this.load("headerFilter"), i && (this.table.options.initialHeaderFilter = i));
  }
  tableRedraw(e) {
    e && this.config.columns && this.save("columns");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  getColumnLayout() {
    return this.parseColumns(this.table.columnManager.getColumns());
  }
  setColumnLayout(e) {
    return this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, e)), !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumn(e) {
    var t, i;
    this.config.columns && (this.defWatcherBlock = !0, t = e.getDefinition(), i = this.config.columns === !0 ? Object.keys(t) : this.config.columns, i.forEach((n) => {
      var a = Object.getOwnPropertyDescriptor(t, n), o = t[n];
      a && Object.defineProperty(t, n, {
        set: (s) => {
          o = s, this.defWatcherBlock || this.save("columns"), a.set && a.set(s);
        },
        get: () => (a.get && a.get(), o)
      });
    }), this.defWatcherBlock = !1);
  }
  //load saved definitions
  load(e, t) {
    var i = this.retrieveData(e);
    return t && (i = i ? this.mergeDefinition(t, i) : t), i;
  }
  //retrieve data from memory
  retrieveData(e) {
    return this.readFunc ? this.readFunc(this.id, e) : !1;
  }
  //merge old and new column definitions
  mergeDefinition(e, t) {
    var i = [];
    return t = t || [], t.forEach((n, a) => {
      var o = this._findColumn(e, n), s;
      o && (this.config.columns === !0 || this.config.columns == null ? (s = Object.keys(o), s.push("width")) : s = this.config.columns, s.forEach((l) => {
        l !== "columns" && typeof n[l] < "u" && (o[l] = n[l]);
      }), o.columns && (o.columns = this.mergeDefinition(o.columns, n.columns)), i.push(o));
    }), e.forEach((n, a) => {
      var o = this._findColumn(t, n);
      o || (i.length > a ? i.splice(a, 0, n) : i.push(n));
    }), i;
  }
  //find matching columns
  _findColumn(e, t) {
    var i = t.columns ? "group" : t.field ? "field" : "object";
    return e.find(function(n) {
      switch (i) {
        case "group":
          return n.title === t.title && n.columns.length === t.columns.length;
        case "field":
          return n.field === t.field;
        case "object":
          return n === t;
      }
    });
  }
  //save data
  save(e) {
    var t = {};
    switch (e) {
      case "columns":
        t = this.parseColumns(this.table.columnManager.getColumns());
        break;
      case "filter":
        t = this.table.modules.filter.getFilters();
        break;
      case "headerFilter":
        t = this.table.modules.filter.getHeaderFilters();
        break;
      case "sort":
        t = this.validateSorters(this.table.modules.sort.getSort());
        break;
      case "group":
        t = this.getGroupConfig();
        break;
      case "page":
        t = this.getPageConfig();
        break;
    }
    this.writeFunc && this.writeFunc(this.id, e, t);
  }
  //ensure sorters contain no function data
  validateSorters(e) {
    return e.forEach(function(t) {
      t.column = t.field, delete t.field;
    }), e;
  }
  getGroupConfig() {
    var e = {};
    return this.config.group && ((this.config.group === !0 || this.config.group.groupBy) && (e.groupBy = this.table.options.groupBy), (this.config.group === !0 || this.config.group.groupStartOpen) && (e.groupStartOpen = this.table.options.groupStartOpen), (this.config.group === !0 || this.config.group.groupHeader) && (e.groupHeader = this.table.options.groupHeader)), e;
  }
  getPageConfig() {
    var e = {};
    return this.config.page && ((this.config.page === !0 || this.config.page.size) && (e.paginationSize = this.table.modules.page.getPageSize()), (this.config.page === !0 || this.config.page.page) && (e.paginationInitialPage = this.table.modules.page.getPage())), e;
  }
  //parse columns for data to store
  parseColumns(e) {
    var t = [], i = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];
    return e.forEach((n) => {
      var a = {}, o = n.getDefinition(), s;
      n.isGroup ? (a.title = o.title, a.columns = this.parseColumns(n.getColumns())) : (a.field = n.getField(), this.config.columns === !0 || this.config.columns == null ? (s = Object.keys(o), s.push("width"), s.push("visible")) : s = this.config.columns, s.forEach((l) => {
        switch (l) {
          case "width":
            a.width = n.getWidth();
            break;
          case "visible":
            a.visible = n.visible;
            break;
          default:
            typeof o[l] != "function" && i.indexOf(l) === -1 && (a[l] = o[l]);
        }
      })), t.push(a);
    }), t;
  }
}
bi.moduleName = "persistence";
bi.moduleInitOrder = -10;
bi.readers = w$e;
bi.writers = P$e;
class kP extends pt {
  constructor(e) {
    super(e), this.columnSubscribers = {}, this.registerTableOption("rowContextPopup", !1), this.registerTableOption("rowClickPopup", !1), this.registerTableOption("rowDblClickPopup", !1), this.registerTableOption("groupContextPopup", !1), this.registerTableOption("groupClickPopup", !1), this.registerTableOption("groupDblClickPopup", !1), this.registerColumnOption("headerContextPopup"), this.registerColumnOption("headerClickPopup"), this.registerColumnOption("headerDblClickPopup"), this.registerColumnOption("headerPopup"), this.registerColumnOption("headerPopupIcon"), this.registerColumnOption("contextPopup"), this.registerColumnOption("clickPopup"), this.registerColumnOption("dblClickPopup"), this.registerComponentFunction("cell", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("column", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("row", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("group", "popup", this._componentPopupCall.bind(this));
  }
  initialize() {
    this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  _componentPopupCall(e, t, i) {
    this.loadPopupEvent(t, null, e, i);
  }
  initializeRowWatchers() {
    this.table.options.rowContextPopup && (this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup)), this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup))), this.table.options.rowClickPopup && this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup)), this.table.options.rowDblClickPopup && this.subscribe("row-dblclick", this.loadPopupEvent.bind(this, this.table.options.rowDblClickPopup));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextPopup && (this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup)), this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup))), this.table.options.groupClickPopup && this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup)), this.table.options.groupDblClickPopup && this.subscribe("group-dblclick", this.loadPopupEvent.bind(this, this.table.options.groupDblClickPopup));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextPopup && !this.columnSubscribers.headerContextPopup && (this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup), this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"))), t.headerClickPopup && !this.columnSubscribers.headerClickPopup && (this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup"), this.subscribe("column-click", this.columnSubscribers.headerClickPopup)), t.headerDblClickPopup && !this.columnSubscribers.headerDblClickPopup && (this.columnSubscribers.headerDblClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerDblClickPopup"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickPopup)), t.headerPopup && this.initializeColumnHeaderPopup(e), t.contextPopup && !this.columnSubscribers.contextPopup && (this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup), this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"))), t.clickPopup && !this.columnSubscribers.clickPopup && (this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup"), this.subscribe("cell-click", this.columnSubscribers.clickPopup)), t.dblClickPopup && !this.columnSubscribers.dblClickPopup && (this.columnSubscribers.dblClickPopup = this.loadPopupTableCellEvent.bind(this, "dblClickPopup"), this.subscribe("cell-click", this.columnSubscribers.dblClickPopup));
  }
  initializeColumnHeaderPopup(e) {
    var t = e.definition.headerPopupIcon, i;
    i = document.createElement("span"), i.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? i.appendChild(t) : i.innerHTML = t) : i.innerHTML = "&vellip;", i.addEventListener("click", (n) => {
      n.stopPropagation(), n.preventDefault(), this.loadPopupEvent(e.definition.headerPopup, n, e);
    }), e.titleElement.insertBefore(i, e.titleElement.firstChild);
  }
  loadPopupTableCellEvent(e, t, i) {
    i._cell && (i = i._cell), i.column.definition[e] && this.loadPopupEvent(i.column.definition[e], t, i);
  }
  loadPopupTableColumnEvent(e, t, i) {
    i._column && (i = i._column), i.definition[e] && this.loadPopupEvent(i.definition[e], t, i);
  }
  loadPopupEvent(e, t, i, n) {
    var a;
    function o(s) {
      a = s;
    }
    i._group ? i = i._group : i._row && (i = i._row), e = typeof e == "function" ? e.call(this.table, t, i.getComponent(), o) : e, this.loadPopup(t, i, e, a, n);
  }
  loadPopup(e, t, i, n, a) {
    var o = !(e instanceof MouseEvent), s, l;
    i instanceof HTMLElement ? s = i : (s = document.createElement("div"), s.innerHTML = i), s.classList.add("tabulator-popup"), s.addEventListener("click", (u) => {
      u.stopPropagation();
    }), o || e.preventDefault(), l = this.popup(s), typeof n == "function" && l.renderCallback(n), e ? l.show(e) : l.show(t.getElement(), a || "center"), l.hideOnBlur(() => {
      this.dispatchExternal("popupClosed", t.getComponent());
    }), this.dispatchExternal("popupOpened", t.getComponent());
  }
}
kP.moduleName = "popup";
class QP extends pt {
  constructor(e) {
    super(e), this.element = !1, this.manualBlock = !1, this.beforeprintEventHandler = null, this.afterprintEventHandler = null, this.registerTableOption("printAsHtml", !1), this.registerTableOption("printFormatter", !1), this.registerTableOption("printHeader", !1), this.registerTableOption("printFooter", !1), this.registerTableOption("printStyled", !0), this.registerTableOption("printRowRange", "visible"), this.registerTableOption("printConfig", {}), this.registerColumnOption("print"), this.registerColumnOption("titlePrint");
  }
  initialize() {
    this.table.options.printAsHtml && (this.beforeprintEventHandler = this.replaceTable.bind(this), this.afterprintEventHandler = this.cleanup.bind(this), window.addEventListener("beforeprint", this.beforeprintEventHandler), window.addEventListener("afterprint", this.afterprintEventHandler), this.subscribe("table-destroy", this.destroy.bind(this))), this.registerTableFunction("print", this.printFullscreen.bind(this));
  }
  destroy() {
    this.table.options.printAsHtml && (window.removeEventListener("beforeprint", this.beforeprintEventHandler), window.removeEventListener("afterprint", this.afterprintEventHandler));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  replaceTable() {
    this.manualBlock || (this.element = document.createElement("div"), this.element.classList.add("tabulator-print-table"), this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print")), this.table.element.style.display = "none", this.table.element.parentNode.insertBefore(this.element, this.table.element));
  }
  cleanup() {
    document.body.classList.remove("tabulator-print-fullscreen-hide"), this.element && this.element.parentNode && (this.element.parentNode.removeChild(this.element), this.table.element.style.display = "");
  }
  printFullscreen(e, t, i) {
    var n = window.scrollX, a = window.scrollY, o = document.createElement("div"), s = document.createElement("div"), l = this.table.modules.export.generateTable(typeof i < "u" ? i : this.table.options.printConfig, typeof t < "u" ? t : this.table.options.printStyled, e || this.table.options.printRowRange, "print"), u, h;
    this.manualBlock = !0, this.element = document.createElement("div"), this.element.classList.add("tabulator-print-fullscreen"), this.table.options.printHeader && (o.classList.add("tabulator-print-header"), u = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader, typeof u == "string" ? o.innerHTML = u : o.appendChild(u), this.element.appendChild(o)), this.element.appendChild(l), this.table.options.printFooter && (s.classList.add("tabulator-print-footer"), h = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter, typeof h == "string" ? s.innerHTML = h : s.appendChild(h), this.element.appendChild(s)), document.body.classList.add("tabulator-print-fullscreen-hide"), document.body.appendChild(this.element), this.table.options.printFormatter && this.table.options.printFormatter(this.element, l), window.print(), this.cleanup(), window.scrollTo(n, a), this.manualBlock = !1;
  }
}
QP.moduleName = "print";
class UP extends pt {
  constructor(e) {
    super(e), this.data = !1, this.blocked = !1, this.origFuncs = {}, this.currentVersion = 0, this.registerTableOption("reactiveData", !1);
  }
  initialize() {
    this.table.options.reactiveData && (this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave")), this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave")), this.subscribe("row-data-save-before", this.block.bind(this, "rowsave")), this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave")), this.subscribe("row-data-init-after", this.watchRow.bind(this)), this.subscribe("data-processing", this.watchData.bind(this)), this.subscribe("table-destroy", this.unwatchData.bind(this)));
  }
  watchData(e) {
    var t = this, i;
    this.currentVersion++, i = this.currentVersion, this.unwatchData(), this.data = e, this.origFuncs.push = e.push, Object.defineProperty(this.data, "push", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n = Array.from(arguments), a;
        return !t.blocked && i === t.currentVersion && (t.block("data-push"), n.forEach((o) => {
          t.table.rowManager.addRowActual(o, !1);
        }), a = t.origFuncs.push.apply(e, arguments), t.unblock("data-push")), a;
      }
    }), this.origFuncs.unshift = e.unshift, Object.defineProperty(this.data, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n = Array.from(arguments), a;
        return !t.blocked && i === t.currentVersion && (t.block("data-unshift"), n.forEach((o) => {
          t.table.rowManager.addRowActual(o, !0);
        }), a = t.origFuncs.unshift.apply(e, arguments), t.unblock("data-unshift")), a;
      }
    }), this.origFuncs.shift = e.shift, Object.defineProperty(this.data, "shift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n, a;
        return !t.blocked && i === t.currentVersion && (t.block("data-shift"), t.data.length && (n = t.table.rowManager.getRowFromDataObject(t.data[0]), n && n.deleteActual()), a = t.origFuncs.shift.call(e), t.unblock("data-shift")), a;
      }
    }), this.origFuncs.pop = e.pop, Object.defineProperty(this.data, "pop", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n, a;
        return !t.blocked && i === t.currentVersion && (t.block("data-pop"), t.data.length && (n = t.table.rowManager.getRowFromDataObject(t.data[t.data.length - 1]), n && n.deleteActual()), a = t.origFuncs.pop.call(e), t.unblock("data-pop")), a;
      }
    }), this.origFuncs.splice = e.splice, Object.defineProperty(this.data, "splice", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n = Array.from(arguments), a = n[0] < 0 ? e.length + n[0] : n[0], o = n[1], s = n[2] ? n.slice(2) : !1, l, u;
        if (!t.blocked && i === t.currentVersion) {
          if (t.block("data-splice"), s && (l = e[a] ? t.table.rowManager.getRowFromDataObject(e[a]) : !1, l ? s.forEach((c) => {
            t.table.rowManager.addRowActual(c, !0, l, !0);
          }) : (s = s.slice().reverse(), s.forEach((c) => {
            t.table.rowManager.addRowActual(c, !0, !1, !0);
          }))), o !== 0) {
            var h = e.slice(a, typeof n[1] > "u" ? n[1] : a + o);
            h.forEach((c, f) => {
              var d = t.table.rowManager.getRowFromDataObject(c);
              d && d.deleteActual(f !== h.length - 1);
            });
          }
          (s || o !== 0) && t.table.rowManager.reRenderInPosition(), u = t.origFuncs.splice.apply(e, arguments), t.unblock("data-splice");
        }
        return u;
      }
    });
  }
  unwatchData() {
    if (this.data !== !1)
      for (var e in this.origFuncs)
        Object.defineProperty(this.data, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: this.origFuncs.key
        });
  }
  watchRow(e) {
    var t = e.getData();
    for (var i in t)
      this.watchKey(e, t, i);
    this.table.options.dataTree && this.watchTreeChildren(e);
  }
  watchTreeChildren(e) {
    var t = this, i = e.getData()[this.table.options.dataTreeChildField], n = {};
    i && (n.push = i.push, Object.defineProperty(i, "push", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-push");
          var a = n.push.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-push");
        }
        return a;
      }
    }), n.unshift = i.unshift, Object.defineProperty(i, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-unshift");
          var a = n.unshift.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-unshift");
        }
        return a;
      }
    }), n.shift = i.shift, Object.defineProperty(i, "shift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-shift");
          var a = n.shift.call(i);
          this.rebuildTree(e), t.unblock("tree-shift");
        }
        return a;
      }
    }), n.pop = i.pop, Object.defineProperty(i, "pop", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-pop");
          var a = n.pop.call(i);
          this.rebuildTree(e), t.unblock("tree-pop");
        }
        return a;
      }
    }), n.splice = i.splice, Object.defineProperty(i, "splice", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-splice");
          var a = n.splice.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-splice");
        }
        return a;
      }
    }));
  }
  rebuildTree(e) {
    this.table.modules.dataTree.initializeRow(e), this.table.modules.dataTree.layoutRow(e), this.table.rowManager.refreshActiveData("tree", !1, !0);
  }
  watchKey(e, t, i) {
    var n = this, a = Object.getOwnPropertyDescriptor(t, i), o = t[i], s = this.currentVersion;
    Object.defineProperty(t, i, {
      set: (l) => {
        if (o = l, !n.blocked && s === n.currentVersion) {
          n.block("key");
          var u = {};
          u[i] = l, e.updateData(u), n.unblock("key");
        }
        a.set && a.set(l);
      },
      get: () => (a.get && a.get(), o)
    });
  }
  unwatchRow(e) {
    var t = e.getData();
    for (var i in t)
      Object.defineProperty(t, i, {
        value: t[i]
      });
  }
  block(e) {
    this.blocked || (this.blocked = e);
  }
  unblock(e) {
    this.blocked === e && (this.blocked = !1);
  }
}
UP.moduleName = "reactiveData";
class $P extends pt {
  constructor(e) {
    super(e), this.startColumn = !1, this.startX = !1, this.startWidth = !1, this.latestX = !1, this.handle = null, this.initialNextColumn = null, this.nextColumn = null, this.initialized = !1, this.registerColumnOption("resizable", !0), this.registerTableOption("resizableColumnFit", !1);
  }
  initialize() {
    this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
  }
  initializeEventWatchers() {
    this.initialized || (this.subscribe("cell-rendered", this.layoutCellHandles.bind(this)), this.subscribe("cell-delete", this.deInitializeComponent.bind(this)), this.subscribe("cell-height", this.resizeHandle.bind(this)), this.subscribe("column-moved", this.columnLayoutUpdated.bind(this)), this.subscribe("column-hide", this.deInitializeColumn.bind(this)), this.subscribe("column-show", this.columnLayoutUpdated.bind(this)), this.subscribe("column-width", this.columnWidthUpdated.bind(this)), this.subscribe("column-delete", this.deInitializeComponent.bind(this)), this.subscribe("column-height", this.resizeHandle.bind(this)), this.initialized = !0);
  }
  layoutCellHandles(e) {
    e.row.type === "row" && (this.deInitializeComponent(e), this.initializeColumn("cell", e, e.column, e.element));
  }
  layoutColumnHeader(e) {
    e.definition.resizable && (this.initializeEventWatchers(), this.deInitializeComponent(e), this.initializeColumn("header", e, e, e.element));
  }
  columnLayoutUpdated(e) {
    var t = e.prevColumn();
    this.reinitializeColumn(e), t && this.reinitializeColumn(t);
  }
  columnWidthUpdated(e) {
    e.modules.frozen && (this.table.modules.frozenColumns.leftColumns.includes(e) ? this.table.modules.frozenColumns.leftColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }) : this.table.modules.frozenColumns.rightColumns.includes(e) && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }));
  }
  frozenColumnOffset(e) {
    var t = !1;
    return e.modules.frozen && (t = e.modules.frozen.marginValue, e.modules.frozen.position === "left" ? t += e.getWidth() - 3 : t && (t -= 3)), t !== !1 ? t + "px" : !1;
  }
  reinitializeColumn(e) {
    var t = this.frozenColumnOffset(e);
    e.cells.forEach((i) => {
      i.modules.resize && i.modules.resize.handleEl && (t && (i.modules.resize.handleEl.style[e.modules.frozen.position] = t), i.element.after(i.modules.resize.handleEl));
    }), e.modules.resize && e.modules.resize.handleEl && (t && (e.modules.resize.handleEl.style[e.modules.frozen.position] = t), e.element.after(e.modules.resize.handleEl));
  }
  initializeColumn(e, t, i, n) {
    var a = this, o = !1, s = i.definition.resizable, l = {}, u = i.getLastColumn();
    if (e === "header" && (o = i.definition.formatter == "textarea" || i.definition.variableHeight, l = { variableHeight: o }), (s === !0 || s == e) && this._checkResizability(u)) {
      var h = document.createElement("span");
      h.className = "tabulator-col-resize-handle", h.addEventListener("click", function(f) {
        f.stopPropagation();
      });
      var c = function(f) {
        a.startColumn = i, a.initialNextColumn = a.nextColumn = u.nextColumn(), a._mouseDown(f, u, h);
      };
      h.addEventListener("mousedown", c), h.addEventListener("touchstart", c, { passive: !0 }), h.addEventListener("dblclick", (f) => {
        var d = u.getWidth();
        f.stopPropagation(), u.reinitializeWidth(!0), d !== u.getWidth() && (a.dispatch("column-resized", u), a.table.externalEvents.dispatch("columnResized", u.getComponent()));
      }), i.modules.frozen && (h.style.position = "sticky", h.style[i.modules.frozen.position] = this.frozenColumnOffset(i)), l.handleEl = h, n.parentNode && i.visible && n.after(h);
    }
    t.modules.resize = l;
  }
  deInitializeColumn(e) {
    this.deInitializeComponent(e), e.cells.forEach((t) => {
      this.deInitializeComponent(t);
    });
  }
  deInitializeComponent(e) {
    var t;
    e.modules.resize && (t = e.modules.resize.handleEl, t && t.parentElement && t.parentElement.removeChild(t));
  }
  resizeHandle(e, t) {
    e.modules.resize && e.modules.resize.handleEl && (e.modules.resize.handleEl.style.height = t);
  }
  _checkResizability(e) {
    return e.definition.resizable;
  }
  _mouseDown(e, t, i) {
    var n = this;
    n.table.element.classList.add("tabulator-block-select");
    function a(s) {
      var l = typeof s.screenX > "u" ? s.touches[0].screenX : s.screenX, u = l - n.startX, h = l - n.latestX, c, f;
      if (n.latestX = l, n.table.rtl && (u = -u, h = -h), c = t.width == t.minWidth || t.width == t.maxWidth, t.setWidth(n.startWidth + u), f = t.width == t.minWidth || t.width == t.maxWidth, h < 0 && (n.nextColumn = n.initialNextColumn), n.table.options.resizableColumnFit && n.nextColumn && !(c && f)) {
        let d = n.nextColumn.getWidth();
        h > 0 && d <= n.nextColumn.minWidth && (n.nextColumn = n.nextColumn.nextColumn()), n.nextColumn && n.nextColumn.setWidth(n.nextColumn.getWidth() - h);
      }
      n.table.columnManager.rerenderColumns(!0), !n.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights();
    }
    function o(s) {
      n.startColumn.modules.edit && (n.startColumn.modules.edit.blocked = !1), n.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights(), document.body.removeEventListener("mouseup", o), document.body.removeEventListener("mousemove", a), i.removeEventListener("touchmove", a), i.removeEventListener("touchend", o), n.table.element.classList.remove("tabulator-block-select"), n.startWidth !== t.getWidth() && (n.table.columnManager.verticalAlignHeaders(), n.dispatch("column-resized", t), n.table.externalEvents.dispatch("columnResized", t.getComponent()));
    }
    e.stopPropagation(), n.startColumn.modules.edit && (n.startColumn.modules.edit.blocked = !0), n.startX = typeof e.screenX > "u" ? e.touches[0].screenX : e.screenX, n.latestX = n.startX, n.startWidth = t.getWidth(), document.body.addEventListener("mousemove", a), document.body.addEventListener("mouseup", o), i.addEventListener("touchmove", a, { passive: !0 }), i.addEventListener("touchend", o);
  }
}
$P.moduleName = "resizeColumns";
class GP extends pt {
  constructor(e) {
    super(e), this.startColumn = !1, this.startY = !1, this.startHeight = !1, this.handle = null, this.prevHandle = null, this.registerTableOption("resizableRows", !1);
  }
  initialize() {
    this.table.options.resizableRows && this.subscribe("row-layout-after", this.initializeRow.bind(this));
  }
  initializeRow(e) {
    var t = this, i = e.getElement(), n = document.createElement("div");
    n.className = "tabulator-row-resize-handle";
    var a = document.createElement("div");
    a.className = "tabulator-row-resize-handle prev", n.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var o = function(l) {
      t.startRow = e, t._mouseDown(l, e, n);
    };
    n.addEventListener("mousedown", o), n.addEventListener("touchstart", o, { passive: !0 }), a.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var s = function(l) {
      var u = t.table.rowManager.prevDisplayRow(e);
      u && (t.startRow = u, t._mouseDown(l, u, a));
    };
    a.addEventListener("mousedown", s), a.addEventListener("touchstart", s, { passive: !0 }), i.appendChild(n), i.appendChild(a);
  }
  _mouseDown(e, t, i) {
    var n = this;
    n.table.element.classList.add("tabulator-block-select");
    function a(s) {
      t.setHeight(n.startHeight + ((typeof s.screenY > "u" ? s.touches[0].screenY : s.screenY) - n.startY));
    }
    function o(s) {
      document.body.removeEventListener("mouseup", a), document.body.removeEventListener("mousemove", a), i.removeEventListener("touchmove", a), i.removeEventListener("touchend", o), n.table.element.classList.remove("tabulator-block-select"), n.dispatchExternal("rowResized", t.getComponent());
    }
    e.stopPropagation(), n.startY = typeof e.screenY > "u" ? e.touches[0].screenY : e.screenY, n.startHeight = t.getHeight(), document.body.addEventListener("mousemove", a), document.body.addEventListener("mouseup", o), i.addEventListener("touchmove", a, { passive: !0 }), i.addEventListener("touchend", o);
  }
}
GP.moduleName = "resizeRows";
class BP extends pt {
  constructor(e) {
    super(e), this.binding = !1, this.visibilityObserver = !1, this.resizeObserver = !1, this.containerObserver = !1, this.tableHeight = 0, this.tableWidth = 0, this.containerHeight = 0, this.containerWidth = 0, this.autoResize = !1, this.visible = !1, this.initialized = !1, this.initialRedraw = !1, this.registerTableOption("autoResize", !0);
  }
  initialize() {
    if (this.table.options.autoResize) {
      var e = this.table, t;
      this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), typeof IntersectionObserver < "u" && typeof ResizeObserver < "u" && e.rowManager.getRenderMode() === "virtual" ? (this.initializeVisibilityObserver(), this.autoResize = !0, this.resizeObserver = new ResizeObserver((i) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var n = Math.floor(i[0].contentRect.height), a = Math.floor(i[0].contentRect.width);
          (this.tableHeight != n || this.tableWidth != a) && (this.tableHeight = n, this.tableWidth = a, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), this.redrawTable());
        }
      }), this.resizeObserver.observe(e.element), t = window.getComputedStyle(e.element), this.table.element.parentNode && !this.table.rowManager.fixedHeight && (t.getPropertyValue("max-height") || t.getPropertyValue("min-height")) && (this.containerObserver = new ResizeObserver((i) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var n = Math.floor(i[0].contentRect.height), a = Math.floor(i[0].contentRect.width);
          (this.containerHeight != n || this.containerWidth != a) && (this.containerHeight = n, this.containerWidth = a, this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth), this.redrawTable();
        }
      }), this.containerObserver.observe(this.table.element.parentNode)), this.subscribe("table-resize", this.tableResized.bind(this))) : (this.binding = function() {
        (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) && (e.columnManager.rerenderColumns(!0), e.redraw());
      }, window.addEventListener("resize", this.binding)), this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
  }
  initializeVisibilityObserver() {
    this.visibilityObserver = new IntersectionObserver((e) => {
      this.visible = e[0].isIntersecting, this.initialized ? this.visible && (this.redrawTable(this.initialRedraw), this.initialRedraw = !1) : (this.initialized = !0, this.initialRedraw = !this.visible);
    }), this.visibilityObserver.observe(this.table.element);
  }
  redrawTable(e) {
    this.initialized && this.visible && (this.table.columnManager.rerenderColumns(!0), this.table.redraw(e));
  }
  tableResized() {
    this.table.rowManager.redraw();
  }
  clearBindings() {
    this.binding && window.removeEventListener("resize", this.binding), this.resizeObserver && this.resizeObserver.unobserve(this.table.element), this.visibilityObserver && this.visibilityObserver.unobserve(this.table.element), this.containerObserver && this.containerObserver.unobserve(this.table.element.parentNode);
  }
}
BP.moduleName = "resizeTable";
class VP extends pt {
  constructor(e) {
    super(e), this.columns = [], this.hiddenColumns = [], this.mode = "", this.index = 0, this.collapseFormatter = [], this.collapseStartOpen = !0, this.collapseHandleColumn = !1, this.registerTableOption("responsiveLayout", !1), this.registerTableOption("responsiveLayoutCollapseStartOpen", !0), this.registerTableOption("responsiveLayoutCollapseUseFormatters", !0), this.registerTableOption("responsiveLayoutCollapseFormatter", !1), this.registerColumnOption("responsive");
  }
  //generate responsive columns list
  initialize() {
    this.table.options.responsiveLayout && (this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-show", this.updateColumnVisibility.bind(this)), this.subscribe("column-hide", this.updateColumnVisibility.bind(this)), this.subscribe("columns-loaded", this.initializeResponsivity.bind(this)), this.subscribe("column-moved", this.initializeResponsivity.bind(this)), this.subscribe("column-add", this.initializeResponsivity.bind(this)), this.subscribe("column-delete", this.initializeResponsivity.bind(this)), this.subscribe("table-redrawing", this.tableRedraw.bind(this)), this.table.options.responsiveLayout === "collapse" && (this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout", this.layoutRow.bind(this))));
  }
  tableRedraw(e) {
    ["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1 && (e || this.update());
  }
  initializeResponsivity() {
    var e = [];
    this.mode = this.table.options.responsiveLayout, this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData, this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen, this.hiddenColumns = [], this.table.columnManager.columnsByIndex.forEach((t, i) => {
      t.modules.responsive && t.modules.responsive.order && t.modules.responsive.visible && (t.modules.responsive.index = i, e.push(t), !t.visible && this.mode === "collapse" && this.hiddenColumns.push(t));
    }), e = e.reverse(), e = e.sort((t, i) => {
      var n = i.modules.responsive.order - t.modules.responsive.order;
      return n || i.modules.responsive.index - t.modules.responsive.index;
    }), this.columns = e, this.mode === "collapse" && this.generateCollapsedContent();
    for (let t of this.table.columnManager.columnsByIndex)
      if (t.definition.formatter == "responsiveCollapse") {
        this.collapseHandleColumn = t;
        break;
      }
    this.collapseHandleColumn && (this.hiddenColumns.length ? this.collapseHandleColumn.show() : this.collapseHandleColumn.hide());
  }
  //define layout information
  initializeColumn(e) {
    var t = e.getDefinition();
    e.modules.responsive = { order: typeof t.responsive > "u" ? 1 : t.responsive, visible: t.visible !== !1 };
  }
  initializeRow(e) {
    var t;
    e.type !== "calc" && (t = document.createElement("div"), t.classList.add("tabulator-responsive-collapse"), e.modules.responsiveLayout = {
      element: t,
      open: this.collapseStartOpen
    }, this.collapseStartOpen || (t.style.display = "none"));
  }
  layoutRow(e) {
    var t = e.getElement();
    e.modules.responsiveLayout && (t.appendChild(e.modules.responsiveLayout.element), this.generateCollapsedRowContent(e));
  }
  //update column visibility
  updateColumnVisibility(e, t) {
    !t && e.modules.responsive && (e.modules.responsive.visible = e.visible, this.initializeResponsivity());
  }
  hideColumn(e) {
    var t = this.hiddenColumns.length;
    e.hide(!1, !0), this.mode === "collapse" && (this.hiddenColumns.unshift(e), this.generateCollapsedContent(), this.collapseHandleColumn && !t && this.collapseHandleColumn.show());
  }
  showColumn(e) {
    var t;
    e.show(!1, !0), e.setWidth(e.getWidth()), this.mode === "collapse" && (t = this.hiddenColumns.indexOf(e), t > -1 && this.hiddenColumns.splice(t, 1), this.generateCollapsedContent(), this.collapseHandleColumn && !this.hiddenColumns.length && this.collapseHandleColumn.hide());
  }
  //redraw columns to fit space
  update() {
    for (var e = !0; e; ) {
      let t = this.table.modules.layout.getMode() == "fitColumns" ? this.table.columnManager.getFlexBaseWidth() : this.table.columnManager.getWidth(), i = (this.table.options.headerVisible ? this.table.columnManager.element.clientWidth : this.table.element.clientWidth) - t;
      if (i < 0) {
        let n = this.columns[this.index];
        n ? (this.hideColumn(n), this.index++) : e = !1;
      } else {
        let n = this.columns[this.index - 1];
        n && i > 0 && i >= n.getWidth() ? (this.showColumn(n), this.index--) : e = !1;
      }
      this.table.rowManager.activeRowsCount || this.table.rowManager.renderEmptyScroll();
    }
  }
  generateCollapsedContent() {
    var e = this.table.rowManager.getDisplayRows();
    e.forEach((t) => {
      this.generateCollapsedRowContent(t);
    });
  }
  generateCollapsedRowContent(e) {
    var t, i;
    if (e.modules.responsiveLayout) {
      for (t = e.modules.responsiveLayout.element; t.firstChild; )
        t.removeChild(t.firstChild);
      i = this.collapseFormatter(this.generateCollapsedRowData(e)), i && t.appendChild(i);
    }
  }
  generateCollapsedRowData(e) {
    var t = e.getData(), i = [], n;
    return this.hiddenColumns.forEach((a) => {
      var o = a.getFieldValue(t);
      if (a.definition.title && a.field)
        if (a.modules.format && this.table.options.responsiveLayoutCollapseUseFormatters) {
          let l = function(u) {
            u();
          };
          var s = l;
          n = {
            value: !1,
            data: {},
            getValue: function() {
              return o;
            },
            getData: function() {
              return t;
            },
            getType: function() {
              return "cell";
            },
            getElement: function() {
              return document.createElement("div");
            },
            getRow: function() {
              return e.getComponent();
            },
            getColumn: function() {
              return a.getComponent();
            },
            getTable: () => this.table
          }, i.push({
            field: a.field,
            title: a.definition.title,
            value: a.modules.format.formatter.call(this.table.modules.format, n, a.modules.format.params, l)
          });
        } else
          i.push({
            field: a.field,
            title: a.definition.title,
            value: o
          });
    }), i;
  }
  formatCollapsedData(e) {
    var t = document.createElement("table");
    return e.forEach(function(i) {
      var n = document.createElement("tr"), a = document.createElement("td"), o = document.createElement("td"), s, l = document.createElement("strong");
      a.appendChild(l), this.langBind("columns|" + i.field, function(u) {
        l.innerHTML = u || i.title;
      }), i.value instanceof Node ? (s = document.createElement("div"), s.appendChild(i.value), o.appendChild(s)) : o.innerHTML = i.value, n.appendChild(a), n.appendChild(o), t.appendChild(n);
    }, this), Object.keys(e).length ? t : "";
  }
}
VP.moduleName = "responsiveLayout";
class FP extends pt {
  constructor(e) {
    super(e), this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], this.headerCheckboxElement = null, this.registerTableOption("selectable", "highlight"), this.registerTableOption("selectableRangeMode", "drag"), this.registerTableOption("selectableRollingSelection", !0), this.registerTableOption("selectablePersistence", !0), this.registerTableOption("selectableCheck", function(t, i) {
      return !0;
    }), this.registerTableFunction("selectRow", this.selectRows.bind(this)), this.registerTableFunction("deselectRow", this.deselectRows.bind(this)), this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this)), this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this)), this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this)), this.registerComponentFunction("row", "select", this.selectRows.bind(this)), this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this)), this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this)), this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
  }
  initialize() {
    this.table.options.selectable !== !1 && (this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-deleting", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clearSelectionData.bind(this)), this.subscribe("rows-retrieve", this.rowRetrieve.bind(this)), this.table.options.selectable && !this.table.options.selectablePersistence && this.subscribe("data-refreshing", this.deselectRows.bind(this)));
  }
  rowRetrieve(e, t) {
    return e === "selected" ? this.selectedRows : t;
  }
  rowDeleted(e) {
    this._deselectRow(e, !0);
  }
  clearSelectionData(e) {
    var t = this.selectedRows.length;
    this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], t && e !== !0 && this._rowSelectionChanged();
  }
  initializeRow(e) {
    var t = this, i = e.getElement(), n = function() {
      setTimeout(function() {
        t.selecting = !1;
      }, 50), document.body.removeEventListener("mouseup", n);
    };
    e.modules.select = { selected: !1 }, t.checkRowSelectability(e) ? (i.classList.add("tabulator-selectable"), i.classList.remove("tabulator-unselectable"), t.table.options.selectable && t.table.options.selectable != "highlight" && (t.table.options.selectableRangeMode === "click" ? i.addEventListener("click", this.handleComplexRowClick.bind(this, e)) : (i.addEventListener("click", function(a) {
      (!t.table.modExists("edit") || !t.table.modules.edit.getCurrentCell()) && t.table._clearSelection(), t.selecting || t.toggleRow(e);
    }), i.addEventListener("mousedown", function(a) {
      if (a.shiftKey)
        return t.table._clearSelection(), t.selecting = !0, t.selectPrev = [], document.body.addEventListener("mouseup", n), document.body.addEventListener("keyup", n), t.toggleRow(e), !1;
    }), i.addEventListener("mouseenter", function(a) {
      t.selecting && (t.table._clearSelection(), t.toggleRow(e), t.selectPrev[1] == e && t.toggleRow(t.selectPrev[0]));
    }), i.addEventListener("mouseout", function(a) {
      t.selecting && (t.table._clearSelection(), t.selectPrev.unshift(e));
    })))) : (i.classList.add("tabulator-unselectable"), i.classList.remove("tabulator-selectable"));
  }
  handleComplexRowClick(e, t) {
    if (t.shiftKey) {
      this.table._clearSelection(), this.lastClickedRow = this.lastClickedRow || e;
      var i = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow), n = this.table.rowManager.getDisplayRowIndex(e), a = i <= n ? i : n, o = i >= n ? i : n, s = this.table.rowManager.getDisplayRows().slice(0), l = s.splice(a, o - a + 1);
      t.ctrlKey || t.metaKey ? (l.forEach((u) => {
        u !== this.lastClickedRow && (this.table.options.selectable !== !0 && !this.isRowSelected(e) ? this.selectedRows.length < this.table.options.selectable && this.toggleRow(u) : this.toggleRow(u));
      }), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.table.options.selectable !== !0 && l.length > this.table.options.selectable && (l = l.slice(0, this.table.options.selectable)), this.selectRows(l)), this.table._clearSelection();
    } else
      t.ctrlKey || t.metaKey ? (this.toggleRow(e), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.selectRows(e), this.lastClickedRow = e);
  }
  checkRowSelectability(e) {
    return e && e.type === "row" ? this.table.options.selectableCheck.call(this.table, e.getComponent()) : !1;
  }
  //toggle row selection
  toggleRow(e) {
    this.checkRowSelectability(e) && (e.modules.select && e.modules.select.selected ? this._deselectRow(e) : this._selectRow(e));
  }
  //select a number of rows
  selectRows(e) {
    var t = [], i, n;
    switch (typeof e) {
      case "undefined":
        i = this.table.rowManager.rows;
        break;
      case "string":
        i = this.table.rowManager.findRow(e), i || (i = this.table.rowManager.getRows(e));
        break;
      default:
        i = e;
        break;
    }
    Array.isArray(i) ? i.length && (i.forEach((a) => {
      n = this._selectRow(a, !0, !0), n && t.push(n);
    }), this._rowSelectionChanged(!1, t)) : i && this._selectRow(i, !1, !0);
  }
  //select an individual row
  _selectRow(e, t, i) {
    if (!isNaN(this.table.options.selectable) && this.table.options.selectable !== !0 && !i && this.selectedRows.length >= this.table.options.selectable)
      if (this.table.options.selectableRollingSelection)
        this._deselectRow(this.selectedRows[0]);
      else
        return !1;
    var n = this.table.rowManager.findRow(e);
    if (n) {
      if (this.selectedRows.indexOf(n) == -1)
        return n.getElement().classList.add("tabulator-selected"), n.modules.select || (n.modules.select = {}), n.modules.select.selected = !0, n.modules.select.checkboxEl && (n.modules.select.checkboxEl.checked = !0), this.selectedRows.push(n), this.table.options.dataTreeSelectPropagate && this.childRowSelection(n, !0), this.dispatchExternal("rowSelected", n.getComponent()), this._rowSelectionChanged(t, n), n;
    } else
      t || console.warn("Selection Error - No such row found, ignoring selection:" + e);
  }
  isRowSelected(e) {
    return this.selectedRows.indexOf(e) !== -1;
  }
  //deselect a number of rows
  deselectRows(e, t) {
    var i = [], n, a;
    switch (typeof e) {
      case "undefined":
        n = Object.assign([], this.selectedRows);
        break;
      case "string":
        n = this.table.rowManager.findRow(e), n || (n = this.table.rowManager.getRows(e));
        break;
      default:
        n = e;
        break;
    }
    Array.isArray(n) ? n.length && (n.forEach((o) => {
      a = this._deselectRow(o, !0, !0), a && i.push(a);
    }), this._rowSelectionChanged(t, [], i)) : n && this._deselectRow(n, t, !0);
  }
  //deselect an individual row
  _deselectRow(e, t) {
    var i = this, n = i.table.rowManager.findRow(e), a, o;
    if (n) {
      if (a = i.selectedRows.findIndex(function(s) {
        return s == n;
      }), a > -1)
        return o = n.getElement(), o && o.classList.remove("tabulator-selected"), n.modules.select || (n.modules.select = {}), n.modules.select.selected = !1, n.modules.select.checkboxEl && (n.modules.select.checkboxEl.checked = !1), i.selectedRows.splice(a, 1), this.table.options.dataTreeSelectPropagate && this.childRowSelection(n, !1), this.dispatchExternal("rowDeselected", n.getComponent()), i._rowSelectionChanged(t, void 0, n), n;
    } else
      t || console.warn("Deselection Error - No such row found, ignoring selection:" + e);
  }
  getSelectedData() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getData());
    }), e;
  }
  getSelectedRows() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  _rowSelectionChanged(e, t = [], i = []) {
    this.headerCheckboxElement && (this.selectedRows.length === 0 ? (this.headerCheckboxElement.checked = !1, this.headerCheckboxElement.indeterminate = !1) : this.table.rowManager.rows.length === this.selectedRows.length ? (this.headerCheckboxElement.checked = !0, this.headerCheckboxElement.indeterminate = !1) : (this.headerCheckboxElement.indeterminate = !0, this.headerCheckboxElement.checked = !1)), e || (Array.isArray(t) || (t = [t]), t = t.map((n) => n.getComponent()), Array.isArray(i) || (i = [i]), i = i.map((n) => n.getComponent()), this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows(), t, i));
  }
  registerRowSelectCheckbox(e, t) {
    e._row.modules.select || (e._row.modules.select = {}), e._row.modules.select.checkboxEl = t;
  }
  registerHeaderSelectCheckbox(e) {
    this.headerCheckboxElement = e;
  }
  childRowSelection(e, t) {
    var i = this.table.modules.dataTree.getChildren(e, !0);
    if (t)
      for (let n of i)
        this._selectRow(n, !0);
    else
      for (let n of i)
        this._deselectRow(n, !0);
  }
}
FP.moduleName = "selectRow";
function N$e(r, e, t, i, n, a, o) {
  var s = o.alignEmptyValues, l = o.decimalSeparator, u = o.thousandSeparator, h = 0;
  if (r = String(r), e = String(e), u && (r = r.split(u).join(""), e = e.split(u).join("")), l && (r = r.split(l).join("."), e = e.split(l).join(".")), r = parseFloat(r), e = parseFloat(e), isNaN(r))
    h = isNaN(e) ? 0 : -1;
  else if (isNaN(e))
    h = 1;
  else
    return r - e;
  return (s === "top" && a === "desc" || s === "bottom" && a === "asc") && (h *= -1), h;
}
function L$e(r, e, t, i, n, a, o) {
  var s = o.alignEmptyValues, l = 0, u;
  if (!r)
    l = e ? -1 : 0;
  else if (!e)
    l = 1;
  else {
    switch (typeof o.locale) {
      case "boolean":
        o.locale && (u = this.langLocale());
        break;
      case "string":
        u = o.locale;
        break;
    }
    return String(r).toLowerCase().localeCompare(String(e).toLowerCase(), u);
  }
  return (s === "top" && a === "desc" || s === "bottom" && a === "asc") && (l *= -1), l;
}
function XP(r, e, t, i, n, a, o) {
  var s = window.DateTime || luxon.DateTime, l = o.format || "dd/MM/yyyy HH:mm:ss", u = o.alignEmptyValues, h = 0;
  if (typeof s < "u") {
    if (s.isDateTime(r) || (l === "iso" ? r = s.fromISO(String(r)) : r = s.fromFormat(String(r), l)), s.isDateTime(e) || (l === "iso" ? e = s.fromISO(String(e)) : e = s.fromFormat(String(e), l)), !r.isValid)
      h = e.isValid ? -1 : 0;
    else if (!e.isValid)
      h = 1;
    else
      return r - e;
    return (u === "top" && a === "desc" || u === "bottom" && a === "asc") && (h *= -1), h;
  } else
    console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
}
function D$e(r, e, t, i, n, a, o) {
  return o.format || (o.format = "dd/MM/yyyy"), XP.call(this, r, e, t, i, n, a, o);
}
function M$e(r, e, t, i, n, a, o) {
  return o.format || (o.format = "HH:mm"), XP.call(this, r, e, t, i, n, a, o);
}
function k$e(r, e, t, i, n, a, o) {
  var s = r === !0 || r === "true" || r === "True" || r === 1 ? 1 : 0, l = e === !0 || e === "true" || e === "True" || e === 1 ? 1 : 0;
  return s - l;
}
function Q$e(r, e, t, i, n, a, o) {
  var s = o.type || "length", l = o.alignEmptyValues, u = 0;
  function h(c) {
    var f;
    switch (s) {
      case "length":
        f = c.length;
        break;
      case "sum":
        f = c.reduce(function(d, p) {
          return d + p;
        });
        break;
      case "max":
        f = Math.max.apply(null, c);
        break;
      case "min":
        f = Math.min.apply(null, c);
        break;
      case "avg":
        f = c.reduce(function(d, p) {
          return d + p;
        }) / c.length;
        break;
    }
    return f;
  }
  if (!Array.isArray(r))
    u = Array.isArray(e) ? -1 : 0;
  else if (!Array.isArray(e))
    u = 1;
  else
    return h(e) - h(r);
  return (l === "top" && a === "desc" || l === "bottom" && a === "asc") && (u *= -1), u;
}
function U$e(r, e, t, i, n, a, o) {
  var s = typeof r > "u" ? 0 : 1, l = typeof e > "u" ? 0 : 1;
  return s - l;
}
function $$e(r, e, t, i, n, a, o) {
  var s, l, u, h, c = 0, f, d = /(\d+)|(\D+)/g, p = /\d/, g = o.alignEmptyValues, v = 0;
  if (!r && r !== 0)
    v = !e && e !== 0 ? 0 : -1;
  else if (!e && e !== 0)
    v = 1;
  else {
    if (isFinite(r) && isFinite(e))
      return r - e;
    if (s = String(r).toLowerCase(), l = String(e).toLowerCase(), s === l)
      return 0;
    if (!(p.test(s) && p.test(l)))
      return s > l ? 1 : -1;
    for (s = s.match(d), l = l.match(d), f = s.length > l.length ? l.length : s.length; c < f; )
      if (u = s[c], h = l[c++], u !== h)
        return isFinite(u) && isFinite(h) ? (u.charAt(0) === "0" && (u = "." + u), h.charAt(0) === "0" && (h = "." + h), u - h) : u > h ? 1 : -1;
    return s.length > l.length;
  }
  return (g === "top" && a === "desc" || g === "bottom" && a === "asc") && (v *= -1), v;
}
var G$e = {
  number: N$e,
  string: L$e,
  date: D$e,
  time: M$e,
  datetime: XP,
  boolean: k$e,
  array: Q$e,
  exists: U$e,
  alphanum: $$e
};
class Zs extends pt {
  constructor(e) {
    super(e), this.sortList = [], this.changed = !1, this.registerTableOption("sortMode", "local"), this.registerTableOption("initialSort", !1), this.registerTableOption("columnHeaderSortMulti", !0), this.registerTableOption("sortOrderReverse", !1), this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>"), this.registerTableOption("headerSortClickElement", "header"), this.registerColumnOption("sorter"), this.registerColumnOption("sorterParams"), this.registerColumnOption("headerSort", !0), this.registerColumnOption("headerSortStartingDir"), this.registerColumnOption("headerSortTristate");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.registerDataHandler(this.sort.bind(this), 20), this.registerTableFunction("setSort", this.userSetSort.bind(this)), this.registerTableFunction("getSorters", this.getSort.bind(this)), this.registerTableFunction("clearSort", this.clearSort.bind(this)), this.table.options.sortMode === "remote" && this.subscribe("data-params", this.remoteSortParams.bind(this));
  }
  tableBuilt() {
    this.table.options.initialSort && this.setSort(this.table.options.initialSort);
  }
  remoteSortParams(e, t, i, n) {
    var a = this.getSort();
    return a.forEach((o) => {
      delete o.column;
    }), n.sort = a, n;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetSort(e, t) {
    this.setSort(e, t), this.refreshSort();
  }
  clearSort() {
    this.clear(), this.refreshSort();
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //initialize column header for sorting
  initializeColumn(e) {
    var t = !1, i, n;
    switch (typeof e.definition.sorter) {
      case "string":
        Zs.sorters[e.definition.sorter] ? t = Zs.sorters[e.definition.sorter] : console.warn("Sort Error - No such sorter found: ", e.definition.sorter);
        break;
      case "function":
        t = e.definition.sorter;
        break;
    }
    if (e.modules.sort = {
      sorter: t,
      dir: "none",
      params: e.definition.sorterParams || {},
      startingDir: e.definition.headerSortStartingDir || "asc",
      tristate: e.definition.headerSortTristate
    }, e.definition.headerSort !== !1) {
      switch (i = e.getElement(), i.classList.add("tabulator-sortable"), n = document.createElement("div"), n.classList.add("tabulator-col-sorter"), this.table.options.headerSortClickElement) {
        case "icon":
          n.classList.add("tabulator-col-sorter-element");
          break;
        case "header":
          i.classList.add("tabulator-col-sorter-element");
          break;
        default:
          i.classList.add("tabulator-col-sorter-element");
          break;
      }
      switch (this.table.options.headerSortElement) {
        case "function":
          break;
        case "object":
          n.appendChild(this.table.options.headerSortElement);
          break;
        default:
          n.innerHTML = this.table.options.headerSortElement;
      }
      e.titleHolderElement.appendChild(n), e.modules.sort.element = n, this.setColumnHeaderSortIcon(e, "none"), (this.table.options.headerSortClickElement === "icon" ? n : i).addEventListener("click", (a) => {
        var o = "", s = [], l = !1;
        if (e.modules.sort) {
          if (e.modules.sort.tristate)
            e.modules.sort.dir == "none" ? o = e.modules.sort.startingDir : e.modules.sort.dir == e.modules.sort.startingDir ? o = e.modules.sort.dir == "asc" ? "desc" : "asc" : o = "none";
          else
            switch (e.modules.sort.dir) {
              case "asc":
                o = "desc";
                break;
              case "desc":
                o = "asc";
                break;
              default:
                o = e.modules.sort.startingDir;
            }
          this.table.options.columnHeaderSortMulti && (a.shiftKey || a.ctrlKey) ? (s = this.getSort(), l = s.findIndex((u) => u.field === e.getField()), l > -1 ? (s[l].dir = o, l = s.splice(l, 1)[0], o != "none" && s.push(l)) : o != "none" && s.push({ column: e, dir: o }), this.setSort(s)) : o == "none" ? this.clear() : this.setSort(e, o), this.refreshSort();
        }
      });
    }
  }
  refreshSort() {
    this.table.options.sortMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0);
  }
  //check if the sorters have changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //return current sorters
  getSort() {
    var e = this, t = [];
    return e.sortList.forEach(function(i) {
      i.column && t.push({ column: i.column.getComponent(), field: i.column.getField(), dir: i.dir });
    }), t;
  }
  //change sort list and trigger sort
  setSort(e, t) {
    var i = this, n = [];
    Array.isArray(e) || (e = [{ column: e, dir: t }]), e.forEach(function(a) {
      var o;
      o = i.table.columnManager.findColumn(a.column), o ? (a.column = o, n.push(a), i.changed = !0) : console.warn("Sort Warning - Sort field does not exist and is being ignored: ", a.column);
    }), i.sortList = n, this.dispatch("sort-changed");
  }
  //clear sorters
  clear() {
    this.setSort([]);
  }
  //find appropriate sorter for column
  findSorter(e) {
    var t = this.table.rowManager.activeRows[0], i = "string", n, a;
    if (t && (t = t.getData(), n = e.getField(), n))
      switch (a = e.getFieldValue(t), typeof a) {
        case "undefined":
          i = "string";
          break;
        case "boolean":
          i = "boolean";
          break;
        default:
          !isNaN(a) && a !== "" ? i = "number" : a.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) && (i = "alphanum");
          break;
      }
    return Zs.sorters[i];
  }
  //work through sort list sorting data
  sort(e) {
    var t = this, i = this.table.options.sortOrderReverse ? t.sortList.slice().reverse() : t.sortList, n = [], a = [];
    return this.subscribedExternal("dataSorting") && this.dispatchExternal("dataSorting", t.getSort()), t.clearColumnHeaders(), this.table.options.sortMode !== "remote" ? (i.forEach(function(o, s) {
      var l;
      o.column && (l = o.column.modules.sort, l && (l.sorter || (l.sorter = t.findSorter(o.column)), o.params = typeof l.params == "function" ? l.params(o.column.getComponent(), o.dir) : l.params, n.push(o)), t.setColumnHeader(o.column, o.dir));
    }), n.length && t._sortItems(e, n)) : i.forEach(function(o, s) {
      t.setColumnHeader(o.column, o.dir);
    }), this.subscribedExternal("dataSorted") && (e.forEach((o) => {
      a.push(o.getComponent());
    }), this.dispatchExternal("dataSorted", t.getSort(), a)), e;
  }
  //clear sort arrows on columns
  clearColumnHeaders() {
    this.table.columnManager.getRealColumns().forEach((e) => {
      e.modules.sort && (e.modules.sort.dir = "none", e.getElement().setAttribute("aria-sort", "none"), this.setColumnHeaderSortIcon(e, "none"));
    });
  }
  //set the column header sort direction
  setColumnHeader(e, t) {
    e.modules.sort.dir = t, e.getElement().setAttribute("aria-sort", t === "asc" ? "ascending" : "descending"), this.setColumnHeaderSortIcon(e, t);
  }
  setColumnHeaderSortIcon(e, t) {
    var i = e.modules.sort.element, n;
    if (e.definition.headerSort && typeof this.table.options.headerSortElement == "function") {
      for (; i.firstChild; )
        i.removeChild(i.firstChild);
      n = this.table.options.headerSortElement.call(this.table, e.getComponent(), t), typeof n == "object" ? i.appendChild(n) : i.innerHTML = n;
    }
  }
  //sort each item in sort list
  _sortItems(e, t) {
    var i = t.length - 1;
    e.sort((n, a) => {
      for (var o, s = i; s >= 0; s--) {
        let l = t[s];
        if (o = this._sortRow(n, a, l.column, l.dir, l.params), o !== 0)
          break;
      }
      return o;
    });
  }
  //process individual rows for a sort function on active data
  _sortRow(e, t, i, n, a) {
    var o, s, l = n == "asc" ? e : t, u = n == "asc" ? t : e;
    return e = i.getFieldValue(l.getData()), t = i.getFieldValue(u.getData()), e = typeof e < "u" ? e : "", t = typeof t < "u" ? t : "", o = l.getComponent(), s = u.getComponent(), i.modules.sort.sorter.call(this, e, t, o, s, i.getComponent(), n, a);
  }
}
Zs.moduleName = "sort";
Zs.sorters = G$e;
class g8 extends pt {
  constructor(e) {
    super(e), this.tooltipSubscriber = null, this.headerSubscriber = null, this.timeout = null, this.popupInstance = null, this.registerTableOption("tooltipGenerationMode", void 0), this.registerTableOption("tooltipDelay", 300), this.registerColumnOption("tooltip"), this.registerColumnOption("headerTooltip");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheckMsg("tooltipGenerationMode", "This option is no longer needed as tooltips are always generated on hover now");
  }
  initializeColumn(e) {
    e.definition.headerTooltip && !this.headerSubscriber && (this.headerSubscriber = !0, this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip")), this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"))), e.definition.tooltip && !this.tooltipSubscriber && (this.tooltipSubscriber = !0, this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip")), this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip")));
  }
  mousemoveCheck(e, t, i) {
    var n = e === "tooltip" ? i.column.definition.tooltip : i.definition.headerTooltip;
    n && (this.clearPopup(), this.timeout = setTimeout(this.loadTooltip.bind(this, t, i, n), this.table.options.tooltipDelay));
  }
  mouseoutCheck(e, t, i) {
    this.popupInstance || this.clearPopup();
  }
  clearPopup(e, t, i) {
    clearTimeout(this.timeout), this.timeout = null, this.popupInstance && this.popupInstance.hide();
  }
  loadTooltip(e, t, i) {
    var n, a, o;
    function s(l) {
      a = l;
    }
    typeof i == "function" && (i = i(e, t.getComponent(), s)), i instanceof HTMLElement ? n = i : (n = document.createElement("div"), i === !0 && (t instanceof dv ? i = t.value : t.definition.field ? this.langBind("columns|" + t.definition.field, (l) => {
      n.innerHTML = i = l || t.definition.title;
    }) : i = t.definition.title), n.innerHTML = i), (i || i === 0 || i === !1) && (n.classList.add("tabulator-tooltip"), n.addEventListener("mousemove", (l) => l.preventDefault()), this.popupInstance = this.popup(n), typeof a == "function" && this.popupInstance.renderCallback(a), o = this.popupInstance.containerEventCoords(e), this.popupInstance.show(o.x + 15, o.y + 15).hideOnBlur(() => {
      this.dispatchExternal("TooltipClosed", t.getComponent()), this.popupInstance = null;
    }), this.dispatchExternal("TooltipOpened", t.getComponent()));
  }
}
g8.moduleName = "tooltip";
var B$e = {
  //is integer
  integer: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && Math.floor(e) === e);
  },
  //is float
  float: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && e % 1 !== 0);
  },
  //must be a number
  numeric: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : !isNaN(e);
  },
  //must be a string
  string: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : isNaN(e);
  },
  //maximum value
  max: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) <= t;
  },
  //minimum value
  min: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) >= t;
  },
  //starts with  value
  starts: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().startsWith(String(t).toLowerCase());
  },
  //ends with  value
  ends: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().endsWith(String(t).toLowerCase());
  },
  //minimum string length
  minLength: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length >= t;
  },
  //maximum string length
  maxLength: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length <= t;
  },
  //in provided value list
  in: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (typeof t == "string" && (t = t.split("|")), t.indexOf(e) > -1);
  },
  //must match provided regex
  regex: function(r, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var i = new RegExp(t);
    return i.test(e);
  },
  //value must be unique in this column
  unique: function(r, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var i = !0, n = r.getData(), a = r.getColumn()._getSelf();
    return this.table.rowManager.rows.forEach(function(o) {
      var s = o.getData();
      s !== n && e == a.getFieldValue(s) && (i = !1);
    }), i;
  },
  //must have a value
  required: function(r, e, t) {
    return e !== "" && e !== null && typeof e < "u";
  }
};
class Gf extends pt {
  constructor(e) {
    super(e), this.invalidCells = [], this.registerTableOption("validationMode", "blocking"), this.registerColumnOption("validator"), this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this)), this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this)), this.registerTableFunction("validate", this.userValidate.bind(this)), this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this)), this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this)), this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this)), this.registerComponentFunction("column", "validate", this.columnValidate.bind(this)), this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
  }
  initialize() {
    this.subscribe("cell-delete", this.clearValidation.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("edit-success", this.editValidate.bind(this)), this.subscribe("edit-editor-clear", this.editorClear.bind(this)), this.subscribe("edit-edited-clear", this.editedClear.bind(this));
  }
  ///////////////////////////////////
  ///////// Event Handling //////////
  ///////////////////////////////////
  editValidate(e, t, i) {
    var n = this.table.options.validationMode !== "manual" ? this.validate(e.column.modules.validate, e, t) : !0;
    return n !== !0 && setTimeout(() => {
      e.getElement().classList.add("tabulator-validation-fail"), this.dispatchExternal("validationFailed", e.getComponent(), t, n);
    }), n;
  }
  editorClear(e, t) {
    t && e.column.modules.validate && this.cellValidate(e), e.getElement().classList.remove("tabulator-validation-fail");
  }
  editedClear(e) {
    e.modules.validate && (e.modules.validate.invalid = !1);
  }
  ///////////////////////////////////
  ////////// Cell Functions /////////
  ///////////////////////////////////
  cellIsValid(e) {
    return e.modules.validate && e.modules.validate.invalid || !0;
  }
  cellValidate(e) {
    return this.validate(e.column.modules.validate, e, e.getValue());
  }
  ///////////////////////////////////
  ///////// Column Functions ////////
  ///////////////////////////////////
  columnValidate(e) {
    var t = [];
    return e.cells.forEach((i) => {
      this.cellValidate(i) !== !0 && t.push(i.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ////////// Row Functions //////////
  ///////////////////////////////////
  rowValidate(e) {
    var t = [];
    return e.cells.forEach((i) => {
      this.cellValidate(i) !== !0 && t.push(i.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userClearCellValidation(e) {
    e || (e = this.getInvalidCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.clearValidation(t._getSelf());
    });
  }
  userValidate(e) {
    var t = [];
    return this.table.rowManager.rows.forEach((i) => {
      i = i.getComponent();
      var n = i.validate();
      n !== !0 && (t = t.concat(n));
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.validator < "u" && this.initializeColumn(e);
  }
  //validate
  initializeColumn(e) {
    var t = this, i = [], n;
    e.definition.validator && (Array.isArray(e.definition.validator) ? e.definition.validator.forEach((a) => {
      n = t._extractValidator(a), n && i.push(n);
    }) : (n = this._extractValidator(e.definition.validator), n && i.push(n)), e.modules.validate = i.length ? i : !1);
  }
  _extractValidator(e) {
    var t, i, n;
    switch (typeof e) {
      case "string":
        return n = e.indexOf(":"), n > -1 ? (t = e.substring(0, n), i = e.substring(n + 1)) : t = e, this._buildValidator(t, i);
      case "function":
        return this._buildValidator(e);
      case "object":
        return this._buildValidator(e.type, e.parameters);
    }
  }
  _buildValidator(e, t) {
    var i = typeof e == "function" ? e : Gf.validators[e];
    return i ? {
      type: typeof e == "function" ? "function" : e,
      func: i,
      params: t
    } : (console.warn("Validator Setup Error - No matching validator found:", e), !1);
  }
  validate(e, t, i) {
    var n = this, a = [], o = this.invalidCells.indexOf(t);
    return e && e.forEach((s) => {
      s.func.call(n, t.getComponent(), i, s.params) || a.push({
        type: s.type,
        parameters: s.params
      });
    }), t.modules.validate || (t.modules.validate = {}), a.length ? (t.modules.validate.invalid = a, this.table.options.validationMode !== "manual" && t.getElement().classList.add("tabulator-validation-fail"), o == -1 && this.invalidCells.push(t)) : (t.modules.validate.invalid = !1, t.getElement().classList.remove("tabulator-validation-fail"), o > -1 && this.invalidCells.splice(o, 1)), a.length ? a : !0;
  }
  getInvalidCells() {
    var e = [];
    return this.invalidCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearValidation(e) {
    var t;
    e.modules.validate && e.modules.validate.invalid && (e.getElement().classList.remove("tabulator-validation-fail"), e.modules.validate.invalid = !1, t = this.invalidCells.indexOf(e), t > -1 && this.invalidCells.splice(t, 1));
  }
}
Gf.moduleName = "validate";
Gf.validators = B$e;
var V$e = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AccessorModule: ch,
  AjaxModule: pa,
  ClipboardModule: El,
  ColumnCalcsModule: No,
  DataTreeModule: _P,
  DownloadModule: fh,
  EditModule: Qf,
  ExportModule: xP,
  FilterModule: Xa,
  FormatModule: rn,
  FrozenColumnsModule: wP,
  FrozenRowsModule: PP,
  GroupRowsModule: NP,
  HistoryModule: bl,
  HtmlTableImportModule: LP,
  ImportModule: Uf,
  InteractionModule: DP,
  KeybindingsModule: Go,
  MenuModule: p8,
  MoveColumnsModule: MP,
  MoveRowsModule: pv,
  MutatorModule: dh,
  PageModule: $f,
  PersistenceModule: bi,
  PopupModule: kP,
  PrintModule: QP,
  ReactiveDataModule: UP,
  ResizeColumnsModule: $P,
  ResizeRowsModule: GP,
  ResizeTableModule: BP,
  ResponsiveLayoutModule: VP,
  SelectRowModule: FP,
  SortModule: Zs,
  TooltipModule: g8,
  ValidateModule: Gf
}), F$e = {
  debugEventsExternal: !1,
  //flag to console log events
  debugEventsInternal: !1,
  //flag to console log events
  debugInvalidOptions: !0,
  //allow toggling of invalid option warnings
  debugInvalidComponentFuncs: !0,
  //allow toggling of invalid component warnings
  debugInitialization: !0,
  //allow toggling of pre initialization function call warnings
  debugDeprecation: !0,
  //allow toggling of deprecation warnings
  height: !1,
  //height of tabulator
  minHeight: !1,
  //minimum height of tabulator
  maxHeight: !1,
  //maximum height of tabulator
  columnHeaderVertAlign: "top",
  //vertical alignment of column headers
  popupContainer: !1,
  columns: [],
  //store for colum header info
  columnDefaults: {},
  //store column default props
  data: !1,
  //default starting data
  autoColumns: !1,
  //build columns from data row structure
  autoColumnsDefinitions: !1,
  nestedFieldSeparator: ".",
  //separator for nested data
  footerElement: !1,
  //hold footer element
  index: "id",
  //filed for row index
  textDirection: "auto",
  addRowPos: "bottom",
  //position to insert blank rows, top|bottom
  headerVisible: !0,
  //hide header
  renderVertical: "virtual",
  renderHorizontal: "basic",
  renderVerticalBuffer: 0,
  // set virtual DOM buffer size
  scrollToRowPosition: "top",
  scrollToRowIfVisible: !0,
  scrollToColumnPosition: "left",
  scrollToColumnIfVisible: !0,
  rowFormatter: !1,
  rowFormatterPrint: null,
  rowFormatterClipboard: null,
  rowFormatterHtmlOutput: null,
  rowHeight: null,
  placeholder: !1,
  dataLoader: !0,
  dataLoaderLoading: !1,
  dataLoaderError: !1,
  dataLoaderErrorTimeout: 3e3,
  dataSendParams: {},
  dataReceiveParams: {}
};
class v8 {
  constructor(e, t, i = {}) {
    this.table = e, this.msgType = t, this.registeredDefaults = Object.assign({}, i);
  }
  register(e, t) {
    this.registeredDefaults[e] = t;
  }
  generate(e, t = {}) {
    var i = Object.assign({}, this.registeredDefaults), n = this.table.options.debugInvalidOptions || t.debugInvalidOptions === !0;
    Object.assign(i, e);
    for (let a in t)
      i.hasOwnProperty(a) || (n && console.warn("Invalid " + this.msgType + " option:", a), i[a] = t.key);
    for (let a in i)
      a in t ? i[a] = t[a] : Array.isArray(i[a]) ? i[a] = Object.assign([], i[a]) : typeof i[a] == "object" && i[a] !== null ? i[a] = Object.assign({}, i[a]) : typeof i[a] > "u" && delete i[a];
    return i;
  }
}
class AT extends zi {
  constructor(e) {
    super(e), this.elementVertical = e.rowManager.element, this.elementHorizontal = e.columnManager.element, this.tableElement = e.rowManager.tableElement, this.verticalFillMode = "fit";
  }
  ///////////////////////////////////
  /////// Internal Bindings /////////
  ///////////////////////////////////
  initialize() {
  }
  clearRows() {
  }
  clearColumns() {
  }
  reinitializeColumnWidths(e) {
  }
  renderRows() {
  }
  renderColumns() {
  }
  rerenderRows(e) {
    e && e();
  }
  rerenderColumns(e, t) {
  }
  renderRowCells(e) {
  }
  rerenderRowCells(e, t) {
  }
  scrollColumns(e, t) {
  }
  scrollRows(e, t) {
  }
  resize() {
  }
  scrollToRow(e) {
  }
  scrollToRowNearestTop(e) {
  }
  visibleRows(e) {
    return [];
  }
  ///////////////////////////////////
  //////// Helper Functions /////////
  ///////////////////////////////////
  rows() {
    return this.table.rowManager.getDisplayRows();
  }
  styleRow(e, t) {
    var i = e.getElement();
    t % 2 ? (i.classList.add("tabulator-row-even"), i.classList.remove("tabulator-row-odd")) : (i.classList.add("tabulator-row-odd"), i.classList.remove("tabulator-row-even"));
  }
  ///////////////////////////////////
  /////// External Triggers /////////
  /////// (DO NOT OVERRIDE) /////////
  ///////////////////////////////////
  clear() {
    this.clearRows(), this.clearColumns();
  }
  render() {
    this.renderRows(), this.renderColumns();
  }
  rerender(e) {
    this.rerenderRows(), this.rerenderColumns();
  }
  scrollToRowPosition(e, t, i) {
    var n = this.rows().indexOf(e), a = e.getElement(), o = 0;
    return new Promise((s, l) => {
      if (n > -1) {
        if (typeof i > "u" && (i = this.table.options.scrollToRowIfVisible), !i && Wt.elVisible(a) && (o = Wt.elOffset(a).top - Wt.elOffset(this.elementVertical).top, o > 0 && o < this.elementVertical.clientHeight - a.offsetHeight))
          return s(), !1;
        switch (typeof t > "u" && (t = this.table.options.scrollToRowPosition), t === "nearest" && (t = this.scrollToRowNearestTop(e) ? "top" : "bottom"), this.scrollToRow(e), t) {
          case "middle":
          case "center":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop + (a.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - a.offsetTop) / 2 : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
            break;
          case "bottom":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - a.offsetTop) + a.offsetHeight : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + a.offsetHeight;
            break;
          case "top":
            this.elementVertical.scrollTop = a.offsetTop;
            break;
        }
        s();
      } else
        console.warn("Scroll Error - Row not visible"), l("Scroll Error - Row not visible");
    });
  }
}
class X$e extends AT {
  constructor(e) {
    super(e);
  }
  renderRowCells(e) {
    const t = document.createDocumentFragment();
    e.cells.forEach((i) => {
      t.appendChild(i.getElement());
    }), e.element.appendChild(t), e.cells.forEach((i) => {
      i.cellRendered();
    });
  }
  reinitializeColumnWidths(e) {
    e.forEach(function(t) {
      t.reinitializeWidth();
    });
  }
}
class Y$e extends AT {
  constructor(e) {
    super(e), this.leftCol = 0, this.rightCol = 0, this.scrollLeft = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0, this.fitDataColAvg = 0, this.windowBuffer = 200, this.visibleRows = null, this.initialized = !1, this.isFitData = !1, this.columns = [];
  }
  initialize() {
    this.compatibilityCheck(), this.layoutCheck(), this.vertScrollListen();
  }
  compatibilityCheck() {
    this.options("layout") == "fitDataTable" && console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode"), this.options("responsiveLayout") && console.warn("Horizontal Virtual DOM is not compatible with responsive columns"), this.options("rtl") && console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
  }
  layoutCheck() {
    this.isFitData = this.options("layout").startsWith("fitData");
  }
  vertScrollListen() {
    this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this)), this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
  }
  clearVisRowCache() {
    this.visibleRows = null;
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  renderColumns(e, t) {
    this.dataChange();
  }
  scrollColumns(e, t) {
    this.scrollLeft != e && (this.scrollLeft = e, this.scroll(e - (this.vDomScrollPosLeft + this.windowBuffer)));
  }
  calcWindowBuffer() {
    var e = this.elementVertical.clientWidth;
    this.table.columnManager.columnsByIndex.forEach((t) => {
      if (t.visible) {
        var i = t.getWidth();
        i > e && (e = i);
      }
    }), this.windowBuffer = e * 2;
  }
  rerenderColumns(e, t) {
    var i = {
      cols: this.columns,
      leftCol: this.leftCol,
      rightCol: this.rightCol
    }, n = 0;
    e && !this.initialized || (this.clear(), this.calcWindowBuffer(), this.scrollLeft = this.elementVertical.scrollLeft, this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer, this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, this.table.columnManager.columnsByIndex.forEach((a) => {
      var o = {}, s;
      a.visible && (a.modules.frozen || (s = a.getWidth(), o.leftPos = n, o.rightPos = n + s, o.width = s, this.isFitData && (o.fitDataCheck = a.modules.vdomHoz ? a.modules.vdomHoz.fitDataCheck : !0), n + s > this.vDomScrollPosLeft && n < this.vDomScrollPosRight ? (this.leftCol == -1 && (this.leftCol = this.columns.length, this.vDomPadLeft = n), this.rightCol = this.columns.length) : this.leftCol !== -1 && (this.vDomPadRight += s), this.columns.push(a), a.modules.vdomHoz = o, n += s));
    }), this.tableElement.style.paddingLeft = this.vDomPadLeft + "px", this.tableElement.style.paddingRight = this.vDomPadRight + "px", this.initialized = !0, t || (!e || this.reinitChanged(i)) && this.reinitializeRows(), this.elementVertical.scrollLeft = this.scrollLeft);
  }
  renderRowCells(e) {
    if (this.initialized)
      this.initializeRow(e);
    else {
      const t = document.createDocumentFragment();
      e.cells.forEach((i) => {
        t.appendChild(i.getElement());
      }), e.element.appendChild(t), e.cells.forEach((i) => {
        i.cellRendered();
      });
    }
  }
  rerenderRowCells(e, t) {
    this.reinitializeRow(e, t);
  }
  reinitializeColumnWidths(e) {
    for (let t = this.leftCol; t <= this.rightCol; t++)
      this.columns[t].reinitializeWidth();
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  deinitialize() {
    this.initialized = !1;
  }
  clear() {
    this.columns = [], this.leftCol = -1, this.rightCol = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0;
  }
  dataChange() {
    var e = !1, t, i;
    if (this.isFitData) {
      if (this.table.columnManager.columnsByIndex.forEach((n) => {
        !n.definition.width && n.visible && (e = !0);
      }), e && this.table.rowManager.getDisplayRows().length && (this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, t = this.chain("rows-sample", [1], [], () => this.table.rowManager.getDisplayRows())[0], t)) {
        i = t.getElement(), t.generateCells(), this.tableElement.appendChild(i);
        for (let n = 0; n < t.cells.length; n++) {
          let a = t.cells[n];
          i.appendChild(a.getElement()), a.column.reinitializeWidth();
        }
        i.parentNode.removeChild(i), this.rerenderColumns(!1, !0);
      }
    } else
      this.options("layout") === "fitColumns" && (this.layoutRefresh(), this.rerenderColumns(!1, !0));
  }
  reinitChanged(e) {
    var t = !0;
    return e.cols.length !== this.columns.length || e.leftCol !== this.leftCol || e.rightCol !== this.rightCol ? !0 : (e.cols.forEach((i, n) => {
      i !== this.columns[n] && (t = !1);
    }), !t);
  }
  reinitializeRows() {
    var e = this.getVisibleRows(), t = this.table.rowManager.getRows().filter((i) => !e.includes(i));
    e.forEach((i) => {
      this.reinitializeRow(i, !0);
    }), t.forEach((i) => {
      i.deinitialize();
    });
  }
  getVisibleRows() {
    return this.visibleRows || (this.visibleRows = this.table.rowManager.getVisibleRows()), this.visibleRows;
  }
  scroll(e) {
    this.vDomScrollPosLeft += e, this.vDomScrollPosRight += e, Math.abs(e) > this.windowBuffer / 2 ? this.rerenderColumns() : e > 0 ? (this.addColRight(), this.removeColLeft()) : (this.addColLeft(), this.removeColRight());
  }
  colPositionAdjust(e, t, i) {
    for (let n = e; n < t; n++) {
      let a = this.columns[n];
      a.modules.vdomHoz.leftPos += i, a.modules.vdomHoz.rightPos += i;
    }
  }
  addColRight() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.rightCol + 1];
      i && i.modules.vdomHoz.leftPos <= this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((n) => {
        if (n.type !== "group") {
          var a = n.getCell(i);
          n.getElement().insertBefore(a.getElement(), n.getCell(this.columns[this.rightCol]).getElement().nextSibling), a.cellRendered();
        }
      }), this.fitDataColActualWidthCheck(i), this.rightCol++, this.getVisibleRows().forEach((n) => {
        n.type !== "group" && (n.modules.vdomHoz.rightCol = this.rightCol);
      }), this.rightCol >= this.columns.length - 1 ? this.vDomPadRight = 0 : this.vDomPadRight -= i.getWidth()) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  addColLeft() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.leftCol - 1];
      if (i)
        if (i.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
          e = !0, this.getVisibleRows().forEach((a) => {
            if (a.type !== "group") {
              var o = a.getCell(i);
              a.getElement().insertBefore(o.getElement(), a.getCell(this.columns[this.leftCol]).getElement()), o.cellRendered();
            }
          }), this.leftCol--, this.getVisibleRows().forEach((a) => {
            a.type !== "group" && (a.modules.vdomHoz.leftCol = this.leftCol);
          }), this.leftCol <= 0 ? this.vDomPadLeft = 0 : this.vDomPadLeft -= i.getWidth();
          let n = this.fitDataColActualWidthCheck(i);
          n && (this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + n, this.vDomPadRight -= n);
        } else
          t = !1;
      else
        t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  removeColRight() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.rightCol];
      i && i.modules.vdomHoz.leftPos > this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((n) => {
        if (n.type !== "group") {
          var a = n.getCell(i);
          try {
            n.getElement().removeChild(a.getElement());
          } catch (o) {
            console.warn("Could not removeColRight", o.message);
          }
        }
      }), this.vDomPadRight += i.getWidth(), this.rightCol--, this.getVisibleRows().forEach((n) => {
        n.type !== "group" && (n.modules.vdomHoz.rightCol = this.rightCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  removeColLeft() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.leftCol];
      i && i.modules.vdomHoz.rightPos < this.vDomScrollPosLeft ? (e = !0, this.getVisibleRows().forEach((n) => {
        if (n.type !== "group") {
          var a = n.getCell(i);
          try {
            n.getElement().removeChild(a.getElement());
          } catch (o) {
            console.warn("Could not removeColLeft", o.message);
          }
        }
      }), this.vDomPadLeft += i.getWidth(), this.leftCol++, this.getVisibleRows().forEach((n) => {
        n.type !== "group" && (n.modules.vdomHoz.leftCol = this.leftCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  fitDataColActualWidthCheck(e) {
    var t, i;
    return e.modules.vdomHoz.fitDataCheck && (e.reinitializeWidth(), t = e.getWidth(), i = t - e.modules.vdomHoz.width, i && (e.modules.vdomHoz.rightPos += i, e.modules.vdomHoz.width = t, this.colPositionAdjust(this.columns.indexOf(e) + 1, this.columns.length, i)), e.modules.vdomHoz.fitDataCheck = !1), i;
  }
  initializeRow(e) {
    if (e.type !== "group") {
      e.modules.vdomHoz = {
        leftCol: this.leftCol,
        rightCol: this.rightCol
      }, this.table.modules.frozenColumns && this.table.modules.frozenColumns.leftColumns.forEach((t) => {
        this.appendCell(e, t);
      });
      for (let t = this.leftCol; t <= this.rightCol; t++)
        this.appendCell(e, this.columns[t]);
      this.table.modules.frozenColumns && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
        this.appendCell(e, t);
      });
    }
  }
  appendCell(e, t) {
    if (t && t.visible) {
      let i = e.getCell(t);
      e.getElement().appendChild(i.getElement()), i.cellRendered();
    }
  }
  reinitializeRow(e, t) {
    if (e.type !== "group" && (t || !e.modules.vdomHoz || e.modules.vdomHoz.leftCol !== this.leftCol || e.modules.vdomHoz.rightCol !== this.rightCol)) {
      for (var i = e.getElement(); i.firstChild; )
        i.removeChild(i.firstChild);
      this.initializeRow(e);
    }
  }
}
class H$e extends zi {
  constructor(e) {
    super(e), this.blockHozScrollEvent = !1, this.headersElement = null, this.contentsElement = null, this.element = null, this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.scrollLeft = 0, this.optionsList = new v8(this.table, "column definition", d8), this.redrawBlock = !1, this.redrawBlockUpdate = null, this.renderer = null;
  }
  ////////////// Setup Functions /////////////////
  initialize() {
    this.initializeRenderer(), this.headersElement = this.createHeadersElement(), this.contentsElement = this.createHeaderContentsElement(), this.element = this.createHeaderElement(), this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild), this.element.insertBefore(this.contentsElement, this.element.firstChild), this.initializeScrollWheelWatcher(), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
  }
  padVerticalScrollbar(e) {
    this.table.rtl ? this.headersElement.style.marginLeft = e + "px" : this.headersElement.style.marginRight = e + "px";
  }
  initializeRenderer() {
    var e, t = {
      virtual: Y$e,
      basic: X$e
    };
    typeof this.table.options.renderHorizontal == "string" ? e = t[this.table.options.renderHorizontal] : e = this.table.options.renderHorizontal, e ? (this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize()) : console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
  }
  createHeadersElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-headers"), e.setAttribute("role", "row"), e;
  }
  createHeaderContentsElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header-contents"), e.setAttribute("role", "rowgroup"), e;
  }
  createHeaderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header"), e.setAttribute("role", "rowgroup"), this.table.options.headerVisible || e.classList.add("tabulator-header-hidden"), e;
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return containing contents element
  getContentsElement() {
    return this.contentsElement;
  }
  //return header containing element
  getHeadersElement() {
    return this.headersElement;
  }
  //scroll horizontally to match table body
  scrollHorizontal(e) {
    this.contentsElement.scrollLeft = e, this.scrollLeft = e, this.renderer.scrollColumns(e);
  }
  initializeScrollWheelWatcher() {
    this.contentsElement.addEventListener("wheel", (e) => {
      var t;
      e.deltaX && (t = this.contentsElement.scrollLeft + e.deltaX, this.table.rowManager.scrollHorizontal(t), this.table.columnManager.scrollHorizontal(t));
    });
  }
  ///////////// Column Setup Functions /////////////
  generateColumnsFromRowData(e) {
    var t = [], i = this.table.options.autoColumnsDefinitions, n, a;
    if (e && e.length) {
      n = e[0];
      for (var o in n) {
        let s = {
          field: o,
          title: o
        }, l = n[o];
        switch (typeof l) {
          case "undefined":
            a = "string";
            break;
          case "boolean":
            a = "boolean";
            break;
          case "object":
            Array.isArray(l) ? a = "array" : a = "string";
            break;
          default:
            !isNaN(l) && l !== "" ? a = "number" : l.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) ? a = "alphanum" : a = "string";
            break;
        }
        s.sorter = a, t.push(s);
      }
      if (i)
        switch (typeof i) {
          case "function":
            this.table.options.columns = i.call(this.table, t);
            break;
          case "object":
            Array.isArray(i) ? t.forEach((s) => {
              var l = i.find((u) => u.field === s.field);
              l && Object.assign(s, l);
            }) : t.forEach((s) => {
              i[s.field] && Object.assign(s, i[s.field]);
            }), this.table.options.columns = t;
            break;
        }
      else
        this.table.options.columns = t;
      this.setColumns(this.table.options.columns);
    }
  }
  setColumns(e, t) {
    for (; this.headersElement.firstChild; )
      this.headersElement.removeChild(this.headersElement.firstChild);
    this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.dispatch("columns-loading"), e.forEach((i, n) => {
      this._addColumn(i);
    }), this._reIndexColumns(), this.dispatch("columns-loaded"), this.rerenderColumns(!1, !0), this.redraw(!0);
  }
  _addColumn(e, t, i) {
    var n = new ro(e, this), a = n.getElement(), o = i && this.findColumnIndex(i);
    if (i && o > -1) {
      var s = i.getTopColumn(), l = this.columns.indexOf(s), u = s.getElement();
      t ? (this.columns.splice(l, 0, n), u.parentNode.insertBefore(a, u)) : (this.columns.splice(l + 1, 0, n), u.parentNode.insertBefore(a, u.nextSibling));
    } else
      t ? (this.columns.unshift(n), this.headersElement.insertBefore(n.getElement(), this.headersElement.firstChild)) : (this.columns.push(n), this.headersElement.appendChild(n.getElement()));
    return n.columnRendered(), n;
  }
  registerColumnField(e) {
    e.definition.field && (this.columnsByField[e.definition.field] = e);
  }
  registerColumnPosition(e) {
    this.columnsByIndex.push(e);
  }
  _reIndexColumns() {
    this.columnsByIndex = [], this.columns.forEach(function(e) {
      e.reRegisterPosition();
    });
  }
  //ensure column headers take up the correct amount of space in column groups
  verticalAlignHeaders() {
    var e = 0;
    this.redrawBlock || (this.headersElement.style.height = "", this.columns.forEach((t) => {
      t.clearVerticalAlign();
    }), this.columns.forEach((t) => {
      var i = t.getHeight();
      i > e && (e = i);
    }), this.headersElement.style.height = e + "px", this.columns.forEach((t) => {
      t.verticalAlign(this.table.options.columnHeaderVertAlign, e);
    }), this.table.rowManager.adjustTableSize());
  }
  //////////////// Column Details /////////////////
  findColumn(e) {
    var t;
    if (typeof e == "object") {
      if (e instanceof ro)
        return e;
      if (e instanceof f8)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return t = [], this.columns.forEach((n) => {
          t.push(n), t = t.concat(n.getColumns(!0));
        }), t.find((n) => n.element === e) || !1;
    } else
      return this.columnsByField[e] || !1;
    return !1;
  }
  getColumnByField(e) {
    return this.columnsByField[e];
  }
  getColumnsByFieldRoot(e) {
    var t = [];
    return Object.keys(this.columnsByField).forEach((i) => {
      var n = i.split(".")[0];
      n === e && t.push(this.columnsByField[i]);
    }), t;
  }
  getColumnByIndex(e) {
    return this.columnsByIndex[e];
  }
  getFirstVisibleColumn() {
    var e = this.columnsByIndex.findIndex((t) => t.visible);
    return e > -1 ? this.columnsByIndex[e] : !1;
  }
  getColumns() {
    return this.columns;
  }
  findColumnIndex(e) {
    return this.columnsByIndex.findIndex((t) => e === t);
  }
  //return all columns that are not groups
  getRealColumns() {
    return this.columnsByIndex;
  }
  //traverse across columns and call action
  traverse(e) {
    this.columnsByIndex.forEach((t, i) => {
      e(t, i);
    });
  }
  //get definitions of actual columns
  getDefinitions(e) {
    var t = [];
    return this.columnsByIndex.forEach((i) => {
      (!e || e && i.visible) && t.push(i.getDefinition());
    }), t;
  }
  //get full nested definition tree
  getDefinitionTree() {
    var e = [];
    return this.columns.forEach((t) => {
      e.push(t.getDefinition(!0));
    }), e;
  }
  getComponents(e) {
    var t = [], i = e ? this.columns : this.columnsByIndex;
    return i.forEach((n) => {
      t.push(n.getComponent());
    }), t;
  }
  getWidth() {
    var e = 0;
    return this.columnsByIndex.forEach((t) => {
      t.visible && (e += t.getWidth());
    }), e;
  }
  moveColumn(e, t, i) {
    t.element.parentNode.insertBefore(e.element, t.element), i && t.element.parentNode.insertBefore(t.element, e.element), this.moveColumnActual(e, t, i), this.verticalAlignHeaders(), this.table.rowManager.reinitialize();
  }
  moveColumnActual(e, t, i) {
    e.parent.isGroup ? this._moveColumnInArray(e.parent.columns, e, t, i) : this._moveColumnInArray(this.columns, e, t, i), this._moveColumnInArray(this.columnsByIndex, e, t, i, !0), this.rerenderColumns(!0), this.dispatch("column-moved", e, t, i), this.subscribedExternal("columnMoved") && this.dispatchExternal("columnMoved", e.getComponent(), this.table.columnManager.getComponents());
  }
  _moveColumnInArray(e, t, i, n, a) {
    var o = e.indexOf(t), s, l = [];
    o > -1 && (e.splice(o, 1), s = e.indexOf(i), s > -1 ? n && (s = s + 1) : s = o, e.splice(s, 0, t), a && (l = this.chain("column-moving-rows", [t, i, n], null, []) || [], l = l.concat(this.table.rowManager.rows), l.forEach(function(u) {
      if (u.cells.length) {
        var h = u.cells.splice(o, 1)[0];
        u.cells.splice(s, 0, h);
      }
    })));
  }
  scrollToColumn(e, t, i) {
    var n = 0, a = e.getLeftOffset(), o = 0, s = e.getElement();
    return new Promise((l, u) => {
      if (typeof t > "u" && (t = this.table.options.scrollToColumnPosition), typeof i > "u" && (i = this.table.options.scrollToColumnIfVisible), e.visible) {
        switch (t) {
          case "middle":
          case "center":
            o = -this.element.clientWidth / 2;
            break;
          case "right":
            o = s.clientWidth - this.headersElement.clientWidth;
            break;
        }
        if (!i && a > 0 && a + s.offsetWidth < this.element.clientWidth)
          return !1;
        n = a + o, n = Math.max(Math.min(n, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0), this.table.rowManager.scrollHorizontal(n), this.scrollHorizontal(n), l();
      } else
        console.warn("Scroll Error - Column not visible"), u("Scroll Error - Column not visible");
    });
  }
  //////////////// Cell Management /////////////////
  generateCells(e) {
    var t = [];
    return this.columnsByIndex.forEach((i) => {
      t.push(i.generateCell(e));
    }), t;
  }
  //////////////// Column Management /////////////////
  getFlexBaseWidth() {
    var e = this.table.element.clientWidth, t = 0;
    return this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (e -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), this.columnsByIndex.forEach(function(i) {
      var n, a, o;
      i.visible && (n = i.definition.width || 0, a = parseInt(i.minWidth), typeof n == "string" ? n.indexOf("%") > -1 ? o = e / 100 * parseInt(n) : o = parseInt(n) : o = n, t += o > a ? o : a);
    }), t;
  }
  addColumn(e, t, i) {
    return new Promise((n, a) => {
      var o = this._addColumn(e, t, i);
      this._reIndexColumns(), this.dispatch("column-add", e, t, i), this.layoutMode() != "fitColumns" && o.reinitializeWidth(), this.redraw(!0), this.table.rowManager.reinitialize(), this.rerenderColumns(), n(o);
    });
  }
  //remove column from system
  deregisterColumn(e) {
    var t = e.getField(), i;
    t && delete this.columnsByField[t], i = this.columnsByIndex.indexOf(e), i > -1 && this.columnsByIndex.splice(i, 1), i = this.columns.indexOf(e), i > -1 && this.columns.splice(i, 1), this.verticalAlignHeaders(), this.redraw();
  }
  rerenderColumns(e, t) {
    this.redrawBlock ? (e === !1 || e === !0 && this.redrawBlockUpdate === null) && (this.redrawBlockUpdate = e) : this.renderer.rerenderColumns(e, t);
  }
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockUpdate = null;
  }
  restoreRedraw() {
    this.redrawBlock = !1, this.verticalAlignHeaders(), this.renderer.rerenderColumns(this.redrawBlockUpdate);
  }
  //redraw columns
  redraw(e) {
    Wt.elVisible(this.element) && this.verticalAlignHeaders(), e && (this.table.rowManager.resetScroll(), this.table.rowManager.reinitialize()), this.confirm("table-redrawing", e) || this.layoutRefresh(e), this.dispatch("table-redraw", e), this.table.footerManager.redraw();
  }
}
class W$e extends AT {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0;
  }
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.scrollTop = 0, e.scrollLeft = 0, e.style.minWidth = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "";
  }
  renderRows() {
    var e = this.tableElement, t = !0, i = document.createDocumentFragment();
    this.rows().forEach((n, a) => {
      this.styleRow(n, a), n.initialize(!0), n.type !== "group" && (t = !1), i.appendChild(n.getElement());
    }), e.appendChild(i), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
  rerenderRows(e) {
    this.clearRows(), e && e(), this.renderRows();
  }
  scrollToRowNearestTop(e) {
    var t = Wt.elOffset(e.getElement()).top;
    return !(Math.abs(this.elementVertical.scrollTop - t) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - t));
  }
  scrollToRow(e) {
    var t = e.getElement();
    this.elementVertical.scrollTop = Wt.elOffset(t).top - Wt.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
  }
  visibleRows(e) {
    return this.rows();
  }
}
class z$e extends AT {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.vDomRowHeight = 20, this.vDomTop = 0, this.vDomBottom = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomMaxRenderChain = 90, this.vDomWindowBuffer = 0, this.vDomWindowMinTotalRows = 20, this.vDomWindowMinMarginRows = 5, this.vDomTopNewRows = [], this.vDomBottomNewRows = [];
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.style.paddingTop = "", e.style.paddingBottom = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "", this.elementVertical.scrollTop = 0, this.elementVertical.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0, this.vDomTop = 0, this.vDomBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0;
  }
  renderRows() {
    this._virtualRenderFill();
  }
  rerenderRows(e) {
    for (var t = this.elementVertical.scrollTop, i = !1, n = !1, a = this.table.rowManager.scrollLeft, o = this.rows(), s = this.vDomTop; s <= this.vDomBottom; s++)
      if (o[s]) {
        var l = t - o[s].getElement().offsetTop;
        if (n === !1 || Math.abs(l) < n)
          n = l, i = s;
        else
          break;
      }
    o.forEach((u) => {
      u.deinitializeHeight();
    }), e && e(), this.rows().length ? this._virtualRenderFill(i === !1 ? this.rows.length - 1 : i, !0, n || 0) : (this.clear(), this.table.rowManager.tableEmpty()), this.scrollColumns(a);
  }
  scrollColumns(e) {
    this.table.rowManager.scrollHorizontal(e);
  }
  scrollRows(e, t) {
    var i = e - this.vDomScrollPosTop, n = e - this.vDomScrollPosBottom, a = this.vDomWindowBuffer * 2, o = this.rows();
    if (this.scrollTop = e, -i > a || n > a) {
      var s = this.table.rowManager.scrollLeft;
      this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * o.length)), this.scrollColumns(s);
    } else
      t ? (i < 0 && this._addTopRow(o, -i), n < 0 && (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer ? this._removeBottomRow(o, -n) : this.vDomScrollPosBottom = this.scrollTop)) : (n >= 0 && this._addBottomRow(o, n), i >= 0 && (this.scrollTop > this.vDomWindowBuffer ? this._removeTopRow(o, i) : this.vDomScrollPosTop = this.scrollTop));
  }
  resize() {
    this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
  }
  scrollToRowNearestTop(e) {
    var t = this.rows().indexOf(e);
    return !(Math.abs(this.vDomTop - t) > Math.abs(this.vDomBottom - t));
  }
  scrollToRow(e) {
    var t = this.rows().indexOf(e);
    t > -1 && this._virtualRenderFill(t, !0);
  }
  visibleRows(e) {
    var t = this.elementVertical.scrollTop, i = this.elementVertical.clientHeight + t, n = !1, a = 0, o = 0, s = this.rows();
    if (e)
      a = this.vDomTop, o = this.vDomBottom;
    else
      for (var l = this.vDomTop; l <= this.vDomBottom; l++)
        if (s[l])
          if (n)
            if (i - s[l].getElement().offsetTop >= 0)
              o = l;
            else
              break;
          else if (t - s[l].getElement().offsetTop >= 0)
            a = l;
          else if (n = !0, i - s[l].getElement().offsetTop >= 0)
            o = l;
          else
            break;
    return s.slice(a, o + 1);
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  //full virtual render
  _virtualRenderFill(e, t, i) {
    var n = this.tableElement, a = this.elementVertical, o = 0, s = 0, l = 0, u = 0, h = 0, c = 0, f = this.rows(), d = f.length, p = 0, g, v, O = [], m = 0, E = 0, b = this.table.rowManager.fixedHeight, T = this.elementVertical.clientHeight, S = this.table.options.rowHeight, y = !0;
    if (e = e || 0, i = i || 0, !e)
      this.clear();
    else {
      for (; n.firstChild; )
        n.removeChild(n.firstChild);
      u = (d - e + 1) * this.vDomRowHeight, u < T && (e -= Math.ceil((T - u) / this.vDomRowHeight), e < 0 && (e = 0)), o = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), e), e -= o;
    }
    if (d && Wt.elVisible(this.elementVertical)) {
      for (this.vDomTop = e, this.vDomBottom = e - 1, b || this.table.options.maxHeight ? (S && (E = T / S + this.vDomWindowBuffer / S), E = Math.max(this.vDomWindowMinTotalRows, Math.ceil(E))) : E = d; (E == d || s <= T + this.vDomWindowBuffer || m < this.vDomWindowMinTotalRows) && this.vDomBottom < d - 1; ) {
        for (O = [], v = document.createDocumentFragment(), c = 0; c < E && this.vDomBottom < d - 1; )
          p = this.vDomBottom + 1, g = f[p], this.styleRow(g, p), g.initialize(), !g.heightInitialized && !this.table.options.rowHeight && g.clearCellHeight(), v.appendChild(g.getElement()), O.push(g), this.vDomBottom++, c++;
        if (!O.length)
          break;
        n.appendChild(v), O.forEach((A) => {
          A.heightInitialized || A.calcHeight(!0);
        }), O.forEach((A) => {
          A.heightInitialized || A.setCellHeight();
        }), O.forEach((A) => {
          l = A.getHeight(), m < o ? h += l : s += l, l > this.vDomWindowBuffer && (this.vDomWindowBuffer = l * 2), m++;
        }), y = this.table.rowManager.adjustTableSize(), T = this.elementVertical.clientHeight, y && (b || this.table.options.maxHeight) && (S = s / m, E = Math.max(this.vDomWindowMinTotalRows, Math.ceil(T / S + this.vDomWindowBuffer / S)));
      }
      e ? (this.vDomTopPad = t ? this.vDomRowHeight * this.vDomTop + i : this.scrollTop - h, this.vDomBottomPad = this.vDomBottom == d - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - s - h, 0)) : (this.vDomTopPad = 0, this.vDomRowHeight = Math.floor((s + h) / m), this.vDomBottomPad = this.vDomRowHeight * (d - this.vDomBottom - 1), this.vDomScrollHeight = h + s + this.vDomBottomPad - T), n.style.paddingTop = this.vDomTopPad + "px", n.style.paddingBottom = this.vDomBottomPad + "px", t && (this.scrollTop = this.vDomTopPad + h + i - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - T : 0)), this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - T), this.elementVertical.scrollWidth > this.elementVertical.clientWidth && t && (this.scrollTop += this.elementVertical.offsetHeight - T), this.vDomScrollPosTop = this.scrollTop, this.vDomScrollPosBottom = this.scrollTop, a.scrollTop = this.scrollTop, this.dispatch("render-virtual-fill");
    }
  }
  _addTopRow(e, t) {
    for (var i = this.tableElement, n = [], a = 0, o = this.vDomTop - 1, s = 0, l = !0; l; )
      if (this.vDomTop) {
        let u = e[o], h, c;
        u && s < this.vDomMaxRenderChain ? (h = u.getHeight() || this.vDomRowHeight, c = u.initialized, t >= h ? (this.styleRow(u, o), i.insertBefore(u.getElement(), i.firstChild), (!u.initialized || !u.heightInitialized) && n.push(u), u.initialize(), c || (h = u.getElement().offsetHeight, h > this.vDomWindowBuffer && (this.vDomWindowBuffer = h * 2)), t -= h, a += h, this.vDomTop--, o--, s++) : l = !1) : l = !1;
      } else
        l = !1;
    for (let u of n)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(n), a && (this.vDomTopPad -= a, this.vDomTopPad < 0 && (this.vDomTopPad = o * this.vDomRowHeight), o < 1 && (this.vDomTopPad = 0), i.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop -= a);
  }
  _removeTopRow(e, t) {
    for (var i = [], n = 0, a = 0, o = !0; o; ) {
      let s = e[this.vDomTop], l;
      s && a < this.vDomMaxRenderChain ? (l = s.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomTop++, t -= l, n += l, i.push(s), a++) : o = !1) : o = !1;
    }
    for (let s of i) {
      let l = s.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    n && (this.vDomTopPad += n, this.tableElement.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop += this.vDomTop ? n : n + this.vDomWindowBuffer);
  }
  _addBottomRow(e, t) {
    for (var i = this.tableElement, n = [], a = 0, o = this.vDomBottom + 1, s = 0, l = !0; l; ) {
      let u = e[o], h, c;
      u && s < this.vDomMaxRenderChain ? (h = u.getHeight() || this.vDomRowHeight, c = u.initialized, t >= h ? (this.styleRow(u, o), i.appendChild(u.getElement()), (!u.initialized || !u.heightInitialized) && n.push(u), u.initialize(), c || (h = u.getElement().offsetHeight, h > this.vDomWindowBuffer && (this.vDomWindowBuffer = h * 2)), t -= h, a += h, this.vDomBottom++, o++, s++) : l = !1) : l = !1;
    }
    for (let u of n)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(n), a && (this.vDomBottomPad -= a, (this.vDomBottomPad < 0 || o == e.length - 1) && (this.vDomBottomPad = 0), i.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom += a);
  }
  _removeBottomRow(e, t) {
    for (var i = [], n = 0, a = 0, o = !0; o; ) {
      let s = e[this.vDomBottom], l;
      s && a < this.vDomMaxRenderChain ? (l = s.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomBottom--, t -= l, n += l, i.push(s), a++) : o = !1) : o = !1;
    }
    for (let s of i) {
      let l = s.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    n && (this.vDomBottomPad += n, this.vDomBottomPad < 0 && (this.vDomBottomPad = 0), this.tableElement.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom -= n);
  }
  _quickNormalizeRowHeight(e) {
    for (let t of e)
      t.calcHeight();
    for (let t of e)
      t.setCellHeight();
  }
}
class Z$e extends zi {
  constructor(e) {
    super(e), this.element = this.createHolderElement(), this.tableElement = this.createTableElement(), this.heightFixer = this.createTableElement(), this.placeholder = null, this.placeholderContents = null, this.firstRender = !1, this.renderMode = "virtual", this.fixedHeight = !1, this.rows = [], this.activeRowsPipeline = [], this.activeRows = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0, this.scrollTop = 0, this.scrollLeft = 0, this.redrawBlock = !1, this.redrawBlockRestoreConfig = !1, this.redrawBlockRenderInPosition = !1, this.dataPipeline = [], this.displayPipeline = [], this.scrollbarWidth = 0, this.renderer = null;
  }
  //////////////// Setup Functions /////////////////
  createHolderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-tableholder"), e.setAttribute("tabindex", 0), e;
  }
  createTableElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-table"), e.setAttribute("role", "rowgroup"), e;
  }
  initializePlaceholder() {
    var e = this.table.options.placeholder;
    if (typeof e == "function" && (e = e.call(this.table)), e = this.chain("placeholder", [e], e, e) || e, e) {
      let t = document.createElement("div");
      if (t.classList.add("tabulator-placeholder"), typeof e == "string") {
        let i = document.createElement("div");
        i.classList.add("tabulator-placeholder-contents"), i.innerHTML = e, t.appendChild(i), this.placeholderContents = i;
      } else
        typeof HTMLElement < "u" && e instanceof HTMLElement ? (t.appendChild(e), this.placeholderContents = e) : (console.warn("Invalid placeholder provided, must be string or HTML Element", e), this.el = null);
      this.placeholder = t;
    }
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return table element
  getTableElement() {
    return this.tableElement;
  }
  initialize() {
    this.initializePlaceholder(), this.initializeRenderer(), this.element.appendChild(this.tableElement), this.firstRender = !0, this.element.addEventListener("scroll", () => {
      var e = this.element.scrollLeft, t = this.scrollLeft > e, i = this.element.scrollTop, n = this.scrollTop > i;
      this.scrollLeft != e && (this.scrollLeft = e, this.dispatch("scroll-horizontal", e, t), this.dispatchExternal("scrollHorizontal", e, t), this._positionPlaceholder()), this.scrollTop != i && (this.scrollTop = i, this.renderer.scrollRows(i, n), this.dispatch("scroll-vertical", i, n), this.dispatchExternal("scrollVertical", i, n));
    });
  }
  ////////////////// Row Manipulation //////////////////
  findRow(e) {
    if (typeof e == "object") {
      if (e instanceof Ti)
        return e;
      if (e instanceof yT)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return this.rows.find((i) => i.getElement() === e) || !1;
      if (e === null)
        return !1;
    } else
      return typeof e > "u" ? !1 : this.rows.find((i) => i.data[this.table.options.index] == e) || !1;
    return !1;
  }
  getRowFromDataObject(e) {
    var t = this.rows.find((i) => i.data === e);
    return t || !1;
  }
  getRowFromPosition(e) {
    return this.getDisplayRows().find((t) => t.getPosition() === e && t.isDisplayed());
  }
  scrollToRow(e, t, i) {
    return this.renderer.scrollToRowPosition(e, t, i);
  }
  ////////////////// Data Handling //////////////////
  setData(e, t, i) {
    return new Promise((n, a) => {
      t && this.getDisplayRows().length ? this.table.options.pagination ? this._setDataActual(e, !0) : this.reRenderInPosition(() => {
        this._setDataActual(e);
      }) : (this.table.options.autoColumns && i && this.table.initialized && this.table.columnManager.generateColumnsFromRowData(e), this.resetScroll(), this._setDataActual(e)), n();
    });
  }
  _setDataActual(e, t) {
    this.dispatchExternal("dataProcessing", e), this._wipeElements(), Array.isArray(e) ? (this.dispatch("data-processing", e), e.forEach((i, n) => {
      if (i && typeof i == "object") {
        var a = new Ti(i, this);
        this.rows.push(a);
      } else
        console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", i);
    }), this.refreshActiveData(!1, !1, t), this.dispatch("data-processed", e), this.dispatchExternal("dataProcessed", e)) : console.error(`Data Loading Error - Unable to process data due to invalid data type 
Expecting: array 
Received: `, typeof e, `
Data:     `, e);
  }
  _wipeElements() {
    this.dispatch("rows-wipe"), this.destroy(), this.adjustTableSize(), this.dispatch("rows-wiped");
  }
  destroy() {
    this.rows.forEach((e) => {
      e.wipe();
    }), this.rows = [], this.activeRows = [], this.activeRowsPipeline = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0;
  }
  deleteRow(e, t) {
    var i = this.rows.indexOf(e), n = this.activeRows.indexOf(e);
    n > -1 && this.activeRows.splice(n, 1), i > -1 && this.rows.splice(i, 1), this.setActiveRows(this.activeRows), this.displayRowIterator((a) => {
      var o = a.indexOf(e);
      o > -1 && a.splice(o, 1);
    }), t || this.reRenderInPosition(), this.regenerateRowPositions(), this.dispatchExternal("rowDeleted", e.getComponent()), this.displayRowsCount || this.tableEmpty(), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.getData());
  }
  addRow(e, t, i, n) {
    var a = this.addRowActual(e, t, i, n);
    return a;
  }
  //add multiple rows
  addRows(e, t, i, n) {
    var a = [];
    return new Promise((o, s) => {
      t = this.findAddRowPos(t), Array.isArray(e) || (e = [e]), (typeof i > "u" && t || typeof i < "u" && !t) && e.reverse(), e.forEach((l, u) => {
        var h = this.addRow(l, t, i, !0);
        a.push(h), this.dispatch("row-added", h, l, t, i);
      }), this.refreshActiveData(n ? "displayPipeline" : !1, !1, !0), this.regenerateRowPositions(), a.length && this._clearPlaceholder(), o(a);
    });
  }
  findAddRowPos(e) {
    return typeof e > "u" && (e = this.table.options.addRowPos), e === "pos" && (e = !0), e === "bottom" && (e = !1), e;
  }
  addRowActual(e, t, i, n) {
    var a = e instanceof Ti ? e : new Ti(e || {}, this), o = this.findAddRowPos(t), s = -1, l, u;
    return i || (u = this.chain("row-adding-position", [a, o], null, { index: i, top: o }), i = u.index, o = u.top), typeof i < "u" && (i = this.findRow(i)), i = this.chain("row-adding-index", [a, i, o], null, i), i && (s = this.rows.indexOf(i)), i && s > -1 ? (l = this.activeRows.indexOf(i), this.displayRowIterator(function(h) {
      var c = h.indexOf(i);
      c > -1 && h.splice(o ? c : c + 1, 0, a);
    }), l > -1 && this.activeRows.splice(o ? l : l + 1, 0, a), this.rows.splice(o ? s : s + 1, 0, a)) : o ? (this.displayRowIterator(function(h) {
      h.unshift(a);
    }), this.activeRows.unshift(a), this.rows.unshift(a)) : (this.displayRowIterator(function(h) {
      h.push(a);
    }), this.activeRows.push(a), this.rows.push(a)), this.setActiveRows(this.activeRows), this.dispatchExternal("rowAdded", a.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), n || this.reRenderInPosition(), a;
  }
  moveRow(e, t, i) {
    this.dispatch("row-move", e, t, i), this.moveRowActual(e, t, i), this.regenerateRowPositions(), this.dispatch("row-moved", e, t, i), this.dispatchExternal("rowMoved", e.getComponent());
  }
  moveRowActual(e, t, i) {
    this.moveRowInArray(this.rows, e, t, i), this.moveRowInArray(this.activeRows, e, t, i), this.displayRowIterator((n) => {
      this.moveRowInArray(n, e, t, i);
    }), this.dispatch("row-moving", e, t, i);
  }
  moveRowInArray(e, t, i, n) {
    var a, o, s, l;
    if (t !== i && (a = e.indexOf(t), a > -1 && (e.splice(a, 1), o = e.indexOf(i), o > -1 ? n ? e.splice(o + 1, 0, t) : e.splice(o, 0, t) : e.splice(a, 0, t)), e === this.getDisplayRows())) {
      s = a < o ? a : o, l = o > a ? o : a + 1;
      for (let u = s; u <= l; u++)
        e[u] && this.styleRow(e[u], u);
    }
  }
  clearData() {
    this.setData([]);
  }
  getRowIndex(e) {
    return this.findRowIndex(e, this.rows);
  }
  getDisplayRowIndex(e) {
    var t = this.getDisplayRows().indexOf(e);
    return t > -1 ? t : !1;
  }
  nextDisplayRow(e, t) {
    var i = this.getDisplayRowIndex(e), n = !1;
    return i !== !1 && i < this.displayRowsCount - 1 && (n = this.getDisplayRows()[i + 1]), n && (!(n instanceof Ti) || n.type != "row") ? this.nextDisplayRow(n, t) : n;
  }
  prevDisplayRow(e, t) {
    var i = this.getDisplayRowIndex(e), n = !1;
    return i && (n = this.getDisplayRows()[i - 1]), t && n && (!(n instanceof Ti) || n.type != "row") ? this.prevDisplayRow(n, t) : n;
  }
  findRowIndex(e, t) {
    var i;
    return e = this.findRow(e), e && (i = t.indexOf(e), i > -1) ? i : !1;
  }
  getData(e, t) {
    var i = [], n = this.getRows(e);
    return n.forEach(function(a) {
      a.type == "row" && i.push(a.getData(t || "data"));
    }), i;
  }
  getComponents(e) {
    var t = [], i = this.getRows(e);
    return i.forEach(function(n) {
      t.push(n.getComponent());
    }), t;
  }
  getDataCount(e) {
    var t = this.getRows(e);
    return t.length;
  }
  scrollHorizontal(e) {
    this.scrollLeft = e, this.element.scrollLeft = e, this.dispatch("scroll-horizontal", e);
  }
  registerDataPipelineHandler(e, t) {
    typeof t < "u" ? (this.dataPipeline.push({ handler: e, priority: t }), this.dataPipeline.sort((i, n) => i.priority - n.priority)) : console.error("Data pipeline handlers must have a priority in order to be registered");
  }
  registerDisplayPipelineHandler(e, t) {
    typeof t < "u" ? (this.displayPipeline.push({ handler: e, priority: t }), this.displayPipeline.sort((i, n) => i.priority - n.priority)) : console.error("Display pipeline handlers must have a priority in order to be registered");
  }
  //set active data set
  refreshActiveData(e, t, i) {
    var n = this.table, a = "", o = 0, s = ["all", "dataPipeline", "display", "displayPipeline", "end"];
    if (!this.table.destroyed) {
      if (typeof e == "function")
        if (o = this.dataPipeline.findIndex((l) => l.handler === e), o > -1)
          a = "dataPipeline", t && (o == this.dataPipeline.length - 1 ? a = "display" : o++);
        else if (o = this.displayPipeline.findIndex((l) => l.handler === e), o > -1)
          a = "displayPipeline", t && (o == this.displayPipeline.length - 1 ? a = "end" : o++);
        else {
          console.error("Unable to refresh data, invalid handler provided", e);
          return;
        }
      else
        a = e || "all", o = 0;
      if (this.redrawBlock) {
        (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === a && o < this.redrawBlockRestoreConfig.index || s.indexOf(a) < s.indexOf(this.redrawBlockRestoreConfig.stage))) && (this.redrawBlockRestoreConfig = {
          handler: e,
          skipStage: t,
          renderInPosition: i,
          stage: a,
          index: o
        });
        return;
      } else
        Wt.elVisible(this.element) ? i ? this.reRenderInPosition(this.refreshPipelines.bind(this, e, a, o, i)) : (this.refreshPipelines(e, a, o, i), e || this.table.columnManager.renderer.renderColumns(), this.renderTable(), n.options.layoutColumnsOnNewData && this.table.columnManager.redraw(!0)) : this.refreshPipelines(e, a, o, i), this.dispatch("data-refreshed");
    }
  }
  refreshPipelines(e, t, i, n) {
    switch (this.dispatch("data-refreshing"), e || (this.activeRowsPipeline[0] = this.rows.slice(0)), t) {
      case "all":
      case "dataPipeline":
        for (let a = i; a < this.dataPipeline.length; a++) {
          let o = this.dataPipeline[a].handler(this.activeRowsPipeline[a].slice(0));
          this.activeRowsPipeline[a + 1] = o || this.activeRowsPipeline[a].slice(0);
        }
        this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
      case "display":
        i = 0, this.resetDisplayRows();
      case "displayPipeline":
        for (let a = i; a < this.displayPipeline.length; a++) {
          let o = this.displayPipeline[a].handler((a ? this.getDisplayRows(a - 1) : this.activeRows).slice(0), n);
          this.setDisplayRows(o || this.getDisplayRows(a - 1).slice(0), a);
        }
      case "end":
        this.regenerateRowPositions();
    }
    this.getDisplayRows().length && this._clearPlaceholder();
  }
  //regenerate row positions
  regenerateRowPositions() {
    var e = this.getDisplayRows(), t = 1;
    e.forEach((i) => {
      i.type === "row" && (i.setPosition(t), t++);
    });
  }
  setActiveRows(e) {
    this.activeRows = this.activeRows = Object.assign([], e), this.activeRowsCount = this.activeRows.length;
  }
  //reset display rows array
  resetDisplayRows() {
    this.displayRows = [], this.displayRows.push(this.activeRows.slice(0)), this.displayRowsCount = this.displayRows[0].length;
  }
  //set display row pipeline data
  setDisplayRows(e, t) {
    this.displayRows[t] = e, t == this.displayRows.length - 1 && (this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length);
  }
  getDisplayRows(e) {
    return typeof e > "u" ? this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [] : this.displayRows[e] || [];
  }
  getVisibleRows(e, t) {
    var i = Object.assign([], this.renderer.visibleRows(!t));
    return e && (i = this.chain("rows-visible", [t], i, i)), i;
  }
  //repeat action across display rows
  displayRowIterator(e) {
    this.activeRowsPipeline.forEach(e), this.displayRows.forEach(e), this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
  }
  //return only actual rows (not group headers etc)
  getRows(e) {
    var t = [];
    switch (e) {
      case "active":
        t = this.activeRows;
        break;
      case "display":
        t = this.table.rowManager.getDisplayRows();
        break;
      case "visible":
        t = this.getVisibleRows(!1, !0);
        break;
      default:
        t = this.chain("rows-retrieve", e, null, this.rows) || this.rows;
    }
    return t;
  }
  ///////////////// Table Rendering /////////////////
  //trigger rerender of table in current position
  reRenderInPosition(e) {
    this.redrawBlock ? e ? e() : this.redrawBlockRenderInPosition = !0 : (this.dispatchExternal("renderStarted"), this.renderer.rerenderRows(e), this.fixedHeight || this.adjustTableSize(), this.scrollBarCheck(), this.dispatchExternal("renderComplete"));
  }
  scrollBarCheck() {
    var e = 0;
    this.element.scrollHeight > this.element.clientHeight && (e = this.element.offsetWidth - this.element.clientWidth), e !== this.scrollbarWidth && (this.scrollbarWidth = e, this.dispatch("scrollbar-vertical", e));
  }
  initializeRenderer() {
    var e, t = {
      virtual: z$e,
      basic: W$e
    };
    typeof this.table.options.renderVertical == "string" ? e = t[this.table.options.renderVertical] : e = this.table.options.renderVertical, e ? (this.renderMode = this.table.options.renderVertical, this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize(), (this.table.element.clientHeight || this.table.options.height) && !(this.table.options.minHeight && this.table.options.maxHeight) ? this.fixedHeight = !0 : this.fixedHeight = !1) : console.error("Unable to find matching renderer:", this.table.options.renderVertical);
  }
  getRenderMode() {
    return this.renderMode;
  }
  renderTable() {
    this.dispatchExternal("renderStarted"), this.element.scrollTop = 0, this._clearTable(), this.displayRowsCount ? (this.renderer.renderRows(), this.firstRender && (this.firstRender = !1, this.fixedHeight || this.adjustTableSize(), this.layoutRefresh(!0))) : this.renderEmptyScroll(), this.fixedHeight || this.adjustTableSize(), this.dispatch("table-layout"), this.displayRowsCount || this._showPlaceholder(), this.scrollBarCheck(), this.dispatchExternal("renderComplete");
  }
  //show scrollbars on empty table div
  renderEmptyScroll() {
    this.placeholder ? this.tableElement.style.display = "none" : this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
  }
  _clearTable() {
    this._clearPlaceholder(), this.scrollTop = 0, this.scrollLeft = 0, this.renderer.clearRows();
  }
  tableEmpty() {
    this.renderEmptyScroll(), this._showPlaceholder();
  }
  _showPlaceholder() {
    this.placeholder && (this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.initializePlaceholder(), this.placeholder.setAttribute("tabulator-render-mode", this.renderMode), this.getElement().appendChild(this.placeholder), this._positionPlaceholder());
  }
  _clearPlaceholder() {
    this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.tableElement.style.minWidth = "", this.tableElement.style.display = "";
  }
  _positionPlaceholder() {
    this.placeholder && this.placeholder.parentNode && (this.placeholder.style.width = this.table.columnManager.getWidth() + "px", this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px", this.placeholderContents.style.marginLeft = this.scrollLeft + "px");
  }
  styleRow(e, t) {
    var i = e.getElement();
    t % 2 ? (i.classList.add("tabulator-row-even"), i.classList.remove("tabulator-row-odd")) : (i.classList.add("tabulator-row-odd"), i.classList.remove("tabulator-row-even"));
  }
  //normalize height of active rows
  normalizeHeight() {
    this.activeRows.forEach(function(e) {
      e.normalizeHeight();
    });
  }
  //adjust the height of the table holder to fit in the Tabulator element
  adjustTableSize() {
    let e = this.element.clientHeight, t, i = !1;
    if (this.renderer.verticalFillMode === "fill") {
      let n = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
      if (this.fixedHeight) {
        t = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
        const a = "calc(100% - " + n + "px)";
        this.element.style.minHeight = t || "calc(100% - " + n + "px)", this.element.style.height = a, this.element.style.maxHeight = a;
      } else
        this.element.style.height = "", this.element.style.height = this.table.element.clientHeight - n + "px", this.element.scrollTop = this.scrollTop;
      this.renderer.resize(), !this.fixedHeight && e != this.element.clientHeight && (i = !0, this.subscribed("table-resize") ? this.dispatch("table-resize") : this.redraw()), this.scrollBarCheck();
    }
    return this._positionPlaceholder(), i;
  }
  //reinitialize all rows
  reinitialize() {
    this.rows.forEach(function(e) {
      e.reinitialize(!0);
    });
  }
  //prevent table from being redrawn
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockRestoreConfig = !1;
  }
  //restore table redrawing
  restoreRedraw() {
    this.redrawBlock = !1, this.redrawBlockRestoreConfig ? (this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition), this.redrawBlockRestoreConfig = !1) : this.redrawBlockRenderInPosition && this.reRenderInPosition(), this.redrawBlockRenderInPosition = !1;
  }
  //redraw table
  redraw(e) {
    const t = this.adjustTableSize();
    this.table.tableWidth = this.table.element.clientWidth, e ? this.renderTable() : (t && this.reRenderInPosition(), this.scrollHorizontal(this.scrollLeft));
  }
  resetScroll() {
    if (this.element.scrollLeft = 0, this.element.scrollTop = 0, this.table.browser === "ie") {
      var e = document.createEvent("Event");
      e.initEvent("scroll", !1, !0), this.element.dispatchEvent(e);
    } else
      this.element.dispatchEvent(new Event("scroll"));
  }
}
class q$e extends zi {
  constructor(e) {
    super(e), this.active = !1, this.element = this.createElement(), this.containerElement = this.createContainerElement(), this.external = !1;
  }
  initialize() {
    this.initializeElement();
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer"), e;
  }
  createContainerElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer-contents"), this.element.appendChild(e), e;
  }
  initializeElement() {
    if (this.table.options.footerElement)
      switch (typeof this.table.options.footerElement) {
        case "string":
          this.table.options.footerElement[0] === "<" ? this.containerElement.innerHTML = this.table.options.footerElement : (this.external = !0, this.containerElement = document.querySelector(this.table.options.footerElement));
          break;
        default:
          this.element = this.table.options.footerElement;
          break;
      }
  }
  getElement() {
    return this.element;
  }
  append(e) {
    this.activate(), this.containerElement.appendChild(e), this.table.rowManager.adjustTableSize();
  }
  prepend(e) {
    this.activate(), this.element.insertBefore(e, this.element.firstChild), this.table.rowManager.adjustTableSize();
  }
  remove(e) {
    e.parentNode.removeChild(e), this.deactivate();
  }
  deactivate(e) {
    (!this.element.firstChild || e) && (this.external || this.element.parentNode.removeChild(this.element), this.active = !1);
  }
  activate() {
    this.active || (this.active = !0, this.external || (this.table.element.appendChild(this.getElement()), this.table.element.style.display = ""));
  }
  redraw() {
    this.dispatch("footer-redraw");
  }
}
class j$e extends zi {
  constructor(e) {
    super(e), this.el = null, this.abortClasses = ["tabulator-headers", "tabulator-table"], this.previousTargets = {}, this.listeners = [
      "click",
      "dblclick",
      "contextmenu",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "mousemove",
      "mouseup",
      "mousedown",
      "touchstart",
      "touchend"
    ], this.componentMap = {
      "tabulator-cell": "cell",
      "tabulator-row": "row",
      "tabulator-group": "group",
      "tabulator-col": "column"
    }, this.pseudoTrackers = {
      row: {
        subscriber: null,
        target: null
      },
      cell: {
        subscriber: null,
        target: null
      },
      group: {
        subscriber: null,
        target: null
      },
      column: {
        subscriber: null,
        target: null
      }
    }, this.pseudoTracking = !1;
  }
  initialize() {
    this.el = this.table.element, this.buildListenerMap(), this.bindSubscriptionWatchers();
  }
  buildListenerMap() {
    var e = {};
    this.listeners.forEach((t) => {
      e[t] = {
        handler: null,
        components: []
      };
    }), this.listeners = e;
  }
  bindPseudoEvents() {
    Object.keys(this.pseudoTrackers).forEach((e) => {
      this.pseudoTrackers[e].subscriber = this.pseudoMouseEnter.bind(this, e), this.subscribe(e + "-mouseover", this.pseudoTrackers[e].subscriber);
    }), this.pseudoTracking = !0;
  }
  pseudoMouseEnter(e, t, i) {
    this.pseudoTrackers[e].target !== i && (this.pseudoTrackers[e].target && this.dispatch(e + "-mouseleave", t, this.pseudoTrackers[e].target), this.pseudoMouseLeave(e, t), this.pseudoTrackers[e].target = i, this.dispatch(e + "-mouseenter", t, i));
  }
  pseudoMouseLeave(e, t) {
    var i = Object.keys(this.pseudoTrackers), n = {
      row: ["cell"],
      cell: ["row"]
    };
    i = i.filter((a) => {
      var o = n[e];
      return a !== e && (!o || o && !o.includes(a));
    }), i.forEach((a) => {
      var o = this.pseudoTrackers[a].target;
      this.pseudoTrackers[a].target && (this.dispatch(a + "-mouseleave", t, o), this.pseudoTrackers[a].target = null);
    });
  }
  bindSubscriptionWatchers() {
    var e = Object.keys(this.listeners), t = Object.values(this.componentMap);
    for (let i of t)
      for (let n of e) {
        let a = i + "-" + n;
        this.subscriptionChange(a, this.subscriptionChanged.bind(this, i, n));
      }
    this.subscribe("table-destroy", this.clearWatchers.bind(this));
  }
  subscriptionChanged(e, t, i) {
    var n = this.listeners[t].components, a = n.indexOf(e), o = !1;
    i ? a === -1 && (n.push(e), o = !0) : this.subscribed(e + "-" + t) || a > -1 && (n.splice(a, 1), o = !0), (t === "mouseenter" || t === "mouseleave") && !this.pseudoTracking && this.bindPseudoEvents(), o && this.updateEventListeners();
  }
  updateEventListeners() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.components.length ? t.handler || (t.handler = this.track.bind(this, e), this.el.addEventListener(e, t.handler)) : t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
  track(e, t) {
    var i = t.composedPath && t.composedPath() || t.path, n = this.findTargets(i);
    n = this.bindComponents(e, n), this.triggerEvents(e, t, n), this.pseudoTracking && (e == "mouseover" || e == "mouseleave") && !Object.keys(n).length && this.pseudoMouseLeave("none", t);
  }
  findTargets(e) {
    var t = {};
    let i = Object.keys(this.componentMap);
    for (let n of e) {
      let a = n.classList ? [...n.classList] : [];
      if (a.filter((l) => this.abortClasses.includes(l)).length)
        break;
      let s = a.filter((l) => i.includes(l));
      for (let l of s)
        t[this.componentMap[l]] || (t[this.componentMap[l]] = n);
    }
    return t.group && t.group === t.row && delete t.row, t;
  }
  bindComponents(e, t) {
    var i = Object.keys(t).reverse(), n = this.listeners[e], a = {}, o = {};
    for (let s of i) {
      let l, u = t[s], h = this.previousTargets[s];
      if (h && h.target === u)
        l = h.component;
      else
        switch (s) {
          case "row":
          case "group":
            (n.components.includes("row") || n.components.includes("cell") || n.components.includes("group")) && (l = this.table.rowManager.getVisibleRows(!0).find((f) => f.getElement() === u), t.row && t.row.parentNode && t.row.parentNode.closest(".tabulator-row") && (t[s] = !1));
            break;
          case "column":
            n.components.includes("column") && (l = this.table.columnManager.findColumn(u));
            break;
          case "cell":
            n.components.includes("cell") && (a.row instanceof Ti ? l = a.row.findCell(u) : t.row && console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?"));
            break;
        }
      l && (a[s] = l, o[s] = {
        target: u,
        component: l
      });
    }
    return this.previousTargets = o, a;
  }
  triggerEvents(e, t, i) {
    var n = this.listeners[e];
    for (let a in i)
      i[a] && n.components.includes(a) && this.dispatch(a + "-" + e, t, i[a]);
  }
  clearWatchers() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
}
class K$e {
  constructor(e) {
    this.table = e, this.bindings = {};
  }
  bind(e, t, i) {
    this.bindings[e] || (this.bindings[e] = {}), this.bindings[e][t] ? console.warn("Unable to bind component handler, a matching function name is already bound", e, t, i) : this.bindings[e][t] = i;
  }
  handle(e, t, i) {
    if (this.bindings[e] && this.bindings[e][i] && typeof this.bindings[e][i].bind == "function")
      return this.bindings[e][i].bind(null, t);
    i !== "then" && typeof i == "string" && !i.startsWith("_") && this.table.options.debugInvalidComponentFuncs && console.error("The " + e + " component does not have a " + i + " function, have you checked that you have the correct Tabulator module installed?");
  }
}
class J$e extends zi {
  constructor(e) {
    super(e), this.requestOrder = 0, this.loading = !1;
  }
  initialize() {
  }
  load(e, t, i, n, a, o) {
    var s = ++this.requestOrder;
    if (this.dispatchExternal("dataLoading", e), e && (e.indexOf("{") == 0 || e.indexOf("[") == 0) && (e = JSON.parse(e)), this.confirm("data-loading", [e, t, i, a])) {
      this.loading = !0, a || this.alertLoader(), t = this.chain("data-params", [e, i, a], t || {}, t || {}), t = this.mapParams(t, this.table.options.dataSendParams);
      var l = this.chain("data-load", [e, t, i, a], !1, Promise.resolve([]));
      return l.then((u) => {
        !Array.isArray(u) && typeof u == "object" && (u = this.mapParams(u, this.objectInvert(this.table.options.dataReceiveParams)));
        var h = this.chain("data-loaded", u, null, u);
        s == this.requestOrder ? (this.clearAlert(), h !== !1 && (this.dispatchExternal("dataLoaded", h), this.table.rowManager.setData(h, n, typeof o > "u" ? !n : o))) : console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
      }).catch((u) => {
        console.error("Data Load Error: ", u), this.dispatchExternal("dataLoadError", u), a || this.alertError(), setTimeout(() => {
          this.clearAlert();
        }, this.table.options.dataLoaderErrorTimeout);
      }).finally(() => {
        this.loading = !1;
      });
    } else
      return this.dispatchExternal("dataLoaded", e), e || (e = []), this.table.rowManager.setData(e, n, typeof o > "u" ? !n : o), Promise.resolve();
  }
  mapParams(e, t) {
    var i = {};
    for (let n in e)
      i[t.hasOwnProperty(n) ? t[n] : n] = e[n];
    return i;
  }
  objectInvert(e) {
    var t = {};
    for (let i in e)
      t[e[i]] = i;
    return t;
  }
  blockActiveLoad() {
    this.requestOrder++;
  }
  alertLoader() {
    var e = typeof this.table.options.dataLoader == "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
    e && this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
  }
  alertError() {
    this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
  }
  clearAlert() {
    this.table.alertManager.clear();
  }
}
class eGe {
  constructor(e, t, i) {
    this.table = e, this.events = {}, this.optionsList = t || {}, this.subscriptionNotifiers = {}, this.dispatch = i ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.debug = i;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t) {
    this.events[e] || (this.events[e] = []), this.events[e].push(t), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var i;
    if (this.events[e])
      if (t)
        if (i = this.events[e].findIndex((n) => n === t), i > -1)
          this.events[e].splice(i, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
      else
        delete this.events[e];
    else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _notifySubscriptionChange(e, t) {
    var i = this.subscriptionNotifiers[e];
    i && i.forEach((n) => {
      n(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift(), i;
    return this.events[t] && this.events[t].forEach((n, a) => {
      let o = n.apply(this.table, e);
      a || (i = o);
    }), i;
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "ExternalEvent:" + e[0], (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
}
class tGe {
  constructor(e) {
    this.events = {}, this.subscriptionNotifiers = {}, this.dispatch = e ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.chain = e ? this._debugChain.bind(this) : this._chain.bind(this), this.confirm = e ? this._debugConfirm.bind(this) : this._confirm.bind(this), this.debug = e;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t, i = 1e4) {
    this.events[e] || (this.events[e] = []), this.events[e].push({ callback: t, priority: i }), this.events[e].sort((n, a) => n.priority - a.priority), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var i;
    if (this.events[e]) {
      if (t)
        if (i = this.events[e].findIndex((n) => n.callback === t), i > -1)
          this.events[e].splice(i, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
    } else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _chain(e, t, i, n) {
    var a = i;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) ? (this.events[e].forEach((o, s) => {
      a = o.callback.apply(this, t.concat([a]));
    }), a) : typeof n == "function" ? n() : n;
  }
  _confirm(e, t) {
    var i = !1;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) && this.events[e].forEach((n, a) => {
      n.callback.apply(this, t) && (i = !0);
    }), i;
  }
  _notifySubscriptionChange(e, t) {
    var i = this.subscriptionNotifiers[e];
    i && i.forEach((n) => {
      n(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift();
    this.events[t] && this.events[t].forEach((i) => {
      i.callback.apply(this, e);
    });
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
  _debugChain() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._chain(...arguments);
  }
  _debugConfirm() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._confirm(...arguments);
  }
}
class rGe extends zi {
  constructor(e) {
    super(e);
  }
  _warnUser() {
    this.options("debugDeprecation") && console.warn(...arguments);
  }
  check(e, t) {
    var i = "";
    return typeof this.options(e) < "u" ? (i = "Deprecated Setup Option - Use of the %c" + e + "%c option is now deprecated", t ? (i = i + ", Please use the %c" + t + "%c option instead", this._warnUser(i, "font-weight: bold;", "font-weight: normal;", "font-weight: bold;", "font-weight: normal;")) : this._warnUser(i, "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  checkMsg(e, t) {
    return typeof this.options(e) < "u" ? (this._warnUser("%cDeprecated Setup Option - Use of the %c" + e + " %c option is now deprecated, " + t, "font-weight: normal;", "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  msg(e) {
    this._warnUser(e);
  }
}
class nn {
  static register(e) {
    nn.tables.push(e);
  }
  static deregister(e) {
    var t = nn.tables.indexOf(e);
    t > -1 && nn.tables.splice(t, 1);
  }
  static lookupTable(e, t) {
    var i = [], n, a;
    if (typeof e == "string") {
      if (n = document.querySelectorAll(e), n.length)
        for (var o = 0; o < n.length; o++)
          a = nn.matchElement(n[o]), a && i.push(a);
    } else
      typeof HTMLElement < "u" && e instanceof HTMLElement || e instanceof jo ? (a = nn.matchElement(e), a && i.push(a)) : Array.isArray(e) ? e.forEach(function(s) {
        i = i.concat(nn.lookupTable(s));
      }) : t || console.warn("Table Connection Error - Invalid Selector", e);
    return i;
  }
  static matchElement(e) {
    return nn.tables.find(function(t) {
      return e instanceof jo ? t === e : t.element === e;
    });
  }
}
nn.tables = [];
function iGe(r, e) {
  e && this.table.columnManager.renderer.reinitializeColumnWidths(r), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function jB(r, e) {
  r.forEach(function(t) {
    t.reinitializeWidth();
  }), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function nGe(r, e) {
  var t = 0, i = this.table.rowManager.element.clientWidth, n = 0, a = !1;
  r.forEach((o, s) => {
    o.widthFixed || o.reinitializeWidth(), (this.table.options.responsiveLayout ? o.modules.responsive.visible : o.visible) && (a = o), o.visible && (t += o.getWidth());
  }), a ? (n = i - t + a.getWidth(), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && (a.setWidth(0), this.table.modules.responsiveLayout.update()), n > 0 ? a.setWidth(n) : a.reinitializeWidth()) : this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function aGe(r, e) {
  var t = this.table.rowManager.element.getBoundingClientRect().width, i = 0, n = 0, a = 0, o = 0, s = [], l = [], u = 0, h = 0, c = 0;
  function f(p) {
    var g;
    return typeof p == "string" ? p.indexOf("%") > -1 ? g = t / 100 * parseInt(p) : g = parseInt(p) : g = p, g;
  }
  function d(p, g, v, O) {
    var m = [], E = 0, b = 0, T = 0, S = a, y = 0, A = 0, C = [];
    function _(x) {
      return v * (x.column.definition.widthGrow || 1);
    }
    function I(x) {
      return f(x.width) - v * (x.column.definition.widthShrink || 0);
    }
    return p.forEach(function(x, P) {
      var N = O ? I(x) : _(x);
      x.column.minWidth >= N ? m.push(x) : x.column.maxWidth && x.column.maxWidth < N ? (x.width = x.column.maxWidth, g -= x.column.maxWidth, S -= O ? x.column.definition.widthShrink || 1 : x.column.definition.widthGrow || 1, S && (v = Math.floor(g / S))) : (C.push(x), A += O ? x.column.definition.widthShrink || 1 : x.column.definition.widthGrow || 1);
    }), m.length ? (m.forEach(function(x) {
      E += O ? x.width - x.column.minWidth : x.column.minWidth, x.width = x.column.minWidth;
    }), b = g - E, T = A ? Math.floor(b / A) : b, y = d(C, b, T, O)) : (y = A ? g - Math.floor(g / A) * A : g, C.forEach(function(x) {
      x.width = O ? I(x) : _(x);
    })), y;
  }
  this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update(), this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (t -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), r.forEach(function(p) {
    var g, v, O;
    p.visible && (g = p.definition.width, v = parseInt(p.minWidth), g ? (O = f(g), i += O > v ? O : v, p.definition.widthShrink && (l.push({
      column: p,
      width: O > v ? O : v
    }), u += p.definition.widthShrink)) : (s.push({
      column: p,
      width: 0
    }), a += p.definition.widthGrow || 1));
  }), n = t - i, o = Math.floor(n / a), c = d(s, n, o, !1), s.length && c > 0 && (s[s.length - 1].width += c), s.forEach(function(p) {
    n -= p.width;
  }), h = Math.abs(c) + n, h > 0 && u && (c = d(l, h, Math.floor(h / u), !0)), c && l.length && (l[l.length - 1].width -= c), s.forEach(function(p) {
    p.column.setWidth(p.width);
  }), l.forEach(function(p) {
    p.column.setWidth(p.width);
  });
}
var oGe = {
  fitData: iGe,
  fitDataFill: jB,
  fitDataTable: jB,
  fitDataStretch: nGe,
  fitColumns: aGe
};
class df extends pt {
  constructor(e) {
    super(e, "layout"), this.mode = null, this.registerTableOption("layout", "fitData"), this.registerTableOption("layoutColumnsOnNewData", !1), this.registerColumnOption("widthGrow"), this.registerColumnOption("widthShrink");
  }
  //initialize layout system
  initialize() {
    var e = this.table.options.layout;
    df.modes[e] ? this.mode = e : (console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + e), this.mode = "fitData"), this.table.element.setAttribute("tabulator-layout", this.mode);
  }
  getMode() {
    return this.mode;
  }
  //trigger table layout
  layout(e) {
    this.dispatch("layout-refreshing"), df.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, e), this.dispatch("layout-refreshed");
  }
}
df.moduleName = "layout";
df.modes = oGe;
var sGe = {
  default: {
    //hold default locale text
    groups: {
      item: "item",
      items: "items"
    },
    columns: {},
    data: {
      loading: "Loading",
      error: "Error"
    },
    pagination: {
      page_size: "Page Size",
      page_title: "Show Page",
      first: "First",
      first_title: "First Page",
      last: "Last",
      last_title: "Last Page",
      prev: "Prev",
      prev_title: "Prev Page",
      next: "Next",
      next_title: "Next Page",
      all: "All",
      counter: {
        showing: "Showing",
        of: "of",
        rows: "rows",
        pages: "pages"
      }
    },
    headerFilters: {
      default: "filter column...",
      columns: {}
    }
  }
};
class gv extends pt {
  constructor(e) {
    super(e), this.locale = "default", this.lang = !1, this.bindings = {}, this.langList = {}, this.registerTableOption("locale", !1), this.registerTableOption("langs", {});
  }
  initialize() {
    this.langList = Wt.deepClone(gv.langs), this.table.options.columnDefaults.headerFilterPlaceholder !== !1 && this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
    for (let e in this.table.options.langs)
      this.installLang(e, this.table.options.langs[e]);
    this.setLocale(this.table.options.locale), this.registerTableFunction("setLocale", this.setLocale.bind(this)), this.registerTableFunction("getLocale", this.getLocale.bind(this)), this.registerTableFunction("getLang", this.getLang.bind(this));
  }
  //set header placeholder
  setHeaderFilterPlaceholder(e) {
    this.langList.default.headerFilters.default = e;
  }
  //setup a lang description object
  installLang(e, t) {
    this.langList[e] ? this._setLangProp(this.langList[e], t) : this.langList[e] = t;
  }
  _setLangProp(e, t) {
    for (let i in t)
      e[i] && typeof e[i] == "object" ? this._setLangProp(e[i], t[i]) : e[i] = t[i];
  }
  //set current locale
  setLocale(e) {
    e = e || "default";
    function t(i, n) {
      for (var a in i)
        typeof i[a] == "object" ? (n[a] || (n[a] = {}), t(i[a], n[a])) : n[a] = i[a];
    }
    if (e === !0 && navigator.language && (e = navigator.language.toLowerCase()), e && !this.langList[e]) {
      let i = e.split("-")[0];
      this.langList[i] ? (console.warn("Localization Error - Exact matching locale not found, using closest match: ", e, i), e = i) : (console.warn("Localization Error - Matching locale not found, using default: ", e), e = "default");
    }
    this.locale = e, this.lang = Wt.deepClone(this.langList.default || {}), e != "default" && t(this.langList[e], this.lang), this.dispatchExternal("localized", this.locale, this.lang), this._executeBindings();
  }
  //get current locale
  getLocale(e) {
    return this.locale;
  }
  //get lang object for given local or current if none provided
  getLang(e) {
    return e ? this.langList[e] : this.lang;
  }
  //get text for current locale
  getText(e, t) {
    var i = t ? e + "|" + t : e, n = i.split("|"), a = this._getLangElement(n, this.locale);
    return a || "";
  }
  //traverse langs object and find localized copy
  _getLangElement(e, t) {
    var i = this.lang;
    return e.forEach(function(n) {
      var a;
      i && (a = i[n], typeof a < "u" ? i = a : i = !1);
    }), i;
  }
  //set update binding
  bind(e, t) {
    this.bindings[e] || (this.bindings[e] = []), this.bindings[e].push(t), t(this.getText(e), this.lang);
  }
  //iterate through bindings and trigger updates
  _executeBindings() {
    for (let e in this.bindings)
      this.bindings[e].forEach((t) => {
        t(this.getText(e), this.lang);
      });
  }
}
gv.moduleName = "localize";
gv.langs = sGe;
class O8 extends pt {
  constructor(e) {
    super(e);
  }
  initialize() {
    this.registerTableFunction("tableComms", this.receive.bind(this));
  }
  getConnections(e) {
    var t = [], i;
    return i = nn.lookupTable(e), i.forEach((n) => {
      this.table !== n && t.push(n);
    }), t;
  }
  send(e, t, i, n) {
    var a = this.getConnections(e);
    a.forEach((o) => {
      o.tableComms(this.table.element, t, i, n);
    }), !a.length && e && console.warn("Table Connection Error - No tables matching selector found", e);
  }
  receive(e, t, i, n) {
    if (this.table.modExists(t))
      return this.table.modules[t].commsReceived(e, i, n);
    console.warn("Inter-table Comms Error - no such module:", t);
  }
}
O8.moduleName = "comms";
var lGe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LayoutModule: df,
  LocalizeModule: gv,
  CommsModule: O8
});
class m8 {
  constructor(e, t) {
    this.bindStaticFunctionality(e), this.bindModules(e, lGe, !0), t && this.bindModules(e, t);
  }
  bindStaticFunctionality(e) {
    e.moduleBindings = {}, e.extendModule = function(t, i, n) {
      if (e.moduleBindings[t]) {
        var a = e.moduleBindings[t][i];
        if (a)
          if (typeof n == "object")
            for (let o in n)
              a[o] = n[o];
          else
            console.warn("Module Error - Invalid value type, it must be an object");
        else
          console.warn("Module Error - property does not exist:", i);
      } else
        console.warn("Module Error - module does not exist:", t);
    }, e.registerModule = function(t) {
      Array.isArray(t) || (t = [t]), t.forEach((i) => {
        e.registerModuleBinding(i);
      });
    }, e.registerModuleBinding = function(t) {
      e.moduleBindings[t.moduleName] = t;
    }, e.findTable = function(t) {
      var i = nn.lookupTable(t, !0);
      return Array.isArray(i) && !i.length ? !1 : i;
    }, e.prototype.bindModules = function() {
      var t = [], i = [], n = [];
      this.modules = {};
      for (var a in e.moduleBindings) {
        let o = e.moduleBindings[a], s = new o(this);
        this.modules[a] = s, o.prototype.moduleCore ? this.modulesCore.push(s) : o.moduleInitOrder ? o.moduleInitOrder < 0 ? t.push(s) : i.push(s) : n.push(s);
      }
      t.sort((o, s) => o.moduleInitOrder > s.moduleInitOrder ? 1 : -1), i.sort((o, s) => o.moduleInitOrder > s.moduleInitOrder ? 1 : -1), this.modulesRegular = t.concat(n.concat(i));
    };
  }
  bindModules(e, t, i) {
    var n = Object.values(t);
    i && n.forEach((a) => {
      a.prototype.moduleCore = !0;
    }), e.registerModule(n);
  }
}
class uGe extends zi {
  constructor(e) {
    super(e), this.element = this._createAlertElement(), this.msgElement = this._createMsgElement(), this.type = null, this.element.appendChild(this.msgElement);
  }
  _createAlertElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert"), e;
  }
  _createMsgElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert-msg"), e.setAttribute("role", "alert"), e;
  }
  _typeClass() {
    return "tabulator-alert-state-" + this.type;
  }
  alert(e, t = "msg") {
    if (e) {
      for (this.clear(), this.type = t; this.msgElement.firstChild; )
        this.msgElement.removeChild(this.msgElement.firstChild);
      this.msgElement.classList.add(this._typeClass()), typeof e == "function" && (e = e()), e instanceof HTMLElement ? this.msgElement.appendChild(e) : this.msgElement.innerHTML = e, this.table.element.appendChild(this.element);
    }
  }
  clear() {
    this.element.parentNode && this.element.parentNode.removeChild(this.element), this.msgElement.classList.remove(this._typeClass());
  }
}
class jo {
  constructor(e, t) {
    this.options = {}, this.columnManager = null, this.rowManager = null, this.footerManager = null, this.alertManager = null, this.vdomHoz = null, this.externalEvents = null, this.eventBus = null, this.interactionMonitor = !1, this.browser = "", this.browserSlow = !1, this.browserMobile = !1, this.rtl = !1, this.originalElement = null, this.componentFunctionBinder = new K$e(this), this.dataLoader = !1, this.modules = {}, this.modulesCore = [], this.modulesRegular = [], this.deprecationAdvisor = new rGe(this), this.optionsList = new v8(this, "table constructor"), this.initialized = !1, this.destroyed = !1, this.initializeElement(e) && (this.initializeCoreSystems(t), setTimeout(() => {
      this._create();
    })), nn.register(this);
  }
  initializeElement(e) {
    return typeof HTMLElement < "u" && e instanceof HTMLElement ? (this.element = e, !0) : typeof e == "string" ? (this.element = document.querySelector(e), this.element ? !0 : (console.error("Tabulator Creation Error - no element found matching selector: ", e), !1)) : (console.error("Tabulator Creation Error - Invalid element provided:", e), !1);
  }
  initializeCoreSystems(e) {
    this.columnManager = new H$e(this), this.rowManager = new Z$e(this), this.footerManager = new q$e(this), this.dataLoader = new J$e(this), this.alertManager = new uGe(this), this.bindModules(), this.options = this.optionsList.generate(jo.defaultOptions, e), this._clearObjectPointers(), this._mapDeprecatedFunctionality(), this.externalEvents = new eGe(this, this.options, this.options.debugEventsExternal), this.eventBus = new tGe(this.options.debugEventsInternal), this.interactionMonitor = new j$e(this), this.dataLoader.initialize(), this.footerManager.initialize();
  }
  //convert deprecated functionality to new functions
  _mapDeprecatedFunctionality() {
  }
  _clearSelection() {
    this.element.classList.add("tabulator-block-select"), window.getSelection ? window.getSelection().empty ? window.getSelection().empty() : window.getSelection().removeAllRanges && window.getSelection().removeAllRanges() : document.selection && document.selection.empty(), this.element.classList.remove("tabulator-block-select");
  }
  //create table
  _create() {
    this.externalEvents.dispatch("tableBuilding"), this.eventBus.dispatch("table-building"), this._rtlCheck(), this._buildElement(), this._initializeTable(), this._loadInitialData(), this.initialized = !0, this.externalEvents.dispatch("tableBuilt");
  }
  _rtlCheck() {
    var e = window.getComputedStyle(this.element);
    switch (this.options.textDirection) {
      case "auto":
        if (e.direction !== "rtl")
          break;
      case "rtl":
        this.element.classList.add("tabulator-rtl"), this.rtl = !0;
        break;
      case "ltr":
        this.element.classList.add("tabulator-ltr");
      default:
        this.rtl = !1;
    }
  }
  //clear pointers to objects in default config object
  _clearObjectPointers() {
    this.options.columns = this.options.columns.slice(0), Array.isArray(this.options.data) && !this.options.reactiveData && (this.options.data = this.options.data.slice(0));
  }
  //build tabulator element
  _buildElement() {
    var e = this.element, t = this.options, i;
    if (e.tagName === "TABLE") {
      this.originalElement = this.element, i = document.createElement("div");
      var n = e.attributes;
      for (var a in n)
        typeof n[a] == "object" && i.setAttribute(n[a].name, n[a].value);
      e.parentNode.replaceChild(i, e), this.element = e = i;
    }
    for (e.classList.add("tabulator"), e.setAttribute("role", "grid"); e.firstChild; )
      e.removeChild(e.firstChild);
    t.height && (t.height = isNaN(t.height) ? t.height : t.height + "px", e.style.height = t.height), t.minHeight !== !1 && (t.minHeight = isNaN(t.minHeight) ? t.minHeight : t.minHeight + "px", e.style.minHeight = t.minHeight), t.maxHeight !== !1 && (t.maxHeight = isNaN(t.maxHeight) ? t.maxHeight : t.maxHeight + "px", e.style.maxHeight = t.maxHeight);
  }
  //initialize core systems and modules
  _initializeTable() {
    var e = this.element, t = this.options;
    this.interactionMonitor.initialize(), this.columnManager.initialize(), this.rowManager.initialize(), this._detectBrowser(), this.modulesCore.forEach((i) => {
      i.initialize();
    }), e.appendChild(this.columnManager.getElement()), e.appendChild(this.rowManager.getElement()), t.footerElement && this.footerManager.activate(), t.autoColumns && t.data && this.columnManager.generateColumnsFromRowData(this.options.data), this.modulesRegular.forEach((i) => {
      i.initialize();
    }), this.columnManager.setColumns(t.columns), this.eventBus.dispatch("table-built");
  }
  _loadInitialData() {
    this.dataLoader.load(this.options.data);
  }
  //deconstructor
  destroy() {
    var e = this.element;
    for (this.destroyed = !0, nn.deregister(this), this.eventBus.dispatch("table-destroy"), this.rowManager.destroy(); e.firstChild; )
      e.removeChild(e.firstChild);
    e.classList.remove("tabulator"), this.externalEvents.dispatch("tableDestroyed");
  }
  _detectBrowser() {
    var e = navigator.userAgent || navigator.vendor || window.opera;
    e.indexOf("Trident") > -1 ? (this.browser = "ie", this.browserSlow = !0) : e.indexOf("Edge") > -1 ? (this.browser = "edge", this.browserSlow = !0) : e.indexOf("Firefox") > -1 ? (this.browser = "firefox", this.browserSlow = !1) : e.indexOf("Mac OS") > -1 ? (this.browser = "safari", this.browserSlow = !1) : (this.browser = "other", this.browserSlow = !1), this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e.slice(0, 4));
  }
  initGuard(e, t) {
    var i, n;
    return this.options.debugInitialization && !this.initialized && (e || (i = new Error().stack.split(`
`), n = i[0] == "Error" ? i[2] : i[1], n[0] == " " ? e = n.trim().split(" ")[1].split(".")[1] : e = n.trim().split("@")[0]), console.warn("Table Not Initialized - Calling the " + e + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (t ? " " + t : ""))), this.initialized;
  }
  ////////////////// Data Handling //////////////////
  //block table redrawing
  blockRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-blocking"), this.rowManager.blockRedraw(), this.columnManager.blockRedraw(), this.eventBus.dispatch("redraw-blocked");
  }
  //restore table redrawing
  restoreRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-restoring"), this.rowManager.restoreRedraw(), this.columnManager.restoreRedraw(), this.eventBus.dispatch("redraw-restored");
  }
  //load data
  setData(e, t, i) {
    return this.initGuard(!1, "To set initial data please use the 'data' property in the table constructor."), this.dataLoader.load(e, t, i, !1);
  }
  //clear data
  clearData() {
    this.initGuard(), this.dataLoader.blockActiveLoad(), this.rowManager.clearData();
  }
  //get table data array
  getData(e) {
    return this.rowManager.getData(e);
  }
  //get table data array count
  getDataCount(e) {
    return this.rowManager.getDataCount(e);
  }
  //replace data, keeping table in position with same sort
  replaceData(e, t, i) {
    return this.initGuard(), this.dataLoader.load(e, t, i, !0, !0);
  }
  //update table data
  updateData(e) {
    var t = 0;
    return this.initGuard(), new Promise((i, n) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((a) => {
        var o = this.rowManager.findRow(a[this.options.index]);
        o ? (t++, o.updateData(a).then(() => {
          t--, t || i();
        }).catch((s) => {
          n("Update Error - Unable to update row", a, s);
        })) : n("Update Error - Unable to find row", a);
      }) : (console.warn("Update Error - No data provided"), n("Update Error - No data provided"));
    });
  }
  addData(e, t, i) {
    return this.initGuard(), new Promise((n, a) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e ? this.rowManager.addRows(e, t, i).then((o) => {
        var s = [];
        o.forEach(function(l) {
          s.push(l.getComponent());
        }), n(s);
      }) : (console.warn("Update Error - No data provided"), a("Update Error - No data provided"));
    });
  }
  //update table data
  updateOrAddData(e) {
    var t = [], i = 0;
    return this.initGuard(), new Promise((n, a) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((o) => {
        var s = this.rowManager.findRow(o[this.options.index]);
        i++, s ? s.updateData(o).then(() => {
          i--, t.push(s.getComponent()), i || n(t);
        }) : this.rowManager.addRows(o).then((l) => {
          i--, t.push(l[0].getComponent()), i || n(t);
        });
      }) : (console.warn("Update Error - No data provided"), a("Update Error - No data provided"));
    });
  }
  //get row object
  getRow(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //get row object
  getRowFromPosition(e) {
    var t = this.rowManager.getRowFromPosition(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //delete row from table
  deleteRow(e) {
    var t = [];
    this.initGuard(), Array.isArray(e) || (e = [e]);
    for (let i of e) {
      let n = this.rowManager.findRow(i, !0);
      if (n)
        t.push(n);
      else
        return console.error("Delete Error - No matching row found:", i), Promise.reject("Delete Error - No matching row found");
    }
    return t.sort((i, n) => this.rowManager.rows.indexOf(i) > this.rowManager.rows.indexOf(n) ? 1 : -1), t.forEach((i) => {
      i.delete();
    }), this.rowManager.reRenderInPosition(), Promise.resolve();
  }
  //add row to table
  addRow(e, t, i) {
    return this.initGuard(), typeof e == "string" && (e = JSON.parse(e)), this.rowManager.addRows(e, t, i, !0).then((n) => n[0].getComponent());
  }
  //update a row if it exists otherwise create it
  updateOrAddRow(e, t) {
    var i = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), i ? i.updateData(t).then(() => i.getComponent()) : this.rowManager.addRows(t).then((n) => n[0].getComponent());
  }
  //update row data
  updateRow(e, t) {
    var i = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), i ? i.updateData(t).then(() => Promise.resolve(i.getComponent())) : (console.warn("Update Error - No matching row found:", e), Promise.reject("Update Error - No matching row found"));
  }
  //scroll to row in DOM
  scrollToRow(e, t, i) {
    var n = this.rowManager.findRow(e);
    return n ? this.rowManager.scrollToRow(n, t, i) : (console.warn("Scroll Error - No matching row found:", e), Promise.reject("Scroll Error - No matching row found"));
  }
  moveRow(e, t, i) {
    var n = this.rowManager.findRow(e);
    this.initGuard(), n ? n.moveToRow(t, i) : console.warn("Move Error - No matching row found:", e);
  }
  getRows(e) {
    return this.rowManager.getComponents(e);
  }
  //get position of row in table
  getRowPosition(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getPosition() : (console.warn("Position Error - No matching row found:", e), !1);
  }
  /////////////// Column Functions  ///////////////
  setColumns(e) {
    this.initGuard(!1, "To set initial columns please use the 'columns' property in the table constructor"), this.columnManager.setColumns(e);
  }
  getColumns(e) {
    return this.columnManager.getComponents(e);
  }
  getColumn(e) {
    var t = this.columnManager.findColumn(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching column found:", e), !1);
  }
  getColumnDefinitions() {
    return this.columnManager.getDefinitionTree();
  }
  showColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.show();
    else
      return console.warn("Column Show Error - No matching column found:", e), !1;
  }
  hideColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.hide();
    else
      return console.warn("Column Hide Error - No matching column found:", e), !1;
  }
  toggleColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.visible ? t.hide() : t.show();
    else
      return console.warn("Column Visibility Toggle Error - No matching column found:", e), !1;
  }
  addColumn(e, t, i) {
    var n = this.columnManager.findColumn(i);
    return this.initGuard(), this.columnManager.addColumn(e, t, n).then((a) => a.getComponent());
  }
  deleteColumn(e) {
    var t = this.columnManager.findColumn(e);
    return this.initGuard(), t ? t.delete() : (console.warn("Column Delete Error - No matching column found:", e), Promise.reject());
  }
  updateColumnDefinition(e, t) {
    var i = this.columnManager.findColumn(e);
    return this.initGuard(), i ? i.updateDefinition(t) : (console.warn("Column Update Error - No matching column found:", e), Promise.reject());
  }
  moveColumn(e, t, i) {
    var n = this.columnManager.findColumn(e), a = this.columnManager.findColumn(t);
    this.initGuard(), n ? a ? this.columnManager.moveColumn(n, a, i) : console.warn("Move Error - No matching column found:", a) : console.warn("Move Error - No matching column found:", e);
  }
  //scroll to column in DOM
  scrollToColumn(e, t, i) {
    return new Promise((n, a) => {
      var o = this.columnManager.findColumn(e);
      return o ? this.columnManager.scrollToColumn(o, t, i) : (console.warn("Scroll Error - No matching column found:", e), Promise.reject("Scroll Error - No matching column found"));
    });
  }
  //////////// General Public Functions ////////////
  //redraw list without updating data
  redraw(e) {
    this.initGuard(), this.columnManager.redraw(e), this.rowManager.redraw(e);
  }
  setHeight(e) {
    this.options.height = isNaN(e) ? e : e + "px", this.element.style.height = this.options.height, this.rowManager.initializeRenderer(), this.rowManager.redraw();
  }
  //////////////////// Event Bus ///////////////////
  on(e, t) {
    this.externalEvents.subscribe(e, t);
  }
  off(e, t) {
    this.externalEvents.unsubscribe(e, t);
  }
  dispatchEvent() {
    var e = Array.from(arguments);
    e.shift(), this.externalEvents.dispatch(...arguments);
  }
  //////////////////// Alerts ///////////////////
  alert(e, t) {
    this.initGuard(), this.alertManager.alert(e, t);
  }
  clearAlert() {
    this.initGuard(), this.alertManager.clear();
  }
  ////////////// Extension Management //////////////
  modExists(e, t) {
    return this.modules[e] ? !0 : (t && console.error("Tabulator Module Not Installed: " + e), !1);
  }
  module(e) {
    var t = this.modules[e];
    return t || console.error("Tabulator module not installed: " + e), t;
  }
}
jo.defaultOptions = F$e;
new m8(jo);
class hGe extends jo {
}
new m8(hGe, V$e);
const cGe = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #888;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}
.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}
.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}
.tabulator.tabulator-block-select {
  user-select: none;
}
.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}
.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}
.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #e6e6e6;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #cdcdcd;
  pointer-events: none;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: 0.6;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: clip;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #cdcdcd;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}
.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: #f3f3f3 !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f3f3f3 !important;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle,
.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}
.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator .tabulator-tableholder:focus {
  outline: none;
}
.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: 700;
  font-size: 20px;
  white-space: normal;
}
.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: 700;
  background: #e2e2e2 !important;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}
.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}
.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}
.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}
.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: 400;
}
.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}
.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}
.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}
.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: hsla(0, 0%, 100%, 0.2);
}
.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}
.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}
.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}
.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}
.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}
.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: 700;
  font-size: 16px;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #d00;
  color: #590000;
}
.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}
.tabulator-row.tabulator-row-even {
  background-color: #efefef;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-selected {
  background-color: #9abcea;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769bcc;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}
.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}
.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}
.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}
.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}
.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}
.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}
.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}
.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1d68cd;
  outline: none;
  padding: 0;
}
.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #d00;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #d00;
}
.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: 700;
  font-size: 1.1em;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: 0.7;
    cursor: pointer;
  }
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}
.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}
.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}
.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}
.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}
.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}
.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}
.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}
.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}
.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #efefef;
  }
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu:after {
  display: inline-block;
  position: absolute;
  top: calc(5px + 0.4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: "";
  border-color: #aaa;
  border-style: solid;
  border-width: 1px 1px 0 0;
  vertical-align: top;
  transform: rotate(45deg);
}
.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}
.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}
.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1d68cd;
}
.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid hsla(0, 0%, 100%, 0.5);
}
.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1d68cd;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1d68cd;
  }
}
.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}
.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 6px 4px 4px;
  color: #333;
  font-weight: 700;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}
.tabulator.tabulator-ltr {
  direction: ltr;
}
.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: 0;
  margin-left: -1px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: auto;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: 0;
  margin-left: 5px;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: 0;
  margin-left: 5px;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}
.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}
.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}
body.tabulator-print-fullscreen-hide > :not(.tabulator-print-fullscreen) {
  display: none !important;
}
.tabulator-print-table {
  border-collapse: collapse;
}
.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
`, fGe = {
  setup() {
    const r = Sl("style", {}, cGe);
    return () => r;
  }
}, dGe = `
.tabulator {
  position: relative;
  border: 1px solid #ddd;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #ddd;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #ddd;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ececec !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #ddd;
  background-color: #e6e6e6;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #f9f9f9;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  background-color: #fff;
  margin-bottom: 20px;
  border: none;
}

.tabulator .tabulator-header {
  border-bottom: 2px solid #ddd;
  background-color: #fff;
  color: inherit;
}

.tabulator .tabulator-header .tabulator-col {
  background-color: #fff;
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 8px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  width: 100%;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-tableholder .tabulator-table {
  color: inherit;
}

.tabulator .tabulator-footer {
  border-top: 2px solid #ddd;
  background: inherit;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-footer .tabulator-paginator {
  color: inherit;
}

.tabulator.table-striped .tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

.tabulator.table-bordered {
  border: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #ddd;
}

.tabulator.table-condensed .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 5px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row {
  min-height: 24px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 5px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.active {
  background: #f5f5f5 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.success {
  background: #dff0d8 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.info {
  background: #d9edf7 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.warning {
  background: #fcf8e3 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.danger {
  background: #f2dede !important;
}

.tabulator-row {
  min-height: 30px;
  border-bottom: 1px solid #ddd;
}

.tabulator-row.tabulator-row-even {
  background-color: transparent;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5 !important;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC !important;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell {
  padding: 8px;
  border-right: none;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

.tabulator-row.tabulator-group {
  background: #fafafa;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-edit-select-list .tabulator-edit-select-list-item {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-notice {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-group {
  color: inherit;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  border: none;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-print-table-group {
  background: #fafafa;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #666;
}

.tabulator-print-table .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

`, pGe = {
  setup() {
    const r = Sl("style", {}, dGe);
    return () => r;
  }
}, gGe = `
.tabulator {
  position: relative;
  border: 1px solid #fff;
  background-color: #fff;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #3759D7;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #fff;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #3759D7;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #fff;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #b7c3f1;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #3759D7;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #f3f3f3;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #fff;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #fff;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #fff;
  border-top: 1px solid #fff;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #3759D7;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #3759D7;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #fff;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #f3f3f3;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #f3f3f3;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #f3f3f3;
  border: 1px solid #fff;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #fff;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #fff;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #f3f3f3;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(243, 243, 243, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #f3f3f3;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #fff;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #fff;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator .tabulator-header {
  border-bottom: 3px solid #3759D7;
  margin-bottom: 4px;
  padding-left: 10px;
  font-size: 1.1em;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: 2px solid #fff;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-col:nth-child(1) {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  border: 1px solid #3759D7;
  font-size: 1em;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border-top: 2px solid #3759D7 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  padding-left: 0 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-top: 3px solid #3759D7 !important;
  border-bottom: 2px solid #3759D7 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid transparent;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  border-bottom: none !important;
}

.tabulator-row {
  margin-bottom: 2px;
}

.tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid #3759D7;
}

.tabulator-row:nth-child(even) {
  background-color: #627ce0;
}

.tabulator-row:nth-child(even) .tabulator-cell {
  background-color: #fff;
}

.tabulator-row:nth-child(even) .tabulator-cell:first-child {
  border-left: 10px solid #627ce0;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    cursor: pointer;
  }
  .tabulator-row.tabulator-selectable:hover .tabulator-cell {
    background-color: #bbb;
  }
}

.tabulator-row.tabulator-selected .tabulator-cell {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover .tabulator-cell {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-moving {
  pointer-events: none !important;
}

.tabulator-row .tabulator-cell {
  padding: 6px 4px;
  border-right: 2px solid #fff;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-group {
  min-width: 100%;
  margin-bottom: 2px;
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  border-right: none;
  background: #8ca0e8;
}

.tabulator-row.tabulator-group span {
  color: #3759D7;
}

.tabulator-edit-select-list {
  border: 1px solid #1D68CD;
}

.tabulator-print-table .tabulator-print-table-group {
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  background: #8ca0e8;
  margin-bottom: 2px;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #3759D7;
}

`, vGe = {
  setup() {
    const r = Sl("style", {}, gGe);
    return () => r;
  }
}, OGe = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: white;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: transparent;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: rgba(0, 0, 0, 0);
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0);
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #363636;
  color: #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: rgba(13, 13, 13, 0) !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: transparent;
  white-space: nowrap;
  overflow: visible;
  color: #363636;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ededed !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: rgba(13, 13, 13, 0) !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #363636;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: transparent;
}

.tabulator-row.tabulator-row-even {
  background-color: #fafafa;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #fafafa;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: transparent;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: transparent;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: transparent;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fafafa;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #aaa;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #363636;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: transparent;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(0, 0, 0, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: transparent;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #363636;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 4px;
  padding-top: 6px;
  color: #363636;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator {
  border: none;
}

.tabulator .tabulator-header {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  border: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.5em 0.75em;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  right: 0px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input {
  border: 1px solid #dbdbdb;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  margin: -5px -10px 10px -10px;
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer .tabulator-page {
  margin: 0 0.1875em;
  padding: calc(0.375em - 1px) 0.75em;
  border: 1px solid #dbdbdb;
  font-size: 16px;
}

.tabulator .tabulator-footer .tabulator-page.active {
  border-color: #4a4a4a;
  color: #363636;
  font-weight: bold;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    border-color: #b5b5b5;
    background: inherit;
    color: inherit;
  }
}

.tabulator.is-striped .tabulator-row:nth-child(even) {
  background-color: #fafafa;
}

.tabulator.is-bordered {
  border: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-narrow .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.25em 0.5em;
}

.tabulator.is-narrow .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 0.25em 0.5em;
}

.tabulator-row {
  min-height: 22px;
}

.tabulator-row.tabulator-row-even {
  background-color: inherit;
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2 !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #009e86 !important;
  }
}

.tabulator-row .tabulator-cell {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 0 0 1px;
}

.tabulator-row.tabulator-group {
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-popup-container {
  background: white;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: white;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    color: white;
  }
}

`, mGe = {
  setup() {
    const r = Sl("style", {}, OGe);
    return () => r;
  }
}, EGe = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #ddd;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #ddd;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #ddd;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  border: none;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #999;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator-row {
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #666;
}

`, bGe = {
  setup() {
    const r = Sl("style", {}, EGe);
    return () => r;
  }
}, SGe = { class: "ns-table-theme-box" }, TGe = /* @__PURE__ */ xi({
  __name: "theme",
  props: {
    theme: {
      type: String,
      default: "default"
    }
  },
  setup(r) {
    return (e, t) => (Tt(), ir("span", SGe, [
      r.theme === "default" ? (Tt(), la(fGe, { key: 0 })) : ln("", !0),
      r.theme === "bootstrap3" ? (Tt(), la(pGe, { key: 1 })) : ln("", !0),
      r.theme === "modern" ? (Tt(), la(vGe, { key: 2 })) : ln("", !0),
      r.theme === "bulma" ? (Tt(), la(mGe, { key: 3 })) : ln("", !0),
      r.theme === "sample" ? (Tt(), la(bGe, { key: 4 })) : ln("", !0)
    ]));
  }
}), yGe = ["id"], RGe = /* @__PURE__ */ xi({
  __name: "table",
  props: {
    columns: {
      // 
      type: Array,
      default: () => []
    },
    data: {
      // 
      type: Array,
      default: () => []
    },
    options: {
      // 
      type: Object,
      default: () => ({})
    },
    theme: {
      // 
      type: String,
      default: "default"
    }
  },
  emits: [
    "loaded"
  ],
  setup(r, { emit: e }) {
    const t = r;
    let i = null;
    const n = lE.v4(), a = Sr(null), o = Sr(null), s = Sr(!1);
    function l() {
      o.value || setTimeout(() => {
        l();
      }, 1e3), delete t.options.data, delete t.options.columns;
      const c = {
        height: "100%",
        layout: "fitColumns",
        columns: t.columns,
        reactiveData: !0,
        autoColumns: !t.columns || t.columns.length < 1,
        ...t.options
      };
      i = new jo(o.value, {
        ...c,
        data: t.data
      }), s.value = !0, e("loaded", n, i);
    }
    function u(c) {
      if (!i) {
        setTimeout(() => {
          u(c);
        }, 100);
        return;
      }
      i.getColumnLayout().length < 1 && h(), i.setData(c);
    }
    function h(c) {
      if (!i) {
        setTimeout(() => {
          h(c);
        }, 100);
        return;
      }
      !c || c.length < 1 || i.setColumns(c);
    }
    return Vn(() => t.columns, (c, f) => {
      c && h(c);
    }, { deep: !0 }), Vn(() => t.data, (c, f) => {
      c && u(c);
    }, { deep: !0 }), po(() => {
      [
        rn,
        Qf,
        MP,
        pv,
        Gf,
        ch,
        El,
        No,
        _P,
        fh,
        xP,
        Xa,
        wP,
        PP,
        NP,
        bl,
        LP,
        Uf,
        DP,
        Go,
        dh,
        $f,
        bi,
        kP,
        QP,
        UP,
        $P,
        GP,
        BP,
        VP,
        FP,
        Zs
      ].forEach((c) => {
        jo.registerModule(c);
      }), Zu(() => {
        l();
      });
    }), (c, f) => (Tt(), ir("div", {
      class: "ns-table-box",
      ref_key: "RefMain",
      ref: a
    }, [
      Vt(TGe, { theme: r.theme }, null, 8, ["theme"]),
      dt("div", {
        class: "ns-table-body",
        id: Fc(n),
        ref_key: "RefBox",
        ref: o
      }, null, 8, yGe)
    ], 512));
  }
}), AGe = `.ns-table-box[data-v-3bdae3b6],.ns-table-box .ns-table-body[data-v-3bdae3b6]{width:100%;height:100%;overflow:hidden;box-sizing:border-box}
`, CGe = /* @__PURE__ */ go(RGe, [["styles", [AGe]], ["__scopeId", "data-v-3bdae3b6"]]), _Ge = ["id"], IGe = /* @__PURE__ */ xi({
  __name: "floatingbox",
  props: {
    width: {
      type: String,
      default: "100px"
    },
    id: {
      type: String,
      default: () => lE.v4()
    },
    style: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["loaded", "mouseleave", "update:show"],
  setup(r, { emit: e }) {
    const t = r, { NsFloatingbox: i } = window, n = Sr(), a = Sr(lE.v4());
    function o() {
      i.close(t.id), e("mouseleave", !1);
    }
    function s() {
      o();
    }
    return po(() => {
      e("loaded", a.value);
    }), (l, u) => (Tt(), ir("div", {
      class: "ns-floating-box",
      id: r.id,
      style: Wn({ width: `${t.width}`, ...t.style }),
      onMouseleave: o,
      ref_key: "RefBox",
      ref: n
    }, [
      dt("div", {
        class: "ns-floating-box-content",
        onClick: s
      }, [
        oi(l.$slots, "items")
      ])
    ], 44, _Ge));
  }
}), xGe = `:root,:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-primary-disabled: #466487;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-success-disabled: #788778;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-warning-disabled: #e1a57d;--ns-error: #aa5032;--ns-error-light-1: #c36955;--ns-error-disabled: #cd876e;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-floating-box{position:fixed;top:0;left:0;z-index:9999;box-shadow:1px 1px 5px var(--ns-border-shadow-color);border-radius:var(--ns-border-radius);background-color:#f7f7f7;padding:0;min-height:30px;display:flex;justify-content:flex-start;align-items:center;flex-direction:column;opacity:0;transition:opacity .2s}.ns-floating-box .ns-floating-box-content{width:100%;height:100%;overflow:hidden;box-sizing:border-box;min-height:30px}
`, wGe = /* @__PURE__ */ go(IGe, [["styles", [xGe]]]), PGe = xi({
  name: "",
  props: {
    hideHeader: {
      type: Boolean,
      default: !1
    },
    hideMenu: {
      type: Boolean,
      default: !1
    },
    menuWidth: {
      type: String,
      default: "200px"
    },
    expandMenu: {
      type: Boolean,
      default: !0
    }
  },
  setup(r, { emit: e }) {
    return {};
  }
}), NGe = `:root,:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-primary-disabled: #466487;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-success-disabled: #788778;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-warning-disabled: #e1a57d;--ns-error: #aa5032;--ns-error-light-1: #c36955;--ns-error-disabled: #cd876e;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-frame-main{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.ns-frame-main .ns-frame-header{width:100%;height:70px;overflow:hidden;box-sizing:border-box;position:relative;z-index:10;box-shadow:1px 1px 5px var(--ns-border-shadow-color);border:1px solid var(--ns-border-color);background-color:var(--ns-primary)}.ns-frame-main .ns-frame-body{width:100%;height:calc(100% - 70px);overflow:hidden;box-sizing:border-box;position:relative;z-index:5}.ns-frame-main .ns-frame-body .ns-frame-body-menu,.ns-frame-main .ns-frame-body .ns-frame-body-content{float:left;height:100%;overflow:hidden;box-sizing:border-box}.ns-none-header .ns-frame-body{height:100%!important}.ns-none-menu .ns-frame-body .ns-frame-body-content{width:100%!important}
`, LGe = {
  key: 0,
  class: "ns-frame-header"
}, DGe = { class: "ns-frame-body" };
function MGe(r, e, t, i, n, a) {
  return Tt(), ir("div", {
    class: Oh(`ns-frame-main ns-none-${r.hideHeader ? "header" : ""} ns-none-${r.hideMenu ? "menu" : ""}`)
  }, [
    r.hideHeader ? ln("", !0) : (Tt(), ir("div", LGe, [
      oi(r.$slots, "header")
    ])),
    dt("div", DGe, [
      r.hideMenu ? ln("", !0) : (Tt(), ir("div", {
        key: 0,
        class: "ns-frame-body-menu",
        style: Wn(`width: ${r.menuWidth}`)
      }, [
        oi(r.$slots, "menu")
      ], 4)),
      dt("div", {
        class: "ns-frame-body-content",
        style: Wn(`width: ${r.hideMenu ? "100%" : `calc(100% - ${r.menuWidth})`}`)
      }, [
        oi(r.$slots, "content")
      ], 4)
    ])
  ], 2);
}
const kGe = /* @__PURE__ */ go(PGe, [["render", MGe], ["styles", [NGe]]]);
function QGe(r) {
  const e = {
    header: 30,
    top: 50,
    bottom: 50
  };
  let t = 0;
  for (let i in r)
    r[i] !== void 0 && (e[i] = 0), t += e[i];
  return `calc(100% - ${t}px)`;
}
const UGe = xi({
  name: "",
  components: {},
  props: {
    scope: {
      type: Array,
      default: () => ["header", "top", "middle", "bottom"]
    },
    hideHeader: {
      type: Boolean,
      default: void 0
    },
    hideTop: {
      type: Boolean,
      default: void 0
    },
    hideBottom: {
      type: Boolean,
      default: void 0
    },
    loading: {
      type: Boolean,
      default: !1
    },
    loadingText: {
      type: String,
      default: "..."
    }
  },
  setup(r, { emit: e }) {
    return {
      handlerScopesHeight: QGe
    };
  }
}), $Ge = `@keyframes contentbox-rotate{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.ns-content-box{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.ns-content-box .ns-content-loading-box{position:fixed;top:0;left:0;bottom:0;right:0;background-color:#96969633;z-index:99999999;width:100%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:center;align-items:center;flex-direction:column}.ns-content-box .ns-content-loading-box svg{animation:contentbox-rotate 3s linear infinite}.ns-content-box .ns-content-loading-box svg path{fill:#aaa}.ns-content-box .ns-content-loading-box span{color:#aaa}.ns-content-box .ns-content-header{position:relative;z-index:10;width:100%;height:30px;overflow:hidden;box-sizing:border-box}.ns-content-box .ns-content-top{position:relative;z-index:10;width:100%;height:50px;overflow:hidden;box-sizing:border-box;border-bottom:1px solid #eee}.ns-content-box .ns-content-middle{position:relative;z-index:5;width:100%;overflow:hidden;box-sizing:border-box}.ns-content-box .ns-content-bottom{position:relative;z-index:10;width:100%;height:50px;overflow:hidden;box-sizing:border-box;border-top:1px solid #eee}
`, GGe = { class: "ns-content-box" }, BGe = {
  key: 0,
  class: "ns-content-loading-box"
}, VGe = /* @__PURE__ */ dt("svg", {
  t: "1692664914237",
  class: "content-loading",
  viewBox: "0 0 1024 1024",
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  "p-id": "8086",
  width: "48",
  height: "48",
  "xmlns:xlink": "http://www.w3.org/1999/xlink"
}, [
  /* @__PURE__ */ dt("path", {
    d: "M393.664871 495.52477c0 11.307533-9.168824 20.466124-20.466124 20.466124l-103.671151 0c-11.307533 0-20.466124-9.15859-20.466124-20.466124 0-11.2973 9.15859-20.466124 20.466124-20.466124l103.671151 0C384.496048 475.058646 393.664871 484.22747 393.664871 495.52477z",
    "p-id": "8087",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M805.207925 495.52477c0 11.307533-9.15859 20.466124-20.466124 20.466124l-103.671151 0c-11.2973 0-20.466124-9.15859-20.466124-20.466124 0-11.2973 9.168824-20.466124 20.466124-20.466124l103.671151 0C796.049335 475.058646 805.207925 484.22747 805.207925 495.52477z",
    "p-id": "8088",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M547.600823 237.917668l0 103.671151c0 11.307533-9.15859 20.466124-20.466124 20.466124s-20.466124-9.15859-20.466124-20.466124l0-103.671151c0-11.307533 9.15859-20.466124 20.466124-20.466124C538.442232 217.451544 547.600823 226.610134 547.600823 237.917668z",
    "p-id": "8089",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M547.600823 649.460722l0 103.681384c0 11.2973-9.15859 20.466124-20.466124 20.466124s-20.466124-9.168824-20.466124-20.466124l0-103.681384c0-11.2973 9.15859-20.466124 20.466124-20.466124C538.442232 628.994598 547.600823 638.163421 547.600823 649.460722z",
    "p-id": "8090",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M411.562497 428.754041c-3.786233 6.569626-10.673084 10.233062-17.733896 10.233062-3.479241 0-6.999414-0.880043-10.222829-2.742461l-89.774653-51.861158c-9.782807-5.658883-13.129019-18.173918-7.480368-27.956725 5.658883-9.79304 18.173918-13.139252 27.956725-7.490601l89.774653 51.861158C413.864936 406.456199 417.22138 418.971234 411.562497 428.754041z",
    "p-id": "8091",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M767.918647 634.633015c-3.796466 6.559393-10.673084 10.233062-17.744129 10.233062-3.469008 0-6.989181-0.890276-10.212596-2.752694l-89.774653-51.861158c-9.782807-5.64865-13.139252-18.173918-7.480368-27.956725 5.64865-9.79304 18.173918-13.139252 27.956725-7.480368l89.774653 51.861158C770.221086 612.32494 773.567297 624.850208 767.918647 634.633015z",
    "p-id": "8092",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M673.723312 282.70778l-51.861158 89.76442c-3.786233 6.559393-10.673084 10.233062-17.744129 10.233062-3.469008 0-6.989181-0.890276-10.212596-2.752694-9.79304-5.64865-13.139252-18.163685-7.480368-27.956725l51.861158-89.76442c5.64865-9.79304 18.163685-13.139252 27.956725-7.490601C676.025751 260.399705 679.382195 272.91474 673.723312 282.70778z",
    "p-id": "8093",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M467.854571 639.053698l-51.861158 89.774653c-3.796466 6.559393-10.673084 10.233062-17.744129 10.233062-3.479241 0-6.999414-0.890276-10.222829-2.752694-9.782807-5.658883-13.139252-18.173918-7.480368-27.956725l51.861158-89.774653c5.658883-9.782807 18.173918-13.129019 27.956725-7.480368C470.15701 616.755856 473.503221 629.27089 467.854571 639.053698z",
    "p-id": "8094",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M460.435601 379.911636c-3.213181 1.862417-6.733355 2.742461-10.202363 2.742461-7.081279 0-13.957897-3.673669-17.744129-10.243295l-51.809993-89.795119c-5.64865-9.79304-2.292206-22.308075 7.500834-27.956725 9.79304-5.64865 22.308075-2.292206 27.956725 7.500834l51.79976 89.795119C473.585085 361.747951 470.228641 374.262986 460.435601 379.911636z",
    "p-id": "8095",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M666.089447 736.400816c-3.223415 1.852184-6.743588 2.742461-10.212596 2.742461-7.071046 0-13.957897-3.673669-17.744129-10.243295l-51.79976-89.805352c-5.64865-9.79304-2.292206-22.308075 7.500834-27.956725 9.782807-5.64865 22.297842-2.281973 27.946492 7.500834l51.809993 89.805352C679.238932 718.237131 675.882488 730.752166 666.089447 736.400816z",
    "p-id": "8096",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M760.499677 384.526747l-89.795119 51.809993c-3.223415 1.852184-6.743588 2.742461-10.212596 2.742461-7.071046 0-13.957897-3.673669-17.744129-10.243295-5.64865-9.79304-2.292206-22.308075 7.500834-27.956725l89.805352-51.809993c9.782807-5.638417 22.297842-2.281973 27.946492 7.500834C773.649162 366.363062 770.292718 378.878097 760.499677 384.526747z",
    "p-id": "8097",
    fill: "#cdcdcd"
  }),
  /* @__PURE__ */ dt("path", {
    d: "M404.02073 590.180594l-89.805352 51.79976c-3.213181 1.862417-6.733355 2.742461-10.202363 2.742461-7.081279 0-13.957897-3.673669-17.744129-10.243295-5.64865-9.79304-2.292206-22.308075 7.500834-27.956725l89.795119-51.79976c9.79304-5.64865 22.308075-2.292206 27.956725 7.500834S413.81377 584.531943 404.02073 590.180594z",
    "p-id": "8098",
    fill: "#cdcdcd"
  })
], -1), FGe = {
  key: 1,
  class: "ns-content-header"
}, XGe = {
  key: 2,
  class: "ns-content-top"
}, YGe = {
  key: 3,
  class: "ns-content-bottom"
};
function HGe(r, e, t, i, n, a) {
  return Tt(), ir("div", GGe, [
    r.loading ? (Tt(), ir("div", BGe, [
      VGe,
      dt("span", null, y1(r.loadingText), 1)
    ])) : ln("", !0),
    r.hideHeader === void 0 ? (Tt(), ir("div", FGe, [
      oi(r.$slots, "header")
    ])) : ln("", !0),
    r.hideTop === void 0 ? (Tt(), ir("div", XGe, [
      oi(r.$slots, "top")
    ])) : ln("", !0),
    dt("div", {
      class: "ns-content-middle",
      style: Wn(`height: ${r.handlerScopesHeight({ header: r.hideHeader, top: r.hideTop, bottom: r.hideBottom })};`)
    }, [
      oi(r.$slots, "middle")
    ], 4),
    r.hideBottom === void 0 ? (Tt(), ir("div", YGe, [
      oi(r.$slots, "bottom")
    ])) : ln("", !0)
  ]);
}
const WGe = /* @__PURE__ */ go(UGe, [["render", HGe], ["styles", [$Ge]]]), zGe = ["width", "height"], ZGe = ["fill"], qGe = /* @__PURE__ */ xi({
  __name: "star",
  props: {
    size: {
      type: [Number, String],
      default: 16
    },
    fill: {
      type: String,
      default: "#CA2188"
    }
  },
  setup(r) {
    return (e, t) => (Tt(), ir("svg", {
      t: "1688548412453",
      class: "icon",
      viewBox: "0 0 1024 1024",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "p-id": "1611",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      width: r.size,
      height: r.size
    }, [
      dt("path", {
        d: "M894.91197 513.709945c0-33.604352-78.328973-62.839187-194.192817-78.305437 70.981634-92.947925 105.664551-169.093163 81.875752-192.829773-23.763217-23.789823-99.884918 10.891048-192.832843 81.899288-15.489786-115.863844-44.701085-194.219423-78.302367-194.219423-33.654494 0-62.892399 78.252225-78.434373 194.116069-92.921319-70.955028-168.964226-105.585757-192.703907-81.795934-23.789823 23.736611 10.9197 99.832729 81.875752 192.727443-115.913986 15.518438-194.192817 44.753273-194.192817 78.407768s78.328973 62.839187 194.192817 78.355579c-71.00824 92.897783-105.691157 168.990832-81.875752 192.779631 23.763217 23.789823 99.884918-10.891048 192.806237-81.899288 15.491833 115.860774 44.677549 194.219423 78.332043 194.219423 33.602306 0 62.889329-78.305437 78.381162-194.116069 92.894713 70.904886 168.990832 105.585757 192.754049 81.795934 23.788799-23.736611-10.917654-99.779517-81.875752-192.727443C816.609603 576.599274 894.91197 547.311227 894.91197 513.709945zM707.835224 316.665173c17.159822 17.107633 3.699252 61.040215-31.060413 115.758444-24.583908-2.723018-50.430576-4.982478-77.584006-6.471388-1.515516-27.541263-3.774977-53.745065-6.603395-78.613452C647.052882 312.811402 690.751127 299.555493 707.835224 316.665173zM600.784092 551.422871c8.528234-8.94165 16.851806-17.828041 24.944112-26.717502 14.873756 17.983583 28.774347 35.709293 40.333614 52.510958-20.296255 3.748371-42.569538 6.729262-66.151629 8.886391C600.450495 574.85249 600.474031 562.982138 600.784092 551.422871zM601.297792 530.049075c0.076748-5.550413 0.410346-10.738575 0.410346-16.33913 0-5.960759-0.152473-11.714809-0.231267-17.573237 5.216815 5.806239 9.633405 11.406794 14.542204 17.10968C611.214652 518.846942 606.332459 524.44852 601.297792 530.049075zM436.366416 566.016241c3.774977 3.853771 7.397481 7.655354 11.277858 11.509125 3.853771 3.853771 7.705496 7.449669 11.585873 11.251252-7.29515-0.410346-14.411221-0.873903-21.450545-1.38658C437.262832 580.350714 436.776761 573.260226 436.366416 566.016241zM439.08841 602.340541c11.585873 0.515746 23.326265 0.926092 35.298947 1.183965 8.707312 8.323573 17.288758 15.876596 25.946952 23.789823-17.983583 14.950504-35.605939 28.361955-52.408627 39.97341C444.276572 647.298476 441.24554 625.514333 439.08841 602.340541zM495.580029 603.77931c5.293563 0.052189 10.532891 0.205685 15.878642 0.205685 5.573949 0 10.788717-0.308015 16.260335-0.410346-5.395894 4.882194-10.765181 9.606799-16.158005 14.232143C506.268462 613.181447 500.92578 608.609315 495.580029 603.77931zM511.35634 590.163197c-10.532891 0-20.914332-0.152473-31.113625-0.512676-7.68196-7.142677-15.284101-14.284331-22.939455-21.939685-7.502881-7.499811-14.747889-15.052834-21.810748-22.555715-0.333598-10.378371-0.515746-20.86112-0.515746-31.547507 0-11.20111 0.310062-22.145369 0.694825-32.936133 6.78145-7.245008 13.745049-14.486946 20.964474-21.681812 7.603165-7.603165 15.260565-14.950504 22.889313-22.092158 10.480702-0.360204 21.013593-0.668219 31.830963-0.668219 10.738575 0 21.348214 0.254803 31.778774 0.565888 7.68196 7.192819 15.360849 14.384615 23.01825 22.092158 7.655354 7.605212 15.029298 15.260565 22.195511 22.968108 0.333598 10.428513 0.565888 21.013593 0.565888 31.752168 0 10.43056-0.308015 20.551058-0.641613 30.621415-7.373944 7.863085-14.926968 15.776312-22.813588 23.636327-7.449669 7.449669-14.95255 14.642488-22.426779 21.681812C532.602224 589.907371 522.094916 590.163197 511.35634 590.163197zM421.208181 513.709945c0 5.446036 0.102331 10.738575 0.155543 16.081257-5.163603-5.753027-9.583263-11.353582-14.490016-17.10968 4.777817-5.600555 9.710153-11.20111 14.771425-16.799618C421.541779 501.942947 421.208181 507.59569 421.208181 513.709945zM422.826028 586.103742c-23.63428-2.157129-45.702901-5.240351-66.049299-9.041934 11.688203-16.95516 25.252127-34.733059 40.383756-52.921303 8.094352 8.939603 15.876596 17.777899 24.483624 26.76969C421.901982 562.829665 422.312328 574.594617 422.826028 586.103742zM422.134273 476.048183c-8.326643 8.68173-16.365736 17.365506-24.252357 25.996071-15.002692-18.136056-29.006637-35.967166-40.641629-52.869115 20.216437-3.751441 42.311665-6.732331 65.791425-8.889461C422.465824 451.845968 422.441265 464.126666 422.134273 476.048183zM587.528184 462.482213c-4.086062-4.211928-8.068769-8.373715-12.280698-12.58769-4.213975-4.211928-8.402367-8.16803-12.590759-12.279674 7.939833 0.410346 15.724123 0.926092 23.379477 1.541099C586.655304 446.76116 587.141374 454.568986 587.528184 462.482213zM584.803119 425.181679c-11.892865-0.565888-23.967878-0.978281-36.248575-1.286296-8.965186-8.578376-17.777899-16.286941-26.717502-24.40483 18.470677-15.362896 36.582173-29.184693 53.795207-41.001833C579.48602 378.988614 582.569242 401.289526 584.803119 425.181679zM528.926508 423.689698c-5.831822-0.102331-11.559267-0.205685-17.467837-0.205685-6.089695 0-11.766998 0.308015-17.804505 0.410346 5.935176-5.342682 11.843746-10.532891 17.752316-15.568581C517.186116 413.311327 523.044544 418.347017 528.926508 423.689698zM601.271186 476.508671c-0.281409-12.227486-0.718361-24.302499-1.284249-36.22197 23.505343 2.209318 45.471634 5.240351 65.691141 8.991792-11.714809 17.057491-25.409716 34.990932-40.618093 53.28253C617.147782 493.877247 609.621365 485.245659 601.271186 476.508671zM511.919159 235.329726c24.150026 0 45.600571 40.383756 59.705823 103.375415-19.628036 15.620769-39.820937 32.67826-60.398602 51.075259-20.063965-18.035772-39.975457-35.195593-59.243289-50.559513C466.113927 275.918143 487.693408 235.329726 511.919159 235.329726zM447.951265 358.951255c16.905018 11.611455 34.630728 25.278733 52.690036 40.333614-8.889461 8.117888-17.801435 16.441461-26.793226 25.022906-11.587919 0.308015-23.508413 0.308015-34.759665 0.820692C441.272145 401.544329 444.199825 379.194298 447.951265 358.951255zM460.07642 437.769368c-4.13518 4.059456-8.271384 8.015557-12.406564 12.125155-3.777023 3.801583-7.373944 7.553023-11.072173 11.356652 0.410346-7.452739 0.77055-14.95255 1.333368-22.197558C445.125917 438.487729 452.652334 438.179714 460.07642 437.769368zM314.927599 316.50963c17.084097-17.057491 60.83453-3.801583 115.321492 30.726815-2.825348 24.868387-5.059226 51.224662-6.626931 78.715783-27.077705 1.488911-52.974515 3.64604-77.481675 6.421246C311.328631 377.653199 297.791313 333.620333 314.927599 316.50963zM233.05287 513.246387c0-24.200168 40.307008-45.676295 103.249549-59.806107 15.516392 19.472494 32.907481 39.665395 51.17452 60.114123-18.188244 20.246113-34.964326 40.181141-50.40397 59.551304C273.744641 558.975894 233.076406 537.446555 233.05287 513.246387zM314.233797 710.241017c-17.057491-17.10968-3.778046-60.83453 30.80254-115.351168 24.868387 2.828418 51.122331 5.087878 78.662571 6.628978 1.49198 27.127847 3.751441 52.974515 6.500041 77.531817C375.428531 713.890126 331.393619 727.350696 314.233797 710.241017zM511.919159 791.93769c-24.173562 0-45.702901-40.644699-59.753919-103.84102 19.343557-15.46625 39.228443-32.267914 59.521628-50.40397 20.37505 18.238386 40.541345 35.605939 60.013839 51.122331C557.572942 751.706407 536.069185 791.93769 511.919159 791.93769zM575.940265 667.954935c-16.928554-11.611455-34.759665-25.38311-52.895721-40.489156 8.631588-7.913227 17.315364-16.031115 26.049283-24.354688 11.895935-0.308015 24.12342-0.308015 35.684734-0.820692C582.595848 625.668853 579.691705 647.812175 575.940265 667.954935zM563.970652 588.570933c3.774977-3.699252 7.553023-7.245008 11.301394-11.04659 4.111644-4.111644 8.015557-8.1711 12.048407-12.279674-0.410346 7.347339-0.744967 14.84715-1.309832 22.043039C578.844407 587.853595 571.368132 588.160587 563.970652 588.570933zM708.503443 710.085474c-17.084097 17.10968-61.040215 3.701299-115.734908-31.03483 2.77316-24.557302 4.958942-50.506301 6.447852-77.584006 27.488051-1.488911 53.745065-3.699252 78.586846-6.5246C712.254883 649.353274 725.58754 693.027983 708.503443 710.085474zM685.895539 573.157895c-15.337313-19.269879-32.473599-39.152718-50.430576-59.243289 18.393929-20.551058 35.427884-40.74396 51.022047-60.371996 62.862723 14.0766 103.172801 35.553751 103.172801 59.703777C789.68437 537.446555 749.171678 559.026036 685.895539 573.157895z",
        fill: r.fill,
        "p-id": "1612"
      }, null, 8, ZGe)
    ], 8, zGe));
  }
}), jGe = xi({
  name: "",
  components: {
    star: qGe
  },
  props: {
    icon: {
      default: ""
    },
    logoWidth: {
      type: String,
      default: "70px"
    },
    title: {
      default: ""
    }
  },
  setup(r, { emit: e }) {
    return {};
  }
}), KGe = `[data-v-b1580676]:root,[data-v-b1580676]:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-primary-disabled: #466487;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-success-disabled: #788778;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-warning-disabled: #e1a57d;--ns-error: #aa5032;--ns-error-light-1: #c36955;--ns-error-disabled: #cd876e;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-header-box[data-v-b1580676]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:space-evenly;align-items:center;position:relative;z-index:100}.ns-header-box .ns-header-item[data-v-b1580676]{width:33%;height:100%;overflow:hidden;box-sizing:border-box;padding:0 10px;display:flex;align-items:center;color:var(--ns-text-color-info)}.ns-header-box .ns-header-left[data-v-b1580676]{justify-content:flex-start}.ns-header-box .ns-header-left .ns-header-icon-box[data-v-b1580676]{width:200px;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:center;align-items:center}.ns-header-box .ns-header-left .ns-header-title-box[data-v-b1580676]{flex-grow:1;font-size:var(--ns-size-top-title);color:var(--ns-text-color-info)}.ns-header-box .ns-header-middle[data-v-b1580676]{justify-content:center}.ns-header-box .ns-header-right[data-v-b1580676]{justify-content:flex-end}
`, JGe = { class: "ns-header-box" }, eBe = { class: "ns-header-item ns-header-left" }, tBe = ["src"], rBe = { class: "ns-header-title-box" }, iBe = { class: "ns-header-item ns-header-middle" }, nBe = { class: "ns-header-item ns-header-right" };
function aBe(r, e, t, i, n, a) {
  const o = XV("star");
  return Tt(), ir("div", JGe, [
    dt("div", eBe, [
      dt("div", {
        class: "ns-header-icon-box",
        style: Wn(`width: ${r.logoWidth};`)
      }, [
        r.icon ? (Tt(), ir("img", {
          key: 1,
          src: r.icon
        }, null, 8, tBe)) : (Tt(), la(o, {
          key: 0,
          size: "64",
          fill: "#f0f0f0"
        }))
      ], 4),
      dt("div", rBe, y1(r.title), 1)
    ]),
    dt("div", iBe, [
      oi(r.$slots, "middle", {}, void 0, !0)
    ]),
    dt("div", nBe, [
      oi(r.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const oBe = /* @__PURE__ */ go(jGe, [["render", aBe], ["styles", [KGe]], ["__scopeId", "data-v-b1580676"]]), sBe = /* @__PURE__ */ xi({
  __name: "text",
  props: {
    type: {
      type: String,
      default: ""
    },
    weight: {
      type: Boolean,
      default: () => {
      }
    }
  },
  setup(r) {
    const e = r;
    po(() => {
    });
    function t() {
      switch (e.type) {
        case "primary":
          return " ns-primary";
        case "success":
          return " ns-success";
        case "warning":
          return " ns-warning";
        case "error":
          return " ns-error";
        case "info":
          return " ns-info";
        default:
          return " ns-default";
      }
    }
    function i() {
      return e.weight === void 0 ? "" : " ns-weight";
    }
    function n() {
      return t() + i();
    }
    return (a, o) => (Tt(), ir("span", {
      class: Oh(`${n()}`)
    }, [
      oi(a.$slots, "default", {}, void 0, !0)
    ], 2));
  }
}), lBe = `[data-v-17b6556d]:root,[data-v-17b6556d]:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-primary-disabled: #466487;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-success-disabled: #788778;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-warning-disabled: #e1a57d;--ns-error: #aa5032;--ns-error-light-1: #c36955;--ns-error-disabled: #cd876e;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-primary[data-v-17b6556d]{color:var(--ns-primary)}.ns-success[data-v-17b6556d]{color:var(--ns-success)}.ns-warning[data-v-17b6556d]{color:var(--ns-warning)}.ns-error[data-v-17b6556d]{color:var(--ns-error)}.ns-info[data-v-17b6556d]{color:var(--ns-info)}.ns-default[data-v-17b6556d]{color:var(--ns-text)}.ns-weight[data-v-17b6556d]{font-weight:var(--ns-weight-text)}
`, uBe = /* @__PURE__ */ go(sBe, [["styles", [lBe]], ["__scopeId", "data-v-17b6556d"]]), hBe = ["innerHTML"], cBe = /* @__PURE__ */ xi({
  __name: "json",
  props: {
    height: {
      type: [Number, String],
      default: 200
    },
    json: {
      type: [Object, String],
      default: ""
    }
  },
  setup(r) {
    const e = r, t = Sr(""), i = {
      string: "#008000",
      number: "#ff8c00",
      boolean: "#0000ff",
      null: "#ff00ff",
      key: "#800404"
    };
    function n(a) {
      return a = a.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), a.replace(/("(\\u[a-zA-Z0-9]{4}|\\[^u]|[^\\"])*"(\s*:)?|\b(true|false|null)\b|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)/g, function(o) {
        var s = "number";
        return /^"/.test(o) ? /:$/.test(o) ? s = "key" : s = "string" : /true|false/.test(o) ? s = "boolean" : /null/.test(o) && (s = "null"), `<span style="color: ${i[s]};">${o}</span>`;
      });
    }
    return Vn(() => e.json, (a) => {
      if (!a) {
        t.value = "";
        return;
      }
      const o = eval;
      switch (typeof a) {
        case "string":
          try {
            const s = JSON.parse(a);
            t.value = n(JSON.stringify(s, null, 4));
          } catch {
            try {
              const l = o(`(${a})`);
              t.value = n(JSON.stringify(l, null, 4));
            } catch {
              t.value = '<span style="color: #f00;">!</span>';
            }
          }
          break;
        case "object":
          try {
            t.value = n(JSON.stringify(a, null, 4));
          } catch {
            t.value = '<span style="color: #f00;">!</span>';
          }
          break;
      }
    }, {
      immediate: !0,
      deep: !0
    }), (a, o) => (Tt(), ir("div", {
      class: "ns-json-main-box",
      style: Wn(`height: ${r.height}${typeof r.height == "string" ? "" : "px"};`)
    }, [
      dt("pre", { innerHTML: t.value }, null, 8, hBe)
    ], 4));
  }
});
console.log(`
--   ____          _____ ______   ____  ____       __ __  ____ 
--  |            / ___/|      | /    ||         |  |  ||    |
--  |  _  | _____(   _ |      ||  o  ||  D  )    |  |  | |  | 
--  |  |  ||     |__  ||_|  |_||     ||    /     |  |  | |  | 
--  |  |  ||_____|/   |  |  |  |  _  ||         |  :  | |  | 
--  |  |  |           |  |  |  |  |  ||  .      |     | |  | 
--  |__|__|        ___|  |__|  |__|__||__|_|     __,_||____|
--                                                             
 Tabulator  ns-table !
`);
const KB = {
  NsAjax: yA
  // Ajax
}, JB = {
  "ns-sandbox": dte,
  // 
  "ns-splitpane": Tte,
  // 
  "ns-codeide": mUe,
  // 
  "ns-table": CGe,
  // 
  "ns-floatingbox": wGe,
  // 
  "ns-framebox": kGe,
  // 
  "ns-contentbox": WGe,
  // 
  "ns-header": oBe,
  // 
  "ns-text": uBe,
  // 
  "ns-json": cBe
  // JSON
};
for (let r in JB) {
  const e = JB[r], t = W1(e);
  customElements.define(r, t);
}
Object.keys(KB).forEach((r) => {
  window[r] = KB[r];
});
