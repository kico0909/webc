function vt(r, e) {
  const t = /* @__PURE__ */ Object.create(null), i = r.split(",");
  for (let o = 0; o < i.length; o++)
    t[i[o]] = !0;
  return e ? (o) => !!t[o.toLowerCase()] : (o) => !!t[o];
}
const Oe = {}.NODE_ENV !== "production" ? Object.freeze({}) : {}, dn = {}.NODE_ENV !== "production" ? Object.freeze([]) : [], Le = () => {
}, ys = () => !1, ZS = /^on[^a-z]/, nr = (r) => ZS.test(r), Xl = (r) => r.startsWith("onUpdate:"), ue = Object.assign, mf = (r, e) => {
  const t = r.indexOf(e);
  t > -1 && r.splice(t, 1);
}, LS = Object.prototype.hasOwnProperty, pe = (r, e) => LS.call(r, e), U = Array.isArray, vo = (r) => Un(r) === "[object Map]", zo = (r) => Un(r) === "[object Set]", ug = (r) => Un(r) === "[object Date]", WS = (r) => Un(r) === "[object RegExp]", re = (r) => typeof r == "function", ne = (r) => typeof r == "string", Wr = (r) => typeof r == "symbol", me = (r) => r !== null && typeof r == "object", Au = (r) => me(r) && re(r.then) && re(r.catch), jO = Object.prototype.toString, Un = (r) => jO.call(r), bf = (r) => Un(r).slice(8, -1), GO = (r) => Un(r) === "[object Object]", Of = (r) => ne(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, wo = /* @__PURE__ */ vt(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), KO = /* @__PURE__ */ vt(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), zu = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, IS = /-(\w)/g, qe = zu((r) => r.replace(IS, (e, t) => t ? t.toUpperCase() : "")), US = /\B([A-Z])/g, Qt = zu(
  (r) => r.replace(US, "-$1").toLowerCase()
), Bi = zu(
  (r) => r.charAt(0).toUpperCase() + r.slice(1)
), _i = zu(
  (r) => r ? `on${Bi(r)}` : ""
), Sn = (r, e) => !Object.is(r, e), Qr = (r, e) => {
  for (let t = 0; t < r.length; t++)
    r[t](e);
}, Al = (r, e, t) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
}, zl = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
}, Nl = (r) => {
  const e = ne(r) ? Number(r) : NaN;
  return isNaN(e) ? r : e;
};
let hg;
const Vl = () => hg || (hg = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Li = {
  [1]: "TEXT",
  [2]: "CLASS",
  [4]: "STYLE",
  [8]: "PROPS",
  [16]: "FULL_PROPS",
  [32]: "HYDRATE_EVENTS",
  [64]: "STABLE_FRAGMENT",
  [128]: "KEYED_FRAGMENT",
  [256]: "UNKEYED_FRAGMENT",
  [512]: "NEED_PATCH",
  [1024]: "DYNAMIC_SLOTS",
  [2048]: "DEV_ROOT_FRAGMENT",
  [-1]: "HOISTED",
  [-2]: "BAIL"
}, YS = {
  [1]: "STABLE",
  [2]: "DYNAMIC",
  [3]: "FORWARDED"
}, FS = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console", BS = /* @__PURE__ */ vt(FS), cg = 2;
function qS(r, e = 0, t = r.length) {
  let i = r.split(/(\r?\n)/);
  const o = i.filter((a, l) => l % 2 === 1);
  i = i.filter((a, l) => l % 2 === 0);
  let n = 0;
  const s = [];
  for (let a = 0; a < i.length; a++)
    if (n += i[a].length + (o[a] && o[a].length || 0), n >= e) {
      for (let l = a - cg; l <= a + cg || t > n; l++) {
        if (l < 0 || l >= i.length)
          continue;
        const u = l + 1;
        s.push(
          `${u}${" ".repeat(Math.max(3 - String(u).length, 0))}|  ${i[l]}`
        );
        const h = i[l].length, c = o[l] && o[l].length || 0;
        if (l === a) {
          const d = e - (n - (h + c)), f = Math.max(
            1,
            t > n ? h - d : t - e
          );
          s.push("   |  " + " ".repeat(d) + "^".repeat(f));
        } else if (l > a) {
          if (t > n) {
            const d = Math.max(Math.min(t - n, h), 1);
            s.push("   |  " + "^".repeat(d));
          }
          n += h + c;
        }
      }
      break;
    }
  return s.join(`
`);
}
function Yn(r) {
  if (U(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const i = r[t], o = ne(i) ? JO(i) : Yn(i);
      if (o)
        for (const n in o)
          e[n] = o[n];
    }
    return e;
  } else {
    if (ne(r))
      return r;
    if (me(r))
      return r;
  }
}
const HS = /;(?![^(]*\))/g, jS = /:([^]+)/, GS = /\/\*[^]*?\*\//g;
function JO(r) {
  const e = {};
  return r.replace(GS, "").split(HS).forEach((t) => {
    if (t) {
      const i = t.split(jS);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function pa(r) {
  let e = "";
  if (ne(r))
    e = r;
  else if (U(r))
    for (let t = 0; t < r.length; t++) {
      const i = pa(r[t]);
      i && (e += i + " ");
    }
  else if (me(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
function KS(r) {
  if (!r)
    return null;
  let { class: e, style: t } = r;
  return e && !ne(e) && (r.class = pa(e)), t && (r.style = Yn(t)), r;
}
const JS = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", eC = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", tC = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", ev = /* @__PURE__ */ vt(JS), tv = /* @__PURE__ */ vt(eC), iC = /* @__PURE__ */ vt(tC), rC = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", oC = /* @__PURE__ */ vt(rC);
function iv(r) {
  return !!r || r === "";
}
function nC(r, e) {
  if (r.length !== e.length)
    return !1;
  let t = !0;
  for (let i = 0; t && i < r.length; i++)
    t = Ir(r[i], e[i]);
  return t;
}
function Ir(r, e) {
  if (r === e)
    return !0;
  let t = ug(r), i = ug(e);
  if (t || i)
    return t && i ? r.getTime() === e.getTime() : !1;
  if (t = Wr(r), i = Wr(e), t || i)
    return r === e;
  if (t = U(r), i = U(e), t || i)
    return t && i ? nC(r, e) : !1;
  if (t = me(r), i = me(e), t || i) {
    if (!t || !i)
      return !1;
    const o = Object.keys(r).length, n = Object.keys(e).length;
    if (o !== n)
      return !1;
    for (const s in r) {
      const a = r.hasOwnProperty(s), l = e.hasOwnProperty(s);
      if (a && !l || !a && l || !Ir(r[s], e[s]))
        return !1;
    }
  }
  return String(r) === String(e);
}
function Nu(r, e) {
  return r.findIndex((t) => Ir(t, e));
}
const sC = (r) => ne(r) ? r : r == null ? "" : U(r) || me(r) && (r.toString === jO || !re(r.toString)) ? JSON.stringify(r, rv, 2) : String(r), rv = (r, e) => e && e.__v_isRef ? rv(r, e.value) : vo(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((t, [i, o]) => (t[`${i} =>`] = o, t), {})
} : zo(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : me(e) && !U(e) && !GO(e) ? String(e) : e;
function Zl(r, ...e) {
  console.warn(`[Vue warn] ${r}`, ...e);
}
let Ut;
class vf {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = Ut, !e && Ut && (this.index = (Ut.scopes || (Ut.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const t = Ut;
      try {
        return Ut = this, e();
      } finally {
        Ut = t;
      }
    } else
      ({}).NODE_ENV !== "production" && Zl("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    Ut = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    Ut = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, i;
      for (t = 0, i = this.effects.length; t < i; t++)
        this.effects[t].stop();
      for (t = 0, i = this.cleanups.length; t < i; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, i = this.scopes.length; t < i; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const o = this.parent.scopes.pop();
        o && o !== this && (this.parent.scopes[this.index] = o, o.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function aC(r) {
  return new vf(r);
}
function ov(r, e = Ut) {
  e && e.active && e.effects.push(r);
}
function nv() {
  return Ut;
}
function lC(r) {
  Ut ? Ut.cleanups.push(r) : {}.NODE_ENV !== "production" && Zl(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
const As = (r) => {
  const e = new Set(r);
  return e.w = 0, e.n = 0, e;
}, sv = (r) => (r.w & Ur) > 0, av = (r) => (r.n & Ur) > 0, uC = ({ deps: r }) => {
  if (r.length)
    for (let e = 0; e < r.length; e++)
      r[e].w |= Ur;
}, hC = (r) => {
  const { deps: e } = r;
  if (e.length) {
    let t = 0;
    for (let i = 0; i < e.length; i++) {
      const o = e[i];
      sv(o) && !av(o) ? o.delete(r) : e[t++] = o, o.w &= ~Ur, o.n &= ~Ur;
    }
    e.length = t;
  }
}, Ll = /* @__PURE__ */ new WeakMap();
let ds = 0, Ur = 1;
const _c = 30;
let St;
const yo = Symbol({}.NODE_ENV !== "production" ? "iterate" : ""), Dc = Symbol({}.NODE_ENV !== "production" ? "Map key iterate" : "");
class ga {
  constructor(e, t = null, i) {
    this.fn = e, this.scheduler = t, this.active = !0, this.deps = [], this.parent = void 0, ov(this, i);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = St, t = _r;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = St, St = this, _r = !0, Ur = 1 << ++ds, ds <= _c ? uC(this) : dg(this), this.fn();
    } finally {
      ds <= _c && hC(this), Ur = 1 << --ds, St = this.parent, _r = t, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    St === this ? this.deferStop = !0 : this.active && (dg(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function dg(r) {
  const { deps: e } = r;
  if (e.length) {
    for (let t = 0; t < e.length; t++)
      e[t].delete(r);
    e.length = 0;
  }
}
function cC(r, e) {
  r.effect && (r = r.effect.fn);
  const t = new ga(r);
  e && (ue(t, e), e.scope && ov(t, e.scope)), (!e || !e.lazy) && t.run();
  const i = t.run.bind(t);
  return i.effect = t, i;
}
function dC(r) {
  r.effect.stop();
}
let _r = !0;
const lv = [];
function No() {
  lv.push(_r), _r = !1;
}
function Vo() {
  const r = lv.pop();
  _r = r === void 0 ? !0 : r;
}
function ut(r, e, t) {
  if (_r && St) {
    let i = Ll.get(r);
    i || Ll.set(r, i = /* @__PURE__ */ new Map());
    let o = i.get(t);
    o || i.set(t, o = As());
    const n = {}.NODE_ENV !== "production" ? { effect: St, target: r, type: e, key: t } : void 0;
    Mc(o, n);
  }
}
function Mc(r, e) {
  let t = !1;
  ds <= _c ? av(r) || (r.n |= Ur, t = !sv(r)) : t = !r.has(St), t && (r.add(St), St.deps.push(r), {}.NODE_ENV !== "production" && St.onTrack && St.onTrack(
    ue(
      {
        effect: St
      },
      e
    )
  ));
}
function qi(r, e, t, i, o, n) {
  const s = Ll.get(r);
  if (!s)
    return;
  let a = [];
  if (e === "clear")
    a = [...s.values()];
  else if (t === "length" && U(r)) {
    const u = Number(i);
    s.forEach((h, c) => {
      (c === "length" || c >= u) && a.push(h);
    });
  } else
    switch (t !== void 0 && a.push(s.get(t)), e) {
      case "add":
        U(r) ? Of(t) && a.push(s.get("length")) : (a.push(s.get(yo)), vo(r) && a.push(s.get(Dc)));
        break;
      case "delete":
        U(r) || (a.push(s.get(yo)), vo(r) && a.push(s.get(Dc)));
        break;
      case "set":
        vo(r) && a.push(s.get(yo));
        break;
    }
  const l = {}.NODE_ENV !== "production" ? { target: r, type: e, key: t, newValue: i, oldValue: o, oldTarget: n } : void 0;
  if (a.length === 1)
    a[0] && ({}.NODE_ENV !== "production" ? nn(a[0], l) : nn(a[0]));
  else {
    const u = [];
    for (const h of a)
      h && u.push(...h);
    ({}).NODE_ENV !== "production" ? nn(As(u), l) : nn(As(u));
  }
}
function nn(r, e) {
  const t = U(r) ? r : [...r];
  for (const i of t)
    i.computed && fg(i, e);
  for (const i of t)
    i.computed || fg(i, e);
}
function fg(r, e) {
  (r !== St || r.allowRecurse) && ({}.NODE_ENV !== "production" && r.onTrigger && r.onTrigger(ue({ effect: r }, e)), r.scheduler ? r.scheduler() : r.run());
}
function fC(r, e) {
  var t;
  return (t = Ll.get(r)) == null ? void 0 : t.get(e);
}
const pC = /* @__PURE__ */ vt("__proto__,__v_isRef,__isVue"), uv = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(Wr)
), gC = /* @__PURE__ */ Vu(), mC = /* @__PURE__ */ Vu(!1, !0), bC = /* @__PURE__ */ Vu(!0), OC = /* @__PURE__ */ Vu(!0, !0), pg = /* @__PURE__ */ vC();
function vC() {
  const r = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    r[e] = function(...t) {
      const i = se(this);
      for (let n = 0, s = this.length; n < s; n++)
        ut(i, "get", n + "");
      const o = i[e](...t);
      return o === -1 || o === !1 ? i[e](...t.map(se)) : o;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    r[e] = function(...t) {
      No();
      const i = se(this)[e].apply(this, t);
      return Vo(), i;
    };
  }), r;
}
function wC(r) {
  const e = se(this);
  return ut(e, "has", r), e.hasOwnProperty(r);
}
function Vu(r = !1, e = !1) {
  return function(i, o, n) {
    if (o === "__v_isReactive")
      return !r;
    if (o === "__v_isReadonly")
      return r;
    if (o === "__v_isShallow")
      return e;
    if (o === "__v_raw" && n === (r ? e ? bv : mv : e ? gv : pv).get(i))
      return i;
    const s = U(i);
    if (!r) {
      if (s && pe(pg, o))
        return Reflect.get(pg, o, n);
      if (o === "hasOwnProperty")
        return wC;
    }
    const a = Reflect.get(i, o, n);
    return (Wr(o) ? uv.has(o) : pC(o)) || (r || ut(i, "get", o), e) ? a : Ne(a) ? s && Of(o) ? a : a.value : me(a) ? r ? yf(a) : Wu(a) : a;
  };
}
const yC = /* @__PURE__ */ hv(), xC = /* @__PURE__ */ hv(!0);
function hv(r = !1) {
  return function(t, i, o, n) {
    let s = t[i];
    if (sr(s) && Ne(s) && !Ne(o))
      return !1;
    if (!r && (!zs(o) && !sr(o) && (s = se(s), o = se(o)), !U(t) && Ne(s) && !Ne(o)))
      return s.value = o, !0;
    const a = U(t) && Of(i) ? Number(i) < t.length : pe(t, i), l = Reflect.set(t, i, o, n);
    return t === se(n) && (a ? Sn(o, s) && qi(t, "set", i, o, s) : qi(t, "add", i, o)), l;
  };
}
function SC(r, e) {
  const t = pe(r, e), i = r[e], o = Reflect.deleteProperty(r, e);
  return o && t && qi(r, "delete", e, void 0, i), o;
}
function CC(r, e) {
  const t = Reflect.has(r, e);
  return (!Wr(e) || !uv.has(e)) && ut(r, "has", e), t;
}
function QC(r) {
  return ut(r, "iterate", U(r) ? "length" : yo), Reflect.ownKeys(r);
}
const cv = {
  get: gC,
  set: yC,
  deleteProperty: SC,
  has: CC,
  ownKeys: QC
}, dv = {
  get: bC,
  set(r, e) {
    return {}.NODE_ENV !== "production" && Zl(
      `Set operation on key "${String(e)}" failed: target is readonly.`,
      r
    ), !0;
  },
  deleteProperty(r, e) {
    return {}.NODE_ENV !== "production" && Zl(
      `Delete operation on key "${String(e)}" failed: target is readonly.`,
      r
    ), !0;
  }
}, PC = /* @__PURE__ */ ue(
  {},
  cv,
  {
    get: mC,
    set: xC
  }
), kC = /* @__PURE__ */ ue(
  {},
  dv,
  {
    get: OC
  }
), wf = (r) => r, Zu = (r) => Reflect.getPrototypeOf(r);
function Na(r, e, t = !1, i = !1) {
  r = r.__v_raw;
  const o = se(r), n = se(e);
  t || (e !== n && ut(o, "get", e), ut(o, "get", n));
  const { has: s } = Zu(o), a = i ? wf : t ? Sf : Vs;
  if (s.call(o, e))
    return a(r.get(e));
  if (s.call(o, n))
    return a(r.get(n));
  r !== o && r.get(e);
}
function Va(r, e = !1) {
  const t = this.__v_raw, i = se(t), o = se(r);
  return e || (r !== o && ut(i, "has", r), ut(i, "has", o)), r === o ? t.has(r) : t.has(r) || t.has(o);
}
function Za(r, e = !1) {
  return r = r.__v_raw, !e && ut(se(r), "iterate", yo), Reflect.get(r, "size", r);
}
function gg(r) {
  r = se(r);
  const e = se(this);
  return Zu(e).has.call(e, r) || (e.add(r), qi(e, "add", r, r)), this;
}
function mg(r, e) {
  e = se(e);
  const t = se(this), { has: i, get: o } = Zu(t);
  let n = i.call(t, r);
  n ? {}.NODE_ENV !== "production" && fv(t, i, r) : (r = se(r), n = i.call(t, r));
  const s = o.call(t, r);
  return t.set(r, e), n ? Sn(e, s) && qi(t, "set", r, e, s) : qi(t, "add", r, e), this;
}
function bg(r) {
  const e = se(this), { has: t, get: i } = Zu(e);
  let o = t.call(e, r);
  o ? {}.NODE_ENV !== "production" && fv(e, t, r) : (r = se(r), o = t.call(e, r));
  const n = i ? i.call(e, r) : void 0, s = e.delete(r);
  return o && qi(e, "delete", r, void 0, n), s;
}
function Og() {
  const r = se(this), e = r.size !== 0, t = {}.NODE_ENV !== "production" ? vo(r) ? new Map(r) : new Set(r) : void 0, i = r.clear();
  return e && qi(r, "clear", void 0, void 0, t), i;
}
function La(r, e) {
  return function(i, o) {
    const n = this, s = n.__v_raw, a = se(s), l = e ? wf : r ? Sf : Vs;
    return !r && ut(a, "iterate", yo), s.forEach((u, h) => i.call(o, l(u), l(h), n));
  };
}
function Wa(r, e, t) {
  return function(...i) {
    const o = this.__v_raw, n = se(o), s = vo(n), a = r === "entries" || r === Symbol.iterator && s, l = r === "keys" && s, u = o[r](...i), h = t ? wf : e ? Sf : Vs;
    return !e && ut(
      n,
      "iterate",
      l ? Dc : yo
    ), {
      // iterator protocol
      next() {
        const { value: c, done: d } = u.next();
        return d ? { value: c, done: d } : {
          value: a ? [h(c[0]), h(c[1])] : h(c),
          done: d
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function mr(r) {
  return function(...e) {
    if ({}.NODE_ENV !== "production") {
      const t = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(
        `${Bi(r)} operation ${t}failed: target is readonly.`,
        se(this)
      );
    }
    return r === "delete" ? !1 : this;
  };
}
function EC() {
  const r = {
    get(n) {
      return Na(this, n);
    },
    get size() {
      return Za(this);
    },
    has: Va,
    add: gg,
    set: mg,
    delete: bg,
    clear: Og,
    forEach: La(!1, !1)
  }, e = {
    get(n) {
      return Na(this, n, !1, !0);
    },
    get size() {
      return Za(this);
    },
    has: Va,
    add: gg,
    set: mg,
    delete: bg,
    clear: Og,
    forEach: La(!1, !0)
  }, t = {
    get(n) {
      return Na(this, n, !0);
    },
    get size() {
      return Za(this, !0);
    },
    has(n) {
      return Va.call(this, n, !0);
    },
    add: mr("add"),
    set: mr("set"),
    delete: mr("delete"),
    clear: mr("clear"),
    forEach: La(!0, !1)
  }, i = {
    get(n) {
      return Na(this, n, !0, !0);
    },
    get size() {
      return Za(this, !0);
    },
    has(n) {
      return Va.call(this, n, !0);
    },
    add: mr("add"),
    set: mr("set"),
    delete: mr("delete"),
    clear: mr("clear"),
    forEach: La(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((n) => {
    r[n] = Wa(
      n,
      !1,
      !1
    ), t[n] = Wa(
      n,
      !0,
      !1
    ), e[n] = Wa(
      n,
      !1,
      !0
    ), i[n] = Wa(
      n,
      !0,
      !0
    );
  }), [
    r,
    t,
    e,
    i
  ];
}
const [
  TC,
  $C,
  RC,
  _C
] = /* @__PURE__ */ EC();
function Lu(r, e) {
  const t = e ? r ? _C : RC : r ? $C : TC;
  return (i, o, n) => o === "__v_isReactive" ? !r : o === "__v_isReadonly" ? r : o === "__v_raw" ? i : Reflect.get(
    pe(t, o) && o in i ? t : i,
    o,
    n
  );
}
const DC = {
  get: /* @__PURE__ */ Lu(!1, !1)
}, MC = {
  get: /* @__PURE__ */ Lu(!1, !0)
}, XC = {
  get: /* @__PURE__ */ Lu(!0, !1)
}, AC = {
  get: /* @__PURE__ */ Lu(!0, !0)
};
function fv(r, e, t) {
  const i = se(t);
  if (i !== t && e.call(r, i)) {
    const o = bf(r);
    console.warn(
      `Reactive ${o} contains both the raw and reactive versions of the same object${o === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const pv = /* @__PURE__ */ new WeakMap(), gv = /* @__PURE__ */ new WeakMap(), mv = /* @__PURE__ */ new WeakMap(), bv = /* @__PURE__ */ new WeakMap();
function zC(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function NC(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : zC(bf(r));
}
function Wu(r) {
  return sr(r) ? r : Iu(
    r,
    !1,
    cv,
    DC,
    pv
  );
}
function Ov(r) {
  return Iu(
    r,
    !1,
    PC,
    MC,
    gv
  );
}
function yf(r) {
  return Iu(
    r,
    !0,
    dv,
    XC,
    mv
  );
}
function sn(r) {
  return Iu(
    r,
    !0,
    kC,
    AC,
    bv
  );
}
function Iu(r, e, t, i, o) {
  if (!me(r))
    return {}.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(r)}`), r;
  if (r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const n = o.get(r);
  if (n)
    return n;
  const s = NC(r);
  if (s === 0)
    return r;
  const a = new Proxy(
    r,
    s === 2 ? i : t
  );
  return o.set(r, a), a;
}
function Dr(r) {
  return sr(r) ? Dr(r.__v_raw) : !!(r && r.__v_isReactive);
}
function sr(r) {
  return !!(r && r.__v_isReadonly);
}
function zs(r) {
  return !!(r && r.__v_isShallow);
}
function Ns(r) {
  return Dr(r) || sr(r);
}
function se(r) {
  const e = r && r.__v_raw;
  return e ? se(e) : r;
}
function xf(r) {
  return Al(r, "__v_skip", !0), r;
}
const Vs = (r) => me(r) ? Wu(r) : r, Sf = (r) => me(r) ? yf(r) : r;
function Cf(r) {
  _r && St && (r = se(r), {}.NODE_ENV !== "production" ? Mc(r.dep || (r.dep = As()), {
    target: r,
    type: "get",
    key: "value"
  }) : Mc(r.dep || (r.dep = As())));
}
function Uu(r, e) {
  r = se(r);
  const t = r.dep;
  t && ({}.NODE_ENV !== "production" ? nn(t, {
    target: r,
    type: "set",
    key: "value",
    newValue: e
  }) : nn(t));
}
function Ne(r) {
  return !!(r && r.__v_isRef === !0);
}
function gt(r) {
  return vv(r, !1);
}
function VC(r) {
  return vv(r, !0);
}
function vv(r, e) {
  return Ne(r) ? r : new ZC(r, e);
}
class ZC {
  constructor(e, t) {
    this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : se(e), this._value = t ? e : Vs(e);
  }
  get value() {
    return Cf(this), this._value;
  }
  set value(e) {
    const t = this.__v_isShallow || zs(e) || sr(e);
    e = t ? e : se(e), Sn(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : Vs(e), Uu(this, e));
  }
}
function LC(r) {
  Uu(r, {}.NODE_ENV !== "production" ? r.value : void 0);
}
function Yu(r) {
  return Ne(r) ? r.value : r;
}
function WC(r) {
  return re(r) ? r() : Yu(r);
}
const IC = {
  get: (r, e, t) => Yu(Reflect.get(r, e, t)),
  set: (r, e, t, i) => {
    const o = r[e];
    return Ne(o) && !Ne(t) ? (o.value = t, !0) : Reflect.set(r, e, t, i);
  }
};
function Qf(r) {
  return Dr(r) ? r : new Proxy(r, IC);
}
class UC {
  constructor(e) {
    this.dep = void 0, this.__v_isRef = !0;
    const { get: t, set: i } = e(
      () => Cf(this),
      () => Uu(this)
    );
    this._get = t, this._set = i;
  }
  get value() {
    return this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function YC(r) {
  return new UC(r);
}
function FC(r) {
  ({}).NODE_ENV !== "production" && !Ns(r) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = U(r) ? new Array(r.length) : {};
  for (const t in r)
    e[t] = wv(r, t);
  return e;
}
class BC {
  constructor(e, t, i) {
    this._object = e, this._key = t, this._defaultValue = i, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return fC(se(this._object), this._key);
  }
}
class qC {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0;
  }
  get value() {
    return this._getter();
  }
}
function HC(r, e, t) {
  return Ne(r) ? r : re(r) ? new qC(r) : me(r) && arguments.length > 1 ? wv(r, e, t) : gt(r);
}
function wv(r, e, t) {
  const i = r[e];
  return Ne(i) ? i : new BC(
    r,
    e,
    t
  );
}
class jC {
  constructor(e, t, i, o) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new ga(e, () => {
      this._dirty || (this._dirty = !0, Uu(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !o, this.__v_isReadonly = i;
  }
  get value() {
    const e = se(this);
    return Cf(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
function GC(r, e, t = !1) {
  let i, o;
  const n = re(r);
  n ? (i = r, o = {}.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : Le) : (i = r.get, o = r.set);
  const s = new jC(i, o, n || !o, t);
  return {}.NODE_ENV !== "production" && e && !t && (s.effect.onTrack = e.onTrack, s.effect.onTrigger = e.onTrigger), s;
}
const xo = [];
function xs(r) {
  xo.push(r);
}
function Ss() {
  xo.pop();
}
function $(r, ...e) {
  if ({}.NODE_ENV === "production")
    return;
  No();
  const t = xo.length ? xo[xo.length - 1].component : null, i = t && t.appContext.config.warnHandler, o = KC();
  if (i)
    Wi(
      i,
      t,
      11,
      [
        r + e.join(""),
        t && t.proxy,
        o.map(
          ({ vnode: n }) => `at <${ih(t, n.type)}>`
        ).join(`
`),
        o
      ]
    );
  else {
    const n = [`[Vue warn]: ${r}`, ...e];
    o.length && n.push(`
`, ...JC(o)), console.warn(...n);
  }
  Vo();
}
function KC() {
  let r = xo[xo.length - 1];
  if (!r)
    return [];
  const e = [];
  for (; r; ) {
    const t = e[0];
    t && t.vnode === r ? t.recurseCount++ : e.push({
      vnode: r,
      recurseCount: 0
    });
    const i = r.component && r.component.parent;
    r = i && i.vnode;
  }
  return e;
}
function JC(r) {
  const e = [];
  return r.forEach((t, i) => {
    e.push(...i === 0 ? [] : [`
`], ...eQ(t));
  }), e;
}
function eQ({ vnode: r, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", i = r.component ? r.component.parent == null : !1, o = ` at <${ih(
    r.component,
    r.type,
    i
  )}`, n = ">" + t;
  return r.props ? [o, ...tQ(r.props), n] : [o + n];
}
function tQ(r) {
  const e = [], t = Object.keys(r);
  return t.slice(0, 3).forEach((i) => {
    e.push(...yv(i, r[i]));
  }), t.length > 3 && e.push(" ..."), e;
}
function yv(r, e, t) {
  return ne(e) ? (e = JSON.stringify(e), t ? e : [`${r}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${r}=${e}`] : Ne(e) ? (e = yv(r, se(e.value), !0), t ? e : [`${r}=Ref<`, e, ">"]) : re(e) ? [`${r}=fn${e.name ? `<${e.name}>` : ""}`] : (e = se(e), t ? e : [`${r}=`, e]);
}
function Pf(r, e) {
  ({}).NODE_ENV !== "production" && r !== void 0 && (typeof r != "number" ? $(`${e} is not a valid number - got ${JSON.stringify(r)}.`) : isNaN(r) && $(`${e} is NaN - the duration expression might be incorrect.`));
}
const kf = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  [0]: "setup function",
  [1]: "render function",
  [2]: "watcher getter",
  [3]: "watcher callback",
  [4]: "watcher cleanup function",
  [5]: "native event handler",
  [6]: "component event handler",
  [7]: "vnode hook",
  [8]: "directive hook",
  [9]: "transition hook",
  [10]: "app errorHandler",
  [11]: "app warnHandler",
  [12]: "ref function",
  [13]: "async component loader",
  [14]: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function Wi(r, e, t, i) {
  let o;
  try {
    o = i ? r(...i) : r();
  } catch (n) {
    Zo(n, e, t);
  }
  return o;
}
function Gt(r, e, t, i) {
  if (re(r)) {
    const n = Wi(r, e, t, i);
    return n && Au(n) && n.catch((s) => {
      Zo(s, e, t);
    }), n;
  }
  const o = [];
  for (let n = 0; n < r.length; n++)
    o.push(Gt(r[n], e, t, i));
  return o;
}
function Zo(r, e, t, i = !0) {
  const o = e ? e.vnode : null;
  if (e) {
    let n = e.parent;
    const s = e.proxy, a = {}.NODE_ENV !== "production" ? kf[t] : t;
    for (; n; ) {
      const u = n.ec;
      if (u) {
        for (let h = 0; h < u.length; h++)
          if (u[h](r, s, a) === !1)
            return;
      }
      n = n.parent;
    }
    const l = e.appContext.config.errorHandler;
    if (l) {
      Wi(
        l,
        null,
        10,
        [r, s, a]
      );
      return;
    }
  }
  iQ(r, t, o, i);
}
function iQ(r, e, t, i = !0) {
  if ({}.NODE_ENV !== "production") {
    const o = kf[e];
    if (t && xs(t), $(`Unhandled error${o ? ` during execution of ${o}` : ""}`), t && Ss(), i)
      throw r;
    console.error(r);
  } else
    console.error(r);
}
let Zs = !1, Xc = !1;
const mt = [];
let Mi = 0;
const fn = [];
let $i = null, yr = 0;
const xv = /* @__PURE__ */ Promise.resolve();
let Ef = null;
const rQ = 100;
function Ls(r) {
  const e = Ef || xv;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function oQ(r) {
  let e = Mi + 1, t = mt.length;
  for (; e < t; ) {
    const i = e + t >>> 1;
    Ws(mt[i]) < r ? e = i + 1 : t = i;
  }
  return e;
}
function ma(r) {
  (!mt.length || !mt.includes(
    r,
    Zs && r.allowRecurse ? Mi + 1 : Mi
  )) && (r.id == null ? mt.push(r) : mt.splice(oQ(r.id), 0, r), Sv());
}
function Sv() {
  !Zs && !Xc && (Xc = !0, Ef = xv.then(Cv));
}
function nQ(r) {
  const e = mt.indexOf(r);
  e > Mi && mt.splice(e, 1);
}
function Fu(r) {
  U(r) ? fn.push(...r) : (!$i || !$i.includes(
    r,
    r.allowRecurse ? yr + 1 : yr
  )) && fn.push(r), Sv();
}
function vg(r, e = Zs ? Mi + 1 : 0) {
  for ({}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()); e < mt.length; e++) {
    const t = mt[e];
    if (t && t.pre) {
      if ({}.NODE_ENV !== "production" && Tf(r, t))
        continue;
      mt.splice(e, 1), e--, t();
    }
  }
}
function Wl(r) {
  if (fn.length) {
    const e = [...new Set(fn)];
    if (fn.length = 0, $i) {
      $i.push(...e);
      return;
    }
    for ($i = e, {}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), $i.sort((t, i) => Ws(t) - Ws(i)), yr = 0; yr < $i.length; yr++)
      ({}).NODE_ENV !== "production" && Tf(r, $i[yr]) || $i[yr]();
    $i = null, yr = 0;
  }
}
const Ws = (r) => r.id == null ? 1 / 0 : r.id, sQ = (r, e) => {
  const t = Ws(r) - Ws(e);
  if (t === 0) {
    if (r.pre && !e.pre)
      return -1;
    if (e.pre && !r.pre)
      return 1;
  }
  return t;
};
function Cv(r) {
  Xc = !1, Zs = !0, {}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), mt.sort(sQ);
  const e = {}.NODE_ENV !== "production" ? (t) => Tf(r, t) : Le;
  try {
    for (Mi = 0; Mi < mt.length; Mi++) {
      const t = mt[Mi];
      if (t && t.active !== !1) {
        if ({}.NODE_ENV !== "production" && e(t))
          continue;
        Wi(t, null, 14);
      }
    }
  } finally {
    Mi = 0, mt.length = 0, Wl(r), Zs = !1, Ef = null, (mt.length || fn.length) && Cv(r);
  }
}
function Tf(r, e) {
  if (!r.has(e))
    r.set(e, 1);
  else {
    const t = r.get(e);
    if (t > rQ) {
      const i = e.ownerInstance, o = i && qs(i.type);
      return $(
        `Maximum recursive updates exceeded${o ? ` in component <${o}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
      ), !0;
    } else
      r.set(e, t + 1);
  }
}
let Mr = !1;
const en = /* @__PURE__ */ new Set();
({}).NODE_ENV !== "production" && (Vl().__VUE_HMR_RUNTIME__ = {
  createRecord: Dh(Qv),
  rerender: Dh(uQ),
  reload: Dh(hQ)
});
const ko = /* @__PURE__ */ new Map();
function aQ(r) {
  const e = r.type.__hmrId;
  let t = ko.get(e);
  t || (Qv(e, r.type), t = ko.get(e)), t.instances.add(r);
}
function lQ(r) {
  ko.get(r.type.__hmrId).instances.delete(r);
}
function Qv(r, e) {
  return ko.has(r) ? !1 : (ko.set(r, {
    initialDef: Cs(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Cs(r) {
  return Sw(r) ? r.__vccOpts : r;
}
function uQ(r, e) {
  const t = ko.get(r);
  t && (t.initialDef.render = e, [...t.instances].forEach((i) => {
    e && (i.render = e, Cs(i.type).render = e), i.renderCache = [], Mr = !0, i.update(), Mr = !1;
  }));
}
function hQ(r, e) {
  const t = ko.get(r);
  if (!t)
    return;
  e = Cs(e), wg(t.initialDef, e);
  const i = [...t.instances];
  for (const o of i) {
    const n = Cs(o.type);
    en.has(n) || (n !== t.initialDef && wg(n, e), en.add(n)), o.appContext.propsCache.delete(o.type), o.appContext.emitsCache.delete(o.type), o.appContext.optionsCache.delete(o.type), o.ceReload ? (en.add(n), o.ceReload(e.styles), en.delete(n)) : o.parent ? ma(o.parent.update) : o.appContext.reload ? o.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  Fu(() => {
    for (const o of i)
      en.delete(
        Cs(o.type)
      );
  });
}
function wg(r, e) {
  ue(r, e);
  for (const t in r)
    t !== "__file" && !(t in e) && delete r[t];
}
function Dh(r) {
  return (e, t) => {
    try {
      return r(e, t);
    } catch (i) {
      console.error(i), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let gi, fs = [], Ac = !1;
function ba(r, ...e) {
  gi ? gi.emit(r, ...e) : Ac || fs.push({ event: r, args: e });
}
function $f(r, e) {
  var t, i;
  gi = r, gi ? (gi.enabled = !0, fs.forEach(({ event: o, args: n }) => gi.emit(o, ...n)), fs = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((i = (t = window.navigator) == null ? void 0 : t.userAgent) != null && i.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((n) => {
    $f(n, e);
  }), setTimeout(() => {
    gi || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, Ac = !0, fs = []);
  }, 3e3)) : (Ac = !0, fs = []);
}
function cQ(r, e) {
  ba("app:init", r, e, {
    Fragment: je,
    Text: Yr,
    Comment: Ue,
    Static: Xr
  });
}
function dQ(r) {
  ba("app:unmount", r);
}
const zc = /* @__PURE__ */ Rf(
  "component:added"
  /* COMPONENT_ADDED */
), Pv = /* @__PURE__ */ Rf(
  "component:updated"
  /* COMPONENT_UPDATED */
), fQ = /* @__PURE__ */ Rf(
  "component:removed"
  /* COMPONENT_REMOVED */
), pQ = (r) => {
  gi && typeof gi.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !gi.cleanupBuffer(r) && fQ(r);
};
function Rf(r) {
  return (e) => {
    ba(
      r,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const gQ = /* @__PURE__ */ kv(
  "perf:start"
  /* PERFORMANCE_START */
), mQ = /* @__PURE__ */ kv(
  "perf:end"
  /* PERFORMANCE_END */
);
function kv(r) {
  return (e, t, i) => {
    ba(r, e.appContext.app, e.uid, e, t, i);
  };
}
function bQ(r, e, t) {
  ba(
    "component:emit",
    r.appContext.app,
    r,
    e,
    t
  );
}
function OQ(r, e, ...t) {
  if (r.isUnmounted)
    return;
  const i = r.vnode.props || Oe;
  if ({}.NODE_ENV !== "production") {
    const {
      emitsOptions: h,
      propsOptions: [c]
    } = r;
    if (h)
      if (!(e in h))
        (!c || !(_i(e) in c)) && $(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${_i(e)}" prop.`
        );
      else {
        const d = h[e];
        re(d) && (d(...t) || $(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let o = t;
  const n = e.startsWith("update:"), s = n && e.slice(7);
  if (s && s in i) {
    const h = `${s === "modelValue" ? "model" : s}Modifiers`, { number: c, trim: d } = i[h] || Oe;
    d && (o = t.map((f) => ne(f) ? f.trim() : f)), c && (o = t.map(zl));
  }
  if ({}.NODE_ENV !== "production" && bQ(r, e, o), {}.NODE_ENV !== "production") {
    const h = e.toLowerCase();
    h !== e && i[_i(h)] && $(
      `Event "${h}" is emitted in component ${ih(
        r,
        r.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Qt(e)}" instead of "${e}".`
    );
  }
  let a, l = i[a = _i(e)] || // also try camelCase event handler (#2249)
  i[a = _i(qe(e))];
  !l && n && (l = i[a = _i(Qt(e))]), l && Gt(
    l,
    r,
    6,
    o
  );
  const u = i[a + "Once"];
  if (u) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[a])
      return;
    r.emitted[a] = !0, Gt(
      u,
      r,
      6,
      o
    );
  }
}
function Ev(r, e, t = !1) {
  const i = e.emitsCache, o = i.get(r);
  if (o !== void 0)
    return o;
  const n = r.emits;
  let s = {}, a = !1;
  if (!re(r)) {
    const l = (u) => {
      const h = Ev(u, e, !0);
      h && (a = !0, ue(s, h));
    };
    !t && e.mixins.length && e.mixins.forEach(l), r.extends && l(r.extends), r.mixins && r.mixins.forEach(l);
  }
  return !n && !a ? (me(r) && i.set(r, null), null) : (U(n) ? n.forEach((l) => s[l] = null) : ue(s, n), me(r) && i.set(r, s), s);
}
function Bu(r, e) {
  return !r || !nr(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), pe(r, e[0].toLowerCase() + e.slice(1)) || pe(r, Qt(e)) || pe(r, e));
}
let Ie = null, qu = null;
function Is(r) {
  const e = Ie;
  return Ie = r, qu = r && r.type.__scopeId || null, e;
}
function Tv(r) {
  qu = r;
}
function $v() {
  qu = null;
}
const vQ = (r) => Us;
function Us(r, e = Ie, t) {
  if (!e || r._n)
    return r;
  const i = (...o) => {
    i._d && Yc(-1);
    const n = Is(e);
    let s;
    try {
      s = r(...o);
    } finally {
      Is(n), i._d && Yc(1);
    }
    return {}.NODE_ENV !== "production" && Pv(e), s;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
let Nc = !1;
function Il() {
  Nc = !0;
}
function Ol(r) {
  const {
    type: e,
    vnode: t,
    proxy: i,
    withProxy: o,
    props: n,
    propsOptions: [s],
    slots: a,
    attrs: l,
    emit: u,
    render: h,
    renderCache: c,
    data: d,
    setupState: f,
    ctx: p,
    inheritAttrs: g
  } = r;
  let b, m;
  const v = Is(r);
  ({}).NODE_ENV !== "production" && (Nc = !1);
  try {
    if (t.shapeFlag & 4) {
      const x = o || i;
      b = Rt(
        h.call(
          x,
          x,
          c,
          n,
          f,
          d,
          p
        )
      ), m = l;
    } else {
      const x = e;
      ({}).NODE_ENV !== "production" && l === n && Il(), b = Rt(
        x.length > 1 ? x(
          n,
          {}.NODE_ENV !== "production" ? {
            get attrs() {
              return Il(), l;
            },
            slots: a,
            emit: u
          } : { attrs: l, slots: a, emit: u }
        ) : x(
          n,
          null
          /* we know it doesn't need it */
        )
      ), m = e.props ? l : yQ(l);
    }
  } catch (x) {
    Es.length = 0, Zo(x, r, 1), b = ke(Ue);
  }
  let S = b, y;
  if ({}.NODE_ENV !== "production" && b.patchFlag > 0 && b.patchFlag & 2048 && ([S, y] = wQ(b)), m && g !== !1) {
    const x = Object.keys(m), { shapeFlag: P } = S;
    if (x.length) {
      if (P & 7)
        s && x.some(Xl) && (m = xQ(
          m,
          s
        )), S = hi(S, m);
      else if ({}.NODE_ENV !== "production" && !Nc && S.type !== Ue) {
        const k = Object.keys(l), C = [], T = [];
        for (let R = 0, M = k.length; R < M; R++) {
          const E = k[R];
          nr(E) ? Xl(E) || C.push(E[2].toLowerCase() + E.slice(3)) : T.push(E);
        }
        T.length && $(
          `Extraneous non-props attributes (${T.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), C.length && $(
          `Extraneous non-emits event listeners (${C.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return t.dirs && ({}.NODE_ENV !== "production" && !yg(S) && $(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), S = hi(S), S.dirs = S.dirs ? S.dirs.concat(t.dirs) : t.dirs), t.transition && ({}.NODE_ENV !== "production" && !yg(S) && $(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), S.transition = t.transition), {}.NODE_ENV !== "production" && y ? y(S) : b = S, Is(v), b;
}
const wQ = (r) => {
  const e = r.children, t = r.dynamicChildren, i = _f(e);
  if (!i)
    return [r, void 0];
  const o = e.indexOf(i), n = t ? t.indexOf(i) : -1, s = (a) => {
    e[o] = a, t && (n > -1 ? t[n] = a : a.patchFlag > 0 && (r.dynamicChildren = [...t, a]));
  };
  return [Rt(i), s];
};
function _f(r) {
  let e;
  for (let t = 0; t < r.length; t++) {
    const i = r[t];
    if (ar(i)) {
      if (i.type !== Ue || i.children === "v-if") {
        if (e)
          return;
        e = i;
      }
    } else
      return;
  }
  return e;
}
const yQ = (r) => {
  let e;
  for (const t in r)
    (t === "class" || t === "style" || nr(t)) && ((e || (e = {}))[t] = r[t]);
  return e;
}, xQ = (r, e) => {
  const t = {};
  for (const i in r)
    (!Xl(i) || !(i.slice(9) in e)) && (t[i] = r[i]);
  return t;
}, yg = (r) => r.shapeFlag & 7 || r.type === Ue;
function SQ(r, e, t) {
  const { props: i, children: o, component: n } = r, { props: s, children: a, patchFlag: l } = e, u = n.emitsOptions;
  if ({}.NODE_ENV !== "production" && (o || a) && Mr || e.dirs || e.transition)
    return !0;
  if (t && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return i ? xg(i, s, u) : !!s;
    if (l & 8) {
      const h = e.dynamicProps;
      for (let c = 0; c < h.length; c++) {
        const d = h[c];
        if (s[d] !== i[d] && !Bu(u, d))
          return !0;
      }
    }
  } else
    return (o || a) && (!a || !a.$stable) ? !0 : i === s ? !1 : i ? s ? xg(i, s, u) : !0 : !!s;
  return !1;
}
function xg(r, e, t) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(r).length)
    return !0;
  for (let o = 0; o < i.length; o++) {
    const n = i[o];
    if (e[n] !== r[n] && !Bu(t, n))
      return !0;
  }
  return !1;
}
function Df({ vnode: r, parent: e }, t) {
  for (; e && e.subTree === r; )
    (r = e.vnode).el = t, e = e.parent;
}
const Rv = (r) => r.__isSuspense, CQ = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(r, e, t, i, o, n, s, a, l, u) {
    r == null ? PQ(
      e,
      t,
      i,
      o,
      n,
      s,
      a,
      l,
      u
    ) : kQ(
      r,
      e,
      t,
      i,
      o,
      s,
      a,
      l,
      u
    );
  },
  hydrate: EQ,
  create: Mf,
  normalize: TQ
}, QQ = CQ;
function Ys(r, e) {
  const t = r.props && r.props[e];
  re(t) && t();
}
function PQ(r, e, t, i, o, n, s, a, l) {
  const {
    p: u,
    o: { createElement: h }
  } = l, c = h("div"), d = r.suspense = Mf(
    r,
    o,
    i,
    e,
    c,
    t,
    n,
    s,
    a,
    l
  );
  u(
    null,
    d.pendingBranch = r.ssContent,
    c,
    null,
    i,
    d,
    n,
    s
  ), d.deps > 0 ? (Ys(r, "onPending"), Ys(r, "onFallback"), u(
    null,
    r.ssFallback,
    e,
    t,
    i,
    null,
    // fallback tree will not have suspense context
    n,
    s
  ), pn(d, r.ssFallback)) : d.resolve(!1, !0);
}
function kQ(r, e, t, i, o, n, s, a, { p: l, um: u, o: { createElement: h } }) {
  const c = e.suspense = r.suspense;
  c.vnode = e, e.el = r.el;
  const d = e.ssContent, f = e.ssFallback, { activeBranch: p, pendingBranch: g, isInFallback: b, isHydrating: m } = c;
  if (g)
    c.pendingBranch = d, mi(d, g) ? (l(
      g,
      d,
      c.hiddenContainer,
      null,
      o,
      c,
      n,
      s,
      a
    ), c.deps <= 0 ? c.resolve() : b && (l(
      p,
      f,
      t,
      i,
      o,
      null,
      // fallback tree will not have suspense context
      n,
      s,
      a
    ), pn(c, f))) : (c.pendingId++, m ? (c.isHydrating = !1, c.activeBranch = g) : u(g, o, c), c.deps = 0, c.effects.length = 0, c.hiddenContainer = h("div"), b ? (l(
      null,
      d,
      c.hiddenContainer,
      null,
      o,
      c,
      n,
      s,
      a
    ), c.deps <= 0 ? c.resolve() : (l(
      p,
      f,
      t,
      i,
      o,
      null,
      // fallback tree will not have suspense context
      n,
      s,
      a
    ), pn(c, f))) : p && mi(d, p) ? (l(
      p,
      d,
      t,
      i,
      o,
      c,
      n,
      s,
      a
    ), c.resolve(!0)) : (l(
      null,
      d,
      c.hiddenContainer,
      null,
      o,
      c,
      n,
      s,
      a
    ), c.deps <= 0 && c.resolve()));
  else if (p && mi(d, p))
    l(
      p,
      d,
      t,
      i,
      o,
      c,
      n,
      s,
      a
    ), pn(c, d);
  else if (Ys(e, "onPending"), c.pendingBranch = d, c.pendingId++, l(
    null,
    d,
    c.hiddenContainer,
    null,
    o,
    c,
    n,
    s,
    a
  ), c.deps <= 0)
    c.resolve();
  else {
    const { timeout: v, pendingId: S } = c;
    v > 0 ? setTimeout(() => {
      c.pendingId === S && c.fallback(f);
    }, v) : v === 0 && c.fallback(f);
  }
}
let Sg = !1;
function Mf(r, e, t, i, o, n, s, a, l, u, h = !1) {
  ({}).NODE_ENV !== "production" && !Sg && (Sg = !0, console[console.info ? "info" : "log"](
    "<Suspense> is an experimental feature and its API will likely change."
  ));
  const {
    p: c,
    m: d,
    um: f,
    n: p,
    o: { parentNode: g, remove: b }
  } = u;
  let m;
  const v = $Q(r);
  v && e != null && e.pendingBranch && (m = e.pendingId, e.deps++);
  const S = r.props ? Nl(r.props.timeout) : void 0;
  ({}).NODE_ENV !== "production" && Pf(S, "Suspense timeout");
  const y = {
    vnode: r,
    parent: e,
    parentComponent: t,
    isSVG: s,
    container: i,
    hiddenContainer: o,
    anchor: n,
    deps: 0,
    pendingId: 0,
    timeout: typeof S == "number" ? S : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !0,
    isHydrating: h,
    isUnmounted: !1,
    effects: [],
    resolve(x = !1, P = !1) {
      if ({}.NODE_ENV !== "production") {
        if (!x && !y.pendingBranch)
          throw new Error(
            "suspense.resolve() is called without a pending branch."
          );
        if (y.isUnmounted)
          throw new Error(
            "suspense.resolve() is called on an already unmounted suspense boundary."
          );
      }
      const {
        vnode: k,
        activeBranch: C,
        pendingBranch: T,
        pendingId: R,
        effects: M,
        parentComponent: E,
        container: Z
      } = y;
      if (y.isHydrating)
        y.isHydrating = !1;
      else if (!x) {
        const ee = C && T.transition && T.transition.mode === "out-in";
        ee && (C.transition.afterLeave = () => {
          R === y.pendingId && d(T, Z, oe, 0);
        });
        let { anchor: oe } = y;
        C && (oe = p(C), f(C, E, y, !0)), ee || d(T, Z, oe, 0);
      }
      pn(y, T), y.pendingBranch = null, y.isInFallback = !1;
      let N = y.parent, G = !1;
      for (; N; ) {
        if (N.pendingBranch) {
          N.effects.push(...M), G = !0;
          break;
        }
        N = N.parent;
      }
      G || Fu(M), y.effects = [], v && e && e.pendingBranch && m === e.pendingId && (e.deps--, e.deps === 0 && !P && e.resolve()), Ys(k, "onResolve");
    },
    fallback(x) {
      if (!y.pendingBranch)
        return;
      const { vnode: P, activeBranch: k, parentComponent: C, container: T, isSVG: R } = y;
      Ys(P, "onFallback");
      const M = p(k), E = () => {
        y.isInFallback && (c(
          null,
          x,
          T,
          M,
          C,
          null,
          // fallback tree will not have suspense context
          R,
          a,
          l
        ), pn(y, x));
      }, Z = x.transition && x.transition.mode === "out-in";
      Z && (k.transition.afterLeave = E), y.isInFallback = !0, f(
        k,
        C,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), Z || E();
    },
    move(x, P, k) {
      y.activeBranch && d(y.activeBranch, x, P, k), y.container = x;
    },
    next() {
      return y.activeBranch && p(y.activeBranch);
    },
    registerDep(x, P) {
      const k = !!y.pendingBranch;
      k && y.deps++;
      const C = x.vnode.el;
      x.asyncDep.catch((T) => {
        Zo(T, x, 0);
      }).then((T) => {
        if (x.isUnmounted || y.isUnmounted || y.pendingId !== x.suspenseId)
          return;
        x.asyncResolved = !0;
        const { vnode: R } = x;
        ({}).NODE_ENV !== "production" && xs(R), qc(x, T, !1), C && (R.el = C);
        const M = !C && x.subTree.el;
        P(
          x,
          R,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          g(C || x.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          C ? null : p(x.subTree),
          y,
          s,
          l
        ), M && b(M), Df(x, R.el), {}.NODE_ENV !== "production" && Ss(), k && --y.deps === 0 && y.resolve();
      });
    },
    unmount(x, P) {
      y.isUnmounted = !0, y.activeBranch && f(
        y.activeBranch,
        t,
        x,
        P
      ), y.pendingBranch && f(
        y.pendingBranch,
        t,
        x,
        P
      );
    }
  };
  return y;
}
function EQ(r, e, t, i, o, n, s, a, l) {
  const u = e.suspense = Mf(
    e,
    i,
    t,
    r.parentNode,
    document.createElement("div"),
    null,
    o,
    n,
    s,
    a,
    !0
    /* hydrating */
  ), h = l(
    r,
    u.pendingBranch = e.ssContent,
    t,
    u,
    n,
    s
  );
  return u.deps === 0 && u.resolve(!1, !0), h;
}
function TQ(r) {
  const { shapeFlag: e, children: t } = r, i = e & 32;
  r.ssContent = Cg(
    i ? t.default : t
  ), r.ssFallback = i ? Cg(t.fallback) : ke(Ue);
}
function Cg(r) {
  let e;
  if (re(r)) {
    const t = To && r._c;
    t && (r._d = !1, et()), r = r(), t && (r._d = !0, e = Dt, hw());
  }
  if (U(r)) {
    const t = _f(r);
    ({}).NODE_ENV !== "production" && !t && $("<Suspense> slots expect a single root node."), r = t;
  }
  return r = Rt(r), e && !r.dynamicChildren && (r.dynamicChildren = e.filter((t) => t !== r)), r;
}
function _v(r, e) {
  e && e.pendingBranch ? U(r) ? e.effects.push(...r) : e.effects.push(r) : Fu(r);
}
function pn(r, e) {
  r.activeBranch = e;
  const { vnode: t, parentComponent: i } = r, o = t.el = e.el;
  i && i.subTree === t && (i.vnode.el = o, Df(i, o));
}
function $Q(r) {
  var e;
  return ((e = r.props) == null ? void 0 : e.suspensible) != null && r.props.suspensible !== !1;
}
function RQ(r, e) {
  return Oa(r, null, e);
}
function Dv(r, e) {
  return Oa(
    r,
    null,
    {}.NODE_ENV !== "production" ? ue({}, e, { flush: "post" }) : { flush: "post" }
  );
}
function _Q(r, e) {
  return Oa(
    r,
    null,
    {}.NODE_ENV !== "production" ? ue({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
const Ia = {};
function yi(r, e, t) {
  return {}.NODE_ENV !== "production" && !re(e) && $(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), Oa(r, e, t);
}
function Oa(r, e, { immediate: t, deep: i, flush: o, onTrack: n, onTrigger: s } = Oe) {
  var a;
  ({}).NODE_ENV !== "production" && !e && (t !== void 0 && $(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), i !== void 0 && $(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const l = (x) => {
    $(
      "Invalid watch source: ",
      x,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, u = nv() === ((a = We) == null ? void 0 : a.scope) ? We : null;
  let h, c = !1, d = !1;
  if (Ne(r) ? (h = () => r.value, c = zs(r)) : Dr(r) ? (h = () => r, i = !0) : U(r) ? (d = !0, c = r.some((x) => Dr(x) || zs(x)), h = () => r.map((x) => {
    if (Ne(x))
      return x.value;
    if (Dr(x))
      return fo(x);
    if (re(x))
      return Wi(x, u, 2);
    ({}).NODE_ENV !== "production" && l(x);
  })) : re(r) ? e ? h = () => Wi(r, u, 2) : h = () => {
    if (!(u && u.isUnmounted))
      return f && f(), Gt(
        r,
        u,
        3,
        [p]
      );
  } : (h = Le, {}.NODE_ENV !== "production" && l(r)), e && i) {
    const x = h;
    h = () => fo(x());
  }
  let f, p = (x) => {
    f = S.onStop = () => {
      Wi(x, u, 4);
    };
  }, g;
  if (Qn)
    if (p = Le, e ? t && Gt(e, u, 3, [
      h(),
      d ? [] : void 0,
      p
    ]) : h(), o === "sync") {
      const x = Pw();
      g = x.__watcherHandles || (x.__watcherHandles = []);
    } else
      return Le;
  let b = d ? new Array(r.length).fill(Ia) : Ia;
  const m = () => {
    if (S.active)
      if (e) {
        const x = S.run();
        (i || c || (d ? x.some(
          (P, k) => Sn(P, b[k])
        ) : Sn(x, b))) && (f && f(), Gt(e, u, 3, [
          x,
          // pass undefined as the old value when it's changed for the first time
          b === Ia ? void 0 : d && b[0] === Ia ? [] : b,
          p
        ]), b = x);
      } else
        S.run();
  };
  m.allowRecurse = !!e;
  let v;
  o === "sync" ? v = m : o === "post" ? v = () => rt(m, u && u.suspense) : (m.pre = !0, u && (m.id = u.uid), v = () => ma(m));
  const S = new ga(h, v);
  ({}).NODE_ENV !== "production" && (S.onTrack = n, S.onTrigger = s), e ? t ? m() : b = S.run() : o === "post" ? rt(
    S.run.bind(S),
    u && u.suspense
  ) : S.run();
  const y = () => {
    S.stop(), u && u.scope && mf(u.scope.effects, S);
  };
  return g && g.push(y), y;
}
function DQ(r, e, t) {
  const i = this.proxy, o = ne(r) ? r.includes(".") ? Mv(i, r) : () => i[r] : r.bind(i, i);
  let n;
  re(e) ? n = e : (n = e.handler, t = e);
  const s = We;
  Br(this);
  const a = Oa(o, n.bind(i), t);
  return s ? Br(s) : Ar(), a;
}
function Mv(r, e) {
  const t = e.split(".");
  return () => {
    let i = r;
    for (let o = 0; o < t.length && i; o++)
      i = i[t[o]];
    return i;
  };
}
function fo(r, e) {
  if (!me(r) || r.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(r)))
    return r;
  if (e.add(r), Ne(r))
    fo(r.value, e);
  else if (U(r))
    for (let t = 0; t < r.length; t++)
      fo(r[t], e);
  else if (zo(r) || vo(r))
    r.forEach((t) => {
      fo(t, e);
    });
  else if (GO(r))
    for (const t in r)
      fo(r[t], e);
  return r;
}
function Xv(r) {
  KO(r) && $("Do not use built-in directive ids as custom directive id: " + r);
}
function MQ(r, e) {
  const t = Ie;
  if (t === null)
    return {}.NODE_ENV !== "production" && $("withDirectives can only be used inside render functions."), r;
  const i = th(t) || t.proxy, o = r.dirs || (r.dirs = []);
  for (let n = 0; n < e.length; n++) {
    let [s, a, l, u = Oe] = e[n];
    s && (re(s) && (s = {
      mounted: s,
      updated: s
    }), s.deep && fo(a), o.push({
      dir: s,
      instance: i,
      value: a,
      oldValue: void 0,
      arg: l,
      modifiers: u
    }));
  }
  return r;
}
function Ri(r, e, t, i) {
  const o = r.dirs, n = e && e.dirs;
  for (let s = 0; s < o.length; s++) {
    const a = o[s];
    n && (a.oldValue = n[s].value);
    let l = a.dir[i];
    l && (No(), Gt(l, t, 8, [
      r.el,
      a,
      r,
      e
    ]), Vo());
  }
}
function Xf() {
  const r = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return io(() => {
    r.isMounted = !0;
  }), Ku(() => {
    r.isUnmounting = !0;
  }), r;
}
const ti = [Function, Array], Af = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: ti,
  onEnter: ti,
  onAfterEnter: ti,
  onEnterCancelled: ti,
  // leave
  onBeforeLeave: ti,
  onLeave: ti,
  onAfterLeave: ti,
  onLeaveCancelled: ti,
  // appear
  onBeforeAppear: ti,
  onAppear: ti,
  onAfterAppear: ti,
  onAppearCancelled: ti
}, XQ = {
  name: "BaseTransition",
  props: Af,
  setup(r, { slots: e }) {
    const t = fr(), i = Xf();
    let o;
    return () => {
      const n = e.default && Hu(e.default(), !0);
      if (!n || !n.length)
        return;
      let s = n[0];
      if (n.length > 1) {
        let g = !1;
        for (const b of n)
          if (b.type !== Ue) {
            if ({}.NODE_ENV !== "production" && g) {
              $(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            if (s = b, g = !0, {}.NODE_ENV === "production")
              break;
          }
      }
      const a = se(r), { mode: l } = a;
      if ({}.NODE_ENV !== "production" && l && l !== "in-out" && l !== "out-in" && l !== "default" && $(`invalid <transition> mode: ${l}`), i.isLeaving)
        return Mh(s);
      const u = Qg(s);
      if (!u)
        return Mh(s);
      const h = Cn(
        u,
        a,
        i,
        t
      );
      Eo(u, h);
      const c = t.subTree, d = c && Qg(c);
      let f = !1;
      const { getTransitionKey: p } = u.type;
      if (p) {
        const g = p();
        o === void 0 ? o = g : g !== o && (o = g, f = !0);
      }
      if (d && d.type !== Ue && (!mi(u, d) || f)) {
        const g = Cn(
          d,
          a,
          i,
          t
        );
        if (Eo(d, g), l === "out-in")
          return i.isLeaving = !0, g.afterLeave = () => {
            i.isLeaving = !1, t.update.active !== !1 && t.update();
          }, Mh(s);
        l === "in-out" && u.type !== Ue && (g.delayLeave = (b, m, v) => {
          const S = zv(
            i,
            d
          );
          S[String(d.key)] = d, b._leaveCb = () => {
            m(), b._leaveCb = void 0, delete h.delayedLeave;
          }, h.delayedLeave = v;
        });
      }
      return s;
    };
  }
}, Av = XQ;
function zv(r, e) {
  const { leavingVNodes: t } = r;
  let i = t.get(e.type);
  return i || (i = /* @__PURE__ */ Object.create(null), t.set(e.type, i)), i;
}
function Cn(r, e, t, i) {
  const {
    appear: o,
    mode: n,
    persisted: s = !1,
    onBeforeEnter: a,
    onEnter: l,
    onAfterEnter: u,
    onEnterCancelled: h,
    onBeforeLeave: c,
    onLeave: d,
    onAfterLeave: f,
    onLeaveCancelled: p,
    onBeforeAppear: g,
    onAppear: b,
    onAfterAppear: m,
    onAppearCancelled: v
  } = e, S = String(r.key), y = zv(t, r), x = (C, T) => {
    C && Gt(
      C,
      i,
      9,
      T
    );
  }, P = (C, T) => {
    const R = T[1];
    x(C, T), U(C) ? C.every((M) => M.length <= 1) && R() : C.length <= 1 && R();
  }, k = {
    mode: n,
    persisted: s,
    beforeEnter(C) {
      let T = a;
      if (!t.isMounted)
        if (o)
          T = g || a;
        else
          return;
      C._leaveCb && C._leaveCb(
        !0
        /* cancelled */
      );
      const R = y[S];
      R && mi(r, R) && R.el._leaveCb && R.el._leaveCb(), x(T, [C]);
    },
    enter(C) {
      let T = l, R = u, M = h;
      if (!t.isMounted)
        if (o)
          T = b || l, R = m || u, M = v || h;
        else
          return;
      let E = !1;
      const Z = C._enterCb = (N) => {
        E || (E = !0, N ? x(M, [C]) : x(R, [C]), k.delayedLeave && k.delayedLeave(), C._enterCb = void 0);
      };
      T ? P(T, [C, Z]) : Z();
    },
    leave(C, T) {
      const R = String(r.key);
      if (C._enterCb && C._enterCb(
        !0
        /* cancelled */
      ), t.isUnmounting)
        return T();
      x(c, [C]);
      let M = !1;
      const E = C._leaveCb = (Z) => {
        M || (M = !0, T(), Z ? x(p, [C]) : x(f, [C]), C._leaveCb = void 0, y[R] === r && delete y[R]);
      };
      y[R] = r, d ? P(d, [C, E]) : E();
    },
    clone(C) {
      return Cn(C, e, t, i);
    }
  };
  return k;
}
function Mh(r) {
  if (Fn(r))
    return r = hi(r), r.children = null, r;
}
function Qg(r) {
  return Fn(r) ? r.children ? r.children[0] : void 0 : r;
}
function Eo(r, e) {
  r.shapeFlag & 6 && r.component ? Eo(r.component.subTree, e) : r.shapeFlag & 128 ? (r.ssContent.transition = e.clone(r.ssContent), r.ssFallback.transition = e.clone(r.ssFallback)) : r.transition = e;
}
function Hu(r, e = !1, t) {
  let i = [], o = 0;
  for (let n = 0; n < r.length; n++) {
    let s = r[n];
    const a = t == null ? s.key : String(t) + String(s.key != null ? s.key : n);
    s.type === je ? (s.patchFlag & 128 && o++, i = i.concat(
      Hu(s.children, e, a)
    )) : (e || s.type !== Ue) && i.push(a != null ? hi(s, { key: a }) : s);
  }
  if (o > 1)
    for (let n = 0; n < i.length; n++)
      i[n].patchFlag = -2;
  return i;
}
function to(r, e) {
  return re(r) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => ue({ name: r.name }, e, { setup: r }))()
  ) : r;
}
const So = (r) => !!r.type.__asyncLoader;
function AQ(r) {
  re(r) && (r = { loader: r });
  const {
    loader: e,
    loadingComponent: t,
    errorComponent: i,
    delay: o = 200,
    timeout: n,
    // undefined = never times out
    suspensible: s = !0,
    onError: a
  } = r;
  let l = null, u, h = 0;
  const c = () => (h++, l = null, d()), d = () => {
    let f;
    return l || (f = l = e().catch((p) => {
      if (p = p instanceof Error ? p : new Error(String(p)), a)
        return new Promise((g, b) => {
          a(p, () => g(c()), () => b(p), h + 1);
        });
      throw p;
    }).then((p) => {
      if (f !== l && l)
        return l;
      if ({}.NODE_ENV !== "production" && !p && $(
        "Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."
      ), p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), {}.NODE_ENV !== "production" && p && !me(p) && !re(p))
        throw new Error(`Invalid async component load result: ${p}`);
      return u = p, p;
    }));
  };
  return to({
    name: "AsyncComponentWrapper",
    __asyncLoader: d,
    get __asyncResolved() {
      return u;
    },
    setup() {
      const f = We;
      if (u)
        return () => Xh(u, f);
      const p = (v) => {
        l = null, Zo(
          v,
          f,
          13,
          !i
          /* do not throw in dev if user provided error component */
        );
      };
      if (s && f.suspense || Qn)
        return d().then((v) => () => Xh(v, f)).catch((v) => (p(v), () => i ? ke(i, {
          error: v
        }) : null));
      const g = gt(!1), b = gt(), m = gt(!!o);
      return o && setTimeout(() => {
        m.value = !1;
      }, o), n != null && setTimeout(() => {
        if (!g.value && !b.value) {
          const v = new Error(
            `Async component timed out after ${n}ms.`
          );
          p(v), b.value = v;
        }
      }, n), d().then(() => {
        g.value = !0, f.parent && Fn(f.parent.vnode) && ma(f.parent.update);
      }).catch((v) => {
        p(v), b.value = v;
      }), () => {
        if (g.value && u)
          return Xh(u, f);
        if (b.value && i)
          return ke(i, {
            error: b.value
          });
        if (t && !m.value)
          return ke(t);
      };
    }
  });
}
function Xh(r, e) {
  const { ref: t, props: i, children: o, ce: n } = e.vnode, s = ke(r, i, o);
  return s.ref = t, s.ce = n, delete e.vnode.ce, s;
}
const Fn = (r) => r.type.__isKeepAlive, zQ = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(r, { slots: e }) {
    const t = fr(), i = t.ctx;
    if (!i.renderer)
      return () => {
        const v = e.default && e.default();
        return v && v.length === 1 ? v[0] : v;
      };
    const o = /* @__PURE__ */ new Map(), n = /* @__PURE__ */ new Set();
    let s = null;
    ({}).NODE_ENV !== "production" && (t.__v_cache = o);
    const a = t.suspense, {
      renderer: {
        p: l,
        m: u,
        um: h,
        o: { createElement: c }
      }
    } = i, d = c("div");
    i.activate = (v, S, y, x, P) => {
      const k = v.component;
      u(v, S, y, 0, a), l(
        k.vnode,
        v,
        S,
        y,
        k,
        a,
        x,
        v.slotScopeIds,
        P
      ), rt(() => {
        k.isDeactivated = !1, k.a && Qr(k.a);
        const C = v.props && v.props.onVnodeMounted;
        C && Tt(C, k.parent, v);
      }, a), {}.NODE_ENV !== "production" && zc(k);
    }, i.deactivate = (v) => {
      const S = v.component;
      u(v, d, null, 1, a), rt(() => {
        S.da && Qr(S.da);
        const y = v.props && v.props.onVnodeUnmounted;
        y && Tt(y, S.parent, v), S.isDeactivated = !0;
      }, a), {}.NODE_ENV !== "production" && zc(S);
    };
    function f(v) {
      Ah(v), h(v, t, a, !0);
    }
    function p(v) {
      o.forEach((S, y) => {
        const x = qs(S.type);
        x && (!v || !v(x)) && g(y);
      });
    }
    function g(v) {
      const S = o.get(v);
      !s || !mi(S, s) ? f(S) : s && Ah(s), o.delete(v), n.delete(v);
    }
    yi(
      () => [r.include, r.exclude],
      ([v, S]) => {
        v && p((y) => ps(v, y)), S && p((y) => !ps(S, y));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let b = null;
    const m = () => {
      b != null && o.set(b, zh(t.subTree));
    };
    return io(m), Gu(m), Ku(() => {
      o.forEach((v) => {
        const { subTree: S, suspense: y } = t, x = zh(S);
        if (v.type === x.type && v.key === x.key) {
          Ah(x);
          const P = x.component.da;
          P && rt(P, y);
          return;
        }
        f(v);
      });
    }), () => {
      if (b = null, !e.default)
        return null;
      const v = e.default(), S = v[0];
      if (v.length > 1)
        return {}.NODE_ENV !== "production" && $("KeepAlive should contain exactly one component child."), s = null, v;
      if (!ar(S) || !(S.shapeFlag & 4) && !(S.shapeFlag & 128))
        return s = null, S;
      let y = zh(S);
      const x = y.type, P = qs(
        So(y) ? y.type.__asyncResolved || {} : x
      ), { include: k, exclude: C, max: T } = r;
      if (k && (!P || !ps(k, P)) || C && P && ps(C, P))
        return s = y, S;
      const R = y.key == null ? x : y.key, M = o.get(R);
      return y.el && (y = hi(y), S.shapeFlag & 128 && (S.ssContent = y)), b = R, M ? (y.el = M.el, y.component = M.component, y.transition && Eo(y, y.transition), y.shapeFlag |= 512, n.delete(R), n.add(R)) : (n.add(R), T && n.size > parseInt(T, 10) && g(n.values().next().value)), y.shapeFlag |= 256, s = y, Rv(S.type) ? S : y;
    };
  }
}, NQ = zQ;
function ps(r, e) {
  return U(r) ? r.some((t) => ps(t, e)) : ne(r) ? r.split(",").includes(e) : WS(r) ? r.test(e) : !1;
}
function Nv(r, e) {
  Zv(r, "a", e);
}
function Vv(r, e) {
  Zv(r, "da", e);
}
function Zv(r, e, t = We) {
  const i = r.__wdc || (r.__wdc = () => {
    let o = t;
    for (; o; ) {
      if (o.isDeactivated)
        return;
      o = o.parent;
    }
    return r();
  });
  if (ju(e, i, t), t) {
    let o = t.parent;
    for (; o && o.parent; )
      Fn(o.parent.vnode) && VQ(i, e, t, o), o = o.parent;
  }
}
function VQ(r, e, t, i) {
  const o = ju(
    e,
    r,
    i,
    !0
    /* prepend */
  );
  Ju(() => {
    mf(i[e], o);
  }, t);
}
function Ah(r) {
  r.shapeFlag &= -257, r.shapeFlag &= -513;
}
function zh(r) {
  return r.shapeFlag & 128 ? r.ssContent : r;
}
function ju(r, e, t = We, i = !1) {
  if (t) {
    const o = t[r] || (t[r] = []), n = e.__weh || (e.__weh = (...s) => {
      if (t.isUnmounted)
        return;
      No(), Br(t);
      const a = Gt(e, t, r, s);
      return Ar(), Vo(), a;
    });
    return i ? o.unshift(n) : o.push(n), n;
  } else if ({}.NODE_ENV !== "production") {
    const o = _i(kf[r].replace(/ hook$/, ""));
    $(
      `${o} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const dr = (r) => (e, t = We) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Qn || r === "sp") && ju(r, (...i) => e(...i), t)
), Lv = dr("bm"), io = dr("m"), Wv = dr("bu"), Gu = dr("u"), Ku = dr("bum"), Ju = dr("um"), Iv = dr("sp"), Uv = dr(
  "rtg"
), Yv = dr(
  "rtc"
);
function Fv(r, e = We) {
  ju("ec", r, e);
}
const Ul = "components", ZQ = "directives";
function LQ(r, e) {
  return zf(Ul, r, !0, e) || r;
}
const Bv = Symbol.for("v-ndc");
function WQ(r) {
  return ne(r) ? zf(Ul, r, !1) || r : r || Bv;
}
function IQ(r) {
  return zf(ZQ, r);
}
function zf(r, e, t = !0, i = !1) {
  const o = Ie || We;
  if (o) {
    const n = o.type;
    if (r === Ul) {
      const a = qs(
        n,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (a && (a === e || a === qe(e) || a === Bi(qe(e))))
        return n;
    }
    const s = (
      // local registration
      // check instance[type] first which is resolved for options API
      Pg(o[r] || n[r], e) || // global registration
      Pg(o.appContext[r], e)
    );
    if (!s && i)
      return n;
    if ({}.NODE_ENV !== "production" && t && !s) {
      const a = r === Ul ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      $(`Failed to resolve ${r.slice(0, -1)}: ${e}${a}`);
    }
    return s;
  } else
    ({}).NODE_ENV !== "production" && $(
      `resolve${Bi(r.slice(0, -1))} can only be used in render() or setup().`
    );
}
function Pg(r, e) {
  return r && (r[e] || r[qe(e)] || r[Bi(qe(e))]);
}
function qv(r, e, t, i) {
  let o;
  const n = t && t[i];
  if (U(r) || ne(r)) {
    o = new Array(r.length);
    for (let s = 0, a = r.length; s < a; s++)
      o[s] = e(r[s], s, void 0, n && n[s]);
  } else if (typeof r == "number") {
    ({}).NODE_ENV !== "production" && !Number.isInteger(r) && $(`The v-for range expect an integer value but got ${r}.`), o = new Array(r);
    for (let s = 0; s < r; s++)
      o[s] = e(s + 1, s, void 0, n && n[s]);
  } else if (me(r))
    if (r[Symbol.iterator])
      o = Array.from(
        r,
        (s, a) => e(s, a, void 0, n && n[a])
      );
    else {
      const s = Object.keys(r);
      o = new Array(s.length);
      for (let a = 0, l = s.length; a < l; a++) {
        const u = s[a];
        o[a] = e(r[u], u, a, n && n[a]);
      }
    }
  else
    o = [];
  return t && (t[i] = o), o;
}
function UQ(r, e) {
  for (let t = 0; t < e.length; t++) {
    const i = e[t];
    if (U(i))
      for (let o = 0; o < i.length; o++)
        r[i[o].name] = i[o].fn;
    else
      i && (r[i.name] = i.key ? (...o) => {
        const n = i.fn(...o);
        return n && (n.key = i.key), n;
      } : i.fn);
  }
  return r;
}
function Nf(r, e, t = {}, i, o) {
  if (Ie.isCE || Ie.parent && So(Ie.parent) && Ie.parent.isCE)
    return e !== "default" && (t.name = e), ke("slot", t, i && i());
  let n = r[e];
  ({}).NODE_ENV !== "production" && n && n.length > 1 && ($(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), n = () => []), n && n._c && (n._d = !1), et();
  const s = n && Hv(n(t)), a = Xi(
    je,
    {
      key: t.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      s && s.key || `_${e}`
    },
    s || (i ? i() : []),
    s && r._ === 1 ? 64 : -2
  );
  return !o && a.scopeId && (a.slotScopeIds = [a.scopeId + "-s"]), n && n._c && (n._d = !0), a;
}
function Hv(r) {
  return r.some((e) => ar(e) ? !(e.type === Ue || e.type === je && !Hv(e.children)) : !0) ? r : null;
}
function YQ(r, e) {
  const t = {};
  if ({}.NODE_ENV !== "production" && !me(r))
    return $("v-on with no argument expects an object value."), t;
  for (const i in r)
    t[e && /[A-Z]/.test(i) ? `on:${i}` : _i(i)] = r[i];
  return t;
}
const Vc = (r) => r ? Ow(r) ? th(r) || r.proxy : Vc(r.parent) : null, Co = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ ue(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => ({}).NODE_ENV !== "production" ? sn(r.props) : r.props,
    $attrs: (r) => ({}).NODE_ENV !== "production" ? sn(r.attrs) : r.attrs,
    $slots: (r) => ({}).NODE_ENV !== "production" ? sn(r.slots) : r.slots,
    $refs: (r) => ({}).NODE_ENV !== "production" ? sn(r.refs) : r.refs,
    $parent: (r) => Vc(r.parent),
    $root: (r) => Vc(r.root),
    $emit: (r) => r.emit,
    $options: (r) => Zf(r),
    $forceUpdate: (r) => r.f || (r.f = () => ma(r.update)),
    $nextTick: (r) => r.n || (r.n = Ls.bind(r.proxy)),
    $watch: (r) => DQ.bind(r)
  })
), Vf = (r) => r === "_" || r === "$", Nh = (r, e) => r !== Oe && !r.__isScriptSetup && pe(r, e), Qs = {
  get({ _: r }, e) {
    const { ctx: t, setupState: i, data: o, props: n, accessCache: s, type: a, appContext: l } = r;
    if ({}.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let u;
    if (e[0] !== "$") {
      const f = s[e];
      if (f !== void 0)
        switch (f) {
          case 1:
            return i[e];
          case 2:
            return o[e];
          case 4:
            return t[e];
          case 3:
            return n[e];
        }
      else {
        if (Nh(i, e))
          return s[e] = 1, i[e];
        if (o !== Oe && pe(o, e))
          return s[e] = 2, o[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (u = r.propsOptions[0]) && pe(u, e)
        )
          return s[e] = 3, n[e];
        if (t !== Oe && pe(t, e))
          return s[e] = 4, t[e];
        Zc && (s[e] = 0);
      }
    }
    const h = Co[e];
    let c, d;
    if (h)
      return e === "$attrs" ? (ut(r, "get", e), {}.NODE_ENV !== "production" && Il()) : {}.NODE_ENV !== "production" && e === "$slots" && ut(r, "get", e), h(r);
    if (
      // css module (injected by vue-loader)
      (c = a.__cssModules) && (c = c[e])
    )
      return c;
    if (t !== Oe && pe(t, e))
      return s[e] = 4, t[e];
    if (
      // global properties
      d = l.config.globalProperties, pe(d, e)
    )
      return d[e];
    ({}).NODE_ENV !== "production" && Ie && (!ne(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (o !== Oe && Vf(e[0]) && pe(o, e) ? $(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : r === Ie && $(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: r }, e, t) {
    const { data: i, setupState: o, ctx: n } = r;
    return Nh(o, e) ? (o[e] = t, !0) : {}.NODE_ENV !== "production" && o.__isScriptSetup && pe(o, e) ? ($(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : i !== Oe && pe(i, e) ? (i[e] = t, !0) : pe(r.props, e) ? ({}.NODE_ENV !== "production" && $(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in r ? ({}.NODE_ENV !== "production" && $(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : ({}.NODE_ENV !== "production" && e in r.appContext.config.globalProperties ? Object.defineProperty(n, e, {
      enumerable: !0,
      configurable: !0,
      value: t
    }) : n[e] = t, !0);
  },
  has({
    _: { data: r, setupState: e, accessCache: t, ctx: i, appContext: o, propsOptions: n }
  }, s) {
    let a;
    return !!t[s] || r !== Oe && pe(r, s) || Nh(e, s) || (a = n[0]) && pe(a, s) || pe(i, s) || pe(Co, s) || pe(o.config.globalProperties, s);
  },
  defineProperty(r, e, t) {
    return t.get != null ? r._.accessCache[e] = 0 : pe(t, "value") && this.set(r, e, t.value, null), Reflect.defineProperty(r, e, t);
  }
};
({}).NODE_ENV !== "production" && (Qs.ownKeys = (r) => ($(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(r)));
const FQ = /* @__PURE__ */ ue(
  {},
  Qs,
  {
    get(r, e) {
      if (e !== Symbol.unscopables)
        return Qs.get(r, e, r);
    },
    has(r, e) {
      const t = e[0] !== "_" && !BS(e);
      return {}.NODE_ENV !== "production" && !t && Qs.has(r, e) && $(
        `Property ${JSON.stringify(
          e
        )} should not start with _ which is a reserved prefix for Vue internals.`
      ), t;
    }
  }
);
function BQ(r) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => r
  }), Object.keys(Co).forEach((t) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      get: () => Co[t](r),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: Le
    });
  }), e;
}
function qQ(r) {
  const {
    ctx: e,
    propsOptions: [t]
  } = r;
  t && Object.keys(t).forEach((i) => {
    Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => r.props[i],
      set: Le
    });
  });
}
function HQ(r) {
  const { ctx: e, setupState: t } = r;
  Object.keys(se(t)).forEach((i) => {
    if (!t.__isScriptSetup) {
      if (Vf(i[0])) {
        $(
          `setup() return property ${JSON.stringify(
            i
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, i, {
        enumerable: !0,
        configurable: !0,
        get: () => t[i],
        set: Le
      });
    }
  });
}
const Lo = (r) => $(
  `${r}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function jQ() {
  return {}.NODE_ENV !== "production" && Lo("defineProps"), null;
}
function GQ() {
  return {}.NODE_ENV !== "production" && Lo("defineEmits"), null;
}
function KQ(r) {
  ({}).NODE_ENV !== "production" && Lo("defineExpose");
}
function JQ(r) {
  ({}).NODE_ENV !== "production" && Lo("defineOptions");
}
function eP() {
  return {}.NODE_ENV !== "production" && Lo("defineSlots"), null;
}
function tP() {
  ({}).NODE_ENV !== "production" && Lo("defineModel");
}
function iP(r, e) {
  return {}.NODE_ENV !== "production" && Lo("withDefaults"), null;
}
function rP() {
  return jv().slots;
}
function oP() {
  return jv().attrs;
}
function nP(r, e, t) {
  const i = fr();
  if ({}.NODE_ENV !== "production" && !i)
    return $("useModel() called without active instance."), gt();
  if ({}.NODE_ENV !== "production" && !i.propsOptions[0][e])
    return $(`useModel() called with prop "${e}" which is not declared.`), gt();
  if (t && t.local) {
    const o = gt(r[e]);
    return yi(
      () => r[e],
      (n) => o.value = n
    ), yi(o, (n) => {
      n !== r[e] && i.emit(`update:${e}`, n);
    }), o;
  } else
    return {
      __v_isRef: !0,
      get value() {
        return r[e];
      },
      set value(o) {
        i.emit(`update:${e}`, o);
      }
    };
}
function jv() {
  const r = fr();
  return {}.NODE_ENV !== "production" && !r && $("useContext() called without active instance."), r.setupContext || (r.setupContext = xw(r));
}
function Fs(r) {
  return U(r) ? r.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : r;
}
function sP(r, e) {
  const t = Fs(r);
  for (const i in e) {
    if (i.startsWith("__skip"))
      continue;
    let o = t[i];
    o ? U(o) || re(o) ? o = t[i] = { type: o, default: e[i] } : o.default = e[i] : o === null ? o = t[i] = { default: e[i] } : {}.NODE_ENV !== "production" && $(`props default key "${i}" has no corresponding declaration.`), o && e[`__skip_${i}`] && (o.skipFactory = !0);
  }
  return t;
}
function aP(r, e) {
  return !r || !e ? r || e : U(r) && U(e) ? r.concat(e) : ue({}, Fs(r), Fs(e));
}
function lP(r, e) {
  const t = {};
  for (const i in r)
    e.includes(i) || Object.defineProperty(t, i, {
      enumerable: !0,
      get: () => r[i]
    });
  return t;
}
function uP(r) {
  const e = fr();
  ({}).NODE_ENV !== "production" && !e && $(
    "withAsyncContext called without active current instance. This is likely a bug."
  );
  let t = r();
  return Ar(), Au(t) && (t = t.catch((i) => {
    throw Br(e), i;
  })), [t, () => Br(e)];
}
function hP() {
  const r = /* @__PURE__ */ Object.create(null);
  return (e, t) => {
    r[t] ? $(`${e} property "${t}" is already defined in ${r[t]}.`) : r[t] = e;
  };
}
let Zc = !0;
function cP(r) {
  const e = Zf(r), t = r.proxy, i = r.ctx;
  Zc = !1, e.beforeCreate && kg(e.beforeCreate, r, "bc");
  const {
    // state
    data: o,
    computed: n,
    methods: s,
    watch: a,
    provide: l,
    inject: u,
    // lifecycle
    created: h,
    beforeMount: c,
    mounted: d,
    beforeUpdate: f,
    updated: p,
    activated: g,
    deactivated: b,
    beforeDestroy: m,
    beforeUnmount: v,
    destroyed: S,
    unmounted: y,
    render: x,
    renderTracked: P,
    renderTriggered: k,
    errorCaptured: C,
    serverPrefetch: T,
    // public API
    expose: R,
    inheritAttrs: M,
    // assets
    components: E,
    directives: Z,
    filters: N
  } = e, G = {}.NODE_ENV !== "production" ? hP() : null;
  if ({}.NODE_ENV !== "production") {
    const [oe] = r.propsOptions;
    if (oe)
      for (const te in oe)
        G("Props", te);
  }
  if (u && dP(u, i, G), s)
    for (const oe in s) {
      const te = s[oe];
      re(te) ? ({}.NODE_ENV !== "production" ? Object.defineProperty(i, oe, {
        value: te.bind(t),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : i[oe] = te.bind(t), {}.NODE_ENV !== "production" && G("Methods", oe)) : {}.NODE_ENV !== "production" && $(
        `Method "${oe}" has type "${typeof te}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (o) {
    ({}).NODE_ENV !== "production" && !re(o) && $(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const oe = o.call(t, t);
    if ({}.NODE_ENV !== "production" && Au(oe) && $(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !me(oe))
      ({}).NODE_ENV !== "production" && $("data() should return an object.");
    else if (r.data = Wu(oe), {}.NODE_ENV !== "production")
      for (const te in oe)
        G("Data", te), Vf(te[0]) || Object.defineProperty(i, te, {
          configurable: !0,
          enumerable: !0,
          get: () => oe[te],
          set: Le
        });
  }
  if (Zc = !0, n)
    for (const oe in n) {
      const te = n[oe], ce = re(te) ? te.bind(t, t) : re(te.get) ? te.get.bind(t, t) : Le;
      ({}).NODE_ENV !== "production" && ce === Le && $(`Computed property "${oe}" has no getter.`);
      const ye = !re(te) && re(te.set) ? te.set.bind(t) : {}.NODE_ENV !== "production" ? () => {
        $(
          `Write operation failed: computed property "${oe}" is readonly.`
        );
      } : Le, Vt = Cw({
        get: ce,
        set: ye
      });
      Object.defineProperty(i, oe, {
        enumerable: !0,
        configurable: !0,
        get: () => Vt.value,
        set: (Zt) => Vt.value = Zt
      }), {}.NODE_ENV !== "production" && G("Computed", oe);
    }
  if (a)
    for (const oe in a)
      Gv(a[oe], i, t, oe);
  if (l) {
    const oe = re(l) ? l.call(t) : l;
    Reflect.ownKeys(oe).forEach((te) => {
      Jv(te, oe[te]);
    });
  }
  h && kg(h, r, "c");
  function ee(oe, te) {
    U(te) ? te.forEach((ce) => oe(ce.bind(t))) : te && oe(te.bind(t));
  }
  if (ee(Lv, c), ee(io, d), ee(Wv, f), ee(Gu, p), ee(Nv, g), ee(Vv, b), ee(Fv, C), ee(Yv, P), ee(Uv, k), ee(Ku, v), ee(Ju, y), ee(Iv, T), U(R))
    if (R.length) {
      const oe = r.exposed || (r.exposed = {});
      R.forEach((te) => {
        Object.defineProperty(oe, te, {
          get: () => t[te],
          set: (ce) => t[te] = ce
        });
      });
    } else
      r.exposed || (r.exposed = {});
  x && r.render === Le && (r.render = x), M != null && (r.inheritAttrs = M), E && (r.components = E), Z && (r.directives = Z);
}
function dP(r, e, t = Le) {
  U(r) && (r = Lc(r));
  for (const i in r) {
    const o = r[i];
    let n;
    me(o) ? "default" in o ? n = Ps(
      o.from || i,
      o.default,
      !0
      /* treat default function as factory */
    ) : n = Ps(o.from || i) : n = Ps(o), Ne(n) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => n.value,
      set: (s) => n.value = s
    }) : e[i] = n, {}.NODE_ENV !== "production" && t("Inject", i);
  }
}
function kg(r, e, t) {
  Gt(
    U(r) ? r.map((i) => i.bind(e.proxy)) : r.bind(e.proxy),
    e,
    t
  );
}
function Gv(r, e, t, i) {
  const o = i.includes(".") ? Mv(t, i) : () => t[i];
  if (ne(r)) {
    const n = e[r];
    re(n) ? yi(o, n) : {}.NODE_ENV !== "production" && $(`Invalid watch handler specified by key "${r}"`, n);
  } else if (re(r))
    yi(o, r.bind(t));
  else if (me(r))
    if (U(r))
      r.forEach((n) => Gv(n, e, t, i));
    else {
      const n = re(r.handler) ? r.handler.bind(t) : e[r.handler];
      re(n) ? yi(o, n, r) : {}.NODE_ENV !== "production" && $(`Invalid watch handler specified by key "${r.handler}"`, n);
    }
  else
    ({}).NODE_ENV !== "production" && $(`Invalid watch option: "${i}"`, r);
}
function Zf(r) {
  const e = r.type, { mixins: t, extends: i } = e, {
    mixins: o,
    optionsCache: n,
    config: { optionMergeStrategies: s }
  } = r.appContext, a = n.get(e);
  let l;
  return a ? l = a : !o.length && !t && !i ? l = e : (l = {}, o.length && o.forEach(
    (u) => Yl(l, u, s, !0)
  ), Yl(l, e, s)), me(e) && n.set(e, l), l;
}
function Yl(r, e, t, i = !1) {
  const { mixins: o, extends: n } = e;
  n && Yl(r, n, t, !0), o && o.forEach(
    (s) => Yl(r, s, t, !0)
  );
  for (const s in e)
    if (i && s === "expose")
      ({}).NODE_ENV !== "production" && $(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const a = fP[s] || t && t[s];
      r[s] = a ? a(r[s], e[s]) : e[s];
    }
  return r;
}
const fP = {
  data: Eg,
  props: Tg,
  emits: Tg,
  // objects
  methods: gs,
  computed: gs,
  // lifecycle
  beforeCreate: xt,
  created: xt,
  beforeMount: xt,
  mounted: xt,
  beforeUpdate: xt,
  updated: xt,
  beforeDestroy: xt,
  beforeUnmount: xt,
  destroyed: xt,
  unmounted: xt,
  activated: xt,
  deactivated: xt,
  errorCaptured: xt,
  serverPrefetch: xt,
  // assets
  components: gs,
  directives: gs,
  // watch
  watch: gP,
  // provide / inject
  provide: Eg,
  inject: pP
};
function Eg(r, e) {
  return e ? r ? function() {
    return ue(
      re(r) ? r.call(this, this) : r,
      re(e) ? e.call(this, this) : e
    );
  } : e : r;
}
function pP(r, e) {
  return gs(Lc(r), Lc(e));
}
function Lc(r) {
  if (U(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++)
      e[r[t]] = r[t];
    return e;
  }
  return r;
}
function xt(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function gs(r, e) {
  return r ? ue(/* @__PURE__ */ Object.create(null), r, e) : e;
}
function Tg(r, e) {
  return r ? U(r) && U(e) ? [.../* @__PURE__ */ new Set([...r, ...e])] : ue(
    /* @__PURE__ */ Object.create(null),
    Fs(r),
    Fs(e ?? {})
  ) : e;
}
function gP(r, e) {
  if (!r)
    return e;
  if (!e)
    return r;
  const t = ue(/* @__PURE__ */ Object.create(null), r);
  for (const i in e)
    t[i] = xt(r[i], e[i]);
  return t;
}
function Kv() {
  return {
    app: null,
    config: {
      isNativeTag: ys,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let mP = 0;
function bP(r, e) {
  return function(i, o = null) {
    re(i) || (i = ue({}, i)), o != null && !me(o) && ({}.NODE_ENV !== "production" && $("root props passed to app.mount() must be an object."), o = null);
    const n = Kv();
    ({}).NODE_ENV !== "production" && Object.defineProperty(n.config, "unwrapInjectedRef", {
      get() {
        return !0;
      },
      set() {
        $(
          "app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API."
        );
      }
    });
    const s = /* @__PURE__ */ new Set();
    let a = !1;
    const l = n.app = {
      _uid: mP++,
      _component: i,
      _props: o,
      _container: null,
      _context: n,
      _instance: null,
      version: jc,
      get config() {
        return n.config;
      },
      set config(u) {
        ({}).NODE_ENV !== "production" && $(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(u, ...h) {
        return s.has(u) ? {}.NODE_ENV !== "production" && $("Plugin has already been applied to target app.") : u && re(u.install) ? (s.add(u), u.install(l, ...h)) : re(u) ? (s.add(u), u(l, ...h)) : {}.NODE_ENV !== "production" && $(
          'A plugin must either be a function or an object with an "install" function.'
        ), l;
      },
      mixin(u) {
        return n.mixins.includes(u) ? {}.NODE_ENV !== "production" && $(
          "Mixin has already been applied to target app" + (u.name ? `: ${u.name}` : "")
        ) : n.mixins.push(u), l;
      },
      component(u, h) {
        return {}.NODE_ENV !== "production" && Bc(u, n.config), h ? ({}.NODE_ENV !== "production" && n.components[u] && $(`Component "${u}" has already been registered in target app.`), n.components[u] = h, l) : n.components[u];
      },
      directive(u, h) {
        return {}.NODE_ENV !== "production" && Xv(u), h ? ({}.NODE_ENV !== "production" && n.directives[u] && $(`Directive "${u}" has already been registered in target app.`), n.directives[u] = h, l) : n.directives[u];
      },
      mount(u, h, c) {
        if (a)
          ({}).NODE_ENV !== "production" && $(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          ({}).NODE_ENV !== "production" && u.__vue_app__ && $(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const d = ke(
            i,
            o
          );
          return d.appContext = n, {}.NODE_ENV !== "production" && (n.reload = () => {
            r(hi(d), u, c);
          }), h && e ? e(d, u) : r(d, u, c), a = !0, l._container = u, u.__vue_app__ = l, {}.NODE_ENV !== "production" && (l._instance = d.component, cQ(l, jc)), th(d.component) || d.component.proxy;
        }
      },
      unmount() {
        a ? (r(null, l._container), {}.NODE_ENV !== "production" && (l._instance = null, dQ(l)), delete l._container.__vue_app__) : {}.NODE_ENV !== "production" && $("Cannot unmount an app that is not mounted.");
      },
      provide(u, h) {
        return {}.NODE_ENV !== "production" && u in n.provides && $(
          `App already provides property with key "${String(u)}". It will be overwritten with the new value.`
        ), n.provides[u] = h, l;
      },
      runWithContext(u) {
        Bs = l;
        try {
          return u();
        } finally {
          Bs = null;
        }
      }
    };
    return l;
  };
}
let Bs = null;
function Jv(r, e) {
  if (!We)
    ({}).NODE_ENV !== "production" && $("provide() can only be used inside setup().");
  else {
    let t = We.provides;
    const i = We.parent && We.parent.provides;
    i === t && (t = We.provides = Object.create(i)), t[r] = e;
  }
}
function Ps(r, e, t = !1) {
  const i = We || Ie;
  if (i || Bs) {
    const o = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : Bs._context.provides;
    if (o && r in o)
      return o[r];
    if (arguments.length > 1)
      return t && re(e) ? e.call(i && i.proxy) : e;
    ({}).NODE_ENV !== "production" && $(`injection "${String(r)}" not found.`);
  } else
    ({}).NODE_ENV !== "production" && $("inject() can only be used inside setup() or functional components.");
}
function OP() {
  return !!(We || Ie || Bs);
}
function vP(r, e, t, i = !1) {
  const o = {}, n = {};
  Al(n, eh, 1), r.propsDefaults = /* @__PURE__ */ Object.create(null), ew(r, e, o, n);
  for (const s in r.propsOptions[0])
    s in o || (o[s] = void 0);
  ({}).NODE_ENV !== "production" && iw(e || {}, o, r), t ? r.props = i ? o : Ov(o) : r.type.props ? r.props = o : r.props = n, r.attrs = n;
}
function wP(r) {
  for (; r; ) {
    if (r.type.__hmrId)
      return !0;
    r = r.parent;
  }
}
function yP(r, e, t, i) {
  const {
    props: o,
    attrs: n,
    vnode: { patchFlag: s }
  } = r, a = se(o), [l] = r.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !({}.NODE_ENV !== "production" && wP(r)) && (i || s > 0) && !(s & 16)
  ) {
    if (s & 8) {
      const h = r.vnode.dynamicProps;
      for (let c = 0; c < h.length; c++) {
        let d = h[c];
        if (Bu(r.emitsOptions, d))
          continue;
        const f = e[d];
        if (l)
          if (pe(n, d))
            f !== n[d] && (n[d] = f, u = !0);
          else {
            const p = qe(d);
            o[p] = Wc(
              l,
              a,
              p,
              f,
              r,
              !1
              /* isAbsent */
            );
          }
        else
          f !== n[d] && (n[d] = f, u = !0);
      }
    }
  } else {
    ew(r, e, o, n) && (u = !0);
    let h;
    for (const c in a)
      (!e || // for camelCase
      !pe(e, c) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((h = Qt(c)) === c || !pe(e, h))) && (l ? t && // for camelCase
      (t[c] !== void 0 || // for kebab-case
      t[h] !== void 0) && (o[c] = Wc(
        l,
        a,
        c,
        void 0,
        r,
        !0
        /* isAbsent */
      )) : delete o[c]);
    if (n !== a)
      for (const c in n)
        (!e || !pe(e, c)) && (delete n[c], u = !0);
  }
  u && qi(r, "set", "$attrs"), {}.NODE_ENV !== "production" && iw(e || {}, o, r);
}
function ew(r, e, t, i) {
  const [o, n] = r.propsOptions;
  let s = !1, a;
  if (e)
    for (let l in e) {
      if (wo(l))
        continue;
      const u = e[l];
      let h;
      o && pe(o, h = qe(l)) ? !n || !n.includes(h) ? t[h] = u : (a || (a = {}))[h] = u : Bu(r.emitsOptions, l) || (!(l in i) || u !== i[l]) && (i[l] = u, s = !0);
    }
  if (n) {
    const l = se(t), u = a || Oe;
    for (let h = 0; h < n.length; h++) {
      const c = n[h];
      t[c] = Wc(
        o,
        l,
        c,
        u[c],
        r,
        !pe(u, c)
      );
    }
  }
  return s;
}
function Wc(r, e, t, i, o, n) {
  const s = r[t];
  if (s != null) {
    const a = pe(s, "default");
    if (a && i === void 0) {
      const l = s.default;
      if (s.type !== Function && !s.skipFactory && re(l)) {
        const { propsDefaults: u } = o;
        t in u ? i = u[t] : (Br(o), i = u[t] = l.call(
          null,
          e
        ), Ar());
      } else
        i = l;
    }
    s[
      0
      /* shouldCast */
    ] && (n && !a ? i = !1 : s[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === Qt(t)) && (i = !0));
  }
  return i;
}
function tw(r, e, t = !1) {
  const i = e.propsCache, o = i.get(r);
  if (o)
    return o;
  const n = r.props, s = {}, a = [];
  let l = !1;
  if (!re(r)) {
    const h = (c) => {
      l = !0;
      const [d, f] = tw(c, e, !0);
      ue(s, d), f && a.push(...f);
    };
    !t && e.mixins.length && e.mixins.forEach(h), r.extends && h(r.extends), r.mixins && r.mixins.forEach(h);
  }
  if (!n && !l)
    return me(r) && i.set(r, dn), dn;
  if (U(n))
    for (let h = 0; h < n.length; h++) {
      ({}).NODE_ENV !== "production" && !ne(n[h]) && $("props must be strings when using array syntax.", n[h]);
      const c = qe(n[h]);
      $g(c) && (s[c] = Oe);
    }
  else if (n) {
    ({}).NODE_ENV !== "production" && !me(n) && $("invalid props options", n);
    for (const h in n) {
      const c = qe(h);
      if ($g(c)) {
        const d = n[h], f = s[c] = U(d) || re(d) ? { type: d } : ue({}, d);
        if (f) {
          const p = _g(Boolean, f.type), g = _g(String, f.type);
          f[
            0
            /* shouldCast */
          ] = p > -1, f[
            1
            /* shouldCastTrue */
          ] = g < 0 || p < g, (p > -1 || pe(f, "default")) && a.push(c);
        }
      }
    }
  }
  const u = [s, a];
  return me(r) && i.set(r, u), u;
}
function $g(r) {
  return r[0] !== "$" ? !0 : ({}.NODE_ENV !== "production" && $(`Invalid prop name: "${r}" is a reserved property.`), !1);
}
function Ic(r) {
  const e = r && r.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : r === null ? "null" : "";
}
function Rg(r, e) {
  return Ic(r) === Ic(e);
}
function _g(r, e) {
  return U(e) ? e.findIndex((t) => Rg(t, r)) : re(e) && Rg(e, r) ? 0 : -1;
}
function iw(r, e, t) {
  const i = se(e), o = t.propsOptions[0];
  for (const n in o) {
    let s = o[n];
    s != null && xP(
      n,
      i[n],
      s,
      !pe(r, n) && !pe(r, Qt(n))
    );
  }
}
function xP(r, e, t, i) {
  const { type: o, required: n, validator: s, skipCheck: a } = t;
  if (n && i) {
    $('Missing required prop: "' + r + '"');
    return;
  }
  if (!(e == null && !n)) {
    if (o != null && o !== !0 && !a) {
      let l = !1;
      const u = U(o) ? o : [o], h = [];
      for (let c = 0; c < u.length && !l; c++) {
        const { valid: d, expectedType: f } = CP(e, u[c]);
        h.push(f || ""), l = d;
      }
      if (!l) {
        $(QP(r, e, h));
        return;
      }
    }
    s && !s(e) && $('Invalid prop: custom validator check failed for prop "' + r + '".');
  }
}
const SP = /* @__PURE__ */ vt(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function CP(r, e) {
  let t;
  const i = Ic(e);
  if (SP(i)) {
    const o = typeof r;
    t = o === i.toLowerCase(), !t && o === "object" && (t = r instanceof e);
  } else
    i === "Object" ? t = me(r) : i === "Array" ? t = U(r) : i === "null" ? t = r === null : t = r instanceof e;
  return {
    valid: t,
    expectedType: i
  };
}
function QP(r, e, t) {
  let i = `Invalid prop: type check failed for prop "${r}". Expected ${t.map(Bi).join(" | ")}`;
  const o = t[0], n = bf(e), s = Dg(e, o), a = Dg(e, n);
  return t.length === 1 && Mg(o) && !PP(o, n) && (i += ` with value ${s}`), i += `, got ${n} `, Mg(n) && (i += `with value ${a}.`), i;
}
function Dg(r, e) {
  return e === "String" ? `"${r}"` : e === "Number" ? `${Number(r)}` : `${r}`;
}
function Mg(r) {
  return ["string", "number", "boolean"].some((t) => r.toLowerCase() === t);
}
function PP(...r) {
  return r.some((e) => e.toLowerCase() === "boolean");
}
const rw = (r) => r[0] === "_" || r === "$stable", Lf = (r) => U(r) ? r.map(Rt) : [Rt(r)], kP = (r, e, t) => {
  if (e._n)
    return e;
  const i = Us((...o) => ({}.NODE_ENV !== "production" && We && $(
    `Slot "${r}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), Lf(e(...o))), t);
  return i._c = !1, i;
}, ow = (r, e, t) => {
  const i = r._ctx;
  for (const o in r) {
    if (rw(o))
      continue;
    const n = r[o];
    if (re(n))
      e[o] = kP(o, n, i);
    else if (n != null) {
      ({}).NODE_ENV !== "production" && $(
        `Non-function value encountered for slot "${o}". Prefer function slots for better performance.`
      );
      const s = Lf(n);
      e[o] = () => s;
    }
  }
}, nw = (r, e) => {
  ({}).NODE_ENV !== "production" && !Fn(r.vnode) && $(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const t = Lf(e);
  r.slots.default = () => t;
}, EP = (r, e) => {
  if (r.vnode.shapeFlag & 32) {
    const t = e._;
    t ? (r.slots = se(e), Al(e, "_", t)) : ow(
      e,
      r.slots = {}
    );
  } else
    r.slots = {}, e && nw(r, e);
  Al(r.slots, eh, 1);
}, TP = (r, e, t) => {
  const { vnode: i, slots: o } = r;
  let n = !0, s = Oe;
  if (i.shapeFlag & 32) {
    const a = e._;
    a ? {}.NODE_ENV !== "production" && Mr ? (ue(o, e), qi(r, "set", "$slots")) : t && a === 1 ? n = !1 : (ue(o, e), !t && a === 1 && delete o._) : (n = !e.$stable, ow(e, o)), s = e;
  } else
    e && (nw(r, e), s = { default: 1 });
  if (n)
    for (const a in o)
      !rw(a) && !(a in s) && delete o[a];
};
function Fl(r, e, t, i, o = !1) {
  if (U(r)) {
    r.forEach(
      (d, f) => Fl(
        d,
        e && (U(e) ? e[f] : e),
        t,
        i,
        o
      )
    );
    return;
  }
  if (So(i) && !o)
    return;
  const n = i.shapeFlag & 4 ? th(i.component) || i.component.proxy : i.el, s = o ? null : n, { i: a, r: l } = r;
  if ({}.NODE_ENV !== "production" && !a) {
    $(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, h = a.refs === Oe ? a.refs = {} : a.refs, c = a.setupState;
  if (u != null && u !== l && (ne(u) ? (h[u] = null, pe(c, u) && (c[u] = null)) : Ne(u) && (u.value = null)), re(l))
    Wi(l, a, 12, [s, h]);
  else {
    const d = ne(l), f = Ne(l);
    if (d || f) {
      const p = () => {
        if (r.f) {
          const g = d ? pe(c, l) ? c[l] : h[l] : l.value;
          o ? U(g) && mf(g, n) : U(g) ? g.includes(n) || g.push(n) : d ? (h[l] = [n], pe(c, l) && (c[l] = h[l])) : (l.value = [n], r.k && (h[r.k] = l.value));
        } else
          d ? (h[l] = s, pe(c, l) && (c[l] = s)) : f ? (l.value = s, r.k && (h[r.k] = s)) : {}.NODE_ENV !== "production" && $("Invalid template ref type:", l, `(${typeof l})`);
      };
      s ? (p.id = -1, rt(p, t)) : p();
    } else
      ({}).NODE_ENV !== "production" && $("Invalid template ref type:", l, `(${typeof l})`);
  }
}
let br = !1;
const Ua = (r) => /svg/.test(r.namespaceURI) && r.tagName !== "foreignObject", es = (r) => r.nodeType === 8;
function $P(r) {
  const {
    mt: e,
    p: t,
    o: {
      patchProp: i,
      createText: o,
      nextSibling: n,
      parentNode: s,
      remove: a,
      insert: l,
      createComment: u
    }
  } = r, h = (m, v) => {
    if (!v.hasChildNodes()) {
      ({}).NODE_ENV !== "production" && $(
        "Attempting to hydrate existing markup but container is empty. Performing full mount instead."
      ), t(null, m, v), Wl(), v._vnode = m;
      return;
    }
    br = !1, c(v.firstChild, m, null, null, null), Wl(), v._vnode = m, br && console.error("Hydration completed but contains mismatches.");
  }, c = (m, v, S, y, x, P = !1) => {
    const k = es(m) && m.data === "[", C = () => g(
      m,
      v,
      S,
      y,
      x,
      k
    ), { type: T, ref: R, shapeFlag: M, patchFlag: E } = v;
    let Z = m.nodeType;
    v.el = m, E === -2 && (P = !1, v.dynamicChildren = null);
    let N = null;
    switch (T) {
      case Yr:
        Z !== 3 ? v.children === "" ? (l(v.el = o(""), s(m), m), N = m) : N = C() : (m.data !== v.children && (br = !0, {}.NODE_ENV !== "production" && $(
          `Hydration text mismatch:
- Client: ${JSON.stringify(m.data)}
- Server: ${JSON.stringify(v.children)}`
        ), m.data = v.children), N = n(m));
        break;
      case Ue:
        Z !== 8 || k ? N = C() : N = n(m);
        break;
      case Xr:
        if (k && (m = n(m), Z = m.nodeType), Z === 1 || Z === 3) {
          N = m;
          const G = !v.children.length;
          for (let ee = 0; ee < v.staticCount; ee++)
            G && (v.children += N.nodeType === 1 ? N.outerHTML : N.data), ee === v.staticCount - 1 && (v.anchor = N), N = n(N);
          return k ? n(N) : N;
        } else
          C();
        break;
      case je:
        k ? N = p(
          m,
          v,
          S,
          y,
          x,
          P
        ) : N = C();
        break;
      default:
        if (M & 1)
          Z !== 1 || v.type.toLowerCase() !== m.tagName.toLowerCase() ? N = C() : N = d(
            m,
            v,
            S,
            y,
            x,
            P
          );
        else if (M & 6) {
          v.slotScopeIds = x;
          const G = s(m);
          if (e(
            v,
            G,
            null,
            S,
            y,
            Ua(G),
            P
          ), N = k ? b(m) : n(m), N && es(N) && N.data === "teleport end" && (N = n(N)), So(v)) {
            let ee;
            k ? (ee = ke(je), ee.anchor = N ? N.previousSibling : G.lastChild) : ee = m.nodeType === 3 ? Wf("") : ke("div"), ee.el = m, v.component.subTree = ee;
          }
        } else
          M & 64 ? Z !== 8 ? N = C() : N = v.type.hydrate(
            m,
            v,
            S,
            y,
            x,
            P,
            r,
            f
          ) : M & 128 ? N = v.type.hydrate(
            m,
            v,
            S,
            y,
            Ua(s(m)),
            x,
            P,
            r,
            c
          ) : {}.NODE_ENV !== "production" && $("Invalid HostVNode type:", T, `(${typeof T})`);
    }
    return R != null && Fl(R, null, y, v), N;
  }, d = (m, v, S, y, x, P) => {
    P = P || !!v.dynamicChildren;
    const { type: k, props: C, patchFlag: T, shapeFlag: R, dirs: M } = v, E = k === "input" && M || k === "option";
    if ({}.NODE_ENV !== "production" || E || T !== -1) {
      if (M && Ri(v, null, S, "created"), C)
        if (E || !P || T & 48)
          for (const N in C)
            (E && N.endsWith("value") || nr(N) && !wo(N)) && i(
              m,
              N,
              null,
              C[N],
              !1,
              void 0,
              S
            );
        else
          C.onClick && i(
            m,
            "onClick",
            null,
            C.onClick,
            !1,
            void 0,
            S
          );
      let Z;
      if ((Z = C && C.onVnodeBeforeMount) && Tt(Z, S, v), M && Ri(v, null, S, "beforeMount"), ((Z = C && C.onVnodeMounted) || M) && _v(() => {
        Z && Tt(Z, S, v), M && Ri(v, null, S, "mounted");
      }, y), R & 16 && // skip if element has innerHTML / textContent
      !(C && (C.innerHTML || C.textContent))) {
        let N = f(
          m.firstChild,
          v,
          m,
          S,
          y,
          x,
          P
        ), G = !1;
        for (; N; ) {
          br = !0, {}.NODE_ENV !== "production" && !G && ($(
            `Hydration children mismatch in <${v.type}>: server rendered element contains more child nodes than client vdom.`
          ), G = !0);
          const ee = N;
          N = N.nextSibling, a(ee);
        }
      } else
        R & 8 && m.textContent !== v.children && (br = !0, {}.NODE_ENV !== "production" && $(
          `Hydration text content mismatch in <${v.type}>:
- Client: ${m.textContent}
- Server: ${v.children}`
        ), m.textContent = v.children);
    }
    return m.nextSibling;
  }, f = (m, v, S, y, x, P, k) => {
    k = k || !!v.dynamicChildren;
    const C = v.children, T = C.length;
    let R = !1;
    for (let M = 0; M < T; M++) {
      const E = k ? C[M] : C[M] = Rt(C[M]);
      if (m)
        m = c(
          m,
          E,
          y,
          x,
          P,
          k
        );
      else {
        if (E.type === Yr && !E.children)
          continue;
        br = !0, {}.NODE_ENV !== "production" && !R && ($(
          `Hydration children mismatch in <${S.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`
        ), R = !0), t(
          null,
          E,
          S,
          null,
          y,
          x,
          Ua(S),
          P
        );
      }
    }
    return m;
  }, p = (m, v, S, y, x, P) => {
    const { slotScopeIds: k } = v;
    k && (x = x ? x.concat(k) : k);
    const C = s(m), T = f(
      n(m),
      v,
      C,
      S,
      y,
      x,
      P
    );
    return T && es(T) && T.data === "]" ? n(v.anchor = T) : (br = !0, l(v.anchor = u("]"), C, T), T);
  }, g = (m, v, S, y, x, P) => {
    if (br = !0, {}.NODE_ENV !== "production" && $(
      `Hydration node mismatch:
- Client vnode:`,
      v.type,
      `
- Server rendered DOM:`,
      m,
      m.nodeType === 3 ? "(text)" : es(m) && m.data === "[" ? "(start of fragment)" : ""
    ), v.el = null, P) {
      const T = b(m);
      for (; ; ) {
        const R = n(m);
        if (R && R !== T)
          a(R);
        else
          break;
      }
    }
    const k = n(m), C = s(m);
    return a(m), t(
      null,
      v,
      C,
      k,
      S,
      y,
      Ua(C),
      x
    ), k;
  }, b = (m) => {
    let v = 0;
    for (; m; )
      if (m = n(m), m && es(m) && (m.data === "[" && v++, m.data === "]")) {
        if (v === 0)
          return n(m);
        v--;
      }
    return m;
  };
  return [h, c];
}
let ts, Pr;
function Ki(r, e) {
  r.appContext.config.performance && Bl() && Pr.mark(`vue-${e}-${r.uid}`), {}.NODE_ENV !== "production" && gQ(r, e, Bl() ? Pr.now() : Date.now());
}
function Ji(r, e) {
  if (r.appContext.config.performance && Bl()) {
    const t = `vue-${e}-${r.uid}`, i = t + ":end";
    Pr.mark(i), Pr.measure(
      `<${ih(r, r.type)}> ${e}`,
      t,
      i
    ), Pr.clearMarks(t), Pr.clearMarks(i);
  }
  ({}).NODE_ENV !== "production" && mQ(r, e, Bl() ? Pr.now() : Date.now());
}
function Bl() {
  return ts !== void 0 || (typeof window < "u" && window.performance ? (ts = !0, Pr = window.performance) : ts = !1), ts;
}
function RP() {
  const r = [];
  if ({}.NODE_ENV !== "production" && r.length) {
    const e = r.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${r.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const rt = _v;
function sw(r) {
  return lw(r);
}
function aw(r) {
  return lw(r, $P);
}
function lw(r, e) {
  RP();
  const t = Vl();
  t.__VUE__ = !0, {}.NODE_ENV !== "production" && $f(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: i,
    remove: o,
    patchProp: n,
    createElement: s,
    createText: a,
    createComment: l,
    setText: u,
    setElementText: h,
    parentNode: c,
    nextSibling: d,
    setScopeId: f = Le,
    insertStaticContent: p
  } = r, g = (w, Q, _, A = null, X = null, L = null, Y = !1, V = null, W = {}.NODE_ENV !== "production" && Mr ? !1 : !!Q.dynamicChildren) => {
    if (w === Q)
      return;
    w && !mi(w, Q) && (A = za(w), Lt(w, X, L, !0), w = null), Q.patchFlag === -2 && (W = !1, Q.dynamicChildren = null);
    const { type: z, ref: K, shapeFlag: q } = Q;
    switch (z) {
      case Yr:
        b(w, Q, _, A);
        break;
      case Ue:
        m(w, Q, _, A);
        break;
      case Xr:
        w == null ? v(Q, _, A, Y) : {}.NODE_ENV !== "production" && S(w, Q, _, Y);
        break;
      case je:
        Z(
          w,
          Q,
          _,
          A,
          X,
          L,
          Y,
          V,
          W
        );
        break;
      default:
        q & 1 ? P(
          w,
          Q,
          _,
          A,
          X,
          L,
          Y,
          V,
          W
        ) : q & 6 ? N(
          w,
          Q,
          _,
          A,
          X,
          L,
          Y,
          V,
          W
        ) : q & 64 || q & 128 ? z.process(
          w,
          Q,
          _,
          A,
          X,
          L,
          Y,
          V,
          W,
          qo
        ) : {}.NODE_ENV !== "production" && $("Invalid VNode type:", z, `(${typeof z})`);
    }
    K != null && X && Fl(K, w && w.ref, L, Q || w, !Q);
  }, b = (w, Q, _, A) => {
    if (w == null)
      i(
        Q.el = a(Q.children),
        _,
        A
      );
    else {
      const X = Q.el = w.el;
      Q.children !== w.children && u(X, Q.children);
    }
  }, m = (w, Q, _, A) => {
    w == null ? i(
      Q.el = l(Q.children || ""),
      _,
      A
    ) : Q.el = w.el;
  }, v = (w, Q, _, A) => {
    [w.el, w.anchor] = p(
      w.children,
      Q,
      _,
      A,
      w.el,
      w.anchor
    );
  }, S = (w, Q, _, A) => {
    if (Q.children !== w.children) {
      const X = d(w.anchor);
      x(w), [Q.el, Q.anchor] = p(
        Q.children,
        _,
        X,
        A
      );
    } else
      Q.el = w.el, Q.anchor = w.anchor;
  }, y = ({ el: w, anchor: Q }, _, A) => {
    let X;
    for (; w && w !== Q; )
      X = d(w), i(w, _, A), w = X;
    i(Q, _, A);
  }, x = ({ el: w, anchor: Q }) => {
    let _;
    for (; w && w !== Q; )
      _ = d(w), o(w), w = _;
    o(Q);
  }, P = (w, Q, _, A, X, L, Y, V, W) => {
    Y = Y || Q.type === "svg", w == null ? k(
      Q,
      _,
      A,
      X,
      L,
      Y,
      V,
      W
    ) : R(
      w,
      Q,
      X,
      L,
      Y,
      V,
      W
    );
  }, k = (w, Q, _, A, X, L, Y, V) => {
    let W, z;
    const { type: K, props: q, shapeFlag: ie, transition: ae, dirs: ge } = w;
    if (W = w.el = s(
      w.type,
      L,
      q && q.is,
      q
    ), ie & 8 ? h(W, w.children) : ie & 16 && T(
      w.children,
      W,
      null,
      A,
      X,
      L && K !== "foreignObject",
      Y,
      V
    ), ge && Ri(w, null, A, "created"), C(W, w, w.scopeId, Y, A), q) {
      for (const Ce in q)
        Ce !== "value" && !wo(Ce) && n(
          W,
          Ce,
          null,
          q[Ce],
          L,
          w.children,
          A,
          X,
          Gi
        );
      "value" in q && n(W, "value", null, q.value), (z = q.onVnodeBeforeMount) && Tt(z, A, w);
    }
    ({}).NODE_ENV !== "production" && (Object.defineProperty(W, "__vnode", {
      value: w,
      enumerable: !1
    }), Object.defineProperty(W, "__vueParentComponent", {
      value: A,
      enumerable: !1
    })), ge && Ri(w, null, A, "beforeMount");
    const Qe = (!X || X && !X.pendingBranch) && ae && !ae.persisted;
    Qe && ae.beforeEnter(W), i(W, Q, _), ((z = q && q.onVnodeMounted) || Qe || ge) && rt(() => {
      z && Tt(z, A, w), Qe && ae.enter(W), ge && Ri(w, null, A, "mounted");
    }, X);
  }, C = (w, Q, _, A, X) => {
    if (_ && f(w, _), A)
      for (let L = 0; L < A.length; L++)
        f(w, A[L]);
    if (X) {
      let L = X.subTree;
      if ({}.NODE_ENV !== "production" && L.patchFlag > 0 && L.patchFlag & 2048 && (L = _f(L.children) || L), Q === L) {
        const Y = X.vnode;
        C(
          w,
          Y,
          Y.scopeId,
          Y.slotScopeIds,
          X.parent
        );
      }
    }
  }, T = (w, Q, _, A, X, L, Y, V, W = 0) => {
    for (let z = W; z < w.length; z++) {
      const K = w[z] = V ? xr(w[z]) : Rt(w[z]);
      g(
        null,
        K,
        Q,
        _,
        A,
        X,
        L,
        Y,
        V
      );
    }
  }, R = (w, Q, _, A, X, L, Y) => {
    const V = Q.el = w.el;
    let { patchFlag: W, dynamicChildren: z, dirs: K } = Q;
    W |= w.patchFlag & 16;
    const q = w.props || Oe, ie = Q.props || Oe;
    let ae;
    _ && no(_, !1), (ae = ie.onVnodeBeforeUpdate) && Tt(ae, _, Q, w), K && Ri(Q, w, _, "beforeUpdate"), _ && no(_, !0), {}.NODE_ENV !== "production" && Mr && (W = 0, Y = !1, z = null);
    const ge = X && Q.type !== "foreignObject";
    if (z ? (M(
      w.dynamicChildren,
      z,
      V,
      _,
      A,
      ge,
      L
    ), {}.NODE_ENV !== "production" && ks(w, Q)) : Y || ce(
      w,
      Q,
      V,
      null,
      _,
      A,
      ge,
      L,
      !1
    ), W > 0) {
      if (W & 16)
        E(
          V,
          Q,
          q,
          ie,
          _,
          A,
          X
        );
      else if (W & 2 && q.class !== ie.class && n(V, "class", null, ie.class, X), W & 4 && n(V, "style", q.style, ie.style, X), W & 8) {
        const Qe = Q.dynamicProps;
        for (let Ce = 0; Ce < Qe.length; Ce++) {
          const Ye = Qe[Ce], di = q[Ye], Ho = ie[Ye];
          (Ho !== di || Ye === "value") && n(
            V,
            Ye,
            di,
            Ho,
            X,
            w.children,
            _,
            A,
            Gi
          );
        }
      }
      W & 1 && w.children !== Q.children && h(V, Q.children);
    } else
      !Y && z == null && E(
        V,
        Q,
        q,
        ie,
        _,
        A,
        X
      );
    ((ae = ie.onVnodeUpdated) || K) && rt(() => {
      ae && Tt(ae, _, Q, w), K && Ri(Q, w, _, "updated");
    }, A);
  }, M = (w, Q, _, A, X, L, Y) => {
    for (let V = 0; V < Q.length; V++) {
      const W = w[V], z = Q[V], K = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        W.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (W.type === je || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !mi(W, z) || // - In the case of a component, it could contain anything.
        W.shapeFlag & 70) ? c(W.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          _
        )
      );
      g(
        W,
        z,
        K,
        null,
        A,
        X,
        L,
        Y,
        !0
      );
    }
  }, E = (w, Q, _, A, X, L, Y) => {
    if (_ !== A) {
      if (_ !== Oe)
        for (const V in _)
          !wo(V) && !(V in A) && n(
            w,
            V,
            _[V],
            null,
            Y,
            Q.children,
            X,
            L,
            Gi
          );
      for (const V in A) {
        if (wo(V))
          continue;
        const W = A[V], z = _[V];
        W !== z && V !== "value" && n(
          w,
          V,
          z,
          W,
          Y,
          Q.children,
          X,
          L,
          Gi
        );
      }
      "value" in A && n(w, "value", _.value, A.value);
    }
  }, Z = (w, Q, _, A, X, L, Y, V, W) => {
    const z = Q.el = w ? w.el : a(""), K = Q.anchor = w ? w.anchor : a("");
    let { patchFlag: q, dynamicChildren: ie, slotScopeIds: ae } = Q;
    ({}).NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (Mr || q & 2048) && (q = 0, W = !1, ie = null), ae && (V = V ? V.concat(ae) : ae), w == null ? (i(z, _, A), i(K, _, A), T(
      Q.children,
      _,
      K,
      X,
      L,
      Y,
      V,
      W
    )) : q > 0 && q & 64 && ie && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    w.dynamicChildren ? (M(
      w.dynamicChildren,
      ie,
      _,
      X,
      L,
      Y,
      V
    ), {}.NODE_ENV !== "production" ? ks(w, Q) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (Q.key != null || X && Q === X.subTree) && ks(
        w,
        Q,
        !0
        /* shallow */
      )
    )) : ce(
      w,
      Q,
      _,
      K,
      X,
      L,
      Y,
      V,
      W
    );
  }, N = (w, Q, _, A, X, L, Y, V, W) => {
    Q.slotScopeIds = V, w == null ? Q.shapeFlag & 512 ? X.ctx.activate(
      Q,
      _,
      A,
      Y,
      W
    ) : G(
      Q,
      _,
      A,
      X,
      L,
      Y,
      W
    ) : ee(w, Q, W);
  }, G = (w, Q, _, A, X, L, Y) => {
    const V = w.component = bw(
      w,
      A,
      X
    );
    if ({}.NODE_ENV !== "production" && V.type.__hmrId && aQ(V), {}.NODE_ENV !== "production" && (xs(w), Ki(V, "mount")), Fn(w) && (V.ctx.renderer = qo), {}.NODE_ENV !== "production" && Ki(V, "init"), vw(V), {}.NODE_ENV !== "production" && Ji(V, "init"), V.asyncDep) {
      if (X && X.registerDep(V, oe), !w.el) {
        const W = V.subTree = ke(Ue);
        m(null, W, Q, _);
      }
      return;
    }
    oe(
      V,
      w,
      Q,
      _,
      X,
      L,
      Y
    ), {}.NODE_ENV !== "production" && (Ss(), Ji(V, "mount"));
  }, ee = (w, Q, _) => {
    const A = Q.component = w.component;
    if (SQ(w, Q, _))
      if (A.asyncDep && !A.asyncResolved) {
        ({}).NODE_ENV !== "production" && xs(Q), te(A, Q, _), {}.NODE_ENV !== "production" && Ss();
        return;
      } else
        A.next = Q, nQ(A.update), A.update();
    else
      Q.el = w.el, A.vnode = Q;
  }, oe = (w, Q, _, A, X, L, Y) => {
    const V = () => {
      if (w.isMounted) {
        let { next: K, bu: q, u: ie, parent: ae, vnode: ge } = w, Qe = K, Ce;
        ({}).NODE_ENV !== "production" && xs(K || w.vnode), no(w, !1), K ? (K.el = ge.el, te(w, K, Y)) : K = ge, q && Qr(q), (Ce = K.props && K.props.onVnodeBeforeUpdate) && Tt(Ce, ae, K, ge), no(w, !0), {}.NODE_ENV !== "production" && Ki(w, "render");
        const Ye = Ol(w);
        ({}).NODE_ENV !== "production" && Ji(w, "render");
        const di = w.subTree;
        w.subTree = Ye, {}.NODE_ENV !== "production" && Ki(w, "patch"), g(
          di,
          Ye,
          // parent may have changed if it's in a teleport
          c(di.el),
          // anchor may have changed if it's in a fragment
          za(di),
          w,
          X,
          L
        ), {}.NODE_ENV !== "production" && Ji(w, "patch"), K.el = Ye.el, Qe === null && Df(w, Ye.el), ie && rt(ie, X), (Ce = K.props && K.props.onVnodeUpdated) && rt(
          () => Tt(Ce, ae, K, ge),
          X
        ), {}.NODE_ENV !== "production" && Pv(w), {}.NODE_ENV !== "production" && Ss();
      } else {
        let K;
        const { el: q, props: ie } = Q, { bm: ae, m: ge, parent: Qe } = w, Ce = So(Q);
        if (no(w, !1), ae && Qr(ae), !Ce && (K = ie && ie.onVnodeBeforeMount) && Tt(K, Qe, Q), no(w, !0), q && _h) {
          const Ye = () => {
            ({}).NODE_ENV !== "production" && Ki(w, "render"), w.subTree = Ol(w), {}.NODE_ENV !== "production" && Ji(w, "render"), {}.NODE_ENV !== "production" && Ki(w, "hydrate"), _h(
              q,
              w.subTree,
              w,
              X,
              null
            ), {}.NODE_ENV !== "production" && Ji(w, "hydrate");
          };
          Ce ? Q.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !w.isUnmounted && Ye()
          ) : Ye();
        } else {
          ({}).NODE_ENV !== "production" && Ki(w, "render");
          const Ye = w.subTree = Ol(w);
          ({}).NODE_ENV !== "production" && Ji(w, "render"), {}.NODE_ENV !== "production" && Ki(w, "patch"), g(
            null,
            Ye,
            _,
            A,
            w,
            X,
            L
          ), {}.NODE_ENV !== "production" && Ji(w, "patch"), Q.el = Ye.el;
        }
        if (ge && rt(ge, X), !Ce && (K = ie && ie.onVnodeMounted)) {
          const Ye = Q;
          rt(
            () => Tt(K, Qe, Ye),
            X
          );
        }
        (Q.shapeFlag & 256 || Qe && So(Qe.vnode) && Qe.vnode.shapeFlag & 256) && w.a && rt(w.a, X), w.isMounted = !0, {}.NODE_ENV !== "production" && zc(w), Q = _ = A = null;
      }
    }, W = w.effect = new ga(
      V,
      () => ma(z),
      w.scope
      // track it in component's effect scope
    ), z = w.update = () => W.run();
    z.id = w.uid, no(w, !0), {}.NODE_ENV !== "production" && (W.onTrack = w.rtc ? (K) => Qr(w.rtc, K) : void 0, W.onTrigger = w.rtg ? (K) => Qr(w.rtg, K) : void 0, z.ownerInstance = w), z();
  }, te = (w, Q, _) => {
    Q.component = w;
    const A = w.vnode.props;
    w.vnode = Q, w.next = null, yP(w, Q.props, A, _), TP(w, Q.children, _), No(), vg(), Vo();
  }, ce = (w, Q, _, A, X, L, Y, V, W = !1) => {
    const z = w && w.children, K = w ? w.shapeFlag : 0, q = Q.children, { patchFlag: ie, shapeFlag: ae } = Q;
    if (ie > 0) {
      if (ie & 128) {
        Vt(
          z,
          q,
          _,
          A,
          X,
          L,
          Y,
          V,
          W
        );
        return;
      } else if (ie & 256) {
        ye(
          z,
          q,
          _,
          A,
          X,
          L,
          Y,
          V,
          W
        );
        return;
      }
    }
    ae & 8 ? (K & 16 && Gi(z, X, L), q !== z && h(_, q)) : K & 16 ? ae & 16 ? Vt(
      z,
      q,
      _,
      A,
      X,
      L,
      Y,
      V,
      W
    ) : Gi(z, X, L, !0) : (K & 8 && h(_, ""), ae & 16 && T(
      q,
      _,
      A,
      X,
      L,
      Y,
      V,
      W
    ));
  }, ye = (w, Q, _, A, X, L, Y, V, W) => {
    w = w || dn, Q = Q || dn;
    const z = w.length, K = Q.length, q = Math.min(z, K);
    let ie;
    for (ie = 0; ie < q; ie++) {
      const ae = Q[ie] = W ? xr(Q[ie]) : Rt(Q[ie]);
      g(
        w[ie],
        ae,
        _,
        null,
        X,
        L,
        Y,
        V,
        W
      );
    }
    z > K ? Gi(
      w,
      X,
      L,
      !0,
      !1,
      q
    ) : T(
      Q,
      _,
      A,
      X,
      L,
      Y,
      V,
      W,
      q
    );
  }, Vt = (w, Q, _, A, X, L, Y, V, W) => {
    let z = 0;
    const K = Q.length;
    let q = w.length - 1, ie = K - 1;
    for (; z <= q && z <= ie; ) {
      const ae = w[z], ge = Q[z] = W ? xr(Q[z]) : Rt(Q[z]);
      if (mi(ae, ge))
        g(
          ae,
          ge,
          _,
          null,
          X,
          L,
          Y,
          V,
          W
        );
      else
        break;
      z++;
    }
    for (; z <= q && z <= ie; ) {
      const ae = w[q], ge = Q[ie] = W ? xr(Q[ie]) : Rt(Q[ie]);
      if (mi(ae, ge))
        g(
          ae,
          ge,
          _,
          null,
          X,
          L,
          Y,
          V,
          W
        );
      else
        break;
      q--, ie--;
    }
    if (z > q) {
      if (z <= ie) {
        const ae = ie + 1, ge = ae < K ? Q[ae].el : A;
        for (; z <= ie; )
          g(
            null,
            Q[z] = W ? xr(Q[z]) : Rt(Q[z]),
            _,
            ge,
            X,
            L,
            Y,
            V,
            W
          ), z++;
      }
    } else if (z > ie)
      for (; z <= q; )
        Lt(w[z], X, L, !0), z++;
    else {
      const ae = z, ge = z, Qe = /* @__PURE__ */ new Map();
      for (z = ge; z <= ie; z++) {
        const yt = Q[z] = W ? xr(Q[z]) : Rt(Q[z]);
        yt.key != null && ({}.NODE_ENV !== "production" && Qe.has(yt.key) && $(
          "Duplicate keys found during update:",
          JSON.stringify(yt.key),
          "Make sure keys are unique."
        ), Qe.set(yt.key, z));
      }
      let Ce, Ye = 0;
      const di = ie - ge + 1;
      let Ho = !1, sg = 0;
      const Jn = new Array(di);
      for (z = 0; z < di; z++)
        Jn[z] = 0;
      for (z = ae; z <= q; z++) {
        const yt = w[z];
        if (Ye >= di) {
          Lt(yt, X, L, !0);
          continue;
        }
        let Qi;
        if (yt.key != null)
          Qi = Qe.get(yt.key);
        else
          for (Ce = ge; Ce <= ie; Ce++)
            if (Jn[Ce - ge] === 0 && mi(yt, Q[Ce])) {
              Qi = Ce;
              break;
            }
        Qi === void 0 ? Lt(yt, X, L, !0) : (Jn[Qi - ge] = z + 1, Qi >= sg ? sg = Qi : Ho = !0, g(
          yt,
          Q[Qi],
          _,
          null,
          X,
          L,
          Y,
          V,
          W
        ), Ye++);
      }
      const ag = Ho ? _P(Jn) : dn;
      for (Ce = ag.length - 1, z = di - 1; z >= 0; z--) {
        const yt = ge + z, Qi = Q[yt], lg = yt + 1 < K ? Q[yt + 1].el : A;
        Jn[z] === 0 ? g(
          null,
          Qi,
          _,
          lg,
          X,
          L,
          Y,
          V,
          W
        ) : Ho && (Ce < 0 || z !== ag[Ce] ? Zt(Qi, _, lg, 2) : Ce--);
      }
    }
  }, Zt = (w, Q, _, A, X = null) => {
    const { el: L, type: Y, transition: V, children: W, shapeFlag: z } = w;
    if (z & 6) {
      Zt(w.component.subTree, Q, _, A);
      return;
    }
    if (z & 128) {
      w.suspense.move(Q, _, A);
      return;
    }
    if (z & 64) {
      Y.move(w, Q, _, qo);
      return;
    }
    if (Y === je) {
      i(L, Q, _);
      for (let q = 0; q < W.length; q++)
        Zt(W[q], Q, _, A);
      i(w.anchor, Q, _);
      return;
    }
    if (Y === Xr) {
      y(w, Q, _);
      return;
    }
    if (A !== 2 && z & 1 && V)
      if (A === 0)
        V.beforeEnter(L), i(L, Q, _), rt(() => V.enter(L), X);
      else {
        const { leave: q, delayLeave: ie, afterLeave: ae } = V, ge = () => i(L, Q, _), Qe = () => {
          q(L, () => {
            ge(), ae && ae();
          });
        };
        ie ? ie(L, ge, Qe) : Qe();
      }
    else
      i(L, Q, _);
  }, Lt = (w, Q, _, A = !1, X = !1) => {
    const {
      type: L,
      props: Y,
      ref: V,
      children: W,
      dynamicChildren: z,
      shapeFlag: K,
      patchFlag: q,
      dirs: ie
    } = w;
    if (V != null && Fl(V, null, _, w, !0), K & 256) {
      Q.ctx.deactivate(w);
      return;
    }
    const ae = K & 1 && ie, ge = !So(w);
    let Qe;
    if (ge && (Qe = Y && Y.onVnodeBeforeUnmount) && Tt(Qe, Q, w), K & 6)
      VS(w.component, _, A);
    else {
      if (K & 128) {
        w.suspense.unmount(_, A);
        return;
      }
      ae && Ri(w, null, Q, "beforeUnmount"), K & 64 ? w.type.remove(
        w,
        Q,
        _,
        X,
        qo,
        A
      ) : z && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (L !== je || q > 0 && q & 64) ? Gi(
        z,
        Q,
        _,
        !1,
        !0
      ) : (L === je && q & 384 || !X && K & 16) && Gi(W, Q, _), A && Bo(w);
    }
    (ge && (Qe = Y && Y.onVnodeUnmounted) || ae) && rt(() => {
      Qe && Tt(Qe, Q, w), ae && Ri(w, null, Q, "unmounted");
    }, _);
  }, Bo = (w) => {
    const { type: Q, el: _, anchor: A, transition: X } = w;
    if (Q === je) {
      ({}).NODE_ENV !== "production" && w.patchFlag > 0 && w.patchFlag & 2048 && X && !X.persisted ? w.children.forEach((Y) => {
        Y.type === Ue ? o(Y.el) : Bo(Y);
      }) : NS(_, A);
      return;
    }
    if (Q === Xr) {
      x(w);
      return;
    }
    const L = () => {
      o(_), X && !X.persisted && X.afterLeave && X.afterLeave();
    };
    if (w.shapeFlag & 1 && X && !X.persisted) {
      const { leave: Y, delayLeave: V } = X, W = () => Y(_, L);
      V ? V(w.el, L, W) : W();
    } else
      L();
  }, NS = (w, Q) => {
    let _;
    for (; w !== Q; )
      _ = d(w), o(w), w = _;
    o(Q);
  }, VS = (w, Q, _) => {
    ({}).NODE_ENV !== "production" && w.type.__hmrId && lQ(w);
    const { bum: A, scope: X, update: L, subTree: Y, um: V } = w;
    A && Qr(A), X.stop(), L && (L.active = !1, Lt(Y, w, Q, _)), V && rt(V, Q), rt(() => {
      w.isUnmounted = !0;
    }, Q), Q && Q.pendingBranch && !Q.isUnmounted && w.asyncDep && !w.asyncResolved && w.suspenseId === Q.pendingId && (Q.deps--, Q.deps === 0 && Q.resolve()), {}.NODE_ENV !== "production" && pQ(w);
  }, Gi = (w, Q, _, A = !1, X = !1, L = 0) => {
    for (let Y = L; Y < w.length; Y++)
      Lt(w[Y], Q, _, A, X);
  }, za = (w) => w.shapeFlag & 6 ? za(w.component.subTree) : w.shapeFlag & 128 ? w.suspense.next() : d(w.anchor || w.el), ng = (w, Q, _) => {
    w == null ? Q._vnode && Lt(Q._vnode, null, null, !0) : g(Q._vnode || null, w, Q, null, null, null, _), vg(), Wl(), Q._vnode = w;
  }, qo = {
    p: g,
    um: Lt,
    m: Zt,
    r: Bo,
    mt: G,
    mc: T,
    pc: ce,
    pbc: M,
    n: za,
    o: r
  };
  let Rh, _h;
  return e && ([Rh, _h] = e(
    qo
  )), {
    render: ng,
    hydrate: Rh,
    createApp: bP(ng, Rh)
  };
}
function no({ effect: r, update: e }, t) {
  r.allowRecurse = e.allowRecurse = t;
}
function ks(r, e, t = !1) {
  const i = r.children, o = e.children;
  if (U(i) && U(o))
    for (let n = 0; n < i.length; n++) {
      const s = i[n];
      let a = o[n];
      a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = o[n] = xr(o[n]), a.el = s.el), t || ks(s, a)), a.type === Yr && (a.el = s.el), {}.NODE_ENV !== "production" && a.type === Ue && !a.el && (a.el = s.el);
    }
}
function _P(r) {
  const e = r.slice(), t = [0];
  let i, o, n, s, a;
  const l = r.length;
  for (i = 0; i < l; i++) {
    const u = r[i];
    if (u !== 0) {
      if (o = t[t.length - 1], r[o] < u) {
        e[i] = o, t.push(i);
        continue;
      }
      for (n = 0, s = t.length - 1; n < s; )
        a = n + s >> 1, r[t[a]] < u ? n = a + 1 : s = a;
      u < r[t[n]] && (n > 0 && (e[i] = t[n - 1]), t[n] = i);
    }
  }
  for (n = t.length, s = t[n - 1]; n-- > 0; )
    t[n] = s, s = e[s];
  return t;
}
const DP = (r) => r.__isTeleport, gn = (r) => r && (r.disabled || r.disabled === ""), Xg = (r) => typeof SVGElement < "u" && r instanceof SVGElement, Uc = (r, e) => {
  const t = r && r.to;
  if (ne(t))
    if (e) {
      const i = e(t);
      return i || {}.NODE_ENV !== "production" && $(
        `Failed to locate Teleport target with selector "${t}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), i;
    } else
      return {}.NODE_ENV !== "production" && $(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return {}.NODE_ENV !== "production" && !t && !gn(r) && $(`Invalid Teleport target: ${t}`), t;
}, MP = {
  __isTeleport: !0,
  process(r, e, t, i, o, n, s, a, l, u) {
    const {
      mc: h,
      pc: c,
      pbc: d,
      o: { insert: f, querySelector: p, createText: g, createComment: b }
    } = u, m = gn(e.props);
    let { shapeFlag: v, children: S, dynamicChildren: y } = e;
    if ({}.NODE_ENV !== "production" && Mr && (l = !1, y = null), r == null) {
      const x = e.el = {}.NODE_ENV !== "production" ? b("teleport start") : g(""), P = e.anchor = {}.NODE_ENV !== "production" ? b("teleport end") : g("");
      f(x, t, i), f(P, t, i);
      const k = e.target = Uc(e.props, p), C = e.targetAnchor = g("");
      k ? (f(C, k), s = s || Xg(k)) : {}.NODE_ENV !== "production" && !m && $("Invalid Teleport target on mount:", k, `(${typeof k})`);
      const T = (R, M) => {
        v & 16 && h(
          S,
          R,
          M,
          o,
          n,
          s,
          a,
          l
        );
      };
      m ? T(t, P) : k && T(k, C);
    } else {
      e.el = r.el;
      const x = e.anchor = r.anchor, P = e.target = r.target, k = e.targetAnchor = r.targetAnchor, C = gn(r.props), T = C ? t : P, R = C ? x : k;
      if (s = s || Xg(P), y ? (d(
        r.dynamicChildren,
        y,
        T,
        o,
        n,
        s,
        a
      ), ks(r, e, !0)) : l || c(
        r,
        e,
        T,
        R,
        o,
        n,
        s,
        a,
        !1
      ), m)
        C || Ya(
          e,
          t,
          x,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
        const M = e.target = Uc(
          e.props,
          p
        );
        M ? Ya(
          e,
          M,
          null,
          u,
          0
        ) : {}.NODE_ENV !== "production" && $(
          "Invalid Teleport target on update:",
          P,
          `(${typeof P})`
        );
      } else
        C && Ya(
          e,
          P,
          k,
          u,
          1
        );
    }
    uw(e);
  },
  remove(r, e, t, i, { um: o, o: { remove: n } }, s) {
    const { shapeFlag: a, children: l, anchor: u, targetAnchor: h, target: c, props: d } = r;
    if (c && n(h), (s || !gn(d)) && (n(u), a & 16))
      for (let f = 0; f < l.length; f++) {
        const p = l[f];
        o(
          p,
          e,
          t,
          !0,
          !!p.dynamicChildren
        );
      }
  },
  move: Ya,
  hydrate: XP
};
function Ya(r, e, t, { o: { insert: i }, m: o }, n = 2) {
  n === 0 && i(r.targetAnchor, e, t);
  const { el: s, anchor: a, shapeFlag: l, children: u, props: h } = r, c = n === 2;
  if (c && i(s, e, t), (!c || gn(h)) && l & 16)
    for (let d = 0; d < u.length; d++)
      o(
        u[d],
        e,
        t,
        2
      );
  c && i(a, e, t);
}
function XP(r, e, t, i, o, n, {
  o: { nextSibling: s, parentNode: a, querySelector: l }
}, u) {
  const h = e.target = Uc(
    e.props,
    l
  );
  if (h) {
    const c = h._lpa || h.firstChild;
    if (e.shapeFlag & 16)
      if (gn(e.props))
        e.anchor = u(
          s(r),
          e,
          a(r),
          t,
          i,
          o,
          n
        ), e.targetAnchor = c;
      else {
        e.anchor = s(r);
        let d = c;
        for (; d; )
          if (d = s(d), d && d.nodeType === 8 && d.data === "teleport anchor") {
            e.targetAnchor = d, h._lpa = e.targetAnchor && s(e.targetAnchor);
            break;
          }
        u(
          c,
          e,
          h,
          t,
          i,
          o,
          n
        );
      }
    uw(e);
  }
  return e.anchor && s(e.anchor);
}
const AP = MP;
function uw(r) {
  const e = r.ctx;
  if (e && e.ut) {
    let t = r.children[0].el;
    for (; t !== r.targetAnchor; )
      t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid), t = t.nextSibling;
    e.ut();
  }
}
const je = Symbol.for("v-fgt"), Yr = Symbol.for("v-txt"), Ue = Symbol.for("v-cmt"), Xr = Symbol.for("v-stc"), Es = [];
let Dt = null;
function et(r = !1) {
  Es.push(Dt = r ? null : []);
}
function hw() {
  Es.pop(), Dt = Es[Es.length - 1] || null;
}
let To = 1;
function Yc(r) {
  To += r;
}
function cw(r) {
  return r.dynamicChildren = To > 0 ? Dt || dn : null, hw(), To > 0 && Dt && Dt.push(r), r;
}
function Fr(r, e, t, i, o, n) {
  return cw(
    Bn(
      r,
      e,
      t,
      i,
      o,
      n,
      !0
      /* isBlock */
    )
  );
}
function Xi(r, e, t, i, o) {
  return cw(
    ke(
      r,
      e,
      t,
      i,
      o,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function ar(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function mi(r, e) {
  return {}.NODE_ENV !== "production" && e.shapeFlag & 6 && en.has(e.type) ? (r.shapeFlag &= -257, e.shapeFlag &= -513, !1) : r.type === e.type && r.key === e.key;
}
let Fc;
function zP(r) {
  Fc = r;
}
const NP = (...r) => fw(
  ...Fc ? Fc(r, Ie) : r
), eh = "__vInternal", dw = ({ key: r }) => r ?? null, vl = ({
  ref: r,
  ref_key: e,
  ref_for: t
}) => (typeof r == "number" && (r = "" + r), r != null ? ne(r) || Ne(r) || re(r) ? { i: Ie, r, k: e, f: !!t } : r : null);
function Bn(r, e = null, t = null, i = 0, o = null, n = r === je ? 0 : 1, s = !1, a = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && dw(e),
    ref: e && vl(e),
    scopeId: qu,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: n,
    patchFlag: i,
    dynamicProps: o,
    dynamicChildren: null,
    appContext: null,
    ctx: Ie
  };
  return a ? (If(l, t), n & 128 && r.normalize(l)) : t && (l.shapeFlag |= ne(t) ? 8 : 16), {}.NODE_ENV !== "production" && l.key !== l.key && $("VNode created with invalid key (NaN). VNode type:", l.type), To > 0 && // avoid a block node from tracking itself
  !s && // has current parent block
  Dt && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || n & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && Dt.push(l), l;
}
const ke = {}.NODE_ENV !== "production" ? NP : fw;
function fw(r, e = null, t = null, i = 0, o = null, n = !1) {
  if ((!r || r === Bv) && ({}.NODE_ENV !== "production" && !r && $(`Invalid vnode type when creating vnode: ${r}.`), r = Ue), ar(r)) {
    const a = hi(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return t && If(a, t), To > 0 && !n && Dt && (a.shapeFlag & 6 ? Dt[Dt.indexOf(r)] = a : Dt.push(a)), a.patchFlag |= -2, a;
  }
  if (Sw(r) && (r = r.__vccOpts), e) {
    e = pw(e);
    let { class: a, style: l } = e;
    a && !ne(a) && (e.class = pa(a)), me(l) && (Ns(l) && !U(l) && (l = ue({}, l)), e.style = Yn(l));
  }
  const s = ne(r) ? 1 : Rv(r) ? 128 : DP(r) ? 64 : me(r) ? 4 : re(r) ? 2 : 0;
  return {}.NODE_ENV !== "production" && s & 4 && Ns(r) && (r = se(r), $(
    "Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    r
  )), Bn(
    r,
    e,
    t,
    i,
    o,
    s,
    n,
    !0
  );
}
function pw(r) {
  return r ? Ns(r) || eh in r ? ue({}, r) : r : null;
}
function hi(r, e, t = !1) {
  const { props: i, ref: o, patchFlag: n, children: s } = r, a = e ? mw(i || {}, e) : i;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: a,
    key: a && dw(a),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && o ? U(o) ? o.concat(vl(e)) : [o, vl(e)] : vl(e)
    ) : o,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: {}.NODE_ENV !== "production" && n === -1 && U(s) ? s.map(gw) : s,
    target: r.target,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== je ? n === -1 ? 16 : n | 16 : n,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: r.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && hi(r.ssContent),
    ssFallback: r.ssFallback && hi(r.ssFallback),
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce
  };
}
function gw(r) {
  const e = hi(r);
  return U(r.children) && (e.children = r.children.map(gw)), e;
}
function Wf(r = " ", e = 0) {
  return ke(Yr, null, r, e);
}
function VP(r, e) {
  const t = ke(Xr, null, r);
  return t.staticCount = e, t;
}
function lo(r = "", e = !1) {
  return e ? (et(), Xi(Ue, null, r)) : ke(Ue, null, r);
}
function Rt(r) {
  return r == null || typeof r == "boolean" ? ke(Ue) : U(r) ? ke(
    je,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : typeof r == "object" ? xr(r) : ke(Yr, null, String(r));
}
function xr(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : hi(r);
}
function If(r, e) {
  let t = 0;
  const { shapeFlag: i } = r;
  if (e == null)
    e = null;
  else if (U(e))
    t = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const o = e.default;
      o && (o._c && (o._d = !1), If(r, o()), o._c && (o._d = !0));
      return;
    } else {
      t = 32;
      const o = e._;
      !o && !(eh in e) ? e._ctx = Ie : o === 3 && Ie && (Ie.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else
    re(e) ? (e = { default: e, _ctx: Ie }, t = 32) : (e = String(e), i & 64 ? (t = 16, e = [Wf(e)]) : t = 8);
  r.children = e, r.shapeFlag |= t;
}
function mw(...r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const i = r[t];
    for (const o in i)
      if (o === "class")
        e.class !== i.class && (e.class = pa([e.class, i.class]));
      else if (o === "style")
        e.style = Yn([e.style, i.style]);
      else if (nr(o)) {
        const n = e[o], s = i[o];
        s && n !== s && !(U(n) && n.includes(s)) && (e[o] = n ? [].concat(n, s) : s);
      } else
        o !== "" && (e[o] = i[o]);
  }
  return e;
}
function Tt(r, e, t, i = null) {
  Gt(r, e, 7, [
    t,
    i
  ]);
}
const ZP = Kv();
let LP = 0;
function bw(r, e, t) {
  const i = r.type, o = (e ? e.appContext : r.appContext) || ZP, n = {
    uid: LP++,
    vnode: r,
    type: i,
    parent: e,
    appContext: o,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new vf(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(o.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: tw(i, o),
    emitsOptions: Ev(i, o),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: Oe,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: Oe,
    data: Oe,
    props: Oe,
    attrs: Oe,
    slots: Oe,
    refs: Oe,
    setupState: Oe,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return {}.NODE_ENV !== "production" ? n.ctx = BQ(n) : n.ctx = { _: n }, n.root = e ? e.root : n, n.emit = OQ.bind(null, n), r.ce && r.ce(n), n;
}
let We = null;
const fr = () => We || Ie;
let Uf, jo, Ag = "__VUE_INSTANCE_SETTERS__";
(jo = Vl()[Ag]) || (jo = Vl()[Ag] = []), jo.push((r) => We = r), Uf = (r) => {
  jo.length > 1 ? jo.forEach((e) => e(r)) : jo[0](r);
};
const Br = (r) => {
  Uf(r), r.scope.on();
}, Ar = () => {
  We && We.scope.off(), Uf(null);
}, WP = /* @__PURE__ */ vt("slot,component");
function Bc(r, e) {
  const t = e.isNativeTag || ys;
  (WP(r) || t(r)) && $(
    "Do not use built-in or reserved HTML elements as component id: " + r
  );
}
function Ow(r) {
  return r.vnode.shapeFlag & 4;
}
let Qn = !1;
function vw(r, e = !1) {
  Qn = e;
  const { props: t, children: i } = r.vnode, o = Ow(r);
  vP(r, t, o, e), EP(r, i);
  const n = o ? IP(r, e) : void 0;
  return Qn = !1, n;
}
function IP(r, e) {
  var t;
  const i = r.type;
  if ({}.NODE_ENV !== "production") {
    if (i.name && Bc(i.name, r.appContext.config), i.components) {
      const n = Object.keys(i.components);
      for (let s = 0; s < n.length; s++)
        Bc(n[s], r.appContext.config);
    }
    if (i.directives) {
      const n = Object.keys(i.directives);
      for (let s = 0; s < n.length; s++)
        Xv(n[s]);
    }
    i.compilerOptions && Yf() && $(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = xf(new Proxy(r.ctx, Qs)), {}.NODE_ENV !== "production" && qQ(r);
  const { setup: o } = i;
  if (o) {
    const n = r.setupContext = o.length > 1 ? xw(r) : null;
    Br(r), No();
    const s = Wi(
      o,
      r,
      0,
      [{}.NODE_ENV !== "production" ? sn(r.props) : r.props, n]
    );
    if (Vo(), Ar(), Au(s)) {
      if (s.then(Ar, Ar), e)
        return s.then((a) => {
          qc(r, a, e);
        }).catch((a) => {
          Zo(a, r, 0);
        });
      if (r.asyncDep = s, {}.NODE_ENV !== "production" && !r.suspense) {
        const a = (t = i.name) != null ? t : "Anonymous";
        $(
          `Component <${a}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      qc(r, s, e);
  } else
    yw(r, e);
}
function qc(r, e, t) {
  re(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : me(e) ? ({}.NODE_ENV !== "production" && ar(e) && $(
    "setup() should not return VNodes directly - return a render function instead."
  ), {}.NODE_ENV !== "production" && (r.devtoolsRawSetupState = e), r.setupState = Qf(e), {}.NODE_ENV !== "production" && HQ(r)) : {}.NODE_ENV !== "production" && e !== void 0 && $(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), yw(r, t);
}
let Ts, Hc;
function ww(r) {
  Ts = r, Hc = (e) => {
    e.render._rc && (e.withProxy = new Proxy(e.ctx, FQ));
  };
}
const Yf = () => !Ts;
function yw(r, e, t) {
  const i = r.type;
  if (!r.render) {
    if (!e && Ts && !i.render) {
      const o = i.template || Zf(r).template;
      if (o) {
        ({}).NODE_ENV !== "production" && Ki(r, "compile");
        const { isCustomElement: n, compilerOptions: s } = r.appContext.config, { delimiters: a, compilerOptions: l } = i, u = ue(
          ue(
            {
              isCustomElement: n,
              delimiters: a
            },
            s
          ),
          l
        );
        i.render = Ts(o, u), {}.NODE_ENV !== "production" && Ji(r, "compile");
      }
    }
    r.render = i.render || Le, Hc && Hc(r);
  }
  Br(r), No(), cP(r), Vo(), Ar(), {}.NODE_ENV !== "production" && !i.render && r.render === Le && !e && (!Ts && i.template ? $(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    /* should not happen */
  ) : $("Component is missing template or render function."));
}
function zg(r) {
  return r.attrsProxy || (r.attrsProxy = new Proxy(
    r.attrs,
    {}.NODE_ENV !== "production" ? {
      get(e, t) {
        return Il(), ut(r, "get", "$attrs"), e[t];
      },
      set() {
        return $("setupContext.attrs is readonly."), !1;
      },
      deleteProperty() {
        return $("setupContext.attrs is readonly."), !1;
      }
    } : {
      get(e, t) {
        return ut(r, "get", "$attrs"), e[t];
      }
    }
  ));
}
function UP(r) {
  return r.slotsProxy || (r.slotsProxy = new Proxy(r.slots, {
    get(e, t) {
      return ut(r, "get", "$slots"), e[t];
    }
  }));
}
function xw(r) {
  const e = (t) => {
    if ({}.NODE_ENV !== "production" && (r.exposed && $("expose() should be called only once per setup()."), t != null)) {
      let i = typeof t;
      i === "object" && (U(t) ? i = "array" : Ne(t) && (i = "ref")), i !== "object" && $(
        `expose() should be passed a plain object, received ${i}.`
      );
    }
    r.exposed = t || {};
  };
  return {}.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return zg(r);
    },
    get slots() {
      return UP(r);
    },
    get emit() {
      return (t, ...i) => r.emit(t, ...i);
    },
    expose: e
  }) : {
    get attrs() {
      return zg(r);
    },
    slots: r.slots,
    emit: r.emit,
    expose: e
  };
}
function th(r) {
  if (r.exposed)
    return r.exposeProxy || (r.exposeProxy = new Proxy(Qf(xf(r.exposed)), {
      get(e, t) {
        if (t in e)
          return e[t];
        if (t in Co)
          return Co[t](r);
      },
      has(e, t) {
        return t in e || t in Co;
      }
    }));
}
const YP = /(?:^|[-_])(\w)/g, FP = (r) => r.replace(YP, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function qs(r, e = !0) {
  return re(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function ih(r, e, t = !1) {
  let i = qs(e);
  if (!i && e.__file) {
    const o = e.__file.match(/([^/\\]+)\.\w+$/);
    o && (i = o[1]);
  }
  if (!i && r && r.parent) {
    const o = (n) => {
      for (const s in n)
        if (n[s] === e)
          return s;
    };
    i = o(
      r.components || r.parent.type.components
    ) || o(r.appContext.components);
  }
  return i ? FP(i) : t ? "App" : "Anonymous";
}
function Sw(r) {
  return re(r) && "__vccOpts" in r;
}
const Cw = (r, e) => GC(r, e, Qn);
function ro(r, e, t) {
  const i = arguments.length;
  return i === 2 ? me(e) && !U(e) ? ar(e) ? ke(r, null, [e]) : ke(r, e) : ke(r, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && ar(t) && (t = [t]), ke(r, e, t));
}
const Qw = Symbol.for("v-scx"), Pw = () => {
  {
    const r = Ps(Qw);
    return r || {}.NODE_ENV !== "production" && $(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), r;
  }
};
function Vh(r) {
  return !!(r && r.__v_isShallow);
}
function kw() {
  if ({}.NODE_ENV === "production" || typeof window > "u")
    return;
  const r = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, t = { style: "color:#b62e24" }, i = { style: "color:#9d288c" }, o = {
    header(c) {
      return me(c) ? c.__isVue ? ["div", r, "VueInstance"] : Ne(c) ? [
        "div",
        {},
        ["span", r, h(c)],
        "<",
        a(c.value),
        ">"
      ] : Dr(c) ? [
        "div",
        {},
        ["span", r, Vh(c) ? "ShallowReactive" : "Reactive"],
        "<",
        a(c),
        `>${sr(c) ? " (readonly)" : ""}`
      ] : sr(c) ? [
        "div",
        {},
        ["span", r, Vh(c) ? "ShallowReadonly" : "Readonly"],
        "<",
        a(c),
        ">"
      ] : null : null;
    },
    hasBody(c) {
      return c && c.__isVue;
    },
    body(c) {
      if (c && c.__isVue)
        return [
          "div",
          {},
          ...n(c.$)
        ];
    }
  };
  function n(c) {
    const d = [];
    c.type.props && c.props && d.push(s("props", se(c.props))), c.setupState !== Oe && d.push(s("setup", c.setupState)), c.data !== Oe && d.push(s("data", se(c.data)));
    const f = l(c, "computed");
    f && d.push(s("computed", f));
    const p = l(c, "inject");
    return p && d.push(s("injected", p)), d.push([
      "div",
      {},
      [
        "span",
        {
          style: i.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: c }]
    ]), d;
  }
  function s(c, d) {
    return d = ue({}, d), Object.keys(d).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        c
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(d).map((f) => [
          "div",
          {},
          ["span", i, f + ": "],
          a(d[f], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function a(c, d = !0) {
    return typeof c == "number" ? ["span", e, c] : typeof c == "string" ? ["span", t, JSON.stringify(c)] : typeof c == "boolean" ? ["span", i, c] : me(c) ? ["object", { object: d ? se(c) : c }] : ["span", t, String(c)];
  }
  function l(c, d) {
    const f = c.type;
    if (re(f))
      return;
    const p = {};
    for (const g in c.ctx)
      u(f, g, d) && (p[g] = c.ctx[g]);
    return p;
  }
  function u(c, d, f) {
    const p = c[f];
    if (U(p) && p.includes(d) || me(p) && d in p || c.extends && u(c.extends, d, f) || c.mixins && c.mixins.some((g) => u(g, d, f)))
      return !0;
  }
  function h(c) {
    return Vh(c) ? "ShallowRef" : c.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(o) : window.devtoolsFormatters = [o];
}
function BP(r, e, t, i) {
  const o = t[i];
  if (o && Ew(o, r))
    return o;
  const n = e();
  return n.memo = r.slice(), t[i] = n;
}
function Ew(r, e) {
  const t = r.memo;
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (Sn(t[i], e[i]))
      return !1;
  return To > 0 && Dt && Dt.push(r), !0;
}
const jc = "3.3.4", qP = {
  createComponentInstance: bw,
  setupComponent: vw,
  renderComponentRoot: Ol,
  setCurrentRenderingInstance: Is,
  isVNode: ar,
  normalizeVNode: Rt
}, HP = qP, jP = null, GP = null, KP = "http://www.w3.org/2000/svg", uo = typeof document < "u" ? document : null, Ng = uo && /* @__PURE__ */ uo.createElement("template"), JP = {
  insert: (r, e, t) => {
    e.insertBefore(r, t || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, t, i) => {
    const o = e ? uo.createElementNS(KP, r) : uo.createElement(r, t ? { is: t } : void 0);
    return r === "select" && i && i.multiple != null && o.setAttribute("multiple", i.multiple), o;
  },
  createText: (r) => uo.createTextNode(r),
  createComment: (r) => uo.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => uo.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, t, i, o, n) {
    const s = t ? t.previousSibling : e.lastChild;
    if (o && (o === n || o.nextSibling))
      for (; e.insertBefore(o.cloneNode(!0), t), !(o === n || !(o = o.nextSibling)); )
        ;
    else {
      Ng.innerHTML = i ? `<svg>${r}</svg>` : r;
      const a = Ng.content;
      if (i) {
        const l = a.firstChild;
        for (; l.firstChild; )
          a.appendChild(l.firstChild);
        a.removeChild(l);
      }
      e.insertBefore(a, t);
    }
    return [
      // first
      s ? s.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
};
function ek(r, e, t) {
  const i = r._vtc;
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? r.removeAttribute("class") : t ? r.setAttribute("class", e) : r.className = e;
}
function tk(r, e, t) {
  const i = r.style, o = ne(t);
  if (t && !o) {
    if (e && !ne(e))
      for (const n in e)
        t[n] == null && Gc(i, n, "");
    for (const n in t)
      Gc(i, n, t[n]);
  } else {
    const n = i.display;
    o ? e !== t && (i.cssText = t) : e && r.removeAttribute("style"), "_vod" in r && (i.display = n);
  }
}
const ik = /[^\\];\s*$/, Vg = /\s*!important$/;
function Gc(r, e, t) {
  if (U(t))
    t.forEach((i) => Gc(r, e, i));
  else if (t == null && (t = ""), {}.NODE_ENV !== "production" && ik.test(t) && $(
    `Unexpected semicolon at the end of '${e}' style value: '${t}'`
  ), e.startsWith("--"))
    r.setProperty(e, t);
  else {
    const i = rk(r, e);
    Vg.test(t) ? r.setProperty(
      Qt(i),
      t.replace(Vg, ""),
      "important"
    ) : r[i] = t;
  }
}
const Zg = ["Webkit", "Moz", "ms"], Zh = {};
function rk(r, e) {
  const t = Zh[e];
  if (t)
    return t;
  let i = qe(e);
  if (i !== "filter" && i in r)
    return Zh[e] = i;
  i = Bi(i);
  for (let o = 0; o < Zg.length; o++) {
    const n = Zg[o] + i;
    if (n in r)
      return Zh[e] = n;
  }
  return e;
}
const Lg = "http://www.w3.org/1999/xlink";
function ok(r, e, t, i, o) {
  if (i && e.startsWith("xlink:"))
    t == null ? r.removeAttributeNS(Lg, e.slice(6, e.length)) : r.setAttributeNS(Lg, e, t);
  else {
    const n = oC(e);
    t == null || n && !iv(t) ? r.removeAttribute(e) : r.setAttribute(e, n ? "" : t);
  }
}
function nk(r, e, t, i, o, n, s) {
  if (e === "innerHTML" || e === "textContent") {
    i && s(i, o, n), r[e] = t ?? "";
    return;
  }
  const a = r.tagName;
  if (e === "value" && a !== "PROGRESS" && // custom elements may use _value internally
  !a.includes("-")) {
    r._value = t;
    const u = a === "OPTION" ? r.getAttribute("value") : r.value, h = t ?? "";
    u !== h && (r.value = h), t == null && r.removeAttribute(e);
    return;
  }
  let l = !1;
  if (t === "" || t == null) {
    const u = typeof r[e];
    u === "boolean" ? t = iv(t) : t == null && u === "string" ? (t = "", l = !0) : u === "number" && (t = 0, l = !0);
  }
  try {
    r[e] = t;
  } catch (u) {
    ({}).NODE_ENV !== "production" && !l && $(
      `Failed setting prop "${e}" on <${a.toLowerCase()}>: value ${t} is invalid.`,
      u
    );
  }
  l && r.removeAttribute(e);
}
function ir(r, e, t, i) {
  r.addEventListener(e, t, i);
}
function sk(r, e, t, i) {
  r.removeEventListener(e, t, i);
}
function ak(r, e, t, i, o = null) {
  const n = r._vei || (r._vei = {}), s = n[e];
  if (i && s)
    s.value = i;
  else {
    const [a, l] = lk(e);
    if (i) {
      const u = n[e] = ck(i, o);
      ir(r, a, u, l);
    } else
      s && (sk(r, a, s, l), n[e] = void 0);
  }
}
const Wg = /(?:Once|Passive|Capture)$/;
function lk(r) {
  let e;
  if (Wg.test(r)) {
    e = {};
    let i;
    for (; i = r.match(Wg); )
      r = r.slice(0, r.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : Qt(r.slice(2)), e];
}
let Lh = 0;
const uk = /* @__PURE__ */ Promise.resolve(), hk = () => Lh || (uk.then(() => Lh = 0), Lh = Date.now());
function ck(r, e) {
  const t = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= t.attached)
      return;
    Gt(
      dk(i, t.value),
      e,
      5,
      [i]
    );
  };
  return t.value = r, t.attached = hk(), t;
}
function dk(r, e) {
  if (U(e)) {
    const t = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      t.call(r), r._stopped = !0;
    }, e.map((i) => (o) => !o._stopped && i && i(o));
  } else
    return e;
}
const Ig = /^on[a-z]/, fk = (r, e, t, i, o = !1, n, s, a, l) => {
  e === "class" ? ek(r, i, o) : e === "style" ? tk(r, t, i) : nr(e) ? Xl(e) || ak(r, e, t, i, s) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : pk(r, e, i, o)) ? nk(
    r,
    e,
    i,
    n,
    s,
    a,
    l
  ) : (e === "true-value" ? r._trueValue = i : e === "false-value" && (r._falseValue = i), ok(r, e, i, o));
};
function pk(r, e, t, i) {
  return i ? !!(e === "innerHTML" || e === "textContent" || e in r && Ig.test(e) && re(t)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA" || Ig.test(e) && ne(t) ? !1 : e in r;
}
function Ff(r, e) {
  const t = to(r);
  class i extends rh {
    constructor(n) {
      super(t, n, e);
    }
  }
  return i.def = t, i;
}
const gk = (r) => Ff(r, Uw), mk = typeof HTMLElement < "u" ? HTMLElement : class {
};
class rh extends mk {
  constructor(e, t = {}, i) {
    super(), this._def = e, this._props = t, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && i ? i(this._createVNode(), this.shadowRoot) : ({}.NODE_ENV !== "production" && this.shadowRoot && $(
      "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
    ), this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, Ls(() => {
      this._connected || (ed(null, this.shadowRoot), this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = !0;
    for (let i = 0; i < this.attributes.length; i++)
      this._setAttr(this.attributes[i].name);
    new MutationObserver((i) => {
      for (const o of i)
        this._setAttr(o.attributeName);
    }).observe(this, { attributes: !0 });
    const e = (i, o = !1) => {
      const { props: n, styles: s } = i;
      let a;
      if (n && !U(n))
        for (const l in n) {
          const u = n[l];
          (u === Number || u && u.type === Number) && (l in this._props && (this._props[l] = Nl(this._props[l])), (a || (a = /* @__PURE__ */ Object.create(null)))[qe(l)] = !0);
        }
      this._numberProps = a, o && this._resolveProps(i), this._applyStyles(s), this._update();
    }, t = this._def.__asyncLoader;
    t ? t().then((i) => e(i, !0)) : e(this._def);
  }
  _resolveProps(e) {
    const { props: t } = e, i = U(t) ? t : Object.keys(t || {});
    for (const o of Object.keys(this))
      o[0] !== "_" && i.includes(o) && this._setProp(o, this[o], !0, !1);
    for (const o of i.map(qe))
      Object.defineProperty(this, o, {
        get() {
          return this._getProp(o);
        },
        set(n) {
          this._setProp(o, n);
        }
      });
  }
  _setAttr(e) {
    let t = this.getAttribute(e);
    const i = qe(e);
    this._numberProps && this._numberProps[i] && (t = Nl(t)), this._setProp(i, t, !1);
  }
  /**
   * @internal
   */
  _getProp(e) {
    return this._props[e];
  }
  /**
   * @internal
   */
  _setProp(e, t, i = !0, o = !0) {
    t !== this._props[e] && (this._props[e] = t, o && this._instance && this._update(), i && (t === !0 ? this.setAttribute(Qt(e), "") : typeof t == "string" || typeof t == "number" ? this.setAttribute(Qt(e), t + "") : t || this.removeAttribute(Qt(e))));
  }
  _update() {
    ed(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const e = ke(this._def, ue({}, this._props));
    return this._instance || (e.ce = (t) => {
      this._instance = t, t.isCE = !0, {}.NODE_ENV !== "production" && (t.ceReload = (n) => {
        this._styles && (this._styles.forEach((s) => this.shadowRoot.removeChild(s)), this._styles.length = 0), this._applyStyles(n), this._instance = null, this._update();
      });
      const i = (n, s) => {
        this.dispatchEvent(
          new CustomEvent(n, {
            detail: s
          })
        );
      };
      t.emit = (n, ...s) => {
        i(n, s), Qt(n) !== n && i(Qt(n), s);
      };
      let o = this;
      for (; o = o && (o.parentNode || o.host); )
        if (o instanceof rh) {
          t.parent = o._instance, t.provides = o._instance.provides;
          break;
        }
    }), e;
  }
  _applyStyles(e) {
    e && e.forEach((t) => {
      const i = document.createElement("style");
      i.textContent = t, this.shadowRoot.appendChild(i), {}.NODE_ENV !== "production" && (this._styles || (this._styles = [])).push(i);
    });
  }
}
function bk(r = "$style") {
  {
    const e = fr();
    if (!e)
      return {}.NODE_ENV !== "production" && $("useCssModule must be called inside setup()"), Oe;
    const t = e.type.__cssModules;
    if (!t)
      return {}.NODE_ENV !== "production" && $("Current instance does not have CSS modules injected."), Oe;
    const i = t[r];
    return i || ({}.NODE_ENV !== "production" && $(`Current instance does not have CSS module named "${r}".`), Oe);
  }
}
function Ok(r) {
  const e = fr();
  if (!e) {
    ({}).NODE_ENV !== "production" && $("useCssVars is called without current active component instance.");
    return;
  }
  const t = e.ut = (o = r(e.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${e.uid}"]`)
    ).forEach((n) => Jc(n, o));
  }, i = () => {
    const o = r(e.proxy);
    Kc(e.subTree, o), t(o);
  };
  Dv(i), io(() => {
    const o = new MutationObserver(i);
    o.observe(e.subTree.el.parentNode, { childList: !0 }), Ju(() => o.disconnect());
  });
}
function Kc(r, e) {
  if (r.shapeFlag & 128) {
    const t = r.suspense;
    r = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => {
      Kc(t.activeBranch, e);
    });
  }
  for (; r.component; )
    r = r.component.subTree;
  if (r.shapeFlag & 1 && r.el)
    Jc(r.el, e);
  else if (r.type === je)
    r.children.forEach((t) => Kc(t, e));
  else if (r.type === Xr) {
    let { el: t, anchor: i } = r;
    for (; t && (Jc(t, e), t !== i); )
      t = t.nextSibling;
  }
}
function Jc(r, e) {
  if (r.nodeType === 1) {
    const t = r.style;
    for (const i in e)
      t.setProperty(`--${i}`, e[i]);
  }
}
const Or = "transition", is = "animation", Bf = (r, { slots: e }) => ro(Av, $w(r), e);
Bf.displayName = "Transition";
const Tw = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, vk = Bf.props = /* @__PURE__ */ ue(
  {},
  Af,
  Tw
), so = (r, e = []) => {
  U(r) ? r.forEach((t) => t(...e)) : r && r(...e);
}, Ug = (r) => r ? U(r) ? r.some((e) => e.length > 1) : r.length > 1 : !1;
function $w(r) {
  const e = {};
  for (const E in r)
    E in Tw || (e[E] = r[E]);
  if (r.css === !1)
    return e;
  const {
    name: t = "v",
    type: i,
    duration: o,
    enterFromClass: n = `${t}-enter-from`,
    enterActiveClass: s = `${t}-enter-active`,
    enterToClass: a = `${t}-enter-to`,
    appearFromClass: l = n,
    appearActiveClass: u = s,
    appearToClass: h = a,
    leaveFromClass: c = `${t}-leave-from`,
    leaveActiveClass: d = `${t}-leave-active`,
    leaveToClass: f = `${t}-leave-to`
  } = r, p = wk(o), g = p && p[0], b = p && p[1], {
    onBeforeEnter: m,
    onEnter: v,
    onEnterCancelled: S,
    onLeave: y,
    onLeaveCancelled: x,
    onBeforeAppear: P = m,
    onAppear: k = v,
    onAppearCancelled: C = S
  } = e, T = (E, Z, N) => {
    wr(E, Z ? h : a), wr(E, Z ? u : s), N && N();
  }, R = (E, Z) => {
    E._isLeaving = !1, wr(E, c), wr(E, f), wr(E, d), Z && Z();
  }, M = (E) => (Z, N) => {
    const G = E ? k : v, ee = () => T(Z, E, N);
    so(G, [Z, ee]), Yg(() => {
      wr(Z, E ? l : n), er(Z, E ? h : a), Ug(G) || Fg(Z, i, g, ee);
    });
  };
  return ue(e, {
    onBeforeEnter(E) {
      so(m, [E]), er(E, n), er(E, s);
    },
    onBeforeAppear(E) {
      so(P, [E]), er(E, l), er(E, u);
    },
    onEnter: M(!1),
    onAppear: M(!0),
    onLeave(E, Z) {
      E._isLeaving = !0;
      const N = () => R(E, Z);
      er(E, c), _w(), er(E, d), Yg(() => {
        E._isLeaving && (wr(E, c), er(E, f), Ug(y) || Fg(E, i, b, N));
      }), so(y, [E, N]);
    },
    onEnterCancelled(E) {
      T(E, !1), so(S, [E]);
    },
    onAppearCancelled(E) {
      T(E, !0), so(C, [E]);
    },
    onLeaveCancelled(E) {
      R(E), so(x, [E]);
    }
  });
}
function wk(r) {
  if (r == null)
    return null;
  if (me(r))
    return [Wh(r.enter), Wh(r.leave)];
  {
    const e = Wh(r);
    return [e, e];
  }
}
function Wh(r) {
  const e = Nl(r);
  return {}.NODE_ENV !== "production" && Pf(e, "<transition> explicit duration"), e;
}
function er(r, e) {
  e.split(/\s+/).forEach((t) => t && r.classList.add(t)), (r._vtc || (r._vtc = /* @__PURE__ */ new Set())).add(e);
}
function wr(r, e) {
  e.split(/\s+/).forEach((i) => i && r.classList.remove(i));
  const { _vtc: t } = r;
  t && (t.delete(e), t.size || (r._vtc = void 0));
}
function Yg(r) {
  requestAnimationFrame(() => {
    requestAnimationFrame(r);
  });
}
let yk = 0;
function Fg(r, e, t, i) {
  const o = r._endId = ++yk, n = () => {
    o === r._endId && i();
  };
  if (t)
    return setTimeout(n, t);
  const { type: s, timeout: a, propCount: l } = Rw(r, e);
  if (!s)
    return i();
  const u = s + "end";
  let h = 0;
  const c = () => {
    r.removeEventListener(u, d), n();
  }, d = (f) => {
    f.target === r && ++h >= l && c();
  };
  setTimeout(() => {
    h < l && c();
  }, a + 1), r.addEventListener(u, d);
}
function Rw(r, e) {
  const t = window.getComputedStyle(r), i = (p) => (t[p] || "").split(", "), o = i(`${Or}Delay`), n = i(`${Or}Duration`), s = Bg(o, n), a = i(`${is}Delay`), l = i(`${is}Duration`), u = Bg(a, l);
  let h = null, c = 0, d = 0;
  e === Or ? s > 0 && (h = Or, c = s, d = n.length) : e === is ? u > 0 && (h = is, c = u, d = l.length) : (c = Math.max(s, u), h = c > 0 ? s > u ? Or : is : null, d = h ? h === Or ? n.length : l.length : 0);
  const f = h === Or && /\b(transform|all)(,|$)/.test(
    i(`${Or}Property`).toString()
  );
  return {
    type: h,
    timeout: c,
    propCount: d,
    hasTransform: f
  };
}
function Bg(r, e) {
  for (; r.length < e.length; )
    r = r.concat(r);
  return Math.max(...e.map((t, i) => qg(t) + qg(r[i])));
}
function qg(r) {
  return Number(r.slice(0, -1).replace(",", ".")) * 1e3;
}
function _w() {
  return document.body.offsetHeight;
}
const Dw = /* @__PURE__ */ new WeakMap(), Mw = /* @__PURE__ */ new WeakMap(), Xw = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ ue({}, vk, {
    tag: String,
    moveClass: String
  }),
  setup(r, { slots: e }) {
    const t = fr(), i = Xf();
    let o, n;
    return Gu(() => {
      if (!o.length)
        return;
      const s = r.moveClass || `${r.name || "v"}-move`;
      if (!kk(
        o[0].el,
        t.vnode.el,
        s
      ))
        return;
      o.forEach(Ck), o.forEach(Qk);
      const a = o.filter(Pk);
      _w(), a.forEach((l) => {
        const u = l.el, h = u.style;
        er(u, s), h.transform = h.webkitTransform = h.transitionDuration = "";
        const c = u._moveCb = (d) => {
          d && d.target !== u || (!d || /transform$/.test(d.propertyName)) && (u.removeEventListener("transitionend", c), u._moveCb = null, wr(u, s));
        };
        u.addEventListener("transitionend", c);
      });
    }), () => {
      const s = se(r), a = $w(s);
      let l = s.tag || je;
      o = n, n = e.default ? Hu(e.default()) : [];
      for (let u = 0; u < n.length; u++) {
        const h = n[u];
        h.key != null ? Eo(
          h,
          Cn(h, a, i, t)
        ) : {}.NODE_ENV !== "production" && $("<TransitionGroup> children must be keyed.");
      }
      if (o)
        for (let u = 0; u < o.length; u++) {
          const h = o[u];
          Eo(
            h,
            Cn(h, a, i, t)
          ), Dw.set(h, h.el.getBoundingClientRect());
        }
      return ke(l, null, n);
    };
  }
}, xk = (r) => delete r.mode;
Xw.props;
const Sk = Xw;
function Ck(r) {
  const e = r.el;
  e._moveCb && e._moveCb(), e._enterCb && e._enterCb();
}
function Qk(r) {
  Mw.set(r, r.el.getBoundingClientRect());
}
function Pk(r) {
  const e = Dw.get(r), t = Mw.get(r), i = e.left - t.left, o = e.top - t.top;
  if (i || o) {
    const n = r.el.style;
    return n.transform = n.webkitTransform = `translate(${i}px,${o}px)`, n.transitionDuration = "0s", r;
  }
}
function kk(r, e, t) {
  const i = r.cloneNode();
  r._vtc && r._vtc.forEach((s) => {
    s.split(/\s+/).forEach((a) => a && i.classList.remove(a));
  }), t.split(/\s+/).forEach((s) => s && i.classList.add(s)), i.style.display = "none";
  const o = e.nodeType === 1 ? e : e.parentNode;
  o.appendChild(i);
  const { hasTransform: n } = Rw(i);
  return o.removeChild(i), n;
}
const qr = (r) => {
  const e = r.props["onUpdate:modelValue"] || !1;
  return U(e) ? (t) => Qr(e, t) : e;
};
function Ek(r) {
  r.target.composing = !0;
}
function Hg(r) {
  const e = r.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const ql = {
  created(r, { modifiers: { lazy: e, trim: t, number: i } }, o) {
    r._assign = qr(o);
    const n = i || o.props && o.props.type === "number";
    ir(r, e ? "change" : "input", (s) => {
      if (s.target.composing)
        return;
      let a = r.value;
      t && (a = a.trim()), n && (a = zl(a)), r._assign(a);
    }), t && ir(r, "change", () => {
      r.value = r.value.trim();
    }), e || (ir(r, "compositionstart", Ek), ir(r, "compositionend", Hg), ir(r, "change", Hg));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(r, { value: e }) {
    r.value = e ?? "";
  },
  beforeUpdate(r, { value: e, modifiers: { lazy: t, trim: i, number: o } }, n) {
    if (r._assign = qr(n), r.composing || document.activeElement === r && r.type !== "range" && (t || i && r.value.trim() === e || (o || r.type === "number") && zl(r.value) === e))
      return;
    const s = e ?? "";
    r.value !== s && (r.value = s);
  }
}, qf = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(r, e, t) {
    r._assign = qr(t), ir(r, "change", () => {
      const i = r._modelValue, o = Pn(r), n = r.checked, s = r._assign;
      if (U(i)) {
        const a = Nu(i, o), l = a !== -1;
        if (n && !l)
          s(i.concat(o));
        else if (!n && l) {
          const u = [...i];
          u.splice(a, 1), s(u);
        }
      } else if (zo(i)) {
        const a = new Set(i);
        n ? a.add(o) : a.delete(o), s(a);
      } else
        s(zw(r, n));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: jg,
  beforeUpdate(r, e, t) {
    r._assign = qr(t), jg(r, e, t);
  }
};
function jg(r, { value: e, oldValue: t }, i) {
  r._modelValue = e, U(e) ? r.checked = Nu(e, i.props.value) > -1 : zo(e) ? r.checked = e.has(i.props.value) : e !== t && (r.checked = Ir(e, zw(r, !0)));
}
const Hf = {
  created(r, { value: e }, t) {
    r.checked = Ir(e, t.props.value), r._assign = qr(t), ir(r, "change", () => {
      r._assign(Pn(r));
    });
  },
  beforeUpdate(r, { value: e, oldValue: t }, i) {
    r._assign = qr(i), e !== t && (r.checked = Ir(e, i.props.value));
  }
}, Aw = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(r, { value: e, modifiers: { number: t } }, i) {
    const o = zo(e);
    ir(r, "change", () => {
      const n = Array.prototype.filter.call(r.options, (s) => s.selected).map(
        (s) => t ? zl(Pn(s)) : Pn(s)
      );
      r._assign(
        r.multiple ? o ? new Set(n) : n : n[0]
      );
    }), r._assign = qr(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(r, { value: e }) {
    Gg(r, e);
  },
  beforeUpdate(r, e, t) {
    r._assign = qr(t);
  },
  updated(r, { value: e }) {
    Gg(r, e);
  }
};
function Gg(r, e) {
  const t = r.multiple;
  if (t && !U(e) && !zo(e)) {
    ({}).NODE_ENV !== "production" && $(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, o = r.options.length; i < o; i++) {
    const n = r.options[i], s = Pn(n);
    if (t)
      U(e) ? n.selected = Nu(e, s) > -1 : n.selected = e.has(s);
    else if (Ir(Pn(n), e)) {
      r.selectedIndex !== i && (r.selectedIndex = i);
      return;
    }
  }
  !t && r.selectedIndex !== -1 && (r.selectedIndex = -1);
}
function Pn(r) {
  return "_value" in r ? r._value : r.value;
}
function zw(r, e) {
  const t = e ? "_trueValue" : "_falseValue";
  return t in r ? r[t] : e;
}
const Nw = {
  created(r, e, t) {
    Fa(r, e, t, null, "created");
  },
  mounted(r, e, t) {
    Fa(r, e, t, null, "mounted");
  },
  beforeUpdate(r, e, t, i) {
    Fa(r, e, t, i, "beforeUpdate");
  },
  updated(r, e, t, i) {
    Fa(r, e, t, i, "updated");
  }
};
function Vw(r, e) {
  switch (r) {
    case "SELECT":
      return Aw;
    case "TEXTAREA":
      return ql;
    default:
      switch (e) {
        case "checkbox":
          return qf;
        case "radio":
          return Hf;
        default:
          return ql;
      }
  }
}
function Fa(r, e, t, i, o) {
  const s = Vw(
    r.tagName,
    t.props && t.props.type
  )[o];
  s && s(r, e, t, i);
}
function Tk() {
  ql.getSSRProps = ({ value: r }) => ({ value: r }), Hf.getSSRProps = ({ value: r }, e) => {
    if (e.props && Ir(e.props.value, r))
      return { checked: !0 };
  }, qf.getSSRProps = ({ value: r }, e) => {
    if (U(r)) {
      if (e.props && Nu(r, e.props.value) > -1)
        return { checked: !0 };
    } else if (zo(r)) {
      if (e.props && r.has(e.props.value))
        return { checked: !0 };
    } else if (r)
      return { checked: !0 };
  }, Nw.getSSRProps = (r, e) => {
    if (typeof e.type != "string")
      return;
    const t = Vw(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      e.type.toUpperCase(),
      e.props && e.props.type
    );
    if (t.getSSRProps)
      return t.getSSRProps(r, e);
  };
}
const $k = ["ctrl", "shift", "alt", "meta"], Rk = {
  stop: (r) => r.stopPropagation(),
  prevent: (r) => r.preventDefault(),
  self: (r) => r.target !== r.currentTarget,
  ctrl: (r) => !r.ctrlKey,
  shift: (r) => !r.shiftKey,
  alt: (r) => !r.altKey,
  meta: (r) => !r.metaKey,
  left: (r) => "button" in r && r.button !== 0,
  middle: (r) => "button" in r && r.button !== 1,
  right: (r) => "button" in r && r.button !== 2,
  exact: (r, e) => $k.some((t) => r[`${t}Key`] && !e.includes(t))
}, _k = (r, e) => (t, ...i) => {
  for (let o = 0; o < e.length; o++) {
    const n = Rk[e[o]];
    if (n && n(t, e))
      return;
  }
  return r(t, ...i);
}, Dk = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Mk = (r, e) => (t) => {
  if (!("key" in t))
    return;
  const i = Qt(t.key);
  if (e.some((o) => o === i || Dk[o] === i))
    return r(t);
}, Zw = {
  beforeMount(r, { value: e }, { transition: t }) {
    r._vod = r.style.display === "none" ? "" : r.style.display, t && e ? t.beforeEnter(r) : rs(r, e);
  },
  mounted(r, { value: e }, { transition: t }) {
    t && e && t.enter(r);
  },
  updated(r, { value: e, oldValue: t }, { transition: i }) {
    !e != !t && (i ? e ? (i.beforeEnter(r), rs(r, !0), i.enter(r)) : i.leave(r, () => {
      rs(r, !1);
    }) : rs(r, e));
  },
  beforeUnmount(r, { value: e }) {
    rs(r, e);
  }
};
function rs(r, e) {
  r.style.display = e ? r._vod : "none";
}
function Xk() {
  Zw.getSSRProps = ({ value: r }) => {
    if (!r)
      return { style: { display: "none" } };
  };
}
const Lw = /* @__PURE__ */ ue({ patchProp: fk }, JP);
let $s, Kg = !1;
function Ww() {
  return $s || ($s = sw(Lw));
}
function Iw() {
  return $s = Kg ? $s : aw(Lw), Kg = !0, $s;
}
const ed = (...r) => {
  Ww().render(...r);
}, Uw = (...r) => {
  Iw().hydrate(...r);
}, Ak = (...r) => {
  const e = Ww().createApp(...r);
  ({}).NODE_ENV !== "production" && (Yw(e), Fw(e));
  const { mount: t } = e;
  return e.mount = (i) => {
    const o = Bw(i);
    if (!o)
      return;
    const n = e._component;
    !re(n) && !n.render && !n.template && (n.template = o.innerHTML), o.innerHTML = "";
    const s = t(o, !1, o instanceof SVGElement);
    return o instanceof Element && (o.removeAttribute("v-cloak"), o.setAttribute("data-v-app", "")), s;
  }, e;
}, zk = (...r) => {
  const e = Iw().createApp(...r);
  ({}).NODE_ENV !== "production" && (Yw(e), Fw(e));
  const { mount: t } = e;
  return e.mount = (i) => {
    const o = Bw(i);
    if (o)
      return t(o, !0, o instanceof SVGElement);
  }, e;
};
function Yw(r) {
  Object.defineProperty(r.config, "isNativeTag", {
    value: (e) => ev(e) || tv(e),
    writable: !1
  });
}
function Fw(r) {
  if (Yf()) {
    const e = r.config.isCustomElement;
    Object.defineProperty(r.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        $(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const t = r.config.compilerOptions, i = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(r.config, "compilerOptions", {
      get() {
        return $(i), t;
      },
      set() {
        $(i);
      }
    });
  }
}
function Bw(r) {
  if (ne(r)) {
    const e = document.querySelector(r);
    return {}.NODE_ENV !== "production" && !e && $(
      `Failed to mount app: mount target selector "${r}" returned null.`
    ), e;
  }
  return {}.NODE_ENV !== "production" && window.ShadowRoot && r instanceof window.ShadowRoot && r.mode === "closed" && $(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), r;
}
let Jg = !1;
const Nk = () => {
  Jg || (Jg = !0, Tk(), Xk());
}, Vk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: Av,
  BaseTransitionPropsValidators: Af,
  Comment: Ue,
  EffectScope: vf,
  Fragment: je,
  KeepAlive: NQ,
  ReactiveEffect: ga,
  Static: Xr,
  Suspense: QQ,
  Teleport: AP,
  Text: Yr,
  Transition: Bf,
  TransitionGroup: Sk,
  VueElement: rh,
  assertNumber: Pf,
  callWithAsyncErrorHandling: Gt,
  callWithErrorHandling: Wi,
  camelize: qe,
  capitalize: Bi,
  cloneVNode: hi,
  compatUtils: GP,
  computed: Cw,
  createApp: Ak,
  createBlock: Xi,
  createCommentVNode: lo,
  createElementBlock: Fr,
  createElementVNode: Bn,
  createHydrationRenderer: aw,
  createPropsRestProxy: lP,
  createRenderer: sw,
  createSSRApp: zk,
  createSlots: UQ,
  createStaticVNode: VP,
  createTextVNode: Wf,
  createVNode: ke,
  customRef: YC,
  defineAsyncComponent: AQ,
  defineComponent: to,
  defineCustomElement: Ff,
  defineEmits: GQ,
  defineExpose: KQ,
  defineModel: tP,
  defineOptions: JQ,
  defineProps: jQ,
  defineSSRCustomElement: gk,
  defineSlots: eP,
  get devtools() {
    return gi;
  },
  effect: cC,
  effectScope: aC,
  getCurrentInstance: fr,
  getCurrentScope: nv,
  getTransitionRawChildren: Hu,
  guardReactiveProps: pw,
  h: ro,
  handleError: Zo,
  hasInjectionContext: OP,
  hydrate: Uw,
  initCustomFormatter: kw,
  initDirectivesForSSR: Nk,
  inject: Ps,
  isMemoSame: Ew,
  isProxy: Ns,
  isReactive: Dr,
  isReadonly: sr,
  isRef: Ne,
  isRuntimeOnly: Yf,
  isShallow: zs,
  isVNode: ar,
  markRaw: xf,
  mergeDefaults: sP,
  mergeModels: aP,
  mergeProps: mw,
  nextTick: Ls,
  normalizeClass: pa,
  normalizeProps: KS,
  normalizeStyle: Yn,
  onActivated: Nv,
  onBeforeMount: Lv,
  onBeforeUnmount: Ku,
  onBeforeUpdate: Wv,
  onDeactivated: Vv,
  onErrorCaptured: Fv,
  onMounted: io,
  onRenderTracked: Yv,
  onRenderTriggered: Uv,
  onScopeDispose: lC,
  onServerPrefetch: Iv,
  onUnmounted: Ju,
  onUpdated: Gu,
  openBlock: et,
  popScopeId: $v,
  provide: Jv,
  proxyRefs: Qf,
  pushScopeId: Tv,
  queuePostFlushCb: Fu,
  reactive: Wu,
  readonly: yf,
  ref: gt,
  registerRuntimeCompiler: ww,
  render: ed,
  renderList: qv,
  renderSlot: Nf,
  resolveComponent: LQ,
  resolveDirective: IQ,
  resolveDynamicComponent: WQ,
  resolveFilter: jP,
  resolveTransitionHooks: Cn,
  setBlockTracking: Yc,
  setDevtoolsHook: $f,
  setTransitionHooks: Eo,
  shallowReactive: Ov,
  shallowReadonly: sn,
  shallowRef: VC,
  ssrContextKey: Qw,
  ssrUtils: HP,
  stop: dC,
  toDisplayString: sC,
  toHandlerKey: _i,
  toHandlers: YQ,
  toRaw: se,
  toRef: HC,
  toRefs: FC,
  toValue: WC,
  transformVNodeArgs: zP,
  triggerRef: LC,
  unref: Yu,
  useAttrs: oP,
  useCssModule: bk,
  useCssVars: Ok,
  useModel: nP,
  useSSRContext: Pw,
  useSlots: rP,
  useTransitionState: Xf,
  vModelCheckbox: qf,
  vModelDynamic: Nw,
  vModelRadio: Hf,
  vModelSelect: Aw,
  vModelText: ql,
  vShow: Zw,
  version: jc,
  warn: $,
  watch: yi,
  watchEffect: RQ,
  watchPostEffect: Dv,
  watchSyncEffect: _Q,
  withAsyncContext: uP,
  withCtx: Us,
  withDefaults: iP,
  withDirectives: MQ,
  withKeys: Mk,
  withMemo: BP,
  withModifiers: _k,
  withScopeId: vQ
}, Symbol.toStringTag, { value: "Module" }));
function jf(r) {
  throw r;
}
function qw(r) {
  ({}).NODE_ENV !== "production" && console.warn(`[Vue warn] ${r.message}`);
}
function we(r, e, t, i) {
  const o = {}.NODE_ENV !== "production" ? (t || Zk)[r] + (i || "") : r, n = new SyntaxError(String(o));
  return n.code = r, n.loc = e, n;
}
const Zk = {
  // parse errors
  [0]: "Illegal comment.",
  [1]: "CDATA section is allowed only in XML context.",
  [2]: "Duplicate attribute.",
  [3]: "End tag cannot have attributes.",
  [4]: "Illegal '/' in tags.",
  [5]: "Unexpected EOF in tag.",
  [6]: "Unexpected EOF in CDATA section.",
  [7]: "Unexpected EOF in comment.",
  [8]: "Unexpected EOF in script.",
  [9]: "Unexpected EOF in tag.",
  [10]: "Incorrectly closed comment.",
  [11]: "Incorrectly opened comment.",
  [12]: "Illegal tag name. Use '&lt;' to print '<'.",
  [13]: "Attribute value was expected.",
  [14]: "End tag name was expected.",
  [15]: "Whitespace was expected.",
  [16]: "Unexpected '<!--' in comment.",
  [17]: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  [18]: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  [19]: "Attribute name cannot start with '='.",
  [21]: "'<?' is allowed only in XML context.",
  [20]: "Unexpected null character.",
  [22]: "Illegal '/' in tags.",
  // Vue-specific parse errors
  [23]: "Invalid end tag.",
  [24]: "Element is missing end tag.",
  [25]: "Interpolation end sign was not found.",
  [27]: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  [26]: "Legal directive name was expected.",
  // transform errors
  [28]: "v-if/v-else-if is missing expression.",
  [29]: "v-if/else branches must use unique keys.",
  [30]: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  [31]: "v-for is missing expression.",
  [32]: "v-for has invalid expression.",
  [33]: "<template v-for> key should be placed on the <template> tag.",
  [34]: "v-bind is missing expression.",
  [35]: "v-on is missing expression.",
  [36]: "Unexpected custom directive on <slot> outlet.",
  [37]: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  [38]: "Duplicate slot names found. ",
  [39]: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  [40]: "v-slot can only be used on components or <template> tags.",
  [41]: "v-model is missing expression.",
  [42]: "v-model value must be a valid JavaScript member expression.",
  [43]: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  [44]: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  [45]: "Error parsing JavaScript expression: ",
  [46]: "<KeepAlive> expects exactly one child component.",
  // generic errors
  [47]: '"prefixIdentifiers" option is not supported in this build of compiler.',
  [48]: "ES module mode is not supported in this build of compiler.",
  [49]: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  [50]: '"scopeId" option is only supported in module mode.',
  // deprecations
  [51]: "@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.",
  [52]: 'v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.',
  // just to fulfill types
  [53]: ""
}, Hs = Symbol({}.NODE_ENV !== "production" ? "Fragment" : ""), Rs = Symbol({}.NODE_ENV !== "production" ? "Teleport" : ""), Gf = Symbol({}.NODE_ENV !== "production" ? "Suspense" : ""), Hl = Symbol({}.NODE_ENV !== "production" ? "KeepAlive" : ""), Hw = Symbol({}.NODE_ENV !== "production" ? "BaseTransition" : ""), $o = Symbol({}.NODE_ENV !== "production" ? "openBlock" : ""), jw = Symbol({}.NODE_ENV !== "production" ? "createBlock" : ""), Gw = Symbol({}.NODE_ENV !== "production" ? "createElementBlock" : ""), Kf = Symbol({}.NODE_ENV !== "production" ? "createVNode" : ""), Jf = Symbol({}.NODE_ENV !== "production" ? "createElementVNode" : ""), va = Symbol({}.NODE_ENV !== "production" ? "createCommentVNode" : ""), ep = Symbol({}.NODE_ENV !== "production" ? "createTextVNode" : ""), Kw = Symbol({}.NODE_ENV !== "production" ? "createStaticVNode" : ""), tp = Symbol({}.NODE_ENV !== "production" ? "resolveComponent" : ""), jl = Symbol(
  {}.NODE_ENV !== "production" ? "resolveDynamicComponent" : ""
), ip = Symbol({}.NODE_ENV !== "production" ? "resolveDirective" : ""), rp = Symbol({}.NODE_ENV !== "production" ? "resolveFilter" : ""), op = Symbol({}.NODE_ENV !== "production" ? "withDirectives" : ""), np = Symbol({}.NODE_ENV !== "production" ? "renderList" : ""), Jw = Symbol({}.NODE_ENV !== "production" ? "renderSlot" : ""), e0 = Symbol({}.NODE_ENV !== "production" ? "createSlots" : ""), oh = Symbol({}.NODE_ENV !== "production" ? "toDisplayString" : ""), Gl = Symbol({}.NODE_ENV !== "production" ? "mergeProps" : ""), sp = Symbol({}.NODE_ENV !== "production" ? "normalizeClass" : ""), ap = Symbol({}.NODE_ENV !== "production" ? "normalizeStyle" : ""), js = Symbol({}.NODE_ENV !== "production" ? "normalizeProps" : ""), wa = Symbol({}.NODE_ENV !== "production" ? "guardReactiveProps" : ""), lp = Symbol({}.NODE_ENV !== "production" ? "toHandlers" : ""), td = Symbol({}.NODE_ENV !== "production" ? "camelize" : ""), Lk = Symbol({}.NODE_ENV !== "production" ? "capitalize" : ""), id = Symbol({}.NODE_ENV !== "production" ? "toHandlerKey" : ""), Kl = Symbol({}.NODE_ENV !== "production" ? "setBlockTracking" : ""), Wk = Symbol({}.NODE_ENV !== "production" ? "pushScopeId" : ""), Ik = Symbol({}.NODE_ENV !== "production" ? "popScopeId" : ""), up = Symbol({}.NODE_ENV !== "production" ? "withCtx" : ""), Uk = Symbol({}.NODE_ENV !== "production" ? "unref" : ""), Yk = Symbol({}.NODE_ENV !== "production" ? "isRef" : ""), hp = Symbol({}.NODE_ENV !== "production" ? "withMemo" : ""), t0 = Symbol({}.NODE_ENV !== "production" ? "isMemoSame" : ""), kn = {
  [Hs]: "Fragment",
  [Rs]: "Teleport",
  [Gf]: "Suspense",
  [Hl]: "KeepAlive",
  [Hw]: "BaseTransition",
  [$o]: "openBlock",
  [jw]: "createBlock",
  [Gw]: "createElementBlock",
  [Kf]: "createVNode",
  [Jf]: "createElementVNode",
  [va]: "createCommentVNode",
  [ep]: "createTextVNode",
  [Kw]: "createStaticVNode",
  [tp]: "resolveComponent",
  [jl]: "resolveDynamicComponent",
  [ip]: "resolveDirective",
  [rp]: "resolveFilter",
  [op]: "withDirectives",
  [np]: "renderList",
  [Jw]: "renderSlot",
  [e0]: "createSlots",
  [oh]: "toDisplayString",
  [Gl]: "mergeProps",
  [sp]: "normalizeClass",
  [ap]: "normalizeStyle",
  [js]: "normalizeProps",
  [wa]: "guardReactiveProps",
  [lp]: "toHandlers",
  [td]: "camelize",
  [Lk]: "capitalize",
  [id]: "toHandlerKey",
  [Kl]: "setBlockTracking",
  [Wk]: "pushScopeId",
  [Ik]: "popScopeId",
  [up]: "withCtx",
  [Uk]: "unref",
  [Yk]: "isRef",
  [hp]: "withMemo",
  [t0]: "isMemoSame"
};
function Fk(r) {
  Object.getOwnPropertySymbols(r).forEach((e) => {
    kn[e] = r[e];
  });
}
const ei = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function Bk(r, e = ei) {
  return {
    type: 0,
    children: r,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: e
  };
}
function Gs(r, e, t, i, o, n, s, a = !1, l = !1, u = !1, h = ei) {
  return r && (a ? (r.helper($o), r.helper($n(r.inSSR, u))) : r.helper(Tn(r.inSSR, u)), s && r.helper(op)), {
    type: 13,
    tag: e,
    props: t,
    children: i,
    patchFlag: o,
    dynamicProps: n,
    directives: s,
    isBlock: a,
    disableTracking: l,
    isComponent: u,
    loc: h
  };
}
function ya(r, e = ei) {
  return {
    type: 17,
    loc: e,
    elements: r
  };
}
function oi(r, e = ei) {
  return {
    type: 15,
    loc: e,
    properties: r
  };
}
function Ve(r, e) {
  return {
    type: 16,
    loc: ei,
    key: ne(r) ? de(r, !0) : r,
    value: e
  };
}
function de(r, e = !1, t = ei, i = 0) {
  return {
    type: 4,
    loc: t,
    content: r,
    isStatic: e,
    constType: e ? 3 : i
  };
}
function xi(r, e = ei) {
  return {
    type: 8,
    loc: e,
    children: r
  };
}
function Fe(r, e = [], t = ei) {
  return {
    type: 14,
    loc: t,
    callee: r,
    arguments: e
  };
}
function En(r, e = void 0, t = !1, i = !1, o = ei) {
  return {
    type: 18,
    params: r,
    returns: e,
    newline: t,
    isSlot: i,
    loc: o
  };
}
function rd(r, e, t, i = !0) {
  return {
    type: 19,
    test: r,
    consequent: e,
    alternate: t,
    newline: i,
    loc: ei
  };
}
function qk(r, e, t = !1) {
  return {
    type: 20,
    index: r,
    value: e,
    isVNode: t,
    loc: ei
  };
}
function Hk(r) {
  return {
    type: 21,
    body: r,
    loc: ei
  };
}
function Tn(r, e) {
  return r || e ? Kf : Jf;
}
function $n(r, e) {
  return r || e ? jw : Gw;
}
function cp(r, { helper: e, removeHelper: t, inSSR: i }) {
  r.isBlock || (r.isBlock = !0, t(Tn(i, r.isComponent)), e($o), e($n(i, r.isComponent)));
}
const Mt = (r) => r.type === 4 && r.isStatic, po = (r, e) => r === e || r === Qt(e);
function i0(r) {
  if (po(r, "Teleport"))
    return Rs;
  if (po(r, "Suspense"))
    return Gf;
  if (po(r, "KeepAlive"))
    return Hl;
  if (po(r, "BaseTransition"))
    return Hw;
}
const jk = /^\d|[^\$\w]/, dp = (r) => !jk.test(r), Gk = /[A-Za-z_$\xA0-\uFFFF]/, Kk = /[\.\?\w$\xA0-\uFFFF]/, Jk = /\s+[.[]\s*|\s*[.[]\s+/g, eE = (r) => {
  r = r.trim().replace(Jk, (s) => s.trim());
  let e = 0, t = [], i = 0, o = 0, n = null;
  for (let s = 0; s < r.length; s++) {
    const a = r.charAt(s);
    switch (e) {
      case 0:
        if (a === "[")
          t.push(e), e = 1, i++;
        else if (a === "(")
          t.push(e), e = 2, o++;
        else if (!(s === 0 ? Gk : Kk).test(a))
          return !1;
        break;
      case 1:
        a === "'" || a === '"' || a === "`" ? (t.push(e), e = 3, n = a) : a === "[" ? i++ : a === "]" && (--i || (e = t.pop()));
        break;
      case 2:
        if (a === "'" || a === '"' || a === "`")
          t.push(e), e = 3, n = a;
        else if (a === "(")
          o++;
        else if (a === ")") {
          if (s === r.length - 1)
            return !1;
          --o || (e = t.pop());
        }
        break;
      case 3:
        a === n && (e = t.pop(), n = null);
        break;
    }
  }
  return !i && !o;
}, r0 = eE;
function o0(r, e, t) {
  const o = {
    source: r.source.slice(e, e + t),
    start: Jl(r.start, r.source, e),
    end: r.end
  };
  return t != null && (o.end = Jl(
    r.start,
    r.source,
    e + t
  )), o;
}
function Jl(r, e, t = e.length) {
  return eu(
    ue({}, r),
    e,
    t
  );
}
function eu(r, e, t = e.length) {
  let i = 0, o = -1;
  for (let n = 0; n < t; n++)
    e.charCodeAt(n) === 10 && (i++, o = n);
  return r.offset += t, r.line += i, r.column = o === -1 ? r.column + t : t - o, r;
}
function em(r, e) {
  if (!r)
    throw new Error(e || "unexpected compiler condition");
}
function ii(r, e, t = !1) {
  for (let i = 0; i < r.props.length; i++) {
    const o = r.props[i];
    if (o.type === 7 && (t || o.exp) && (ne(e) ? o.name === e : e.test(o.name)))
      return o;
  }
}
function Rn(r, e, t = !1, i = !1) {
  for (let o = 0; o < r.props.length; o++) {
    const n = r.props[o];
    if (n.type === 6) {
      if (t)
        continue;
      if (n.name === e && (n.value || i))
        return n;
    } else if (n.name === "bind" && (n.exp || i) && go(n.arg, e))
      return n;
  }
}
function go(r, e) {
  return !!(r && Mt(r) && r.content === e);
}
function tE(r) {
  return r.props.some(
    (e) => e.type === 7 && e.name === "bind" && (!e.arg || // v-bind="obj"
    e.arg.type !== 4 || // v-bind:[_ctx.foo]
    !e.arg.isStatic)
    // v-bind:[foo]
  );
}
function Ih(r) {
  return r.type === 5 || r.type === 2;
}
function iE(r) {
  return r.type === 7 && r.name === "slot";
}
function tu(r) {
  return r.type === 1 && r.tagType === 3;
}
function iu(r) {
  return r.type === 1 && r.tagType === 2;
}
const rE = /* @__PURE__ */ new Set([js, wa]);
function n0(r, e = []) {
  if (r && !ne(r) && r.type === 14) {
    const t = r.callee;
    if (!ne(t) && rE.has(t))
      return n0(
        r.arguments[0],
        e.concat(r)
      );
  }
  return [r, e];
}
function ru(r, e, t) {
  let i, o = r.type === 13 ? r.props : r.arguments[2], n = [], s;
  if (o && !ne(o) && o.type === 14) {
    const a = n0(o);
    o = a[0], n = a[1], s = n[n.length - 1];
  }
  if (o == null || ne(o))
    i = oi([e]);
  else if (o.type === 14) {
    const a = o.arguments[0];
    !ne(a) && a.type === 15 ? tm(e, a) || a.properties.unshift(e) : o.callee === lp ? i = Fe(t.helper(Gl), [
      oi([e]),
      o
    ]) : o.arguments.unshift(oi([e])), !i && (i = o);
  } else
    o.type === 15 ? (tm(e, o) || o.properties.unshift(e), i = o) : (i = Fe(t.helper(Gl), [
      oi([e]),
      o
    ]), s && s.callee === wa && (s = n[n.length - 2]));
  r.type === 13 ? s ? s.arguments[0] = i : r.props = i : s ? s.arguments[0] = i : r.arguments[2] = i;
}
function tm(r, e) {
  let t = !1;
  if (r.key.type === 4) {
    const i = r.key.content;
    t = e.properties.some(
      (o) => o.key.type === 4 && o.key.content === i
    );
  }
  return t;
}
function Ks(r, e) {
  return `_${e}_${r.replace(/[^\w]/g, (t, i) => t === "-" ? "_" : r.charCodeAt(i).toString())}`;
}
function oE(r) {
  return r.type === 14 && r.callee === hp ? r.arguments[1].returns : r;
}
const nE = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (r) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${r}.sync\` should be changed to \`v-model:${r}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_PROP: {
    message: ".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate."
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTER: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function od(r, e) {
  const t = e.options ? e.options.compatConfig : e.compatConfig, i = t && t[r];
  return r === "MODE" ? i || 3 : i;
}
function zr(r, e) {
  const t = od("MODE", e), i = od(r, e);
  return t === 3 ? i === !0 : i !== !1;
}
function Ro(r, e, t, ...i) {
  const o = zr(r, e);
  return {}.NODE_ENV !== "production" && o && nh(r, e, t, ...i), o;
}
function nh(r, e, t, ...i) {
  if (od(r, e) === "suppress-warning")
    return;
  const { message: n, link: s } = nE[r], a = `(deprecation ${r}) ${typeof n == "function" ? n(...i) : n}${s ? `
  Details: ${s}` : ""}`, l = new SyntaxError(a);
  l.code = r, t && (l.loc = t), e.onWarn(l);
}
const sE = /&(gt|lt|amp|apos|quot);/g, aE = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
}, im = {
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: ys,
  isPreTag: ys,
  isCustomElement: ys,
  decodeEntities: (r) => r.replace(sE, (e, t) => aE[t]),
  onError: jf,
  onWarn: qw,
  comments: {}.NODE_ENV !== "production"
};
function lE(r, e = {}) {
  const t = uE(r, e), i = Kt(t);
  return Bk(
    fp(t, 0, []),
    Jt(t, i)
  );
}
function uE(r, e) {
  const t = ue({}, im);
  let i;
  for (i in e)
    t[i] = e[i] === void 0 ? im[i] : e[i];
  return {
    options: t,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: r,
    source: r,
    inPre: !1,
    inVPre: !1,
    onWarn: t.onWarn
  };
}
function fp(r, e, t) {
  const i = sh(t), o = i ? i.ns : 0, n = [];
  for (; !OE(r, e, t); ) {
    const a = r.source;
    let l;
    if (e === 0 || e === 1) {
      if (!r.inVPre && bt(a, r.options.delimiters[0]))
        l = mE(r, e);
      else if (e === 0 && a[0] === "<")
        if (a.length === 1)
          xe(r, 5, 1);
        else if (a[1] === "!")
          bt(a, "<!--") ? l = cE(r) : bt(a, "<!DOCTYPE") ? l = os(r) : bt(a, "<![CDATA[") ? o !== 0 ? l = hE(r, t) : (xe(r, 1), l = os(r)) : (xe(r, 11), l = os(r));
        else if (a[1] === "/")
          if (a.length === 2)
            xe(r, 5, 2);
          else if (a[2] === ">") {
            xe(r, 14, 2), Ke(r, 3);
            continue;
          } else if (/[a-z]/i.test(a[2])) {
            xe(r, 23), nd(r, ou.End, i);
            continue;
          } else
            xe(
              r,
              12,
              2
            ), l = os(r);
        else
          /[a-z]/i.test(a[1]) ? (l = dE(r, t), zr(
            "COMPILER_NATIVE_TEMPLATE",
            r
          ) && l && l.tag === "template" && !l.props.some(
            (u) => u.type === 7 && s0(u.name)
          ) && ({}.NODE_ENV !== "production" && nh(
            "COMPILER_NATIVE_TEMPLATE",
            r,
            l.loc
          ), l = l.children)) : a[1] === "?" ? (xe(
            r,
            21,
            1
          ), l = os(r)) : xe(r, 12, 1);
    }
    if (l || (l = bE(r, e)), U(l))
      for (let u = 0; u < l.length; u++)
        rm(n, l[u]);
    else
      rm(n, l);
  }
  let s = !1;
  if (e !== 2 && e !== 1) {
    const a = r.options.whitespace !== "preserve";
    for (let l = 0; l < n.length; l++) {
      const u = n[l];
      if (u.type === 2)
        if (r.inPre)
          u.content = u.content.replace(/\r\n/g, `
`);
        else if (/[^\t\r\n\f ]/.test(u.content))
          a && (u.content = u.content.replace(/[\t\r\n\f ]+/g, " "));
        else {
          const h = n[l - 1], c = n[l + 1];
          !h || !c || a && (h.type === 3 && c.type === 3 || h.type === 3 && c.type === 1 || h.type === 1 && c.type === 3 || h.type === 1 && c.type === 1 && /[\r\n]/.test(u.content)) ? (s = !0, n[l] = null) : u.content = " ";
        }
      else
        u.type === 3 && !r.options.comments && (s = !0, n[l] = null);
    }
    if (r.inPre && i && r.options.isPreTag(i.tag)) {
      const l = n[0];
      l && l.type === 2 && (l.content = l.content.replace(/^\r?\n/, ""));
    }
  }
  return s ? n.filter(Boolean) : n;
}
function rm(r, e) {
  if (e.type === 2) {
    const t = sh(r);
    if (t && t.type === 2 && t.loc.end.offset === e.loc.start.offset) {
      t.content += e.content, t.loc.end = e.loc.end, t.loc.source += e.loc.source;
      return;
    }
  }
  r.push(e);
}
function hE(r, e) {
  Ke(r, 9);
  const t = fp(r, 3, e);
  return r.source.length === 0 ? xe(r, 6) : Ke(r, 3), t;
}
function cE(r) {
  const e = Kt(r);
  let t;
  const i = /--(\!)?>/.exec(r.source);
  if (!i)
    t = r.source.slice(4), Ke(r, r.source.length), xe(r, 7);
  else {
    i.index <= 3 && xe(r, 0), i[1] && xe(r, 10), t = r.source.slice(4, i.index);
    const o = r.source.slice(0, i.index);
    let n = 1, s = 0;
    for (; (s = o.indexOf("<!--", n)) !== -1; )
      Ke(r, s - n + 1), s + 4 < o.length && xe(r, 16), n = s + 1;
    Ke(r, i.index + i[0].length - n + 1);
  }
  return {
    type: 3,
    content: t,
    loc: Jt(r, e)
  };
}
function os(r) {
  const e = Kt(r), t = r.source[1] === "?" ? 1 : 2;
  let i;
  const o = r.source.indexOf(">");
  return o === -1 ? (i = r.source.slice(t), Ke(r, r.source.length)) : (i = r.source.slice(t, o), Ke(r, o + 1)), {
    type: 3,
    content: i,
    loc: Jt(r, e)
  };
}
function dE(r, e) {
  const t = r.inPre, i = r.inVPre, o = sh(e), n = nd(r, ou.Start, o), s = r.inPre && !t, a = r.inVPre && !i;
  if (n.isSelfClosing || r.options.isVoidTag(n.tag))
    return s && (r.inPre = !1), a && (r.inVPre = !1), n;
  e.push(n);
  const l = r.options.getTextMode(n, o), u = fp(r, l, e);
  e.pop();
  {
    const h = n.props.find(
      (c) => c.type === 6 && c.name === "inline-template"
    );
    if (h && Ro(
      "COMPILER_INLINE_TEMPLATE",
      r,
      h.loc
    )) {
      const c = Jt(r, n.loc.end);
      h.value = {
        type: 2,
        content: c.source,
        loc: c
      };
    }
  }
  if (n.children = u, sd(r.source, n.tag))
    nd(r, ou.End, o);
  else if (xe(r, 24, 0, n.loc.start), r.source.length === 0 && n.tag.toLowerCase() === "script") {
    const h = u[0];
    h && bt(h.loc.source, "<!--") && xe(r, 8);
  }
  return n.loc = Jt(r, n.loc.start), s && (r.inPre = !1), a && (r.inVPre = !1), n;
}
var ou = /* @__PURE__ */ ((r) => (r[r.Start = 0] = "Start", r[r.End = 1] = "End", r))(ou || {});
const s0 = /* @__PURE__ */ vt(
  "if,else,else-if,for,slot"
);
function nd(r, e, t) {
  const i = Kt(r), o = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(r.source), n = o[1], s = r.options.getNamespace(n, t);
  Ke(r, o[0].length), Js(r);
  const a = Kt(r), l = r.source;
  r.options.isPreTag(n) && (r.inPre = !0);
  let u = om(r, e);
  e === 0 && !r.inVPre && u.some((d) => d.type === 7 && d.name === "pre") && (r.inVPre = !0, ue(r, a), r.source = l, u = om(r, e).filter((d) => d.name !== "v-pre"));
  let h = !1;
  if (r.source.length === 0 ? xe(r, 9) : (h = bt(r.source, "/>"), e === 1 && h && xe(r, 4), Ke(r, h ? 2 : 1)), e === 1)
    return;
  if ({}.NODE_ENV !== "production" && zr(
    "COMPILER_V_IF_V_FOR_PRECEDENCE",
    r
  )) {
    let d = !1, f = !1;
    for (let p = 0; p < u.length; p++) {
      const g = u[p];
      if (g.type === 7 && (g.name === "if" ? d = !0 : g.name === "for" && (f = !0)), d && f) {
        nh(
          "COMPILER_V_IF_V_FOR_PRECEDENCE",
          r,
          Jt(r, i)
        );
        break;
      }
    }
  }
  let c = 0;
  return r.inVPre || (n === "slot" ? c = 2 : n === "template" ? u.some(
    (d) => d.type === 7 && s0(d.name)
  ) && (c = 3) : fE(n, u, r) && (c = 1)), {
    type: 1,
    ns: s,
    tag: n,
    tagType: c,
    props: u,
    isSelfClosing: h,
    children: [],
    loc: Jt(r, i),
    codegenNode: void 0
    // to be created during transform phase
  };
}
function fE(r, e, t) {
  const i = t.options;
  if (i.isCustomElement(r))
    return !1;
  if (r === "component" || /^[A-Z]/.test(r) || i0(r) || i.isBuiltInComponent && i.isBuiltInComponent(r) || i.isNativeTag && !i.isNativeTag(r))
    return !0;
  for (let o = 0; o < e.length; o++) {
    const n = e[o];
    if (n.type === 6) {
      if (n.name === "is" && n.value) {
        if (n.value.content.startsWith("vue:"))
          return !0;
        if (Ro(
          "COMPILER_IS_ON_ELEMENT",
          t,
          n.loc
        ))
          return !0;
      }
    } else {
      if (n.name === "is")
        return !0;
      if (
        // :is on plain element - only treat as component in compat mode
        n.name === "bind" && go(n.arg, "is") && Ro(
          "COMPILER_IS_ON_ELEMENT",
          t,
          n.loc
        )
      )
        return !0;
    }
  }
}
function om(r, e) {
  const t = [], i = /* @__PURE__ */ new Set();
  for (; r.source.length > 0 && !bt(r.source, ">") && !bt(r.source, "/>"); ) {
    if (bt(r.source, "/")) {
      xe(r, 22), Ke(r, 1), Js(r);
      continue;
    }
    e === 1 && xe(r, 3);
    const o = pE(r, i);
    o.type === 6 && o.value && o.name === "class" && (o.value.content = o.value.content.replace(/\s+/g, " ").trim()), e === 0 && t.push(o), /^[^\t\r\n\f />]/.test(r.source) && xe(r, 15), Js(r);
  }
  return t;
}
function pE(r, e) {
  var t;
  const i = Kt(r), n = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(r.source)[0];
  e.has(n) && xe(r, 2), e.add(n), n[0] === "=" && xe(r, 19);
  {
    const l = /["'<]/g;
    let u;
    for (; u = l.exec(n); )
      xe(
        r,
        17,
        u.index
      );
  }
  Ke(r, n.length);
  let s;
  /^[\t\r\n\f ]*=/.test(r.source) && (Js(r), Ke(r, 1), Js(r), s = gE(r), s || xe(r, 13));
  const a = Jt(r, i);
  if (!r.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(n)) {
    const l = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
      n
    );
    let u = bt(n, "."), h = l[1] || (u || bt(n, ":") ? "bind" : bt(n, "@") ? "on" : "slot"), c;
    if (l[2]) {
      const f = h === "slot", p = n.lastIndexOf(
        l[2],
        n.length - (((t = l[3]) == null ? void 0 : t.length) || 0)
      ), g = Jt(
        r,
        nm(r, i, p),
        nm(
          r,
          i,
          p + l[2].length + (f && l[3] || "").length
        )
      );
      let b = l[2], m = !0;
      b.startsWith("[") ? (m = !1, b.endsWith("]") ? b = b.slice(1, b.length - 1) : (xe(
        r,
        27
      ), b = b.slice(1))) : f && (b += l[3] || ""), c = {
        type: 4,
        content: b,
        isStatic: m,
        constType: m ? 3 : 0,
        loc: g
      };
    }
    if (s && s.isQuoted) {
      const f = s.loc;
      f.start.offset++, f.start.column++, f.end = Jl(f.start, s.content), f.source = f.source.slice(1, -1);
    }
    const d = l[3] ? l[3].slice(1).split(".") : [];
    return u && d.push("prop"), h === "bind" && c && (d.includes("sync") && Ro(
      "COMPILER_V_BIND_SYNC",
      r,
      a,
      c.loc.source
    ) && (h = "model", d.splice(d.indexOf("sync"), 1)), {}.NODE_ENV !== "production" && d.includes("prop") && Ro(
      "COMPILER_V_BIND_PROP",
      r,
      a
    )), {
      type: 7,
      name: h,
      exp: s && {
        type: 4,
        content: s.content,
        isStatic: !1,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: s.loc
      },
      arg: c,
      modifiers: d,
      loc: a
    };
  }
  return !r.inVPre && bt(n, "v-") && xe(r, 26), {
    type: 6,
    name: n,
    value: s && {
      type: 2,
      content: s.content,
      loc: s.loc
    },
    loc: a
  };
}
function gE(r) {
  const e = Kt(r);
  let t;
  const i = r.source[0], o = i === '"' || i === "'";
  if (o) {
    Ke(r, 1);
    const n = r.source.indexOf(i);
    n === -1 ? t = _s(
      r,
      r.source.length,
      4
    ) : (t = _s(r, n, 4), Ke(r, 1));
  } else {
    const n = /^[^\t\r\n\f >]+/.exec(r.source);
    if (!n)
      return;
    const s = /["'<=`]/g;
    let a;
    for (; a = s.exec(n[0]); )
      xe(
        r,
        18,
        a.index
      );
    t = _s(r, n[0].length, 4);
  }
  return { content: t, isQuoted: o, loc: Jt(r, e) };
}
function mE(r, e) {
  const [t, i] = r.options.delimiters, o = r.source.indexOf(i, t.length);
  if (o === -1) {
    xe(r, 25);
    return;
  }
  const n = Kt(r);
  Ke(r, t.length);
  const s = Kt(r), a = Kt(r), l = o - t.length, u = r.source.slice(0, l), h = _s(r, l, e), c = h.trim(), d = h.indexOf(c);
  d > 0 && eu(s, u, d);
  const f = l - (h.length - c.length - d);
  return eu(a, u, f), Ke(r, i.length), {
    type: 5,
    content: {
      type: 4,
      isStatic: !1,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content: c,
      loc: Jt(r, s, a)
    },
    loc: Jt(r, n)
  };
}
function bE(r, e) {
  const t = e === 3 ? ["]]>"] : ["<", r.options.delimiters[0]];
  let i = r.source.length;
  for (let s = 0; s < t.length; s++) {
    const a = r.source.indexOf(t[s], 1);
    a !== -1 && i > a && (i = a);
  }
  const o = Kt(r);
  return {
    type: 2,
    content: _s(r, i, e),
    loc: Jt(r, o)
  };
}
function _s(r, e, t) {
  const i = r.source.slice(0, e);
  return Ke(r, e), t === 2 || t === 3 || !i.includes("&") ? i : r.options.decodeEntities(
    i,
    t === 4
  );
}
function Kt(r) {
  const { column: e, line: t, offset: i } = r;
  return { column: e, line: t, offset: i };
}
function Jt(r, e, t) {
  return t = t || Kt(r), {
    start: e,
    end: t,
    source: r.originalSource.slice(e.offset, t.offset)
  };
}
function sh(r) {
  return r[r.length - 1];
}
function bt(r, e) {
  return r.startsWith(e);
}
function Ke(r, e) {
  const { source: t } = r;
  eu(r, t, e), r.source = t.slice(e);
}
function Js(r) {
  const e = /^[\t\r\n\f ]+/.exec(r.source);
  e && Ke(r, e[0].length);
}
function nm(r, e, t) {
  return Jl(
    e,
    r.originalSource.slice(e.offset, t),
    t
  );
}
function xe(r, e, t, i = Kt(r)) {
  t && (i.offset += t, i.column += t), r.options.onError(
    we(e, {
      start: i,
      end: i,
      source: ""
    })
  );
}
function OE(r, e, t) {
  const i = r.source;
  switch (e) {
    case 0:
      if (bt(i, "</")) {
        for (let o = t.length - 1; o >= 0; --o)
          if (sd(i, t[o].tag))
            return !0;
      }
      break;
    case 1:
    case 2: {
      const o = sh(t);
      if (o && sd(i, o.tag))
        return !0;
      break;
    }
    case 3:
      if (bt(i, "]]>"))
        return !0;
      break;
  }
  return !i;
}
function sd(r, e) {
  return bt(r, "</") && r.slice(2, 2 + e.length).toLowerCase() === e.toLowerCase() && /[\t\r\n\f />]/.test(r[2 + e.length] || ">");
}
function vE(r, e) {
  wl(
    r,
    e,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    a0(r, r.children[0])
  );
}
function a0(r, e) {
  const { children: t } = r;
  return t.length === 1 && e.type === 1 && !iu(e);
}
function wl(r, e, t = !1) {
  const { children: i } = r, o = i.length;
  let n = 0;
  for (let s = 0; s < i.length; s++) {
    const a = i[s];
    if (a.type === 1 && a.tagType === 0) {
      const l = t ? 0 : ni(a, e);
      if (l > 0) {
        if (l >= 2) {
          a.codegenNode.patchFlag = -1 + ({}.NODE_ENV !== "production" ? " /* HOISTED */" : ""), a.codegenNode = e.hoist(a.codegenNode), n++;
          continue;
        }
      } else {
        const u = a.codegenNode;
        if (u.type === 13) {
          const h = c0(u);
          if ((!h || h === 512 || h === 1) && u0(a, e) >= 2) {
            const c = h0(a);
            c && (u.props = e.hoist(c));
          }
          u.dynamicProps && (u.dynamicProps = e.hoist(u.dynamicProps));
        }
      }
    }
    if (a.type === 1) {
      const l = a.tagType === 1;
      l && e.scopes.vSlot++, wl(a, e), l && e.scopes.vSlot--;
    } else if (a.type === 11)
      wl(a, e, a.children.length === 1);
    else if (a.type === 9)
      for (let l = 0; l < a.branches.length; l++)
        wl(
          a.branches[l],
          e,
          a.branches[l].children.length === 1
        );
  }
  n && e.transformHoist && e.transformHoist(i, e, r), n && n === o && r.type === 1 && r.tagType === 0 && r.codegenNode && r.codegenNode.type === 13 && U(r.codegenNode.children) && (r.codegenNode.children = e.hoist(
    ya(r.codegenNode.children)
  ));
}
function ni(r, e) {
  const { constantCache: t } = e;
  switch (r.type) {
    case 1:
      if (r.tagType !== 0)
        return 0;
      const i = t.get(r);
      if (i !== void 0)
        return i;
      const o = r.codegenNode;
      if (o.type !== 13 || o.isBlock && r.tag !== "svg" && r.tag !== "foreignObject")
        return 0;
      if (c0(o))
        return t.set(r, 0), 0;
      {
        let a = 3;
        const l = u0(r, e);
        if (l === 0)
          return t.set(r, 0), 0;
        l < a && (a = l);
        for (let u = 0; u < r.children.length; u++) {
          const h = ni(r.children[u], e);
          if (h === 0)
            return t.set(r, 0), 0;
          h < a && (a = h);
        }
        if (a > 1)
          for (let u = 0; u < r.props.length; u++) {
            const h = r.props[u];
            if (h.type === 7 && h.name === "bind" && h.exp) {
              const c = ni(h.exp, e);
              if (c === 0)
                return t.set(r, 0), 0;
              c < a && (a = c);
            }
          }
        if (o.isBlock) {
          for (let u = 0; u < r.props.length; u++)
            if (r.props[u].type === 7)
              return t.set(r, 0), 0;
          e.removeHelper($o), e.removeHelper(
            $n(e.inSSR, o.isComponent)
          ), o.isBlock = !1, e.helper(Tn(e.inSSR, o.isComponent));
        }
        return t.set(r, a), a;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return ni(r.content, e);
    case 4:
      return r.constType;
    case 8:
      let s = 3;
      for (let a = 0; a < r.children.length; a++) {
        const l = r.children[a];
        if (ne(l) || Wr(l))
          continue;
        const u = ni(l, e);
        if (u === 0)
          return 0;
        u < s && (s = u);
      }
      return s;
    default:
      return 0;
  }
}
const wE = /* @__PURE__ */ new Set([
  sp,
  ap,
  js,
  wa
]);
function l0(r, e) {
  if (r.type === 14 && !ne(r.callee) && wE.has(r.callee)) {
    const t = r.arguments[0];
    if (t.type === 4)
      return ni(t, e);
    if (t.type === 14)
      return l0(t, e);
  }
  return 0;
}
function u0(r, e) {
  let t = 3;
  const i = h0(r);
  if (i && i.type === 15) {
    const { properties: o } = i;
    for (let n = 0; n < o.length; n++) {
      const { key: s, value: a } = o[n], l = ni(s, e);
      if (l === 0)
        return l;
      l < t && (t = l);
      let u;
      if (a.type === 4 ? u = ni(a, e) : a.type === 14 ? u = l0(a, e) : u = 0, u === 0)
        return u;
      u < t && (t = u);
    }
  }
  return t;
}
function h0(r) {
  const e = r.codegenNode;
  if (e.type === 13)
    return e.props;
}
function c0(r) {
  const e = r.patchFlag;
  return e ? parseInt(e, 10) : void 0;
}
function yE(r, {
  filename: e = "",
  prefixIdentifiers: t = !1,
  hoistStatic: i = !1,
  cacheHandlers: o = !1,
  nodeTransforms: n = [],
  directiveTransforms: s = {},
  transformHoist: a = null,
  isBuiltInComponent: l = Le,
  isCustomElement: u = Le,
  expressionPlugins: h = [],
  scopeId: c = null,
  slotted: d = !0,
  ssr: f = !1,
  inSSR: p = !1,
  ssrCssVars: g = "",
  bindingMetadata: b = Oe,
  inline: m = !1,
  isTS: v = !1,
  onError: S = jf,
  onWarn: y = qw,
  compatConfig: x
}) {
  const P = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), k = {
    // options
    selfName: P && Bi(qe(P[1])),
    prefixIdentifiers: t,
    hoistStatic: i,
    cacheHandlers: o,
    nodeTransforms: n,
    directiveTransforms: s,
    transformHoist: a,
    isBuiltInComponent: l,
    isCustomElement: u,
    expressionPlugins: h,
    scopeId: c,
    slotted: d,
    ssr: f,
    inSSR: p,
    ssrCssVars: g,
    bindingMetadata: b,
    inline: m,
    isTS: v,
    onError: S,
    onWarn: y,
    compatConfig: x,
    // state
    root: r,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: r,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(C) {
      const T = k.helpers.get(C) || 0;
      return k.helpers.set(C, T + 1), C;
    },
    removeHelper(C) {
      const T = k.helpers.get(C);
      if (T) {
        const R = T - 1;
        R ? k.helpers.set(C, R) : k.helpers.delete(C);
      }
    },
    helperString(C) {
      return `_${kn[k.helper(C)]}`;
    },
    replaceNode(C) {
      if ({}.NODE_ENV !== "production") {
        if (!k.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!k.parent)
          throw new Error("Cannot replace root node.");
      }
      k.parent.children[k.childIndex] = k.currentNode = C;
    },
    removeNode(C) {
      if ({}.NODE_ENV !== "production" && !k.parent)
        throw new Error("Cannot remove root node.");
      const T = k.parent.children, R = C ? T.indexOf(C) : k.currentNode ? k.childIndex : -1;
      if ({}.NODE_ENV !== "production" && R < 0)
        throw new Error("node being removed is not a child of current parent");
      !C || C === k.currentNode ? (k.currentNode = null, k.onNodeRemoved()) : k.childIndex > R && (k.childIndex--, k.onNodeRemoved()), k.parent.children.splice(R, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(C) {
    },
    removeIdentifiers(C) {
    },
    hoist(C) {
      ne(C) && (C = de(C)), k.hoists.push(C);
      const T = de(
        `_hoisted_${k.hoists.length}`,
        !1,
        C.loc,
        2
      );
      return T.hoisted = C, T;
    },
    cache(C, T = !1) {
      return qk(k.cached++, C, T);
    }
  };
  return k.filters = /* @__PURE__ */ new Set(), k;
}
function xE(r, e) {
  const t = yE(r, e);
  ah(r, t), e.hoistStatic && vE(r, t), e.ssr || SE(r, t), r.helpers = /* @__PURE__ */ new Set([...t.helpers.keys()]), r.components = [...t.components], r.directives = [...t.directives], r.imports = t.imports, r.hoists = t.hoists, r.temps = t.temps, r.cached = t.cached, r.filters = [...t.filters];
}
function SE(r, e) {
  const { helper: t } = e, { children: i } = r;
  if (i.length === 1) {
    const o = i[0];
    if (a0(r, o) && o.codegenNode) {
      const n = o.codegenNode;
      n.type === 13 && cp(n, e), r.codegenNode = n;
    } else
      r.codegenNode = o;
  } else if (i.length > 1) {
    let o = 64, n = Li[64];
    ({}).NODE_ENV !== "production" && i.filter((s) => s.type !== 3).length === 1 && (o |= 2048, n += `, ${Li[2048]}`), r.codegenNode = Gs(
      e,
      t(Hs),
      void 0,
      r.children,
      o + ({}.NODE_ENV !== "production" ? ` /* ${n} */` : ""),
      void 0,
      void 0,
      !0,
      void 0,
      !1
      /* isComponent */
    );
  }
}
function CE(r, e) {
  let t = 0;
  const i = () => {
    t--;
  };
  for (; t < r.children.length; t++) {
    const o = r.children[t];
    ne(o) || (e.parent = r, e.childIndex = t, e.onNodeRemoved = i, ah(o, e));
  }
}
function ah(r, e) {
  e.currentNode = r;
  const { nodeTransforms: t } = e, i = [];
  for (let n = 0; n < t.length; n++) {
    const s = t[n](r, e);
    if (s && (U(s) ? i.push(...s) : i.push(s)), e.currentNode)
      r = e.currentNode;
    else
      return;
  }
  switch (r.type) {
    case 3:
      e.ssr || e.helper(va);
      break;
    case 5:
      e.ssr || e.helper(oh);
      break;
    case 9:
      for (let n = 0; n < r.branches.length; n++)
        ah(r.branches[n], e);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      CE(r, e);
      break;
  }
  e.currentNode = r;
  let o = i.length;
  for (; o--; )
    i[o]();
}
function d0(r, e) {
  const t = ne(r) ? (i) => i === r : (i) => r.test(i);
  return (i, o) => {
    if (i.type === 1) {
      const { props: n } = i;
      if (i.tagType === 3 && n.some(iE))
        return;
      const s = [];
      for (let a = 0; a < n.length; a++) {
        const l = n[a];
        if (l.type === 7 && t(l.name)) {
          n.splice(a, 1), a--;
          const u = e(i, l, o);
          u && s.push(u);
        }
      }
      return s;
    }
  };
}
const lh = "/*#__PURE__*/", f0 = (r) => `${kn[r]}: _${kn[r]}`;
function sm(r, {
  mode: e = "function",
  prefixIdentifiers: t = e === "module",
  sourceMap: i = !1,
  filename: o = "template.vue.html",
  scopeId: n = null,
  optimizeImports: s = !1,
  runtimeGlobalName: a = "Vue",
  runtimeModuleName: l = "vue",
  ssrRuntimeModuleName: u = "vue/server-renderer",
  ssr: h = !1,
  isTS: c = !1,
  inSSR: d = !1
}) {
  const f = {
    mode: e,
    prefixIdentifiers: t,
    sourceMap: i,
    filename: o,
    scopeId: n,
    optimizeImports: s,
    runtimeGlobalName: a,
    runtimeModuleName: l,
    ssrRuntimeModuleName: u,
    ssr: h,
    isTS: c,
    inSSR: d,
    source: r.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(g) {
      return `_${kn[g]}`;
    },
    push(g, b) {
      f.code += g;
    },
    indent() {
      p(++f.indentLevel);
    },
    deindent(g = !1) {
      g ? --f.indentLevel : p(--f.indentLevel);
    },
    newline() {
      p(f.indentLevel);
    }
  };
  function p(g) {
    f.push(`
` + "  ".repeat(g));
  }
  return f;
}
function QE(r, e = {}) {
  const t = sm(r, e);
  e.onContextCreated && e.onContextCreated(t);
  const {
    mode: i,
    push: o,
    prefixIdentifiers: n,
    indent: s,
    deindent: a,
    newline: l,
    scopeId: u,
    ssr: h
  } = t, c = Array.from(r.helpers), d = c.length > 0, f = !n && i !== "module", p = !1, g = p ? sm(r, e) : t;
  PE(r, g);
  const b = h ? "ssrRender" : "render", v = (h ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ");
  if (o(`function ${b}(${v}) {`), s(), f && (o("with (_ctx) {"), s(), d && (o(`const { ${c.map(f0).join(", ")} } = _Vue`), o(`
`), l())), r.components.length && (Uh(r.components, "component", t), (r.directives.length || r.temps > 0) && l()), r.directives.length && (Uh(r.directives, "directive", t), r.temps > 0 && l()), r.filters && r.filters.length && (l(), Uh(r.filters, "filter", t), l()), r.temps > 0) {
    o("let ");
    for (let S = 0; S < r.temps; S++)
      o(`${S > 0 ? ", " : ""}_temp${S}`);
  }
  return (r.components.length || r.directives.length || r.temps) && (o(`
`), l()), h || o("return "), r.codegenNode ? Ot(r.codegenNode, t) : o("null"), f && (a(), o("}")), a(), o("}"), {
    ast: r,
    code: t.code,
    preamble: p ? g.code : "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: t.map ? t.map.toJSON() : void 0
  };
}
function PE(r, e) {
  const {
    ssr: t,
    prefixIdentifiers: i,
    push: o,
    newline: n,
    runtimeModuleName: s,
    runtimeGlobalName: a,
    ssrRuntimeModuleName: l
  } = e, u = a, h = Array.from(r.helpers);
  if (h.length > 0 && (o(`const _Vue = ${u}
`), r.hoists.length)) {
    const c = [
      Kf,
      Jf,
      va,
      ep,
      Kw
    ].filter((d) => h.includes(d)).map(f0).join(", ");
    o(`const { ${c} } = _Vue
`);
  }
  kE(r.hoists, e), n(), o("return ");
}
function Uh(r, e, { helper: t, push: i, newline: o, isTS: n }) {
  const s = t(
    e === "filter" ? rp : e === "component" ? tp : ip
  );
  for (let a = 0; a < r.length; a++) {
    let l = r[a];
    const u = l.endsWith("__self");
    u && (l = l.slice(0, -6)), i(
      `const ${Ks(l, e)} = ${s}(${JSON.stringify(l)}${u ? ", true" : ""})${n ? "!" : ""}`
    ), a < r.length - 1 && o();
  }
}
function kE(r, e) {
  if (!r.length)
    return;
  e.pure = !0;
  const { push: t, newline: i, helper: o, scopeId: n, mode: s } = e;
  i();
  for (let a = 0; a < r.length; a++) {
    const l = r[a];
    l && (t(
      `const _hoisted_${a + 1} = `
    ), Ot(l, e), i());
  }
  e.pure = !1;
}
function EE(r) {
  return ne(r) || r.type === 4 || r.type === 2 || r.type === 5 || r.type === 8;
}
function pp(r, e) {
  const t = r.length > 3 || {}.NODE_ENV !== "production" && r.some((i) => U(i) || !EE(i));
  e.push("["), t && e.indent(), xa(r, e, t), t && e.deindent(), e.push("]");
}
function xa(r, e, t = !1, i = !0) {
  const { push: o, newline: n } = e;
  for (let s = 0; s < r.length; s++) {
    const a = r[s];
    ne(a) ? o(a) : U(a) ? pp(a, e) : Ot(a, e), s < r.length - 1 && (t ? (i && o(","), n()) : i && o(", "));
  }
}
function Ot(r, e) {
  if (ne(r)) {
    e.push(r);
    return;
  }
  if (Wr(r)) {
    e.push(e.helper(r));
    return;
  }
  switch (r.type) {
    case 1:
    case 9:
    case 11:
      ({}).NODE_ENV !== "production" && em(
        r.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), Ot(r.codegenNode, e);
      break;
    case 2:
      TE(r, e);
      break;
    case 4:
      p0(r, e);
      break;
    case 5:
      $E(r, e);
      break;
    case 12:
      Ot(r.codegenNode, e);
      break;
    case 8:
      g0(r, e);
      break;
    case 3:
      _E(r, e);
      break;
    case 13:
      DE(r, e);
      break;
    case 14:
      XE(r, e);
      break;
    case 15:
      AE(r, e);
      break;
    case 17:
      zE(r, e);
      break;
    case 18:
      NE(r, e);
      break;
    case 19:
      VE(r, e);
      break;
    case 20:
      ZE(r, e);
      break;
    case 21:
      xa(r.body, e, !0, !1);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if ({}.NODE_ENV !== "production")
        return em(!1, `unhandled codegen node type: ${r.type}`), r;
  }
}
function TE(r, e) {
  e.push(JSON.stringify(r.content), r);
}
function p0(r, e) {
  const { content: t, isStatic: i } = r;
  e.push(i ? JSON.stringify(t) : t, r);
}
function $E(r, e) {
  const { push: t, helper: i, pure: o } = e;
  o && t(lh), t(`${i(oh)}(`), Ot(r.content, e), t(")");
}
function g0(r, e) {
  for (let t = 0; t < r.children.length; t++) {
    const i = r.children[t];
    ne(i) ? e.push(i) : Ot(i, e);
  }
}
function RE(r, e) {
  const { push: t } = e;
  if (r.type === 8)
    t("["), g0(r, e), t("]");
  else if (r.isStatic) {
    const i = dp(r.content) ? r.content : JSON.stringify(r.content);
    t(i, r);
  } else
    t(`[${r.content}]`, r);
}
function _E(r, e) {
  const { push: t, helper: i, pure: o } = e;
  o && t(lh), t(`${i(va)}(${JSON.stringify(r.content)})`, r);
}
function DE(r, e) {
  const { push: t, helper: i, pure: o } = e, {
    tag: n,
    props: s,
    children: a,
    patchFlag: l,
    dynamicProps: u,
    directives: h,
    isBlock: c,
    disableTracking: d,
    isComponent: f
  } = r;
  h && t(i(op) + "("), c && t(`(${i($o)}(${d ? "true" : ""}), `), o && t(lh);
  const p = c ? $n(e.inSSR, f) : Tn(e.inSSR, f);
  t(i(p) + "(", r), xa(
    ME([n, s, a, l, u]),
    e
  ), t(")"), c && t(")"), h && (t(", "), Ot(h, e), t(")"));
}
function ME(r) {
  let e = r.length;
  for (; e-- && r[e] == null; )
    ;
  return r.slice(0, e + 1).map((t) => t || "null");
}
function XE(r, e) {
  const { push: t, helper: i, pure: o } = e, n = ne(r.callee) ? r.callee : i(r.callee);
  o && t(lh), t(n + "(", r), xa(r.arguments, e), t(")");
}
function AE(r, e) {
  const { push: t, indent: i, deindent: o, newline: n } = e, { properties: s } = r;
  if (!s.length) {
    t("{}", r);
    return;
  }
  const a = s.length > 1 || {}.NODE_ENV !== "production" && s.some((l) => l.value.type !== 4);
  t(a ? "{" : "{ "), a && i();
  for (let l = 0; l < s.length; l++) {
    const { key: u, value: h } = s[l];
    RE(u, e), t(": "), Ot(h, e), l < s.length - 1 && (t(","), n());
  }
  a && o(), t(a ? "}" : " }");
}
function zE(r, e) {
  pp(r.elements, e);
}
function NE(r, e) {
  const { push: t, indent: i, deindent: o } = e, { params: n, returns: s, body: a, newline: l, isSlot: u } = r;
  u && t(`_${kn[up]}(`), t("(", r), U(n) ? xa(n, e) : n && Ot(n, e), t(") => "), (l || a) && (t("{"), i()), s ? (l && t("return "), U(s) ? pp(s, e) : Ot(s, e)) : a && Ot(a, e), (l || a) && (o(), t("}")), u && (r.isNonScopedSlot && t(", undefined, true"), t(")"));
}
function VE(r, e) {
  const { test: t, consequent: i, alternate: o, newline: n } = r, { push: s, indent: a, deindent: l, newline: u } = e;
  if (t.type === 4) {
    const c = !dp(t.content);
    c && s("("), p0(t, e), c && s(")");
  } else
    s("("), Ot(t, e), s(")");
  n && a(), e.indentLevel++, n || s(" "), s("? "), Ot(i, e), e.indentLevel--, n && u(), n || s(" "), s(": ");
  const h = o.type === 19;
  h || e.indentLevel++, Ot(o, e), h || e.indentLevel--, n && l(
    !0
    /* without newline */
  );
}
function ZE(r, e) {
  const { push: t, helper: i, indent: o, deindent: n, newline: s } = e;
  t(`_cache[${r.index}] || (`), r.isVNode && (o(), t(`${i(Kl)}(-1),`), s()), t(`_cache[${r.index}] = `), Ot(r.value, e), r.isVNode && (t(","), s(), t(`${i(Kl)}(1),`), s(), t(`_cache[${r.index}]`), n()), t(")");
}
const LE = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
), WE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function mo(r, e, t = !1, i = !1) {
  const o = r.content;
  if (o.trim())
    try {
      new Function(
        i ? ` ${o} ` : `return ${t ? `(${o}) => {}` : `(${o})`}`
      );
    } catch (n) {
      let s = n.message;
      const a = o.replace(WE, "").match(LE);
      a && (s = `avoid using JavaScript keyword as property name: "${a[0]}"`), e.onError(
        we(
          45,
          r.loc,
          void 0,
          s
        )
      );
    }
}
const IE = (r, e) => {
  if (r.type === 5)
    r.content = Yh(
      r.content,
      e
    );
  else if (r.type === 1)
    for (let t = 0; t < r.props.length; t++) {
      const i = r.props[t];
      if (i.type === 7 && i.name !== "for") {
        const o = i.exp, n = i.arg;
        o && o.type === 4 && !(i.name === "on" && n) && (i.exp = Yh(
          o,
          e,
          // slot args must be processed as function params
          i.name === "slot"
        )), n && n.type === 4 && !n.isStatic && (i.arg = Yh(n, e));
      }
    }
};
function Yh(r, e, t = !1, i = !1, o = Object.create(e.identifiers)) {
  return {}.NODE_ENV !== "production" && mo(r, e, t, i), r;
}
const UE = d0(
  /^(if|else|else-if)$/,
  (r, e, t) => YE(r, e, t, (i, o, n) => {
    const s = t.parent.children;
    let a = s.indexOf(i), l = 0;
    for (; a-- >= 0; ) {
      const u = s[a];
      u && u.type === 9 && (l += u.branches.length);
    }
    return () => {
      if (n)
        i.codegenNode = lm(
          o,
          l,
          t
        );
      else {
        const u = BE(i.codegenNode);
        u.alternate = lm(
          o,
          l + i.branches.length - 1,
          t
        );
      }
    };
  })
);
function YE(r, e, t, i) {
  if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
    const o = e.exp ? e.exp.loc : r.loc;
    t.onError(
      we(28, e.loc)
    ), e.exp = de("true", !1, o);
  }
  if ({}.NODE_ENV !== "production" && e.exp && mo(e.exp, t), e.name === "if") {
    const o = am(r, e), n = {
      type: 9,
      loc: r.loc,
      branches: [o]
    };
    if (t.replaceNode(n), i)
      return i(n, o, !0);
  } else {
    const o = t.parent.children, n = [];
    let s = o.indexOf(r);
    for (; s-- >= -1; ) {
      const a = o[s];
      if (a && a.type === 3) {
        t.removeNode(a), {}.NODE_ENV !== "production" && n.unshift(a);
        continue;
      }
      if (a && a.type === 2 && !a.content.trim().length) {
        t.removeNode(a);
        continue;
      }
      if (a && a.type === 9) {
        e.name === "else-if" && a.branches[a.branches.length - 1].condition === void 0 && t.onError(
          we(30, r.loc)
        ), t.removeNode();
        const l = am(r, e);
        if ({}.NODE_ENV !== "production" && n.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(t.parent && t.parent.type === 1 && po(t.parent.tag, "transition")) && (l.children = [...n, ...l.children]), {}.NODE_ENV !== "production") {
          const h = l.userKey;
          h && a.branches.forEach(({ userKey: c }) => {
            FE(c, h) && t.onError(
              we(
                29,
                l.userKey.loc
              )
            );
          });
        }
        a.branches.push(l);
        const u = i && i(a, l, !1);
        ah(l, t), u && u(), t.currentNode = null;
      } else
        t.onError(
          we(30, r.loc)
        );
      break;
    }
  }
}
function am(r, e) {
  const t = r.tagType === 3;
  return {
    type: 10,
    loc: r.loc,
    condition: e.name === "else" ? void 0 : e.exp,
    children: t && !ii(r, "for") ? r.children : [r],
    userKey: Rn(r, "key"),
    isTemplateIf: t
  };
}
function lm(r, e, t) {
  return r.condition ? rd(
    r.condition,
    um(r, e, t),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    Fe(t.helper(va), [
      {}.NODE_ENV !== "production" ? '"v-if"' : '""',
      "true"
    ])
  ) : um(r, e, t);
}
function um(r, e, t) {
  const { helper: i } = t, o = Ve(
    "key",
    de(
      `${e}`,
      !1,
      ei,
      2
    )
  ), { children: n } = r, s = n[0];
  if (n.length !== 1 || s.type !== 1)
    if (n.length === 1 && s.type === 11) {
      const l = s.codegenNode;
      return ru(l, o, t), l;
    } else {
      let l = 64, u = Li[64];
      return {}.NODE_ENV !== "production" && !r.isTemplateIf && n.filter((h) => h.type !== 3).length === 1 && (l |= 2048, u += `, ${Li[2048]}`), Gs(
        t,
        i(Hs),
        oi([o]),
        n,
        l + ({}.NODE_ENV !== "production" ? ` /* ${u} */` : ""),
        void 0,
        void 0,
        !0,
        !1,
        !1,
        r.loc
      );
    }
  else {
    const l = s.codegenNode, u = oE(l);
    return u.type === 13 && cp(u, t), ru(u, o, t), l;
  }
}
function FE(r, e) {
  if (!r || r.type !== e.type)
    return !1;
  if (r.type === 6) {
    if (r.value.content !== e.value.content)
      return !1;
  } else {
    const t = r.exp, i = e.exp;
    if (t.type !== i.type || t.type !== 4 || t.isStatic !== i.isStatic || t.content !== i.content)
      return !1;
  }
  return !0;
}
function BE(r) {
  for (; ; )
    if (r.type === 19)
      if (r.alternate.type === 19)
        r = r.alternate;
      else
        return r;
    else
      r.type === 20 && (r = r.value);
}
const qE = d0(
  "for",
  (r, e, t) => {
    const { helper: i, removeHelper: o } = t;
    return HE(r, e, t, (n) => {
      const s = Fe(i(np), [
        n.source
      ]), a = tu(r), l = ii(r, "memo"), u = Rn(r, "key"), h = u && (u.type === 6 ? de(u.value.content, !0) : u.exp), c = u ? Ve("key", h) : null, d = n.source.type === 4 && n.source.constType > 0, f = d ? 64 : u ? 128 : 256;
      return n.codegenNode = Gs(
        t,
        i(Hs),
        void 0,
        s,
        f + ({}.NODE_ENV !== "production" ? ` /* ${Li[f]} */` : ""),
        void 0,
        void 0,
        !0,
        !d,
        !1,
        r.loc
      ), () => {
        let p;
        const { children: g } = n;
        ({}).NODE_ENV !== "production" && a && r.children.some((v) => {
          if (v.type === 1) {
            const S = Rn(v, "key");
            if (S)
              return t.onError(
                we(
                  33,
                  S.loc
                )
              ), !0;
          }
        });
        const b = g.length !== 1 || g[0].type !== 1, m = iu(r) ? r : a && r.children.length === 1 && iu(r.children[0]) ? r.children[0] : null;
        if (m ? (p = m.codegenNode, a && c && ru(p, c, t)) : b ? p = Gs(
          t,
          i(Hs),
          c ? oi([c]) : void 0,
          r.children,
          64 + ({}.NODE_ENV !== "production" ? ` /* ${Li[64]} */` : ""),
          void 0,
          void 0,
          !0,
          void 0,
          !1
          /* isComponent */
        ) : (p = g[0].codegenNode, a && c && ru(p, c, t), p.isBlock !== !d && (p.isBlock ? (o($o), o(
          $n(t.inSSR, p.isComponent)
        )) : o(
          Tn(t.inSSR, p.isComponent)
        )), p.isBlock = !d, p.isBlock ? (i($o), i($n(t.inSSR, p.isComponent))) : i(Tn(t.inSSR, p.isComponent))), l) {
          const v = En(
            ad(n.parseResult, [
              de("_cached")
            ])
          );
          v.body = Hk([
            xi(["const _memo = (", l.exp, ")"]),
            xi([
              "if (_cached",
              ...h ? [" && _cached.key === ", h] : [],
              ` && ${t.helperString(
                t0
              )}(_cached, _memo)) return _cached`
            ]),
            xi(["const _item = ", p]),
            de("_item.memo = _memo"),
            de("return _item")
          ]), s.arguments.push(
            v,
            de("_cache"),
            de(String(t.cached++))
          );
        } else
          s.arguments.push(
            En(
              ad(n.parseResult),
              p,
              !0
              /* force newline */
            )
          );
      };
    });
  }
);
function HE(r, e, t, i) {
  if (!e.exp) {
    t.onError(
      we(31, e.loc)
    );
    return;
  }
  const o = m0(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    e.exp,
    t
  );
  if (!o) {
    t.onError(
      we(32, e.loc)
    );
    return;
  }
  const { addIdentifiers: n, removeIdentifiers: s, scopes: a } = t, { source: l, value: u, key: h, index: c } = o, d = {
    type: 11,
    loc: e.loc,
    source: l,
    valueAlias: u,
    keyAlias: h,
    objectIndexAlias: c,
    parseResult: o,
    children: tu(r) ? r.children : [r]
  };
  t.replaceNode(d), a.vFor++;
  const f = i && i(d);
  return () => {
    a.vFor--, f && f();
  };
}
const jE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, hm = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, GE = /^\(|\)$/g;
function m0(r, e) {
  const t = r.loc, i = r.content, o = i.match(jE);
  if (!o)
    return;
  const [, n, s] = o, a = {
    source: Ba(
      t,
      s.trim(),
      i.indexOf(s, n.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0
  };
  ({}).NODE_ENV !== "production" && mo(a.source, e);
  let l = n.trim().replace(GE, "").trim();
  const u = n.indexOf(l), h = l.match(hm);
  if (h) {
    l = l.replace(hm, "").trim();
    const c = h[1].trim();
    let d;
    if (c && (d = i.indexOf(c, u + l.length), a.key = Ba(t, c, d), {}.NODE_ENV !== "production" && mo(
      a.key,
      e,
      !0
    )), h[2]) {
      const f = h[2].trim();
      f && (a.index = Ba(
        t,
        f,
        i.indexOf(
          f,
          a.key ? d + c.length : u + l.length
        )
      ), {}.NODE_ENV !== "production" && mo(
        a.index,
        e,
        !0
      ));
    }
  }
  return l && (a.value = Ba(t, l, u), {}.NODE_ENV !== "production" && mo(
    a.value,
    e,
    !0
  )), a;
}
function Ba(r, e, t) {
  return de(
    e,
    !1,
    o0(r, t, e.length)
  );
}
function ad({ value: r, key: e, index: t }, i = []) {
  return KE([r, e, t, ...i]);
}
function KE(r) {
  let e = r.length;
  for (; e-- && !r[e]; )
    ;
  return r.slice(0, e + 1).map((t, i) => t || de("_".repeat(i + 1), !1));
}
const cm = de("undefined", !1), JE = (r, e) => {
  if (r.type === 1 && (r.tagType === 1 || r.tagType === 3)) {
    const t = ii(r, "slot");
    if (t)
      return t.exp, e.scopes.vSlot++, () => {
        e.scopes.vSlot--;
      };
  }
}, eT = (r, e, t) => En(
  r,
  e,
  !1,
  !0,
  e.length ? e[0].loc : t
);
function tT(r, e, t = eT) {
  e.helper(up);
  const { children: i, loc: o } = r, n = [], s = [];
  let a = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
  const l = ii(r, "slot", !0);
  if (l) {
    const { arg: b, exp: m } = l;
    b && !Mt(b) && (a = !0), n.push(
      Ve(
        b || de("default", !0),
        t(m, i, o)
      )
    );
  }
  let u = !1, h = !1;
  const c = [], d = /* @__PURE__ */ new Set();
  let f = 0;
  for (let b = 0; b < i.length; b++) {
    const m = i[b];
    let v;
    if (!tu(m) || !(v = ii(m, "slot", !0))) {
      m.type !== 3 && c.push(m);
      continue;
    }
    if (l) {
      e.onError(
        we(37, v.loc)
      );
      break;
    }
    u = !0;
    const { children: S, loc: y } = m, {
      arg: x = de("default", !0),
      exp: P,
      loc: k
    } = v;
    let C;
    Mt(x) ? C = x ? x.content : "default" : a = !0;
    const T = t(P, S, y);
    let R, M, E;
    if (R = ii(m, "if"))
      a = !0, s.push(
        rd(
          R.exp,
          qa(x, T, f++),
          cm
        )
      );
    else if (M = ii(
      m,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let Z = b, N;
      for (; Z-- && (N = i[Z], N.type === 3); )
        ;
      if (N && tu(N) && ii(N, "if")) {
        i.splice(b, 1), b--;
        let G = s[s.length - 1];
        for (; G.alternate.type === 19; )
          G = G.alternate;
        G.alternate = M.exp ? rd(
          M.exp,
          qa(
            x,
            T,
            f++
          ),
          cm
        ) : qa(x, T, f++);
      } else
        e.onError(
          we(30, M.loc)
        );
    } else if (E = ii(m, "for")) {
      a = !0;
      const Z = E.parseResult || m0(E.exp, e);
      Z ? s.push(
        Fe(e.helper(np), [
          Z.source,
          En(
            ad(Z),
            qa(x, T),
            !0
            /* force newline */
          )
        ])
      ) : e.onError(
        we(32, E.loc)
      );
    } else {
      if (C) {
        if (d.has(C)) {
          e.onError(
            we(
              38,
              k
            )
          );
          continue;
        }
        d.add(C), C === "default" && (h = !0);
      }
      n.push(Ve(x, T));
    }
  }
  if (!l) {
    const b = (m, v) => {
      const S = t(m, v, o);
      return e.compatConfig && (S.isNonScopedSlot = !0), Ve("default", S);
    };
    u ? c.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    c.some((m) => b0(m)) && (h ? e.onError(
      we(
        39,
        c[0].loc
      )
    ) : n.push(
      b(void 0, c)
    )) : n.push(b(void 0, i));
  }
  const p = a ? 2 : yl(r.children) ? 3 : 1;
  let g = oi(
    n.concat(
      Ve(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        de(
          p + ({}.NODE_ENV !== "production" ? ` /* ${YS[p]} */` : ""),
          !1
        )
      )
    ),
    o
  );
  return s.length && (g = Fe(e.helper(e0), [
    g,
    ya(s)
  ])), {
    slots: g,
    hasDynamicSlots: a
  };
}
function qa(r, e, t) {
  const i = [
    Ve("name", r),
    Ve("fn", e)
  ];
  return t != null && i.push(
    Ve("key", de(String(t), !0))
  ), oi(i);
}
function yl(r) {
  for (let e = 0; e < r.length; e++) {
    const t = r[e];
    switch (t.type) {
      case 1:
        if (t.tagType === 2 || yl(t.children))
          return !0;
        break;
      case 9:
        if (yl(t.branches))
          return !0;
        break;
      case 10:
      case 11:
        if (yl(t.children))
          return !0;
        break;
    }
  }
  return !1;
}
function b0(r) {
  return r.type !== 2 && r.type !== 12 ? !0 : r.type === 2 ? !!r.content.trim() : b0(r.content);
}
const O0 = /* @__PURE__ */ new WeakMap(), iT = (r, e) => function() {
  if (r = e.currentNode, !(r.type === 1 && (r.tagType === 0 || r.tagType === 1)))
    return;
  const { tag: i, props: o } = r, n = r.tagType === 1;
  let s = n ? rT(r, e) : `"${i}"`;
  const a = me(s) && s.callee === jl;
  let l, u, h, c = 0, d, f, p, g = (
    // dynamic component may resolve to plain elements
    a || s === Rs || s === Gf || !n && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (i === "svg" || i === "foreignObject")
  );
  if (o.length > 0) {
    const b = v0(
      r,
      e,
      void 0,
      n,
      a
    );
    l = b.props, c = b.patchFlag, f = b.dynamicPropNames;
    const m = b.directives;
    p = m && m.length ? ya(
      m.map((v) => nT(v, e))
    ) : void 0, b.shouldUseBlock && (g = !0);
  }
  if (r.children.length > 0)
    if (s === Hl && (g = !0, c |= 1024, {}.NODE_ENV !== "production" && r.children.length > 1 && e.onError(
      we(46, {
        start: r.children[0].loc.start,
        end: r.children[r.children.length - 1].loc.end,
        source: ""
      })
    )), n && // Teleport is not a real component and has dedicated runtime handling
    s !== Rs && // explained above.
    s !== Hl) {
      const { slots: m, hasDynamicSlots: v } = tT(r, e);
      u = m, v && (c |= 1024);
    } else if (r.children.length === 1 && s !== Rs) {
      const m = r.children[0], v = m.type, S = v === 5 || v === 8;
      S && ni(m, e) === 0 && (c |= 1), S || v === 2 ? u = m : u = r.children;
    } else
      u = r.children;
  if (c !== 0) {
    if ({}.NODE_ENV !== "production")
      if (c < 0)
        h = c + ` /* ${Li[c]} */`;
      else {
        const b = Object.keys(Li).map(Number).filter((m) => m > 0 && c & m).map((m) => Li[m]).join(", ");
        h = c + ` /* ${b} */`;
      }
    else
      h = String(c);
    f && f.length && (d = sT(f));
  }
  r.codegenNode = Gs(
    e,
    s,
    l,
    u,
    h,
    d,
    p,
    !!g,
    !1,
    n,
    r.loc
  );
};
function rT(r, e, t = !1) {
  let { tag: i } = r;
  const o = ld(i), n = Rn(r, "is");
  if (n)
    if (o || zr(
      "COMPILER_IS_ON_ELEMENT",
      e
    )) {
      const l = n.type === 6 ? n.value && de(n.value.content, !0) : n.exp;
      if (l)
        return Fe(e.helper(jl), [
          l
        ]);
    } else
      n.type === 6 && n.value.content.startsWith("vue:") && (i = n.value.content.slice(4));
  const s = !o && ii(r, "is");
  if (s && s.exp)
    return {}.NODE_ENV !== "production" && e.onWarn(
      we(52, s.loc)
    ), Fe(e.helper(jl), [
      s.exp
    ]);
  const a = i0(i) || e.isBuiltInComponent(i);
  return a ? (t || e.helper(a), a) : (e.helper(tp), e.components.add(i), Ks(i, "component"));
}
function v0(r, e, t = r.props, i, o, n = !1) {
  const { tag: s, loc: a, children: l } = r;
  let u = [];
  const h = [], c = [], d = l.length > 0;
  let f = !1, p = 0, g = !1, b = !1, m = !1, v = !1, S = !1, y = !1;
  const x = [], P = (T) => {
    u.length && (h.push(
      oi(dm(u), a)
    ), u = []), T && h.push(T);
  }, k = ({ key: T, value: R }) => {
    if (Mt(T)) {
      const M = T.content, E = nr(M);
      if (E && (!i || o) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      M.toLowerCase() !== "onclick" && // omit v-model handlers
      M !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !wo(M) && (v = !0), E && wo(M) && (y = !0), R.type === 20 || (R.type === 4 || R.type === 8) && ni(R, e) > 0)
        return;
      M === "ref" ? g = !0 : M === "class" ? b = !0 : M === "style" ? m = !0 : M !== "key" && !x.includes(M) && x.push(M), i && (M === "class" || M === "style") && !x.includes(M) && x.push(M);
    } else
      S = !0;
  };
  for (let T = 0; T < t.length; T++) {
    const R = t[T];
    if (R.type === 6) {
      const { loc: M, name: E, value: Z } = R;
      let N = !0;
      if (E === "ref" && (g = !0, e.scopes.vFor > 0 && u.push(
        Ve(
          de("ref_for", !0),
          de("true")
        )
      )), E === "is" && (ld(s) || Z && Z.content.startsWith("vue:") || zr(
        "COMPILER_IS_ON_ELEMENT",
        e
      )))
        continue;
      u.push(
        Ve(
          de(
            E,
            !0,
            o0(M, 0, E.length)
          ),
          de(
            Z ? Z.content : "",
            N,
            Z ? Z.loc : M
          )
        )
      );
    } else {
      const { name: M, arg: E, exp: Z, loc: N } = R, G = M === "bind", ee = M === "on";
      if (M === "slot") {
        i || e.onError(
          we(40, N)
        );
        continue;
      }
      if (M === "once" || M === "memo" || M === "is" || G && go(E, "is") && (ld(s) || zr(
        "COMPILER_IS_ON_ELEMENT",
        e
      )) || ee && n)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (G && go(E, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        ee && d && go(E, "vue:before-update")) && (f = !0), G && go(E, "ref") && e.scopes.vFor > 0 && u.push(
          Ve(
            de("ref_for", !0),
            de("true")
          )
        ), !E && (G || ee)
      ) {
        if (S = !0, Z)
          if (G) {
            if (P(), {}.NODE_ENV !== "production" && h.some((ce) => ce.type === 15 ? ce.properties.some(({ key: ye }) => ye.type !== 4 || !ye.isStatic ? !0 : ye.content !== "class" && ye.content !== "style" && !nr(ye.content)) : !0) && Ro(
              "COMPILER_V_BIND_OBJECT_ORDER",
              e,
              N
            ), zr(
              "COMPILER_V_BIND_OBJECT_ORDER",
              e
            )) {
              h.unshift(Z);
              continue;
            }
            h.push(Z);
          } else
            P({
              type: 14,
              loc: N,
              callee: e.helper(lp),
              arguments: i ? [Z] : [Z, "true"]
            });
        else
          e.onError(
            we(
              G ? 34 : 35,
              N
            )
          );
        continue;
      }
      const oe = e.directiveTransforms[M];
      if (oe) {
        const { props: te, needRuntime: ce } = oe(R, r, e);
        !n && te.forEach(k), ee && E && !Mt(E) ? P(oi(te, a)) : u.push(...te), ce && (c.push(R), Wr(ce) && O0.set(R, ce));
      } else
        KO(M) || (c.push(R), d && (f = !0));
    }
  }
  let C;
  if (h.length ? (P(), h.length > 1 ? C = Fe(
    e.helper(Gl),
    h,
    a
  ) : C = h[0]) : u.length && (C = oi(
    dm(u),
    a
  )), S ? p |= 16 : (b && !i && (p |= 2), m && !i && (p |= 4), x.length && (p |= 8), v && (p |= 32)), !f && (p === 0 || p === 32) && (g || y || c.length > 0) && (p |= 512), !e.inSSR && C)
    switch (C.type) {
      case 15:
        let T = -1, R = -1, M = !1;
        for (let N = 0; N < C.properties.length; N++) {
          const G = C.properties[N].key;
          Mt(G) ? G.content === "class" ? T = N : G.content === "style" && (R = N) : G.isHandlerKey || (M = !0);
        }
        const E = C.properties[T], Z = C.properties[R];
        M ? C = Fe(
          e.helper(js),
          [C]
        ) : (E && !Mt(E.value) && (E.value = Fe(
          e.helper(sp),
          [E.value]
        )), Z && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (m || Z.value.type === 4 && Z.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        Z.value.type === 17) && (Z.value = Fe(
          e.helper(ap),
          [Z.value]
        )));
        break;
      case 14:
        break;
      default:
        C = Fe(
          e.helper(js),
          [
            Fe(e.helper(wa), [
              C
            ])
          ]
        );
        break;
    }
  return {
    props: C,
    directives: c,
    patchFlag: p,
    dynamicPropNames: x,
    shouldUseBlock: f
  };
}
function dm(r) {
  const e = /* @__PURE__ */ new Map(), t = [];
  for (let i = 0; i < r.length; i++) {
    const o = r[i];
    if (o.key.type === 8 || !o.key.isStatic) {
      t.push(o);
      continue;
    }
    const n = o.key.content, s = e.get(n);
    s ? (n === "style" || n === "class" || nr(n)) && oT(s, o) : (e.set(n, o), t.push(o));
  }
  return t;
}
function oT(r, e) {
  r.value.type === 17 ? r.value.elements.push(e.value) : r.value = ya(
    [r.value, e.value],
    r.loc
  );
}
function nT(r, e) {
  const t = [], i = O0.get(r);
  i ? t.push(e.helperString(i)) : (e.helper(ip), e.directives.add(r.name), t.push(Ks(r.name, "directive")));
  const { loc: o } = r;
  if (r.exp && t.push(r.exp), r.arg && (r.exp || t.push("void 0"), t.push(r.arg)), Object.keys(r.modifiers).length) {
    r.arg || (r.exp || t.push("void 0"), t.push("void 0"));
    const n = de("true", !1, o);
    t.push(
      oi(
        r.modifiers.map(
          (s) => Ve(s, n)
        ),
        o
      )
    );
  }
  return ya(t, r.loc);
}
function sT(r) {
  let e = "[";
  for (let t = 0, i = r.length; t < i; t++)
    e += JSON.stringify(r[t]), t < i - 1 && (e += ", ");
  return e + "]";
}
function ld(r) {
  return r === "component" || r === "Component";
}
const aT = (r, e) => {
  if (iu(r)) {
    const { children: t, loc: i } = r, { slotName: o, slotProps: n } = lT(r, e), s = [
      e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      o,
      "{}",
      "undefined",
      "true"
    ];
    let a = 2;
    n && (s[2] = n, a = 3), t.length && (s[3] = En([], t, !1, !1, i), a = 4), e.scopeId && !e.slotted && (a = 5), s.splice(a), r.codegenNode = Fe(
      e.helper(Jw),
      s,
      i
    );
  }
};
function lT(r, e) {
  let t = '"default"', i;
  const o = [];
  for (let n = 0; n < r.props.length; n++) {
    const s = r.props[n];
    s.type === 6 ? s.value && (s.name === "name" ? t = JSON.stringify(s.value.content) : (s.name = qe(s.name), o.push(s))) : s.name === "bind" && go(s.arg, "name") ? s.exp && (t = s.exp) : (s.name === "bind" && s.arg && Mt(s.arg) && (s.arg.content = qe(s.arg.content)), o.push(s));
  }
  if (o.length > 0) {
    const { props: n, directives: s } = v0(
      r,
      e,
      o,
      !1,
      !1
    );
    i = n, s.length && e.onError(
      we(
        36,
        s[0].loc
      )
    );
  }
  return {
    slotName: t,
    slotProps: i
  };
}
const uT = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, w0 = (r, e, t, i) => {
  const { loc: o, modifiers: n, arg: s } = r;
  !r.exp && !n.length && t.onError(we(35, o));
  let a;
  if (s.type === 4)
    if (s.isStatic) {
      let c = s.content;
      ({}).NODE_ENV !== "production" && c.startsWith("vnode") && t.onWarn(
        we(51, s.loc)
      ), c.startsWith("vue:") && (c = `vnode-${c.slice(4)}`);
      const d = e.tagType !== 0 || c.startsWith("vnode") || !/[A-Z]/.test(c) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        _i(qe(c))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${c}`
      );
      a = de(d, !0, s.loc);
    } else
      a = xi([
        `${t.helperString(id)}(`,
        s,
        ")"
      ]);
  else
    a = s, a.children.unshift(`${t.helperString(id)}(`), a.children.push(")");
  let l = r.exp;
  l && !l.content.trim() && (l = void 0);
  let u = t.cacheHandlers && !l && !t.inVOnce;
  if (l) {
    const c = r0(l.content), d = !(c || uT.test(l.content)), f = l.content.includes(";");
    ({}).NODE_ENV !== "production" && mo(
      l,
      t,
      !1,
      f
    ), (d || u && c) && (l = xi([
      `${d ? "$event" : "(...args)"} => ${f ? "{" : "("}`,
      l,
      f ? "}" : ")"
    ]));
  }
  let h = {
    props: [
      Ve(
        a,
        l || de("() => {}", !1, o)
      )
    ]
  };
  return i && (h = i(h)), u && (h.props[0].value = t.cache(h.props[0].value)), h.props.forEach((c) => c.key.isHandlerKey = !0), h;
}, hT = (r, e, t) => {
  const { exp: i, modifiers: o, loc: n } = r, s = r.arg;
  return s.type !== 4 ? (s.children.unshift("("), s.children.push(') || ""')) : s.isStatic || (s.content = `${s.content} || ""`), o.includes("camel") && (s.type === 4 ? s.isStatic ? s.content = qe(s.content) : s.content = `${t.helperString(td)}(${s.content})` : (s.children.unshift(`${t.helperString(td)}(`), s.children.push(")"))), t.inSSR || (o.includes("prop") && fm(s, "."), o.includes("attr") && fm(s, "^")), !i || i.type === 4 && !i.content.trim() ? (t.onError(we(34, n)), {
    props: [Ve(s, de("", !0, n))]
  }) : {
    props: [Ve(s, i)]
  };
}, fm = (r, e) => {
  r.type === 4 ? r.isStatic ? r.content = e + r.content : r.content = `\`${e}\${${r.content}}\`` : (r.children.unshift(`'${e}' + (`), r.children.push(")"));
}, cT = (r, e) => {
  if (r.type === 0 || r.type === 1 || r.type === 11 || r.type === 10)
    return () => {
      const t = r.children;
      let i, o = !1;
      for (let n = 0; n < t.length; n++) {
        const s = t[n];
        if (Ih(s)) {
          o = !0;
          for (let a = n + 1; a < t.length; a++) {
            const l = t[a];
            if (Ih(l))
              i || (i = t[n] = xi(
                [s],
                s.loc
              )), i.children.push(" + ", l), t.splice(a, 1), a--;
            else {
              i = void 0;
              break;
            }
          }
        }
      }
      if (!(!o || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      t.length === 1 && (r.type === 0 || r.type === 1 && r.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !r.props.find(
        (n) => n.type === 7 && !e.directiveTransforms[n.name]
      ) && r.tag !== "template")))
        for (let n = 0; n < t.length; n++) {
          const s = t[n];
          if (Ih(s) || s.type === 8) {
            const a = [];
            (s.type !== 2 || s.content !== " ") && a.push(s), !e.ssr && ni(s, e) === 0 && a.push(
              1 + ({}.NODE_ENV !== "production" ? ` /* ${Li[1]} */` : "")
            ), t[n] = {
              type: 12,
              content: s,
              loc: s.loc,
              codegenNode: Fe(
                e.helper(ep),
                a
              )
            };
          }
        }
    };
}, pm = /* @__PURE__ */ new WeakSet(), dT = (r, e) => {
  if (r.type === 1 && ii(r, "once", !0))
    return pm.has(r) || e.inVOnce || e.inSSR ? void 0 : (pm.add(r), e.inVOnce = !0, e.helper(Kl), () => {
      e.inVOnce = !1;
      const t = e.currentNode;
      t.codegenNode && (t.codegenNode = e.cache(
        t.codegenNode,
        !0
        /* isVNode */
      ));
    });
}, y0 = (r, e, t) => {
  const { exp: i, arg: o } = r;
  if (!i)
    return t.onError(
      we(41, r.loc)
    ), Ha();
  const n = i.loc.source, s = i.type === 4 ? i.content : n, a = t.bindingMetadata[n];
  if (a === "props" || a === "props-aliased")
    return t.onError(we(44, i.loc)), Ha();
  const l = !1;
  if (!s.trim() || !r0(s) && !l)
    return t.onError(
      we(42, i.loc)
    ), Ha();
  const u = o || de("modelValue", !0), h = o ? Mt(o) ? `onUpdate:${qe(o.content)}` : xi(['"onUpdate:" + ', o]) : "onUpdate:modelValue";
  let c;
  const d = t.isTS ? "($event: any)" : "$event";
  c = xi([
    `${d} => ((`,
    i,
    ") = $event)"
  ]);
  const f = [
    // modelValue: foo
    Ve(u, r.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    Ve(h, c)
  ];
  if (r.modifiers.length && e.tagType === 1) {
    const p = r.modifiers.map((b) => (dp(b) ? b : JSON.stringify(b)) + ": true").join(", "), g = o ? Mt(o) ? `${o.content}Modifiers` : xi([o, ' + "Modifiers"']) : "modelModifiers";
    f.push(
      Ve(
        g,
        de(
          `{ ${p} }`,
          !1,
          r.loc,
          2
        )
      )
    );
  }
  return Ha(f);
};
function Ha(r = []) {
  return { props: r };
}
const fT = /[\w).+\-_$\]]/, pT = (r, e) => {
  zr("COMPILER_FILTER", e) && (r.type === 5 && nu(r.content, e), r.type === 1 && r.props.forEach((t) => {
    t.type === 7 && t.name !== "for" && t.exp && nu(t.exp, e);
  }));
};
function nu(r, e) {
  if (r.type === 4)
    gm(r, e);
  else
    for (let t = 0; t < r.children.length; t++) {
      const i = r.children[t];
      typeof i == "object" && (i.type === 4 ? gm(i, e) : i.type === 8 ? nu(r, e) : i.type === 5 && nu(i.content, e));
    }
}
function gm(r, e) {
  const t = r.content;
  let i = !1, o = !1, n = !1, s = !1, a = 0, l = 0, u = 0, h = 0, c, d, f, p, g = [];
  for (f = 0; f < t.length; f++)
    if (d = c, c = t.charCodeAt(f), i)
      c === 39 && d !== 92 && (i = !1);
    else if (o)
      c === 34 && d !== 92 && (o = !1);
    else if (n)
      c === 96 && d !== 92 && (n = !1);
    else if (s)
      c === 47 && d !== 92 && (s = !1);
    else if (c === 124 && // pipe
    t.charCodeAt(f + 1) !== 124 && t.charCodeAt(f - 1) !== 124 && !a && !l && !u)
      p === void 0 ? (h = f + 1, p = t.slice(0, f).trim()) : b();
    else {
      switch (c) {
        case 34:
          o = !0;
          break;
        case 39:
          i = !0;
          break;
        case 96:
          n = !0;
          break;
        case 40:
          u++;
          break;
        case 41:
          u--;
          break;
        case 91:
          l++;
          break;
        case 93:
          l--;
          break;
        case 123:
          a++;
          break;
        case 125:
          a--;
          break;
      }
      if (c === 47) {
        let m = f - 1, v;
        for (; m >= 0 && (v = t.charAt(m), v === " "); m--)
          ;
        (!v || !fT.test(v)) && (s = !0);
      }
    }
  p === void 0 ? p = t.slice(0, f).trim() : h !== 0 && b();
  function b() {
    g.push(t.slice(h, f).trim()), h = f + 1;
  }
  if (g.length) {
    for ({}.NODE_ENV !== "production" && nh(
      "COMPILER_FILTER",
      e,
      r.loc
    ), f = 0; f < g.length; f++)
      p = gT(p, g[f], e);
    r.content = p;
  }
}
function gT(r, e, t) {
  t.helper(rp);
  const i = e.indexOf("(");
  if (i < 0)
    return t.filters.add(e), `${Ks(e, "filter")}(${r})`;
  {
    const o = e.slice(0, i), n = e.slice(i + 1);
    return t.filters.add(o), `${Ks(o, "filter")}(${r}${n !== ")" ? "," + n : n}`;
  }
}
const mm = /* @__PURE__ */ new WeakSet(), mT = (r, e) => {
  if (r.type === 1) {
    const t = ii(r, "memo");
    return !t || mm.has(r) ? void 0 : (mm.add(r), () => {
      const i = r.codegenNode || e.currentNode.codegenNode;
      i && i.type === 13 && (r.tagType !== 1 && cp(i, e), r.codegenNode = Fe(e.helper(hp), [
        t.exp,
        En(void 0, i),
        "_cache",
        String(e.cached++)
      ]));
    });
  }
};
function bT(r) {
  return [
    [
      dT,
      UE,
      mT,
      qE,
      pT,
      ...{}.NODE_ENV !== "production" ? [IE] : [],
      aT,
      iT,
      JE,
      cT
    ],
    {
      on: w0,
      bind: hT,
      model: y0
    }
  ];
}
function OT(r, e = {}) {
  const t = e.onError || jf, i = e.mode === "module";
  e.prefixIdentifiers === !0 ? t(we(47)) : i && t(we(48));
  const o = !1;
  e.cacheHandlers && t(we(49)), e.scopeId && !i && t(we(50));
  const n = ne(r) ? lE(r, e) : r, [s, a] = bT();
  return xE(
    n,
    ue({}, e, {
      prefixIdentifiers: o,
      nodeTransforms: [
        ...s,
        ...e.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: ue(
        {},
        a,
        e.directiveTransforms || {}
        // user transforms
      )
    })
  ), QE(
    n,
    ue({}, e, {
      prefixIdentifiers: o
    })
  );
}
const vT = () => ({ props: [] }), x0 = Symbol({}.NODE_ENV !== "production" ? "vModelRadio" : ""), S0 = Symbol({}.NODE_ENV !== "production" ? "vModelCheckbox" : ""), C0 = Symbol({}.NODE_ENV !== "production" ? "vModelText" : ""), Q0 = Symbol({}.NODE_ENV !== "production" ? "vModelSelect" : ""), ud = Symbol({}.NODE_ENV !== "production" ? "vModelDynamic" : ""), P0 = Symbol({}.NODE_ENV !== "production" ? "vOnModifiersGuard" : ""), k0 = Symbol({}.NODE_ENV !== "production" ? "vOnKeysGuard" : ""), E0 = Symbol({}.NODE_ENV !== "production" ? "vShow" : ""), gp = Symbol({}.NODE_ENV !== "production" ? "Transition" : ""), T0 = Symbol({}.NODE_ENV !== "production" ? "TransitionGroup" : "");
Fk({
  [x0]: "vModelRadio",
  [S0]: "vModelCheckbox",
  [C0]: "vModelText",
  [Q0]: "vModelSelect",
  [ud]: "vModelDynamic",
  [P0]: "withModifiers",
  [k0]: "withKeys",
  [E0]: "vShow",
  [gp]: "Transition",
  [T0]: "TransitionGroup"
});
let Go;
function wT(r, e = !1) {
  return Go || (Go = document.createElement("div")), e ? (Go.innerHTML = `<div foo="${r.replace(/"/g, "&quot;")}">`, Go.children[0].getAttribute("foo")) : (Go.innerHTML = r, Go.textContent);
}
const yT = /* @__PURE__ */ vt(
  "style,iframe,script,noscript",
  !0
), xT = {
  isVoidTag: iC,
  isNativeTag: (r) => ev(r) || tv(r),
  isPreTag: (r) => r === "pre",
  decodeEntities: wT,
  isBuiltInComponent: (r) => {
    if (po(r, "Transition"))
      return gp;
    if (po(r, "TransitionGroup"))
      return T0;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(r, e) {
    let t = e ? e.ns : 0;
    if (e && t === 2)
      if (e.tag === "annotation-xml") {
        if (r === "svg")
          return 1;
        e.props.some(
          (i) => i.type === 6 && i.name === "encoding" && i.value != null && (i.value.content === "text/html" || i.value.content === "application/xhtml+xml")
        ) && (t = 0);
      } else
        /^m(?:[ions]|text)$/.test(e.tag) && r !== "mglyph" && r !== "malignmark" && (t = 0);
    else
      e && t === 1 && (e.tag === "foreignObject" || e.tag === "desc" || e.tag === "title") && (t = 0);
    if (t === 0) {
      if (r === "svg")
        return 1;
      if (r === "math")
        return 2;
    }
    return t;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag: r, ns: e }) {
    if (e === 0) {
      if (r === "textarea" || r === "title")
        return 1;
      if (yT(r))
        return 2;
    }
    return 0;
  }
}, ST = (r) => {
  r.type === 1 && r.props.forEach((e, t) => {
    e.type === 6 && e.name === "style" && e.value && (r.props[t] = {
      type: 7,
      name: "bind",
      arg: de("style", !0, e.loc),
      exp: CT(e.value.content, e.loc),
      modifiers: [],
      loc: e.loc
    });
  });
}, CT = (r, e) => {
  const t = JO(r);
  return de(
    JSON.stringify(t),
    !1,
    e,
    3
  );
};
function bi(r, e) {
  return we(
    r,
    e,
    {}.NODE_ENV !== "production" ? QT : void 0
  );
}
const QT = {
  [53]: "v-html is missing expression.",
  [54]: "v-html will override element children.",
  [55]: "v-text is missing expression.",
  [56]: "v-text will override element children.",
  [57]: "v-model can only be used on <input>, <textarea> and <select> elements.",
  [58]: "v-model argument is not supported on plain elements.",
  [59]: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  [60]: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  [61]: "v-show is missing expression.",
  [62]: "<Transition> expects exactly one child element or component.",
  [63]: "Tags with side effect (<script> and <style>) are ignored in client component templates."
}, PT = (r, e, t) => {
  const { exp: i, loc: o } = r;
  return i || t.onError(
    bi(53, o)
  ), e.children.length && (t.onError(
    bi(54, o)
  ), e.children.length = 0), {
    props: [
      Ve(
        de("innerHTML", !0, o),
        i || de("", !0)
      )
    ]
  };
}, kT = (r, e, t) => {
  const { exp: i, loc: o } = r;
  return i || t.onError(
    bi(55, o)
  ), e.children.length && (t.onError(
    bi(56, o)
  ), e.children.length = 0), {
    props: [
      Ve(
        de("textContent", !0),
        i ? ni(i, t) > 0 ? i : Fe(
          t.helperString(oh),
          [i],
          o
        ) : de("", !0)
      )
    ]
  };
}, ET = (r, e, t) => {
  const i = y0(r, e, t);
  if (!i.props.length || e.tagType === 1)
    return i;
  r.arg && t.onError(
    bi(
      58,
      r.arg.loc
    )
  );
  function o() {
    const a = Rn(e, "value");
    a && t.onError(
      bi(
        60,
        a.loc
      )
    );
  }
  const { tag: n } = e, s = t.isCustomElement(n);
  if (n === "input" || n === "textarea" || n === "select" || s) {
    let a = C0, l = !1;
    if (n === "input" || s) {
      const u = Rn(e, "type");
      if (u) {
        if (u.type === 7)
          a = ud;
        else if (u.value)
          switch (u.value.content) {
            case "radio":
              a = x0;
              break;
            case "checkbox":
              a = S0;
              break;
            case "file":
              l = !0, t.onError(
                bi(
                  59,
                  r.loc
                )
              );
              break;
            default:
              ({}).NODE_ENV !== "production" && o();
              break;
          }
      } else
        tE(e) ? a = ud : {}.NODE_ENV !== "production" && o();
    } else
      n === "select" ? a = Q0 : {}.NODE_ENV !== "production" && o();
    l || (i.needRuntime = t.helper(a));
  } else
    t.onError(
      bi(
        57,
        r.loc
      )
    );
  return i.props = i.props.filter(
    (a) => !(a.key.type === 4 && a.key.content === "modelValue")
  ), i;
}, TT = /* @__PURE__ */ vt("passive,once,capture"), $T = /* @__PURE__ */ vt(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), RT = /* @__PURE__ */ vt("left,right"), $0 = /* @__PURE__ */ vt(
  "onkeyup,onkeydown,onkeypress",
  !0
), _T = (r, e, t, i) => {
  const o = [], n = [], s = [];
  for (let a = 0; a < e.length; a++) {
    const l = e[a];
    l === "native" && Ro(
      "COMPILER_V_ON_NATIVE",
      t,
      i
    ) || TT(l) ? s.push(l) : RT(l) ? Mt(r) ? $0(r.content) ? o.push(l) : n.push(l) : (o.push(l), n.push(l)) : $T(l) ? n.push(l) : o.push(l);
  }
  return {
    keyModifiers: o,
    nonKeyModifiers: n,
    eventOptionModifiers: s
  };
}, bm = (r, e) => Mt(r) && r.content.toLowerCase() === "onclick" ? de(e, !0) : r.type !== 4 ? xi([
  "(",
  r,
  `) === "onClick" ? "${e}" : (`,
  r,
  ")"
]) : r, DT = (r, e, t) => w0(r, e, t, (i) => {
  const { modifiers: o } = r;
  if (!o.length)
    return i;
  let { key: n, value: s } = i.props[0];
  const { keyModifiers: a, nonKeyModifiers: l, eventOptionModifiers: u } = _T(n, o, t, r.loc);
  if (l.includes("right") && (n = bm(n, "onContextmenu")), l.includes("middle") && (n = bm(n, "onMouseup")), l.length && (s = Fe(t.helper(P0), [
    s,
    JSON.stringify(l)
  ])), a.length && // if event name is dynamic, always wrap with keys guard
  (!Mt(n) || $0(n.content)) && (s = Fe(t.helper(k0), [
    s,
    JSON.stringify(a)
  ])), u.length) {
    const h = u.map(Bi).join("");
    n = Mt(n) ? de(`${n.content}${h}`, !0) : xi(["(", n, `) + "${h}"`]);
  }
  return {
    props: [Ve(n, s)]
  };
}), MT = (r, e, t) => {
  const { exp: i, loc: o } = r;
  return i || t.onError(
    bi(61, o)
  ), {
    props: [],
    needRuntime: t.helper(E0)
  };
}, XT = (r, e) => {
  if (r.type === 1 && r.tagType === 1 && e.isBuiltInComponent(r.tag) === gp)
    return () => {
      if (!r.children.length)
        return;
      R0(r) && e.onError(
        bi(
          62,
          {
            start: r.children[0].loc.start,
            end: r.children[r.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const i = r.children[0];
      if (i.type === 1)
        for (const o of i.props)
          o.type === 7 && o.name === "show" && r.props.push({
            type: 6,
            name: "persisted",
            value: void 0,
            loc: r.loc
          });
    };
};
function R0(r) {
  const e = r.children = r.children.filter(
    (i) => i.type !== 3 && !(i.type === 2 && !i.content.trim())
  ), t = e[0];
  return e.length !== 1 || t.type === 11 || t.type === 9 && t.branches.some(R0);
}
const AT = (r, e) => {
  r.type === 1 && r.tagType === 0 && (r.tag === "script" || r.tag === "style") && ({}.NODE_ENV !== "production" && e.onError(
    bi(
      63,
      r.loc
    )
  ), e.removeNode());
}, zT = [
  ST,
  ...{}.NODE_ENV !== "production" ? [XT] : []
], NT = {
  cloak: vT,
  html: PT,
  text: kT,
  model: ET,
  // override compiler-core
  on: DT,
  // override compiler-core
  show: MT
};
function VT(r, e = {}) {
  return OT(
    r,
    ue({}, xT, e, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        AT,
        ...zT,
        ...e.nodeTransforms || []
      ],
      directiveTransforms: ue(
        {},
        NT,
        e.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function ZT() {
  kw();
}
({}).NODE_ENV !== "production" && ZT();
const Om = /* @__PURE__ */ Object.create(null);
function LT(r, e) {
  if (!ne(r))
    if (r.nodeType)
      r = r.innerHTML;
    else
      return {}.NODE_ENV !== "production" && $("invalid template option: ", r), Le;
  const t = r, i = Om[t];
  if (i)
    return i;
  if (r[0] === "#") {
    const l = document.querySelector(r);
    ({}).NODE_ENV !== "production" && !l && $(`Template element not found or is empty: ${r}`), r = l ? l.innerHTML : "";
  }
  const o = ue(
    {
      hoistStatic: !0,
      onError: {}.NODE_ENV !== "production" ? s : void 0,
      onWarn: {}.NODE_ENV !== "production" ? (l) => s(l, !0) : Le
    },
    e
  );
  !o.isCustomElement && typeof customElements < "u" && (o.isCustomElement = (l) => !!customElements.get(l));
  const { code: n } = VT(r, o);
  function s(l, u = !1) {
    const h = u ? l.message : `Template compilation error: ${l.message}`, c = l.loc && qS(
      r,
      l.loc.start.offset,
      l.loc.end.offset
    );
    $(c ? `${h}
${c}` : h);
  }
  const a = new Function("Vue", n)(Vk);
  return a._rc = !0, Om[t] = a;
}
ww(LT);
var ja, WT = new Uint8Array(16);
function _0() {
  if (!ja && (ja = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !ja))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return ja(WT);
}
const IT = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function D0(r) {
  return typeof r == "string" && IT.test(r);
}
var it = [];
for (var Fh = 0; Fh < 256; ++Fh)
  it.push((Fh + 256).toString(16).substr(1));
function mp(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (it[r[e + 0]] + it[r[e + 1]] + it[r[e + 2]] + it[r[e + 3]] + "-" + it[r[e + 4]] + it[r[e + 5]] + "-" + it[r[e + 6]] + it[r[e + 7]] + "-" + it[r[e + 8]] + it[r[e + 9]] + "-" + it[r[e + 10]] + it[r[e + 11]] + it[r[e + 12]] + it[r[e + 13]] + it[r[e + 14]] + it[r[e + 15]]).toLowerCase();
  if (!D0(t))
    throw TypeError("Stringified UUID is invalid");
  return t;
}
var vm, Bh, qh = 0, Hh = 0;
function UT(r, e, t) {
  var i = e && t || 0, o = e || new Array(16);
  r = r || {};
  var n = r.node || vm, s = r.clockseq !== void 0 ? r.clockseq : Bh;
  if (n == null || s == null) {
    var a = r.random || (r.rng || _0)();
    n == null && (n = vm = [a[0] | 1, a[1], a[2], a[3], a[4], a[5]]), s == null && (s = Bh = (a[6] << 8 | a[7]) & 16383);
  }
  var l = r.msecs !== void 0 ? r.msecs : Date.now(), u = r.nsecs !== void 0 ? r.nsecs : Hh + 1, h = l - qh + (u - Hh) / 1e4;
  if (h < 0 && r.clockseq === void 0 && (s = s + 1 & 16383), (h < 0 || l > qh) && r.nsecs === void 0 && (u = 0), u >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  qh = l, Hh = u, Bh = s, l += 122192928e5;
  var c = ((l & 268435455) * 1e4 + u) % 4294967296;
  o[i++] = c >>> 24 & 255, o[i++] = c >>> 16 & 255, o[i++] = c >>> 8 & 255, o[i++] = c & 255;
  var d = l / 4294967296 * 1e4 & 268435455;
  o[i++] = d >>> 8 & 255, o[i++] = d & 255, o[i++] = d >>> 24 & 15 | 16, o[i++] = d >>> 16 & 255, o[i++] = s >>> 8 | 128, o[i++] = s & 255;
  for (var f = 0; f < 6; ++f)
    o[i + f] = n[f];
  return e || mp(o);
}
function YT(r) {
  if (!D0(r))
    throw TypeError("Invalid UUID");
  var e, t = new Uint8Array(16);
  return t[0] = (e = parseInt(r.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(r.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(r.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(r.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
function FT(r) {
  r = unescape(encodeURIComponent(r));
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t));
  return e;
}
var BT = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", qT = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function M0(r, e, t) {
  function i(o, n, s, a) {
    if (typeof o == "string" && (o = FT(o)), typeof n == "string" && (n = YT(n)), n.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var l = new Uint8Array(16 + o.length);
    if (l.set(n), l.set(o, n.length), l = t(l), l[6] = l[6] & 15 | e, l[8] = l[8] & 63 | 128, s) {
      a = a || 0;
      for (var u = 0; u < 16; ++u)
        s[a + u] = l[u];
      return s;
    }
    return mp(l);
  }
  try {
    i.name = r;
  } catch {
  }
  return i.DNS = BT, i.URL = qT, i;
}
function HT(r) {
  if (typeof r == "string") {
    var e = unescape(encodeURIComponent(r));
    r = new Uint8Array(e.length);
    for (var t = 0; t < e.length; ++t)
      r[t] = e.charCodeAt(t);
  }
  return jT(GT(KT(r), r.length * 8));
}
function jT(r) {
  for (var e = [], t = r.length * 32, i = "0123456789abcdef", o = 0; o < t; o += 8) {
    var n = r[o >> 5] >>> o % 32 & 255, s = parseInt(i.charAt(n >>> 4 & 15) + i.charAt(n & 15), 16);
    e.push(s);
  }
  return e;
}
function X0(r) {
  return (r + 64 >>> 9 << 4) + 14 + 1;
}
function GT(r, e) {
  r[e >> 5] |= 128 << e % 32, r[X0(e) - 1] = e;
  for (var t = 1732584193, i = -271733879, o = -1732584194, n = 271733878, s = 0; s < r.length; s += 16) {
    var a = t, l = i, u = o, h = n;
    t = ht(t, i, o, n, r[s], 7, -680876936), n = ht(n, t, i, o, r[s + 1], 12, -389564586), o = ht(o, n, t, i, r[s + 2], 17, 606105819), i = ht(i, o, n, t, r[s + 3], 22, -1044525330), t = ht(t, i, o, n, r[s + 4], 7, -176418897), n = ht(n, t, i, o, r[s + 5], 12, 1200080426), o = ht(o, n, t, i, r[s + 6], 17, -1473231341), i = ht(i, o, n, t, r[s + 7], 22, -45705983), t = ht(t, i, o, n, r[s + 8], 7, 1770035416), n = ht(n, t, i, o, r[s + 9], 12, -1958414417), o = ht(o, n, t, i, r[s + 10], 17, -42063), i = ht(i, o, n, t, r[s + 11], 22, -1990404162), t = ht(t, i, o, n, r[s + 12], 7, 1804603682), n = ht(n, t, i, o, r[s + 13], 12, -40341101), o = ht(o, n, t, i, r[s + 14], 17, -1502002290), i = ht(i, o, n, t, r[s + 15], 22, 1236535329), t = ct(t, i, o, n, r[s + 1], 5, -165796510), n = ct(n, t, i, o, r[s + 6], 9, -1069501632), o = ct(o, n, t, i, r[s + 11], 14, 643717713), i = ct(i, o, n, t, r[s], 20, -373897302), t = ct(t, i, o, n, r[s + 5], 5, -701558691), n = ct(n, t, i, o, r[s + 10], 9, 38016083), o = ct(o, n, t, i, r[s + 15], 14, -660478335), i = ct(i, o, n, t, r[s + 4], 20, -405537848), t = ct(t, i, o, n, r[s + 9], 5, 568446438), n = ct(n, t, i, o, r[s + 14], 9, -1019803690), o = ct(o, n, t, i, r[s + 3], 14, -187363961), i = ct(i, o, n, t, r[s + 8], 20, 1163531501), t = ct(t, i, o, n, r[s + 13], 5, -1444681467), n = ct(n, t, i, o, r[s + 2], 9, -51403784), o = ct(o, n, t, i, r[s + 7], 14, 1735328473), i = ct(i, o, n, t, r[s + 12], 20, -1926607734), t = dt(t, i, o, n, r[s + 5], 4, -378558), n = dt(n, t, i, o, r[s + 8], 11, -2022574463), o = dt(o, n, t, i, r[s + 11], 16, 1839030562), i = dt(i, o, n, t, r[s + 14], 23, -35309556), t = dt(t, i, o, n, r[s + 1], 4, -1530992060), n = dt(n, t, i, o, r[s + 4], 11, 1272893353), o = dt(o, n, t, i, r[s + 7], 16, -155497632), i = dt(i, o, n, t, r[s + 10], 23, -1094730640), t = dt(t, i, o, n, r[s + 13], 4, 681279174), n = dt(n, t, i, o, r[s], 11, -358537222), o = dt(o, n, t, i, r[s + 3], 16, -722521979), i = dt(i, o, n, t, r[s + 6], 23, 76029189), t = dt(t, i, o, n, r[s + 9], 4, -640364487), n = dt(n, t, i, o, r[s + 12], 11, -421815835), o = dt(o, n, t, i, r[s + 15], 16, 530742520), i = dt(i, o, n, t, r[s + 2], 23, -995338651), t = ft(t, i, o, n, r[s], 6, -198630844), n = ft(n, t, i, o, r[s + 7], 10, 1126891415), o = ft(o, n, t, i, r[s + 14], 15, -1416354905), i = ft(i, o, n, t, r[s + 5], 21, -57434055), t = ft(t, i, o, n, r[s + 12], 6, 1700485571), n = ft(n, t, i, o, r[s + 3], 10, -1894986606), o = ft(o, n, t, i, r[s + 10], 15, -1051523), i = ft(i, o, n, t, r[s + 1], 21, -2054922799), t = ft(t, i, o, n, r[s + 8], 6, 1873313359), n = ft(n, t, i, o, r[s + 15], 10, -30611744), o = ft(o, n, t, i, r[s + 6], 15, -1560198380), i = ft(i, o, n, t, r[s + 13], 21, 1309151649), t = ft(t, i, o, n, r[s + 4], 6, -145523070), n = ft(n, t, i, o, r[s + 11], 10, -1120210379), o = ft(o, n, t, i, r[s + 2], 15, 718787259), i = ft(i, o, n, t, r[s + 9], 21, -343485551), t = Er(t, a), i = Er(i, l), o = Er(o, u), n = Er(n, h);
  }
  return [t, i, o, n];
}
function KT(r) {
  if (r.length === 0)
    return [];
  for (var e = r.length * 8, t = new Uint32Array(X0(e)), i = 0; i < e; i += 8)
    t[i >> 5] |= (r[i / 8] & 255) << i % 32;
  return t;
}
function Er(r, e) {
  var t = (r & 65535) + (e & 65535), i = (r >> 16) + (e >> 16) + (t >> 16);
  return i << 16 | t & 65535;
}
function JT(r, e) {
  return r << e | r >>> 32 - e;
}
function uh(r, e, t, i, o, n) {
  return Er(JT(Er(Er(e, r), Er(i, n)), o), t);
}
function ht(r, e, t, i, o, n, s) {
  return uh(e & t | ~e & i, r, e, o, n, s);
}
function ct(r, e, t, i, o, n, s) {
  return uh(e & i | t & ~i, r, e, o, n, s);
}
function dt(r, e, t, i, o, n, s) {
  return uh(e ^ t ^ i, r, e, o, n, s);
}
function ft(r, e, t, i, o, n, s) {
  return uh(t ^ (e | ~i), r, e, o, n, s);
}
var e$ = M0("v3", 48, HT);
const t$ = e$;
function i$(r, e, t) {
  r = r || {};
  var i = r.random || (r.rng || _0)();
  if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, e) {
    t = t || 0;
    for (var o = 0; o < 16; ++o)
      e[t + o] = i[o];
    return e;
  }
  return mp(i);
}
function r$(r, e, t, i) {
  switch (r) {
    case 0:
      return e & t ^ ~e & i;
    case 1:
      return e ^ t ^ i;
    case 2:
      return e & t ^ e & i ^ t & i;
    case 3:
      return e ^ t ^ i;
  }
}
function jh(r, e) {
  return r << e | r >>> 32 - e;
}
function o$(r) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782], t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof r == "string") {
    var i = unescape(encodeURIComponent(r));
    r = [];
    for (var o = 0; o < i.length; ++o)
      r.push(i.charCodeAt(o));
  } else
    Array.isArray(r) || (r = Array.prototype.slice.call(r));
  r.push(128);
  for (var n = r.length / 4 + 2, s = Math.ceil(n / 16), a = new Array(s), l = 0; l < s; ++l) {
    for (var u = new Uint32Array(16), h = 0; h < 16; ++h)
      u[h] = r[l * 64 + h * 4] << 24 | r[l * 64 + h * 4 + 1] << 16 | r[l * 64 + h * 4 + 2] << 8 | r[l * 64 + h * 4 + 3];
    a[l] = u;
  }
  a[s - 1][14] = (r.length - 1) * 8 / Math.pow(2, 32), a[s - 1][14] = Math.floor(a[s - 1][14]), a[s - 1][15] = (r.length - 1) * 8 & 4294967295;
  for (var c = 0; c < s; ++c) {
    for (var d = new Uint32Array(80), f = 0; f < 16; ++f)
      d[f] = a[c][f];
    for (var p = 16; p < 80; ++p)
      d[p] = jh(d[p - 3] ^ d[p - 8] ^ d[p - 14] ^ d[p - 16], 1);
    for (var g = t[0], b = t[1], m = t[2], v = t[3], S = t[4], y = 0; y < 80; ++y) {
      var x = Math.floor(y / 20), P = jh(g, 5) + r$(x, b, m, v) + S + e[x] + d[y] >>> 0;
      S = v, v = m, m = jh(b, 30) >>> 0, b = g, g = P;
    }
    t[0] = t[0] + g >>> 0, t[1] = t[1] + b >>> 0, t[2] = t[2] + m >>> 0, t[3] = t[3] + v >>> 0, t[4] = t[4] + S >>> 0;
  }
  return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255];
}
var n$ = M0("v5", 80, o$);
const s$ = n$;
var A0 = {
  v1: UT,
  v3: t$,
  v4: i$,
  v5: s$
};
const a$ = { class: "ns-sandbox-box" }, l$ = ["src", "id", "name", "sandbox"], u$ = /* @__PURE__ */ to({
  __name: "sandbox",
  props: {
    url: {
      type: String,
      default: ""
    },
    limit: {
      // 限制条件, 默认只限制顶级内容控制
      type: String,
      default: "allow-same-origin allow-scripts allow-forms"
    }
  },
  emits: ["name", "loaded", "change"],
  setup(r, { expose: e, emit: t }) {
    const i = r, o = gt(), n = gt(A0.v4()), s = gt(!1), a = gt(), l = gt(!0);
    function u() {
      if (!o.value) {
        setTimeout(() => {
          u();
        }, 100);
        return;
      }
      o.value.onload = function(d) {
        Ls(() => {
          t("loaded", i.url);
        });
      };
    }
    function h(d, f) {
      !s.value || !a.value || a.value.on(d, f);
    }
    function c(d, f) {
      return !s.value || !a.value ? Promise.reject() : a.value.send(d, f);
    }
    return yi(() => i.url, (d, f) => {
      d && (f || (l.value = !1, Ls(() => {
        l.value = !0;
      })));
    }, {
      immediate: !0
    }), io(() => {
      u(), t("name", n.value);
    }), e({
      on: h,
      send: c
    }), (d, f) => (et(), Fr("div", a$, [
      r.url && l.value ? (et(), Fr("iframe", {
        key: 0,
        src: r.url,
        id: n.value,
        name: n.value,
        ref_key: "RefIframeBox",
        ref: o,
        sandbox: r.limit.toLocaleLowerCase() === "all" ? "" : r.limit
      }, null, 8, l$)) : lo("", !0)
    ]));
  }
}), h$ = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box;padding:0}iframe{width:100%;height:100%;overflow:hidden;border:0}
`, Sa = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [i, o] of e)
    t[i] = o;
  return t;
}, c$ = /* @__PURE__ */ Sa(u$, [["styles", [h$]]]), d$ = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: !1,
    panes: [],
    touch: {
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null
    },
    splitterTaps: {
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    // Indexed panes by `uid` of Pane components for fast lookup.
    // Every time a pane is destroyed this index is recomputed.
    indexedPanes() {
      return this.panes.reduce((r, e) => (r[e.id] = e) && r, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((r) => {
        r.update && r.update({
          // Panes are indexed by Pane component uid, as they might be inserted at different index.
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[r.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(r, e) {
      this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = e;
    },
    onMouseMove(r) {
      this.touch.mouseDown && (r.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(r)), this.$emit("resize", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((r) => ({ min: r.min, max: r.max, size: r.size }))), this.touch.mouseDown = !1, setTimeout(() => {
        this.touch.dragging = !1, this.unbindEvents();
      }, 100);
    },
    // If touch device, detect double tap manually (2 taps separated by less than 500ms).
    onSplitterClick(r, e) {
      "ontouchstart" in window && (r.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === e ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(r, e), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = e, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[e]);
    },
    // On splitter dbl click or dbl tap maximize this pane.
    onSplitterDblClick(r, e) {
      let t = 0;
      this.panes = this.panes.map((i, o) => (i.size = o === e ? i.max : i.min, o !== e && (t += i.min), i)), this.panes[e].size -= t, this.$emit("pane-maximize", this.panes[e]), this.$emit("resized", this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })));
    },
    onPaneClick(r, e) {
      this.$emit("pane-click", this.indexedPanes[e]);
    },
    // Get the cursor position relative to the splitpane container.
    getCurrentMouseDrag(r) {
      const e = this.container.getBoundingClientRect(), { clientX: t, clientY: i } = "ontouchstart" in window && r.touches ? r.touches[0] : r;
      return {
        x: t - e.left,
        y: i - e.top
      };
    },
    // Returns the drag percentage of the splitter relative to the 2 panes it's inbetween.
    // if the sum of size of the 2 cells is 60%, the dragPercentage range will be 0 to 100% of this 60%.
    getCurrentDragPercentage(r) {
      r = r[this.horizontal ? "y" : "x"];
      const e = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (r = e - r), r * 100 / e;
    },
    calculatePanesSize(r) {
      const e = this.touch.activeSplitter;
      let t = {
        prevPanesSize: this.sumPrevPanesSize(e),
        nextPanesSize: this.sumNextPanesSize(e),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const i = 0 + (this.pushOtherPanes ? 0 : t.prevPanesSize), o = 100 - (this.pushOtherPanes ? 0 : t.nextPanesSize), n = Math.max(Math.min(this.getCurrentDragPercentage(r), o), i);
      let s = [e, e + 1], a = this.panes[s[0]] || null, l = this.panes[s[1]] || null;
      const u = a.max < 100 && n >= a.max + t.prevPanesSize, h = l.max < 100 && n <= 100 - (l.max + this.sumNextPanesSize(e + 1));
      if (u || h) {
        u ? (a.size = a.max, l.size = Math.max(100 - a.max - t.prevPanesSize - t.nextPanesSize, 0)) : (a.size = Math.max(100 - l.max - t.prevPanesSize - this.sumNextPanesSize(e + 1), 0), l.size = l.max);
        return;
      }
      if (this.pushOtherPanes) {
        const c = this.doPushOtherPanes(t, n);
        if (!c)
          return;
        ({ sums: t, panesToResize: s } = c), a = this.panes[s[0]] || null, l = this.panes[s[1]] || null;
      }
      a !== null && (a.size = Math.min(Math.max(n - t.prevPanesSize - t.prevReachedMinPanes, a.min), a.max)), l !== null && (l.size = Math.min(Math.max(100 - n - t.nextPanesSize - t.nextReachedMinPanes, l.min), l.max));
    },
    doPushOtherPanes(r, e) {
      const t = this.touch.activeSplitter, i = [t, t + 1];
      return e < r.prevPanesSize + this.panes[i[0]].min && (i[0] = this.findPrevExpandedPane(t).index, r.prevReachedMinPanes = 0, i[0] < t && this.panes.forEach((o, n) => {
        n > i[0] && n <= t && (o.size = o.min, r.prevReachedMinPanes += o.min);
      }), r.prevPanesSize = this.sumPrevPanesSize(i[0]), i[0] === void 0) ? (r.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((o, n) => {
        n > 0 && n <= t && (o.size = o.min, r.prevReachedMinPanes += o.min);
      }), this.panes[i[1]].size = 100 - r.prevReachedMinPanes - this.panes[0].min - r.prevPanesSize - r.nextPanesSize, null) : e > 100 - r.nextPanesSize - this.panes[i[1]].min && (i[1] = this.findNextExpandedPane(t).index, r.nextReachedMinPanes = 0, i[1] > t + 1 && this.panes.forEach((o, n) => {
        n > t && n < i[1] && (o.size = o.min, r.nextReachedMinPanes += o.min);
      }), r.nextPanesSize = this.sumNextPanesSize(i[1] - 1), i[1] === void 0) ? (r.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((o, n) => {
        n < this.panesCount - 1 && n >= t + 1 && (o.size = o.min, r.nextReachedMinPanes += o.min);
      }), this.panes[i[0]].size = 100 - r.prevPanesSize - r.nextReachedMinPanes - this.panes[this.panesCount - 1].min - r.nextPanesSize, null) : { sums: r, panesToResize: i };
    },
    sumPrevPanesSize(r) {
      return this.panes.reduce((e, t, i) => e + (i < r ? t.size : 0), 0);
    },
    sumNextPanesSize(r) {
      return this.panes.reduce((e, t, i) => e + (i > r + 1 ? t.size : 0), 0);
    },
    // Return the previous pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findPrevExpandedPane(r) {
      return [...this.panes].reverse().find((t) => t.index < r && t.size > t.min) || {};
    },
    // Return the next pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findNextExpandedPane(r) {
      return this.panes.find((t) => t.index > r + 1 && t.size > t.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((e) => {
        const t = e.classList.contains("splitpanes__pane"), i = e.classList.contains("splitpanes__splitter");
        !t && !i && console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed.");
      });
    },
    addSplitter(r, e, t = !1) {
      const i = r - 1, o = document.createElement("div");
      o.classList.add("splitpanes__splitter"), t || (o.onmousedown = (n) => this.onMouseDown(n, i), typeof window < "u" && "ontouchstart" in window && (o.ontouchstart = (n) => this.onMouseDown(n, i)), o.onclick = (n) => this.onSplitterClick(n, i + 1)), this.dblClickSplitter && (o.ondblclick = (n) => this.onSplitterDblClick(n, i + 1)), e.parentNode.insertBefore(o, e);
    },
    removeSplitter(r) {
      r.onmousedown = void 0, r.onclick = void 0, r.ondblclick = void 0, r.parentNode.removeChild(r);
    },
    redoSplitters() {
      const r = Array.from(this.container.children);
      r.forEach((t) => {
        t.className.includes("splitpanes__splitter") && this.removeSplitter(t);
      });
      let e = 0;
      r.forEach((t) => {
        t.className.includes("splitpanes__pane") && (!e && this.firstSplitter ? this.addSplitter(e, t, !0) : e && this.addSplitter(e, t), e++);
      });
    },
    // Called by Pane component on programmatic resize.
    requestUpdate({ target: r, ...e }) {
      const t = this.indexedPanes[r._.uid];
      Object.entries(e).forEach(([i, o]) => t[i] = o);
    },
    onPaneAdd(r) {
      let e = -1;
      Array.from(r.$el.parentNode.children).some((o) => (o.className.includes("splitpanes__pane") && e++, o === r.$el));
      const t = parseFloat(r.minSize), i = parseFloat(r.maxSize);
      this.panes.splice(e, 0, {
        id: r._.uid,
        index: e,
        min: isNaN(t) ? 0 : t,
        max: isNaN(i) ? 100 : i,
        size: r.size === null ? null : parseFloat(r.size),
        givenSize: r.size,
        update: r.update
      }), this.panes.forEach((o, n) => o.index = n), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[e] }), this.$emit("pane-add", { index: e, panes: this.panes.map((o) => ({ min: o.min, max: o.max, size: o.size })) });
      });
    },
    onPaneRemove(r) {
      const e = this.panes.findIndex((i) => i.id === r._.uid), t = this.panes.splice(e, 1)[0];
      this.panes.forEach((i, o) => i.index = o), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...t, index: e } }), this.$emit("pane-remove", { removed: t, panes: this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })) });
      });
    },
    resetPaneSizes(r = {}) {
      !r.addedPane && !r.removedPane ? this.initialPanesSizing() : this.panes.some((e) => e.givenSize !== null || e.min || e.max < 100) ? this.equalizeAfterAddOrRemove(r) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size })));
    },
    equalize() {
      const r = 100 / this.panesCount;
      let e = 0;
      const t = [], i = [];
      this.panes.forEach((o) => {
        o.size = Math.max(Math.min(r, o.max), o.min), e -= o.size, o.size >= o.max && t.push(o.id), o.size <= o.min && i.push(o.id);
      }), e > 0.1 && this.readjustSizes(e, t, i);
    },
    initialPanesSizing() {
      let r = 100;
      const e = [], t = [];
      let i = 0;
      this.panes.forEach((n) => {
        r -= n.size, n.size !== null && i++, n.size >= n.max && e.push(n.id), n.size <= n.min && t.push(n.id);
      });
      let o = 100;
      r > 0.1 && (this.panes.forEach((n) => {
        n.size === null && (n.size = Math.max(Math.min(r / (this.panesCount - i), n.max), n.min)), o -= n.size;
      }), o > 0.1 && this.readjustSizes(r, e, t));
    },
    equalizeAfterAddOrRemove({ addedPane: r, removedPane: e } = {}) {
      let t = 100 / this.panesCount, i = 0;
      const o = [], n = [];
      r && r.givenSize !== null && (t = (100 - r.givenSize) / (this.panesCount - 1)), this.panes.forEach((s) => {
        i -= s.size, s.size >= s.max && o.push(s.id), s.size <= s.min && n.push(s.id);
      }), !(Math.abs(i) < 0.1) && (this.panes.forEach((s) => {
        r && r.givenSize !== null && r.id === s.id || (s.size = Math.max(Math.min(t, s.max), s.min)), i -= s.size, s.size >= s.max && o.push(s.id), s.size <= s.min && n.push(s.id);
      }), i > 0.1 && this.readjustSizes(i, o, n));
    },
    /* recalculatePaneSizes ({ addedPane, removedPane } = {}) {
          let leftToAllocate = 100
          let equalSpaceToAllocate = leftToAllocate / this.panesCount
          let ungrowable = []
          let unshrinkable = []
    
          // When adding a pane with no size, apply min-size if defined otherwise divide another pane
          // (next or prev) in 2.
          // if (addedPane && addedPane.size === null) {
          //   if (addedPane.min) addedPane.size = addedPane.min
          //   else {
          //     const paneToDivide = this.panes[addedPane.index + 1] || this.panes[addedPane.index - 1]
          //     if (paneToDivide) {
          //       // @todo: Dividing that pane in 2 could be incorrect if becoming lower than its min size.
          //       addedPane.size = paneToDivide.size / 2
          //       paneToDivide.size /= 2
          //     }
          //   }
          // }
    
          this.panes.forEach((pane, i) => {
            // Added pane - reduce the size of the next pane.
            if (addedPane && addedPane.index + 1 === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Removed pane - increase the size of the next pane.
            else if (removedPane && removedPane.index === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Initial load and on demand recalculation.
            else if (!addedPane && !removedPane && pane.size === null) {
              pane.size = Math.max(Math.min(equalSpaceToAllocate, pane.max), pane.min)
            }
    
            leftToAllocate -= pane.size
    
            if (pane.size >= pane.max) ungrowable.push(pane.id)
            if (pane.size <= pane.min) unshrinkable.push(pane.id)
          })
    
          // Do one more loop to adjust sizes if still wrong.
          // > 0.1: Prevent maths rounding issues due to bytes.
          if (Math.abs(leftToAllocate) > 0.1) this.readjustSizes(leftToAllocate, ungrowable, unshrinkable)
        }, */
    // Second loop to adjust sizes now that we know more about the panes constraints.
    readjustSizes(r, e, t) {
      let i;
      r > 0 ? i = r / (this.panesCount - e.length) : i = r / (this.panesCount - t.length), this.panes.forEach((o, n) => {
        if (r > 0 && !e.includes(o.id)) {
          const s = Math.max(Math.min(o.size + i, o.max), o.min), a = s - o.size;
          r -= a, o.size = s;
        } else if (!t.includes(o.id)) {
          const s = Math.max(Math.min(o.size + i, o.max), o.min), a = s - o.size;
          r -= a, o.size = s;
        }
        o.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[o.id].size}%`
        });
      }), Math.abs(r) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
    /* distributeEmptySpace () {
          let growablePanes = []
          let collapsedPanesCount = 0
          let growableAmount = 0 // Total of how much the current panes can grow to fill blank space.
          let spaceToDistribute = 100 - this.panes.reduce((sum, pane) => (sum += pane.size) && sum, 0)
          // Do a first loop to determine if we can distribute the new blank space between all the
          // expandedPanes, without expanding the collapsed ones.
          this.panes.forEach(pane => {
            if (pane.size < pane.max) growablePanes.push(pane)
    
            if (!pane.size) collapsedPanesCount++
            else growableAmount += pane.max - pane.size
          })
    
          // If the blank space to distribute is too great for the expanded panes, also expand collapsed ones.
          let expandCollapsedPanes = growableAmount < spaceToDistribute
    
          // New space to distribute equally.
          let growablePanesCount = (growablePanes.length - (expandCollapsedPanes ? 0 : collapsedPanesCount))
          let equalSpaceToDistribute = spaceToDistribute / growablePanesCount
          // if (growablePanesCount === 1) equalSpace = 100 / this.panesCount
          let spaceLeftToDistribute = spaceToDistribute
    
          // Now add the equalSpaceToDistribute to each pane size accordingly.
          growablePanes.forEach(pane => {
            if (pane.size < pane.max && (pane.size || (!pane.size && expandCollapsedPanes))) {
              const newSize = Math.min(pane.size + equalSpaceToDistribute, pane.max)
              let allocatedSpace = (newSize - pane.size)
              spaceLeftToDistribute -= allocatedSpace
              pane.size = newSize
              // If the equalSpaceToDistribute is not fully added to the current pane, distribute the remainder
              // to the next panes.
              // Also fix decimal issue due to bites - E.g. calculating 8.33 and getting 8.3299999999999
              if (equalSpaceToDistribute - allocatedSpace > 0.1) equalSpaceToDistribute = spaceLeftToDistribute / (--growablePanesCount)
            }
          })
    
          /* Disabled otherwise will show up on hot reload.
          // if there is still space to allocate show warning message.
          if (this.panesCount && ~~spaceLeftToDistribute) {
            // eslint-disable-next-line no-console
            console.warn('Splitpanes: Could not distribute all the empty space between panes due to their constraints.')
          } *\/
    
          this.$emit('resized', this.panes.map(pane => ({ min: pane.min, max: pane.max, size: pane.size })))
        } */
  },
  watch: {
    panes: {
      // Every time a pane is updated, update the panes accordingly.
      deep: !0,
      immediate: !1,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(r) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((t, i) => {
        t.ondblclick = r ? (o) => this.onSplitterDblClick(o, i) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = !1;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = !0;
  },
  render() {
    return ro(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          "default-theme",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
}, f$ = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    // Called from the splitpanes component.
    update(r) {
      this.style = r;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(r) {
      this.requestUpdate({ target: this, size: r });
    },
    minSizeNumber(r) {
      this.requestUpdate({ target: this, min: r });
    },
    maxSizeNumber(r) {
      this.requestUpdate({ target: this, max: r });
    }
  }
};
function p$(r, e, t, i, o, n) {
  return et(), Fr("div", {
    class: "splitpanes__pane",
    onClick: e[0] || (e[0] = (s) => n.onPaneClick(s, r._.uid)),
    style: Yn(r.style)
  }, [
    Nf(r.$slots, "default")
  ], 4);
}
const g$ = /* @__PURE__ */ Sa(f$, [["render", p$]]), m$ = { class: "pane-box" }, b$ = /* @__PURE__ */ to({
  __name: "splitpane",
  props: {
    keys: {
      type: Array,
      default: () => []
    },
    size: {
      type: Array,
      default: () => [25, 25, 25, 25]
    },
    minSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    maxSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  setup(r, { emit: e }) {
    return (t, i) => (et(), Xi(d$, {
      onReady: i[0] || (i[0] = (o) => e("ready", o)),
      onResize: i[1] || (i[1] = (o) => e("resize", o)),
      onResized: i[2] || (i[2] = (o) => e("resized", o)),
      onPaneClick: i[3] || (i[3] = (o) => e("pane-click", o)),
      onPaneMaximize: i[4] || (i[4] = (o) => e("pane-maximize", o)),
      onPaneAdd: i[5] || (i[5] = (o) => e("pane-add", o)),
      onPaneRemove: i[6] || (i[6] = (o) => e("pane-remove", o)),
      onSplitterClick: i[7] || (i[7] = (o) => e("splitter-click", o)),
      horizontal: r.horizontal,
      pushOtherPanes: r.pushOtherPanes,
      dblClickSplitter: r.dblClickSplitter,
      rtl: r.rtl,
      firstSplitter: r.firstSplitter
    }, {
      default: Us(() => [
        (et(!0), Fr(je, null, qv(r.keys, (o, n) => (et(), Xi(g$, {
          size: r.size[n] ? r.size[n] : 10,
          "min-size": r.minSize[n] ? r.minSize[n] : 0,
          "max-size": r.maxSize[n] ? r.maxSize[n] : 100
        }, {
          default: Us(() => [
            Bn("div", m$, [
              Nf(t.$slots, o)
            ])
          ]),
          _: 2
        }, 1032, ["size", "min-size", "max-size"]))), 256))
      ]),
      _: 3
    }, 8, ["horizontal", "pushOtherPanes", "dblClickSplitter", "rtl", "firstSplitter"]));
  }
}), O$ = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.splitpanes{display:flex;width:100%;height:100%}.splitpanes--vertical{flex-direction:row}.splitpanes--horizontal{flex-direction:column}.splitpanes--dragging *{user-select:none}.splitpanes__pane{width:100%;height:100%;overflow:hidden}.splitpanes--vertical .splitpanes__pane{transition:width .2s ease-out}.splitpanes--horizontal .splitpanes__pane{transition:height .2s ease-out}.splitpanes--dragging .splitpanes__pane{transition:none}.splitpanes__splitter{touch-action:none}.splitpanes--vertical>.splitpanes__splitter{min-width:1px;cursor:col-resize}.splitpanes--horizontal>.splitpanes__splitter{min-height:1px;cursor:row-resize}.splitpanes.default-theme .splitpanes__pane{background-color:#f2f2f2}.splitpanes.default-theme .splitpanes__splitter{background-color:#fff;box-sizing:border-box;position:relative;flex-shrink:0}.splitpanes.default-theme .splitpanes__splitter:before,.splitpanes.default-theme .splitpanes__splitter:after{content:"";position:absolute;top:50%;left:50%;background-color:#00000026;transition:background-color .3s}.splitpanes.default-theme .splitpanes__splitter:hover:before,.splitpanes.default-theme .splitpanes__splitter:hover:after{background-color:#00000040}.splitpanes.default-theme .splitpanes__splitter:first-child{cursor:auto}.default-theme.splitpanes .splitpanes .splitpanes__splitter{z-index:1}.default-theme.splitpanes--vertical>.splitpanes__splitter,.default-theme .splitpanes--vertical>.splitpanes__splitter{width:7px;border-left:1px solid #eee;margin-left:-1px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{transform:translateY(-50%);width:1px;height:30px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:before{margin-left:-2px}.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{margin-left:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter,.default-theme .splitpanes--horizontal>.splitpanes__splitter{height:7px;border-top:1px solid #eee;margin-top:-1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{transform:translate(-50%);width:30px;height:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before{margin-top:-2px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{margin-top:1px}
`, v$ = `.pane-box{height:100%;width:100%;background-color:#fff;box-sizing:border-box;overflow:hidden;overflow-y:auto;overflow-x:auto;border-radius:4px}.splitpanes__splitter{background-color:#f0f0f0!important}
`, w$ = /* @__PURE__ */ Sa(b$, [["styles", [O$, v$]]]);
class ve {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    let o = [];
    return this.decompose(
      0,
      e,
      o,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      o,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      o,
      1
      /* Open.From */
    ), Ai.from(o, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    let i = [];
    return this.decompose(e, t, i, 0), Ai.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), o = new Ds(this), n = new Ds(e);
    for (let s = t, a = t; ; ) {
      if (o.next(s), n.next(s), s = 0, o.lineBreak != n.lineBreak || o.done != n.done || o.value != n.value)
        return !1;
      if (a += o.value.length, o.done || a >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new Ds(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new z0(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let o = this.line(e).from;
      i = this.iterRange(o, Math.max(o, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new N0(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? ve.empty : e.length <= 32 ? new Ze(e) : Ai.from(Ze.split(e, []));
  }
}
class Ze extends ve {
  constructor(e, t = y$(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, o) {
    for (let n = 0; ; n++) {
      let s = this.text[n], a = o + s.length;
      if ((t ? i : a) >= e)
        return new x$(o, a, i, s);
      o = a + 1, i++;
    }
  }
  decompose(e, t, i, o) {
    let n = e <= 0 && t >= this.length ? this : new Ze(wm(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (o & 1) {
      let s = i.pop(), a = xl(n.text, s.text.slice(), 0, n.length);
      if (a.length <= 32)
        i.push(new Ze(a, s.length + n.length));
      else {
        let l = a.length >> 1;
        i.push(new Ze(a.slice(0, l)), new Ze(a.slice(l)));
      }
    } else
      i.push(n);
  }
  replace(e, t, i) {
    if (!(i instanceof Ze))
      return super.replace(e, t, i);
    let o = xl(this.text, xl(i.text, wm(this.text, 0, e)), t), n = this.length + i.length - (t - e);
    return o.length <= 32 ? new Ze(o, n) : Ai.from(Ze.split(o, []), n);
  }
  sliceString(e, t = this.length, i = `
`) {
    let o = "";
    for (let n = 0, s = 0; n <= t && s < this.text.length; s++) {
      let a = this.text[s], l = n + a.length;
      n > e && s && (o += i), e < l && t > n && (o += a.slice(Math.max(0, e - n), t - n)), n = l + 1;
    }
    return o;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], o = -1;
    for (let n of e)
      i.push(n), o += n.length + 1, i.length == 32 && (t.push(new Ze(i, o)), i = [], o = -1);
    return o > -1 && t.push(new Ze(i, o)), t;
  }
}
class Ai extends ve {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, o) {
    for (let n = 0; ; n++) {
      let s = this.children[n], a = o + s.length, l = i + s.lines - 1;
      if ((t ? l : a) >= e)
        return s.lineInner(e, t, i, o);
      o = a + 1, i = l + 1;
    }
  }
  decompose(e, t, i, o) {
    for (let n = 0, s = 0; s <= t && n < this.children.length; n++) {
      let a = this.children[n], l = s + a.length;
      if (e <= l && t >= s) {
        let u = o & ((s <= e ? 1 : 0) | (l >= t ? 2 : 0));
        s >= e && l <= t && !u ? i.push(a) : a.decompose(e - s, t - s, i, u);
      }
      s = l + 1;
    }
  }
  replace(e, t, i) {
    if (i.lines < this.lines)
      for (let o = 0, n = 0; o < this.children.length; o++) {
        let s = this.children[o], a = n + s.length;
        if (e >= n && t <= a) {
          let l = s.replace(e - n, t - n, i), u = this.lines - s.lines + l.lines;
          if (l.lines < u >> 5 - 1 && l.lines > u >> 5 + 1) {
            let h = this.children.slice();
            return h[o] = l, new Ai(h, this.length - (t - e) + i.length);
          }
          return super.replace(n, a, l);
        }
        n = a + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    let o = "";
    for (let n = 0, s = 0; n < this.children.length && s <= t; n++) {
      let a = this.children[n], l = s + a.length;
      s > e && n && (o += i), e < l && t > s && (o += a.sliceString(e - s, t - s, i)), s = l + 1;
    }
    return o;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof Ai))
      return 0;
    let i = 0, [o, n, s, a] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; o += t, n += t) {
      if (o == s || n == a)
        return i;
      let l = this.children[o], u = e.children[n];
      if (l != u)
        return i + l.scanIdentical(u, t);
      i += l.length + 1;
    }
  }
  static from(e, t = e.reduce((i, o) => i + o.length + 1, -1)) {
    let i = 0;
    for (let f of e)
      i += f.lines;
    if (i < 32) {
      let f = [];
      for (let p of e)
        p.flatten(f);
      return new Ze(f, t);
    }
    let o = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), n = o << 1, s = o >> 1, a = [], l = 0, u = -1, h = [];
    function c(f) {
      let p;
      if (f.lines > n && f instanceof Ai)
        for (let g of f.children)
          c(g);
      else
        f.lines > s && (l > s || !l) ? (d(), a.push(f)) : f instanceof Ze && l && (p = h[h.length - 1]) instanceof Ze && f.lines + p.lines <= 32 ? (l += f.lines, u += f.length + 1, h[h.length - 1] = new Ze(p.text.concat(f.text), p.length + 1 + f.length)) : (l + f.lines > o && d(), l += f.lines, u += f.length + 1, h.push(f));
    }
    function d() {
      l != 0 && (a.push(h.length == 1 ? h[0] : Ai.from(h, u)), u = -1, l = h.length = 0);
    }
    for (let f of e)
      c(f);
    return d(), a.length == 1 ? a[0] : new Ai(a, t);
  }
}
ve.empty = /* @__PURE__ */ new Ze([""], 0);
function y$(r) {
  let e = -1;
  for (let t of r)
    e += t.length + 1;
  return e;
}
function xl(r, e, t = 0, i = 1e9) {
  for (let o = 0, n = 0, s = !0; n < r.length && o <= i; n++) {
    let a = r[n], l = o + a.length;
    l >= t && (l > i && (a = a.slice(0, i - o)), o < t && (a = a.slice(t - o)), s ? (e[e.length - 1] += a, s = !1) : e.push(a)), o = l + 1;
  }
  return e;
}
function wm(r, e, t) {
  return xl(r, [""], e, t);
}
class Ds {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof Ze ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, o = this.nodes[i], n = this.offsets[i], s = n >> 1, a = o instanceof Ze ? o.text.length : o.children.length;
      if (s == (t > 0 ? a : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((n & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (o instanceof Ze) {
        let l = o.text[s + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = o.children[s + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof Ze ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class z0 {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new Ds(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: o } = this.cursor.next(e);
    return this.pos += (o.length + e) * t, this.value = o.length <= i ? o : t < 0 ? o.slice(o.length - i) : o.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class N0 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: o } = this.inner.next(e);
    return t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = o, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (ve.prototype[Symbol.iterator] = function() {
  return this.iter();
}, Ds.prototype[Symbol.iterator] = z0.prototype[Symbol.iterator] = N0.prototype[Symbol.iterator] = function() {
  return this;
});
class x$ {
  /**
  @internal
  */
  constructor(e, t, i, o) {
    this.from = e, this.to = t, this.number = i, this.text = o;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
let mn = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((r) => r ? parseInt(r, 36) : 1);
for (let r = 1; r < mn.length; r++)
  mn[r] += mn[r - 1];
function S$(r) {
  for (let e = 1; e < mn.length; e += 2)
    if (mn[e] > r)
      return mn[e - 1] <= r;
  return !1;
}
function ym(r) {
  return r >= 127462 && r <= 127487;
}
const xm = 8205;
function Pt(r, e, t = !0, i = !0) {
  return (t ? V0 : C$)(r, e, i);
}
function V0(r, e, t) {
  if (e == r.length)
    return e;
  e && Z0(r.charCodeAt(e)) && L0(r.charCodeAt(e - 1)) && e--;
  let i = nt(r, e);
  for (e += ri(i); e < r.length; ) {
    let o = nt(r, e);
    if (i == xm || o == xm || t && S$(o))
      e += ri(o), i = o;
    else if (ym(o)) {
      let n = 0, s = e - 2;
      for (; s >= 0 && ym(nt(r, s)); )
        n++, s -= 2;
      if (n % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function C$(r, e, t) {
  for (; e > 0; ) {
    let i = V0(r, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function Z0(r) {
  return r >= 56320 && r < 57344;
}
function L0(r) {
  return r >= 55296 && r < 56320;
}
function nt(r, e) {
  let t = r.charCodeAt(e);
  if (!L0(t) || e + 1 == r.length)
    return t;
  let i = r.charCodeAt(e + 1);
  return Z0(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function bp(r) {
  return r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
}
function ri(r) {
  return r < 65536 ? 1 : 2;
}
const hd = /\r\n?|\n/;
var at = /* @__PURE__ */ function(r) {
  return r[r.Simple = 0] = "Simple", r[r.TrackDel = 1] = "TrackDel", r[r.TrackBefore = 2] = "TrackBefore", r[r.TrackAfter = 3] = "TrackAfter", r;
}(at || (at = {}));
class Ii {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, o = 0; t < this.sections.length; ) {
      let n = this.sections[t++], s = this.sections[t++];
      s < 0 ? (e(i, o, n), o += n) : o += s, i += n;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    cd(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], o = this.sections[t++];
      o < 0 ? e.push(i, o) : e.push(o, i);
    }
    return new Ii(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : W0(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : dd(this, e, t);
  }
  mapPos(e, t = -1, i = at.Simple) {
    let o = 0, n = 0;
    for (let s = 0; s < this.sections.length; ) {
      let a = this.sections[s++], l = this.sections[s++], u = o + a;
      if (l < 0) {
        if (u > e)
          return n + (e - o);
        n += a;
      } else {
        if (i != at.Simple && u >= e && (i == at.TrackDel && o < e && u > e || i == at.TrackBefore && o < e || i == at.TrackAfter && u > e))
          return null;
        if (u > e || u == e && t < 0 && !a)
          return e == o || t < 0 ? n : n + l;
        n += l;
      }
      o = u;
    }
    if (e > o)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${o}`);
    return n;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, o = 0; i < this.sections.length && o <= t; ) {
      let n = this.sections[i++], s = this.sections[i++], a = o + n;
      if (s >= 0 && o <= t && a >= e)
        return o < e && a > t ? "cover" : !0;
      o = a;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], o = this.sections[t++];
      e += (e ? " " : "") + i + (o >= 0 ? ":" + o : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Ii(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Ii(e);
  }
}
class He extends Ii {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return cd(this, (t, i, o, n, s) => e = e.replace(o, o + (i - t), s), !1), e;
  }
  mapDesc(e, t = !1) {
    return dd(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let o = 0, n = 0; o < t.length; o += 2) {
      let s = t[o], a = t[o + 1];
      if (a >= 0) {
        t[o] = a, t[o + 1] = s;
        let l = o >> 1;
        for (; i.length < l; )
          i.push(ve.empty);
        i.push(s ? e.slice(n, n + s) : ve.empty);
      }
      n += s;
    }
    return new He(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA` → `docB` and `other` represents `docB` → `docC`, the
  returned value will represent the change `docA` → `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : W0(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : dd(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    cd(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Ii.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], o = [], n = new ea(this);
    e:
      for (let s = 0, a = 0; ; ) {
        let l = s == e.length ? 1e9 : e[s++];
        for (; a < l || a == l && n.len == 0; ) {
          if (n.done)
            break e;
          let h = Math.min(n.len, l - a);
          pt(o, h, -1);
          let c = n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0;
          pt(t, h, c), c > 0 && Tr(i, t, n.text), n.forward(h), a += h;
        }
        let u = e[s++];
        for (; a < u; ) {
          if (n.done)
            break e;
          let h = Math.min(n.len, u - a);
          pt(t, h, -1), pt(o, h, n.ins == -1 ? -1 : n.off == 0 ? n.ins : 0), n.forward(h), a += h;
        }
      }
    return {
      changes: new He(t, i),
      filtered: Ii.create(o)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], o = this.sections[t + 1];
      o < 0 ? e.push(i) : o == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let o = [], n = [], s = 0, a = null;
    function l(h = !1) {
      if (!h && !o.length)
        return;
      s < t && pt(o, t - s, -1);
      let c = new He(o, n);
      a = a ? a.compose(c.map(a)) : c, o = [], n = [], s = 0;
    }
    function u(h) {
      if (Array.isArray(h))
        for (let c of h)
          u(c);
      else if (h instanceof He) {
        if (h.length != t)
          throw new RangeError(`Mismatched change set length (got ${h.length}, expected ${t})`);
        l(), a = a ? a.compose(h.map(a)) : h;
      } else {
        let { from: c, to: d = c, insert: f } = h;
        if (c > d || c < 0 || d > t)
          throw new RangeError(`Invalid change range ${c} to ${d} (in doc of length ${t})`);
        let p = f ? typeof f == "string" ? ve.of(f.split(i || hd)) : f : ve.empty, g = p.length;
        if (c == d && g == 0)
          return;
        c < s && l(), c > s && pt(o, c - s, -1), pt(o, d - c, g), Tr(n, o, p), s = d;
      }
    }
    return u(e), l(!a), a;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new He(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let o = 0; o < e.length; o++) {
      let n = e[o];
      if (typeof n == "number")
        t.push(n, -1);
      else {
        if (!Array.isArray(n) || typeof n[0] != "number" || n.some((s, a) => a && typeof s != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (n.length == 1)
          t.push(n[0], 0);
        else {
          for (; i.length < o; )
            i.push(ve.empty);
          i[o] = ve.of(n.slice(1)), t.push(n[0], i[o].length);
        }
      }
    }
    return new He(t, i);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new He(e, t);
  }
}
function pt(r, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let o = r.length - 2;
  o >= 0 && t <= 0 && t == r[o + 1] ? r[o] += e : e == 0 && r[o] == 0 ? r[o + 1] += t : i ? (r[o] += e, r[o + 1] += t) : r.push(e, t);
}
function Tr(r, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < r.length)
    r[r.length - 1] = r[r.length - 1].append(t);
  else {
    for (; r.length < i; )
      r.push(ve.empty);
    r.push(t);
  }
}
function cd(r, e, t) {
  let i = r.inserted;
  for (let o = 0, n = 0, s = 0; s < r.sections.length; ) {
    let a = r.sections[s++], l = r.sections[s++];
    if (l < 0)
      o += a, n += a;
    else {
      let u = o, h = n, c = ve.empty;
      for (; u += a, h += l, l && i && (c = c.append(i[s - 2 >> 1])), !(t || s == r.sections.length || r.sections[s + 1] < 0); )
        a = r.sections[s++], l = r.sections[s++];
      e(o, u, n, h, c), o = u, n = h;
    }
  }
}
function dd(r, e, t, i = !1) {
  let o = [], n = i ? [] : null, s = new ea(r), a = new ea(e);
  for (let l = -1; ; )
    if (s.ins == -1 && a.ins == -1) {
      let u = Math.min(s.len, a.len);
      pt(o, u, -1), s.forward(u), a.forward(u);
    } else if (a.ins >= 0 && (s.ins < 0 || l == s.i || s.off == 0 && (a.len < s.len || a.len == s.len && !t))) {
      let u = a.len;
      for (pt(o, a.ins, -1); u; ) {
        let h = Math.min(s.len, u);
        s.ins >= 0 && l < s.i && s.len <= h && (pt(o, 0, s.ins), n && Tr(n, o, s.text), l = s.i), s.forward(h), u -= h;
      }
      a.next();
    } else if (s.ins >= 0) {
      let u = 0, h = s.len;
      for (; h; )
        if (a.ins == -1) {
          let c = Math.min(h, a.len);
          u += c, h -= c, a.forward(c);
        } else if (a.ins == 0 && a.len < h)
          h -= a.len, a.next();
        else
          break;
      pt(o, u, l < s.i ? s.ins : 0), n && l < s.i && Tr(n, o, s.text), l = s.i, s.forward(s.len - h);
    } else {
      if (s.done && a.done)
        return n ? He.createSet(o, n) : Ii.create(o);
      throw new Error("Mismatched change set lengths");
    }
}
function W0(r, e, t = !1) {
  let i = [], o = t ? [] : null, n = new ea(r), s = new ea(e);
  for (let a = !1; ; ) {
    if (n.done && s.done)
      return o ? He.createSet(i, o) : Ii.create(i);
    if (n.ins == 0)
      pt(i, n.len, 0, a), n.next();
    else if (s.len == 0 && !s.done)
      pt(i, 0, s.ins, a), o && Tr(o, i, s.text), s.next();
    else {
      if (n.done || s.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(n.len2, s.len), u = i.length;
        if (n.ins == -1) {
          let h = s.ins == -1 ? -1 : s.off ? 0 : s.ins;
          pt(i, l, h, a), o && h && Tr(o, i, s.text);
        } else
          s.ins == -1 ? (pt(i, n.off ? 0 : n.len, l, a), o && Tr(o, i, n.textBit(l))) : (pt(i, n.off ? 0 : n.len, s.off ? 0 : s.ins, a), o && !s.off && Tr(o, i, s.text));
        a = (n.ins > l || s.ins >= 0 && s.len > l) && (a || i.length > u), n.forward2(l), s.forward(l);
      }
    }
  }
}
class ea {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? ve.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? ve.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class bo {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the range—the side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, o;
    return this.empty ? i = o = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), o = e.mapPos(this.to, -1)), i == this.from && o == this.to ? this : new bo(i, o, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return D.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return D.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return D.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new bo(e, t, i);
  }
}
class D {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : D.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new D([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return D.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, D.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new D(e.ranges.map((t) => bo.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new D([D.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, o = 0; o < e.length; o++) {
      let n = e[o];
      if (n.empty ? n.from <= i : n.from < i)
        return D.normalized(e.slice(), t);
      i = n.to;
    }
    return new D(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, o) {
    return bo.create(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (i == null ? 3 : Math.min(2, i)) | (o ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i, o) {
    let n = (i ?? 33554431) << 5 | (o == null ? 3 : Math.min(2, o));
    return t < e ? bo.create(t, e, 24 | n) : bo.create(e, t, (t > e ? 4 : 0) | n);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((o, n) => o.from - n.from), t = e.indexOf(i);
    for (let o = 1; o < e.length; o++) {
      let n = e[o], s = e[o - 1];
      if (n.empty ? n.from <= s.to : n.from < s.to) {
        let a = s.from, l = Math.max(n.to, s.to);
        o <= t && t--, e.splice(--o, 2, n.anchor > n.head ? D.range(l, a) : D.range(a, l));
      }
    }
    return new D(e, t);
  }
}
function I0(r, e) {
  for (let t of r.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Op = 0;
class H {
  constructor(e, t, i, o, n) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = o, this.id = Op++, this.default = e([]), this.extensions = typeof n == "function" ? n(this) : n;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new H(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : vp), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new Sl([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Sl(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new Sl(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function vp(r, e) {
  return r == e || r.length == e.length && r.every((t, i) => t === e[i]);
}
class Sl {
  constructor(e, t, i, o) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = o, this.id = Op++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, o = this.facet.compareInput, n = this.id, s = e[n] >> 1, a = this.type == 2, l = !1, u = !1, h = [];
    for (let c of this.dependencies)
      c == "doc" ? l = !0 : c == "selection" ? u = !0 : ((t = e[c.id]) !== null && t !== void 0 ? t : 1) & 1 || h.push(e[c.id]);
    return {
      create(c) {
        return c.values[s] = i(c), 1;
      },
      update(c, d) {
        if (l && d.docChanged || u && (d.docChanged || d.selection) || fd(c, h)) {
          let f = i(c);
          if (a ? !Sm(f, c.values[s], o) : !o(f, c.values[s]))
            return c.values[s] = f, 1;
        }
        return 0;
      },
      reconfigure: (c, d) => {
        let f, p = d.config.address[n];
        if (p != null) {
          let g = au(d, p);
          if (this.dependencies.every((b) => b instanceof H ? d.facet(b) === c.facet(b) : b instanceof tt ? d.field(b, !1) == c.field(b, !1) : !0) || (a ? Sm(f = i(c), g, o) : o(f = i(c), g)))
            return c.values[s] = g, 0;
        } else
          f = i(c);
        return c.values[s] = f, 1;
      }
    };
  }
}
function Sm(r, e, t) {
  if (r.length != e.length)
    return !1;
  for (let i = 0; i < r.length; i++)
    if (!t(r[i], e[i]))
      return !1;
  return !0;
}
function fd(r, e) {
  let t = !1;
  for (let i of e)
    Ms(r, i) & 1 && (t = !0);
  return t;
}
function Q$(r, e, t) {
  let i = t.map((l) => r[l.id]), o = t.map((l) => l.type), n = i.filter((l) => !(l & 1)), s = r[e.id] >> 1;
  function a(l) {
    let u = [];
    for (let h = 0; h < i.length; h++) {
      let c = au(l, i[h]);
      if (o[h] == 2)
        for (let d of c)
          u.push(d);
      else
        u.push(c);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of i)
        Ms(l, u);
      return l.values[s] = a(l), 1;
    },
    update(l, u) {
      if (!fd(l, n))
        return 0;
      let h = a(l);
      return e.compare(h, l.values[s]) ? 0 : (l.values[s] = h, 1);
    },
    reconfigure(l, u) {
      let h = fd(l, i), c = u.config.facets[e.id], d = u.facet(e);
      if (c && !h && vp(t, c))
        return l.values[s] = d, 0;
      let f = a(l);
      return e.compare(f, d) ? (l.values[s] = d, 0) : (l.values[s] = f, 1);
    }
  };
}
const Cm = /* @__PURE__ */ H.define({ static: !0 });
class tt {
  constructor(e, t, i, o, n) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = o, this.spec = n, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new tt(Op++, e.create, e.update, e.compare || ((i, o) => i === o), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(Cm).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, o) => {
        let n = i.values[t], s = this.updateF(n, o);
        return this.compareF(n, s) ? 0 : (i.values[t] = s, 1);
      },
      reconfigure: (i, o) => o.config.address[this.id] != null ? (i.values[t] = o.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, Cm.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const ho = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ns(r) {
  return (e) => new U0(e, r);
}
const Wo = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ns(ho.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ns(ho.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ns(ho.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ ns(ho.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ns(ho.lowest)
};
class U0 {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class hh {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new pd(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return hh.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class pd {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class su {
  constructor(e, t, i, o, n, s) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = o, this.staticValues = n, this.facets = s, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let o = [], n = /* @__PURE__ */ Object.create(null), s = /* @__PURE__ */ new Map();
    for (let d of P$(e, t, s))
      d instanceof tt ? o.push(d) : (n[d.facet.id] || (n[d.facet.id] = [])).push(d);
    let a = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let d of o)
      a[d.id] = u.length << 1, u.push((f) => d.slot(f));
    let h = i == null ? void 0 : i.config.facets;
    for (let d in n) {
      let f = n[d], p = f[0].facet, g = h && h[d] || [];
      if (f.every(
        (b) => b.type == 0
        /* Provider.Static */
      ))
        if (a[p.id] = l.length << 1 | 1, vp(g, f))
          l.push(i.facet(p));
        else {
          let b = p.combine(f.map((m) => m.value));
          l.push(i && p.compare(b, i.facet(p)) ? i.facet(p) : b);
        }
      else {
        for (let b of f)
          b.type == 0 ? (a[b.id] = l.length << 1 | 1, l.push(b.value)) : (a[b.id] = u.length << 1, u.push((m) => b.dynamicSlot(m)));
        a[p.id] = u.length << 1, u.push((b) => Q$(b, p, f));
      }
    }
    let c = u.map((d) => d(a));
    return new su(e, s, c, a, l, n);
  }
}
function P$(r, e, t) {
  let i = [[], [], [], [], []], o = /* @__PURE__ */ new Map();
  function n(s, a) {
    let l = o.get(s);
    if (l != null) {
      if (l <= a)
        return;
      let u = i[l].indexOf(s);
      u > -1 && i[l].splice(u, 1), s instanceof pd && t.delete(s.compartment);
    }
    if (o.set(s, a), Array.isArray(s))
      for (let u of s)
        n(u, a);
    else if (s instanceof pd) {
      if (t.has(s.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(s.compartment) || s.inner;
      t.set(s.compartment, u), n(u, a);
    } else if (s instanceof U0)
      n(s.inner, s.prec);
    else if (s instanceof tt)
      i[a].push(s), s.provides && n(s.provides, a);
    else if (s instanceof Sl)
      i[a].push(s), s.facet.extensions && n(s.facet.extensions, ho.default);
    else {
      let u = s.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${s}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      n(u, a);
    }
  }
  return n(r, ho.default), i.reduce((s, a) => s.concat(a));
}
function Ms(r, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = r.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  r.status[t] = 4;
  let o = r.computeSlot(r, r.config.dynamicSlots[t]);
  return r.status[t] = 2 | o;
}
function au(r, e) {
  return e & 1 ? r.config.staticValues[e >> 1] : r.values[e >> 1];
}
const Y0 = /* @__PURE__ */ H.define(), F0 = /* @__PURE__ */ H.define({
  combine: (r) => r.some((e) => e),
  static: !0
}), B0 = /* @__PURE__ */ H.define({
  combine: (r) => r.length ? r[0] : void 0,
  static: !0
}), q0 = /* @__PURE__ */ H.define(), H0 = /* @__PURE__ */ H.define(), j0 = /* @__PURE__ */ H.define(), G0 = /* @__PURE__ */ H.define({
  combine: (r) => r.length ? r[0] : !1
});
class pr {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new k$();
  }
}
class k$ {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new pr(this, e);
  }
}
class E$ {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new le(this, e);
  }
}
class le {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new le(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new E$(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let o of e) {
      let n = o.map(t);
      n && i.push(n);
    }
    return i;
  }
}
le.reconfigure = /* @__PURE__ */ le.define();
le.appendConfig = /* @__PURE__ */ le.define();
class Ge {
  constructor(e, t, i, o, n, s) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = o, this.annotations = n, this.scrollIntoView = s, this._doc = null, this._state = null, i && I0(i, t.newLength), n.some((a) => a.type == Ge.time) || (this.annotations = n.concat(Ge.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, i, o, n, s) {
    return new Ge(e, t, i, o, n, s);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(Ge.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
Ge.time = /* @__PURE__ */ pr.define();
Ge.userEvent = /* @__PURE__ */ pr.define();
Ge.addToHistory = /* @__PURE__ */ pr.define();
Ge.remote = /* @__PURE__ */ pr.define();
function T$(r, e) {
  let t = [];
  for (let i = 0, o = 0; ; ) {
    let n, s;
    if (i < r.length && (o == e.length || e[o] >= r[i]))
      n = r[i++], s = r[i++];
    else if (o < e.length)
      n = e[o++], s = e[o++];
    else
      return t;
    !t.length || t[t.length - 1] < n ? t.push(n, s) : t[t.length - 1] < s && (t[t.length - 1] = s);
  }
}
function K0(r, e, t) {
  var i;
  let o, n, s;
  return t ? (o = e.changes, n = He.empty(e.changes.length), s = r.changes.compose(e.changes)) : (o = e.changes.map(r.changes), n = r.changes.mapDesc(e.changes, !0), s = r.changes.compose(o)), {
    changes: s,
    selection: e.selection ? e.selection.map(n) : (i = r.selection) === null || i === void 0 ? void 0 : i.map(o),
    effects: le.mapEffects(r.effects, o).concat(le.mapEffects(e.effects, n)),
    annotations: r.annotations.length ? r.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: r.scrollIntoView || e.scrollIntoView
  };
}
function gd(r, e, t) {
  let i = e.selection, o = bn(e.annotations);
  return e.userEvent && (o = o.concat(Ge.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof He ? e.changes : He.of(e.changes || [], t, r.facet(B0)),
    selection: i && (i instanceof D ? i : D.single(i.anchor, i.head)),
    effects: bn(e.effects),
    annotations: o,
    scrollIntoView: !!e.scrollIntoView
  };
}
function J0(r, e, t) {
  let i = gd(r, e.length ? e[0] : {}, r.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let n = 1; n < e.length; n++) {
    e[n].filter === !1 && (t = !1);
    let s = !!e[n].sequential;
    i = K0(i, gd(r, e[n], s ? i.changes.newLength : r.doc.length), s);
  }
  let o = Ge.create(r, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return R$(t ? $$(o) : o);
}
function $$(r) {
  let e = r.startState, t = !0;
  for (let o of e.facet(q0)) {
    let n = o(r);
    if (n === !1) {
      t = !1;
      break;
    }
    Array.isArray(n) && (t = t === !0 ? n : T$(t, n));
  }
  if (t !== !0) {
    let o, n;
    if (t === !1)
      n = r.changes.invertedDesc, o = He.empty(e.doc.length);
    else {
      let s = r.changes.filter(t);
      o = s.changes, n = s.filtered.mapDesc(s.changes).invertedDesc;
    }
    r = Ge.create(e, o, r.selection && r.selection.map(n), le.mapEffects(r.effects, n), r.annotations, r.scrollIntoView);
  }
  let i = e.facet(H0);
  for (let o = i.length - 1; o >= 0; o--) {
    let n = i[o](r);
    n instanceof Ge ? r = n : Array.isArray(n) && n.length == 1 && n[0] instanceof Ge ? r = n[0] : r = J0(e, bn(n), !1);
  }
  return r;
}
function R$(r) {
  let e = r.startState, t = e.facet(j0), i = r;
  for (let o = t.length - 1; o >= 0; o--) {
    let n = t[o](r);
    n && Object.keys(n).length && (i = K0(i, gd(e, n, r.changes.newLength), !0));
  }
  return i == r ? r : Ge.create(e, r.changes, r.selection, i.effects, i.annotations, i.scrollIntoView);
}
const _$ = [];
function bn(r) {
  return r == null ? _$ : Array.isArray(r) ? r : [r];
}
var Re = /* @__PURE__ */ function(r) {
  return r[r.Word = 0] = "Word", r[r.Space = 1] = "Space", r[r.Other = 2] = "Other", r;
}(Re || (Re = {}));
const D$ = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let md;
try {
  md = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function M$(r) {
  if (md)
    return md.test(r);
  for (let e = 0; e < r.length; e++) {
    let t = r[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || D$.test(t)))
      return !0;
  }
  return !1;
}
function X$(r) {
  return (e) => {
    if (!/\S/.test(e))
      return Re.Space;
    if (M$(e))
      return Re.Word;
    for (let t = 0; t < r.length; t++)
      if (e.indexOf(r[t]) > -1)
        return Re.Word;
    return Re.Other;
  };
}
class be {
  constructor(e, t, i, o, n, s) {
    this.config = e, this.doc = t, this.selection = i, this.values = o, this.status = e.statusTemplate.slice(), this.computeSlot = n, s && (s._state = this);
    for (let a = 0; a < this.config.dynamicSlots.length; a++)
      Ms(this, a << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return Ms(this, i), au(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return J0(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: o } = t;
    for (let s of e.effects)
      s.is(hh.reconfigure) ? (t && (o = /* @__PURE__ */ new Map(), t.compartments.forEach((a, l) => o.set(l, a)), t = null), o.set(s.value.compartment, s.value.extension)) : s.is(le.reconfigure) ? (t = null, i = s.value) : s.is(le.appendConfig) && (t = null, i = bn(i).concat(s.value));
    let n;
    t ? n = e.startState.values.slice() : (t = su.resolve(i, o, this), n = new be(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (a, l) => l.reconfigure(a, this), null).values), new be(t, e.newDoc, e.newSelection, n, (s, a) => a.update(s, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: D.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), o = this.changes(i.changes), n = [i.range], s = bn(i.effects);
    for (let a = 1; a < t.ranges.length; a++) {
      let l = e(t.ranges[a]), u = this.changes(l.changes), h = u.map(o);
      for (let d = 0; d < a; d++)
        n[d] = n[d].map(h);
      let c = o.mapDesc(u, !0);
      n.push(l.range.map(c)), o = o.compose(h), s = le.mapEffects(s, h).concat(le.mapEffects(bn(l.effects), c));
    }
    return {
      changes: o,
      selection: D.create(n, t.mainIndex),
      effects: s
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof He ? e : He.of(e, this.doc.length, this.facet(be.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return ve.of(e.split(this.facet(be.lineSeparator) || hd));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (Ms(this, t), au(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let o = e[i];
        o instanceof tt && this.config.address[o.id] != null && (t[i] = o.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let o = [];
    if (i) {
      for (let n in i)
        if (Object.prototype.hasOwnProperty.call(e, n)) {
          let s = i[n], a = e[n];
          o.push(s.init((l) => s.spec.fromJSON(a, l)));
        }
    }
    return be.create({
      doc: e.doc,
      selection: D.fromJSON(e.selection),
      extensions: t.extensions ? o.concat([t.extensions]) : o
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editor—updated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = su.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof ve ? e.doc : ve.of((e.doc || "").split(t.staticFacet(be.lineSeparator) || hd)), o = e.selection ? e.selection instanceof D ? e.selection : D.single(e.selection.anchor, e.selection.head) : D.single(0);
    return I0(o, i.length), t.staticFacet(F0) || (o = o.asSingle()), new be(t, i, o, t.dynamicSlots.map(() => null), (n, s) => s.create(n), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(be.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(be.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(G0);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let i of this.facet(be.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, o) => {
      if (o == "$")
        return "$";
      let n = +(o || 1);
      return !n || n > t.length ? i : t[n - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, i = -1) {
    let o = [];
    for (let n of this.facet(Y0))
      for (let s of n(this, t, i))
        Object.prototype.hasOwnProperty.call(s, e) && o.push(s[e]);
    return o;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return X$(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: o } = this.doc.lineAt(e), n = this.charCategorizer(e), s = e - i, a = e - i;
    for (; s > 0; ) {
      let l = Pt(t, s, !1);
      if (n(t.slice(l, s)) != Re.Word)
        break;
      s = l;
    }
    for (; a < o; ) {
      let l = Pt(t, a);
      if (n(t.slice(a, l)) != Re.Word)
        break;
      a = l;
    }
    return s == a ? null : D.range(s + i, a + i);
  }
}
be.allowMultipleSelections = F0;
be.tabSize = /* @__PURE__ */ H.define({
  combine: (r) => r.length ? r[0] : 4
});
be.lineSeparator = B0;
be.readOnly = G0;
be.phrases = /* @__PURE__ */ H.define({
  compare(r, e) {
    let t = Object.keys(r), i = Object.keys(e);
    return t.length == i.length && t.every((o) => r[o] == e[o]);
  }
});
be.languageData = Y0;
be.changeFilter = q0;
be.transactionFilter = H0;
be.transactionExtender = j0;
hh.reconfigure = /* @__PURE__ */ le.define();
function Hi(r, e, t = {}) {
  let i = {};
  for (let o of r)
    for (let n of Object.keys(o)) {
      let s = o[n], a = i[n];
      if (a === void 0)
        i[n] = s;
      else if (!(a === s || s === void 0))
        if (Object.hasOwnProperty.call(t, n))
          i[n] = t[n](a, s);
        else
          throw new Error("Config merge conflict for field " + n);
    }
  for (let o in e)
    i[o] === void 0 && (i[o] = e[o]);
  return i;
}
class _o {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return bd.create(e, t, this);
  }
}
_o.prototype.startSide = _o.prototype.endSide = 0;
_o.prototype.point = !1;
_o.prototype.mapMode = at.TrackDel;
let bd = class ey {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new ey(e, t, i);
  }
};
function Od(r, e) {
  return r.from - e.from || r.value.startSide - e.value.startSide;
}
class wp {
  constructor(e, t, i, o) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = o;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, o = 0) {
    let n = i ? this.to : this.from;
    for (let s = o, a = n.length; ; ) {
      if (s == a)
        return s;
      let l = s + a >> 1, u = n[l] - e || (i ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == s)
        return u >= 0 ? s : a;
      u >= 0 ? a = l : s = l + 1;
    }
  }
  between(e, t, i, o) {
    for (let n = this.findIndex(t, -1e9, !0), s = this.findIndex(i, 1e9, !1, n); n < s; n++)
      if (o(this.from[n] + e, this.to[n] + e, this.value[n]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], o = [], n = [], s = -1, a = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], h = this.from[l] + e, c = this.to[l] + e, d, f;
      if (h == c) {
        let p = t.mapPos(h, u.startSide, u.mapMode);
        if (p == null || (d = f = p, u.startSide != u.endSide && (f = t.mapPos(h, u.endSide), f < d)))
          continue;
      } else if (d = t.mapPos(h, u.startSide), f = t.mapPos(c, u.endSide), d > f || d == f && u.startSide > 0 && u.endSide <= 0)
        continue;
      (f - d || u.endSide - u.startSide) < 0 || (s < 0 && (s = d), u.point && (a = Math.max(a, f - d)), i.push(u), o.push(d - s), n.push(f - s));
    }
    return { mapped: i.length ? new wp(o, n, i, a) : null, pos: s };
  }
}
class Se {
  constructor(e, t, i, o) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = o;
  }
  /**
  @internal
  */
  static create(e, t, i, o) {
    return new Se(e, t, i, o);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: o = 0, filterTo: n = this.length } = e, s = e.filter;
    if (t.length == 0 && !s)
      return this;
    if (i && (t = t.slice().sort(Od)), this.isEmpty)
      return t.length ? Se.of(t) : this;
    let a = new ty(this, null, -1).goto(0), l = 0, u = [], h = new Hr();
    for (; a.value || l < t.length; )
      if (l < t.length && (a.from - t[l].from || a.startSide - t[l].value.startSide) >= 0) {
        let c = t[l++];
        h.addInner(c.from, c.to, c.value) || u.push(c);
      } else
        a.rangeIndex == 1 && a.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(a.chunkIndex) < t[l].from) && (!s || o > this.chunkEnd(a.chunkIndex) || n < this.chunkPos[a.chunkIndex]) && h.addChunk(this.chunkPos[a.chunkIndex], this.chunk[a.chunkIndex]) ? a.nextChunk() : ((!s || o > a.to || n < a.from || s(a.from, a.to, a.value)) && (h.addInner(a.from, a.to, a.value) || u.push(bd.create(a.from, a.to, a.value))), a.next());
    return h.finishInner(this.nextLayer.isEmpty && !u.length ? Se.empty : this.nextLayer.update({ add: u, filter: s, filterFrom: o, filterTo: n }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], o = -1;
    for (let s = 0; s < this.chunk.length; s++) {
      let a = this.chunkPos[s], l = this.chunk[s], u = e.touchesRange(a, a + l.length);
      if (u === !1)
        o = Math.max(o, l.maxPoint), t.push(l), i.push(e.mapPos(a));
      else if (u === !0) {
        let { mapped: h, pos: c } = l.map(a, e);
        h && (o = Math.max(o, h.maxPoint), t.push(h), i.push(c));
      }
    }
    let n = this.nextLayer.map(e);
    return t.length == 0 ? n : new Se(i, t, n || Se.empty, o);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let o = 0; o < this.chunk.length; o++) {
        let n = this.chunkPos[o], s = this.chunk[o];
        if (t >= n && e <= n + s.length && s.between(n, e - n, t - n, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return ta.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return ta.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, o, n = -1) {
    let s = e.filter((c) => c.maxPoint > 0 || !c.isEmpty && c.maxPoint >= n), a = t.filter((c) => c.maxPoint > 0 || !c.isEmpty && c.maxPoint >= n), l = Qm(s, a, i), u = new ss(s, l, n), h = new ss(a, l, n);
    i.iterGaps((c, d, f) => Pm(u, c, h, d, f, o)), i.empty && i.length == 0 && Pm(u, 0, h, 0, 0, o);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, o) {
    o == null && (o = 1e9 - 1);
    let n = e.filter((h) => !h.isEmpty && t.indexOf(h) < 0), s = t.filter((h) => !h.isEmpty && e.indexOf(h) < 0);
    if (n.length != s.length)
      return !1;
    if (!n.length)
      return !0;
    let a = Qm(n, s), l = new ss(n, a, 0).goto(i), u = new ss(s, a, 0).goto(i);
    for (; ; ) {
      if (l.to != u.to || !vd(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > o)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, o, n = -1) {
    let s = new ss(e, null, n).goto(t), a = t, l = s.openStart;
    for (; ; ) {
      let u = Math.min(s.to, i);
      if (s.point) {
        let h = s.activeForPoint(s.to), c = s.pointFrom < t ? h.length + 1 : Math.min(h.length, l);
        o.point(a, u, s.point, h, c, s.pointRank), l = Math.min(s.openEnd(u), h.length);
      } else
        u > a && (o.span(a, u, s.active, l), l = s.openEnd(u));
      if (s.to > i)
        return l + (s.point && s.to > i ? 1 : 0);
      a = s.to, s.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let i = new Hr();
    for (let o of e instanceof bd ? [e] : t ? A$(e) : e)
      i.add(o.from, o.to, o.value);
    return i.finish();
  }
}
Se.empty = /* @__PURE__ */ new Se([], [], null, -1);
function A$(r) {
  if (r.length > 1)
    for (let e = r[0], t = 1; t < r.length; t++) {
      let i = r[t];
      if (Od(e, i) > 0)
        return r.slice().sort(Od);
      e = i;
    }
  return r;
}
Se.empty.nextLayer = Se.empty;
class Hr {
  finishChunk(e) {
    this.chunks.push(new wp(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new Hr())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let o = e - this.lastTo || i.startSide - this.last.endSide;
    if (o <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return o < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(Se.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = Se.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function Qm(r, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let n of r)
    for (let s = 0; s < n.chunk.length; s++)
      n.chunk[s].maxPoint <= 0 && i.set(n.chunk[s], n.chunkPos[s]);
  let o = /* @__PURE__ */ new Set();
  for (let n of e)
    for (let s = 0; s < n.chunk.length; s++) {
      let a = i.get(n.chunk[s]);
      a != null && (t ? t.mapPos(a) : a) == n.chunkPos[s] && !(t != null && t.touchesRange(a, a + n.chunk[s].length)) && o.add(n.chunk[s]);
    }
  return o;
}
class ty {
  constructor(e, t, i, o = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = o;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let o = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(o) || this.layer.chunkEnd(this.chunkIndex) < e || o.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let o = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < o) && this.setRangeIndex(o);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class ta {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let o = [];
    for (let n = 0; n < e.length; n++)
      for (let s = e[n]; !s.isEmpty; s = s.nextLayer)
        s.maxPoint >= i && o.push(new ty(s, t, i, n));
    return o.length == 1 ? o[0] : new ta(o);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Gh(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      Gh(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), Gh(this.heap, 0);
    }
  }
}
function Gh(r, e) {
  for (let t = r[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= r.length)
      break;
    let o = r[i];
    if (i + 1 < r.length && o.compare(r[i + 1]) >= 0 && (o = r[i + 1], i++), t.compare(o) < 0)
      break;
    r[i] = t, r[e] = o, e = i;
  }
}
class ss {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = ta.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    Ga(this.active, e), Ga(this.activeTo, e), Ga(this.activeRank, e), this.minActive = km(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: o, rank: n } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= n; )
      t++;
    Ka(this.active, t, i), Ka(this.activeTo, t, o), Ka(this.activeRank, t, n), e && Ka(e, t, this.cursor.from), this.minActive = km(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let o = this.minActive;
      if (o > -1 && (this.activeTo[o] - this.cursor.from || this.active[o].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[o] > e) {
          this.to = this.activeTo[o], this.endSide = this.active[o].endSide;
          break;
        }
        this.removeActive(o), i && Ga(i, o);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let n = this.cursor.value;
          if (!n.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = n, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = n.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let o = i.length - 1; o >= 0 && i[o] < e; o--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function Pm(r, e, t, i, o, n) {
  r.goto(e), t.goto(i);
  let s = i + o, a = i, l = i - e;
  for (; ; ) {
    let u = r.to + l - t.to || r.endSide - t.endSide, h = u < 0 ? r.to + l : t.to, c = Math.min(h, s);
    if (r.point || t.point ? r.point && t.point && (r.point == t.point || r.point.eq(t.point)) && vd(r.activeForPoint(r.to), t.activeForPoint(t.to)) || n.comparePoint(a, c, r.point, t.point) : c > a && !vd(r.active, t.active) && n.compareRange(a, c, r.active, t.active), h > s)
      break;
    a = h, u <= 0 && r.next(), u >= 0 && t.next();
  }
}
function vd(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] != e[t] && !r[t].eq(e[t]))
      return !1;
  return !0;
}
function Ga(r, e) {
  for (let t = e, i = r.length - 1; t < i; t++)
    r[t] = r[t + 1];
  r.pop();
}
function Ka(r, e, t) {
  for (let i = r.length - 1; i >= e; i--)
    r[i + 1] = r[i];
  r[e] = t;
}
function km(r, e) {
  let t = -1, i = 1e9;
  for (let o = 0; o < e.length; o++)
    (e[o] - i || r[o].endSide - r[t].endSide) < 0 && (t = o, i = e[o]);
  return t;
}
function Ca(r, e, t = r.length) {
  let i = 0;
  for (let o = 0; o < t; )
    r.charCodeAt(o) == 9 ? (i += e - i % e, o++) : (i++, o = Pt(r, o));
  return i;
}
function wd(r, e, t, i) {
  for (let o = 0, n = 0; ; ) {
    if (n >= e)
      return o;
    if (o == r.length)
      break;
    n += r.charCodeAt(o) == 9 ? t - n % t : 1, o = Pt(r, o);
  }
  return i === !0 ? -1 : r.length;
}
const yd = "ͼ", Em = typeof Symbol > "u" ? "__" + yd : Symbol.for(yd), xd = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), Tm = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class jr {
  // :: (Object<Style>, ?{finish: ?(string) → string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function o(s) {
      return /^@/.test(s) ? [s] : s.split(/,\s*/);
    }
    function n(s, a, l, u) {
      let h = [], c = /^@(\w+)\b/.exec(s[0]), d = c && c[1] == "keyframes";
      if (c && a == null)
        return l.push(s[0] + ";");
      for (let f in a) {
        let p = a[f];
        if (/&/.test(f))
          n(
            f.split(/,\s*/).map((g) => s.map((b) => g.replace(/&/, b))).reduce((g, b) => g.concat(b)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!c)
            throw new RangeError("The value of a property (" + f + ") should be a primitive value.");
          n(o(f), p, h, d);
        } else
          p != null && h.push(f.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (h.length || d) && l.push((i && !c && !u ? s.map(i) : s).join(", ") + " {" + h.join(" ") + "}");
    }
    for (let s in e)
      n(o(s), e[s], this.rules);
  }
  // :: () → string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: () → string
  // Generate a new unique CSS class name.
  static newName() {
    let e = Tm[Em] || 1;
    return Tm[Em] = e + 1, yd + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(e, t) {
    (e[xd] || new z$(e)).mount(Array.isArray(t) ? t : [t]);
  }
}
let $m = /* @__PURE__ */ new Map();
class z$ {
  constructor(e) {
    let t = e.ownerDocument || e, i = t.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let o = $m.get(t);
      if (o)
        return e.adoptedStyleSheets = [o.sheet, ...e.adoptedStyleSheets], e[xd] = o;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], $m.set(t, this);
    } else {
      this.styleTag = t.createElement("style");
      let o = e.head || e;
      o.insertBefore(this.styleTag, o.firstChild);
    }
    this.modules = [], e[xd] = this;
  }
  mount(e) {
    let t = this.sheet, i = 0, o = 0;
    for (let n = 0; n < e.length; n++) {
      let s = e[n], a = this.modules.indexOf(s);
      if (a < o && a > -1 && (this.modules.splice(a, 1), o--, a = -1), a == -1) {
        if (this.modules.splice(o++, 0, s), t)
          for (let l = 0; l < s.rules.length; l++)
            t.insertRule(s.rules[l], i++);
      } else {
        for (; o < a; )
          i += this.modules[o++].rules.length;
        i += s.rules.length, o++;
      }
    }
    if (!t) {
      let n = "";
      for (let s = 0; s < this.modules.length; s++)
        n += this.modules[s].getRules() + `
`;
      this.styleTag.textContent = n;
    }
  }
}
var Gr = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ia = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, N$ = typeof navigator < "u" && /Mac/.test(navigator.platform), V$ = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var st = 0; st < 10; st++)
  Gr[48 + st] = Gr[96 + st] = String(st);
for (var st = 1; st <= 24; st++)
  Gr[st + 111] = "F" + st;
for (var st = 65; st <= 90; st++)
  Gr[st] = String.fromCharCode(st + 32), ia[st] = String.fromCharCode(st);
for (var Kh in Gr)
  ia.hasOwnProperty(Kh) || (ia[Kh] = Gr[Kh]);
function Z$(r) {
  var e = N$ && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey || V$ && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? ia : Gr)[r.keyCode] || r.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function lu(r) {
  let e;
  return r.nodeType == 11 ? e = r.getSelection ? r : r.ownerDocument : e = r, e.getSelection();
}
function _n(r, e) {
  return e ? r == e || r.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function L$(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function Cl(r, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return _n(r, e.anchorNode);
  } catch {
    return !1;
  }
}
function ra(r) {
  return r.nodeType == 3 ? Dn(r, 0, r.nodeValue.length).getClientRects() : r.nodeType == 1 ? r.getClientRects() : [];
}
function uu(r, e, t, i) {
  return t ? Rm(r, e, t, i, -1) || Rm(r, e, t, i, 1) : !1;
}
function hu(r) {
  for (var e = 0; ; e++)
    if (r = r.previousSibling, !r)
      return e;
}
function Rm(r, e, t, i, o) {
  for (; ; ) {
    if (r == t && e == i)
      return !0;
    if (e == (o < 0 ? 0 : Kr(r))) {
      if (r.nodeName == "DIV")
        return !1;
      let n = r.parentNode;
      if (!n || n.nodeType != 1)
        return !1;
      e = hu(r) + (o < 0 ? 0 : 1), r = n;
    } else if (r.nodeType == 1) {
      if (r = r.childNodes[e + (o < 0 ? -1 : 0)], r.nodeType == 1 && r.contentEditable == "false")
        return !1;
      e = o < 0 ? Kr(r) : 0;
    } else
      return !1;
  }
}
function Kr(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function yp(r, e) {
  let t = e ? r.left : r.right;
  return { left: t, right: t, top: r.top, bottom: r.bottom };
}
function W$(r) {
  return {
    left: 0,
    right: r.innerWidth,
    top: 0,
    bottom: r.innerHeight
  };
}
function I$(r, e, t, i, o, n, s, a) {
  let l = r.ownerDocument, u = l.defaultView || window;
  for (let h = r; h; )
    if (h.nodeType == 1) {
      let c, d = h == l.body;
      if (d)
        c = W$(u);
      else {
        if (h.scrollHeight <= h.clientHeight && h.scrollWidth <= h.clientWidth) {
          h = h.assignedSlot || h.parentNode;
          continue;
        }
        let g = h.getBoundingClientRect();
        c = {
          left: g.left,
          right: g.left + h.clientWidth,
          top: g.top,
          bottom: g.top + h.clientHeight
        };
      }
      let f = 0, p = 0;
      if (o == "nearest")
        e.top < c.top ? (p = -(c.top - e.top + s), t > 0 && e.bottom > c.bottom + p && (p = e.bottom - c.bottom + p + s)) : e.bottom > c.bottom && (p = e.bottom - c.bottom + s, t < 0 && e.top - p < c.top && (p = -(c.top + p - e.top + s)));
      else {
        let g = e.bottom - e.top, b = c.bottom - c.top;
        p = (o == "center" && g <= b ? e.top + g / 2 - b / 2 : o == "start" || o == "center" && t < 0 ? e.top - s : e.bottom - b + s) - c.top;
      }
      if (i == "nearest" ? e.left < c.left ? (f = -(c.left - e.left + n), t > 0 && e.right > c.right + f && (f = e.right - c.right + f + n)) : e.right > c.right && (f = e.right - c.right + n, t < 0 && e.left < c.left + f && (f = -(c.left + f - e.left + n))) : f = (i == "center" ? e.left + (e.right - e.left) / 2 - (c.right - c.left) / 2 : i == "start" == a ? e.left - n : e.right - (c.right - c.left) + n) - c.left, f || p)
        if (d)
          u.scrollBy(f, p);
        else {
          let g = 0, b = 0;
          if (p) {
            let m = h.scrollTop;
            h.scrollTop += p, b = h.scrollTop - m;
          }
          if (f) {
            let m = h.scrollLeft;
            h.scrollLeft += f, g = h.scrollLeft - m;
          }
          e = {
            left: e.left - g,
            top: e.top - b,
            right: e.right - g,
            bottom: e.bottom - b
          }, g && Math.abs(g - f) < 1 && (i = "nearest"), b && Math.abs(b - p) < 1 && (o = "nearest");
        }
      if (d)
        break;
      h = h.assignedSlot || h.parentNode;
    } else if (h.nodeType == 11)
      h = h.host;
    else
      break;
}
function U$(r) {
  let e = r.ownerDocument;
  for (let t = r.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class Y$ {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? Kr(t) : 0), i, Math.min(e.focusOffset, i ? Kr(i) : 0));
  }
  set(e, t, i, o) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = o;
  }
}
let Ko = null;
function iy(r) {
  if (r.setActive)
    return r.setActive();
  if (Ko)
    return r.focus(Ko);
  let e = [];
  for (let t = r; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (r.focus(Ko == null ? {
    get preventScroll() {
      return Ko = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ko) {
    Ko = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], o = e[t++], n = e[t++];
      i.scrollTop != o && (i.scrollTop = o), i.scrollLeft != n && (i.scrollLeft = n);
    }
  }
}
let _m;
function Dn(r, e, t = e) {
  let i = _m || (_m = document.createRange());
  return i.setEnd(r, t), i.setStart(r, e), i;
}
function On(r, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, o = new KeyboardEvent("keydown", i);
  o.synthetic = !0, r.dispatchEvent(o);
  let n = new KeyboardEvent("keyup", i);
  return n.synthetic = !0, r.dispatchEvent(n), o.defaultPrevented || n.defaultPrevented;
}
function F$(r) {
  for (; r; ) {
    if (r && (r.nodeType == 9 || r.nodeType == 11 && r.host))
      return r;
    r = r.assignedSlot || r.parentNode;
  }
  return null;
}
function ry(r) {
  for (; r.attributes.length; )
    r.removeAttributeNode(r.attributes[0]);
}
function B$(r, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, Kr(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let o = t.childNodes[i - 1];
      o.contentEditable == "false" ? i-- : (t = o, i = Kr(t));
    } else {
      if (t == r)
        return !0;
      i = hu(t), t = t.parentNode;
    }
}
class lt {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new lt(e.parentNode, hu(e), t);
  }
  static after(e, t) {
    return new lt(e.parentNode, hu(e) + 1, t);
  }
}
const xp = [];
class Ee {
  constructor() {
    this.parent = null, this.dom = null, this.dirty = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.dirty & 2) {
      let i = this.dom, o = null, n;
      for (let s of this.children) {
        if (s.dirty) {
          if (!s.dom && (n = o ? o.nextSibling : i.firstChild)) {
            let a = Ee.get(n);
            (!a || !a.parent && a.canReuseDOM(s)) && s.reuseDOM(n);
          }
          s.sync(e, t), s.dirty = 0;
        }
        if (n = o ? o.nextSibling : i.firstChild, t && !t.written && t.node == i && n != s.dom && (t.written = !0), s.dom.parentNode == i)
          for (; n && n != s.dom; )
            n = Dm(n);
        else
          i.insertBefore(s.dom, n);
        o = s.dom;
      }
      for (n = o ? o.nextSibling : i.firstChild, n && t && t.node == i && (t.written = !0); n; )
        n = Dm(n);
    } else if (this.dirty & 1)
      for (let i of this.children)
        i.dirty && (i.sync(e, t), i.dirty = 0);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let o = Kr(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let n = e.parentNode;
        if (n == this.dom)
          break;
        o == 0 && n.firstChild != n.lastChild && (e == n.firstChild ? o = -1 : o = 1), e = n;
      }
      o < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Ee.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let o = 0, n = 0; ; o++) {
      let s = this.children[o];
      if (s.dom == i)
        return n;
      n += s.length + s.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let o = -1, n = -1, s = -1, a = -1;
    for (let l = 0, u = i, h = i; l < this.children.length; l++) {
      let c = this.children[l], d = u + c.length;
      if (u < e && d > t)
        return c.domBoundsAround(e, t, u);
      if (d >= e && o == -1 && (o = l, n = u), u > t && c.dom.parentNode == this.dom) {
        s = l, a = h;
        break;
      }
      h = d, u = d + c.breakAfter;
    }
    return {
      from: n,
      to: a < 0 ? i + this.length : a,
      startDOM: (o ? this.children[o - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: s < this.children.length && s >= 0 ? this.children[s].dom : null
    };
  }
  markDirty(e = !1) {
    this.dirty |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.dirty |= 2), t.dirty & 1)
        return;
      t.dirty |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.dirty && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = xp) {
    this.markDirty();
    for (let o = e; o < t; o++) {
      let n = this.children[o];
      n.parent == this && n.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let o = 0; o < i.length; o++)
      i[o].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new oy(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, o, n, s) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor;
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
Ee.prototype.breakAfter = 0;
function Dm(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class oy {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function ny(r, e, t, i, o, n, s, a, l) {
  let { children: u } = r, h = u.length ? u[e] : null, c = n.length ? n[n.length - 1] : null, d = c ? c.breakAfter : s;
  if (!(e == i && h && !s && !d && n.length < 2 && h.merge(t, o, n.length ? c : null, t == 0, a, l))) {
    if (i < u.length) {
      let f = u[i];
      f && o < f.length ? (e == i && (f = f.split(o), o = 0), !d && c && f.merge(0, o, c, !0, 0, l) ? n[n.length - 1] = f : (o && f.merge(0, o, null, !1, 0, l), n.push(f))) : f != null && f.breakAfter && (c ? c.breakAfter = 1 : s = 1), i++;
    }
    for (h && (h.breakAfter = s, t > 0 && (!s && n.length && h.merge(t, h.length, n[0], !1, a, 0) ? h.breakAfter = n.shift().breakAfter : (t < h.length || h.children.length && h.children[h.children.length - 1].length == 0) && h.merge(t, h.length, null, !1, a, 0), e++)); e < i && n.length; )
      if (u[i - 1].become(n[n.length - 1]))
        i--, n.pop(), l = n.length ? 0 : a;
      else if (u[e].become(n[0]))
        e++, n.shift(), a = n.length ? 0 : l;
      else
        break;
    !n.length && e && i < u.length && !u[e - 1].breakAfter && u[i].merge(0, 0, u[e - 1], !1, a, l) && e--, (e < i || n.length) && r.replaceChildren(e, i, n);
  }
}
function sy(r, e, t, i, o, n) {
  let s = r.childCursor(), { i: a, off: l } = s.findPos(t, 1), { i: u, off: h } = s.findPos(e, -1), c = e - t;
  for (let d of i)
    c += d.length;
  r.length += c, ny(r, u, h, a, l, i, 0, o, n);
}
let Ht = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, Sd = typeof document < "u" ? document : { documentElement: { style: {} } };
const Cd = /* @__PURE__ */ /Edge\/(\d+)/.exec(Ht.userAgent), ay = /* @__PURE__ */ /MSIE \d/.test(Ht.userAgent), Qd = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Ht.userAgent), ch = !!(ay || Qd || Cd), Mm = !ch && /* @__PURE__ */ /gecko\/(\d+)/i.test(Ht.userAgent), Jh = !ch && /* @__PURE__ */ /Chrome\/(\d+)/.exec(Ht.userAgent), Xm = "webkitFontSmoothing" in Sd.documentElement.style, ly = !ch && /* @__PURE__ */ /Apple Computer/.test(Ht.vendor), Am = ly && (/* @__PURE__ */ /Mobile\/\w+/.test(Ht.userAgent) || Ht.maxTouchPoints > 2);
var j = {
  mac: Am || /* @__PURE__ */ /Mac/.test(Ht.platform),
  windows: /* @__PURE__ */ /Win/.test(Ht.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(Ht.platform),
  ie: ch,
  ie_version: ay ? Sd.documentMode || 6 : Qd ? +Qd[1] : Cd ? +Cd[1] : 0,
  gecko: Mm,
  gecko_version: Mm ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(Ht.userAgent) || [0, 0])[1] : 0,
  chrome: !!Jh,
  chrome_version: Jh ? +Jh[1] : 0,
  ios: Am,
  android: /* @__PURE__ */ /Android\b/.test(Ht.userAgent),
  webkit: Xm,
  safari: ly,
  webkit_version: Xm ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: Sd.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const q$ = 256;
class Do extends Ee {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return i && (!(i instanceof Do) || this.length - (t - e) + i.length > q$) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Do(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new lt(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return Pd(this.dom, e, t);
  }
}
class lr extends Ee {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let o of t)
      o.setParent(this);
  }
  setAttrs(e) {
    if (ry(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, t) {
    this.dom ? this.dirty & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, o, n, s) {
    return i && (!(i instanceof lr && i.mark.eq(this.mark)) || e && n <= 0 || t < this.length && s <= 0) ? !1 : (sy(this, e, t, i ? i.children : [], n - 1, s - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, o = -1, n = 0;
    for (let a of this.children) {
      let l = i + a.length;
      l > e && t.push(i < e ? a.split(e - i) : a), o < 0 && i >= e && (o = n), i = l, n++;
    }
    let s = this.length - e;
    return this.length = e, o > -1 && (this.children.length = o, this.markDirty()), new lr(this.mark, t, s);
  }
  domAtPos(e) {
    return fy(this, e);
  }
  coordsAt(e, t) {
    return gy(this, e, t);
  }
}
function Pd(r, e, t) {
  let i = r.nodeValue.length;
  e > i && (e = i);
  let o = e, n = e, s = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? j.chrome || j.gecko || (e ? (o--, s = 1) : n < i && (n++, s = -1)) : t < 0 ? o-- : n < i && n++;
  let a = Dn(r, o, n).getClientRects();
  if (!a.length)
    return null;
  let l = a[(s ? s < 0 : t >= 0) ? 0 : a.length - 1];
  return j.safari && !s && l.width == 0 && (l = Array.prototype.find.call(a, (u) => u.width) || l), s ? yp(l, s < 0) : l || null;
}
class $r extends Ee {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  static create(e, t, i) {
    return new (e.customView || $r)(e, t, i);
  }
  split(e) {
    let t = $r.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, o, n, s) {
    return i && (!(i instanceof $r) || !this.widget.compare(i.widget) || e > 0 && n <= 0 || t < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof $r && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return ve.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, o = this.posAtStart;
    return i ? i.slice(o, o + this.length) : ve.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? lt.before(this.dom) : lt.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let o = this.dom.getClientRects(), n = null;
    if (!o.length)
      return null;
    let s = this.side ? this.side < 0 : e > 0;
    for (let a = s ? o.length - 1 : 0; n = o[a], !(e > 0 ? a == 0 : a == o.length - 1 || n.top < n.bottom); a += s ? -1 : 1)
      ;
    return yp(n, !s);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class uy extends $r {
  domAtPos(e) {
    let { topView: t, text: i } = this.widget;
    return t ? kd(e, 0, t, i, this.length - t.length, (o, n) => o.domAtPos(n), (o, n) => new lt(o, Math.min(n, o.nodeValue.length))) : new lt(i, Math.min(e, i.nodeValue.length));
  }
  sync() {
    this.setDOM(this.widget.toDOM());
  }
  localPosFromDOM(e, t) {
    let { topView: i, text: o } = this.widget;
    return i ? cy(e, t, i, o, this.length - i.length) : Math.min(t, this.length);
  }
  ignoreMutation() {
    return !1;
  }
  get overrideDOMText() {
    return null;
  }
  coordsAt(e, t) {
    let { topView: i, text: o } = this.widget;
    return i ? kd(e, t, i, o, this.length - i.length, (n, s, a) => n.coordsAt(s, a), (n, s, a) => Pd(n, s, a)) : Pd(o, e, t);
  }
  destroy() {
    var e;
    super.destroy(), (e = this.widget.topView) === null || e === void 0 || e.destroy();
  }
  get isEditable() {
    return !0;
  }
  canReuseDOM() {
    return !0;
  }
}
function kd(r, e, t, i, o, n, s) {
  if (t instanceof lr) {
    for (let a = t.dom.firstChild; a; a = a.nextSibling) {
      let l = Ee.get(a);
      if (l) {
        let u = _n(a, i), h = l.length + (u ? o : 0);
        if (r < h || r == h && l.getSide() <= 0)
          return u ? kd(r, e, l, i, o, n, s) : n(l, r, e);
        r -= h;
      } else {
        let u = hy(r, e, a, s);
        if (typeof u != "number")
          return u;
        r = u;
      }
    }
    return n(t, t.length, -1);
  } else
    return t.dom == i ? s(i, r, e) : n(t, r, e);
}
function hy(r, e, t, i) {
  if (t.nodeType == 3) {
    let o = t.nodeValue.length;
    if (r <= o)
      return i(t, r, e);
    r -= o;
  } else if (t.nodeType == 1 && t.contentEditable != "false")
    for (let o = t.firstChild; o; o = o.nextSibling) {
      let n = hy(r, e, o, i);
      if (typeof n != "number")
        return n;
      r = n;
    }
  return r;
}
function cy(r, e, t, i, o) {
  if (t instanceof lr) {
    let n = 0;
    for (let s = t.dom.firstChild; s; s = s.nextSibling) {
      let a = Ee.get(s);
      if (a) {
        let l = _n(s, i);
        if (_n(s, r))
          return n + (l ? cy(r, e, a, i, o) : a.localPosFromDOM(r, e));
        n += a.length + (l ? o : 0);
      } else {
        let l = dy(r, e, s);
        if (l.result != null)
          return n + l.result;
        n += l.size;
      }
    }
  } else if (t.dom == i)
    return Math.min(e, i.nodeValue.length);
  return t.localPosFromDOM(r, e);
}
function dy(r, e, t) {
  if (t.nodeType == 3)
    return r == t ? { result: e } : { size: t.nodeValue.length };
  if (t.nodeType == 1 && t.contentEditable != "false") {
    let i = 0;
    for (let o = t.firstChild, n = 0; ; o = o.nextSibling, n++) {
      if (r == t && n == e)
        return { result: i };
      if (!o)
        return { size: i };
      let s = dy(r, e, o);
      if (s.result != null)
        return { result: e + s.result };
      i += s.size;
    }
  } else
    return t.contains(r) ? { result: 0 } : { size: 0 };
}
class Mn extends Ee {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Mn && e.side == this.side;
  }
  split() {
    return new Mn(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? lt.before(this.dom) : lt.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return ve.empty;
  }
  get isHidden() {
    return !0;
  }
}
Do.prototype.children = $r.prototype.children = Mn.prototype.children = xp;
function fy(r, e) {
  let t = r.dom, { children: i } = r, o = 0;
  for (let n = 0; o < i.length; o++) {
    let s = i[o], a = n + s.length;
    if (!(a == n && s.getSide() <= 0)) {
      if (e > n && e < a && s.dom.parentNode == t)
        return s.domAtPos(e - n);
      if (e <= n)
        break;
      n = a;
    }
  }
  for (let n = o; n > 0; n--) {
    let s = i[n - 1];
    if (s.dom.parentNode == t)
      return s.domAtPos(s.length);
  }
  for (let n = o; n < i.length; n++) {
    let s = i[n];
    if (s.dom.parentNode == t)
      return s.domAtPos(0);
  }
  return new lt(t, 0);
}
function py(r, e, t) {
  let i, { children: o } = r;
  t > 0 && e instanceof lr && o.length && (i = o[o.length - 1]) instanceof lr && i.mark.eq(e.mark) ? py(i, e.children[0], t - 1) : (o.push(e), e.setParent(r)), r.length += e.length;
}
function gy(r, e, t) {
  let i = null, o = -1, n = null, s = -1;
  function a(u, h) {
    for (let c = 0, d = 0; c < u.children.length && d <= h; c++) {
      let f = u.children[c], p = d + f.length;
      p >= h && (f.children.length ? a(f, h - d) : (!n || n.isHidden && t > 0) && (p > h || d == p && f.getSide() > 0) ? (n = f, s = h - d) : (d < h || d == p && f.getSide() < 0 && !f.isHidden) && (i = f, o = h - d)), d = p;
    }
  }
  a(r, e);
  let l = (t < 0 ? i : n) || i || n;
  return l ? l.coordsAt(Math.max(0, l == i ? o : s), t) : H$(r);
}
function H$(r) {
  let e = r.dom.lastChild;
  if (!e)
    return r.dom.getBoundingClientRect();
  let t = ra(e);
  return t[t.length - 1] || null;
}
function Ed(r, e) {
  for (let t in r)
    t == "class" && e.class ? e.class += " " + r.class : t == "style" && e.style ? e.style += ";" + r.style : e[t] = r[t];
  return e;
}
function Sp(r, e) {
  if (r == e)
    return !0;
  if (!r || !e)
    return !1;
  let t = Object.keys(r), i = Object.keys(e);
  if (t.length != i.length)
    return !1;
  for (let o of t)
    if (i.indexOf(o) == -1 || r[o] !== e[o])
      return !1;
  return !0;
}
function Td(r, e, t) {
  let i = null;
  if (e)
    for (let o in e)
      t && o in t || r.removeAttribute(i = o);
  if (t)
    for (let o in t)
      e && e[o] == t[o] || r.setAttribute(i = o, t[o]);
  return !!i;
}
class gr {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queried—less than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, i) {
    return null;
  }
  /**
  @internal
  */
  get customView() {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var Ae = /* @__PURE__ */ function(r) {
  return r[r.Text = 0] = "Text", r[r.WidgetBefore = 1] = "WidgetBefore", r[r.WidgetAfter = 2] = "WidgetAfter", r[r.WidgetRange = 3] = "WidgetRange", r;
}(Ae || (Ae = {}));
class J extends _o {
  constructor(e, t, i, o) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = o;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new dh(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Jr(e, t, t, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, o;
    if (e.isBlockGap)
      i = -5e8, o = 4e8;
    else {
      let { start: n, end: s } = my(e, t);
      i = (n ? t ? -3e8 : -1 : 5e8) - 1, o = (s ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Jr(e, i, o, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Qa(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return Se.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
J.none = Se.empty;
class dh extends J {
  constructor(e) {
    let { start: t, end: i } = my(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    return this == e || e instanceof dh && this.tagName == e.tagName && this.class == e.class && Sp(this.attrs, e.attrs);
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
dh.prototype.point = !1;
class Qa extends J {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Qa && this.spec.class == e.spec.class && Sp(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
Qa.prototype.mapMode = at.TrackBefore;
Qa.prototype.point = !0;
class Jr extends J {
  constructor(e, t, i, o, n, s) {
    super(t, i, n, e), this.block = o, this.isReplace = s, this.mapMode = o ? t <= 0 ? at.TrackBefore : at.TrackAfter : at.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? Ae.WidgetRange : this.startSide <= 0 ? Ae.WidgetBefore : Ae.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Jr && j$(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Jr.prototype.point = !0;
function my(r, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = r;
  return t == null && (t = r.inclusive), i == null && (i = r.inclusive), { start: t ?? e, end: i ?? e };
}
function j$(r, e) {
  return r == e || !!(r && e && r.compare(e));
}
function $d(r, e, t, i = 0) {
  let o = t.length - 1;
  o >= 0 && t[o] + i >= r ? t[o] = Math.max(t[o], e) : t.push(r, e);
}
class Xt extends Ee {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, o, n, s) {
    if (i) {
      if (!(i instanceof Xt))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return o && this.setDeco(i ? i.attrs : null), sy(this, e, t, i ? i.children : [], n, s), !0;
  }
  split(e) {
    let t = new Xt();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: o } = this.childPos(e);
    o && (t.append(this.children[i].split(o), 0), this.children[i].merge(o, this.children[i].length, null, !1, 0, 0), i++);
    for (let n = i; n < this.children.length; n++)
      t.append(this.children[n], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Sp(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    py(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = Ed(t, this.attrs || {})), i && (this.attrs = Ed({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return fy(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.dirty |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.dirty & 4 && (ry(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (Td(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let o = this.dom.lastChild;
    for (; o && Ee.get(o) instanceof lr; )
      o = o.lastChild;
    if (!o || !this.length || o.nodeName != "BR" && ((i = Ee.get(o)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!j.ios || !this.children.some((n) => n instanceof Do))) {
      let n = document.createElement("BR");
      n.cmIgnore = !0, this.dom.appendChild(n);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof Do) || /[^ -~]/.test(i.text))
        return null;
      let o = ra(i.dom);
      if (o.length != 1)
        return null;
      e += o[0].width, t = o[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = gy(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: o } = this.parent.view.viewState, n = i.bottom - i.top;
      if (Math.abs(n - o.lineHeight) < 2 && o.textHeight < n) {
        let s = (n - o.textHeight) / 2;
        return { top: i.top + s, bottom: i.bottom - s, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  get type() {
    return Ae.Text;
  }
  static find(e, t) {
    for (let i = 0, o = 0; i < e.children.length; i++) {
      let n = e.children[i], s = o + n.length;
      if (s >= t) {
        if (n instanceof Xt)
          return n;
        if (s > t)
          break;
      }
      o = s + n.breakAfter;
    }
    return null;
  }
}
class Qo extends Ee {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.type = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, o, n, s) {
    return i && (!(i instanceof Qo) || !this.widget.compare(i.widget) || e > 0 && n <= 0 || t < this.length && s <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? lt.before(this.dom) : lt.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new Qo(this.widget, t, this.type);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return xp;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : ve.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof Qo && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.type = e.type, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Cp {
  constructor(e, t, i, o) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = o, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof Qo && e.type == Ae.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new Xt()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(Ja(new Mn(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: n, lineBreak: s, done: a } = this.cursor.next(this.skip);
        if (this.skip = 0, a)
          throw new Error("Ran out of text content when drawing inline views");
        if (s) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = n, this.textOff = 0;
      }
      let o = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* Chunk */
      );
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(Ja(new Do(this.text.slice(this.textOff, this.textOff + o)), t), i), this.atCursorPos = !0, this.textOff += o, e -= o, i = 0;
    }
  }
  span(e, t, i, o) {
    this.buildText(t - e, i, o), this.pos = t, this.openStart < 0 && (this.openStart = o);
  }
  point(e, t, i, o, n, s) {
    if (this.disallowBlockEffectsFor[s] && i instanceof Jr) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let a = t - e;
    if (i instanceof Jr)
      if (i.block) {
        let { type: l } = i;
        l == Ae.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new Qo(i.widget || new zm("div"), a, l));
      } else {
        let l = $r.create(i.widget || new zm("span"), a, a ? 0 : i.startSide), u = this.atCursorPos && !l.isEditable && n <= o.length && (e < t || i.startSide > 0), h = !l.isEditable && (e < t || n > o.length || i.startSide <= 0), c = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(o), u && (c.append(Ja(new Mn(1), o), n), n = o.length + Math.max(0, n - o.length)), c.append(Ja(l, o), n), this.atCursorPos = h, this.pendingBuffer = h ? e < t || n > o.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = o.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    a && (this.textOff + a <= this.text.length ? this.textOff += a : (this.skip += a - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = n);
  }
  static build(e, t, i, o, n) {
    let s = new Cp(e, t, i, n);
    return s.openEnd = Se.spans(o, t, i, s), s.openStart < 0 && (s.openStart = s.openEnd), s.finish(s.openEnd), s;
  }
}
function Ja(r, e) {
  for (let t of e)
    r = new lr(t, [r], r.length);
  return r;
}
class zm extends gr {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const by = /* @__PURE__ */ H.define(), Oy = /* @__PURE__ */ H.define(), vy = /* @__PURE__ */ H.define(), wy = /* @__PURE__ */ H.define(), Rd = /* @__PURE__ */ H.define(), yy = /* @__PURE__ */ H.define(), xy = /* @__PURE__ */ H.define(), Sy = /* @__PURE__ */ H.define({
  combine: (r) => r.some((e) => e)
}), Cy = /* @__PURE__ */ H.define({
  combine: (r) => r.some((e) => e)
});
class cu {
  constructor(e, t = "nearest", i = "nearest", o = 5, n = 5) {
    this.range = e, this.y = t, this.x = i, this.yMargin = o, this.xMargin = n;
  }
  map(e) {
    return e.empty ? this : new cu(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const Nm = /* @__PURE__ */ le.define({ map: (r, e) => r.map(e) });
function li(r, e, t) {
  let i = r.facet(wy);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const fh = /* @__PURE__ */ H.define({ combine: (r) => r.length ? r[0] : !0 });
let G$ = 0;
const ms = /* @__PURE__ */ H.define();
class Je {
  constructor(e, t, i, o) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.extension = o(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: i, provide: o, decorations: n } = t || {};
    return new Je(G$++, e, i, (s) => {
      let a = [ms.of(s)];
      return n && a.push(oa.of((l) => {
        let u = l.plugin(s);
        return u ? n(u) : J.none;
      })), o && a.push(o(s)), a;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Je.define((i) => new e(i), t);
  }
}
class ec {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (li(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        li(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        li(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Qy = /* @__PURE__ */ H.define(), Qp = /* @__PURE__ */ H.define(), oa = /* @__PURE__ */ H.define(), Pp = /* @__PURE__ */ H.define(), Py = /* @__PURE__ */ H.define();
function ky(r) {
  let e = 0, t = 0, i = 0, o = 0;
  for (let n of r.state.facet(Py)) {
    let s = n(r);
    s && (s.left != null && (e = Math.max(e, s.left)), s.right != null && (t = Math.max(t, s.right)), s.top != null && (i = Math.max(i, s.top)), s.bottom != null && (o = Math.max(o, s.bottom)));
  }
  return { left: e, right: t, top: i, bottom: o };
}
const bs = /* @__PURE__ */ H.define();
class Ui {
  constructor(e, t, i, o) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = o;
  }
  join(e) {
    return new Ui(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let o = e[t - 1];
      if (!(o.fromA > i.toA)) {
        if (o.toA < i.fromA)
          break;
        i = i.join(o), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let o = 0, n = 0, s = 0, a = 0; ; o++) {
      let l = o == e.length ? null : e[o], u = s - a, h = l ? l.fromB : 1e9;
      for (; n < t.length && t[n] < h; ) {
        let c = t[n], d = t[n + 1], f = Math.max(a, c), p = Math.min(h, d);
        if (f <= p && new Ui(f + u, p + u, f, p).addToSet(i), d > h)
          break;
        n += 2;
      }
      if (!l)
        return i;
      new Ui(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), s = l.toA, a = l.toB;
    }
  }
}
class du {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = He.empty(this.startState.doc.length);
    for (let n of i)
      this.changes = this.changes.compose(n.changes);
    let o = [];
    this.changes.iterChangedRanges((n, s, a, l) => o.push(new Ui(n, s, a, l))), this.changedRanges = o;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new du(e, t, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var Me = /* @__PURE__ */ function(r) {
  return r[r.LTR = 0] = "LTR", r[r.RTL = 1] = "RTL", r;
}(Me || (Me = {}));
const _d = Me.LTR, K$ = Me.RTL;
function Ey(r) {
  let e = [];
  for (let t = 0; t < r.length; t++)
    e.push(1 << +r[t]);
  return e;
}
const J$ = /* @__PURE__ */ Ey("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), eR = /* @__PURE__ */ Ey("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), Dd = /* @__PURE__ */ Object.create(null), Pi = [];
for (let r of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ r.charCodeAt(0), t = /* @__PURE__ */ r.charCodeAt(1);
  Dd[e] = t, Dd[t] = -e;
}
function tR(r) {
  return r <= 247 ? J$[r] : 1424 <= r && r <= 1524 ? 2 : 1536 <= r && r <= 1785 ? eR[r - 1536] : 1774 <= r && r <= 2220 ? 4 : 8192 <= r && r <= 8203 ? 256 : 64336 <= r && r <= 65023 ? 4 : r == 8204 ? 256 : 1;
}
const iR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class vn {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? K$ : _d;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, t, i, o) {
    let n = -1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      if (a.from <= t && a.to >= t) {
        if (a.level == i)
          return s;
        (n < 0 || (o != 0 ? o < 0 ? a.from < t : a.to > t : e[n].level > a.level)) && (n = s);
      }
    }
    if (n < 0)
      throw new RangeError("Index out of range");
    return n;
  }
}
const De = [];
function rR(r, e) {
  let t = r.length, i = e == _d ? 1 : 2, o = e == _d ? 2 : 1;
  if (!r || i == 1 && !iR.test(r))
    return Ty(t);
  for (let s = 0, a = i, l = i; s < t; s++) {
    let u = tR(r.charCodeAt(s));
    u == 512 ? u = a : u == 8 && l == 4 && (u = 16), De[s] = u == 4 ? 2 : u, u & 7 && (l = u), a = u;
  }
  for (let s = 0, a = i, l = i; s < t; s++) {
    let u = De[s];
    if (u == 128)
      s < t - 1 && a == De[s + 1] && a & 24 ? u = De[s] = a : De[s] = 256;
    else if (u == 64) {
      let h = s + 1;
      for (; h < t && De[h] == 64; )
        h++;
      let c = s && a == 8 || h < t && De[h] == 8 ? l == 1 ? 1 : 8 : 256;
      for (let d = s; d < h; d++)
        De[d] = c;
      s = h - 1;
    } else
      u == 8 && l == 1 && (De[s] = 1);
    a = u, u & 7 && (l = u);
  }
  for (let s = 0, a = 0, l = 0, u, h, c; s < t; s++)
    if (h = Dd[u = r.charCodeAt(s)])
      if (h < 0) {
        for (let d = a - 3; d >= 0; d -= 3)
          if (Pi[d + 1] == -h) {
            let f = Pi[d + 2], p = f & 2 ? i : f & 4 ? f & 1 ? o : i : 0;
            p && (De[s] = De[Pi[d]] = p), a = d;
            break;
          }
      } else {
        if (Pi.length == 189)
          break;
        Pi[a++] = s, Pi[a++] = u, Pi[a++] = l;
      }
    else if ((c = De[s]) == 2 || c == 1) {
      let d = c == i;
      l = d ? 0 : 1;
      for (let f = a - 3; f >= 0; f -= 3) {
        let p = Pi[f + 2];
        if (p & 2)
          break;
        if (d)
          Pi[f + 2] |= 2;
        else {
          if (p & 4)
            break;
          Pi[f + 2] |= 4;
        }
      }
    }
  for (let s = 0; s < t; s++)
    if (De[s] == 256) {
      let a = s + 1;
      for (; a < t && De[a] == 256; )
        a++;
      let l = (s ? De[s - 1] : i) == 1, u = (a < t ? De[a] : i) == 1, h = l == u ? l ? 1 : 2 : i;
      for (let c = s; c < a; c++)
        De[c] = h;
      s = a - 1;
    }
  let n = [];
  if (i == 1)
    for (let s = 0; s < t; ) {
      let a = s, l = De[s++] != 1;
      for (; s < t && l == (De[s] != 1); )
        s++;
      if (l)
        for (let u = s; u > a; ) {
          let h = u, c = De[--u] != 2;
          for (; u > a && c == (De[u - 1] != 2); )
            u--;
          n.push(new vn(u, h, c ? 2 : 1));
        }
      else
        n.push(new vn(a, s, 0));
    }
  else
    for (let s = 0; s < t; ) {
      let a = s, l = De[s++] == 2;
      for (; s < t && l == (De[s] == 2); )
        s++;
      n.push(new vn(a, s, l ? 1 : 2));
    }
  return n;
}
function Ty(r) {
  return [new vn(0, r, 0)];
}
let $y = "";
function oR(r, e, t, i, o) {
  var n;
  let s = i.head - r.from, a = -1;
  if (s == 0) {
    if (!o || !r.length)
      return null;
    e[0].level != t && (s = e[0].side(!1, t), a = 0);
  } else if (s == r.length) {
    if (o)
      return null;
    let d = e[e.length - 1];
    d.level != t && (s = d.side(!0, t), a = e.length - 1);
  }
  a < 0 && (a = vn.find(e, s, (n = i.bidiLevel) !== null && n !== void 0 ? n : -1, i.assoc));
  let l = e[a];
  s == l.side(o, t) && (l = e[a += o ? 1 : -1], s = l.side(!o, t));
  let u = o == (l.dir == t), h = Pt(r.text, s, u);
  if ($y = r.text.slice(Math.min(s, h), Math.max(s, h)), h != l.side(o, t))
    return D.cursor(h + r.from, u ? -1 : 1, l.level);
  let c = a == (o ? e.length - 1 : 0) ? null : e[a + (o ? 1 : -1)];
  return !c && l.level != t ? D.cursor(o ? r.to : r.from, o ? -1 : 1, t) : c && c.level < l.level ? D.cursor(c.side(!o, t) + r.from, o ? 1 : -1, c.level) : D.cursor(h + r.from, o ? -1 : 1, l.level);
}
const an = "￿";
class Ry {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(be.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += an;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let o = e; ; ) {
      this.findPointBefore(i, o);
      let n = this.text.length;
      this.readNode(o);
      let s = o.nextSibling;
      if (s == t)
        break;
      let a = Ee.get(o), l = Ee.get(s);
      (a && l ? a.breakAfter : (a ? a.breakAfter : Vm(o)) || Vm(s) && (o.nodeName != "BR" || o.cmIgnore) && this.text.length > n) && this.lineBreak(), o = s;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, o = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let n = -1, s = 1, a;
      if (this.lineSeparator ? (n = t.indexOf(this.lineSeparator, i), s = this.lineSeparator.length) : (a = o.exec(t)) && (n = a.index, s = a[0].length), this.append(t.slice(i, n < 0 ? t.length : n)), n < 0)
        break;
      if (this.lineBreak(), s > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= s - 1);
      i = n + s;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Ee.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let o = i.iter(); !o.next().done; )
        o.lineBreak ? this.lineBreak() : this.append(o.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + Math.min(t, i.offset));
  }
}
function Vm(r) {
  return r.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(r.nodeName);
}
class Zm {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
class Lm extends Ee {
  constructor(e) {
    super(), this.view = e, this.compositionDeco = J.none, this.decorations = [], this.dynamicDecorationMap = [], this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new Xt()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new Ui(0, 0, 0, e.state.doc.length)], 0);
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state.
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: s, toA: a }) => a < this.minWidthFrom || s > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0), this.view.inputState.composing < 0 ? this.compositionDeco = J.none : (e.transactions.length || this.dirty) && (this.compositionDeco = sR(this.view, e.changes)), (j.ie || j.chrome) && !this.compositionDeco.size && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let i = this.decorations, o = this.updateDeco(), n = hR(i, o, e.changes);
    return t = Ui.extendWithRanges(t, n), this.dirty == 0 && t.length == 0 ? !1 : (this.updateInner(t, e.startState.doc.length), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t);
    let { observer: i } = this.view;
    i.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let n = j.chrome || j.ios ? { node: i.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, n), this.dirty = 0, n && (n.written || i.selectionRange.focusNode != n.node) && (this.forceSelection = !0), this.dom.style.height = "";
    });
    let o = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let n of this.children)
        n instanceof Qo && n.widget instanceof Wm && o.push(n.dom);
    i.updateGaps(o);
  }
  updateChildren(e, t) {
    let i = this.childCursor(t);
    for (let o = e.length - 1; ; o--) {
      let n = o >= 0 ? e[o] : null;
      if (!n)
        break;
      let { fromA: s, toA: a, fromB: l, toB: u } = n, { content: h, breakAtStart: c, openStart: d, openEnd: f } = Cp.build(this.view.state.doc, l, u, this.decorations, this.dynamicDecorationMap), { i: p, off: g } = i.findPos(a, 1), { i: b, off: m } = i.findPos(s, -1);
      ny(this, b, m, p, g, h, c, d, f);
    }
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, o = i == this.dom, n = !o && Cl(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(o || t || n))
      return;
    let s = this.forceSelection;
    this.forceSelection = !1;
    let a = this.view.state.selection.main, l = this.domAtPos(a.anchor), u = a.empty ? l : this.domAtPos(a.head);
    if (j.gecko && a.empty && !this.compositionDeco.size && nR(l)) {
      let c = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(c, l.node.childNodes[l.offset] || null)), l = u = new lt(c, 0), s = !0;
    }
    let h = this.view.observer.selectionRange;
    (s || !h.focusNode || !uu(l.node, l.offset, h.anchorNode, h.anchorOffset) || !uu(u.node, u.offset, h.focusNode, h.focusOffset)) && (this.view.observer.ignore(() => {
      j.android && j.chrome && this.dom.contains(h.focusNode) && cR(h.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let c = lu(this.view.root);
      if (c)
        if (a.empty) {
          if (j.gecko) {
            let d = lR(l.node, l.offset);
            if (d && d != 3) {
              let f = Dy(l.node, l.offset, d == 1 ? 1 : -1);
              f && (l = new lt(f, d == 1 ? 0 : f.nodeValue.length));
            }
          }
          c.collapse(l.node, l.offset), a.bidiLevel != null && h.cursorBidiLevel != null && (h.cursorBidiLevel = a.bidiLevel);
        } else if (c.extend) {
          c.collapse(l.node, l.offset);
          try {
            c.extend(u.node, u.offset);
          } catch {
          }
        } else {
          let d = document.createRange();
          a.anchor > a.head && ([l, u] = [u, l]), d.setEnd(u.node, u.offset), d.setStart(l.node, l.offset), c.removeAllRanges(), c.addRange(d);
        }
      n && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new lt(h.anchorNode, h.anchorOffset), this.impreciseHead = u.precise ? null : new lt(h.focusNode, h.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.compositionDeco.size)
      return;
    let { view: e } = this, t = e.state.selection.main, i = lu(e.root), { anchorNode: o, anchorOffset: n } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let s = Xt.find(this, t.head);
    if (!s)
      return;
    let a = s.posAtStart;
    if (t.head == a || t.head == a + s.length)
      return;
    let l = this.coordsAt(t.head, -1), u = this.coordsAt(t.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let h = this.domAtPos(t.head + t.assoc);
    i.collapse(h.node, h.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let c = e.observer.selectionRange;
    e.docView.posFromDOM(c.anchorNode, c.anchorOffset) != t.from && i.collapse(o, n);
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = Ee.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let o = this.children[t];
      if (i < o.length || o instanceof Xt)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    for (let i = this.length, o = this.children.length - 1; ; o--) {
      let n = this.children[o], s = i - n.breakAfter - n.length;
      if (e > s || e == s && n.type != Ae.WidgetBefore && n.type != Ae.WidgetAfter && (!o || t == 2 || this.children[o - 1].breakAfter || this.children[o - 1].type == Ae.WidgetBefore && t > -2))
        return n.coordsAt(e - s, t);
      i = s;
    }
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: o } = e, n = this.view.contentDOM.clientWidth, s = n > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, a = -1, l = this.view.textDirection == Me.LTR;
    for (let u = 0, h = 0; h < this.children.length; h++) {
      let c = this.children[h], d = u + c.length;
      if (d > o)
        break;
      if (u >= i) {
        let f = c.dom.getBoundingClientRect();
        if (t.push(f.height), s) {
          let p = c.dom.lastChild, g = p ? ra(p) : [];
          if (g.length) {
            let b = g[g.length - 1], m = l ? b.right - f.left : f.right - b.left;
            m > a && (a = m, this.minWidth = n, this.minWidthFrom = u, this.minWidthTo = d);
          }
        }
      }
      u = d + c.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? Me.RTL : Me.LTR;
  }
  measureTextSize() {
    for (let n of this.children)
      if (n instanceof Xt) {
        let s = n.measureTextSize();
        if (s)
          return s;
      }
    let e = document.createElement("div"), t, i, o;
    return e.className = "cm-line", e.style.width = "99999px", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let n = ra(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = n ? n.width / 27 : 7, o = n ? n.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: o };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new oy(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, o = 0; ; o++) {
      let n = o == t.viewports.length ? null : t.viewports[o], s = n ? n.from - 1 : this.length;
      if (s > i) {
        let a = t.lineBlockAt(s).bottom - t.lineBlockAt(i).top;
        e.push(J.replace({
          widget: new Wm(a),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, s));
      }
      if (!n)
        break;
      i = n.to + 1;
    }
    return J.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(oa).map((t, i) => (this.dynamicDecorationMap[i] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1;
    return this.decorations = [
      ...e,
      this.compositionDeco,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), o;
    if (!i)
      return;
    !t.empty && (o = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, o.left),
      top: Math.min(i.top, o.top),
      right: Math.max(i.right, o.right),
      bottom: Math.max(i.bottom, o.bottom)
    });
    let n = ky(this.view), s = {
      left: i.left - n.left,
      top: i.top - n.top,
      right: i.right + n.right,
      bottom: i.bottom + n.bottom
    };
    I$(this.view.scrollDOM, s, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == Me.LTR);
  }
}
function nR(r) {
  return r.node.nodeType == 1 && r.node.firstChild && (r.offset == 0 || r.node.childNodes[r.offset - 1].contentEditable == "false") && (r.offset == r.node.childNodes.length || r.node.childNodes[r.offset].contentEditable == "false");
}
class Wm extends gr {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function _y(r) {
  let e = r.observer.selectionRange, t = e.focusNode && Dy(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let i = r.docView.nearest(t);
  if (!i)
    return null;
  if (i instanceof Xt) {
    let o = t;
    for (; o.parentNode != i.dom; )
      o = o.parentNode;
    let n = o.previousSibling;
    for (; n && !Ee.get(n); )
      n = n.previousSibling;
    let s = n ? Ee.get(n).posAtEnd : i.posAtStart;
    return { from: s, to: s, node: o, text: t };
  } else {
    for (; ; ) {
      let { parent: n } = i;
      if (!n)
        return null;
      if (n instanceof Xt)
        break;
      i = n;
    }
    let o = i.posAtStart;
    return { from: o, to: o + i.length, node: i.dom, text: t };
  }
}
function sR(r, e) {
  let t = _y(r);
  if (!t)
    return J.none;
  let { from: i, to: o, node: n, text: s } = t, a = e.mapPos(i, 1), l = Math.max(a, e.mapPos(o, -1)), { state: u } = r, h = new Ry([], u);
  n.nodeType == 3 ? h.readTextNode(n) : h.readRange(n.firstChild, null);
  let { text: c } = h;
  if (c.indexOf(an) > -1)
    return J.none;
  if (l - a < c.length)
    if (u.doc.sliceString(a, Math.min(u.doc.length, a + c.length)) == c)
      l = a + c.length;
    else if (u.doc.sliceString(Math.max(0, l - c.length), l) == c)
      a = l - c.length;
    else
      return J.none;
  else if (u.doc.sliceString(a, l) != c)
    return J.none;
  let d = Ee.get(n);
  return d instanceof uy ? d = d.widget.topView : d && (d.parent = null), J.set(J.replace({ widget: new aR(n, s, d), inclusive: !0 }).range(a, l));
}
class aR extends gr {
  constructor(e, t, i) {
    super(), this.top = e, this.text = t, this.topView = i;
  }
  eq(e) {
    return this.top == e.top && this.text == e.text;
  }
  toDOM() {
    return this.top;
  }
  ignoreEvent() {
    return !1;
  }
  get customView() {
    return uy;
  }
}
function Dy(r, e, t) {
  if (t <= 0)
    for (let i = r, o = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && o > 0)
        i = i.childNodes[o - 1], o = Kr(i);
      else
        break;
    }
  if (t >= 0)
    for (let i = r, o = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && o < i.childNodes.length && t >= 0)
        i = i.childNodes[o], o = 0;
      else
        break;
    }
  return null;
}
function lR(r, e) {
  return r.nodeType != 1 ? 0 : (e && r.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < r.childNodes.length && r.childNodes[e].contentEditable == "false" ? 2 : 0);
}
class uR {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    $d(e, t, this.changes);
  }
  comparePoint(e, t) {
    $d(e, t, this.changes);
  }
}
function hR(r, e, t) {
  let i = new uR();
  return Se.compare(r, e, t, i), i.changes;
}
function cR(r, e) {
  for (let t = r; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function dR(r, e, t = 1) {
  let i = r.charCategorizer(e), o = r.doc.lineAt(e), n = e - o.from;
  if (o.length == 0)
    return D.cursor(e);
  n == 0 ? t = 1 : n == o.length && (t = -1);
  let s = n, a = n;
  t < 0 ? s = Pt(o.text, n, !1) : a = Pt(o.text, n);
  let l = i(o.text.slice(s, a));
  for (; s > 0; ) {
    let u = Pt(o.text, s, !1);
    if (i(o.text.slice(u, s)) != l)
      break;
    s = u;
  }
  for (; a < o.length; ) {
    let u = Pt(o.text, a);
    if (i(o.text.slice(a, u)) != l)
      break;
    a = u;
  }
  return D.range(s + o.from, a + o.from);
}
function fR(r, e) {
  return e.left > r ? e.left - r : Math.max(0, r - e.right);
}
function pR(r, e) {
  return e.top > r ? e.top - r : Math.max(0, r - e.bottom);
}
function tc(r, e) {
  return r.top < e.bottom - 1 && r.bottom > e.top + 1;
}
function Im(r, e) {
  return e < r.top ? { top: e, left: r.left, right: r.right, bottom: r.bottom } : r;
}
function Um(r, e) {
  return e > r.bottom ? { top: r.top, left: r.left, right: r.right, bottom: e } : r;
}
function Md(r, e, t) {
  let i, o, n, s, a = !1, l, u, h, c;
  for (let p = r.firstChild; p; p = p.nextSibling) {
    let g = ra(p);
    for (let b = 0; b < g.length; b++) {
      let m = g[b];
      o && tc(o, m) && (m = Im(Um(m, o.bottom), o.top));
      let v = fR(e, m), S = pR(t, m);
      if (v == 0 && S == 0)
        return p.nodeType == 3 ? Ym(p, e, t) : Md(p, e, t);
      if (!i || s > S || s == S && n > v) {
        i = p, o = m, n = v, s = S;
        let y = S ? t < m.top ? -1 : 1 : v ? e < m.left ? -1 : 1 : 0;
        a = !y || (y > 0 ? b < g.length - 1 : b > 0);
      }
      v == 0 ? t > m.bottom && (!h || h.bottom < m.bottom) ? (l = p, h = m) : t < m.top && (!c || c.top > m.top) && (u = p, c = m) : h && tc(h, m) ? h = Um(h, m.bottom) : c && tc(c, m) && (c = Im(c, m.top));
    }
  }
  if (h && h.bottom >= t ? (i = l, o = h) : c && c.top <= t && (i = u, o = c), !i)
    return { node: r, offset: 0 };
  let d = Math.max(o.left, Math.min(o.right, e));
  if (i.nodeType == 3)
    return Ym(i, d, t);
  if (a && i.contentEditable != "false")
    return Md(i, d, t);
  let f = Array.prototype.indexOf.call(r.childNodes, i) + (e >= (o.left + o.right) / 2 ? 1 : 0);
  return { node: r, offset: f };
}
function Ym(r, e, t) {
  let i = r.nodeValue.length, o = -1, n = 1e9, s = 0;
  for (let a = 0; a < i; a++) {
    let l = Dn(r, a, a + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let h = l[u];
      if (h.top == h.bottom)
        continue;
      s || (s = e - h.left);
      let c = (h.top > t ? h.top - t : t - h.bottom) - 1;
      if (h.left - 1 <= e && h.right + 1 >= e && c < n) {
        let d = e >= (h.left + h.right) / 2, f = d;
        if ((j.chrome || j.gecko) && Dn(r, a).getBoundingClientRect().left == h.right && (f = !d), c <= 0)
          return { node: r, offset: a + (f ? 1 : 0) };
        o = a + (f ? 1 : 0), n = c;
      }
    }
  }
  return { node: r, offset: o > -1 ? o : s > 0 ? r.nodeValue.length : 0 };
}
function My(r, e, t, i = -1) {
  var o, n;
  let s = r.contentDOM.getBoundingClientRect(), a = s.top + r.viewState.paddingTop, l, { docHeight: u } = r.viewState, { x: h, y: c } = e, d = c - a;
  if (d < 0)
    return 0;
  if (d > u)
    return r.state.doc.length;
  for (let y = r.viewState.heightOracle.textHeight / 2, x = !1; l = r.elementAtHeight(d), l.type != Ae.Text; )
    for (; d = i > 0 ? l.bottom + y : l.top - y, !(d >= 0 && d <= u); ) {
      if (x)
        return t ? null : 0;
      x = !0, i = -i;
    }
  c = a + d;
  let f = l.from;
  if (f < r.viewport.from)
    return r.viewport.from == 0 ? 0 : t ? null : Fm(r, s, l, h, c);
  if (f > r.viewport.to)
    return r.viewport.to == r.state.doc.length ? r.state.doc.length : t ? null : Fm(r, s, l, h, c);
  let p = r.dom.ownerDocument, g = r.root.elementFromPoint ? r.root : p, b = g.elementFromPoint(h, c);
  b && !r.contentDOM.contains(b) && (b = null), b || (h = Math.max(s.left + 1, Math.min(s.right - 1, h)), b = g.elementFromPoint(h, c), b && !r.contentDOM.contains(b) && (b = null));
  let m, v = -1;
  if (b && ((o = r.docView.nearest(b)) === null || o === void 0 ? void 0 : o.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let y = p.caretPositionFromPoint(h, c);
      y && ({ offsetNode: m, offset: v } = y);
    } else if (p.caretRangeFromPoint) {
      let y = p.caretRangeFromPoint(h, c);
      y && ({ startContainer: m, startOffset: v } = y, (!r.contentDOM.contains(m) || j.safari && gR(m, v, h) || j.chrome && mR(m, v, h)) && (m = void 0));
    }
  }
  if (!m || !r.docView.dom.contains(m)) {
    let y = Xt.find(r.docView, f);
    if (!y)
      return d > l.top + l.height / 2 ? l.to : l.from;
    ({ node: m, offset: v } = Md(y.dom, h, c));
  }
  let S = r.docView.nearest(m);
  if (!S)
    return null;
  if (S.isWidget && ((n = S.dom) === null || n === void 0 ? void 0 : n.nodeType) == 1) {
    let y = S.dom.getBoundingClientRect();
    return e.y < y.top || e.y <= y.bottom && e.x <= (y.left + y.right) / 2 ? S.posAtStart : S.posAtEnd;
  } else
    return S.localPosFromDOM(m, v) + S.posAtStart;
}
function Fm(r, e, t, i, o) {
  let n = Math.round((i - e.left) * r.defaultCharacterWidth);
  if (r.lineWrapping && t.height > r.defaultLineHeight * 1.5) {
    let a = r.viewState.heightOracle.textHeight, l = Math.floor((o - t.top - (r.defaultLineHeight - a) * 0.5) / a);
    n += l * r.viewState.heightOracle.lineLength;
  }
  let s = r.state.sliceDoc(t.from, t.to);
  return t.from + wd(s, n, r.state.tabSize);
}
function gR(r, e, t) {
  let i;
  if (r.nodeType != 3 || e != (i = r.nodeValue.length))
    return !1;
  for (let o = r.nextSibling; o; o = o.nextSibling)
    if (o.nodeType != 1 || o.nodeName != "BR")
      return !1;
  return Dn(r, i - 1, i).getBoundingClientRect().left > t;
}
function mR(r, e, t) {
  if (e != 0)
    return !1;
  for (let o = r; ; ) {
    let n = o.parentNode;
    if (!n || n.nodeType != 1 || n.firstChild != o)
      return !1;
    if (n.classList.contains("cm-line"))
      break;
    o = n;
  }
  let i = r.nodeType == 1 ? r.getBoundingClientRect() : Dn(r, 0, Math.max(r.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function Xd(r, e) {
  let t = r.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == Ae.Text))
        return i;
  }
  return t;
}
function bR(r, e, t, i) {
  let o = Xd(r, e.head), n = !i || o.type != Ae.Text || !(r.lineWrapping || o.widgetLineBreaks) ? null : r.coordsAtPos(e.assoc < 0 && e.head > o.from ? e.head - 1 : e.head);
  if (n) {
    let s = r.dom.getBoundingClientRect(), a = r.textDirectionAt(o.from), l = r.posAtCoords({
      x: t == (a == Me.LTR) ? s.right - 1 : s.left + 1,
      y: (n.top + n.bottom) / 2
    });
    if (l != null)
      return D.cursor(l, t ? -1 : 1);
  }
  return D.cursor(t ? o.to : o.from, t ? -1 : 1);
}
function Bm(r, e, t, i) {
  let o = r.state.doc.lineAt(e.head), n = r.bidiSpans(o), s = r.textDirectionAt(o.from);
  for (let a = e, l = null; ; ) {
    let u = oR(o, n, s, a, t), h = $y;
    if (!u) {
      if (o.number == (t ? r.state.doc.lines : 1))
        return a;
      h = `
`, o = r.state.doc.line(o.number + (t ? 1 : -1)), n = r.bidiSpans(o), u = D.cursor(t ? o.from : o.to);
    }
    if (l) {
      if (!l(h))
        return a;
    } else {
      if (!i)
        return u;
      l = i(h);
    }
    a = u;
  }
}
function OR(r, e, t) {
  let i = r.state.charCategorizer(e), o = i(t);
  return (n) => {
    let s = i(n);
    return o == Re.Space && (o = s), o == s;
  };
}
function vR(r, e, t, i) {
  let o = e.head, n = t ? 1 : -1;
  if (o == (t ? r.state.doc.length : 0))
    return D.cursor(o, e.assoc);
  let s = e.goalColumn, a, l = r.contentDOM.getBoundingClientRect(), u = r.coordsAtPos(o), h = r.documentTop;
  if (u)
    s == null && (s = u.left - l.left), a = n < 0 ? u.top : u.bottom;
  else {
    let f = r.viewState.lineBlockAt(o);
    s == null && (s = Math.min(l.right - l.left, r.defaultCharacterWidth * (o - f.from))), a = (n < 0 ? f.top : f.bottom) + h;
  }
  let c = l.left + s, d = i ?? r.viewState.heightOracle.textHeight >> 1;
  for (let f = 0; ; f += 10) {
    let p = a + (d + f) * n, g = My(r, { x: c, y: p }, !1, n);
    if (p < l.top || p > l.bottom || (n < 0 ? g < o : g > o))
      return D.cursor(g, e.assoc, void 0, s);
  }
}
function Ql(r, e, t) {
  for (; ; ) {
    let i = 0;
    for (let o of r)
      o.between(e - 1, e + 1, (n, s, a) => {
        if (e > n && e < s) {
          let l = i || t || (e - n < s - e ? -1 : 1);
          e = l < 0 ? n : s, i = l;
        }
      });
    if (!i)
      return e;
  }
}
function ic(r, e, t) {
  let i = Ql(r.state.facet(Pp).map((o) => o(r)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : D.cursor(i, i < t.from ? 1 : -1);
}
class wR {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null;
    let t = (i, o) => {
      this.ignoreDuringComposition(o) || o.type == "keydown" && this.keydown(e, o) || (this.mustFlushObserver(o) && e.observer.forceFlush(), this.runCustomHandlers(o.type, e, o) ? o.preventDefault() : i(e, o));
    };
    for (let i in Be) {
      let o = Be[i];
      e.contentDOM.addEventListener(i, (n) => {
        qm(e, n) && t(o, n);
      }, Ad[i]), this.registeredEvents.push(i);
    }
    e.scrollDOM.addEventListener("mousedown", (i) => {
      if (i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && (t(Be.mousedown, i), !i.defaultPrevented && i.button == 2)) {
        let o = e.contentDOM.style.minHeight;
        e.contentDOM.style.minHeight = "100%", setTimeout(() => e.contentDOM.style.minHeight = o, 200);
      }
    }), e.scrollDOM.addEventListener("drop", (i) => {
      i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && t(Be.drop, i);
    }), j.chrome && j.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: !0 }), this.notifiedFocused = e.hasFocus, j.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e, t) {
    var i;
    let o;
    this.customHandlers = [];
    for (let n of t)
      if (o = (i = n.update(e).spec) === null || i === void 0 ? void 0 : i.domEventHandlers) {
        this.customHandlers.push({ plugin: n.value, handlers: o });
        for (let s in o)
          this.registeredEvents.indexOf(s) < 0 && s != "scroll" && (this.registeredEvents.push(s), e.contentDOM.addEventListener(s, (a) => {
            qm(e, a) && this.runCustomHandlers(s, e, a) && a.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, t, i) {
    for (let o of this.customHandlers) {
      let n = o.handlers[e];
      if (n)
        try {
          if (n.call(o.plugin, i, t) || i.defaultPrevented)
            return !0;
        } catch (s) {
          li(t.state, s);
        }
    }
    return !1;
  }
  runScrollHandlers(e, t) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let i of this.customHandlers) {
      let o = i.handlers.scroll;
      if (o)
        try {
          o.call(i.plugin, t, e);
        } catch (n) {
          li(e.state, n);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (t.keyCode != 27 && Ay.indexOf(t.keyCode) < 0 && (e.inputState.lastEscPress = 0), j.android && j.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let i;
    return j.ios && !t.synthetic && !t.altKey && !t.metaKey && ((i = Xy.find((o) => o.keyCode == t.keyCode)) && !t.ctrlKey || yR.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = i || t, setTimeout(() => this.flushIOSKey(e), 250), !0) : !1;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, On(e.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : j.safari && !j.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const Xy = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], yR = "dthko", Ay = [16, 17, 18, 20, 91, 92, 224, 225], el = 6;
function tl(r) {
  return Math.max(0, r) * 0.7 + 8;
}
class xR {
  constructor(e, t, i, o) {
    this.view = e, this.style = i, this.mustSelect = o, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = U$(e.contentDOM), this.atoms = e.state.facet(Pp).map((s) => s(e));
    let n = e.contentDOM.ownerDocument;
    n.addEventListener("mousemove", this.move = this.move.bind(this)), n.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(be.allowMultipleSelections) && SR(e, t), this.dragging = QR(e, t) && Zy(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && (e.preventDefault(), this.select(e));
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging !== !1)
      return;
    this.select(this.lastEvent = e);
    let i = 0, o = 0, n = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, s = ky(this.view);
    e.clientX - s.left <= n.left + el ? i = -tl(n.left - e.clientX) : e.clientX + s.right >= n.right - el && (i = tl(e.clientX - n.right)), e.clientY - s.top <= n.top + el ? o = -tl(n.top - e.clientY) : e.clientY + s.bottom >= n.bottom - el && (o = tl(e.clientY - n.bottom)), this.setScrollSpeed(i, o);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let o = e.ranges[i], n = null;
      if (o.empty) {
        let s = Ql(this.atoms, o.from, 0);
        s != o.from && (n = D.cursor(s, -1));
      } else {
        let s = Ql(this.atoms, o.from, -1), a = Ql(this.atoms, o.to, 1);
        (s != o.from || a != o.to) && (n = D.range(o.from == o.anchor ? s : a, o.from == o.head ? s : a));
      }
      n && (t || (t = e.ranges.slice()), t[i] = n);
    }
    return t ? D.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection) || i.main.assoc != t.state.selection.main.assoc) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function SR(r, e) {
  let t = r.state.facet(by);
  return t.length ? t[0](e) : j.mac ? e.metaKey : e.ctrlKey;
}
function CR(r, e) {
  let t = r.state.facet(Oy);
  return t.length ? t[0](e) : j.mac ? !e.altKey : !e.ctrlKey;
}
function QR(r, e) {
  let { main: t } = r.state.selection;
  if (t.empty)
    return !1;
  let i = lu(r.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let o = i.getRangeAt(0).getClientRects();
  for (let n = 0; n < o.length; n++) {
    let s = o[n];
    if (s.left <= e.clientX && s.right >= e.clientX && s.top <= e.clientY && s.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function qm(r, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != r.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = Ee.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const Be = /* @__PURE__ */ Object.create(null), Ad = /* @__PURE__ */ Object.create(null), zy = j.ie && j.ie_version < 15 || j.ios && j.webkit_version < 604;
function PR(r) {
  let e = r.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    r.focus(), t.remove(), Ny(r, t.value);
  }, 50);
}
function Ny(r, e) {
  let { state: t } = r, i, o = 1, n = t.toText(e), s = n.lines == t.selection.ranges.length;
  if (zd != null && t.selection.ranges.every((l) => l.empty) && zd == n.toString()) {
    let l = -1;
    i = t.changeByRange((u) => {
      let h = t.doc.lineAt(u.from);
      if (h.from == l)
        return { range: u };
      l = h.from;
      let c = t.toText((s ? n.line(o++).text : e) + t.lineBreak);
      return {
        changes: { from: h.from, insert: c },
        range: D.cursor(u.from + c.length)
      };
    });
  } else
    s ? i = t.changeByRange((l) => {
      let u = n.line(o++);
      return {
        changes: { from: l.from, to: l.to, insert: u.text },
        range: D.cursor(l.from + u.length)
      };
    }) : i = t.replaceSelection(n);
  r.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
Be.keydown = (r, e) => {
  r.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (r.inputState.lastEscPress = Date.now());
};
Be.touchstart = (r, e) => {
  r.inputState.lastTouchTime = Date.now(), r.inputState.setSelectionOrigin("select.pointer");
};
Be.touchmove = (r) => {
  r.inputState.setSelectionOrigin("select.pointer");
};
Ad.touchstart = Ad.touchmove = { passive: !0 };
Be.mousedown = (r, e) => {
  if (r.observer.flush(), r.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let t = null;
  for (let i of r.state.facet(vy))
    if (t = i(r, e), t)
      break;
  if (!t && e.button == 0 && (t = TR(r, e)), t) {
    let i = r.root.activeElement != r.contentDOM;
    r.inputState.startMouseSelection(new xR(r, e, t, i)), i && r.observer.ignore(() => iy(r.contentDOM)), r.inputState.mouseSelection && r.inputState.mouseSelection.start(e);
  }
};
function Hm(r, e, t, i) {
  if (i == 1)
    return D.cursor(e, t);
  if (i == 2)
    return dR(r.state, e, t);
  {
    let o = Xt.find(r.docView, e), n = r.state.doc.lineAt(o ? o.posAtEnd : e), s = o ? o.posAtStart : n.from, a = o ? o.posAtEnd : n.to;
    return a < r.state.doc.length && a == n.to && a++, D.range(s, a);
  }
}
let Vy = (r, e) => r >= e.top && r <= e.bottom, jm = (r, e, t) => Vy(e, t) && r >= t.left && r <= t.right;
function kR(r, e, t, i) {
  let o = Xt.find(r.docView, e);
  if (!o)
    return 1;
  let n = e - o.posAtStart;
  if (n == 0)
    return 1;
  if (n == o.length)
    return -1;
  let s = o.coordsAt(n, -1);
  if (s && jm(t, i, s))
    return -1;
  let a = o.coordsAt(n, 1);
  return a && jm(t, i, a) ? 1 : s && Vy(i, s) ? -1 : 1;
}
function Gm(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: kR(r, t, e.clientX, e.clientY) };
}
const ER = j.ie && j.ie_version <= 11;
let Km = null, Jm = 0, eb = 0;
function Zy(r) {
  if (!ER)
    return r.detail;
  let e = Km, t = eb;
  return Km = r, eb = Date.now(), Jm = !e || t > Date.now() - 400 && Math.abs(e.clientX - r.clientX) < 2 && Math.abs(e.clientY - r.clientY) < 2 ? (Jm + 1) % 3 : 1;
}
function TR(r, e) {
  let t = Gm(r, e), i = Zy(e), o = r.state.selection;
  return {
    update(n) {
      n.docChanged && (t.pos = n.changes.mapPos(t.pos), o = o.map(n.changes));
    },
    get(n, s, a) {
      let l = Gm(r, n), u, h = Hm(r, l.pos, l.bias, i);
      if (t.pos != l.pos && !s) {
        let c = Hm(r, t.pos, t.bias, i), d = Math.min(c.from, h.from), f = Math.max(c.to, h.to);
        h = d < h.from ? D.range(d, f) : D.range(f, d);
      }
      return s ? o.replaceRange(o.main.extend(h.from, h.to)) : a && i == 1 && o.ranges.length > 1 && (u = $R(o, l.pos)) ? u : a ? o.addRange(h) : D.create([h]);
    }
  };
}
function $R(r, e) {
  for (let t = 0; t < r.ranges.length; t++) {
    let { from: i, to: o } = r.ranges[t];
    if (i <= e && o >= e)
      return D.create(r.ranges.slice(0, t).concat(r.ranges.slice(t + 1)), r.mainIndex == t ? 0 : r.mainIndex - (r.mainIndex > t ? 1 : 0));
  }
  return null;
}
Be.dragstart = (r, e) => {
  let { selection: { main: t } } = r.state, { mouseSelection: i } = r.inputState;
  i && (i.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", r.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function tb(r, e, t, i) {
  if (!t)
    return;
  let o = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  e.preventDefault();
  let { mouseSelection: n } = r.inputState, s = i && n && n.dragging && CR(r, e) ? { from: n.dragging.from, to: n.dragging.to } : null, a = { from: o, insert: t }, l = r.state.changes(s ? [s, a] : a);
  r.focus(), r.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(o, -1), head: l.mapPos(o, 1) },
    userEvent: s ? "move.drop" : "input.drop"
  });
}
Be.drop = (r, e) => {
  if (!e.dataTransfer)
    return;
  if (r.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let i = Array(t.length), o = 0, n = () => {
      ++o == t.length && tb(r, e, i.filter((s) => s != null).join(r.state.lineBreak), !1);
    };
    for (let s = 0; s < t.length; s++) {
      let a = new FileReader();
      a.onerror = n, a.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(a.result) || (i[s] = a.result), n();
      }, a.readAsText(t[s]);
    }
  } else
    tb(r, e, e.dataTransfer.getData("Text"), !0);
};
Be.paste = (r, e) => {
  if (r.state.readOnly)
    return e.preventDefault();
  r.observer.flush();
  let t = zy ? null : e.clipboardData;
  t ? (Ny(r, t.getData("text/plain") || t.getData("text/uri-text")), e.preventDefault()) : PR(r);
};
function RR(r, e) {
  let t = r.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), r.focus();
  }, 50);
}
function _R(r) {
  let e = [], t = [], i = !1;
  for (let o of r.selection.ranges)
    o.empty || (e.push(r.sliceDoc(o.from, o.to)), t.push(o));
  if (!e.length) {
    let o = -1;
    for (let { from: n } of r.selection.ranges) {
      let s = r.doc.lineAt(n);
      s.number > o && (e.push(s.text), t.push({ from: s.from, to: Math.min(r.doc.length, s.to + 1) })), o = s.number;
    }
    i = !0;
  }
  return { text: e.join(r.lineBreak), ranges: t, linewise: i };
}
let zd = null;
Be.copy = Be.cut = (r, e) => {
  let { text: t, ranges: i, linewise: o } = _R(r.state);
  if (!t && !o)
    return;
  zd = o ? t : null;
  let n = zy ? null : e.clipboardData;
  n ? (e.preventDefault(), n.clearData(), n.setData("text/plain", t)) : RR(r, t), e.type == "cut" && !r.state.readOnly && r.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
const Ly = /* @__PURE__ */ pr.define();
function Wy(r, e) {
  let t = [];
  for (let i of r.facet(xy)) {
    let o = i(r, e);
    o && t.push(o);
  }
  return t ? r.update({ effects: t, annotations: Ly.of(!0) }) : null;
}
function Iy(r) {
  setTimeout(() => {
    let e = r.hasFocus;
    if (e != r.inputState.notifiedFocused) {
      let t = Wy(r.state, e);
      t ? r.dispatch(t) : r.update([]);
    }
  }, 10);
}
Be.focus = (r) => {
  r.inputState.lastFocusTime = Date.now(), !r.scrollDOM.scrollTop && (r.inputState.lastScrollTop || r.inputState.lastScrollLeft) && (r.scrollDOM.scrollTop = r.inputState.lastScrollTop, r.scrollDOM.scrollLeft = r.inputState.lastScrollLeft), Iy(r);
};
Be.blur = (r) => {
  r.observer.clearSelectionRange(), Iy(r);
};
Be.compositionstart = Be.compositionupdate = (r) => {
  r.inputState.compositionFirstChange == null && (r.inputState.compositionFirstChange = !0), r.inputState.composing < 0 && (r.inputState.composing = 0);
};
Be.compositionend = (r) => {
  r.inputState.composing = -1, r.inputState.compositionEndedAt = Date.now(), r.inputState.compositionPendingKey = !0, r.inputState.compositionPendingChange = r.observer.pendingRecords().length > 0, r.inputState.compositionFirstChange = null, j.chrome && j.android ? r.observer.flushSoon() : r.inputState.compositionPendingChange ? Promise.resolve().then(() => r.observer.flush()) : setTimeout(() => {
    r.inputState.composing < 0 && r.docView.compositionDeco.size && r.update([]);
  }, 50);
};
Be.contextmenu = (r) => {
  r.inputState.lastContextMenu = Date.now();
};
Be.beforeinput = (r, e) => {
  var t;
  let i;
  if (j.chrome && j.android && (i = Xy.find((o) => o.inputType == e.inputType)) && (r.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let o = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var n;
      (((n = window.visualViewport) === null || n === void 0 ? void 0 : n.height) || 0) > o + 10 && r.hasFocus && (r.contentDOM.blur(), r.focus());
    }, 100);
  }
};
const ib = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class DR {
  constructor(e) {
    this.lineWrapping = e, this.doc = ve.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return ib.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      o < 0 ? i++ : this.heightSamples[Math.floor(o * 10)] || (t = !0, this.heightSamples[Math.floor(o * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, o, n, s) {
    let a = ib.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != a;
    if (this.lineWrapping = a, this.lineHeight = t, this.charWidth = i, this.textHeight = o, this.lineLength = n, l) {
      this.heightSamples = {};
      for (let u = 0; u < s.length; u++) {
        let h = s[u];
        h < 0 ? u++ : this.heightSamples[Math.floor(h * 10)] = !0;
      }
    }
    return l;
  }
}
class MR {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class zi {
  /**
  @internal
  */
  constructor(e, t, i, o, n) {
    this.from = e, this.length = t, this.top = i, this.height = o, this._content = n;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? Ae.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Jr ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new zi(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var Te = /* @__PURE__ */ function(r) {
  return r[r.ByPos = 0] = "ByPos", r[r.ByHeight = 1] = "ByHeight", r[r.ByPosNoHeight = 2] = "ByPosNoHeight", r;
}(Te || (Te = {}));
const Pl = 1e-3;
class kt {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > Pl && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return kt.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, o) {
    let n = this, s = i.doc;
    for (let a = o.length - 1; a >= 0; a--) {
      let { fromA: l, toA: u, fromB: h, toB: c } = o[a], d = n.lineAt(l, Te.ByPosNoHeight, i.setDoc(t), 0, 0), f = d.to >= u ? d : n.lineAt(u, Te.ByPosNoHeight, i, 0, 0);
      for (c += f.to - u, u = f.to; a > 0 && d.from <= o[a - 1].toA; )
        l = o[a - 1].fromA, h = o[a - 1].fromB, a--, l < d.from && (d = n.lineAt(l, Te.ByPosNoHeight, i, 0, 0));
      h += d.from - l, l = d.from;
      let p = kp.build(i.setDoc(s), e, h, c);
      n = n.replace(l, u, p);
    }
    return n.updateHeight(i, 0);
  }
  static empty() {
    return new Yt(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, o = 0, n = 0;
    for (; ; )
      if (t == i)
        if (o > n * 2) {
          let a = e[t - 1];
          a.break ? e.splice(--t, 1, a.left, null, a.right) : e.splice(--t, 1, a.left, a.right), i += 1 + a.break, o -= a.size;
        } else if (n > o * 2) {
          let a = e[i];
          a.break ? e.splice(i, 1, a.left, null, a.right) : e.splice(i, 1, a.left, a.right), i += 2 + a.break, n -= a.size;
        } else
          break;
      else if (o < n) {
        let a = e[t++];
        a && (o += a.size);
      } else {
        let a = e[--i];
        a && (n += a.size);
      }
    let s = 0;
    return e[t - 1] == null ? (s = 1, t--) : e[t] == null && (s = 1, i++), new XR(kt.of(e.slice(0, t)), s, kt.of(e.slice(i)));
  }
}
kt.prototype.size = 1;
class Uy extends kt {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, o) {
    return new zi(o, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, o, n) {
    return this.blockAt(0, i, o, n);
  }
  forEachLine(e, t, i, o, n, s) {
    e <= n + this.length && t >= n && s(this.blockAt(0, i, o, n));
  }
  updateHeight(e, t = 0, i = !1, o) {
    return o && o.from <= t && o.more && this.setHeight(e, o.heights[o.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class Yt extends Uy {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, o) {
    return new zi(o, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let o = i[0];
    return i.length == 1 && (o instanceof Yt || o instanceof ot && o.flags & 4) && Math.abs(this.length - o.length) < 10 ? (o instanceof ot ? o = new Yt(o.length, this.height) : o.height = this.height, this.outdated || (o.outdated = !1), o) : kt.of(i);
  }
  updateHeight(e, t = 0, i = !1, o) {
    return o && o.from <= t && o.more ? this.setHeight(e, o.heights[o.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class ot extends kt {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, o = e.doc.lineAt(t + this.length).number, n = o - i + 1, s, a = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * n);
      s = l / n, this.length > n + 1 && (a = (this.height - l) / (this.length - n - 1));
    } else
      s = this.height / n;
    return { firstLine: i, lastLine: o, perLine: s, perChar: a };
  }
  blockAt(e, t, i, o) {
    let { firstLine: n, lastLine: s, perLine: a, perChar: l } = this.heightMetrics(t, o);
    if (t.lineWrapping) {
      let u = o + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), h = t.doc.lineAt(u), c = a + h.length * l, d = Math.max(i, e - c / 2);
      return new zi(h.from, h.length, d, c, 0);
    } else {
      let u = Math.max(0, Math.min(s - n, Math.floor((e - i) / a))), { from: h, length: c } = t.doc.line(n + u);
      return new zi(h, c, i + a * u, a, 0);
    }
  }
  lineAt(e, t, i, o, n) {
    if (t == Te.ByHeight)
      return this.blockAt(e, i, o, n);
    if (t == Te.ByPosNoHeight) {
      let { from: f, to: p } = i.doc.lineAt(e);
      return new zi(f, p - f, 0, 0, 0);
    }
    let { firstLine: s, perLine: a, perChar: l } = this.heightMetrics(i, n), u = i.doc.lineAt(e), h = a + u.length * l, c = u.number - s, d = o + a * c + l * (u.from - n - c);
    return new zi(u.from, u.length, Math.max(o, Math.min(d, o + this.height - h)), h, 0);
  }
  forEachLine(e, t, i, o, n, s) {
    e = Math.max(e, n), t = Math.min(t, n + this.length);
    let { firstLine: a, perLine: l, perChar: u } = this.heightMetrics(i, n);
    for (let h = e, c = o; h <= t; ) {
      let d = i.doc.lineAt(h);
      if (h == e) {
        let p = d.number - a;
        c += l * p + u * (e - n - p);
      }
      let f = l + u * d.length;
      s(new zi(d.from, d.length, c, f, 0)), c += f, h = d.to + 1;
    }
  }
  replace(e, t, i) {
    let o = this.length - t;
    if (o > 0) {
      let n = i[i.length - 1];
      n instanceof ot ? i[i.length - 1] = new ot(n.length + o) : i.push(null, new ot(o - 1));
    }
    if (e > 0) {
      let n = i[0];
      n instanceof ot ? i[0] = new ot(e + n.length) : i.unshift(new ot(e - 1), null);
    }
    return kt.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new ot(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new ot(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, o) {
    let n = t + this.length;
    if (o && o.from <= t + this.length && o.more) {
      let s = [], a = Math.max(t, o.from), l = -1;
      for (o.from > t && s.push(new ot(o.from - t - 1).updateHeight(e, t)); a <= n && o.more; ) {
        let h = e.doc.lineAt(a).length;
        s.length && s.push(null);
        let c = o.heights[o.index++];
        l == -1 ? l = c : Math.abs(c - l) >= Pl && (l = -2);
        let d = new Yt(h, c);
        d.outdated = !1, s.push(d), a += h + 1;
      }
      a <= n && s.push(null, new ot(n - a).updateHeight(e, a));
      let u = kt.of(s);
      return (l < 0 || Math.abs(u.height - this.height) >= Pl || Math.abs(l - this.heightMetrics(e, t).perLine) >= Pl) && (e.heightChanged = !0), u;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class XR extends kt {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, o) {
    let n = i + this.left.height;
    return e < n ? this.left.blockAt(e, t, i, o) : this.right.blockAt(e, t, n, o + this.left.length + this.break);
  }
  lineAt(e, t, i, o, n) {
    let s = o + this.left.height, a = n + this.left.length + this.break, l = t == Te.ByHeight ? e < s : e < a, u = l ? this.left.lineAt(e, t, i, o, n) : this.right.lineAt(e, t, i, s, a);
    if (this.break || (l ? u.to < a : u.from > a))
      return u;
    let h = t == Te.ByPosNoHeight ? Te.ByPosNoHeight : Te.ByPos;
    return l ? u.join(this.right.lineAt(a, h, i, s, a)) : this.left.lineAt(a, h, i, o, n).join(u);
  }
  forEachLine(e, t, i, o, n, s) {
    let a = o + this.left.height, l = n + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, i, o, n, s), t >= l && this.right.forEachLine(e, t, i, a, l, s);
    else {
      let u = this.lineAt(l, Te.ByPos, i, o, n);
      e < u.from && this.left.forEachLine(e, u.from - 1, i, o, n, s), u.to >= e && u.from <= t && s(u), t > u.to && this.right.forEachLine(u.to + 1, t, i, a, l, s);
    }
  }
  replace(e, t, i) {
    let o = this.left.length + this.break;
    if (t < o)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - o, t - o, i));
    let n = [];
    e > 0 && this.decomposeLeft(e, n);
    let s = n.length;
    for (let a of i)
      n.push(a);
    if (e > 0 && rb(n, s - 1), t < this.length) {
      let a = n.length;
      this.decomposeRight(t, n), rb(n, a);
    }
    return kt.of(n);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, o = i + this.break;
    if (e >= o)
      return this.right.decomposeRight(e - o, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < o && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? kt.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, o) {
    let { left: n, right: s } = this, a = t + n.length + this.break, l = null;
    return o && o.from <= t + n.length && o.more ? l = n = n.updateHeight(e, t, i, o) : n.updateHeight(e, t, i), o && o.from <= a + s.length && o.more ? l = s = s.updateHeight(e, a, i, o) : s.updateHeight(e, a, i), l ? this.balanced(n, s) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function rb(r, e) {
  let t, i;
  r[e] == null && (t = r[e - 1]) instanceof ot && (i = r[e + 1]) instanceof ot && r.splice(e - 1, 3, new ot(t.length + 1 + i.length));
}
const AR = 5;
class kp {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), o = this.nodes[this.nodes.length - 1];
      o instanceof Yt ? o.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new Yt(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let o = i.widget ? i.widget.estimatedHeight : 0, n = i.widget ? i.widget.lineBreaks : 0;
      o < 0 && (o = this.oracle.lineHeight);
      let s = t - e;
      i.block ? this.addBlock(new Uy(s, o, i)) : (s || n || o >= AR) && this.addLineDeco(o, n, s);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new Yt(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new ot(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof Yt)
      return e;
    let t = new Yt(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    var t;
    this.enterLine();
    let i = (t = e.deco) === null || t === void 0 ? void 0 : t.type;
    i == Ae.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, i != Ae.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let o = this.ensureLine();
    o.length += i, o.collapsed += i, o.widgetHeight = Math.max(o.widgetHeight, e), o.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof Yt) && !this.isCovered ? this.nodes.push(new Yt(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let o of this.nodes)
      o instanceof Yt && o.updateHeight(this.oracle, i), i += o ? o.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, o) {
    let n = new kp(i, e);
    return Se.spans(t, i, o, n, 0), n.finish(i);
  }
}
function zR(r, e, t) {
  let i = new NR();
  return Se.compare(r, e, t, i, 0), i.changes;
}
class NR {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, o) {
    (e < t || i && i.heightRelevant || o && o.heightRelevant) && $d(e, t, this.changes, 5);
  }
}
function VR(r, e) {
  let t = r.getBoundingClientRect(), i = r.ownerDocument, o = i.defaultView || window, n = Math.max(0, t.left), s = Math.min(o.innerWidth, t.right), a = Math.max(0, t.top), l = Math.min(o.innerHeight, t.bottom);
  for (let u = r.parentNode; u && u != i.body; )
    if (u.nodeType == 1) {
      let h = u, c = window.getComputedStyle(h);
      if ((h.scrollHeight > h.clientHeight || h.scrollWidth > h.clientWidth) && c.overflow != "visible") {
        let d = h.getBoundingClientRect();
        n = Math.max(n, d.left), s = Math.min(s, d.right), a = Math.max(a, d.top), l = u == r.parentNode ? d.bottom : Math.min(l, d.bottom);
      }
      u = c.position == "absolute" || c.position == "fixed" ? h.offsetParent : h.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: n - t.left,
    right: Math.max(n, s) - t.left,
    top: a - (t.top + e),
    bottom: Math.max(a, l) - (t.top + e)
  };
}
function ZR(r, e) {
  let t = r.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class rc {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let o = e[i], n = t[i];
      if (o.from != n.from || o.to != n.to || o.size != n.size)
        return !1;
    }
    return !0;
  }
  draw(e) {
    return J.replace({ widget: new LR(this.size, e) }).range(this.from, this.to);
  }
}
class LR extends gr {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class ob {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = nb, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = Me.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Qp).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new DR(t), this.stateDeco = e.facet(oa).filter((i) => typeof i != "function"), this.heightMap = kt.empty().applyChanges(this.stateDeco, ve.empty, this.heightOracle.setDoc(e.doc), [new Ui(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = J.set(this.lineGaps.map((i) => i.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let o = i ? t.head : t.anchor;
      if (!e.some(({ from: n, to: s }) => o >= n && o <= s)) {
        let { from: n, to: s } = this.lineBlockAt(o);
        e.push(new il(n, s));
      }
    }
    this.viewports = e.sort((i, o) => i.from - o.from), this.scaler = this.heightMap.height <= 7e6 ? nb : new UR(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Os(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(oa).filter((h) => typeof h != "function");
    let o = e.changedRanges, n = Ui.extendWithRanges(o, zR(i, this.stateDeco, e ? e.changes : He.empty(this.state.doc.length))), s = this.heightMap.height, a = this.scrolledToBottom ? null : this.lineBlockAtHeight(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), n), this.heightMap.height != s && (e.flags |= 2), a ? (this.scrollAnchorPos = e.changes.mapPos(a.from, -1), this.scrollAnchorHeight = a.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = n.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let u = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), u && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(Cy) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), o = this.heightOracle, n = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? Me.RTL : Me.LTR;
    let s = this.heightOracle.mustRefreshForWrapping(n), a = t.getBoundingClientRect(), l = s || this.mustMeasureContent || this.contentDOMHeight != a.height;
    this.contentDOMHeight = a.height, this.mustMeasureContent = !1;
    let u = 0, h = 0, c = parseInt(i.paddingTop) || 0, d = parseInt(i.paddingBottom) || 0;
    (this.paddingTop != c || this.paddingBottom != d) && (this.paddingTop = c, this.paddingBottom = d, u |= 10), this.editorWidth != e.scrollDOM.clientWidth && (o.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 8), this.scrollTop != e.scrollDOM.scrollTop && (this.scrollAnchorHeight = -1, this.scrollTop = e.scrollDOM.scrollTop), this.scrolledToBottom = this.scrollTop > e.scrollDOM.scrollHeight - e.scrollDOM.clientHeight - 4;
    let f = (this.printing ? ZR : VR)(t, this.paddingTop), p = f.top - this.pixelViewport.top, g = f.bottom - this.pixelViewport.bottom;
    this.pixelViewport = f;
    let b = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (b != this.inView && (this.inView = b, b && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let m = a.width;
    if ((this.contentDOMWidth != m || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = a.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 8), l) {
      let S = e.docView.measureVisibleLineHeights(this.viewport);
      if (o.mustRefreshForHeights(S) && (s = !0), s || o.lineWrapping && Math.abs(m - this.contentDOMWidth) > o.charWidth) {
        let { lineHeight: y, charWidth: x, textHeight: P } = e.docView.measureTextSize();
        s = y > 0 && o.refresh(n, y, x, P, m / x, S), s && (e.docView.minWidth = 0, u |= 8);
      }
      p > 0 && g > 0 ? h = Math.max(p, g) : p < 0 && g < 0 && (h = Math.min(p, g)), o.heightChanged = !1;
      for (let y of this.viewports) {
        let x = y.from == this.viewport.from ? S : e.docView.measureVisibleLineHeights(y);
        this.heightMap = (s ? kt.empty().applyChanges(this.stateDeco, ve.empty, this.heightOracle, [new Ui(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(o, 0, s, new MR(y.from, x));
      }
      o.heightChanged && (u |= 2);
    }
    let v = !this.viewportIsAppropriate(this.viewport, h) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return v && (this.viewport = this.getViewport(h, this.scrollTarget)), this.updateForViewport(), (u & 2 || v) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(s ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), o = this.heightMap, n = this.heightOracle, { visibleTop: s, visibleBottom: a } = this, l = new il(o.lineAt(s - i * 1e3, Te.ByHeight, n, 0, 0).from, o.lineAt(a + (1 - i) * 1e3, Te.ByHeight, n, 0, 0).to);
    if (t) {
      let { head: u } = t.range;
      if (u < l.from || u > l.to) {
        let h = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), c = o.lineAt(u, Te.ByPos, n, 0, 0), d;
        t.y == "center" ? d = (c.top + c.bottom) / 2 - h / 2 : t.y == "start" || t.y == "nearest" && u < l.from ? d = c.top : d = c.bottom - h, l = new il(o.lineAt(d - 1e3 / 2, Te.ByHeight, n, 0, 0).from, o.lineAt(d + h + 1e3 / 2, Te.ByHeight, n, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), o = t.mapPos(e.to, 1);
    return new il(this.heightMap.lineAt(i, Te.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(o, Te.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: o } = this.heightMap.lineAt(e, Te.ByPos, this.heightOracle, 0, 0), { bottom: n } = this.heightMap.lineAt(t, Te.ByPos, this.heightOracle, 0, 0), { visibleTop: s, visibleBottom: a } = this;
    return (e == 0 || o <= s - Math.max(10, Math.min(
      -i,
      250
      /* MaxCoverMargin */
    ))) && (t == this.state.doc.length || n >= a + Math.max(10, Math.min(
      i,
      250
      /* MaxCoverMargin */
    ))) && o > s - 2 * 1e3 && n < a + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let o of e)
      t.touchesRange(o.from, o.to) || i.push(new rc(t.mapPos(o.from), t.mapPos(o.to), o.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, o = i ? 1e4 : 2e3, n = o >> 1, s = o << 1;
    if (this.defaultTextDirection != Me.LTR && !i)
      return [];
    let a = [], l = (u, h, c, d) => {
      if (h - u < n)
        return;
      let f = this.state.selection.main, p = [f.from];
      f.empty || p.push(f.to);
      for (let b of p)
        if (b > u && b < h) {
          l(u, b - 10, c, d), l(b + 10, h, c, d);
          return;
        }
      let g = IR(e, (b) => b.from >= c.from && b.to <= c.to && Math.abs(b.from - u) < n && Math.abs(b.to - h) < n && !p.some((m) => b.from < m && b.to > m));
      if (!g) {
        if (h < c.to && t && i && t.visibleRanges.some((b) => b.from <= h && b.to >= h)) {
          let b = t.moveToLineBoundary(D.cursor(h), !1, !0).head;
          b > u && (h = b);
        }
        g = new rc(u, h, this.gapSize(c, u, h, d));
      }
      a.push(g);
    };
    for (let u of this.viewportLines) {
      if (u.length < s)
        continue;
      let h = WR(u.from, u.to, this.stateDeco);
      if (h.total < s)
        continue;
      let c = this.scrollTarget ? this.scrollTarget.range.head : null, d, f;
      if (i) {
        let p = o / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, b;
        if (c != null) {
          let m = ol(h, c), v = ((this.visibleBottom - this.visibleTop) / 2 + p) / u.height;
          g = m - v, b = m + v;
        } else
          g = (this.visibleTop - u.top - p) / u.height, b = (this.visibleBottom - u.top + p) / u.height;
        d = rl(h, g), f = rl(h, b);
      } else {
        let p = h.total * this.heightOracle.charWidth, g = o * this.heightOracle.charWidth, b, m;
        if (c != null) {
          let v = ol(h, c), S = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          b = v - S, m = v + S;
        } else
          b = (this.pixelViewport.left - g) / p, m = (this.pixelViewport.right + g) / p;
        d = rl(h, b), f = rl(h, m);
      }
      d > u.from && l(u.from, d, u, h), f < u.to && l(f, u.to, u, h);
    }
    return a;
  }
  gapSize(e, t, i, o) {
    let n = ol(o, i) - ol(o, t);
    return this.heightOracle.lineWrapping ? e.height * n : o.total * this.heightOracle.charWidth * n;
  }
  updateLineGaps(e) {
    rc.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = J.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    Se.spans(e, this.viewport.from, this.viewport.to, {
      span(o, n) {
        t.push({ from: o, to: n });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((o, n) => o.from != t[n].from || o.to != t[n].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Os(this.heightMap.lineAt(e, Te.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Os(this.heightMap.lineAt(this.scaler.fromDOM(e), Te.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  elementAtHeight(e) {
    return Os(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class il {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function WR(r, e, t) {
  let i = [], o = r, n = 0;
  return Se.spans(t, r, e, {
    span() {
    },
    point(s, a) {
      s > o && (i.push({ from: o, to: s }), n += s - o), o = a;
    }
  }, 20), o < e && (i.push({ from: o, to: e }), n += e - o), { total: n, ranges: i };
}
function rl({ total: r, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(r * t);
  for (let o = 0; ; o++) {
    let { from: n, to: s } = e[o], a = s - n;
    if (i <= a)
      return n + i;
    i -= a;
  }
}
function ol(r, e) {
  let t = 0;
  for (let { from: i, to: o } of r.ranges) {
    if (e <= o) {
      t += e - i;
      break;
    }
    t += o - i;
  }
  return t / r.total;
}
function IR(r, e) {
  for (let t of r)
    if (e(t))
      return t;
}
const nb = {
  toDOM(r) {
    return r;
  },
  fromDOM(r) {
    return r;
  },
  scale: 1
};
class UR {
  constructor(e, t, i) {
    let o = 0, n = 0, s = 0;
    this.viewports = i.map(({ from: a, to: l }) => {
      let u = t.lineAt(a, Te.ByPos, e, 0, 0).top, h = t.lineAt(l, Te.ByPos, e, 0, 0).bottom;
      return o += h - u, { from: a, to: l, top: u, bottom: h, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - o) / (t.height - o);
    for (let a of this.viewports)
      a.domTop = s + (a.top - n) * this.scale, s = a.domBottom = a.domTop + (a.bottom - a.top), n = a.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, o = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.top)
        return o + (e - i) * this.scale;
      if (e <= n.bottom)
        return n.domTop + (e - n.top);
      i = n.bottom, o = n.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, o = 0; ; t++) {
      let n = t < this.viewports.length ? this.viewports[t] : null;
      if (!n || e < n.domTop)
        return i + (e - o) / this.scale;
      if (e <= n.domBottom)
        return n.top + (e - n.domTop);
      i = n.bottom, o = n.domBottom;
    }
  }
}
function Os(r, e) {
  if (e.scale == 1)
    return r;
  let t = e.toDOM(r.top), i = e.toDOM(r.bottom);
  return new zi(r.from, r.length, t, i - t, Array.isArray(r._content) ? r._content.map((o) => Os(o, e)) : r._content);
}
const nl = /* @__PURE__ */ H.define({ combine: (r) => r.join(" ") }), Nd = /* @__PURE__ */ H.define({ combine: (r) => r.indexOf(!0) > -1 }), Vd = /* @__PURE__ */ jr.newName(), Yy = /* @__PURE__ */ jr.newName(), Fy = /* @__PURE__ */ jr.newName(), By = { "&light": "." + Yy, "&dark": "." + Fy };
function Zd(r, e, t) {
  return new jr(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (o) => {
        if (o == "&")
          return r;
        if (!t || !t[o])
          throw new RangeError(`Unsupported selector: ${o}`);
        return t[o];
      }) : r + " " + i;
    }
  });
}
const YR = /* @__PURE__ */ Zd("." + Vd, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    left: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, By);
class FR {
  constructor(e, t, i, o) {
    this.typeOver = o, this.bounds = null, this.text = "";
    let { impreciseHead: n, impreciseAnchor: s } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let a = n || s ? [] : qR(e), l = new Ry(a, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = HR(a, this.bounds.from);
    } else {
      let a = e.observer.selectionRange, l = n && n.node == a.focusNode && n.offset == a.focusOffset || !_n(e.contentDOM, a.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(a.focusNode, a.focusOffset), u = s && s.node == a.anchorNode && s.offset == a.anchorOffset || !_n(e.contentDOM, a.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(a.anchorNode, a.anchorOffset);
      this.newSel = D.single(u, l);
    }
  }
}
function qy(r, e) {
  let t, { newSel: i } = e, o = r.state.selection.main, n = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: s, to: a } = e.bounds, l = o.from, u = null;
    (n === 8 || j.android && e.text.length < a - s) && (l = o.to, u = "end");
    let h = BR(r.state.doc.sliceString(s, a, an), e.text, l - s, u);
    h && (j.chrome && n == 13 && h.toB == h.from + 2 && e.text.slice(h.from, h.toB) == an + an && h.toB--, t = {
      from: s + h.from,
      to: s + h.toA,
      insert: ve.of(e.text.slice(h.from, h.toB).split(an))
    });
  } else
    i && (!r.hasFocus && r.state.facet(fh) || i.main.eq(o)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !o.empty && i && i.main.empty ? t = { from: o.from, to: o.to, insert: r.state.doc.slice(o.from, o.to) } : t && t.from >= o.from && t.to <= o.to && (t.from != o.from || t.to != o.to) && o.to - o.from - (t.to - t.from) <= 4 ? t = {
    from: o.from,
    to: o.to,
    insert: r.state.doc.slice(o.from, t.from).append(t.insert).append(r.state.doc.slice(t.to, o.to))
  } : (j.mac || j.android) && t && t.from == t.to && t.from == o.head - 1 && /^\. ?$/.test(t.insert.toString()) && r.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = D.single(i.main.anchor - 1, i.main.head - 1)), t = { from: o.from, to: o.to, insert: ve.of([" "]) }) : j.chrome && t && t.from == t.to && t.from == o.head && t.insert.toString() == `
 ` && r.lineWrapping && (i && (i = D.single(i.main.anchor - 1, i.main.head - 1)), t = { from: o.from, to: o.to, insert: ve.of([" "]) }), t) {
    let s = r.state;
    if (j.ios && r.inputState.flushIOSKey(r) || j.android && (t.from == o.from && t.to == o.to && t.insert.length == 1 && t.insert.lines == 2 && On(r.contentDOM, "Enter", 13) || (t.from == o.from - 1 && t.to == o.to && t.insert.length == 0 || n == 8 && t.insert.length < t.to - t.from) && On(r.contentDOM, "Backspace", 8) || t.from == o.from && t.to == o.to + 1 && t.insert.length == 0 && On(r.contentDOM, "Delete", 46)))
      return !0;
    let a = t.insert.toString();
    if (r.state.facet(yy).some((h) => h(r, t.from, t.to, a)))
      return !0;
    r.inputState.composing >= 0 && r.inputState.composing++;
    let l;
    if (t.from >= o.from && t.to <= o.to && t.to - t.from >= (o.to - o.from) / 3 && (!i || i.main.empty && i.main.from == t.from + t.insert.length) && r.inputState.composing < 0) {
      let h = o.from < t.from ? s.sliceDoc(o.from, t.from) : "", c = o.to > t.to ? s.sliceDoc(t.to, o.to) : "";
      l = s.replaceSelection(r.state.toText(h + t.insert.sliceString(0, void 0, r.state.lineBreak) + c));
    } else {
      let h = s.changes(t), c = i && i.main.to <= h.newLength ? i.main : void 0;
      if (s.selection.ranges.length > 1 && r.inputState.composing >= 0 && t.to <= o.to && t.to >= o.to - 10) {
        let d = r.state.sliceDoc(t.from, t.to), f = _y(r) || r.state.doc.lineAt(o.head), p = o.to - t.to, g = o.to - o.from;
        l = s.changeByRange((b) => {
          if (b.from == o.from && b.to == o.to)
            return { changes: h, range: c || b.map(h) };
          let m = b.to - p, v = m - d.length;
          if (b.to - b.from != g || r.state.sliceDoc(v, m) != d || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          f && b.to >= f.from && b.from <= f.to)
            return { range: b };
          let S = s.changes({ from: v, to: m, insert: t.insert }), y = b.to - o.to;
          return {
            changes: S,
            range: c ? D.range(Math.max(0, c.anchor + y), Math.max(0, c.head + y)) : b.map(S)
          };
        });
      } else
        l = {
          changes: h,
          selection: c && s.selection.replaceRange(c)
        };
    }
    let u = "input.type";
    return (r.composing || r.inputState.compositionPendingChange && r.inputState.compositionEndedAt > Date.now() - 50) && (r.inputState.compositionPendingChange = !1, u += ".compose", r.inputState.compositionFirstChange && (u += ".start", r.inputState.compositionFirstChange = !1)), r.dispatch(l, { scrollIntoView: !0, userEvent: u }), !0;
  } else if (i && !i.main.eq(o)) {
    let s = !1, a = "select";
    return r.inputState.lastSelectionTime > Date.now() - 50 && (r.inputState.lastSelectionOrigin == "select" && (s = !0), a = r.inputState.lastSelectionOrigin), r.dispatch({ selection: i, scrollIntoView: s, userEvent: a }), !0;
  } else
    return !1;
}
function BR(r, e, t, i) {
  let o = Math.min(r.length, e.length), n = 0;
  for (; n < o && r.charCodeAt(n) == e.charCodeAt(n); )
    n++;
  if (n == o && r.length == e.length)
    return null;
  let s = r.length, a = e.length;
  for (; s > 0 && a > 0 && r.charCodeAt(s - 1) == e.charCodeAt(a - 1); )
    s--, a--;
  if (i == "end") {
    let l = Math.max(0, n - Math.min(s, a));
    t -= s + l - n;
  }
  if (s < n && r.length < e.length) {
    let l = t <= n && t >= s ? n - t : 0;
    n -= l, a = n + (a - s), s = n;
  } else if (a < n) {
    let l = t <= n && t >= a ? n - t : 0;
    n -= l, s = n + (s - a), a = n;
  }
  return { from: n, toA: s, toB: a };
}
function qR(r) {
  let e = [];
  if (r.root.activeElement != r.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: o, focusOffset: n } = r.observer.selectionRange;
  return t && (e.push(new Zm(t, i)), (o != t || n != i) && e.push(new Zm(o, n))), e;
}
function HR(r, e) {
  if (r.length == 0)
    return null;
  let t = r[0].pos, i = r.length == 2 ? r[1].pos : t;
  return t > -1 && i > -1 ? D.single(t + e, i + e) : null;
}
const jR = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, oc = j.ie && j.ie_version <= 11;
class GR {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new Y$(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (j.ie && j.ie_version <= 11 || j.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), oc && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, o = this.selectionRange;
    if (i.state.facet(fh) ? i.root.activeElement != this.dom : !Cl(i.dom, o))
      return;
    let n = o.anchorNode && i.docView.nearest(o.anchorNode);
    if (n && n.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (j.ie && j.ie_version <= 11 || j.android && j.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    o.focusNode && uu(o.focusNode, o.focusOffset, o.anchorNode, o.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = j.safari && e.root.nodeType == 11 && L$(this.dom.ownerDocument) == this.dom && KR(this.view) || lu(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let i = Cl(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && B$(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, jR), oc && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), oc && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let o = () => {
        let n = this.delayedAndroidKey;
        n && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = n.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && n.force && On(this.dom, n.key, n.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(o);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, o = !1;
    for (let n of e) {
      let s = this.readMutation(n);
      s && (s.typeOver && (o = !0), t == -1 ? { from: t, to: i } = s : (t = Math.min(s.from, t), i = Math.max(s.to, i)));
    }
    return { from: t, to: i, typeOver: o };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), o = this.selectionChanged && Cl(this.dom, this.selectionRange);
    return e < 0 && !o ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1, new FR(this.view, e, t, i));
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return !1;
    let i = this.view.state, o = qy(this.view, t);
    return this.view.state == i && this.view.update([]), o;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.dirty |= 4), e.type == "childList") {
      let i = sb(t, e.previousSibling || e.target.previousSibling, -1), o = sb(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: o ? t.posBefore(o) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i, o;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect(), (o = this.resizeContent) === null || o === void 0 || o.disconnect();
    for (let n of this.scrollTargets)
      n.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function sb(r, e, t) {
  for (; e; ) {
    let i = Ee.get(e);
    if (i && i.parent == r)
      return i;
    let o = e.parentNode;
    e = o != r.dom ? o : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function KR(r) {
  let e = null;
  function t(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (r.contentDOM.addEventListener("beforeinput", t, !0), r.dom.ownerDocument.execCommand("indent"), r.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, o = e.startOffset, n = e.endContainer, s = e.endOffset, a = r.docView.domAtPos(r.state.selection.main.anchor);
  return uu(a.node, a.offset, n, s) && ([i, o, n, s] = [n, s, i, o]), { anchorNode: i, anchorOffset: o, focusNode: n, focusOffset: s };
}
class B {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((t) => this.update([t])), this.dispatch = this.dispatch.bind(this), this._root = e.root || F$(e.parent) || document, this.viewState = new ob(e.state || be.create(e)), this.plugins = this.state.facet(ms).map((t) => new ec(t));
    for (let t of this.plugins)
      t.update(this);
    this.observer = new GR(this), this.inputState = new wR(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new Lm(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Ge ? e[0] : this.state.update(...e);
    this._dispatch(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, o, n = this.state;
    for (let d of e) {
      if (d.startState != n)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      n = d.state;
    }
    if (this.destroyed) {
      this.viewState.state = n;
      return;
    }
    let s = this.hasFocus, a = 0, l = null;
    e.some((d) => d.annotation(Ly)) ? (this.inputState.notifiedFocused = s, a = 1) : s != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = s, l = Wy(n, s), l || (a = 1));
    let u = this.observer.delayedAndroidKey, h = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), h = this.observer.readChange(), (h && !this.state.doc.eq(n.doc) || !this.state.selection.eq(n.selection)) && (h = null)) : this.observer.clear(), n.facet(be.phrases) != this.state.facet(be.phrases))
      return this.setState(n);
    o = du.create(this, n, e), o.flags |= a;
    let c = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let d of e) {
        if (c && (c = c.map(d.changes)), d.scrollIntoView) {
          let { main: f } = d.state.selection;
          c = new cu(f.empty ? f : D.cursor(f.head, f.head > f.anchor ? -1 : 1));
        }
        for (let f of d.effects)
          f.is(Nm) && (c = f.value);
      }
      this.viewState.update(o, c), this.bidiCache = fu.update(this.bidiCache, o.changes), o.empty || (this.updatePlugins(o), this.inputState.update(o)), t = this.docView.update(o), this.state.facet(bs) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((d) => d.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (o.startState.facet(nl) != o.state.facet(nl) && (this.viewState.mustMeasureContent = !0), (t || i || c || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !o.empty)
      for (let d of this.state.facet(Rd))
        d(o);
    (l || h) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), h && !qy(this, h) && u.force && On(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new ob(e), this.plugins = e.facet(ms).map((i) => new ec(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new Lm(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(ms), i = e.state.facet(ms);
    if (t != i) {
      let o = [];
      for (let n of i) {
        let s = t.indexOf(n);
        if (s < 0)
          o.push(new ec(n));
        else {
          let a = this.plugins[s];
          a.mustUpdate = e, o.push(a);
        }
      }
      for (let n of this.plugins)
        n.mustUpdate != e && n.destroy(this);
      this.plugins = o, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let o of this.plugins)
        o.mustUpdate = e;
    for (let o = 0; o < this.plugins.length; o++)
      this.plugins[o].update(this);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, { scrollTop: o } = i, { scrollAnchorPos: n, scrollAnchorHeight: s } = this.viewState;
    if (this.viewState.scrollAnchorHeight = -1, s < 0 || o != this.viewState.scrollTop)
      if (o > i.scrollHeight - i.clientHeight - 4)
        n = -1, s = this.viewState.heightMap.height;
      else {
        let a = this.viewState.lineBlockAtHeight(o);
        n = a.from, s = a.top;
      }
    try {
      for (let a = 0; ; a++) {
        this.updateState = 1;
        let l = this.viewport, u = this.viewState.measure(this);
        if (!u && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (a > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let h = [];
        u & 4 || ([this.measureRequests, h] = [h, this.measureRequests]);
        let c = h.map((g) => {
          try {
            return g.read(this);
          } catch (b) {
            return li(this.state, b), ab;
          }
        }), d = du.create(this, this.state, []), f = !1, p = !1;
        d.flags |= u, t ? t.flags |= u : t = d, this.updateState = 2, d.empty || (this.updatePlugins(d), this.inputState.update(d), this.updateAttrs(), f = this.docView.update(d));
        for (let g = 0; g < h.length; g++)
          if (c[g] != ab)
            try {
              let b = h[g];
              b.write && b.write(c[g], this);
            } catch (b) {
              li(this.state, b);
            }
        if (this.viewState.editorHeight) {
          if (this.viewState.scrollTarget)
            this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null, p = !0;
          else if (s > -1) {
            let b = (n < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(n).top) - s;
            (b > 1 || b < -1) && (i.scrollTop = o + b, p = !0);
          }
        }
        if (f && this.docView.updateSelection(!0), this.viewport.from == l.from && this.viewport.to == l.to && !p && this.measureRequests.length == 0)
          break;
        s = -1;
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let a of this.state.facet(Rd))
        a(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return Vd + " " + (this.state.facet(Nd) ? Fy : Yy) + " " + this.state.facet(nl);
  }
  updateAttrs() {
    let e = lb(this, Qy, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(fh) ? "true" : "false",
      class: "cm-content",
      style: `${j.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), lb(this, Qp, t);
    let i = this.observer.ignore(() => {
      let o = Td(this.contentDOM, this.contentAttrs, t), n = Td(this.dom, this.editorAttrs, e);
      return o || n;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let o of i.effects)
        if (o.is(B.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let n = this.announceDOM.appendChild(document.createElement("div"));
          n.textContent = o.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(bs), jr.mount(this.root, this.styleModules.concat(YR).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return ic(this, e, Bm(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return ic(this, e, Bm(this, e, t, (i) => OR(this, e.head, i)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = !0) {
    return bR(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return ic(this, e, vR(this, e, t, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), My(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let o = this.state.doc.lineAt(e), n = this.bidiSpans(o), s = n[vn.find(n, e - o.from, -1, t)];
    return yp(i, s.dir == Me.LTR == t > 0);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(Sy) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)—if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > JR)
      return Ty(e.length);
    let t = this.textDirectionAt(e.from);
    for (let o of this.bidiCache)
      if (o.from == e.from && o.dir == t)
        return o.order;
    let i = rR(e.text, t);
    return this.bidiCache.push(new fu(e.from, e.to, t, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || j.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      iy(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return Nm.of(new cu(typeof e == "number" ? D.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Je.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)—to which the scope class will be
  added—need to be explicitly differentiated by adding an `&` to
  the selector for that element—for example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = jr.newName(), o = [nl.of(i), bs.of(Zd(`.${i}`, e))];
    return t && t.dark && o.push(Nd.of(!0)), o;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return Wo.lowest(bs.of(Zd("." + Vd, e, By)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), o = i && Ee.get(i) || Ee.get(e);
    return ((t = o == null ? void 0 : o.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
B.styleModule = bs;
B.inputHandler = yy;
B.focusChangeEffect = xy;
B.perLineTextDirection = Sy;
B.exceptionSink = wy;
B.updateListener = Rd;
B.editable = fh;
B.mouseSelectionStyle = vy;
B.dragMovesSelection = Oy;
B.clickAddsSelectionRange = by;
B.decorations = oa;
B.atomicRanges = Pp;
B.scrollMargins = Py;
B.darkTheme = Nd;
B.contentAttributes = Qp;
B.editorAttributes = Qy;
B.lineWrapping = /* @__PURE__ */ B.contentAttributes.of({ class: "cm-lineWrapping" });
B.announce = /* @__PURE__ */ le.define();
const JR = 4096, ab = {};
class fu {
  constructor(e, t, i, o) {
    this.from = e, this.to = t, this.dir = i, this.order = o;
  }
  static update(e, t) {
    if (t.empty)
      return e;
    let i = [], o = e.length ? e[e.length - 1].dir : Me.LTR;
    for (let n = Math.max(0, e.length - 10); n < e.length; n++) {
      let s = e[n];
      s.dir == o && !t.touchesRange(s.from, s.to) && i.push(new fu(t.mapPos(s.from, 1), t.mapPos(s.to, -1), s.dir, s.order));
    }
    return i;
  }
}
function lb(r, e, t) {
  for (let i = r.state.facet(e), o = i.length - 1; o >= 0; o--) {
    let n = i[o], s = typeof n == "function" ? n(r) : n;
    s && Ed(s, t);
  }
  return t;
}
const e_ = j.mac ? "mac" : j.windows ? "win" : j.linux ? "linux" : "key";
function t_(r, e) {
  const t = r.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let o, n, s, a;
  for (let l = 0; l < t.length - 1; ++l) {
    const u = t[l];
    if (/^(cmd|meta|m)$/i.test(u))
      a = !0;
    else if (/^a(lt)?$/i.test(u))
      o = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      n = !0;
    else if (/^s(hift)?$/i.test(u))
      s = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? a = !0 : n = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return o && (i = "Alt-" + i), n && (i = "Ctrl-" + i), a && (i = "Meta-" + i), s && (i = "Shift-" + i), i;
}
function sl(r, e, t) {
  return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t !== !1 && e.shiftKey && (r = "Shift-" + r), r;
}
const i_ = /* @__PURE__ */ Wo.default(/* @__PURE__ */ B.domEventHandlers({
  keydown(r, e) {
    return jy(Hy(e.state), r, e, "editor");
  }
})), Pa = /* @__PURE__ */ H.define({ enables: i_ }), ub = /* @__PURE__ */ new WeakMap();
function Hy(r) {
  let e = r.facet(Pa), t = ub.get(e);
  return t || ub.set(e, t = n_(e.reduce((i, o) => i.concat(o), []))), t;
}
function r_(r, e, t) {
  return jy(Hy(r.state), e, r, t);
}
let kr = null;
const o_ = 4e3;
function n_(r, e = e_) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), o = (s, a) => {
    let l = i[s];
    if (l == null)
      i[s] = a;
    else if (l != a)
      throw new Error("Key binding " + s + " is used both as a regular binding and as a multi-stroke prefix");
  }, n = (s, a, l, u) => {
    var h, c;
    let d = t[s] || (t[s] = /* @__PURE__ */ Object.create(null)), f = a.split(/ (?!$)/).map((b) => t_(b, e));
    for (let b = 1; b < f.length; b++) {
      let m = f.slice(0, b).join(" ");
      o(m, !0), d[m] || (d[m] = {
        preventDefault: !0,
        run: [(v) => {
          let S = kr = { view: v, prefix: m, scope: s };
          return setTimeout(() => {
            kr == S && (kr = null);
          }, o_), !0;
        }]
      });
    }
    let p = f.join(" ");
    o(p, !1);
    let g = d[p] || (d[p] = { preventDefault: !1, run: ((c = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || c === void 0 ? void 0 : c.slice()) || [] });
    l && g.run.push(l), u && (g.preventDefault = !0);
  };
  for (let s of r) {
    let a = s.scope ? s.scope.split(" ") : ["editor"];
    if (s.any)
      for (let u of a) {
        let h = t[u] || (t[u] = /* @__PURE__ */ Object.create(null));
        h._any || (h._any = { preventDefault: !1, run: [] });
        for (let c in h)
          h[c].run.push(s.any);
      }
    let l = s[e] || s.key;
    if (l)
      for (let u of a)
        n(u, l, s.run, s.preventDefault), s.shift && n(u, "Shift-" + l, s.shift, s.preventDefault);
  }
  return t;
}
function jy(r, e, t, i) {
  let o = Z$(e), n = nt(o, 0), s = ri(n) == o.length && o != " ", a = "", l = !1;
  kr && kr.view == t && kr.scope == i && (a = kr.prefix + " ", (l = Ay.indexOf(e.keyCode) < 0) && (kr = null));
  let u = /* @__PURE__ */ new Set(), h = (p) => {
    if (p) {
      for (let g of p.run)
        if (!u.has(g) && (u.add(g), g(t, e)))
          return !0;
      p.preventDefault && (l = !0);
    }
    return !1;
  }, c = r[i], d, f;
  if (c) {
    if (h(c[a + sl(o, e, !s)]))
      return !0;
    if (s && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
    !(j.windows && e.ctrlKey && e.altKey) && (d = Gr[e.keyCode]) && d != o) {
      if (h(c[a + sl(d, e, !0)]))
        return !0;
      if (e.shiftKey && (f = ia[e.keyCode]) != o && f != d && h(c[a + sl(f, e, !1)]))
        return !0;
    } else if (s && e.shiftKey && h(c[a + sl(o, e, !0)]))
      return !0;
    if (h(c._any))
      return !0;
  }
  return l;
}
class ka {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, i, o, n) {
    this.className = e, this.left = t, this.top = i, this.width = o, this.height = n;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, i) {
    if (i.empty) {
      let o = e.coordsAtPos(i.head, i.assoc || 1);
      if (!o)
        return [];
      let n = Gy(e);
      return [new ka(t, o.left - n.left, o.top - n.top, null, o.bottom - o.top)];
    } else
      return s_(e, t, i);
  }
}
function Gy(r) {
  let e = r.scrollDOM.getBoundingClientRect();
  return { left: (r.textDirection == Me.LTR ? e.left : e.right - r.scrollDOM.clientWidth) - r.scrollDOM.scrollLeft, top: e.top - r.scrollDOM.scrollTop };
}
function hb(r, e, t) {
  let i = D.cursor(e);
  return {
    from: Math.max(t.from, r.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(t.to, r.moveToLineBoundary(i, !0, !0).from),
    type: Ae.Text
  };
}
function s_(r, e, t) {
  if (t.to <= r.viewport.from || t.from >= r.viewport.to)
    return [];
  let i = Math.max(t.from, r.viewport.from), o = Math.min(t.to, r.viewport.to), n = r.textDirection == Me.LTR, s = r.contentDOM, a = s.getBoundingClientRect(), l = Gy(r), u = s.querySelector(".cm-line"), h = u && window.getComputedStyle(u), c = a.left + (h ? parseInt(h.paddingLeft) + Math.min(0, parseInt(h.textIndent)) : 0), d = a.right - (h ? parseInt(h.paddingRight) : 0), f = Xd(r, i), p = Xd(r, o), g = f.type == Ae.Text ? f : null, b = p.type == Ae.Text ? p : null;
  if (g && (r.lineWrapping || f.widgetLineBreaks) && (g = hb(r, i, g)), b && (r.lineWrapping || p.widgetLineBreaks) && (b = hb(r, o, b)), g && b && g.from == b.from)
    return v(S(t.from, t.to, g));
  {
    let x = g ? S(t.from, null, g) : y(f, !1), P = b ? S(null, t.to, b) : y(p, !0), k = [];
    return (g || f).to < (b || p).from - (g && b ? 1 : 0) || f.widgetLineBreaks > 1 && x.bottom + r.defaultLineHeight / 2 < P.top ? k.push(m(c, x.bottom, d, P.top)) : x.bottom < P.top && r.elementAtHeight((x.bottom + P.top) / 2).type == Ae.Text && (x.bottom = P.top = (x.bottom + P.top) / 2), v(x).concat(k).concat(v(P));
  }
  function m(x, P, k, C) {
    return new ka(
      e,
      x - l.left,
      P - l.top - 0.01,
      k - x,
      C - P + 0.01
      /* Epsilon */
    );
  }
  function v({ top: x, bottom: P, horizontal: k }) {
    let C = [];
    for (let T = 0; T < k.length; T += 2)
      C.push(m(k[T], x, k[T + 1], P));
    return C;
  }
  function S(x, P, k) {
    let C = 1e9, T = -1e9, R = [];
    function M(N, G, ee, oe, te) {
      let ce = r.coordsAtPos(N, N == k.to ? -2 : 2), ye = r.coordsAtPos(ee, ee == k.from ? 2 : -2);
      !ce || !ye || (C = Math.min(ce.top, ye.top, C), T = Math.max(ce.bottom, ye.bottom, T), te == Me.LTR ? R.push(n && G ? c : ce.left, n && oe ? d : ye.right) : R.push(!n && oe ? c : ye.left, !n && G ? d : ce.right));
    }
    let E = x ?? k.from, Z = P ?? k.to;
    for (let N of r.visibleRanges)
      if (N.to > E && N.from < Z)
        for (let G = Math.max(N.from, E), ee = Math.min(N.to, Z); ; ) {
          let oe = r.state.doc.lineAt(G);
          for (let te of r.bidiSpans(oe)) {
            let ce = te.from + oe.from, ye = te.to + oe.from;
            if (ce >= ee)
              break;
            ye > G && M(Math.max(ce, G), x == null && ce <= E, Math.min(ye, ee), P == null && ye >= Z, te.dir);
          }
          if (G = oe.to + 1, G >= ee)
            break;
        }
    return R.length == 0 && M(E, x == null, Z, P == null, r.textDirection), { top: C, bottom: T, horizontal: R };
  }
  function y(x, P) {
    let k = a.top + (P ? x.top : x.bottom);
    return { top: k, bottom: k, horizontal: [] };
  }
}
function a_(r, e) {
  return r.constructor == e.constructor && r.eq(e);
}
class l_ {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(kl) != e.state.facet(kl) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, i = e.facet(kl);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !a_(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let o of e)
        o.update && t && o.constructor && this.drawn[i].constructor && o.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(o.draw(), t);
      for (; t; ) {
        let o = t.nextSibling;
        t.remove(), t = o;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const kl = /* @__PURE__ */ H.define();
function Ky(r) {
  return [
    Je.define((e) => new l_(e, r)),
    kl.of(r)
  ];
}
const Jy = !j.ios, na = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function u_(r = {}) {
  return [
    na.of(r),
    h_,
    c_,
    d_,
    Cy.of(!0)
  ];
}
function ex(r) {
  return r.startState.facet(na) != r.state.facet(na);
}
const h_ = /* @__PURE__ */ Ky({
  above: !0,
  markers(r) {
    let { state: e } = r, t = e.facet(na), i = [];
    for (let o of e.selection.ranges) {
      let n = o == e.selection.main;
      if (o.empty ? !n || Jy : t.drawRangeCursor) {
        let s = n ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", a = o.empty ? o : D.cursor(o.head, o.head > o.anchor ? -1 : 1);
        for (let l of ka.forRange(r, s, a))
          i.push(l);
      }
    }
    return i;
  },
  update(r, e) {
    r.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = ex(r);
    return t && cb(r.state, e), r.docChanged || r.selectionSet || t;
  },
  mount(r, e) {
    cb(e.state, r);
  },
  class: "cm-cursorLayer"
});
function cb(r, e) {
  e.style.animationDuration = r.facet(na).cursorBlinkRate + "ms";
}
const c_ = /* @__PURE__ */ Ky({
  above: !1,
  markers(r) {
    return r.state.selection.ranges.map((e) => e.empty ? [] : ka.forRange(r, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(r, e) {
    return r.docChanged || r.selectionSet || r.viewportChanged || ex(r);
  },
  class: "cm-selectionLayer"
}), tx = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
Jy && (tx[".cm-line"].caretColor = "transparent !important");
const d_ = /* @__PURE__ */ Wo.highest(/* @__PURE__ */ B.theme(tx)), ix = /* @__PURE__ */ le.define({
  map(r, e) {
    return r == null ? null : e.mapPos(r);
  }
}), vs = /* @__PURE__ */ tt.define({
  create() {
    return null;
  },
  update(r, e) {
    return r != null && (r = e.changes.mapPos(r)), e.effects.reduce((t, i) => i.is(ix) ? i.value : t, r);
  }
}), f_ = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.view = r, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(r) {
    var e;
    let t = r.state.field(vs);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (r.startState.field(vs) != t || r.docChanged || r.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let r = this.view.state.field(vs), e = r != null && this.view.coordsAtPos(r);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(r) {
    this.cursor && (r ? (this.cursor.style.left = r.left + "px", this.cursor.style.top = r.top + "px", this.cursor.style.height = r.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(r) {
    this.view.state.field(vs) != r && this.view.dispatch({ effects: ix.of(r) });
  }
}, {
  eventHandlers: {
    dragover(r) {
      this.setDropPos(this.view.posAtCoords({ x: r.clientX, y: r.clientY }));
    },
    dragleave(r) {
      (r.target == this.view.contentDOM || !this.view.contentDOM.contains(r.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function p_() {
  return [vs, f_];
}
function db(r, e, t, i, o) {
  e.lastIndex = 0;
  for (let n = r.iterRange(t, i), s = t, a; !n.next().done; s += n.value.length)
    if (!n.lineBreak)
      for (; a = e.exec(n.value); )
        o(s + a.index, a);
}
function g_(r, e) {
  let t = r.visibleRanges;
  if (t.length == 1 && t[0].from == r.viewport.from && t[0].to == r.viewport.to)
    return t;
  let i = [];
  for (let { from: o, to: n } of t)
    o = Math.max(r.state.doc.lineAt(o).from, o - e), n = Math.min(r.state.doc.lineAt(n).to, n + e), i.length && i[i.length - 1].to >= o ? i[i.length - 1].to = n : i.push({ from: o, to: n });
  return i;
}
class m_ {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: i, decorate: o, boundary: n, maxLength: s = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, o)
      this.addMatch = (a, l, u, h) => o(h, u, u + a[0].length, a, l);
    else if (typeof i == "function")
      this.addMatch = (a, l, u, h) => {
        let c = i(a, l, u);
        c && h(u, u + a[0].length, c);
      };
    else if (i)
      this.addMatch = (a, l, u, h) => h(u, u + a[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = n, this.maxLength = s;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Hr(), i = t.add.bind(t);
    for (let { from: o, to: n } of g_(e, this.maxLength))
      db(e.state.doc, this.regexp, o, n, (s, a) => this.addMatch(a, e, s, i));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, o = -1;
    return e.docChanged && e.changes.iterChanges((n, s, a, l) => {
      l > e.view.viewport.from && a < e.view.viewport.to && (i = Math.min(a, i), o = Math.max(l, o));
    }), e.viewportChanged || o - i > 1e3 ? this.createDeco(e.view) : o > -1 ? this.updateRange(e.view, t.map(e.changes), i, o) : t;
  }
  updateRange(e, t, i, o) {
    for (let n of e.visibleRanges) {
      let s = Math.max(n.from, i), a = Math.min(n.to, o);
      if (a > s) {
        let l = e.state.doc.lineAt(s), u = l.to < a ? e.state.doc.lineAt(a) : l, h = Math.max(n.from, l.from), c = Math.min(n.to, u.to);
        if (this.boundary) {
          for (; s > l.from; s--)
            if (this.boundary.test(l.text[s - 1 - l.from])) {
              h = s;
              break;
            }
          for (; a < u.to; a++)
            if (this.boundary.test(u.text[a - u.from])) {
              c = a;
              break;
            }
        }
        let d = [], f, p = (g, b, m) => d.push(m.range(g, b));
        if (l == u)
          for (this.regexp.lastIndex = h - l.from; (f = this.regexp.exec(l.text)) && f.index < c - l.from; )
            this.addMatch(f, e, f.index + l.from, p);
        else
          db(e.state.doc, this.regexp, h, c, (g, b) => this.addMatch(b, e, g, p));
        t = t.update({ filterFrom: h, filterTo: c, filter: (g, b) => g < h || b > c, add: d });
      }
    }
    return t;
  }
}
const Ld = /x/.unicode != null ? "gu" : "g", b_ = /* @__PURE__ */ new RegExp(`[\0-\b
--­؜​‎‏\u2028\u2029‭‮⁦⁧⁩\uFEFF￹-￼]`, Ld), O_ = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let nc = null;
function v_() {
  var r;
  if (nc == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    nc = ((r = e.tabSize) !== null && r !== void 0 ? r : e.MozTabSize) != null;
  }
  return nc || !1;
}
const El = /* @__PURE__ */ H.define({
  combine(r) {
    let e = Hi(r, {
      render: null,
      specialChars: b_,
      addSpecialChars: null
    });
    return (e.replaceTabs = !v_()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, Ld)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, Ld)), e;
  }
});
function w_(r = {}) {
  return [El.of(r), y_()];
}
let fb = null;
function y_() {
  return fb || (fb = Je.fromClass(class {
    constructor(r) {
      this.view = r, this.decorations = J.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(r.state.facet(El)), this.decorations = this.decorator.createDeco(r);
    }
    makeDecorator(r) {
      return new m_({
        regexp: r.specialChars,
        decoration: (e, t, i) => {
          let { doc: o } = t.state, n = nt(e[0], 0);
          if (n == 9) {
            let s = o.lineAt(i), a = t.state.tabSize, l = Ca(s.text, a, i - s.from);
            return J.replace({ widget: new Q_((a - l % a) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[n] || (this.decorationCache[n] = J.replace({ widget: new C_(r, n) }));
        },
        boundary: r.replaceTabs ? void 0 : /[^]/
      });
    }
    update(r) {
      let e = r.state.facet(El);
      r.startState.facet(El) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(r.view)) : this.decorations = this.decorator.updateDeco(r, this.decorations);
    }
  }, {
    decorations: (r) => r.decorations
  }));
}
const x_ = "•";
function S_(r) {
  return r >= 32 ? x_ : r == 10 ? "␤" : String.fromCharCode(9216 + r);
}
class C_ extends gr {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = S_(this.code), i = e.state.phrase("Control character") + " " + (O_[this.code] || "0x" + this.code.toString(16)), o = this.options.render && this.options.render(this.code, i, t);
    if (o)
      return o;
    let n = document.createElement("span");
    return n.textContent = t, n.title = i, n.setAttribute("aria-label", i), n.className = "cm-specialChar", n;
  }
  ignoreEvent() {
    return !1;
  }
}
class Q_ extends gr {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function P_() {
  return E_;
}
const k_ = /* @__PURE__ */ J.line({ class: "cm-activeLine" }), E_ = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.docChanged || r.selectionSet) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = -1, t = [];
    for (let i of r.state.selection.ranges) {
      let o = r.lineBlockAt(i.head);
      o.from > e && (t.push(k_.range(o.from)), e = o.from);
    }
    return J.set(t);
  }
}, {
  decorations: (r) => r.decorations
}), Wd = 2e3;
function T_(r, e, t) {
  let i = Math.min(e.line, t.line), o = Math.max(e.line, t.line), n = [];
  if (e.off > Wd || t.off > Wd || e.col < 0 || t.col < 0) {
    let s = Math.min(e.off, t.off), a = Math.max(e.off, t.off);
    for (let l = i; l <= o; l++) {
      let u = r.doc.line(l);
      u.length <= a && n.push(D.range(u.from + s, u.to + a));
    }
  } else {
    let s = Math.min(e.col, t.col), a = Math.max(e.col, t.col);
    for (let l = i; l <= o; l++) {
      let u = r.doc.line(l), h = wd(u.text, s, r.tabSize, !0);
      if (h < 0)
        n.push(D.cursor(u.to));
      else {
        let c = wd(u.text, a, r.tabSize);
        n.push(D.range(u.from + h, u.from + c));
      }
    }
  }
  return n;
}
function $_(r, e) {
  let t = r.coordsAtPos(r.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / r.defaultCharacterWidth)) : -1;
}
function pb(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = r.state.doc.lineAt(t), o = t - i.from, n = o > Wd ? -1 : o == i.length ? $_(r, e.clientX) : Ca(i.text, r.state.tabSize, t - i.from);
  return { line: i.number, col: n, off: o };
}
function R_(r, e) {
  let t = pb(r, e), i = r.state.selection;
  return t ? {
    update(o) {
      if (o.docChanged) {
        let n = o.changes.mapPos(o.startState.doc.line(t.line).from), s = o.state.doc.lineAt(n);
        t = { line: s.number, col: t.col, off: Math.min(t.off, s.length) }, i = i.map(o.changes);
      }
    },
    get(o, n, s) {
      let a = pb(r, o);
      if (!a)
        return i;
      let l = T_(r.state, t, a);
      return l.length ? s ? D.create(l.concat(i.ranges)) : D.create(l) : i;
    }
  } : null;
}
function __(r) {
  let e = (r == null ? void 0 : r.eventFilter) || ((t) => t.altKey && t.button == 0);
  return B.mouseSelectionStyle.of((t, i) => e(i) ? R_(t, i) : null);
}
const D_ = {
  Alt: [18, (r) => !!r.altKey],
  Control: [17, (r) => !!r.ctrlKey],
  Shift: [16, (r) => !!r.shiftKey],
  Meta: [91, (r) => !!r.metaKey]
}, M_ = { style: "cursor: crosshair" };
function X_(r = {}) {
  let [e, t] = D_[r.key || "Alt"], i = Je.fromClass(class {
    constructor(o) {
      this.view = o, this.isDown = !1;
    }
    set(o) {
      this.isDown != o && (this.isDown = o, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(o) {
        this.set(o.keyCode == e || t(o));
      },
      keyup(o) {
        (o.keyCode == e || !t(o)) && this.set(!1);
      },
      mousemove(o) {
        this.set(t(o));
      }
    }
  });
  return [
    i,
    B.contentAttributes.of((o) => {
      var n;
      return !((n = o.plugin(i)) === null || n === void 0) && n.isDown ? M_ : null;
    })
  ];
}
const al = "-10000px";
class rx {
  constructor(e, t, i) {
    this.facet = t, this.createTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((o) => o), this.tooltipViews = this.tooltips.map(i);
  }
  update(e) {
    var t;
    let i = e.state.facet(this.facet), o = i.filter((s) => s);
    if (i === this.input) {
      for (let s of this.tooltipViews)
        s.update && s.update(e);
      return !1;
    }
    let n = [];
    for (let s = 0; s < o.length; s++) {
      let a = o[s], l = -1;
      if (a) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let h = this.tooltips[u];
          h && h.create == a.create && (l = u);
        }
        if (l < 0)
          n[s] = this.createTooltipView(a);
        else {
          let u = n[s] = this.tooltipViews[l];
          u.update && u.update(e);
        }
      }
    }
    for (let s of this.tooltipViews)
      n.indexOf(s) < 0 && (s.dom.remove(), (t = s.destroy) === null || t === void 0 || t.call(s));
    return this.input = i, this.tooltips = o, this.tooltipViews = n, !0;
  }
}
function A_(r) {
  let { win: e } = r;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const sc = /* @__PURE__ */ H.define({
  combine: (r) => {
    var e, t, i;
    return {
      position: j.ios ? "absolute" : ((e = r.find((o) => o.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = r.find((o) => o.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = r.find((o) => o.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || A_
    };
  }
}), gb = /* @__PURE__ */ new WeakMap(), ox = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.view = r, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = r.state.facet(sc);
    this.position = e.position, this.parent = e.parent, this.classes = r.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new rx(r, Ep, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), r.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let r of this.manager.tooltipViews)
        this.intersectionObserver.observe(r.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(r) {
    r.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(r);
    e && this.observeIntersection();
    let t = e || r.geometryChanged, i = r.state.facet(sc);
    if (i.position != this.position) {
      this.position = i.position;
      for (let o of this.manager.tooltipViews)
        o.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let o of this.manager.tooltipViews)
        this.container.appendChild(o.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(r) {
    let e = r.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), r.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = al, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var r, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (r = t.destroy) === null || r === void 0 || r.call(t);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let r = this.view.dom.getBoundingClientRect();
    return {
      editor: r,
      parent: this.parent ? this.container.getBoundingClientRect() : r,
      pos: this.manager.tooltips.map((e, t) => {
        let i = this.manager.tooltipViews[t];
        return i.getCoords ? i.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(sc).tooltipSpace(this.view)
    };
  }
  writeMeasure(r) {
    var e;
    let { editor: t, space: i } = r, o = [];
    for (let n = 0; n < this.manager.tooltips.length; n++) {
      let s = this.manager.tooltips[n], a = this.manager.tooltipViews[n], { dom: l } = a, u = r.pos[n], h = r.size[n];
      if (!u || u.bottom <= Math.max(t.top, i.top) || u.top >= Math.min(t.bottom, i.bottom) || u.right < Math.max(t.left, i.left) - 0.1 || u.left > Math.min(t.right, i.right) + 0.1) {
        l.style.top = al;
        continue;
      }
      let c = s.arrow ? a.dom.querySelector(".cm-tooltip-arrow") : null, d = c ? 7 : 0, f = h.right - h.left, p = (e = gb.get(a)) !== null && e !== void 0 ? e : h.bottom - h.top, g = a.offset || N_, b = this.view.textDirection == Me.LTR, m = h.width > i.right - i.left ? b ? i.left : i.right - h.width : b ? Math.min(u.left - (c ? 14 : 0) + g.x, i.right - f) : Math.max(i.left, u.left - f + (c ? 14 : 0) - g.x), v = !!s.above;
      !s.strictSide && (v ? u.top - (h.bottom - h.top) - g.y < i.top : u.bottom + (h.bottom - h.top) + g.y > i.bottom) && v == i.bottom - u.bottom > u.top - i.top && (v = !v);
      let S = (v ? u.top - i.top : i.bottom - u.bottom) - d;
      if (S < p && a.resize !== !1) {
        if (S < this.view.defaultLineHeight) {
          l.style.top = al;
          continue;
        }
        gb.set(a, p), l.style.height = (p = S) + "px";
      } else
        l.style.height && (l.style.height = "");
      let y = v ? u.top - p - d - g.y : u.bottom + d + g.y, x = m + f;
      if (a.overlap !== !0)
        for (let P of o)
          P.left < x && P.right > m && P.top < y + p && P.bottom > y && (y = v ? P.top - p - 2 - d : P.bottom + d + 2);
      this.position == "absolute" ? (l.style.top = y - r.parent.top + "px", l.style.left = m - r.parent.left + "px") : (l.style.top = y + "px", l.style.left = m + "px"), c && (c.style.left = `${u.left + (b ? g.x : -g.x) - (m + 14 - 7)}px`), a.overlap !== !0 && o.push({ left: m, top: y, right: x, bottom: y + p }), l.classList.toggle("cm-tooltip-above", v), l.classList.toggle("cm-tooltip-below", !v), a.positioned && a.positioned(r.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let r of this.manager.tooltipViews)
        r.dom.style.top = al;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), z_ = /* @__PURE__ */ B.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), N_ = { x: 0, y: 0 }, Ep = /* @__PURE__ */ H.define({
  enables: [ox, z_]
}), pu = /* @__PURE__ */ H.define();
class Tp {
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new rx(e, pu, (t) => this.createHostedView(t));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Tp(e);
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
}
const V_ = /* @__PURE__ */ Ep.compute([pu], (r) => {
  let e = r.facet(pu).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: Tp.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class Z_ {
  constructor(e, t, i, o, n) {
    this.view = e, this.source = t, this.field = i, this.setHover = o, this.hoverTime = n, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: e } = this, t = this.view.contentDOM.contains(e.target) ? this.view.posAtCoords(e) : null;
    if (t == null)
      return;
    let i = this.view.coordsAtPos(t);
    if (i == null || e.y < i.top || e.y > i.bottom || e.x < i.left - this.view.defaultCharacterWidth || e.x > i.right + this.view.defaultCharacterWidth)
      return;
    let o = this.view.bidiSpans(this.view.state.doc.lineAt(t)).find((a) => a.from <= t && a.to >= t), n = o && o.dir == Me.RTL ? -1 : 1, s = this.source(this.view, t, e.x < i.left ? -n : n);
    if (s != null && s.then) {
      let a = this.pending = { pos: t };
      s.then((l) => {
        this.pending == a && (this.pending = null, l && this.view.dispatch({ effects: this.setHover.of(l) }));
      }, (l) => li(this.view.state, l, "hover tooltip"));
    } else
      s && this.view.dispatch({ effects: this.setHover.of(s) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let i = this.active;
    if (i && !mb(this.lastMove.target) || this.pending) {
      let { pos: o } = i || this.pending, n = (t = i == null ? void 0 : i.end) !== null && t !== void 0 ? t : o;
      (o == n ? this.view.posAtCoords(this.lastMove) != o : !L_(
        this.view,
        o,
        n,
        e.clientX,
        e.clientY,
        6
        /* MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !mb(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function mb(r) {
  for (let e = r; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function L_(r, e, t, i, o, n) {
  let s = document.createRange(), a = r.domAtPos(e), l = r.domAtPos(t);
  s.setEnd(l.node, l.offset), s.setStart(a.node, a.offset);
  let u = s.getClientRects();
  s.detach();
  for (let h = 0; h < u.length; h++) {
    let c = u[h];
    if (Math.max(c.top - o, o - c.bottom, c.left - i, i - c.right) <= n)
      return !0;
  }
  return !1;
}
function W_(r, e = {}) {
  let t = le.define(), i = tt.define({
    create() {
      return null;
    },
    update(o, n) {
      if (o && (e.hideOnChange && (n.docChanged || n.selection) || e.hideOn && e.hideOn(n, o)))
        return null;
      if (o && n.docChanged) {
        let s = n.changes.mapPos(o.pos, -1, at.TrackDel);
        if (s == null)
          return null;
        let a = Object.assign(/* @__PURE__ */ Object.create(null), o);
        a.pos = s, o.end != null && (a.end = n.changes.mapPos(o.end)), o = a;
      }
      for (let s of n.effects)
        s.is(t) && (o = s.value), s.is(I_) && (o = null);
      return o;
    },
    provide: (o) => pu.from(o)
  });
  return [
    i,
    Je.define((o) => new Z_(
      o,
      r,
      i,
      t,
      e.hoverTime || 300
      /* Time */
    )),
    V_
  ];
}
function nx(r, e) {
  let t = r.plugin(ox);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const I_ = /* @__PURE__ */ le.define(), bb = /* @__PURE__ */ H.define({
  combine(r) {
    let e, t;
    for (let i of r)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function sa(r, e) {
  let t = r.plugin(sx), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const sx = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.input = r.state.facet(aa), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(r));
    let e = r.state.facet(bb);
    this.top = new ll(r, !0, e.topContainer), this.bottom = new ll(r, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(r) {
    let e = r.state.facet(bb);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new ll(r.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new ll(r.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = r.state.facet(aa);
    if (t != this.input) {
      let i = t.filter((l) => l), o = [], n = [], s = [], a = [];
      for (let l of i) {
        let u = this.specs.indexOf(l), h;
        u < 0 ? (h = l(r.view), a.push(h)) : (h = this.panels[u], h.update && h.update(r)), o.push(h), (h.top ? n : s).push(h);
      }
      this.specs = i, this.panels = o, this.top.sync(n), this.bottom.sync(s);
      for (let l of a)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(r);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (r) => B.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class ll {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = Ob(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = Ob(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function Ob(r) {
  let e = r.nextSibling;
  return r.remove(), e;
}
const aa = /* @__PURE__ */ H.define({
  enables: sx
});
class ur extends _o {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
ur.prototype.elementClass = "";
ur.prototype.toDOM = void 0;
ur.prototype.mapMode = at.TrackBefore;
ur.prototype.startSide = ur.prototype.endSide = -1;
ur.prototype.point = !0;
const Tl = /* @__PURE__ */ H.define(), U_ = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => Se.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, Xs = /* @__PURE__ */ H.define();
function Y_(r) {
  return [ax(), Xs.of(Object.assign(Object.assign({}, U_), r))];
}
const Id = /* @__PURE__ */ H.define({
  combine: (r) => r.some((e) => e)
});
function ax(r) {
  let e = [
    F_
  ];
  return r && r.fixed === !1 && e.push(Id.of(!0)), e;
}
const F_ = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.view = r, this.prevViewport = r.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = r.state.facet(Xs).map((e) => new wb(r, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !r.state.facet(Id), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), r.scrollDOM.insertBefore(this.dom, r.contentDOM);
  }
  update(r) {
    if (this.updateGutters(r)) {
      let e = this.prevViewport, t = r.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    r.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(Id) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = r.view.viewport;
  }
  syncGutters(r) {
    let e = this.dom.nextSibling;
    r && this.dom.remove();
    let t = Se.iter(this.view.state.facet(Tl), this.view.viewport.from), i = [], o = this.gutters.map((n) => new B_(n, this.view.viewport, -this.view.documentPadding.top));
    for (let n of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(n.type)) {
        let s = !0;
        for (let a of n.type)
          if (a.type == Ae.Text && s) {
            Ud(t, i, a.from);
            for (let l of o)
              l.line(this.view, a, i);
            s = !1;
          } else if (a.widget)
            for (let l of o)
              l.widget(this.view, a);
      } else if (n.type == Ae.Text) {
        Ud(t, i, n.from);
        for (let s of o)
          s.line(this.view, n, i);
      }
    for (let n of o)
      n.finish();
    r && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(r) {
    let e = r.startState.facet(Xs), t = r.state.facet(Xs), i = r.docChanged || r.heightChanged || r.viewportChanged || !Se.eq(r.startState.facet(Tl), r.state.facet(Tl), r.view.viewport.from, r.view.viewport.to);
    if (e == t)
      for (let o of this.gutters)
        o.update(r) && (i = !0);
    else {
      i = !0;
      let o = [];
      for (let n of t) {
        let s = e.indexOf(n);
        s < 0 ? o.push(new wb(this.view, n)) : (this.gutters[s].update(r), o.push(this.gutters[s]));
      }
      for (let n of this.gutters)
        n.dom.remove(), o.indexOf(n) < 0 && n.destroy();
      for (let n of o)
        this.dom.appendChild(n.dom);
      this.gutters = o;
    }
    return i;
  }
  destroy() {
    for (let r of this.gutters)
      r.destroy();
    this.dom.remove();
  }
}, {
  provide: (r) => B.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == Me.LTR ? { left: t.dom.offsetWidth } : { right: t.dom.offsetWidth };
  })
});
function vb(r) {
  return Array.isArray(r) ? r : [r];
}
function Ud(r, e, t) {
  for (; r.value && r.from <= t; )
    r.from == t && e.push(r.value), r.next();
}
class B_ {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = Se.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: o } = this, n = t.top - this.height;
    if (this.i == o.elements.length) {
      let s = new lx(e, t.height, n, i);
      o.elements.push(s), o.dom.appendChild(s.dom);
    } else
      o.elements[this.i].update(e, t.height, n, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let o = [];
    Ud(this.cursor, o, t.from), i.length && (o = o.concat(i));
    let n = this.gutter.config.lineMarker(e, t, o);
    n && o.unshift(n);
    let s = this.gutter;
    o.length == 0 && !s.config.renderEmptyElements || this.addElement(e, t, o);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t);
    i && this.addElement(e, t, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class wb {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (o) => {
        let n = o.target, s;
        if (n != this.dom && this.dom.contains(n)) {
          for (; n.parentNode != this.dom; )
            n = n.parentNode;
          let l = n.getBoundingClientRect();
          s = (l.top + l.bottom) / 2;
        } else
          s = o.clientY;
        let a = e.lineBlockAtHeight(s - e.documentTop);
        t.domEventHandlers[i](e, a, o) && o.preventDefault();
      });
    this.markers = vb(t.markers(e)), t.initialSpacer && (this.spacer = new lx(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = vb(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let o = this.config.updateSpacer(this.spacer.markers[0], e);
      o != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [o]);
    }
    let i = e.view.viewport;
    return !Se.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class lx {
  constructor(e, t, i, o) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, o);
  }
  update(e, t, i, o) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), q_(this.markers, o) || this.setMarkers(e, o);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", o = this.dom.firstChild;
    for (let n = 0, s = 0; ; ) {
      let a = s, l = n < t.length ? t[n++] : null, u = !1;
      if (l) {
        let h = l.elementClass;
        h && (i += " " + h);
        for (let c = s; c < this.markers.length; c++)
          if (this.markers[c].compare(l)) {
            a = c, u = !0;
            break;
          }
      } else
        a = this.markers.length;
      for (; s < a; ) {
        let h = this.markers[s++];
        if (h.toDOM) {
          h.destroy(o);
          let c = o.nextSibling;
          o.remove(), o = c;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? o = o.nextSibling : this.dom.insertBefore(l.toDOM(e), o)), u && s++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function q_(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].compare(e[t]))
      return !1;
  return !0;
}
const H_ = /* @__PURE__ */ H.define(), ln = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let o in t) {
          let n = i[o], s = t[o];
          i[o] = n ? (a, l, u) => n(a, l, u) || s(a, l, u) : s;
        }
        return i;
      }
    });
  }
});
class ac extends ur {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function lc(r, e) {
  return r.state.facet(ln).formatNumber(e, r.state);
}
const j_ = /* @__PURE__ */ Xs.compute([ln], (r) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(H_);
  },
  lineMarker(e, t, i) {
    return i.some((o) => o.toDOM) ? null : new ac(lc(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(ln) != e.state.facet(ln),
  initialSpacer(e) {
    return new ac(lc(e, yb(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = lc(t.view, yb(t.view.state.doc.lines));
    return i == e.number ? e : new ac(i);
  },
  domEventHandlers: r.facet(ln).domEventHandlers
}));
function G_(r = {}) {
  return [
    ln.of(r),
    ax(),
    j_
  ];
}
function yb(r) {
  let e = 9;
  for (; e < r; )
    e = e * 10 + 9;
  return e;
}
const K_ = /* @__PURE__ */ new class extends ur {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), J_ = /* @__PURE__ */ Tl.compute(["selection"], (r) => {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let o = r.doc.lineAt(i.head).from;
    o > t && (t = o, e.push(K_.range(o)));
  }
  return Se.of(e);
});
function eD() {
  return J_;
}
const ux = 1024;
let tD = 0;
class si {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class he {
  /// Create a new node prop type.
  constructor(e = {}) {
    this.id = tD++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /// This is meant to be used with
  /// [`NodeSet.extend`](#common.NodeSet.extend) or
  /// [`LRParser.configure`](#lr.ParserConfig.props) to compute
  /// prop values for each node type in the set. Takes a [match
  /// object](#common.NodeType^match) or function that returns undefined
  /// if the node type doesn't get this prop, and the prop's value if
  /// it does.
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Et.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
he.closedBy = new he({ deserialize: (r) => r.split(" ") });
he.openedBy = new he({ deserialize: (r) => r.split(" ") });
he.group = new he({ deserialize: (r) => r.split(" ") });
he.contextHash = new he({ perNode: !0 });
he.lookAhead = new he({ perNode: !0 });
he.mounted = new he({ perNode: !0 });
class iD {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
}
const rD = /* @__PURE__ */ Object.create(null);
class Et {
  /// @internal
  constructor(e, t, i, o = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = o;
  }
  /// Define a node type.
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : rD, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), o = new Et(e.name || "", t, e.id, i);
    if (e.props) {
      for (let n of e.props)
        if (Array.isArray(n) || (n = n(o)), n) {
          if (n[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[n[0].id] = n[1];
        }
    }
    return o;
  }
  /// Retrieves a node prop for this type. Will return `undefined` if
  /// the prop isn't present on this node.
  prop(e) {
    return this.props[e.id];
  }
  /// True when this is the top node of a grammar.
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /// True when this node is produced by a skip rule.
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /// Indicates whether this is an error node.
  get isError() {
    return (this.flags & 4) > 0;
  }
  /// When true, this node type doesn't correspond to a user-declared
  /// named node, for example because it is used to cache repetition.
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /// Returns true when this node's name or one of its
  /// [groups](#common.NodeProp^group) matches the given string.
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(he.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /// Create a function from node types to arbitrary values by
  /// specifying an object whose property names are node or
  /// [group](#common.NodeProp^group) names. Often useful with
  /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  /// names, separated by spaces, in a single property name to map
  /// multiple node names to a single value.
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let o of i.split(" "))
        t[o] = e[i];
    return (i) => {
      for (let o = i.prop(he.group), n = -1; n < (o ? o.length : 0); n++) {
        let s = t[n < 0 ? i.name : o[n]];
        if (s)
          return s;
      }
    };
  }
}
Et.none = new Et(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class $p {
  /// Create a set with the given types. The `id` property of each
  /// type should correspond to its position within the array.
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /// Create a copy of this set with some node properties added. The
  /// arguments to this method can be created with
  /// [`NodeProp.add`](#common.NodeProp.add).
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let o = null;
      for (let n of e) {
        let s = n(i);
        s && (o || (o = Object.assign({}, i.props)), o[s[0].id] = s[1]);
      }
      t.push(o ? new Et(i.name, o, i.id, i.flags) : i);
    }
    return new $p(t);
  }
}
const ul = /* @__PURE__ */ new WeakMap(), xb = /* @__PURE__ */ new WeakMap();
var $e;
(function(r) {
  r[r.ExcludeBuffers = 1] = "ExcludeBuffers", r[r.IncludeAnonymous = 2] = "IncludeAnonymous", r[r.IgnoreMounts = 4] = "IgnoreMounts", r[r.IgnoreOverlays = 8] = "IgnoreOverlays";
})($e || ($e = {}));
class Xe {
  /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  constructor(e, t, i, o, n) {
    if (this.type = e, this.children = t, this.positions = i, this.length = o, this.props = null, n && n.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [s, a] of n)
        this.props[typeof s == "number" ? s : s.id] = a;
    }
  }
  /// @internal
  toString() {
    let e = this.prop(he.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let o = i.toString();
      o && (t && (t += ","), t += o);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /// Get a [tree cursor](#common.TreeCursor) positioned at the top of
  /// the tree. Mode can be used to [control](#common.IterMode) which
  /// nodes the cursor visits.
  cursor(e = 0) {
    return new la(this.topNode, e);
  }
  /// Get a [tree cursor](#common.TreeCursor) pointing into this tree
  /// at the given position and side (see
  /// [`moveTo`](#common.TreeCursor.moveTo).
  cursorAt(e, t = 0, i = 0) {
    let o = ul.get(this) || this.topNode, n = new la(o);
    return n.moveTo(e, t), ul.set(this, n._tree), n;
  }
  /// Get a [syntax node](#common.SyntaxNode) object for the top of the
  /// tree.
  get topNode() {
    return new ui(this, 0, 0, null);
  }
  /// Get the [syntax node](#common.SyntaxNode) at the given position.
  /// If `side` is -1, this will move into nodes that end at the
  /// position. If 1, it'll move into nodes that start at the
  /// position. With 0, it'll only enter nodes that cover the position
  /// from both sides.
  ///
  /// Note that this will not enter
  /// [overlays](#common.MountedTree.overlay), and you often want
  /// [`resolveInner`](#common.Tree.resolveInner) instead.
  resolve(e, t = 0) {
    let i = Xn(ul.get(this) || this.topNode, e, t, !1);
    return ul.set(this, i), i;
  }
  /// Like [`resolve`](#common.Tree.resolve), but will enter
  /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  /// pointing into the innermost overlaid tree at the given position
  /// (with parent links going through all parent structure, including
  /// the host trees).
  resolveInner(e, t = 0) {
    let i = Xn(xb.get(this) || this.topNode, e, t, !0);
    return xb.set(this, i), i;
  }
  /// Iterate over the tree and its children, calling `enter` for any
  /// node that touches the `from`/`to` region (if given) before
  /// running over such a node's children, and `leave` (if given) when
  /// leaving the node. When `enter` returns `false`, that node will
  /// not have its children iterated over (or `leave` called).
  iterate(e) {
    let { enter: t, leave: i, from: o = 0, to: n = this.length } = e, s = e.mode || 0, a = (s & $e.IncludeAnonymous) > 0;
    for (let l = this.cursor(s | $e.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= n && l.to >= o && (!a && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && i && (a || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /// Get the value of the given [node prop](#common.NodeProp) for this
  /// node. Works with both per-node and per-type props.
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /// Returns the node's [per-node props](#common.NodeProp.perNode) in a
  /// format that can be passed to the [`Tree`](#common.Tree)
  /// constructor.
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /// Balance the direct children of this tree, producing a copy of
  /// which may have children grouped into subtrees with type
  /// [`NodeType.none`](#common.NodeType^none).
  balance(e = {}) {
    return this.children.length <= 8 ? this : Dp(Et.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, o) => new Xe(this.type, t, i, o, this.propValues), e.makeTree || ((t, i, o) => new Xe(Et.none, t, i, o)));
  }
  /// Build a tree from a postfix-ordered buffer of node information,
  /// or a cursor over such a buffer.
  static build(e) {
    return nD(e);
  }
}
Xe.empty = new Xe(Et.none, [], [], 0);
class Rp {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Rp(this.buffer, this.index);
  }
}
class Io {
  /// Create a tree buffer.
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /// @internal
  get type() {
    return Et.none;
  }
  /// @internal
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /// @internal
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], o = this.set.types[t], n = o.name;
    if (/\W/.test(n) && !o.isError && (n = JSON.stringify(n)), e += 4, i == e)
      return n;
    let s = [];
    for (; e < i; )
      s.push(this.childString(e)), e = this.buffer[e + 3];
    return n + "(" + s.join(",") + ")";
  }
  /// @internal
  findChild(e, t, i, o, n) {
    let { buffer: s } = this, a = -1;
    for (let l = e; l != t && !(hx(n, o, s[l + 1], s[l + 2]) && (a = l, i > 0)); l = s[l + 3])
      ;
    return a;
  }
  /// @internal
  slice(e, t, i) {
    let o = this.buffer, n = new Uint16Array(t - e), s = 0;
    for (let a = e, l = 0; a < t; ) {
      n[l++] = o[a++], n[l++] = o[a++] - i;
      let u = n[l++] = o[a++] - i;
      n[l++] = o[a++] - e, s = Math.max(s, u);
    }
    return new Io(n, s, this.set);
  }
}
function hx(r, e, t, i) {
  switch (r) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function cx(r, e) {
  let t = r.childBefore(e);
  for (; t; ) {
    let i = t.lastChild;
    if (!i || i.to != t.to)
      break;
    i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
  }
  return r;
}
function Xn(r, e, t, i) {
  for (var o; r.from == r.to || (t < 1 ? r.from >= e : r.from > e) || (t > -1 ? r.to <= e : r.to < e); ) {
    let s = !i && r instanceof ui && r.index < 0 ? null : r.parent;
    if (!s)
      return r;
    r = s;
  }
  let n = i ? 0 : $e.IgnoreOverlays;
  if (i)
    for (let s = r, a = s.parent; a; s = a, a = s.parent)
      s instanceof ui && s.index < 0 && ((o = a.enter(e, t, n)) === null || o === void 0 ? void 0 : o.from) != s.from && (r = a);
  for (; ; ) {
    let s = r.enter(e, t, n);
    if (!s)
      return r;
    r = s;
  }
}
class ui {
  constructor(e, t, i, o) {
    this._tree = e, this.from = t, this.index = i, this._parent = o;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, o, n = 0) {
    for (let s = this; ; ) {
      for (let { children: a, positions: l } = s._tree, u = t > 0 ? a.length : -1; e != u; e += t) {
        let h = a[e], c = l[e] + s.from;
        if (hx(o, i, c, c + h.length)) {
          if (h instanceof Io) {
            if (n & $e.ExcludeBuffers)
              continue;
            let d = h.findChild(0, h.buffer.length, t, i - c, o);
            if (d > -1)
              return new Ni(new oD(s, h, e, c), null, d);
          } else if (n & $e.IncludeAnonymous || !h.type.isAnonymous || _p(h)) {
            let d;
            if (!(n & $e.IgnoreMounts) && h.props && (d = h.prop(he.mounted)) && !d.overlay)
              return new ui(d.tree, c, e, s);
            let f = new ui(h, c, e, s);
            return n & $e.IncludeAnonymous || !f.type.isAnonymous ? f : f.nextChild(t < 0 ? h.children.length - 1 : 0, t, i, o);
          }
        }
      }
      if (n & $e.IncludeAnonymous || !s.type.isAnonymous || (s.index >= 0 ? e = s.index + t : e = t < 0 ? -1 : s._parent._tree.children.length, s = s._parent, !s))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    let o;
    if (!(i & $e.IgnoreOverlays) && (o = this._tree.prop(he.mounted)) && o.overlay) {
      let n = e - this.from;
      for (let { from: s, to: a } of o.overlay)
        if ((t > 0 ? s <= n : s < n) && (t < 0 ? a >= n : a > n))
          return new ui(o.tree, o.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(e = 0) {
    return new la(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, t = 0) {
    return Xn(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Xn(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return cx(this, e);
  }
  getChild(e, t = null, i = null) {
    let o = gu(this, e, t, i);
    return o.length ? o[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return gu(this, e, t, i);
  }
  /// @internal
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return mu(this, e);
  }
}
function gu(r, e, t, i) {
  let o = r.cursor(), n = [];
  if (!o.firstChild())
    return n;
  if (t != null) {
    for (; !o.type.is(t); )
      if (!o.nextSibling())
        return n;
  }
  for (; ; ) {
    if (i != null && o.type.is(i))
      return n;
    if (o.type.is(e) && n.push(o.node), !o.nextSibling())
      return i == null ? n : [];
  }
}
function mu(r, e, t = e.length - 1) {
  for (let i = r.parent; t >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class oD {
  constructor(e, t, i, o) {
    this.parent = e, this.buffer = t, this.index = i, this.start = o;
  }
}
class Ni {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: o } = this.context, n = o.findChild(this.index + 4, o.buffer[this.index + 3], e, t - this.context.start, i);
    return n < 0 ? null : new Ni(this.context, this, n);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    if (i & $e.ExcludeBuffers)
      return null;
    let { buffer: o } = this.context, n = o.findChild(this.index + 4, o.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return n < 0 ? null : new Ni(this.context, this, n);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new Ni(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new Ni(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(e = 0) {
    return new la(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, o = this.index + 4, n = i.buffer[this.index + 3];
    if (n > o) {
      let s = i.buffer[this.index + 1];
      e.push(i.slice(o, n, s)), t.push(0);
    }
    return new Xe(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return Xn(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return Xn(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return cx(this, e);
  }
  /// @internal
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, i = null) {
    let o = gu(this, e, t, i);
    return o.length ? o[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return gu(this, e, t, i);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return mu(this, e);
  }
}
class la {
  /// Shorthand for `.type.name`.
  get name() {
    return this.type.name;
  }
  /// @internal
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof ui)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: o } = this.buffer;
    return this.type = t || o.set.types[o.buffer[e]], this.from = i + o.buffer[e + 1], this.to = i + o.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof ui ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /// @internal
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /// @internal
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: o } = this.buffer, n = o.findChild(this.index + 4, o.buffer[this.index + 3], e, t - this.buffer.start, i);
    return n < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(n));
  }
  /// Move the cursor to this node's first child. When this returns
  /// false, the node has no child, and the cursor has not been moved.
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to this node's last child.
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /// Move the cursor to the first child that ends after `pos`.
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /// Move to the last child that starts before `pos`.
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /// Move the cursor to the child around `pos`. If side is -1 the
  /// child may end at that position, when 1 it may start there. This
  /// will also enter [overlaid](#common.MountedTree.overlay)
  /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  /// set to false.
  enter(e, t, i = this.mode) {
    return this.buffer ? i & $e.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  /// Move to the node's parent node, if this isn't the top node.
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & $e.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & $e.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /// @internal
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let o = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != o)
        return this.yieldBuf(t.findChild(
          o,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let o = t.buffer[this.index + 3];
      if (o < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(o);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /// Move to this node's next sibling, if any.
  nextSibling() {
    return this.sibling(1);
  }
  /// Move to this node's previous sibling, if any.
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: o } = this;
    if (o) {
      if (e > 0) {
        if (this.index < o.buffer.buffer.length)
          return !1;
      } else
        for (let n = 0; n < this.index; n++)
          if (o.buffer.buffer[n + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = o);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let n = t + e, s = e < 0 ? -1 : i._tree.children.length; n != s; n += e) {
          let a = i._tree.children[n];
          if (this.mode & $e.IncludeAnonymous || a instanceof Io || !a.type.isAnonymous || _p(a))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /// Move to the next node in a
  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  /// traversal, going from a node to its first child or, if the
  /// current node is empty or `enter` is false, its next sibling or
  /// the next sibling of the first parent node that has one.
  next(e = !0) {
    return this.move(1, e);
  }
  /// Move to the next node in a last-to-first pre-order traveral. A
  /// node is followed by its last child or, if it has none, its
  /// previous sibling or the previous sibling of the first parent
  /// node that has one.
  prev(e = !0) {
    return this.move(-1, e);
  }
  /// Move the cursor to the innermost node that covers `pos`. If
  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  /// it will enter nodes that start at `pos`.
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /// Get a [syntax node](#common.SyntaxNode) at the cursor's current
  /// position.
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let o = this.index, n = this.stack.length; n >= 0; ) {
          for (let s = e; s; s = s._parent)
            if (s.index == o) {
              if (o == this.index)
                return s;
              t = s, i = n + 1;
              break e;
            }
          o = this.stack[--n];
        }
    for (let o = i; o < this.stack.length; o++)
      t = new Ni(this.buffer, t, this.stack[o]);
    return this.bufferNode = new Ni(this.buffer, t, this.index);
  }
  /// Get the [tree](#common.Tree) that represents the current node, if
  /// any. Will return null when the node is in a [tree
  /// buffer](#common.TreeBuffer).
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /// Iterate over the current node and all its descendants, calling
  /// `enter` when entering a node and `leave`, if given, when leaving
  /// one. When `enter` returns `false`, any children of that node are
  /// skipped, and `leave` isn't called for it.
  iterate(e, t) {
    for (let i = 0; ; ) {
      let o = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (o = !0);
      }
      for (; o && t && t(this), o = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, o = !0;
      }
    }
  }
  /// Test whether the current node matches a given context—a sequence
  /// of direct parent node names. Empty strings in the context array
  /// are treated as wildcards.
  matchContext(e) {
    if (!this.buffer)
      return mu(this.node, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let o = e.length - 1, n = this.stack.length - 1; o >= 0; n--) {
      if (n < 0)
        return mu(this.node, e, o);
      let s = i[t.buffer[this.stack[n]]];
      if (!s.isAnonymous) {
        if (e[o] && e[o] != s.name)
          return !1;
        o--;
      }
    }
    return !0;
  }
}
function _p(r) {
  return r.children.some((e) => e instanceof Io || !e.type.isAnonymous || _p(e));
}
function nD(r) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: o = ux, reused: n = [], minRepeatType: s = i.types.length } = r, a = Array.isArray(t) ? new Rp(t, t.length) : t, l = i.types, u = 0, h = 0;
  function c(y, x, P, k, C) {
    let { id: T, start: R, end: M, size: E } = a, Z = h;
    for (; E < 0; )
      if (a.next(), E == -1) {
        let te = n[T];
        P.push(te), k.push(R - y);
        return;
      } else if (E == -3) {
        u = T;
        return;
      } else if (E == -4) {
        h = T;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${E}`);
    let N = l[T], G, ee, oe = R - y;
    if (M - R <= o && (ee = g(a.pos - x, C))) {
      let te = new Uint16Array(ee.size - ee.skip), ce = a.pos - ee.size, ye = te.length;
      for (; a.pos > ce; )
        ye = b(ee.start, te, ye);
      G = new Io(te, M - ee.start, i), oe = ee.start - y;
    } else {
      let te = a.pos - E;
      a.next();
      let ce = [], ye = [], Vt = T >= s ? T : -1, Zt = 0, Lt = M;
      for (; a.pos > te; )
        Vt >= 0 && a.id == Vt && a.size >= 0 ? (a.end <= Lt - o && (f(ce, ye, R, Zt, a.end, Lt, Vt, Z), Zt = ce.length, Lt = a.end), a.next()) : c(R, te, ce, ye, Vt);
      if (Vt >= 0 && Zt > 0 && Zt < ce.length && f(ce, ye, R, Zt, R, Lt, Vt, Z), ce.reverse(), ye.reverse(), Vt > -1 && Zt > 0) {
        let Bo = d(N);
        G = Dp(N, ce, ye, 0, ce.length, 0, M - R, Bo, Bo);
      } else
        G = p(N, ce, ye, M - R, Z - M);
    }
    P.push(G), k.push(oe);
  }
  function d(y) {
    return (x, P, k) => {
      let C = 0, T = x.length - 1, R, M;
      if (T >= 0 && (R = x[T]) instanceof Xe) {
        if (!T && R.type == y && R.length == k)
          return R;
        (M = R.prop(he.lookAhead)) && (C = P[T] + R.length + M);
      }
      return p(y, x, P, k, C);
    };
  }
  function f(y, x, P, k, C, T, R, M) {
    let E = [], Z = [];
    for (; y.length > k; )
      E.push(y.pop()), Z.push(x.pop() + P - C);
    y.push(p(i.types[R], E, Z, T - C, M - T)), x.push(C - P);
  }
  function p(y, x, P, k, C = 0, T) {
    if (u) {
      let R = [he.contextHash, u];
      T = T ? [R].concat(T) : [R];
    }
    if (C > 25) {
      let R = [he.lookAhead, C];
      T = T ? [R].concat(T) : [R];
    }
    return new Xe(y, x, P, k, T);
  }
  function g(y, x) {
    let P = a.fork(), k = 0, C = 0, T = 0, R = P.end - o, M = { size: 0, start: 0, skip: 0 };
    e:
      for (let E = P.pos - y; P.pos > E; ) {
        let Z = P.size;
        if (P.id == x && Z >= 0) {
          M.size = k, M.start = C, M.skip = T, T += 4, k += 4, P.next();
          continue;
        }
        let N = P.pos - Z;
        if (Z < 0 || N < E || P.start < R)
          break;
        let G = P.id >= s ? 4 : 0, ee = P.start;
        for (P.next(); P.pos > N; ) {
          if (P.size < 0)
            if (P.size == -3)
              G += 4;
            else
              break e;
          else
            P.id >= s && (G += 4);
          P.next();
        }
        C = ee, k += Z, T += G;
      }
    return (x < 0 || k == y) && (M.size = k, M.start = C, M.skip = T), M.size > 4 ? M : void 0;
  }
  function b(y, x, P) {
    let { id: k, start: C, end: T, size: R } = a;
    if (a.next(), R >= 0 && k < s) {
      let M = P;
      if (R > 4) {
        let E = a.pos - (R - 4);
        for (; a.pos > E; )
          P = b(y, x, P);
      }
      x[--P] = M, x[--P] = T - y, x[--P] = C - y, x[--P] = k;
    } else
      R == -3 ? u = k : R == -4 && (h = k);
    return P;
  }
  let m = [], v = [];
  for (; a.pos > 0; )
    c(r.start || 0, r.bufferStart || 0, m, v, -1);
  let S = (e = r.length) !== null && e !== void 0 ? e : m.length ? v[0] + m[0].length : 0;
  return new Xe(l[r.topID], m.reverse(), v.reverse(), S);
}
const Sb = /* @__PURE__ */ new WeakMap();
function $l(r, e) {
  if (!r.isAnonymous || e instanceof Io || e.type != r)
    return 1;
  let t = Sb.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != r || !(i instanceof Xe)) {
        t = 1;
        break;
      }
      t += $l(r, i);
    }
    Sb.set(e, t);
  }
  return t;
}
function Dp(r, e, t, i, o, n, s, a, l) {
  let u = 0;
  for (let p = i; p < o; p++)
    u += $l(r, e[p]);
  let h = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), c = [], d = [];
  function f(p, g, b, m, v) {
    for (let S = b; S < m; ) {
      let y = S, x = g[S], P = $l(r, p[S]);
      for (S++; S < m; S++) {
        let k = $l(r, p[S]);
        if (P + k >= h)
          break;
        P += k;
      }
      if (S == y + 1) {
        if (P > h) {
          let k = p[y];
          f(k.children, k.positions, 0, k.children.length, g[y] + v);
          continue;
        }
        c.push(p[y]);
      } else {
        let k = g[S - 1] + p[S - 1].length - x;
        c.push(Dp(r, p, g, y, S, x, k, null, l));
      }
      d.push(x + v - n);
    }
  }
  return f(e, t, i, o, 0), (a || l)(c, d, s);
}
class sD {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, i) {
    let o = this.map.get(e);
    o || this.map.set(e, o = /* @__PURE__ */ new Map()), o.set(t, i);
  }
  getBuffer(e, t) {
    let i = this.map.get(e);
    return i && i.get(t);
  }
  /// Set the value for this syntax node.
  set(e, t) {
    e instanceof Ni ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof ui && this.map.set(e.tree, t);
  }
  /// Retrieve value for this syntax node, if it exists in the map.
  get(e) {
    return e instanceof Ni ? this.getBuffer(e.context.buffer, e.index) : e instanceof ui ? this.map.get(e.tree) : void 0;
  }
  /// Set the value for the node that a cursor currently points to.
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /// Retrieve the value for the node that a cursor currently points
  /// to.
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class or {
  /// Construct a tree fragment. You'll usually want to use
  /// [`addTree`](#common.TreeFragment^addTree) and
  /// [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  /// calling this directly.
  constructor(e, t, i, o, n = !1, s = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = o, this.open = (n ? 1 : 0) | (s ? 2 : 0);
  }
  /// Whether the start of the fragment represents the start of a
  /// parse, or the end of a change. (In the second case, it may not
  /// be safe to reuse some nodes at the start, depending on the
  /// parsing algorithm.)
  get openStart() {
    return (this.open & 1) > 0;
  }
  /// Whether the end of the fragment represents the end of a
  /// full-document parse, or the start of a change.
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /// Create a set of fragments from a freshly parsed tree, or update
  /// an existing set of fragments by replacing the ones that overlap
  /// with a tree with content from the new tree. When `partial` is
  /// true, the parse is treated as incomplete, and the resulting
  /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  /// true.
  static addTree(e, t = [], i = !1) {
    let o = [new or(0, e.length, e, 0, !1, i)];
    for (let n of t)
      n.to > e.length && o.push(n);
    return o;
  }
  /// Apply a set of edits to an array of fragments, removing or
  /// splitting fragments as necessary to remove edited ranges, and
  /// adjusting offsets for fragments that moved.
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let o = [], n = 1, s = e.length ? e[0] : null;
    for (let a = 0, l = 0, u = 0; ; a++) {
      let h = a < t.length ? t[a] : null, c = h ? h.fromA : 1e9;
      if (c - l >= i)
        for (; s && s.from < c; ) {
          let d = s;
          if (l >= d.from || c <= d.to || u) {
            let f = Math.max(d.from, l) - u, p = Math.min(d.to, c) - u;
            d = f >= p ? null : new or(f, p, d.tree, d.offset + u, a > 0, !!h);
          }
          if (d && o.push(d), s.to > c)
            break;
          s = n < e.length ? e[n++] : null;
        }
      if (!h)
        break;
      l = h.toA, u = h.toA - h.toB;
    }
    return o;
  }
}
class dx {
  /// Start a parse, returning a [partial parse](#common.PartialParse)
  /// object. [`fragments`](#common.TreeFragment) can be passed in to
  /// make the parse incremental.
  ///
  /// By default, the entire input is parsed. You can pass `ranges`,
  /// which should be a sorted array of non-empty, non-overlapping
  /// ranges, to parse only those ranges. The tree returned in that
  /// case will start at `ranges[0].from`.
  startParse(e, t, i) {
    return typeof e == "string" && (e = new aD(e)), i = i ? i.length ? i.map((o) => new si(o.from, o.to)) : [new si(0, 0)] : [new si(0, e.length)], this.createParse(e, t || [], i);
  }
  /// Run a full parse, returning the resulting tree.
  parse(e, t, i) {
    let o = this.startParse(e, t, i);
    for (; ; ) {
      let n = o.advance();
      if (n)
        return n;
    }
  }
}
class aD {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function lD(r) {
  return (e, t, i, o) => new hD(e, r, t, i, o);
}
class Cb {
  constructor(e, t, i, o, n) {
    if (this.parser = e, this.parse = t, this.overlay = i, this.target = o, this.ranges = n, !n.length || n.some((s) => s.from >= s.to))
      throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(n));
  }
}
class uD {
  constructor(e, t, i, o, n, s, a) {
    this.parser = e, this.predicate = t, this.mounts = i, this.index = o, this.start = n, this.target = s, this.prev = a, this.depth = 0, this.ranges = [];
  }
}
const Yd = new he({ perNode: !0 });
class hD {
  constructor(e, t, i, o, n) {
    this.nest = t, this.input = i, this.fragments = o, this.ranges = n, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let o of this.inner)
          o.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new Xe(i.type, i.children, i.positions, i.length, i.propValues.concat([[Yd, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[he.mounted.id] = new iD(t, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].ranges[0].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new fD(this.fragments), t = null, i = null, o = new la(new ui(this.baseTree, this.ranges[0].from, 0, null), $e.IncludeAnonymous | $e.IgnoreMounts);
    e:
      for (let n, s; this.stoppedAt == null || o.from < this.stoppedAt; ) {
        let a = !0, l;
        if (e.hasNode(o)) {
          if (t) {
            let u = t.mounts.find((h) => h.frag.from <= o.from && h.frag.to >= o.to && h.mount.overlay);
            if (u)
              for (let h of u.mount.overlay) {
                let c = h.from + u.pos, d = h.to + u.pos;
                c >= o.from && d <= o.to && !t.ranges.some((f) => f.from < d && f.to > c) && t.ranges.push({ from: c, to: d });
              }
          }
          a = !1;
        } else if (i && (s = cD(i.ranges, o.from, o.to)))
          a = s != 2;
        else if (!o.type.isAnonymous && o.from < o.to && (n = this.nest(o, this.input))) {
          o.tree || dD(o);
          let u = e.findMounts(o.from, n.parser);
          if (typeof n.overlay == "function")
            t = new uD(n.parser, n.overlay, u, this.inner.length, o.from, o.tree, t);
          else {
            let h = kb(this.ranges, n.overlay || [new si(o.from, o.to)]);
            h.length && this.inner.push(new Cb(n.parser, n.parser.startParse(this.input, Eb(u, h), h), n.overlay ? n.overlay.map((c) => new si(c.from - o.from, c.to - o.from)) : null, o.tree, h)), n.overlay ? h.length && (i = { ranges: h, depth: 0, prev: i }) : a = !1;
          }
        } else
          t && (l = t.predicate(o)) && (l === !0 && (l = new si(o.from, o.to)), l.from < l.to && t.ranges.push(l));
        if (a && o.firstChild())
          t && t.depth++, i && i.depth++;
        else
          for (; !o.nextSibling(); ) {
            if (!o.parent())
              break e;
            if (t && !--t.depth) {
              let u = kb(this.ranges, t.ranges);
              u.length && this.inner.splice(t.index, 0, new Cb(t.parser, t.parser.startParse(this.input, Eb(t.mounts, u), u), t.ranges.map((h) => new si(h.from - t.start, h.to - t.start)), t.target, u)), t = t.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
}
function cD(r, e, t) {
  for (let i of r) {
    if (i.from >= t)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= t ? 2 : 1;
  }
  return 0;
}
function Qb(r, e, t, i, o, n) {
  if (e < t) {
    let s = r.buffer[e + 1];
    i.push(r.slice(e, t, s)), o.push(s - n);
  }
}
function dD(r) {
  let { node: e } = r, t = 0;
  do
    r.parent(), t++;
  while (!r.tree);
  let i = 0, o = r.tree, n = 0;
  for (; n = o.positions[i] + r.from, !(n <= e.from && n + o.children[i].length >= e.to); i++)
    ;
  let s = o.children[i], a = s.buffer;
  function l(u, h, c, d, f) {
    let p = u;
    for (; a[p + 2] + n <= e.from; )
      p = a[p + 3];
    let g = [], b = [];
    Qb(s, u, p, g, b, d);
    let m = a[p + 1], v = a[p + 2], S = m + n == e.from && v + n == e.to && a[p] == e.type.id;
    return g.push(S ? e.toTree() : l(p + 4, a[p + 3], s.set.types[a[p]], m, v - m)), b.push(m - d), Qb(s, a[p + 3], h, g, b, d), new Xe(c, g, b, f);
  }
  o.children[i] = l(0, a.length, Et.none, 0, s.length);
  for (let u = 0; u <= t; u++)
    r.childAfter(e.from);
}
class Pb {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor($e.IncludeAnonymous | $e.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, i = e - this.offset;
    for (; !this.done && t.from < i; )
      t.to >= e && t.enter(i, 1, $e.IgnoreOverlays | $e.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof Xe)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let fD = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (t = i.tree.prop(Yd)) !== null && t !== void 0 ? t : i.to, this.inner = new Pb(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(Yd)) !== null && e !== void 0 ? e : t.to, this.inner = new Pb(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var i;
    let o = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let n = this.inner.cursor.node; n; n = n.parent) {
        let s = (i = n.tree) === null || i === void 0 ? void 0 : i.prop(he.mounted);
        if (s && s.parser == t)
          for (let a = this.fragI; a < this.fragments.length; a++) {
            let l = this.fragments[a];
            if (l.from >= n.to)
              break;
            l.tree == this.curFrag.tree && o.push({
              frag: l,
              pos: n.from - l.offset,
              mount: s
            });
          }
      }
    }
    return o;
  }
};
function kb(r, e) {
  let t = null, i = e;
  for (let o = 1, n = 0; o < r.length; o++) {
    let s = r[o - 1].to, a = r[o].from;
    for (; n < i.length; n++) {
      let l = i[n];
      if (l.from >= a)
        break;
      l.to <= s || (t || (i = t = e.slice()), l.from < s ? (t[n] = new si(l.from, s), l.to > a && t.splice(n + 1, 0, new si(a, l.to))) : l.to > a ? t[n--] = new si(a, l.to) : t.splice(n--, 1));
    }
  }
  return i;
}
function pD(r, e, t, i) {
  let o = 0, n = 0, s = !1, a = !1, l = -1e9, u = [];
  for (; ; ) {
    let h = o == r.length ? 1e9 : s ? r[o].to : r[o].from, c = n == e.length ? 1e9 : a ? e[n].to : e[n].from;
    if (s != a) {
      let d = Math.max(l, t), f = Math.min(h, c, i);
      d < f && u.push(new si(d, f));
    }
    if (l = Math.min(h, c), l == 1e9)
      break;
    h == l && (s ? (s = !1, o++) : s = !0), c == l && (a ? (a = !1, n++) : a = !0);
  }
  return u;
}
function Eb(r, e) {
  let t = [];
  for (let { pos: i, mount: o, frag: n } of r) {
    let s = i + (o.overlay ? o.overlay[0].from : 0), a = s + o.tree.length, l = Math.max(n.from, s), u = Math.min(n.to, a);
    if (o.overlay) {
      let h = o.overlay.map((d) => new si(d.from + i, d.to + i)), c = pD(e, h, l, u);
      for (let d = 0, f = l; ; d++) {
        let p = d == c.length, g = p ? u : c[d].from;
        if (g > f && t.push(new or(f, g, o.tree, -s, n.from >= f || n.openStart, n.to <= g || n.openEnd)), p)
          break;
        f = c[d].to;
      }
    } else
      t.push(new or(l, u, o.tree, -s, n.from >= s || n.openStart, n.to <= a || n.openEnd));
  }
  return t;
}
let gD = 0;
class Di {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = gD++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Di([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new bu();
    return (t) => t.modified.indexOf(e) > -1 ? t : bu.get(t.base || t, t.modified.concat(e).sort((i, o) => i.id - o.id));
  }
}
let mD = 0;
class bu {
  constructor() {
    this.instances = [], this.id = mD++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((a) => a.base == e && bD(t, a.modified));
    if (i)
      return i;
    let o = [], n = new Di(o, e, t);
    for (let a of t)
      a.instances.push(n);
    let s = OD(t);
    for (let a of e.set)
      if (!a.modified.length)
        for (let l of s)
          o.push(bu.get(a, l));
    return n;
  }
}
function bD(r, e) {
  return r.length == e.length && r.every((t, i) => t == e[i]);
}
function OD(r) {
  let e = [[]];
  for (let t = 0; t < r.length; t++)
    for (let i = 0, o = e.length; i < o; i++)
      e.push(e[i].concat(r[t]));
  return e.sort((t, i) => i.length - t.length);
}
function Uo(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r) {
    let i = r[t];
    Array.isArray(i) || (i = [i]);
    for (let o of t.split(" "))
      if (o) {
        let n = [], s = 2, a = o;
        for (let c = 0; ; ) {
          if (a == "..." && c > 0 && c + 3 == o.length) {
            s = 1;
            break;
          }
          let d = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(a);
          if (!d)
            throw new RangeError("Invalid path: " + o);
          if (n.push(d[0] == "*" ? "" : d[0][0] == '"' ? JSON.parse(d[0]) : d[0]), c += d[0].length, c == o.length)
            break;
          let f = o[c++];
          if (c == o.length && f == "!") {
            s = 0;
            break;
          }
          if (f != "/")
            throw new RangeError("Invalid path: " + o);
          a = o.slice(c);
        }
        let l = n.length - 1, u = n[l];
        if (!u)
          throw new RangeError("Invalid path: " + o);
        let h = new Ou(i, s, l > 0 ? n.slice(0, l) : null);
        e[u] = h.sort(e[u]);
      }
  }
  return fx.add(e);
}
const fx = new he();
class Ou {
  constructor(e, t, i, o) {
    this.tags = e, this.mode = t, this.context = i, this.next = o;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
Ou.empty = new Ou([], 2, null);
function px(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let n of r)
    if (!Array.isArray(n.tag))
      t[n.tag.id] = n.class;
    else
      for (let s of n.tag)
        t[s.id] = n.class;
  let { scope: i, all: o = null } = e || {};
  return {
    style: (n) => {
      let s = o;
      for (let a of n)
        for (let l of a.set) {
          let u = t[l.id];
          if (u) {
            s = s ? s + " " + u : u;
            break;
          }
        }
      return s;
    },
    scope: i
  };
}
function vD(r, e) {
  let t = null;
  for (let i of r) {
    let o = i.style(e);
    o && (t = t ? t + " " + o : o);
  }
  return t;
}
function wD(r, e, t, i = 0, o = r.length) {
  let n = new yD(i, Array.isArray(e) ? e : [e], t);
  n.highlightRange(r.cursor(), i, o, "", n.highlighters), n.flush(o);
}
class yD {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, o, n) {
    let { type: s, from: a, to: l } = e;
    if (a >= i || l <= t)
      return;
    s.isTop && (n = this.highlighters.filter((f) => !f.scope || f.scope(s)));
    let u = o, h = xD(e) || Ou.empty, c = vD(n, h.tags);
    if (c && (u && (u += " "), u += c, h.mode == 1 && (o += (o ? " " : "") + c)), this.startSpan(Math.max(t, a), u), h.opaque)
      return;
    let d = e.tree && e.tree.prop(he.mounted);
    if (d && d.overlay) {
      let f = e.node.enter(d.overlay[0].from + a, 1), p = this.highlighters.filter((b) => !b.scope || b.scope(d.tree.type)), g = e.firstChild();
      for (let b = 0, m = a; ; b++) {
        let v = b < d.overlay.length ? d.overlay[b] : null, S = v ? v.from + a : l, y = Math.max(t, m), x = Math.min(i, S);
        if (y < x && g)
          for (; e.from < x && (this.highlightRange(e, y, x, o, n), this.startSpan(Math.min(x, e.to), u), !(e.to >= S || !e.nextSibling())); )
            ;
        if (!v || S > i)
          break;
        m = v.to + a, m > t && (this.highlightRange(f.cursor(), Math.max(t, v.from + a), Math.min(i, m), "", p), this.startSpan(Math.min(i, m), u));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      d && (o = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, o, n), this.startSpan(Math.min(i, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function xD(r) {
  let e = r.type.prop(fx);
  for (; e && e.context && !r.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const I = Di.define, hl = I(), Sr = I(), Tb = I(Sr), $b = I(Sr), Cr = I(), cl = I(Cr), uc = I(Cr), Ti = I(), ao = I(Ti), ki = I(), Ei = I(), Fd = I(), as = I(Fd), dl = I(), O = {
  /**
  A comment.
  */
  comment: hl,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: I(hl),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: I(hl),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: I(hl),
  /**
  Any kind of identifier.
  */
  name: Sr,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: I(Sr),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: Tb,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: I(Tb),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: $b,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: I($b),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: I(Sr),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: I(Sr),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: I(Sr),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: I(Sr),
  /**
  A literal value.
  */
  literal: Cr,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: cl,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: I(cl),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: I(cl),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: I(cl),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: uc,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: I(uc),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: I(uc),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: I(Cr),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: I(Cr),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: I(Cr),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: I(Cr),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: I(Cr),
  /**
  A language keyword.
  */
  keyword: ki,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: I(ki),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: I(ki),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: I(ki),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: I(ki),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: I(ki),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: I(ki),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: I(ki),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: I(ki),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: I(ki),
  /**
  An operator.
  */
  operator: Ei,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: I(Ei),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: I(Ei),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: I(Ei),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: I(Ei),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: I(Ei),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: I(Ei),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: I(Ei),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: I(Ei),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: I(Ei),
  /**
  Program or markup punctuation.
  */
  punctuation: Fd,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: I(Fd),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: as,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: I(as),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: I(as),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: I(as),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: I(as),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: Ti,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: ao,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: I(ao),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: I(ao),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: I(ao),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: I(ao),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: I(ao),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: I(ao),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: I(Ti),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: I(Ti),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: I(Ti),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: I(Ti),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: I(Ti),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: I(Ti),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: I(Ti),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: I(Ti),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: I(),
  /**
  Deleted text.
  */
  deleted: I(),
  /**
  Changed text.
  */
  changed: I(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: I(),
  /**
  Metadata or meta-instruction.
  */
  meta: dl,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: I(dl),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: I(dl),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: I(dl),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Di.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Di.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Di.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Di.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Di.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Di.defineModifier()
};
px([
  { tag: O.link, class: "tok-link" },
  { tag: O.heading, class: "tok-heading" },
  { tag: O.emphasis, class: "tok-emphasis" },
  { tag: O.strong, class: "tok-strong" },
  { tag: O.keyword, class: "tok-keyword" },
  { tag: O.atom, class: "tok-atom" },
  { tag: O.bool, class: "tok-bool" },
  { tag: O.url, class: "tok-url" },
  { tag: O.labelName, class: "tok-labelName" },
  { tag: O.inserted, class: "tok-inserted" },
  { tag: O.deleted, class: "tok-deleted" },
  { tag: O.literal, class: "tok-literal" },
  { tag: O.string, class: "tok-string" },
  { tag: O.number, class: "tok-number" },
  { tag: [O.regexp, O.escape, O.special(O.string)], class: "tok-string2" },
  { tag: O.variableName, class: "tok-variableName" },
  { tag: O.local(O.variableName), class: "tok-variableName tok-local" },
  { tag: O.definition(O.variableName), class: "tok-variableName tok-definition" },
  { tag: O.special(O.variableName), class: "tok-variableName2" },
  { tag: O.definition(O.propertyName), class: "tok-propertyName tok-definition" },
  { tag: O.typeName, class: "tok-typeName" },
  { tag: O.namespace, class: "tok-namespace" },
  { tag: O.className, class: "tok-className" },
  { tag: O.macroName, class: "tok-macroName" },
  { tag: O.propertyName, class: "tok-propertyName" },
  { tag: O.operator, class: "tok-operator" },
  { tag: O.comment, class: "tok-comment" },
  { tag: O.meta, class: "tok-meta" },
  { tag: O.invalid, class: "tok-invalid" },
  { tag: O.punctuation, class: "tok-punctuation" }
]);
var hc;
const un = /* @__PURE__ */ new he();
function SD(r) {
  return H.define({
    combine: r ? (e) => e.concat(r) : void 0
  });
}
const CD = /* @__PURE__ */ new he();
class Oi {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, i = [], o = "") {
    this.data = e, this.name = o, be.prototype.hasOwnProperty("tree") || Object.defineProperty(be.prototype, "tree", { get() {
      return ze(this);
    } }), this.parser = t, this.extension = [
      eo.of(this),
      be.languageData.of((n, s, a) => {
        let l = Rb(n, s, a), u = l.type.prop(un);
        if (!u)
          return [];
        let h = n.facet(u), c = l.type.prop(CD);
        if (c) {
          let d = l.resolve(s - l.from, a);
          for (let f of c)
            if (f.test(d, n)) {
              let p = n.facet(f.facet);
              return f.type == "replace" ? p : p.concat(h);
            }
        }
        return h;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return Rb(e, t, i).type.prop(un) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(eo);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], o = (n, s) => {
      if (n.prop(un) == this.data) {
        i.push({ from: s, to: s + n.length });
        return;
      }
      let a = n.prop(he.mounted);
      if (a) {
        if (a.tree.prop(un) == this.data) {
          if (a.overlay)
            for (let l of a.overlay)
              i.push({ from: l.from + s, to: l.to + s });
          else
            i.push({ from: s, to: s + n.length });
          return;
        } else if (a.overlay) {
          let l = i.length;
          if (o(a.tree, a.overlay[0].from + s), i.length > l)
            return;
        }
      }
      for (let l = 0; l < n.children.length; l++) {
        let u = n.children[l];
        u instanceof Xe && o(u, n.positions[l] + s);
      }
    };
    return o(ze(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Oi.setState = /* @__PURE__ */ le.define();
function Rb(r, e, t) {
  let i = r.facet(eo), o = ze(r).topNode;
  if (!i || i.allowsNesting)
    for (let n = o; n; n = n.enter(e, t, $e.ExcludeBuffers))
      n.type.isTop && (o = n);
  return o;
}
class hr extends Oi {
  constructor(e, t, i) {
    super(e, t, [], i), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = SD(e.languageData);
    return new hr(t, e.parser.configure({
      props: [un.add((i) => i.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new hr(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function ze(r) {
  let e = r.field(Oi.state, !1);
  return e ? e.tree : Xe.empty;
}
class QD {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let ls = null;
class vu {
  constructor(e, t, i = [], o, n, s, a, l) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = o, this.treeLen = n, this.viewport = s, this.skipped = a, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new vu(e, t, [], Xe.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new QD(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != Xe.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let o = Date.now() + e;
        e = () => Date.now() > o;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let o = this.parse.advance();
        if (o)
          if (this.fragments = this.withoutTempSkipped(or.addTree(o, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = o, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(or.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = ls;
    ls = this;
    try {
      return e();
    } finally {
      ls = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = _b(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: o, treeLen: n, viewport: s, skipped: a } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, h, c, d) => l.push({ fromA: u, toA: h, fromB: c, toB: d })), i = or.applyChanges(i, l), o = Xe.empty, n = 0, s = { from: e.mapPos(s.from, -1), to: e.mapPos(s.to, 1) }, this.skipped.length) {
        a = [];
        for (let u of this.skipped) {
          let h = e.mapPos(u.from, 1), c = e.mapPos(u.to, -1);
          h < c && a.push({ from: h, to: c });
        }
      }
    }
    return new vu(this.parser, t, i, o, n, s, a, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: o, to: n } = this.skipped[i];
      o < e.to && n > e.from && (this.fragments = _b(this.fragments, o, n), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends dx {
      createParse(t, i, o) {
        let n = o[0].from, s = o[o.length - 1].to;
        return {
          parsedPos: n,
          advance() {
            let l = ls;
            if (l) {
              for (let u of o)
                l.tempSkipped.push(u);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = s, new Xe(Et.none, [], [], s - n);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return ls;
  }
}
function _b(r, e, t) {
  return or.applyChanges(r, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class An {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new An(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = vu.create(e.facet(eo).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new An(i);
  }
}
Oi.state = /* @__PURE__ */ tt.define({
  create: An.init,
  update(r, e) {
    for (let t of e.effects)
      if (t.is(Oi.setState))
        return t.value;
    return e.startState.facet(eo) != e.state.facet(eo) ? An.init(e.state) : r.apply(e);
  }
});
let gx = (r) => {
  let e = setTimeout(
    () => r(),
    500
    /* MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (gx = (r) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(r, {
        timeout: 500 - 100
        /* MinPause */
      });
    },
    100
    /* MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const cc = typeof navigator < "u" && (!((hc = navigator.scheduling) === null || hc === void 0) && hc.isInputPending) ? () => navigator.scheduling.isInputPending() : null, PD = /* @__PURE__ */ Je.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Oi.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Oi.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = gx(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: o } } = this.view, n = i.field(Oi.state);
    if (n.tree == n.context.tree && n.context.isDone(
      o + 1e5
      /* MaxParseAhead */
    ))
      return;
    let s = Date.now() + Math.min(this.chunkBudget, 100, e && !cc ? Math.max(25, e.timeRemaining() - 5) : 1e9), a = n.context.treeLen < o && i.doc.length > o + 1e3, l = n.context.work(() => cc && cc() || Date.now() > s, o + (a ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (n.context.takeTree(), this.view.dispatch({ effects: Oi.setState.of(new An(n.context)) })), this.chunkBudget > 0 && !(l && !a) && this.scheduleWork(), this.checkAsyncSchedule(n.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => li(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), eo = /* @__PURE__ */ H.define({
  combine(r) {
    return r.length ? r[0] : null;
  },
  enables: (r) => [
    Oi.state,
    PD,
    B.contentAttributes.compute([r], (e) => {
      let t = e.facet(r);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class qn {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const kD = /* @__PURE__ */ H.define(), ph = /* @__PURE__ */ H.define({
  combine: (r) => {
    if (!r.length)
      return "  ";
    let e = r[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(r[0]));
    return e;
  }
});
function wu(r) {
  let e = r.facet(ph);
  return e.charCodeAt(0) == 9 ? r.tabSize * e.length : e.length;
}
function ua(r, e) {
  let t = "", i = r.tabSize, o = r.facet(ph)[0];
  if (o == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    o = " ";
  }
  for (let n = 0; n < e; n++)
    t += o;
  return t;
}
function Mp(r, e) {
  r instanceof be && (r = new gh(r));
  for (let i of r.state.facet(kD)) {
    let o = i(r, e);
    if (o !== void 0)
      return o;
  }
  let t = ze(r.state);
  return t ? ED(r, t, e) : null;
}
class gh {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = wu(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: o, simulateDoubleBreak: n } = this.options;
    return o != null && o >= i.from && o <= i.to ? n && o == e ? { text: "", from: e } : (t < 0 ? o < e : o <= e) ? { text: i.text.slice(o - i.from), from: o } : { text: i.text.slice(0, o - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: o } = this.lineAt(e, t);
    return i.slice(e - o, Math.min(i.length, e + 100 - o));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: o } = this.lineAt(e, t), n = this.countColumn(i, e - o), s = this.options.overrideIndentation ? this.options.overrideIndentation(o) : -1;
    return s > -1 && (n += s - this.countColumn(i, i.search(/\S|$/))), n;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Ca(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: o } = this.lineAt(e, t), n = this.options.overrideIndentation;
    if (n) {
      let s = n(o);
      if (s > -1)
        return s;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const Yo = /* @__PURE__ */ new he();
function ED(r, e, t) {
  return mx(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, r);
}
function TD(r) {
  return r.pos == r.options.simulateBreak && r.options.simulateDoubleBreak;
}
function $D(r) {
  let e = r.type.prop(Yo);
  if (e)
    return e;
  let t = r.firstChild, i;
  if (t && (i = t.type.prop(he.closedBy))) {
    let o = r.lastChild, n = o && i.indexOf(o.name) > -1;
    return (s) => Ox(s, !0, 1, void 0, n && !TD(s) ? o.from : void 0);
  }
  return r.parent == null ? RD : null;
}
function mx(r, e, t) {
  for (; r; r = r.parent) {
    let i = $D(r);
    if (i)
      return i(Xp.create(t, e, r));
  }
  return null;
}
function RD() {
  return 0;
}
class Xp extends gh {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new Xp(e, t, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(t.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (_D(i, e))
        break;
      t = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? mx(e, this.pos, this.base) : 0;
  }
}
function _D(r, e) {
  for (let t = e; t; t = t.parent)
    if (r == t)
      return !0;
  return !1;
}
function DD(r) {
  let e = r.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let o = r.options.simulateBreak, n = r.state.doc.lineAt(t.from), s = o == null || o <= n.from ? n.to : Math.min(n.to, o);
  for (let a = t.to; ; ) {
    let l = e.childAfter(a);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped)
      return l.from < s ? t : null;
    a = l.to;
  }
}
function bx({ closing: r, align: e = !0, units: t = 1 }) {
  return (i) => Ox(i, e, t, r);
}
function Ox(r, e, t, i, o) {
  let n = r.textAfter, s = n.match(/^\s*/)[0].length, a = i && n.slice(s, s + i.length) == i || o == r.pos + s, l = e ? DD(r) : null;
  return l ? a ? r.column(l.from) : r.column(l.to) : r.baseIndent + (a ? 0 : r.unit * t);
}
const vx = (r) => r.baseIndent;
function Yi({ except: r, units: e = 1 } = {}) {
  return (t) => {
    let i = r && r.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
const MD = 200;
function XD() {
  return be.transactionFilter.of((r) => {
    if (!r.docChanged || !r.isUserEvent("input.type") && !r.isUserEvent("input.complete"))
      return r;
    let e = r.startState.languageDataAt("indentOnInput", r.startState.selection.main.head);
    if (!e.length)
      return r;
    let t = r.newDoc, { head: i } = r.newSelection.main, o = t.lineAt(i);
    if (i > o.from + MD)
      return r;
    let n = t.sliceString(o.from, i);
    if (!e.some((u) => u.test(n)))
      return r;
    let { state: s } = r, a = -1, l = [];
    for (let { head: u } of s.selection.ranges) {
      let h = s.doc.lineAt(u);
      if (h.from == a)
        continue;
      a = h.from;
      let c = Mp(s, h.from);
      if (c == null)
        continue;
      let d = /^\s*/.exec(h.text)[0], f = ua(s, c);
      d != f && l.push({ from: h.from, to: h.from + d.length, insert: f });
    }
    return l.length ? [r, { changes: l, sequential: !0 }] : r;
  });
}
const AD = /* @__PURE__ */ H.define(), Fo = /* @__PURE__ */ new he();
function mh(r) {
  let e = r.firstChild, t = r.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? r.to : t.from } : null;
}
function zD(r, e, t) {
  let i = ze(r);
  if (i.length < t)
    return null;
  let o = i.resolveInner(t, 1), n = null;
  for (let s = o; s; s = s.parent) {
    if (s.to <= t || s.from > t)
      continue;
    if (n && s.from < e)
      break;
    let a = s.type.prop(Fo);
    if (a && (s.to < i.length - 50 || i.length == r.doc.length || !ND(s))) {
      let l = a(s, r);
      l && l.from <= t && l.from >= e && l.to > t && (n = l);
    }
  }
  return n;
}
function ND(r) {
  let e = r.lastChild;
  return e && e.to == r.to && e.type.isError;
}
function yu(r, e, t) {
  for (let i of r.facet(AD)) {
    let o = i(r, e, t);
    if (o)
      return o;
  }
  return zD(r, e, t);
}
function wx(r, e) {
  let t = e.mapPos(r.from, 1), i = e.mapPos(r.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const bh = /* @__PURE__ */ le.define({ map: wx }), Ea = /* @__PURE__ */ le.define({ map: wx });
function yx(r) {
  let e = [];
  for (let { head: t } of r.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(r.lineBlockAt(t));
  return e;
}
const Mo = /* @__PURE__ */ tt.define({
  create() {
    return J.none;
  },
  update(r, e) {
    r = r.map(e.changes);
    for (let t of e.effects)
      t.is(bh) && !VD(r, t.value.from, t.value.to) ? r = r.update({ add: [Db.range(t.value.from, t.value.to)] }) : t.is(Ea) && (r = r.update({
        filter: (i, o) => t.value.from != i || t.value.to != o,
        filterFrom: t.value.from,
        filterTo: t.value.to
      }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      r.between(i, i, (o, n) => {
        o < i && n > i && (t = !0);
      }), t && (r = r.update({
        filterFrom: i,
        filterTo: i,
        filter: (o, n) => n <= i || o >= i
      }));
    }
    return r;
  },
  provide: (r) => B.decorations.from(r),
  toJSON(r, e) {
    let t = [];
    return r.between(0, e.doc.length, (i, o) => {
      t.push(i, o);
    }), t;
  },
  fromJSON(r) {
    if (!Array.isArray(r) || r.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < r.length; ) {
      let i = r[t++], o = r[t++];
      if (typeof i != "number" || typeof o != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(Db.range(i, o));
    }
    return J.set(e, !0);
  }
});
function xu(r, e, t) {
  var i;
  let o = null;
  return (i = r.field(Mo, !1)) === null || i === void 0 || i.between(e, t, (n, s) => {
    (!o || o.from > n) && (o = { from: n, to: s });
  }), o;
}
function VD(r, e, t) {
  let i = !1;
  return r.between(e, e, (o, n) => {
    o == e && n == t && (i = !0);
  }), i;
}
function xx(r, e) {
  return r.field(Mo, !1) ? e : e.concat(le.appendConfig.of(Qx()));
}
const ZD = (r) => {
  for (let e of yx(r)) {
    let t = yu(r.state, e.from, e.to);
    if (t)
      return r.dispatch({ effects: xx(r.state, [bh.of(t), Sx(r, t)]) }), !0;
  }
  return !1;
}, LD = (r) => {
  if (!r.state.field(Mo, !1))
    return !1;
  let e = [];
  for (let t of yx(r)) {
    let i = xu(r.state, t.from, t.to);
    i && e.push(Ea.of(i), Sx(r, i, !1));
  }
  return e.length && r.dispatch({ effects: e }), e.length > 0;
};
function Sx(r, e, t = !0) {
  let i = r.state.doc.lineAt(e.from).number, o = r.state.doc.lineAt(e.to).number;
  return B.announce.of(`${r.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${r.state.phrase("to")} ${o}.`);
}
const WD = (r) => {
  let { state: e } = r, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let o = r.lineBlockAt(i), n = yu(e, o.from, o.to);
    n && t.push(bh.of(n)), i = (n ? r.lineBlockAt(n.to) : o).to + 1;
  }
  return t.length && r.dispatch({ effects: xx(r.state, t) }), !!t.length;
}, ID = (r) => {
  let e = r.state.field(Mo, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, r.state.doc.length, (i, o) => {
    t.push(Ea.of({ from: i, to: o }));
  }), r.dispatch({ effects: t }), !0;
}, UD = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: ZD },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: LD },
  { key: "Ctrl-Alt-[", run: WD },
  { key: "Ctrl-Alt-]", run: ID }
], YD = {
  placeholderDOM: null,
  placeholderText: "…"
}, Cx = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, YD);
  }
});
function Qx(r) {
  let e = [Mo, qD];
  return r && e.push(Cx.of(r)), e;
}
const Db = /* @__PURE__ */ J.replace({ widget: /* @__PURE__ */ new class extends gr {
  toDOM(r) {
    let { state: e } = r, t = e.facet(Cx), i = (n) => {
      let s = r.lineBlockAt(r.posAtDOM(n.target)), a = xu(r.state, s.from, s.to);
      a && r.dispatch({ effects: Ea.of(a) }), n.preventDefault();
    };
    if (t.placeholderDOM)
      return t.placeholderDOM(r, i);
    let o = document.createElement("span");
    return o.textContent = t.placeholderText, o.setAttribute("aria-label", e.phrase("folded code")), o.title = e.phrase("unfold"), o.className = "cm-foldPlaceholder", o.onclick = i, o;
  }
}() }), FD = {
  openText: "⌄",
  closedText: "›",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class dc extends ur {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function BD(r = {}) {
  let e = Object.assign(Object.assign({}, FD), r), t = new dc(e, !0), i = new dc(e, !1), o = Je.fromClass(class {
    constructor(s) {
      this.from = s.viewport.from, this.markers = this.buildMarkers(s);
    }
    update(s) {
      (s.docChanged || s.viewportChanged || s.startState.facet(eo) != s.state.facet(eo) || s.startState.field(Mo, !1) != s.state.field(Mo, !1) || ze(s.startState) != ze(s.state) || e.foldingChanged(s)) && (this.markers = this.buildMarkers(s.view));
    }
    buildMarkers(s) {
      let a = new Hr();
      for (let l of s.viewportLineBlocks) {
        let u = xu(s.state, l.from, l.to) ? i : yu(s.state, l.from, l.to) ? t : null;
        u && a.add(l.from, l.from, u);
      }
      return a.finish();
    }
  }), { domEventHandlers: n } = e;
  return [
    o,
    Y_({
      class: "cm-foldGutter",
      markers(s) {
        var a;
        return ((a = s.plugin(o)) === null || a === void 0 ? void 0 : a.markers) || Se.empty;
      },
      initialSpacer() {
        return new dc(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, n), { click: (s, a, l) => {
        if (n.click && n.click(s, a, l))
          return !0;
        let u = xu(s.state, a.from, a.to);
        if (u)
          return s.dispatch({ effects: Ea.of(u) }), !0;
        let h = yu(s.state, a.from, a.to);
        return h ? (s.dispatch({ effects: bh.of(h) }), !0) : !1;
      } })
    }),
    Qx()
  ];
}
const qD = /* @__PURE__ */ B.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Ta {
  constructor(e, t) {
    this.specs = e;
    let i;
    function o(a) {
      let l = jr.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = a, l;
    }
    const n = typeof t.all == "string" ? t.all : t.all ? o(t.all) : void 0, s = t.scope;
    this.scope = s instanceof Oi ? (a) => a.prop(un) == s.data : s ? (a) => a == s : void 0, this.style = px(e.map((a) => ({
      tag: a.tag,
      class: a.class || o(Object.assign({}, a, { tag: null }))
    })), {
      all: n
    }).style, this.module = i ? new jr(i) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Ta(e, t || {});
  }
}
const Bd = /* @__PURE__ */ H.define(), Px = /* @__PURE__ */ H.define({
  combine(r) {
    return r.length ? [r[0]] : null;
  }
});
function fc(r) {
  let e = r.facet(Bd);
  return e.length ? e : r.facet(Px);
}
function kx(r, e) {
  let t = [jD], i;
  return r instanceof Ta && (r.module && t.push(B.styleModule.of(r.module)), i = r.themeType), e != null && e.fallback ? t.push(Px.of(r)) : i ? t.push(Bd.computeN([B.darkTheme], (o) => o.facet(B.darkTheme) == (i == "dark") ? [r] : [])) : t.push(Bd.of(r)), t;
}
class HD {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = ze(e.state), this.decorations = this.buildDeco(e, fc(e.state));
  }
  update(e) {
    let t = ze(e.state), i = fc(e.state), o = i != fc(e.startState);
    t.length < e.view.viewport.to && !o && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || o) && (this.tree = t, this.decorations = this.buildDeco(e.view, i));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return J.none;
    let i = new Hr();
    for (let { from: o, to: n } of e.visibleRanges)
      wD(this.tree, t, (s, a, l) => {
        i.add(s, a, this.markCache[l] || (this.markCache[l] = J.mark({ class: l })));
      }, o, n);
    return i.finish();
  }
}
const jD = /* @__PURE__ */ Wo.high(/* @__PURE__ */ Je.fromClass(HD, {
  decorations: (r) => r.decorations
})), GD = /* @__PURE__ */ Ta.define([
  {
    tag: O.meta,
    color: "#404740"
  },
  {
    tag: O.link,
    textDecoration: "underline"
  },
  {
    tag: O.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: O.emphasis,
    fontStyle: "italic"
  },
  {
    tag: O.strong,
    fontWeight: "bold"
  },
  {
    tag: O.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: O.keyword,
    color: "#708"
  },
  {
    tag: [O.atom, O.bool, O.url, O.contentSeparator, O.labelName],
    color: "#219"
  },
  {
    tag: [O.literal, O.inserted],
    color: "#164"
  },
  {
    tag: [O.string, O.deleted],
    color: "#a11"
  },
  {
    tag: [O.regexp, O.escape, /* @__PURE__ */ O.special(O.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ O.definition(O.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ O.local(O.variableName),
    color: "#30a"
  },
  {
    tag: [O.typeName, O.namespace],
    color: "#085"
  },
  {
    tag: O.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ O.special(O.variableName), O.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ O.definition(O.propertyName),
    color: "#00c"
  },
  {
    tag: O.comment,
    color: "#940"
  },
  {
    tag: O.invalid,
    color: "#f00"
  }
]), KD = /* @__PURE__ */ B.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), Ex = 1e4, Tx = "()[]{}", $x = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, {
      afterCursor: !0,
      brackets: Tx,
      maxScanDistance: Ex,
      renderMatch: tM
    });
  }
}), JD = /* @__PURE__ */ J.mark({ class: "cm-matchingBracket" }), eM = /* @__PURE__ */ J.mark({ class: "cm-nonmatchingBracket" });
function tM(r) {
  let e = [], t = r.matched ? JD : eM;
  return e.push(t.range(r.start.from, r.start.to)), r.end && e.push(t.range(r.end.from, r.end.to)), e;
}
const iM = /* @__PURE__ */ tt.define({
  create() {
    return J.none;
  },
  update(r, e) {
    if (!e.docChanged && !e.selection)
      return r;
    let t = [], i = e.state.facet($x);
    for (let o of e.state.selection.ranges) {
      if (!o.empty)
        continue;
      let n = Vi(e.state, o.head, -1, i) || o.head > 0 && Vi(e.state, o.head - 1, 1, i) || i.afterCursor && (Vi(e.state, o.head, 1, i) || o.head < e.state.doc.length && Vi(e.state, o.head + 1, -1, i));
      n && (t = t.concat(i.renderMatch(n, e.state)));
    }
    return J.set(t, !0);
  },
  provide: (r) => B.decorations.from(r)
}), rM = [
  iM,
  KD
];
function oM(r = {}) {
  return [$x.of(r), rM];
}
const nM = /* @__PURE__ */ new he();
function qd(r, e, t) {
  let i = r.prop(e < 0 ? he.openedBy : he.closedBy);
  if (i)
    return i;
  if (r.name.length == 1) {
    let o = t.indexOf(r.name);
    if (o > -1 && o % 2 == (e < 0 ? 1 : 0))
      return [t[o + e]];
  }
  return null;
}
function Hd(r) {
  let e = r.type.prop(nM);
  return e ? e(r.node) : r;
}
function Vi(r, e, t, i = {}) {
  let o = i.maxScanDistance || Ex, n = i.brackets || Tx, s = ze(r), a = s.resolveInner(e, t);
  for (let l = a; l; l = l.parent) {
    let u = qd(l.type, t, n);
    if (u && l.from < l.to) {
      let h = Hd(l);
      if (h && (t > 0 ? e >= h.from && e < h.to : e > h.from && e <= h.to))
        return sM(r, e, t, l, h, u, n);
    }
  }
  return aM(r, e, t, s, a.type, o, n);
}
function sM(r, e, t, i, o, n, s) {
  let a = i.parent, l = { from: o.from, to: o.to }, u = 0, h = a == null ? void 0 : a.cursor();
  if (h && (t < 0 ? h.childBefore(i.from) : h.childAfter(i.to)))
    do
      if (t < 0 ? h.to <= i.from : h.from >= i.to) {
        if (u == 0 && n.indexOf(h.type.name) > -1 && h.from < h.to) {
          let c = Hd(h);
          return { start: l, end: c ? { from: c.from, to: c.to } : void 0, matched: !0 };
        } else if (qd(h.type, t, s))
          u++;
        else if (qd(h.type, -t, s)) {
          if (u == 0) {
            let c = Hd(h);
            return {
              start: l,
              end: c && c.from < c.to ? { from: c.from, to: c.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (t < 0 ? h.prevSibling() : h.nextSibling());
  return { start: l, matched: !1 };
}
function aM(r, e, t, i, o, n, s) {
  let a = t < 0 ? r.sliceDoc(e - 1, e) : r.sliceDoc(e, e + 1), l = s.indexOf(a);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let u = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, h = r.doc.iterRange(e, t > 0 ? r.doc.length : 0), c = 0;
  for (let d = 0; !h.next().done && d <= n; ) {
    let f = h.value;
    t < 0 && (d += f.length);
    let p = e + d * t;
    for (let g = t > 0 ? 0 : f.length - 1, b = t > 0 ? f.length : -1; g != b; g += t) {
      let m = s.indexOf(f[g]);
      if (!(m < 0 || i.resolveInner(p + g, 1).type != o))
        if (m % 2 == 0 == t > 0)
          c++;
        else {
          if (c == 1)
            return { start: u, end: { from: p + g, to: p + g + 1 }, matched: m >> 1 == l >> 1 };
          c--;
        }
    }
    t > 0 && (d += f.length);
  }
  return h.done ? { start: u, matched: !1 } : null;
}
const lM = /* @__PURE__ */ Object.create(null), Mb = [Et.none], Xb = [], uM = /* @__PURE__ */ Object.create(null);
for (let [r, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  uM[r] = /* @__PURE__ */ hM(lM, e);
function pc(r, e) {
  Xb.indexOf(r) > -1 || (Xb.push(r), console.warn(e));
}
function hM(r, e) {
  let t = null;
  for (let n of e.split(".")) {
    let s = r[n] || O[n];
    s ? typeof s == "function" ? t ? t = s(t) : pc(n, `Modifier ${n} used at start of tag`) : t ? pc(n, `Tag ${n} used as modifier`) : t = s : pc(n, `Unknown highlighting tag ${n}`);
  }
  if (!t)
    return 0;
  let i = e.replace(/ /g, "_"), o = Et.define({
    id: Mb.length,
    name: i,
    props: [Uo({ [i]: t })]
  });
  return Mb.push(o), o.id;
}
const cM = (r) => {
  let { state: e } = r, t = e.doc.lineAt(e.selection.main.from), i = zp(r.state, t.from);
  return i.line ? dM(r) : i.block ? pM(r) : !1;
};
function Ap(r, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let o = r(e, t);
    return o ? (i(t.update(o)), !0) : !1;
  };
}
const dM = /* @__PURE__ */ Ap(
  bM,
  0
  /* CommentOption.Toggle */
), fM = /* @__PURE__ */ Ap(
  Rx,
  0
  /* CommentOption.Toggle */
), pM = /* @__PURE__ */ Ap(
  (r, e) => Rx(r, e, mM(e)),
  0
  /* CommentOption.Toggle */
);
function zp(r, e) {
  let t = r.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const us = 50;
function gM(r, { open: e, close: t }, i, o) {
  let n = r.sliceDoc(i - us, i), s = r.sliceDoc(o, o + us), a = /\s*$/.exec(n)[0].length, l = /^\s*/.exec(s)[0].length, u = n.length - a;
  if (n.slice(u - e.length, u) == e && s.slice(l, l + t.length) == t)
    return {
      open: { pos: i - a, margin: a && 1 },
      close: { pos: o + l, margin: l && 1 }
    };
  let h, c;
  o - i <= 2 * us ? h = c = r.sliceDoc(i, o) : (h = r.sliceDoc(i, i + us), c = r.sliceDoc(o - us, o));
  let d = /^\s*/.exec(h)[0].length, f = /\s*$/.exec(c)[0].length, p = c.length - f - t.length;
  return h.slice(d, d + e.length) == e && c.slice(p, p + t.length) == t ? {
    open: {
      pos: i + d + e.length,
      margin: /\s/.test(h.charAt(d + e.length)) ? 1 : 0
    },
    close: {
      pos: o - f - t.length,
      margin: /\s/.test(c.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function mM(r) {
  let e = [];
  for (let t of r.selection.ranges) {
    let i = r.doc.lineAt(t.from), o = t.to <= i.to ? i : r.doc.lineAt(t.to), n = e.length - 1;
    n >= 0 && e[n].to > i.from ? e[n].to = o.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: o.to });
  }
  return e;
}
function Rx(r, e, t = e.selection.ranges) {
  let i = t.map((n) => zp(e, n.from).block);
  if (!i.every((n) => n))
    return null;
  let o = t.map((n, s) => gM(e, i[s], n.from, n.to));
  if (r != 2 && !o.every((n) => n))
    return { changes: e.changes(t.map((n, s) => o[s] ? [] : [{ from: n.from, insert: i[s].open + " " }, { from: n.to, insert: " " + i[s].close }])) };
  if (r != 1 && o.some((n) => n)) {
    let n = [];
    for (let s = 0, a; s < o.length; s++)
      if (a = o[s]) {
        let l = i[s], { open: u, close: h } = a;
        n.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: h.pos - h.margin, to: h.pos + l.close.length });
      }
    return { changes: n };
  }
  return null;
}
function bM(r, e, t = e.selection.ranges) {
  let i = [], o = -1;
  for (let { from: n, to: s } of t) {
    let a = i.length, l = 1e9, u = zp(e, n).line;
    if (u) {
      for (let h = n; h <= s; ) {
        let c = e.doc.lineAt(h);
        if (c.from > o && (n == s || s > c.from)) {
          o = c.from;
          let d = /^\s*/.exec(c.text)[0].length, f = d == c.length, p = c.text.slice(d, d + u.length) == u ? d : -1;
          d < c.text.length && d < l && (l = d), i.push({ line: c, comment: p, token: u, indent: d, empty: f, single: !1 });
        }
        h = c.to + 1;
      }
      if (l < 1e9)
        for (let h = a; h < i.length; h++)
          i[h].indent < i[h].line.text.length && (i[h].indent = l);
      i.length == a + 1 && (i[a].single = !0);
    }
  }
  if (r != 2 && i.some((n) => n.comment < 0 && (!n.empty || n.single))) {
    let n = [];
    for (let { line: a, token: l, indent: u, empty: h, single: c } of i)
      (c || !h) && n.push({ from: a.from + u, insert: l + " " });
    let s = e.changes(n);
    return { changes: s, selection: e.selection.map(s, 1) };
  } else if (r != 1 && i.some((n) => n.comment >= 0)) {
    let n = [];
    for (let { line: s, comment: a, token: l } of i)
      if (a >= 0) {
        let u = s.from + a, h = u + l.length;
        s.text[h - s.from] == " " && h++, n.push({ from: u, to: h });
      }
    return { changes: n };
  }
  return null;
}
const jd = /* @__PURE__ */ pr.define(), OM = /* @__PURE__ */ pr.define(), vM = /* @__PURE__ */ H.define(), _x = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, o) => e(i, o) || t(i, o)
    });
  }
});
function wM(r) {
  let e = 0;
  return r.iterChangedRanges((t, i) => e = i), e;
}
const Dx = /* @__PURE__ */ tt.define({
  create() {
    return Zi.empty;
  },
  update(r, e) {
    let t = e.state.facet(_x), i = e.annotation(jd);
    if (i) {
      let l = e.docChanged ? D.single(wM(e.changes)) : void 0, u = At.fromTransaction(e, l), h = i.side, c = h == 0 ? r.undone : r.done;
      return u ? c = Su(c, c.length, t.minDepth, u) : c = Ax(c, e.startState.selection), new Zi(h == 0 ? i.rest : c, h == 0 ? c : i.rest);
    }
    let o = e.annotation(OM);
    if ((o == "full" || o == "before") && (r = r.isolate()), e.annotation(Ge.addToHistory) === !1)
      return e.changes.empty ? r : r.addMapping(e.changes.desc);
    let n = At.fromTransaction(e), s = e.annotation(Ge.time), a = e.annotation(Ge.userEvent);
    return n ? r = r.addChanges(n, s, a, t, e) : e.selection && (r = r.addSelection(e.startState.selection, s, a, t.newGroupDelay)), (o == "full" || o == "after") && (r = r.isolate()), r;
  },
  toJSON(r) {
    return { done: r.done.map((e) => e.toJSON()), undone: r.undone.map((e) => e.toJSON()) };
  },
  fromJSON(r) {
    return new Zi(r.done.map(At.fromJSON), r.undone.map(At.fromJSON));
  }
});
function yM(r = {}) {
  return [
    Dx,
    _x.of(r),
    B.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? Mx : e.inputType == "historyRedo" ? Gd : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
function Oh(r, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let o = t.field(Dx, !1);
    if (!o)
      return !1;
    let n = o.pop(r, t, e);
    return n ? (i(n), !0) : !1;
  };
}
const Mx = /* @__PURE__ */ Oh(0, !1), Gd = /* @__PURE__ */ Oh(1, !1), xM = /* @__PURE__ */ Oh(0, !0), SM = /* @__PURE__ */ Oh(1, !0);
class At {
  constructor(e, t, i, o, n) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = o, this.selectionsAfter = n;
  }
  setSelAfter(e) {
    return new At(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((o) => o.toJSON())
    };
  }
  static fromJSON(e) {
    return new At(e.changes && He.fromJSON(e.changes), [], e.mapped && Ii.fromJSON(e.mapped), e.startSelection && D.fromJSON(e.startSelection), e.selectionsAfter.map(D.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = ai;
    for (let o of e.startState.facet(vM)) {
      let n = o(e);
      n.length && (i = i.concat(n));
    }
    return !i.length && e.changes.empty ? null : new At(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, ai);
  }
  static selection(e) {
    return new At(void 0, ai, void 0, void 0, e);
  }
}
function Su(r, e, t, i) {
  let o = e + 1 > t + 20 ? e - t - 1 : 0, n = r.slice(o, e);
  return n.push(i), n;
}
function CM(r, e) {
  let t = [], i = !1;
  return r.iterChangedRanges((o, n) => t.push(o, n)), e.iterChangedRanges((o, n, s, a) => {
    for (let l = 0; l < t.length; ) {
      let u = t[l++], h = t[l++];
      a >= u && s <= h && (i = !0);
    }
  }), i;
}
function QM(r, e) {
  return r.ranges.length == e.ranges.length && r.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function Xx(r, e) {
  return r.length ? e.length ? r.concat(e) : r : e;
}
const ai = [], PM = 200;
function Ax(r, e) {
  if (r.length) {
    let t = r[r.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - PM));
    return i.length && i[i.length - 1].eq(e) ? r : (i.push(e), Su(r, r.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [At.selection([e])];
}
function kM(r) {
  let e = r[r.length - 1], t = r.slice();
  return t[r.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function gc(r, e) {
  if (!r.length)
    return r;
  let t = r.length, i = ai;
  for (; t; ) {
    let o = EM(r[t - 1], e, i);
    if (o.changes && !o.changes.empty || o.effects.length) {
      let n = r.slice(0, t);
      return n[t - 1] = o, n;
    } else
      e = o.mapped, t--, i = o.selectionsAfter;
  }
  return i.length ? [At.selection(i)] : ai;
}
function EM(r, e, t) {
  let i = Xx(r.selectionsAfter.length ? r.selectionsAfter.map((a) => a.map(e)) : ai, t);
  if (!r.changes)
    return At.selection(i);
  let o = r.changes.map(e), n = e.mapDesc(r.changes, !0), s = r.mapped ? r.mapped.composeDesc(n) : n;
  return new At(o, le.mapEffects(r.effects, e), s, r.startSelection.map(n), i);
}
const TM = /^(input\.type|delete)($|\.)/;
class Zi {
  constructor(e, t, i = 0, o = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = o;
  }
  isolate() {
    return this.prevTime ? new Zi(this.done, this.undone) : this;
  }
  addChanges(e, t, i, o, n) {
    let s = this.done, a = s[s.length - 1];
    return a && a.changes && !a.changes.empty && e.changes && (!i || TM.test(i)) && (!a.selectionsAfter.length && t - this.prevTime < o.newGroupDelay && o.joinToEvent(n, CM(a.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? s = Su(s, s.length - 1, o.minDepth, new At(e.changes.compose(a.changes), Xx(e.effects, a.effects), a.mapped, a.startSelection, ai)) : s = Su(s, s.length, o.minDepth, e), new Zi(s, ai, t, i);
  }
  addSelection(e, t, i, o) {
    let n = this.done.length ? this.done[this.done.length - 1].selectionsAfter : ai;
    return n.length > 0 && t - this.prevTime < o && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && QM(n[n.length - 1], e) ? this : new Zi(Ax(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new Zi(gc(this.done, e), gc(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let o = e == 0 ? this.done : this.undone;
    if (o.length == 0)
      return null;
    let n = o[o.length - 1];
    if (i && n.selectionsAfter.length)
      return t.update({
        selection: n.selectionsAfter[n.selectionsAfter.length - 1],
        annotations: jd.of({ side: e, rest: kM(o) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (n.changes) {
      let s = o.length == 1 ? ai : o.slice(0, o.length - 1);
      return n.mapped && (s = gc(s, n.mapped)), t.update({
        changes: n.changes,
        selection: n.startSelection,
        effects: n.effects,
        annotations: jd.of({ side: e, rest: s }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
Zi.empty = /* @__PURE__ */ new Zi(ai, ai);
const $M = [
  { key: "Mod-z", run: Mx, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: Gd, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: Gd, preventDefault: !0 },
  { key: "Mod-u", run: xM, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: SM, preventDefault: !0 }
];
function Hn(r, e) {
  return D.create(r.ranges.map(e), r.mainIndex);
}
function ji(r, e) {
  return r.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function Si({ state: r, dispatch: e }, t) {
  let i = Hn(r.selection, t);
  return i.eq(r.selection) ? !1 : (e(ji(r, i)), !0);
}
function vh(r, e) {
  return D.cursor(e ? r.to : r.from);
}
function zx(r, e) {
  return Si(r, (t) => t.empty ? r.moveByChar(t, e) : vh(t, e));
}
function wt(r) {
  return r.textDirectionAt(r.state.selection.main.head) == Me.LTR;
}
const Nx = (r) => zx(r, !wt(r)), Vx = (r) => zx(r, wt(r));
function Zx(r, e) {
  return Si(r, (t) => t.empty ? r.moveByGroup(t, e) : vh(t, e));
}
const RM = (r) => Zx(r, !wt(r)), _M = (r) => Zx(r, wt(r));
function DM(r, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(r.sliceDoc(e.from, e.to))) || e.firstChild;
}
function wh(r, e, t) {
  let i = ze(r).resolveInner(e.head), o = t ? he.closedBy : he.openedBy;
  for (let l = e.head; ; ) {
    let u = t ? i.childAfter(l) : i.childBefore(l);
    if (!u)
      break;
    DM(r, u, o) ? i = u : l = t ? u.to : u.from;
  }
  let n = i.type.prop(o), s, a;
  return n && (s = t ? Vi(r, i.from, 1) : Vi(r, i.to, -1)) && s.matched ? a = t ? s.end.to : s.end.from : a = t ? i.to : i.from, D.cursor(a, t ? -1 : 1);
}
const MM = (r) => Si(r, (e) => wh(r.state, e, !wt(r))), XM = (r) => Si(r, (e) => wh(r.state, e, wt(r)));
function Lx(r, e) {
  return Si(r, (t) => {
    if (!t.empty)
      return vh(t, e);
    let i = r.moveVertically(t, e);
    return i.head != t.head ? i : r.moveToLineBoundary(t, e);
  });
}
const Wx = (r) => Lx(r, !1), Ix = (r) => Lx(r, !0);
function Ux(r) {
  let e = r.scrollDOM.clientHeight < r.scrollDOM.scrollHeight - 2, t = 0, i = 0, o;
  if (e) {
    for (let n of r.state.facet(B.scrollMargins)) {
      let s = n(r);
      s != null && s.top && (t = Math.max(s == null ? void 0 : s.top, t)), s != null && s.bottom && (i = Math.max(s == null ? void 0 : s.bottom, i));
    }
    o = r.scrollDOM.clientHeight - t - i;
  } else
    o = (r.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(r.defaultLineHeight, o - 5)
  };
}
function Yx(r, e) {
  let t = Ux(r), { state: i } = r, o = Hn(i.selection, (s) => s.empty ? r.moveVertically(s, e, t.height) : vh(s, e));
  if (o.eq(i.selection))
    return !1;
  let n;
  if (t.selfScroll) {
    let s = r.coordsAtPos(i.selection.main.head), a = r.scrollDOM.getBoundingClientRect(), l = a.top + t.marginTop, u = a.bottom - t.marginBottom;
    s && s.top > l && s.bottom < u && (n = B.scrollIntoView(o.main.head, { y: "start", yMargin: s.top - l }));
  }
  return r.dispatch(ji(i, o), { effects: n }), !0;
}
const Ab = (r) => Yx(r, !1), Kd = (r) => Yx(r, !0);
function oo(r, e, t) {
  let i = r.lineBlockAt(e.head), o = r.moveToLineBoundary(e, t);
  if (o.head == e.head && o.head != (t ? i.to : i.from) && (o = r.moveToLineBoundary(e, t, !1)), !t && o.head == i.from && i.length) {
    let n = /^\s*/.exec(r.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    n && e.head != i.from + n && (o = D.cursor(i.from + n));
  }
  return o;
}
const AM = (r) => Si(r, (e) => oo(r, e, !0)), zM = (r) => Si(r, (e) => oo(r, e, !1)), NM = (r) => Si(r, (e) => oo(r, e, !wt(r))), VM = (r) => Si(r, (e) => oo(r, e, wt(r))), ZM = (r) => Si(r, (e) => D.cursor(r.lineBlockAt(e.head).from, 1)), LM = (r) => Si(r, (e) => D.cursor(r.lineBlockAt(e.head).to, -1));
function WM(r, e, t) {
  let i = !1, o = Hn(r.selection, (n) => {
    let s = Vi(r, n.head, -1) || Vi(r, n.head, 1) || n.head > 0 && Vi(r, n.head - 1, 1) || n.head < r.doc.length && Vi(r, n.head + 1, -1);
    if (!s || !s.end)
      return n;
    i = !0;
    let a = s.start.from == n.head ? s.end.to : s.end.from;
    return t ? D.range(n.anchor, a) : D.cursor(a);
  });
  return i ? (e(ji(r, o)), !0) : !1;
}
const IM = ({ state: r, dispatch: e }) => WM(r, e, !1);
function ci(r, e) {
  let t = Hn(r.state.selection, (i) => {
    let o = e(i);
    return D.range(i.anchor, o.head, o.goalColumn, o.bidiLevel || void 0);
  });
  return t.eq(r.state.selection) ? !1 : (r.dispatch(ji(r.state, t)), !0);
}
function Fx(r, e) {
  return ci(r, (t) => r.moveByChar(t, e));
}
const Bx = (r) => Fx(r, !wt(r)), qx = (r) => Fx(r, wt(r));
function Hx(r, e) {
  return ci(r, (t) => r.moveByGroup(t, e));
}
const UM = (r) => Hx(r, !wt(r)), YM = (r) => Hx(r, wt(r)), FM = (r) => ci(r, (e) => wh(r.state, e, !wt(r))), BM = (r) => ci(r, (e) => wh(r.state, e, wt(r)));
function jx(r, e) {
  return ci(r, (t) => r.moveVertically(t, e));
}
const Gx = (r) => jx(r, !1), Kx = (r) => jx(r, !0);
function Jx(r, e) {
  return ci(r, (t) => r.moveVertically(t, e, Ux(r).height));
}
const zb = (r) => Jx(r, !1), Nb = (r) => Jx(r, !0), qM = (r) => ci(r, (e) => oo(r, e, !0)), HM = (r) => ci(r, (e) => oo(r, e, !1)), jM = (r) => ci(r, (e) => oo(r, e, !wt(r))), GM = (r) => ci(r, (e) => oo(r, e, wt(r))), KM = (r) => ci(r, (e) => D.cursor(r.lineBlockAt(e.head).from)), JM = (r) => ci(r, (e) => D.cursor(r.lineBlockAt(e.head).to)), Vb = ({ state: r, dispatch: e }) => (e(ji(r, { anchor: 0 })), !0), Zb = ({ state: r, dispatch: e }) => (e(ji(r, { anchor: r.doc.length })), !0), Lb = ({ state: r, dispatch: e }) => (e(ji(r, { anchor: r.selection.main.anchor, head: 0 })), !0), Wb = ({ state: r, dispatch: e }) => (e(ji(r, { anchor: r.selection.main.anchor, head: r.doc.length })), !0), e2 = ({ state: r, dispatch: e }) => (e(r.update({ selection: { anchor: 0, head: r.doc.length }, userEvent: "select" })), !0), t2 = ({ state: r, dispatch: e }) => {
  let t = xh(r).map(({ from: i, to: o }) => D.range(i, Math.min(o + 1, r.doc.length)));
  return e(r.update({ selection: D.create(t), userEvent: "select" })), !0;
}, i2 = ({ state: r, dispatch: e }) => {
  let t = Hn(r.selection, (i) => {
    var o;
    let n = ze(r).resolveInner(i.head, 1);
    for (; !(n.from < i.from && n.to >= i.to || n.to > i.to && n.from <= i.from || !(!((o = n.parent) === null || o === void 0) && o.parent)); )
      n = n.parent;
    return D.range(n.to, n.from);
  });
  return e(ji(r, t)), !0;
}, r2 = ({ state: r, dispatch: e }) => {
  let t = r.selection, i = null;
  return t.ranges.length > 1 ? i = D.create([t.main]) : t.main.empty || (i = D.create([D.cursor(t.main.head)])), i ? (e(ji(r, i)), !0) : !1;
};
function yh(r, e) {
  if (r.state.readOnly)
    return !1;
  let t = "delete.selection", { state: i } = r, o = i.changeByRange((n) => {
    let { from: s, to: a } = n;
    if (s == a) {
      let l = e(s);
      l < s ? (t = "delete.backward", l = fl(r, l, !1)) : l > s && (t = "delete.forward", l = fl(r, l, !0)), s = Math.min(s, l), a = Math.max(a, l);
    } else
      s = fl(r, s, !1), a = fl(r, a, !0);
    return s == a ? { range: n } : { changes: { from: s, to: a }, range: D.cursor(s) };
  });
  return o.changes.empty ? !1 : (r.dispatch(i.update(o, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? B.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function fl(r, e, t) {
  if (r instanceof B)
    for (let i of r.state.facet(B.atomicRanges).map((o) => o(r)))
      i.between(e, e, (o, n) => {
        o < e && n > e && (e = t ? n : o);
      });
  return e;
}
const e1 = (r, e) => yh(r, (t) => {
  let { state: i } = r, o = i.doc.lineAt(t), n, s;
  if (!e && t > o.from && t < o.from + 200 && !/[^ \t]/.test(n = o.text.slice(0, t - o.from))) {
    if (n[n.length - 1] == "	")
      return t - 1;
    let a = Ca(n, i.tabSize), l = a % wu(i) || wu(i);
    for (let u = 0; u < l && n[n.length - 1 - u] == " "; u++)
      t--;
    s = t;
  } else
    s = Pt(o.text, t - o.from, e, e) + o.from, s == t && o.number != (e ? i.doc.lines : 1) && (s += e ? 1 : -1);
  return s;
}), Jd = (r) => e1(r, !1), t1 = (r) => e1(r, !0), i1 = (r, e) => yh(r, (t) => {
  let i = t, { state: o } = r, n = o.doc.lineAt(i), s = o.charCategorizer(i);
  for (let a = null; ; ) {
    if (i == (e ? n.to : n.from)) {
      i == t && n.number != (e ? o.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let l = Pt(n.text, i - n.from, e) + n.from, u = n.text.slice(Math.min(i, l) - n.from, Math.max(i, l) - n.from), h = s(u);
    if (a != null && h != a)
      break;
    (u != " " || i != t) && (a = h), i = l;
  }
  return i;
}), r1 = (r) => i1(r, !1), o2 = (r) => i1(r, !0), o1 = (r) => yh(r, (e) => {
  let t = r.lineBlockAt(e).to;
  return e < t ? t : Math.min(r.state.doc.length, e + 1);
}), n2 = (r) => yh(r, (e) => {
  let t = r.lineBlockAt(e).from;
  return e > t ? t : Math.max(0, e - 1);
}), s2 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: ve.of(["", ""]) },
    range: D.cursor(i.from)
  }));
  return e(r.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, a2 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == r.doc.length)
      return { range: i };
    let o = i.from, n = r.doc.lineAt(o), s = o == n.from ? o - 1 : Pt(n.text, o - n.from, !1) + n.from, a = o == n.to ? o + 1 : Pt(n.text, o - n.from, !0) + n.from;
    return {
      changes: { from: s, to: a, insert: r.doc.slice(o, a).append(r.doc.slice(s, o)) },
      range: D.cursor(a)
    };
  });
  return t.changes.empty ? !1 : (e(r.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function xh(r) {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let o = r.doc.lineAt(i.from), n = r.doc.lineAt(i.to);
    if (!i.empty && i.to == n.from && (n = r.doc.lineAt(i.to - 1)), t >= o.number) {
      let s = e[e.length - 1];
      s.to = n.to, s.ranges.push(i);
    } else
      e.push({ from: o.from, to: n.to, ranges: [i] });
    t = n.number + 1;
  }
  return e;
}
function n1(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [], o = [];
  for (let n of xh(r)) {
    if (t ? n.to == r.doc.length : n.from == 0)
      continue;
    let s = r.doc.lineAt(t ? n.to + 1 : n.from - 1), a = s.length + 1;
    if (t) {
      i.push({ from: n.to, to: s.to }, { from: n.from, insert: s.text + r.lineBreak });
      for (let l of n.ranges)
        o.push(D.range(Math.min(r.doc.length, l.anchor + a), Math.min(r.doc.length, l.head + a)));
    } else {
      i.push({ from: s.from, to: n.from }, { from: n.to, insert: r.lineBreak + s.text });
      for (let l of n.ranges)
        o.push(D.range(l.anchor - a, l.head - a));
    }
  }
  return i.length ? (e(r.update({
    changes: i,
    scrollIntoView: !0,
    selection: D.create(o, r.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const l2 = ({ state: r, dispatch: e }) => n1(r, e, !1), u2 = ({ state: r, dispatch: e }) => n1(r, e, !0);
function s1(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [];
  for (let o of xh(r))
    t ? i.push({ from: o.from, insert: r.doc.slice(o.from, o.to) + r.lineBreak }) : i.push({ from: o.to, insert: r.lineBreak + r.doc.slice(o.from, o.to) });
  return e(r.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const h2 = ({ state: r, dispatch: e }) => s1(r, e, !1), c2 = ({ state: r, dispatch: e }) => s1(r, e, !0), d2 = (r) => {
  if (r.state.readOnly)
    return !1;
  let { state: e } = r, t = e.changes(xh(e).map(({ from: o, to: n }) => (o > 0 ? o-- : n < e.doc.length && n++, { from: o, to: n }))), i = Hn(e.selection, (o) => r.moveVertically(o, !0)).map(t);
  return r.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
};
function f2(r, e) {
  if (/\(\)|\[\]|\{\}/.test(r.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = ze(r).resolveInner(e), i = t.childBefore(e), o = t.childAfter(e), n;
  return i && o && i.to <= e && o.from >= e && (n = i.type.prop(he.closedBy)) && n.indexOf(o.name) > -1 && r.doc.lineAt(i.to).from == r.doc.lineAt(o.from).from ? { from: i.to, to: o.from } : null;
}
const p2 = /* @__PURE__ */ a1(!1), g2 = /* @__PURE__ */ a1(!0);
function a1(r) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((o) => {
      let { from: n, to: s } = o, a = e.doc.lineAt(n), l = !r && n == s && f2(e, n);
      r && (n = s = (s <= a.to ? a : e.doc.lineAt(s)).to);
      let u = new gh(e, { simulateBreak: n, simulateDoubleBreak: !!l }), h = Mp(u, n);
      for (h == null && (h = /^\s*/.exec(e.doc.lineAt(n).text)[0].length); s < a.to && /\s/.test(a.text[s - a.from]); )
        s++;
      l ? { from: n, to: s } = l : n > a.from && n < a.from + 100 && !/\S/.test(a.text.slice(0, n)) && (n = a.from);
      let c = ["", ua(e, h)];
      return l && c.push(ua(e, u.lineIndent(a.from, -1))), {
        changes: { from: n, to: s, insert: ve.of(c) },
        range: D.cursor(n + 1 + c[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function Np(r, e) {
  let t = -1;
  return r.changeByRange((i) => {
    let o = [];
    for (let s = i.from; s <= i.to; ) {
      let a = r.doc.lineAt(s);
      a.number > t && (i.empty || i.to > a.from) && (e(a, o, i), t = a.number), s = a.to + 1;
    }
    let n = r.changes(o);
    return {
      changes: o,
      range: D.range(n.mapPos(i.anchor, 1), n.mapPos(i.head, 1))
    };
  });
}
const m2 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new gh(r, { overrideIndentation: (n) => {
    let s = t[n];
    return s ?? -1;
  } }), o = Np(r, (n, s, a) => {
    let l = Mp(i, n.from);
    if (l == null)
      return;
    /\S/.test(n.text) || (l = 0);
    let u = /^\s*/.exec(n.text)[0], h = ua(r, l);
    (u != h || a.from < n.from + u.length) && (t[n.from] = l, s.push({ from: n.from, to: n.from + u.length, insert: h }));
  });
  return o.changes.empty || e(r.update(o, { userEvent: "indent" })), !0;
}, b2 = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(Np(r, (t, i) => {
  i.push({ from: t.from, insert: r.facet(ph) });
}), { userEvent: "input.indent" })), !0), O2 = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(Np(r, (t, i) => {
  let o = /^\s*/.exec(t.text)[0];
  if (!o)
    return;
  let n = Ca(o, r.tabSize), s = 0, a = ua(r, Math.max(0, n - wu(r)));
  for (; s < o.length && s < a.length && o.charCodeAt(s) == a.charCodeAt(s); )
    s++;
  i.push({ from: t.from + s, to: t.from + o.length, insert: a.slice(s) });
}), { userEvent: "delete.dedent" })), !0), v2 = [
  { key: "Ctrl-b", run: Nx, shift: Bx, preventDefault: !0 },
  { key: "Ctrl-f", run: Vx, shift: qx },
  { key: "Ctrl-p", run: Wx, shift: Gx },
  { key: "Ctrl-n", run: Ix, shift: Kx },
  { key: "Ctrl-a", run: ZM, shift: KM },
  { key: "Ctrl-e", run: LM, shift: JM },
  { key: "Ctrl-d", run: t1 },
  { key: "Ctrl-h", run: Jd },
  { key: "Ctrl-k", run: o1 },
  { key: "Ctrl-Alt-h", run: r1 },
  { key: "Ctrl-o", run: s2 },
  { key: "Ctrl-t", run: a2 },
  { key: "Ctrl-v", run: Kd }
], w2 = /* @__PURE__ */ [
  { key: "ArrowLeft", run: Nx, shift: Bx, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: RM, shift: UM, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: NM, shift: jM, preventDefault: !0 },
  { key: "ArrowRight", run: Vx, shift: qx, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: _M, shift: YM, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: VM, shift: GM, preventDefault: !0 },
  { key: "ArrowUp", run: Wx, shift: Gx, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: Vb, shift: Lb },
  { mac: "Ctrl-ArrowUp", run: Ab, shift: zb },
  { key: "ArrowDown", run: Ix, shift: Kx, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: Zb, shift: Wb },
  { mac: "Ctrl-ArrowDown", run: Kd, shift: Nb },
  { key: "PageUp", run: Ab, shift: zb },
  { key: "PageDown", run: Kd, shift: Nb },
  { key: "Home", run: zM, shift: HM, preventDefault: !0 },
  { key: "Mod-Home", run: Vb, shift: Lb },
  { key: "End", run: AM, shift: qM, preventDefault: !0 },
  { key: "Mod-End", run: Zb, shift: Wb },
  { key: "Enter", run: p2 },
  { key: "Mod-a", run: e2 },
  { key: "Backspace", run: Jd, shift: Jd },
  { key: "Delete", run: t1 },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: r1 },
  { key: "Mod-Delete", mac: "Alt-Delete", run: o2 },
  { mac: "Mod-Backspace", run: n2 },
  { mac: "Mod-Delete", run: o1 }
].concat(/* @__PURE__ */ v2.map((r) => ({ mac: r.key, run: r.run, shift: r.shift }))), l1 = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: MM, shift: FM },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: XM, shift: BM },
  { key: "Alt-ArrowUp", run: l2 },
  { key: "Shift-Alt-ArrowUp", run: h2 },
  { key: "Alt-ArrowDown", run: u2 },
  { key: "Shift-Alt-ArrowDown", run: c2 },
  { key: "Escape", run: r2 },
  { key: "Mod-Enter", run: g2 },
  { key: "Alt-l", mac: "Ctrl-l", run: t2 },
  { key: "Mod-i", run: i2, preventDefault: !0 },
  { key: "Mod-[", run: O2 },
  { key: "Mod-]", run: b2 },
  { key: "Mod-Alt-\\", run: m2 },
  { key: "Shift-Mod-k", run: d2 },
  { key: "Shift-Mod-\\", run: IM },
  { key: "Mod-/", run: cM },
  { key: "Alt-A", run: fM }
].concat(w2);
function Pe() {
  var r = arguments[0];
  typeof r == "string" && (r = document.createElement(r));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var o = t[i];
        typeof o == "string" ? r.setAttribute(i, o) : o != null && (r[i] = o);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    u1(r, arguments[e]);
  return r;
}
function u1(r, e) {
  if (typeof e == "string")
    r.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      r.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        u1(r, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const Ib = typeof String.prototype.normalize == "function" ? (r) => r.normalize("NFKD") : (r) => r;
class zn {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, o = e.length, n, s) {
    this.test = s, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, o), this.bufferStart = i, this.normalize = n ? (a) => n(Ib(a)) : Ib, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return nt(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = bp(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += ri(e);
      let o = this.normalize(t);
      for (let n = 0, s = i; ; n++) {
        let a = o.charCodeAt(n), l = this.match(a, s);
        if (l)
          return this.value = l, this;
        if (n == o.length - 1)
          break;
        s == i && n < t.length && t.charCodeAt(n) == a && s++;
      }
    }
  }
  match(e, t) {
    let i = null;
    for (let o = 0; o < this.matches.length; o += 2) {
      let n = this.matches[o], s = !1;
      this.query.charCodeAt(n) == e && (n == this.query.length - 1 ? i = { from: this.matches[o + 1], to: t + 1 } : (this.matches[o]++, s = !0)), s || (this.matches.splice(o, 2), o -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: t + 1 } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferPos) && (i = null), i;
  }
}
typeof Symbol < "u" && (zn.prototype[Symbol.iterator] = function() {
  return this;
});
const h1 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, Vp = "gm" + (/x/.unicode == null ? "" : "u");
class c1 {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, o = 0, n = e.length) {
    if (this.text = e, this.to = n, this.curLine = "", this.done = !1, this.value = h1, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new d1(e, t, i, o, n);
    this.re = new RegExp(t, Vp + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let s = e.lineAt(o);
    this.curLineStart = s.from, this.matchPos = Cu(e, o), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, o = i + t[0].length;
        if (this.matchPos = Cu(this.text, o + (i == o ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < o || i > this.value.to) && (!this.test || this.test(i, o, t)))
          return this.value = { from: i, to: o, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const mc = /* @__PURE__ */ new WeakMap();
class wn {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let o = mc.get(e);
    if (!o || o.from >= i || o.to <= t) {
      let a = new wn(t, e.sliceString(t, i));
      return mc.set(e, a), a;
    }
    if (o.from == t && o.to == i)
      return o;
    let { text: n, from: s } = o;
    return s > t && (n = e.sliceString(t, s) + n, s = t), o.to < i && (n += e.sliceString(o.to, i)), mc.set(e, new wn(s, n)), new wn(t, n.slice(t - s, i - s));
  }
}
class d1 {
  constructor(e, t, i, o, n) {
    this.text = e, this.to = n, this.done = !1, this.value = h1, this.matchPos = Cu(e, o), this.re = new RegExp(t, Vp + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = wn.get(e, o, this.chunkEnd(
      o + 5e3
      /* Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, o = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, o, t)))
          return this.value = { from: i, to: o, match: t }, this.matchPos = Cu(this.text, o + (i == o ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = wn.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (c1.prototype[Symbol.iterator] = d1.prototype[Symbol.iterator] = function() {
  return this;
});
function y2(r) {
  try {
    return new RegExp(r, Vp), !0;
  } catch {
    return !1;
  }
}
function Cu(r, e) {
  if (e >= r.length)
    return e;
  let t = r.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function ef(r) {
  let e = Pe("input", { class: "cm-textfield", name: "line" }), t = Pe("form", {
    class: "cm-gotoLine",
    onkeydown: (o) => {
      o.keyCode == 27 ? (o.preventDefault(), r.dispatch({ effects: Qu.of(!1) }), r.focus()) : o.keyCode == 13 && (o.preventDefault(), i());
    },
    onsubmit: (o) => {
      o.preventDefault(), i();
    }
  }, Pe("label", r.state.phrase("Go to line"), ": ", e), " ", Pe("button", { class: "cm-button", type: "submit" }, r.state.phrase("go")));
  function i() {
    let o = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!o)
      return;
    let { state: n } = r, s = n.doc.lineAt(n.selection.main.head), [, a, l, u, h] = o, c = u ? +u.slice(1) : 0, d = l ? +l : s.number;
    if (l && h) {
      let p = d / 100;
      a && (p = p * (a == "-" ? -1 : 1) + s.number / n.doc.lines), d = Math.round(n.doc.lines * p);
    } else
      l && a && (d = d * (a == "-" ? -1 : 1) + s.number);
    let f = n.doc.line(Math.max(1, Math.min(n.doc.lines, d)));
    r.dispatch({
      effects: Qu.of(!1),
      selection: D.cursor(f.from + Math.max(0, Math.min(c, f.length))),
      scrollIntoView: !0
    }), r.focus();
  }
  return { dom: t };
}
const Qu = /* @__PURE__ */ le.define(), Ub = /* @__PURE__ */ tt.define({
  create() {
    return !0;
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(Qu) && (r = t.value);
    return r;
  },
  provide: (r) => aa.from(r, (e) => e ? ef : null)
}), x2 = (r) => {
  let e = sa(r, ef);
  if (!e) {
    let t = [Qu.of(!0)];
    r.state.field(Ub, !1) == null && t.push(le.appendConfig.of([Ub, S2])), r.dispatch({ effects: t }), e = sa(r, ef);
  }
  return e && e.dom.querySelector("input").focus(), !0;
}, S2 = /* @__PURE__ */ B.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), C2 = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, f1 = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, C2, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Q2(r) {
  let e = [$2, T2];
  return r && e.push(f1.of(r)), e;
}
const P2 = /* @__PURE__ */ J.mark({ class: "cm-selectionMatch" }), k2 = /* @__PURE__ */ J.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function Yb(r, e, t, i) {
  return (t == 0 || r(e.sliceDoc(t - 1, t)) != Re.Word) && (i == e.doc.length || r(e.sliceDoc(i, i + 1)) != Re.Word);
}
function E2(r, e, t, i) {
  return r(e.sliceDoc(t, t + 1)) == Re.Word && r(e.sliceDoc(i - 1, i)) == Re.Word;
}
const T2 = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.selectionSet || r.docChanged || r.viewportChanged) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = r.state.facet(f1), { state: t } = r, i = t.selection;
    if (i.ranges.length > 1)
      return J.none;
    let o = i.main, n, s = null;
    if (o.empty) {
      if (!e.highlightWordAroundCursor)
        return J.none;
      let l = t.wordAt(o.head);
      if (!l)
        return J.none;
      s = t.charCategorizer(o.head), n = t.sliceDoc(l.from, l.to);
    } else {
      let l = o.to - o.from;
      if (l < e.minSelectionLength || l > 200)
        return J.none;
      if (e.wholeWords) {
        if (n = t.sliceDoc(o.from, o.to), s = t.charCategorizer(o.head), !(Yb(s, t, o.from, o.to) && E2(s, t, o.from, o.to)))
          return J.none;
      } else if (n = t.sliceDoc(o.from, o.to).trim(), !n)
        return J.none;
    }
    let a = [];
    for (let l of r.visibleRanges) {
      let u = new zn(t.doc, n, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: h, to: c } = u.value;
        if ((!s || Yb(s, t, h, c)) && (o.empty && h <= o.from && c >= o.to ? a.push(k2.range(h, c)) : (h >= o.to || c <= o.from) && a.push(P2.range(h, c)), a.length > e.maxMatches))
          return J.none;
      }
    }
    return J.set(a);
  }
}, {
  decorations: (r) => r.decorations
}), $2 = /* @__PURE__ */ B.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), R2 = ({ state: r, dispatch: e }) => {
  let { selection: t } = r, i = D.create(t.ranges.map((o) => r.wordAt(o.head) || D.cursor(o.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(r.update({ selection: i })), !0);
};
function _2(r, e) {
  let { main: t, ranges: i } = r.selection, o = r.wordAt(t.head), n = o && o.from == t.from && o.to == t.to;
  for (let s = !1, a = new zn(r.doc, e, i[i.length - 1].to); ; )
    if (a.next(), a.done) {
      if (s)
        return null;
      a = new zn(r.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), s = !0;
    } else {
      if (s && i.some((l) => l.from == a.value.from))
        continue;
      if (n) {
        let l = r.wordAt(a.value.from);
        if (!l || l.from != a.value.from || l.to != a.value.to)
          continue;
      }
      return a.value;
    }
}
const D2 = ({ state: r, dispatch: e }) => {
  let { ranges: t } = r.selection;
  if (t.some((n) => n.from === n.to))
    return R2({ state: r, dispatch: e });
  let i = r.sliceDoc(t[0].from, t[0].to);
  if (r.selection.ranges.some((n) => r.sliceDoc(n.from, n.to) != i))
    return !1;
  let o = _2(r, i);
  return o ? (e(r.update({
    selection: r.selection.addRange(D.range(o.from, o.to), !1),
    effects: B.scrollIntoView(o.to)
  })), !0) : !1;
}, jn = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new Y2(e),
      scrollToMatch: (e) => B.scrollIntoView(e)
    });
  }
});
class p1 {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || y2(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new z2(this) : new X2(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, i) {
    let o = e.doc ? e : be.create({ doc: e });
    return i == null && (i = o.doc.length), this.regexp ? rn(this, o, t, i) : tn(this, o, t, i);
  }
}
class g1 {
  constructor(e) {
    this.spec = e;
  }
}
function tn(r, e, t, i) {
  return new zn(e.doc, r.unquoted, t, i, r.caseSensitive ? void 0 : (o) => o.toLowerCase(), r.wholeWord ? M2(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function M2(r, e) {
  return (t, i, o, n) => ((n > t || n + o.length < i) && (n = Math.max(0, t - 2), o = r.sliceString(n, Math.min(r.length, i + 2))), (e(Pu(o, t - n)) != Re.Word || e(ku(o, t - n)) != Re.Word) && (e(ku(o, i - n)) != Re.Word || e(Pu(o, i - n)) != Re.Word));
}
class X2 extends g1 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let o = tn(this.spec, e, i, e.doc.length).nextOverlapping();
    return o.done && (o = tn(this.spec, e, 0, t).nextOverlapping()), o.done ? null : o.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let o = i; ; ) {
      let n = Math.max(t, o - 1e4 - this.spec.unquoted.length), s = tn(this.spec, e, n, o), a = null;
      for (; !s.nextOverlapping().done; )
        a = s.value;
      if (a)
        return a;
      if (n == t)
        return null;
      o -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = tn(this.spec, e, 0, e.doc.length), o = [];
    for (; !i.next().done; ) {
      if (o.length >= t)
        return null;
      o.push(i.value);
    }
    return o;
  }
  highlight(e, t, i, o) {
    let n = tn(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !n.next().done; )
      o(n.value.from, n.value.to);
  }
}
function rn(r, e, t, i) {
  return new c1(e.doc, r.search, {
    ignoreCase: !r.caseSensitive,
    test: r.wholeWord ? A2(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function Pu(r, e) {
  return r.slice(Pt(r, e, !1), e);
}
function ku(r, e) {
  return r.slice(e, Pt(r, e));
}
function A2(r) {
  return (e, t, i) => !i[0].length || (r(Pu(i.input, i.index)) != Re.Word || r(ku(i.input, i.index)) != Re.Word) && (r(ku(i.input, i.index + i[0].length)) != Re.Word || r(Pu(i.input, i.index + i[0].length)) != Re.Word);
}
class z2 extends g1 {
  nextMatch(e, t, i) {
    let o = rn(this.spec, e, i, e.doc.length).next();
    return o.done && (o = rn(this.spec, e, 0, t).next()), o.done ? null : o.value;
  }
  prevMatchInRange(e, t, i) {
    for (let o = 1; ; o++) {
      let n = Math.max(
        t,
        i - o * 1e4
        /* ChunkSize */
      ), s = rn(this.spec, e, n, i), a = null;
      for (; !s.next().done; )
        a = s.value;
      if (a && (n == t || a.from > n + 10))
        return a;
      if (n == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t));
  }
  matchAll(e, t) {
    let i = rn(this.spec, e, 0, e.doc.length), o = [];
    for (; !i.next().done; ) {
      if (o.length >= t)
        return null;
      o.push(i.value);
    }
    return o;
  }
  highlight(e, t, i, o) {
    let n = rn(this.spec, e, Math.max(
      0,
      t - 250
      /* HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !n.next().done; )
      o(n.value.from, n.value.to);
  }
}
const ha = /* @__PURE__ */ le.define(), Zp = /* @__PURE__ */ le.define(), Nr = /* @__PURE__ */ tt.define({
  create(r) {
    return new bc(tf(r).create(), null);
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(ha) ? r = new bc(t.value.create(), r.panel) : t.is(Zp) && (r = new bc(r.query, t.value ? Lp : null));
    return r;
  },
  provide: (r) => aa.from(r, (e) => e.panel)
});
class bc {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const N2 = /* @__PURE__ */ J.mark({ class: "cm-searchMatch" }), V2 = /* @__PURE__ */ J.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Z2 = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.view = r, this.decorations = this.highlight(r.state.field(Nr));
  }
  update(r) {
    let e = r.state.field(Nr);
    (e != r.startState.field(Nr) || r.docChanged || r.selectionSet || r.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: r, panel: e }) {
    if (!e || !r.spec.valid)
      return J.none;
    let { view: t } = this, i = new Hr();
    for (let o = 0, n = t.visibleRanges, s = n.length; o < s; o++) {
      let { from: a, to: l } = n[o];
      for (; o < s - 1 && l > n[o + 1].from - 2 * 250; )
        l = n[++o].to;
      r.highlight(t.state, a, l, (u, h) => {
        let c = t.state.selection.ranges.some((d) => d.from == u && d.to == h);
        i.add(u, h, c ? V2 : N2);
      });
    }
    return i.finish();
  }
}, {
  decorations: (r) => r.decorations
});
function $a(r) {
  return (e) => {
    let t = e.state.field(Nr, !1);
    return t && t.query.spec.valid ? r(e, t) : O1(e);
  };
}
const Eu = /* @__PURE__ */ $a((r, { query: e }) => {
  let { to: t } = r.state.selection.main, i = e.nextMatch(r.state, t, t);
  if (!i)
    return !1;
  let o = D.single(i.from, i.to), n = r.state.facet(jn);
  return r.dispatch({
    selection: o,
    effects: [Wp(r, i), n.scrollToMatch(o.main, r)],
    userEvent: "select.search"
  }), b1(r), !0;
}), Tu = /* @__PURE__ */ $a((r, { query: e }) => {
  let { state: t } = r, { from: i } = t.selection.main, o = e.prevMatch(t, i, i);
  if (!o)
    return !1;
  let n = D.single(o.from, o.to), s = r.state.facet(jn);
  return r.dispatch({
    selection: n,
    effects: [Wp(r, o), s.scrollToMatch(n.main, r)],
    userEvent: "select.search"
  }), b1(r), !0;
}), L2 = /* @__PURE__ */ $a((r, { query: e }) => {
  let t = e.matchAll(r.state, 1e3);
  return !t || !t.length ? !1 : (r.dispatch({
    selection: D.create(t.map((i) => D.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), W2 = ({ state: r, dispatch: e }) => {
  let t = r.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: o } = t.main, n = [], s = 0;
  for (let a = new zn(r.doc, r.sliceDoc(i, o)); !a.next().done; ) {
    if (n.length > 1e3)
      return !1;
    a.value.from == i && (s = n.length), n.push(D.range(a.value.from, a.value.to));
  }
  return e(r.update({
    selection: D.create(n, s),
    userEvent: "select.search.matches"
  })), !0;
}, Fb = /* @__PURE__ */ $a((r, { query: e }) => {
  let { state: t } = r, { from: i, to: o } = t.selection.main;
  if (t.readOnly)
    return !1;
  let n = e.nextMatch(t, i, i);
  if (!n)
    return !1;
  let s = [], a, l, u = [];
  if (n.from == i && n.to == o && (l = t.toText(e.getReplacement(n)), s.push({ from: n.from, to: n.to, insert: l }), n = e.nextMatch(t, n.from, n.to), u.push(B.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + "."))), n) {
    let h = s.length == 0 || s[0].from >= n.to ? 0 : n.to - n.from - l.length;
    a = D.single(n.from - h, n.to - h), u.push(Wp(r, n)), u.push(t.facet(jn).scrollToMatch(a.main, r));
  }
  return r.dispatch({
    changes: s,
    selection: a,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), I2 = /* @__PURE__ */ $a((r, { query: e }) => {
  if (r.state.readOnly)
    return !1;
  let t = e.matchAll(r.state, 1e9).map((o) => {
    let { from: n, to: s } = o;
    return { from: n, to: s, insert: e.getReplacement(o) };
  });
  if (!t.length)
    return !1;
  let i = r.state.phrase("replaced $ matches", t.length) + ".";
  return r.dispatch({
    changes: t,
    effects: B.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function Lp(r) {
  return r.state.facet(jn).createPanel(r);
}
function tf(r, e) {
  var t, i, o, n, s;
  let a = r.selection.main, l = a.empty || a.to > a.from + 100 ? "" : r.sliceDoc(a.from, a.to);
  if (e && !l)
    return e;
  let u = r.facet(jn);
  return new p1({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : u.caseSensitive,
    literal: (o = e == null ? void 0 : e.literal) !== null && o !== void 0 ? o : u.literal,
    regexp: (n = e == null ? void 0 : e.regexp) !== null && n !== void 0 ? n : u.regexp,
    wholeWord: (s = e == null ? void 0 : e.wholeWord) !== null && s !== void 0 ? s : u.wholeWord
  });
}
function m1(r) {
  let e = sa(r, Lp);
  return e && e.dom.querySelector("[main-field]");
}
function b1(r) {
  let e = m1(r);
  e && e == r.root.activeElement && e.select();
}
const O1 = (r) => {
  let e = r.state.field(Nr, !1);
  if (e && e.panel) {
    let t = m1(r);
    if (t && t != r.root.activeElement) {
      let i = tf(r.state, e.query.spec);
      i.valid && r.dispatch({ effects: ha.of(i) }), t.focus(), t.select();
    }
  } else
    r.dispatch({ effects: [
      Zp.of(!0),
      e ? ha.of(tf(r.state, e.query.spec)) : le.appendConfig.of(B2)
    ] });
  return !0;
}, v1 = (r) => {
  let e = r.state.field(Nr, !1);
  if (!e || !e.panel)
    return !1;
  let t = sa(r, Lp);
  return t && t.dom.contains(r.root.activeElement) && r.focus(), r.dispatch({ effects: Zp.of(!1) }), !0;
}, U2 = [
  { key: "Mod-f", run: O1, scope: "editor search-panel" },
  { key: "F3", run: Eu, shift: Tu, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: Eu, shift: Tu, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: v1, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: W2 },
  { key: "Alt-g", run: x2 },
  { key: "Mod-d", run: D2, preventDefault: !0 }
];
class Y2 {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Nr).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Pe("input", {
      value: t.search,
      placeholder: Wt(e, "Find"),
      "aria-label": Wt(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Pe("input", {
      value: t.replace,
      placeholder: Wt(e, "Replace"),
      "aria-label": Wt(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Pe("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Pe("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Pe("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(o, n, s) {
      return Pe("button", { class: "cm-button", name: o, onclick: n, type: "button" }, s);
    }
    this.dom = Pe("div", { onkeydown: (o) => this.keydown(o), class: "cm-search" }, [
      this.searchField,
      i("next", () => Eu(e), [Wt(e, "next")]),
      i("prev", () => Tu(e), [Wt(e, "previous")]),
      i("select", () => L2(e), [Wt(e, "all")]),
      Pe("label", null, [this.caseField, Wt(e, "match case")]),
      Pe("label", null, [this.reField, Wt(e, "regexp")]),
      Pe("label", null, [this.wordField, Wt(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Pe("br"),
        this.replaceField,
        i("replace", () => Fb(e), [Wt(e, "replace")]),
        i("replaceAll", () => I2(e), [Wt(e, "replace all")])
      ],
      Pe("button", {
        name: "close",
        onclick: () => v1(e),
        "aria-label": Wt(e, "close"),
        type: "button"
      }, ["×"])
    ]);
  }
  commit() {
    let e = new p1({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: ha.of(e) }));
  }
  keydown(e) {
    r_(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? Tu : Eu)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), Fb(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(ha) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(jn).top;
  }
}
function Wt(r, e) {
  return r.state.phrase(e);
}
const pl = 30, gl = /[\s\.,:;?!]/;
function Wp(r, { from: e, to: t }) {
  let i = r.state.doc.lineAt(e), o = r.state.doc.lineAt(t).to, n = Math.max(i.from, e - pl), s = Math.min(o, t + pl), a = r.state.sliceDoc(n, s);
  if (n != i.from) {
    for (let l = 0; l < pl; l++)
      if (!gl.test(a[l + 1]) && gl.test(a[l])) {
        a = a.slice(l);
        break;
      }
  }
  if (s != o) {
    for (let l = a.length - 1; l > a.length - pl; l--)
      if (!gl.test(a[l - 1]) && gl.test(a[l])) {
        a = a.slice(0, l);
        break;
      }
  }
  return B.announce.of(`${r.state.phrase("current match")}. ${a} ${r.state.phrase("on line")} ${i.number}.`);
}
const F2 = /* @__PURE__ */ B.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), B2 = [
  Nr,
  /* @__PURE__ */ Wo.lowest(Z2),
  F2
];
class w1 {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sources—in the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = ze(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), o = t.text.slice(i - t.from, this.pos - t.from), n = o.search(x1(e, !1));
    return n < 0 ? null : { from: i + n, to: this.pos, text: o.slice(n) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function Bb(r) {
  let e = Object.keys(r).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function q2(r) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: o } of r) {
    e[o[0]] = !0;
    for (let n = 1; n < o.length; n++)
      t[o[n]] = !0;
  }
  let i = Bb(e) + Bb(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function Ip(r) {
  let e = r.map((o) => typeof o == "string" ? { label: o } : o), [t, i] = e.every((o) => /^\w+$/.test(o.label)) ? [/\w*$/, /\w+$/] : q2(e);
  return (o) => {
    let n = o.matchBefore(i);
    return n || o.explicit ? { from: n ? n.from : o.pos, options: e, validFor: t } : null;
  };
}
function y1(r, e) {
  return (t) => {
    for (let i = ze(t.state).resolveInner(t.pos, -1); i; i = i.parent) {
      if (r.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(t);
  };
}
class qb {
  constructor(e, t, i, o) {
    this.completion = e, this.source = t, this.match = i, this.score = o;
  }
}
function Vr(r) {
  return r.selection.main.from;
}
function x1(r, e) {
  var t;
  let { source: i } = r, o = e && i[0] != "^", n = i[i.length - 1] != "$";
  return !o && !n ? r : new RegExp(`${o ? "^" : ""}(?:${i})${n ? "$" : ""}`, (t = r.flags) !== null && t !== void 0 ? t : r.ignoreCase ? "i" : "");
}
const S1 = /* @__PURE__ */ pr.define();
function H2(r, e, t, i) {
  let { main: o } = r.selection, n = t - o.from, s = i - o.from;
  return Object.assign(Object.assign({}, r.changeByRange((a) => a != o && t != i && r.sliceDoc(a.from + n, a.from + s) != r.sliceDoc(t, i) ? { range: a } : {
    changes: { from: a.from + n, to: i == o.from ? a.to : a.from + s, insert: e },
    range: D.cursor(a.from + n + e.length)
  })), { userEvent: "input.complete" });
}
const Hb = /* @__PURE__ */ new WeakMap();
function j2(r) {
  if (!Array.isArray(r))
    return r;
  let e = Hb.get(r);
  return e || Hb.set(r, e = Ip(r)), e;
}
const Up = /* @__PURE__ */ le.define(), ca = /* @__PURE__ */ le.define();
class G2 {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [];
    for (let t = 0; t < e.length; ) {
      let i = nt(e, t), o = ri(i);
      this.chars.push(i);
      let n = e.slice(t, t + o), s = n.toUpperCase();
      this.folded.push(nt(s == n ? n.toLowerCase() : s, 0)), t += o;
    }
    this.astral = e.length != this.chars.length;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return null for no match, and otherwise an array that starts
  // with the match score, followed by any number of `from, to` pairs
  // indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return [
        -100
        /* NotFull */
      ];
    if (e.length < this.pattern.length)
      return null;
    let { chars: t, folded: i, any: o, precise: n, byWord: s } = this;
    if (t.length == 1) {
      let v = nt(e, 0), S = ri(v), y = S == e.length ? 0 : -100;
      if (v != t[0])
        if (v == i[0])
          y += -200;
        else
          return null;
      return [y, 0, S];
    }
    let a = e.indexOf(this.pattern);
    if (a == 0)
      return [e.length == this.pattern.length ? 0 : -100, 0, this.pattern.length];
    let l = t.length, u = 0;
    if (a < 0) {
      for (let v = 0, S = Math.min(e.length, 200); v < S && u < l; ) {
        let y = nt(e, v);
        (y == t[u] || y == i[u]) && (o[u++] = v), v += ri(y);
      }
      if (u < l)
        return null;
    }
    let h = 0, c = 0, d = !1, f = 0, p = -1, g = -1, b = /[a-z]/.test(e), m = !0;
    for (let v = 0, S = Math.min(e.length, 200), y = 0; v < S && c < l; ) {
      let x = nt(e, v);
      a < 0 && (h < l && x == t[h] && (n[h++] = v), f < l && (x == t[f] || x == i[f] ? (f == 0 && (p = v), g = v + 1, f++) : f = 0));
      let P, k = x < 255 ? x >= 48 && x <= 57 || x >= 97 && x <= 122 ? 2 : x >= 65 && x <= 90 ? 1 : 0 : (P = bp(x)) != P.toLowerCase() ? 1 : P != P.toUpperCase() ? 2 : 0;
      (!v || k == 1 && b || y == 0 && k != 0) && (t[c] == x || i[c] == x && (d = !0) ? s[c++] = v : s.length && (m = !1)), y = k, v += ri(x);
    }
    return c == l && s[0] == 0 && m ? this.result(-100 + (d ? -200 : 0), s, e) : f == l && p == 0 ? [-200 - e.length + (g == e.length ? 0 : -100), 0, g] : a > -1 ? [-700 - e.length, a, a + this.pattern.length] : f == l ? [-200 + -700 - e.length, p, g] : c == l ? this.result(-100 + (d ? -200 : 0) + -700 + (m ? 0 : -1100), s, e) : t.length == 2 ? null : this.result((o[0] ? -700 : 0) + -200 + -1100, o, e);
  }
  result(e, t, i) {
    let o = [e - i.length], n = 1;
    for (let s of t) {
      let a = s + (this.astral ? ri(nt(i, s)) : 1);
      n > 1 && o[n - 1] == s ? o[n - 1] = a : (o[n++] = s, o[n++] = a);
    }
    return o;
  }
}
const zt = /* @__PURE__ */ H.define({
  combine(r) {
    return Hi(r, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: K2,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => jb(e(i), t(i)),
      optionClass: (e, t) => (i) => jb(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function jb(r, e) {
  return r ? e ? r + " " + e : r : e;
}
function K2(r, e, t, i, o) {
  let n = r.textDirection == Me.RTL, s = n, a = !1, l = "top", u, h, c = e.left - o.left, d = o.right - e.right, f = i.right - i.left, p = i.bottom - i.top;
  if (s && c < Math.min(f, d) ? s = !1 : !s && d < Math.min(f, c) && (s = !0), f <= (s ? c : d))
    u = Math.max(o.top, Math.min(t.top, o.bottom - p)) - e.top, h = Math.min(400, s ? c : d);
  else {
    a = !0, h = Math.min(
      400,
      (n ? e.right : o.right - e.left) - 30
      /* Margin */
    );
    let g = o.bottom - e.bottom;
    g >= p || g > e.top ? u = t.bottom - e.top : (l = "bottom", u = e.bottom - t.top);
  }
  return {
    style: `${l}: ${u}px; max-width: ${h}px`,
    class: "cm-completionInfo-" + (a ? n ? "left-narrow" : "right-narrow" : s ? "left" : "right")
  };
}
function J2(r) {
  let e = r.addToOptions.slice();
  return r.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((o) => "cm-completionIcon-" + o)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, o) {
      let n = document.createElement("span");
      n.className = "cm-completionLabel";
      let { label: s } = t, a = 0;
      for (let l = 1; l < o.length; ) {
        let u = o[l++], h = o[l++];
        u > a && n.appendChild(document.createTextNode(s.slice(a, u)));
        let c = n.appendChild(document.createElement("span"));
        c.appendChild(document.createTextNode(s.slice(u, h))), c.className = "cm-completionMatchedText", a = h;
      }
      return a < s.length && n.appendChild(document.createTextNode(s.slice(a))), n;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function Gb(r, e, t) {
  if (r <= t)
    return { from: 0, to: r };
  if (e < 0 && (e = 0), e <= r >> 1) {
    let o = Math.floor(e / t);
    return { from: o * t, to: (o + 1) * t };
  }
  let i = Math.floor((r - e) / t);
  return { from: r - (i + 1) * t, to: r - i * t };
}
class eX {
  constructor(e, t, i) {
    this.view = e, this.stateField = t, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let o = e.state.field(t), { options: n, selected: s } = o.open, a = e.state.facet(zt);
    this.optionContent = J2(a), this.optionClass = a.optionClass, this.tooltipClass = a.tooltipClass, this.range = Gb(n.length, s, a.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      for (let u = l.target, h; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (h = /-(\d+)$/.exec(u.id)) && +h[1] < n.length) {
          this.applyCompletion(e, n[+h[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(zt).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: ca.of(null) });
    }), this.list = this.dom.appendChild(this.createListBox(n, o.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var t, i, o;
    let n = e.state.field(this.stateField), s = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), n != s && (this.updateSel(), ((t = n.open) === null || t === void 0 ? void 0 : t.disabled) != ((i = s.open) === null || i === void 0 ? void 0 : i.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((o = n.open) === null || o === void 0) && o.disabled)));
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = Gb(t.options.length, t.selected, this.view.state.facet(zt).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    })), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: i } = t.options[t.selected], { info: o } = i;
      if (!o)
        return;
      let n = typeof o == "string" ? document.createTextNode(o) : o(i);
      if (!n)
        return;
      "then" in n ? n.then((s) => {
        s && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(s, i);
      }).catch((s) => li(this.view.state, s, "completion info")) : this.addInfoPane(n, i);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: o, destroy: n } = e;
      i.appendChild(o), this.infoDestroy = n || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, o = this.range.from; i; i = i.nextSibling, o++)
      i.nodeName != "LI" || !i.id ? o-- : o == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && iX(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), o = e.getBoundingClientRect(), n = this.space;
    if (!n) {
      let s = this.dom.ownerDocument.defaultView || window;
      n = { left: 0, top: 0, right: s.innerWidth, bottom: s.innerHeight };
    }
    return o.top > Math.min(n.bottom, t.bottom) - 10 || o.bottom < Math.max(n.top, t.top) + 10 ? null : this.view.state.facet(zt).positionInfo(this.view, t, o, i, n);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, i) {
    const o = document.createElement("ul");
    o.id = t, o.setAttribute("role", "listbox"), o.setAttribute("aria-expanded", "true"), o.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let n = null;
    for (let s = i.from; s < i.to; s++) {
      let { completion: a, match: l } = e[s], { section: u } = a;
      if (u) {
        let d = typeof u == "string" ? u : u.name;
        if (d != n && (s > i.from || i.from == 0))
          if (n = d, typeof u != "string" && u.header)
            o.appendChild(u.header(u));
          else {
            let f = o.appendChild(document.createElement("completion-section"));
            f.textContent = d;
          }
      }
      const h = o.appendChild(document.createElement("li"));
      h.id = t + "-" + s, h.setAttribute("role", "option");
      let c = this.optionClass(a);
      c && (h.className = c);
      for (let d of this.optionContent) {
        let f = d(a, this.view.state, l);
        f && h.appendChild(f);
      }
    }
    return i.from && o.classList.add("cm-completionListIncompleteTop"), i.to < e.length && o.classList.add("cm-completionListIncompleteBottom"), o;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function tX(r, e) {
  return (t) => new eX(t, r, e);
}
function iX(r, e) {
  let t = r.getBoundingClientRect(), i = e.getBoundingClientRect();
  i.top < t.top ? r.scrollTop -= t.top - i.top : i.bottom > t.bottom && (r.scrollTop += i.bottom - t.bottom);
}
function Kb(r) {
  return (r.boost || 0) * 100 + (r.apply ? 10 : 0) + (r.info ? 5 : 0) + (r.type ? 1 : 0);
}
function rX(r, e) {
  let t = [], i = null, o = (l) => {
    t.push(l);
    let { section: u } = l.completion;
    if (u) {
      i || (i = []);
      let h = typeof u == "string" ? u : u.name;
      i.some((c) => c.name == h) || i.push(typeof u == "string" ? { name: h } : u);
    }
  };
  for (let l of r)
    if (l.hasResult())
      if (l.result.filter === !1) {
        let u = l.result.getMatch;
        for (let h of l.result.options) {
          let c = [1e9 - t.length];
          if (u)
            for (let d of u(h))
              c.push(d);
          o(new qb(h, l.source, c, c[0]));
        }
      } else {
        let u = new G2(e.sliceDoc(l.from, l.to)), h;
        for (let c of l.result.options)
          (h = u.match(c.label)) && o(new qb(c, l.source, h, h[0] + (c.boost || 0)));
      }
  if (i) {
    let l = /* @__PURE__ */ Object.create(null), u = 0, h = (c, d) => {
      var f, p;
      return ((f = c.rank) !== null && f !== void 0 ? f : 1e9) - ((p = d.rank) !== null && p !== void 0 ? p : 1e9) || (c.name < d.name ? -1 : 1);
    };
    for (let c of i.sort(h))
      u -= 1e5, l[c.name] = u;
    for (let c of t) {
      let { section: d } = c.completion;
      d && (c.score += l[typeof d == "string" ? d : d.name]);
    }
  }
  let n = [], s = null, a = e.facet(zt).compareCompletions;
  for (let l of t.sort((u, h) => h.score - u.score || a(u.completion, h.completion))) {
    let u = l.completion;
    !s || s.label != u.label || s.detail != u.detail || s.type != null && u.type != null && s.type != u.type || s.apply != u.apply || s.boost != u.boost ? n.push(l) : Kb(l.completion) > Kb(s) && (n[n.length - 1] = l), s = l.completion;
  }
  return n;
}
class hn {
  constructor(e, t, i, o, n, s) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = o, this.selected = n, this.disabled = s;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new hn(this.options, Jb(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, o, n) {
    let s = rX(e, t);
    if (!s.length)
      return o && e.some(
        (l) => l.state == 1
        /* Pending */
      ) ? new hn(o.options, o.attrs, o.tooltip, o.timestamp, o.selected, !0) : null;
    let a = t.facet(zt).selectOnOpen ? 0 : -1;
    if (o && o.selected != a && o.selected != -1) {
      let l = o.options[o.selected].completion;
      for (let u = 0; u < s.length; u++)
        if (s[u].completion == l) {
          a = u;
          break;
        }
    }
    return new hn(s, Jb(i, a), {
      pos: e.reduce((l, u) => u.hasResult() ? Math.min(l, u.from) : l, 1e8),
      create: tX(qt, P1),
      above: n.aboveCursor
    }, o ? o.timestamp : Date.now(), a, !1);
  }
  map(e) {
    return new hn(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class $u {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new $u(sX, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(zt), n = (i.override || t.languageDataAt("autocomplete", Vr(t)).map(j2)).map((a) => (this.active.find((u) => u.source == a) || new _t(
      a,
      this.active.some(
        (u) => u.state != 0
        /* Inactive */
      ) ? 1 : 0
      /* Inactive */
    )).update(e, i));
    n.length == this.active.length && n.every((a, l) => a == this.active[l]) && (n = this.active);
    let s = this.open;
    s && e.docChanged && (s = s.map(e.changes)), e.selection || n.some((a) => a.hasResult() && e.changes.touchesRange(a.from, a.to)) || !oX(n, this.active) ? s = hn.build(n, t, this.id, s, i) : s && s.disabled && !n.some(
      (a) => a.state == 1
      /* Pending */
    ) && (s = null), !s && n.every(
      (a) => a.state != 1
      /* Pending */
    ) && n.some((a) => a.hasResult()) && (n = n.map((a) => a.hasResult() ? new _t(
      a.source,
      0
      /* Inactive */
    ) : a));
    for (let a of e.effects)
      a.is(Q1) && (s = s && s.setSelected(a.value, this.id));
    return n == this.active && s == this.open ? this : new $u(n, this.id, s);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : nX;
  }
}
function oX(r, e) {
  if (r == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < r.length && !r[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let o = t == r.length, n = i == e.length;
    if (o || n)
      return o == n;
    if (r[t++].result != e[i++].result)
      return !1;
  }
}
const nX = {
  "aria-autocomplete": "list"
};
function Jb(r, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": r
  };
  return e > -1 && (t["aria-activedescendant"] = r + "-" + e), t;
}
const sX = [];
function rf(r) {
  return r.isUserEvent("input.type") ? "input" : r.isUserEvent("delete.backward") ? "delete" : null;
}
class _t {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let i = rf(e), o = this;
    i ? o = o.handleUserEvent(e, i, t) : e.docChanged ? o = o.handleChange(e) : e.selection && o.state != 0 && (o = new _t(
      o.source,
      0
      /* Inactive */
    ));
    for (let n of e.effects)
      if (n.is(Up))
        o = new _t(o.source, 1, n.value ? Vr(e.state) : -1);
      else if (n.is(ca))
        o = new _t(
          o.source,
          0
          /* Inactive */
        );
      else if (n.is(C1))
        for (let s of n.value)
          s.source == o.source && (o = s);
    return o;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new _t(
      this.source,
      1
      /* Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(Vr(e.startState)) ? new _t(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new _t(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class yn extends _t {
  constructor(e, t, i, o, n) {
    super(e, 2, t), this.result = i, this.from = o, this.to = n;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, i) {
    var o;
    let n = e.changes.mapPos(this.from), s = e.changes.mapPos(this.to, 1), a = Vr(e.state);
    if ((this.explicitPos < 0 ? a <= n : a < this.from) || a > s || t == "delete" && Vr(e.startState) == this.from)
      return new _t(
        this.source,
        t == "input" && i.activateOnTyping ? 1 : 0
        /* Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), u;
    return aX(this.result.validFor, e.state, n, s) ? new yn(this.source, l, this.result, n, s) : this.result.update && (u = this.result.update(this.result, n, s, new w1(e.state, a, l >= 0))) ? new yn(this.source, l, u, u.from, (o = u.to) !== null && o !== void 0 ? o : Vr(e.state)) : new _t(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new _t(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new yn(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function aX(r, e, t, i) {
  if (!r)
    return !1;
  let o = e.sliceDoc(t, i);
  return typeof r == "function" ? r(o, t, i, e) : x1(r, !0).test(o);
}
const C1 = /* @__PURE__ */ le.define({
  map(r, e) {
    return r.map((t) => t.map(e));
  }
}), Q1 = /* @__PURE__ */ le.define(), qt = /* @__PURE__ */ tt.define({
  create() {
    return $u.start();
  },
  update(r, e) {
    return r.update(e);
  },
  provide: (r) => [
    Ep.from(r, (e) => e.tooltip),
    B.contentAttributes.from(r, (e) => e.attrs)
  ]
});
function P1(r, e) {
  const t = e.completion.apply || e.completion.label;
  let i = r.state.field(qt).active.find((o) => o.source == e.source);
  return i instanceof yn ? (typeof t == "string" ? r.dispatch(Object.assign(Object.assign({}, H2(r.state, t, i.from, i.to)), { annotations: S1.of(e.completion) })) : t(r, e.completion, i.from, i.to), !0) : !1;
}
function ml(r, e = "option") {
  return (t) => {
    let i = t.state.field(qt, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(zt).interactionDelay)
      return !1;
    let o = 1, n;
    e == "page" && (n = nx(t, i.open.tooltip)) && (o = Math.max(2, Math.floor(n.dom.offsetHeight / n.dom.querySelector("li").offsetHeight) - 1));
    let { length: s } = i.open.options, a = i.open.selected > -1 ? i.open.selected + o * (r ? 1 : -1) : r ? 0 : s - 1;
    return a < 0 ? a = e == "page" ? 0 : s - 1 : a >= s && (a = e == "page" ? s - 1 : 0), t.dispatch({ effects: Q1.of(a) }), !0;
  };
}
const lX = (r) => {
  let e = r.state.field(qt, !1);
  return r.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < r.state.facet(zt).interactionDelay ? !1 : P1(r, e.open.options[e.open.selected]);
}, uX = (r) => r.state.field(qt, !1) ? (r.dispatch({ effects: Up.of(!0) }), !0) : !1, hX = (r) => {
  let e = r.state.field(qt, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* Inactive */
  ) ? !1 : (r.dispatch({ effects: ca.of(null) }), !0);
};
class cX {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const eO = 50, dX = 50, fX = 1e3, pX = /* @__PURE__ */ Je.fromClass(class {
  constructor(r) {
    this.view = r, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of r.state.field(qt).active)
      e.state == 1 && this.startQuery(e);
  }
  update(r) {
    let e = r.state.field(qt);
    if (!r.selectionSet && !r.docChanged && r.startState.field(qt) == e)
      return;
    let t = r.transactions.some((i) => (i.selection || i.docChanged) && !rf(i));
    for (let i = 0; i < this.running.length; i++) {
      let o = this.running[i];
      if (t || o.updates.length + r.transactions.length > dX && Date.now() - o.time > fX) {
        for (let n of o.context.abortListeners)
          try {
            n();
          } catch (s) {
            li(this.view.state, s);
          }
        o.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        o.updates.push(...r.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((o) => o.active.source == i.source)) ? setTimeout(() => this.startUpdate(), eO) : -1, this.composing != 0)
      for (let i of r.transactions)
        rf(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: r } = this.view, e = r.field(qt);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(r) {
    let { state: e } = this.view, t = Vr(e), i = new w1(e, t, r.explicitPos == t), o = new cX(r, i);
    this.running.push(o), Promise.resolve(r.source(i)).then((n) => {
      o.context.aborted || (o.done = n || null, this.scheduleAccept());
    }, (n) => {
      this.view.dispatch({ effects: ca.of(null) }), li(this.view.state, n);
    });
  }
  scheduleAccept() {
    this.running.every((r) => r.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), eO));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var r;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(zt);
    for (let i = 0; i < this.running.length; i++) {
      let o = this.running[i];
      if (o.done === void 0)
        continue;
      if (this.running.splice(i--, 1), o.done) {
        let s = new yn(o.active.source, o.active.explicitPos, o.done, o.done.from, (r = o.done.to) !== null && r !== void 0 ? r : Vr(o.updates.length ? o.updates[0].startState : this.view.state));
        for (let a of o.updates)
          s = s.update(a, t);
        if (s.hasResult()) {
          e.push(s);
          continue;
        }
      }
      let n = this.view.state.field(qt).active.find((s) => s.source == o.active.source);
      if (n && n.state == 1)
        if (o.done == null) {
          let s = new _t(
            o.active.source,
            0
            /* Inactive */
          );
          for (let a of o.updates)
            s = s.update(a, t);
          s.state != 1 && e.push(s);
        } else
          this.startQuery(n);
    }
    e.length && this.view.dispatch({ effects: C1.of(e) });
  }
}, {
  eventHandlers: {
    blur(r) {
      let e = this.view.state.field(qt, !1);
      if (e && e.tooltip && this.view.state.facet(zt).closeOnBlur) {
        let t = e.open && nx(this.view, e.open.tooltip);
        (!t || !t.dom.contains(r.relatedTarget)) && this.view.dispatch({ effects: ca.of(null) });
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: Up.of(!1) }), 20), this.composing = 0;
    }
  }
}), k1 = /* @__PURE__ */ B.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '"···"',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "'ƒ'" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "'○'" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "'◌'" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "'𝑥'" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "'𝐶'" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "'𝑡'" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "'∪'" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "'□'" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "'🔑︎'" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "'▢'" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class gX {
  constructor(e, t, i, o) {
    this.field = e, this.line = t, this.from = i, this.to = o;
  }
}
class Yp {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, at.TrackDel), i = e.mapPos(this.to, 1, at.TrackDel);
    return t == null || i == null ? null : new Yp(this.field, t, i);
  }
}
class Fp {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], o = [t], n = e.doc.lineAt(t), s = /^\s*/.exec(n.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let u = s, h = /^\t*/.exec(l)[0].length;
        for (let c = 0; c < h; c++)
          u += e.facet(ph);
        o.push(t + u.length - h), l = u + l.slice(h);
      }
      i.push(l), t += l.length + 1;
    }
    let a = this.fieldPositions.map((l) => new Yp(l.field, o[l.line] + l.from, o[l.line] + l.to));
    return { text: i, ranges: a };
  }
  static parse(e) {
    let t = [], i = [], o = [], n;
    for (let s of e.split(/\r\n?|\n/)) {
      for (; n = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(s); ) {
        let a = n[1] ? +n[1] : null, l = n[2] || n[3] || "", u = -1;
        for (let h = 0; h < t.length; h++)
          (a != null ? t[h].seq == a : l && t[h].name == l) && (u = h);
        if (u < 0) {
          let h = 0;
          for (; h < t.length && (a == null || t[h].seq != null && t[h].seq < a); )
            h++;
          t.splice(h, 0, { seq: a, name: l }), u = h;
          for (let c of o)
            c.field >= u && c.field++;
        }
        o.push(new gX(u, i.length, n.index, n.index + l.length)), s = s.slice(0, n.index) + l + s.slice(n.index + n[0].length);
      }
      for (let a; a = /\\([{}])/.exec(s); ) {
        s = s.slice(0, a.index) + a[1] + s.slice(a.index + a[0].length);
        for (let l of o)
          l.line == i.length && l.from > a.index && (l.from--, l.to--);
      }
      i.push(s);
    }
    return new Fp(i, o);
  }
}
let mX = /* @__PURE__ */ J.widget({ widget: /* @__PURE__ */ new class extends gr {
  toDOM() {
    let r = document.createElement("span");
    return r.className = "cm-snippetFieldPosition", r;
  }
  ignoreEvent() {
    return !1;
  }
}() }), bX = /* @__PURE__ */ J.mark({ class: "cm-snippetField" });
class Gn {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = J.set(e.map((i) => (i.from == i.to ? mX : bX).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let o = i.map(e);
      if (!o)
        return null;
      t.push(o);
    }
    return new Gn(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
}
const Ra = /* @__PURE__ */ le.define({
  map(r, e) {
    return r && r.map(e);
  }
}), OX = /* @__PURE__ */ le.define(), da = /* @__PURE__ */ tt.define({
  create() {
    return null;
  },
  update(r, e) {
    for (let t of e.effects) {
      if (t.is(Ra))
        return t.value;
      if (t.is(OX) && r)
        return new Gn(r.ranges, t.value);
    }
    return r && e.docChanged && (r = r.map(e.changes)), r && e.selection && !r.selectionInsideField(e.selection) && (r = null), r;
  },
  provide: (r) => B.decorations.from(r, (e) => e ? e.deco : J.none)
});
function Bp(r, e) {
  return D.create(r.filter((t) => t.field == e).map((t) => D.range(t.from, t.to)));
}
function vX(r) {
  let e = Fp.parse(r);
  return (t, i, o, n) => {
    let { text: s, ranges: a } = e.instantiate(t.state, o), l = {
      changes: { from: o, to: n, insert: ve.of(s) },
      scrollIntoView: !0,
      annotations: i ? S1.of(i) : void 0
    };
    if (a.length && (l.selection = Bp(a, 0)), a.length > 1) {
      let u = new Gn(a, 0), h = l.effects = [Ra.of(u)];
      t.state.field(da, !1) === void 0 && h.push(le.appendConfig.of([da, CX, QX, k1]));
    }
    t.dispatch(t.state.update(l));
  };
}
function E1(r) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(da, !1);
    if (!i || r < 0 && i.active == 0)
      return !1;
    let o = i.active + r, n = r > 0 && !i.ranges.some((s) => s.field == o + r);
    return t(e.update({
      selection: Bp(i.ranges, o),
      effects: Ra.of(n ? null : new Gn(i.ranges, o))
    })), !0;
  };
}
const wX = ({ state: r, dispatch: e }) => r.field(da, !1) ? (e(r.update({ effects: Ra.of(null) })), !0) : !1, yX = /* @__PURE__ */ E1(1), xX = /* @__PURE__ */ E1(-1), SX = [
  { key: "Tab", run: yX, shift: xX },
  { key: "Escape", run: wX }
], tO = /* @__PURE__ */ H.define({
  combine(r) {
    return r.length ? r[0] : SX;
  }
}), CX = /* @__PURE__ */ Wo.highest(/* @__PURE__ */ Pa.compute([tO], (r) => r.facet(tO)));
function fi(r, e) {
  return Object.assign(Object.assign({}, e), { apply: vX(r) });
}
const QX = /* @__PURE__ */ B.domEventHandlers({
  mousedown(r, e) {
    let t = e.state.field(da, !1), i;
    if (!t || (i = e.posAtCoords({ x: r.clientX, y: r.clientY })) == null)
      return !1;
    let o = t.ranges.find((n) => n.from <= i && n.to >= i);
    return !o || o.field == t.active ? !1 : (e.dispatch({
      selection: Bp(t.ranges, o.field),
      effects: Ra.of(t.ranges.some((n) => n.field > o.field) ? new Gn(t.ranges, o.field) : null)
    }), !0);
  }
}), fa = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, Oo = /* @__PURE__ */ le.define({
  map(r, e) {
    let t = e.mapPos(r, -1, at.TrackAfter);
    return t ?? void 0;
  }
}), qp = /* @__PURE__ */ new class extends _o {
}();
qp.startSide = 1;
qp.endSide = -1;
const T1 = /* @__PURE__ */ tt.define({
  create() {
    return Se.empty;
  },
  update(r, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, i = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(i, -1) && (r = Se.empty);
    }
    r = r.map(e.changes);
    for (let t of e.effects)
      t.is(Oo) && (r = r.update({ add: [qp.range(t.value, t.value + 1)] }));
    return r;
  }
});
function PX() {
  return [EX, T1];
}
const Oc = "()[]{}<>";
function $1(r) {
  for (let e = 0; e < Oc.length; e += 2)
    if (Oc.charCodeAt(e) == r)
      return Oc.charAt(e + 1);
  return bp(r < 128 ? r : r + 1);
}
function R1(r, e) {
  return r.languageDataAt("closeBrackets", e)[0] || fa;
}
const kX = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), EX = /* @__PURE__ */ B.inputHandler.of((r, e, t, i) => {
  if ((kX ? r.composing : r.compositionStarted) || r.state.readOnly)
    return !1;
  let o = r.state.selection.main;
  if (i.length > 2 || i.length == 2 && ri(nt(i, 0)) == 1 || e != o.from || t != o.to)
    return !1;
  let n = RX(r.state, i);
  return n ? (r.dispatch(n), !0) : !1;
}), TX = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let i = R1(r, r.selection.main.head).brackets || fa.brackets, o = null, n = r.changeByRange((s) => {
    if (s.empty) {
      let a = _X(r.doc, s.head);
      for (let l of i)
        if (l == a && Sh(r.doc, s.head) == $1(nt(l, 0)))
          return {
            changes: { from: s.head - l.length, to: s.head + l.length },
            range: D.cursor(s.head - l.length)
          };
    }
    return { range: o = s };
  });
  return o || e(r.update(n, { scrollIntoView: !0, userEvent: "delete.backward" })), !o;
}, $X = [
  { key: "Backspace", run: TX }
];
function RX(r, e) {
  let t = R1(r, r.selection.main.head), i = t.brackets || fa.brackets;
  for (let o of i) {
    let n = $1(nt(o, 0));
    if (e == o)
      return n == o ? XX(r, o, i.indexOf(o + o + o) > -1, t) : DX(r, o, n, t.before || fa.before);
    if (e == n && _1(r, r.selection.main.from))
      return MX(r, o, n);
  }
  return null;
}
function _1(r, e) {
  let t = !1;
  return r.field(T1).between(0, r.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function Sh(r, e) {
  let t = r.sliceString(e, e + 2);
  return t.slice(0, ri(nt(t, 0)));
}
function _X(r, e) {
  let t = r.sliceString(e - 2, e);
  return ri(nt(t, 0)) == t.length ? t : t.slice(1);
}
function DX(r, e, t, i) {
  let o = null, n = r.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: t, from: s.to }],
        effects: Oo.of(s.to + e.length),
        range: D.range(s.anchor + e.length, s.head + e.length)
      };
    let a = Sh(r.doc, s.head);
    return !a || /\s/.test(a) || i.indexOf(a) > -1 ? {
      changes: { insert: e + t, from: s.head },
      effects: Oo.of(s.head + e.length),
      range: D.cursor(s.head + e.length)
    } : { range: o = s };
  });
  return o ? null : r.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function MX(r, e, t) {
  let i = null, o = r.changeByRange((n) => n.empty && Sh(r.doc, n.head) == t ? {
    changes: { from: n.head, to: n.head + t.length, insert: t },
    range: D.cursor(n.head + t.length)
  } : i = { range: n });
  return i ? null : r.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function XX(r, e, t, i) {
  let o = i.stringPrefixes || fa.stringPrefixes, n = null, s = r.changeByRange((a) => {
    if (!a.empty)
      return {
        changes: [{ insert: e, from: a.from }, { insert: e, from: a.to }],
        effects: Oo.of(a.to + e.length),
        range: D.range(a.anchor + e.length, a.head + e.length)
      };
    let l = a.head, u = Sh(r.doc, l), h;
    if (u == e) {
      if (iO(r, l))
        return {
          changes: { insert: e + e, from: l },
          effects: Oo.of(l + e.length),
          range: D.cursor(l + e.length)
        };
      if (_1(r, l)) {
        let d = t && r.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + d.length, insert: d },
          range: D.cursor(l + d.length)
        };
      }
    } else {
      if (t && r.sliceDoc(l - 2 * e.length, l) == e + e && (h = rO(r, l - 2 * e.length, o)) > -1 && iO(r, h))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: Oo.of(l + e.length),
          range: D.cursor(l + e.length)
        };
      if (r.charCategorizer(l)(u) != Re.Word && rO(r, l, o) > -1 && !AX(r, l, e, o))
        return {
          changes: { insert: e + e, from: l },
          effects: Oo.of(l + e.length),
          range: D.cursor(l + e.length)
        };
    }
    return { range: n = a };
  });
  return n ? null : r.update(s, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function iO(r, e) {
  let t = ze(r).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function AX(r, e, t, i) {
  let o = ze(r).resolveInner(e, -1), n = i.reduce((s, a) => Math.max(s, a.length), 0);
  for (let s = 0; s < 5; s++) {
    let a = r.sliceDoc(o.from, Math.min(o.to, o.from + t.length + n)), l = a.indexOf(t);
    if (!l || l > -1 && i.indexOf(a.slice(0, l)) > -1) {
      let h = o.firstChild;
      for (; h && h.from == o.from && h.to - h.from > t.length + l; ) {
        if (r.sliceDoc(h.to - t.length, h.to) == t)
          return !1;
        h = h.firstChild;
      }
      return !0;
    }
    let u = o.to == e && o.parent;
    if (!u)
      break;
    o = u;
  }
  return !1;
}
function rO(r, e, t) {
  let i = r.charCategorizer(e);
  if (i(r.sliceDoc(e - 1, e)) != Re.Word)
    return e;
  for (let o of t) {
    let n = e - o.length;
    if (r.sliceDoc(n, e) == o && i(r.sliceDoc(n - 1, n)) != Re.Word)
      return n;
  }
  return -1;
}
function D1(r = {}) {
  return [
    qt,
    zt.of(r),
    pX,
    zX,
    k1
  ];
}
const M1 = [
  { key: "Ctrl-Space", run: uX },
  { key: "Escape", run: hX },
  { key: "ArrowDown", run: /* @__PURE__ */ ml(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ ml(!1) },
  { key: "PageDown", run: /* @__PURE__ */ ml(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ ml(!1, "page") },
  { key: "Enter", run: lX }
], zX = /* @__PURE__ */ Wo.highest(/* @__PURE__ */ Pa.computeN([zt], (r) => r.facet(zt).defaultKeymap ? [M1] : []));
class NX {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class co {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let o = e, n = i.facet(z1).markerFilter;
    n && (o = n(o));
    let s = J.set(o.map((a) => a.from == a.to || a.from == a.to - 1 && i.doc.lineAt(a.from).to == a.from ? J.widget({
      widget: new BX(a),
      diagnostic: a
    }).range(a.from) : J.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + a.severity },
      diagnostic: a
    }).range(a.from, a.to)), !0);
    return new co(s, t, Nn(s));
  }
}
function Nn(r, e = null, t = 0) {
  let i = null;
  return r.between(t, 1e9, (o, n, { spec: s }) => {
    if (!(e && s.diagnostic != e))
      return i = new NX(o, n, s.diagnostic), !1;
  }), i;
}
function VX(r, e) {
  let t = r.startState.doc.lineAt(e.pos);
  return !!(r.effects.some((i) => i.is(X1)) || r.changes.touchesRange(t.from, t.to));
}
function ZX(r, e) {
  return r.field(jt, !1) ? e : e.concat(le.appendConfig.of(jX));
}
const X1 = /* @__PURE__ */ le.define(), Hp = /* @__PURE__ */ le.define(), A1 = /* @__PURE__ */ le.define(), jt = /* @__PURE__ */ tt.define({
  create() {
    return new co(J.none, null, null);
  },
  update(r, e) {
    if (e.docChanged) {
      let t = r.diagnostics.map(e.changes), i = null;
      if (r.selected) {
        let o = e.changes.mapPos(r.selected.from, 1);
        i = Nn(t, r.selected.diagnostic, o) || Nn(t, null, o);
      }
      r = new co(t, r.panel, i);
    }
    for (let t of e.effects)
      t.is(X1) ? r = co.init(t.value, r.panel, e.state) : t.is(Hp) ? r = new co(r.diagnostics, t.value ? Ch.open : null, r.selected) : t.is(A1) && (r = new co(r.diagnostics, r.panel, t.value));
    return r;
  },
  provide: (r) => [
    aa.from(r, (e) => e.panel),
    B.decorations.from(r, (e) => e.diagnostics)
  ]
}), LX = /* @__PURE__ */ J.mark({ class: "cm-lintRange cm-lintRange-active" });
function WX(r, e, t) {
  let { diagnostics: i } = r.state.field(jt), o = [], n = 2e8, s = 0;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, u, { spec: h }) => {
    e >= l && e <= u && (l == u || (e > l || t > 0) && (e < u || t < 0)) && (o.push(h.diagnostic), n = Math.min(l, n), s = Math.max(u, s));
  });
  let a = r.state.facet(z1).tooltipFilter;
  return a && (o = a(o)), o.length ? {
    pos: n,
    end: s,
    above: r.state.doc.lineAt(n).to < s,
    create() {
      return { dom: IX(r, o) };
    }
  } : null;
}
function IX(r, e) {
  return Pe("ul", { class: "cm-tooltip-lint" }, e.map((t) => V1(r, t, !1)));
}
const UX = (r) => {
  let e = r.state.field(jt, !1);
  (!e || !e.panel) && r.dispatch({ effects: ZX(r.state, [Hp.of(!0)]) });
  let t = sa(r, Ch.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, oO = (r) => {
  let e = r.state.field(jt, !1);
  return !e || !e.panel ? !1 : (r.dispatch({ effects: Hp.of(!1) }), !0);
}, YX = (r) => {
  let e = r.state.field(jt, !1);
  if (!e)
    return !1;
  let t = r.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (r.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, FX = [
  { key: "Mod-Shift-m", run: UX, preventDefault: !0 },
  { key: "F8", run: YX }
], z1 = /* @__PURE__ */ H.define({
  combine(r) {
    return Object.assign({ sources: r.map((e) => e.source) }, Hi(r.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (i) => e(i) || t(i) : e : t
    }));
  }
});
function N1(r) {
  let e = [];
  if (r)
    e:
      for (let { name: t } of r) {
        for (let i = 0; i < t.length; i++) {
          let o = t[i];
          if (/[a-zA-Z]/.test(o) && !e.some((n) => n.toLowerCase() == o.toLowerCase())) {
            e.push(o);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function V1(r, e, t) {
  var i;
  let o = t ? N1(e.actions) : [];
  return Pe("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Pe("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((n, s) => {
    let a = !1, l = (d) => {
      if (d.preventDefault(), a)
        return;
      a = !0;
      let f = Nn(r.state.field(jt).diagnostics, e);
      f && n.apply(r, f.from, f.to);
    }, { name: u } = n, h = o[s] ? u.indexOf(o[s]) : -1, c = h < 0 ? u : [
      u.slice(0, h),
      Pe("u", u.slice(h, h + 1)),
      u.slice(h + 1)
    ];
    return Pe("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${h < 0 ? "" : ` (access key "${o[s]})"`}.`
    }, c);
  }), e.source && Pe("div", { class: "cm-diagnosticSource" }, e.source));
}
class BX extends gr {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Pe("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class nO {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = V1(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class Ch {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (o) => {
      if (o.keyCode == 27)
        oO(this.view), this.view.focus();
      else if (o.keyCode == 38 || o.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (o.keyCode == 40 || o.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (o.keyCode == 36)
        this.moveSelection(0);
      else if (o.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (o.keyCode == 13)
        this.view.focus();
      else if (o.keyCode >= 65 && o.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: n } = this.items[this.selectedIndex], s = N1(n.actions);
        for (let a = 0; a < s.length; a++)
          if (s[a].toUpperCase().charCodeAt(0) == o.keyCode) {
            let l = Nn(this.view.state.field(jt).diagnostics, n);
            l && n.actions[a].apply(e, l.from, l.to);
          }
      } else
        return;
      o.preventDefault();
    }, i = (o) => {
      for (let n = 0; n < this.items.length; n++)
        this.items[n].dom.contains(o.target) && this.moveSelection(n);
    };
    this.list = Pe("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = Pe("div", { class: "cm-panel-lint" }, this.list, Pe("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => oO(this.view)
    }, "×")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(jt).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(jt), i = 0, o = !1, n = null;
    for (e.between(0, this.view.state.doc.length, (s, a, { spec: l }) => {
      let u = -1, h;
      for (let c = i; c < this.items.length; c++)
        if (this.items[c].diagnostic == l.diagnostic) {
          u = c;
          break;
        }
      u < 0 ? (h = new nO(this.view, l.diagnostic), this.items.splice(i, 0, h), o = !0) : (h = this.items[u], u > i && (this.items.splice(i, u - i), o = !0)), t && h.diagnostic == t.diagnostic ? h.dom.hasAttribute("aria-selected") || (h.dom.setAttribute("aria-selected", "true"), n = h) : h.dom.hasAttribute("aria-selected") && h.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      o = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new nO(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), o = !0), n ? (this.list.setAttribute("aria-activedescendant", n.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: n.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: s, panel: a }) => {
        s.top < a.top ? this.list.scrollTop -= a.top - s.top : s.bottom > a.bottom && (this.list.scrollTop += s.bottom - a.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), o && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(jt), i = Nn(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: A1.of(i)
    });
  }
  static open(e) {
    return new Ch(e);
  }
}
function qX(r, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(r)}</svg>')`;
}
function vc(r) {
  return qX(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${r}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const HX = /* @__PURE__ */ B.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ vc("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ vc("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ vc("#999") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), jX = [
  jt,
  /* @__PURE__ */ B.decorations.compute([jt], (r) => {
    let { selected: e, panel: t } = r.field(jt);
    return !e || !t || e.from == e.to ? J.none : J.set([
      LX.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ W_(WX, { hideOn: VX }),
  HX
], GX = /* @__PURE__ */ (() => [
  G_(),
  eD(),
  w_(),
  yM(),
  BD(),
  u_(),
  p_(),
  be.allowMultipleSelections.of(!0),
  XD(),
  kx(GD, { fallback: !0 }),
  oM(),
  PX(),
  D1(),
  __(),
  X_(),
  P_(),
  Q2(),
  Pa.of([
    ...$X,
    ...l1,
    ...U2,
    ...$M,
    ...UD,
    ...M1,
    ...FX
  ])
])(), KX = "#e5c07b", sO = "#e06c75", JX = "#56b6c2", eA = "#ffffff", Rl = "#abb2bf", of = "#7d8799", tA = "#61afef", iA = "#98c379", aO = "#d19a66", rA = "#c678dd", oA = "#21252b", lO = "#2c313a", uO = "#282c34", wc = "#353a42", nA = "#3E4451", hO = "#528bff", sA = /* @__PURE__ */ B.theme({
  "&": {
    color: Rl,
    backgroundColor: uO
  },
  ".cm-content": {
    caretColor: hO
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: hO },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: nA },
  ".cm-panels": { backgroundColor: oA, color: Rl },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: uO,
    color: of,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: lO
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: wc
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: wc,
    borderBottomColor: wc
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: lO,
      color: Rl
    }
  }
}, { dark: !0 }), aA = /* @__PURE__ */ Ta.define([
  {
    tag: O.keyword,
    color: rA
  },
  {
    tag: [O.name, O.deleted, O.character, O.propertyName, O.macroName],
    color: sO
  },
  {
    tag: [/* @__PURE__ */ O.function(O.variableName), O.labelName],
    color: tA
  },
  {
    tag: [O.color, /* @__PURE__ */ O.constant(O.name), /* @__PURE__ */ O.standard(O.name)],
    color: aO
  },
  {
    tag: [/* @__PURE__ */ O.definition(O.name), O.separator],
    color: Rl
  },
  {
    tag: [O.typeName, O.className, O.number, O.changed, O.annotation, O.modifier, O.self, O.namespace],
    color: KX
  },
  {
    tag: [O.operator, O.operatorKeyword, O.url, O.escape, O.regexp, O.link, /* @__PURE__ */ O.special(O.string)],
    color: JX
  },
  {
    tag: [O.meta, O.comment],
    color: of
  },
  {
    tag: O.strong,
    fontWeight: "bold"
  },
  {
    tag: O.emphasis,
    fontStyle: "italic"
  },
  {
    tag: O.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: O.link,
    color: of,
    textDecoration: "underline"
  },
  {
    tag: O.heading,
    fontWeight: "bold",
    color: sO
  },
  {
    tag: [O.atom, O.bool, /* @__PURE__ */ O.special(O.variableName)],
    color: aO
  },
  {
    tag: [O.processingInstruction, O.string, O.inserted],
    color: iA
  },
  {
    tag: O.invalid,
    color: eA
  }
]), lA = [sA, /* @__PURE__ */ kx(aA)];
class Ru {
  /// @internal
  constructor(e, t, i, o, n, s, a, l, u, h = 0, c) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = o, this.pos = n, this.score = s, this.buffer = a, this.bufferBase = l, this.curContext = u, this.lookAhead = h, this.parent = c;
  }
  /// @internal
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /// @internal
  static start(e, t, i = 0) {
    let o = e.parser.context;
    return new Ru(e, [], t, i, i, 0, [], 0, o ? new cO(o, o.start) : null, 0, null);
  }
  /// The stack's current [context](#lr.ContextTracker) value, if
  /// any. Its type will depend on the context tracker's type
  /// parameter, or it will be `null` if there is no context
  /// tracker.
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /// @internal
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /// @internal
  reduce(e) {
    var t;
    let i = e >> 19, o = e & 65535, { parser: n } = this.p, s = n.dynamicPrecedence(o);
    if (s && (this.score += s), i == 0) {
      this.pushState(n.getGoto(this.state, o, !0), this.reducePos), o < n.minRepeatTerm && this.storeNode(o, this.reducePos, this.reducePos, 4, !0), this.reduceContext(o, this.reducePos);
      return;
    }
    let a = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), l = a ? this.stack[a - 2] : this.p.ranges[0].from, u = this.reducePos - l;
    u >= 2e3 && !(!((t = this.p.parser.nodeSet.types[o]) === null || t === void 0) && t.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = u));
    let h = a ? this.stack[a - 1] : 0, c = this.bufferBase + this.buffer.length - h;
    if (o < n.minRepeatTerm || e & 131072) {
      let d = n.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(o, l, d, c + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[a];
    else {
      let d = this.stack[a - 3];
      this.state = n.getGoto(d, o, !0);
    }
    for (; this.stack.length > a; )
      this.stack.pop();
    this.reduceContext(o, l);
  }
  // Shift a value into the buffer
  /// @internal
  storeNode(e, t, i, o = 4, n = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let s = this, a = this.buffer.length;
      if (a == 0 && s.parent && (a = s.bufferBase - s.parent.bufferBase, s = s.parent), a > 0 && s.buffer[a - 4] == 0 && s.buffer[a - 1] > -1) {
        if (t == i)
          return;
        if (s.buffer[a - 2] >= t) {
          s.buffer[a - 2] = i;
          return;
        }
      }
    }
    if (!n || this.pos == i)
      this.buffer.push(e, t, i, o);
    else {
      let s = this.buffer.length;
      if (s > 0 && this.buffer[s - 4] != 0)
        for (; s > 0 && this.buffer[s - 2] > i; )
          this.buffer[s] = this.buffer[s - 4], this.buffer[s + 1] = this.buffer[s - 3], this.buffer[s + 2] = this.buffer[s - 2], this.buffer[s + 3] = this.buffer[s - 1], s -= 4, o > 4 && (o -= 4);
      this.buffer[s] = e, this.buffer[s + 1] = t, this.buffer[s + 2] = i, this.buffer[s + 3] = o;
    }
  }
  // Apply a shift action
  /// @internal
  shift(e, t, i) {
    let o = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(t, o), t <= this.p.parser.maxNode && this.buffer.push(t, o, i, 4);
    else {
      let n = e, { parser: s } = this.p;
      (i > this.pos || t <= s.maxNode) && (this.pos = i, s.stateFlag(
        n,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(n, o), this.shiftContext(t, o), t <= s.maxNode && this.buffer.push(t, o, i, 4);
    }
  }
  // Apply an action
  /// @internal
  apply(e, t, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /// @internal
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let o = this.pos;
    this.reducePos = this.pos = o + e.length, this.pushState(t, o), this.buffer.push(
      i,
      o,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /// @internal
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), o = e.bufferBase + t;
    for (; e && o == e.bufferBase; )
      e = e.parent;
    return new Ru(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, o, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /// @internal
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /// Check if the given term would be able to be shifted (optionally
  /// after some reductions) on this stack. This can be useful for
  /// external tokenizers that want to make sure they only provide a
  /// given token when it applies.
  canShift(e) {
    for (let t = new uA(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /// @internal
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let o = [];
      for (let n = 0, s; n < t.length; n += 2)
        (s = t[n + 1]) != this.state && this.p.parser.hasAction(s, e) && o.push(t[n], s);
      if (this.stack.length < 120)
        for (let n = 0; o.length < 8 && n < t.length; n += 2) {
          let s = t[n + 1];
          o.some((a, l) => l & 1 && a == s) || o.push(t[n], s);
        }
      t = o;
    }
    let i = [];
    for (let o = 0; o < t.length && i.length < 4; o += 2) {
      let n = t[o + 1];
      if (n == this.state)
        continue;
      let s = this.split();
      s.pushState(n, this.pos), s.storeNode(0, s.pos, s.pos, 4, !0), s.shiftContext(t[o], this.pos), s.score -= 200, i.push(s);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /// @internal
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(t & 65536))
      return !1;
    if (!e.validAction(this.state, t)) {
      let i = t >> 19, o = t & 65535, n = this.stack.length - i * 3;
      if (n < 0 || e.getGoto(this.stack[n], o, !1) < 0) {
        let s = this.findForcedReduction();
        if (s == null)
          return !1;
        t = s;
      }
      this.storeNode(0, this.reducePos, this.reducePos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /// Try to scan through the automaton to find some kind of reduction
  /// that can be applied. Used when the regular ForcedReduce field
  /// isn't a valid action. @internal
  findForcedReduction() {
    let { parser: e } = this.p, t = [], i = (o, n) => {
      if (!t.includes(o))
        return t.push(o), e.allActions(o, (s) => {
          if (!(s & 393216))
            if (s & 65536) {
              let a = (s >> 19) - n;
              if (a > 1) {
                let l = s & 65535, u = this.stack.length - a * 3;
                if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                  return a << 19 | 65536 | l;
              }
            } else {
              let a = i(s, n + 1);
              if (a != null)
                return a;
            }
        });
    };
    return i(this.state, 0);
  }
  /// @internal
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /// Check whether this state has no further actions (assumed to be a direct descendant of the
  /// top state, since any other states must be able to continue
  /// somehow). @internal
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /// Restart the stack (put it back in its start state). Only safe
  /// when this.stack.length == 3 (state is directly below the top
  /// state). @internal
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /// @internal
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /// Get the parser used by this stack.
  get parser() {
    return this.p.parser;
  }
  /// Test whether a given dialect (by numeric ID, as exported from
  /// the terms file) is enabled.
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /// @internal
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /// @internal
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new cO(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /// @internal
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /// @internal
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class cO {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
var dO;
(function(r) {
  r[r.Insert = 200] = "Insert", r[r.Delete = 190] = "Delete", r[r.Reduce = 100] = "Reduce", r[r.MaxNext = 4] = "MaxNext", r[r.MaxInsertStackDepth = 300] = "MaxInsertStackDepth", r[r.DampenInsertStackDepth = 120] = "DampenInsertStackDepth", r[r.MinBigReduction = 2e3] = "MinBigReduction";
})(dO || (dO = {}));
class uA {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let o = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = o;
  }
}
class _u {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new _u(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new _u(this.stack, this.pos, this.index);
  }
}
function ws(r, e = Uint16Array) {
  if (typeof r != "string")
    return r;
  let t = null;
  for (let i = 0, o = 0; i < r.length; ) {
    let n = 0;
    for (; ; ) {
      let s = r.charCodeAt(i++), a = !1;
      if (s == 126) {
        n = 65535;
        break;
      }
      s >= 92 && s--, s >= 34 && s--;
      let l = s - 32;
      if (l >= 46 && (l -= 46, a = !0), n += l, a)
        break;
      n *= 46;
    }
    t ? t[o++] = n : t = new e(n);
  }
  return t;
}
class _l {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const fO = new _l();
class hA {
  /// @internal
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = fO, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /// @internal
  resolveOffset(e, t) {
    let i = this.range, o = this.rangeIndex, n = this.pos + e;
    for (; n < i.from; ) {
      if (!o)
        return null;
      let s = this.ranges[--o];
      n -= i.from - s.to, i = s;
    }
    for (; t < 0 ? n > i.to : n >= i.to; ) {
      if (o == this.ranges.length - 1)
        return null;
      let s = this.ranges[++o];
      n += s.from - i.to, i = s;
    }
    return n;
  }
  /// @internal
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /// Look at a code unit near the stream position. `.peek(0)` equals
  /// `.next`, `.peek(-1)` gives you the previous character, and so
  /// on.
  ///
  /// Note that looking around during tokenizing creates dependencies
  /// on potentially far-away content, which may reduce the
  /// effectiveness incremental parsing—when looking forward—or even
  /// cause invalid reparses when looking backward more than 25 code
  /// units, since the library does not track lookbehind.
  peek(e) {
    let t = this.chunkOff + e, i, o;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, o = this.chunk.charCodeAt(t);
    else {
      let n = this.resolveOffset(e, 1);
      if (n == null)
        return -1;
      if (i = n, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        o = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let s = this.rangeIndex, a = this.range;
        for (; a.to <= i; )
          a = this.ranges[++s];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > a.to && (this.chunk2 = this.chunk2.slice(0, a.to - i)), o = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), o;
  }
  /// Accept a token. By default, the end of the token is set to the
  /// current stream position, but you can pass an offset (relative to
  /// the stream position) to change that.
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /// Move the stream forward N (defaults to 1) code units. Returns
  /// the new value of [`next`](#lr.InputStream.next).
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /// @internal
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = fO, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /// @internal
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let o of this.ranges) {
      if (o.from >= t)
        break;
      o.to > e && (i += this.input.read(Math.max(o.from, e), Math.min(o.to, t)));
    }
    return i;
  }
}
class xn {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: i } = t.p;
    Z1(this.data, e, t, this.id, i.data, i.tokenPrecTable);
  }
}
xn.prototype.contextual = xn.prototype.fallback = xn.prototype.extend = !1;
class nf {
  constructor(e, t, i) {
    this.precTable = t, this.elseToken = i, this.data = typeof e == "string" ? ws(e) : e;
  }
  token(e, t) {
    let i = e.pos, o = 0;
    for (; ; ) {
      let n = e.resolveOffset(1, -1);
      if (Z1(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (n == null)
        break;
      e.reset(n, e.token), o++;
    }
    o && (e.reset(i, e.token), e.acceptToken(this.elseToken, o));
  }
}
nf.prototype.contextual = xn.prototype.fallback = xn.prototype.extend = !1;
class Ci {
  /// Create a tokenizer. The first argument is the function that,
  /// given an input stream, scans for the types of tokens it
  /// recognizes at the stream's position, and calls
  /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  /// one.
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function Z1(r, e, t, i, o, n) {
  let s = 0, a = 1 << i, { dialect: l } = t.p.parser;
  e:
    for (; a & r[s]; ) {
      let u = r[s + 1];
      for (let f = s + 3; f < u; f += 2)
        if ((r[f + 1] & a) > 0) {
          let p = r[f];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || cA(p, e.token.value, o, n))) {
            e.acceptToken(p);
            break;
          }
        }
      let h = e.next, c = 0, d = r[s + 2];
      if (e.next < 0 && d > c && r[u + d * 3 - 3] == 65535 && r[u + d * 3 - 3] == 65535) {
        s = r[u + d * 3 - 1];
        continue e;
      }
      for (; c < d; ) {
        let f = c + d >> 1, p = u + f + (f << 1), g = r[p], b = r[p + 1] || 65536;
        if (h < g)
          d = f;
        else if (h >= b)
          c = f + 1;
        else {
          s = r[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function pO(r, e, t) {
  for (let i = e, o; (o = r[i]) != 65535; i++)
    if (o == t)
      return i - e;
  return -1;
}
function cA(r, e, t, i) {
  let o = pO(t, i, e);
  return o < 0 || pO(t, i, r) < o;
}
const pi = typeof process < "u" && {} && /\bparse\b/.test({}.LOG);
let yc = null;
var gO;
(function(r) {
  r[r.Margin = 25] = "Margin";
})(gO || (gO = {}));
function mO(r, e, t) {
  let i = r.cursor($e.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(r.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : r.length;
      }
}
class dA {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? mO(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? mO(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], o = this.index[t];
      if (o == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let n = i.children[o], s = this.start[t] + i.positions[o];
      if (s > e)
        return this.nextStart = s, null;
      if (n instanceof Xe) {
        if (s == e) {
          if (s < this.safeFrom)
            return null;
          let a = s + n.length;
          if (a <= this.safeTo) {
            let l = n.prop(he.lookAhead);
            if (!l || a + l < this.fragment.to)
              return n;
          }
        }
        this.index[t]++, s + n.length >= Math.max(this.safeFrom, e) && (this.trees.push(n), this.start.push(s), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = s + n.length;
    }
  }
}
class fA {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new _l());
  }
  getActions(e) {
    let t = 0, i = null, { parser: o } = e.p, { tokenizers: n } = o, s = o.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), a = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < n.length; u++) {
      if (!(1 << u & s))
        continue;
      let h = n[u], c = this.tokens[u];
      if (!(i && !h.fallback) && ((h.contextual || c.start != e.pos || c.mask != s || c.context != a) && (this.updateCachedToken(c, h, e), c.mask = s, c.context = a), c.lookAhead > c.end + 25 && (l = Math.max(c.lookAhead, l)), c.value != 0)) {
        let d = t;
        if (c.extended > -1 && (t = this.addActions(e, c.extended, c.end, t)), t = this.addActions(e, c.value, c.end, t), !h.extend && (i = c, t > d))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !i && e.pos == this.stream.end && (i = new _l(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new _l(), { pos: i, p: o } = e;
    return t.start = i, t.end = Math.min(i + 1, o.stream.end), t.value = i == o.stream.end ? o.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    let o = this.stream.clipPos(i.pos);
    if (t.token(this.stream.reset(o, e), i), e.value > -1) {
      let { parser: n } = i.p;
      for (let s = 0; s < n.specialized.length; s++)
        if (n.specialized[s] == e.value) {
          let a = n.specializers[s](this.stream.read(e.start, e.end), i);
          if (a >= 0 && i.p.parser.dialect.allows(a >> 1)) {
            a & 1 ? e.extended = a >> 1 : e.value = a >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(o + 1);
  }
  putAction(e, t, i, o) {
    for (let n = 0; n < o; n += 3)
      if (this.actions[n] == e)
        return o;
    return this.actions[o++] = e, this.actions[o++] = t, this.actions[o++] = i, o;
  }
  addActions(e, t, i, o) {
    let { state: n } = e, { parser: s } = e.p, { data: a } = s;
    for (let l = 0; l < 2; l++)
      for (let u = s.stateSlot(
        n,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (a[u] == 65535)
          if (a[u + 1] == 1)
            u = tr(a, u + 2);
          else {
            o == 0 && a[u + 1] == 2 && (o = this.putAction(tr(a, u + 2), t, i, o));
            break;
          }
        a[u] == t && (o = this.putAction(tr(a, u + 1), t, i, o));
      }
    return o;
  }
}
var bO;
(function(r) {
  r[r.Distance = 5] = "Distance", r[r.MaxRemainingPerStep = 3] = "MaxRemainingPerStep", r[r.MinBufferLengthPrune = 500] = "MinBufferLengthPrune", r[r.ForceReduceLimit = 10] = "ForceReduceLimit", r[r.CutDepth = 15e3] = "CutDepth", r[r.CutTo = 9e3] = "CutTo", r[r.MaxLeftAssociativeReductionCount = 300] = "MaxLeftAssociativeReductionCount", r[r.MaxStackCount = 12] = "MaxStackCount";
})(bO || (bO = {}));
class pA {
  constructor(e, t, i, o) {
    this.parser = e, this.input = t, this.ranges = o, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new hA(t, o), this.tokens = new fA(e, this.stream), this.topTerm = e.top[1];
    let { from: n } = o[0];
    this.stacks = [Ru.start(this, e.top[0], n)], this.fragments = i.length && this.stream.end - n > e.bufferLength * 4 ? new dA(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], o, n;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [s] = e;
      for (; s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let s = 0; s < e.length; s++) {
      let a = e[s];
      for (; ; ) {
        if (this.tokens.mainToken = null, a.pos > t)
          i.push(a);
        else {
          if (this.advanceStack(a, i, e))
            continue;
          {
            o || (o = [], n = []), o.push(a);
            let l = this.tokens.getMainToken(a);
            n.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let s = o && mA(o);
      if (s)
        return this.stackToTree(s);
      if (this.parser.strict)
        throw pi && o && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && o) {
      let s = this.stoppedAt != null && o[0].pos > this.stoppedAt ? o[0] : this.runRecovery(o, n, i);
      if (s)
        return this.stackToTree(s.forceAll());
    }
    if (this.recovering) {
      let s = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > s)
        for (i.sort((a, l) => l.score - a.score); i.length > s; )
          i.pop();
      i.some((a) => a.reducePos > t) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let s = 0; s < i.length - 1; s++) {
          let a = i[s];
          for (let l = s + 1; l < i.length; l++) {
            let u = i[l];
            if (a.sameState(u) || a.buffer.length > 500 && u.buffer.length > 500)
              if ((a.score - u.score || a.buffer.length - u.buffer.length) > 0)
                i.splice(l--, 1);
              else {
                i.splice(s--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let s = 1; s < i.length; s++)
      i[s].pos < this.minStackPos && (this.minStackPos = i[s].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let o = e.pos, { parser: n } = this, s = pi ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && o > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, h = u ? e.curContext.hash : 0;
      for (let c = this.fragments.nodeAt(o); c; ) {
        let d = this.parser.nodeSet.types[c.type.id] == c.type ? n.getGoto(e.state, c.type.id) : -1;
        if (d > -1 && c.length && (!u || (c.prop(he.contextHash) || 0) == h))
          return e.useNode(c, d), pi && console.log(s + this.stackID(e) + ` (via reuse of ${n.getName(c.type.id)})`), !0;
        if (!(c instanceof Xe) || c.children.length == 0 || c.positions[0] > 0)
          break;
        let f = c.children[0];
        if (f instanceof Xe && c.positions[0] == 0)
          c = f;
        else
          break;
      }
    }
    let a = n.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (a > 0)
      return e.reduce(a), pi && console.log(s + this.stackID(e) + ` (via always-reduce ${n.getName(
        a & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let h = l[u++], c = l[u++], d = l[u++], f = u == l.length || !i, p = f ? e : e.split();
      if (p.apply(h, c, d), pi && console.log(s + this.stackID(p) + ` (via ${h & 65536 ? `reduce of ${n.getName(
        h & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${n.getName(c)} @ ${o}${p == e ? "" : ", split"})`), f)
        return !0;
      p.pos > o ? t.push(p) : i.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return OO(e, t), !0;
    }
  }
  runRecovery(e, t, i) {
    let o = null, n = !1;
    for (let s = 0; s < e.length; s++) {
      let a = e[s], l = t[s << 1], u = t[(s << 1) + 1], h = pi ? this.stackID(a) + " -> " : "";
      if (a.deadEnd && (n || (n = !0, a.restart(), pi && console.log(h + this.stackID(a) + " (restarted)"), this.advanceFully(a, i))))
        continue;
      let c = a.split(), d = h;
      for (let f = 0; c.forceReduce() && f < 10 && (pi && console.log(d + this.stackID(c) + " (via force-reduce)"), !this.advanceFully(c, i)); f++)
        pi && (d = this.stackID(c) + " -> ");
      for (let f of a.recoverByInsert(l))
        pi && console.log(h + this.stackID(f) + " (via recover-insert)"), this.advanceFully(f, i);
      this.stream.end > a.pos ? (u == a.pos && (u++, l = 0), a.recoverByDelete(l, u), pi && console.log(h + this.stackID(a) + ` (via recover-delete ${this.parser.getName(l)})`), OO(a, i)) : (!o || o.score < a.score) && (o = a);
    }
    return o;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), Xe.build({
      buffer: _u.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (yc || (yc = /* @__PURE__ */ new WeakMap())).get(e);
    return t || yc.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function OO(r, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == r.pos && i.sameState(r)) {
      e[t].score < r.score && (e[t] = r);
      return;
    }
  }
  e.push(r);
}
class gA {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const xc = (r) => r;
class L1 {
  /// Define a context tracker.
  constructor(e) {
    this.start = e.start, this.shift = e.shift || xc, this.reduce = e.reduce || xc, this.reuse = e.reuse || xc, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class cr extends dx {
  /// @internal
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let a = 0; a < e.repeatNodeCount; a++)
      t.push("");
    let i = Object.keys(e.topRules).map((a) => e.topRules[a][1]), o = [];
    for (let a = 0; a < t.length; a++)
      o.push([]);
    function n(a, l, u) {
      o[a].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let a of e.nodeProps) {
        let l = a[0];
        typeof l == "string" && (l = he[l]);
        for (let u = 1; u < a.length; ) {
          let h = a[u++];
          if (h >= 0)
            n(h, l, a[u++]);
          else {
            let c = a[u + -h];
            for (let d = -h; d > 0; d--)
              n(a[u++], l, c);
            u++;
          }
        }
      }
    this.nodeSet = new $p(t.map((a, l) => Et.define({
      name: l >= this.minRepeatTerm ? void 0 : a,
      id: l,
      props: o[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = ux;
    let s = ws(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let a = 0; a < this.specializerSpecs.length; a++)
      this.specialized[a] = this.specializerSpecs[a].term;
    this.specializers = this.specializerSpecs.map(vO), this.states = ws(e.states, Uint32Array), this.data = ws(e.stateData), this.goto = ws(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((a) => typeof a == "number" ? new xn(s, a) : a), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let o = new pA(this, e, t, i);
    for (let n of this.wrappers)
      o = n(o, e, t, i);
    return o;
  }
  /// Get a goto table entry @internal
  getGoto(e, t, i = !1) {
    let o = this.goto;
    if (t >= o[0])
      return -1;
    for (let n = o[t + 1]; ; ) {
      let s = o[n++], a = s & 1, l = o[n++];
      if (a && i)
        return l;
      for (let u = n + (s >> 1); n < u; n++)
        if (o[n] == e)
          return l;
      if (a)
        return -1;
    }
  }
  /// Check if this state has an action for a given terminal @internal
  hasAction(e, t) {
    let i = this.data;
    for (let o = 0; o < 2; o++)
      for (let n = this.stateSlot(
        e,
        o ? 2 : 1
        /* ParseState.Actions */
      ), s; ; n += 3) {
        if ((s = i[n]) == 65535)
          if (i[n + 1] == 1)
            s = i[n = tr(i, n + 2)];
          else {
            if (i[n + 1] == 2)
              return tr(i, n + 2);
            break;
          }
        if (s == t || s == 0)
          return tr(i, n + 1);
      }
    return 0;
  }
  /// @internal
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /// @internal
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /// @internal
  validAction(e, t) {
    return !!this.allActions(e, (i) => i == t ? !0 : null);
  }
  /// @internal
  allActions(e, t) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), o = i ? t(i) : void 0;
    for (let n = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); o == null; n += 3) {
      if (this.data[n] == 65535)
        if (this.data[n + 1] == 1)
          n = tr(this.data, n + 2);
        else
          break;
      o = t(tr(this.data, n + 1));
    }
    return o;
  }
  /// Get the states that can follow this one through shift actions or
  /// goto jumps. @internal
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = tr(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let o = this.data[i + 1];
        t.some((n, s) => s & 1 && n == o) || t.push(this.data[i], o);
      }
    }
    return t;
  }
  /// Configure the parser. Returns a new parser instance that has the
  /// given settings modified. Settings not provided in `config` are
  /// kept from the original parser.
  configure(e) {
    let t = Object.assign(Object.create(cr.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let o = e.tokenizers.find((n) => n.from == i);
      return o ? o.to : i;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((i, o) => {
      let n = e.specializers.find((a) => a.from == i.external);
      if (!n)
        return i;
      let s = Object.assign(Object.assign({}, i), { external: n.to });
      return t.specializers[o] = vO(s), s;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /// Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  /// are registered for this parser.
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /// Returns the name associated with a given term. This will only
  /// work for all terms when the parser was generated with the
  /// `--names` option. By default, only the names of tagged terms are
  /// stored.
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /// The eof term id is always allocated directly after the node
  /// types. @internal
  get eofTerm() {
    return this.maxNode + 1;
  }
  /// The type of top node produced by the parser.
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /// @internal
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /// @internal
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => !1);
    if (e)
      for (let n of e.split(" ")) {
        let s = t.indexOf(n);
        s >= 0 && (i[s] = !0);
      }
    let o = null;
    for (let n = 0; n < t.length; n++)
      if (!i[n])
        for (let s = this.dialects[t[n]], a; (a = this.data[s++]) != 65535; )
          (o || (o = new Uint8Array(this.maxTerm + 1)))[a] = 1;
    return new gA(e, i, o);
  }
  /// Used by the output of the parser generator. Not available to
  /// user code. @hide
  static deserialize(e) {
    return new cr(e);
  }
}
function tr(r, e) {
  return r[e] | r[e + 1] << 16;
}
function mA(r) {
  let e = null;
  for (let t of r) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function vO(r) {
  if (r.external) {
    let e = r.extend ? 1 : 0;
    return (t, i) => r.external(t, i) << 1 | e;
  }
  return r.get;
}
const bA = Uo({
  null: O.null,
  instanceof: O.operatorKeyword,
  this: O.self,
  "new super assert open to with void": O.keyword,
  "class interface extends implements enum var": O.definitionKeyword,
  "module package import": O.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": O.controlKeyword,
  ["requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws"]: O.modifier,
  IntegerLiteral: O.integer,
  FloatingPointLiteral: O.float,
  "StringLiteral TextBlock": O.string,
  CharacterLiteral: O.character,
  LineComment: O.lineComment,
  BlockComment: O.blockComment,
  BooleanLiteral: O.bool,
  PrimitiveType: O.standard(O.typeName),
  TypeName: O.typeName,
  Identifier: O.variableName,
  "MethodName/Identifier": O.function(O.variableName),
  Definition: O.definition(O.variableName),
  ArithOp: O.arithmeticOperator,
  LogicOp: O.logicOperator,
  BitOp: O.bitwiseOperator,
  CompareOp: O.compareOperator,
  AssignOp: O.definitionOperator,
  UpdateOp: O.updateOperator,
  Asterisk: O.punctuation,
  Label: O.labelName,
  "( )": O.paren,
  "[ ]": O.squareBracket,
  "{ }": O.brace,
  ".": O.derefOperator,
  ", ;": O.separator
}), OA = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 236, open: 265, module: 267, requires: 272, transitive: 274, exports: 276, to: 278, opens: 280, uses: 282, provides: 284, with: 286, package: 290, import: 294, if: 306, else: 308, while: 312, for: 316, var: 323, assert: 330, switch: 334, case: 340, do: 344, break: 348, continue: 352, return: 356, throw: 362, try: 366, catch: 370, finally: 378 }, vA = cr.deserialize({
  version: 14,
  states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
  stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
  goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
  nodeNames: "⚠ LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
  maxTerm: 274,
  nodeProps: [
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [bA],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "#$`_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixy@zyzAhz{BU{|Bz|}Db}!OEO!O!PFi!P!Q! c!Q!R!,X!R![!0P![!]!>a!]!^!?q!^!_!@_!_!`!Ax!`!a!Bl!a!b!DY!b!c!Dx!c!}!Kt!}#O!MQ#O#P%Q#P#Q!Mn#Q#R!N[#R#S4e#S#T%Q#T#o4e#o#p# O#p#q# l#q#r##U#r#s##r#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&WSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&WS%wZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&WS%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#sP&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&WSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&WSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&WSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&USXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&VP_4la%}Z&WSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#gQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&lR&WSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&WSOY9aYZ%lZr9ars:Xsw9awx%Qx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT9fZ&WSOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT:[ZOY:}YZ%lZr:}rs>zsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T;QZOY9aYZ%lZr9ars:Xsw9awx;sx#O9a#O#P<a#P;'S9a;'S;=`>t<%lO9aT;zVbP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<fV&WSOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT=QW&WSOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP=mWOY=jZw=jwx>Vx#O=j#O#P>[#P;'S=j;'S;=`>n<%lO=jP>[ObPP>_TOY=jYZ=jZ;'S=j;'S;=`>n<%lO=jP>qP;=`<%l=jT>wP;=`<%l9aT>}ZOY:}YZ%lZr:}rs=jsw:}wx?px#O:}#O#P@[#P;'S:};'S;=`@t<%lO:}T?uVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT@_VOY9aYZ<{Zr9ars:Xs;'S9a;'S;=`>t<%lO9aT@wP;=`<%l:}_ARVZZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAoVYR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVB_X$YP&WS#fQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCRZ#eR&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ct|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVC{V#qR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDiVqR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVEV[#eR&WSOY%QYZ%lZr%Qrs%qs}%Q}!OCt!O!_%Q!_!`6e!`!aE{!a;'S%Q;'S;=`&s<%lO%QVFSV&vR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FpZWY&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGc!P!Q%Q!Q![Hq![;'S%Q;'S;=`&s<%lO%QVGhX&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHT!P;'S%Q;'S;=`&s<%lO%QVH[V&oR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTHxc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#R%Q#R#SNk#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTJ[V&WS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJv]&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ko|}%Q}!OKo!O!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTKtX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![;'S%Q;'S;=`&s<%lO%QTLhc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![!f%Q!f!gJT!g!h%Q!h!iJT!i#R%Q#R#SMs#S#W%Q#W#XJT#X#Y%Q#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QTMxZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![La![#R%Q#R#SMs#S;'S%Q;'S;=`&s<%lO%QTNpZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![#R%Q#R#SNk#S;'S%Q;'S;=`&s<%lO%Q_! j]&WS#fQOY%QYZ%lZr%Qrs%qsz%Qz{!!c{!P%Q!P!Q!)U!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_!!hX&WSOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{;'S!!c;'S;=`!'d<%lO!!c_!#YT&WSOz!#iz{!#{{;'S!#i;'S;=`!$j<%lO!#iZ!#lTOz!#iz{!#{{;'S!#i;'S;=`!$j<%lO!#iZ!$OVOz!#iz{!#{{!P!#i!P!Q!$e!Q;'S!#i;'S;=`!$j<%lO!#iZ!$jOQZZ!$mP;=`<%l!#i_!$sXOY!%`YZ!#TZr!%`rs!'jsz!%`z{!(Y{;'S!%`;'S;=`!)O<%lO!%`_!%cXOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{;'S!!c;'S;=`!'d<%lO!!c_!&TZ&WSOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{!P!!c!P!Q!&v!Q;'S!!c;'S;=`!'d<%lO!!c_!&}V&WSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!'gP;=`<%l!!c_!'mXOY!%`YZ!#TZr!%`rs!#isz!%`z{!(Y{;'S!%`;'S;=`!)O<%lO!%`_!(]ZOY!!cYZ!#TZr!!crs!$psz!!cz{!&O{!P!!c!P!Q!&v!Q;'S!!c;'S;=`!'d<%lO!!c_!)RP;=`<%l!%`_!)]V&WSPZOY!)UYZ%lZr!)Urs!)rs;'S!)U;'S;=`!*x<%lO!)U_!)wVPZOY!*^YZ%lZr!*^rs!+Os;'S!*^;'S;=`!,R<%lO!*^_!*cVPZOY!)UYZ%lZr!)Urs!)rs;'S!)U;'S;=`!*x<%lO!)U_!*{P;=`<%l!)U_!+TVPZOY!*^YZ%lZr!*^rs!+js;'S!*^;'S;=`!,R<%lO!*^Z!+oSPZOY!+jZ;'S!+j;'S;=`!+{<%lO!+jZ!,OP;=`<%l!+j_!,UP;=`<%l!*^T!,`u&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.s!P!Q%Q!Q![!0P![!d%Q!d!e!3Z!e!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!1u!o!q%Q!q!r!5X!r!z%Q!z!{!7P!{#R%Q#R#S!2c#S#U%Q#U#V!3Z#V#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!1u#a#c%Q#c#d!5X#d#l%Q#l#m!7P#m;'S%Q;'S;=`&s<%lO%QT!.za&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hq![!f%Q!f!gJT!g!hJq!h!iJT!i#W%Q#W#XJT#X#YJq#Y#ZJT#Z;'S%Q;'S;=`&s<%lO%QT!0Wi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.s!P!Q%Q!Q![!0P![!f%Q!f!gJT!g!hJq!h!iJT!i!n%Q!n!o!1u!o#R%Q#R#S!2c#S#W%Q#W#XJT#X#YJq#Y#ZJT#Z#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!1|V&WS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!2hZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!0P![#R%Q#R#S!2c#S;'S%Q;'S;=`&s<%lO%QT!3`Y&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4O!R!S!4O!S;'S%Q;'S;=`&s<%lO%QT!4V`&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4O!R!S!4O!S!n%Q!n!o!1u!o#R%Q#R#S!3Z#S#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!5^X&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!5y!Y;'S%Q;'S;=`&s<%lO%QT!6Q_&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!5y!Y!n%Q!n!o!1u!o#R%Q#R#S!5X#S#`%Q#`#a!1u#a;'S%Q;'S;=`&s<%lO%QT!7U_&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!8T!P!Q%Q!Q![!:c![!c%Q!c!i!:c!i#T%Q#T#Z!:c#Z;'S%Q;'S;=`&s<%lO%QT!8Y]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i#T%Q#T#Z!9R#Z;'S%Q;'S;=`&s<%lO%QT!9Wc&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i!r%Q!r!sJq!s#R%Q#R#S!8T#S#T%Q#T#Z!9R#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!:ji&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!<X!P!Q%Q!Q![!:c![!c%Q!c!i!:c!i!n%Q!n!o!1u!o!r%Q!r!sJq!s#R%Q#R#S!=c#S#T%Q#T#Z!:c#Z#`%Q#`#a!1u#a#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!<^a&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9R![!c%Q!c!i!9R!i!r%Q!r!sJq!s#T%Q#T#Z!9R#Z#d%Q#d#eJq#e;'S%Q;'S;=`&s<%lO%QT!=h]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!:c![!c%Q!c!i!:c!i#T%Q#T#Z!:c#Z;'S%Q;'S;=`&s<%lO%QV!>hX#oR&WSOY%QYZ%lZr%Qrs%qs![%Q![!]!?T!];'S%Q;'S;=`&s<%lO%QV!?[V&tR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!?xV!PR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!@fY&]Z&WSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!AU!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!A]X#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!BPX!bR&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!BsY&[R&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!Cc!a;'S%Q;'S;=`&s<%lO%QU!CjY#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!AU!a;'S%Q;'S;=`&s<%lO%Q_!DcV&`X#nQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!EPX%{Z&WSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!El#^;'S%Q;'S;=`&s<%lO%QV!EqX&WSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!F^#c;'S%Q;'S;=`&s<%lO%QV!FcX&WSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!GO#i;'S%Q;'S;=`&s<%lO%QV!GTX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Gp#Y;'S%Q;'S;=`&s<%lO%QV!GuX&WSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!Hb#g;'S%Q;'S;=`&s<%lO%QV!HgX&WSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!IS#Z;'S%Q;'S;=`&s<%lO%QV!IXX&WSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!It#U;'S%Q;'S;=`&s<%lO%QV!IyX&WSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Jf#W;'S%Q;'S;=`&s<%lO%QV!JkX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!KW#Y;'S%Q;'S;=`&s<%lO%QV!K_V&rR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!K{a&PZ&WSOY%QYZ%lZr%Qrs%qst%Qtu!Ktu!Q%Q!Q![!Kt![!c%Q!c!}!Kt!}#R%Q#R#S!Kt#S#T%Q#T#o!Kt#o;'S%Q;'S;=`&s<%lO%Q_!MXVuZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!MuVsR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!NcX#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV# VV}R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_# uZ&|X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q#!h#q;'S%Q;'S;=`&s<%lO%QU#!oV#dQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV##]V|R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT##yV#tP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3] },
  dynamicPrecedences: { 27: 1, 230: -1, 241: -1 },
  specialized: [{ term: 229, get: (r) => OA[r] || -1 }],
  tokenPrec: 7067
}), wA = /* @__PURE__ */ hr.define({
  parser: /* @__PURE__ */ vA.configure({
    props: [
      /* @__PURE__ */ Yo.add({
        IfStatement: /* @__PURE__ */ Yi({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Yi({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: vx,
        SwitchBlock: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : i ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ bx({ closing: "}" }),
        BlockComment: () => -1,
        Statement: /* @__PURE__ */ Yi({ except: /^{/ })
      }),
      /* @__PURE__ */ Fo.add({
        ["Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer"]: mh,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function yA() {
  return new qn(wA);
}
const wO = 302, yO = 1, xA = 2, xO = 303, SA = 305, CA = 306, QA = 3, PA = 4, kA = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], W1 = 125, EA = 59, SO = 47, TA = 42, $A = 43, RA = 45, _A = new L1({
  start: !1,
  shift(r, e) {
    return e == QA || e == PA || e == SA ? r : e == CA;
  },
  strict: !1
}), DA = new Ci((r, e) => {
  let { next: t } = r;
  (t == W1 || t == -1 || e.context) && e.canShift(xO) && r.acceptToken(xO);
}, { contextual: !0, fallback: !0 }), MA = new Ci((r, e) => {
  let { next: t } = r, i;
  kA.indexOf(t) > -1 || t == SO && ((i = r.peek(1)) == SO || i == TA) || t != W1 && t != EA && t != -1 && !e.context && e.canShift(wO) && r.acceptToken(wO);
}, { contextual: !0 }), XA = new Ci((r, e) => {
  let { next: t } = r;
  if ((t == $A || t == RA) && (r.advance(), t == r.next)) {
    r.advance();
    let i = !e.context && e.canShift(yO);
    r.acceptToken(i ? yO : xA);
  }
}, { contextual: !0 }), AA = Uo({
  "get set async static": O.modifier,
  "for while do if else switch try catch finally return throw break continue default case": O.controlKeyword,
  "in of await yield void typeof delete instanceof": O.operatorKeyword,
  "let var const function class extends": O.definitionKeyword,
  "import export from": O.moduleKeyword,
  "with debugger as new": O.keyword,
  TemplateString: O.special(O.string),
  super: O.atom,
  BooleanLiteral: O.bool,
  this: O.self,
  null: O.null,
  Star: O.modifier,
  VariableName: O.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": O.function(O.variableName),
  VariableDefinition: O.definition(O.variableName),
  Label: O.labelName,
  PropertyName: O.propertyName,
  PrivatePropertyName: O.special(O.propertyName),
  "CallExpression/MemberExpression/PropertyName": O.function(O.propertyName),
  "FunctionDeclaration/VariableDefinition": O.function(O.definition(O.variableName)),
  "ClassDeclaration/VariableDefinition": O.definition(O.className),
  PropertyDefinition: O.definition(O.propertyName),
  PrivatePropertyDefinition: O.definition(O.special(O.propertyName)),
  UpdateOp: O.updateOperator,
  LineComment: O.lineComment,
  BlockComment: O.blockComment,
  Number: O.number,
  String: O.string,
  Escape: O.escape,
  ArithOp: O.arithmeticOperator,
  LogicOp: O.logicOperator,
  BitOp: O.bitwiseOperator,
  CompareOp: O.compareOperator,
  RegExp: O.regexp,
  Equals: O.definitionOperator,
  Arrow: O.function(O.punctuation),
  ": Spread": O.punctuation,
  "( )": O.paren,
  "[ ]": O.squareBracket,
  "{ }": O.brace,
  "InterpolationStart InterpolationEnd": O.special(O.brace),
  ".": O.derefOperator,
  ", ;": O.separator,
  "@": O.meta,
  TypeName: O.typeName,
  TypeDefinition: O.definition(O.typeName),
  "type enum interface implements namespace module declare": O.definitionKeyword,
  "abstract global Privacy readonly override": O.modifier,
  "is keyof unique infer": O.operatorKeyword,
  JSXAttributeValue: O.attributeValue,
  JSXText: O.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": O.angleBracket,
  "JSXIdentifier JSXNameSpacedName": O.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": O.attributeName,
  "JSXBuiltin/JSXIdentifier": O.standard(O.tagName)
}), zA = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 221, private: 221, protected: 221, readonly: 223, instanceof: 242, satisfies: 245, in: 246, const: 248, import: 280, keyof: 335, unique: 339, infer: 345, is: 381, abstract: 401, implements: 403, type: 405, let: 408, var: 410, interface: 417, enum: 421, namespace: 427, module: 429, declare: 433, global: 437, for: 456, of: 465, while: 468, with: 472, do: 476, if: 480, else: 482, switch: 486, case: 492, try: 498, catch: 502, finally: 506, return: 510, throw: 514, break: 518, continue: 522, debugger: 526 }, NA = { __proto__: null, async: 117, get: 119, set: 121, declare: 181, public: 183, private: 183, protected: 183, static: 185, abstract: 187, override: 189, readonly: 195, accessor: 197, new: 385 }, VA = { __proto__: null, "<": 137 }, ZA = cr.deserialize({
  version: 14,
  states: "$6[O`QUOOO%QQUOOO'TQWOOP(bOSOOO*pQ(CjO'#CfO*wOpO'#CgO+VO!bO'#CgO+eO07`O'#DZO-vQUO'#DaO.WQUO'#DlO%QQUO'#DvO0[QUO'#EOOOQ(CY'#EW'#EWO0uQSO'#ETOOQO'#Ei'#EiOOQO'#Ib'#IbO0}QSO'#GkO1YQSO'#EhO1_QSO'#EhO3aQ(CjO'#JcO6QQ(CjO'#JdO6nQSO'#FWO6sQ#tO'#FoOOQ(CY'#F`'#F`O7OO&jO'#F`O7^Q,UO'#FvO8tQSO'#FuOOQ(CY'#Jd'#JdOOQ(CW'#Jc'#JcOOQQ'#KO'#KOO8yQSO'#IOO9OQ(C[O'#IPOOQQ'#JP'#JPOOQQ'#IT'#ITQ`QUOOO%QQUO'#DnO9WQUO'#DzO%QQUO'#D|O9_QSO'#GkO9dQ,UO'#ClO9rQSO'#EgO9}QSO'#ErO:SQ,UO'#F_O:qQSO'#GkO:vQSO'#GoO;RQSO'#GoO;aQSO'#GrO;aQSO'#GsO;aQSO'#GuO9_QSO'#GxO<QQSO'#G{O=cQSO'#CbO=sQSO'#HXO={QSO'#H_O={QSO'#HaO`QUO'#HcO={QSO'#HeO={QSO'#HhO>QQSO'#HnO>VQ(C]O'#HtO%QQUO'#HvO>bQ(C]O'#HxO>mQ(C]O'#HzO9OQ(C[O'#H|O>xQ(CjO'#CfO?zQWO'#DfQOQSOOO@bQSO'#EPO9dQ,UO'#EgO@mQSO'#EgO@xQ`O'#F_OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jg'#JgO%QQUO'#JgOOQO'#Jk'#JkOOQO'#I_'#I_OAxQWO'#E`OOQ(CW'#E_'#E_OBtQ(C`O'#E`OCOQWO'#ESOOQO'#Jj'#JjOCdQWO'#JkODqQWO'#ESOCOQWO'#E`PEOO?MpO'#C`POOO)CDn)CDnOOOO'#IU'#IUOEZOpO,59ROOQ(CY,59R,59ROOOO'#IV'#IVOEiO!bO,59RO%QQUO'#D]OOOO'#IX'#IXOEwO07`O,59uOOQ(CY,59u,59uOFVQUO'#IYOFjQSO'#JeOHlQbO'#JeO+sQUO'#JeOHsQSO,59{OIZQSO'#EiOIhQSO'#JsOIsQSO'#JrOIsQSO'#JrOI{QSO,5;VOJQQSO'#JqOOQ(CY,5:W,5:WOJXQUO,5:WOLYQ(CjO,5:bOLyQSO,5:jOMdQ(C[O'#JpOMkQSO'#JoO:vQSO'#JoONPQSO'#JoONXQSO,5;UON^QSO'#JoO!!fQbO'#JdOOQ(CY'#Cf'#CfO%QQUO'#EOO!#UQ`O,5:oOOQO'#Jl'#JlOOQO-E<`-E<`O9_QSO,5=VO!#lQSO,5=VO!#qQUO,5;SO!%tQ,UO'#EdO!'XQSO,5;SO!(qQ,UO'#DpO!(xQUO'#DuO!)SQWO,5;]O!)[QWO,5;]O%QQUO,5;]OOQQ'#FO'#FOOOQQ'#FQ'#FQO%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^O%QQUO,5;^OOQQ'#FU'#FUO!)jQUO,5;oOOQ(CY,5;t,5;tOOQ(CY,5;u,5;uO!+mQSO,5;uOOQ(CY,5;v,5;vO%QQUO'#IfO!+uQ(C[O,5<cO!%tQ,UO,5;^O!,dQ,UO,5;^O%QQUO,5;rO!,kQ#tO'#FeO!-hQ#tO'#JwO!-SQ#tO'#JwO!-oQ#tO'#JwOOQO'#Jw'#JwO!.TQ#tO,5;}OOOO,5<Z,5<ZO!.fQUO'#FqOOOO'#Ie'#IeO7OO&jO,5;zO!.mQ#tO'#FsOOQ(CY,5;z,5;zO!/^Q7[O'#CrOOQ(CY'#Cv'#CvO!/qQSO'#CvO!/vO07`O'#CzO!0dQ,UO,5<`O!0kQSO,5<bO!2QQMhO'#GQO!2_QSO'#GRO!2dQSO'#GRO!2iQMhO'#GVO!3hQWO'#GZO!4ZQ7[O'#J^OOQ(CY'#J^'#J^O!4eQSO'#J]O!4sQSO'#J[O!4{QSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0xQSO'#DSO!'^Q,UO'#FxO!'^Q,UO'#FzO!5TQSO'#F|O!5YQSO'#F}O!2dQSO'#GTO!'^Q,UO'#GYO!5_QSO'#EjO!5|QSO,5<aO`QUO,5>jOOQQ'#JX'#JXOOQQ,5>k,5>kOOQQ-E<R-E<RO!7{Q(CjO,5:YO!:iQ(CjO,5:fO%QQUO,5:fO!=SQ(CjO,5:hOOQ(CW'#Co'#CoO!=sQ,UO,5=VO!>RQ(C[O'#JYO8tQSO'#JYO!>dQ(C[O,59WO!>oQWO,59WO!>wQ,UO,59WO9dQ,UO,59WO!?SQSO,5;SO!?[QSO'#HWO!?mQSO'#KSO%QQUO,5;wO!?uQWO,5;yO!?zQSO,5=qO!@PQSO,5=qO!@UQSO,5=qO9OQ(C[O,5=qO!@dQSO'#EkO!A^QWO'#ElOOQ(CW'#Jq'#JqO!AeQ(C[O'#KPO9OQ(C[O,5=ZO;aQSO,5=aOOQO'#Cr'#CrO!ApQWO,5=^O!AxQ,UO,5=_O!BTQSO,5=aO!BYQ`O,5=dO>QQSO'#G}O9_QSO'#HPO!BbQSO'#HPO9dQ,UO'#HRO!BgQSO'#HROOQQ,5=g,5=gO!BlQSO'#HSO!BtQSO'#ClO!ByQSO,58|O!CTQSO,58|O!E]QUO,58|OOQQ,58|,58|O!EjQ(C[O,58|O%QQUO,58|O!EuQUO'#HZOOQQ'#H['#H[OOQQ'#H]'#H]O`QUO,5=sO!FVQSO,5=sO`QUO,5=yO`QUO,5={O!F[QSO,5=}O`QUO,5>PO!FaQSO,5>SO!FfQUO,5>YOOQQ,5>`,5>`O%QQUO,5>`O9OQ(C[O,5>bOOQQ,5>d,5>dO!JmQSO,5>dOOQQ,5>f,5>fO!JmQSO,5>fOOQQ,5>h,5>hO!JrQWO'#DXO%QQUO'#JgO!KaQWO'#JgO!LOQWO'#DgO!LaQWO'#DgO!NrQUO'#DgO!NyQSO'#JfO# RQSO,5:QO# WQSO'#EmO# fQSO'#JtO# nQSO,5;WO# sQWO'#DgO#!QQWO'#EROOQ(CY,5:k,5:kO%QQUO,5:kO#!XQSO,5:kO>QQSO,5;RO!>oQWO,5;RO!>wQ,UO,5;RO9dQ,UO,5;RO#!aQSO,5@RO#!fQ!LQO,5:oOOQO-E<]-E<]O##lQ(C`O,5:zOCOQWO,5:nO##vQWO,5:nOCOQWO,5:zO!>dQ(C[O,5:nOOQ(CW'#Ec'#EcOOQO,5:z,5:zO%QQUO,5:zO#$TQ(C[O,5:zO#$`Q(C[O,5:zO!>oQWO,5:nOOQO,5;Q,5;QO#$nQ(C[O,5:zPOOO'#IS'#ISP#%SO?MpO,58zPOOO,58z,58zOOOO-E<S-E<SOOQ(CY1G.m1G.mOOOO-E<T-E<TO#%_Q`O,59wOOOO-E<V-E<VOOQ(CY1G/a1G/aO#%dQbO,5>tO+sQUO,5>tOOQO,5>z,5>zO#%nQUO'#IYOOQO-E<W-E<WO#%{QSO,5@PO#&TQbO,5@PO#&[QSO,5@^OOQ(CY1G/g1G/gO%QQUO,5@_O#&dQSO'#I`OOQO-E<^-E<^O#&[QSO,5@^OOQ(CW1G0q1G0qOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO%QQUO,5@[O#&xQ(C[O,5@[O#'ZQ(C[O,5@[O#'bQSO,5@ZO:vQSO,5@ZO#'jQSO,5@ZO#'xQSO'#IcO#'bQSO,5@ZOOQ(CW1G0p1G0pO!)SQWO,5:qO!)_QWO,5:qOOQO,5:s,5:sO#(jQSO,5:sO#(rQ,UO1G2qO9_QSO1G2qOOQ(CY1G0n1G0nO#)QQ(CjO1G0nO#*VQ(ChO,5;OOOQ(CY'#GP'#GPO#*sQ(CjO'#J^O!#qQUO1G0nO#,{Q,UO'#JhO#-VQSO,5:[O#-[QbO'#JiO%QQUO'#JiO#-fQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0w1G0wO%QQUO1G0wOOQ(CY1G1a1G1aO#-kQSO1G0wO#0SQ(CjO1G0xO#0ZQ(CjO1G0xO#2tQ(CjO1G0xO#2{Q(CjO1G0xO#5VQ(CjO1G0xO#5mQ(CjO1G0xO#8gQ(CjO1G0xO#8nQ(CjO1G0xO#;XQ(CjO1G0xO#;`Q(CjO1G0xO#=WQ(CjO1G0xO#@WQ$IUO'#CfO#BUQ$IUO1G1ZO#B]Q$IUO'#JdO!+pQSO1G1aO#BmQ(CjO,5?QOOQ(CW-E<d-E<dO#CaQ(CjO1G0xOOQ(CY1G0x1G0xO#ElQ(CjO1G1^O#F`Q#tO,5<RO#FhQ#tO,5<SO#FpQ#tO'#FjO#GXQSO'#FiOOQO'#Jx'#JxOOQO'#Id'#IdO#G^Q#tO1G1iOOQ(CY1G1i1G1iOOOO1G1t1G1tO#GoQ$IUO'#JcO#GyQSO,5<]O!)jQUO,5<]OOOO-E<c-E<cOOQ(CY1G1f1G1fO#HOQWO'#JwOOQ(CY,5<_,5<_O#HWQWO,5<_OOQ(CY,59b,59bO!%tQ,UO'#C|OOOO'#IW'#IWO#H]O07`O,59fOOQ(CY,59f,59fO%QQUO1G1zO!5YQSO'#IhO#HhQSO,5<sOOQ(CY,5<p,5<pOOQO'#Gf'#GfO!'^Q,UO,5=POOQO'#Gh'#GhO!'^Q,UO,5=RO!%tQ,UO,5=TOOQO1G1|1G1|O#HvQ`O'#CoO#IZQ`O,5<lO#IbQSO'#J{O9_QSO'#J{O#IpQSO,5<nO!'^Q,UO,5<mO#IuQSO'#GSO#JQQSO,5<mO#JVQ`O'#GPO#JdQ`O'#J|O#JnQSO'#J|O!%tQ,UO'#J|O#JsQSO,5<qO#JxQWO'#G[O!3cQWO'#G[O#KZQSO'#G^O#K`QSO'#G`O!2dQSO'#GcO#KeQ(C[O'#IjO#KpQWO,5<uOOQ(CY,5<u,5<uO#KwQWO'#G[O#LVQWO'#G]O#L_QWO'#G]OOQ(CY,5=U,5=UO!'^Q,UO,5?wO!'^Q,UO,5?wO#LdQSO'#IkO#LoQSO,5?vO#LwQSO,59]O#MhQ,UO,59nOOQ(CY,59n,59nO#NZQ,UO,5<dO#N|Q,UO,5<fO?rQSO,5<hOOQ(CY,5<i,5<iO$ WQSO,5<oO$ ]Q,UO,5<tO$ mQSO'#JoO!#qQUO1G1{O$ rQSO1G1{OOQQ1G4U1G4UOOQ(CY1G/t1G/tO!+mQSO1G/tO$#qQ(CjO1G0QOOQQ1G2q1G2qO!%tQ,UO1G2qO%QQUO1G2qO$$bQSO1G2qO$$mQ,UO'#EdOOQ(CW,5?t,5?tO$$wQ(C[O,5?tOOQQ1G.r1G.rO!>dQ(C[O1G.rO!>oQWO1G.rO!>wQ,UO1G.rO$%YQSO1G0nO$%_QSO'#CfO$%jQSO'#KTO$%rQSO,5=rO$%wQSO'#KTO$%|QSO'#KTO$&XQSO'#IsO$&gQSO,5@nO$&oQbO1G1cOOQ(CY1G1e1G1eO9_QSO1G3]O?rQSO1G3]O$&vQSO1G3]O$&{QSO1G3]OOQQ1G3]1G3]O:vQSO'#JrO:vQSO'#EmO%QQUO'#EmO:vQSO'#ImO$'QQ(C[O,5@kOOQQ1G2u1G2uO!BTQSO1G2{O!%tQ,UO1G2xO$']QSO1G2xOOQQ1G2y1G2yO!%tQ,UO1G2yO$'bQSO1G2yO$'jQWO'#GwOOQQ1G2{1G2{O!3cQWO'#IoO!BYQ`O1G3OOOQQ1G3O1G3OOOQQ,5=i,5=iO$'rQ,UO,5=kO9_QSO,5=kO#K`QSO,5=mO8tQSO,5=mO!>oQWO,5=mO!>wQ,UO,5=mO9dQ,UO,5=mO$(QQSO'#KRO$(]QSO,5=nOOQQ1G.h1G.hO$(bQ(C[O1G.hO?rQSO1G.hO$(mQSO1G.hO9OQ(C[O1G.hO$*rQbO,5@pO$+SQSO,5@pO$+_QUO,5=uO$+fQSO,5=uO:vQSO,5@pOOQQ1G3_1G3_O`QUO1G3_OOQQ1G3e1G3eOOQQ1G3g1G3gO={QSO1G3iO$+kQUO1G3kO$/lQUO'#HjOOQQ1G3n1G3nO$/yQSO'#HpO>QQSO'#HrOOQQ1G3t1G3tO$0RQUO1G3tO9OQ(C[O1G3zOOQQ1G3|1G3|OOQ(CW'#GW'#GWO9OQ(C[O1G4OO9OQ(C[O1G4QO$4VQSO,5@RO!)jQUO,5;XO:vQSO,5;XO>QQSO,5:RO!)jQUO,5:RO!>oQWO,5:RO$4[Q$IUO,5:ROOQO,5;X,5;XO$4fQWO'#IZO$4|QSO,5@QOOQ(CY1G/l1G/lO$5UQWO'#IaO$5`QSO,5@`OOQ(CW1G0r1G0rO!LaQWO,5:ROOQO'#I^'#I^O$5hQWO,5:mOOQ(CY,5:m,5:mO#![QSO1G0VOOQ(CY1G0V1G0VO%QQUO1G0VOOQ(CY1G0m1G0mO>QQSO1G0mO!>oQWO1G0mO!>wQ,UO1G0mOOQ(CW1G5m1G5mO!>dQ(C[O1G0YOOQO1G0f1G0fO%QQUO1G0fO$5oQ(C[O1G0fO$5zQ(C[O1G0fO!>oQWO1G0YOCOQWO1G0YO$6YQ(C[O1G0fOOQO1G0Y1G0YO$6nQ(CjO1G0fPOOO-E<Q-E<QPOOO1G.f1G.fOOOO1G/c1G/cO$6xQ`O,5<cO$7QQbO1G4`OOQO1G4f1G4fO%QQUO,5>tO$7[QSO1G5kO$7dQSO1G5xO$7lQbO1G5yO:vQSO,5>zO$7vQ(CjO1G5vO%QQUO1G5vO$8WQ(C[O1G5vO$8iQSO1G5uO$8iQSO1G5uO:vQSO1G5uO$8qQSO,5>}O:vQSO,5>}OOQO,5>},5>}O$9VQSO,5>}O$ mQSO,5>}OOQO-E<a-E<aOOQO1G0]1G0]OOQO1G0_1G0_O!+pQSO1G0_OOQQ7+(]7+(]O!%tQ,UO7+(]O%QQUO7+(]O$9eQSO7+(]O$9pQ,UO7+(]O$:OQ(CjO,59nO$<WQ(CjO,5<dO$>cQ(CjO,5<fO$@nQ(CjO,5<tOOQ(CY7+&Y7+&YO$CPQ(CjO7+&YO$CsQ,UO'#I[O$C}QSO,5@SOOQ(CY1G/v1G/vO$DVQUO'#I]O$DdQSO,5@TO$DlQbO,5@TOOQ(CY1G/{1G/{O$DvQSO7+&cOOQ(CY7+&c7+&cO$D{Q$IUO,5:bO%QQUO7+&uO$EVQ$IUO,5:YO$EdQ$IUO,5:fO$EnQ$IUO,5:hOOQ(CY7+&{7+&{OOQO1G1m1G1mOOQO1G1n1G1nO$ExQ#tO,5<UO!)jQUO,5<TOOQO-E<b-E<bOOQ(CY7+'T7+'TOOOO7+'`7+'`OOOO1G1w1G1wO$FTQSO1G1wOOQ(CY1G1y1G1yO$FYQ`O,59hOOOO-E<U-E<UOOQ(CY1G/Q1G/QO$FaQ(CjO7+'fOOQ(CY,5?S,5?SO$GTQSO,5?SOOQ(CY1G2_1G2_P$GYQSO'#IhPOQ(CY-E<f-E<fO$G|Q,UO1G2kO$HoQ,UO1G2mO$HyQ`O1G2oOOQ(CY1G2W1G2WO$IQQSO'#IgO$I`QSO,5@gO$I`QSO,5@gO$IhQSO,5@gO$IsQSO,5@gOOQO1G2Y1G2YO$JRQ,UO1G2XO!'^Q,UO1G2XO$JcQMhO'#IiO$JsQSO,5@hO!%tQ,UO,5@hO$J{Q`O,5@hOOQ(CY1G2]1G2]OOQ(CW,5<v,5<vOOQ(CW,5<w,5<wO$ mQSO,5<wOBoQSO,5<wO!>oQWO,5<vOOQO'#G_'#G_O$KVQSO,5<xOOQ(CW,5<z,5<zO$ mQSO,5<}OOQO,5?U,5?UOOQO-E<h-E<hOOQ(CY1G2a1G2aO!3cQWO,5<vO$K_QSO,5<wO#KZQSO,5<xO!3cQWO,5<wO$KjQ,UO1G5cO$KtQ,UO1G5cOOQO,5?V,5?VOOQO-E<i-E<iOOQO1G.w1G.wO!?uQWO,59pO%QQUO,59pO$LRQSO1G2SO!'^Q,UO1G2ZO$LWQ(CjO7+'gOOQ(CY7+'g7+'gO!#qQUO7+'gOOQ(CY7+%`7+%`O$LzQ`O'#J}O#![QSO7+(]O$MUQbO7+(]O$9hQSO7+(]O$M]Q(ChO'#CfO$MpQ(ChO,5<{O$NbQSO,5<{OOQ(CW1G5`1G5`OOQQ7+$^7+$^O!>dQ(C[O7+$^O!>oQWO7+$^O!#qQUO7+&YO$NgQSO'#IrO$N{QSO,5@oOOQO1G3^1G3^O9_QSO,5@oO$N{QSO,5@oO% TQSO,5@oOOQO,5?_,5?_OOQO-E<q-E<qOOQ(CY7+&}7+&}O% YQSO7+(wO9OQ(C[O7+(wO9_QSO7+(wO?rQSO7+(wO% _QSO,5;XOOQ(CW,5?X,5?XOOQ(CW-E<k-E<kOOQQ7+(g7+(gO% dQ(ChO7+(dO!%tQ,UO7+(dO% nQ`O7+(eOOQQ7+(e7+(eO!%tQ,UO7+(eO% uQSO'#KQO%!QQSO,5=cOOQO,5?Z,5?ZOOQO-E<m-E<mOOQQ7+(j7+(jO%#aQWO'#HQOOQQ1G3V1G3VO!%tQ,UO1G3VO%QQUO1G3VO%#hQSO1G3VO%#sQ,UO1G3VO9OQ(C[O1G3XO#K`QSO1G3XO8tQSO1G3XO!>oQWO1G3XO!>wQ,UO1G3XO%$RQSO'#IqO%$^QSO,5@mO%$fQWO,5@mOOQ(CW1G3Y1G3YOOQQ7+$S7+$SO?rQSO7+$SO9OQ(C[O7+$SO%$qQSO7+$SO%QQUO1G6[O%QQUO1G6]O%$vQUO1G3aO%$}QSO1G3aO%%SQUO1G3aO%%ZQ(C[O1G6[OOQQ7+(y7+(yO9OQ(C[O7+)TO`QUO7+)VOOQQ'#KW'#KWOOQQ'#It'#ItO%%eQUO,5>UOOQQ,5>U,5>UO%QQUO'#HkO%%rQSO'#HmOOQQ,5>[,5>[O:vQSO,5>[OOQQ,5>^,5>^OOQQ7+)`7+)`OOQQ7+)f7+)fOOQQ7+)j7+)jOOQQ7+)l7+)lO%%wQWO1G5mO%&]Q$IUO1G0sO%&gQSO1G0sOOQO1G/m1G/mO%&rQ$IUO1G/mO>QQSO1G/mO!)jQUO'#DgOOQO,5>u,5>uOOQO-E<X-E<XOOQO,5>{,5>{OOQO-E<_-E<_O!>oQWO1G/mOOQO-E<[-E<[OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO#![QSO7+%qOOQ(CY7+&X7+&XO>QQSO7+&XO!>oQWO7+&XOOQO7+%t7+%tO$6nQ(CjO7+&QOOQO7+&Q7+&QO%QQUO7+&QO%&|Q(C[O7+&QO!>dQ(C[O7+%tO!>oQWO7+%tO%'XQ(C[O7+&QO%'gQ(CjO7++bO%QQUO7++bO%'wQSO7++aO%'wQSO7++aOOQO1G4i1G4iO:vQSO1G4iO%(PQSO1G4iOOQO7+%y7+%yO#![QSO<<KwO$MUQbO<<KwO%(_QSO<<KwOOQQ<<Kw<<KwO!%tQ,UO<<KwO%QQUO<<KwO%(gQSO<<KwO%(rQ(CjO1G2kO%*}Q(CjO1G2mO%-YQ(CjO1G2XO%/kQ,UO,5>vOOQO-E<Y-E<YO%/uQbO,5>wO%QQUO,5>wOOQO-E<Z-E<ZO%0PQSO1G5oOOQ(CY<<I}<<I}O%0XQ$IUO1G0nO%2cQ$IUO1G0xO%2jQ$IUO1G0xO%4nQ$IUO1G0xO%4uQ$IUO1G0xO%6jQ$IUO1G0xO%7QQ$IUO1G0xO%9eQ$IUO1G0xO%9lQ$IUO1G0xO%;pQ$IUO1G0xO%;wQ$IUO1G0xO%=oQ$IUO1G0xO%>SQ(CjO<<JaO%?XQ$IUO1G0xO%@}Q$IUO'#J^O%CQQ$IUO1G1^O%C_Q$IUO1G0QO!)jQUO'#FlOOQO'#Jy'#JyOOQO1G1p1G1pO%CiQSO1G1oO%CnQ$IUO,5?QOOOO7+'c7+'cOOOO1G/S1G/SOOQ(CY1G4n1G4nO!'^Q,UO7+(ZO%CxQSO,5?RO9_QSO,5?ROOQO-E<e-E<eO%DWQSO1G6RO%DWQSO1G6RO%D`QSO1G6RO%DkQ,UO7+'sO%D{Q`O,5?TO%EVQSO,5?TO!%tQ,UO,5?TOOQO-E<g-E<gO%E[Q`O1G6SO%EfQSO1G6SOOQ(CW1G2c1G2cO$ mQSO1G2cOOQ(CW1G2b1G2bO%EnQSO1G2dO!%tQ,UO1G2dOOQ(CW1G2i1G2iO!>oQWO1G2bOBoQSO1G2cO%EsQSO1G2dO%E{QSO1G2cO!'^Q,UO7+*}OOQ(CY1G/[1G/[O%FWQSO1G/[OOQ(CY7+'n7+'nO%F]Q,UO7+'uO%FmQ(CjO<<KROOQ(CY<<KR<<KRO!%tQ,UO'#IlO%GaQSO,5@iO!%tQ,UO1G2gOOQQ<<Gx<<GxO!>dQ(C[O<<GxO%GiQ(CjO<<ItOOQ(CY<<It<<ItOOQO,5?^,5?^O%H]QSO,5?^O$%|QSO,5?^OOQO-E<p-E<pO%HbQSO1G6ZO%HbQSO1G6ZO9_QSO1G6ZO?rQSO<<LcOOQQ<<Lc<<LcO%HjQSO<<LcO9OQ(C[O<<LcO%HoQSO1G0sOOQQ<<LO<<LOO% dQ(ChO<<LOOOQQ<<LP<<LPO% nQ`O<<LPO%HtQWO'#InO%IPQSO,5@lO!)jQUO,5@lOOQQ1G2}1G2}O%IXQUO'#JgOOQO'#Ip'#IpO9OQ(C[O'#IpO%IcQWO,5=lOOQQ,5=l,5=lO%IjQWO'#E`O%JOQSO7+(qO%JTQSO7+(qOOQQ7+(q7+(qO!%tQ,UO7+(qO%QQUO7+(qO%J]QSO7+(qOOQQ7+(s7+(sO9OQ(C[O7+(sO#K`QSO7+(sO8tQSO7+(sO!>oQWO7+(sO%JhQSO,5?]OOQO-E<o-E<oOOQO'#HT'#HTO%JsQSO1G6XO9OQ(C[O<<GnOOQQ<<Gn<<GnO?rQSO<<GnO%J{QSO7++vO%KQQSO7++wOOQQ7+({7+({O%KVQSO7+({O%K[QUO7+({O%KcQSO7+({O%QQUO7++vO%QQUO7++wOOQQ<<Lo<<LoOOQQ<<Lq<<LqOOQQ-E<r-E<rOOQQ1G3p1G3pO%KhQSO,5>VOOQQ,5>X,5>XO%KmQSO1G3vO:vQSO7+&_O!)jQUO7+&_OOQO7+%X7+%XO%KrQ$IUO1G5yO>QQSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Is<<IsO>QQSO<<IsOOQO<<Il<<IlO$6nQ(CjO<<IlO%QQUO<<IlOOQO<<I`<<I`O!>dQ(C[O<<I`O%K|Q(C[O<<IlO%LXQ(CjO<<N|O%LiQSO<<N{OOQO7+*T7+*TO:vQSO7+*TOOQQANAcANAcO%LqQSOANAcO!%tQ,UOANAcO#![QSOANAcO$MUQbOANAcO%QQUOANAcO%LyQ(CjO7+'sO& [Q(CjO7+'uO&#mQbO1G4cO&#wQ$IUO7+&YO&$UQ$IUO,59nO&&XQ$IUO,5<dO&([Q$IUO,5<fO&*_Q$IUO,5<tO&,TQ$IUO7+'fO&,bQ$IUO7+'gO&,oQSO,5<WOOQO7+'Z7+'ZO&,tQ,UO<<KuOOQO1G4m1G4mO&,{QSO1G4mO&-WQSO1G4mO&-fQSO7++mO&-fQSO7++mO!%tQ,UO1G4oO&-nQ`O1G4oO&-xQSO7++nOOQ(CW7+'}7+'}O$ mQSO7+(OO&.QQ`O7+(OOOQ(CW7+'|7+'|O$ mQSO7+'}O&.XQSO7+(OO!%tQ,UO7+(OOBoQSO7+'}O&.^Q,UO<<NiOOQ(CY7+$v7+$vO&.hQ`O,5?WOOQO-E<j-E<jO&.rQ(ChO7+(ROOQQAN=dAN=dO9_QSO1G4xOOQO1G4x1G4xO&/SQSO1G4xO&/XQSO7++uO&/XQSO7++uO9OQ(C[OANA}O?rQSOANA}OOQQANA}ANA}OOQQANAjANAjOOQQANAkANAkO&/aQSO,5?YOOQO-E<l-E<lO&/lQ$IUO1G6WO&1|QbO'#CfOOQO,5?[,5?[OOQO-E<n-E<nOOQQ1G3W1G3WO%IXQUO,5<xOOQQ<<L]<<L]O!%tQ,UO<<L]O%JOQSO<<L]O&2WQSO<<L]O%QQUO<<L]OOQQ<<L_<<L_O9OQ(C[O<<L_O#K`QSO<<L_O8tQSO<<L_O&2`QWO1G4wO&2kQSO7++sOOQQAN=YAN=YO9OQ(C[OAN=YOOQQ<= b<= bOOQQ<= c<= cOOQQ<<Lg<<LgO&2sQSO<<LgO&2xQUO<<LgO&3PQSO<= bO&3UQSO<= cOOQQ1G3q1G3qO>QQSO7+)bO&3ZQSO<<IyO&3fQ$IUO<<IyOOQO<<Hs<<HsOOQ(CYAN?_AN?_OOQOAN?WAN?WO$6nQ(CjOAN?WOOQOAN>zAN>zO%QQUOAN?WOOQO<<Mo<<MoOOQQG26}G26}O!%tQ,UOG26}O#![QSOG26}O&3pQSOG26}O$MUQbOG26}O&3xQ$IUO<<JaO&4VQ$IUO1G2XO&5{Q$IUO1G2kO&8OQ$IUO1G2mO&:RQ$IUO<<KRO&:`Q$IUO<<ItOOQO1G1r1G1rO!'^Q,UOANAaOOQO7+*X7+*XO&:mQSO7+*XO&:xQSO<= XO&;QQ`O7+*ZOOQ(CW<<Kj<<KjO$ mQSO<<KjOOQ(CW<<Ki<<KiO&;[Q`O<<KjO$ mQSO<<KiOOQO7+*d7+*dO9_QSO7+*dO&;cQSO<= aOOQQG27iG27iO9OQ(C[OG27iO!)jQUO1G4tO&;kQSO7++rO%JOQSOANAwOOQQANAwANAwO!%tQ,UOANAwO&;sQSOANAwOOQQANAyANAyO9OQ(C[OANAyO#K`QSOANAyOOQO'#HU'#HUOOQO7+*c7+*cOOQQG22tG22tOOQQANBRANBRO&;{QSOANBROOQQAND|AND|OOQQAND}AND}OOQQ<<L|<<L|O!)jQUOAN?eOOQOG24rG24rO$6nQ(CjOG24rO#![QSOLD,iOOQQLD,iLD,iO!%tQ,UOLD,iO&<QQSOLD,iO&<YQ$IUO7+'sO&>OQ$IUO7+'uO&?tQ,UOG26{OOQO<<Ms<<MsOOQ(CWANAUANAUO$ mQSOANAUOOQ(CWANATANATOOQO<<NO<<NOOOQQLD-TLD-TO&@UQ$IUO7+*`OOQQG27cG27cO%JOQSOG27cO!%tQ,UOG27cOOQQG27eG27eO9OQ(C[OG27eOOQQG27mG27mO&@`Q$IUOG25POOQOLD*^LD*^OOQQ!$(!T!$(!TO#![QSO!$(!TO!%tQ,UO!$(!TO&@jQ(CjOG26{OOQ(CWG26pG26pOOQQLD,}LD,}O%JOQSOLD,}OOQQLD-PLD-POOQQ!)9Eo!)9EoO#![QSO!)9EoOOQQ!$(!i!$(!iOOQQ!.K;Z!.K;ZO&B{Q$IUOG26{O!)jQUO'#DvO0uQSO'#ETO&DqQbO'#JcO!)jQUO'#DnO&DxQUO'#DzO!)jQUO'#D|O&EPQbO'#CfO&GgQbO'#CfO&GwQUO,5;SO!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO,5;^O!)jQUO'#IfO&IzQSO,5<cO&JSQ,UO,5;^O&KgQ,UO,5;^O!)jQUO,5;rO0xQSO'#DSO0xQSO'#DSO!%tQ,UO'#FxO&JSQ,UO'#FxO!%tQ,UO'#FzO&JSQ,UO'#FzO!%tQ,UO'#GYO&JSQ,UO'#GYO!)jQUO,5:fO!)jQUO,5@_O&GwQUO1G0nO&KnQ$IUO'#CfO!)jQUO1G1zO!%tQ,UO,5=PO&JSQ,UO,5=PO!%tQ,UO,5=RO&JSQ,UO,5=RO!%tQ,UO,5<mO&JSQ,UO,5<mO&GwQUO1G1{O!)jQUO7+&uO!%tQ,UO1G2XO&JSQ,UO1G2XO!%tQ,UO1G2ZO&JSQ,UO1G2ZO&GwQUO7+'gO&GwQUO7+&YO!%tQ,UOANAaO&JSQ,UOANAaO&KxQSO'#EhO&K}QSO'#EhO&LVQSO'#FWO&L[QSO'#ErO&LaQSO'#JsO&LlQSO'#JqO&LwQSO,5;SO&L|Q,UO,5<`O&MTQSO'#GRO&MYQSO'#GRO&M_QSO,5<aO&MgQSO,5;SO&MoQ$IUO1G1ZO&MvQSO,5<mO&M{QSO,5<mO&NQQSO,5<oO&NVQSO,5<oO&N[QSO1G1{O&NaQSO1G0nO&NfQ,UO<<KuO&NmQ,UO<<KuO7^Q,UO'#FvO8tQSO'#FuO@mQSO'#EgO!)jQUO,5;oO!2dQSO'#GRO!2dQSO'#GRO!2dQSO'#GTO!2dQSO'#GTO!'^Q,UO7+(ZO!'^Q,UO7+(ZO$HyQ`O1G2oO$HyQ`O1G2oO!%tQ,UO,5=TO!%tQ,UO,5=T",
  stateData: "' v~O'mOS'nOSROS'oRQ~OPYOQYOV!TO^pOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O#p}O$QzO$UfO%`{O%b!OO%d|O%e|O%h!PO%j!QO%m!RO%n!RO%p!SO%|!UO&S!VO&U!WO&W!XO&Y!YO&]!ZO&c![O&i!]O&k!^O&m!_O&o!`O&q!aO'tSO'vTO'yUO(RVO(a[O(niO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't!bO'vTO'yUO(RVO(a[O(niO~O^!sOl!kO|!lO![!uO!]!rO!^!rO!x9mO!|!mO!}!mO#O!tO#P!mO#Q!mO#T!vO#U!vO'u!iO'vTO'yUO(U!jO(a!pO~O'o!wO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX'kYX(RYX(bYX(iYX(jYX~O!a$zX~P(gO[!yO'v!{O'w!yO'x!{O~O[!|O'x!{O'y!{O'z!|O~Oq#OO!O#PO(S#PO(T#RO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't9rO'vTO'yUO(RVO(a[O(niO~O!U#VO!V#SO!S(XP!S(fP~P+sO!W#_O~P`OPYOQYOa!gOb!fOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!cO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO'vTO'yUO(RVO(a[O(niO~Oi#iO!U#eO!x]O#b#hO#c#eO't9sO!g(cP~P._O!h#kO't#jO~O!t#oO!x]O%`#pO~O#d#qO~O!a#rO#d#qO~OP$YOX$aOk#}Oy#vOz#wO|#xO!V$^O!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O^(VX'k(VX'i(VX!g(VX!S(VX!X(VX%a(VX!a(VX~P1gO#X$bO#{$bOP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX!X(WX%a(WX~O^(WX!f(WX'k(WX'i(WX!S(WX!g(WXo(WX!a(WX~P3}O#X$bO~O$W$dO$Y$cO$a$iO~O!X$jO$UfO$d$kO$f$mO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#c%YO$Q%VO$m%TO$o%UO$r%WO't$oO'vTO'yUO'}%OO(R$rOd(OP~O!h%ZO~O!a%]O~O^%^O'k%^O~O'u!iO~P%QO't%eO~O!h%ZO't%eO'u!iO'}%OO~Ob%lO!h%ZO't%eO~O#o$PO~Oy%qO!X%nO!h%pO%b%tO't%eO'u!iO'vTO'yUO](vP~O!t#oO~O|%vO!X%wO't%eO~O|%vO!X%wO%j%{O't%eO~O't%|O~O#p}O%b!OO%d|O%e|O%h!PO%j!QO%m!RO%n!RO~Oa&VOb&UO!t&SO%`&TO%r&RO~P;fOa&YObwO!X&XO!tvO!x]O#p}O%`{O%d|O%e|O%h!PO%j!QO%m!RO%n!RO%p!SO~O_&]O#X&`O%b&ZO'u!iO~P<eO!h&aO!q&eO~O!h#kO~O!XXO~O^%^O'j&mO'k%^O~O^%^O'j&pO'k%^O~O^%^O'j&rO'k%^O~O'iYX!SYXoYX!gYX&QYX!XYX%aYX!aYX~P(gO!['PO!]&xO!^&xO'u!iO'vTO'yUO~Ol&vO|&uO!U&yO(U&tO!W(YP!W(hP~P?fOg'SO!X'QO't%eO~Ob'XO!h%ZO't%eO~Oy%qO!h%pO~Ol!kO|!lO!x9mO!|!mO!}!mO#P!mO#Q!mO'u!iO'vTO'yUO(U!jO(a!pO~O!['_O!]'^O!^'^O#O!mO#T'`O#U'`O~PAQO^%^O!a#rO!h%ZO'k%^O'}%OO(b'bO~O!l'fO#X'dO~PB`Ol!kO|!lO'vTO'yUO(U!jO(a!pO~O!XXOl(_X|(_X![(_X!](_X!^(_X!x(_X!|(_X!}(_X#O(_X#P(_X#Q(_X#T(_X#U(_X'u(_X'v(_X'y(_X(U(_X(a(_X~O!]'^O!^'^O'u!iO~PCOO'p'jO'q'jO'r'lO~O[!yO'v'nO'w!yO'x'nO~O[!|O'x'nO'y'nO'z!|O~Oq#OO!O#PO(S#PO(T'rO~O!U'tO!S&|X!S'SX!V&|X!V'SX~P+sO!V'vO!S(XX~OP$YOX$aOk#}Oy#vOz#wO|#xO!V'vO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O!S(XX~PFrO!S'{O~O!S(eX!V(eX!a(eX!g(eX(b(eX~O#X(eX#d#]X!W(eX~PHxO#X'|O!S(gX!V(gX~O!V'}O!S(fX~O!S(QO~O#X$bO~PHxO!W(RO~P`Oy#vOz#wO|#xO!f#tO!h#uO(RVOP!jaX!jak!ja!V!ja!e!ja!l!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#o!ja#q!ja#s!ja#u!ja#v!ja(b!ja(i!ja(j!ja~O^!ja'k!ja'i!ja!S!ja!g!jao!ja!X!ja%a!ja!a!ja~PJ`O!g(SO~O!a#rO#X(TO(b'bO!V(dX^(dX'k(dX~O!g(dX~PMOO|%vO!X%wO!x]O#b(YO#c(XO't%eO~O!V(ZO!g(cX~O!g(]O~O|%vO!X%wO#c(XO't%eO~OP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!f(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#o(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX~O!a#rO!g(WX~PNlOy(^Oz(_O!f#tO!h#uO!x!wa|!wa~O!t!wa%`!wa!X!wa#b!wa#c!wa't!wa~P!!pO!t(cO~OPYOQYOa!gOb!fOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!csO!hZO!kYO!lYO!mYO!otO!quO!t!eO$Q!hO$UfO't!bO'vTO'yUO(RVO(a[O(niO~Oi%POk$qOl$pOm$pOs%QOu%ROw:VO|$xO!X$yO!c;aO!h$uO#c:]O$Q%VO$m:XO$o:ZO$r%WO't(gO'vTO'yUO'}%OO(R$rO~O#d(iO~Oi%POk$qOl$pOm$pOs%QOu%ROw%SO|$xO!X$yO!c%XO!h$uO#c%YO$Q%VO$m%TO$o%UO$r%WO't(gO'vTO'yUO'}%OO(R$rO~Od([P~P!'^O!U(mO!g(]P~P%QO(U(oO(a[O~O|(qO!h#uO(U(oO(a[O~OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!X!cO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO't)PO'vTO'yUO(RVO(a[O(n;ZO~Oz)SO!h#uO~O!V$^O^$ka'k$ka'i$ka!g$ka!S$ka!X$ka%a$ka!a$ka~O#p)WO~P!%tOy)ZO!a)YO!X$XX$T$XX$W$XX$Y$XX$a$XX~O!a)YO!X(kX$T(kX$W(kX$Y(kX$a(kX~Oy)ZO~P!-SOy)ZO!X(kX$T(kX$W(kX$Y(kX$a(kX~O!X)]O$T)aO$W)[O$Y)[O$a)bO~O!U)eO~P!)jO$W$dO$Y$cO$a)iO~Og$sXy$sX|$sX!f$sX(i$sX(j$sX~OdfXd$sXgfX!VfX#XfX~P!.xOl)kO~Oq)lO(S)mO(T)oO~Og)xOy)qO|)rO(i)tO(j)vO~Od)pO~P!0ROd)yO~Oi%POk$qOl$pOm$pOs%QOu%ROw:VO|$xO!X$yO!c;aO!h$uO#c:]O$Q%VO$m:XO$o:ZO$r%WO'vTO'yUO'}%OO(R$rO~O!U)}O't)zO!g(oP~P!0pO#d*PO~O!h*QO~O!U*VO't*SO!S(pP~P!0pOk*cO|*ZO![*aO!]*YO!^*YO!h*QO#T*bO%W*]O'u!iO(U!jO~O!W*`O~P!2vO!f#tOg(QXy(QX|(QX(i(QX(j(QX!V(QX#X(QX~Od(QX#y(QX~P!3oOg*fO#X*eOd(PX!V(PX~O!V*gOd(OX~O't%|Od(OP~O!h*nO~O't(gO~Oi*rO|%vO!U#eO!X%wO!x]O#b#hO#c#eO't%eO!g(cP~O!a#rO#d*sO~OP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO#v$VO(RVO(b$WO(i#yO(j#zO~O^!ba!V!ba'k!ba'i!ba!S!ba!g!bao!ba!X!ba%a!ba!a!ba~P!6UOy#vOz#wO|#xO!f#tO!h#uO(RVOP!naX!nak!na!V!na!e!na!l!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#o!na#q!na#s!na#u!na#v!na(b!na(i!na(j!na~O^!na'k!na'i!na!S!na!g!nao!na!X!na%a!na!a!na~P!8oOy#vOz#wO|#xO!f#tO!h#uO(RVOP!paX!pak!pa!V!pa!e!pa!l!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#o!pa#q!pa#s!pa#u!pa#v!pa(b!pa(i!pa(j!pa~O^!pa'k!pa'i!pa!S!pa!g!pao!pa!X!pa%a!pa!a!pa~P!;YOg*{O!X'QO%a*zO'}%OO~O!a*}O^'|X!X'|X'k'|X!V'|X~O^%^O!XXO'k%^O~O!h%ZO'}%OO~O!h%ZO't%eO'}%OO~O!a#rO#d(iO~O%b+ZO't+VO'vTO'yUO!W(wP~O!V+[O](vX~O(U(oO~OX+`O~O]+aO~O!X%nO't%eO'u!iO](vP~O|%vO!U+eO!V'}O!X%wO't%eO!S(fP~Ol&|O|+gO!U+fO'vTO'yUO(U(oO~O!W(hP~P!@xO!V+hO^(sX'k(sX~O#X+lO'}%OO~Og+oO!X$yO'}%OO~O!X+qO~Oy+sO!XXO~O!t+xO~Ob+}O~O't#jO!W(uP~Ob%lO~O%b!OO't%|O~P<eOX,TO],SO~OPYOQYOaxObwOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!csO!hZO!kYO!lYO!mYO!otO!quO!tvO!x]O$UfO%`{O'vTO'yUO(RVO(a[O(niO~O!X!cO$Q!hO't!bO~P!C]O],SO^%^O'k%^O~O^,XO#p,ZO%d,ZO%e,ZO~P%QO!h&aO~O&S,`O~O!X,bO~O&e,dO&g,eOP&baQ&baV&ba^&baa&bab&bai&bak&bal&bam&bas&bau&baw&ba|&ba!Q&ba!R&ba!X&ba!c&ba!h&ba!k&ba!l&ba!m&ba!o&ba!q&ba!t&ba!x&ba#p&ba$Q&ba$U&ba%`&ba%b&ba%d&ba%e&ba%h&ba%j&ba%m&ba%n&ba%p&ba%|&ba&S&ba&U&ba&W&ba&Y&ba&]&ba&c&ba&i&ba&k&ba&m&ba&o&ba&q&ba'i&ba't&ba'v&ba'y&ba(R&ba(a&ba(n&ba!W&ba&Z&ba_&ba&`&ba~O't,jO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#X{X'}!_X~O!a,oO#X,nO!V#aX!V(ZX!W#aX!W(ZX!a(ZX!h(ZX'}(ZX~O!a,qO!h%ZO'}%OO!V!ZX!W!ZX~Ol!kO|!lO'vTO'yUO(U!jO~OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!X!cO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO'vTO'yUO(RVO(a[O(n;ZO~O't:bO~P!LrO!V,uO!W(YX~O!W,wO~O!a,oO#X,nO!V#aX!W#aX~O!V,xO!W(hX~O!W,zO~O!],{O!^,{O'u!iO~P!LaO!W-OO~P'TOg-RO!X'QO~O!S-WO~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#Q!wa#T!wa#U!wa'u!wa'v!wa'y!wa(U!wa(a!wa~P!!pO!l-]O#X-ZO~PB`O!]-_O!^-_O'u!iO~PCOO^%^O#X-ZO'k%^O~O^%^O!a#rO#X-ZO'k%^O~O^%^O!a#rO!l-]O#X-ZO'k%^O(b'bO~O'p'jO'q'jO'r-dO~Oo-eO~O!S&|a!V&|a~P!6UO!U-iO!S&|X!V&|X~P%QO!V'vO!S(Xa~O!S(Xa~PFrO!V'}O!S(fa~O|%vO!U-mO!X%wO't%eO!S'SX!V'SX~O#X-oO!V(da!g(da^(da'k(da~O!a#rO~P#&xO!V(ZO!g(ca~O|%vO!X%wO#c-sO't%eO~Oi-xO|%vO!U-uO!X%wO!x]O#b-wO#c-uO't%eO!V'VX!g'VX~Oz-|O!h#uO~Og.PO!X'QO%a.OO'}%OO~O^#[i!V#[i'k#[i'i#[i!S#[i!g#[io#[i!X#[i%a#[i!a#[i~P!6UOg;gOy)qO|)rO(i)tO(j)vO~O#d#Wa^#Wa#X#Wa'k#Wa!V#Wa!g#Wa!X#Wa!S#Wa~P#)tO#d(QXP(QXX(QX^(QXk(QXz(QX!e(QX!h(QX!l(QX#g(QX#h(QX#i(QX#j(QX#k(QX#l(QX#m(QX#n(QX#o(QX#q(QX#s(QX#u(QX#v(QX'k(QX(R(QX(b(QX!g(QX!S(QX'i(QXo(QX!X(QX%a(QX!a(QX~P!3oO!V.YOd([X~P!0ROd.[O~O!V.]O!g(]X~P!6UO!g.`O~O!S.bO~OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(RVOX#fi^#fik#fi!V#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O#g#fi~P#-pO#g#{O~P#-pOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O(RVOX#fi^#fi!V#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~Ok#fi~P#0bOk#}O~P#0bOP$YOk#}Oy#vOz#wO|#xO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO(RVO^#fi!V#fi#q#fi#s#fi#u#fi#v#fi'k#fi(b#fi(i#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P#3SOX$aO!e$PO#l$PO#m$PO#n$`O#o$PO~P#3SOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO(RVO^#fi!V#fi#s#fi#u#fi#v#fi'k#fi(b#fi(j#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(i#fi~P#6TO(i#yO~P#6TOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO(RVO(i#yO^#fi!V#fi#u#fi#v#fi'k#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(j#fi~P#8uO(j#zO~P#8uOP$YOX$aOk#}Oy#vOz#wO|#xO!e$PO!f#tO!h#uO!l$YO#g#{O#h#|O#i#|O#j#|O#k$OO#l$PO#m$PO#n$`O#o$PO#q$QO#s$SO#u$UO(RVO(i#yO(j#zO~O^#fi!V#fi#v#fi'k#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#;gOPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX!VYX!WYX~O#yYX~P#>QOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O#u:OO#v:PO(RVO(b$WO(i#yO(j#zO~O#y.dO~P#@_O#X:UO#{:UO#y(WX!W(WX~PNlO^'Ya!V'Ya'k'Ya'i'Ya!g'Ya!S'Yao'Ya!X'Ya%a'Ya!a'Ya~P!6UOP#fiX#fi^#fik#fiz#fi!V#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'k#fi(R#fi(b#fi'i#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#)tO^#zi!V#zi'k#zi'i#zi!S#zi!g#zio#zi!X#zi%a#zi!a#zi~P!6UO$W.iO$Y.iO~O$W.jO$Y.jO~O!a)YO#X.kO!X$^X$T$^X$W$^X$Y$^X$a$^X~O!U.lO~O!X)]O$T.nO$W)[O$Y)[O$a.oO~O!V:QO!W(VX~P#@_O!W.pO~O!a)YO$a(kX~O$a.rO~Oq)lO(S)mO(T.uO~Ol.xO!S.yO'vTO'yUO~O!VcX!acX!gcX!g$sX(bcX~P!.xO!g/PO~P#)tO!V/QO!a#rO(b'bO!g(oX~O!g/VO~O!U)}O't%eO!g(oP~O#d/XO~O!S$sX!V$sX!a$zX~P!.xO!V/YO!S(pX~P#)tO!a/[O~O!S/^O~Ok/bO!a#rO!h%ZO'}%OO(b'bO~O't/dO~O!a*}O~O^%^O!V/hO'k%^O~O!W/jO~P!2vO!]/kO!^/kO'u!iO(U!jO~O|/mO(U!jO~O#T/nO~O't%|Od'_X!V'_X~O!V*gOd(Oa~Od/sO~Oy/tOz/tO|/uOgva(iva(jva!Vva#Xva~Odva#yva~P#L|Oy)qO|)rOg$la(i$la(j$la!V$la#X$la~Od$la#y$la~P#MrOy)qO|)rOg$na(i$na(j$na!V$na#X$na~Od$na#y$na~P#NeO#d/wO~Od$|a!V$|a#X$|a#y$|a~P!0RO!a#rO~O#d/zO~Oy#vOz#wO|#xO!f#tO!h#uO(RVOP!niX!nik!ni!V!ni!e!ni!l!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#o!ni#q!ni#s!ni#u!ni#v!ni(b!ni(i!ni(j!ni~O^!ni'k!ni'i!ni!S!ni!g!nio!ni!X!ni%a!ni!a!ni~P$ wOg.PO!X'QO%a.OO~Oi0RO't0QO~P!0sO!a*}O^'|a!X'|a'k'|a!V'|a~O#d0XO~OXYX!VcX!WcX~O!V0YO!W(wX~O!W0[O~OX0]O~O't+VO'vTO'yUO~O!X%nO't%eO]'gX!V'gX~O!V+[O](va~O!g0bO~P!6UOX0eO~O]0fO~O!V+hO^(sa'k(sa~O#X0lO~Og0oO!X$yO~O(U(oO!W(tP~Og0xO!X0uO%a0wO'}%OO~OX1SO!V1QO!W(uX~O!W1TO~O]1VO^%^O'k%^O~O't#jO'vTO'yUO~O#X$bO#{$bOP(WXX(WXk(WXy(WXz(WX|(WX!V(WX!e(WX!h(WX!l(WX#g(WX#h(WX#i(WX#j(WX#k(WX#l(WX#m(WX#n(WX#q(WX#s(WX#u(WX#v(WX(R(WX(b(WX(i(WX(j(WX~O#o1YO&Q1ZO^(WX!f(WX~P$(xO#X$bO#o1YO&Q1ZO~O^1[O~P%QO^1^O~O&Z1bOP&XiQ&XiV&Xi^&Xia&Xib&Xii&Xik&Xil&Xim&Xis&Xiu&Xiw&Xi|&Xi!Q&Xi!R&Xi!X&Xi!c&Xi!h&Xi!k&Xi!l&Xi!m&Xi!o&Xi!q&Xi!t&Xi!x&Xi#p&Xi$Q&Xi$U&Xi%`&Xi%b&Xi%d&Xi%e&Xi%h&Xi%j&Xi%m&Xi%n&Xi%p&Xi%|&Xi&S&Xi&U&Xi&W&Xi&Y&Xi&]&Xi&c&Xi&i&Xi&k&Xi&m&Xi&o&Xi&q&Xi'i&Xi't&Xi'v&Xi'y&Xi(R&Xi(a&Xi(n&Xi!W&Xi_&Xi&`&Xi~O_1hO!W1fO&`1gO~P`O!XXO!h1jO~O&g,eOP&biQ&biV&bi^&bia&bib&bii&bik&bil&bim&bis&biu&biw&bi|&bi!Q&bi!R&bi!X&bi!c&bi!h&bi!k&bi!l&bi!m&bi!o&bi!q&bi!t&bi!x&bi#p&bi$Q&bi$U&bi%`&bi%b&bi%d&bi%e&bi%h&bi%j&bi%m&bi%n&bi%p&bi%|&bi&S&bi&U&bi&W&bi&Y&bi&]&bi&c&bi&i&bi&k&bi&m&bi&o&bi&q&bi'i&bi't&bi'v&bi'y&bi(R&bi(a&bi(n&bi!W&bi&Z&bi_&bi&`&bi~O!S1pO~O!V!Za!W!Za~P#@_Ol!kO|!lO!U1vO(U!jO!V&}X!W&}X~P?fO!V,uO!W(Ya~O!V'TX!W'TX~P!@xO!V,xO!W(ha~O!W1}O~P'TO^%^O#X2WO'k%^O~O^%^O!a#rO#X2WO'k%^O~O^%^O!a#rO!l2[O#X2WO'k%^O(b'bO~O^%^O'k%^O~P!6UO!V$^Oo$ka~O!S&|i!V&|i~P!6UO!V'vO!S(Xi~O!V'}O!S(fi~O!S(gi!V(gi~P!6UO!V(di!g(di^(di'k(di~P!6UO#X2^O!V(di!g(di^(di'k(di~O!V(ZO!g(ci~O|%vO!X%wO!x]O#b2cO#c2bO't%eO~O|%vO!X%wO#c2bO't%eO~Og2jO!X'QO%a2iO~Og2jO!X'QO%a2iO'}%OO~O#dvaPvaXva^vakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva'kva(Rva(bva!gva!Sva'ivaova!Xva%ava!ava~P#L|O#d$laP$laX$la^$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la'k$la(R$la(b$la!g$la!S$la'i$lao$la!X$la%a$la!a$la~P#MrO#d$naP$naX$na^$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na'k$na(R$na(b$na!g$na!S$na'i$nao$na!X$na%a$na!a$na~P#NeO#d$|aP$|aX$|a^$|ak$|az$|a!V$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a'k$|a(R$|a(b$|a!g$|a!S$|a'i$|a#X$|ao$|a!X$|a%a$|a!a$|a~P#)tO^#[q!V#[q'k#[q'i#[q!S#[q!g#[qo#[q!X#[q%a#[q!a#[q~P!6UOd'OX!V'OX~P!'^O!V.YOd([a~O!U2rO!V'PX!g'PX~P%QO!V.]O!g(]a~O!V.]O!g(]a~P!6UO!S2uO~O#y!ja!W!ja~PJ`O#y!ba!V!ba!W!ba~P#@_O#y!na!W!na~P!8oO#y!pa!W!pa~P!;YO!X3XO$UfO$_3YO~O!W3^O~Oo3_O~P#)tO^$hq!V$hq'k$hq'i$hq!S$hq!g$hqo$hq!X$hq%a$hq!a$hq~P!6UO!S3`O~Ol.xO'vTO'yUO~Oy)qO|)rO(j)vOg%Xi(i%Xi!V%Xi#X%Xi~Od%Xi#y%Xi~P$GeOy)qO|)rOg%Zi(i%Zi(j%Zi!V%Zi#X%Zi~Od%Zi#y%Zi~P$HWO(b$WO~P#)tO!U3cO't%eO!V'ZX!g'ZX~O!V/QO!g(oa~O!V/QO!a#rO!g(oa~O!V/QO!a#rO(b'bO!g(oa~Od$ui!V$ui#X$ui#y$ui~P!0RO!U3kO't*SO!S']X!V']X~P!0pO!V/YO!S(pa~O!V/YO!S(pa~P#)tO!a#rO#o3sO~Ok3vO!a#rO(b'bO~Od(Pi!V(Pi~P!0RO#X3yOd(Pi!V(Pi~P!0RO!g3|O~O^$iq!V$iq'k$iq'i$iq!S$iq!g$iqo$iq!X$iq%a$iq!a$iq~P!6UO!V4QO!X(qX~P#)tO!f#tO~P3}O^$sX!X$sX%UYX'k$sX!V$sX~P!.xO%U4SO^hXghXyhX|hX!XhX'khX(ihX(jhX!VhX~O%U4SO~O%b4ZO't+VO'vTO'yUO!V'fX!W'fX~O!V0YO!W(wa~OX4_O~O]4`O~O!S4dO~O^%^O'k%^O~P#)tO!X$yO~P#)tO!V4iO#X4kO!W(tX~O!W4lO~Ol!kO|4mO![!uO!]!rO!^!rO!x9mO!|!mO!}!mO#O!mO#P!mO#Q!mO#T4rO#U!vO'u!iO'vTO'yUO(U!jO(a!pO~O!W4qO~P%!VOg4wO!X0uO%a4vO~Og4wO!X0uO%a4vO'}%OO~O't#jO!V'eX!W'eX~O!V1QO!W(ua~O'vTO'yUO(U5QO~O]5UO~O!g5XO~P%QO^5ZO~O^5ZO~P%QO#o5]O&Q5^O~PMOO_1hO!W5bO&`1gO~P`O!a5dO~O!a5fO!V(Zi!W(Zi!a(Zi!h(Zi'}(Zi~O!V#ai!W#ai~P#@_O#X5gO!V#ai!W#ai~O!V!Zi!W!Zi~P#@_O^%^O#X5pO'k%^O~O^%^O!a#rO#X5pO'k%^O~O!V(dq!g(dq^(dq'k(dq~P!6UO!V(ZO!g(cq~O|%vO!X%wO#c5wO't%eO~O!X'QO%a5zO~Og5}O!X'QO%a5zO~O#d%XiP%XiX%Xi^%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi'k%Xi(R%Xi(b%Xi!g%Xi!S%Xi'i%Xio%Xi!X%Xi%a%Xi!a%Xi~P$GeO#d%ZiP%ZiX%Zi^%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi'k%Zi(R%Zi(b%Zi!g%Zi!S%Zi'i%Zio%Zi!X%Zi%a%Zi!a%Zi~P$HWO#d$uiP$uiX$ui^$uik$uiz$ui!V$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui'k$ui(R$ui(b$ui!g$ui!S$ui'i$ui#X$uio$ui!X$ui%a$ui!a$ui~P#)tOd'Oa!V'Oa~P!0RO!V'Pa!g'Pa~P!6UO!V.]O!g(]i~O#y#[i!V#[i!W#[i~P#@_OP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO(RVOX#fik#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~O#g#fi~P%0fO#g9uO~P%0fOP$YOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO(RVOX#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~Ok#fi~P%2qOk9wO~P%2qOP$YOk9wOy#vOz#wO|#xO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO(RVO#q#fi#s#fi#u#fi#v#fi#y#fi(b#fi(i#fi(j#fi!V#fi!W#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P%4|OX:TO!e9yO#l9yO#m9yO#n:SO#o9yO~P%4|OP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO(RVO#s#fi#u#fi#v#fi#y#fi(b#fi(j#fi!V#fi!W#fi~O(i#fi~P%7hO(i#yO~P%7hOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O(RVO(i#yO#u#fi#v#fi#y#fi(b#fi!V#fi!W#fi~O(j#fi~P%9sO(j#zO~P%9sOP$YOX:TOk9wOy#vOz#wO|#xO!e9yO!f#tO!h#uO!l$YO#g9uO#h9vO#i9vO#j9vO#k9xO#l9yO#m9yO#n:SO#o9yO#q9zO#s9|O#u:OO(RVO(i#yO(j#zO~O#v#fi#y#fi(b#fi!V#fi!W#fi~P%<OO^#wy!V#wy'k#wy'i#wy!S#wy!g#wyo#wy!X#wy%a#wy!a#wy~P!6UOg;hOy)qO|)rO(i)tO(j)vO~OP#fiX#fik#fiz#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(R#fi(b#fi!V#fi!W#fi~P%>vO!f#tOP(QXX(QXg(QXk(QXy(QXz(QX|(QX!e(QX!h(QX!l(QX#g(QX#h(QX#i(QX#j(QX#k(QX#l(QX#m(QX#n(QX#o(QX#q(QX#s(QX#u(QX#v(QX#y(QX(R(QX(b(QX(i(QX(j(QX!V(QX!W(QX~O#y#zi!V#zi!W#zi~P#@_O#y!ni!W!ni~P$ wO!W6ZO~O!V'Ya!W'Ya~P#@_O!a#rO(b'bO!V'Za!g'Za~O!V/QO!g(oi~O!V/QO!a#rO!g(oi~Od$uq!V$uq#X$uq#y$uq~P!0RO!S']a!V']a~P#)tO!a6bO~O!V/YO!S(pi~P#)tO!V/YO!S(pi~O!S6fO~O!a#rO#o6kO~Ok6lO!a#rO(b'bO~O!S6nO~Od$wq!V$wq#X$wq#y$wq~P!0RO^$iy!V$iy'k$iy'i$iy!S$iy!g$iyo$iy!X$iy%a$iy!a$iy~P!6UO!V4QO!X(qa~O^#[y!V#[y'k#[y'i#[y!S#[y!g#[yo#[y!X#[y%a#[y!a#[y~P!6UOX6sO~O!V0YO!W(wi~O]6yO~O!a5fO~O(U(oO!V'bX!W'bX~O!V4iO!W(ta~OikO't7QO~P._O!W7TO~P%!VOl!kO|7UO'vTO'yUO(U!jO(a!pO~O!X0uO~O!X0uO%a7WO~Og7ZO!X0uO%a7WO~OX7`O!V'ea!W'ea~O!V1QO!W(ui~O!g7dO~O!g7eO~O!g7fO~O!g7fO~P%QO^7hO~O!a7kO~O!g7lO~O!V(gi!W(gi~P#@_O^%^O#X7tO'k%^O~O!V(dy!g(dy^(dy'k(dy~P!6UO!V(ZO!g(cy~O!X'QO%a7wO~O#d$uqP$uqX$uq^$uqk$uqz$uq!V$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq'k$uq(R$uq(b$uq!g$uq!S$uq'i$uq#X$uqo$uq!X$uq%a$uq!a$uq~P#)tO#d$wqP$wqX$wq^$wqk$wqz$wq!V$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq'k$wq(R$wq(b$wq!g$wq!S$wq'i$wq#X$wqo$wq!X$wq%a$wq!a$wq~P#)tO!V'Pi!g'Pi~P!6UO#y#[q!V#[q!W#[q~P#@_Oy/tOz/tO|/uOPvaXvagvakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva#yva(Rva(bva(iva(jva!Vva!Wva~Oy)qO|)rOP$laX$lag$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la#y$la(R$la(b$la(i$la(j$la!V$la!W$la~Oy)qO|)rOP$naX$nag$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na#y$na(R$na(b$na(i$na(j$na!V$na!W$na~OP$|aX$|ak$|az$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a#y$|a(R$|a(b$|a!V$|a!W$|a~P%>vO#y$hq!V$hq!W$hq~P#@_O#y$iq!V$iq!W$iq~P#@_O!W8RO~O#y8SO~P!0RO!a#rO!V'Zi!g'Zi~O!a#rO(b'bO!V'Zi!g'Zi~O!V/QO!g(oq~O!S']i!V']i~P#)tO!V/YO!S(pq~O!S8YO~P#)tO!S8YO~Od(Py!V(Py~P!0RO!V'`a!X'`a~P#)tO^%Tq!X%Tq'k%Tq!V%Tq~P#)tOX8_O~O!V0YO!W(wq~O#X8cO!V'ba!W'ba~O!V4iO!W(ti~P#@_OPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX~O!a%RX#o%RX~P&/vO!X0uO%a8gO~O'vTO'yUO(U8lO~O!V1QO!W(uq~O!g8oO~O!g8oO~P%QO!g8qO~O!g8rO~O#X8tO!V#ay!W#ay~O!V#ay!W#ay~P#@_O!X'QO%a8yO~O#y#wy!V#wy!W#wy~P#@_OP$uiX$uik$uiz$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui#y$ui(R$ui(b$ui!V$ui!W$ui~P%>vOy)qO|)rO(j)vOP%XiX%Xig%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi#y%Xi(R%Xi(b%Xi(i%Xi!V%Xi!W%Xi~Oy)qO|)rOP%ZiX%Zig%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi#y%Zi(R%Zi(b%Zi(i%Zi(j%Zi!V%Zi!W%Zi~O#y$iy!V$iy!W$iy~P#@_O#y#[y!V#[y!W#[y~P#@_O!a#rO!V'Zq!g'Zq~O!V/QO!g(oy~O!S']q!V']q~P#)tO!S9QO~P#)tO!V0YO!W(wy~O!V4iO!W(tq~O!X0uO%a9XO~O!g9[O~O!X'QO%a9aO~OP$uqX$uqk$uqz$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq#y$uq(R$uq(b$uq!V$uq!W$uq~P%>vOP$wqX$wqk$wqz$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq#y$wq(R$wq(b$wq!V$wq!W$wq~P%>vOd%]!Z!V%]!Z#X%]!Z#y%]!Z~P!0RO!V'bq!W'bq~P#@_O!V#a!Z!W#a!Z~P#@_O#d%]!ZP%]!ZX%]!Z^%]!Zk%]!Zz%]!Z!V%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z'k%]!Z(R%]!Z(b%]!Z!g%]!Z!S%]!Z'i%]!Z#X%]!Zo%]!Z!X%]!Z%a%]!Z!a%]!Z~P#)tOP%]!ZX%]!Zk%]!Zz%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z#y%]!Z(R%]!Z(b%]!Z!V%]!Z!W%]!Z~P%>vOo(VX~P1gO'u!iO~P!)jO!ScX!VcX#XcX~P&/vOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#XYX#XcX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(RYX(bYX(iYX(jYX~O!acX!gYX!gcX(bcX~P&E^OP9lOQ9lOa;]Ob!fOikOk9lOlkOmkOskOu9lOw9lO|WO!QkO!RkO!XXO!c9oO!hZO!k9lO!l9lO!m9lO!o9pO!q9qO!t!eO$Q!hO$UfO't)PO'vTO'yUO(RVO(a[O(n;ZO~O!V:QO!W$ka~Oi%POk$qOl$pOm$pOs%QOu%ROw:WO|$xO!X$yO!c;bO!h$uO#c:^O$Q%VO$m:YO$o:[O$r%WO't(gO'vTO'yUO'}%OO(R$rO~O#p)WO~P&JSO!WYX!WcX~P&E^O#d9tO~O!a#rO#d9tO~O#X:UO~O#o9yO~O#X:`O!V(gX!W(gX~O#X:UO!V(eX!W(eX~O#d:aO~Od:cO~P!0RO#d:hO~O#d:iO~O!a#rO#d:jO~O!a#rO#d:aO~O#y:kO~P#@_O#d:lO~O#d:mO~O#d:nO~O#d:oO~O#d:pO~O#d:qO~O#y:rO~P!0RO#y:sO~P!0RO$U~!f!|!}#P#Q#T#b#c#n(n$m$o$r%U%`%a%b%h%j%m%n%p%r~'oR$U(n#h!R'm'u#il#g#jky'n(U'n't$W$Y$W~",
  goto: "$%Z({PPPP(|P)PP)aP*p.rPPPP5SPP5iP;d>iP>|P>|PPP>|P@lP>|P>|P>|P@pPP@uPA`PFUPPPFYPPPPFYIXPPPI_JYPFYPLgPPPPNuFYPPPFYPFYP!#TFYP!&g!'i!'rP!(e!(i!(ePPPPP!+r!'iPP!,`!-YP!/|FYFY!0R!3Z!7n!7n!;cPPP!;jFYPPPPPPPPPPP!>uP!@WPPFY!AePFYPFYFYFYFYPFY!BwPP!E}P!IPP!IT!I_!Ic!IcP!EzP!Ig!IgP!LiP!LmFYFY!Ls# t>|P>|P>|>|P##O>|>|#$x>|#'V>|#(y>|>|#)g#+c#+c#+g#+o#+c#+wP#+cP>|#,a>|#-i>|>|5SPPP#.tPP#/^#/^P#/^P#/s#/^PP#/yP#/pP#/p#0]#/p#0w#0}5P)P#1Q)PP#1X#1X#1XP)PP)PP)PP)PPP)PP#1_#1bP#1b)PP#1fP#1iP)PP)PP)PP)PP)PP)P)PPP#1o#1u#2P#2V#2]#2c#2i#2w#2}#3T#3_#3e#3o#4O#4U#4u#5X#5_#5e#5s#6Y#7j#7x#8O#8U#8[#8b#8l#8r#8x#9S#9f#9lPPPPPPPPPP#9rPPPPPPP#:f#=mP#>|#?T#?]PPPP#Cg#F]#Lr#Lu#Lx#Mq#Mt#Mw#NO#NWPP#N^#Nb$ Z$!Z$!_$!sPP$!w$!}$#RP$#U$#Y$#]$$R$$i$$n$$q$$t$$z$$}$%R$%VR!xRmpOXr!X#`%]&d&f&g&i,],b1b1eY!rQ'Q,}0u4pQ%ctQ%kwQ%rzQ&[!TS&x!c,uQ'W!fS'^!o!uS*Y$y*_Q+T%lQ+b%tQ+|&UQ,{'PQ-V'XQ-_'_Q/k*aQ1P+}R:_9p$zdOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s+g,X,],b-R-Z-i-o.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2r4m4w5Z5]5^5p7U7Z7h7tS#m]9m!r)R$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q*j%SQ+Y%nQ,O&XQ,V&aQ.S:VQ0O*{Q0S*}Q0_+ZQ1X,TQ2f.PQ4Y0YQ5O1QQ5|2jQ6S:WQ6u4ZR7z5}&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^t!kQ!o!r!u!v&x'P'Q'^'_'`,u,{,}-_0u4p4r$Y$pi#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hQ%uzQ&v!cS&|%w,xQ+Y%nS.x)r.zQ/v*nQ0_+ZQ0d+aQ1W,SQ1X,TQ4Y0YQ4c0fQ5R1SQ5S1VQ6u4ZQ6x4`Q7c5UQ8b6yR8m7`pmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eR,Q&]&r^OPXYrstux!X!^!g!l#O#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u'S'd'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;];^[#XWZ#S#V&y'tQ%fvQ%jwS%oz%t!U%x|}#d#e#h%Z%v'}(X(Y(Z+e+f+h,Z,o-m-s-t-u-w1j2b2c5f5wQ&Q!RQ'T!eQ'V!fQ(b#oS)|$u*QS+S%k%lQ+W%nQ+w&SQ+{&US-U'W'XQ.R(cQ/U)}Q0W+TQ0^+ZQ0`+[Q0c+`Q0z+xS1O+|+}Q2S-VQ3b/QQ4X0YQ4]0]Q4b0eQ4}1PQ6_3cQ6t4ZQ6w4_Q8^6sR9S8_v$wi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!S%hw!f!q%j%k%l&w'V'W'X']'g*X+S+T,r-U-V-^/c0W1{2S2Z3uQ*|%fQ+m%}Q+p&OQ+z&UQ.Q(bQ0y+wU0}+{+|+}Q2k.RQ4x0zS4|1O1PQ7_4}!z;_#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hg;`:S:T:Y:[:^:e:g:i:m:o:sW$|i%O*g;ZS%}!O&ZQ&O!PQ&P!QR+k%{$Z${i#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hT)m$r)nV*k%S:V:WU&|!c%w,xS(p#v#wQ+_%qS-z(^(_Q0p+qQ3z/tR6}4i&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^$i$]c#U#a%a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.e.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QT#PV#Q&ykOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q&z!cR1w,uv!kQ!c!o!r!u!v&x'P'Q'^'_'`,u,{,}-_0u4p4rS*X$y*_S/c*Y*aQ/l*bQ0r+sQ3u/kR3x/nlpOXr!X#`%]&d&f&g&i,],b1b1eQ&k![Q'h!tS(d#q9tQ+Q%iQ+u&QQ+v&RQ-S'UQ-a'aS.W(i:aS/y*s:jQ0U+RQ0t+tQ1i,dQ1k,eQ1s,pQ2Q-TQ2T-XS4P/z:pQ4T0VS4W0X:qQ5h1uQ5l2RQ5q2YQ6r4UQ7o5jQ7p5mQ7s5rR8s7l$d$[c#U#a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QS(a#l'ZU*d$z(h3US*w%a.eQ2g0OQ5y2fQ7y5|R8z7z$d$Zc#U#a%b%d's'y(e(l(t(u(v(w(x(y(z({(|(})O)Q)T)X)c*x+^,s-b-g-l-n.X._.c.f.g.v/x1q1t2U2]2q2v2w2x2y2z2{2|2}3O3P3Q3R3S3V3W3]4O4V5i5o5t6Q6R6W6X7P7n7r7{8P8Q8v9U9]9n;QS(`#l'ZS(r#w$[S*v%a.eS-{(_(aQ.h)SQ/{*wR2d-|&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^S#m]9mQ&f!VQ&g!WQ&i!YQ&j!ZR1a,`Q'R!eQ*y%fQ-Q'TS-}(b*|Q2O-PW2h.Q.R/}0PQ5k2PU5x2e2g2kS7v5y5{S8x7x7yS9_8w8zQ9g9`R9j9hU!sQ'Q,}T4n0u4p!O_OXZ`r!T!X#`#d%Z%]&Z&]&d&f&g&i(Z,],b-t1b1e]!mQ!o'Q,}0u4pT#m]9m%UyOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tS(p#v#wS-z(^(_!s:w$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Y!qQ'Q,}0u4pQ']!oS'g!r!uS'i!v4rS-^'^'_Q-`'`R2Z-_Q'f!qS(V#c1_S-]']'iQ/T)|Q/a*XQ2[-`Q3g/US3p/b/lQ6^3bS6i3v3xQ8U6_R8]6lQ#sbQ'e!qS(U#c1_S(W#i*rQ*t%[Q+O%gQ+U%mU-[']'f'iQ-p(VQ/S)|Q/`*XQ/f*[Q0T+PQ0{+yS2X-]-`Q2a-xS3f/T/US3o/a/lQ3r/eQ3t/gQ4z0|Q5s2[Q6]3bQ6a3gS6e3p3xQ6j3wQ7]4{S8T6^6_Q8X6fQ8Z6iQ8j7^Q9O8UQ9P8YQ9R8]Q9Z8kQ9c9QQ:z:uQ;V;OR;W;PV!sQ'Q,}%UaOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tS#sx!g!r:t$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^R:z;]%UbOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tQ%[j!S%gw!f!q%j%k%l&w'V'W'X']'g*X+S+T,r-U-V-^/c0W1{2S2Z3uS%mx!gQ+P%hQ+y&UW0|+z+{+|+}U4{0}1O1PS7^4|4}Q8k7_!r:u$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q;O;[R;P;]$xeOPXYrstu!X!^!l#O#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7tY#^WZ#S#V't!U%x|}#d#e#h%Z%v'}(X(Y(Z+e+f+h,Z,o-m-s-t-u-w1j2b2c5f5wQ,W&a!p:v$X$j)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^R:y&yS&}!c%wR1y,x$zdOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s+g,X,],b-R-Z-i-o.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2r4m4w5Z5]5^5p7U7Z7h7t!r)R$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^Q,V&aQ0O*{Q2f.PQ5|2jR7z5}!f$Rc#U%a's'y(e(l({(|(})O)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9n!T9{)Q)c,s.e1q1t2v3O3P3Q3R3V3]5i6R6W6X7P7n7{8P8Q9U9];Q!b$Tc#U%a's'y(e(l(})O)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9n!P9})Q)c,s.e1q1t2v3Q3R3V3]5i6R6W6X7P7n7{8P8Q9U9];Q!^$Xc#U%a's'y(e(l)T)X+^-b-g-l-n.X._.v/x2U2]2q3S4O4V5o5t6Q7r8v9nQ3a/Oz;^)Q)c,s.e1q1t2v3V3]5i6R6W6X7P7n7{8P8Q9U9];QQ;c;eR;d;f&xkOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^S$kh$lR3Y.k'PgOPWXYZhrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.k.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^T$gf$mQ$efS)[$h)`R)h$mT$ff$mT)^$h)`'PhOPWXYZhrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$X$^$b$j$l%]%c%p&]&`&a&d&f&g&i&m&u&y'S'd't'v'|(T(i(m(q)e)p*s*{+g,X,],b,n,q-R-Z-i-o.P.].d.k.l/u/z0X0x1Y1Z1[1^1b1e1g1v2W2^2j2r3X4k4m4w5Z5]5^5g5p5}7U7Z7h7t8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^T$kh$lQ$nhR)g$l%UjOPWXYZrstu!X!^!l#O#S#V#`#k#q#u#x#{#|#}$O$P$Q$R$S$T$U$V$^$b%]%c%p&]&`&a&d&f&g&i&m&u'S'd't'v'|(T(i(m(q)p*s*{+g,X,],b-R-Z-i-o.P.].d/u/z0X0x1Y1Z1[1^1b1e1g2W2^2j2r4m4w5Z5]5^5p5}7U7Z7h7t!s;[$X$j&y)e,n,q.l1v3X4k5g8c8t9l9o9p9q9t9u9v9w9x9y9z9{9|9}:O:P:Q:U:_:`:a:c:j:k:p:q;^#alOPXZr!X!^!l#O#`#k#x$j%]&]&`&a&d&f&g&i&m&u'S(q)e*{+g,X,],b-R.P.l/u0x1Y1Z1[1^1b1e1g2j3X4m4w5Z5]5^5}7U7Z7hv$zi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!z(h#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hQ*o%WQ.w)qg3U:S:T:Y:[:^:e:g:i:m:o:sv$vi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;dQ*R$wS*[$y*_Q*p%XQ/g*]!z:|#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hf:}:S:T:Y:[:^:e:g:i:m:o:sQ;R;_Q;S;`Q;T;aR;U;bv$zi#t%T%U%Y)u)w*P*e*f.Y/X/w3a3y8S;Z;c;d!z(h#r$`$a$u$x)l)x*V*z*}+l+o.O/Y/[0l0o0w2i3k3s4Q4S4v5z6b6k7W7w8g8y9X9a:X:Z:]:d:f:h:l:n:r;g;hg3U:S:T:Y:[:^:e:g:i:m:o:slnOXr!X#`%]&d&f&g&i,],b1b1eQ*U$xQ,k&pQ,l&rR3j/Y$Y${i#r#t$`$a$u$x%T%U%Y)l)u)w)x*P*V*e*f*z*}+l+o.O.Y/X/Y/[/w0l0o0w2i3a3k3s3y4Q4S4v5z6b6k7W7w8S8g8y9X9a:S:T:X:Y:Z:[:]:^:d:e:f:g:h:i:l:m:n:o:r:s;Z;c;d;g;hQ+n&OQ0n+pQ4g0mR6|4hT*^$y*_S*^$y*_T4o0u4pS/e*Z4mT3w/m7UQ+O%gQ/f*[Q0T+PQ0{+yQ4z0|Q7]4{Q8j7^R9Z8kn)u$s(j*q/W/o/p2o3h3}6[6m8}:{;X;Y!W:d(f)V){*T.V.s/O/]/|0k0m2n3i3m4f4h6O6P6c6g6o6q8W8[9b;e;f]:e3T6V7|8{8|9kp)w$s(j*q.|/W/o/p2o3h3}6[6m8}:{;X;Y!Y:f(f)V){*T.V.s/O/]/|0k0m2l2n3i3m4f4h6O6P6c6g6o6q8W8[9b;e;f_:g3T6V7|7}8{8|9kpmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eQ&W!SR,X&apmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eR&W!SQ+r&PR0j+kqmOXr!T!X#`%]&Z&d&f&g&i,],b1b1eQ0v+wS4u0y0zU7V4s4t4xS8f7X7YS9V8e8hQ9d9WR9i9eQ&_!TR,R&ZR5R1SS%oz%tR0`+[Q&d!UR,]&eR,c&jT1c,b1eR,g&kQ,f&kR1l,gQ'k!wR-c'kQrOQ#`XT%`r#`Q!zTR'm!zQ!}UR'o!}Q)n$rR.t)nQ#QVR'q#QQ#TWU'w#T'x-jQ'x#UR-j'yQ,v&zR1x,vQ.Z(jR2p.ZQ.^(lS2s.^2tR2t._Q,}'QR1|,}Y!oQ'Q,}0u4pR'[!oS#ZW%vU(O#Z(P-kQ(P#[R-k'zQ,y&}R1z,yr`OXr!T!X#`%]&Z&]&d&f&g&i,],b1b1eS#dZ%ZU#n`#d-tR-t(ZQ([#fQ-q(WW-y([-q2_5uQ2_-rR5u2`Q)`$hR.m)`Q$lhR)f$lQ$_cU)U$_-f:RQ-f9nR:R)cQ/R)|W3d/R3e6`8VU3e/S/T/US6`3f3gR8V6a#m)s$s(f(j)V){*T*l*m*q.T.U.V.s.|.}/O/W/]/o/p/|0k0m2l2m2n2o3T3h3i3m3}4f4h6O6P6T6U6V6[6c6g6m6o6q7|7}8O8W8[8{8|8}9b9k:{;X;Y;e;fQ/Z*TU3l/Z3n6dQ3n/]R6d3mQ*_$yR/i*_Q*h$}R/r*hQ4R/|R6p4RQ+i%yR0i+iQ4j0pS7O4j8dR8d7PQ+t&QR0s+tQ4p0uR7S4pQ1R,OS5P1R7aR7a5RQ0Z+WW4[0Z4^6v8`Q4^0^Q6v4]R8`6wQ+]%oR0a+]Q1e,bR5a1eWqOXr#`Q&h!XQ*u%]Q,[&dQ,^&fQ,_&gQ,a&iQ1`,]S1c,b1eR5`1bQ%_oQ&l!]Q&o!_Q&q!`Q&s!aQ'c!qQ+Q%iQ+d%uQ+j%zQ,Q&_Q,i&nW-Y']'e'f'iQ-a'aQ/h*^Q0U+RS1U,R,UQ1m,hQ1n,kQ1o,lQ2T-XW2V-[-]-`-bQ4T0VQ4a0dQ4e0kQ4y0{Q5T1WQ5_1aU5n2U2X2[Q5q2YQ6r4UQ6z4cQ6{4fQ7R4oQ7[4zQ7b5SS7q5o5sQ7s5rQ8a6xQ8i7]Q8n7cQ8u7rQ9T8bQ9Y8jQ9^8vR9f9ZQ%iwQ'U!fQ'a!qU+R%j%k%lQ,p&wU-T'V'W'XS-X']'gQ/_*XS0V+S+TQ1u,rS2R-U-VQ2Y-^Q3q/cQ4U0WQ5j1{Q5m2SQ5r2ZR6h3uS$ti;ZR*i%OU$}i%O;ZR/q*gQ$siS(f#r*}Q(j#tS)V$`$aQ){$uQ*T$xQ*l%TQ*m%UQ*q%YQ.T:XQ.U:ZQ.V:]Q.s)lQ.|)uQ.})wQ/O)xQ/W*PQ/]*VQ/o*eQ/p*fh/|*z.O0w2i4v5z7W7w8g8y9X9aQ0k+lQ0m+oQ2l:dQ2m:fQ2n:hQ2o.YS3T:S:TQ3h/XQ3i/YQ3m/[Q3}/wQ4f0lQ4h0oQ6O:lQ6P:nQ6T:YQ6U:[Q6V:^Q6[3aQ6c3kQ6g3sQ6m3yQ6o4QQ6q4SQ7|:iQ7}:eQ8O:gQ8W6bQ8[6kQ8{:mQ8|:oQ8}8SQ9b:rQ9k:sQ:{;ZQ;X;cQ;Y;dQ;e;gR;f;hloOXr!X#`%]&d&f&g&i,],b1b1eQ!dPS#bZ#kQ&n!^U'Y!l4m7UQ'p#OQ(s#xQ)d$jS,U&]&`Q,Y&aQ,h&mQ,m&uQ-P'SQ.a(qQ.q)eQ0P*{Q0g+gQ1],XQ2P-RQ2g.PQ3[.lQ3{/uQ4t0xQ5V1YQ5W1ZQ5Y1[Q5[1^Q5c1gQ5y2jQ6Y3XQ7Y4wQ7g5ZQ7i5]Q7j5^Q7y5}Q8h7ZR8p7h#UcOPXZr!X!^!l#`#k#x%]&]&`&a&d&f&g&i&m&u'S(q*{+g,X,],b-R.P/u0x1Y1Z1[1^1b1e1g2j4m4w5Z5]5^5}7U7Z7hQ#UWQ#aYQ%asQ%btQ%duS's#S'vQ'y#VQ(e#qQ(l#uQ(t#{Q(u#|Q(v#}Q(w$OQ(x$PQ(y$QQ(z$RQ({$SQ(|$TQ(}$UQ)O$VQ)Q$XQ)T$^Q)X$bW)c$j)e.l3XQ*x%cQ+^%pS,s&y1vQ-b'dS-g't-iQ-l'|Q-n(TQ.X(iQ._(mQ.c9lQ.e9oQ.f9pQ.g9qQ.v)pQ/x*sQ1q,nQ1t,qQ2U-ZQ2]-oQ2q.]Q2v9tQ2w9uQ2x9vQ2y9wQ2z9xQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S.dQ3V:UQ3W:_Q3]:QQ4O/zQ4V0XQ5i:`Q5o2WQ5t2^Q6Q2rQ6R:aQ6W:cQ6X:jQ7P4kQ7n5gQ7r5pQ7{:kQ8P:pQ8Q:qQ8v7tQ9U8cQ9]8tQ9n#OR;Q;^R#WWR&{!cY!qQ'Q,}0u4pS&w!c,uQ']!oS'g!r!uS'i!v4rS,r&x'PS-^'^'_Q-`'`Q1{,{R2Z-_R(k#tR(n#uQ!dQT,|'Q,}]!nQ!o'Q,}0u4pQ#l]R'Z9mT#gZ%ZS#fZ%ZU%y|},ZU(W#d#e#hS-r(X(YQ-v(ZQ0h+hQ2`-sU2a-t-u-wS5v2b2cR7u5w`#YW#S#V%v't'}+e-mt#cZ|}#d#e#h%Z(X(Y(Z+h-s-t-u-w2b2c5wQ1_,ZQ1r,oQ5e1jQ7m5fT:x&y+fT#]W%vS#[W%vS'u#S'}S'z#V+eS,t&y+fT-h't-mT'O!c%wQ$hfR)j$mT)_$h)`R3Z.kT*O$u*QR*W$xQ/}*zQ2e.OQ4s0wQ5{2iQ7X4vQ7x5zQ8e7WQ8w7wQ9W8gQ9`8yQ9e9XR9h9alpOXr!X#`%]&d&f&g&i,],b1b1eQ&^!TR,Q&ZV%z|},ZR0q+qR,P&XQ%szR+c%tR+X%nT&b!U&eT&c!U&eT1d,b1e",
  nodeNames: "⚠ ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 364,
  context: _A,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 199, 203, 206, 207, 209, 212, 215, 225, 227, 233, 235, 237, 239, 242, 248, 254, 256, 258, 260, 262, 264, 265, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 103, 104, 113, 114, 131, 134, 136, 137, 138, 139, 141, 142, 162, 163, 165, "Expression", -23, 24, 26, 30, 34, 36, 38, 166, 168, 170, 171, 173, 174, 175, 177, 178, 179, 181, 182, 183, 193, 195, 197, 198, "Type", -3, 84, 96, 102, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 143, "JSXStartTag", 155, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 144, "JSXSelfCloseEndTag JSXEndTag", 160, "JSXEndTag"]
  ],
  propSources: [AA],
  skippedNodes: [0, 3, 4, 268],
  repeatNodeCount: 33,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$d&j'z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$d&j'wpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'wpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$d&j'wp'z!b'm(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'x#S$d&j'n(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$d&j'wp'z!b'n(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$d&j!l$Ip'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#q$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#q$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'v$(n$d&j'z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$d&j'z!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$d&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$_#t$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$_#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$_#t$d&j'z!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'z!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$_#t'z!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$d&j(a!L^'wp'z!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$d&j'wp'z!b(U!LY't&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$d&j'wp'z!b$W#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$d&j'wp'z!b#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$d&j#{$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(j%<v$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$d&j#u$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'y$)`$d&j'wpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$d&j'wpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$d&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$_#t$d&j'wpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'wpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$_#t'wpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$d&j'wp'z!b'u#)d#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$d&j'wp'z!b#g$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$d&j'wp'z!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$d&j'wp'z!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$d&j'wp'z!b#h$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$d&j'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$d&j'z!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$d&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$d&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$d&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$d&j'z!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'z!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'z!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'z!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$d&j'z!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$d&j'wp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$d&j'wp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'wp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'wp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'wpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$d&j'wpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$d&j'wp'z!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'wp'z!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'wp'z!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'wp'z!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$d&j'wp'z!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$d&j'wp'z!b'o(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$d&j'wp'z!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$d&j'z!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$d&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'z!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$d&j'wpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'wpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'wp'z!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$d&j#{$Id'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$T#t$d&j'wp'z!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$d&j'wp'z!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$d&j#y%<f'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^'}!*v!e'.r'wp'z!b$U)d(nSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$f&j'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#k$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#{$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#l$Id'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#X%?x$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#d$Ih$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#l$Id$a#|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#l$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#k$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#k$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(b$Ip$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$d&j#v$Id'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$d&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$d&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$d&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$d&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$d&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!'l$-S_!SM|$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#s$Id$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$d&j'wp'z!b(R&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$d&j'wp'z!b(U!LY't&;d$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$d&j'wp'z!b$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'wp'z!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(i%<v$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$d&j'wp'z!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$d&j'wp'z!b'm(;d(U!LY't&;d$W#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$d&j'wp'z!b'n(;d(U!LY't&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [MA, XA, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, DA, new nf("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(T~~", 141, 326), new nf("j~RQYZXz{^~^O'q~~aP!P!Qd~iO'r~~", 25, 308)],
  topRules: { Script: [0, 5], SingleExpression: [1, 266], SingleClassItem: [2, 267] },
  dialects: { jsx: 12686, ts: 12688 },
  dynamicPrecedences: { 76: 1, 78: 1, 163: 1, 191: 1 },
  specialized: [{ term: 312, get: (r) => zA[r] || -1 }, { term: 328, get: (r) => NA[r] || -1 }, { term: 67, get: (r) => VA[r] || -1 }],
  tokenPrec: 12712
}), LA = [
  /* @__PURE__ */ fi("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ fi(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ fi('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ fi('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], CO = /* @__PURE__ */ new sD(), I1 = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function hs(r) {
  return (e, t) => {
    let i = e.node.getChild("VariableDefinition");
    return i && t(i, r), !0;
  };
}
const WA = ["FunctionDeclaration"], IA = {
  FunctionDeclaration: /* @__PURE__ */ hs("function"),
  ClassDeclaration: /* @__PURE__ */ hs("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ hs("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ hs("type"),
  NamespaceDeclaration: /* @__PURE__ */ hs("namespace"),
  VariableDefinition(r, e) {
    r.matchContext(WA) || e(r, "variable");
  },
  TypeDefinition(r, e) {
    e(r, "type");
  },
  __proto__: null
};
function U1(r, e) {
  let t = CO.get(e);
  if (t)
    return t;
  let i = [], o = !0;
  function n(s, a) {
    let l = r.sliceString(s.from, s.to);
    i.push({ label: l, type: a });
  }
  return e.cursor($e.IncludeAnonymous).iterate((s) => {
    if (o)
      o = !1;
    else if (s.name) {
      let a = IA[s.name];
      if (a && a(s, n) || I1.has(s.name))
        return !1;
    } else if (s.to - s.from > 8192) {
      for (let a of U1(r, s.node))
        i.push(a);
      return !1;
    }
  }), CO.set(e, i), i;
}
const QO = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, Y1 = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function UA(r) {
  let e = ze(r.state).resolveInner(r.pos, -1);
  if (Y1.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && QO.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let i = [];
  for (let o = e; o; o = o.parent)
    I1.has(o.name) && (i = i.concat(U1(r.state.doc, o)));
  return {
    options: i,
    from: t ? e.from : r.pos,
    validFor: QO
  };
}
const Zr = /* @__PURE__ */ hr.define({
  name: "javascript",
  parser: /* @__PURE__ */ ZA.configure({
    props: [
      /* @__PURE__ */ Yo.add({
        IfStatement: /* @__PURE__ */ Yi({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ Yi({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: vx,
        SwitchBody: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : i ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ bx({ closing: "}" }),
        ArrowFunction: (r) => r.baseIndent + r.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ Yi({ except: /^{/ }),
        JSXElement(r) {
          let e = /^\s*<\//.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        JSXEscape(r) {
          let e = /\s*\}/.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        }
      }),
      /* @__PURE__ */ Fo.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": mh,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), YA = /* @__PURE__ */ Zr.configure({ dialect: "ts" }, "typescript"), FA = /* @__PURE__ */ Zr.configure({ dialect: "jsx" }), BA = /* @__PURE__ */ Zr.configure({ dialect: "jsx ts" }, "typescript"), qA = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((r) => ({ label: r, type: "keyword" }));
function Dl(r = {}) {
  let e = r.jsx ? r.typescript ? BA : FA : r.typescript ? YA : Zr;
  return new qn(e, [
    Zr.data.of({
      autocomplete: y1(Y1, Ip(LA.concat(qA)))
    }),
    Zr.data.of({
      autocomplete: UA
    }),
    r.jsx ? jA : []
  ]);
}
function PO(r, e, t = r.length) {
  if (!e)
    return "";
  let i = e.getChild("JSXIdentifier");
  return i ? r.sliceString(i.from, Math.min(i.to, t)) : "";
}
const HA = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), jA = /* @__PURE__ */ B.inputHandler.of((r, e, t, i) => {
  if ((HA ? r.composing : r.compositionStarted) || r.state.readOnly || e != t || i != ">" && i != "/" || !Zr.isActiveAt(r.state, e, -1))
    return !1;
  let { state: o } = r, n = o.changeByRange((s) => {
    var a, l, u;
    let { head: h } = s, c = ze(o).resolveInner(h, -1), d;
    if (c.name == "JSXStartTag" && (c = c.parent), i == ">" && c.name == "JSXFragmentTag")
      return { range: D.cursor(h + 1), changes: { from: h, insert: "><>" } };
    if (i == ">" && c.name == "JSXIdentifier") {
      if (((l = (a = c.parent) === null || a === void 0 ? void 0 : a.lastChild) === null || l === void 0 ? void 0 : l.name) != "JSXEndTag" && (d = PO(o.doc, c.parent, h)))
        return { range: D.cursor(h + 1), changes: { from: h, insert: `></${d}>` } };
    } else if (i == "/" && c.name == "JSXFragmentTag") {
      let f = c.parent, p = f == null ? void 0 : f.parent;
      if (f.from == h - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "JSXEndTag" && (d = PO(o.doc, p == null ? void 0 : p.firstChild, h))) {
        let g = `/${d}>`;
        return { range: D.cursor(h + g.length), changes: { from: h, insert: g } };
      }
    }
    return { range: s };
  });
  return n.changes.empty ? !1 : (r.dispatch(n, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), GA = 95, kO = 1, KA = 96, JA = 97, EO = 2, F1 = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], ez = 58, tz = 40, B1 = 95, iz = 91, Ml = 45, rz = 46, oz = 35, nz = 37;
function Du(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 161;
}
function sz(r) {
  return r >= 48 && r <= 57;
}
const az = new Ci((r, e) => {
  for (let t = !1, i = 0, o = 0; ; o++) {
    let { next: n } = r;
    if (Du(n) || n == Ml || n == B1 || t && sz(n))
      !t && (n != Ml || o > 0) && (t = !0), i === o && n == Ml && i++, r.advance();
    else {
      t && r.acceptToken(n == tz ? KA : i == 2 && e.canShift(EO) ? EO : JA);
      break;
    }
  }
}), lz = new Ci((r) => {
  if (F1.includes(r.peek(-1))) {
    let { next: e } = r;
    (Du(e) || e == B1 || e == oz || e == rz || e == iz || e == ez || e == Ml) && r.acceptToken(GA);
  }
}), uz = new Ci((r) => {
  if (!F1.includes(r.peek(-1))) {
    let { next: e } = r;
    if (e == nz && (r.advance(), r.acceptToken(kO)), Du(e)) {
      do
        r.advance();
      while (Du(r.next));
      r.acceptToken(kO);
    }
  }
}), hz = Uo({
  "AtKeyword import charset namespace keyframes media supports": O.definitionKeyword,
  "from to selector": O.keyword,
  NamespaceName: O.namespace,
  KeyframeName: O.labelName,
  KeyframeRangeName: O.operatorKeyword,
  TagName: O.tagName,
  ClassName: O.className,
  PseudoClassName: O.constant(O.className),
  IdName: O.labelName,
  "FeatureName PropertyName": O.propertyName,
  AttributeName: O.attributeName,
  NumberLiteral: O.number,
  KeywordQuery: O.keyword,
  UnaryQueryOp: O.operatorKeyword,
  "CallTag ValueName": O.atom,
  VariableName: O.variableName,
  Callee: O.operatorKeyword,
  Unit: O.unit,
  "UniversalSelector NestingSelector": O.definitionOperator,
  MatchOp: O.compareOperator,
  "ChildOp SiblingOp, LogicOp": O.logicOperator,
  BinOp: O.arithmeticOperator,
  Important: O.modifier,
  Comment: O.blockComment,
  ColorLiteral: O.color,
  "ParenthesizedContent StringLiteral": O.string,
  ":": O.punctuation,
  "PseudoOp #": O.derefOperator,
  "; ,": O.separator,
  "( )": O.paren,
  "[ ]": O.squareBracket,
  "{ }": O.brace
}), cz = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, dz = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, fz = { __proto__: null, not: 128, only: 128 }, pz = cr.deserialize({
  version: 14,
  states: "8`QYQ[OOO#_Q[OOOOQP'#Cd'#CdOOQP'#Cc'#CcO#fQ[O'#CfO$YQXO'#CaO$aQ[O'#ChO$lQ[O'#DPO$qQ[O'#DTOOQP'#Ee'#EeO$vQdO'#DeO%bQ[O'#DrO$vQdO'#DtO%sQ[O'#DvO&OQ[O'#DyO&WQ[O'#EPO&fQ[O'#EROOQS'#Ed'#EdOOQS'#ET'#ETQYQ[OOO&mQXO'#CdO'bQWO'#DaO'gQWO'#EkO'rQ[O'#EkQOQWOOOOQP'#Cg'#CgOOQP,59Q,59QO#fQ[O,59QO'|Q[O'#EWO(hQWO,58{O(pQ[O,59SO$lQ[O,59kO$qQ[O,59oO'|Q[O,59sO'|Q[O,59uO'|Q[O,59vO({Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)SQWO,59SO)XQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)^Q`O,59oOOQS'#Cp'#CpO$vQdO'#CqO)fQvO'#CsO*sQtO,5:POOQO'#Cx'#CxO)XQWO'#CwO+XQWO'#CyOOQS'#Eh'#EhOOQO'#Dh'#DhO+^Q[O'#DoO+lQWO'#ElO&WQ[O'#DmO+zQWO'#DpOOQO'#Em'#EmO(kQWO,5:^O,PQpO,5:`OOQS'#Dx'#DxO,XQWO,5:bO,^Q[O,5:bOOQO'#D{'#D{O,fQWO,5:eO,kQWO,5:kO,sQWO,5:mOOQS-E8R-E8RO$vQdO,59{O,{Q[O'#EYO-YQWO,5;VO-YQWO,5;VOOQP1G.l1G.lO.PQXO,5:rOOQO-E8U-E8UOOQS1G.g1G.gOOQP1G.n1G.nO)SQWO1G.nO)XQWO1G.nOOQP1G/V1G/VO.^Q`O1G/ZO.wQXO1G/_O/_QXO1G/aO/uQXO1G/bO0]QWO,59zO0bQ[O'#DOO0iQdO'#CoOOQP1G/Z1G/ZO$vQdO1G/ZO0pQpO,59]OOQS,59_,59_O$vQdO,59aO0xQWO1G/kOOQS,59c,59cO0}Q!bO,59eO1VQWO'#DhO1bQWO,5:TO1gQWO,5:ZO&WQ[O,5:VO&WQ[O'#EZO1oQWO,5;WO1zQWO,5:XO'|Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2]QWO1G/|O2bQdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO2mQtO1G/gOOQO,5:t,5:tO3TQ[O,5:tOOQO-E8W-E8WO3bQWO1G0qOOQP7+$Y7+$YOOQP7+$u7+$uO$vQdO7+$uOOQS1G/f1G/fO3mQXO'#EjO3tQWO,59jO3yQtO'#EUO4nQdO'#EgO4xQWO,59ZO4}QpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5VQWO1G/PO$vQdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5[QWO,5:uOOQO-E8X-E8XO5jQXO1G/vOOQS7+%h7+%hO5qQYO'#CsOOQO'#EO'#EOO5|Q`O'#D}OOQO'#D}'#D}O6XQWO'#E[O6aQdO,5:hOOQS,5:h,5:hO6lQtO'#EXO$vQdO'#EXO7jQdO7+%ROOQO7+%R7+%ROOQO1G0`1G0`O7}QpO<<HaO8VQWO,5;UOOQP1G/U1G/UOOQS-E8S-E8SO$vQdO'#EVO8_QWO,5;ROOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO8gQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO2eQdO'#E]O6XQWO,5:vOOQS,5:v,5:vOOQS-E8Y-E8YOOQS1G0S1G0SO8nQtO,5:sOOQS-E8V-E8VOOQO<<Hm<<HmOOQPAN={AN={O9lQdO,5:qOOQO-E8T-E8TOOQO<<Hu<<HuOOQO,5:w,5:wOOQO-E8Z-E8ZOOQS1G0b1G0b",
  stateData: ":O~O#VOSROS~OUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#TQO#YSO~OQeOUXOXXO]UO^UOtVOxWO!Y`O!ZYO!gZO!i[O!k]O!n^O!t_O#TdO#YSO~O#Q#_P~P!ZO#TiO~O]nO^nOplOtoOxpO|qO!PsO#RrO#YkO~O!RtO~P#kO`zO#SwO#TvO~O#T{O~O#T}O~OQ!WOb!QOf!WOh!WOn!VO#S!TO#T!PO#]!RO~Ob!YO!b![O!e!]O#T!XO!R#`P~Oh!bOn!VO#T!aO~Oh!dO#T!dO~Ob!YO!b![O!e!]O#T!XO~O!W#`P~P%bO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#RWX#YWX~O]!iO~O!W!jO#Q#_X!Q#_X~O#Q#_X!Q#_X~P!ZOUXOXXO]UO^UOtVOxWO#TQO#YSO~OplO!RtO~O`!sO#SwO#TvO~O!Q#_P~P!ZOb!zO~Ob!{O~Ov!|Oz!}O~OP#PObgXjgX!WgX!bgX!egX#TgXagXQgXfgXhgXngXpgX!VgX#QgX#SgX#]gXvgX!QgX~Ob!YOj#QO!b![O!e!]O#T!XO!W#`P~Ob#TO~Ob!YO!b![O!e!]O#T#UO~Op#YO!`#XO!R#`X!W#`X~Ob#]O~Oj#QO!W#_O~O!W#`O~Oh#aOn!VO~O!R#bO~O!RtO!`#XO~O!RtO!W#eO~O!W!|X#Q!|X!Q!|X~P!ZO!W!jO#Q#_a!Q#_a~O]nO^nOtoOxpO|qO!PsO#RrO#YkO~Op!za!R!zaa!za~P-eOv#lOz#mO~O]nO^nOtoOxpO#YkO~Op{i|{i!P{i!R{i#R{ia{i~P.fOp}i|}i!P}i!R}i#R}ia}i~P.fOp!Oi|!Oi!P!Oi!R!Oi#R!Oia!Oi~P.fO!Q#nO~Oa#^P~P'|Oa#ZP~P$vOa#uOj#QO~O!W#wO~Oh#xOo#xO~O]!^Xa![X!`![X~O]#yO~Oa#zO!`#XO~Op#YO!R#`a!W#`a~O!`#XOp!aa!R!aa!W!aaa!aa~O!W$PO~O!Q$WO#T$RO#]$QO~Oj#QOp$YO!V$[O!W!Ti#Q!Ti!Q!Ti~P$vO!W!|a#Q!|a!Q!|a~P!ZO!W!jO#Q#_i!Q#_i~Oa#^X~P#kOa$`O~Oj#QOQ!xXa!xXb!xXf!xXh!xXn!xXp!xX#S!xX#T!xX#]!xX~Op$bOa#ZX~P$vOa$dO~Oj#QOv$eO~Oa$fO~O!`#XOp!}a!R!}a!W!}a~Oa$hO~P-eOP#POpgX!RgX~O#]$QOp!qX!R!qX~Op$jO!RtO~O!Q$nO#T$RO#]$QO~Oj#QOQ!{Xb!{Xf!{Xh!{Xn!{Xp!{X!V!{X!W!{X#Q!{X#S!{X#T!{X#]!{X!Q!{X~Op$YO!V$qO!W!Tq#Q!Tq!Q!Tq~P$vOj#QOv$rO~OplOa#^a~Op$bOa#Za~Oa$uO~P$vOj#QOQ!{ab!{af!{ah!{an!{ap!{a!V!{a!W!{a#Q!{a#S!{a#T!{a#]!{a!Q!{a~Oa!yap!ya~P$vO#VoR#]j!Pj~",
  goto: ",z#bPPPPP#cP#l#{P#l$[#lPP$bPPP$h$q$qP%TP$qP$q%o&RPPP&k&q#lP&wP#lP&}P#lP#l#lPPP'T'j'wPP#cPP(O(O(Y(OP(OP(O(OP#cP#cP#cP(]#cP(`(c(f(m#cP#cP(r)R)a)g)q)w*R*X*_PPPPPP*e*nP+Z+^P,S,V,],f_aOPcgt!j#hkXOPcglqrst!j!z#]#hkROPcglqrst!j!z#]#hQjSR!mkQxUR!qnQ!qzQ#S!UR#k!sq!WY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sp!WY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sU$T#b$V$jR$i$Sq!UY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sp!WY[!Q!i!{!}#Q#f#m#r#y$Y$Z$b$g$sQ!b]R#a!cQyUR!rnQ!qyR#k!rQ|VR!toQ!OWR!upQuTQ!pmQ#^!_Q#d!fQ#e!gQ$l$UR$x$kSfPtQ!lgQ#g!jR$]#hZePgt!j#ha!^Z_`!S!Y![#X#YR#V!YR!c]R!e^R#c!eS$U#b$VR$v$jV$S#b$V$jQcOSgPtU!hcg#hR#h!jQ#r!{U$a#r$g$sQ$g#yR$s$bQ$c#rR$t$cQmTS!om$_R$_#oQ$Z#fR$p$ZQ!kfS#i!k#jR#j!lQ#Z!ZR#}#ZQ$V#bR$m$VQ$k$UR$w$k_bOPcgt!j#h^TOPcgt!j#hQ!nlQ!vqQ!wrQ!xsQ#o!zR$O#]R#s!{Q!SYQ!`[Q#O!QQ#f!i[#q!{#r#y$b$g$sQ#t!}Q#v#QS$X#f$ZQ$^#mR$o$YR#p!zQhPR!ytQ!_ZQ!g`R#R!SU!ZZ`!SQ!f_Q#W!YQ#[![Q#{#XR#|#Y",
  nodeNames: "⚠ Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 109,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [hz],
  skippedNodes: [0, 3],
  repeatNodeCount: 9,
  tokenData: "Lq~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Cu![!]Dp!]!^El!^!_$}!_!`E}!`!aF`!a!b$}!b!cG[!c!}$}!}#OHt#O#P$}#P#QIV#Q#R6d#R#T$}#T#UIh#U#c$}#c#dJy#d#o$}#o#pK`#p#q6d#q#rKq#r#sLS#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`Lk<%lO$}W%QSOy%^z;'S%^;'S;=`%o<%lO%^W%cSoWOy%^z;'S%^;'S;=`%o<%lO%^W%rP;=`<%l%^~%zh#V~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#V~oWOX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^^)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^^)sUoWOy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^^*[UoWOy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^^*sUoWOy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^^+[UoWOy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^^+sUoWOy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^^,[UoWOy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^^,sUoWOy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^^-[UoWOy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^^-uS!VUoWOy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.R_/zYtPOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^^0oYoWOy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^^1dYoWOy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^^2ZYfUoWOy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^^3QYfUoWOy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^^3uYoWOy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^^4lYfUoWOy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^^5aYoWOy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^^6WSfUoWOy%^z;'S%^;'S;=`%o<%lO%^Y6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^Y7QSzQoWOy%^z;'S%^;'S;=`%o<%lO%^X7cSXPOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7o_9cSbVOy%^z;'S%^;'S;=`%o<%lO%^~9tOa~_9{UUPjSOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^_:fWjS!PPOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^^;TUoWOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^^;nYoW#]UOy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^^<cYoWOy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=WUoWOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^=qUoW#]UOy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^^>[[oW#]UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^_?VSpVOy%^z;'S%^;'S;=`%o<%lO%^^?hWjSOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^_@VU#YPOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjSOy%^z{@}{;'S%^;'S;=`%o<%lO%^~ASUoWOy@}yzAfz{Bm{;'S@};'S;=`Co<%lO@}~AiTOzAfz{Ax{;'SAf;'S;=`Bg<%lOAf~A{VOzAfz{Ax{!PAf!P!QBb!Q;'SAf;'S;=`Bg<%lOAf~BgOR~~BjP;=`<%lAf~BrWoWOy@}yzAfz{Bm{!P@}!P!QC[!Q;'S@};'S;=`Co<%lO@}~CcSoWR~Oy%^z;'S%^;'S;=`%o<%lO%^~CrP;=`<%l@}^Cz[#]UOy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^XDuU]POy%^z![%^![!]EX!];'S%^;'S;=`%o<%lO%^XE`S^PoWOy%^z;'S%^;'S;=`%o<%lO%^_EqS!WVOy%^z;'S%^;'S;=`%o<%lO%^YFSSzQOy%^z;'S%^;'S;=`%o<%lO%^XFeU|POy%^z!`%^!`!aFw!a;'S%^;'S;=`%o<%lO%^XGOS|PoWOy%^z;'S%^;'S;=`%o<%lO%^XG_WOy%^z!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHO[!YPoWOy%^z}%^}!OGw!O!Q%^!Q![Gw![!c%^!c!}Gw!}#T%^#T#oGw#o;'S%^;'S;=`%o<%lO%^XHySxPOy%^z;'S%^;'S;=`%o<%lO%^^I[SvUOy%^z;'S%^;'S;=`%o<%lO%^XIkUOy%^z#b%^#b#cI}#c;'S%^;'S;=`%o<%lO%^XJSUoWOy%^z#W%^#W#XJf#X;'S%^;'S;=`%o<%lO%^XJmS!`PoWOy%^z;'S%^;'S;=`%o<%lO%^XJ|UOy%^z#f%^#f#gJf#g;'S%^;'S;=`%o<%lO%^ZKeS!RROy%^z;'S%^;'S;=`%o<%lO%^_KvS!QVOy%^z;'S%^;'S;=`%o<%lO%^ZLXU!PPOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^WLnP;=`<%l$}",
  tokenizers: [lz, uz, az, 0, 1, 2, 3],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 96, get: (r) => cz[r] || -1 }, { term: 56, get: (r) => dz[r] || -1 }, { term: 97, get: (r) => fz[r] || -1 }],
  tokenPrec: 1142
});
let Sc = null;
function Cc() {
  if (!Sc && typeof document == "object" && document.body) {
    let r = [];
    for (let e in document.body.style)
      /[A-Z]|^-|^(item|length)$/.test(e) || r.push(e);
    Sc = r.sort().map((e) => ({ type: "property", label: e }));
  }
  return Sc || [];
}
const TO = /* @__PURE__ */ [
  "active",
  "after",
  "before",
  "checked",
  "default",
  "disabled",
  "empty",
  "enabled",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "lang",
  "last-child",
  "last-of-type",
  "link",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-of-type",
  "only-child",
  "optional",
  "out-of-range",
  "placeholder",
  "read-only",
  "read-write",
  "required",
  "root",
  "selection",
  "target",
  "valid",
  "visited"
].map((r) => ({ type: "class", label: r })), $O = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((r) => ({ type: "keyword", label: r })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((r) => ({ type: "constant", label: r }))), gz = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((r) => ({ type: "type", label: r })), vr = /^[\w-]*/, mz = (r) => {
  let { state: e, pos: t } = r, i = ze(e).resolveInner(t, -1);
  if (i.name == "PropertyName")
    return { from: i.from, options: Cc(), validFor: vr };
  if (i.name == "ValueName")
    return { from: i.from, options: $O, validFor: vr };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: TO, validFor: vr };
  if (i.name == "TagName") {
    for (let { parent: s } = i; s; s = s.parent)
      if (s.name == "Block")
        return { from: i.from, options: Cc(), validFor: vr };
    return { from: i.from, options: gz, validFor: vr };
  }
  if (!r.explicit)
    return null;
  let o = i.resolve(t), n = o.childBefore(t);
  return n && n.name == ":" && o.name == "PseudoClassSelector" ? { from: t, options: TO, validFor: vr } : n && n.name == ":" && o.name == "Declaration" || o.name == "ArgList" ? { from: t, options: $O, validFor: vr } : o.name == "Block" ? { from: t, options: Cc(), validFor: vr } : null;
}, sf = /* @__PURE__ */ hr.define({
  parser: /* @__PURE__ */ pz.configure({
    props: [
      /* @__PURE__ */ Yo.add({
        Declaration: /* @__PURE__ */ Yi()
      }),
      /* @__PURE__ */ Fo.add({
        Block: mh
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function af() {
  return new qn(sf, sf.data.of({ autocomplete: mz }));
}
const bz = 54, Oz = 1, vz = 55, wz = 2, yz = 56, xz = 3, RO = 4, Sz = 5, Mu = 6, q1 = 7, H1 = 8, j1 = 9, G1 = 10, Cz = 11, Qz = 12, Pz = 13, Qc = 57, kz = 14, _O = 58, K1 = 20, Ez = 22, J1 = 23, Tz = 24, lf = 26, eS = 27, $z = 28, Rz = 31, _z = 34, Dz = 36, Mz = 37, Xz = 0, Az = 1, zz = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, Nz = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, DO = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function Vz(r) {
  return r == 45 || r == 46 || r == 58 || r >= 65 && r <= 90 || r == 95 || r >= 97 && r <= 122 || r >= 161;
}
function tS(r) {
  return r == 9 || r == 10 || r == 13 || r == 32;
}
let MO = null, XO = null, AO = 0;
function uf(r, e) {
  let t = r.pos + e;
  if (AO == t && XO == r)
    return MO;
  let i = r.peek(e);
  for (; tS(i); )
    i = r.peek(++e);
  let o = "";
  for (; Vz(i); )
    o += String.fromCharCode(i), i = r.peek(++e);
  return XO = r, AO = t, MO = o ? o.toLowerCase() : i == Zz || i == Lz ? void 0 : null;
}
const iS = 60, Xu = 62, jp = 47, Zz = 63, Lz = 33, Wz = 45;
function zO(r, e) {
  this.name = r, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < r.length; t++)
    this.hash += (this.hash << 4) + r.charCodeAt(t) + (r.charCodeAt(t) << 8);
}
const Iz = [Mu, G1, q1, H1, j1], Uz = new L1({
  start: null,
  shift(r, e, t, i) {
    return Iz.indexOf(e) > -1 ? new zO(uf(i, 1) || "", r) : r;
  },
  reduce(r, e) {
    return e == K1 && r ? r.parent : r;
  },
  reuse(r, e, t, i) {
    let o = e.type.id;
    return o == Mu || o == Dz ? new zO(uf(i, 1) || "", r) : r;
  },
  hash(r) {
    return r ? r.hash : 0;
  },
  strict: !1
}), Yz = new Ci((r, e) => {
  if (r.next != iS) {
    r.next < 0 && e.context && r.acceptToken(Qc);
    return;
  }
  r.advance();
  let t = r.next == jp;
  t && r.advance();
  let i = uf(r, 0);
  if (i === void 0)
    return;
  if (!i)
    return r.acceptToken(t ? kz : Mu);
  let o = e.context ? e.context.name : null;
  if (t) {
    if (i == o)
      return r.acceptToken(Cz);
    if (o && Nz[o])
      return r.acceptToken(Qc, -2);
    if (e.dialectEnabled(Xz))
      return r.acceptToken(Qz);
    for (let n = e.context; n; n = n.parent)
      if (n.name == i)
        return;
    r.acceptToken(Pz);
  } else {
    if (i == "script")
      return r.acceptToken(q1);
    if (i == "style")
      return r.acceptToken(H1);
    if (i == "textarea")
      return r.acceptToken(j1);
    if (zz.hasOwnProperty(i))
      return r.acceptToken(G1);
    o && DO[o] && DO[o][i] ? r.acceptToken(Qc, -1) : r.acceptToken(Mu);
  }
}, { contextual: !0 }), Fz = new Ci((r) => {
  for (let e = 0, t = 0; ; t++) {
    if (r.next < 0) {
      t && r.acceptToken(_O);
      break;
    }
    if (r.next == Wz)
      e++;
    else if (r.next == Xu && e >= 2) {
      t > 3 && r.acceptToken(_O, -2);
      break;
    } else
      e = 0;
    r.advance();
  }
});
function Bz(r) {
  for (; r; r = r.parent)
    if (r.name == "svg" || r.name == "math")
      return !0;
  return !1;
}
const qz = new Ci((r, e) => {
  if (r.next == jp && r.peek(1) == Xu) {
    let t = e.dialectEnabled(Az) || Bz(e.context);
    r.acceptToken(t ? Sz : RO, 2);
  } else
    r.next == Xu && r.acceptToken(RO, 1);
});
function Gp(r, e, t) {
  let i = 2 + r.length;
  return new Ci((o) => {
    for (let n = 0, s = 0, a = 0; ; a++) {
      if (o.next < 0) {
        a && o.acceptToken(e);
        break;
      }
      if (n == 0 && o.next == iS || n == 1 && o.next == jp || n >= 2 && n < i && o.next == r.charCodeAt(n - 2))
        n++, s++;
      else if ((n == 2 || n == i) && tS(o.next))
        s++;
      else if (n == i && o.next == Xu) {
        a > s ? o.acceptToken(e, -s) : o.acceptToken(t, -(s - 2));
        break;
      } else if ((o.next == 10 || o.next == 13) && a) {
        o.acceptToken(e, 1);
        break;
      } else
        n = s = 0;
      o.advance();
    }
  });
}
const Hz = Gp("script", bz, Oz), jz = Gp("style", vz, wz), Gz = Gp("textarea", yz, xz), Kz = Uo({
  "Text RawText": O.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": O.angleBracket,
  TagName: O.tagName,
  "MismatchedCloseTag/TagName": [O.tagName, O.invalid],
  AttributeName: O.attributeName,
  "AttributeValue UnquotedAttributeValue": O.attributeValue,
  Is: O.definitionOperator,
  "EntityReference CharacterReference": O.character,
  Comment: O.blockComment,
  ProcessingInst: O.processingInstruction,
  DoctypeDecl: O.documentMeta
}), Jz = cr.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: "⚠ StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: Uz,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [Kz],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "#%g!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs4ysv-_vw5iwxJ^x}-_}!OKP!O!P-_!P!Q$q!Q![-_![!]!!O!]!^-_!^!_!&W!_!`#$o!`!a&X!a!c-_!c!}!!O!}#R-_#R#S!!O#S#T3V#T#o!!O#o#s-_#s$f$q$f%W-_%W%o!!O%o%p-_%p&a!!O&a&b-_&b1p!!O1p4U-_4U4d!!O4d4e-_4e$IS!!O$IS$I`-_$I`$Ib!!O$Ib$Kh-_$Kh%#t!!O%#t&/x-_&/x&Et!!O&Et&FV-_&FV;'S!!O;'S;:j!&Q;:j;=`4s<%l?&r-_?&r?Ah!!O?Ah?BY$q?BY?Mn!!O?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/echSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0uXhSqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0pS1eP;=`<%l0p[1kP;=`<%l/^!U1wbhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!U3SP;=`<%l1n!V3bchS`P!a`!cpOq&Xqr3Vrs&}sv3Vvw0pwx(tx!P3V!P!Q&X!Q!^3V!^!_1n!_!a&X!a#s3V#s$f&X$f;'S3V;'S;=`4m<%l?Ah3V?Ah?BY&X?BY?Mn3V?MnO&X!V4pP;=`<%l3V!_4vP;=`<%l-_!Z5SV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_5rjhSkWc!ROX7dXZ8qZ[7d[^8q^p7dqr:crs8qst@Ttw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^/^!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!Z7ibkWOX7dXZ8qZ[7d[^8q^p7dqr7drs8qst+Ptw7dwx8qx!]7d!]!^9f!^!a8q!a#S7d#S#T8q#T;'S7d;'S;=`:]<%lO7d!R8tVOp8qqs8qt!]8q!]!^9Z!^;'S8q;'S;=`9`<%lO8q!R9`Oa!R!R9cP;=`<%l8q!Z9mYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z:`P;=`<%l7d!_:jjhSkWOX7dXZ8qZ[7d[^8q^p7dqr:crs8qst/^tw:cwx8qx!P:c!P!Q7d!Q!]:c!]!^<[!^!_=p!_!a8q!a#S:c#S#T=p#T#s:c#s$f7d$f;'S:c;'S;=`?}<%l?Ah:c?Ah?BY7d?BY?Mn:c?MnO7d!_<echSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V=udhSOp8qqr=prs8qst0ptw=pwx8qx!P=p!P!Q8q!Q!]=p!]!^?T!^!_=p!_!a8q!a#s=p#s$f8q$f;'S=p;'S;=`?w<%l?Ah=p?Ah?BY8q?BY?Mn=p?MnO8q!V?[XhSa!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!V?zP;=`<%l=p!_@QP;=`<%l:c!_@[ihSkWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^/^!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!ZBOakWOXAyXZCTZ[Ay[^CT^pAyqrAyrsCTswAywxCTx!]Ay!]!^Cu!^!aCT!a#SAy#S#TCT#T;'SAy;'S;=`Dl<%lOAy!RCWUOpCTq!]CT!]!^Cj!^;'SCT;'S;=`Co<%lOCT!RCoOb!R!RCrP;=`<%lCT!ZC|YkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZDoP;=`<%lAy!_DyihSkWOXAyXZCTZ[Ay[^CT^pAyqrDrrsCTswDrwxCTx!PDr!P!QAy!Q!]Dr!]!^Fh!^!_G|!_!aCT!a#SDr#S#TG|#T#sDr#s$fAy$f;'SDr;'S;=`JW<%l?AhDr?Ah?BYAy?BY?MnDr?MnOAy!_FqchSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!^!_0p!a#S/^#S#T0p#T#s/^#s$f+P$f;'S/^;'S;=`1h<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VHRchSOpCTqrG|rsCTswG|wxCTx!PG|!P!QCT!Q!]G|!]!^I^!^!_G|!_!aCT!a#sG|#s$fCT$f;'SG|;'S;=`JQ<%l?AhG|?Ah?BYCT?BY?MnG|?MnOCT!VIeXhSb!Rqr0psw0px!P0p!Q!_0p!a#s0p$f;'S0p;'S;=`1b<%l?Ah0p?BY?Mn0p!VJTP;=`<%lG|!_JZP;=`<%lDr!ZJgW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aK^lhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMU!O!P-_!P!Q$q!Q!^-_!^!_1n!_!a&X!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aMckhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_1n!_!`&X!`!a! W!a#S-_#S#T3V#T#s-_#s$f$q$f;'S-_;'S;=`4s<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!T! cX`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!a!!_!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!O!!O!O!P!!O!P!Q$q!Q![!!O![!]!!O!]!^-_!^!_1n!_!a&X!a!c-_!c!}!!O!}#R-_#R#S!!O#S#T3V#T#o!!O#o#s-_#s$f$q$f$}-_$}%O!!O%O%W-_%W%o!!O%o%p-_%p&a!!O&a&b-_&b1p!!O1p4U!!O4U4d!!O4d4e-_4e$IS!!O$IS$I`-_$I`$Ib!!O$Ib$Je-_$Je$Jg!!O$Jg$Kh-_$Kh%#t!!O%#t&/x-_&/x&Et!!O&Et&FV-_&FV;'S!!O;'S;:j!&Q;:j;=`4s<%l?&r-_?&r?Ah!!O?Ah?BY$q?BY?Mn!!O?MnO$q!a!&TP;=`<%l!!O!V!&achS!a`!cpOq*Vqr!'lrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!b!Ey!b#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!'uhhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!)a!O!P1n!P!Q*V!Q!_1n!_!a*V!a!f1n!f!g!,]!g#W1n#W#X!<y#X#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!)jdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex}1n}!O!*x!O!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!+TbhS!a`!cp!dPOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!,fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!q1n!q!r!-t!r#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!-}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!e1n!e!f!/]!f#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!/fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!v1n!v!w!0t!w#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!0}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!{1n!{!|!2]!|#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!2fdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!r1n!r!s!3t!s#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!3}dhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a!g1n!g!h!5]!h#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!5fchS!a`!cpOq!6qqr!5]rs!7hsv!5]vw!;`wx!9[x!P!5]!P!Q!6q!Q!_!5]!_!`!6q!`!a!:j!a#s!5]#s$f!6q$f;'S!5];'S;=`!<s<%l?Ah!5]?Ah?BY!6q?BY?Mn!5]?MnO!6q!R!6xY!a`!cpOr!6qrs!7hsv!6qvw!8Swx!9[x!`!6q!`!a!:j!a;'S!6q;'S;=`!;Y<%lO!6qq!7mV!cpOv!7hvx!8Sx!`!7h!`!a!8q!a;'S!7h;'S;=`!9U<%lO!7hP!8VTO!`!8S!`!a!8f!a;'S!8S;'S;=`!8k<%lO!8SP!8kO{PP!8nP;=`<%l!8Sq!8xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!9XP;=`<%l!7ha!9aX!a`Or!9[rs!8Ssv!9[vw!8Sw!`!9[!`!a!9|!a;'S!9[;'S;=`!:d<%lO!9[a!:TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!:gP;=`<%l!9[!R!:sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;]P;=`<%l!6qT!;ebhSOq!8Sqr!;`rs!8Ssw!;`wx!8Sx!P!;`!P!Q!8S!Q!_!;`!_!`!8S!`!a!8f!a#s!;`#s$f!8S$f;'S!;`;'S;=`!<m<%l?Ah!;`?Ah?BY!8S?BY?Mn!;`?MnO!8ST!<pP;=`<%l!;`!V!<vP;=`<%l!5]!V!=SdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#c1n#c#d!>b#d#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!>kdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#V1n#V#W!?y#W#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!@SdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#h1n#h#i!Ab#i#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!AkdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#m1n#m#n!By#n#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!CSdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#d1n#d#e!Db#e#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!DkdhS!a`!cpOq*Vqr1nrs(Vsv1nvw0pwx)ex!P1n!P!Q*V!Q!_1n!_!a*V!a#X1n#X#Y!5]#Y#s1n#s$f*V$f;'S1n;'S;=`3P<%l?Ah1n?Ah?BY*V?BY?Mn1n?MnO*V!V!FSchS!a`!cpOq!G_qr!Eyrs!HUsv!Eyvw!Ncwx!Jvx!P!Ey!P!Q!G_!Q!_!Ey!_!a!G_!a!b##T!b#s!Ey#s$f!G_$f;'S!Ey;'S;=`#$i<%l?Ah!Ey?Ah?BY!G_?BY?Mn!Ey?MnO!G_!R!GfY!a`!cpOr!G_rs!HUsv!G_vw!Hpwx!Jvx!a!G_!a!b!Lv!b;'S!G_;'S;=`!N]<%lO!G_q!HZV!cpOv!HUvx!Hpx!a!HU!a!b!Iq!b;'S!HU;'S;=`!Jp<%lO!HUP!HsTO!a!Hp!a!b!IS!b;'S!Hp;'S;=`!Ik<%lO!HpP!IVTO!`!Hp!`!a!If!a;'S!Hp;'S;=`!Ik<%lO!HpP!IkOxPP!InP;=`<%l!Hpq!IvV!cpOv!HUvx!Hpx!`!HU!`!a!J]!a;'S!HU;'S;=`!Jp<%lO!HUq!JdS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!JsP;=`<%l!HUa!J{X!a`Or!Jvrs!Hpsv!Jvvw!Hpw!a!Jv!a!b!Kh!b;'S!Jv;'S;=`!Lp<%lO!Jva!KmX!a`Or!Jvrs!Hpsv!Jvvw!Hpw!`!Jv!`!a!LY!a;'S!Jv;'S;=`!Lp<%lO!Jva!LaT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!LsP;=`<%l!Jv!R!L}Y!a`!cpOr!G_rs!HUsv!G_vw!Hpwx!Jvx!`!G_!`!a!Mm!a;'S!G_;'S;=`!N]<%lO!G_!R!MvV!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!N`P;=`<%l!G_T!NhbhSOq!Hpqr!Ncrs!Hpsw!Ncwx!Hpx!P!Nc!P!Q!Hp!Q!_!Nc!_!a!Hp!a!b# p!b#s!Nc#s$f!Hp$f;'S!Nc;'S;=`#!}<%l?Ah!Nc?Ah?BY!Hp?BY?Mn!Nc?MnO!HpT# ubhSOq!Hpqr!Ncrs!Hpsw!Ncwx!Hpx!P!Nc!P!Q!Hp!Q!_!Nc!_!`!Hp!`!a!If!a#s!Nc#s$f!Hp$f;'S!Nc;'S;=`#!}<%l?Ah!Nc?Ah?BY!Hp?BY?Mn!Nc?MnO!HpT##QP;=`<%l!Nc!V##^chS!a`!cpOq!G_qr!Eyrs!HUsv!Eyvw!Ncwx!Jvx!P!Ey!P!Q!G_!Q!_!Ey!_!`!G_!`!a!Mm!a#s!Ey#s$f!G_$f;'S!Ey;'S;=`#$i<%l?Ah!Ey?Ah?BY!G_?BY?Mn!Ey?MnO!G_!V#$lP;=`<%l!Ey!V#$zXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [Hz, jz, Gz, qz, Yz, Fz, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function rS(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i of r.getChildren(J1)) {
    let o = i.getChild(Tz), n = i.getChild(lf) || i.getChild(eS);
    o && (t[e.read(o.from, o.to)] = n ? n.type.id == lf ? e.read(n.from + 1, n.to - 1) : e.read(n.from, n.to) : "");
  }
  return t;
}
function NO(r, e) {
  let t = r.getChild(Ez);
  return t ? e.read(t.from, t.to) : " ";
}
function Pc(r, e, t) {
  let i;
  for (let o of t)
    if (!o.attrs || o.attrs(i || (i = rS(r.node.parent.firstChild, e))))
      return { parser: o.parser };
  return null;
}
function eN(r = [], e = []) {
  let t = [], i = [], o = [], n = [];
  for (let a of r)
    (a.tag == "script" ? t : a.tag == "style" ? i : a.tag == "textarea" ? o : n).push(a);
  let s = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let a of e)
    (s[a.name] || (s[a.name] = [])).push(a);
  return lD((a, l) => {
    let u = a.type.id;
    if (u == $z)
      return Pc(a, l, t);
    if (u == Rz)
      return Pc(a, l, i);
    if (u == _z)
      return Pc(a, l, o);
    if (u == K1 && n.length) {
      let h = a.node, c = h.firstChild, d = c && NO(c, l), f;
      if (d) {
        for (let p of n)
          if (p.tag == d && (!p.attrs || p.attrs(f || (f = rS(h, l))))) {
            let g = h.lastChild;
            return { parser: p.parser, overlay: [{ from: c.to, to: g.type.id == Mz ? g.from : h.to }] };
          }
      }
    }
    if (s && u == J1) {
      let h = a.node, c;
      if (c = h.firstChild) {
        let d = s[l.read(c.from, c.to)];
        if (d)
          for (let f of d) {
            if (f.tagName && f.tagName != NO(h.parent, l))
              continue;
            let p = h.lastChild;
            if (p.type.id == lf) {
              let g = p.from + 1, b = p.lastChild, m = p.to - (b && b.isError ? 0 : 1);
              if (m > g)
                return { parser: f.parser, overlay: [{ from: g, to: m }] };
            } else if (p.type.id == eS)
              return { parser: f.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const cs = ["_blank", "_self", "_top", "_parent"], kc = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], Ec = ["get", "post", "put", "delete"], Tc = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], It = ["true", "false"], F = {}, Qh = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: cs,
      hreflang: null
    }
  },
  abbr: F,
  acronym: F,
  address: F,
  applet: F,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: F,
  aside: F,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: F,
  base: { attrs: { href: null, target: cs } },
  basefont: F,
  bdi: F,
  bdo: F,
  big: F,
  blockquote: { attrs: { cite: null } },
  body: F,
  br: F,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: Tc,
      formmethod: Ec,
      formnovalidate: ["novalidate"],
      formtarget: cs,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: F,
  center: F,
  cite: F,
  code: F,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: F,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: F,
  dir: F,
  div: F,
  dl: F,
  dt: F,
  em: F,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: F,
  figure: F,
  font: F,
  footer: F,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": kc,
      autocomplete: ["on", "off"],
      enctype: Tc,
      method: Ec,
      novalidate: ["novalidate"],
      target: cs
    }
  },
  frame: F,
  frameset: F,
  h1: F,
  h2: F,
  h3: F,
  h4: F,
  h5: F,
  h6: F,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: F,
  hgroup: F,
  hr: F,
  html: {
    attrs: { manifest: null }
  },
  i: F,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: Tc,
      formmethod: Ec,
      formnovalidate: ["novalidate"],
      formtarget: cs,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: F,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: F,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: F,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: kc,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: F,
  noframes: F,
  noscript: F,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: F,
  param: { attrs: { name: null, value: null } },
  pre: F,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: F,
  rt: F,
  ruby: F,
  s: F,
  samp: F,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: kc
    }
  },
  section: F,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: F,
  source: { attrs: { src: null, type: null, media: null } },
  span: F,
  strike: F,
  strong: F,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: F,
  summary: F,
  sup: F,
  table: F,
  tbody: F,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: F,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: F,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: F,
  time: { attrs: { datetime: null } },
  title: F,
  tr: F,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  tt: F,
  u: F,
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: F,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: F
}, oS = {
  accesskey: null,
  class: null,
  contenteditable: It,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: It,
  autocorrect: It,
  autocapitalize: It,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  onclick: null,
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": It,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": It,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": It,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": It,
  "aria-hidden": It,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": It,
  "aria-multiselectable": It,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": It,
  "aria-relevant": null,
  "aria-required": It,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, tN = /* @__PURE__ */ Object.keys(Qh), VO = /* @__PURE__ */ Object.keys(oS);
function Vn(r, e, t = r.length) {
  if (!e)
    return "";
  let i = e.firstChild, o = i && i.getChild("TagName");
  return o ? r.sliceString(o.from, Math.min(o.to, t)) : "";
}
function Ph(r, e = !1) {
  for (let t = r.parent; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function nS(r, e) {
  let t = Qh[Vn(r, Ph(e, !0))];
  return (t == null ? void 0 : t.children) || tN;
}
function Kp(r, e) {
  let t = [];
  for (let i = e; i = Ph(i); ) {
    let o = Vn(r, i);
    if (o && i.lastChild.name == "CloseTag")
      break;
    o && t.indexOf(o) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && t.push(o);
  }
  return t;
}
const sS = /^[:\-\.\w\u00b7-\uffff]*$/;
function ZO(r, e, t, i) {
  let o = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: nS(r.doc, e).map((n) => ({ label: n, type: "type" })).concat(Kp(r.doc, e).map((n, s) => ({ label: "/" + n, apply: "/" + n + o, type: "type", boost: 99 - s }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function LO(r, e, t, i) {
  let o = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: Kp(r.doc, e).map((n, s) => ({ label: n, apply: n + o, type: "type", boost: 99 - s })),
    validFor: sS
  };
}
function iN(r, e, t) {
  let i = [], o = 0;
  for (let n of nS(r.doc, e))
    i.push({ label: "<" + n, type: "type" });
  for (let n of Kp(r.doc, e))
    i.push({ label: "</" + n + ">", type: "type", boost: 99 - o++ });
  return { from: t, to: t, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function rN(r, e, t, i) {
  let o = Ph(e), n = o ? Qh[Vn(r.doc, o)] : null, s = n && n.attrs ? Object.keys(n.attrs).concat(VO) : VO;
  return {
    from: t,
    to: i,
    options: s.map((a) => ({ label: a, type: "property" })),
    validFor: sS
  };
}
function oN(r, e, t, i) {
  var o;
  let n = (o = e.parent) === null || o === void 0 ? void 0 : o.getChild("AttributeName"), s = [], a;
  if (n) {
    let l = r.sliceDoc(n.from, n.to), u = oS[l];
    if (!u) {
      let h = Ph(e), c = h ? Qh[Vn(r.doc, h)] : null;
      u = (c == null ? void 0 : c.attrs) && c.attrs[l];
    }
    if (u) {
      let h = r.sliceDoc(t, i).toLowerCase(), c = '"', d = '"';
      /^['"]/.test(h) ? (a = h[0] == '"' ? /^[^"]*$/ : /^[^']*$/, c = "", d = r.sliceDoc(i, i + 1) == h[0] ? "" : h[0], h = h.slice(1), t++) : a = /^[^\s<>='"]*$/;
      for (let f of u)
        s.push({ label: f, apply: c + f + d, type: "constant" });
    }
  }
  return { from: t, to: i, options: s, validFor: a };
}
function nN(r) {
  let { state: e, pos: t } = r, i = ze(e).resolveInner(t), o = i.resolve(t, -1);
  for (let n = t, s; i == o && (s = o.childBefore(n)); ) {
    let a = s.lastChild;
    if (!a || !a.type.isError || a.from < a.to)
      break;
    i = o = s, n = a.from;
  }
  return o.name == "TagName" ? o.parent && /CloseTag$/.test(o.parent.name) ? LO(e, o, o.from, t) : ZO(e, o, o.from, t) : o.name == "StartTag" ? ZO(e, o, t, t) : o.name == "StartCloseTag" || o.name == "IncompleteCloseTag" ? LO(e, o, t, t) : r.explicit && (o.name == "OpenTag" || o.name == "SelfClosingTag") || o.name == "AttributeName" ? rN(e, o, o.name == "AttributeName" ? o.from : t, t) : o.name == "Is" || o.name == "AttributeValue" || o.name == "UnquotedAttributeValue" ? oN(e, o, o.name == "Is" ? t : o.from, t) : r.explicit && (i.name == "Element" || i.name == "Text" || i.name == "Document") ? iN(e, o, t) : null;
}
const hf = /* @__PURE__ */ hr.define({
  parser: /* @__PURE__ */ Jz.configure({
    props: [
      /* @__PURE__ */ Yo.add({
        Element(r) {
          let e = /^(\s*)(<\/)?/.exec(r.textAfter);
          return r.node.to <= r.pos + e[0].length ? r.continue() : r.lineIndent(r.node.from) + (e[2] ? 0 : r.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        },
        Document(r) {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length < r.node.to)
            return r.continue();
          let e = null, t;
          for (let i = r.node; ; ) {
            let o = i.lastChild;
            if (!o || o.name != "Element" || o.to != i.to)
              break;
            e = i = o;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? r.lineIndent(e.from) + r.unit : null;
        }
      }),
      /* @__PURE__ */ Fo.add({
        Element(r) {
          let e = r.firstChild, t = r.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : r.to };
        }
      })
    ],
    wrap: /* @__PURE__ */ eN([
      {
        tag: "script",
        attrs(r) {
          return !r.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(r.type);
        },
        parser: Zr.parser
      },
      {
        tag: "style",
        attrs(r) {
          return (!r.lang || r.lang == "css") && (!r.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(r.type));
        },
        parser: sf.parser
      }
    ])
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function sN(r = {}) {
  let e = hf;
  return r.matchClosingTags === !1 && (e = e.configure({ dialect: "noMatch" })), new qn(e, [
    hf.data.of({ autocomplete: nN }),
    r.autoCloseTags !== !1 ? aN : [],
    Dl().support,
    af().support
  ]);
}
const aN = /* @__PURE__ */ B.inputHandler.of((r, e, t, i) => {
  if (r.composing || r.state.readOnly || e != t || i != ">" && i != "/" || !hf.isActiveAt(r.state, e, -1))
    return !1;
  let { state: o } = r, n = o.changeByRange((s) => {
    var a, l, u;
    let { head: h } = s, c = ze(o).resolveInner(h, -1), d;
    if ((c.name == "TagName" || c.name == "StartTag") && (c = c.parent), i == ">" && c.name == "OpenTag") {
      if (((l = (a = c.parent) === null || a === void 0 ? void 0 : a.lastChild) === null || l === void 0 ? void 0 : l.name) != "CloseTag" && (d = Vn(o.doc, c.parent, h)))
        return { range: D.cursor(h + 1), changes: { from: h, insert: `></${d}>` } };
    } else if (i == "/" && c.name == "OpenTag") {
      let f = c.parent, p = f == null ? void 0 : f.parent;
      if (f.from == h - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (d = Vn(o.doc, p, h))) {
        let g = `/${d}>`;
        return { range: D.cursor(h + g.length), changes: { from: h, insert: g } };
      }
    }
    return { range: s };
  });
  return n.changes.empty ? !1 : (r.dispatch(n, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), lN = Uo({
  String: O.string,
  Number: O.number,
  "True False": O.bool,
  PropertyName: O.propertyName,
  Null: O.null,
  ",": O.separator,
  "[ ]": O.squareBracket,
  "{ }": O.brace
}), uN = cr.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: "⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [lN],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), hN = /* @__PURE__ */ hr.define({
  parser: /* @__PURE__ */ uN.configure({
    props: [
      /* @__PURE__ */ Yo.add({
        Object: /* @__PURE__ */ Yi({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ Yi({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Fo.add({
        "Object Array": mh
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function cN() {
  return new qn(hN);
}
const dN = 34, WO = 1, fN = 2, $c = 3, bl = 4, pN = 5, gN = 6, mN = 7, bN = 8, ON = 9, vN = 10, wN = 11, yN = 12, xN = 13, SN = 14, CN = 15, QN = 16, PN = 17, kN = 18, EN = 19, aS = 20, lS = 21, TN = 22;
function cf(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 48 && r <= 57;
}
function $N(r) {
  return r >= 48 && r <= 57 || r >= 97 && r <= 102 || r >= 65 && r <= 70;
}
function on(r, e, t) {
  for (let i = !1; ; ) {
    if (r.next < 0)
      return;
    if (r.next == e && !i) {
      r.advance();
      return;
    }
    i = t && !i && r.next == 92, r.advance();
  }
}
function uS(r, e) {
  for (; !(r.next != 95 && !cf(r.next)); )
    e != null && (e += String.fromCharCode(r.next)), r.advance();
  return e;
}
function RN(r) {
  if (r.next == 39 || r.next == 34 || r.next == 96) {
    let e = r.next;
    r.advance(), on(r, e, !1);
  } else
    uS(r);
}
function IO(r, e) {
  for (; ; ) {
    if (r.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (r.next < 48 || r.next > 57)
      break;
    r.advance();
  }
  if (r.next == 69 || r.next == 101)
    for (r.advance(), (r.next == 43 || r.next == 45) && r.advance(); r.next >= 48 && r.next <= 57; )
      r.advance();
}
function UO(r) {
  for (; !(r.next < 0 || r.next == 10); )
    r.advance();
}
function Jo(r, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == r)
      return !0;
  return !1;
}
const YO = ` 	\r
`;
function hS(r, e, t) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = pN, i.null = i.unknown = gN;
  for (let o of r.split(" "))
    o && (i[o] = aS);
  for (let o of e.split(" "))
    o && (i[o] = lS);
  for (let o of (t || "").split(" "))
    o && (i[o] = TN);
  return i;
}
const _N = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", DN = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", df = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  charSetCasts: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: /* @__PURE__ */ hS(DN, _N)
};
function MN(r, e, t, i) {
  let o = {};
  for (let n in df)
    o[n] = (r.hasOwnProperty(n) ? r : df)[n];
  return e && (o.words = hS(e, t || "", i)), o;
}
function cS(r) {
  return new Ci((e) => {
    var t;
    let { next: i } = e;
    if (e.advance(), Jo(i, YO)) {
      for (; Jo(e.next, YO); )
        e.advance();
      e.acceptToken(dN);
    } else if (i == 39 || i == 34 && r.doubleQuotedStrings)
      on(e, i, r.backslashEscapes), e.acceptToken($c);
    else if (i == 35 && r.hashComments || i == 47 && e.next == 47 && r.slashComments)
      UO(e), e.acceptToken(WO);
    else if (i == 45 && e.next == 45 && (!r.spaceAfterDashes || e.peek(2) == 32))
      UO(e), e.acceptToken(WO);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let o = -1, n = 1; !(e.next < 0); )
        if (e.advance(), o == 42 && e.next == 47) {
          if (n--, !n) {
            e.advance();
            break;
          }
          o = -1;
        } else
          o == 47 && e.next == 42 ? (n++, o = -1) : o = e.next;
      e.acceptToken(fN);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), on(e, 39, !0);
    else if ((i == 110 || i == 78) && e.next == 39 && r.charSetCasts)
      e.advance(), on(e, 39, r.backslashEscapes), e.acceptToken($c);
    else if (i == 95 && r.charSetCasts)
      for (let o = 0; ; o++) {
        if (e.next == 39 && o > 1) {
          e.advance(), on(e, 39, r.backslashEscapes), e.acceptToken($c);
          break;
        }
        if (!cf(e.next))
          break;
        e.advance();
      }
    else if (i == 40)
      e.acceptToken(mN);
    else if (i == 41)
      e.acceptToken(bN);
    else if (i == 123)
      e.acceptToken(ON);
    else if (i == 125)
      e.acceptToken(vN);
    else if (i == 91)
      e.acceptToken(wN);
    else if (i == 93)
      e.acceptToken(yN);
    else if (i == 59)
      e.acceptToken(xN);
    else if (i == 48 && (e.next == 98 || e.next == 66) || (i == 98 || i == 66) && e.next == 39) {
      let o = e.next == 39;
      for (e.advance(); e.next == 48 || e.next == 49; )
        e.advance();
      o && e.next == 39 && e.advance(), e.acceptToken(bl);
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let o = e.next == 39;
      for (e.advance(); $N(e.next); )
        e.advance();
      o && e.next == 39 && e.advance(), e.acceptToken(bl);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      IO(e, !0), e.acceptToken(bl);
    else if (i == 46)
      e.acceptToken(SN);
    else if (i >= 48 && i <= 57)
      IO(e, !1), e.acceptToken(bl);
    else if (Jo(i, r.operatorChars)) {
      for (; Jo(e.next, r.operatorChars); )
        e.advance();
      e.acceptToken(CN);
    } else if (Jo(i, r.specialVar))
      e.next == i && e.advance(), RN(e), e.acceptToken(PN);
    else if (Jo(i, r.identifierQuotes))
      on(e, i, !1), e.acceptToken(EN);
    else if (i == 58 || i == 44)
      e.acceptToken(QN);
    else if (cf(i)) {
      let o = uS(e, String.fromCharCode(i));
      e.acceptToken((t = r.words[o.toLowerCase()]) !== null && t !== void 0 ? t : kN);
    }
  });
}
const dS = /* @__PURE__ */ cS(df), XN = /* @__PURE__ */ cr.deserialize({
  version: 14,
  states: "%dQ]QQOOO#kQRO'#DQO#rQQO'#CuO%RQQO'#CvO%YQQO'#CwO%aQQO'#CxOOQQ'#DQ'#DQOOQQ'#C{'#C{O&lQRO'#CyOOQQ'#Ct'#CtOOQQ'#Cz'#CzQ]QQOOQOQQOOO&vQQO,59aO'RQQO,59aO'WQQO'#DQOOQQ,59b,59bO'eQQO,59bOOQQ,59c,59cO'lQQO,59cOOQQ,59d,59dO'sQQO,59dOOQQ-E6y-E6yOOQQ,59`,59`OOQQ-E6x-E6xOOQQ'#C|'#C|OOQQ1G.{1G.{O&vQQO1G.{OOQQ1G.|1G.|OOQQ1G.}1G.}OOQQ1G/O1G/OP'zQQO'#C{POQQ-E6z-E6zOOQQ7+$g7+$g",
  stateData: "(R~OrOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUO~O^]ORtXStXTtXUtXVtXXtXZtX]tX_tX`tXatXbtXctXdtXetXftX~OqtX~P!dOa^Ob^Oc^O~ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOa_Ob_Oc_OdUOeUOfUO~OW`O~P#}OYbO~P#}O[dO~P#}ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUO~O]gOqmX~P%hOaiObiOciO~O^kO~OWtXYtX[tX~P!dOWlO~P#}OYmO~P#}O[nO~P#}O]gO~P#}O",
  goto: "#YuPPPPPPPPPPPPPPPPPPPPPPPPvzzzz!W![!b!vPPP!|TYOZeUORSTWZaceoT[OZQZORhZSWOZQaRQcSQeTZfWaceoQj]RqkeVORSTWZaceo",
  nodeNames: "⚠ LineComment BlockComment String Number Bool Null ( ) [ ] { } ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 36,
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, dS],
  topRules: { Script: [0, 23] },
  tokenPrec: 0
});
function ff(r) {
  let e = r.cursor().moveTo(r.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function AN(r) {
  let e = /^[`'"](.*)[`'"]$/.exec(r);
  return e ? e[1] : r;
}
function zN(r, e) {
  return e.name == "Identifier" || e.name == "QuotedIdentifier" || e.name == "Keyword" && /^public$/i.test(r.sliceDoc(e.from, e.to));
}
function FO(r, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let i = ff(e);
    if (!i || !zN(r, i))
      return t;
    t.unshift(AN(r.sliceDoc(i.from, i.to))), e = ff(i);
  }
}
function NN(r, e) {
  let t = ze(r).resolveInner(e, -1);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? r.sliceDoc(t.from, t.from + 1) : null,
    parents: FO(r, ff(t))
  } : t.name == "." ? {
    from: e,
    quoted: null,
    parents: FO(r, t)
  } : { from: e, quoted: null, parents: [], empty: !0 };
}
function VN(r, e) {
  return r ? e.map((t) => Object.assign(Object.assign({}, t), { label: r + t.label + r, apply: void 0 })) : e;
}
const ZN = /^\w*$/, LN = /^[`'"]?\w*[`'"]?$/;
class Jp {
  constructor() {
    this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return t[e] || (t[e] = new Jp());
  }
  childCompletions(e) {
    return this.children ? Object.keys(this.children).filter((t) => t).map((t) => ({ label: t, type: e })) : [];
  }
}
function WN(r, e, t, i) {
  let o = new Jp(), n = o.child(i || "");
  for (let s in r) {
    let a = s.indexOf("."), u = (a > -1 ? o.child(s.slice(0, a)) : n).child(a > -1 ? s.slice(a + 1) : s);
    u.list = r[s].map((h) => typeof h == "string" ? { label: h, type: "property" } : h);
  }
  n.list = (e || n.childCompletions("type")).concat(t ? n.child(t).list : []);
  for (let s in o.children) {
    let a = o.child(s);
    a.list.length || (a.list = a.childCompletions("type"));
  }
  return o.list = n.list.concat(o.childCompletions("type")), (s) => {
    let { parents: a, from: l, quoted: u, empty: h } = NN(s.state, s.pos);
    if (h && !s.explicit)
      return null;
    let c = o;
    for (let f of a) {
      for (; !c.children || !c.children[f]; )
        if (c == o)
          c = n;
        else if (c == n && t)
          c = c.child(t);
        else
          return null;
      c = c.child(f);
    }
    let d = u && s.state.sliceDoc(s.pos, s.pos + 1) == u;
    return {
      from: l,
      to: d ? s.pos + 1 : void 0,
      options: VN(u, c.list),
      validFor: u ? LN : ZN
    };
  };
}
function IN(r, e) {
  let t = Object.keys(r).map((i) => ({
    label: e ? i.toUpperCase() : i,
    type: r[i] == lS ? "type" : r[i] == aS ? "keyword" : "variable",
    boost: -1
  }));
  return y1(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], Ip(t));
}
let UN = /* @__PURE__ */ XN.configure({
  props: [
    /* @__PURE__ */ Yo.add({
      Statement: /* @__PURE__ */ Yi()
    }),
    /* @__PURE__ */ Fo.add({
      Statement(r) {
        return { from: r.firstChild.to, to: r.to };
      },
      BlockComment(r) {
        return { from: r.from + 2, to: r.to - 2 };
      }
    }),
    /* @__PURE__ */ Uo({
      Keyword: O.keyword,
      Type: O.typeName,
      Builtin: /* @__PURE__ */ O.standard(O.name),
      Bool: O.bool,
      Null: O.null,
      Number: O.number,
      String: O.string,
      Identifier: O.name,
      QuotedIdentifier: /* @__PURE__ */ O.special(O.string),
      SpecialVar: /* @__PURE__ */ O.special(O.name),
      LineComment: O.lineComment,
      BlockComment: O.blockComment,
      Operator: O.operator,
      "Semi Punctuation": O.punctuation,
      "( )": O.paren,
      "{ }": O.brace,
      "[ ]": O.squareBracket
    })
  ]
});
class eg {
  constructor(e, t) {
    this.dialect = e, this.language = t;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = MN(e, e.keywords, e.types, e.builtin), i = hr.define({
      parser: UN.configure({
        tokenizers: [{ from: dS, to: cS(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new eg(t, i);
  }
}
function YN(r, e = !1) {
  return IN(r.dialect.words, e);
}
function FN(r, e = !1) {
  return r.language.data.of({
    autocomplete: YN(r, e)
  });
}
function BN(r) {
  return r.schema ? WN(r.schema, r.tables, r.defaultTable, r.defaultSchema) : () => null;
}
function qN(r) {
  return r.schema ? (r.dialect || fS).language.data.of({
    autocomplete: BN(r)
  }) : [];
}
function HN(r = {}) {
  let e = r.dialect || fS;
  return new qn(e.language, [qN(r), FN(e, !!r.upperCaseKeywords)]);
}
const fS = /* @__PURE__ */ eg.define({}), jN = (r) => (Tv("data-v-b26a3bdf"), r = r(), $v(), r), GN = /* @__PURE__ */ jN(() => /* @__PURE__ */ Bn("div", { id: "code" }, null, -1)), KN = [
  GN
], JN = /* @__PURE__ */ to({
  __name: "codeide",
  props: {
    code: {
      type: String,
      default: ""
    },
    language: {
      type: String,
      default: "javascript"
    }
  },
  emits: ["change", "keypress", "keydown"],
  setup(r, { emit: e }) {
    const t = r, i = gt();
    let o = null;
    function n(s) {
      switch (s) {
        case "java":
          return [yA()];
        case "javascript":
          return [Dl()];
        case "css":
          return [af()];
        case "html":
          return [af(), sN(), Dl()];
        case "json":
          return [cN()];
        case "sql":
          return [HN()];
        default:
          return [Dl()];
      }
    }
    return yi(() => t.code, (s, a) => {
      if (o && s !== a) {
        const l = o.state.doc, u = { from: 0, to: l ? l.length : 0, insert: s }, h = o.state.update({
          changes: u
        });
        o.dispatch(h);
      }
    }), io(() => {
      var a;
      const s = be.create({
        doc: `${t.code}`,
        extensions: [
          GX,
          Pa.of(l1),
          D1({
            defaultKeymap: !0
          }),
          ...n(t.language),
          lA()
        ]
      });
      o = new B({
        state: s,
        parent: (a = i.value) == null ? void 0 : a.children.code
      }), o == null || o.dom.addEventListener("keyup", (l) => {
        e("change", o == null ? void 0 : o.state.doc.toString());
      });
    }), (s, a) => (et(), Fr("div", {
      class: "ns-code-ide-box",
      ref_key: "RefMainBox",
      ref: i
    }, KN, 512));
  }
}), eV = `.ns-code-ide-box[data-v-b26a3bdf]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;overflow-y:auto}.ns-code-ide-box #code[data-v-b26a3bdf]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;overflow-y:auto;text-align:left}
`, tV = /* @__PURE__ */ Sa(JN, [["styles", [eV]], ["__scopeId", "data-v-b26a3bdf"]]);
class Nt {
  constructor(e) {
    this.table = e;
  }
  //////////////////////////////////////////
  /////////////// DataLoad /////////////////
  //////////////////////////////////////////
  reloadData(e, t, i) {
    return this.table.dataLoader.load(e, void 0, void 0, void 0, t, i);
  }
  //////////////////////////////////////////
  ///////////// Localization ///////////////
  //////////////////////////////////////////
  langText() {
    return this.table.modules.localize.getText(...arguments);
  }
  langBind() {
    return this.table.modules.localize.bind(...arguments);
  }
  langLocale() {
    return this.table.modules.localize.getLocale(...arguments);
  }
  //////////////////////////////////////////
  ////////// Inter Table Comms /////////////
  //////////////////////////////////////////
  commsConnections() {
    return this.table.modules.comms.getConnections(...arguments);
  }
  commsSend() {
    return this.table.modules.comms.send(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Layout  /////////////////
  //////////////////////////////////////////
  layoutMode() {
    return this.table.modules.layout.getMode();
  }
  layoutRefresh(e) {
    return this.table.modules.layout.layout(e);
  }
  //////////////////////////////////////////
  /////////////// Event Bus ////////////////
  //////////////////////////////////////////
  subscribe() {
    return this.table.eventBus.subscribe(...arguments);
  }
  unsubscribe() {
    return this.table.eventBus.unsubscribe(...arguments);
  }
  subscribed(e) {
    return this.table.eventBus.subscribed(e);
  }
  subscriptionChange() {
    return this.table.eventBus.subscriptionChange(...arguments);
  }
  dispatch() {
    return this.table.eventBus.dispatch(...arguments);
  }
  chain() {
    return this.table.eventBus.chain(...arguments);
  }
  confirm() {
    return this.table.eventBus.confirm(...arguments);
  }
  dispatchExternal() {
    return this.table.externalEvents.dispatch(...arguments);
  }
  subscribedExternal(e) {
    return this.table.externalEvents.subscribed(e);
  }
  subscriptionChangeExternal() {
    return this.table.externalEvents.subscriptionChange(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Options /////////////////
  //////////////////////////////////////////
  options(e) {
    return this.table.options[e];
  }
  setOption(e, t) {
    return typeof t < "u" && (this.table.options[e] = t), this.table.options[e];
  }
  //////////////////////////////////////////
  /////////// Deprecation Checks ///////////
  //////////////////////////////////////////
  deprecationCheck(e, t) {
    return this.table.deprecationAdvisor.check(e, t);
  }
  deprecationCheckMsg(e, t) {
    return this.table.deprecationAdvisor.checkMsg(e, t);
  }
  deprecationMsg(e) {
    return this.table.deprecationAdvisor.msg(e);
  }
  //////////////////////////////////////////
  //////////////// Modules /////////////////
  //////////////////////////////////////////
  module(e) {
    return this.table.module(e);
  }
}
class _e {
  static elVisible(e) {
    return !(e.offsetWidth <= 0 && e.offsetHeight <= 0);
  }
  static elOffset(e) {
    var t = e.getBoundingClientRect();
    return {
      top: t.top + window.pageYOffset - document.documentElement.clientTop,
      left: t.left + window.pageXOffset - document.documentElement.clientLeft
    };
  }
  static deepClone(e, t, i = []) {
    var o = {}.__proto__, n = [].__proto__;
    t || (t = Object.assign(Array.isArray(e) ? [] : {}, e));
    for (var s in e) {
      let a = e[s], l, u;
      a != null && typeof a == "object" && (a.__proto__ === o || a.__proto__ === n) && (l = i.findIndex((h) => h.subject === a), l > -1 ? t[s] = i[l].copy : (u = Object.assign(Array.isArray(a) ? [] : {}, a), i.unshift({ subject: a, copy: u }), t[s] = this.deepClone(a, u, i)));
    }
    return t;
  }
}
class tg extends Nt {
  constructor(e, t, i) {
    super(e), this.element = t, this.container = this._lookupContainer(), this.parent = i, this.reversedX = !1, this.childPopup = null, this.blurable = !1, this.blurCallback = null, this.blurEventsBound = !1, this.renderedCallback = null, this.visible = !1, this.hideable = !0, this.element.classList.add("tabulator-popup-container"), this.blurEvent = this.hide.bind(this, !1), this.escEvent = this._escapeCheck.bind(this), this.destroyBinding = this.tableDestroyed.bind(this), this.destroyed = !1;
  }
  tableDestroyed() {
    this.destroyed = !0, this.hide(!0);
  }
  _lookupContainer() {
    var e = this.table.options.popupContainer;
    return typeof e == "string" ? (e = document.querySelector(e), e || console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)")) : e === !0 && (e = this.table.element), e && !this._checkContainerIsParent(e) && (e = !1, console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)")), e || (e = document.body), e;
  }
  _checkContainerIsParent(e, t = this.table.element) {
    return e === t ? !0 : t.parentNode ? this._checkContainerIsParent(e, t.parentNode) : !1;
  }
  renderCallback(e) {
    this.renderedCallback = e;
  }
  containerEventCoords(e) {
    var t = !(e instanceof MouseEvent), i = t ? e.touches[0].pageX : e.pageX, o = t ? e.touches[0].pageY : e.pageY;
    if (this.container !== document.body) {
      let n = _e.elOffset(this.container);
      i -= n.left, o -= n.top;
    }
    return { x: i, y: o };
  }
  elementPositionCoords(e, t = "right") {
    var i = _e.elOffset(e), o, n, s;
    switch (this.container !== document.body && (o = _e.elOffset(this.container), i.left -= o.left, i.top -= o.top), t) {
      case "right":
        n = i.left + e.offsetWidth, s = i.top - 1;
        break;
      case "bottom":
        n = i.left, s = i.top + e.offsetHeight;
        break;
      case "left":
        n = i.left, s = i.top - 1;
        break;
      case "top":
        n = i.left, s = i.top;
        break;
      case "center":
        n = i.left + e.offsetWidth / 2, s = i.top + e.offsetHeight / 2;
        break;
    }
    return { x: n, y: s, offset: i };
  }
  show(e, t) {
    var i, o, n, s, a;
    return this.destroyed || this.table.destroyed ? this : (e instanceof HTMLElement ? (n = e, a = this.elementPositionCoords(e, t), s = a.offset, i = a.x, o = a.y) : typeof e == "number" ? (s = { top: 0, left: 0 }, i = e, o = t) : (a = this.containerEventCoords(e), i = a.x, o = a.y, this.reversedX = !1), this.element.style.top = o + "px", this.element.style.left = i + "px", this.container.appendChild(this.element), typeof this.renderedCallback == "function" && this.renderedCallback(), this._fitToScreen(i, o, n, s, t), this.visible = !0, this.subscribe("table-destroy", this.destroyBinding), this.element.addEventListener("mousedown", (l) => {
      l.stopPropagation();
    }), this);
  }
  _fitToScreen(e, t, i, o, n) {
    var s = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
    if ((e + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) && (this.element.style.left = "", i ? this.element.style.right = this.container.offsetWidth - o.left + "px" : this.element.style.right = this.container.offsetWidth - e + "px", this.reversedX = !0), t + this.element.offsetHeight > Math.max(this.container.offsetHeight, s ? this.container.scrollHeight : 0))
      if (i)
        switch (n) {
          case "bottom":
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - i.offsetHeight - 1 + "px";
            break;
          default:
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + i.offsetHeight + 1 + "px";
        }
      else
        this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + "px";
  }
  isVisible() {
    return this.visible;
  }
  hideOnBlur(e) {
    return this.blurable = !0, this.visible && (setTimeout(() => {
      this.visible && (this.table.rowManager.element.addEventListener("scroll", this.blurEvent), this.subscribe("cell-editing", this.blurEvent), document.body.addEventListener("click", this.blurEvent), document.body.addEventListener("contextmenu", this.blurEvent), document.body.addEventListener("mousedown", this.blurEvent), window.addEventListener("resize", this.blurEvent), document.body.addEventListener("keydown", this.escEvent), this.blurEventsBound = !0);
    }, 100), this.blurCallback = e), this;
  }
  _escapeCheck(e) {
    e.keyCode == 27 && this.hide();
  }
  blockHide() {
    this.hideable = !1;
  }
  restoreHide() {
    this.hideable = !0;
  }
  hide(e = !1) {
    return this.visible && this.hideable && (this.blurable && this.blurEventsBound && (document.body.removeEventListener("keydown", this.escEvent), document.body.removeEventListener("click", this.blurEvent), document.body.removeEventListener("contextmenu", this.blurEvent), document.body.removeEventListener("mousedown", this.blurEvent), window.removeEventListener("resize", this.blurEvent), this.table.rowManager.element.removeEventListener("scroll", this.blurEvent), this.unsubscribe("cell-editing", this.blurEvent), this.blurEventsBound = !1), this.childPopup && this.childPopup.hide(), this.parent && (this.parent.childPopup = null), this.element.parentNode && this.element.parentNode.removeChild(this.element), this.visible = !1, this.blurCallback && !e && this.blurCallback(), this.unsubscribe("table-destroy", this.destroyBinding)), this;
  }
  child(e) {
    return this.childPopup && this.childPopup.hide(), this.childPopup = new tg(this.table, e, this), this.childPopup;
  }
}
class fe extends Nt {
  constructor(e, t) {
    super(e), this._handler = null;
  }
  initialize() {
  }
  ///////////////////////////////////
  ////// Options Registration ///////
  ///////////////////////////////////
  registerTableOption(e, t) {
    this.table.optionsList.register(e, t);
  }
  registerColumnOption(e, t) {
    this.table.columnManager.optionsList.register(e, t);
  }
  ///////////////////////////////////
  /// Public Function Registration ///
  ///////////////////////////////////
  registerTableFunction(e, t) {
    typeof this.table[e] > "u" ? this.table[e] = (...i) => (this.table.initGuard(e), t(...i)) : console.warn("Unable to bind table function, name already in use", e);
  }
  registerComponentFunction(e, t, i) {
    return this.table.componentFunctionBinder.bind(e, t, i);
  }
  ///////////////////////////////////
  ////////// Data Pipeline //////////
  ///////////////////////////////////
  registerDataHandler(e, t) {
    this.table.rowManager.registerDataPipelineHandler(e, t), this._handler = e;
  }
  registerDisplayHandler(e, t) {
    this.table.rowManager.registerDisplayPipelineHandler(e, t), this._handler = e;
  }
  displayRows(e) {
    var t = this.table.rowManager.displayRows.length - 1, i;
    if (this._handler && (i = this.table.rowManager.displayPipeline.findIndex((o) => o.handler === this._handler), i > -1 && (t = i)), e && (t = t + e), this._handler)
      return t > -1 ? this.table.rowManager.getDisplayRows(t) : this.activeRows();
  }
  activeRows() {
    return this.table.rowManager.activeRows;
  }
  refreshData(e, t) {
    t || (t = this._handler), t && this.table.rowManager.refreshActiveData(t, !1, e);
  }
  ///////////////////////////////////
  //////// Footer Management ////////
  ///////////////////////////////////
  footerAppend(e) {
    return this.table.footerManager.append(e);
  }
  footerPrepend(e) {
    return this.table.footerManager.prepend(e);
  }
  footerRemove(e) {
    return this.table.footerManager.remove(e);
  }
  ///////////////////////////////////
  //////// Popups Management ////////
  ///////////////////////////////////
  popup(e, t) {
    return new tg(this.table, e, t);
  }
  ///////////////////////////////////
  //////// Alert Management ////////
  ///////////////////////////////////
  alert(e, t) {
    return this.table.alertManager.alert(e, t);
  }
  clearAlert() {
    return this.table.alertManager.clear();
  }
}
var iV = {};
class Zn extends fe {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"], this.registerColumnOption("accessor"), this.registerColumnOption("accessorParams"), this.registerColumnOption("accessorData"), this.registerColumnOption("accessorDataParams"), this.registerColumnOption("accessorDownload"), this.registerColumnOption("accessorDownloadParams"), this.registerColumnOption("accessorClipboard"), this.registerColumnOption("accessorClipboardParams"), this.registerColumnOption("accessorPrint"), this.registerColumnOption("accessorPrintParams"), this.registerColumnOption("accessorHtmlOutput"), this.registerColumnOption("accessorHtmlOutputParams");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-retrieve", this.transformRow.bind(this));
  }
  //initialize column accessor
  initializeColumn(e) {
    var t = !1, i = {};
    this.allowedTypes.forEach((o) => {
      var n = "accessor" + (o.charAt(0).toUpperCase() + o.slice(1)), s;
      e.definition[n] && (s = this.lookupAccessor(e.definition[n]), s && (t = !0, i[n] = {
        accessor: s,
        params: e.definition[n + "Params"] || {}
      }));
    }), t && (e.modules.accessor = i);
  }
  lookupAccessor(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        Zn.accessors[e] ? t = Zn.accessors[e] : console.warn("Accessor Error - No such accessor found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply accessor to row
  transformRow(e, t) {
    var i = "accessor" + (t.charAt(0).toUpperCase() + t.slice(1)), o = e.getComponent(), n = _e.deepClone(e.data || {});
    return this.table.columnManager.traverse(function(s) {
      var a, l, u, h;
      s.modules.accessor && (l = s.modules.accessor[i] || s.modules.accessor.accessor || !1, l && (a = s.getFieldValue(n), a != "undefined" && (h = s.getComponent(), u = typeof l.params == "function" ? l.params(a, n, t, h, o) : l.params, s.setFieldValue(n, l.accessor(a, n, t, u, h, o)))));
    }), n;
  }
}
Zn.moduleName = "accessor";
Zn.accessors = iV;
var rV = {
  method: "GET"
};
function pf(r, e) {
  var t = [];
  if (e = e || "", Array.isArray(r))
    r.forEach((o, n) => {
      t = t.concat(pf(o, e ? e + "[" + n + "]" : n));
    });
  else if (typeof r == "object")
    for (var i in r)
      t = t.concat(pf(r[i], e ? e + "[" + i + "]" : i));
  else
    t.push({ key: e, value: r });
  return t;
}
function oV(r) {
  var e = pf(r), t = [];
  return e.forEach(function(i) {
    t.push(encodeURIComponent(i.key) + "=" + encodeURIComponent(i.value));
  }), t.join("&");
}
function pS(r, e, t) {
  return r && t && Object.keys(t).length && (!e.method || e.method.toLowerCase() == "get") && (e.method = "get", r += (r.includes("?") ? "&" : "?") + oV(t)), r;
}
function nV(r, e, t) {
  var i;
  return new Promise((o, n) => {
    if (r = this.urlGenerator.call(this.table, r, e, t), e.method.toUpperCase() != "GET")
      if (i = typeof this.table.options.ajaxContentType == "object" ? this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType], i) {
        for (var s in i.headers)
          e.headers || (e.headers = {}), typeof e.headers[s] > "u" && (e.headers[s] = i.headers[s]);
        e.body = i.body.call(this, r, e, t);
      } else
        console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
    r ? (typeof e.headers > "u" && (e.headers = {}), typeof e.headers.Accept > "u" && (e.headers.Accept = "application/json"), typeof e.headers["X-Requested-With"] > "u" && (e.headers["X-Requested-With"] = "XMLHttpRequest"), typeof e.mode > "u" && (e.mode = "cors"), e.mode == "cors" ? (typeof e.headers.Origin > "u" && (e.headers.Origin = window.location.origin), typeof e.credentials > "u" && (e.credentials = "same-origin")) : typeof e.credentials > "u" && (e.credentials = "include"), fetch(r, e).then((a) => {
      a.ok ? a.json().then((l) => {
        o(l);
      }).catch((l) => {
        n(l), console.warn("Ajax Load Error - Invalid JSON returned", l);
      }) : (console.error("Ajax Load Error - Connection Error: " + a.status, a.statusText), n(a));
    }).catch((a) => {
      console.error("Ajax Load Error - Connection Error: ", a), n(a);
    })) : (console.warn("Ajax Load Error - No URL Set"), o([]));
  });
}
function gf(r, e) {
  var t = [];
  if (e = e || "", Array.isArray(r))
    r.forEach((o, n) => {
      t = t.concat(gf(o, e ? e + "[" + n + "]" : n));
    });
  else if (typeof r == "object")
    for (var i in r)
      t = t.concat(gf(r[i], e ? e + "[" + i + "]" : i));
  else
    t.push({ key: e, value: r });
  return t;
}
var sV = {
  json: {
    headers: {
      "Content-Type": "application/json"
    },
    body: function(r, e, t) {
      return JSON.stringify(t);
    }
  },
  form: {
    headers: {},
    body: function(r, e, t) {
      var i = gf(t), o = new FormData();
      return i.forEach(function(n) {
        o.append(n.key, n.value);
      }), o;
    }
  }
};
class vi extends fe {
  constructor(e) {
    super(e), this.config = {}, this.url = "", this.urlGenerator = !1, this.params = !1, this.loaderPromise = !1, this.registerTableOption("ajaxURL", !1), this.registerTableOption("ajaxURLGenerator", !1), this.registerTableOption("ajaxParams", {}), this.registerTableOption("ajaxConfig", "get"), this.registerTableOption("ajaxContentType", "form"), this.registerTableOption("ajaxRequestFunc", !1), this.registerTableOption("ajaxRequesting", function() {
    }), this.registerTableOption("ajaxResponse", !1), this.contentTypeFormatters = vi.contentTypeFormatters;
  }
  //initialize setup options
  initialize() {
    this.loaderPromise = this.table.options.ajaxRequestFunc || vi.defaultLoaderPromise, this.urlGenerator = this.table.options.ajaxURLGenerator || vi.defaultURLGenerator, this.table.options.ajaxURL && this.setUrl(this.table.options.ajaxURL), this.setDefaultConfig(this.table.options.ajaxConfig), this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this)), this.subscribe("data-loading", this.requestDataCheck.bind(this)), this.subscribe("data-params", this.requestParams.bind(this)), this.subscribe("data-load", this.requestData.bind(this));
  }
  requestParams(e, t, i, o) {
    var n = this.table.options.ajaxParams;
    return n && (typeof n == "function" && (n = n.call(this.table)), o = Object.assign(o, n)), o;
  }
  requestDataCheck(e, t, i, o) {
    return !!(!e && this.url || typeof e == "string");
  }
  requestData(e, t, i, o, n) {
    var s;
    return !n && this.requestDataCheck(e) ? (e && this.setUrl(e), s = this.generateConfig(i), this.sendRequest(this.url, t, s)) : n;
  }
  setDefaultConfig(e = {}) {
    this.config = Object.assign({}, vi.defaultConfig), typeof e == "string" ? this.config.method = e : Object.assign(this.config, e);
  }
  //load config object
  generateConfig(e = {}) {
    var t = Object.assign({}, this.config);
    return typeof e == "string" ? t.method = e : Object.assign(t, e), t;
  }
  //set request url
  setUrl(e) {
    this.url = e;
  }
  //get request url
  getUrl() {
    return this.url;
  }
  //send ajax request
  sendRequest(e, t, i) {
    return this.table.options.ajaxRequesting.call(this.table, e, t) !== !1 ? this.loaderPromise(e, i, t).then((o) => (this.table.options.ajaxResponse && (o = this.table.options.ajaxResponse.call(this.table, e, t, o)), o)) : Promise.reject();
  }
}
vi.moduleName = "ajax";
vi.defaultConfig = rV;
vi.defaultURLGenerator = pS;
vi.defaultLoaderPromise = nV;
vi.contentTypeFormatters = sV;
var aV = {
  replace: function(r) {
    return this.table.setData(r);
  },
  update: function(r) {
    return this.table.updateOrAddData(r);
  },
  insert: function(r) {
    return this.table.addData(r);
  }
}, lV = {
  table: function(r) {
    var e = [], t = !0, i = this.table.columnManager.columns, o = [], n = [];
    return r = r.split(`
`), r.forEach(function(s) {
      e.push(s.split("	"));
    }), e.length && !(e.length === 1 && e[0].length < 2) ? (e[0].forEach(function(s) {
      var a = i.find(function(l) {
        return s && l.definition.title && s.trim() && l.definition.title.trim() === s.trim();
      });
      a ? o.push(a) : t = !1;
    }), t || (t = !0, o = [], e[0].forEach(function(s) {
      var a = i.find(function(l) {
        return s && l.field && s.trim() && l.field.trim() === s.trim();
      });
      a ? o.push(a) : t = !1;
    }), t || (o = this.table.columnManager.columnsByIndex)), t && e.shift(), e.forEach(function(s) {
      var a = {};
      s.forEach(function(l, u) {
        o[u] && (a[o[u].field] = l);
      }), n.push(a);
    }), n) : !1;
  }
};
class Xo extends fe {
  constructor(e) {
    super(e), this.mode = !0, this.pasteParser = function() {
    }, this.pasteAction = function() {
    }, this.customSelection = !1, this.rowRange = !1, this.blocked = !0, this.registerTableOption("clipboard", !1), this.registerTableOption("clipboardCopyStyled", !0), this.registerTableOption("clipboardCopyConfig", !1), this.registerTableOption("clipboardCopyFormatter", !1), this.registerTableOption("clipboardCopyRowRange", "active"), this.registerTableOption("clipboardPasteParser", "table"), this.registerTableOption("clipboardPasteAction", "insert"), this.registerColumnOption("clipboard"), this.registerColumnOption("titleClipboard");
  }
  initialize() {
    this.mode = this.table.options.clipboard, this.rowRange = this.table.options.clipboardCopyRowRange, (this.mode === !0 || this.mode === "copy") && this.table.element.addEventListener("copy", (e) => {
      var t, i, o;
      this.blocked || (e.preventDefault(), this.customSelection ? (t = this.customSelection, this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t))) : (o = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard"), i = this.table.modules.export.generateHTMLTable(o), t = i ? this.generatePlainContent(o) : "", this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t), i = this.table.options.clipboardCopyFormatter("html", i))), window.clipboardData && window.clipboardData.setData ? window.clipboardData.setData("Text", t) : e.clipboardData && e.clipboardData.setData ? (e.clipboardData.setData("text/plain", t), i && e.clipboardData.setData("text/html", i)) : e.originalEvent && e.originalEvent.clipboardData.setData && (e.originalEvent.clipboardData.setData("text/plain", t), i && e.originalEvent.clipboardData.setData("text/html", i)), this.dispatchExternal("clipboardCopied", t, i), this.reset());
    }), (this.mode === !0 || this.mode === "paste") && this.table.element.addEventListener("paste", (e) => {
      this.paste(e);
    }), this.setPasteParser(this.table.options.clipboardPasteParser), this.setPasteAction(this.table.options.clipboardPasteAction), this.registerTableFunction("copyToClipboard", this.copy.bind(this));
  }
  reset() {
    this.blocked = !0, this.customSelection = !1;
  }
  generatePlainContent(e) {
    var t = [];
    return e.forEach((i) => {
      var o = [];
      i.columns.forEach((n) => {
        var s = "";
        if (n)
          if (i.type === "group" && (n.value = n.component.getKey()), n.value === null)
            s = "";
          else
            switch (typeof n.value) {
              case "object":
                s = JSON.stringify(n.value);
                break;
              case "undefined":
                s = "";
                break;
              default:
                s = n.value;
            }
        o.push(s);
      }), t.push(o.join("	"));
    }), t.join(`
`);
  }
  copy(e, t) {
    var i, o;
    this.blocked = !1, this.customSelection = !1, (this.mode === !0 || this.mode === "copy") && (this.rowRange = e || this.table.options.clipboardCopyRowRange, typeof window.getSelection < "u" && typeof document.createRange < "u" ? (e = document.createRange(), e.selectNodeContents(this.table.element), i = window.getSelection(), i.toString() && t && (this.customSelection = i.toString()), i.removeAllRanges(), i.addRange(e)) : typeof document.selection < "u" && typeof document.body.createTextRange < "u" && (o = document.body.createTextRange(), o.moveToElementText(this.table.element), o.select()), document.execCommand("copy"), i && i.removeAllRanges());
  }
  //PASTE EVENT HANDLING
  setPasteAction(e) {
    switch (typeof e) {
      case "string":
        this.pasteAction = Xo.pasteActions[e], this.pasteAction || console.warn("Clipboard Error - No such paste action found:", e);
        break;
      case "function":
        this.pasteAction = e;
        break;
    }
  }
  setPasteParser(e) {
    switch (typeof e) {
      case "string":
        this.pasteParser = Xo.pasteParsers[e], this.pasteParser || console.warn("Clipboard Error - No such paste parser found:", e);
        break;
      case "function":
        this.pasteParser = e;
        break;
    }
  }
  paste(e) {
    var t, i, o;
    this.checkPaseOrigin(e) && (t = this.getPasteData(e), i = this.pasteParser.call(this, t), i ? (e.preventDefault(), this.table.modExists("mutator") && (i = this.mutateData(i)), o = this.pasteAction.call(this, i), this.dispatchExternal("clipboardPasted", t, i, o)) : this.dispatchExternal("clipboardPasteError", t));
  }
  mutateData(e) {
    var t = [];
    return Array.isArray(e) ? e.forEach((i) => {
      t.push(this.table.modules.mutator.transformRow(i, "clipboard"));
    }) : t = e, t;
  }
  checkPaseOrigin(e) {
    var t = !0;
    return (e.target.tagName != "DIV" || this.table.modules.edit.currentCell) && (t = !1), t;
  }
  getPasteData(e) {
    var t;
    return window.clipboardData && window.clipboardData.getData ? t = window.clipboardData.getData("Text") : e.clipboardData && e.clipboardData.getData ? t = e.clipboardData.getData("text/plain") : e.originalEvent && e.originalEvent.clipboardData.getData && (t = e.originalEvent.clipboardData.getData("text/plain")), t;
  }
}
Xo.moduleName = "clipboard";
Xo.pasteActions = aV;
Xo.pasteParsers = lV;
class uV {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, i, o) {
        return typeof t[i] < "u" ? t[i] : t._row.table.componentFunctionBinder.handle("row", t._row, i);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getTable() {
    return this._row.table;
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  _getSelf() {
    return this._row;
  }
}
class gS {
  constructor(e) {
    return this._cell = e, new Proxy(this, {
      get: function(t, i, o) {
        return typeof t[i] < "u" ? t[i] : t._cell.table.componentFunctionBinder.handle("cell", t._cell, i);
      }
    });
  }
  getValue() {
    return this._cell.getValue();
  }
  getOldValue() {
    return this._cell.getOldValue();
  }
  getInitialValue() {
    return this._cell.initialValue;
  }
  getElement() {
    return this._cell.getElement();
  }
  getRow() {
    return this._cell.row.getComponent();
  }
  getData(e) {
    return this._cell.row.getData(e);
  }
  getType() {
    return "cell";
  }
  getField() {
    return this._cell.column.getField();
  }
  getColumn() {
    return this._cell.column.getComponent();
  }
  setValue(e, t) {
    typeof t > "u" && (t = !0), this._cell.setValue(e, t);
  }
  restoreOldValue() {
    this._cell.setValueActual(this._cell.getOldValue());
  }
  restoreInitialValue() {
    this._cell.setValueActual(this._cell.initialValue);
  }
  checkHeight() {
    this._cell.checkHeight();
  }
  getTable() {
    return this._cell.table;
  }
  _getSelf() {
    return this._cell;
  }
}
class _a extends Nt {
  constructor(e, t) {
    super(e.table), this.table = e.table, this.column = e, this.row = t, this.element = null, this.value = null, this.initialValue, this.oldValue = null, this.modules = {}, this.height = null, this.width = null, this.minWidth = null, this.component = null, this.loaded = !1, this.build();
  }
  //////////////// Setup Functions /////////////////
  //generate element
  build() {
    this.generateElement(), this.setWidth(), this._configureCell(), this.setValueActual(this.column.getFieldValue(this.row.data)), this.initialValue = this.value;
  }
  generateElement() {
    this.element = document.createElement("div"), this.element.className = "tabulator-cell", this.element.setAttribute("role", "gridcell");
  }
  _configureCell() {
    var e = this.element, t = this.column.getField(), i = {
      top: "flex-start",
      bottom: "flex-end",
      middle: "center"
    }, o = {
      left: "flex-start",
      right: "flex-end",
      center: "center"
    };
    if (e.style.textAlign = this.column.hozAlign, this.column.vertAlign && (e.style.display = "inline-flex", e.style.alignItems = i[this.column.vertAlign] || "", this.column.hozAlign && (e.style.justifyContent = o[this.column.hozAlign] || "")), t && e.setAttribute("tabulator-field", t), this.column.definition.cssClass) {
      var n = this.column.definition.cssClass.split(" ");
      n.forEach((s) => {
        e.classList.add(s);
      });
    }
    this.dispatch("cell-init", this), this.column.visible || this.hide();
  }
  //generate cell contents
  _generateContents() {
    var e;
    switch (e = this.chain("cell-format", this, null, () => this.element.innerHTML = this.value), typeof e) {
      case "object":
        if (e instanceof Node) {
          for (; this.element.firstChild; )
            this.element.removeChild(this.element.firstChild);
          this.element.appendChild(e);
        } else
          this.element.innerHTML = "", e != null && console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", e);
        break;
      case "undefined":
        this.element.innerHTML = "";
        break;
      default:
        this.element.innerHTML = e;
    }
  }
  cellRendered() {
    this.dispatch("cell-rendered", this);
  }
  //////////////////// Getters ////////////////////
  getElement(e) {
    return this.loaded || (this.loaded = !0, e || this.layoutElement()), this.element;
  }
  getValue() {
    return this.value;
  }
  getOldValue() {
    return this.oldValue;
  }
  //////////////////// Actions ////////////////////
  setValue(e, t, i) {
    var o = this.setValueProcessData(e, t, i);
    o && (this.dispatch("cell-value-updated", this), this.cellRendered(), this.column.definition.cellEdited && this.column.definition.cellEdited.call(this.table, this.getComponent()), this.dispatchExternal("cellEdited", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()));
  }
  setValueProcessData(e, t, i) {
    var o = !1;
    return (this.value !== e || i) && (o = !0, t && (e = this.chain("cell-value-changing", [this, e], null, e))), this.setValueActual(e), o && this.dispatch("cell-value-changed", this), o;
  }
  setValueActual(e) {
    this.oldValue = this.value, this.value = e, this.dispatch("cell-value-save-before", this), this.column.setFieldValue(this.row.data, e), this.dispatch("cell-value-save-after", this), this.loaded && this.layoutElement();
  }
  layoutElement() {
    this._generateContents(), this.dispatch("cell-layout", this);
  }
  setWidth() {
    this.width = this.column.width, this.element.style.width = this.column.widthStyled;
  }
  clearWidth() {
    this.width = "", this.element.style.width = "";
  }
  getWidth() {
    return this.width || this.element.offsetWidth;
  }
  setMinWidth() {
    this.minWidth = this.column.minWidth, this.element.style.minWidth = this.column.minWidthStyled;
  }
  setMaxWidth() {
    this.maxWidth = this.column.maxWidth, this.element.style.maxWidth = this.column.maxWidthStyled;
  }
  checkHeight() {
    this.row.reinitializeHeight();
  }
  clearHeight() {
    this.element.style.height = "", this.height = null, this.dispatch("cell-height", this, "");
  }
  setHeight() {
    this.height = this.row.height, this.element.style.height = this.row.heightStyled, this.dispatch("cell-height", this, this.row.heightStyled);
  }
  getHeight() {
    return this.height || this.element.offsetHeight;
  }
  show() {
    this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
  }
  hide() {
    this.element.style.display = "none";
  }
  delete() {
    this.dispatch("cell-delete", this), !this.table.rowManager.redrawBlock && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.column.deleteCell(this), this.row.deleteCell(this), this.calcs = {};
  }
  getIndex() {
    return this.row.getCellIndex(this);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new gS(this)), this.component;
  }
}
class mS {
  constructor(e) {
    return this._column = e, this.type = "ColumnComponent", new Proxy(this, {
      get: function(t, i, o) {
        return typeof t[i] < "u" ? t[i] : t._column.table.componentFunctionBinder.handle("column", t._column, i);
      }
    });
  }
  getElement() {
    return this._column.getElement();
  }
  getDefinition() {
    return this._column.getDefinition();
  }
  getField() {
    return this._column.getField();
  }
  getTitleDownload() {
    return this._column.getTitleDownload();
  }
  getCells() {
    var e = [];
    return this._column.cells.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  isVisible() {
    return this._column.visible;
  }
  show() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.show();
    }) : this._column.show();
  }
  hide() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.hide();
    }) : this._column.hide();
  }
  toggle() {
    this._column.visible ? this.hide() : this.show();
  }
  delete() {
    return this._column.delete();
  }
  getSubColumns() {
    var e = [];
    return this._column.columns.length && this._column.columns.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getParentColumn() {
    return this._column.parent instanceof Fi ? this._column.parent.getComponent() : !1;
  }
  _getSelf() {
    return this._column;
  }
  scrollTo(e, t) {
    return this._column.table.columnManager.scrollToColumn(this._column, e, t);
  }
  getTable() {
    return this._column.table;
  }
  move(e, t) {
    var i = this._column.table.columnManager.findColumn(e);
    i ? this._column.table.columnManager.moveColumn(this._column, i, t) : console.warn("Move Error - No matching column found:", i);
  }
  getNextColumn() {
    var e = this._column.nextColumn();
    return e ? e.getComponent() : !1;
  }
  getPrevColumn() {
    var e = this._column.prevColumn();
    return e ? e.getComponent() : !1;
  }
  updateDefinition(e) {
    return this._column.updateDefinition(e);
  }
  getWidth() {
    return this._column.getWidth();
  }
  setWidth(e) {
    var t;
    return e === !0 ? t = this._column.reinitializeWidth(!0) : t = this._column.setWidth(e), this._column.table.columnManager.rerenderColumns(!0), t;
  }
}
var bS = {
  title: void 0,
  field: void 0,
  columns: void 0,
  visible: void 0,
  hozAlign: void 0,
  vertAlign: void 0,
  width: void 0,
  minWidth: 40,
  maxWidth: void 0,
  maxInitialWidth: void 0,
  cssClass: void 0,
  variableHeight: void 0,
  headerVertical: void 0,
  headerHozAlign: void 0,
  headerWordWrap: !1,
  editableTitle: void 0
};
class Fi extends Nt {
  constructor(e, t) {
    super(t.table), this.definition = e, this.parent = t, this.type = "column", this.columns = [], this.cells = [], this.element = this.createElement(), this.contentElement = !1, this.titleHolderElement = !1, this.titleElement = !1, this.groupElement = this.createGroupElement(), this.isGroup = !1, this.hozAlign = "", this.vertAlign = "", this.field = "", this.fieldStructure = "", this.getFieldValue = "", this.setFieldValue = "", this.titleDownload = null, this.titleFormatterRendered = !1, this.mapDefinitions(), this.setField(this.definition.field), this.modules = {}, this.width = null, this.widthStyled = "", this.maxWidth = null, this.maxWidthStyled = "", this.maxInitialWidth = null, this.minWidth = null, this.minWidthStyled = "", this.widthFixed = !1, this.visible = !0, this.component = null, this.definition.columns ? (this.isGroup = !0, this.definition.columns.forEach((i, o) => {
      var n = new Fi(i, this);
      this.attachColumn(n);
    }), this.checkColumnVisibility()) : t.registerColumnField(this), this._initialize();
  }
  createElement() {
    var e = document.createElement("div");
    switch (e.classList.add("tabulator-col"), e.setAttribute("role", "columnheader"), e.setAttribute("aria-sort", "none"), this.table.options.columnHeaderVertAlign) {
      case "middle":
        e.style.justifyContent = "center";
        break;
      case "bottom":
        e.style.justifyContent = "flex-end";
        break;
    }
    return e;
  }
  createGroupElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-group-cols"), e;
  }
  mapDefinitions() {
    var e = this.table.options.columnDefaults;
    if (e)
      for (let t in e)
        typeof this.definition[t] > "u" && (this.definition[t] = e[t]);
    this.definition = this.table.columnManager.optionsList.generate(Fi.defaultOptionList, this.definition);
  }
  checkDefinition() {
    Object.keys(this.definition).forEach((e) => {
      Fi.defaultOptionList.indexOf(e) === -1 && console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", e);
    });
  }
  setField(e) {
    this.field = e, this.fieldStructure = e ? this.table.options.nestedFieldSeparator ? e.split(this.table.options.nestedFieldSeparator) : [e] : [], this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData, this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
  }
  //register column position with column manager
  registerColumnPosition(e) {
    this.parent.registerColumnPosition(e);
  }
  //register column position with column manager
  registerColumnField(e) {
    this.parent.registerColumnField(e);
  }
  //trigger position registration
  reRegisterPosition() {
    this.isGroup ? this.columns.forEach(function(e) {
      e.reRegisterPosition();
    }) : this.registerColumnPosition(this);
  }
  //build header element
  _initialize() {
    for (var e = this.definition; this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    e.headerVertical && (this.element.classList.add("tabulator-col-vertical"), e.headerVertical === "flip" && this.element.classList.add("tabulator-col-vertical-flip")), this.contentElement = this._buildColumnHeaderContent(), this.element.appendChild(this.contentElement), this.isGroup ? this._buildGroupHeader() : this._buildColumnHeader(), this.dispatch("column-init", this);
  }
  //build header element for header
  _buildColumnHeader() {
    var e = this.definition;
    if (this.dispatch("column-layout", this), typeof e.visible < "u" && (e.visible ? this.show(!0) : this.hide(!0)), e.cssClass) {
      var t = e.cssClass.split(" ");
      t.forEach((i) => {
        this.element.classList.add(i);
      });
    }
    e.field && this.element.setAttribute("tabulator-field", e.field), this.setMinWidth(parseInt(e.minWidth)), e.maxInitialWidth && (this.maxInitialWidth = parseInt(e.maxInitialWidth)), e.maxWidth && this.setMaxWidth(parseInt(e.maxWidth)), this.reinitializeWidth(), this.hozAlign = this.definition.hozAlign, this.vertAlign = this.definition.vertAlign, this.titleElement.style.textAlign = this.definition.headerHozAlign;
  }
  _buildColumnHeaderContent() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-content"), this.titleHolderElement = document.createElement("div"), this.titleHolderElement.classList.add("tabulator-col-title-holder"), e.appendChild(this.titleHolderElement), this.titleElement = this._buildColumnHeaderTitle(), this.titleHolderElement.appendChild(this.titleElement), e;
  }
  //build title element of column
  _buildColumnHeaderTitle() {
    var e = this.definition, t = document.createElement("div");
    if (t.classList.add("tabulator-col-title"), e.headerWordWrap && t.classList.add("tabulator-col-title-wrap"), e.editableTitle) {
      var i = document.createElement("input");
      i.classList.add("tabulator-title-editor"), i.addEventListener("click", (o) => {
        o.stopPropagation(), i.focus();
      }), i.addEventListener("change", () => {
        e.title = i.value, this.dispatchExternal("columnTitleChanged", this.getComponent());
      }), t.appendChild(i), e.field ? this.langBind("columns|" + e.field, (o) => {
        i.value = o || e.title || "&nbsp;";
      }) : i.value = e.title || "&nbsp;";
    } else
      e.field ? this.langBind("columns|" + e.field, (o) => {
        this._formatColumnHeaderTitle(t, o || e.title || "&nbsp;");
      }) : this._formatColumnHeaderTitle(t, e.title || "&nbsp;");
    return t;
  }
  _formatColumnHeaderTitle(e, t) {
    var i = this.chain("column-format", [this, t, e], null, () => t);
    switch (typeof i) {
      case "object":
        i instanceof Node ? e.appendChild(i) : (e.innerHTML = "", console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", i));
        break;
      case "undefined":
        e.innerHTML = "";
        break;
      default:
        e.innerHTML = i;
    }
  }
  //build header element for column group
  _buildGroupHeader() {
    if (this.element.classList.add("tabulator-col-group"), this.element.setAttribute("role", "columngroup"), this.element.setAttribute("aria-title", this.definition.title), this.definition.cssClass) {
      var e = this.definition.cssClass.split(" ");
      e.forEach((t) => {
        this.element.classList.add(t);
      });
    }
    this.titleElement.style.textAlign = this.definition.headerHozAlign, this.element.appendChild(this.groupElement);
  }
  //flat field lookup
  _getFlatData(e) {
    return e[this.field];
  }
  //nested field lookup
  _getNestedData(e) {
    var t = e, i = this.fieldStructure, o = i.length, n;
    for (let s = 0; s < o && (t = t[i[s]], n = t, !!t); s++)
      ;
    return n;
  }
  //flat field set
  _setFlatData(e, t) {
    this.field && (e[this.field] = t);
  }
  //nested field set
  _setNestedData(e, t) {
    var i = e, o = this.fieldStructure, n = o.length;
    for (let s = 0; s < n; s++)
      if (s == n - 1)
        i[o[s]] = t;
      else {
        if (!i[o[s]])
          if (typeof t < "u")
            i[o[s]] = {};
          else
            break;
        i = i[o[s]];
      }
  }
  //attach column to this group
  attachColumn(e) {
    this.groupElement ? (this.columns.push(e), this.groupElement.appendChild(e.getElement()), e.columnRendered()) : console.warn("Column Warning - Column being attached to another column instead of column group");
  }
  //vertically align header in column
  verticalAlign(e, t) {
    var i = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : t || this.parent.getHeadersElement().clientHeight;
    this.element.style.height = i + "px", this.dispatch("column-height", this, this.element.style.height), this.isGroup && (this.groupElement.style.minHeight = i - this.contentElement.offsetHeight + "px"), this.columns.forEach(function(o) {
      o.verticalAlign(e);
    });
  }
  //clear vertical alignment
  clearVerticalAlign() {
    this.element.style.paddingTop = "", this.element.style.height = "", this.element.style.minHeight = "", this.groupElement.style.minHeight = "", this.columns.forEach(function(e) {
      e.clearVerticalAlign();
    }), this.dispatch("column-height", this, "");
  }
  //// Retrieve Column Information ////
  //return column header element
  getElement() {
    return this.element;
  }
  //return column group element
  getGroupElement() {
    return this.groupElement;
  }
  //return field name
  getField() {
    return this.field;
  }
  getTitleDownload() {
    return this.titleDownload;
  }
  //return the first column in a group
  getFirstColumn() {
    return this.isGroup ? this.columns.length ? this.columns[0].getFirstColumn() : !1 : this;
  }
  //return the last column in a group
  getLastColumn() {
    return this.isGroup ? this.columns.length ? this.columns[this.columns.length - 1].getLastColumn() : !1 : this;
  }
  //return all columns in a group
  getColumns(e) {
    var t = [];
    return e ? this.columns.forEach((i) => {
      t.push(i), t = t.concat(i.getColumns(!0));
    }) : t = this.columns, t;
  }
  //return all columns in a group
  getCells() {
    return this.cells;
  }
  //retrieve the top column in a group of columns
  getTopColumn() {
    return this.parent.isGroup ? this.parent.getTopColumn() : this;
  }
  //return column definition object
  getDefinition(e) {
    var t = [];
    return this.isGroup && e && (this.columns.forEach(function(i) {
      t.push(i.getDefinition(!0));
    }), this.definition.columns = t), this.definition;
  }
  //////////////////// Actions ////////////////////
  checkColumnVisibility() {
    var e = !1;
    this.columns.forEach(function(t) {
      t.visible && (e = !0);
    }), e ? (this.show(), this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1)) : this.hide();
  }
  //show column
  show(e, t) {
    this.visible || (this.visible = !0, this.element.style.display = "", this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(i) {
      i.show();
    }), !this.isGroup && this.width === null && this.reinitializeWidth(), this.table.columnManager.verticalAlignHeaders(), this.dispatch("column-show", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !0), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  //hide column
  hide(e, t) {
    this.visible && (this.visible = !1, this.element.style.display = "none", this.table.columnManager.verticalAlignHeaders(), this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(i) {
      i.hide();
    }), this.dispatch("column-hide", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  matchChildWidths() {
    var e = 0;
    this.contentElement && this.columns.length && (this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }), this.contentElement.style.maxWidth = e - 1 + "px", this.parent.isGroup && this.parent.matchChildWidths());
  }
  removeChild(e) {
    var t = this.columns.indexOf(e);
    t > -1 && this.columns.splice(t, 1), this.columns.length || this.delete();
  }
  setWidth(e) {
    this.widthFixed = !0, this.setWidthActual(e);
  }
  setWidthActual(e) {
    isNaN(e) && (e = Math.floor(this.table.element.clientWidth / 100 * parseInt(e))), e = Math.max(this.minWidth, e), this.maxWidth && (e = Math.min(this.maxWidth, e)), this.width = e, this.widthStyled = e ? e + "px" : "", this.element.style.width = this.widthStyled, this.isGroup || this.cells.forEach(function(t) {
      t.setWidth();
    }), this.parent.isGroup && this.parent.matchChildWidths(), this.dispatch("column-width", this);
  }
  checkCellHeights() {
    var e = [];
    this.cells.forEach(function(t) {
      t.row.heightInitialized && (t.row.getElement().offsetParent !== null ? (e.push(t.row), t.row.clearCellHeight()) : t.row.heightInitialized = !1);
    }), e.forEach(function(t) {
      t.calcHeight();
    }), e.forEach(function(t) {
      t.setCellHeight();
    });
  }
  getWidth() {
    var e = 0;
    return this.isGroup ? this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }) : e = this.width, e;
  }
  getLeftOffset() {
    var e = this.element.offsetLeft;
    return this.parent.isGroup && (e += this.parent.getLeftOffset()), e;
  }
  getHeight() {
    return Math.ceil(this.element.getBoundingClientRect().height);
  }
  setMinWidth(e) {
    this.maxWidth && e > this.maxWidth && (e = this.maxWidth, console.warn("the minWidth (" + e + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")")), this.minWidth = e, this.minWidthStyled = e ? e + "px" : "", this.element.style.minWidth = this.minWidthStyled, this.cells.forEach(function(t) {
      t.setMinWidth();
    });
  }
  setMaxWidth(e) {
    this.minWidth && e < this.minWidth && (e = this.minWidth, console.warn("the maxWidth (" + e + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")")), this.maxWidth = e, this.maxWidthStyled = e ? e + "px" : "", this.element.style.maxWidth = this.maxWidthStyled, this.cells.forEach(function(t) {
      t.setMaxWidth();
    });
  }
  delete() {
    return new Promise((e, t) => {
      this.isGroup && this.columns.forEach(function(o) {
        o.delete();
      }), this.dispatch("column-delete", this);
      var i = this.cells.length;
      for (let o = 0; o < i; o++)
        this.cells[0].delete();
      this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.contentElement = !1, this.titleElement = !1, this.groupElement = !1, this.parent.isGroup && this.parent.removeChild(this), this.table.columnManager.deregisterColumn(this), this.table.columnManager.rerenderColumns(!0), e();
    });
  }
  columnRendered() {
    this.titleFormatterRendered && this.titleFormatterRendered(), this.dispatch("column-rendered", this);
  }
  //////////////// Cell Management /////////////////
  //generate cell for this column
  generateCell(e) {
    var t = new _a(this, e);
    return this.cells.push(t), t;
  }
  nextColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._nextVisibleColumn(e + 1) : !1;
  }
  _nextVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._nextVisibleColumn(e + 1);
  }
  prevColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._prevVisibleColumn(e - 1) : !1;
  }
  _prevVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._prevVisibleColumn(e - 1);
  }
  reinitializeWidth(e) {
    this.widthFixed = !1, typeof this.definition.width < "u" && !e && this.setWidth(this.definition.width), this.dispatch("column-width-fit-before", this), this.fitToData(e), this.dispatch("column-width-fit-after", this);
  }
  //set column width to maximum cell width for non group columns
  fitToData(e) {
    if (!this.isGroup) {
      this.widthFixed || (this.element.style.width = "", this.cells.forEach((o) => {
        o.clearWidth();
      }));
      var t = this.element.offsetWidth;
      if ((!this.width || !this.widthFixed) && (this.cells.forEach((o) => {
        var n = o.getWidth();
        n > t && (t = n);
      }), t)) {
        var i = t + 1;
        this.maxInitialWidth && !e && (i = Math.min(i, this.maxInitialWidth)), this.setWidthActual(i);
      }
    }
  }
  updateDefinition(e) {
    var t;
    return this.isGroup || this.parent.isGroup ? (console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns"), Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups")) : (t = Object.assign({}, this.getDefinition()), t = Object.assign(t, e), this.table.columnManager.addColumn(t, !1, this).then((i) => (t.field == this.field && (this.field = !1), this.delete().then(() => i.getComponent()))));
  }
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new mS(this)), this.component;
  }
}
Fi.defaultOptionList = bS;
class kh {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, i, o) {
        return typeof t[i] < "u" ? t[i] : t._row.table.componentFunctionBinder.handle("row", t._row, i);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  getIndex() {
    return this._row.getData("data")[this._row.table.options.index];
  }
  getPosition() {
    return this._row.getPosition();
  }
  watchPosition(e) {
    return this._row.watchPosition(e);
  }
  delete() {
    return this._row.delete();
  }
  scrollTo(e, t) {
    return this._row.table.rowManager.scrollToRow(this._row, e, t);
  }
  move(e, t) {
    this._row.moveToRow(e, t);
  }
  update(e) {
    return this._row.updateData(e);
  }
  normalizeHeight() {
    this._row.normalizeHeight(!0);
  }
  _getSelf() {
    return this._row;
  }
  reformat() {
    return this._row.reinitialize();
  }
  getTable() {
    return this._row.table;
  }
  getNextRow() {
    var e = this._row.nextRow();
    return e && e.getComponent();
  }
  getPrevRow() {
    var e = this._row.prevRow();
    return e && e.getComponent();
  }
}
class Ct extends Nt {
  constructor(e, t, i = "row") {
    super(t.table), this.parent = t, this.data = {}, this.type = i, this.element = !1, this.modules = {}, this.cells = [], this.height = 0, this.heightStyled = "", this.manualHeight = !1, this.outerHeight = 0, this.initialized = !1, this.heightInitialized = !1, this.position = 0, this.positionWatchers = [], this.component = null, this.created = !1, this.setData(e);
  }
  create() {
    this.created || (this.created = !0, this.generateElement());
  }
  createElement() {
    var e = document.createElement("div");
    e.classList.add("tabulator-row"), e.setAttribute("role", "row"), this.element = e;
  }
  getElement() {
    return this.create(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  generateElement() {
    this.createElement(), this.dispatch("row-init", this);
  }
  generateCells() {
    this.cells = this.table.columnManager.generateCells(this);
  }
  //functions to setup on first render
  initialize(e) {
    if (this.create(), !this.initialized || e) {
      for (this.deleteCells(); this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.dispatch("row-layout-before", this), this.generateCells(), this.initialized = !0, this.table.columnManager.renderer.renderRowCells(this), e && this.normalizeHeight(), this.dispatch("row-layout", this), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent()), this.dispatch("row-layout-after", this);
    } else
      this.table.columnManager.renderer.rerenderRowCells(this);
  }
  reinitializeHeight() {
    this.heightInitialized = !1, this.element && this.element.offsetParent !== null && this.normalizeHeight(!0);
  }
  deinitialize() {
    this.initialized = !1;
  }
  deinitializeHeight() {
    this.heightInitialized = !1;
  }
  reinitialize(e) {
    this.initialized = !1, this.heightInitialized = !1, this.manualHeight || (this.height = 0, this.heightStyled = ""), this.element && this.element.offsetParent !== null && this.initialize(!0), this.dispatch("row-relayout", this);
  }
  //get heights when doing bulk row style calcs in virtual DOM
  calcHeight(e) {
    var t = 0, i;
    this.table.options.rowHeight ? this.height = this.table.options.rowHeight : (i = this.table.options.resizableRows ? this.element.clientHeight : 0, this.cells.forEach(function(o) {
      var n = o.getHeight();
      n > t && (t = n);
    }), e ? this.height = Math.max(t, i) : this.height = this.manualHeight ? this.height : Math.max(t, i)), this.heightStyled = this.height ? this.height + "px" : "", this.outerHeight = this.element.offsetHeight;
  }
  //set of cells
  setCellHeight() {
    this.cells.forEach(function(e) {
      e.setHeight();
    }), this.heightInitialized = !0;
  }
  clearCellHeight() {
    this.cells.forEach(function(e) {
      e.clearHeight();
    });
  }
  //normalize the height of elements in the row
  normalizeHeight(e) {
    e && !this.table.options.rowHeight && this.clearCellHeight(), this.calcHeight(e), this.setCellHeight();
  }
  //set height of rows
  setHeight(e, t) {
    (this.height != e || t) && (this.manualHeight = !0, this.height = e, this.heightStyled = e ? e + "px" : "", this.setCellHeight(), this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  //return rows outer Width
  getWidth() {
    return this.element.offsetWidth;
  }
  //////////////// Cell Management /////////////////
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Data Management /////////////////
  setData(e) {
    this.data = this.chain("row-data-init-before", [this, e], void 0, e), this.dispatch("row-data-init-after", this);
  }
  //update the rows data
  updateData(e) {
    var t = this.element && _e.elVisible(this.element), i = {}, o;
    return new Promise((n, s) => {
      typeof e == "string" && (e = JSON.parse(e)), this.dispatch("row-data-save-before", this), this.subscribed("row-data-changing") && (i = Object.assign(i, this.data), i = Object.assign(i, e)), o = this.chain("row-data-changing", [this, i, e], null, e);
      for (let a in o)
        this.data[a] = o[a];
      this.dispatch("row-data-save-after", this);
      for (let a in e)
        this.table.columnManager.getColumnsByFieldRoot(a).forEach((u) => {
          let h = this.getCell(u.getField());
          if (h) {
            let c = u.getFieldValue(o);
            h.getValue() !== c && (h.setValueProcessData(c), t && h.cellRendered());
          }
        });
      t ? (this.normalizeHeight(!0), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent())) : (this.initialized = !1, this.height = 0, this.heightStyled = ""), this.dispatch("row-data-changed", this, t, e), this.dispatchExternal("rowUpdated", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), n();
    });
  }
  getData(e) {
    return e ? this.chain("row-data-retrieve", [this, e], null, this.data) : this.data;
  }
  getCell(e) {
    var t = !1;
    return e = this.table.columnManager.findColumn(e), !this.initialized && this.cells.length === 0 && this.generateCells(), t = this.cells.find(function(i) {
      return i.column === e;
    }), t;
  }
  getCellIndex(e) {
    return this.cells.findIndex(function(t) {
      return t === e;
    });
  }
  findCell(e) {
    return this.cells.find((t) => t.element === e);
  }
  getCells() {
    return !this.initialized && this.cells.length === 0 && this.generateCells(), this.cells;
  }
  nextRow() {
    var e = this.table.rowManager.nextDisplayRow(this, !0);
    return e || !1;
  }
  prevRow() {
    var e = this.table.rowManager.prevDisplayRow(this, !0);
    return e || !1;
  }
  moveToRow(e, t) {
    var i = this.table.rowManager.findRow(e);
    i ? (this.table.rowManager.moveRowActual(this, i, !t), this.table.rowManager.refreshActiveData("display", !1, !0)) : console.warn("Move Error - No matching row found:", e);
  }
  ///////////////////// Actions  /////////////////////
  delete() {
    return this.dispatch("row-delete", this), this.deleteActual(), Promise.resolve();
  }
  deleteActual(e) {
    this.detachModules(), this.table.rowManager.deleteRow(this, e), this.deleteCells(), this.initialized = !1, this.heightInitialized = !1, this.element = !1, this.dispatch("row-deleted", this);
  }
  detachModules() {
    this.dispatch("row-deleting", this);
  }
  deleteCells() {
    var e = this.cells.length;
    for (let t = 0; t < e; t++)
      this.cells[0].delete();
  }
  wipe() {
    if (this.detachModules(), this.deleteCells(), this.element) {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.element.parentNode && this.element.parentNode.removeChild(this.element);
    }
    this.element = !1, this.modules = {};
  }
  isDisplayed() {
    return this.table.rowManager.getDisplayRows().includes(this);
  }
  getPosition() {
    return this.isDisplayed() ? this.position : !1;
  }
  setPosition(e) {
    e != this.position && (this.position = e, this.positionWatchers.forEach((t) => {
      t(this.position);
    }));
  }
  watchPosition(e) {
    this.positionWatchers.push(e), e(this.position);
  }
  getGroup() {
    return this.modules.group || !1;
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new kh(this)), this.component;
  }
}
var hV = {
  avg: function(r, e, t) {
    var i = 0, o = typeof t.precision < "u" ? t.precision : 2;
    return r.length && (i = r.reduce(function(n, s) {
      return Number(n) + Number(s);
    }), i = i / r.length, i = o !== !1 ? i.toFixed(o) : i), parseFloat(i).toString();
  },
  max: function(r, e, t) {
    var i = null, o = typeof t.precision < "u" ? t.precision : !1;
    return r.forEach(function(n) {
      n = Number(n), (n > i || i === null) && (i = n);
    }), i !== null ? o !== !1 ? i.toFixed(o) : i : "";
  },
  min: function(r, e, t) {
    var i = null, o = typeof t.precision < "u" ? t.precision : !1;
    return r.forEach(function(n) {
      n = Number(n), (n < i || i === null) && (i = n);
    }), i !== null ? o !== !1 ? i.toFixed(o) : i : "";
  },
  sum: function(r, e, t) {
    var i = 0, o = typeof t.precision < "u" ? t.precision : !1;
    return r.length && r.forEach(function(n) {
      n = Number(n), i += isNaN(n) ? 0 : Number(n);
    }), o !== !1 ? i.toFixed(o) : i;
  },
  concat: function(r, e, t) {
    var i = 0;
    return r.length && (i = r.reduce(function(o, n) {
      return String(o) + String(n);
    })), i;
  },
  count: function(r, e, t) {
    var i = 0;
    return r.length && r.forEach(function(o) {
      o && i++;
    }), i;
  },
  unique: function(r, e, t) {
    var i = r.filter((o, n) => (r || o === 0) && r.indexOf(o) === n);
    return i.length;
  }
};
class Rr extends fe {
  constructor(e) {
    super(e), this.topCalcs = [], this.botCalcs = [], this.genColumn = !1, this.topElement = this.createElement(), this.botElement = this.createElement(), this.topRow = !1, this.botRow = !1, this.topInitialized = !1, this.botInitialized = !1, this.blocked = !1, this.recalcAfterBlock = !1, this.registerTableOption("columnCalcs", !0), this.registerColumnOption("topCalc"), this.registerColumnOption("topCalcParams"), this.registerColumnOption("topCalcFormatter"), this.registerColumnOption("topCalcFormatterParams"), this.registerColumnOption("bottomCalc"), this.registerColumnOption("bottomCalcParams"), this.registerColumnOption("bottomCalcFormatter"), this.registerColumnOption("bottomCalcFormatterParams");
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-calcs-holder"), e;
  }
  initialize() {
    this.genColumn = new Fi({ field: "value" }, this), this.subscribe("cell-value-changed", this.cellValueChanged.bind(this)), this.subscribe("column-init", this.initializeColumnCheck.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("column-moved", this.recalcActiveRows.bind(this)), this.subscribe("column-add", this.recalcActiveRows.bind(this)), this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this)), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this)), this.subscribe("redraw-blocked", this.blockRedraw.bind(this)), this.subscribe("redraw-restored", this.restoreRedraw.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this)), this.registerTableFunction("getCalcResults", this.getResults.bind(this)), this.registerTableFunction("recalc", this.userRecalc.bind(this)), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  tableRedraw(e) {
    this.recalc(this.table.rowManager.activeRows), e && this.redraw();
  }
  blockRedraw() {
    this.blocked = !0, this.recalcAfterBlock = !1;
  }
  restoreRedraw() {
    this.blocked = !1, this.recalcAfterBlock && (this.recalcAfterBlock = !1, this.recalcActiveRowsRefresh());
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userRecalc() {
    this.recalc(this.table.rowManager.activeRows);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  blockCheck() {
    return this.blocked && (this.recalcAfterBlock = !0), this.blocked;
  }
  visibleRows(e, t) {
    return this.topRow && t.unshift(this.topRow), this.botRow && t.push(this.botRow), t;
  }
  rowsUpdated(e) {
    this.table.options.groupBy ? this.recalcRowGroup(e) : this.recalcActiveRows();
  }
  recalcActiveRowsRefresh() {
    this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree ? this.recalcAll() : this.recalcActiveRows();
  }
  recalcActiveRows() {
    this.recalc(this.table.rowManager.activeRows);
  }
  cellValueChanged(e) {
    (e.column.definition.topCalc || e.column.definition.bottomCalc) && (this.table.options.groupBy ? ((this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") && this.recalcActiveRows(), this.table.options.columnCalcs != "table" && this.recalcRowGroup(e.row)) : this.recalcActiveRows());
  }
  initializeColumnCheck(e) {
    (e.definition.topCalc || e.definition.bottomCalc) && this.initializeColumn(e);
  }
  //initialize column calcs
  initializeColumn(e) {
    var t = e.definition, i = {
      topCalcParams: t.topCalcParams || {},
      botCalcParams: t.bottomCalcParams || {}
    };
    if (t.topCalc) {
      switch (typeof t.topCalc) {
        case "string":
          Rr.calculations[t.topCalc] ? i.topCalc = Rr.calculations[t.topCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.topCalc);
          break;
        case "function":
          i.topCalc = t.topCalc;
          break;
      }
      i.topCalc && (e.modules.columnCalcs = i, this.topCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeTopRow());
    }
    if (t.bottomCalc) {
      switch (typeof t.bottomCalc) {
        case "string":
          Rr.calculations[t.bottomCalc] ? i.botCalc = Rr.calculations[t.bottomCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.bottomCalc);
          break;
        case "function":
          i.botCalc = t.bottomCalc;
          break;
      }
      i.botCalc && (e.modules.columnCalcs = i, this.botCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeBottomRow());
    }
  }
  //dummy functions to handle being mock column manager
  registerColumnField() {
  }
  removeCalcs() {
    var e = !1;
    this.topInitialized && (this.topInitialized = !1, this.topElement.parentNode.removeChild(this.topElement), e = !0), this.botInitialized && (this.botInitialized = !1, this.footerRemove(this.botElement), e = !0), e && this.table.rowManager.adjustTableSize();
  }
  reinitializeCalcs() {
    this.topCalcs.length && this.initializeTopRow(), this.botCalcs.length && this.initializeBottomRow();
  }
  initializeTopRow() {
    this.topInitialized || (this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.topInitialized = !0);
  }
  initializeBottomRow() {
    this.botInitialized || (this.footerPrepend(this.botElement), this.botInitialized = !0);
  }
  scrollHorizontal(e) {
    this.botInitialized && this.botRow && (this.botElement.scrollLeft = e);
  }
  recalc(e) {
    var t, i;
    if (!this.blockCheck() && (this.topInitialized || this.botInitialized)) {
      if (t = this.rowsToData(e), this.topInitialized) {
        for (this.topRow && this.topRow.deleteCells(), i = this.generateRow("top", t), this.topRow = i; this.topElement.firstChild; )
          this.topElement.removeChild(this.topElement.firstChild);
        this.topElement.appendChild(i.getElement()), i.initialize(!0);
      }
      if (this.botInitialized) {
        for (this.botRow && this.botRow.deleteCells(), i = this.generateRow("bottom", t), this.botRow = i; this.botElement.firstChild; )
          this.botElement.removeChild(this.botElement.firstChild);
        this.botElement.appendChild(i.getElement()), i.initialize(!0);
      }
      this.table.rowManager.adjustTableSize(), this.table.modExists("frozenColumns") && this.table.modules.frozenColumns.layout();
    }
  }
  recalcRowGroup(e) {
    this.recalcGroup(this.table.modules.groupRows.getRowGroup(e));
  }
  recalcAll() {
    if ((this.topCalcs.length || this.botCalcs.length) && (this.table.options.columnCalcs !== "group" && this.recalcActiveRows(), this.table.options.groupBy && this.table.options.columnCalcs !== "table")) {
      var e = this.table.modules.groupRows.getChildGroups();
      e.forEach((t) => {
        this.recalcGroup(t);
      });
    }
  }
  recalcGroup(e) {
    var t, i;
    this.blockCheck() || e && e.calcs && (e.calcs.bottom && (t = this.rowsToData(e.rows), i = this.generateRowData("bottom", t), e.calcs.bottom.updateData(i), e.calcs.bottom.reinitialize()), e.calcs.top && (t = this.rowsToData(e.rows), i = this.generateRowData("top", t), e.calcs.top.updateData(i), e.calcs.top.reinitialize()));
  }
  //generate top stats row
  generateTopRow(e) {
    return this.generateRow("top", this.rowsToData(e));
  }
  //generate bottom stats row
  generateBottomRow(e) {
    return this.generateRow("bottom", this.rowsToData(e));
  }
  rowsToData(e) {
    var t = [];
    return e.forEach((i) => {
      if (t.push(i.getData()), this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs && i.modules.dataTree && i.modules.dataTree.open) {
        var o = this.rowsToData(this.table.modules.dataTree.getFilteredTreeChildren(i));
        t = t.concat(o);
      }
    }), t;
  }
  //generate stats row
  generateRow(e, t) {
    var i = this.generateRowData(e, t), o;
    return this.table.modExists("mutator") && this.table.modules.mutator.disable(), o = new Ct(i, this, "calc"), this.table.modExists("mutator") && this.table.modules.mutator.enable(), o.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + e), o.component = !1, o.getComponent = () => (o.component || (o.component = new uV(o)), o.component), o.generateCells = () => {
      var n = [];
      this.table.columnManager.columnsByIndex.forEach((s) => {
        this.genColumn.setField(s.getField()), this.genColumn.hozAlign = s.hozAlign, s.definition[e + "CalcFormatter"] && this.table.modExists("format") ? this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter(s.definition[e + "CalcFormatter"]),
          params: s.definition[e + "CalcFormatterParams"] || {}
        } : this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter("plaintext"),
          params: {}
        }, this.genColumn.definition.cssClass = s.definition.cssClass;
        var a = new _a(this.genColumn, o);
        a.getElement(), a.column = s, a.setWidth(), s.cells.push(a), n.push(a), s.visible || a.hide();
      }), o.cells = n;
    }, o;
  }
  //generate stats row
  generateRowData(e, t) {
    var i = {}, o = e == "top" ? this.topCalcs : this.botCalcs, n = e == "top" ? "topCalc" : "botCalc", s, a;
    return o.forEach(function(l) {
      var u = [];
      l.modules.columnCalcs && l.modules.columnCalcs[n] && (t.forEach(function(h) {
        u.push(l.getFieldValue(h));
      }), a = n + "Params", s = typeof l.modules.columnCalcs[a] == "function" ? l.modules.columnCalcs[a](u, t) : l.modules.columnCalcs[a], l.setFieldValue(i, l.modules.columnCalcs[n](u, t, s)));
    }), i;
  }
  hasTopCalcs() {
    return !!this.topCalcs.length;
  }
  hasBottomCalcs() {
    return !!this.botCalcs.length;
  }
  //handle table redraw
  redraw() {
    this.topRow && this.topRow.normalizeHeight(!0), this.botRow && this.botRow.normalizeHeight(!0);
  }
  //return the calculated
  getResults() {
    var e = {}, t;
    return this.table.options.groupBy && this.table.modExists("groupRows") ? (t = this.table.modules.groupRows.getGroups(!0), t.forEach((i) => {
      e[i.getKey()] = this.getGroupResults(i);
    })) : e = {
      top: this.topRow ? this.topRow.getData() : {},
      bottom: this.botRow ? this.botRow.getData() : {}
    }, e;
  }
  //get results from a group
  getGroupResults(e) {
    var t = e._getSelf(), i = e.getSubGroups(), o = {}, n = {};
    return i.forEach((s) => {
      o[s.getKey()] = this.getGroupResults(s);
    }), n = {
      top: t.calcs.top ? t.calcs.top.getData() : {},
      bottom: t.calcs.bottom ? t.calcs.bottom.getData() : {},
      groups: o
    }, n;
  }
  adjustForScrollbar(e) {
    this.botRow && (this.table.rtl ? this.botElement.style.paddingLeft = e + "px" : this.botElement.style.paddingRight = e + "px");
  }
}
Rr.moduleName = "columnCalcs";
Rr.calculations = hV;
class OS extends fe {
  constructor(e) {
    super(e), this.indent = 10, this.field = "", this.collapseEl = null, this.expandEl = null, this.branchEl = null, this.elementField = !1, this.startOpen = function() {
    }, this.registerTableOption("dataTree", !1), this.registerTableOption("dataTreeFilter", !0), this.registerTableOption("dataTreeSort", !0), this.registerTableOption("dataTreeElementColumn", !1), this.registerTableOption("dataTreeBranchElement", !0), this.registerTableOption("dataTreeChildIndent", 9), this.registerTableOption("dataTreeChildField", "_children"), this.registerTableOption("dataTreeCollapseElement", !1), this.registerTableOption("dataTreeExpandElement", !1), this.registerTableOption("dataTreeStartExpanded", !1), this.registerTableOption("dataTreeChildColumnCalcs", !1), this.registerTableOption("dataTreeSelectPropagate", !1), this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this)), this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this)), this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this)), this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this)), this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this)), this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this)), this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
  }
  initialize() {
    if (this.table.options.dataTree) {
      var e = null, t = this.table.options;
      switch (this.field = t.dataTreeChildField, this.indent = t.dataTreeChildIndent, this.options("movableRows") && console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior"), t.dataTreeBranchElement && (t.dataTreeBranchElement === !0 ? (this.branchEl = document.createElement("div"), this.branchEl.classList.add("tabulator-data-tree-branch")) : typeof t.dataTreeBranchElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeBranchElement, this.branchEl = e.firstChild) : this.branchEl = t.dataTreeBranchElement), t.dataTreeCollapseElement ? typeof t.dataTreeCollapseElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeCollapseElement, this.collapseEl = e.firstChild) : this.collapseEl = t.dataTreeCollapseElement : (this.collapseEl = document.createElement("div"), this.collapseEl.classList.add("tabulator-data-tree-control"), this.collapseEl.tabIndex = 0, this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>"), t.dataTreeExpandElement ? typeof t.dataTreeExpandElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeExpandElement, this.expandEl = e.firstChild) : this.expandEl = t.dataTreeExpandElement : (this.expandEl = document.createElement("div"), this.expandEl.classList.add("tabulator-data-tree-control"), this.expandEl.tabIndex = 0, this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>"), typeof t.dataTreeStartExpanded) {
        case "boolean":
          this.startOpen = function(i, o) {
            return t.dataTreeStartExpanded;
          };
          break;
        case "function":
          this.startOpen = t.dataTreeStartExpanded;
          break;
        default:
          this.startOpen = function(i, o) {
            return t.dataTreeStartExpanded[o];
          };
          break;
      }
      this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("row-deleted", this.rowDelete.bind(this), 0), this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10), this.subscribe("cell-value-updated", this.cellValueChanged.bind(this)), this.subscribe("edit-cancelled", this.cellValueChanged.bind(this)), this.subscribe("column-moving-rows", this.columnMoving.bind(this)), this.subscribe("table-built", this.initializeElementField.bind(this)), this.subscribe("table-redrawing", this.tableRedrawing.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 30);
    }
  }
  tableRedrawing(e) {
    var t;
    e && (t = this.table.rowManager.getRows(), t.forEach((i) => {
      this.reinitializeRowChildren(i);
    }));
  }
  initializeElementField() {
    var e = this.table.columnManager.getFirstVisibleColumn();
    this.elementField = this.table.options.dataTreeElementColumn || (e ? e.field : !1);
  }
  getRowChildren(e) {
    return this.getTreeChildren(e, !0);
  }
  columnMoving() {
    var e = [];
    return this.table.rowManager.rows.forEach((t) => {
      e = e.concat(this.getTreeChildren(t, !1, !0));
    }), e;
  }
  rowDataChanged(e, t, i) {
    this.redrawNeeded(i) && (this.initializeRow(e), t && (this.layoutRow(e), this.refreshData(!0)));
  }
  cellValueChanged(e) {
    var t = e.column.getField();
    t === this.elementField && this.layoutRow(e.row);
  }
  initializeRow(e) {
    var t = e.getData()[this.field], i = Array.isArray(t), o = i || !i && typeof t == "object" && t !== null;
    !o && e.modules.dataTree && e.modules.dataTree.branchEl && e.modules.dataTree.branchEl.parentNode.removeChild(e.modules.dataTree.branchEl), !o && e.modules.dataTree && e.modules.dataTree.controlEl && e.modules.dataTree.controlEl.parentNode.removeChild(e.modules.dataTree.controlEl), e.modules.dataTree = {
      index: e.modules.dataTree ? e.modules.dataTree.index : 0,
      open: o ? e.modules.dataTree ? e.modules.dataTree.open : this.startOpen(e.getComponent(), 0) : !1,
      controlEl: e.modules.dataTree && o ? e.modules.dataTree.controlEl : !1,
      branchEl: e.modules.dataTree && o ? e.modules.dataTree.branchEl : !1,
      parent: e.modules.dataTree ? e.modules.dataTree.parent : !1,
      children: o
    };
  }
  reinitializeRowChildren(e) {
    var t = this.getTreeChildren(e, !1, !0);
    t.forEach(function(i) {
      i.reinitialize(!0);
    });
  }
  layoutRow(e) {
    var t = this.elementField ? e.getCell(this.elementField) : e.getCells()[0], i = t.getElement(), o = e.modules.dataTree;
    o.branchEl && (o.branchEl.parentNode && o.branchEl.parentNode.removeChild(o.branchEl), o.branchEl = !1), o.controlEl && (o.controlEl.parentNode && o.controlEl.parentNode.removeChild(o.controlEl), o.controlEl = !1), this.generateControlElement(e, i), e.getElement().classList.add("tabulator-tree-level-" + o.index), o.index && (this.branchEl ? (o.branchEl = this.branchEl.cloneNode(!0), i.insertBefore(o.branchEl, i.firstChild), this.table.rtl ? o.branchEl.style.marginRight = (o.branchEl.offsetWidth + o.branchEl.style.marginLeft) * (o.index - 1) + o.index * this.indent + "px" : o.branchEl.style.marginLeft = (o.branchEl.offsetWidth + o.branchEl.style.marginRight) * (o.index - 1) + o.index * this.indent + "px") : this.table.rtl ? i.style.paddingRight = parseInt(window.getComputedStyle(i, null).getPropertyValue("padding-right")) + o.index * this.indent + "px" : i.style.paddingLeft = parseInt(window.getComputedStyle(i, null).getPropertyValue("padding-left")) + o.index * this.indent + "px");
  }
  generateControlElement(e, t) {
    var i = e.modules.dataTree, o = i.controlEl;
    t = t || e.getCells()[0].getElement(), i.children !== !1 && (i.open ? (i.controlEl = this.collapseEl.cloneNode(!0), i.controlEl.addEventListener("click", (n) => {
      n.stopPropagation(), this.collapseRow(e);
    })) : (i.controlEl = this.expandEl.cloneNode(!0), i.controlEl.addEventListener("click", (n) => {
      n.stopPropagation(), this.expandRow(e);
    })), i.controlEl.addEventListener("mousedown", (n) => {
      n.stopPropagation();
    }), o && o.parentNode === t ? o.parentNode.replaceChild(i.controlEl, o) : t.insertBefore(i.controlEl, t.firstChild));
  }
  getRows(e) {
    var t = [];
    return e.forEach((i, o) => {
      var n, s;
      t.push(i), i instanceof Ct && (i.create(), n = i.modules.dataTree, !n.index && n.children !== !1 && (s = this.getChildren(i), s.forEach((a) => {
        a.create(), t.push(a);
      })));
    }), t;
  }
  getChildren(e, t) {
    var i = e.modules.dataTree, o = [], n = [];
    return i.children !== !1 && (i.open || t) && (Array.isArray(i.children) || (i.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? o = this.table.modules.filter.filter(i.children) : o = i.children, this.table.modExists("sort") && this.table.options.dataTreeSort && this.table.modules.sort.sort(o), o.forEach((s) => {
      n.push(s);
      var a = this.getChildren(s);
      a.forEach((l) => {
        n.push(l);
      });
    })), n;
  }
  generateChildren(e) {
    var t = [], i = e.getData()[this.field];
    return Array.isArray(i) || (i = [i]), i.forEach((o) => {
      var n = new Ct(o || {}, this.table.rowManager);
      n.create(), n.modules.dataTree.index = e.modules.dataTree.index + 1, n.modules.dataTree.parent = e, n.modules.dataTree.children && (n.modules.dataTree.open = this.startOpen(n.getComponent(), n.modules.dataTree.index)), t.push(n);
    }), t;
  }
  expandRow(e, t) {
    var i = e.modules.dataTree;
    i.children !== !1 && (i.open = !0, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowExpanded", e.getComponent(), e.modules.dataTree.index));
  }
  collapseRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open = !1, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowCollapsed", e.getComponent(), e.modules.dataTree.index));
  }
  toggleRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open ? this.collapseRow(e) : this.expandRow(e));
  }
  isRowExpanded(e) {
    return e.modules.dataTree.open;
  }
  getTreeParent(e) {
    return e.modules.dataTree.parent ? e.modules.dataTree.parent.getComponent() : !1;
  }
  getTreeParentRoot(e) {
    return e.modules.dataTree && e.modules.dataTree.parent ? this.getTreeParentRoot(e.modules.dataTree.parent) : e;
  }
  getFilteredTreeChildren(e) {
    var t = e.modules.dataTree, i = [], o;
    return t.children && (Array.isArray(t.children) || (t.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? o = this.table.modules.filter.filter(t.children) : o = t.children, o.forEach((n) => {
      n instanceof Ct && i.push(n);
    })), i;
  }
  rowDelete(e) {
    var t = e.modules.dataTree.parent, i;
    t && (i = this.findChildIndex(e, t), i !== !1 && t.data[this.field].splice(i, 1), t.data[this.field].length || delete t.data[this.field], this.initializeRow(t), this.layoutRow(t)), this.refreshData(!0);
  }
  addTreeChildRow(e, t, i, o) {
    var n = !1;
    typeof t == "string" && (t = JSON.parse(t)), Array.isArray(e.data[this.field]) || (e.data[this.field] = [], e.modules.dataTree.open = this.startOpen(e.getComponent(), e.modules.dataTree.index)), typeof o < "u" && (n = this.findChildIndex(o, e), n !== !1 && e.data[this.field].splice(i ? n : n + 1, 0, t)), n === !1 && (i ? e.data[this.field].unshift(t) : e.data[this.field].push(t)), this.initializeRow(e), this.layoutRow(e), this.refreshData(!0);
  }
  findChildIndex(e, t) {
    var i = !1;
    return typeof e == "object" ? e instanceof Ct ? i = e.data : e instanceof kh ? i = e._getSelf().data : typeof HTMLElement < "u" && e instanceof HTMLElement ? t.modules.dataTree && (i = t.modules.dataTree.children.find((o) => o instanceof Ct ? o.element === e : !1), i && (i = i.data)) : e === null && (i = !1) : typeof e > "u" ? i = !1 : i = t.data[this.field].find((o) => o.data[this.table.options.index] == e), i && (Array.isArray(t.data[this.field]) && (i = t.data[this.field].indexOf(i)), i == -1 && (i = !1)), i;
  }
  getTreeChildren(e, t, i) {
    var o = e.modules.dataTree, n = [];
    return o.children && (Array.isArray(o.children) || (o.children = this.generateChildren(e)), o.children.forEach((s) => {
      s instanceof Ct && (n.push(t ? s.getComponent() : s), i && (n = n.concat(this.getTreeChildren(s, t, i))));
    })), n;
  }
  getChildField() {
    return this.field;
  }
  redrawNeeded(e) {
    return (this.field ? typeof e[this.field] < "u" : !1) || (this.elementField ? typeof e[this.elementField] < "u" : !1);
  }
}
OS.moduleName = "dataTree";
function cV(r, e = {}, t) {
  var i = e.delimiter ? e.delimiter : ",", o = [], n = [];
  r.forEach((s) => {
    var a = [];
    switch (s.type) {
      case "group":
        console.warn("Download Warning - CSV downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - CSV downloader cannot process column calculations");
        break;
      case "header":
        s.columns.forEach((l, u) => {
          l && l.depth === 1 && (n[u] = typeof l.value > "u" || l.value === null ? "" : '"' + String(l.value).split('"').join('""') + '"');
        });
        break;
      case "row":
        s.columns.forEach((l) => {
          if (l) {
            switch (typeof l.value) {
              case "object":
                l.value = l.value !== null ? JSON.stringify(l.value) : "";
                break;
              case "undefined":
                l.value = "";
                break;
            }
            a.push('"' + String(l.value).split('"').join('""') + '"');
          }
        }), o.push(a.join(i));
        break;
    }
  }), n.length && o.unshift(n.join(i)), o = o.join(`
`), e.bom && (o = "\uFEFF" + o), t(o, "text/csv");
}
function dV(r, e, t) {
  var i = [];
  r.forEach((o) => {
    var n = {};
    switch (o.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        o.columns.forEach((s) => {
          s && (n[s.component.getTitleDownload() || s.component.getField()] = s.value);
        }), i.push(n);
        break;
    }
  }), i = JSON.stringify(i, null, "	"), t(i, "application/json");
}
function fV(r, e = {}, t) {
  var i = [], o = [], n = {}, s = e.rowGroupStyles || {
    fontStyle: "bold",
    fontSize: 12,
    cellPadding: 6,
    fillColor: 220
  }, a = e.rowCalcStyles || {
    fontStyle: "bold",
    fontSize: 10,
    cellPadding: 4,
    fillColor: 232
  }, l = e.jsPDF || {}, u = e.title ? e.title : "";
  l.orientation || (l.orientation = e.orientation || "landscape"), l.unit || (l.unit = "pt"), r.forEach((d) => {
    switch (d.type) {
      case "header":
        i.push(h(d));
        break;
      case "group":
        o.push(h(d, s));
        break;
      case "calc":
        o.push(h(d, a));
        break;
      case "row":
        o.push(h(d));
        break;
    }
  });
  function h(d, f) {
    var p = [];
    return d.columns.forEach((g) => {
      var b;
      if (g) {
        switch (typeof g.value) {
          case "object":
            g.value = g.value !== null ? JSON.stringify(g.value) : "";
            break;
          case "undefined":
            g.value = "";
            break;
        }
        b = {
          content: g.value,
          colSpan: g.width,
          rowSpan: g.height
        }, f && (b.styles = f), p.push(b);
      }
    }), p;
  }
  var c = new jspdf.jsPDF(l);
  e.autoTable && (typeof e.autoTable == "function" ? n = e.autoTable(c) || {} : n = e.autoTable), u && (n.didDrawPage = function(d) {
    c.text(u, 40, 30);
  }), n.head = i, n.body = o, c.autoTable(n), e.documentProcessing && e.documentProcessing(c), t(c.output("arraybuffer"), "application/pdf");
}
function pV(r, e, t) {
  var i = this, o = e.sheetName || "Sheet1", n = XLSX.utils.book_new(), s = new Nt(this), a = "compress" in e ? e.compress : !0, l = e.writeOptions || { bookType: "xlsx", bookSST: !0, compression: a }, u;
  l.type = "binary", n.SheetNames = [], n.Sheets = {};
  function h() {
    var f = [], p = [], g = {}, b = { s: { c: 0, r: 0 }, e: { c: r[0] ? r[0].columns.reduce((m, v) => m + (v && v.width ? v.width : 1), 0) : 0, r: r.length } };
    return r.forEach((m, v) => {
      var S = [];
      m.columns.forEach(function(y, x) {
        y ? (S.push(!(y.value instanceof Date) && typeof y.value == "object" ? JSON.stringify(y.value) : y.value), (y.width > 1 || y.height > -1) && (y.height > 1 || y.width > 1) && p.push({ s: { r: v, c: x }, e: { r: v + y.height - 1, c: x + y.width - 1 } })) : S.push("");
      }), f.push(S);
    }), XLSX.utils.sheet_add_aoa(g, f), g["!ref"] = XLSX.utils.encode_range(b), p.length && (g["!merges"] = p), g;
  }
  if (e.sheetOnly) {
    t(h());
    return;
  }
  if (e.sheets)
    for (var c in e.sheets)
      e.sheets[c] === !0 ? (n.SheetNames.push(c), n.Sheets[c] = h()) : (n.SheetNames.push(c), s.commsSend(e.sheets[c], "download", "intercept", {
        type: "xlsx",
        options: { sheetOnly: !0 },
        active: i.active,
        intercept: function(f) {
          n.Sheets[c] = f;
        }
      }));
  else
    n.SheetNames.push(o), n.Sheets[o] = h();
  e.documentProcessing && (n = e.documentProcessing(n));
  function d(f) {
    for (var p = new ArrayBuffer(f.length), g = new Uint8Array(p), b = 0; b != f.length; ++b)
      g[b] = f.charCodeAt(b) & 255;
    return p;
  }
  u = XLSX.write(n, l), t(d(u), "application/octet-stream");
}
function gV(r, e, t) {
  this.modExists("export", !0) && t(this.modules.export.generateHTMLTable(r), "text/html");
}
function mV(r, e, t) {
  const i = [];
  r.forEach((o) => {
    const n = {};
    switch (o.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        o.columns.forEach((s) => {
          s && (n[s.component.getTitleDownload() || s.component.getField()] = s.value);
        }), i.push(JSON.stringify(n));
        break;
    }
  }), t(i.join(`
`), "application/x-ndjson");
}
var bV = {
  csv: cV,
  json: dV,
  jsonLines: mV,
  pdf: fV,
  xlsx: pV,
  html: gV
};
class Ln extends fe {
  constructor(e) {
    super(e), this.registerTableOption("downloadEncoder", function(t, i) {
      return new Blob([t], { type: i });
    }), this.registerTableOption("downloadReady", void 0), this.registerTableOption("downloadConfig", {}), this.registerTableOption("downloadRowRange", "active"), this.registerColumnOption("download"), this.registerColumnOption("titleDownload");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.registerTableFunction("download", this.download.bind(this)), this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("downloadReady", "downloadEncoder");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  downloadToTab(e, t, i, o) {
    this.download(e, t, i, o, !0);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //trigger file download
  download(e, t, i, o, n) {
    var s = !1;
    function a(u, h) {
      n ? n === !0 ? this.triggerDownload(u, h, e, t, !0) : n(u) : this.triggerDownload(u, h, e, t);
    }
    if (typeof e == "function" ? s = e : Ln.downloaders[e] ? s = Ln.downloaders[e] : console.warn("Download Error - No such download type found: ", e), s) {
      var l = this.generateExportList(o);
      s.call(this.table, l, i || {}, a.bind(this));
    }
  }
  generateExportList(e) {
    var t = this.table.modules.export.generateExportList(this.table.options.downloadConfig, !1, e || this.table.options.downloadRowRange, "download"), i = this.table.options.groupHeaderDownload;
    return i && !Array.isArray(i) && (i = [i]), t.forEach((o) => {
      var n;
      o.type === "group" && (n = o.columns[0], i && i[o.indent] && (n.value = i[o.indent](n.value, o.component._group.getRowCount(), o.component._group.getData(), o.component)));
    }), t;
  }
  triggerDownload(e, t, i, o, n) {
    var s = document.createElement("a"), a = this.table.options.downloadEncoder(e, t);
    a && (n ? window.open(window.URL.createObjectURL(a)) : (o = o || "Tabulator." + (typeof i == "function" ? "txt" : i), navigator.msSaveOrOpenBlob ? navigator.msSaveOrOpenBlob(a, o) : (s.setAttribute("href", window.URL.createObjectURL(a)), s.setAttribute("download", o), s.style.display = "none", document.body.appendChild(s), s.click(), document.body.removeChild(s))), this.dispatchExternal("downloadComplete"));
  }
  commsReceived(e, t, i) {
    switch (t) {
      case "intercept":
        this.download(i.type, "", i.options, i.active, i.intercept);
        break;
    }
  }
}
Ln.moduleName = "download";
Ln.downloaders = bV;
function Eh(r, e) {
  var t = e.mask, i = typeof e.maskLetterChar < "u" ? e.maskLetterChar : "A", o = typeof e.maskNumberChar < "u" ? e.maskNumberChar : "9", n = typeof e.maskWildcardChar < "u" ? e.maskWildcardChar : "*";
  function s(a) {
    var l = t[a];
    typeof l < "u" && l !== n && l !== i && l !== o && (r.value = r.value + "" + l, s(a + 1));
  }
  r.addEventListener("keydown", (a) => {
    var l = r.value.length, u = a.key;
    if (a.keyCode > 46 && !a.ctrlKey && !a.metaKey) {
      if (l >= t.length)
        return a.preventDefault(), a.stopPropagation(), !1;
      switch (t[l]) {
        case i:
          if (u.toUpperCase() == u.toLowerCase())
            return a.preventDefault(), a.stopPropagation(), !1;
          break;
        case o:
          if (isNaN(u))
            return a.preventDefault(), a.stopPropagation(), !1;
          break;
        case n:
          break;
        default:
          if (u !== t[l])
            return a.preventDefault(), a.stopPropagation(), !1;
      }
    }
  }), r.addEventListener("keyup", (a) => {
    a.keyCode > 46 && e.maskAutoFill && s(r.value.length);
  }), r.placeholder || (r.placeholder = t), e.maskAutoFill && s(r.value.length);
}
function OV(r, e, t, i, o) {
  var n = r.getValue(), s = document.createElement("input");
  if (s.setAttribute("type", o.search ? "search" : "text"), s.style.padding = "4px", s.style.width = "100%", s.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let l in o.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), s.setAttribute(l, s.getAttribute(l) + o.elementAttributes["+" + l])) : s.setAttribute(l, o.elementAttributes[l]);
  s.value = typeof n < "u" ? n : "", e(function() {
    r.getType() === "cell" && (s.focus({ preventScroll: !0 }), s.style.height = "100%", o.selectContents && s.select());
  });
  function a(l) {
    (n === null || typeof n > "u") && s.value !== "" || s.value !== n ? t(s.value) && (n = s.value) : i();
  }
  return s.addEventListener("change", a), s.addEventListener("blur", a), s.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        a();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        l.stopPropagation();
        break;
    }
  }), o.mask && Eh(s, o), s;
}
function vV(r, e, t, i, o) {
  var n = r.getValue(), s = o.verticalNavigation || "hybrid", a = String(n !== null && typeof n < "u" ? n : ""), l = document.createElement("textarea"), u = 0;
  if (l.style.display = "block", l.style.padding = "2px", l.style.height = "100%", l.style.width = "100%", l.style.boxSizing = "border-box", l.style.whiteSpace = "pre-wrap", l.style.resize = "none", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let c in o.elementAttributes)
      c.charAt(0) == "+" ? (c = c.slice(1), l.setAttribute(c, l.getAttribute(c) + o.elementAttributes["+" + c])) : l.setAttribute(c, o.elementAttributes[c]);
  l.value = a, e(function() {
    r.getType() === "cell" && (l.focus({ preventScroll: !0 }), l.style.height = "100%", l.scrollHeight, l.style.height = l.scrollHeight + "px", r.getRow().normalizeHeight(), o.selectContents && l.select());
  });
  function h(c) {
    (n === null || typeof n > "u") && l.value !== "" || l.value !== n ? (t(l.value) && (n = l.value), setTimeout(function() {
      r.getRow().normalizeHeight();
    }, 300)) : i();
  }
  return l.addEventListener("change", h), l.addEventListener("blur", h), l.addEventListener("keyup", function() {
    l.style.height = "";
    var c = l.scrollHeight;
    l.style.height = c + "px", c != u && (u = c, r.getRow().normalizeHeight());
  }), l.addEventListener("keydown", function(c) {
    switch (c.keyCode) {
      case 13:
        c.shiftKey && o.shiftEnterSubmit && h();
        break;
      case 27:
        i();
        break;
      case 38:
        (s == "editor" || s == "hybrid" && l.selectionStart) && (c.stopImmediatePropagation(), c.stopPropagation());
        break;
      case 40:
        (s == "editor" || s == "hybrid" && l.selectionStart !== l.value.length) && (c.stopImmediatePropagation(), c.stopPropagation());
        break;
      case 35:
      case 36:
        c.stopPropagation();
        break;
    }
  }), o.mask && Eh(l, o), l;
}
function wV(r, e, t, i, o) {
  var n = r.getValue(), s = o.verticalNavigation || "editor", a = document.createElement("input");
  if (a.setAttribute("type", "number"), typeof o.max < "u" && a.setAttribute("max", o.max), typeof o.min < "u" && a.setAttribute("min", o.min), typeof o.step < "u" && a.setAttribute("step", o.step), a.style.padding = "4px", a.style.width = "100%", a.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let h in o.elementAttributes)
      h.charAt(0) == "+" ? (h = h.slice(1), a.setAttribute(h, a.getAttribute(h) + o.elementAttributes["+" + h])) : a.setAttribute(h, o.elementAttributes[h]);
  a.value = n;
  var l = function(h) {
    u();
  };
  e(function() {
    r.getType() === "cell" && (a.removeEventListener("blur", l), a.focus({ preventScroll: !0 }), a.style.height = "100%", a.addEventListener("blur", l), o.selectContents && a.select());
  });
  function u() {
    var h = a.value;
    !isNaN(h) && h !== "" && (h = Number(h)), h !== n ? t(h) && (n = h) : i();
  }
  return a.addEventListener("keydown", function(h) {
    switch (h.keyCode) {
      case 13:
        u();
        break;
      case 27:
        i();
        break;
      case 38:
      case 40:
        s == "editor" && (h.stopImmediatePropagation(), h.stopPropagation());
        break;
      case 35:
      case 36:
        h.stopPropagation();
        break;
    }
  }), o.mask && Eh(a, o), a;
}
function yV(r, e, t, i, o) {
  var n = r.getValue(), s = document.createElement("input");
  if (s.setAttribute("type", "range"), typeof o.max < "u" && s.setAttribute("max", o.max), typeof o.min < "u" && s.setAttribute("min", o.min), typeof o.step < "u" && s.setAttribute("step", o.step), s.style.padding = "4px", s.style.width = "100%", s.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let l in o.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), s.setAttribute(l, s.getAttribute(l) + o.elementAttributes["+" + l])) : s.setAttribute(l, o.elementAttributes[l]);
  s.value = n, e(function() {
    r.getType() === "cell" && (s.focus({ preventScroll: !0 }), s.style.height = "100%");
  });
  function a() {
    var l = s.value;
    !isNaN(l) && l !== "" && (l = Number(l)), l != n ? t(l) && (n = l) : i();
  }
  return s.addEventListener("blur", function(l) {
    a();
  }), s.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        a();
        break;
      case 27:
        i();
        break;
    }
  }), s;
}
function xV(r, e, t, i, o) {
  var n = o.format, s = o.verticalNavigation || "editor", a = n ? window.DateTime || luxon.DateTime : null, l = r.getValue(), u = document.createElement("input");
  function h(d) {
    var f;
    return a.isDateTime(d) ? f = d : n === "iso" ? f = a.fromISO(String(d)) : f = a.fromFormat(String(d), n), f.toFormat("yyyy-MM-dd");
  }
  if (u.type = "date", u.style.padding = "4px", u.style.width = "100%", u.style.boxSizing = "border-box", o.max && u.setAttribute("max", n ? h(o.max) : o.max), o.min && u.setAttribute("min", n ? h(o.min) : o.min), o.elementAttributes && typeof o.elementAttributes == "object")
    for (let d in o.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), u.setAttribute(d, u.getAttribute(d) + o.elementAttributes["+" + d])) : u.setAttribute(d, o.elementAttributes[d]);
  l = typeof l < "u" ? l : "", n && (a ? l = h(l) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), u.value = l, e(function() {
    r.getType() === "cell" && (u.focus({ preventScroll: !0 }), u.style.height = "100%", o.selectContents && u.select());
  });
  function c() {
    var d = u.value, f;
    if ((l === null || typeof l > "u") && d !== "" || d !== l) {
      if (d && n)
        switch (f = a.fromFormat(String(d), "yyyy-MM-dd"), n) {
          case !0:
            d = f;
            break;
          case "iso":
            d = f.toISO();
            break;
          default:
            d = f.toFormat(n);
        }
      t(d) && (l = u.value);
    } else
      i();
  }
  return u.addEventListener("blur", function(d) {
    (d.relatedTarget || d.rangeParent || d.explicitOriginalTarget !== u) && c();
  }), u.addEventListener("keydown", function(d) {
    switch (d.keyCode) {
      case 13:
        c();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        d.stopPropagation();
        break;
      case 38:
      case 40:
        s == "editor" && (d.stopImmediatePropagation(), d.stopPropagation());
        break;
    }
  }), u;
}
function SV(r, e, t, i, o) {
  var n = o.format, s = o.verticalNavigation || "editor", a = n ? window.DateTime || luxon.DateTime : null, l, u = r.getValue(), h = document.createElement("input");
  if (h.type = "time", h.style.padding = "4px", h.style.width = "100%", h.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let d in o.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), h.setAttribute(d, h.getAttribute(d) + o.elementAttributes["+" + d])) : h.setAttribute(d, o.elementAttributes[d]);
  u = typeof u < "u" ? u : "", n && (a ? (a.isDateTime(u) ? l = u : n === "iso" ? l = a.fromISO(String(u)) : l = a.fromFormat(String(u), n), u = l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), h.value = u, e(function() {
    r.getType() == "cell" && (h.focus({ preventScroll: !0 }), h.style.height = "100%", o.selectContents && h.select());
  });
  function c() {
    var d = h.value, f;
    if ((u === null || typeof u > "u") && d !== "" || d !== u) {
      if (d && n)
        switch (f = a.fromFormat(String(d), "hh:mm"), n) {
          case !0:
            d = f;
            break;
          case "iso":
            d = f.toISO();
            break;
          default:
            d = f.toFormat(n);
        }
      t(d) && (u = h.value);
    } else
      i();
  }
  return h.addEventListener("blur", function(d) {
    (d.relatedTarget || d.rangeParent || d.explicitOriginalTarget !== h) && c();
  }), h.addEventListener("keydown", function(d) {
    switch (d.keyCode) {
      case 13:
        c();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        d.stopPropagation();
        break;
      case 38:
      case 40:
        s == "editor" && (d.stopImmediatePropagation(), d.stopPropagation());
        break;
    }
  }), h;
}
function CV(r, e, t, i, o) {
  var n = o.format, s = o.verticalNavigation || "editor", a = n ? window.DateTime || luxon.DateTime : null, l, u = r.getValue(), h = document.createElement("input");
  if (h.type = "datetime-local", h.style.padding = "4px", h.style.width = "100%", h.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let d in o.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), h.setAttribute(d, h.getAttribute(d) + o.elementAttributes["+" + d])) : h.setAttribute(d, o.elementAttributes[d]);
  u = typeof u < "u" ? u : "", n && (a ? (a.isDateTime(u) ? l = u : n === "iso" ? l = a.fromISO(String(u)) : l = a.fromFormat(String(u), n), u = l.toFormat("yyyy-MM-dd") + "T" + l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), h.value = u, e(function() {
    r.getType() === "cell" && (h.focus({ preventScroll: !0 }), h.style.height = "100%", o.selectContents && h.select());
  });
  function c() {
    var d = h.value, f;
    if ((u === null || typeof u > "u") && d !== "" || d !== u) {
      if (d && n)
        switch (f = a.fromISO(String(d)), n) {
          case !0:
            d = f;
            break;
          case "iso":
            d = f.toISO();
            break;
          default:
            d = f.toFormat(n);
        }
      t(d) && (u = h.value);
    } else
      i();
  }
  return h.addEventListener("blur", function(d) {
    (d.relatedTarget || d.rangeParent || d.explicitOriginalTarget !== h) && c();
  }), h.addEventListener("keydown", function(d) {
    switch (d.keyCode) {
      case 13:
        c();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        d.stopPropagation();
        break;
      case 38:
      case 40:
        s == "editor" && (d.stopImmediatePropagation(), d.stopPropagation());
        break;
    }
  }), h;
}
class ig {
  constructor(e, t, i, o, n, s) {
    this.edit = e, this.table = e.table, this.cell = t, this.params = this._initializeParams(s), this.data = [], this.displayItems = [], this.currentItems = [], this.focusedItem = null, this.input = this._createInputElement(), this.listEl = this._createListElement(), this.initialValues = null, this.isFilter = t.getType() === "header", this.filterTimeout = null, this.filtered = !1, this.typing = !1, this.values = [], this.popup = null, this.listIteration = 0, this.lastAction = "", this.filterTerm = "", this.blurable = !0, this.actions = {
      success: o,
      cancel: n
    }, this._deprecatedOptionsCheck(), this._initializeValue(), i(this._onRendered.bind(this));
  }
  _deprecatedOptionsCheck() {
    this.params.listItemFormatter && this.cell.getTable().deprecationAdvisor.msg("The listItemFormatter editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.sortValuesList && this.cell.getTable().deprecationAdvisor.msg("The sortValuesList editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchFunc && this.cell.getTable().deprecationAdvisor.msg("The searchFunc editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchingPlaceholder && this.cell.getTable().deprecationAdvisor.msg("The searchingPlaceholder editor param has been deprecated, please see the latest editor documentation for updated options");
  }
  _initializeValue() {
    var e = this.cell.getValue();
    typeof e > "u" && typeof this.params.defaultValue < "u" && (e = this.params.defaultValue), this.initialValues = this.params.multiselect ? e : [e], this.isFilter && (this.input.value = this.initialValues ? this.initialValues.join(",") : "", this.headerFilterInitialListGen());
  }
  _onRendered() {
    var e = this.cell.getElement();
    function t(i) {
      i.stopPropagation();
    }
    this.isFilter || (this.input.style.height = "100%", this.input.focus({ preventScroll: !0 })), e.addEventListener("click", t), setTimeout(() => {
      e.removeEventListener("click", t);
    }, 1e3), this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
  }
  _createListElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-edit-list"), e.addEventListener("mousedown", this._preventBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e;
  }
  _setListWidth() {
    var e = this.isFilter ? this.input : this.cell.getElement();
    this.listEl.style.minWidth = e.offsetWidth + "px", this.params.maxWidth && (this.params.maxWidth === !0 ? this.listEl.style.maxWidth = e.offsetWidth + "px" : typeof this.params.maxWidth == "number" ? this.listEl.style.maxWidth = this.params.maxWidth + "px" : this.listEl.style.maxWidth = this.params.maxWidth);
  }
  _createInputElement() {
    var e = this.params.elementAttributes, t = document.createElement("input");
    if (t.setAttribute("type", this.params.clearable ? "search" : "text"), t.style.padding = "4px", t.style.width = "100%", t.style.boxSizing = "border-box", this.params.autocomplete || (t.style.cursor = "default", t.style.caretColor = "transparent"), e && typeof e == "object")
      for (let i in e)
        i.charAt(0) == "+" ? (i = i.slice(1), t.setAttribute(i, t.getAttribute(i) + e["+" + i])) : t.setAttribute(i, e[i]);
    return this.params.mask && Eh(t, this.params), this._bindInputEvents(t), t;
  }
  _initializeParams(e) {
    var t = ["values", "valuesURL", "valuesLookup"], i;
    return e = Object.assign({}, e), e.verticalNavigation = e.verticalNavigation || "editor", e.placeholderLoading = typeof e.placeholderLoading > "u" ? "Searching ..." : e.placeholderLoading, e.placeholderEmpty = typeof e.placeholderEmpty > "u" ? "No Results Found" : e.placeholderEmpty, e.filterDelay = typeof e.filterDelay > "u" ? 300 : e.filterDelay, e.emptyValue = Object.keys(e).includes("emptyValue") ? e.emptyValue : "", i = Object.keys(e).filter((o) => t.includes(o)).length, i ? i > 1 && console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor") : console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set"), e.autocomplete ? e.multiselect && (e.multiselect = !1, console.warn("list editor config error - multiselect option is not available when autocomplete is enabled")) : (e.freetext && (e.freetext = !1, console.warn("list editor config error - freetext option is only available when autocomplete is enabled")), e.filterFunc && (e.filterFunc = !1, console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled")), e.filterRemote && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled")), e.mask && (e.mask = !1, console.warn("list editor config error - mask option is only available when autocomplete is enabled")), e.allowEmpty && (e.allowEmpty = !1, console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled")), e.listOnEmpty && (e.listOnEmpty = !1, console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled"))), e.filterRemote && !(typeof e.valuesLookup == "function" || e.valuesURL) && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source")), e;
  }
  //////////////////////////////////////
  ////////// Event Handling ////////////
  //////////////////////////////////////
  _bindInputEvents(e) {
    e.addEventListener("focus", this._inputFocus.bind(this)), e.addEventListener("click", this._inputClick.bind(this)), e.addEventListener("blur", this._inputBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e.addEventListener("search", this._inputSearch.bind(this)), this.params.autocomplete && e.addEventListener("keyup", this._inputKeyUp.bind(this));
  }
  _inputFocus(e) {
    this.rebuildOptionsList();
  }
  _filter() {
    this.params.filterRemote ? (clearTimeout(this.filterTimeout), this.filterTimeout = setTimeout(() => {
      this.rebuildOptionsList();
    }, this.params.filterDelay)) : this._filterList();
  }
  _inputClick(e) {
    e.stopPropagation();
  }
  _inputBlur(e) {
    this.blurable && (this.popup ? this.popup.hide() : this._resolveValue(!0));
  }
  _inputSearch() {
    this._clearChoices();
  }
  _inputKeyDown(e) {
    switch (e.keyCode) {
      case 38:
        this._keyUp(e);
        break;
      case 40:
        this._keyDown(e);
        break;
      case 37:
      case 39:
        this._keySide(e);
        break;
      case 13:
        this._keyEnter();
        break;
      case 27:
        this._keyEsc();
        break;
      case 36:
      case 35:
        this._keyHomeEnd(e);
        break;
      case 9:
        this._keyTab(e);
        break;
      default:
        this._keySelectLetter(e);
    }
  }
  _inputKeyUp(e) {
    switch (e.keyCode) {
      case 38:
      case 37:
      case 39:
      case 40:
      case 13:
      case 27:
        break;
      default:
        this._keyAutoCompLetter(e);
    }
  }
  _preventPopupBlur() {
    this.popup && this.popup.blockHide(), setTimeout(() => {
      this.popup && this.popup.restoreHide();
    }, 10);
  }
  _preventBlur() {
    this.blurable = !1, setTimeout(() => {
      this.blurable = !0;
    }, 10);
  }
  //////////////////////////////////////
  //////// Keyboard Navigation /////////
  //////////////////////////////////////
  _keyTab(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem, !0);
  }
  _keyUp(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t > 0 && this._focusItem(this.displayItems[t - 1]));
  }
  _keyDown(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t < this.displayItems.length - 1) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t < this.displayItems.length - 1 && (t == -1 ? this._focusItem(this.displayItems[0]) : this._focusItem(this.displayItems[t + 1])));
  }
  _keySide(e) {
    this.params.autocomplete || (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault());
  }
  _keyEnter(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem);
  }
  _keyEsc(e) {
    this._cancel();
  }
  _keyHomeEnd(e) {
    this.params.autocomplete && e.stopImmediatePropagation();
  }
  _keySelectLetter(e) {
    this.params.autocomplete || (e.preventDefault(), e.keyCode >= 38 && e.keyCode <= 90 && this._scrollToValue(e.keyCode));
  }
  _keyAutoCompLetter(e) {
    this._filter(), this.lastAction = "typing", this.typing = !0;
  }
  _scrollToValue(e) {
    clearTimeout(this.filterTimeout);
    var t = String.fromCharCode(e).toLowerCase();
    this.filterTerm += t.toLowerCase();
    var i = this.displayItems.find((o) => typeof o.label < "u" && o.label.toLowerCase().startsWith(this.filterTerm));
    i && this._focusItem(i), this.filterTimeout = setTimeout(() => {
      this.filterTerm = "";
    }, 800);
  }
  _focusItem(e) {
    this.lastAction = "focus", this.focusedItem && this.focusedItem.element && this.focusedItem.element.classList.remove("focused"), this.focusedItem = e, e && e.element && (e.element.classList.add("focused"), e.element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" }));
  }
  //////////////////////////////////////
  /////// Data List Generation /////////
  //////////////////////////////////////
  headerFilterInitialListGen() {
    this._generateOptions(!0);
  }
  rebuildOptionsList() {
    this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch((e) => {
      Number.isInteger(e) || console.error("List generation error", e);
    });
  }
  _filterList() {
    this._buildList(this._filterOptions()), this._showList();
  }
  _generateOptions(e) {
    var t = [], i = ++this.listIteration;
    return this.filtered = !1, this.params.values ? t = this.params.values : this.params.valuesURL ? t = this._ajaxRequest(this.params.valuesURL, this.input.value) : typeof this.params.valuesLookup == "function" ? t = this.params.valuesLookup(this.cell, this.input.value) : this.params.valuesLookup && (t = this._uniqueColumnValues(this.params.valuesLookupField)), t instanceof Promise ? (e || this._addPlaceholder(this.params.placeholderLoading), t.then().then((o) => this.listIteration === i ? this._parseList(o) : Promise.reject(i))) : Promise.resolve(this._parseList(t));
  }
  _addPlaceholder(e) {
    var t = document.createElement("div");
    typeof e == "function" && (e = e(this.cell.getComponent(), this.listEl)), e && (this._clearList(), e instanceof HTMLElement ? t = e : (t.classList.add("tabulator-edit-list-placeholder"), t.innerHTML = e), this.listEl.appendChild(t), this._showList());
  }
  _ajaxRequest(e, t) {
    var i = this.params.filterRemote ? { term: t } : {};
    return e = pS(e, {}, i), fetch(e).then((o) => o.ok ? o.json().catch((n) => (console.warn("List Ajax Load Error - Invalid JSON returned", n), Promise.reject(n))) : (console.error("List Ajax Load Error - Connection Error: " + o.status, o.statusText), Promise.reject(o))).catch((o) => (console.error("List Ajax Load Error - Connection Error: ", o), Promise.reject(o)));
  }
  _uniqueColumnValues(e) {
    var t = {}, i = this.table.getData(this.params.valuesLookup), o;
    return e ? o = this.table.columnManager.getColumnByField(e) : o = this.cell.getColumn()._getSelf(), o ? i.forEach((n) => {
      var s = o.getFieldValue(n);
      s !== null && typeof s < "u" && s !== "" && (t[s] = !0);
    }) : (console.warn("unable to find matching column to create select lookup list:", e), t = []), Object.keys(t);
  }
  _parseList(e) {
    var t = [];
    return Array.isArray(e) || (e = Object.entries(e).map(([i, o]) => ({
      label: o,
      value: i
    }))), e.forEach((i) => {
      typeof i != "object" && (i = {
        label: i,
        value: i
      }), this._parseListItem(i, t, 0);
    }), !this.currentItems.length && this.params.freetext && (this.input.value = this.initialValues, this.typing = !0, this.lastAction = "typing"), this.data = t, t;
  }
  _parseListItem(e, t, i) {
    var o = {};
    e.options ? o = this._parseListGroup(e, i + 1) : (o = {
      label: e.label,
      value: e.value,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      selected: !1,
      visible: !0,
      level: i,
      original: e
    }, this.initialValues && this.initialValues.indexOf(e.value) > -1 && this._chooseItem(o, !0)), t.push(o);
  }
  _parseListGroup(e, t) {
    var i = {
      label: e.label,
      group: !0,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      visible: !0,
      level: t,
      options: [],
      original: e
    };
    return e.options.forEach((o) => {
      this._parseListItem(o, i.options, t);
    }), i;
  }
  _sortOptions(e) {
    var t;
    return this.params.sort && (t = typeof this.params.sort == "function" ? this.params.sort : this._defaultSortFunction.bind(this), this._sortGroup(t, e)), e;
  }
  _sortGroup(e, t) {
    t.sort((i, o) => e(i.label, o.label, i.value, o.value, i.original, o.original)), t.forEach((i) => {
      i.group && this._sortGroup(e, i.options);
    });
  }
  _defaultSortFunction(e, t) {
    var i, o, n, s, a = 0, l, u = /(\d+)|(\D+)/g, h = /\d/, c = 0;
    if (this.params.sort === "desc" && ([e, t] = [t, e]), !e && e !== 0)
      c = !t && t !== 0 ? 0 : -1;
    else if (!t && t !== 0)
      c = 1;
    else {
      if (isFinite(e) && isFinite(t))
        return e - t;
      if (i = String(e).toLowerCase(), o = String(t).toLowerCase(), i === o)
        return 0;
      if (!(h.test(i) && h.test(o)))
        return i > o ? 1 : -1;
      for (i = i.match(u), o = o.match(u), l = i.length > o.length ? o.length : i.length; a < l; )
        if (n = i[a], s = o[a++], n !== s)
          return isFinite(n) && isFinite(s) ? (n.charAt(0) === "0" && (n = "." + n), s.charAt(0) === "0" && (s = "." + s), n - s) : n > s ? 1 : -1;
      return i.length > o.length;
    }
    return c;
  }
  _filterOptions() {
    var e = this.params.filterFunc || this._defaultFilterFunc, t = this.input.value;
    return t ? (this.filtered = !0, this.data.forEach((i) => {
      this._filterItem(e, t, i);
    })) : this.filtered = !1, this.data;
  }
  _filterItem(e, t, i) {
    var o = !1;
    return i.group ? (i.options.forEach((n) => {
      this._filterItem(e, t, n) && (o = !0);
    }), i.visible = o) : i.visible = e(t, i.label, i.value, i.original), i.visible;
  }
  _defaultFilterFunc(e, t, i, o) {
    return e = String(e).toLowerCase(), t !== null && typeof t < "u" && (String(t).toLowerCase().indexOf(e) > -1 || String(i).toLowerCase().indexOf(e) > -1);
  }
  //////////////////////////////////////
  /////////// Display List /////////////
  //////////////////////////////////////
  _clearList() {
    for (; this.listEl.firstChild; )
      this.listEl.removeChild(this.listEl.firstChild);
    this.displayItems = [];
  }
  _buildList(e) {
    this._clearList(), e.forEach((t) => {
      this._buildItem(t);
    }), this.displayItems.length || this._addPlaceholder(this.params.placeholderEmpty);
  }
  _buildItem(e) {
    var t = e.element, i;
    if (!this.filtered || e.visible) {
      if (!t) {
        if (t = document.createElement("div"), t.tabIndex = 0, i = this.params.itemFormatter ? this.params.itemFormatter(e.label, e.value, e.original, t) : e.label, i instanceof HTMLElement ? t.appendChild(i) : t.innerHTML = i, e.group ? t.classList.add("tabulator-edit-list-group") : t.classList.add("tabulator-edit-list-item"), t.classList.add("tabulator-edit-list-group-level-" + e.level), e.elementAttributes && typeof e.elementAttributes == "object")
          for (let o in e.elementAttributes)
            o.charAt(0) == "+" ? (o = o.slice(1), t.setAttribute(o, this.input.getAttribute(o) + e.elementAttributes["+" + o])) : t.setAttribute(o, e.elementAttributes[o]);
        e.group ? t.addEventListener("click", this._groupClick.bind(this, e)) : t.addEventListener("click", this._itemClick.bind(this, e)), t.addEventListener("mousedown", this._preventBlur.bind(this)), e.element = t;
      }
      this._styleItem(e), this.listEl.appendChild(t), e.group ? e.options.forEach((o) => {
        this._buildItem(o);
      }) : this.displayItems.push(e);
    }
  }
  _showList() {
    var e = this.popup && this.popup.isVisible();
    if (this.input.parentNode) {
      if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
        this.popup && this.popup.hide(!0);
        return;
      }
      this._setListWidth(), this.popup || (this.popup = this.edit.popup(this.listEl)), this.popup.show(this.cell.getElement(), "bottom"), e || setTimeout(() => {
        this.popup.hideOnBlur(this._resolveValue.bind(this, !0));
      }, 10);
    }
  }
  _styleItem(e) {
    e && e.element && (e.selected ? e.element.classList.add("active") : e.element.classList.remove("active"));
  }
  //////////////////////////////////////
  ///////// User Interaction ///////////
  //////////////////////////////////////
  _itemClick(e, t) {
    t.stopPropagation(), this._chooseItem(e);
  }
  _groupClick(e, t) {
    t.stopPropagation();
  }
  //////////////////////////////////////
  ////// Current Item Management ///////
  //////////////////////////////////////
  _cancel() {
    this.popup.hide(!0), this.actions.cancel();
  }
  _clearChoices() {
    this.typing = !0, this.currentItems.forEach((e) => {
      e.selected = !1, this._styleItem(e);
    }), this.currentItems = [], this.focusedItem = null;
  }
  _chooseItem(e, t) {
    var i;
    this.typing = !1, this.params.multiselect ? (i = this.currentItems.indexOf(e), i > -1 ? (this.currentItems.splice(i, 1), e.selected = !1) : (this.currentItems.push(e), e.selected = !0), this.input.value = this.currentItems.map((o) => o.label).join(","), this._styleItem(e)) : (this.currentItems = [e], e.selected = !0, this.input.value = e.label, this._styleItem(e), t || this._resolveValue()), this._focusItem(e);
  }
  _resolveValue(e) {
    var t, i;
    if (this.popup && this.popup.hide(!0), this.params.multiselect)
      t = this.currentItems.map((o) => o.value);
    else if (e && this.params.autocomplete && this.typing)
      if (this.params.freetext || this.params.allowEmpty && this.input.value === "")
        t = this.input.value;
      else {
        this.actions.cancel();
        return;
      }
    else
      this.currentItems[0] ? t = this.currentItems[0].value : (i = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues, i === null || typeof i > "u" || i === "" ? t = i : t = this.params.emptyValue);
    t === "" && (t = this.params.emptyValue), this.actions.success(t), this.isFilter && (this.initialValues = t && !Array.isArray(t) ? [t] : t, this.currentItems = []);
  }
}
function QV(r, e, t, i, o) {
  this.deprecationMsg("The select editor has been deprecated, please use the new list editor");
  var n = new ig(this, r, e, t, i, o);
  return n.input;
}
function PV(r, e, t, i, o) {
  var n = new ig(this, r, e, t, i, o);
  return n.input;
}
function kV(r, e, t, i, o) {
  this.deprecationMsg("The autocomplete editor has been deprecated, please use the new list editor with the 'autocomplete' editorParam"), o.autocomplete = !0;
  var n = new ig(this, r, e, t, i, o);
  return n.input;
}
function EV(r, e, t, i, o) {
  var n = this, s = r.getElement(), a = r.getValue(), l = s.getElementsByTagName("svg").length || 5, u = s.getElementsByTagName("svg")[0] ? s.getElementsByTagName("svg")[0].getAttribute("width") : 14, h = [], c = document.createElement("div"), d = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  function f(m) {
    h.forEach(function(v, S) {
      S < m ? (n.table.browser == "ie" ? v.setAttribute("class", "tabulator-star-active") : v.classList.replace("tabulator-star-inactive", "tabulator-star-active"), v.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>') : (n.table.browser == "ie" ? v.setAttribute("class", "tabulator-star-inactive") : v.classList.replace("tabulator-star-active", "tabulator-star-inactive"), v.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>');
    });
  }
  function p(m) {
    var v = document.createElement("span"), S = d.cloneNode(!0);
    h.push(S), v.addEventListener("mouseenter", function(y) {
      y.stopPropagation(), y.stopImmediatePropagation(), f(m);
    }), v.addEventListener("mousemove", function(y) {
      y.stopPropagation(), y.stopImmediatePropagation();
    }), v.addEventListener("click", function(y) {
      y.stopPropagation(), y.stopImmediatePropagation(), t(m), s.blur();
    }), v.appendChild(S), c.appendChild(v);
  }
  function g(m) {
    a = m, f(m);
  }
  if (s.style.whiteSpace = "nowrap", s.style.overflow = "hidden", s.style.textOverflow = "ellipsis", c.style.verticalAlign = "middle", c.style.display = "inline-block", c.style.padding = "4px", d.setAttribute("width", u), d.setAttribute("height", u), d.setAttribute("viewBox", "0 0 512 512"), d.setAttribute("xml:space", "preserve"), d.style.padding = "0 1px", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let m in o.elementAttributes)
      m.charAt(0) == "+" ? (m = m.slice(1), c.setAttribute(m, c.getAttribute(m) + o.elementAttributes["+" + m])) : c.setAttribute(m, o.elementAttributes[m]);
  for (var b = 1; b <= l; b++)
    p(b);
  return a = Math.min(parseInt(a), l), f(a), c.addEventListener("mousemove", function(m) {
    f(0);
  }), c.addEventListener("click", function(m) {
    t(0);
  }), s.addEventListener("blur", function(m) {
    i();
  }), s.addEventListener("keydown", function(m) {
    switch (m.keyCode) {
      case 39:
        g(a + 1);
        break;
      case 37:
        g(a - 1);
        break;
      case 13:
        t(a);
        break;
      case 27:
        i();
        break;
    }
  }), c;
}
function TV(r, e, t, i, o) {
  var n = r.getElement(), s = typeof o.max > "u" ? n.getElementsByTagName("div")[0] && n.getElementsByTagName("div")[0].getAttribute("max") || 100 : o.max, a = typeof o.min > "u" ? n.getElementsByTagName("div")[0] && n.getElementsByTagName("div")[0].getAttribute("min") || 0 : o.min, l = (s - a) / 100, u = r.getValue() || 0, h = document.createElement("div"), c = document.createElement("div"), d, f;
  function p() {
    var g = window.getComputedStyle(n, null), b = l * Math.round(c.offsetWidth / ((n.clientWidth - parseInt(g.getPropertyValue("padding-left")) - parseInt(g.getPropertyValue("padding-right"))) / 100)) + a;
    t(b), n.setAttribute("aria-valuenow", b), n.setAttribute("aria-label", u);
  }
  if (h.style.position = "absolute", h.style.right = "0", h.style.top = "0", h.style.bottom = "0", h.style.width = "5px", h.classList.add("tabulator-progress-handle"), c.style.display = "inline-block", c.style.position = "relative", c.style.height = "100%", c.style.backgroundColor = "#488CE9", c.style.maxWidth = "100%", c.style.minWidth = "0%", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let g in o.elementAttributes)
      g.charAt(0) == "+" ? (g = g.slice(1), c.setAttribute(g, c.getAttribute(g) + o.elementAttributes["+" + g])) : c.setAttribute(g, o.elementAttributes[g]);
  return n.style.padding = "4px 4px", u = Math.min(parseFloat(u), s), u = Math.max(parseFloat(u), a), u = Math.round((u - a) / l), c.style.width = u + "%", n.setAttribute("aria-valuemin", a), n.setAttribute("aria-valuemax", s), c.appendChild(h), h.addEventListener("mousedown", function(g) {
    d = g.screenX, f = c.offsetWidth;
  }), h.addEventListener("mouseover", function() {
    h.style.cursor = "ew-resize";
  }), n.addEventListener("mousemove", function(g) {
    d && (c.style.width = f + g.screenX - d + "px");
  }), n.addEventListener("mouseup", function(g) {
    d && (g.stopPropagation(), g.stopImmediatePropagation(), d = !1, f = !1, p());
  }), n.addEventListener("keydown", function(g) {
    switch (g.keyCode) {
      case 39:
        g.preventDefault(), c.style.width = c.clientWidth + n.clientWidth / 100 + "px";
        break;
      case 37:
        g.preventDefault(), c.style.width = c.clientWidth - n.clientWidth / 100 + "px";
        break;
      case 9:
      case 13:
        p();
        break;
      case 27:
        i();
        break;
    }
  }), n.addEventListener("blur", function() {
    i();
  }), c;
}
function $V(r, e, t, i, o) {
  var n = r.getValue(), s = document.createElement("input"), a = o.tristate, l = typeof o.indeterminateValue > "u" ? null : o.indeterminateValue, u = !1, h = Object.keys(o).includes("trueValue"), c = Object.keys(o).includes("falseValue");
  if (s.setAttribute("type", "checkbox"), s.style.marginTop = "5px", s.style.boxSizing = "border-box", o.elementAttributes && typeof o.elementAttributes == "object")
    for (let f in o.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), s.setAttribute(f, s.getAttribute(f) + o.elementAttributes["+" + f])) : s.setAttribute(f, o.elementAttributes[f]);
  s.value = n, a && (typeof n > "u" || n === l || n === "") && (u = !0, s.indeterminate = !0), this.table.browser != "firefox" && this.table.browser != "safari" && e(function() {
    r.getType() === "cell" && s.focus({ preventScroll: !0 });
  }), s.checked = h ? n === o.trueValue : n === !0 || n === "true" || n === "True" || n === 1;
  function d(f) {
    var p = s.checked;
    return h && p ? p = o.trueValue : c && !p && (p = o.falseValue), a ? f ? u ? l : p : s.checked && !u ? (s.checked = !1, s.indeterminate = !0, u = !0, l) : (u = !1, p) : p;
  }
  return s.addEventListener("change", function(f) {
    t(d());
  }), s.addEventListener("blur", function(f) {
    t(d(!0));
  }), s.addEventListener("keydown", function(f) {
    f.keyCode == 13 && t(d()), f.keyCode == 27 && i();
  }), s;
}
var RV = {
  input: OV,
  textarea: vV,
  number: wV,
  range: yV,
  date: xV,
  time: SV,
  datetime: CV,
  select: QV,
  list: PV,
  autocomplete: kV,
  star: EV,
  progress: TV,
  tickCross: $V
};
class Kn extends fe {
  constructor(e) {
    super(e), this.currentCell = !1, this.mouseClick = !1, this.recursionBlock = !1, this.invalidEdit = !1, this.editedCells = [], this.editors = Kn.editors, this.registerColumnOption("editable"), this.registerColumnOption("editor"), this.registerColumnOption("editorParams"), this.registerColumnOption("cellEditing"), this.registerColumnOption("cellEdited"), this.registerColumnOption("cellEditCancelled"), this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this)), this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this)), this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this)), this.registerTableFunction("navigateNext", this.navigateNext.bind(this)), this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this)), this.registerTableFunction("navigateRight", this.navigateRight.bind(this)), this.registerTableFunction("navigateUp", this.navigateUp.bind(this)), this.registerTableFunction("navigateDown", this.navigateDown.bind(this)), this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this)), this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this)), this.registerComponentFunction("cell", "edit", this.editCell.bind(this)), this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this)), this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this)), this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this)), this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this)), this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this)), this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this)), this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
  }
  initialize() {
    this.subscribe("cell-init", this.bindEditor.bind(this)), this.subscribe("cell-delete", this.clearEdited.bind(this)), this.subscribe("cell-value-changed", this.updateCellClass.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("column-delete", this.columnDeleteCheck.bind(this)), this.subscribe("row-deleting", this.rowDeleteCheck.bind(this)), this.subscribe("row-layout", this.rowEditableCheck.bind(this)), this.subscribe("data-refreshing", this.cancelEdit.bind(this)), this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, void 0)), this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this)), this.subscribe("keybinding-nav-left", this.navigateLeft.bind(this, void 0)), this.subscribe("keybinding-nav-right", this.navigateRight.bind(this, void 0)), this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, void 0)), this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, void 0));
  }
  ///////////////////////////////////
  ////// Keybinding Functions ///////
  ///////////////////////////////////
  keybindingNavigateNext(e) {
    var t = this.currentCell, i = this.options("tabEndNewRow");
    t && (this.navigateNext(t, e) || i && (t.getElement().firstChild.blur(), i === !0 ? i = this.table.addRow({}) : typeof i == "function" ? i = this.table.addRow(i(t.row.getComponent())) : i = this.table.addRow(Object.assign({}, i)), i.then(() => {
      setTimeout(() => {
        t.getComponent().navigateNext();
      });
    })));
  }
  ///////////////////////////////////
  ///////// Cell Functions //////////
  ///////////////////////////////////
  cellIsEdited(e) {
    return !!e.modules.edit && e.modules.edit.edited;
  }
  cellCancelEdit(e) {
    e === this.currentCell ? this.table.modules.edit.cancelEdit() : console.warn("Cancel Editor Error - This cell is not currently being edited ");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  updateCellClass(e) {
    this.allowEdit(e) ? e.getElement().classList.add("tabulator-editable") : e.getElement().classList.remove("tabulator-editable");
  }
  clearCellEdited(e) {
    e || (e = this.table.modules.edit.getEditedCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.table.modules.edit.clearEdited(t._getSelf());
    });
  }
  navigatePrev(e = this.currentCell, t) {
    var i, o;
    if (e) {
      if (t && t.preventDefault(), i = this.navigateLeft(), i)
        return !0;
      if (o = this.table.rowManager.prevDisplayRow(e.row, !0), o && (i = this.findPrevEditableCell(o, o.cells.length), i))
        return i.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateNext(e = this.currentCell, t) {
    var i, o;
    if (e) {
      if (t && t.preventDefault(), i = this.navigateRight(), i)
        return !0;
      if (o = this.table.rowManager.nextDisplayRow(e.row, !0), o && (i = this.findNextEditableCell(o, -1), i))
        return i.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateLeft(e = this.currentCell, t) {
    var i, o;
    return e && (t && t.preventDefault(), i = e.getIndex(), o = this.findPrevEditableCell(e.row, i), o) ? (o.getComponent().edit(), !0) : !1;
  }
  navigateRight(e = this.currentCell, t) {
    var i, o;
    return e && (t && t.preventDefault(), i = e.getIndex(), o = this.findNextEditableCell(e.row, i), o) ? (o.getComponent().edit(), !0) : !1;
  }
  navigateUp(e = this.currentCell, t) {
    var i, o;
    return e && (t && t.preventDefault(), i = e.getIndex(), o = this.table.rowManager.prevDisplayRow(e.row, !0), o) ? (o.cells[i].getComponent().edit(), !0) : !1;
  }
  navigateDown(e = this.currentCell, t) {
    var i, o;
    return e && (t && t.preventDefault(), i = e.getIndex(), o = this.table.rowManager.nextDisplayRow(e.row, !0), o) ? (o.cells[i].getComponent().edit(), !0) : !1;
  }
  findNextEditableCell(e, t) {
    var i = !1;
    if (t < e.cells.length - 1)
      for (var o = t + 1; o < e.cells.length; o++) {
        let n = e.cells[o];
        if (n.column.modules.edit && _e.elVisible(n.getElement()) && this.allowEdit(n)) {
          i = n;
          break;
        }
      }
    return i;
  }
  findPrevEditableCell(e, t) {
    var i = !1;
    if (t > 0)
      for (var o = t - 1; o >= 0; o--) {
        let n = e.cells[o];
        if (n.column.modules.edit && _e.elVisible(n.getElement()) && this.allowEdit(n)) {
          i = n;
          break;
        }
      }
    return i;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.editor < "u" && this.initializeColumn(e);
  }
  columnDeleteCheck(e) {
    this.currentCell && this.currentCell.column === e && this.cancelEdit();
  }
  rowDeleteCheck(e) {
    this.currentCell && this.currentCell.row === e && this.cancelEdit();
  }
  rowEditableCheck(e) {
    e.getCells().forEach((t) => {
      t.column.modules.edit && typeof t.column.modules.edit.check == "function" && this.updateCellClass(t);
    });
  }
  //initialize column editor
  initializeColumn(e) {
    var t = {
      editor: !1,
      blocked: !1,
      check: e.definition.editable,
      params: e.definition.editorParams || {}
    };
    switch (typeof e.definition.editor) {
      case "string":
        this.editors[e.definition.editor] ? t.editor = this.editors[e.definition.editor] : console.warn("Editor Error - No such editor found: ", e.definition.editor);
        break;
      case "function":
        t.editor = e.definition.editor;
        break;
      case "boolean":
        e.definition.editor === !0 && (typeof e.definition.formatter != "function" ? this.editors[e.definition.formatter] ? t.editor = this.editors[e.definition.formatter] : t.editor = this.editors.input : console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", e.definition.formatter));
        break;
    }
    t.editor && (e.modules.edit = t);
  }
  getCurrentCell() {
    return this.currentCell ? this.currentCell.getComponent() : !1;
  }
  clearEditor(e) {
    var t = this.currentCell, i;
    if (this.invalidEdit = !1, t) {
      for (this.currentCell = !1, i = t.getElement(), this.dispatch("edit-editor-clear", t, e), i.classList.remove("tabulator-editing"); i.firstChild; )
        i.removeChild(i.firstChild);
      t.row.getElement().classList.remove("tabulator-editing"), t.table.element.classList.remove("tabulator-editing");
    }
  }
  cancelEdit() {
    if (this.currentCell) {
      var e = this.currentCell, t = this.currentCell.getComponent();
      this.clearEditor(!0), e.setValueActual(e.getValue()), e.cellRendered(), (e.column.definition.editor == "textarea" || e.column.definition.variableHeight) && e.row.normalizeHeight(!0), e.column.definition.cellEditCancelled && e.column.definition.cellEditCancelled.call(this.table, t), this.dispatch("edit-cancelled", e), this.dispatchExternal("cellEditCancelled", t);
    }
  }
  //return a formatted value for a cell
  bindEditor(e) {
    if (e.column.modules.edit) {
      var t = this, i = e.getElement(!0);
      this.updateCellClass(e), i.setAttribute("tabindex", 0), i.addEventListener("click", function(o) {
        i.classList.contains("tabulator-editing") || i.focus({ preventScroll: !0 });
      }), i.addEventListener("mousedown", function(o) {
        o.button === 2 ? o.preventDefault() : t.mouseClick = !0;
      }), i.addEventListener("focus", function(o) {
        t.recursionBlock || t.edit(e, o, !1);
      });
    }
  }
  focusCellNoEvent(e, t) {
    this.recursionBlock = !0, t && this.table.browser === "ie" || e.getElement().focus({ preventScroll: !0 }), this.recursionBlock = !1;
  }
  editCell(e, t) {
    this.focusCellNoEvent(e), this.edit(e, !1, t);
  }
  focusScrollAdjust(e) {
    if (this.table.rowManager.getRenderMode() == "virtual") {
      var t = this.table.rowManager.element.scrollTop, i = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop, o = e.row.getElement();
      o.offsetTop < t ? this.table.rowManager.element.scrollTop -= t - o.offsetTop : o.offsetTop + o.offsetHeight > i && (this.table.rowManager.element.scrollTop += o.offsetTop + o.offsetHeight - i);
      var n = this.table.rowManager.element.scrollLeft, s = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft, a = e.getElement();
      this.table.modExists("frozenColumns") && (n += parseInt(this.table.modules.frozenColumns.leftMargin || 0), s -= parseInt(this.table.modules.frozenColumns.rightMargin || 0)), this.table.options.renderHorizontal === "virtual" && (n -= parseInt(this.table.columnManager.renderer.vDomPadLeft), s -= parseInt(this.table.columnManager.renderer.vDomPadLeft)), a.offsetLeft < n ? this.table.rowManager.element.scrollLeft -= n - a.offsetLeft : a.offsetLeft + a.offsetWidth > s && (this.table.rowManager.element.scrollLeft += a.offsetLeft + a.offsetWidth - s);
    }
  }
  allowEdit(e) {
    var t = !!e.column.modules.edit;
    if (e.column.modules.edit)
      switch (typeof e.column.modules.edit.check) {
        case "function":
          e.row.initialized && (t = e.column.modules.edit.check(e.getComponent()));
          break;
        case "string":
          t = !!e.row.data[e.column.modules.edit.check];
          break;
        case "boolean":
          t = e.column.modules.edit.check;
          break;
      }
    return t;
  }
  edit(e, t, i) {
    var o = this, n = !0, s = function() {
    }, a = e.getElement(), l, u, h;
    if (this.currentCell) {
      !this.invalidEdit && this.currentCell !== e && this.cancelEdit();
      return;
    }
    function c(b) {
      if (o.currentCell === e) {
        var m = o.chain("edit-success", [e, b], !0, !0);
        return m === !0 || o.table.options.validationMode === "highlight" ? (o.clearEditor(), e.modules.edit || (e.modules.edit = {}), e.modules.edit.edited = !0, o.editedCells.indexOf(e) == -1 && o.editedCells.push(e), e.setValue(b, !0), m === !0) : (o.invalidEdit = !0, o.focusCellNoEvent(e, !0), s(), !1);
      }
    }
    function d() {
      o.currentCell === e && o.cancelEdit();
    }
    function f(b) {
      s = b;
    }
    if (e.column.modules.edit.blocked)
      return this.mouseClick = !1, a.blur(), !1;
    if (t && t.stopPropagation(), n = this.allowEdit(e), n || i) {
      if (o.cancelEdit(), o.currentCell = e, this.focusScrollAdjust(e), u = e.getComponent(), this.mouseClick && (this.mouseClick = !1, e.column.definition.cellClick && e.column.definition.cellClick.call(this.table, t, u)), e.column.definition.cellEditing && e.column.definition.cellEditing.call(this.table, u), this.dispatch("cell-editing", e), this.dispatchExternal("cellEditing", u), h = typeof e.column.modules.edit.params == "function" ? e.column.modules.edit.params(u) : e.column.modules.edit.params, l = e.column.modules.edit.editor.call(o, u, f, c, d, h), this.currentCell && l !== !1)
        if (l instanceof Node) {
          for (a.classList.add("tabulator-editing"), e.row.getElement().classList.add("tabulator-editing"), e.table.element.classList.add("tabulator-editing"); a.firstChild; )
            a.removeChild(a.firstChild);
          a.appendChild(l), s();
          for (var p = a.children, g = 0; g < p.length; g++)
            p[g].addEventListener("click", function(b) {
              b.stopPropagation();
            });
        } else
          return console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", l), a.blur(), !1;
      else
        return a.blur(), !1;
      return !0;
    } else
      return this.mouseClick = !1, a.blur(), !1;
  }
  getEditedCells() {
    var e = [];
    return this.editedCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearEdited(e) {
    var t;
    e.modules.edit && e.modules.edit.edited && (e.modules.edit.edited = !1, this.dispatch("edit-edited-clear", e)), t = this.editedCells.indexOf(e), t > -1 && this.editedCells.splice(t, 1);
  }
}
Kn.moduleName = "edit";
Kn.editors = RV;
class BO {
  constructor(e, t, i, o) {
    this.type = e, this.columns = t, this.component = i || !1, this.indent = o || 0;
  }
}
class Rc {
  constructor(e, t, i, o, n) {
    this.value = e, this.component = t || !1, this.width = i, this.height = o, this.depth = n;
  }
}
class vS extends fe {
  constructor(e) {
    super(e), this.config = {}, this.cloneTableStyle = !0, this.colVisProp = "", this.registerTableOption("htmlOutputConfig", !1), this.registerColumnOption("htmlOutput"), this.registerColumnOption("titleHtmlOutput");
  }
  initialize() {
    this.registerTableFunction("getHtml", this.getHtml.bind(this));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  generateExportList(e, t, i, o) {
    this.cloneTableStyle = t, this.config = e || {}, this.colVisProp = o;
    var n = this.config.columnHeaders !== !1 ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [], s = this.bodyToExportRows(this.rowLookup(i));
    return n.concat(s);
  }
  generateTable(e, t, i, o) {
    var n = this.generateExportList(e, t, i, o);
    return this.generateTableElement(n);
  }
  rowLookup(e) {
    var t = [];
    if (typeof e == "function")
      e.call(this.table).forEach((i) => {
        i = this.table.rowManager.findRow(i), i && t.push(i);
      });
    else
      switch (e) {
        case !0:
        case "visible":
          t = this.table.rowManager.getVisibleRows(!1, !0);
          break;
        case "all":
          t = this.table.rowManager.rows;
          break;
        case "selected":
          t = this.table.modules.selectRow.selectedRows;
          break;
        case "active":
        default:
          this.table.options.pagination ? t = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2) : t = this.table.rowManager.getDisplayRows();
      }
    return Object.assign([], t);
  }
  generateColumnGroupHeaders() {
    var e = [], t = this.config.columnGroups !== !1 ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
    return t.forEach((i) => {
      var o = this.processColumnGroup(i);
      o && e.push(o);
    }), e;
  }
  processColumnGroup(e) {
    var t = e.columns, i = 0, o = e.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || e.definition.title, n = {
      title: o,
      column: e,
      depth: 1
    };
    if (t.length) {
      if (n.subGroups = [], n.width = 0, t.forEach((s) => {
        var a = this.processColumnGroup(s);
        a && (n.width += a.width, n.subGroups.push(a), a.depth > i && (i = a.depth));
      }), n.depth += i, !n.width)
        return !1;
    } else if (this.columnVisCheck(e))
      n.width = 1;
    else
      return !1;
    return n;
  }
  columnVisCheck(e) {
    var t = e.definition[this.colVisProp];
    return typeof t == "function" && (t = t.call(this.table, e.getComponent())), t !== !1 && (e.visible || !e.visible && t);
  }
  headersToExportRows(e) {
    var t = [], i = 0, o = [];
    function n(s, a) {
      var l = i - a;
      if (typeof t[a] > "u" && (t[a] = []), s.height = s.subGroups ? 1 : l - s.depth + 1, t[a].push(s), s.height > 1)
        for (let u = 1; u < s.height; u++)
          typeof t[a + u] > "u" && (t[a + u] = []), t[a + u].push(!1);
      if (s.width > 1)
        for (let u = 1; u < s.width; u++)
          t[a].push(!1);
      s.subGroups && s.subGroups.forEach(function(u) {
        n(u, a + 1);
      });
    }
    return e.forEach(function(s) {
      s.depth > i && (i = s.depth);
    }), e.forEach(function(s) {
      n(s, 0);
    }), t.forEach((s) => {
      var a = [];
      s.forEach((l) => {
        if (l) {
          let u = typeof l.title > "u" ? "" : l.title;
          a.push(new Rc(u, l.column.getComponent(), l.width, l.height, l.depth));
        } else
          a.push(null);
      }), o.push(new BO("header", a));
    }), o;
  }
  bodyToExportRows(e) {
    var t = [], i = [];
    return this.table.columnManager.columnsByIndex.forEach((o) => {
      this.columnVisCheck(o) && t.push(o.getComponent());
    }), this.config.columnCalcs !== !1 && this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && e.unshift(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && e.push(this.table.modules.columnCalcs.botRow)), e = e.filter((o) => {
      switch (o.type) {
        case "group":
          return this.config.rowGroups !== !1;
        case "calc":
          return this.config.columnCalcs !== !1;
        case "row":
          return !(this.table.options.dataTree && this.config.dataTree === !1 && o.modules.dataTree.parent);
      }
      return !0;
    }), e.forEach((o, n) => {
      var s = o.getData(this.colVisProp), a = [], l = 0;
      switch (o.type) {
        case "group":
          l = o.level, a.push(new Rc(o.key, o.getComponent(), t.length, 1));
          break;
        case "calc":
        case "row":
          t.forEach((u) => {
            a.push(new Rc(u._column.getFieldValue(s), u, 1, 1));
          }), this.table.options.dataTree && this.config.dataTree !== !1 && (l = o.modules.dataTree.index);
          break;
      }
      i.push(new BO(o.type, a, o.getComponent(), l));
    }), i;
  }
  generateTableElement(e) {
    var t = document.createElement("table"), i = document.createElement("thead"), o = document.createElement("tbody"), n = this.lookupTableStyles(), s = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], a = {};
    return a.rowFormatter = s !== null ? s : this.table.options.rowFormatter, this.table.options.dataTree && this.config.dataTree !== !1 && this.table.modExists("columnCalcs") && (a.treeElementField = this.table.modules.dataTree.elementField), a.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], a.groupHeader && !Array.isArray(a.groupHeader) && (a.groupHeader = [a.groupHeader]), t.classList.add("tabulator-print-table"), this.mapElementStyles(this.table.columnManager.getHeadersElement(), i, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), e.length > 1e3 && console.warn("It may take a long time to render an HTML table with more than 1000 rows"), e.forEach((l, u) => {
      let h;
      switch (l.type) {
        case "header":
          i.appendChild(this.generateHeaderElement(l, a, n));
          break;
        case "group":
          o.appendChild(this.generateGroupElement(l, a, n));
          break;
        case "calc":
          o.appendChild(this.generateCalcElement(l, a, n));
          break;
        case "row":
          h = this.generateRowElement(l, a, n), this.mapElementStyles(u % 2 && n.evenRow ? n.evenRow : n.oddRow, h, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), o.appendChild(h);
          break;
      }
    }), i.innerHTML && t.appendChild(i), t.appendChild(o), this.mapElementStyles(this.table.element, t, ["border-top", "border-left", "border-right", "border-bottom"]), t;
  }
  lookupTableStyles() {
    var e = {};
    return this.cloneTableStyle && window.getComputedStyle && (e.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)"), e.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)"), e.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs"), e.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)"), e.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0], e.firstRow && (e.styleCells = e.firstRow.getElementsByClassName("tabulator-cell"), e.firstCell = e.styleCells[0], e.lastCell = e.styleCells[e.styleCells.length - 1])), e;
  }
  generateHeaderElement(e, t, i) {
    var o = document.createElement("tr");
    return e.columns.forEach((n) => {
      if (n) {
        var s = document.createElement("th"), a = n.component._column.definition.cssClass ? n.component._column.definition.cssClass.split(" ") : [];
        s.colSpan = n.width, s.rowSpan = n.height, s.innerHTML = n.value, this.cloneTableStyle && (s.style.boxSizing = "border-box"), a.forEach(function(l) {
          s.classList.add(l);
        }), this.mapElementStyles(n.component.getElement(), s, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), this.mapElementStyles(n.component._column.contentElement, s, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), n.component._column.visible ? this.mapElementStyles(n.component.getElement(), s, ["width"]) : n.component._column.definition.width && (s.style.width = n.component._column.definition.width + "px"), n.component._column.parent && this.mapElementStyles(n.component._column.parent.groupElement, s, ["border-top"]), o.appendChild(s);
      }
    }), o;
  }
  generateGroupElement(e, t, i) {
    var o = document.createElement("tr"), n = document.createElement("td"), s = e.columns[0];
    return o.classList.add("tabulator-print-table-row"), t.groupHeader && t.groupHeader[e.indent] ? s.value = t.groupHeader[e.indent](s.value, e.component._group.getRowCount(), e.component._group.getData(), e.component) : t.groupHeader !== !1 && (s.value = e.component._group.generator(s.value, e.component._group.getRowCount(), e.component._group.getData(), e.component)), n.colSpan = s.width, n.innerHTML = s.value, o.classList.add("tabulator-print-table-group"), o.classList.add("tabulator-group-level-" + e.indent), s.component.isVisible() && o.classList.add("tabulator-group-visible"), this.mapElementStyles(i.firstGroup, o, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), this.mapElementStyles(i.firstGroup, n, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), o.appendChild(n), o;
  }
  generateCalcElement(e, t, i) {
    var o = this.generateRowElement(e, t, i);
    return o.classList.add("tabulator-print-table-calcs"), this.mapElementStyles(i.calcRow, o, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), o;
  }
  generateRowElement(e, t, i) {
    var o = document.createElement("tr");
    if (o.classList.add("tabulator-print-table-row"), e.columns.forEach((n, s) => {
      if (n) {
        var a = document.createElement("td"), l = n.component._column, u = this.table.columnManager.findColumnIndex(l), h = n.value, c, d = {
          modules: {},
          getValue: function() {
            return h;
          },
          getField: function() {
            return l.definition.field;
          },
          getElement: function() {
            return a;
          },
          getType: function() {
            return "cell";
          },
          getColumn: function() {
            return l.getComponent();
          },
          getData: function() {
            return e.component.getData();
          },
          getRow: function() {
            return e.component;
          },
          getComponent: function() {
            return d;
          },
          column: l
        }, f = l.definition.cssClass ? l.definition.cssClass.split(" ") : [];
        if (f.forEach(function(p) {
          a.classList.add(p);
        }), this.table.modExists("format") && this.config.formatCells !== !1)
          h = this.table.modules.format.formatExportValue(d, this.colVisProp);
        else
          switch (typeof h) {
            case "object":
              h = h !== null ? JSON.stringify(h) : "";
              break;
            case "undefined":
              h = "";
              break;
          }
        h instanceof Node ? a.appendChild(h) : a.innerHTML = h, c = i.styleCells && i.styleCells[u] ? i.styleCells[u] : i.firstCell, c && (this.mapElementStyles(c, a, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"]), l.definition.align && (a.style.textAlign = l.definition.align)), this.table.options.dataTree && this.config.dataTree !== !1 && (t.treeElementField && t.treeElementField == l.field || !t.treeElementField && s == 0) && (e.component._row.modules.dataTree.controlEl && a.insertBefore(e.component._row.modules.dataTree.controlEl.cloneNode(!0), a.firstChild), e.component._row.modules.dataTree.branchEl && a.insertBefore(e.component._row.modules.dataTree.branchEl.cloneNode(!0), a.firstChild)), o.appendChild(a), d.modules.format && d.modules.format.renderedCallback && d.modules.format.renderedCallback();
      }
    }), t.rowFormatter && e.type === "row" && this.config.formatCells !== !1) {
      let n = Object.assign(e.component);
      n.getElement = function() {
        return o;
      }, t.rowFormatter(e.component);
    }
    return o;
  }
  generateHTMLTable(e) {
    var t = document.createElement("div");
    return t.appendChild(this.generateTableElement(e)), t.innerHTML;
  }
  getHtml(e, t, i, o) {
    var n = this.generateExportList(i || this.table.options.htmlOutputConfig, t, e, o || "htmlOutput");
    return this.generateHTMLTable(n);
  }
  mapElementStyles(e, t, i) {
    if (this.cloneTableStyle && e && t) {
      var o = {
        "background-color": "backgroundColor",
        color: "fontColor",
        width: "width",
        "font-weight": "fontWeight",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "text-align": "textAlign",
        "border-top": "borderTop",
        "border-left": "borderLeft",
        "border-right": "borderRight",
        "border-bottom": "borderBottom",
        "padding-top": "paddingTop",
        "padding-left": "paddingLeft",
        "padding-right": "paddingRight",
        "padding-bottom": "paddingBottom"
      };
      if (window.getComputedStyle) {
        var n = window.getComputedStyle(e);
        i.forEach(function(s) {
          t.style[o[s]] || (t.style[o[s]] = n.getPropertyValue(s));
        });
      }
    }
  }
}
vS.moduleName = "export";
var _V = {
  //equal to
  "=": function(r, e, t, i) {
    return e == r;
  },
  //less than
  "<": function(r, e, t, i) {
    return e < r;
  },
  //less than or equal to
  "<=": function(r, e, t, i) {
    return e <= r;
  },
  //greater than
  ">": function(r, e, t, i) {
    return e > r;
  },
  //greater than or equal to
  ">=": function(r, e, t, i) {
    return e >= r;
  },
  //not equal to
  "!=": function(r, e, t, i) {
    return e != r;
  },
  regex: function(r, e, t, i) {
    return typeof r == "string" && (r = new RegExp(r)), r.test(e);
  },
  //contains the string
  like: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().indexOf(r.toLowerCase()) > -1 : !1;
  },
  //contains the keywords
  keywords: function(r, e, t, i) {
    var o = r.toLowerCase().split(typeof i.separator > "u" ? " " : i.separator), n = String(e === null || typeof e > "u" ? "" : e).toLowerCase(), s = [];
    return o.forEach((a) => {
      n.includes(a) && s.push(!0);
    }), i.matchAll ? s.length === o.length : !!s.length;
  },
  //starts with the string
  starts: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().startsWith(r.toLowerCase()) : !1;
  },
  //ends with the string
  ends: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().endsWith(r.toLowerCase()) : !1;
  },
  //in array
  in: function(r, e, t, i) {
    return Array.isArray(r) ? r.length ? r.indexOf(e) > -1 : !0 : (console.warn("Filter Error - filter value is not an array:", r), !1);
  }
};
class rr extends fe {
  constructor(e) {
    super(e), this.filterList = [], this.headerFilters = {}, this.headerFilterColumns = [], this.prevHeaderFilterChangeCheck = "", this.prevHeaderFilterChangeCheck = "{}", this.changed = !1, this.tableInitialized = !1, this.registerTableOption("filterMode", "local"), this.registerTableOption("initialFilter", !1), this.registerTableOption("initialHeaderFilter", !1), this.registerTableOption("headerFilterLiveFilterDelay", 300), this.registerTableOption("placeholderHeaderFilter", !1), this.registerColumnOption("headerFilter"), this.registerColumnOption("headerFilterPlaceholder"), this.registerColumnOption("headerFilterParams"), this.registerColumnOption("headerFilterEmptyCheck"), this.registerColumnOption("headerFilterFunc"), this.registerColumnOption("headerFilterFuncParams"), this.registerColumnOption("headerFilterLiveFilter"), this.registerTableFunction("searchRows", this.searchRows.bind(this)), this.registerTableFunction("searchData", this.searchData.bind(this)), this.registerTableFunction("setFilter", this.userSetFilter.bind(this)), this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this)), this.registerTableFunction("addFilter", this.userAddFilter.bind(this)), this.registerTableFunction("getFilters", this.getFilters.bind(this)), this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this)), this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this)), this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this)), this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this)), this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this)), this.registerTableFunction("clearFilter", this.userClearFilter.bind(this)), this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this)), this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this)), this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this)), this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this)), this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
  }
  initialize() {
    this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this)), this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this)), this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.subscribe("placeholder", this.generatePlaceholder.bind(this)), this.table.options.filterMode === "remote" && this.subscribe("data-params", this.remoteFilterParams.bind(this)), this.registerDataHandler(this.filter.bind(this), 10);
  }
  tableBuilt() {
    this.table.options.initialFilter && this.setFilter(this.table.options.initialFilter), this.table.options.initialHeaderFilter && this.table.options.initialHeaderFilter.forEach((e) => {
      var t = this.table.columnManager.findColumn(e.field);
      if (t)
        this.setHeaderFilterValue(t, e.value);
      else
        return console.warn("Column Filter Error - No matching column found:", e.field), !1;
    }), this.tableInitialized = !0;
  }
  remoteFilterParams(e, t, i, o) {
    return o.filter = this.getFilters(!0, !0), o;
  }
  generatePlaceholder(e) {
    if (this.table.options.placeholderHeaderFilter && Object.keys(this.headerFilters).length)
      return this.table.options.placeholderHeaderFilter;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  //set standard filters
  userSetFilter(e, t, i, o) {
    this.setFilter(e, t, i, o), this.refreshFilter();
  }
  //set standard filters
  userRefreshFilter() {
    this.refreshFilter();
  }
  //add filter to array
  userAddFilter(e, t, i, o) {
    this.addFilter(e, t, i, o), this.refreshFilter();
  }
  userSetHeaderFilterFocus(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      this.setHeaderFilterFocus(t);
    else
      return console.warn("Column Filter Focus Error - No matching column found:", e), !1;
  }
  userGetHeaderFilterValue(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      return this.getHeaderFilterValue(t);
    console.warn("Column Filter Error - No matching column found:", e);
  }
  userSetHeaderFilterValue(e, t) {
    var i = this.table.columnManager.findColumn(e);
    if (i)
      this.setHeaderFilterValue(i, t);
    else
      return console.warn("Column Filter Error - No matching column found:", e), !1;
  }
  //remove filter from array
  userRemoveFilter(e, t, i) {
    this.removeFilter(e, t, i), this.refreshFilter();
  }
  //clear filters
  userClearFilter(e) {
    this.clearFilter(e), this.refreshFilter();
  }
  //clear header filters
  userClearHeaderFilter() {
    this.clearHeaderFilter(), this.refreshFilter();
  }
  //search for specific row components
  searchRows(e, t, i) {
    return this.search("rows", e, t, i);
  }
  //search for specific data
  searchData(e, t, i) {
    return this.search("data", e, t, i);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnHeaderFilter(e) {
    var t = e.definition;
    t.headerFilter && this.initializeColumn(e);
  }
  //initialize column header filter
  initializeColumn(e, t) {
    var i = this, o = e.getField();
    function n(s) {
      var a = e.modules.filter.tagType == "input" && e.modules.filter.attrType == "text" || e.modules.filter.tagType == "textarea" ? "partial" : "match", l = "", u = "", h;
      if (typeof e.modules.filter.prevSuccess > "u" || e.modules.filter.prevSuccess !== s) {
        if (e.modules.filter.prevSuccess = s, e.modules.filter.emptyFunc(s))
          delete i.headerFilters[o];
        else {
          switch (e.modules.filter.value = s, typeof e.definition.headerFilterFunc) {
            case "string":
              rr.filters[e.definition.headerFilterFunc] ? (l = e.definition.headerFilterFunc, h = function(c) {
                var d = e.definition.headerFilterFuncParams || {}, f = e.getFieldValue(c);
                return d = typeof d == "function" ? d(s, f, c) : d, rr.filters[e.definition.headerFilterFunc](s, f, c, d);
              }) : console.warn("Header Filter Error - Matching filter function not found: ", e.definition.headerFilterFunc);
              break;
            case "function":
              h = function(c) {
                var d = e.definition.headerFilterFuncParams || {}, f = e.getFieldValue(c);
                return d = typeof d == "function" ? d(s, f, c) : d, e.definition.headerFilterFunc(s, f, c, d);
              }, l = h;
              break;
          }
          if (!h)
            switch (a) {
              case "partial":
                h = function(c) {
                  var d = e.getFieldValue(c);
                  return typeof d < "u" && d !== null ? String(d).toLowerCase().indexOf(String(s).toLowerCase()) > -1 : !1;
                }, l = "like";
                break;
              default:
                h = function(c) {
                  return e.getFieldValue(c) == s;
                }, l = "=";
            }
          i.headerFilters[o] = { value: s, func: h, type: l };
        }
        e.modules.filter.value = s, u = JSON.stringify(i.headerFilters), i.prevHeaderFilterChangeCheck !== u && (i.prevHeaderFilterChangeCheck = u, i.trackChanges(), i.refreshFilter());
      }
      return !0;
    }
    e.modules.filter = {
      success: n,
      attrType: !1,
      tagType: !1,
      emptyFunc: !1
    }, this.generateHeaderFilterElement(e);
  }
  generateHeaderFilterElement(e, t, i) {
    var o = this, n = e.modules.filter.success, s = e.getField(), a, l, u, h, c, d, f, p;
    e.modules.filter.value = t;
    function g() {
    }
    function b(m) {
      p = m;
    }
    if (e.modules.filter.headerElement && e.modules.filter.headerElement.parentNode && e.contentElement.removeChild(e.modules.filter.headerElement.parentNode), s) {
      switch (e.modules.filter.emptyFunc = e.definition.headerFilterEmptyCheck || function(m) {
        return !m && m !== 0;
      }, a = document.createElement("div"), a.classList.add("tabulator-header-filter"), typeof e.definition.headerFilter) {
        case "string":
          o.table.modules.edit.editors[e.definition.headerFilter] ? (l = o.table.modules.edit.editors[e.definition.headerFilter], (e.definition.headerFilter === "tick" || e.definition.headerFilter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(m) {
            return m !== !0 && m !== !1;
          })) : console.warn("Filter Error - Cannot build header filter, No such editor found: ", e.definition.editor);
          break;
        case "function":
          l = e.definition.headerFilter;
          break;
        case "boolean":
          e.modules.edit && e.modules.edit.editor ? l = e.modules.edit.editor : e.definition.formatter && o.table.modules.edit.editors[e.definition.formatter] ? (l = o.table.modules.edit.editors[e.definition.formatter], (e.definition.formatter === "tick" || e.definition.formatter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(m) {
            return m !== !0 && m !== !1;
          })) : l = o.table.modules.edit.editors.input;
          break;
      }
      if (l) {
        if (h = {
          getValue: function() {
            return typeof t < "u" ? t : "";
          },
          getField: function() {
            return e.definition.field;
          },
          getElement: function() {
            return a;
          },
          getColumn: function() {
            return e.getComponent();
          },
          getTable: () => this.table,
          getType: () => "header",
          getRow: function() {
            return {
              normalizeHeight: function() {
              }
            };
          }
        }, f = e.definition.headerFilterParams || {}, f = typeof f == "function" ? f.call(o.table, h) : f, u = l.call(this.table.modules.edit, h, b, n, g, f), !u) {
          console.warn("Filter Error - Cannot add filter to " + s + " column, editor returned a value of false");
          return;
        }
        if (!(u instanceof Node)) {
          console.warn("Filter Error - Cannot add filter to " + s + " column, editor should return an instance of Node, the editor returned:", u);
          return;
        }
        o.langBind("headerFilters|columns|" + e.definition.field, function(m) {
          u.setAttribute("placeholder", typeof m < "u" && m ? m : e.definition.headerFilterPlaceholder || o.langText("headerFilters|default"));
        }), u.addEventListener("click", function(m) {
          m.stopPropagation(), u.focus();
        }), u.addEventListener("focus", (m) => {
          var v = this.table.columnManager.contentsElement.scrollLeft, S = this.table.rowManager.element.scrollLeft;
          v !== S && (this.table.rowManager.scrollHorizontal(v), this.table.columnManager.scrollHorizontal(v));
        }), c = !1, d = function(m) {
          c && clearTimeout(c), c = setTimeout(function() {
            n(u.value);
          }, o.table.options.headerFilterLiveFilterDelay);
        }, e.modules.filter.headerElement = u, e.modules.filter.attrType = u.hasAttribute("type") ? u.getAttribute("type").toLowerCase() : "", e.modules.filter.tagType = u.tagName.toLowerCase(), e.definition.headerFilterLiveFilter !== !1 && (e.definition.headerFilter === "autocomplete" || e.definition.headerFilter === "tickCross" || (e.definition.editor === "autocomplete" || e.definition.editor === "tickCross") && e.definition.headerFilter === !0 || (u.addEventListener("keyup", d), u.addEventListener("search", d), e.modules.filter.attrType == "number" && u.addEventListener("change", function(m) {
          n(u.value);
        }), e.modules.filter.attrType == "text" && this.table.browser !== "ie" && u.setAttribute("type", "search")), (e.modules.filter.tagType == "input" || e.modules.filter.tagType == "select" || e.modules.filter.tagType == "textarea") && u.addEventListener("mousedown", function(m) {
          m.stopPropagation();
        })), a.appendChild(u), e.contentElement.appendChild(a), i || o.headerFilterColumns.push(e), p && p();
      }
    } else
      console.warn("Filter Error - Cannot add header filter, column has no field set:", e.definition.title);
  }
  //hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  hideHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "none");
    });
  }
  //show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  showHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "");
    });
  }
  //programmatically set focus of header filter
  setHeaderFilterFocus(e) {
    e.modules.filter && e.modules.filter.headerElement ? e.modules.filter.headerElement.focus() : console.warn("Column Filter Focus Error - No header filter set on column:", e.getField());
  }
  //programmatically get value of header filter
  getHeaderFilterValue(e) {
    if (e.modules.filter && e.modules.filter.headerElement)
      return e.modules.filter.value;
    console.warn("Column Filter Error - No header filter set on column:", e.getField());
  }
  //programmatically set value of header filter
  setHeaderFilterValue(e, t) {
    e && (e.modules.filter && e.modules.filter.headerElement ? (this.generateHeaderFilterElement(e, t, !0), e.modules.filter.success(t)) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  reloadHeaderFilter(e) {
    e && (e.modules.filter && e.modules.filter.headerElement ? this.generateHeaderFilterElement(e, e.modules.filter.value, !0) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  refreshFilter() {
    this.tableInitialized && (this.table.options.filterMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0));
  }
  //check if the filters has changed since last use
  trackChanges() {
    this.changed = !0, this.dispatch("filter-changed");
  }
  //check if the filters has changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //set standard filters
  setFilter(e, t, i, o) {
    this.filterList = [], Array.isArray(e) || (e = [{ field: e, type: t, value: i, params: o }]), this.addFilter(e);
  }
  //add filter to array
  addFilter(e, t, i, o) {
    var n = !1;
    Array.isArray(e) || (e = [{ field: e, type: t, value: i, params: o }]), e.forEach((s) => {
      s = this.findFilter(s), s && (this.filterList.push(s), n = !0);
    }), n && this.trackChanges();
  }
  findFilter(e) {
    var t;
    if (Array.isArray(e))
      return this.findSubFilters(e);
    var i = !1;
    return typeof e.field == "function" ? i = function(o) {
      return e.field(o, e.type || {});
    } : rr.filters[e.type] ? (t = this.table.columnManager.getColumnByField(e.field), t ? i = function(o) {
      return rr.filters[e.type](e.value, t.getFieldValue(o), o, e.params || {});
    } : i = function(o) {
      return rr.filters[e.type](e.value, o[e.field], o, e.params || {});
    }) : console.warn("Filter Error - No such filter type found, ignoring: ", e.type), e.func = i, e.func ? e : !1;
  }
  findSubFilters(e) {
    var t = [];
    return e.forEach((i) => {
      i = this.findFilter(i), i && t.push(i);
    }), t.length ? t : !1;
  }
  //get all filters
  getFilters(e, t) {
    var i = [];
    return e && (i = this.getHeaderFilters()), t && i.forEach(function(o) {
      typeof o.type == "function" && (o.type = "function");
    }), i = i.concat(this.filtersToArray(this.filterList, t)), i;
  }
  //filter to Object
  filtersToArray(e, t) {
    var i = [];
    return e.forEach((o) => {
      var n;
      Array.isArray(o) ? i.push(this.filtersToArray(o, t)) : (n = { field: o.field, type: o.type, value: o.value }, t && typeof n.type == "function" && (n.type = "function"), i.push(n));
    }), i;
  }
  //get all filters
  getHeaderFilters() {
    var e = [];
    for (var t in this.headerFilters)
      e.push({ field: t, type: this.headerFilters[t].type, value: this.headerFilters[t].value });
    return e;
  }
  //remove filter from array
  removeFilter(e, t, i) {
    Array.isArray(e) || (e = [{ field: e, type: t, value: i }]), e.forEach((o) => {
      var n = -1;
      typeof o.field == "object" ? n = this.filterList.findIndex((s) => o === s) : n = this.filterList.findIndex((s) => o.field === s.field && o.type === s.type && o.value === s.value), n > -1 ? this.filterList.splice(n, 1) : console.warn("Filter Error - No matching filter type found, ignoring: ", o.type);
    }), this.trackChanges();
  }
  //clear filters
  clearFilter(e) {
    this.filterList = [], e && this.clearHeaderFilter(), this.trackChanges();
  }
  //clear header filters
  clearHeaderFilter() {
    this.headerFilters = {}, this.prevHeaderFilterChangeCheck = "{}", this.headerFilterColumns.forEach((e) => {
      typeof e.modules.filter.value < "u" && delete e.modules.filter.value, e.modules.filter.prevSuccess = void 0, this.reloadHeaderFilter(e);
    }), this.trackChanges();
  }
  //search data and return matching rows
  search(e, t, i, o) {
    var n = [], s = [];
    return Array.isArray(t) || (t = [{ field: t, type: i, value: o }]), t.forEach((a) => {
      a = this.findFilter(a), a && s.push(a);
    }), this.table.rowManager.rows.forEach((a) => {
      var l = !0;
      s.forEach((u) => {
        this.filterRecurse(u, a.getData()) || (l = !1);
      }), l && n.push(e === "data" ? a.getData("data") : a.getComponent());
    }), n;
  }
  //filter row array
  filter(e, t) {
    var i = [], o = [];
    return this.subscribedExternal("dataFiltering") && this.dispatchExternal("dataFiltering", this.getFilters(!0)), this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length) ? e.forEach((n) => {
      this.filterRow(n) && i.push(n);
    }) : i = e.slice(0), this.subscribedExternal("dataFiltered") && (i.forEach((n) => {
      o.push(n.getComponent());
    }), this.dispatchExternal("dataFiltered", this.getFilters(!0), o)), i;
  }
  //filter individual row
  filterRow(e, t) {
    var i = !0, o = e.getData();
    this.filterList.forEach((s) => {
      this.filterRecurse(s, o) || (i = !1);
    });
    for (var n in this.headerFilters)
      this.headerFilters[n].func(o) || (i = !1);
    return i;
  }
  filterRecurse(e, t) {
    var i = !1;
    return Array.isArray(e) ? e.forEach((o) => {
      this.filterRecurse(o, t) && (i = !0);
    }) : i = e.func(t), i;
  }
}
rr.moduleName = "filter";
rr.filters = _V;
function DV(r, e, t) {
  return this.emptyToSpace(this.sanitizeHTML(r.getValue()));
}
function MV(r, e, t) {
  return r.getValue();
}
function XV(r, e, t) {
  return r.getElement().style.whiteSpace = "pre-wrap", this.emptyToSpace(this.sanitizeHTML(r.getValue()));
}
function AV(r, e, t) {
  var i = parseFloat(r.getValue()), o = "", n, s, a, l, u, h = e.decimal || ".", c = e.thousand || ",", d = e.negativeSign || "-", f = e.symbol || "", p = !!e.symbolAfter, g = typeof e.precision < "u" ? e.precision : 2;
  if (isNaN(i))
    return this.emptyToSpace(this.sanitizeHTML(r.getValue()));
  if (i < 0 && (i = Math.abs(i), o = d), n = g !== !1 ? i.toFixed(g) : i, n = String(n).split("."), s = n[0], a = n.length > 1 ? h + n[1] : "", e.thousand !== !1)
    for (l = /(\d+)(\d{3})/; l.test(s); )
      s = s.replace(l, "$1" + c + "$2");
  return u = s + a, o === !0 ? (u = "(" + u + ")", p ? u + f : f + u) : p ? o + u + f : o + f + u;
}
function zV(r, e, t) {
  var i = r.getValue(), o = e.urlPrefix || "", n = e.download, s = i, a = document.createElement("a"), l;
  function u(h, c) {
    var d = h.shift(), f = c[d];
    return h.length && typeof f == "object" ? u(h, f) : f;
  }
  if (e.labelField && (l = r.getData(), s = u(e.labelField.split(this.table.options.nestedFieldSeparator), l)), e.label)
    switch (typeof e.label) {
      case "string":
        s = e.label;
        break;
      case "function":
        s = e.label(r);
        break;
    }
  if (s) {
    if (e.urlField && (l = r.getData(), i = l[e.urlField]), e.url)
      switch (typeof e.url) {
        case "string":
          i = e.url;
          break;
        case "function":
          i = e.url(r);
          break;
      }
    return a.setAttribute("href", o + i), e.target && a.setAttribute("target", e.target), e.download && (typeof n == "function" ? n = n(r) : n = n === !0 ? "" : n, a.setAttribute("download", n)), a.innerHTML = this.emptyToSpace(this.sanitizeHTML(s)), a;
  } else
    return "&nbsp;";
}
function NV(r, e, t) {
  var i = document.createElement("img"), o = r.getValue();
  switch (e.urlPrefix && (o = e.urlPrefix + r.getValue()), e.urlSuffix && (o = o + e.urlSuffix), i.setAttribute("src", o), typeof e.height) {
    case "number":
      i.style.height = e.height + "px";
      break;
    case "string":
      i.style.height = e.height;
      break;
  }
  switch (typeof e.width) {
    case "number":
      i.style.width = e.width + "px";
      break;
    case "string":
      i.style.width = e.width;
      break;
  }
  return i.addEventListener("load", function() {
    r.getRow().normalizeHeight();
  }), i;
}
function VV(r, e, t) {
  var i = r.getValue(), o = r.getElement(), n = e.allowEmpty, s = e.allowTruthy, a = Object.keys(e).includes("trueValue"), l = typeof e.tickElement < "u" ? e.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>', u = typeof e.crossElement < "u" ? e.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
  return a && i === e.trueValue || !a && (s && i || i === !0 || i === "true" || i === "True" || i === 1 || i === "1") ? (o.setAttribute("aria-checked", !0), l || "") : n && (i === "null" || i === "" || i === null || typeof i > "u") ? (o.setAttribute("aria-checked", "mixed"), "") : (o.setAttribute("aria-checked", !1), u || "");
}
function ZV(r, e, t) {
  var i = window.DateTime || luxon.DateTime, o = e.inputFormat || "yyyy-MM-dd HH:mm:ss", n = e.outputFormat || "dd/MM/yyyy HH:mm:ss", s = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", a = r.getValue();
  if (typeof i < "u") {
    var l;
    return i.isDateTime(a) ? l = a : o === "iso" ? l = i.fromISO(String(a)) : l = i.fromFormat(String(a), o), l.isValid ? (e.timezone && (l = l.setZone(e.timezone)), l.toFormat(n)) : s === !0 || !a ? a : typeof s == "function" ? s(a) : s;
  } else
    console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
}
function LV(r, e, t) {
  var i = window.DateTime || luxon.DateTime, o = e.inputFormat || "yyyy-MM-dd HH:mm:ss", n = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", s = typeof e.suffix < "u" ? e.suffix : !1, a = typeof e.unit < "u" ? e.unit : "days", l = typeof e.humanize < "u" ? e.humanize : !1, u = typeof e.date < "u" ? e.date : i.now(), h = r.getValue();
  if (typeof i < "u") {
    var c;
    return i.isDateTime(h) ? c = h : o === "iso" ? c = i.fromISO(String(h)) : c = i.fromFormat(String(h), o), c.isValid ? l ? c.diff(u, a).toHuman() + (s ? " " + s : "") : parseInt(c.diff(u, a)[a]) + (s ? " " + s : "") : n === !0 ? h : typeof n == "function" ? n(h) : n;
  } else
    console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
}
function WV(r, e, t) {
  var i = r.getValue();
  return typeof e[i] > "u" ? (console.warn("Missing display value for " + i), i) : e[i];
}
function IV(r, e, t) {
  var i = r.getValue(), o = r.getElement(), n = e && e.stars ? e.stars : 5, s = document.createElement("span"), a = document.createElementNS("http://www.w3.org/2000/svg", "svg"), l = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>', u = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
  s.style.verticalAlign = "middle", a.setAttribute("width", "14"), a.setAttribute("height", "14"), a.setAttribute("viewBox", "0 0 512 512"), a.setAttribute("xml:space", "preserve"), a.style.padding = "0 1px", i = i && !isNaN(i) ? parseInt(i) : 0, i = Math.max(0, Math.min(i, n));
  for (var h = 1; h <= n; h++) {
    var c = a.cloneNode(!0);
    c.innerHTML = h <= i ? l : u, s.appendChild(c);
  }
  return o.style.whiteSpace = "nowrap", o.style.overflow = "hidden", o.style.textOverflow = "ellipsis", o.setAttribute("aria-label", i), s;
}
function UV(r, e, t) {
  var i = this.sanitizeHTML(r.getValue()) || 0, o = document.createElement("span"), n = e && e.max ? e.max : 100, s = e && e.min ? e.min : 0, a = e && typeof e.color < "u" ? e.color : ["red", "orange", "green"], l = "#666666", u, h;
  if (!(isNaN(i) || typeof r.getValue() > "u")) {
    switch (o.classList.add("tabulator-traffic-light"), h = parseFloat(i) <= n ? parseFloat(i) : n, h = parseFloat(h) >= s ? parseFloat(h) : s, u = (n - s) / 100, h = Math.round((h - s) / u), typeof a) {
      case "string":
        l = a;
        break;
      case "function":
        l = a(i);
        break;
      case "object":
        if (Array.isArray(a)) {
          var c = 100 / a.length, d = Math.floor(h / c);
          d = Math.min(d, a.length - 1), d = Math.max(d, 0), l = a[d];
          break;
        }
    }
    return o.style.backgroundColor = l, o;
  }
}
function YV(r, e = {}, t) {
  var i = this.sanitizeHTML(r.getValue()) || 0, o = r.getElement(), n = e.max ? e.max : 100, s = e.min ? e.min : 0, a = e.legendAlign ? e.legendAlign : "center", l, u, h, c, d;
  switch (u = parseFloat(i) <= n ? parseFloat(i) : n, u = parseFloat(u) >= s ? parseFloat(u) : s, l = (n - s) / 100, u = Math.round((u - s) / l), typeof e.color) {
    case "string":
      h = e.color;
      break;
    case "function":
      h = e.color(i);
      break;
    case "object":
      if (Array.isArray(e.color)) {
        let b = 100 / e.color.length, m = Math.floor(u / b);
        m = Math.min(m, e.color.length - 1), m = Math.max(m, 0), h = e.color[m];
        break;
      }
    default:
      h = "#2DC214";
  }
  switch (typeof e.legend) {
    case "string":
      c = e.legend;
      break;
    case "function":
      c = e.legend(i);
      break;
    case "boolean":
      c = i;
      break;
    default:
      c = !1;
  }
  switch (typeof e.legendColor) {
    case "string":
      d = e.legendColor;
      break;
    case "function":
      d = e.legendColor(i);
      break;
    case "object":
      if (Array.isArray(e.legendColor)) {
        let b = 100 / e.legendColor.length, m = Math.floor(u / b);
        m = Math.min(m, e.legendColor.length - 1), m = Math.max(m, 0), d = e.legendColor[m];
      }
      break;
    default:
      d = "#000";
  }
  o.style.minWidth = "30px", o.style.position = "relative", o.setAttribute("aria-label", u);
  var f = document.createElement("div");
  f.style.display = "inline-block", f.style.width = u + "%", f.style.backgroundColor = h, f.style.height = "100%", f.setAttribute("data-max", n), f.setAttribute("data-min", s);
  var p = document.createElement("div");
  if (p.style.position = "relative", p.style.width = "100%", p.style.height = "100%", c) {
    var g = document.createElement("div");
    g.style.position = "absolute", g.style.top = 0, g.style.left = 0, g.style.textAlign = a, g.style.width = "100%", g.style.color = d, g.innerHTML = c;
  }
  return t(function() {
    if (!(r instanceof gS)) {
      var b = document.createElement("div");
      b.style.position = "absolute", b.style.top = "4px", b.style.bottom = "4px", b.style.left = "4px", b.style.right = "4px", o.appendChild(b), o = b;
    }
    o.appendChild(p), p.appendChild(f), c && p.appendChild(g);
  }), "";
}
function FV(r, e, t) {
  return r.getElement().style.backgroundColor = this.sanitizeHTML(r.getValue()), "";
}
function BV(r, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}
function qV(r, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}
function HV(r, e, t) {
  var i = document.createElement("span"), o = r.getRow();
  return o.watchPosition((n) => {
    i.innerText = n;
  }), i;
}
function jV(r, e, t) {
  return r.getElement().classList.add("tabulator-row-handle"), "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}
function GV(r, e, t) {
  var i = document.createElement("div"), o = r.getRow()._row.modules.responsiveLayout;
  i.classList.add("tabulator-responsive-collapse-toggle"), i.innerHTML = `<svg class='tabulator-responsive-collapse-toggle-open' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12" fill="none" stroke-width="3" stroke-linecap="round" />
  <line y1="7" x1="12" y2="17" x2="12" fill="none" stroke-width="3" stroke-linecap="round" />
</svg>

<svg class='tabulator-responsive-collapse-toggle-close' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12"  fill="none" stroke-width="3" stroke-linecap="round" />
</svg>`, r.getElement().classList.add("tabulator-row-handle");
  function n(s) {
    var a = o.element;
    o.open = s, a && (o.open ? (i.classList.add("open"), a.style.display = "") : (i.classList.remove("open"), a.style.display = "none"));
  }
  return i.addEventListener("click", function(s) {
    s.stopImmediatePropagation(), n(!o.open), r.getTable().rowManager.adjustTableSize();
  }), n(o.open), i;
}
function KV(r, e, t) {
  var i = document.createElement("input"), o = !1;
  if (i.type = "checkbox", i.setAttribute("aria-label", "Select Row"), this.table.modExists("selectRow", !0))
    if (i.addEventListener("click", (s) => {
      s.stopPropagation();
    }), typeof r.getRow == "function") {
      var n = r.getRow();
      n instanceof kh ? (i.addEventListener("change", (s) => {
        this.table.options.selectableRangeMode === "click" && o ? o = !1 : n.toggleSelect();
      }), this.table.options.selectableRangeMode === "click" && i.addEventListener("click", (s) => {
        o = !0, this.table.modules.selectRow.handleComplexRowClick(n._row, s);
      }), i.checked = n.isSelected && n.isSelected(), this.table.modules.selectRow.registerRowSelectCheckbox(n, i)) : i = "";
    } else
      i.addEventListener("change", (s) => {
        this.table.modules.selectRow.selectedRows.length ? this.table.deselectRow() : this.table.selectRow(e.rowRange);
      }), this.table.modules.selectRow.registerHeaderSelectCheckbox(i);
  return i;
}
var JV = {
  plaintext: DV,
  html: MV,
  textarea: XV,
  money: AV,
  link: zV,
  image: NV,
  tickCross: VV,
  datetime: ZV,
  datetimediff: LV,
  lookup: WV,
  star: IV,
  traffic: UV,
  progress: YV,
  color: FV,
  buttonTick: BV,
  buttonCross: qV,
  rownum: HV,
  handle: jV,
  responsiveCollapse: GV,
  rowSelection: KV
};
class Ft extends fe {
  constructor(e) {
    super(e), this.registerColumnOption("formatter"), this.registerColumnOption("formatterParams"), this.registerColumnOption("formatterPrint"), this.registerColumnOption("formatterPrintParams"), this.registerColumnOption("formatterClipboard"), this.registerColumnOption("formatterClipboardParams"), this.registerColumnOption("formatterHtmlOutput"), this.registerColumnOption("formatterHtmlOutputParams"), this.registerColumnOption("titleFormatter"), this.registerColumnOption("titleFormatterParams");
  }
  initialize() {
    this.subscribe("cell-format", this.formatValue.bind(this)), this.subscribe("cell-rendered", this.cellRendered.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-format", this.formatHeader.bind(this));
  }
  //initialize column formatter
  initializeColumn(e) {
    e.modules.format = this.lookupFormatter(e, ""), typeof e.definition.formatterPrint < "u" && (e.modules.format.print = this.lookupFormatter(e, "Print")), typeof e.definition.formatterClipboard < "u" && (e.modules.format.clipboard = this.lookupFormatter(e, "Clipboard")), typeof e.definition.formatterHtmlOutput < "u" && (e.modules.format.htmlOutput = this.lookupFormatter(e, "HtmlOutput"));
  }
  lookupFormatter(e, t) {
    var i = { params: e.definition["formatter" + t + "Params"] || {} }, o = e.definition["formatter" + t];
    switch (typeof o) {
      case "string":
        Ft.formatters[o] ? i.formatter = Ft.formatters[o] : (console.warn("Formatter Error - No such formatter found: ", o), i.formatter = Ft.formatters.plaintext);
        break;
      case "function":
        i.formatter = o;
        break;
      default:
        i.formatter = Ft.formatters.plaintext;
        break;
    }
    return i;
  }
  cellRendered(e) {
    e.modules.format && e.modules.format.renderedCallback && !e.modules.format.rendered && (e.modules.format.renderedCallback(), e.modules.format.rendered = !0);
  }
  //return a formatted value for a column header
  formatHeader(e, t, i) {
    var o, n, s, a;
    return e.definition.titleFormatter ? (o = this.getFormatter(e.definition.titleFormatter), s = (l) => {
      e.titleFormatterRendered = l;
    }, a = {
      getValue: function() {
        return t;
      },
      getElement: function() {
        return i;
      },
      getType: function() {
        return "header";
      },
      getColumn: function() {
        return e.getComponent();
      },
      getTable: () => this.table
    }, n = e.definition.titleFormatterParams || {}, n = typeof n == "function" ? n() : n, o.call(this, a, n, s)) : t;
  }
  //return a formatted value for a cell
  formatValue(e) {
    var t = e.getComponent(), i = typeof e.column.modules.format.params == "function" ? e.column.modules.format.params(t) : e.column.modules.format.params;
    function o(n) {
      e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = n, e.modules.format.rendered = !1;
    }
    return e.column.modules.format.formatter.call(this, t, i, o);
  }
  formatExportValue(e, t) {
    var i = e.column.modules.format[t], o;
    if (i) {
      let s = function(a) {
        e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = a, e.modules.format.rendered = !1;
      };
      var n = s;
      return o = typeof i.params == "function" ? i.params(e.getComponent()) : i.params, i.formatter.call(this, e.getComponent(), o, s);
    } else
      return this.formatValue(e);
  }
  sanitizeHTML(e) {
    if (e) {
      var t = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      return String(e).replace(/[&<>"'`=/]/g, function(i) {
        return t[i];
      });
    } else
      return e;
  }
  emptyToSpace(e) {
    return e === null || typeof e > "u" || e === "" ? "&nbsp;" : e;
  }
  //get formatter for cell
  getFormatter(e) {
    switch (typeof e) {
      case "string":
        Ft.formatters[e] ? e = Ft.formatters[e] : (console.warn("Formatter Error - No such formatter found: ", e), e = Ft.formatters.plaintext);
        break;
      case "function":
        break;
      default:
        e = Ft.formatters.plaintext;
        break;
    }
    return e;
  }
}
Ft.moduleName = "format";
Ft.formatters = JV;
class wS extends fe {
  constructor(e) {
    super(e), this.leftColumns = [], this.rightColumns = [], this.initializationMode = "left", this.active = !1, this.blocked = !0, this.registerColumnOption("frozen");
  }
  //reset initial state
  reset() {
    this.initializationMode = "left", this.leftColumns = [], this.rightColumns = [], this.active = !1;
  }
  initialize() {
    this.subscribe("cell-layout", this.layoutCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-width", this.layout.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("table-layout", this.layout.bind(this)), this.subscribe("columns-loading", this.reset.bind(this)), this.subscribe("column-add", this.reinitializeColumns.bind(this)), this.subscribe("column-delete", this.reinitializeColumns.bind(this)), this.subscribe("table-redraw", this.layout.bind(this)), this.subscribe("layout-refreshing", this.blockLayout.bind(this)), this.subscribe("layout-refreshed", this.unblockLayout.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
  }
  blockLayout() {
    this.blocked = !0;
  }
  unblockLayout() {
    this.blocked = !1;
  }
  layoutCell(e) {
    this.layoutElement(e.element, e.column);
  }
  reinitializeColumns() {
    this.reset(), this.table.columnManager.columnsByIndex.forEach((e) => {
      this.initializeColumn(e);
    });
  }
  //initialize specific column
  initializeColumn(e) {
    var t = { margin: 0, edge: !1 };
    e.isGroup || (this.frozenCheck(e) ? (t.position = this.initializationMode, this.initializationMode == "left" ? this.leftColumns.push(e) : this.rightColumns.unshift(e), this.active = !0, e.modules.frozen = t) : this.initializationMode = "right");
  }
  frozenCheck(e) {
    return e.parent.isGroup && e.definition.frozen && console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups"), e.parent.isGroup ? this.frozenCheck(e.parent) : e.definition.frozen;
  }
  //layout calculation rows
  layoutCalcRows() {
    this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow && this.layoutRow(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow && this.layoutRow(this.table.modules.columnCalcs.botRow), this.table.modExists("groupRows") && this.layoutGroupCalcs(this.table.modules.groupRows.getGroups()));
  }
  layoutGroupCalcs(e) {
    e.forEach((t) => {
      t.calcs.top && this.layoutRow(t.calcs.top), t.calcs.bottom && this.layoutRow(t.calcs.bottom), t.groupList && t.groupList.length && this.layoutGroupCalcs(t.groupList);
    });
  }
  //calculate column positions and layout headers
  layoutColumnPosition(e) {
    var t = [], i = 0, o = 0;
    this.leftColumns.forEach((n, s) => {
      if (n.modules.frozen.marginValue = i, n.modules.frozen.margin = n.modules.frozen.marginValue + "px", n.visible && (i += n.getWidth()), s == this.leftColumns.length - 1 ? n.modules.frozen.edge = !0 : n.modules.frozen.edge = !1, n.parent.isGroup) {
        var a = this.getColGroupParentElement(n);
        t.includes(a) || (this.layoutElement(a, n), t.push(a)), n.modules.frozen.edge && a.classList.add("tabulator-frozen-" + n.modules.frozen.position);
      } else
        this.layoutElement(n.getElement(), n);
      e && n.cells.forEach((l) => {
        this.layoutElement(l.getElement(!0), n);
      });
    }), this.rightColumns.forEach((n, s) => {
      n.modules.frozen.marginValue = o, n.modules.frozen.margin = n.modules.frozen.marginValue + "px", n.visible && (o += n.getWidth()), s == this.rightColumns.length - 1 ? n.modules.frozen.edge = !0 : n.modules.frozen.edge = !1, n.parent.isGroup ? this.layoutElement(this.getColGroupParentElement(n), n) : this.layoutElement(n.getElement(), n), e && n.cells.forEach((a) => {
        this.layoutElement(a.getElement(!0), n);
      });
    });
  }
  getColGroupParentElement(e) {
    return e.parent.isGroup ? this.getColGroupParentElement(e.parent) : e.getElement();
  }
  //layout columns appropriately
  layout() {
    this.active && !this.blocked && (this.layoutColumnPosition(), this.reinitializeRows(), this.layoutCalcRows());
  }
  reinitializeRows() {
    var e = this.table.rowManager.getVisibleRows(!0), t = this.table.rowManager.getRows().filter((i) => !e.includes(i));
    t.forEach((i) => {
      i.deinitialize();
    }), e.forEach((i) => {
      i.type === "row" && this.layoutRow(i);
    });
  }
  layoutRow(e) {
    this.table.options.layout === "fitDataFill" && this.rightColumns.length && (this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")"), this.leftColumns.forEach((t) => {
      var i = e.getCell(t);
      i && this.layoutElement(i.getElement(!0), t);
    }), this.rightColumns.forEach((t) => {
      var i = e.getCell(t);
      i && this.layoutElement(i.getElement(!0), t);
    });
  }
  layoutElement(e, t) {
    var i;
    t.modules.frozen && e && (e.style.position = "sticky", this.table.rtl ? i = t.modules.frozen.position === "left" ? "right" : "left" : i = t.modules.frozen.position, e.style[i] = t.modules.frozen.margin, e.classList.add("tabulator-frozen"), t.modules.frozen.edge && e.classList.add("tabulator-frozen-" + t.modules.frozen.position));
  }
  adjustForScrollbar(e) {
    this.rightColumns.length && (this.table.columnManager.getContentsElement().style.width = "calc(100% - " + e + "px)");
  }
  _calcSpace(e, t) {
    var i = 0;
    for (let o = 0; o < t; o++)
      e[o].visible && (i += e[o].getWidth());
    return i;
  }
}
wS.moduleName = "frozenColumns";
class yS extends fe {
  constructor(e) {
    super(e), this.topElement = document.createElement("div"), this.rows = [], this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this)), this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this)), this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this)), this.registerTableOption("frozenRowsField", "id"), this.registerTableOption("frozenRows", !1);
  }
  initialize() {
    this.rows = [], this.topElement.classList.add("tabulator-frozen-rows-holder"), this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.subscribe("row-deleting", this.detachRow.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 10), this.table.options.frozenRows && (this.subscribe("data-processed", this.initializeRows.bind(this)), this.subscribe("row-added", this.initializeRow.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this))), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  initializeRows() {
    this.table.rowManager.getRows().forEach((e) => {
      this.initializeRow(e);
    });
  }
  initializeRow(e) {
    var t = this.table.options.frozenRows, i = typeof t;
    i === "number" ? e.getPosition() && e.getPosition() + this.rows.length <= t && this.freezeRow(e) : i === "function" ? t.call(this.table, e.getComponent()) && this.freezeRow(e) : Array.isArray(t) && t.includes(e.data[this.options("frozenRowsField")]) && this.freezeRow(e);
  }
  isRowFrozen(e) {
    var t = this.rows.indexOf(e);
    return t > -1;
  }
  isFrozen() {
    return !!this.rows.length;
  }
  visibleRows(e, t) {
    return this.rows.forEach((i) => {
      t.push(i);
    }), t;
  }
  //filter frozen rows out of display data
  getRows(e) {
    var t = e.slice(0);
    return this.rows.forEach(function(i) {
      var o = t.indexOf(i);
      o > -1 && t.splice(o, 1);
    }), t;
  }
  freezeRow(e) {
    e.modules.frozen ? console.warn("Freeze Error - Row is already frozen") : (e.modules.frozen = !0, this.topElement.appendChild(e.getElement()), e.initialize(), e.normalizeHeight(), this.rows.push(e), this.refreshData(!1, "display"), this.table.rowManager.adjustTableSize(), this.styleRows());
  }
  unfreezeRow(e) {
    e.modules.frozen ? (e.modules.frozen = !1, this.detachRow(e), this.table.rowManager.adjustTableSize(), this.refreshData(!1, "display"), this.rows.length && this.styleRows()) : console.warn("Freeze Error - Row is already unfrozen");
  }
  detachRow(e) {
    var t = this.rows.indexOf(e);
    if (t > -1) {
      var i = e.getElement();
      i.parentNode && i.parentNode.removeChild(i), this.rows.splice(t, 1);
    }
  }
  styleRows(e) {
    this.rows.forEach((t, i) => {
      this.table.rowManager.styleRow(t, i);
    });
  }
}
yS.moduleName = "frozenRows";
class e5 {
  constructor(e) {
    return this._group = e, this.type = "GroupComponent", new Proxy(this, {
      get: function(t, i, o) {
        return typeof t[i] < "u" ? t[i] : t._group.groupManager.table.componentFunctionBinder.handle("group", t._group, i);
      }
    });
  }
  getKey() {
    return this._group.key;
  }
  getField() {
    return this._group.field;
  }
  getElement() {
    return this._group.element;
  }
  getRows() {
    return this._group.getRows(!0);
  }
  getSubGroups() {
    return this._group.getSubGroups(!0);
  }
  getParentGroup() {
    return this._group.parent ? this._group.parent.getComponent() : !1;
  }
  isVisible() {
    return this._group.visible;
  }
  show() {
    this._group.show();
  }
  hide() {
    this._group.hide();
  }
  toggle() {
    this._group.toggleVisibility();
  }
  scrollTo(e, t) {
    return this._group.groupManager.table.rowManager.scrollToRow(this._group, e, t);
  }
  _getSelf() {
    return this._group;
  }
  getTable() {
    return this._group.groupManager.table;
  }
}
class cn {
  constructor(e, t, i, o, n, s, a) {
    this.groupManager = e, this.parent = t, this.key = o, this.level = i, this.field = n, this.hasSubGroups = i < e.groupIDLookups.length - 1, this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow, this.type = "group", this.old = a, this.rows = [], this.groups = [], this.groupList = [], this.generator = s, this.element = !1, this.elementContents = !1, this.height = 0, this.outerHeight = 0, this.initialized = !1, this.calcs = {}, this.initialized = !1, this.modules = {}, this.arrowElement = !1, this.visible = a ? a.visible : typeof e.startOpen[i] < "u" ? e.startOpen[i] : e.startOpen[0], this.component = null, this.createElements(), this.addBindings(), this.createValueGroups();
  }
  wipe(e) {
    e || (this.groupList.length ? this.groupList.forEach(function(t) {
      t.wipe();
    }) : this.rows.forEach((t) => {
      t.modules && delete t.modules.group;
    })), this.element = !1, this.arrowElement = !1, this.elementContents = !1;
  }
  createElements() {
    var e = document.createElement("div");
    e.classList.add("tabulator-arrow"), this.element = document.createElement("div"), this.element.classList.add("tabulator-row"), this.element.classList.add("tabulator-group"), this.element.classList.add("tabulator-group-level-" + this.level), this.element.setAttribute("role", "rowgroup"), this.arrowElement = document.createElement("div"), this.arrowElement.classList.add("tabulator-group-toggle"), this.arrowElement.appendChild(e), this.groupManager.table.options.movableRows !== !1 && this.groupManager.table.modExists("moveRow") && this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
  }
  createValueGroups() {
    var e = this.level + 1;
    this.groupManager.allowedValues && this.groupManager.allowedValues[e] && this.groupManager.allowedValues[e].forEach((t) => {
      this._createGroup(t, e);
    });
  }
  addBindings() {
    var e;
    this.groupManager.table.options.groupToggleElement && (e = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element, e.addEventListener("click", (t) => {
      t.stopPropagation(), t.stopImmediatePropagation(), this.toggleVisibility();
    }));
  }
  _createGroup(e, t) {
    var i = t + "_" + e, o = new cn(this.groupManager, this, t, e, this.groupManager.groupIDLookups[t].field, this.groupManager.headerGenerator[t] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[i] : !1);
    this.groups[i] = o, this.groupList.push(o);
  }
  _addRowToGroup(e) {
    var t = this.level + 1;
    if (this.hasSubGroups) {
      var i = this.groupManager.groupIDLookups[t].func(e.getData()), o = t + "_" + i;
      this.groupManager.allowedValues && this.groupManager.allowedValues[t] ? this.groups[o] && this.groups[o].addRow(e) : (this.groups[o] || this._createGroup(i, t), this.groups[o].addRow(e));
    }
  }
  _addRow(e) {
    this.rows.push(e), e.modules.group = this;
  }
  insertRow(e, t, i) {
    var o = this.conformRowData({});
    e.updateData(o);
    var n = this.rows.indexOf(t);
    n > -1 ? i ? this.rows.splice(n + 1, 0, e) : this.rows.splice(n, 0, e) : i ? this.rows.push(e) : this.rows.unshift(e), e.modules.group = this, this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this), this.groupManager.updateGroupRows(!0);
  }
  scrollHeader(e) {
    this.arrowElement && (this.arrowElement.style.marginLeft = e, this.groupList.forEach(function(t) {
      t.scrollHeader(e);
    }));
  }
  getRowIndex(e) {
  }
  //update row data to match grouping constraints
  conformRowData(e) {
    return this.field ? e[this.field] = this.key : console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function"), this.parent && (e = this.parent.conformRowData(e)), e;
  }
  removeRow(e) {
    var t = this.rows.indexOf(e), i = e.getElement();
    t > -1 && this.rows.splice(t, 1), !this.groupManager.table.options.groupValues && !this.rows.length ? (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this), this.groupManager.updateGroupRows(!0)) : (i.parentNode && i.parentNode.removeChild(i), this.groupManager.blockRedraw || (this.generateGroupHeaderContents(), this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this)));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, i;
    this.groups[t] && (delete this.groups[t], i = this.groupList.indexOf(e), i > -1 && this.groupList.splice(i, 1), this.groupList.length || (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this)));
  }
  getHeadersAndRows() {
    var e = [];
    return e.push(this), this._visSet(), this.calcs.top && (this.calcs.top.detachElement(), this.calcs.top.deleteCells()), this.calcs.bottom && (this.calcs.bottom.detachElement(), this.calcs.bottom.deleteCells()), this.visible ? this.groupList.length ? this.groupList.forEach(function(t) {
      e = e.concat(t.getHeadersAndRows());
    }) : (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs() && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), e = e.concat(this.rows), this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))) : !this.groupList.length && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && (this.groupManager.table.modules.columnCalcs.hasTopCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))), e;
  }
  getData(e, t) {
    var i = [];
    return this._visSet(), (!e || e && this.visible) && this.rows.forEach((o) => {
      i.push(o.getData(t || "data"));
    }), i;
  }
  getRowCount() {
    var e = 0;
    return this.groupList.length ? this.groupList.forEach((t) => {
      e += t.getRowCount();
    }) : e = this.rows.length, e;
  }
  toggleVisibility() {
    this.visible ? this.hide() : this.show();
  }
  hide() {
    this.visible = !1, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination ? (this.element.classList.remove("tabulator-group-visible"), this.groupList.length ? this.groupList.forEach((e) => {
      var t = e.getHeadersAndRows();
      t.forEach((i) => {
        i.detachElement();
      });
    }) : this.rows.forEach((e) => {
      var t = e.getElement();
      t.parentNode.removeChild(t);
    }), this.groupManager.updateGroupRows(!0)) : this.groupManager.updateGroupRows(!0), this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !1);
  }
  show() {
    if (this.visible = !0, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.add("tabulator-group-visible");
      var e = this.generateElement();
      this.groupList.length ? this.groupList.forEach((t) => {
        var i = t.getHeadersAndRows();
        i.forEach((o) => {
          var n = o.getElement();
          e.parentNode.insertBefore(n, e.nextSibling), o.initialize(), e = n;
        });
      }) : this.rows.forEach((t) => {
        var i = t.getElement();
        e.parentNode.insertBefore(i, e.nextSibling), t.initialize(), e = i;
      }), this.groupManager.updateGroupRows(!0);
    } else
      this.groupManager.updateGroupRows(!0);
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !0);
  }
  _visSet() {
    var e = [];
    typeof this.visible == "function" && (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.visible = this.visible(this.key, this.getRowCount(), e, this.getComponent()));
  }
  getRowGroup(e) {
    var t = !1;
    return this.groupList.length ? this.groupList.forEach(function(i) {
      var o = i.getRowGroup(e);
      o && (t = o);
    }) : this.rows.find(function(i) {
      return i === e;
    }) && (t = this), t;
  }
  getSubGroups(e) {
    var t = [];
    return this.groupList.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  getRows(e) {
    var t = [];
    return this.rows.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  generateGroupHeaderContents() {
    var e = [];
    for (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.elementContents = this.generator(this.key, this.getRowCount(), e, this.getComponent()); this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    typeof this.elementContents == "string" ? this.element.innerHTML = this.elementContents : this.element.appendChild(this.elementContents), this.element.insertBefore(this.arrowElement, this.element.firstChild);
  }
  getPath(e = []) {
    return e.unshift(this.key), this.parent && this.parent.getPath(e), e;
  }
  ////////////// Standard Row Functions //////////////
  getElement() {
    return this.elementContents ? this.element : this.generateElement();
  }
  generateElement() {
    this.addBindings = !1, this._visSet(), this.visible ? this.element.classList.add("tabulator-group-visible") : this.element.classList.remove("tabulator-group-visible");
    for (var e = 0; e < this.element.childNodes.length; ++e)
      this.element.childNodes[e].parentNode.removeChild(this.element.childNodes[e]);
    return this.generateGroupHeaderContents(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  //normalize the height of elements in the row
  normalizeHeight() {
    this.setHeight(this.element.clientHeight);
  }
  initialize(e) {
    (!this.initialized || e) && (this.normalizeHeight(), this.initialized = !0);
  }
  reinitialize() {
    this.initialized = !1, this.height = 0, _e.elVisible(this.element) && this.initialize(!0);
  }
  setHeight(e) {
    this.height != e && (this.height = e, this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  getGroup() {
    return this;
  }
  reinitializeHeight() {
  }
  calcHeight() {
  }
  setCellHeight() {
  }
  clearCellHeight() {
  }
  deinitializeHeight() {
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new e5(this)), this.component;
  }
}
class xS extends fe {
  constructor(e) {
    super(e), this.groupIDLookups = !1, this.startOpen = [function() {
      return !1;
    }], this.headerGenerator = [function() {
      return "";
    }], this.groupList = [], this.allowedValues = !1, this.groups = {}, this.displayHandler = this.getRows.bind(this), this.blockRedraw = !1, this.registerTableOption("groupBy", !1), this.registerTableOption("groupStartOpen", !0), this.registerTableOption("groupValues", !1), this.registerTableOption("groupUpdateOnCellEdit", !1), this.registerTableOption("groupHeader", !1), this.registerTableOption("groupHeaderPrint", null), this.registerTableOption("groupHeaderClipboard", null), this.registerTableOption("groupHeaderHtmlOutput", null), this.registerTableOption("groupHeaderDownload", null), this.registerTableOption("groupToggleElement", "arrow"), this.registerTableOption("groupClosedShowCalcs", !1), this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this)), this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this)), this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this)), this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this)), this.registerTableFunction("getGroups", this.userGetGroups.bind(this)), this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this)), this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
  }
  //initialize group configuration
  initialize() {
    this.subscribe("table-destroy", this._blockRedrawing.bind(this)), this.subscribe("rows-wipe", this._blockRedrawing.bind(this)), this.subscribe("rows-wiped", this._restore_redrawing.bind(this)), this.table.options.groupBy && (this.table.options.groupUpdateOnCellEdit && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0)), this.subscribe("table-built", this.configureGroupSetup.bind(this)), this.subscribe("row-deleting", this.rowDeleting.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this)), this.subscribe("rows-wipe", this.wipe.bind(this)), this.subscribe("rows-added", this.rowsUpdated.bind(this)), this.subscribe("row-moving", this.rowMoving.bind(this)), this.subscribe("row-adding-index", this.rowAddingIndex.bind(this)), this.subscribe("rows-sample", this.rowSample.bind(this)), this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this)), this.registerDisplayHandler(this.displayHandler, 20), this.initialized = !0);
  }
  _blockRedrawing() {
    this.blockRedraw = !0;
  }
  _restore_redrawing() {
    this.blockRedraw = !1;
  }
  configureGroupSetup() {
    if (this.table.options.groupBy) {
      var e = this.table.options.groupBy, t = this.table.options.groupStartOpen, i = this.table.options.groupHeader;
      if (this.allowedValues = this.table.options.groupValues, Array.isArray(e) && Array.isArray(i) && e.length > i.length && console.warn("Error creating group headers, groupHeader array is shorter than groupBy array"), this.headerGenerator = [function() {
        return "";
      }], this.startOpen = [function() {
        return !1;
      }], this.langBind("groups|item", (n, s) => {
        this.headerGenerator[0] = (a, l, u) => (typeof a > "u" ? "" : a) + "<span>(" + l + " " + (l === 1 ? n : s.groups.items) + ")</span>";
      }), this.groupIDLookups = [], e)
        this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both" && this.table.modules.columnCalcs.removeCalcs();
      else if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {
        var o = this.table.columnManager.getRealColumns();
        o.forEach((n) => {
          n.definition.topCalc && this.table.modules.columnCalcs.initializeTopRow(), n.definition.bottomCalc && this.table.modules.columnCalcs.initializeBottomRow();
        });
      }
      Array.isArray(e) || (e = [e]), e.forEach((n, s) => {
        var a, l;
        typeof n == "function" ? a = n : (l = this.table.columnManager.getColumnByField(n), l ? a = function(u) {
          return l.getFieldValue(u);
        } : a = function(u) {
          return u[n];
        }), this.groupIDLookups.push({
          field: typeof n == "function" ? !1 : n,
          func: a,
          values: this.allowedValues ? this.allowedValues[s] : !1
        });
      }), t && (Array.isArray(t) || (t = [t]), t.forEach((n) => {
      }), this.startOpen = t), i && (this.headerGenerator = Array.isArray(i) ? i : [i]);
    } else
      this.groupList = [], this.groups = {};
  }
  rowSample(e, t) {
    if (this.table.options.groupBy) {
      var i = this.getGroups(!1)[0];
      t.push(i.getRows(!1)[0]);
    }
    return t;
  }
  virtualRenderFill() {
    var e = this.table.rowManager.tableElement, t = this.table.rowManager.getVisibleRows();
    if (this.table.options.groupBy)
      t = t.filter((i) => i.type !== "group"), e.style.minWidth = t.length ? "" : this.table.columnManager.getWidth() + "px";
    else
      return t;
  }
  rowAddingIndex(e, t, i) {
    if (this.table.options.groupBy) {
      this.assignRowToGroup(e);
      var o = e.modules.group.rows;
      return o.length > 1 && (!t || t && o.indexOf(t) == -1 ? i ? o[0] !== e && (t = o[0], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)) : o[o.length - 1] !== e && (t = o[o.length - 1], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)) : this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)), t;
    }
  }
  trackChanges() {
    this.dispatch("group-changed");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  setGroupBy(e) {
    this.table.options.groupBy = e, this.initialized || this.initialize(), this.configureGroupSetup(), !e && this.table.modExists("columnCalcs") && this.table.options.columnCalcs === !0 && this.table.modules.columnCalcs.reinitializeCalcs(), this.refreshData(), this.trackChanges();
  }
  setGroupValues(e) {
    this.table.options.groupValues = e, this.configureGroupSetup(), this.refreshData(), this.trackChanges();
  }
  setGroupStartOpen(e) {
    this.table.options.groupStartOpen = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  setGroupHeader(e) {
    this.table.options.groupHeader = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  userGetGroups(e) {
    return this.getGroups(!0);
  }
  // get grouped table data in the same format as getData()
  userGetGroupedData() {
    return this.table.options.groupBy ? this.getGroupedData() : this.getData();
  }
  ///////////////////////////////////////
  ///////// Component Functions /////////
  ///////////////////////////////////////
  rowGetGroup(e) {
    return e.modules.group ? e.modules.group.getComponent() : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  rowMoving(e, t, i) {
    if (this.table.options.groupBy) {
      !i && t instanceof cn && (t = this.table.rowManager.prevDisplayRow(e) || t);
      var o = t instanceof cn ? t : t.modules.group, n = e instanceof cn ? e : e.modules.group;
      o === n ? this.table.rowManager.moveRowInArray(o.rows, e, t, i) : (n && n.removeRow(e), o.insertRow(e, t, i));
    }
  }
  rowDeleting(e) {
    this.table.options.groupBy && e.modules.group && e.modules.group.removeRow(e);
  }
  rowsUpdated(e) {
    this.table.options.groupBy && this.updateGroupRows(!0);
  }
  cellUpdated(e) {
    this.table.options.groupBy && this.reassignRowToGroup(e.row);
  }
  //return appropriate rows with group headers
  getRows(e) {
    return this.table.options.groupBy && this.groupIDLookups.length ? (this.dispatchExternal("dataGrouping"), this.generateGroups(e), this.subscribedExternal("dataGrouped") && this.dispatchExternal("dataGrouped", this.getGroups(!0)), this.updateGroupRows()) : e.slice(0);
  }
  getGroups(e) {
    var t = [];
    return this.groupList.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  getChildGroups(e) {
    var t = [];
    return e || (e = this), e.groupList.forEach((i) => {
      i.groupList.length ? t = t.concat(this.getChildGroups(i)) : t.push(i);
    }), t;
  }
  wipe() {
    this.table.options.groupBy && (this.groupList.forEach(function(e) {
      e.wipe();
    }), this.groupList = [], this.groups = {});
  }
  pullGroupListData(e) {
    var t = [];
    return e.forEach((i) => {
      var o = {};
      o.level = 0, o.rowCount = 0, o.headerContent = "";
      var n = [];
      i.hasSubGroups ? (n = this.pullGroupListData(i.groupList), o.level = i.level, o.rowCount = n.length - i.groupList.length, o.headerContent = i.generator(i.key, o.rowCount, i.rows, i), t.push(o), t = t.concat(n)) : (o.level = i.level, o.headerContent = i.generator(i.key, i.rows.length, i.rows, i), o.rowCount = i.getRows().length, t.push(o), i.getRows().forEach((s) => {
        t.push(s.getData("data"));
      }));
    }), t;
  }
  getGroupedData() {
    return this.pullGroupListData(this.groupList);
  }
  getRowGroup(e) {
    var t = !1;
    return this.options("dataTree") && (e = this.table.modules.dataTree.getTreeParentRoot(e)), this.groupList.forEach((i) => {
      var o = i.getRowGroup(e);
      o && (t = o);
    }), t;
  }
  countGroups() {
    return this.groupList.length;
  }
  generateGroups(e) {
    var t = this.groups;
    this.groups = {}, this.groupList = [], this.allowedValues && this.allowedValues[0] ? (this.allowedValues[0].forEach((i) => {
      this.createGroup(i, 0, t);
    }), e.forEach((i) => {
      this.assignRowToExistingGroup(i, t);
    })) : e.forEach((i) => {
      this.assignRowToGroup(i, t);
    }), Object.values(t).forEach((i) => {
      i.wipe(!0);
    });
  }
  createGroup(e, t, i) {
    var o = t + "_" + e, n;
    i = i || [], n = new cn(this, !1, t, e, this.groupIDLookups[0].field, this.headerGenerator[0], i[o]), this.groups[o] = n, this.groupList.push(n);
  }
  assignRowToExistingGroup(e, t) {
    var i = this.groupIDLookups[0].func(e.getData()), o = "0_" + i;
    this.groups[o] && this.groups[o].addRow(e);
  }
  assignRowToGroup(e, t) {
    var i = this.groupIDLookups[0].func(e.getData()), o = !this.groups["0_" + i];
    return o && this.createGroup(i, 0, t), this.groups["0_" + i].addRow(e), !o;
  }
  reassignRowToGroup(e) {
    if (e.type === "row") {
      var t = e.modules.group, i = t.getPath(), o = this.getExpectedPath(e), n;
      n = i.length == o.length && i.every((s, a) => s === o[a]), n || (t.removeRow(e), this.assignRowToGroup(e, this.groups), this.refreshData(!0));
    }
  }
  getExpectedPath(e) {
    var t = [], i = e.getData();
    return this.groupIDLookups.forEach((o) => {
      t.push(o.func(i));
    }), t;
  }
  updateGroupRows(e) {
    var t = [];
    return this.blockRedraw || (this.groupList.forEach((i) => {
      t = t.concat(i.getHeadersAndRows());
    }), e && this.refreshData(!0)), t;
  }
  scrollHeaders(e) {
    this.table.options.groupBy && (this.table.options.renderHorizontal === "virtual" && (e -= this.table.columnManager.renderer.vDomPadLeft), e = e + "px", this.groupList.forEach((t) => {
      t.scrollHeader(e);
    }));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, i;
    this.groups[t] && (delete this.groups[t], i = this.groupList.indexOf(e), i > -1 && this.groupList.splice(i, 1));
  }
  checkBasicModeGroupHeaderWidth() {
    var e = this.table.rowManager.tableElement, t = !0;
    this.table.rowManager.getDisplayRows().forEach((i, o) => {
      this.table.rowManager.styleRow(i, o), e.appendChild(i.getElement()), i.initialize(!0), i.type !== "group" && (t = !1);
    }), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
}
xS.moduleName = "groupRows";
var t5 = {
  cellEdit: function(r) {
    r.component.setValueProcessData(r.data.oldValue), r.component.cellRendered();
  },
  rowAdd: function(r) {
    r.component.deleteActual();
  },
  rowDelete: function(r) {
    var e = this.table.rowManager.addRowActual(r.data.data, r.data.pos, r.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(r.component, e);
  },
  rowMove: function(r) {
    this.table.rowManager.moveRowActual(r.component, this.table.rowManager.rows[r.data.posFrom], !r.data.after), this.table.rowManager.redraw();
  }
}, i5 = {
  cellEdit: function(r) {
    r.component.setValueProcessData(r.data.newValue), r.component.cellRendered();
  },
  rowAdd: function(r) {
    var e = this.table.rowManager.addRowActual(r.data.data, r.data.pos, r.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(r.component, e);
  },
  rowDelete: function(r) {
    r.component.deleteActual();
  },
  rowMove: function(r) {
    this.table.rowManager.moveRowActual(r.component, this.table.rowManager.rows[r.data.posTo], r.data.after), this.table.rowManager.redraw();
  }
};
class Ao extends fe {
  constructor(e) {
    super(e), this.history = [], this.index = -1, this.registerTableOption("history", !1);
  }
  initialize() {
    this.table.options.history && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("cell-delete", this.clearComponentHistory.bind(this)), this.subscribe("row-delete", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clear.bind(this)), this.subscribe("row-added", this.rowAdded.bind(this)), this.subscribe("row-move", this.rowMoved.bind(this))), this.registerTableFunction("undo", this.undo.bind(this)), this.registerTableFunction("redo", this.redo.bind(this)), this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this)), this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this)), this.registerTableFunction("clearHistory", this.clear.bind(this));
  }
  rowMoved(e, t, i) {
    this.action("rowMove", e, { posFrom: e.getPosition(), posTo: t.getPosition(), to: t, after: i });
  }
  rowAdded(e, t, i, o) {
    this.action("rowAdd", e, { data: t, pos: i, index: o });
  }
  rowDeleted(e) {
    var t, i;
    this.table.options.groupBy ? (i = e.getComponent().getGroup()._getSelf().rows, t = i.indexOf(e), t && (t = i[t - 1])) : (t = e.table.rowManager.getRowIndex(e), t && (t = e.table.rowManager.rows[t - 1])), this.action("rowDelete", e, { data: e.getData(), pos: !t, index: t });
  }
  cellUpdated(e) {
    this.action("cellEdit", e, { oldValue: e.oldValue, newValue: e.value });
  }
  clear() {
    this.history = [], this.index = -1;
  }
  action(e, t, i) {
    this.history = this.history.slice(0, this.index + 1), this.history.push({
      type: e,
      component: t,
      data: i
    }), this.index++;
  }
  getHistoryUndoSize() {
    return this.index + 1;
  }
  getHistoryRedoSize() {
    return this.history.length - (this.index + 1);
  }
  clearComponentHistory(e) {
    var t = this.history.findIndex(function(i) {
      return i.component === e;
    });
    t > -1 && (this.history.splice(t, 1), t <= this.index && this.index--, this.clearComponentHistory(e));
  }
  undo() {
    if (this.index > -1) {
      let e = this.history[this.index];
      return Ao.undoers[e.type].call(this, e), this.index--, this.dispatchExternal("historyUndo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Undo Error - No more history to undo"), !1;
  }
  redo() {
    if (this.history.length - 1 > this.index) {
      this.index++;
      let e = this.history[this.index];
      return Ao.redoers[e.type].call(this, e), this.dispatchExternal("historyRedo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Redo Error - No more history to redo"), !1;
  }
  //rebind rows to new element after deletion
  _rebindRow(e, t) {
    this.history.forEach(function(i) {
      if (i.component instanceof Ct)
        i.component === e && (i.component = t);
      else if (i.component instanceof _a && i.component.row === e) {
        var o = i.component.column.getField();
        o && (i.component = t.getCell(o));
      }
    });
  }
}
Ao.moduleName = "history";
Ao.undoers = t5;
Ao.redoers = i5;
class SS extends fe {
  constructor(e) {
    super(e), this.fieldIndex = [], this.hasIndex = !1;
  }
  initialize() {
    this.tableElementCheck();
  }
  tableElementCheck() {
    this.table.originalElement && this.table.originalElement.tagName === "TABLE" && (this.table.originalElement.childNodes.length ? this.parseTable() : console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element."));
  }
  parseTable() {
    var e = this.table.originalElement, t = this.table.options, i = e.getElementsByTagName("th"), o = e.getElementsByTagName("tbody")[0], n = [];
    this.hasIndex = !1, this.dispatchExternal("htmlImporting"), o = o ? o.getElementsByTagName("tr") : [], this._extractOptions(e, t), i.length ? this._extractHeaders(i, o) : this._generateBlankHeaders(i, o);
    for (var s = 0; s < o.length; s++) {
      var a = o[s], l = a.getElementsByTagName("td"), u = {};
      this.hasIndex || (u[t.index] = s);
      for (var h = 0; h < l.length; h++) {
        var c = l[h];
        typeof this.fieldIndex[h] < "u" && (u[this.fieldIndex[h]] = c.innerHTML);
      }
      n.push(u);
    }
    t.data = n, this.dispatchExternal("htmlImported");
  }
  //extract tabulator attribute options
  _extractOptions(e, t, i) {
    var o = e.attributes, n = Object.keys(i || t), s = {};
    n.forEach((h) => {
      s[h.toLowerCase()] = h;
    });
    for (var a in o) {
      var l = o[a], u;
      l && typeof l == "object" && l.name && l.name.indexOf("tabulator-") === 0 && (u = l.name.replace("tabulator-", ""), typeof s[u] < "u" && (t[s[u]] = this._attribValue(l.value)));
    }
  }
  //get value of attribute
  _attribValue(e) {
    return e === "true" ? !0 : e === "false" ? !1 : e;
  }
  //find column if it has already been defined
  _findCol(e) {
    var t = this.table.options.columns.find((i) => i.title === e);
    return t || !1;
  }
  //extract column from headers
  _extractHeaders(e, t) {
    for (var i = 0; i < e.length; i++) {
      var o = e[i], n = !1, s = this._findCol(o.textContent), a;
      s ? n = !0 : s = { title: o.textContent.trim() }, s.field || (s.field = o.textContent.trim().toLowerCase().replace(" ", "_")), a = o.getAttribute("width"), a && !s.width && (s.width = a), this._extractOptions(o, s, this.table.columnManager.optionsList.registeredDefaults), this.fieldIndex[i] = s.field, s.field == this.table.options.index && (this.hasIndex = !0), n || this.table.options.columns.push(s);
    }
  }
  //generate blank headers
  _generateBlankHeaders(e, t) {
    for (var i = 0; i < e.length; i++) {
      var o = e[i], n = { title: "", field: "col" + i };
      this.fieldIndex[i] = n.field;
      var s = o.getAttribute("width");
      s && (n.width = s), this.table.options.columns.push(n);
    }
  }
}
SS.moduleName = "htmlTableImport";
function r5(r) {
  var e = [], t = 0, i = 0, o = !1;
  for (let n = 0; n < r.length; n++) {
    let s = r[n], a = r[n + 1];
    if (e[t] || (e[t] = []), e[t][i] || (e[t][i] = ""), s == '"' && o && a == '"') {
      e[t][i] += s, n++;
      continue;
    }
    if (s == '"') {
      o = !o;
      continue;
    }
    if (s == "," && !o) {
      i++;
      continue;
    }
    if (s == "\r" && a == `
` && !o) {
      i = 0, t++, n++;
      continue;
    }
    if ((s == "\r" || s == `
`) && !o) {
      i = 0, t++;
      continue;
    }
    e[t][i] += s;
  }
  return e;
}
function o5(r) {
  try {
    return JSON.parse(r);
  } catch (e) {
    return console.warn("JSON Import Error - File contents is invalid JSON", e), Promise.reject();
  }
}
function n5(r) {
  return r;
}
var s5 = {
  csv: r5,
  json: o5,
  array: n5
};
class Da extends fe {
  constructor(e) {
    super(e), this.registerTableOption("importFormat"), this.registerTableOption("importReader", "text");
  }
  initialize() {
    this.registerTableFunction("import", this.importFromFile.bind(this)), this.table.options.importFormat && (this.subscribe("data-loading", this.loadDataCheck.bind(this), 10), this.subscribe("data-load", this.loadData.bind(this), 10));
  }
  loadDataCheck(e) {
    return this.table.options.importFormat && (typeof e == "string" || Array.isArray(e) && e.length && Array.isArray(e));
  }
  loadData(e, t, i, o, n) {
    return this.importData(this.lookupImporter(), e).then(this.structureData.bind(this)).catch((s) => (console.error("Import Error:", s || "Unable to import data"), Promise.reject(s)));
  }
  lookupImporter(e) {
    var t;
    return e || (e = this.table.options.importFormat), typeof e == "string" ? t = Da.importers[e] : t = e, t || console.error("Import Error - Importer not found:", e), t;
  }
  importFromFile(e, t) {
    var i = this.lookupImporter(e);
    if (i)
      return this.pickFile(t).then(this.importData.bind(this, i)).then(this.structureData.bind(this)).then(this.setData.bind(this)).catch((o) => (console.error("Import Error:", o || "Unable to import file"), Promise.reject(o)));
  }
  pickFile(e) {
    return new Promise((t, i) => {
      var o = document.createElement("input");
      o.type = "file", o.accept = e, o.addEventListener("change", (n) => {
        var s = o.files[0], a = new FileReader();
        switch (this.table.options.importReader) {
          case "buffer":
            a.readAsArrayBuffer(s);
            break;
          case "binary":
            a.readAsBinaryString(s);
            break;
          case "url":
            a.readAsDataURL(s);
            break;
          case "text":
          default:
            a.readAsText(s);
        }
        a.onload = (l) => {
          t(a.result);
        }, a.onerror = (l) => {
          console.warn("File Load Error - Unable to read file"), i();
        };
      }), o.click();
    });
  }
  importData(e, t) {
    var i = e.call(this.table, t);
    return i instanceof Promise ? i : i ? Promise.resolve(i) : Promise.reject();
  }
  structureData(e) {
    var t = [];
    return Array.isArray(e) && e.length && Array.isArray(e[0]) ? (this.table.options.autoColumns ? t = this.structureArrayToObject(e) : t = this.structureArrayToColumns(e), t) : e;
  }
  structureArrayToObject(e) {
    var t = e.shift(), i = e.map((o) => {
      var n = {};
      return t.forEach((s, a) => {
        n[s] = o[a];
      }), n;
    });
    return i;
  }
  structureArrayToColumns(e) {
    var t = [], i = this.table.getColumns();
    return i[0] && e[0][0] && i[0].getDefinition().title === e[0][0] && e.shift(), e.forEach((o) => {
      var n = {};
      o.forEach((s, a) => {
        var l = i[a];
        l && (n[l.getField()] = s);
      }), t.push(n);
    }), t;
  }
  setData(e) {
    return this.table.setData(e);
  }
}
Da.moduleName = "import";
Da.importers = s5;
class CS extends fe {
  constructor(e) {
    super(e), this.eventMap = {
      //row events
      rowClick: "row-click",
      rowDblClick: "row-dblclick",
      rowContext: "row-contextmenu",
      rowMouseEnter: "row-mouseenter",
      rowMouseLeave: "row-mouseleave",
      rowMouseOver: "row-mouseover",
      rowMouseOut: "row-mouseout",
      rowMouseMove: "row-mousemove",
      rowMouseDown: "row-mousedown",
      rowMouseUp: "row-mouseup",
      rowTap: "row",
      rowDblTap: "row",
      rowTapHold: "row",
      //cell events
      cellClick: "cell-click",
      cellDblClick: "cell-dblclick",
      cellContext: "cell-contextmenu",
      cellMouseEnter: "cell-mouseenter",
      cellMouseLeave: "cell-mouseleave",
      cellMouseOver: "cell-mouseover",
      cellMouseOut: "cell-mouseout",
      cellMouseMove: "cell-mousemove",
      cellMouseDown: "cell-mousedown",
      cellMouseUp: "cell-mouseup",
      cellTap: "cell",
      cellDblTap: "cell",
      cellTapHold: "cell",
      //column header events
      headerClick: "column-click",
      headerDblClick: "column-dblclick",
      headerContext: "column-contextmenu",
      headerMouseEnter: "column-mouseenter",
      headerMouseLeave: "column-mouseleave",
      headerMouseOver: "column-mouseover",
      headerMouseOut: "column-mouseout",
      headerMouseMove: "column-mousemove",
      headerMouseDown: "column-mousedown",
      headerMouseUp: "column-mouseup",
      headerTap: "column",
      headerDblTap: "column",
      headerTapHold: "column",
      //group header
      groupClick: "group-click",
      groupDblClick: "group-dblclick",
      groupContext: "group-contextmenu",
      groupMouseEnter: "group-mouseenter",
      groupMouseLeave: "group-mouseleave",
      groupMouseOver: "group-mouseover",
      groupMouseOut: "group-mouseout",
      groupMouseMove: "group-mousemove",
      groupMouseDown: "group-mousedown",
      groupMouseUp: "group-mouseup",
      groupTap: "group",
      groupDblTap: "group",
      groupTapHold: "group"
    }, this.subscribers = {}, this.touchSubscribers = {}, this.columnSubscribers = {}, this.touchWatchers = {
      row: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      cell: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      column: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      group: {
        tap: null,
        tapDbl: null,
        tapHold: null
      }
    }, this.registerColumnOption("headerClick"), this.registerColumnOption("headerDblClick"), this.registerColumnOption("headerContext"), this.registerColumnOption("headerMouseEnter"), this.registerColumnOption("headerMouseLeave"), this.registerColumnOption("headerMouseOver"), this.registerColumnOption("headerMouseOut"), this.registerColumnOption("headerMouseMove"), this.registerColumnOption("headerMouseDown"), this.registerColumnOption("headerMouseUp"), this.registerColumnOption("headerTap"), this.registerColumnOption("headerDblTap"), this.registerColumnOption("headerTapHold"), this.registerColumnOption("cellClick"), this.registerColumnOption("cellDblClick"), this.registerColumnOption("cellContext"), this.registerColumnOption("cellMouseEnter"), this.registerColumnOption("cellMouseLeave"), this.registerColumnOption("cellMouseOver"), this.registerColumnOption("cellMouseOut"), this.registerColumnOption("cellMouseMove"), this.registerColumnOption("cellMouseDown"), this.registerColumnOption("cellMouseUp"), this.registerColumnOption("cellTap"), this.registerColumnOption("cellDblTap"), this.registerColumnOption("cellTapHold");
  }
  initialize() {
    this.initializeExternalEvents(), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this)), this.subscribe("scroll-horizontal", this.clearTouchWatchers.bind(this)), this.subscribe("scroll-vertical", this.clearTouchWatchers.bind(this));
  }
  clearTouchWatchers() {
    var e = Object.values(this.touchWatchers);
    e.forEach((t) => {
      for (let i in t)
        t[i] = null;
    });
  }
  cellContentsSelectionFixer(e, t) {
    var i;
    if (!(this.table.modExists("edit") && this.table.modules.edit.currentCell === t)) {
      e.preventDefault();
      try {
        document.selection ? (i = document.body.createTextRange(), i.moveToElementText(t.getElement()), i.select()) : window.getSelection && (i = document.createRange(), i.selectNode(t.getElement()), window.getSelection().removeAllRanges(), window.getSelection().addRange(i));
      } catch {
      }
    }
  }
  initializeExternalEvents() {
    for (let e in this.eventMap)
      this.subscriptionChangeExternal(e, this.subscriptionChanged.bind(this, e));
  }
  subscriptionChanged(e, t) {
    t ? this.subscribers[e] || (this.eventMap[e].includes("-") ? (this.subscribers[e] = this.handle.bind(this, e), this.subscribe(this.eventMap[e], this.subscribers[e])) : this.subscribeTouchEvents(e)) : this.eventMap[e].includes("-") ? this.subscribers[e] && !this.columnSubscribers[e] && !this.subscribedExternal(e) && (this.unsubscribe(this.eventMap[e], this.subscribers[e]), delete this.subscribers[e]) : this.unsubscribeTouchEvents(e);
  }
  subscribeTouchEvents(e) {
    var t = this.eventMap[e];
    this.touchSubscribers[t + "-touchstart"] || (this.touchSubscribers[t + "-touchstart"] = this.handleTouch.bind(this, t, "start"), this.touchSubscribers[t + "-touchend"] = this.handleTouch.bind(this, t, "end"), this.subscribe(t + "-touchstart", this.touchSubscribers[t + "-touchstart"]), this.subscribe(t + "-touchend", this.touchSubscribers[t + "-touchend"])), this.subscribers[e] = !0;
  }
  unsubscribeTouchEvents(e) {
    var t = !0, i = this.eventMap[e];
    if (this.subscribers[e] && !this.subscribedExternal(e)) {
      delete this.subscribers[e];
      for (let o in this.eventMap)
        this.eventMap[o] === i && this.subscribers[o] && (t = !1);
      t && (this.unsubscribe(i + "-touchstart", this.touchSubscribers[i + "-touchstart"]), this.unsubscribe(i + "-touchend", this.touchSubscribers[i + "-touchend"]), delete this.touchSubscribers[i + "-touchstart"], delete this.touchSubscribers[i + "-touchend"]);
    }
  }
  initializeColumn(e) {
    var t = e.definition;
    for (let i in this.eventMap)
      t[i] && (this.subscriptionChanged(i, !0), this.columnSubscribers[i] || (this.columnSubscribers[i] = []), this.columnSubscribers[i].push(e));
  }
  handle(e, t, i) {
    this.dispatchEvent(e, t, i);
  }
  handleTouch(e, t, i, o) {
    var n = this.touchWatchers[e];
    switch (e === "column" && (e = "header"), t) {
      case "start":
        n.tap = !0, clearTimeout(n.tapHold), n.tapHold = setTimeout(() => {
          clearTimeout(n.tapHold), n.tapHold = null, n.tap = null, clearTimeout(n.tapDbl), n.tapDbl = null, this.dispatchEvent(e + "TapHold", i, o);
        }, 1e3);
        break;
      case "end":
        n.tap && (n.tap = null, this.dispatchEvent(e + "Tap", i, o)), n.tapDbl ? (clearTimeout(n.tapDbl), n.tapDbl = null, this.dispatchEvent(e + "DblTap", i, o)) : n.tapDbl = setTimeout(() => {
          clearTimeout(n.tapDbl), n.tapDbl = null;
        }, 300), clearTimeout(n.tapHold), n.tapHold = null;
        break;
    }
  }
  dispatchEvent(e, t, i) {
    var o = i.getComponent(), n;
    this.columnSubscribers[e] && (i instanceof _a ? n = i.column.definition[e] : i instanceof Fi && (n = i.definition[e]), n && n(t, o)), this.dispatchExternal(e, t, o);
  }
}
CS.moduleName = "interaction";
var a5 = {
  navPrev: "shift + 9",
  navNext: 9,
  navUp: 38,
  navDown: 40,
  scrollPageUp: 33,
  scrollPageDown: 34,
  scrollToStart: 36,
  scrollToEnd: 35,
  undo: ["ctrl + 90", "meta + 90"],
  redo: ["ctrl + 89", "meta + 89"],
  copyToClipboard: ["ctrl + 67", "meta + 89"]
}, l5 = {
  keyBlock: function(r) {
    r.stopPropagation(), r.preventDefault();
  },
  scrollPageUp: function(r) {
    var e = this.table.rowManager, t = e.scrollTop - e.element.clientHeight;
    r.preventDefault(), e.displayRowsCount && (t >= 0 ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[0])), this.table.element.focus();
  },
  scrollPageDown: function(r) {
    var e = this.table.rowManager, t = e.scrollTop + e.element.clientHeight, i = e.element.scrollHeight;
    r.preventDefault(), e.displayRowsCount && (t <= i ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1])), this.table.element.focus();
  },
  scrollToStart: function(r) {
    var e = this.table.rowManager;
    r.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[0]), this.table.element.focus();
  },
  scrollToEnd: function(r) {
    var e = this.table.rowManager;
    r.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1]), this.table.element.focus();
  },
  navPrev: function(r) {
    this.dispatch("keybinding-nav-prev", r);
  },
  navNext: function(r) {
    this.dispatch("keybinding-nav-next", r);
  },
  navLeft: function(r) {
    this.dispatch("keybinding-nav-left", r);
  },
  navRight: function(r) {
    this.dispatch("keybinding-nav-right", r);
  },
  navUp: function(r) {
    this.dispatch("keybinding-nav-up", r);
  },
  navDown: function(r) {
    this.dispatch("keybinding-nav-down", r);
  },
  undo: function(r) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (r.preventDefault(), this.table.modules.history.undo()));
  },
  redo: function(r) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (r.preventDefault(), this.table.modules.history.redo()));
  },
  copyToClipboard: function(r) {
    this.table.modules.edit.currentCell || this.table.modExists("clipboard", !0) && this.table.modules.clipboard.copy(!1, !0);
  }
};
class Lr extends fe {
  constructor(e) {
    super(e), this.watchKeys = null, this.pressedKeys = null, this.keyupBinding = !1, this.keydownBinding = !1, this.registerTableOption("keybindings", {}), this.registerTableOption("tabEndNewRow", !1);
  }
  initialize() {
    var e = this.table.options.keybindings, t = {};
    this.watchKeys = {}, this.pressedKeys = [], e !== !1 && (Object.assign(t, Lr.bindings), Object.assign(t, e), this.mapBindings(t), this.bindEvents()), this.subscribe("table-destroy", this.clearBindings.bind(this));
  }
  mapBindings(e) {
    for (let t in e)
      Lr.actions[t] ? e[t] && (typeof e[t] != "object" && (e[t] = [e[t]]), e[t].forEach((i) => {
        var o = Array.isArray(i) ? i : [i];
        o.forEach((n) => {
          this.mapBinding(t, n);
        });
      })) : console.warn("Key Binding Error - no such action:", t);
  }
  mapBinding(e, t) {
    var i = {
      action: Lr.actions[e],
      keys: [],
      ctrl: !1,
      shift: !1,
      meta: !1
    }, o = t.toString().toLowerCase().split(" ").join("").split("+");
    o.forEach((n) => {
      switch (n) {
        case "ctrl":
          i.ctrl = !0;
          break;
        case "shift":
          i.shift = !0;
          break;
        case "meta":
          i.meta = !0;
          break;
        default:
          n = isNaN(n) ? n.toUpperCase().charCodeAt(0) : parseInt(n), i.keys.push(n), this.watchKeys[n] || (this.watchKeys[n] = []), this.watchKeys[n].push(i);
      }
    });
  }
  bindEvents() {
    var e = this;
    this.keyupBinding = function(t) {
      var i = t.keyCode, o = e.watchKeys[i];
      o && (e.pressedKeys.push(i), o.forEach(function(n) {
        e.checkBinding(t, n);
      }));
    }, this.keydownBinding = function(t) {
      var i = t.keyCode, o = e.watchKeys[i];
      if (o) {
        var n = e.pressedKeys.indexOf(i);
        n > -1 && e.pressedKeys.splice(n, 1);
      }
    }, this.table.element.addEventListener("keydown", this.keyupBinding), this.table.element.addEventListener("keyup", this.keydownBinding);
  }
  clearBindings() {
    this.keyupBinding && this.table.element.removeEventListener("keydown", this.keyupBinding), this.keydownBinding && this.table.element.removeEventListener("keyup", this.keydownBinding);
  }
  checkBinding(e, t) {
    var i = !0;
    return e.ctrlKey == t.ctrl && e.shiftKey == t.shift && e.metaKey == t.meta ? (t.keys.forEach((o) => {
      var n = this.pressedKeys.indexOf(o);
      n == -1 && (i = !1);
    }), i && t.action.call(this, e), !0) : !1;
  }
}
Lr.moduleName = "keybindings";
Lr.bindings = a5;
Lr.actions = l5;
class QS extends fe {
  constructor(e) {
    super(e), this.menuContainer = null, this.nestedMenuBlock = !1, this.currentComponent = null, this.rootPopup = null, this.columnSubscribers = {}, this.registerTableOption("menuContainer", void 0), this.registerTableOption("rowContextMenu", !1), this.registerTableOption("rowClickMenu", !1), this.registerTableOption("rowDblClickMenu", !1), this.registerTableOption("groupContextMenu", !1), this.registerTableOption("groupClickMenu", !1), this.registerTableOption("groupDblClickMenu", !1), this.registerColumnOption("headerContextMenu"), this.registerColumnOption("headerClickMenu"), this.registerColumnOption("headerDblClickMenu"), this.registerColumnOption("headerMenu"), this.registerColumnOption("headerMenuIcon"), this.registerColumnOption("contextMenu"), this.registerColumnOption("clickMenu"), this.registerColumnOption("dblClickMenu");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("menuContainer", "popupContainer") || (this.table.options.popupContainer = this.table.options.menuContainer);
  }
  initializeRowWatchers() {
    this.table.options.rowContextMenu && (this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu)), this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu))), this.table.options.rowClickMenu && this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu)), this.table.options.rowDblClickMenu && this.subscribe("row-dblclick", this.loadMenuEvent.bind(this, this.table.options.rowDblClickMenu));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextMenu && (this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu)), this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu))), this.table.options.groupClickMenu && this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu)), this.table.options.groupDblClickMenu && this.subscribe("group-dblclick", this.loadMenuEvent.bind(this, this.table.options.groupDblClickMenu));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextMenu && !this.columnSubscribers.headerContextMenu && (this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu), this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"))), t.headerClickMenu && !this.columnSubscribers.headerClickMenu && (this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu"), this.subscribe("column-click", this.columnSubscribers.headerClickMenu)), t.headerDblClickMenu && !this.columnSubscribers.headerDblClickMenu && (this.columnSubscribers.headerDblClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerDblClickMenu"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickMenu)), t.headerMenu && this.initializeColumnHeaderMenu(e), t.contextMenu && !this.columnSubscribers.contextMenu && (this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu), this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"))), t.clickMenu && !this.columnSubscribers.clickMenu && (this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu"), this.subscribe("cell-click", this.columnSubscribers.clickMenu)), t.dblClickMenu && !this.columnSubscribers.dblClickMenu && (this.columnSubscribers.dblClickMenu = this.loadMenuTableCellEvent.bind(this, "dblClickMenu"), this.subscribe("cell-dblclick", this.columnSubscribers.dblClickMenu));
  }
  initializeColumnHeaderMenu(e) {
    var t = e.definition.headerMenuIcon, i;
    i = document.createElement("span"), i.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? i.appendChild(t) : i.innerHTML = t) : i.innerHTML = "&vellip;", i.addEventListener("click", (o) => {
      o.stopPropagation(), o.preventDefault(), this.loadMenuEvent(e.definition.headerMenu, o, e);
    }), e.titleElement.insertBefore(i, e.titleElement.firstChild);
  }
  loadMenuTableCellEvent(e, t, i) {
    i._cell && (i = i._cell), i.column.definition[e] && this.loadMenuEvent(i.column.definition[e], t, i);
  }
  loadMenuTableColumnEvent(e, t, i) {
    i._column && (i = i._column), i.definition[e] && this.loadMenuEvent(i.definition[e], t, i);
  }
  loadMenuEvent(e, t, i) {
    i._group ? i = i._group : i._row && (i = i._row), e = typeof e == "function" ? e.call(this.table, t, i.getComponent()) : e, this.loadMenu(t, i, e);
  }
  loadMenu(e, t, i, o, n) {
    var s = !(e instanceof MouseEvent), a = document.createElement("div"), l;
    if (a.classList.add("tabulator-menu"), s || e.preventDefault(), !(!i || !i.length)) {
      if (o)
        l = n.child(a);
      else {
        if (this.nestedMenuBlock) {
          if (this.rootPopup)
            return;
        } else
          this.nestedMenuBlock = setTimeout(() => {
            this.nestedMenuBlock = !1;
          }, 100);
        this.rootPopup && this.rootPopup.hide(), this.rootPopup = l = this.popup(a);
      }
      i.forEach((u) => {
        var h = document.createElement("div"), c = u.label, d = u.disabled;
        u.separator ? h.classList.add("tabulator-menu-separator") : (h.classList.add("tabulator-menu-item"), typeof c == "function" && (c = c.call(this.table, t.getComponent())), c instanceof Node ? h.appendChild(c) : h.innerHTML = c, typeof d == "function" && (d = d.call(this.table, t.getComponent())), d ? (h.classList.add("tabulator-menu-item-disabled"), h.addEventListener("click", (f) => {
          f.stopPropagation();
        })) : u.menu && u.menu.length ? h.addEventListener("click", (f) => {
          f.stopPropagation(), this.loadMenu(f, t, u.menu, h, l);
        }) : u.action && h.addEventListener("click", (f) => {
          u.action(f, t.getComponent());
        }), u.menu && u.menu.length && h.classList.add("tabulator-menu-item-submenu")), a.appendChild(h);
      }), a.addEventListener("click", (u) => {
        this.rootPopup && this.rootPopup.hide();
      }), l.show(o || e), l === this.rootPopup && (this.rootPopup.hideOnBlur(() => {
        this.rootPopup = null, this.currentComponent && (this.dispatchExternal("menuClosed", this.currentComponent.getComponent()), this.currentComponent = null);
      }), this.currentComponent = t, this.dispatchExternal("menuOpened", t.getComponent()));
    }
  }
}
QS.moduleName = "menu";
class rg extends fe {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 250, this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.startX = 0, this.autoScrollMargin = 40, this.autoScrollStep = 5, this.autoScrollTimeout = !1, this.touchMove = !1, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.registerTableOption("movableColumns", !1);
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col"), e.classList.add("tabulator-col-placeholder"), e;
  }
  initialize() {
    this.table.options.movableColumns && this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  initializeColumn(e) {
    var t = this, i = {}, o;
    !e.modules.frozen && !e.isGroup && (o = e.getElement(), i.mousemove = function(n) {
      e.parent === t.moving.parent && ((t.touchMove ? n.touches[0].pageX : n.pageX) - _e.elOffset(o).left + t.table.columnManager.contentsElement.scrollLeft > e.getWidth() / 2 ? (t.toCol !== e || !t.toColAfter) && (o.parentNode.insertBefore(t.placeholderElement, o.nextSibling), t.moveColumn(e, !0)) : (t.toCol !== e || t.toColAfter) && (o.parentNode.insertBefore(t.placeholderElement, o), t.moveColumn(e, !1)));
    }.bind(t), o.addEventListener("mousedown", function(n) {
      t.touchMove = !1, n.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(n, e);
      }, t.checkPeriod));
    }), o.addEventListener("mouseup", function(n) {
      n.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), t.bindTouchEvents(e)), e.modules.moveColumn = i;
  }
  bindTouchEvents(e) {
    var t = e.getElement(), i = !1, o, n, s, a, l, u;
    t.addEventListener("touchstart", (h) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, o = e.nextColumn(), s = o ? o.getWidth() / 2 : 0, n = e.prevColumn(), a = n ? n.getWidth() / 2 : 0, l = 0, u = 0, i = !1, this.startMove(h, e);
      }, this.checkPeriod);
    }, { passive: !0 }), t.addEventListener("touchmove", (h) => {
      var c, d;
      this.moving && (this.moveHover(h), i || (i = h.touches[0].pageX), c = h.touches[0].pageX - i, c > 0 ? o && c - l > s && (d = o, d !== e && (i = h.touches[0].pageX, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement().nextSibling), this.moveColumn(d, !0))) : n && -c - u > a && (d = n, d !== e && (i = h.touches[0].pageX, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement()), this.moveColumn(d, !1))), d && (o = d.nextColumn(), l = s, s = o ? o.getWidth() / 2 : 0, n = d.prevColumn(), u = a, a = n ? n.getWidth() / 2 : 0));
    }, { passive: !0 }), t.addEventListener("touchend", (h) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && this.endMove(h);
    });
  }
  startMove(e, t) {
    var i = t.getElement(), o = this.table.columnManager.getContentsElement(), n = this.table.columnManager.getHeadersElement();
    this.moving = t, this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - _e.elOffset(i).left, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", i.parentNode.insertBefore(this.placeholderElement, i), i.parentNode.removeChild(i), this.hoverElement = i.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), o.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.bottom = o.clientHeight - n.offsetHeight + "px", this.touchMove || (this._bindMouseMove(), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove)), this.moveHover(e);
  }
  _bindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  moveColumn(e, t) {
    var i = this.moving.getCells();
    this.toCol = e, this.toColAfter = t, t ? e.getCells().forEach(function(o, n) {
      var s = o.getElement(!0);
      s.parentNode && i[n] && s.parentNode.insertBefore(i[n].getElement(), s.nextSibling);
    }) : e.getCells().forEach(function(o, n) {
      var s = o.getElement(!0);
      s.parentNode && i[n] && s.parentNode.insertBefore(i[n].getElement(), s);
    });
  }
  endMove(e) {
    (e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toCol && this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter), this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.touchMove || (document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove)));
  }
  moveHover(e) {
    var t = this.table.columnManager.getContentsElement(), i = t.scrollLeft, o = (this.touchMove ? e.touches[0].pageX : e.pageX) - _e.elOffset(t).left + i, n;
    this.hoverElement.style.left = o - this.startX + "px", o - i < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      n = Math.max(0, i - 5), this.table.rowManager.getElement().scrollLeft = n, this.autoScrollTimeout = !1;
    }, 1))), i + t.clientWidth - o < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      n = Math.min(t.clientWidth, i + 5), this.table.rowManager.getElement().scrollLeft = n, this.autoScrollTimeout = !1;
    }, 1)));
  }
}
rg.moduleName = "moveColumn";
class Th extends fe {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 150, this.moving = !1, this.toRow = !1, this.toRowAfter = !1, this.hasHandle = !1, this.startY = 0, this.startX = 0, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.tableRowDropEvent = !1, this.touchMove = !1, this.connection = !1, this.connectionSelectorsTables = !1, this.connectionSelectorsElements = !1, this.connectionElements = [], this.connections = [], this.connectedTable = !1, this.connectedRow = !1, this.registerTableOption("movableRows", !1), this.registerTableOption("movableRowsConnectedTables", !1), this.registerTableOption("movableRowsConnectedElements", !1), this.registerTableOption("movableRowsSender", !1), this.registerTableOption("movableRowsReceiver", "insert"), this.registerColumnOption("rowHandle");
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-row"), e.classList.add("tabulator-row-placeholder"), e;
  }
  initialize() {
    this.table.options.movableRows && (this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables, this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements, this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements, this.subscribe("cell-init", this.initializeCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)));
  }
  initializeGroupHeader(e) {
    var t = this, i = {};
    i.mouseup = function(o) {
      t.tableRowDrop(o, e);
    }.bind(t), i.mousemove = function(o) {
      var n;
      o.pageY - _e.elOffset(e.element).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (n = e.getElement(), n.parentNode.insertBefore(t.placeholderElement, n.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (n = e.getElement(), n.previousSibling && (n.parentNode.insertBefore(t.placeholderElement, n), t.moveRow(e, !1)));
    }.bind(t), e.modules.moveRow = i;
  }
  initializeRow(e) {
    var t = this, i = {}, o;
    i.mouseup = function(n) {
      t.tableRowDrop(n, e);
    }.bind(t), i.mousemove = function(n) {
      var s = e.getElement();
      n.pageY - _e.elOffset(s).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (s.parentNode.insertBefore(t.placeholderElement, s.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (s.parentNode.insertBefore(t.placeholderElement, s), t.moveRow(e, !1));
    }.bind(t), this.hasHandle || (o = e.getElement(), o.addEventListener("mousedown", function(n) {
      n.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(n, e);
      }, t.checkPeriod));
    }), o.addEventListener("mouseup", function(n) {
      n.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), this.bindTouchEvents(e, e.getElement())), e.modules.moveRow = i;
  }
  initializeColumn(e) {
    e.definition.rowHandle && this.table.options.movableRows !== !1 && (this.hasHandle = !0);
  }
  initializeCell(e) {
    if (e.column.definition.rowHandle && this.table.options.movableRows !== !1) {
      var t = this, i = e.getElement(!0);
      i.addEventListener("mousedown", function(o) {
        o.which === 1 && (t.checkTimeout = setTimeout(function() {
          t.startMove(o, e.row);
        }, t.checkPeriod));
      }), i.addEventListener("mouseup", function(o) {
        o.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
      }), this.bindTouchEvents(e.row, i);
    }
  }
  bindTouchEvents(e, t) {
    var i = !1, o, n, s, a, l, u;
    t.addEventListener("touchstart", (h) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, o = e.nextRow(), s = o ? o.getHeight() / 2 : 0, n = e.prevRow(), a = n ? n.getHeight() / 2 : 0, l = 0, u = 0, i = !1, this.startMove(h, e);
      }, this.checkPeriod);
    }, { passive: !0 }), this.moving, this.toRow, this.toRowAfter, t.addEventListener("touchmove", (h) => {
      var c, d;
      this.moving && (h.preventDefault(), this.moveHover(h), i || (i = h.touches[0].pageY), c = h.touches[0].pageY - i, c > 0 ? o && c - l > s && (d = o, d !== e && (i = h.touches[0].pageY, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement().nextSibling), this.moveRow(d, !0))) : n && -c - u > a && (d = n, d !== e && (i = h.touches[0].pageY, d.getElement().parentNode.insertBefore(this.placeholderElement, d.getElement()), this.moveRow(d, !1))), d && (o = d.nextRow(), l = s, s = o ? o.getHeight() / 2 : 0, n = d.prevRow(), u = a, a = n ? n.getHeight() / 2 : 0));
    }), t.addEventListener("touchend", (h) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && (this.endMove(h), this.touchMove = !1);
    });
  }
  _bindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  startMove(e, t) {
    var i = t.getElement();
    this.setStartPosition(e, t), this.moving = t, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", this.connection ? (this.table.element.classList.add("tabulator-movingrow-sending"), this.connectToTables(t)) : (i.parentNode.insertBefore(this.placeholderElement, i), i.parentNode.removeChild(i)), this.hoverElement = i.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), this.connection ? (document.body.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this.hoverElement.style.width = this.table.element.clientWidth + "px", this.hoverElement.style.whiteSpace = "nowrap", this.hoverElement.style.overflow = "hidden", this.hoverElement.style.pointerEvents = "none") : (this.table.rowManager.getTableElement().appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this._bindMouseMove()), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove), this.dispatchExternal("rowMoving", t.getComponent()), this.moveHover(e);
  }
  setStartPosition(e, t) {
    var i = this.touchMove ? e.touches[0].pageX : e.pageX, o = this.touchMove ? e.touches[0].pageY : e.pageY, n, s;
    n = t.getElement(), this.connection ? (s = n.getBoundingClientRect(), this.startX = s.left - i + window.pageXOffset, this.startY = s.top - o + window.pageYOffset) : this.startY = o - n.getBoundingClientRect().top;
  }
  endMove(e) {
    (!e || e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.connection || (this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement)), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toRow ? this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter) : this.dispatchExternal("rowMoveCancelled", this.moving.getComponent()), this.moving = !1, this.toRow = !1, this.toRowAfter = !1, document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove), this.connection && (this.table.element.classList.remove("tabulator-movingrow-sending"), this.disconnectFromTables()));
  }
  moveRow(e, t) {
    this.toRow = e, this.toRowAfter = t;
  }
  moveHover(e) {
    this.connection ? this.moveHoverConnections.call(this, e) : this.moveHoverTable.call(this, e);
  }
  moveHoverTable(e) {
    var t = this.table.rowManager.getElement(), i = t.scrollTop, o = (this.touchMove ? e.touches[0].pageY : e.pageY) - t.getBoundingClientRect().top + i;
    this.hoverElement.style.top = Math.min(o - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
  }
  moveHoverConnections(e) {
    this.hoverElement.style.left = this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX) + "px", this.hoverElement.style.top = this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY) + "px";
  }
  elementRowDrop(e, t, i) {
    this.dispatchExternal("movableRowsElementDrop", e, t, i ? i.getComponent() : !1);
  }
  //establish connection with other tables
  connectToTables(e) {
    var t;
    this.connectionSelectorsTables && (t = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStart", t), this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
      row: e
    })), this.connectionSelectorsElements && (this.connectionElements = [], Array.isArray(this.connectionSelectorsElements) || (this.connectionSelectorsElements = [this.connectionSelectorsElements]), this.connectionSelectorsElements.forEach((i) => {
      typeof i == "string" ? this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(i))) : this.connectionElements.push(i);
    }), this.connectionElements.forEach((i) => {
      var o = (n) => {
        this.elementRowDrop(n, i, this.moving);
      };
      i.addEventListener("mouseup", o), i.tabulatorElementDropEvent = o, i.classList.add("tabulator-movingrow-receiving");
    }));
  }
  //disconnect from other tables
  disconnectFromTables() {
    var e;
    this.connectionSelectorsTables && (e = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStop", e), this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect")), this.connectionElements.forEach((t) => {
      t.classList.remove("tabulator-movingrow-receiving"), t.removeEventListener("mouseup", t.tabulatorElementDropEvent), delete t.tabulatorElementDropEvent;
    });
  }
  //accept incomming connection
  connect(e, t) {
    return this.connectedTable ? (console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable), !1) : (this.connectedTable = e, this.connectedRow = t, this.table.element.classList.add("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((i) => {
      i.type === "row" && i.modules.moveRow && i.modules.moveRow.mouseup && i.getElement().addEventListener("mouseup", i.modules.moveRow.mouseup);
    }), this.tableRowDropEvent = this.tableRowDrop.bind(this), this.table.element.addEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStart", t, e), !0);
  }
  //close incoming connection
  disconnect(e) {
    e === this.connectedTable ? (this.connectedTable = !1, this.connectedRow = !1, this.table.element.classList.remove("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((t) => {
      t.type === "row" && t.modules.moveRow && t.modules.moveRow.mouseup && t.getElement().removeEventListener("mouseup", t.modules.moveRow.mouseup);
    }), this.table.element.removeEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStop", e)) : console.warn("Move Row Error - trying to disconnect from non connected table");
  }
  dropComplete(e, t, i) {
    var o = !1;
    if (i) {
      switch (typeof this.table.options.movableRowsSender) {
        case "string":
          o = this.senders[this.table.options.movableRowsSender];
          break;
        case "function":
          o = this.table.options.movableRowsSender;
          break;
      }
      o ? o.call(this, this.moving ? this.moving.getComponent() : void 0, t ? t.getComponent() : void 0, e) : this.table.options.movableRowsSender && console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender), this.dispatchExternal("movableRowsSent", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    } else
      this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    this.endMove();
  }
  tableRowDrop(e, t) {
    var i = !1, o = !1;
    switch (e.stopImmediatePropagation(), typeof this.table.options.movableRowsReceiver) {
      case "string":
        i = this.receivers[this.table.options.movableRowsReceiver];
        break;
      case "function":
        i = this.table.options.movableRowsReceiver;
        break;
    }
    i ? o = i.call(this, this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver), o ? this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable), this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
      row: t,
      success: o
    });
  }
  commsReceived(e, t, i) {
    switch (t) {
      case "connect":
        return this.connect(e, i.row);
      case "disconnect":
        return this.disconnect(e);
      case "dropcomplete":
        return this.dropComplete(e, i.row, i.success);
    }
  }
}
Th.prototype.receivers = {
  insert: function(r, e, t) {
    return this.table.addRow(r.getData(), void 0, e), !0;
  },
  add: function(r, e, t) {
    return this.table.addRow(r.getData()), !0;
  },
  update: function(r, e, t) {
    return e ? (e.update(r.getData()), !0) : !1;
  },
  replace: function(r, e, t) {
    return e ? (this.table.addRow(r.getData(), void 0, e), e.delete(), !0) : !1;
  }
};
Th.prototype.senders = {
  delete: function(r, e, t) {
    r.delete();
  }
};
Th.moduleName = "moveRow";
var u5 = {};
class Wn extends fe {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "edit", "clipboard"], this.enabled = !0, this.registerColumnOption("mutator"), this.registerColumnOption("mutatorParams"), this.registerColumnOption("mutatorData"), this.registerColumnOption("mutatorDataParams"), this.registerColumnOption("mutatorEdit"), this.registerColumnOption("mutatorEditParams"), this.registerColumnOption("mutatorClipboard"), this.registerColumnOption("mutatorClipboardParams"), this.registerColumnOption("mutateLink");
  }
  initialize() {
    this.subscribe("cell-value-changing", this.transformCell.bind(this)), this.subscribe("cell-value-changed", this.mutateLink.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-init-before", this.rowDataChanged.bind(this)), this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
  }
  rowDataChanged(e, t, i) {
    return this.transformRow(t, "data", i);
  }
  //initialize column mutator
  initializeColumn(e) {
    var t = !1, i = {};
    this.allowedTypes.forEach((o) => {
      var n = "mutator" + (o.charAt(0).toUpperCase() + o.slice(1)), s;
      e.definition[n] && (s = this.lookupMutator(e.definition[n]), s && (t = !0, i[n] = {
        mutator: s,
        params: e.definition[n + "Params"] || {}
      }));
    }), t && (e.modules.mutate = i);
  }
  lookupMutator(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        Wn.mutators[e] ? t = Wn.mutators[e] : console.warn("Mutator Error - No such mutator found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply mutator to row
  transformRow(e, t, i) {
    var o = "mutator" + (t.charAt(0).toUpperCase() + t.slice(1)), n;
    return this.enabled && this.table.columnManager.traverse((s) => {
      var a, l, u;
      s.modules.mutate && (a = s.modules.mutate[o] || s.modules.mutate.mutator || !1, a && (n = s.getFieldValue(typeof i < "u" ? i : e), (t == "data" && !i || typeof n < "u") && (u = s.getComponent(), l = typeof a.params == "function" ? a.params(n, e, t, u) : a.params, s.setFieldValue(e, a.mutator(n, e, t, l, u)))));
    }), e;
  }
  //apply mutator to new cell value
  transformCell(e, t) {
    if (e.column.modules.mutate) {
      var i = e.column.modules.mutate.mutatorEdit || e.column.modules.mutate.mutator || !1, o = {};
      if (i)
        return o = Object.assign(o, e.row.getData()), e.column.setFieldValue(o, t), i.mutator(t, o, "edit", i.params, e.getComponent());
    }
    return t;
  }
  mutateLink(e) {
    var t = e.column.definition.mutateLink;
    t && (Array.isArray(t) || (t = [t]), t.forEach((i) => {
      var o = e.row.getCell(i);
      o && o.setValue(o.getValue(), !0, !0);
    }));
  }
  enable() {
    this.enabled = !0;
  }
  disable() {
    this.enabled = !1;
  }
}
Wn.moduleName = "mutator";
Wn.mutators = u5;
function h5(r, e, t, i, o) {
  var n = document.createElement("span"), s = document.createElement("span"), a = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), h = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (c) => {
    s.innerHTML = c;
  }), this.table.modules.localize.langBind("pagination|counter|of", (c) => {
    l.innerHTML = c;
  }), this.table.modules.localize.langBind("pagination|counter|rows", (c) => {
    h.innerHTML = c;
  }), i ? (a.innerHTML = " " + e + "-" + Math.min(e + r - 1, i) + " ", u.innerHTML = " " + i + " ", n.appendChild(s), n.appendChild(a), n.appendChild(l), n.appendChild(u), n.appendChild(h)) : (a.innerHTML = " 0 ", n.appendChild(s), n.appendChild(a), n.appendChild(h)), n;
}
function c5(r, e, t, i, o) {
  var n = document.createElement("span"), s = document.createElement("span"), a = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), h = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (c) => {
    s.innerHTML = c;
  }), a.innerHTML = " " + t + " ", this.table.modules.localize.langBind("pagination|counter|of", (c) => {
    l.innerHTML = c;
  }), u.innerHTML = " " + o + " ", this.table.modules.localize.langBind("pagination|counter|pages", (c) => {
    h.innerHTML = c;
  }), n.appendChild(s), n.appendChild(a), n.appendChild(l), n.appendChild(u), n.appendChild(h), n;
}
var d5 = {
  rows: h5,
  pages: c5
};
class Ma extends fe {
  constructor(e) {
    super(e), this.mode = "local", this.progressiveLoad = !1, this.element = null, this.pageCounterElement = null, this.pageCounter = null, this.size = 0, this.page = 1, this.count = 5, this.max = 1, this.remoteRowCountEstimate = null, this.initialLoad = !0, this.dataChanging = !1, this.pageSizes = [], this.registerTableOption("pagination", !1), this.registerTableOption("paginationMode", "local"), this.registerTableOption("paginationSize", !1), this.registerTableOption("paginationInitialPage", 1), this.registerTableOption("paginationCounter", !1), this.registerTableOption("paginationCounterElement", !1), this.registerTableOption("paginationButtonCount", 5), this.registerTableOption("paginationSizeSelector", !1), this.registerTableOption("paginationElement", !1), this.registerTableOption("paginationAddRow", "page"), this.registerTableOption("progressiveLoad", !1), this.registerTableOption("progressiveLoadDelay", 0), this.registerTableOption("progressiveLoadScrollMargin", 0), this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this)), this.registerTableFunction("setPage", this.setPage.bind(this)), this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this)), this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this)), this.registerTableFunction("getPageSize", this.getPageSize.bind(this)), this.registerTableFunction("previousPage", this.previousPage.bind(this)), this.registerTableFunction("nextPage", this.nextPage.bind(this)), this.registerTableFunction("getPage", this.getPage.bind(this)), this.registerTableFunction("getPageMax", this.getPageMax.bind(this)), this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
  }
  initialize() {
    this.table.options.pagination ? (this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("footer-redraw", this.footerRedraw.bind(this)), this.table.options.paginationAddRow == "page" && this.subscribe("row-adding-position", this.rowAddingPosition.bind(this)), this.table.options.paginationMode === "remote" && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this))), this.table.options.progressiveLoad && console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time"), this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40), this.registerDisplayHandler(this.getRows.bind(this), 50), this.createElements(), this.initializePageCounter(), this.initializePaginator()) : this.table.options.progressiveLoad && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.initializeProgressive(this.table.options.progressiveLoad), this.table.options.progressiveLoad === "scroll" && this.subscribe("scroll-vertical", this.scrollVertical.bind(this)));
  }
  rowAddingPosition(e, t) {
    var i = this.table.rowManager, o = i.getDisplayRows(), n;
    return t ? o.length ? n = o[0] : i.activeRows.length && (n = i.activeRows[i.activeRows.length - 1], t = !1) : o.length && (n = o[o.length - 1], t = !(o.length < this.size)), { index: n, top: t };
  }
  calculatePageSizes() {
    var e, t;
    this.table.options.paginationSize ? this.size = this.table.options.paginationSize : (e = document.createElement("div"), e.classList.add("tabulator-row"), e.style.visibility = "hidden", t = document.createElement("div"), t.classList.add("tabulator-cell"), t.innerHTML = "Page Row Test", e.appendChild(t), this.table.rowManager.getTableElement().appendChild(e), this.size = Math.floor(this.table.rowManager.getElement().clientHeight / e.offsetHeight), this.table.rowManager.getTableElement().removeChild(e)), this.dispatchExternal("pageSizeChanged", this.size), this.generatePageSizeSelectList();
  }
  initialLoadComplete() {
    this.initialLoad = !1;
  }
  remotePageParams(e, t, i, o) {
    return this.initialLoad || (this.progressiveLoad && !i || !this.progressiveLoad && !this.dataChanging) && this.reset(!0), o.page = this.page, this.size && (o.size = this.size), o;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetPageToRow(e) {
    return this.table.options.pagination && (e = this.rowManager.findRow(e), e) ? this.setPageToRow(e) : Promise.reject();
  }
  userSetPageSize(e) {
    return this.table.options.pagination ? (this.setPageSize(e), this.setPage(1)) : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  scrollVertical(e, t) {
    var i, o, n;
    !t && !this.table.dataLoader.loading && (i = this.table.rowManager.getElement(), o = i.scrollHeight - i.clientHeight - e, n = this.table.options.progressiveLoadScrollMargin || i.clientHeight * 2, o < n && this.nextPage().catch(() => {
    }));
  }
  restOnRenderBefore(e, t) {
    return t || this.mode === "local" && this.reset(), e;
  }
  rowsUpdated() {
    this.refreshData(!0, "all");
  }
  createElements() {
    var e;
    this.element = document.createElement("span"), this.element.classList.add("tabulator-paginator"), this.pagesElement = document.createElement("span"), this.pagesElement.classList.add("tabulator-pages"), e = document.createElement("button"), e.classList.add("tabulator-page"), e.setAttribute("type", "button"), e.setAttribute("role", "button"), e.setAttribute("aria-label", ""), e.setAttribute("title", ""), this.firstBut = e.cloneNode(!0), this.firstBut.setAttribute("data-page", "first"), this.prevBut = e.cloneNode(!0), this.prevBut.setAttribute("data-page", "prev"), this.nextBut = e.cloneNode(!0), this.nextBut.setAttribute("data-page", "next"), this.lastBut = e.cloneNode(!0), this.lastBut.setAttribute("data-page", "last"), this.table.options.paginationSizeSelector && (this.pageSizeSelect = document.createElement("select"), this.pageSizeSelect.classList.add("tabulator-page-size"));
  }
  generatePageSizeSelectList() {
    var e = [];
    if (this.pageSizeSelect) {
      if (Array.isArray(this.table.options.paginationSizeSelector))
        e = this.table.options.paginationSizeSelector, this.pageSizes = e, this.pageSizes.indexOf(this.size) == -1 && e.unshift(this.size);
      else if (this.pageSizes.indexOf(this.size) == -1) {
        e = [];
        for (let t = 1; t < 5; t++)
          e.push(this.size * t);
        this.pageSizes = e;
      } else
        e = this.pageSizes;
      for (; this.pageSizeSelect.firstChild; )
        this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
      e.forEach((t) => {
        var i = document.createElement("option");
        i.value = t, t === !0 ? this.langBind("pagination|all", function(o) {
          i.innerHTML = o;
        }) : i.innerHTML = t, this.pageSizeSelect.appendChild(i);
      }), this.pageSizeSelect.value = this.size;
    }
  }
  initializePageCounter() {
    var e = this.table.options.paginationCounter, t = null;
    e && (typeof e == "function" ? t = e : t = Ma.pageCounters[e], t ? (this.pageCounter = t, this.pageCounterElement = document.createElement("span"), this.pageCounterElement.classList.add("tabulator-page-counter")) : console.warn("Pagination Error - No such page counter found: ", e));
  }
  //setup pagination
  initializePaginator(e) {
    var t, i;
    e || (this.langBind("pagination|first", (o) => {
      this.firstBut.innerHTML = o;
    }), this.langBind("pagination|first_title", (o) => {
      this.firstBut.setAttribute("aria-label", o), this.firstBut.setAttribute("title", o);
    }), this.langBind("pagination|prev", (o) => {
      this.prevBut.innerHTML = o;
    }), this.langBind("pagination|prev_title", (o) => {
      this.prevBut.setAttribute("aria-label", o), this.prevBut.setAttribute("title", o);
    }), this.langBind("pagination|next", (o) => {
      this.nextBut.innerHTML = o;
    }), this.langBind("pagination|next_title", (o) => {
      this.nextBut.setAttribute("aria-label", o), this.nextBut.setAttribute("title", o);
    }), this.langBind("pagination|last", (o) => {
      this.lastBut.innerHTML = o;
    }), this.langBind("pagination|last_title", (o) => {
      this.lastBut.setAttribute("aria-label", o), this.lastBut.setAttribute("title", o);
    }), this.firstBut.addEventListener("click", () => {
      this.setPage(1);
    }), this.prevBut.addEventListener("click", () => {
      this.previousPage();
    }), this.nextBut.addEventListener("click", () => {
      this.nextPage();
    }), this.lastBut.addEventListener("click", () => {
      this.setPage(this.max);
    }), this.table.options.paginationElement && (this.element = this.table.options.paginationElement), this.pageSizeSelect && (t = document.createElement("label"), this.langBind("pagination|page_size", (o) => {
      this.pageSizeSelect.setAttribute("aria-label", o), this.pageSizeSelect.setAttribute("title", o), t.innerHTML = o;
    }), this.element.appendChild(t), this.element.appendChild(this.pageSizeSelect), this.pageSizeSelect.addEventListener("change", (o) => {
      this.setPageSize(this.pageSizeSelect.value == "true" ? !0 : this.pageSizeSelect.value), this.setPage(1);
    })), this.element.appendChild(this.firstBut), this.element.appendChild(this.prevBut), this.element.appendChild(this.pagesElement), this.element.appendChild(this.nextBut), this.element.appendChild(this.lastBut), this.table.options.paginationElement || (this.table.options.paginationCounter && (this.table.options.paginationCounterElement ? this.table.options.paginationCounterElement instanceof HTMLElement ? this.table.options.paginationCounterElement.appendChild(this.pageCounterElement) : typeof this.table.options.paginationCounterElement == "string" && (i = document.querySelector(this.table.options.paginationCounterElement), i ? i.appendChild(this.pageCounterElement) : console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement)) : this.footerAppend(this.pageCounterElement)), this.footerAppend(this.element)), this.page = this.table.options.paginationInitialPage, this.count = this.table.options.paginationButtonCount), this.mode = this.table.options.paginationMode;
  }
  initializeProgressive(e) {
    this.initializePaginator(!0), this.mode = "progressive_" + e, this.progressiveLoad = !0;
  }
  trackChanges() {
    this.dispatch("page-changed");
  }
  //calculate maximum page from number of rows
  setMaxRows(e) {
    e ? this.max = this.size === !0 ? 1 : Math.ceil(e / this.size) : this.max = 1, this.page > this.max && (this.page = this.max);
  }
  //reset to first page without triggering action
  reset(e) {
    this.initialLoad || (this.mode == "local" || e) && (this.page = 1, this.trackChanges());
  }
  //set the maximum page
  setMaxPage(e) {
    e = parseInt(e), this.max = e || 1, this.page > this.max && (this.page = this.max, this.trigger());
  }
  //set current page number
  setPage(e) {
    switch (e) {
      case "first":
        return this.setPage(1);
      case "prev":
        return this.previousPage();
      case "next":
        return this.nextPage();
      case "last":
        return this.setPage(this.max);
    }
    return e = parseInt(e), e > 0 && e <= this.max || this.mode !== "local" ? (this.page = e, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", e), Promise.reject());
  }
  setPageToRow(e) {
    var t = this.displayRows(-1), i = t.indexOf(e);
    if (i > -1) {
      var o = this.size === !0 ? 1 : Math.ceil((i + 1) / this.size);
      return this.setPage(o);
    } else
      return console.warn("Pagination Error - Requested row is not visible"), Promise.reject();
  }
  setPageSize(e) {
    e !== !0 && (e = parseInt(e)), e > 0 && (this.size = e, this.dispatchExternal("pageSizeChanged", e)), this.pageSizeSelect && this.generatePageSizeSelectList(), this.trackChanges();
  }
  _setPageCounter(e, t, i) {
    var o;
    if (this.pageCounter)
      switch (this.mode === "remote" && (t = this.size, i = (this.page - 1) * this.size + 1, e = this.remoteRowCountEstimate), o = this.pageCounter.call(this, t, i, this.page, e, this.max), typeof o) {
        case "object":
          if (o instanceof Node) {
            for (; this.pageCounterElement.firstChild; )
              this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);
            this.pageCounterElement.appendChild(o);
          } else
            this.pageCounterElement.innerHTML = "", o != null && console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", o);
          break;
        case "undefined":
          this.pageCounterElement.innerHTML = "";
          break;
        default:
          this.pageCounterElement.innerHTML = o;
      }
  }
  //setup the pagination buttons
  _setPageButtons() {
    let e = Math.floor((this.count - 1) / 2), t = Math.ceil((this.count - 1) / 2), i = this.max - this.page + e + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - e, 1), o = this.page <= t ? Math.min(this.count, this.max) : Math.min(this.page + t, this.max);
    for (; this.pagesElement.firstChild; )
      this.pagesElement.removeChild(this.pagesElement.firstChild);
    this.page == 1 ? (this.firstBut.disabled = !0, this.prevBut.disabled = !0) : (this.firstBut.disabled = !1, this.prevBut.disabled = !1), this.page == this.max ? (this.lastBut.disabled = !0, this.nextBut.disabled = !0) : (this.lastBut.disabled = !1, this.nextBut.disabled = !1);
    for (let n = i; n <= o; n++)
      n > 0 && n <= this.max && this.pagesElement.appendChild(this._generatePageButton(n));
    this.footerRedraw();
  }
  _generatePageButton(e) {
    var t = document.createElement("button");
    return t.classList.add("tabulator-page"), e == this.page && t.classList.add("active"), t.setAttribute("type", "button"), t.setAttribute("role", "button"), this.langBind("pagination|page_title", (i) => {
      t.setAttribute("aria-label", i + " " + e), t.setAttribute("title", i + " " + e);
    }), t.setAttribute("data-page", e), t.textContent = e, t.addEventListener("click", (i) => {
      this.setPage(e);
    }), t;
  }
  //previous page
  previousPage() {
    return this.page > 1 ? (this.page--, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Previous page would be less than page 1:", 0), Promise.reject());
  }
  //next page
  nextPage() {
    return this.page < this.max ? (this.page++, this.trackChanges(), this.trigger()) : (this.progressiveLoad || console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1), Promise.reject());
  }
  //return current page number
  getPage() {
    return this.page;
  }
  //return max page number
  getPageMax() {
    return this.max;
  }
  getPageSize(e) {
    return this.size;
  }
  getMode() {
    return this.mode;
  }
  //return appropriate rows for current page
  getRows(e) {
    var t = 0, i, o, n, s, a = e.filter((l) => l.type === "row");
    if (this.mode == "local") {
      i = [], this.setMaxRows(e.length), this.size === !0 ? (o = 0, n = e.length) : (o = this.size * (this.page - 1), n = o + parseInt(this.size)), this._setPageButtons();
      for (let l = o; l < n; l++) {
        let u = e[l];
        u && (i.push(u), u.type === "row" && (s || (s = u), t++));
      }
      return this._setPageCounter(a.length, t, s ? a.indexOf(s) + 1 : 0), i;
    } else
      return this._setPageButtons(), this._setPageCounter(a.length), e.slice(0);
  }
  trigger() {
    var e;
    switch (this.mode) {
      case "local":
        return e = this.table.rowManager.scrollLeft, this.refreshData(), this.table.rowManager.scrollHorizontal(e), this.dispatchExternal("pageLoaded", this.getPage()), Promise.resolve();
      case "remote":
        return this.dataChanging = !0, this.reloadData(null).finally(() => {
          this.dataChanging = !1;
        });
      case "progressive_load":
      case "progressive_scroll":
        return this.reloadData(null, !0);
      default:
        return console.warn("Pagination Error - no such pagination mode:", this.mode), Promise.reject();
    }
  }
  _parseRemoteData(e) {
    var t;
    if (typeof e.last_page > "u" && console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property"), e.data)
      if (this.max = parseInt(e.last_page) || 1, this.remoteRowCountEstimate = typeof e.last_row < "u" ? e.last_row : e.last_page * this.size - (this.page == e.last_page ? this.size - e.data.length : 0), this.progressiveLoad) {
        switch (this.mode) {
          case "progressive_load":
            this.page == 1 ? this.table.rowManager.setData(e.data, !1, this.page == 1) : this.table.rowManager.addRows(e.data), this.page < this.max && setTimeout(() => {
              this.nextPage();
            }, this.table.options.progressiveLoadDelay);
            break;
          case "progressive_scroll":
            e = this.page === 1 ? e.data : this.table.rowManager.getData().concat(e.data), this.table.rowManager.setData(e, this.page !== 1, this.page == 1), t = this.table.options.progressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2, this.table.rowManager.element.scrollHeight <= this.table.rowManager.element.clientHeight + t && this.page < this.max && setTimeout(() => {
              this.nextPage();
            });
            break;
        }
        return !1;
      } else
        this.dispatchExternal("pageLoaded", this.getPage());
    else
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
    return e.data;
  }
  //handle the footer element being redrawn
  footerRedraw() {
    var e = this.table.footerManager.containerElement;
    Math.ceil(e.clientWidth) - e.scrollWidth < 0 ? this.pagesElement.style.display = "none" : (this.pagesElement.style.display = "", Math.ceil(e.clientWidth) - e.scrollWidth < 0 && (this.pagesElement.style.display = "none"));
  }
}
Ma.moduleName = "page";
Ma.pageCounters = d5;
var f5 = {
  local: function(r, e) {
    var t = localStorage.getItem(r + "-" + e);
    return t ? JSON.parse(t) : !1;
  },
  cookie: function(r, e) {
    var t = document.cookie, i = r + "-" + e, o = t.indexOf(i + "="), n, s;
    return o > -1 && (t = t.slice(o), n = t.indexOf(";"), n > -1 && (t = t.slice(0, n)), s = t.replace(i + "=", "")), s ? JSON.parse(s) : !1;
  }
}, p5 = {
  local: function(r, e, t) {
    localStorage.setItem(r + "-" + e, JSON.stringify(t));
  },
  cookie: function(r, e, t) {
    var i = /* @__PURE__ */ new Date();
    i.setDate(i.getDate() + 1e4), document.cookie = r + "-" + e + "=" + JSON.stringify(t) + "; expires=" + i.toUTCString();
  }
};
class $t extends fe {
  constructor(e) {
    super(e), this.mode = "", this.id = "", this.defWatcherBlock = !1, this.config = {}, this.readFunc = !1, this.writeFunc = !1, this.registerTableOption("persistence", !1), this.registerTableOption("persistenceID", ""), this.registerTableOption("persistenceMode", !0), this.registerTableOption("persistenceReaderFunc", !1), this.registerTableOption("persistenceWriterFunc", !1);
  }
  // Test for whether localStorage is available for use.
  localStorageTest() {
    var e = "_tabulator_test";
    try {
      return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0;
    } catch {
      return !1;
    }
  }
  //setup parameters
  initialize() {
    if (this.table.options.persistence) {
      var e = this.table.options.persistenceMode, t = this.table.options.persistenceID, i;
      this.mode = e !== !0 ? e : this.localStorageTest() ? "local" : "cookie", this.table.options.persistenceReaderFunc ? typeof this.table.options.persistenceReaderFunc == "function" ? this.readFunc = this.table.options.persistenceReaderFunc : $t.readers[this.table.options.persistenceReaderFunc] ? this.readFunc = $t.readers[this.table.options.persistenceReaderFunc] : console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc) : $t.readers[this.mode] ? this.readFunc = $t.readers[this.mode] : console.warn("Persistence Read Error - invalid reader set", this.mode), this.table.options.persistenceWriterFunc ? typeof this.table.options.persistenceWriterFunc == "function" ? this.writeFunc = this.table.options.persistenceWriterFunc : $t.writers[this.table.options.persistenceWriterFunc] ? this.writeFunc = $t.writers[this.table.options.persistenceWriterFunc] : console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc) : $t.writers[this.mode] ? this.writeFunc = $t.writers[this.mode] : console.warn("Persistence Write Error - invalid writer set", this.mode), this.id = "tabulator-" + (t || this.table.element.getAttribute("id") || ""), this.config = {
        sort: this.table.options.persistence === !0 || this.table.options.persistence.sort,
        filter: this.table.options.persistence === !0 || this.table.options.persistence.filter,
        headerFilter: this.table.options.persistence === !0 || this.table.options.persistence.headerFilter,
        group: this.table.options.persistence === !0 || this.table.options.persistence.group,
        page: this.table.options.persistence === !0 || this.table.options.persistence.page,
        columns: this.table.options.persistence === !0 ? ["title", "width", "visible"] : this.table.options.persistence.columns
      }, this.config.page && (i = this.retrieveData("page"), i && (typeof i.paginationSize < "u" && (this.config.page === !0 || this.config.page.size) && (this.table.options.paginationSize = i.paginationSize), typeof i.paginationInitialPage < "u" && (this.config.page === !0 || this.config.page.page) && (this.table.options.paginationInitialPage = i.paginationInitialPage))), this.config.group && (i = this.retrieveData("group"), i && (typeof i.groupBy < "u" && (this.config.group === !0 || this.config.group.groupBy) && (this.table.options.groupBy = i.groupBy), typeof i.groupStartOpen < "u" && (this.config.group === !0 || this.config.group.groupStartOpen) && (this.table.options.groupStartOpen = i.groupStartOpen), typeof i.groupHeader < "u" && (this.config.group === !0 || this.config.group.groupHeader) && (this.table.options.groupHeader = i.groupHeader))), this.config.columns && (this.table.options.columns = this.load("columns", this.table.options.columns), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-show", this.save.bind(this, "columns")), this.subscribe("column-hide", this.save.bind(this, "columns")), this.subscribe("column-moved", this.save.bind(this, "columns"))), this.subscribe("table-built", this.tableBuilt.bind(this), 0), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("filter-changed", this.eventSave.bind(this, "filter")), this.subscribe("filter-changed", this.eventSave.bind(this, "headerFilter")), this.subscribe("sort-changed", this.eventSave.bind(this, "sort")), this.subscribe("group-changed", this.eventSave.bind(this, "group")), this.subscribe("page-changed", this.eventSave.bind(this, "page")), this.subscribe("column-resized", this.eventSave.bind(this, "columns")), this.subscribe("column-width", this.eventSave.bind(this, "columns")), this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
    }
    this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this)), this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
  }
  eventSave(e) {
    this.config[e] && this.save(e);
  }
  tableBuilt() {
    var e, t, i;
    this.config.sort && (e = this.load("sort"), e && (this.table.options.initialSort = e)), this.config.filter && (t = this.load("filter"), t && (this.table.options.initialFilter = t)), this.config.headerFilter && (i = this.load("headerFilter"), i && (this.table.options.initialHeaderFilter = i));
  }
  tableRedraw(e) {
    e && this.config.columns && this.save("columns");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  getColumnLayout() {
    return this.parseColumns(this.table.columnManager.getColumns());
  }
  setColumnLayout(e) {
    return this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, e)), !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumn(e) {
    var t, i;
    this.config.columns && (this.defWatcherBlock = !0, t = e.getDefinition(), i = this.config.columns === !0 ? Object.keys(t) : this.config.columns, i.forEach((o) => {
      var n = Object.getOwnPropertyDescriptor(t, o), s = t[o];
      n && Object.defineProperty(t, o, {
        set: (a) => {
          s = a, this.defWatcherBlock || this.save("columns"), n.set && n.set(a);
        },
        get: () => (n.get && n.get(), s)
      });
    }), this.defWatcherBlock = !1);
  }
  //load saved definitions
  load(e, t) {
    var i = this.retrieveData(e);
    return t && (i = i ? this.mergeDefinition(t, i) : t), i;
  }
  //retrieve data from memory
  retrieveData(e) {
    return this.readFunc ? this.readFunc(this.id, e) : !1;
  }
  //merge old and new column definitions
  mergeDefinition(e, t) {
    var i = [];
    return t = t || [], t.forEach((o, n) => {
      var s = this._findColumn(e, o), a;
      s && (this.config.columns === !0 || this.config.columns == null ? (a = Object.keys(s), a.push("width")) : a = this.config.columns, a.forEach((l) => {
        l !== "columns" && typeof o[l] < "u" && (s[l] = o[l]);
      }), s.columns && (s.columns = this.mergeDefinition(s.columns, o.columns)), i.push(s));
    }), e.forEach((o, n) => {
      var s = this._findColumn(t, o);
      s || (i.length > n ? i.splice(n, 0, o) : i.push(o));
    }), i;
  }
  //find matching columns
  _findColumn(e, t) {
    var i = t.columns ? "group" : t.field ? "field" : "object";
    return e.find(function(o) {
      switch (i) {
        case "group":
          return o.title === t.title && o.columns.length === t.columns.length;
        case "field":
          return o.field === t.field;
        case "object":
          return o === t;
      }
    });
  }
  //save data
  save(e) {
    var t = {};
    switch (e) {
      case "columns":
        t = this.parseColumns(this.table.columnManager.getColumns());
        break;
      case "filter":
        t = this.table.modules.filter.getFilters();
        break;
      case "headerFilter":
        t = this.table.modules.filter.getHeaderFilters();
        break;
      case "sort":
        t = this.validateSorters(this.table.modules.sort.getSort());
        break;
      case "group":
        t = this.getGroupConfig();
        break;
      case "page":
        t = this.getPageConfig();
        break;
    }
    this.writeFunc && this.writeFunc(this.id, e, t);
  }
  //ensure sorters contain no function data
  validateSorters(e) {
    return e.forEach(function(t) {
      t.column = t.field, delete t.field;
    }), e;
  }
  getGroupConfig() {
    var e = {};
    return this.config.group && ((this.config.group === !0 || this.config.group.groupBy) && (e.groupBy = this.table.options.groupBy), (this.config.group === !0 || this.config.group.groupStartOpen) && (e.groupStartOpen = this.table.options.groupStartOpen), (this.config.group === !0 || this.config.group.groupHeader) && (e.groupHeader = this.table.options.groupHeader)), e;
  }
  getPageConfig() {
    var e = {};
    return this.config.page && ((this.config.page === !0 || this.config.page.size) && (e.paginationSize = this.table.modules.page.getPageSize()), (this.config.page === !0 || this.config.page.page) && (e.paginationInitialPage = this.table.modules.page.getPage())), e;
  }
  //parse columns for data to store
  parseColumns(e) {
    var t = [], i = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];
    return e.forEach((o) => {
      var n = {}, s = o.getDefinition(), a;
      o.isGroup ? (n.title = s.title, n.columns = this.parseColumns(o.getColumns())) : (n.field = o.getField(), this.config.columns === !0 || this.config.columns == null ? (a = Object.keys(s), a.push("width"), a.push("visible")) : a = this.config.columns, a.forEach((l) => {
        switch (l) {
          case "width":
            n.width = o.getWidth();
            break;
          case "visible":
            n.visible = o.visible;
            break;
          default:
            typeof s[l] != "function" && i.indexOf(l) === -1 && (n[l] = s[l]);
        }
      })), t.push(n);
    }), t;
  }
}
$t.moduleName = "persistence";
$t.moduleInitOrder = -10;
$t.readers = f5;
$t.writers = p5;
class PS extends fe {
  constructor(e) {
    super(e), this.columnSubscribers = {}, this.registerTableOption("rowContextPopup", !1), this.registerTableOption("rowClickPopup", !1), this.registerTableOption("rowDblClickPopup", !1), this.registerTableOption("groupContextPopup", !1), this.registerTableOption("groupClickPopup", !1), this.registerTableOption("groupDblClickPopup", !1), this.registerColumnOption("headerContextPopup"), this.registerColumnOption("headerClickPopup"), this.registerColumnOption("headerDblClickPopup"), this.registerColumnOption("headerPopup"), this.registerColumnOption("headerPopupIcon"), this.registerColumnOption("contextPopup"), this.registerColumnOption("clickPopup"), this.registerColumnOption("dblClickPopup"), this.registerComponentFunction("cell", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("column", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("row", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("group", "popup", this._componentPopupCall.bind(this));
  }
  initialize() {
    this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  _componentPopupCall(e, t, i) {
    this.loadPopupEvent(t, null, e, i);
  }
  initializeRowWatchers() {
    this.table.options.rowContextPopup && (this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup)), this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup))), this.table.options.rowClickPopup && this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup)), this.table.options.rowDblClickPopup && this.subscribe("row-dblclick", this.loadPopupEvent.bind(this, this.table.options.rowDblClickPopup));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextPopup && (this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup)), this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup))), this.table.options.groupClickPopup && this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup)), this.table.options.groupDblClickPopup && this.subscribe("group-dblclick", this.loadPopupEvent.bind(this, this.table.options.groupDblClickPopup));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextPopup && !this.columnSubscribers.headerContextPopup && (this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup), this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"))), t.headerClickPopup && !this.columnSubscribers.headerClickPopup && (this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup"), this.subscribe("column-click", this.columnSubscribers.headerClickPopup)), t.headerDblClickPopup && !this.columnSubscribers.headerDblClickPopup && (this.columnSubscribers.headerDblClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerDblClickPopup"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickPopup)), t.headerPopup && this.initializeColumnHeaderPopup(e), t.contextPopup && !this.columnSubscribers.contextPopup && (this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup), this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"))), t.clickPopup && !this.columnSubscribers.clickPopup && (this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup"), this.subscribe("cell-click", this.columnSubscribers.clickPopup)), t.dblClickPopup && !this.columnSubscribers.dblClickPopup && (this.columnSubscribers.dblClickPopup = this.loadPopupTableCellEvent.bind(this, "dblClickPopup"), this.subscribe("cell-click", this.columnSubscribers.dblClickPopup));
  }
  initializeColumnHeaderPopup(e) {
    var t = e.definition.headerPopupIcon, i;
    i = document.createElement("span"), i.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? i.appendChild(t) : i.innerHTML = t) : i.innerHTML = "&vellip;", i.addEventListener("click", (o) => {
      o.stopPropagation(), o.preventDefault(), this.loadPopupEvent(e.definition.headerPopup, o, e);
    }), e.titleElement.insertBefore(i, e.titleElement.firstChild);
  }
  loadPopupTableCellEvent(e, t, i) {
    i._cell && (i = i._cell), i.column.definition[e] && this.loadPopupEvent(i.column.definition[e], t, i);
  }
  loadPopupTableColumnEvent(e, t, i) {
    i._column && (i = i._column), i.definition[e] && this.loadPopupEvent(i.definition[e], t, i);
  }
  loadPopupEvent(e, t, i, o) {
    var n;
    function s(a) {
      n = a;
    }
    i._group ? i = i._group : i._row && (i = i._row), e = typeof e == "function" ? e.call(this.table, t, i.getComponent(), s) : e, this.loadPopup(t, i, e, n, o);
  }
  loadPopup(e, t, i, o, n) {
    var s = !(e instanceof MouseEvent), a, l;
    i instanceof HTMLElement ? a = i : (a = document.createElement("div"), a.innerHTML = i), a.classList.add("tabulator-popup"), a.addEventListener("click", (u) => {
      u.stopPropagation();
    }), s || e.preventDefault(), l = this.popup(a), typeof o == "function" && l.renderCallback(o), e ? l.show(e) : l.show(t.getElement(), n || "center"), l.hideOnBlur(() => {
      this.dispatchExternal("popupClosed", t.getComponent());
    }), this.dispatchExternal("popupOpened", t.getComponent());
  }
}
PS.moduleName = "popup";
class kS extends fe {
  constructor(e) {
    super(e), this.element = !1, this.manualBlock = !1, this.beforeprintEventHandler = null, this.afterprintEventHandler = null, this.registerTableOption("printAsHtml", !1), this.registerTableOption("printFormatter", !1), this.registerTableOption("printHeader", !1), this.registerTableOption("printFooter", !1), this.registerTableOption("printStyled", !0), this.registerTableOption("printRowRange", "visible"), this.registerTableOption("printConfig", {}), this.registerColumnOption("print"), this.registerColumnOption("titlePrint");
  }
  initialize() {
    this.table.options.printAsHtml && (this.beforeprintEventHandler = this.replaceTable.bind(this), this.afterprintEventHandler = this.cleanup.bind(this), window.addEventListener("beforeprint", this.beforeprintEventHandler), window.addEventListener("afterprint", this.afterprintEventHandler), this.subscribe("table-destroy", this.destroy.bind(this))), this.registerTableFunction("print", this.printFullscreen.bind(this));
  }
  destroy() {
    this.table.options.printAsHtml && (window.removeEventListener("beforeprint", this.beforeprintEventHandler), window.removeEventListener("afterprint", this.afterprintEventHandler));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  replaceTable() {
    this.manualBlock || (this.element = document.createElement("div"), this.element.classList.add("tabulator-print-table"), this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print")), this.table.element.style.display = "none", this.table.element.parentNode.insertBefore(this.element, this.table.element));
  }
  cleanup() {
    document.body.classList.remove("tabulator-print-fullscreen-hide"), this.element && this.element.parentNode && (this.element.parentNode.removeChild(this.element), this.table.element.style.display = "");
  }
  printFullscreen(e, t, i) {
    var o = window.scrollX, n = window.scrollY, s = document.createElement("div"), a = document.createElement("div"), l = this.table.modules.export.generateTable(typeof i < "u" ? i : this.table.options.printConfig, typeof t < "u" ? t : this.table.options.printStyled, e || this.table.options.printRowRange, "print"), u, h;
    this.manualBlock = !0, this.element = document.createElement("div"), this.element.classList.add("tabulator-print-fullscreen"), this.table.options.printHeader && (s.classList.add("tabulator-print-header"), u = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader, typeof u == "string" ? s.innerHTML = u : s.appendChild(u), this.element.appendChild(s)), this.element.appendChild(l), this.table.options.printFooter && (a.classList.add("tabulator-print-footer"), h = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter, typeof h == "string" ? a.innerHTML = h : a.appendChild(h), this.element.appendChild(a)), document.body.classList.add("tabulator-print-fullscreen-hide"), document.body.appendChild(this.element), this.table.options.printFormatter && this.table.options.printFormatter(this.element, l), window.print(), this.cleanup(), window.scrollTo(o, n), this.manualBlock = !1;
  }
}
kS.moduleName = "print";
class ES extends fe {
  constructor(e) {
    super(e), this.data = !1, this.blocked = !1, this.origFuncs = {}, this.currentVersion = 0, this.registerTableOption("reactiveData", !1);
  }
  initialize() {
    this.table.options.reactiveData && (this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave")), this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave")), this.subscribe("row-data-save-before", this.block.bind(this, "rowsave")), this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave")), this.subscribe("row-data-init-after", this.watchRow.bind(this)), this.subscribe("data-processing", this.watchData.bind(this)), this.subscribe("table-destroy", this.unwatchData.bind(this)));
  }
  watchData(e) {
    var t = this, i;
    this.currentVersion++, i = this.currentVersion, this.unwatchData(), this.data = e, this.origFuncs.push = e.push, Object.defineProperty(this.data, "push", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o = Array.from(arguments), n;
        return !t.blocked && i === t.currentVersion && (t.block("data-push"), o.forEach((s) => {
          t.table.rowManager.addRowActual(s, !1);
        }), n = t.origFuncs.push.apply(e, arguments), t.unblock("data-push")), n;
      }
    }), this.origFuncs.unshift = e.unshift, Object.defineProperty(this.data, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o = Array.from(arguments), n;
        return !t.blocked && i === t.currentVersion && (t.block("data-unshift"), o.forEach((s) => {
          t.table.rowManager.addRowActual(s, !0);
        }), n = t.origFuncs.unshift.apply(e, arguments), t.unblock("data-unshift")), n;
      }
    }), this.origFuncs.shift = e.shift, Object.defineProperty(this.data, "shift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o, n;
        return !t.blocked && i === t.currentVersion && (t.block("data-shift"), t.data.length && (o = t.table.rowManager.getRowFromDataObject(t.data[0]), o && o.deleteActual()), n = t.origFuncs.shift.call(e), t.unblock("data-shift")), n;
      }
    }), this.origFuncs.pop = e.pop, Object.defineProperty(this.data, "pop", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o, n;
        return !t.blocked && i === t.currentVersion && (t.block("data-pop"), t.data.length && (o = t.table.rowManager.getRowFromDataObject(t.data[t.data.length - 1]), o && o.deleteActual()), n = t.origFuncs.pop.call(e), t.unblock("data-pop")), n;
      }
    }), this.origFuncs.splice = e.splice, Object.defineProperty(this.data, "splice", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var o = Array.from(arguments), n = o[0] < 0 ? e.length + o[0] : o[0], s = o[1], a = o[2] ? o.slice(2) : !1, l, u;
        if (!t.blocked && i === t.currentVersion) {
          if (t.block("data-splice"), a && (l = e[n] ? t.table.rowManager.getRowFromDataObject(e[n]) : !1, l ? a.forEach((c) => {
            t.table.rowManager.addRowActual(c, !0, l, !0);
          }) : (a = a.slice().reverse(), a.forEach((c) => {
            t.table.rowManager.addRowActual(c, !0, !1, !0);
          }))), s !== 0) {
            var h = e.slice(n, typeof o[1] > "u" ? o[1] : n + s);
            h.forEach((c, d) => {
              var f = t.table.rowManager.getRowFromDataObject(c);
              f && f.deleteActual(d !== h.length - 1);
            });
          }
          (a || s !== 0) && t.table.rowManager.reRenderInPosition(), u = t.origFuncs.splice.apply(e, arguments), t.unblock("data-splice");
        }
        return u;
      }
    });
  }
  unwatchData() {
    if (this.data !== !1)
      for (var e in this.origFuncs)
        Object.defineProperty(this.data, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: this.origFuncs.key
        });
  }
  watchRow(e) {
    var t = e.getData();
    for (var i in t)
      this.watchKey(e, t, i);
    this.table.options.dataTree && this.watchTreeChildren(e);
  }
  watchTreeChildren(e) {
    var t = this, i = e.getData()[this.table.options.dataTreeChildField], o = {};
    i && (o.push = i.push, Object.defineProperty(i, "push", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-push");
          var n = o.push.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-push");
        }
        return n;
      }
    }), o.unshift = i.unshift, Object.defineProperty(i, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-unshift");
          var n = o.unshift.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-unshift");
        }
        return n;
      }
    }), o.shift = i.shift, Object.defineProperty(i, "shift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-shift");
          var n = o.shift.call(i);
          this.rebuildTree(e), t.unblock("tree-shift");
        }
        return n;
      }
    }), o.pop = i.pop, Object.defineProperty(i, "pop", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-pop");
          var n = o.pop.call(i);
          this.rebuildTree(e), t.unblock("tree-pop");
        }
        return n;
      }
    }), o.splice = i.splice, Object.defineProperty(i, "splice", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-splice");
          var n = o.splice.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-splice");
        }
        return n;
      }
    }));
  }
  rebuildTree(e) {
    this.table.modules.dataTree.initializeRow(e), this.table.modules.dataTree.layoutRow(e), this.table.rowManager.refreshActiveData("tree", !1, !0);
  }
  watchKey(e, t, i) {
    var o = this, n = Object.getOwnPropertyDescriptor(t, i), s = t[i], a = this.currentVersion;
    Object.defineProperty(t, i, {
      set: (l) => {
        if (s = l, !o.blocked && a === o.currentVersion) {
          o.block("key");
          var u = {};
          u[i] = l, e.updateData(u), o.unblock("key");
        }
        n.set && n.set(l);
      },
      get: () => (n.get && n.get(), s)
    });
  }
  unwatchRow(e) {
    var t = e.getData();
    for (var i in t)
      Object.defineProperty(t, i, {
        value: t[i]
      });
  }
  block(e) {
    this.blocked || (this.blocked = e);
  }
  unblock(e) {
    this.blocked === e && (this.blocked = !1);
  }
}
ES.moduleName = "reactiveData";
class TS extends fe {
  constructor(e) {
    super(e), this.startColumn = !1, this.startX = !1, this.startWidth = !1, this.latestX = !1, this.handle = null, this.initialNextColumn = null, this.nextColumn = null, this.initialized = !1, this.registerColumnOption("resizable", !0), this.registerTableOption("resizableColumnFit", !1);
  }
  initialize() {
    this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
  }
  initializeEventWatchers() {
    this.initialized || (this.subscribe("cell-rendered", this.layoutCellHandles.bind(this)), this.subscribe("cell-delete", this.deInitializeComponent.bind(this)), this.subscribe("cell-height", this.resizeHandle.bind(this)), this.subscribe("column-moved", this.columnLayoutUpdated.bind(this)), this.subscribe("column-hide", this.deInitializeColumn.bind(this)), this.subscribe("column-show", this.columnLayoutUpdated.bind(this)), this.subscribe("column-width", this.columnWidthUpdated.bind(this)), this.subscribe("column-delete", this.deInitializeComponent.bind(this)), this.subscribe("column-height", this.resizeHandle.bind(this)), this.initialized = !0);
  }
  layoutCellHandles(e) {
    e.row.type === "row" && (this.deInitializeComponent(e), this.initializeColumn("cell", e, e.column, e.element));
  }
  layoutColumnHeader(e) {
    e.definition.resizable && (this.initializeEventWatchers(), this.deInitializeComponent(e), this.initializeColumn("header", e, e, e.element));
  }
  columnLayoutUpdated(e) {
    var t = e.prevColumn();
    this.reinitializeColumn(e), t && this.reinitializeColumn(t);
  }
  columnWidthUpdated(e) {
    e.modules.frozen && (this.table.modules.frozenColumns.leftColumns.includes(e) ? this.table.modules.frozenColumns.leftColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }) : this.table.modules.frozenColumns.rightColumns.includes(e) && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }));
  }
  frozenColumnOffset(e) {
    var t = !1;
    return e.modules.frozen && (t = e.modules.frozen.marginValue, e.modules.frozen.position === "left" ? t += e.getWidth() - 3 : t && (t -= 3)), t !== !1 ? t + "px" : !1;
  }
  reinitializeColumn(e) {
    var t = this.frozenColumnOffset(e);
    e.cells.forEach((i) => {
      i.modules.resize && i.modules.resize.handleEl && (t && (i.modules.resize.handleEl.style[e.modules.frozen.position] = t), i.element.after(i.modules.resize.handleEl));
    }), e.modules.resize && e.modules.resize.handleEl && (t && (e.modules.resize.handleEl.style[e.modules.frozen.position] = t), e.element.after(e.modules.resize.handleEl));
  }
  initializeColumn(e, t, i, o) {
    var n = this, s = !1, a = i.definition.resizable, l = {}, u = i.getLastColumn();
    if (e === "header" && (s = i.definition.formatter == "textarea" || i.definition.variableHeight, l = { variableHeight: s }), (a === !0 || a == e) && this._checkResizability(u)) {
      var h = document.createElement("span");
      h.className = "tabulator-col-resize-handle", h.addEventListener("click", function(d) {
        d.stopPropagation();
      });
      var c = function(d) {
        n.startColumn = i, n.initialNextColumn = n.nextColumn = u.nextColumn(), n._mouseDown(d, u, h);
      };
      h.addEventListener("mousedown", c), h.addEventListener("touchstart", c, { passive: !0 }), h.addEventListener("dblclick", (d) => {
        var f = u.getWidth();
        d.stopPropagation(), u.reinitializeWidth(!0), f !== u.getWidth() && (n.dispatch("column-resized", u), n.table.externalEvents.dispatch("columnResized", u.getComponent()));
      }), i.modules.frozen && (h.style.position = "sticky", h.style[i.modules.frozen.position] = this.frozenColumnOffset(i)), l.handleEl = h, o.parentNode && i.visible && o.after(h);
    }
    t.modules.resize = l;
  }
  deInitializeColumn(e) {
    this.deInitializeComponent(e), e.cells.forEach((t) => {
      this.deInitializeComponent(t);
    });
  }
  deInitializeComponent(e) {
    var t;
    e.modules.resize && (t = e.modules.resize.handleEl, t && t.parentElement && t.parentElement.removeChild(t));
  }
  resizeHandle(e, t) {
    e.modules.resize && e.modules.resize.handleEl && (e.modules.resize.handleEl.style.height = t);
  }
  _checkResizability(e) {
    return e.definition.resizable;
  }
  _mouseDown(e, t, i) {
    var o = this;
    o.table.element.classList.add("tabulator-block-select");
    function n(a) {
      var l = typeof a.screenX > "u" ? a.touches[0].screenX : a.screenX, u = l - o.startX, h = l - o.latestX, c, d;
      if (o.latestX = l, o.table.rtl && (u = -u, h = -h), c = t.width == t.minWidth || t.width == t.maxWidth, t.setWidth(o.startWidth + u), d = t.width == t.minWidth || t.width == t.maxWidth, h < 0 && (o.nextColumn = o.initialNextColumn), o.table.options.resizableColumnFit && o.nextColumn && !(c && d)) {
        let f = o.nextColumn.getWidth();
        h > 0 && f <= o.nextColumn.minWidth && (o.nextColumn = o.nextColumn.nextColumn()), o.nextColumn && o.nextColumn.setWidth(o.nextColumn.getWidth() - h);
      }
      o.table.columnManager.rerenderColumns(!0), !o.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights();
    }
    function s(a) {
      o.startColumn.modules.edit && (o.startColumn.modules.edit.blocked = !1), o.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights(), document.body.removeEventListener("mouseup", s), document.body.removeEventListener("mousemove", n), i.removeEventListener("touchmove", n), i.removeEventListener("touchend", s), o.table.element.classList.remove("tabulator-block-select"), o.startWidth !== t.getWidth() && (o.table.columnManager.verticalAlignHeaders(), o.dispatch("column-resized", t), o.table.externalEvents.dispatch("columnResized", t.getComponent()));
    }
    e.stopPropagation(), o.startColumn.modules.edit && (o.startColumn.modules.edit.blocked = !0), o.startX = typeof e.screenX > "u" ? e.touches[0].screenX : e.screenX, o.latestX = o.startX, o.startWidth = t.getWidth(), document.body.addEventListener("mousemove", n), document.body.addEventListener("mouseup", s), i.addEventListener("touchmove", n, { passive: !0 }), i.addEventListener("touchend", s);
  }
}
TS.moduleName = "resizeColumns";
class $S extends fe {
  constructor(e) {
    super(e), this.startColumn = !1, this.startY = !1, this.startHeight = !1, this.handle = null, this.prevHandle = null, this.registerTableOption("resizableRows", !1);
  }
  initialize() {
    this.table.options.resizableRows && this.subscribe("row-layout-after", this.initializeRow.bind(this));
  }
  initializeRow(e) {
    var t = this, i = e.getElement(), o = document.createElement("div");
    o.className = "tabulator-row-resize-handle";
    var n = document.createElement("div");
    n.className = "tabulator-row-resize-handle prev", o.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var s = function(l) {
      t.startRow = e, t._mouseDown(l, e, o);
    };
    o.addEventListener("mousedown", s), o.addEventListener("touchstart", s, { passive: !0 }), n.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var a = function(l) {
      var u = t.table.rowManager.prevDisplayRow(e);
      u && (t.startRow = u, t._mouseDown(l, u, n));
    };
    n.addEventListener("mousedown", a), n.addEventListener("touchstart", a, { passive: !0 }), i.appendChild(o), i.appendChild(n);
  }
  _mouseDown(e, t, i) {
    var o = this;
    o.table.element.classList.add("tabulator-block-select");
    function n(a) {
      t.setHeight(o.startHeight + ((typeof a.screenY > "u" ? a.touches[0].screenY : a.screenY) - o.startY));
    }
    function s(a) {
      document.body.removeEventListener("mouseup", n), document.body.removeEventListener("mousemove", n), i.removeEventListener("touchmove", n), i.removeEventListener("touchend", s), o.table.element.classList.remove("tabulator-block-select"), o.dispatchExternal("rowResized", t.getComponent());
    }
    e.stopPropagation(), o.startY = typeof e.screenY > "u" ? e.touches[0].screenY : e.screenY, o.startHeight = t.getHeight(), document.body.addEventListener("mousemove", n), document.body.addEventListener("mouseup", s), i.addEventListener("touchmove", n, { passive: !0 }), i.addEventListener("touchend", s);
  }
}
$S.moduleName = "resizeRows";
class RS extends fe {
  constructor(e) {
    super(e), this.binding = !1, this.visibilityObserver = !1, this.resizeObserver = !1, this.containerObserver = !1, this.tableHeight = 0, this.tableWidth = 0, this.containerHeight = 0, this.containerWidth = 0, this.autoResize = !1, this.visible = !1, this.initialized = !1, this.initialRedraw = !1, this.registerTableOption("autoResize", !0);
  }
  initialize() {
    if (this.table.options.autoResize) {
      var e = this.table, t;
      this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), typeof IntersectionObserver < "u" && typeof ResizeObserver < "u" && e.rowManager.getRenderMode() === "virtual" ? (this.initializeVisibilityObserver(), this.autoResize = !0, this.resizeObserver = new ResizeObserver((i) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var o = Math.floor(i[0].contentRect.height), n = Math.floor(i[0].contentRect.width);
          (this.tableHeight != o || this.tableWidth != n) && (this.tableHeight = o, this.tableWidth = n, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), this.redrawTable());
        }
      }), this.resizeObserver.observe(e.element), t = window.getComputedStyle(e.element), this.table.element.parentNode && !this.table.rowManager.fixedHeight && (t.getPropertyValue("max-height") || t.getPropertyValue("min-height")) && (this.containerObserver = new ResizeObserver((i) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var o = Math.floor(i[0].contentRect.height), n = Math.floor(i[0].contentRect.width);
          (this.containerHeight != o || this.containerWidth != n) && (this.containerHeight = o, this.containerWidth = n, this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth), this.redrawTable();
        }
      }), this.containerObserver.observe(this.table.element.parentNode)), this.subscribe("table-resize", this.tableResized.bind(this))) : (this.binding = function() {
        (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) && (e.columnManager.rerenderColumns(!0), e.redraw());
      }, window.addEventListener("resize", this.binding)), this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
  }
  initializeVisibilityObserver() {
    this.visibilityObserver = new IntersectionObserver((e) => {
      this.visible = e[0].isIntersecting, this.initialized ? this.visible && (this.redrawTable(this.initialRedraw), this.initialRedraw = !1) : (this.initialized = !0, this.initialRedraw = !this.visible);
    }), this.visibilityObserver.observe(this.table.element);
  }
  redrawTable(e) {
    this.initialized && this.visible && (this.table.columnManager.rerenderColumns(!0), this.table.redraw(e));
  }
  tableResized() {
    this.table.rowManager.redraw();
  }
  clearBindings() {
    this.binding && window.removeEventListener("resize", this.binding), this.resizeObserver && this.resizeObserver.unobserve(this.table.element), this.visibilityObserver && this.visibilityObserver.unobserve(this.table.element), this.containerObserver && this.containerObserver.unobserve(this.table.element.parentNode);
  }
}
RS.moduleName = "resizeTable";
class _S extends fe {
  constructor(e) {
    super(e), this.columns = [], this.hiddenColumns = [], this.mode = "", this.index = 0, this.collapseFormatter = [], this.collapseStartOpen = !0, this.collapseHandleColumn = !1, this.registerTableOption("responsiveLayout", !1), this.registerTableOption("responsiveLayoutCollapseStartOpen", !0), this.registerTableOption("responsiveLayoutCollapseUseFormatters", !0), this.registerTableOption("responsiveLayoutCollapseFormatter", !1), this.registerColumnOption("responsive");
  }
  //generate responsive columns list
  initialize() {
    this.table.options.responsiveLayout && (this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-show", this.updateColumnVisibility.bind(this)), this.subscribe("column-hide", this.updateColumnVisibility.bind(this)), this.subscribe("columns-loaded", this.initializeResponsivity.bind(this)), this.subscribe("column-moved", this.initializeResponsivity.bind(this)), this.subscribe("column-add", this.initializeResponsivity.bind(this)), this.subscribe("column-delete", this.initializeResponsivity.bind(this)), this.subscribe("table-redrawing", this.tableRedraw.bind(this)), this.table.options.responsiveLayout === "collapse" && (this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout", this.layoutRow.bind(this))));
  }
  tableRedraw(e) {
    ["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1 && (e || this.update());
  }
  initializeResponsivity() {
    var e = [];
    this.mode = this.table.options.responsiveLayout, this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData, this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen, this.hiddenColumns = [], this.table.columnManager.columnsByIndex.forEach((t, i) => {
      t.modules.responsive && t.modules.responsive.order && t.modules.responsive.visible && (t.modules.responsive.index = i, e.push(t), !t.visible && this.mode === "collapse" && this.hiddenColumns.push(t));
    }), e = e.reverse(), e = e.sort((t, i) => {
      var o = i.modules.responsive.order - t.modules.responsive.order;
      return o || i.modules.responsive.index - t.modules.responsive.index;
    }), this.columns = e, this.mode === "collapse" && this.generateCollapsedContent();
    for (let t of this.table.columnManager.columnsByIndex)
      if (t.definition.formatter == "responsiveCollapse") {
        this.collapseHandleColumn = t;
        break;
      }
    this.collapseHandleColumn && (this.hiddenColumns.length ? this.collapseHandleColumn.show() : this.collapseHandleColumn.hide());
  }
  //define layout information
  initializeColumn(e) {
    var t = e.getDefinition();
    e.modules.responsive = { order: typeof t.responsive > "u" ? 1 : t.responsive, visible: t.visible !== !1 };
  }
  initializeRow(e) {
    var t;
    e.type !== "calc" && (t = document.createElement("div"), t.classList.add("tabulator-responsive-collapse"), e.modules.responsiveLayout = {
      element: t,
      open: this.collapseStartOpen
    }, this.collapseStartOpen || (t.style.display = "none"));
  }
  layoutRow(e) {
    var t = e.getElement();
    e.modules.responsiveLayout && (t.appendChild(e.modules.responsiveLayout.element), this.generateCollapsedRowContent(e));
  }
  //update column visibility
  updateColumnVisibility(e, t) {
    !t && e.modules.responsive && (e.modules.responsive.visible = e.visible, this.initializeResponsivity());
  }
  hideColumn(e) {
    var t = this.hiddenColumns.length;
    e.hide(!1, !0), this.mode === "collapse" && (this.hiddenColumns.unshift(e), this.generateCollapsedContent(), this.collapseHandleColumn && !t && this.collapseHandleColumn.show());
  }
  showColumn(e) {
    var t;
    e.show(!1, !0), e.setWidth(e.getWidth()), this.mode === "collapse" && (t = this.hiddenColumns.indexOf(e), t > -1 && this.hiddenColumns.splice(t, 1), this.generateCollapsedContent(), this.collapseHandleColumn && !this.hiddenColumns.length && this.collapseHandleColumn.hide());
  }
  //redraw columns to fit space
  update() {
    for (var e = !0; e; ) {
      let t = this.table.modules.layout.getMode() == "fitColumns" ? this.table.columnManager.getFlexBaseWidth() : this.table.columnManager.getWidth(), i = (this.table.options.headerVisible ? this.table.columnManager.element.clientWidth : this.table.element.clientWidth) - t;
      if (i < 0) {
        let o = this.columns[this.index];
        o ? (this.hideColumn(o), this.index++) : e = !1;
      } else {
        let o = this.columns[this.index - 1];
        o && i > 0 && i >= o.getWidth() ? (this.showColumn(o), this.index--) : e = !1;
      }
      this.table.rowManager.activeRowsCount || this.table.rowManager.renderEmptyScroll();
    }
  }
  generateCollapsedContent() {
    var e = this.table.rowManager.getDisplayRows();
    e.forEach((t) => {
      this.generateCollapsedRowContent(t);
    });
  }
  generateCollapsedRowContent(e) {
    var t, i;
    if (e.modules.responsiveLayout) {
      for (t = e.modules.responsiveLayout.element; t.firstChild; )
        t.removeChild(t.firstChild);
      i = this.collapseFormatter(this.generateCollapsedRowData(e)), i && t.appendChild(i);
    }
  }
  generateCollapsedRowData(e) {
    var t = e.getData(), i = [], o;
    return this.hiddenColumns.forEach((n) => {
      var s = n.getFieldValue(t);
      if (n.definition.title && n.field)
        if (n.modules.format && this.table.options.responsiveLayoutCollapseUseFormatters) {
          let l = function(u) {
            u();
          };
          var a = l;
          o = {
            value: !1,
            data: {},
            getValue: function() {
              return s;
            },
            getData: function() {
              return t;
            },
            getType: function() {
              return "cell";
            },
            getElement: function() {
              return document.createElement("div");
            },
            getRow: function() {
              return e.getComponent();
            },
            getColumn: function() {
              return n.getComponent();
            },
            getTable: () => this.table
          }, i.push({
            field: n.field,
            title: n.definition.title,
            value: n.modules.format.formatter.call(this.table.modules.format, o, n.modules.format.params, l)
          });
        } else
          i.push({
            field: n.field,
            title: n.definition.title,
            value: s
          });
    }), i;
  }
  formatCollapsedData(e) {
    var t = document.createElement("table");
    return e.forEach(function(i) {
      var o = document.createElement("tr"), n = document.createElement("td"), s = document.createElement("td"), a, l = document.createElement("strong");
      n.appendChild(l), this.langBind("columns|" + i.field, function(u) {
        l.innerHTML = u || i.title;
      }), i.value instanceof Node ? (a = document.createElement("div"), a.appendChild(i.value), s.appendChild(a)) : s.innerHTML = i.value, o.appendChild(n), o.appendChild(s), t.appendChild(o);
    }, this), Object.keys(e).length ? t : "";
  }
}
_S.moduleName = "responsiveLayout";
class DS extends fe {
  constructor(e) {
    super(e), this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], this.headerCheckboxElement = null, this.registerTableOption("selectable", "highlight"), this.registerTableOption("selectableRangeMode", "drag"), this.registerTableOption("selectableRollingSelection", !0), this.registerTableOption("selectablePersistence", !0), this.registerTableOption("selectableCheck", function(t, i) {
      return !0;
    }), this.registerTableFunction("selectRow", this.selectRows.bind(this)), this.registerTableFunction("deselectRow", this.deselectRows.bind(this)), this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this)), this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this)), this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this)), this.registerComponentFunction("row", "select", this.selectRows.bind(this)), this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this)), this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this)), this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
  }
  initialize() {
    this.table.options.selectable !== !1 && (this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-deleting", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clearSelectionData.bind(this)), this.subscribe("rows-retrieve", this.rowRetrieve.bind(this)), this.table.options.selectable && !this.table.options.selectablePersistence && this.subscribe("data-refreshing", this.deselectRows.bind(this)));
  }
  rowRetrieve(e, t) {
    return e === "selected" ? this.selectedRows : t;
  }
  rowDeleted(e) {
    this._deselectRow(e, !0);
  }
  clearSelectionData(e) {
    var t = this.selectedRows.length;
    this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], t && e !== !0 && this._rowSelectionChanged();
  }
  initializeRow(e) {
    var t = this, i = e.getElement(), o = function() {
      setTimeout(function() {
        t.selecting = !1;
      }, 50), document.body.removeEventListener("mouseup", o);
    };
    e.modules.select = { selected: !1 }, t.checkRowSelectability(e) ? (i.classList.add("tabulator-selectable"), i.classList.remove("tabulator-unselectable"), t.table.options.selectable && t.table.options.selectable != "highlight" && (t.table.options.selectableRangeMode === "click" ? i.addEventListener("click", this.handleComplexRowClick.bind(this, e)) : (i.addEventListener("click", function(n) {
      (!t.table.modExists("edit") || !t.table.modules.edit.getCurrentCell()) && t.table._clearSelection(), t.selecting || t.toggleRow(e);
    }), i.addEventListener("mousedown", function(n) {
      if (n.shiftKey)
        return t.table._clearSelection(), t.selecting = !0, t.selectPrev = [], document.body.addEventListener("mouseup", o), document.body.addEventListener("keyup", o), t.toggleRow(e), !1;
    }), i.addEventListener("mouseenter", function(n) {
      t.selecting && (t.table._clearSelection(), t.toggleRow(e), t.selectPrev[1] == e && t.toggleRow(t.selectPrev[0]));
    }), i.addEventListener("mouseout", function(n) {
      t.selecting && (t.table._clearSelection(), t.selectPrev.unshift(e));
    })))) : (i.classList.add("tabulator-unselectable"), i.classList.remove("tabulator-selectable"));
  }
  handleComplexRowClick(e, t) {
    if (t.shiftKey) {
      this.table._clearSelection(), this.lastClickedRow = this.lastClickedRow || e;
      var i = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow), o = this.table.rowManager.getDisplayRowIndex(e), n = i <= o ? i : o, s = i >= o ? i : o, a = this.table.rowManager.getDisplayRows().slice(0), l = a.splice(n, s - n + 1);
      t.ctrlKey || t.metaKey ? (l.forEach((u) => {
        u !== this.lastClickedRow && (this.table.options.selectable !== !0 && !this.isRowSelected(e) ? this.selectedRows.length < this.table.options.selectable && this.toggleRow(u) : this.toggleRow(u));
      }), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.table.options.selectable !== !0 && l.length > this.table.options.selectable && (l = l.slice(0, this.table.options.selectable)), this.selectRows(l)), this.table._clearSelection();
    } else
      t.ctrlKey || t.metaKey ? (this.toggleRow(e), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.selectRows(e), this.lastClickedRow = e);
  }
  checkRowSelectability(e) {
    return e && e.type === "row" ? this.table.options.selectableCheck.call(this.table, e.getComponent()) : !1;
  }
  //toggle row selection
  toggleRow(e) {
    this.checkRowSelectability(e) && (e.modules.select && e.modules.select.selected ? this._deselectRow(e) : this._selectRow(e));
  }
  //select a number of rows
  selectRows(e) {
    var t = [], i, o;
    switch (typeof e) {
      case "undefined":
        i = this.table.rowManager.rows;
        break;
      case "string":
        i = this.table.rowManager.findRow(e), i || (i = this.table.rowManager.getRows(e));
        break;
      default:
        i = e;
        break;
    }
    Array.isArray(i) ? i.length && (i.forEach((n) => {
      o = this._selectRow(n, !0, !0), o && t.push(o);
    }), this._rowSelectionChanged(!1, t)) : i && this._selectRow(i, !1, !0);
  }
  //select an individual row
  _selectRow(e, t, i) {
    if (!isNaN(this.table.options.selectable) && this.table.options.selectable !== !0 && !i && this.selectedRows.length >= this.table.options.selectable)
      if (this.table.options.selectableRollingSelection)
        this._deselectRow(this.selectedRows[0]);
      else
        return !1;
    var o = this.table.rowManager.findRow(e);
    if (o) {
      if (this.selectedRows.indexOf(o) == -1)
        return o.getElement().classList.add("tabulator-selected"), o.modules.select || (o.modules.select = {}), o.modules.select.selected = !0, o.modules.select.checkboxEl && (o.modules.select.checkboxEl.checked = !0), this.selectedRows.push(o), this.table.options.dataTreeSelectPropagate && this.childRowSelection(o, !0), this.dispatchExternal("rowSelected", o.getComponent()), this._rowSelectionChanged(t, o), o;
    } else
      t || console.warn("Selection Error - No such row found, ignoring selection:" + e);
  }
  isRowSelected(e) {
    return this.selectedRows.indexOf(e) !== -1;
  }
  //deselect a number of rows
  deselectRows(e, t) {
    var i = [], o, n;
    switch (typeof e) {
      case "undefined":
        o = Object.assign([], this.selectedRows);
        break;
      case "string":
        o = this.table.rowManager.findRow(e), o || (o = this.table.rowManager.getRows(e));
        break;
      default:
        o = e;
        break;
    }
    Array.isArray(o) ? o.length && (o.forEach((s) => {
      n = this._deselectRow(s, !0, !0), n && i.push(n);
    }), this._rowSelectionChanged(t, [], i)) : o && this._deselectRow(o, t, !0);
  }
  //deselect an individual row
  _deselectRow(e, t) {
    var i = this, o = i.table.rowManager.findRow(e), n, s;
    if (o) {
      if (n = i.selectedRows.findIndex(function(a) {
        return a == o;
      }), n > -1)
        return s = o.getElement(), s && s.classList.remove("tabulator-selected"), o.modules.select || (o.modules.select = {}), o.modules.select.selected = !1, o.modules.select.checkboxEl && (o.modules.select.checkboxEl.checked = !1), i.selectedRows.splice(n, 1), this.table.options.dataTreeSelectPropagate && this.childRowSelection(o, !1), this.dispatchExternal("rowDeselected", o.getComponent()), i._rowSelectionChanged(t, void 0, o), o;
    } else
      t || console.warn("Deselection Error - No such row found, ignoring selection:" + e);
  }
  getSelectedData() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getData());
    }), e;
  }
  getSelectedRows() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  _rowSelectionChanged(e, t = [], i = []) {
    this.headerCheckboxElement && (this.selectedRows.length === 0 ? (this.headerCheckboxElement.checked = !1, this.headerCheckboxElement.indeterminate = !1) : this.table.rowManager.rows.length === this.selectedRows.length ? (this.headerCheckboxElement.checked = !0, this.headerCheckboxElement.indeterminate = !1) : (this.headerCheckboxElement.indeterminate = !0, this.headerCheckboxElement.checked = !1)), e || (Array.isArray(t) || (t = [t]), t = t.map((o) => o.getComponent()), Array.isArray(i) || (i = [i]), i = i.map((o) => o.getComponent()), this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows(), t, i));
  }
  registerRowSelectCheckbox(e, t) {
    e._row.modules.select || (e._row.modules.select = {}), e._row.modules.select.checkboxEl = t;
  }
  registerHeaderSelectCheckbox(e) {
    this.headerCheckboxElement = e;
  }
  childRowSelection(e, t) {
    var i = this.table.modules.dataTree.getChildren(e, !0);
    if (t)
      for (let o of i)
        this._selectRow(o, !0);
    else
      for (let o of i)
        this._deselectRow(o, !0);
  }
}
DS.moduleName = "selectRow";
function g5(r, e, t, i, o, n, s) {
  var a = s.alignEmptyValues, l = s.decimalSeparator, u = s.thousandSeparator, h = 0;
  if (r = String(r), e = String(e), u && (r = r.split(u).join(""), e = e.split(u).join("")), l && (r = r.split(l).join("."), e = e.split(l).join(".")), r = parseFloat(r), e = parseFloat(e), isNaN(r))
    h = isNaN(e) ? 0 : -1;
  else if (isNaN(e))
    h = 1;
  else
    return r - e;
  return (a === "top" && n === "desc" || a === "bottom" && n === "asc") && (h *= -1), h;
}
function m5(r, e, t, i, o, n, s) {
  var a = s.alignEmptyValues, l = 0, u;
  if (!r)
    l = e ? -1 : 0;
  else if (!e)
    l = 1;
  else {
    switch (typeof s.locale) {
      case "boolean":
        s.locale && (u = this.langLocale());
        break;
      case "string":
        u = s.locale;
        break;
    }
    return String(r).toLowerCase().localeCompare(String(e).toLowerCase(), u);
  }
  return (a === "top" && n === "desc" || a === "bottom" && n === "asc") && (l *= -1), l;
}
function og(r, e, t, i, o, n, s) {
  var a = window.DateTime || luxon.DateTime, l = s.format || "dd/MM/yyyy HH:mm:ss", u = s.alignEmptyValues, h = 0;
  if (typeof a < "u") {
    if (a.isDateTime(r) || (l === "iso" ? r = a.fromISO(String(r)) : r = a.fromFormat(String(r), l)), a.isDateTime(e) || (l === "iso" ? e = a.fromISO(String(e)) : e = a.fromFormat(String(e), l)), !r.isValid)
      h = e.isValid ? -1 : 0;
    else if (!e.isValid)
      h = 1;
    else
      return r - e;
    return (u === "top" && n === "desc" || u === "bottom" && n === "asc") && (h *= -1), h;
  } else
    console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
}
function b5(r, e, t, i, o, n, s) {
  return s.format || (s.format = "dd/MM/yyyy"), og.call(this, r, e, t, i, o, n, s);
}
function O5(r, e, t, i, o, n, s) {
  return s.format || (s.format = "HH:mm"), og.call(this, r, e, t, i, o, n, s);
}
function v5(r, e, t, i, o, n, s) {
  var a = r === !0 || r === "true" || r === "True" || r === 1 ? 1 : 0, l = e === !0 || e === "true" || e === "True" || e === 1 ? 1 : 0;
  return a - l;
}
function w5(r, e, t, i, o, n, s) {
  var a = s.type || "length", l = s.alignEmptyValues, u = 0;
  function h(c) {
    var d;
    switch (a) {
      case "length":
        d = c.length;
        break;
      case "sum":
        d = c.reduce(function(f, p) {
          return f + p;
        });
        break;
      case "max":
        d = Math.max.apply(null, c);
        break;
      case "min":
        d = Math.min.apply(null, c);
        break;
      case "avg":
        d = c.reduce(function(f, p) {
          return f + p;
        }) / c.length;
        break;
    }
    return d;
  }
  if (!Array.isArray(r))
    u = Array.isArray(e) ? -1 : 0;
  else if (!Array.isArray(e))
    u = 1;
  else
    return h(e) - h(r);
  return (l === "top" && n === "desc" || l === "bottom" && n === "asc") && (u *= -1), u;
}
function y5(r, e, t, i, o, n, s) {
  var a = typeof r > "u" ? 0 : 1, l = typeof e > "u" ? 0 : 1;
  return a - l;
}
function x5(r, e, t, i, o, n, s) {
  var a, l, u, h, c = 0, d, f = /(\d+)|(\D+)/g, p = /\d/, g = s.alignEmptyValues, b = 0;
  if (!r && r !== 0)
    b = !e && e !== 0 ? 0 : -1;
  else if (!e && e !== 0)
    b = 1;
  else {
    if (isFinite(r) && isFinite(e))
      return r - e;
    if (a = String(r).toLowerCase(), l = String(e).toLowerCase(), a === l)
      return 0;
    if (!(p.test(a) && p.test(l)))
      return a > l ? 1 : -1;
    for (a = a.match(f), l = l.match(f), d = a.length > l.length ? l.length : a.length; c < d; )
      if (u = a[c], h = l[c++], u !== h)
        return isFinite(u) && isFinite(h) ? (u.charAt(0) === "0" && (u = "." + u), h.charAt(0) === "0" && (h = "." + h), u - h) : u > h ? 1 : -1;
    return a.length > l.length;
  }
  return (g === "top" && n === "desc" || g === "bottom" && n === "asc") && (b *= -1), b;
}
var S5 = {
  number: g5,
  string: m5,
  date: b5,
  time: O5,
  datetime: og,
  boolean: v5,
  array: w5,
  exists: y5,
  alphanum: x5
};
class Po extends fe {
  constructor(e) {
    super(e), this.sortList = [], this.changed = !1, this.registerTableOption("sortMode", "local"), this.registerTableOption("initialSort", !1), this.registerTableOption("columnHeaderSortMulti", !0), this.registerTableOption("sortOrderReverse", !1), this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>"), this.registerTableOption("headerSortClickElement", "header"), this.registerColumnOption("sorter"), this.registerColumnOption("sorterParams"), this.registerColumnOption("headerSort", !0), this.registerColumnOption("headerSortStartingDir"), this.registerColumnOption("headerSortTristate");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.registerDataHandler(this.sort.bind(this), 20), this.registerTableFunction("setSort", this.userSetSort.bind(this)), this.registerTableFunction("getSorters", this.getSort.bind(this)), this.registerTableFunction("clearSort", this.clearSort.bind(this)), this.table.options.sortMode === "remote" && this.subscribe("data-params", this.remoteSortParams.bind(this));
  }
  tableBuilt() {
    this.table.options.initialSort && this.setSort(this.table.options.initialSort);
  }
  remoteSortParams(e, t, i, o) {
    var n = this.getSort();
    return n.forEach((s) => {
      delete s.column;
    }), o.sort = n, o;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetSort(e, t) {
    this.setSort(e, t), this.refreshSort();
  }
  clearSort() {
    this.clear(), this.refreshSort();
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //initialize column header for sorting
  initializeColumn(e) {
    var t = !1, i, o;
    switch (typeof e.definition.sorter) {
      case "string":
        Po.sorters[e.definition.sorter] ? t = Po.sorters[e.definition.sorter] : console.warn("Sort Error - No such sorter found: ", e.definition.sorter);
        break;
      case "function":
        t = e.definition.sorter;
        break;
    }
    if (e.modules.sort = {
      sorter: t,
      dir: "none",
      params: e.definition.sorterParams || {},
      startingDir: e.definition.headerSortStartingDir || "asc",
      tristate: e.definition.headerSortTristate
    }, e.definition.headerSort !== !1) {
      switch (i = e.getElement(), i.classList.add("tabulator-sortable"), o = document.createElement("div"), o.classList.add("tabulator-col-sorter"), this.table.options.headerSortClickElement) {
        case "icon":
          o.classList.add("tabulator-col-sorter-element");
          break;
        case "header":
          i.classList.add("tabulator-col-sorter-element");
          break;
        default:
          i.classList.add("tabulator-col-sorter-element");
          break;
      }
      switch (this.table.options.headerSortElement) {
        case "function":
          break;
        case "object":
          o.appendChild(this.table.options.headerSortElement);
          break;
        default:
          o.innerHTML = this.table.options.headerSortElement;
      }
      e.titleHolderElement.appendChild(o), e.modules.sort.element = o, this.setColumnHeaderSortIcon(e, "none"), (this.table.options.headerSortClickElement === "icon" ? o : i).addEventListener("click", (n) => {
        var s = "", a = [], l = !1;
        if (e.modules.sort) {
          if (e.modules.sort.tristate)
            e.modules.sort.dir == "none" ? s = e.modules.sort.startingDir : e.modules.sort.dir == e.modules.sort.startingDir ? s = e.modules.sort.dir == "asc" ? "desc" : "asc" : s = "none";
          else
            switch (e.modules.sort.dir) {
              case "asc":
                s = "desc";
                break;
              case "desc":
                s = "asc";
                break;
              default:
                s = e.modules.sort.startingDir;
            }
          this.table.options.columnHeaderSortMulti && (n.shiftKey || n.ctrlKey) ? (a = this.getSort(), l = a.findIndex((u) => u.field === e.getField()), l > -1 ? (a[l].dir = s, l = a.splice(l, 1)[0], s != "none" && a.push(l)) : s != "none" && a.push({ column: e, dir: s }), this.setSort(a)) : s == "none" ? this.clear() : this.setSort(e, s), this.refreshSort();
        }
      });
    }
  }
  refreshSort() {
    this.table.options.sortMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0);
  }
  //check if the sorters have changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //return current sorters
  getSort() {
    var e = this, t = [];
    return e.sortList.forEach(function(i) {
      i.column && t.push({ column: i.column.getComponent(), field: i.column.getField(), dir: i.dir });
    }), t;
  }
  //change sort list and trigger sort
  setSort(e, t) {
    var i = this, o = [];
    Array.isArray(e) || (e = [{ column: e, dir: t }]), e.forEach(function(n) {
      var s;
      s = i.table.columnManager.findColumn(n.column), s ? (n.column = s, o.push(n), i.changed = !0) : console.warn("Sort Warning - Sort field does not exist and is being ignored: ", n.column);
    }), i.sortList = o, this.dispatch("sort-changed");
  }
  //clear sorters
  clear() {
    this.setSort([]);
  }
  //find appropriate sorter for column
  findSorter(e) {
    var t = this.table.rowManager.activeRows[0], i = "string", o, n;
    if (t && (t = t.getData(), o = e.getField(), o))
      switch (n = e.getFieldValue(t), typeof n) {
        case "undefined":
          i = "string";
          break;
        case "boolean":
          i = "boolean";
          break;
        default:
          !isNaN(n) && n !== "" ? i = "number" : n.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) && (i = "alphanum");
          break;
      }
    return Po.sorters[i];
  }
  //work through sort list sorting data
  sort(e) {
    var t = this, i = this.table.options.sortOrderReverse ? t.sortList.slice().reverse() : t.sortList, o = [], n = [];
    return this.subscribedExternal("dataSorting") && this.dispatchExternal("dataSorting", t.getSort()), t.clearColumnHeaders(), this.table.options.sortMode !== "remote" ? (i.forEach(function(s, a) {
      var l;
      s.column && (l = s.column.modules.sort, l && (l.sorter || (l.sorter = t.findSorter(s.column)), s.params = typeof l.params == "function" ? l.params(s.column.getComponent(), s.dir) : l.params, o.push(s)), t.setColumnHeader(s.column, s.dir));
    }), o.length && t._sortItems(e, o)) : i.forEach(function(s, a) {
      t.setColumnHeader(s.column, s.dir);
    }), this.subscribedExternal("dataSorted") && (e.forEach((s) => {
      n.push(s.getComponent());
    }), this.dispatchExternal("dataSorted", t.getSort(), n)), e;
  }
  //clear sort arrows on columns
  clearColumnHeaders() {
    this.table.columnManager.getRealColumns().forEach((e) => {
      e.modules.sort && (e.modules.sort.dir = "none", e.getElement().setAttribute("aria-sort", "none"), this.setColumnHeaderSortIcon(e, "none"));
    });
  }
  //set the column header sort direction
  setColumnHeader(e, t) {
    e.modules.sort.dir = t, e.getElement().setAttribute("aria-sort", t === "asc" ? "ascending" : "descending"), this.setColumnHeaderSortIcon(e, t);
  }
  setColumnHeaderSortIcon(e, t) {
    var i = e.modules.sort.element, o;
    if (e.definition.headerSort && typeof this.table.options.headerSortElement == "function") {
      for (; i.firstChild; )
        i.removeChild(i.firstChild);
      o = this.table.options.headerSortElement.call(this.table, e.getComponent(), t), typeof o == "object" ? i.appendChild(o) : i.innerHTML = o;
    }
  }
  //sort each item in sort list
  _sortItems(e, t) {
    var i = t.length - 1;
    e.sort((o, n) => {
      for (var s, a = i; a >= 0; a--) {
        let l = t[a];
        if (s = this._sortRow(o, n, l.column, l.dir, l.params), s !== 0)
          break;
      }
      return s;
    });
  }
  //process individual rows for a sort function on active data
  _sortRow(e, t, i, o, n) {
    var s, a, l = o == "asc" ? e : t, u = o == "asc" ? t : e;
    return e = i.getFieldValue(l.getData()), t = i.getFieldValue(u.getData()), e = typeof e < "u" ? e : "", t = typeof t < "u" ? t : "", s = l.getComponent(), a = u.getComponent(), i.modules.sort.sorter.call(this, e, t, s, a, i.getComponent(), o, n);
  }
}
Po.moduleName = "sort";
Po.sorters = S5;
class MS extends fe {
  constructor(e) {
    super(e), this.tooltipSubscriber = null, this.headerSubscriber = null, this.timeout = null, this.popupInstance = null, this.registerTableOption("tooltipGenerationMode", void 0), this.registerTableOption("tooltipDelay", 300), this.registerColumnOption("tooltip"), this.registerColumnOption("headerTooltip");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheckMsg("tooltipGenerationMode", "This option is no longer needed as tooltips are always generated on hover now");
  }
  initializeColumn(e) {
    e.definition.headerTooltip && !this.headerSubscriber && (this.headerSubscriber = !0, this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip")), this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"))), e.definition.tooltip && !this.tooltipSubscriber && (this.tooltipSubscriber = !0, this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip")), this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip")));
  }
  mousemoveCheck(e, t, i) {
    var o = e === "tooltip" ? i.column.definition.tooltip : i.definition.headerTooltip;
    o && (this.clearPopup(), this.timeout = setTimeout(this.loadTooltip.bind(this, t, i, o), this.table.options.tooltipDelay));
  }
  mouseoutCheck(e, t, i) {
    this.popupInstance || this.clearPopup();
  }
  clearPopup(e, t, i) {
    clearTimeout(this.timeout), this.timeout = null, this.popupInstance && this.popupInstance.hide();
  }
  loadTooltip(e, t, i) {
    var o, n, s;
    function a(l) {
      n = l;
    }
    typeof i == "function" && (i = i(e, t.getComponent(), a)), i instanceof HTMLElement ? o = i : (o = document.createElement("div"), i === !0 && (t instanceof _a ? i = t.value : t.definition.field ? this.langBind("columns|" + t.definition.field, (l) => {
      o.innerHTML = i = l || t.definition.title;
    }) : i = t.definition.title), o.innerHTML = i), (i || i === 0 || i === !1) && (o.classList.add("tabulator-tooltip"), o.addEventListener("mousemove", (l) => l.preventDefault()), this.popupInstance = this.popup(o), typeof n == "function" && this.popupInstance.renderCallback(n), s = this.popupInstance.containerEventCoords(e), this.popupInstance.show(s.x + 15, s.y + 15).hideOnBlur(() => {
      this.dispatchExternal("TooltipClosed", t.getComponent()), this.popupInstance = null;
    }), this.dispatchExternal("TooltipOpened", t.getComponent()));
  }
}
MS.moduleName = "tooltip";
var C5 = {
  //is integer
  integer: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && Math.floor(e) === e);
  },
  //is float
  float: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && e % 1 !== 0);
  },
  //must be a number
  numeric: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : !isNaN(e);
  },
  //must be a string
  string: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : isNaN(e);
  },
  //maximum value
  max: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) <= t;
  },
  //minimum value
  min: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) >= t;
  },
  //starts with  value
  starts: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().startsWith(String(t).toLowerCase());
  },
  //ends with  value
  ends: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().endsWith(String(t).toLowerCase());
  },
  //minimum string length
  minLength: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length >= t;
  },
  //maximum string length
  maxLength: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length <= t;
  },
  //in provided value list
  in: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (typeof t == "string" && (t = t.split("|")), t.indexOf(e) > -1);
  },
  //must match provided regex
  regex: function(r, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var i = new RegExp(t);
    return i.test(e);
  },
  //value must be unique in this column
  unique: function(r, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var i = !0, o = r.getData(), n = r.getColumn()._getSelf();
    return this.table.rowManager.rows.forEach(function(s) {
      var a = s.getData();
      a !== o && e == n.getFieldValue(a) && (i = !1);
    }), i;
  },
  //must have a value
  required: function(r, e, t) {
    return e !== "" && e !== null && typeof e < "u";
  }
};
class Xa extends fe {
  constructor(e) {
    super(e), this.invalidCells = [], this.registerTableOption("validationMode", "blocking"), this.registerColumnOption("validator"), this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this)), this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this)), this.registerTableFunction("validate", this.userValidate.bind(this)), this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this)), this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this)), this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this)), this.registerComponentFunction("column", "validate", this.columnValidate.bind(this)), this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
  }
  initialize() {
    this.subscribe("cell-delete", this.clearValidation.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("edit-success", this.editValidate.bind(this)), this.subscribe("edit-editor-clear", this.editorClear.bind(this)), this.subscribe("edit-edited-clear", this.editedClear.bind(this));
  }
  ///////////////////////////////////
  ///////// Event Handling //////////
  ///////////////////////////////////
  editValidate(e, t, i) {
    var o = this.table.options.validationMode !== "manual" ? this.validate(e.column.modules.validate, e, t) : !0;
    return o !== !0 && setTimeout(() => {
      e.getElement().classList.add("tabulator-validation-fail"), this.dispatchExternal("validationFailed", e.getComponent(), t, o);
    }), o;
  }
  editorClear(e, t) {
    t && e.column.modules.validate && this.cellValidate(e), e.getElement().classList.remove("tabulator-validation-fail");
  }
  editedClear(e) {
    e.modules.validate && (e.modules.validate.invalid = !1);
  }
  ///////////////////////////////////
  ////////// Cell Functions /////////
  ///////////////////////////////////
  cellIsValid(e) {
    return e.modules.validate && e.modules.validate.invalid || !0;
  }
  cellValidate(e) {
    return this.validate(e.column.modules.validate, e, e.getValue());
  }
  ///////////////////////////////////
  ///////// Column Functions ////////
  ///////////////////////////////////
  columnValidate(e) {
    var t = [];
    return e.cells.forEach((i) => {
      this.cellValidate(i) !== !0 && t.push(i.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ////////// Row Functions //////////
  ///////////////////////////////////
  rowValidate(e) {
    var t = [];
    return e.cells.forEach((i) => {
      this.cellValidate(i) !== !0 && t.push(i.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userClearCellValidation(e) {
    e || (e = this.getInvalidCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.clearValidation(t._getSelf());
    });
  }
  userValidate(e) {
    var t = [];
    return this.table.rowManager.rows.forEach((i) => {
      i = i.getComponent();
      var o = i.validate();
      o !== !0 && (t = t.concat(o));
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.validator < "u" && this.initializeColumn(e);
  }
  //validate
  initializeColumn(e) {
    var t = this, i = [], o;
    e.definition.validator && (Array.isArray(e.definition.validator) ? e.definition.validator.forEach((n) => {
      o = t._extractValidator(n), o && i.push(o);
    }) : (o = this._extractValidator(e.definition.validator), o && i.push(o)), e.modules.validate = i.length ? i : !1);
  }
  _extractValidator(e) {
    var t, i, o;
    switch (typeof e) {
      case "string":
        return o = e.indexOf(":"), o > -1 ? (t = e.substring(0, o), i = e.substring(o + 1)) : t = e, this._buildValidator(t, i);
      case "function":
        return this._buildValidator(e);
      case "object":
        return this._buildValidator(e.type, e.parameters);
    }
  }
  _buildValidator(e, t) {
    var i = typeof e == "function" ? e : Xa.validators[e];
    return i ? {
      type: typeof e == "function" ? "function" : e,
      func: i,
      params: t
    } : (console.warn("Validator Setup Error - No matching validator found:", e), !1);
  }
  validate(e, t, i) {
    var o = this, n = [], s = this.invalidCells.indexOf(t);
    return e && e.forEach((a) => {
      a.func.call(o, t.getComponent(), i, a.params) || n.push({
        type: a.type,
        parameters: a.params
      });
    }), t.modules.validate || (t.modules.validate = {}), n.length ? (t.modules.validate.invalid = n, this.table.options.validationMode !== "manual" && t.getElement().classList.add("tabulator-validation-fail"), s == -1 && this.invalidCells.push(t)) : (t.modules.validate.invalid = !1, t.getElement().classList.remove("tabulator-validation-fail"), s > -1 && this.invalidCells.splice(s, 1)), n.length ? n : !0;
  }
  getInvalidCells() {
    var e = [];
    return this.invalidCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearValidation(e) {
    var t;
    e.modules.validate && e.modules.validate.invalid && (e.getElement().classList.remove("tabulator-validation-fail"), e.modules.validate.invalid = !1, t = this.invalidCells.indexOf(e), t > -1 && this.invalidCells.splice(t, 1));
  }
}
Xa.moduleName = "validate";
Xa.validators = C5;
var Q5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AccessorModule: Zn,
  AjaxModule: vi,
  ClipboardModule: Xo,
  ColumnCalcsModule: Rr,
  DataTreeModule: OS,
  DownloadModule: Ln,
  EditModule: Kn,
  ExportModule: vS,
  FilterModule: rr,
  FormatModule: Ft,
  FrozenColumnsModule: wS,
  FrozenRowsModule: yS,
  GroupRowsModule: xS,
  HistoryModule: Ao,
  HtmlTableImportModule: SS,
  ImportModule: Da,
  InteractionModule: CS,
  KeybindingsModule: Lr,
  MenuModule: QS,
  MoveColumnsModule: rg,
  MoveRowsModule: Th,
  MutatorModule: Wn,
  PageModule: Ma,
  PersistenceModule: $t,
  PopupModule: PS,
  PrintModule: kS,
  ReactiveDataModule: ES,
  ResizeColumnsModule: TS,
  ResizeRowsModule: $S,
  ResizeTableModule: RS,
  ResponsiveLayoutModule: _S,
  SelectRowModule: DS,
  SortModule: Po,
  TooltipModule: MS,
  ValidateModule: Xa
}), P5 = {
  debugEventsExternal: !1,
  //flag to console log events
  debugEventsInternal: !1,
  //flag to console log events
  debugInvalidOptions: !0,
  //allow toggling of invalid option warnings
  debugInvalidComponentFuncs: !0,
  //allow toggling of invalid component warnings
  debugInitialization: !0,
  //allow toggling of pre initialization function call warnings
  debugDeprecation: !0,
  //allow toggling of deprecation warnings
  height: !1,
  //height of tabulator
  minHeight: !1,
  //minimum height of tabulator
  maxHeight: !1,
  //maximum height of tabulator
  columnHeaderVertAlign: "top",
  //vertical alignment of column headers
  popupContainer: !1,
  columns: [],
  //store for colum header info
  columnDefaults: {},
  //store column default props
  data: !1,
  //default starting data
  autoColumns: !1,
  //build columns from data row structure
  autoColumnsDefinitions: !1,
  nestedFieldSeparator: ".",
  //separator for nested data
  footerElement: !1,
  //hold footer element
  index: "id",
  //filed for row index
  textDirection: "auto",
  addRowPos: "bottom",
  //position to insert blank rows, top|bottom
  headerVisible: !0,
  //hide header
  renderVertical: "virtual",
  renderHorizontal: "basic",
  renderVerticalBuffer: 0,
  // set virtual DOM buffer size
  scrollToRowPosition: "top",
  scrollToRowIfVisible: !0,
  scrollToColumnPosition: "left",
  scrollToColumnIfVisible: !0,
  rowFormatter: !1,
  rowFormatterPrint: null,
  rowFormatterClipboard: null,
  rowFormatterHtmlOutput: null,
  rowHeight: null,
  placeholder: !1,
  dataLoader: !0,
  dataLoaderLoading: !1,
  dataLoaderError: !1,
  dataLoaderErrorTimeout: 3e3,
  dataSendParams: {},
  dataReceiveParams: {}
};
class XS {
  constructor(e, t, i = {}) {
    this.table = e, this.msgType = t, this.registeredDefaults = Object.assign({}, i);
  }
  register(e, t) {
    this.registeredDefaults[e] = t;
  }
  generate(e, t = {}) {
    var i = Object.assign({}, this.registeredDefaults), o = this.table.options.debugInvalidOptions || t.debugInvalidOptions === !0;
    Object.assign(i, e);
    for (let n in t)
      i.hasOwnProperty(n) || (o && console.warn("Invalid " + this.msgType + " option:", n), i[n] = t.key);
    for (let n in i)
      n in t ? i[n] = t[n] : Array.isArray(i[n]) ? i[n] = Object.assign([], i[n]) : typeof i[n] == "object" && i[n] !== null ? i[n] = Object.assign({}, i[n]) : typeof i[n] > "u" && delete i[n];
    return i;
  }
}
class $h extends Nt {
  constructor(e) {
    super(e), this.elementVertical = e.rowManager.element, this.elementHorizontal = e.columnManager.element, this.tableElement = e.rowManager.tableElement, this.verticalFillMode = "fit";
  }
  ///////////////////////////////////
  /////// Internal Bindings /////////
  ///////////////////////////////////
  initialize() {
  }
  clearRows() {
  }
  clearColumns() {
  }
  reinitializeColumnWidths(e) {
  }
  renderRows() {
  }
  renderColumns() {
  }
  rerenderRows(e) {
    e && e();
  }
  rerenderColumns(e, t) {
  }
  renderRowCells(e) {
  }
  rerenderRowCells(e, t) {
  }
  scrollColumns(e, t) {
  }
  scrollRows(e, t) {
  }
  resize() {
  }
  scrollToRow(e) {
  }
  scrollToRowNearestTop(e) {
  }
  visibleRows(e) {
    return [];
  }
  ///////////////////////////////////
  //////// Helper Functions /////////
  ///////////////////////////////////
  rows() {
    return this.table.rowManager.getDisplayRows();
  }
  styleRow(e, t) {
    var i = e.getElement();
    t % 2 ? (i.classList.add("tabulator-row-even"), i.classList.remove("tabulator-row-odd")) : (i.classList.add("tabulator-row-odd"), i.classList.remove("tabulator-row-even"));
  }
  ///////////////////////////////////
  /////// External Triggers /////////
  /////// (DO NOT OVERRIDE) /////////
  ///////////////////////////////////
  clear() {
    this.clearRows(), this.clearColumns();
  }
  render() {
    this.renderRows(), this.renderColumns();
  }
  rerender(e) {
    this.rerenderRows(), this.rerenderColumns();
  }
  scrollToRowPosition(e, t, i) {
    var o = this.rows().indexOf(e), n = e.getElement(), s = 0;
    return new Promise((a, l) => {
      if (o > -1) {
        if (typeof i > "u" && (i = this.table.options.scrollToRowIfVisible), !i && _e.elVisible(n) && (s = _e.elOffset(n).top - _e.elOffset(this.elementVertical).top, s > 0 && s < this.elementVertical.clientHeight - n.offsetHeight))
          return a(), !1;
        switch (typeof t > "u" && (t = this.table.options.scrollToRowPosition), t === "nearest" && (t = this.scrollToRowNearestTop(e) ? "top" : "bottom"), this.scrollToRow(e), t) {
          case "middle":
          case "center":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop + (n.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - n.offsetTop) / 2 : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
            break;
          case "bottom":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - n.offsetTop) + n.offsetHeight : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + n.offsetHeight;
            break;
          case "top":
            this.elementVertical.scrollTop = n.offsetTop;
            break;
        }
        a();
      } else
        console.warn("Scroll Error - Row not visible"), l("Scroll Error - Row not visible");
    });
  }
}
class k5 extends $h {
  constructor(e) {
    super(e);
  }
  renderRowCells(e) {
    const t = document.createDocumentFragment();
    e.cells.forEach((i) => {
      t.appendChild(i.getElement());
    }), e.element.appendChild(t), e.cells.forEach((i) => {
      i.cellRendered();
    });
  }
  reinitializeColumnWidths(e) {
    e.forEach(function(t) {
      t.reinitializeWidth();
    });
  }
}
class E5 extends $h {
  constructor(e) {
    super(e), this.leftCol = 0, this.rightCol = 0, this.scrollLeft = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0, this.fitDataColAvg = 0, this.windowBuffer = 200, this.visibleRows = null, this.initialized = !1, this.isFitData = !1, this.columns = [];
  }
  initialize() {
    this.compatibilityCheck(), this.layoutCheck(), this.vertScrollListen();
  }
  compatibilityCheck() {
    this.options("layout") == "fitDataTable" && console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode"), this.options("responsiveLayout") && console.warn("Horizontal Virtual DOM is not compatible with responsive columns"), this.options("rtl") && console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
  }
  layoutCheck() {
    this.isFitData = this.options("layout").startsWith("fitData");
  }
  vertScrollListen() {
    this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this)), this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
  }
  clearVisRowCache() {
    this.visibleRows = null;
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  renderColumns(e, t) {
    this.dataChange();
  }
  scrollColumns(e, t) {
    this.scrollLeft != e && (this.scrollLeft = e, this.scroll(e - (this.vDomScrollPosLeft + this.windowBuffer)));
  }
  calcWindowBuffer() {
    var e = this.elementVertical.clientWidth;
    this.table.columnManager.columnsByIndex.forEach((t) => {
      if (t.visible) {
        var i = t.getWidth();
        i > e && (e = i);
      }
    }), this.windowBuffer = e * 2;
  }
  rerenderColumns(e, t) {
    var i = {
      cols: this.columns,
      leftCol: this.leftCol,
      rightCol: this.rightCol
    }, o = 0;
    e && !this.initialized || (this.clear(), this.calcWindowBuffer(), this.scrollLeft = this.elementVertical.scrollLeft, this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer, this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, this.table.columnManager.columnsByIndex.forEach((n) => {
      var s = {}, a;
      n.visible && (n.modules.frozen || (a = n.getWidth(), s.leftPos = o, s.rightPos = o + a, s.width = a, this.isFitData && (s.fitDataCheck = n.modules.vdomHoz ? n.modules.vdomHoz.fitDataCheck : !0), o + a > this.vDomScrollPosLeft && o < this.vDomScrollPosRight ? (this.leftCol == -1 && (this.leftCol = this.columns.length, this.vDomPadLeft = o), this.rightCol = this.columns.length) : this.leftCol !== -1 && (this.vDomPadRight += a), this.columns.push(n), n.modules.vdomHoz = s, o += a));
    }), this.tableElement.style.paddingLeft = this.vDomPadLeft + "px", this.tableElement.style.paddingRight = this.vDomPadRight + "px", this.initialized = !0, t || (!e || this.reinitChanged(i)) && this.reinitializeRows(), this.elementVertical.scrollLeft = this.scrollLeft);
  }
  renderRowCells(e) {
    if (this.initialized)
      this.initializeRow(e);
    else {
      const t = document.createDocumentFragment();
      e.cells.forEach((i) => {
        t.appendChild(i.getElement());
      }), e.element.appendChild(t), e.cells.forEach((i) => {
        i.cellRendered();
      });
    }
  }
  rerenderRowCells(e, t) {
    this.reinitializeRow(e, t);
  }
  reinitializeColumnWidths(e) {
    for (let t = this.leftCol; t <= this.rightCol; t++)
      this.columns[t].reinitializeWidth();
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  deinitialize() {
    this.initialized = !1;
  }
  clear() {
    this.columns = [], this.leftCol = -1, this.rightCol = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0;
  }
  dataChange() {
    var e = !1, t, i;
    if (this.isFitData) {
      if (this.table.columnManager.columnsByIndex.forEach((o) => {
        !o.definition.width && o.visible && (e = !0);
      }), e && this.table.rowManager.getDisplayRows().length && (this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, t = this.chain("rows-sample", [1], [], () => this.table.rowManager.getDisplayRows())[0], t)) {
        i = t.getElement(), t.generateCells(), this.tableElement.appendChild(i);
        for (let o = 0; o < t.cells.length; o++) {
          let n = t.cells[o];
          i.appendChild(n.getElement()), n.column.reinitializeWidth();
        }
        i.parentNode.removeChild(i), this.rerenderColumns(!1, !0);
      }
    } else
      this.options("layout") === "fitColumns" && (this.layoutRefresh(), this.rerenderColumns(!1, !0));
  }
  reinitChanged(e) {
    var t = !0;
    return e.cols.length !== this.columns.length || e.leftCol !== this.leftCol || e.rightCol !== this.rightCol ? !0 : (e.cols.forEach((i, o) => {
      i !== this.columns[o] && (t = !1);
    }), !t);
  }
  reinitializeRows() {
    var e = this.getVisibleRows(), t = this.table.rowManager.getRows().filter((i) => !e.includes(i));
    e.forEach((i) => {
      this.reinitializeRow(i, !0);
    }), t.forEach((i) => {
      i.deinitialize();
    });
  }
  getVisibleRows() {
    return this.visibleRows || (this.visibleRows = this.table.rowManager.getVisibleRows()), this.visibleRows;
  }
  scroll(e) {
    this.vDomScrollPosLeft += e, this.vDomScrollPosRight += e, Math.abs(e) > this.windowBuffer / 2 ? this.rerenderColumns() : e > 0 ? (this.addColRight(), this.removeColLeft()) : (this.addColLeft(), this.removeColRight());
  }
  colPositionAdjust(e, t, i) {
    for (let o = e; o < t; o++) {
      let n = this.columns[o];
      n.modules.vdomHoz.leftPos += i, n.modules.vdomHoz.rightPos += i;
    }
  }
  addColRight() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.rightCol + 1];
      i && i.modules.vdomHoz.leftPos <= this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((o) => {
        if (o.type !== "group") {
          var n = o.getCell(i);
          o.getElement().insertBefore(n.getElement(), o.getCell(this.columns[this.rightCol]).getElement().nextSibling), n.cellRendered();
        }
      }), this.fitDataColActualWidthCheck(i), this.rightCol++, this.getVisibleRows().forEach((o) => {
        o.type !== "group" && (o.modules.vdomHoz.rightCol = this.rightCol);
      }), this.rightCol >= this.columns.length - 1 ? this.vDomPadRight = 0 : this.vDomPadRight -= i.getWidth()) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  addColLeft() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.leftCol - 1];
      if (i)
        if (i.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
          e = !0, this.getVisibleRows().forEach((n) => {
            if (n.type !== "group") {
              var s = n.getCell(i);
              n.getElement().insertBefore(s.getElement(), n.getCell(this.columns[this.leftCol]).getElement()), s.cellRendered();
            }
          }), this.leftCol--, this.getVisibleRows().forEach((n) => {
            n.type !== "group" && (n.modules.vdomHoz.leftCol = this.leftCol);
          }), this.leftCol <= 0 ? this.vDomPadLeft = 0 : this.vDomPadLeft -= i.getWidth();
          let o = this.fitDataColActualWidthCheck(i);
          o && (this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + o, this.vDomPadRight -= o);
        } else
          t = !1;
      else
        t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  removeColRight() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.rightCol];
      i && i.modules.vdomHoz.leftPos > this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((o) => {
        if (o.type !== "group") {
          var n = o.getCell(i);
          try {
            o.getElement().removeChild(n.getElement());
          } catch (s) {
            console.warn("Could not removeColRight", s.message);
          }
        }
      }), this.vDomPadRight += i.getWidth(), this.rightCol--, this.getVisibleRows().forEach((o) => {
        o.type !== "group" && (o.modules.vdomHoz.rightCol = this.rightCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  removeColLeft() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.leftCol];
      i && i.modules.vdomHoz.rightPos < this.vDomScrollPosLeft ? (e = !0, this.getVisibleRows().forEach((o) => {
        if (o.type !== "group") {
          var n = o.getCell(i);
          try {
            o.getElement().removeChild(n.getElement());
          } catch (s) {
            console.warn("Could not removeColLeft", s.message);
          }
        }
      }), this.vDomPadLeft += i.getWidth(), this.leftCol++, this.getVisibleRows().forEach((o) => {
        o.type !== "group" && (o.modules.vdomHoz.leftCol = this.leftCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  fitDataColActualWidthCheck(e) {
    var t, i;
    return e.modules.vdomHoz.fitDataCheck && (e.reinitializeWidth(), t = e.getWidth(), i = t - e.modules.vdomHoz.width, i && (e.modules.vdomHoz.rightPos += i, e.modules.vdomHoz.width = t, this.colPositionAdjust(this.columns.indexOf(e) + 1, this.columns.length, i)), e.modules.vdomHoz.fitDataCheck = !1), i;
  }
  initializeRow(e) {
    if (e.type !== "group") {
      e.modules.vdomHoz = {
        leftCol: this.leftCol,
        rightCol: this.rightCol
      }, this.table.modules.frozenColumns && this.table.modules.frozenColumns.leftColumns.forEach((t) => {
        this.appendCell(e, t);
      });
      for (let t = this.leftCol; t <= this.rightCol; t++)
        this.appendCell(e, this.columns[t]);
      this.table.modules.frozenColumns && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
        this.appendCell(e, t);
      });
    }
  }
  appendCell(e, t) {
    if (t && t.visible) {
      let i = e.getCell(t);
      e.getElement().appendChild(i.getElement()), i.cellRendered();
    }
  }
  reinitializeRow(e, t) {
    if (e.type !== "group" && (t || !e.modules.vdomHoz || e.modules.vdomHoz.leftCol !== this.leftCol || e.modules.vdomHoz.rightCol !== this.rightCol)) {
      for (var i = e.getElement(); i.firstChild; )
        i.removeChild(i.firstChild);
      this.initializeRow(e);
    }
  }
}
class T5 extends Nt {
  constructor(e) {
    super(e), this.blockHozScrollEvent = !1, this.headersElement = null, this.contentsElement = null, this.element = null, this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.scrollLeft = 0, this.optionsList = new XS(this.table, "column definition", bS), this.redrawBlock = !1, this.redrawBlockUpdate = null, this.renderer = null;
  }
  ////////////// Setup Functions /////////////////
  initialize() {
    this.initializeRenderer(), this.headersElement = this.createHeadersElement(), this.contentsElement = this.createHeaderContentsElement(), this.element = this.createHeaderElement(), this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild), this.element.insertBefore(this.contentsElement, this.element.firstChild), this.initializeScrollWheelWatcher(), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
  }
  padVerticalScrollbar(e) {
    this.table.rtl ? this.headersElement.style.marginLeft = e + "px" : this.headersElement.style.marginRight = e + "px";
  }
  initializeRenderer() {
    var e, t = {
      virtual: E5,
      basic: k5
    };
    typeof this.table.options.renderHorizontal == "string" ? e = t[this.table.options.renderHorizontal] : e = this.table.options.renderHorizontal, e ? (this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize()) : console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
  }
  createHeadersElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-headers"), e.setAttribute("role", "row"), e;
  }
  createHeaderContentsElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header-contents"), e.setAttribute("role", "rowgroup"), e;
  }
  createHeaderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header"), e.setAttribute("role", "rowgroup"), this.table.options.headerVisible || e.classList.add("tabulator-header-hidden"), e;
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return containing contents element
  getContentsElement() {
    return this.contentsElement;
  }
  //return header containing element
  getHeadersElement() {
    return this.headersElement;
  }
  //scroll horizontally to match table body
  scrollHorizontal(e) {
    this.contentsElement.scrollLeft = e, this.scrollLeft = e, this.renderer.scrollColumns(e);
  }
  initializeScrollWheelWatcher() {
    this.contentsElement.addEventListener("wheel", (e) => {
      var t;
      e.deltaX && (t = this.contentsElement.scrollLeft + e.deltaX, this.table.rowManager.scrollHorizontal(t), this.table.columnManager.scrollHorizontal(t));
    });
  }
  ///////////// Column Setup Functions /////////////
  generateColumnsFromRowData(e) {
    var t = [], i = this.table.options.autoColumnsDefinitions, o, n;
    if (e && e.length) {
      o = e[0];
      for (var s in o) {
        let a = {
          field: s,
          title: s
        }, l = o[s];
        switch (typeof l) {
          case "undefined":
            n = "string";
            break;
          case "boolean":
            n = "boolean";
            break;
          case "object":
            Array.isArray(l) ? n = "array" : n = "string";
            break;
          default:
            !isNaN(l) && l !== "" ? n = "number" : l.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) ? n = "alphanum" : n = "string";
            break;
        }
        a.sorter = n, t.push(a);
      }
      if (i)
        switch (typeof i) {
          case "function":
            this.table.options.columns = i.call(this.table, t);
            break;
          case "object":
            Array.isArray(i) ? t.forEach((a) => {
              var l = i.find((u) => u.field === a.field);
              l && Object.assign(a, l);
            }) : t.forEach((a) => {
              i[a.field] && Object.assign(a, i[a.field]);
            }), this.table.options.columns = t;
            break;
        }
      else
        this.table.options.columns = t;
      this.setColumns(this.table.options.columns);
    }
  }
  setColumns(e, t) {
    for (; this.headersElement.firstChild; )
      this.headersElement.removeChild(this.headersElement.firstChild);
    this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.dispatch("columns-loading"), e.forEach((i, o) => {
      this._addColumn(i);
    }), this._reIndexColumns(), this.dispatch("columns-loaded"), this.rerenderColumns(!1, !0), this.redraw(!0);
  }
  _addColumn(e, t, i) {
    var o = new Fi(e, this), n = o.getElement(), s = i && this.findColumnIndex(i);
    if (i && s > -1) {
      var a = i.getTopColumn(), l = this.columns.indexOf(a), u = a.getElement();
      t ? (this.columns.splice(l, 0, o), u.parentNode.insertBefore(n, u)) : (this.columns.splice(l + 1, 0, o), u.parentNode.insertBefore(n, u.nextSibling));
    } else
      t ? (this.columns.unshift(o), this.headersElement.insertBefore(o.getElement(), this.headersElement.firstChild)) : (this.columns.push(o), this.headersElement.appendChild(o.getElement()));
    return o.columnRendered(), o;
  }
  registerColumnField(e) {
    e.definition.field && (this.columnsByField[e.definition.field] = e);
  }
  registerColumnPosition(e) {
    this.columnsByIndex.push(e);
  }
  _reIndexColumns() {
    this.columnsByIndex = [], this.columns.forEach(function(e) {
      e.reRegisterPosition();
    });
  }
  //ensure column headers take up the correct amount of space in column groups
  verticalAlignHeaders() {
    var e = 0;
    this.redrawBlock || (this.headersElement.style.height = "", this.columns.forEach((t) => {
      t.clearVerticalAlign();
    }), this.columns.forEach((t) => {
      var i = t.getHeight();
      i > e && (e = i);
    }), this.headersElement.style.height = e + "px", this.columns.forEach((t) => {
      t.verticalAlign(this.table.options.columnHeaderVertAlign, e);
    }), this.table.rowManager.adjustTableSize());
  }
  //////////////// Column Details /////////////////
  findColumn(e) {
    var t;
    if (typeof e == "object") {
      if (e instanceof Fi)
        return e;
      if (e instanceof mS)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return t = [], this.columns.forEach((o) => {
          t.push(o), t = t.concat(o.getColumns(!0));
        }), t.find((o) => o.element === e) || !1;
    } else
      return this.columnsByField[e] || !1;
    return !1;
  }
  getColumnByField(e) {
    return this.columnsByField[e];
  }
  getColumnsByFieldRoot(e) {
    var t = [];
    return Object.keys(this.columnsByField).forEach((i) => {
      var o = i.split(".")[0];
      o === e && t.push(this.columnsByField[i]);
    }), t;
  }
  getColumnByIndex(e) {
    return this.columnsByIndex[e];
  }
  getFirstVisibleColumn() {
    var e = this.columnsByIndex.findIndex((t) => t.visible);
    return e > -1 ? this.columnsByIndex[e] : !1;
  }
  getColumns() {
    return this.columns;
  }
  findColumnIndex(e) {
    return this.columnsByIndex.findIndex((t) => e === t);
  }
  //return all columns that are not groups
  getRealColumns() {
    return this.columnsByIndex;
  }
  //traverse across columns and call action
  traverse(e) {
    this.columnsByIndex.forEach((t, i) => {
      e(t, i);
    });
  }
  //get definitions of actual columns
  getDefinitions(e) {
    var t = [];
    return this.columnsByIndex.forEach((i) => {
      (!e || e && i.visible) && t.push(i.getDefinition());
    }), t;
  }
  //get full nested definition tree
  getDefinitionTree() {
    var e = [];
    return this.columns.forEach((t) => {
      e.push(t.getDefinition(!0));
    }), e;
  }
  getComponents(e) {
    var t = [], i = e ? this.columns : this.columnsByIndex;
    return i.forEach((o) => {
      t.push(o.getComponent());
    }), t;
  }
  getWidth() {
    var e = 0;
    return this.columnsByIndex.forEach((t) => {
      t.visible && (e += t.getWidth());
    }), e;
  }
  moveColumn(e, t, i) {
    t.element.parentNode.insertBefore(e.element, t.element), i && t.element.parentNode.insertBefore(t.element, e.element), this.moveColumnActual(e, t, i), this.verticalAlignHeaders(), this.table.rowManager.reinitialize();
  }
  moveColumnActual(e, t, i) {
    e.parent.isGroup ? this._moveColumnInArray(e.parent.columns, e, t, i) : this._moveColumnInArray(this.columns, e, t, i), this._moveColumnInArray(this.columnsByIndex, e, t, i, !0), this.rerenderColumns(!0), this.dispatch("column-moved", e, t, i), this.subscribedExternal("columnMoved") && this.dispatchExternal("columnMoved", e.getComponent(), this.table.columnManager.getComponents());
  }
  _moveColumnInArray(e, t, i, o, n) {
    var s = e.indexOf(t), a, l = [];
    s > -1 && (e.splice(s, 1), a = e.indexOf(i), a > -1 ? o && (a = a + 1) : a = s, e.splice(a, 0, t), n && (l = this.chain("column-moving-rows", [t, i, o], null, []) || [], l = l.concat(this.table.rowManager.rows), l.forEach(function(u) {
      if (u.cells.length) {
        var h = u.cells.splice(s, 1)[0];
        u.cells.splice(a, 0, h);
      }
    })));
  }
  scrollToColumn(e, t, i) {
    var o = 0, n = e.getLeftOffset(), s = 0, a = e.getElement();
    return new Promise((l, u) => {
      if (typeof t > "u" && (t = this.table.options.scrollToColumnPosition), typeof i > "u" && (i = this.table.options.scrollToColumnIfVisible), e.visible) {
        switch (t) {
          case "middle":
          case "center":
            s = -this.element.clientWidth / 2;
            break;
          case "right":
            s = a.clientWidth - this.headersElement.clientWidth;
            break;
        }
        if (!i && n > 0 && n + a.offsetWidth < this.element.clientWidth)
          return !1;
        o = n + s, o = Math.max(Math.min(o, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0), this.table.rowManager.scrollHorizontal(o), this.scrollHorizontal(o), l();
      } else
        console.warn("Scroll Error - Column not visible"), u("Scroll Error - Column not visible");
    });
  }
  //////////////// Cell Management /////////////////
  generateCells(e) {
    var t = [];
    return this.columnsByIndex.forEach((i) => {
      t.push(i.generateCell(e));
    }), t;
  }
  //////////////// Column Management /////////////////
  getFlexBaseWidth() {
    var e = this.table.element.clientWidth, t = 0;
    return this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (e -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), this.columnsByIndex.forEach(function(i) {
      var o, n, s;
      i.visible && (o = i.definition.width || 0, n = parseInt(i.minWidth), typeof o == "string" ? o.indexOf("%") > -1 ? s = e / 100 * parseInt(o) : s = parseInt(o) : s = o, t += s > n ? s : n);
    }), t;
  }
  addColumn(e, t, i) {
    return new Promise((o, n) => {
      var s = this._addColumn(e, t, i);
      this._reIndexColumns(), this.dispatch("column-add", e, t, i), this.layoutMode() != "fitColumns" && s.reinitializeWidth(), this.redraw(!0), this.table.rowManager.reinitialize(), this.rerenderColumns(), o(s);
    });
  }
  //remove column from system
  deregisterColumn(e) {
    var t = e.getField(), i;
    t && delete this.columnsByField[t], i = this.columnsByIndex.indexOf(e), i > -1 && this.columnsByIndex.splice(i, 1), i = this.columns.indexOf(e), i > -1 && this.columns.splice(i, 1), this.verticalAlignHeaders(), this.redraw();
  }
  rerenderColumns(e, t) {
    this.redrawBlock ? (e === !1 || e === !0 && this.redrawBlockUpdate === null) && (this.redrawBlockUpdate = e) : this.renderer.rerenderColumns(e, t);
  }
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockUpdate = null;
  }
  restoreRedraw() {
    this.redrawBlock = !1, this.verticalAlignHeaders(), this.renderer.rerenderColumns(this.redrawBlockUpdate);
  }
  //redraw columns
  redraw(e) {
    _e.elVisible(this.element) && this.verticalAlignHeaders(), e && (this.table.rowManager.resetScroll(), this.table.rowManager.reinitialize()), this.confirm("table-redrawing", e) || this.layoutRefresh(e), this.dispatch("table-redraw", e), this.table.footerManager.redraw();
  }
}
class $5 extends $h {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0;
  }
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.scrollTop = 0, e.scrollLeft = 0, e.style.minWidth = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "";
  }
  renderRows() {
    var e = this.tableElement, t = !0, i = document.createDocumentFragment();
    this.rows().forEach((o, n) => {
      this.styleRow(o, n), o.initialize(!0), o.type !== "group" && (t = !1), i.appendChild(o.getElement());
    }), e.appendChild(i), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
  rerenderRows(e) {
    this.clearRows(), e && e(), this.renderRows();
  }
  scrollToRowNearestTop(e) {
    var t = _e.elOffset(e.getElement()).top;
    return !(Math.abs(this.elementVertical.scrollTop - t) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - t));
  }
  scrollToRow(e) {
    var t = e.getElement();
    this.elementVertical.scrollTop = _e.elOffset(t).top - _e.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
  }
  visibleRows(e) {
    return this.rows();
  }
}
class R5 extends $h {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.vDomRowHeight = 20, this.vDomTop = 0, this.vDomBottom = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomMaxRenderChain = 90, this.vDomWindowBuffer = 0, this.vDomWindowMinTotalRows = 20, this.vDomWindowMinMarginRows = 5, this.vDomTopNewRows = [], this.vDomBottomNewRows = [];
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.style.paddingTop = "", e.style.paddingBottom = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "", this.elementVertical.scrollTop = 0, this.elementVertical.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0, this.vDomTop = 0, this.vDomBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0;
  }
  renderRows() {
    this._virtualRenderFill();
  }
  rerenderRows(e) {
    for (var t = this.elementVertical.scrollTop, i = !1, o = !1, n = this.table.rowManager.scrollLeft, s = this.rows(), a = this.vDomTop; a <= this.vDomBottom; a++)
      if (s[a]) {
        var l = t - s[a].getElement().offsetTop;
        if (o === !1 || Math.abs(l) < o)
          o = l, i = a;
        else
          break;
      }
    s.forEach((u) => {
      u.deinitializeHeight();
    }), e && e(), this.rows().length ? this._virtualRenderFill(i === !1 ? this.rows.length - 1 : i, !0, o || 0) : (this.clear(), this.table.rowManager.tableEmpty()), this.scrollColumns(n);
  }
  scrollColumns(e) {
    this.table.rowManager.scrollHorizontal(e);
  }
  scrollRows(e, t) {
    var i = e - this.vDomScrollPosTop, o = e - this.vDomScrollPosBottom, n = this.vDomWindowBuffer * 2, s = this.rows();
    if (this.scrollTop = e, -i > n || o > n) {
      var a = this.table.rowManager.scrollLeft;
      this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * s.length)), this.scrollColumns(a);
    } else
      t ? (i < 0 && this._addTopRow(s, -i), o < 0 && (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer ? this._removeBottomRow(s, -o) : this.vDomScrollPosBottom = this.scrollTop)) : (o >= 0 && this._addBottomRow(s, o), i >= 0 && (this.scrollTop > this.vDomWindowBuffer ? this._removeTopRow(s, i) : this.vDomScrollPosTop = this.scrollTop));
  }
  resize() {
    this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
  }
  scrollToRowNearestTop(e) {
    var t = this.rows().indexOf(e);
    return !(Math.abs(this.vDomTop - t) > Math.abs(this.vDomBottom - t));
  }
  scrollToRow(e) {
    var t = this.rows().indexOf(e);
    t > -1 && this._virtualRenderFill(t, !0);
  }
  visibleRows(e) {
    var t = this.elementVertical.scrollTop, i = this.elementVertical.clientHeight + t, o = !1, n = 0, s = 0, a = this.rows();
    if (e)
      n = this.vDomTop, s = this.vDomBottom;
    else
      for (var l = this.vDomTop; l <= this.vDomBottom; l++)
        if (a[l])
          if (o)
            if (i - a[l].getElement().offsetTop >= 0)
              s = l;
            else
              break;
          else if (t - a[l].getElement().offsetTop >= 0)
            n = l;
          else if (o = !0, i - a[l].getElement().offsetTop >= 0)
            s = l;
          else
            break;
    return a.slice(n, s + 1);
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  //full virtual render
  _virtualRenderFill(e, t, i) {
    var o = this.tableElement, n = this.elementVertical, s = 0, a = 0, l = 0, u = 0, h = 0, c = 0, d = this.rows(), f = d.length, p = 0, g, b, m = [], v = 0, S = 0, y = this.table.rowManager.fixedHeight, x = this.elementVertical.clientHeight, P = this.table.options.rowHeight, k = !0;
    if (e = e || 0, i = i || 0, !e)
      this.clear();
    else {
      for (; o.firstChild; )
        o.removeChild(o.firstChild);
      u = (f - e + 1) * this.vDomRowHeight, u < x && (e -= Math.ceil((x - u) / this.vDomRowHeight), e < 0 && (e = 0)), s = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), e), e -= s;
    }
    if (f && _e.elVisible(this.elementVertical)) {
      for (this.vDomTop = e, this.vDomBottom = e - 1, y || this.table.options.maxHeight ? (P && (S = x / P + this.vDomWindowBuffer / P), S = Math.max(this.vDomWindowMinTotalRows, Math.ceil(S))) : S = f; (S == f || a <= x + this.vDomWindowBuffer || v < this.vDomWindowMinTotalRows) && this.vDomBottom < f - 1; ) {
        for (m = [], b = document.createDocumentFragment(), c = 0; c < S && this.vDomBottom < f - 1; )
          p = this.vDomBottom + 1, g = d[p], this.styleRow(g, p), g.initialize(), !g.heightInitialized && !this.table.options.rowHeight && g.clearCellHeight(), b.appendChild(g.getElement()), m.push(g), this.vDomBottom++, c++;
        if (!m.length)
          break;
        o.appendChild(b), m.forEach((C) => {
          C.heightInitialized || C.calcHeight(!0);
        }), m.forEach((C) => {
          C.heightInitialized || C.setCellHeight();
        }), m.forEach((C) => {
          l = C.getHeight(), v < s ? h += l : a += l, l > this.vDomWindowBuffer && (this.vDomWindowBuffer = l * 2), v++;
        }), k = this.table.rowManager.adjustTableSize(), x = this.elementVertical.clientHeight, k && (y || this.table.options.maxHeight) && (P = a / v, S = Math.max(this.vDomWindowMinTotalRows, Math.ceil(x / P + this.vDomWindowBuffer / P)));
      }
      e ? (this.vDomTopPad = t ? this.vDomRowHeight * this.vDomTop + i : this.scrollTop - h, this.vDomBottomPad = this.vDomBottom == f - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - a - h, 0)) : (this.vDomTopPad = 0, this.vDomRowHeight = Math.floor((a + h) / v), this.vDomBottomPad = this.vDomRowHeight * (f - this.vDomBottom - 1), this.vDomScrollHeight = h + a + this.vDomBottomPad - x), o.style.paddingTop = this.vDomTopPad + "px", o.style.paddingBottom = this.vDomBottomPad + "px", t && (this.scrollTop = this.vDomTopPad + h + i - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - x : 0)), this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - x), this.elementVertical.scrollWidth > this.elementVertical.clientWidth && t && (this.scrollTop += this.elementVertical.offsetHeight - x), this.vDomScrollPosTop = this.scrollTop, this.vDomScrollPosBottom = this.scrollTop, n.scrollTop = this.scrollTop, this.dispatch("render-virtual-fill");
    }
  }
  _addTopRow(e, t) {
    for (var i = this.tableElement, o = [], n = 0, s = this.vDomTop - 1, a = 0, l = !0; l; )
      if (this.vDomTop) {
        let u = e[s], h, c;
        u && a < this.vDomMaxRenderChain ? (h = u.getHeight() || this.vDomRowHeight, c = u.initialized, t >= h ? (this.styleRow(u, s), i.insertBefore(u.getElement(), i.firstChild), (!u.initialized || !u.heightInitialized) && o.push(u), u.initialize(), c || (h = u.getElement().offsetHeight, h > this.vDomWindowBuffer && (this.vDomWindowBuffer = h * 2)), t -= h, n += h, this.vDomTop--, s--, a++) : l = !1) : l = !1;
      } else
        l = !1;
    for (let u of o)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(o), n && (this.vDomTopPad -= n, this.vDomTopPad < 0 && (this.vDomTopPad = s * this.vDomRowHeight), s < 1 && (this.vDomTopPad = 0), i.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop -= n);
  }
  _removeTopRow(e, t) {
    for (var i = [], o = 0, n = 0, s = !0; s; ) {
      let a = e[this.vDomTop], l;
      a && n < this.vDomMaxRenderChain ? (l = a.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomTop++, t -= l, o += l, i.push(a), n++) : s = !1) : s = !1;
    }
    for (let a of i) {
      let l = a.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    o && (this.vDomTopPad += o, this.tableElement.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop += this.vDomTop ? o : o + this.vDomWindowBuffer);
  }
  _addBottomRow(e, t) {
    for (var i = this.tableElement, o = [], n = 0, s = this.vDomBottom + 1, a = 0, l = !0; l; ) {
      let u = e[s], h, c;
      u && a < this.vDomMaxRenderChain ? (h = u.getHeight() || this.vDomRowHeight, c = u.initialized, t >= h ? (this.styleRow(u, s), i.appendChild(u.getElement()), (!u.initialized || !u.heightInitialized) && o.push(u), u.initialize(), c || (h = u.getElement().offsetHeight, h > this.vDomWindowBuffer && (this.vDomWindowBuffer = h * 2)), t -= h, n += h, this.vDomBottom++, s++, a++) : l = !1) : l = !1;
    }
    for (let u of o)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(o), n && (this.vDomBottomPad -= n, (this.vDomBottomPad < 0 || s == e.length - 1) && (this.vDomBottomPad = 0), i.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom += n);
  }
  _removeBottomRow(e, t) {
    for (var i = [], o = 0, n = 0, s = !0; s; ) {
      let a = e[this.vDomBottom], l;
      a && n < this.vDomMaxRenderChain ? (l = a.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomBottom--, t -= l, o += l, i.push(a), n++) : s = !1) : s = !1;
    }
    for (let a of i) {
      let l = a.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    o && (this.vDomBottomPad += o, this.vDomBottomPad < 0 && (this.vDomBottomPad = 0), this.tableElement.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom -= o);
  }
  _quickNormalizeRowHeight(e) {
    for (let t of e)
      t.calcHeight();
    for (let t of e)
      t.setCellHeight();
  }
}
class _5 extends Nt {
  constructor(e) {
    super(e), this.element = this.createHolderElement(), this.tableElement = this.createTableElement(), this.heightFixer = this.createTableElement(), this.placeholder = null, this.placeholderContents = null, this.firstRender = !1, this.renderMode = "virtual", this.fixedHeight = !1, this.rows = [], this.activeRowsPipeline = [], this.activeRows = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0, this.scrollTop = 0, this.scrollLeft = 0, this.redrawBlock = !1, this.redrawBlockRestoreConfig = !1, this.redrawBlockRenderInPosition = !1, this.dataPipeline = [], this.displayPipeline = [], this.scrollbarWidth = 0, this.renderer = null;
  }
  //////////////// Setup Functions /////////////////
  createHolderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-tableholder"), e.setAttribute("tabindex", 0), e;
  }
  createTableElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-table"), e.setAttribute("role", "rowgroup"), e;
  }
  initializePlaceholder() {
    var e = this.table.options.placeholder;
    if (typeof e == "function" && (e = e.call(this.table)), e = this.chain("placeholder", [e], e, e) || e, e) {
      let t = document.createElement("div");
      if (t.classList.add("tabulator-placeholder"), typeof e == "string") {
        let i = document.createElement("div");
        i.classList.add("tabulator-placeholder-contents"), i.innerHTML = e, t.appendChild(i), this.placeholderContents = i;
      } else
        typeof HTMLElement < "u" && e instanceof HTMLElement ? (t.appendChild(e), this.placeholderContents = e) : (console.warn("Invalid placeholder provided, must be string or HTML Element", e), this.el = null);
      this.placeholder = t;
    }
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return table element
  getTableElement() {
    return this.tableElement;
  }
  initialize() {
    this.initializePlaceholder(), this.initializeRenderer(), this.element.appendChild(this.tableElement), this.firstRender = !0, this.element.addEventListener("scroll", () => {
      var e = this.element.scrollLeft, t = this.scrollLeft > e, i = this.element.scrollTop, o = this.scrollTop > i;
      this.scrollLeft != e && (this.scrollLeft = e, this.dispatch("scroll-horizontal", e, t), this.dispatchExternal("scrollHorizontal", e, t), this._positionPlaceholder()), this.scrollTop != i && (this.scrollTop = i, this.renderer.scrollRows(i, o), this.dispatch("scroll-vertical", i, o), this.dispatchExternal("scrollVertical", i, o));
    });
  }
  ////////////////// Row Manipulation //////////////////
  findRow(e) {
    if (typeof e == "object") {
      if (e instanceof Ct)
        return e;
      if (e instanceof kh)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return this.rows.find((i) => i.getElement() === e) || !1;
      if (e === null)
        return !1;
    } else
      return typeof e > "u" ? !1 : this.rows.find((i) => i.data[this.table.options.index] == e) || !1;
    return !1;
  }
  getRowFromDataObject(e) {
    var t = this.rows.find((i) => i.data === e);
    return t || !1;
  }
  getRowFromPosition(e) {
    return this.getDisplayRows().find((t) => t.getPosition() === e && t.isDisplayed());
  }
  scrollToRow(e, t, i) {
    return this.renderer.scrollToRowPosition(e, t, i);
  }
  ////////////////// Data Handling //////////////////
  setData(e, t, i) {
    return new Promise((o, n) => {
      t && this.getDisplayRows().length ? this.table.options.pagination ? this._setDataActual(e, !0) : this.reRenderInPosition(() => {
        this._setDataActual(e);
      }) : (this.table.options.autoColumns && i && this.table.initialized && this.table.columnManager.generateColumnsFromRowData(e), this.resetScroll(), this._setDataActual(e)), o();
    });
  }
  _setDataActual(e, t) {
    this.dispatchExternal("dataProcessing", e), this._wipeElements(), Array.isArray(e) ? (this.dispatch("data-processing", e), e.forEach((i, o) => {
      if (i && typeof i == "object") {
        var n = new Ct(i, this);
        this.rows.push(n);
      } else
        console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", i);
    }), this.refreshActiveData(!1, !1, t), this.dispatch("data-processed", e), this.dispatchExternal("dataProcessed", e)) : console.error(`Data Loading Error - Unable to process data due to invalid data type 
Expecting: array 
Received: `, typeof e, `
Data:     `, e);
  }
  _wipeElements() {
    this.dispatch("rows-wipe"), this.destroy(), this.adjustTableSize(), this.dispatch("rows-wiped");
  }
  destroy() {
    this.rows.forEach((e) => {
      e.wipe();
    }), this.rows = [], this.activeRows = [], this.activeRowsPipeline = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0;
  }
  deleteRow(e, t) {
    var i = this.rows.indexOf(e), o = this.activeRows.indexOf(e);
    o > -1 && this.activeRows.splice(o, 1), i > -1 && this.rows.splice(i, 1), this.setActiveRows(this.activeRows), this.displayRowIterator((n) => {
      var s = n.indexOf(e);
      s > -1 && n.splice(s, 1);
    }), t || this.reRenderInPosition(), this.regenerateRowPositions(), this.dispatchExternal("rowDeleted", e.getComponent()), this.displayRowsCount || this.tableEmpty(), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.getData());
  }
  addRow(e, t, i, o) {
    var n = this.addRowActual(e, t, i, o);
    return n;
  }
  //add multiple rows
  addRows(e, t, i, o) {
    var n = [];
    return new Promise((s, a) => {
      t = this.findAddRowPos(t), Array.isArray(e) || (e = [e]), (typeof i > "u" && t || typeof i < "u" && !t) && e.reverse(), e.forEach((l, u) => {
        var h = this.addRow(l, t, i, !0);
        n.push(h), this.dispatch("row-added", h, l, t, i);
      }), this.refreshActiveData(o ? "displayPipeline" : !1, !1, !0), this.regenerateRowPositions(), n.length && this._clearPlaceholder(), s(n);
    });
  }
  findAddRowPos(e) {
    return typeof e > "u" && (e = this.table.options.addRowPos), e === "pos" && (e = !0), e === "bottom" && (e = !1), e;
  }
  addRowActual(e, t, i, o) {
    var n = e instanceof Ct ? e : new Ct(e || {}, this), s = this.findAddRowPos(t), a = -1, l, u;
    return i || (u = this.chain("row-adding-position", [n, s], null, { index: i, top: s }), i = u.index, s = u.top), typeof i < "u" && (i = this.findRow(i)), i = this.chain("row-adding-index", [n, i, s], null, i), i && (a = this.rows.indexOf(i)), i && a > -1 ? (l = this.activeRows.indexOf(i), this.displayRowIterator(function(h) {
      var c = h.indexOf(i);
      c > -1 && h.splice(s ? c : c + 1, 0, n);
    }), l > -1 && this.activeRows.splice(s ? l : l + 1, 0, n), this.rows.splice(s ? a : a + 1, 0, n)) : s ? (this.displayRowIterator(function(h) {
      h.unshift(n);
    }), this.activeRows.unshift(n), this.rows.unshift(n)) : (this.displayRowIterator(function(h) {
      h.push(n);
    }), this.activeRows.push(n), this.rows.push(n)), this.setActiveRows(this.activeRows), this.dispatchExternal("rowAdded", n.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), o || this.reRenderInPosition(), n;
  }
  moveRow(e, t, i) {
    this.dispatch("row-move", e, t, i), this.moveRowActual(e, t, i), this.regenerateRowPositions(), this.dispatch("row-moved", e, t, i), this.dispatchExternal("rowMoved", e.getComponent());
  }
  moveRowActual(e, t, i) {
    this.moveRowInArray(this.rows, e, t, i), this.moveRowInArray(this.activeRows, e, t, i), this.displayRowIterator((o) => {
      this.moveRowInArray(o, e, t, i);
    }), this.dispatch("row-moving", e, t, i);
  }
  moveRowInArray(e, t, i, o) {
    var n, s, a, l;
    if (t !== i && (n = e.indexOf(t), n > -1 && (e.splice(n, 1), s = e.indexOf(i), s > -1 ? o ? e.splice(s + 1, 0, t) : e.splice(s, 0, t) : e.splice(n, 0, t)), e === this.getDisplayRows())) {
      a = n < s ? n : s, l = s > n ? s : n + 1;
      for (let u = a; u <= l; u++)
        e[u] && this.styleRow(e[u], u);
    }
  }
  clearData() {
    this.setData([]);
  }
  getRowIndex(e) {
    return this.findRowIndex(e, this.rows);
  }
  getDisplayRowIndex(e) {
    var t = this.getDisplayRows().indexOf(e);
    return t > -1 ? t : !1;
  }
  nextDisplayRow(e, t) {
    var i = this.getDisplayRowIndex(e), o = !1;
    return i !== !1 && i < this.displayRowsCount - 1 && (o = this.getDisplayRows()[i + 1]), o && (!(o instanceof Ct) || o.type != "row") ? this.nextDisplayRow(o, t) : o;
  }
  prevDisplayRow(e, t) {
    var i = this.getDisplayRowIndex(e), o = !1;
    return i && (o = this.getDisplayRows()[i - 1]), t && o && (!(o instanceof Ct) || o.type != "row") ? this.prevDisplayRow(o, t) : o;
  }
  findRowIndex(e, t) {
    var i;
    return e = this.findRow(e), e && (i = t.indexOf(e), i > -1) ? i : !1;
  }
  getData(e, t) {
    var i = [], o = this.getRows(e);
    return o.forEach(function(n) {
      n.type == "row" && i.push(n.getData(t || "data"));
    }), i;
  }
  getComponents(e) {
    var t = [], i = this.getRows(e);
    return i.forEach(function(o) {
      t.push(o.getComponent());
    }), t;
  }
  getDataCount(e) {
    var t = this.getRows(e);
    return t.length;
  }
  scrollHorizontal(e) {
    this.scrollLeft = e, this.element.scrollLeft = e, this.dispatch("scroll-horizontal", e);
  }
  registerDataPipelineHandler(e, t) {
    typeof t < "u" ? (this.dataPipeline.push({ handler: e, priority: t }), this.dataPipeline.sort((i, o) => i.priority - o.priority)) : console.error("Data pipeline handlers must have a priority in order to be registered");
  }
  registerDisplayPipelineHandler(e, t) {
    typeof t < "u" ? (this.displayPipeline.push({ handler: e, priority: t }), this.displayPipeline.sort((i, o) => i.priority - o.priority)) : console.error("Display pipeline handlers must have a priority in order to be registered");
  }
  //set active data set
  refreshActiveData(e, t, i) {
    var o = this.table, n = "", s = 0, a = ["all", "dataPipeline", "display", "displayPipeline", "end"];
    if (!this.table.destroyed) {
      if (typeof e == "function")
        if (s = this.dataPipeline.findIndex((l) => l.handler === e), s > -1)
          n = "dataPipeline", t && (s == this.dataPipeline.length - 1 ? n = "display" : s++);
        else if (s = this.displayPipeline.findIndex((l) => l.handler === e), s > -1)
          n = "displayPipeline", t && (s == this.displayPipeline.length - 1 ? n = "end" : s++);
        else {
          console.error("Unable to refresh data, invalid handler provided", e);
          return;
        }
      else
        n = e || "all", s = 0;
      if (this.redrawBlock) {
        (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === n && s < this.redrawBlockRestoreConfig.index || a.indexOf(n) < a.indexOf(this.redrawBlockRestoreConfig.stage))) && (this.redrawBlockRestoreConfig = {
          handler: e,
          skipStage: t,
          renderInPosition: i,
          stage: n,
          index: s
        });
        return;
      } else
        _e.elVisible(this.element) ? i ? this.reRenderInPosition(this.refreshPipelines.bind(this, e, n, s, i)) : (this.refreshPipelines(e, n, s, i), e || this.table.columnManager.renderer.renderColumns(), this.renderTable(), o.options.layoutColumnsOnNewData && this.table.columnManager.redraw(!0)) : this.refreshPipelines(e, n, s, i), this.dispatch("data-refreshed");
    }
  }
  refreshPipelines(e, t, i, o) {
    switch (this.dispatch("data-refreshing"), e || (this.activeRowsPipeline[0] = this.rows.slice(0)), t) {
      case "all":
      case "dataPipeline":
        for (let n = i; n < this.dataPipeline.length; n++) {
          let s = this.dataPipeline[n].handler(this.activeRowsPipeline[n].slice(0));
          this.activeRowsPipeline[n + 1] = s || this.activeRowsPipeline[n].slice(0);
        }
        this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
      case "display":
        i = 0, this.resetDisplayRows();
      case "displayPipeline":
        for (let n = i; n < this.displayPipeline.length; n++) {
          let s = this.displayPipeline[n].handler((n ? this.getDisplayRows(n - 1) : this.activeRows).slice(0), o);
          this.setDisplayRows(s || this.getDisplayRows(n - 1).slice(0), n);
        }
      case "end":
        this.regenerateRowPositions();
    }
    this.getDisplayRows().length && this._clearPlaceholder();
  }
  //regenerate row positions
  regenerateRowPositions() {
    var e = this.getDisplayRows(), t = 1;
    e.forEach((i) => {
      i.type === "row" && (i.setPosition(t), t++);
    });
  }
  setActiveRows(e) {
    this.activeRows = this.activeRows = Object.assign([], e), this.activeRowsCount = this.activeRows.length;
  }
  //reset display rows array
  resetDisplayRows() {
    this.displayRows = [], this.displayRows.push(this.activeRows.slice(0)), this.displayRowsCount = this.displayRows[0].length;
  }
  //set display row pipeline data
  setDisplayRows(e, t) {
    this.displayRows[t] = e, t == this.displayRows.length - 1 && (this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length);
  }
  getDisplayRows(e) {
    return typeof e > "u" ? this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [] : this.displayRows[e] || [];
  }
  getVisibleRows(e, t) {
    var i = Object.assign([], this.renderer.visibleRows(!t));
    return e && (i = this.chain("rows-visible", [t], i, i)), i;
  }
  //repeat action across display rows
  displayRowIterator(e) {
    this.activeRowsPipeline.forEach(e), this.displayRows.forEach(e), this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
  }
  //return only actual rows (not group headers etc)
  getRows(e) {
    var t = [];
    switch (e) {
      case "active":
        t = this.activeRows;
        break;
      case "display":
        t = this.table.rowManager.getDisplayRows();
        break;
      case "visible":
        t = this.getVisibleRows(!1, !0);
        break;
      default:
        t = this.chain("rows-retrieve", e, null, this.rows) || this.rows;
    }
    return t;
  }
  ///////////////// Table Rendering /////////////////
  //trigger rerender of table in current position
  reRenderInPosition(e) {
    this.redrawBlock ? e ? e() : this.redrawBlockRenderInPosition = !0 : (this.dispatchExternal("renderStarted"), this.renderer.rerenderRows(e), this.fixedHeight || this.adjustTableSize(), this.scrollBarCheck(), this.dispatchExternal("renderComplete"));
  }
  scrollBarCheck() {
    var e = 0;
    this.element.scrollHeight > this.element.clientHeight && (e = this.element.offsetWidth - this.element.clientWidth), e !== this.scrollbarWidth && (this.scrollbarWidth = e, this.dispatch("scrollbar-vertical", e));
  }
  initializeRenderer() {
    var e, t = {
      virtual: R5,
      basic: $5
    };
    typeof this.table.options.renderVertical == "string" ? e = t[this.table.options.renderVertical] : e = this.table.options.renderVertical, e ? (this.renderMode = this.table.options.renderVertical, this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize(), (this.table.element.clientHeight || this.table.options.height) && !(this.table.options.minHeight && this.table.options.maxHeight) ? this.fixedHeight = !0 : this.fixedHeight = !1) : console.error("Unable to find matching renderer:", this.table.options.renderVertical);
  }
  getRenderMode() {
    return this.renderMode;
  }
  renderTable() {
    this.dispatchExternal("renderStarted"), this.element.scrollTop = 0, this._clearTable(), this.displayRowsCount ? (this.renderer.renderRows(), this.firstRender && (this.firstRender = !1, this.fixedHeight || this.adjustTableSize(), this.layoutRefresh(!0))) : this.renderEmptyScroll(), this.fixedHeight || this.adjustTableSize(), this.dispatch("table-layout"), this.displayRowsCount || this._showPlaceholder(), this.scrollBarCheck(), this.dispatchExternal("renderComplete");
  }
  //show scrollbars on empty table div
  renderEmptyScroll() {
    this.placeholder ? this.tableElement.style.display = "none" : this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
  }
  _clearTable() {
    this._clearPlaceholder(), this.scrollTop = 0, this.scrollLeft = 0, this.renderer.clearRows();
  }
  tableEmpty() {
    this.renderEmptyScroll(), this._showPlaceholder();
  }
  _showPlaceholder() {
    this.placeholder && (this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.initializePlaceholder(), this.placeholder.setAttribute("tabulator-render-mode", this.renderMode), this.getElement().appendChild(this.placeholder), this._positionPlaceholder());
  }
  _clearPlaceholder() {
    this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.tableElement.style.minWidth = "", this.tableElement.style.display = "";
  }
  _positionPlaceholder() {
    this.placeholder && this.placeholder.parentNode && (this.placeholder.style.width = this.table.columnManager.getWidth() + "px", this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px", this.placeholderContents.style.marginLeft = this.scrollLeft + "px");
  }
  styleRow(e, t) {
    var i = e.getElement();
    t % 2 ? (i.classList.add("tabulator-row-even"), i.classList.remove("tabulator-row-odd")) : (i.classList.add("tabulator-row-odd"), i.classList.remove("tabulator-row-even"));
  }
  //normalize height of active rows
  normalizeHeight() {
    this.activeRows.forEach(function(e) {
      e.normalizeHeight();
    });
  }
  //adjust the height of the table holder to fit in the Tabulator element
  adjustTableSize() {
    let e = this.element.clientHeight, t, i = !1;
    if (this.renderer.verticalFillMode === "fill") {
      let o = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
      if (this.fixedHeight) {
        t = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
        const n = "calc(100% - " + o + "px)";
        this.element.style.minHeight = t || "calc(100% - " + o + "px)", this.element.style.height = n, this.element.style.maxHeight = n;
      } else
        this.element.style.height = "", this.element.style.height = this.table.element.clientHeight - o + "px", this.element.scrollTop = this.scrollTop;
      this.renderer.resize(), !this.fixedHeight && e != this.element.clientHeight && (i = !0, this.subscribed("table-resize") ? this.dispatch("table-resize") : this.redraw()), this.scrollBarCheck();
    }
    return this._positionPlaceholder(), i;
  }
  //reinitialize all rows
  reinitialize() {
    this.rows.forEach(function(e) {
      e.reinitialize(!0);
    });
  }
  //prevent table from being redrawn
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockRestoreConfig = !1;
  }
  //restore table redrawing
  restoreRedraw() {
    this.redrawBlock = !1, this.redrawBlockRestoreConfig ? (this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition), this.redrawBlockRestoreConfig = !1) : this.redrawBlockRenderInPosition && this.reRenderInPosition(), this.redrawBlockRenderInPosition = !1;
  }
  //redraw table
  redraw(e) {
    const t = this.adjustTableSize();
    this.table.tableWidth = this.table.element.clientWidth, e ? this.renderTable() : (t && this.reRenderInPosition(), this.scrollHorizontal(this.scrollLeft));
  }
  resetScroll() {
    if (this.element.scrollLeft = 0, this.element.scrollTop = 0, this.table.browser === "ie") {
      var e = document.createEvent("Event");
      e.initEvent("scroll", !1, !0), this.element.dispatchEvent(e);
    } else
      this.element.dispatchEvent(new Event("scroll"));
  }
}
class D5 extends Nt {
  constructor(e) {
    super(e), this.active = !1, this.element = this.createElement(), this.containerElement = this.createContainerElement(), this.external = !1;
  }
  initialize() {
    this.initializeElement();
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer"), e;
  }
  createContainerElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer-contents"), this.element.appendChild(e), e;
  }
  initializeElement() {
    if (this.table.options.footerElement)
      switch (typeof this.table.options.footerElement) {
        case "string":
          this.table.options.footerElement[0] === "<" ? this.containerElement.innerHTML = this.table.options.footerElement : (this.external = !0, this.containerElement = document.querySelector(this.table.options.footerElement));
          break;
        default:
          this.element = this.table.options.footerElement;
          break;
      }
  }
  getElement() {
    return this.element;
  }
  append(e) {
    this.activate(), this.containerElement.appendChild(e), this.table.rowManager.adjustTableSize();
  }
  prepend(e) {
    this.activate(), this.element.insertBefore(e, this.element.firstChild), this.table.rowManager.adjustTableSize();
  }
  remove(e) {
    e.parentNode.removeChild(e), this.deactivate();
  }
  deactivate(e) {
    (!this.element.firstChild || e) && (this.external || this.element.parentNode.removeChild(this.element), this.active = !1);
  }
  activate() {
    this.active || (this.active = !0, this.external || (this.table.element.appendChild(this.getElement()), this.table.element.style.display = ""));
  }
  redraw() {
    this.dispatch("footer-redraw");
  }
}
class M5 extends Nt {
  constructor(e) {
    super(e), this.el = null, this.abortClasses = ["tabulator-headers", "tabulator-table"], this.previousTargets = {}, this.listeners = [
      "click",
      "dblclick",
      "contextmenu",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "mousemove",
      "mouseup",
      "mousedown",
      "touchstart",
      "touchend"
    ], this.componentMap = {
      "tabulator-cell": "cell",
      "tabulator-row": "row",
      "tabulator-group": "group",
      "tabulator-col": "column"
    }, this.pseudoTrackers = {
      row: {
        subscriber: null,
        target: null
      },
      cell: {
        subscriber: null,
        target: null
      },
      group: {
        subscriber: null,
        target: null
      },
      column: {
        subscriber: null,
        target: null
      }
    }, this.pseudoTracking = !1;
  }
  initialize() {
    this.el = this.table.element, this.buildListenerMap(), this.bindSubscriptionWatchers();
  }
  buildListenerMap() {
    var e = {};
    this.listeners.forEach((t) => {
      e[t] = {
        handler: null,
        components: []
      };
    }), this.listeners = e;
  }
  bindPseudoEvents() {
    Object.keys(this.pseudoTrackers).forEach((e) => {
      this.pseudoTrackers[e].subscriber = this.pseudoMouseEnter.bind(this, e), this.subscribe(e + "-mouseover", this.pseudoTrackers[e].subscriber);
    }), this.pseudoTracking = !0;
  }
  pseudoMouseEnter(e, t, i) {
    this.pseudoTrackers[e].target !== i && (this.pseudoTrackers[e].target && this.dispatch(e + "-mouseleave", t, this.pseudoTrackers[e].target), this.pseudoMouseLeave(e, t), this.pseudoTrackers[e].target = i, this.dispatch(e + "-mouseenter", t, i));
  }
  pseudoMouseLeave(e, t) {
    var i = Object.keys(this.pseudoTrackers), o = {
      row: ["cell"],
      cell: ["row"]
    };
    i = i.filter((n) => {
      var s = o[e];
      return n !== e && (!s || s && !s.includes(n));
    }), i.forEach((n) => {
      var s = this.pseudoTrackers[n].target;
      this.pseudoTrackers[n].target && (this.dispatch(n + "-mouseleave", t, s), this.pseudoTrackers[n].target = null);
    });
  }
  bindSubscriptionWatchers() {
    var e = Object.keys(this.listeners), t = Object.values(this.componentMap);
    for (let i of t)
      for (let o of e) {
        let n = i + "-" + o;
        this.subscriptionChange(n, this.subscriptionChanged.bind(this, i, o));
      }
    this.subscribe("table-destroy", this.clearWatchers.bind(this));
  }
  subscriptionChanged(e, t, i) {
    var o = this.listeners[t].components, n = o.indexOf(e), s = !1;
    i ? n === -1 && (o.push(e), s = !0) : this.subscribed(e + "-" + t) || n > -1 && (o.splice(n, 1), s = !0), (t === "mouseenter" || t === "mouseleave") && !this.pseudoTracking && this.bindPseudoEvents(), s && this.updateEventListeners();
  }
  updateEventListeners() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.components.length ? t.handler || (t.handler = this.track.bind(this, e), this.el.addEventListener(e, t.handler)) : t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
  track(e, t) {
    var i = t.composedPath && t.composedPath() || t.path, o = this.findTargets(i);
    o = this.bindComponents(e, o), this.triggerEvents(e, t, o), this.pseudoTracking && (e == "mouseover" || e == "mouseleave") && !Object.keys(o).length && this.pseudoMouseLeave("none", t);
  }
  findTargets(e) {
    var t = {};
    let i = Object.keys(this.componentMap);
    for (let o of e) {
      let n = o.classList ? [...o.classList] : [];
      if (n.filter((l) => this.abortClasses.includes(l)).length)
        break;
      let a = n.filter((l) => i.includes(l));
      for (let l of a)
        t[this.componentMap[l]] || (t[this.componentMap[l]] = o);
    }
    return t.group && t.group === t.row && delete t.row, t;
  }
  bindComponents(e, t) {
    var i = Object.keys(t).reverse(), o = this.listeners[e], n = {}, s = {};
    for (let a of i) {
      let l, u = t[a], h = this.previousTargets[a];
      if (h && h.target === u)
        l = h.component;
      else
        switch (a) {
          case "row":
          case "group":
            (o.components.includes("row") || o.components.includes("cell") || o.components.includes("group")) && (l = this.table.rowManager.getVisibleRows(!0).find((d) => d.getElement() === u), t.row && t.row.parentNode && t.row.parentNode.closest(".tabulator-row") && (t[a] = !1));
            break;
          case "column":
            o.components.includes("column") && (l = this.table.columnManager.findColumn(u));
            break;
          case "cell":
            o.components.includes("cell") && (n.row instanceof Ct ? l = n.row.findCell(u) : t.row && console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?"));
            break;
        }
      l && (n[a] = l, s[a] = {
        target: u,
        component: l
      });
    }
    return this.previousTargets = s, n;
  }
  triggerEvents(e, t, i) {
    var o = this.listeners[e];
    for (let n in i)
      i[n] && o.components.includes(n) && this.dispatch(n + "-" + e, t, i[n]);
  }
  clearWatchers() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
}
class X5 {
  constructor(e) {
    this.table = e, this.bindings = {};
  }
  bind(e, t, i) {
    this.bindings[e] || (this.bindings[e] = {}), this.bindings[e][t] ? console.warn("Unable to bind component handler, a matching function name is already bound", e, t, i) : this.bindings[e][t] = i;
  }
  handle(e, t, i) {
    if (this.bindings[e] && this.bindings[e][i] && typeof this.bindings[e][i].bind == "function")
      return this.bindings[e][i].bind(null, t);
    i !== "then" && typeof i == "string" && !i.startsWith("_") && this.table.options.debugInvalidComponentFuncs && console.error("The " + e + " component does not have a " + i + " function, have you checked that you have the correct Tabulator module installed?");
  }
}
class A5 extends Nt {
  constructor(e) {
    super(e), this.requestOrder = 0, this.loading = !1;
  }
  initialize() {
  }
  load(e, t, i, o, n, s) {
    var a = ++this.requestOrder;
    if (this.dispatchExternal("dataLoading", e), e && (e.indexOf("{") == 0 || e.indexOf("[") == 0) && (e = JSON.parse(e)), this.confirm("data-loading", [e, t, i, n])) {
      this.loading = !0, n || this.alertLoader(), t = this.chain("data-params", [e, i, n], t || {}, t || {}), t = this.mapParams(t, this.table.options.dataSendParams);
      var l = this.chain("data-load", [e, t, i, n], !1, Promise.resolve([]));
      return l.then((u) => {
        !Array.isArray(u) && typeof u == "object" && (u = this.mapParams(u, this.objectInvert(this.table.options.dataReceiveParams)));
        var h = this.chain("data-loaded", u, null, u);
        a == this.requestOrder ? (this.clearAlert(), h !== !1 && (this.dispatchExternal("dataLoaded", h), this.table.rowManager.setData(h, o, typeof s > "u" ? !o : s))) : console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
      }).catch((u) => {
        console.error("Data Load Error: ", u), this.dispatchExternal("dataLoadError", u), n || this.alertError(), setTimeout(() => {
          this.clearAlert();
        }, this.table.options.dataLoaderErrorTimeout);
      }).finally(() => {
        this.loading = !1;
      });
    } else
      return this.dispatchExternal("dataLoaded", e), e || (e = []), this.table.rowManager.setData(e, o, typeof s > "u" ? !o : s), Promise.resolve();
  }
  mapParams(e, t) {
    var i = {};
    for (let o in e)
      i[t.hasOwnProperty(o) ? t[o] : o] = e[o];
    return i;
  }
  objectInvert(e) {
    var t = {};
    for (let i in e)
      t[e[i]] = i;
    return t;
  }
  blockActiveLoad() {
    this.requestOrder++;
  }
  alertLoader() {
    var e = typeof this.table.options.dataLoader == "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
    e && this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
  }
  alertError() {
    this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
  }
  clearAlert() {
    this.table.alertManager.clear();
  }
}
class z5 {
  constructor(e, t, i) {
    this.table = e, this.events = {}, this.optionsList = t || {}, this.subscriptionNotifiers = {}, this.dispatch = i ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.debug = i;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t) {
    this.events[e] || (this.events[e] = []), this.events[e].push(t), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var i;
    if (this.events[e])
      if (t)
        if (i = this.events[e].findIndex((o) => o === t), i > -1)
          this.events[e].splice(i, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
      else
        delete this.events[e];
    else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _notifySubscriptionChange(e, t) {
    var i = this.subscriptionNotifiers[e];
    i && i.forEach((o) => {
      o(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift(), i;
    return this.events[t] && this.events[t].forEach((o, n) => {
      let s = o.apply(this.table, e);
      n || (i = s);
    }), i;
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "ExternalEvent:" + e[0], (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
}
class N5 {
  constructor(e) {
    this.events = {}, this.subscriptionNotifiers = {}, this.dispatch = e ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.chain = e ? this._debugChain.bind(this) : this._chain.bind(this), this.confirm = e ? this._debugConfirm.bind(this) : this._confirm.bind(this), this.debug = e;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t, i = 1e4) {
    this.events[e] || (this.events[e] = []), this.events[e].push({ callback: t, priority: i }), this.events[e].sort((o, n) => o.priority - n.priority), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var i;
    if (this.events[e]) {
      if (t)
        if (i = this.events[e].findIndex((o) => o.callback === t), i > -1)
          this.events[e].splice(i, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
    } else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _chain(e, t, i, o) {
    var n = i;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) ? (this.events[e].forEach((s, a) => {
      n = s.callback.apply(this, t.concat([n]));
    }), n) : typeof o == "function" ? o() : o;
  }
  _confirm(e, t) {
    var i = !1;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) && this.events[e].forEach((o, n) => {
      o.callback.apply(this, t) && (i = !0);
    }), i;
  }
  _notifySubscriptionChange(e, t) {
    var i = this.subscriptionNotifiers[e];
    i && i.forEach((o) => {
      o(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift();
    this.events[t] && this.events[t].forEach((i) => {
      i.callback.apply(this, e);
    });
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
  _debugChain() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._chain(...arguments);
  }
  _debugConfirm() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._confirm(...arguments);
  }
}
class V5 extends Nt {
  constructor(e) {
    super(e);
  }
  _warnUser() {
    this.options("debugDeprecation") && console.warn(...arguments);
  }
  check(e, t) {
    var i = "";
    return typeof this.options(e) < "u" ? (i = "Deprecated Setup Option - Use of the %c" + e + "%c option is now deprecated", t ? (i = i + ", Please use the %c" + t + "%c option instead", this._warnUser(i, "font-weight: bold;", "font-weight: normal;", "font-weight: bold;", "font-weight: normal;")) : this._warnUser(i, "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  checkMsg(e, t) {
    return typeof this.options(e) < "u" ? (this._warnUser("%cDeprecated Setup Option - Use of the %c" + e + " %c option is now deprecated, " + t, "font-weight: normal;", "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  msg(e) {
    this._warnUser(e);
  }
}
class Bt {
  static register(e) {
    Bt.tables.push(e);
  }
  static deregister(e) {
    var t = Bt.tables.indexOf(e);
    t > -1 && Bt.tables.splice(t, 1);
  }
  static lookupTable(e, t) {
    var i = [], o, n;
    if (typeof e == "string") {
      if (o = document.querySelectorAll(e), o.length)
        for (var s = 0; s < o.length; s++)
          n = Bt.matchElement(o[s]), n && i.push(n);
    } else
      typeof HTMLElement < "u" && e instanceof HTMLElement || e instanceof wi ? (n = Bt.matchElement(e), n && i.push(n)) : Array.isArray(e) ? e.forEach(function(a) {
        i = i.concat(Bt.lookupTable(a));
      }) : t || console.warn("Table Connection Error - Invalid Selector", e);
    return i;
  }
  static matchElement(e) {
    return Bt.tables.find(function(t) {
      return e instanceof wi ? t === e : t.element === e;
    });
  }
}
Bt.tables = [];
function Z5(r, e) {
  e && this.table.columnManager.renderer.reinitializeColumnWidths(r), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function qO(r, e) {
  r.forEach(function(t) {
    t.reinitializeWidth();
  }), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function L5(r, e) {
  var t = 0, i = this.table.rowManager.element.clientWidth, o = 0, n = !1;
  r.forEach((s, a) => {
    s.widthFixed || s.reinitializeWidth(), (this.table.options.responsiveLayout ? s.modules.responsive.visible : s.visible) && (n = s), s.visible && (t += s.getWidth());
  }), n ? (o = i - t + n.getWidth(), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && (n.setWidth(0), this.table.modules.responsiveLayout.update()), o > 0 ? n.setWidth(o) : n.reinitializeWidth()) : this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function W5(r, e) {
  var t = this.table.rowManager.element.getBoundingClientRect().width, i = 0, o = 0, n = 0, s = 0, a = [], l = [], u = 0, h = 0, c = 0;
  function d(p) {
    var g;
    return typeof p == "string" ? p.indexOf("%") > -1 ? g = t / 100 * parseInt(p) : g = parseInt(p) : g = p, g;
  }
  function f(p, g, b, m) {
    var v = [], S = 0, y = 0, x = 0, P = n, k = 0, C = 0, T = [];
    function R(E) {
      return b * (E.column.definition.widthGrow || 1);
    }
    function M(E) {
      return d(E.width) - b * (E.column.definition.widthShrink || 0);
    }
    return p.forEach(function(E, Z) {
      var N = m ? M(E) : R(E);
      E.column.minWidth >= N ? v.push(E) : E.column.maxWidth && E.column.maxWidth < N ? (E.width = E.column.maxWidth, g -= E.column.maxWidth, P -= m ? E.column.definition.widthShrink || 1 : E.column.definition.widthGrow || 1, P && (b = Math.floor(g / P))) : (T.push(E), C += m ? E.column.definition.widthShrink || 1 : E.column.definition.widthGrow || 1);
    }), v.length ? (v.forEach(function(E) {
      S += m ? E.width - E.column.minWidth : E.column.minWidth, E.width = E.column.minWidth;
    }), y = g - S, x = C ? Math.floor(y / C) : y, k = f(T, y, x, m)) : (k = C ? g - Math.floor(g / C) * C : g, T.forEach(function(E) {
      E.width = m ? M(E) : R(E);
    })), k;
  }
  this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update(), this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (t -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), r.forEach(function(p) {
    var g, b, m;
    p.visible && (g = p.definition.width, b = parseInt(p.minWidth), g ? (m = d(g), i += m > b ? m : b, p.definition.widthShrink && (l.push({
      column: p,
      width: m > b ? m : b
    }), u += p.definition.widthShrink)) : (a.push({
      column: p,
      width: 0
    }), n += p.definition.widthGrow || 1));
  }), o = t - i, s = Math.floor(o / n), c = f(a, o, s, !1), a.length && c > 0 && (a[a.length - 1].width += c), a.forEach(function(p) {
    o -= p.width;
  }), h = Math.abs(c) + o, h > 0 && u && (c = f(l, h, Math.floor(h / u), !0)), c && l.length && (l[l.length - 1].width -= c), a.forEach(function(p) {
    p.column.setWidth(p.width);
  }), l.forEach(function(p) {
    p.column.setWidth(p.width);
  });
}
var I5 = {
  fitData: Z5,
  fitDataFill: qO,
  fitDataTable: qO,
  fitDataStretch: L5,
  fitColumns: W5
};
class In extends fe {
  constructor(e) {
    super(e, "layout"), this.mode = null, this.registerTableOption("layout", "fitData"), this.registerTableOption("layoutColumnsOnNewData", !1), this.registerColumnOption("widthGrow"), this.registerColumnOption("widthShrink");
  }
  //initialize layout system
  initialize() {
    var e = this.table.options.layout;
    In.modes[e] ? this.mode = e : (console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + e), this.mode = "fitData"), this.table.element.setAttribute("tabulator-layout", this.mode);
  }
  getMode() {
    return this.mode;
  }
  //trigger table layout
  layout(e) {
    this.dispatch("layout-refreshing"), In.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, e), this.dispatch("layout-refreshed");
  }
}
In.moduleName = "layout";
In.modes = I5;
var U5 = {
  default: {
    //hold default locale text
    groups: {
      item: "item",
      items: "items"
    },
    columns: {},
    data: {
      loading: "Loading",
      error: "Error"
    },
    pagination: {
      page_size: "Page Size",
      page_title: "Show Page",
      first: "First",
      first_title: "First Page",
      last: "Last",
      last_title: "Last Page",
      prev: "Prev",
      prev_title: "Prev Page",
      next: "Next",
      next_title: "Next Page",
      all: "All",
      counter: {
        showing: "Showing",
        of: "of",
        rows: "rows",
        pages: "pages"
      }
    },
    headerFilters: {
      default: "filter column...",
      columns: {}
    }
  }
};
class Aa extends fe {
  constructor(e) {
    super(e), this.locale = "default", this.lang = !1, this.bindings = {}, this.langList = {}, this.registerTableOption("locale", !1), this.registerTableOption("langs", {});
  }
  initialize() {
    this.langList = _e.deepClone(Aa.langs), this.table.options.columnDefaults.headerFilterPlaceholder !== !1 && this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
    for (let e in this.table.options.langs)
      this.installLang(e, this.table.options.langs[e]);
    this.setLocale(this.table.options.locale), this.registerTableFunction("setLocale", this.setLocale.bind(this)), this.registerTableFunction("getLocale", this.getLocale.bind(this)), this.registerTableFunction("getLang", this.getLang.bind(this));
  }
  //set header placeholder
  setHeaderFilterPlaceholder(e) {
    this.langList.default.headerFilters.default = e;
  }
  //setup a lang description object
  installLang(e, t) {
    this.langList[e] ? this._setLangProp(this.langList[e], t) : this.langList[e] = t;
  }
  _setLangProp(e, t) {
    for (let i in t)
      e[i] && typeof e[i] == "object" ? this._setLangProp(e[i], t[i]) : e[i] = t[i];
  }
  //set current locale
  setLocale(e) {
    e = e || "default";
    function t(i, o) {
      for (var n in i)
        typeof i[n] == "object" ? (o[n] || (o[n] = {}), t(i[n], o[n])) : o[n] = i[n];
    }
    if (e === !0 && navigator.language && (e = navigator.language.toLowerCase()), e && !this.langList[e]) {
      let i = e.split("-")[0];
      this.langList[i] ? (console.warn("Localization Error - Exact matching locale not found, using closest match: ", e, i), e = i) : (console.warn("Localization Error - Matching locale not found, using default: ", e), e = "default");
    }
    this.locale = e, this.lang = _e.deepClone(this.langList.default || {}), e != "default" && t(this.langList[e], this.lang), this.dispatchExternal("localized", this.locale, this.lang), this._executeBindings();
  }
  //get current locale
  getLocale(e) {
    return this.locale;
  }
  //get lang object for given local or current if none provided
  getLang(e) {
    return e ? this.langList[e] : this.lang;
  }
  //get text for current locale
  getText(e, t) {
    var i = t ? e + "|" + t : e, o = i.split("|"), n = this._getLangElement(o, this.locale);
    return n || "";
  }
  //traverse langs object and find localized copy
  _getLangElement(e, t) {
    var i = this.lang;
    return e.forEach(function(o) {
      var n;
      i && (n = i[o], typeof n < "u" ? i = n : i = !1);
    }), i;
  }
  //set update binding
  bind(e, t) {
    this.bindings[e] || (this.bindings[e] = []), this.bindings[e].push(t), t(this.getText(e), this.lang);
  }
  //iterate through bindings and trigger updates
  _executeBindings() {
    for (let e in this.bindings)
      this.bindings[e].forEach((t) => {
        t(this.getText(e), this.lang);
      });
  }
}
Aa.moduleName = "localize";
Aa.langs = U5;
class AS extends fe {
  constructor(e) {
    super(e);
  }
  initialize() {
    this.registerTableFunction("tableComms", this.receive.bind(this));
  }
  getConnections(e) {
    var t = [], i;
    return i = Bt.lookupTable(e), i.forEach((o) => {
      this.table !== o && t.push(o);
    }), t;
  }
  send(e, t, i, o) {
    var n = this.getConnections(e);
    n.forEach((s) => {
      s.tableComms(this.table.element, t, i, o);
    }), !n.length && e && console.warn("Table Connection Error - No tables matching selector found", e);
  }
  receive(e, t, i, o) {
    if (this.table.modExists(t))
      return this.table.modules[t].commsReceived(e, i, o);
    console.warn("Inter-table Comms Error - no such module:", t);
  }
}
AS.moduleName = "comms";
var Y5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LayoutModule: In,
  LocalizeModule: Aa,
  CommsModule: AS
});
class zS {
  constructor(e, t) {
    this.bindStaticFunctionality(e), this.bindModules(e, Y5, !0), t && this.bindModules(e, t);
  }
  bindStaticFunctionality(e) {
    e.moduleBindings = {}, e.extendModule = function(t, i, o) {
      if (e.moduleBindings[t]) {
        var n = e.moduleBindings[t][i];
        if (n)
          if (typeof o == "object")
            for (let s in o)
              n[s] = o[s];
          else
            console.warn("Module Error - Invalid value type, it must be an object");
        else
          console.warn("Module Error - property does not exist:", i);
      } else
        console.warn("Module Error - module does not exist:", t);
    }, e.registerModule = function(t) {
      Array.isArray(t) || (t = [t]), t.forEach((i) => {
        e.registerModuleBinding(i);
      });
    }, e.registerModuleBinding = function(t) {
      e.moduleBindings[t.moduleName] = t;
    }, e.findTable = function(t) {
      var i = Bt.lookupTable(t, !0);
      return Array.isArray(i) && !i.length ? !1 : i;
    }, e.prototype.bindModules = function() {
      var t = [], i = [], o = [];
      this.modules = {};
      for (var n in e.moduleBindings) {
        let s = e.moduleBindings[n], a = new s(this);
        this.modules[n] = a, s.prototype.moduleCore ? this.modulesCore.push(a) : s.moduleInitOrder ? s.moduleInitOrder < 0 ? t.push(a) : i.push(a) : o.push(a);
      }
      t.sort((s, a) => s.moduleInitOrder > a.moduleInitOrder ? 1 : -1), i.sort((s, a) => s.moduleInitOrder > a.moduleInitOrder ? 1 : -1), this.modulesRegular = t.concat(o.concat(i));
    };
  }
  bindModules(e, t, i) {
    var o = Object.values(t);
    i && o.forEach((n) => {
      n.prototype.moduleCore = !0;
    }), e.registerModule(o);
  }
}
class F5 extends Nt {
  constructor(e) {
    super(e), this.element = this._createAlertElement(), this.msgElement = this._createMsgElement(), this.type = null, this.element.appendChild(this.msgElement);
  }
  _createAlertElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert"), e;
  }
  _createMsgElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert-msg"), e.setAttribute("role", "alert"), e;
  }
  _typeClass() {
    return "tabulator-alert-state-" + this.type;
  }
  alert(e, t = "msg") {
    if (e) {
      for (this.clear(), this.type = t; this.msgElement.firstChild; )
        this.msgElement.removeChild(this.msgElement.firstChild);
      this.msgElement.classList.add(this._typeClass()), typeof e == "function" && (e = e()), e instanceof HTMLElement ? this.msgElement.appendChild(e) : this.msgElement.innerHTML = e, this.table.element.appendChild(this.element);
    }
  }
  clear() {
    this.element.parentNode && this.element.parentNode.removeChild(this.element), this.msgElement.classList.remove(this._typeClass());
  }
}
class wi {
  constructor(e, t) {
    this.options = {}, this.columnManager = null, this.rowManager = null, this.footerManager = null, this.alertManager = null, this.vdomHoz = null, this.externalEvents = null, this.eventBus = null, this.interactionMonitor = !1, this.browser = "", this.browserSlow = !1, this.browserMobile = !1, this.rtl = !1, this.originalElement = null, this.componentFunctionBinder = new X5(this), this.dataLoader = !1, this.modules = {}, this.modulesCore = [], this.modulesRegular = [], this.deprecationAdvisor = new V5(this), this.optionsList = new XS(this, "table constructor"), this.initialized = !1, this.destroyed = !1, this.initializeElement(e) && (this.initializeCoreSystems(t), setTimeout(() => {
      this._create();
    })), Bt.register(this);
  }
  initializeElement(e) {
    return typeof HTMLElement < "u" && e instanceof HTMLElement ? (this.element = e, !0) : typeof e == "string" ? (this.element = document.querySelector(e), this.element ? !0 : (console.error("Tabulator Creation Error - no element found matching selector: ", e), !1)) : (console.error("Tabulator Creation Error - Invalid element provided:", e), !1);
  }
  initializeCoreSystems(e) {
    this.columnManager = new T5(this), this.rowManager = new _5(this), this.footerManager = new D5(this), this.dataLoader = new A5(this), this.alertManager = new F5(this), this.bindModules(), this.options = this.optionsList.generate(wi.defaultOptions, e), this._clearObjectPointers(), this._mapDeprecatedFunctionality(), this.externalEvents = new z5(this, this.options, this.options.debugEventsExternal), this.eventBus = new N5(this.options.debugEventsInternal), this.interactionMonitor = new M5(this), this.dataLoader.initialize(), this.footerManager.initialize();
  }
  //convert deprecated functionality to new functions
  _mapDeprecatedFunctionality() {
  }
  _clearSelection() {
    this.element.classList.add("tabulator-block-select"), window.getSelection ? window.getSelection().empty ? window.getSelection().empty() : window.getSelection().removeAllRanges && window.getSelection().removeAllRanges() : document.selection && document.selection.empty(), this.element.classList.remove("tabulator-block-select");
  }
  //create table
  _create() {
    this.externalEvents.dispatch("tableBuilding"), this.eventBus.dispatch("table-building"), this._rtlCheck(), this._buildElement(), this._initializeTable(), this._loadInitialData(), this.initialized = !0, this.externalEvents.dispatch("tableBuilt");
  }
  _rtlCheck() {
    var e = window.getComputedStyle(this.element);
    switch (this.options.textDirection) {
      case "auto":
        if (e.direction !== "rtl")
          break;
      case "rtl":
        this.element.classList.add("tabulator-rtl"), this.rtl = !0;
        break;
      case "ltr":
        this.element.classList.add("tabulator-ltr");
      default:
        this.rtl = !1;
    }
  }
  //clear pointers to objects in default config object
  _clearObjectPointers() {
    this.options.columns = this.options.columns.slice(0), Array.isArray(this.options.data) && !this.options.reactiveData && (this.options.data = this.options.data.slice(0));
  }
  //build tabulator element
  _buildElement() {
    var e = this.element, t = this.options, i;
    if (e.tagName === "TABLE") {
      this.originalElement = this.element, i = document.createElement("div");
      var o = e.attributes;
      for (var n in o)
        typeof o[n] == "object" && i.setAttribute(o[n].name, o[n].value);
      e.parentNode.replaceChild(i, e), this.element = e = i;
    }
    for (e.classList.add("tabulator"), e.setAttribute("role", "grid"); e.firstChild; )
      e.removeChild(e.firstChild);
    t.height && (t.height = isNaN(t.height) ? t.height : t.height + "px", e.style.height = t.height), t.minHeight !== !1 && (t.minHeight = isNaN(t.minHeight) ? t.minHeight : t.minHeight + "px", e.style.minHeight = t.minHeight), t.maxHeight !== !1 && (t.maxHeight = isNaN(t.maxHeight) ? t.maxHeight : t.maxHeight + "px", e.style.maxHeight = t.maxHeight);
  }
  //initialize core systems and modules
  _initializeTable() {
    var e = this.element, t = this.options;
    this.interactionMonitor.initialize(), this.columnManager.initialize(), this.rowManager.initialize(), this._detectBrowser(), this.modulesCore.forEach((i) => {
      i.initialize();
    }), e.appendChild(this.columnManager.getElement()), e.appendChild(this.rowManager.getElement()), t.footerElement && this.footerManager.activate(), t.autoColumns && t.data && this.columnManager.generateColumnsFromRowData(this.options.data), this.modulesRegular.forEach((i) => {
      i.initialize();
    }), this.columnManager.setColumns(t.columns), this.eventBus.dispatch("table-built");
  }
  _loadInitialData() {
    this.dataLoader.load(this.options.data);
  }
  //deconstructor
  destroy() {
    var e = this.element;
    for (this.destroyed = !0, Bt.deregister(this), this.eventBus.dispatch("table-destroy"), this.rowManager.destroy(); e.firstChild; )
      e.removeChild(e.firstChild);
    e.classList.remove("tabulator"), this.externalEvents.dispatch("tableDestroyed");
  }
  _detectBrowser() {
    var e = navigator.userAgent || navigator.vendor || window.opera;
    e.indexOf("Trident") > -1 ? (this.browser = "ie", this.browserSlow = !0) : e.indexOf("Edge") > -1 ? (this.browser = "edge", this.browserSlow = !0) : e.indexOf("Firefox") > -1 ? (this.browser = "firefox", this.browserSlow = !1) : e.indexOf("Mac OS") > -1 ? (this.browser = "safari", this.browserSlow = !1) : (this.browser = "other", this.browserSlow = !1), this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e.slice(0, 4));
  }
  initGuard(e, t) {
    var i, o;
    return this.options.debugInitialization && !this.initialized && (e || (i = new Error().stack.split(`
`), o = i[0] == "Error" ? i[2] : i[1], o[0] == " " ? e = o.trim().split(" ")[1].split(".")[1] : e = o.trim().split("@")[0]), console.warn("Table Not Initialized - Calling the " + e + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (t ? " " + t : ""))), this.initialized;
  }
  ////////////////// Data Handling //////////////////
  //block table redrawing
  blockRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-blocking"), this.rowManager.blockRedraw(), this.columnManager.blockRedraw(), this.eventBus.dispatch("redraw-blocked");
  }
  //restore table redrawing
  restoreRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-restoring"), this.rowManager.restoreRedraw(), this.columnManager.restoreRedraw(), this.eventBus.dispatch("redraw-restored");
  }
  //load data
  setData(e, t, i) {
    return this.initGuard(!1, "To set initial data please use the 'data' property in the table constructor."), this.dataLoader.load(e, t, i, !1);
  }
  //clear data
  clearData() {
    this.initGuard(), this.dataLoader.blockActiveLoad(), this.rowManager.clearData();
  }
  //get table data array
  getData(e) {
    return this.rowManager.getData(e);
  }
  //get table data array count
  getDataCount(e) {
    return this.rowManager.getDataCount(e);
  }
  //replace data, keeping table in position with same sort
  replaceData(e, t, i) {
    return this.initGuard(), this.dataLoader.load(e, t, i, !0, !0);
  }
  //update table data
  updateData(e) {
    var t = 0;
    return this.initGuard(), new Promise((i, o) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((n) => {
        var s = this.rowManager.findRow(n[this.options.index]);
        s ? (t++, s.updateData(n).then(() => {
          t--, t || i();
        }).catch((a) => {
          o("Update Error - Unable to update row", n, a);
        })) : o("Update Error - Unable to find row", n);
      }) : (console.warn("Update Error - No data provided"), o("Update Error - No data provided"));
    });
  }
  addData(e, t, i) {
    return this.initGuard(), new Promise((o, n) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e ? this.rowManager.addRows(e, t, i).then((s) => {
        var a = [];
        s.forEach(function(l) {
          a.push(l.getComponent());
        }), o(a);
      }) : (console.warn("Update Error - No data provided"), n("Update Error - No data provided"));
    });
  }
  //update table data
  updateOrAddData(e) {
    var t = [], i = 0;
    return this.initGuard(), new Promise((o, n) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((s) => {
        var a = this.rowManager.findRow(s[this.options.index]);
        i++, a ? a.updateData(s).then(() => {
          i--, t.push(a.getComponent()), i || o(t);
        }) : this.rowManager.addRows(s).then((l) => {
          i--, t.push(l[0].getComponent()), i || o(t);
        });
      }) : (console.warn("Update Error - No data provided"), n("Update Error - No data provided"));
    });
  }
  //get row object
  getRow(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //get row object
  getRowFromPosition(e) {
    var t = this.rowManager.getRowFromPosition(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //delete row from table
  deleteRow(e) {
    var t = [];
    this.initGuard(), Array.isArray(e) || (e = [e]);
    for (let i of e) {
      let o = this.rowManager.findRow(i, !0);
      if (o)
        t.push(o);
      else
        return console.error("Delete Error - No matching row found:", i), Promise.reject("Delete Error - No matching row found");
    }
    return t.sort((i, o) => this.rowManager.rows.indexOf(i) > this.rowManager.rows.indexOf(o) ? 1 : -1), t.forEach((i) => {
      i.delete();
    }), this.rowManager.reRenderInPosition(), Promise.resolve();
  }
  //add row to table
  addRow(e, t, i) {
    return this.initGuard(), typeof e == "string" && (e = JSON.parse(e)), this.rowManager.addRows(e, t, i, !0).then((o) => o[0].getComponent());
  }
  //update a row if it exists otherwise create it
  updateOrAddRow(e, t) {
    var i = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), i ? i.updateData(t).then(() => i.getComponent()) : this.rowManager.addRows(t).then((o) => o[0].getComponent());
  }
  //update row data
  updateRow(e, t) {
    var i = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), i ? i.updateData(t).then(() => Promise.resolve(i.getComponent())) : (console.warn("Update Error - No matching row found:", e), Promise.reject("Update Error - No matching row found"));
  }
  //scroll to row in DOM
  scrollToRow(e, t, i) {
    var o = this.rowManager.findRow(e);
    return o ? this.rowManager.scrollToRow(o, t, i) : (console.warn("Scroll Error - No matching row found:", e), Promise.reject("Scroll Error - No matching row found"));
  }
  moveRow(e, t, i) {
    var o = this.rowManager.findRow(e);
    this.initGuard(), o ? o.moveToRow(t, i) : console.warn("Move Error - No matching row found:", e);
  }
  getRows(e) {
    return this.rowManager.getComponents(e);
  }
  //get position of row in table
  getRowPosition(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getPosition() : (console.warn("Position Error - No matching row found:", e), !1);
  }
  /////////////// Column Functions  ///////////////
  setColumns(e) {
    this.initGuard(!1, "To set initial columns please use the 'columns' property in the table constructor"), this.columnManager.setColumns(e);
  }
  getColumns(e) {
    return this.columnManager.getComponents(e);
  }
  getColumn(e) {
    var t = this.columnManager.findColumn(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching column found:", e), !1);
  }
  getColumnDefinitions() {
    return this.columnManager.getDefinitionTree();
  }
  showColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.show();
    else
      return console.warn("Column Show Error - No matching column found:", e), !1;
  }
  hideColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.hide();
    else
      return console.warn("Column Hide Error - No matching column found:", e), !1;
  }
  toggleColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.visible ? t.hide() : t.show();
    else
      return console.warn("Column Visibility Toggle Error - No matching column found:", e), !1;
  }
  addColumn(e, t, i) {
    var o = this.columnManager.findColumn(i);
    return this.initGuard(), this.columnManager.addColumn(e, t, o).then((n) => n.getComponent());
  }
  deleteColumn(e) {
    var t = this.columnManager.findColumn(e);
    return this.initGuard(), t ? t.delete() : (console.warn("Column Delete Error - No matching column found:", e), Promise.reject());
  }
  updateColumnDefinition(e, t) {
    var i = this.columnManager.findColumn(e);
    return this.initGuard(), i ? i.updateDefinition(t) : (console.warn("Column Update Error - No matching column found:", e), Promise.reject());
  }
  moveColumn(e, t, i) {
    var o = this.columnManager.findColumn(e), n = this.columnManager.findColumn(t);
    this.initGuard(), o ? n ? this.columnManager.moveColumn(o, n, i) : console.warn("Move Error - No matching column found:", n) : console.warn("Move Error - No matching column found:", e);
  }
  //scroll to column in DOM
  scrollToColumn(e, t, i) {
    return new Promise((o, n) => {
      var s = this.columnManager.findColumn(e);
      return s ? this.columnManager.scrollToColumn(s, t, i) : (console.warn("Scroll Error - No matching column found:", e), Promise.reject("Scroll Error - No matching column found"));
    });
  }
  //////////// General Public Functions ////////////
  //redraw list without updating data
  redraw(e) {
    this.initGuard(), this.columnManager.redraw(e), this.rowManager.redraw(e);
  }
  setHeight(e) {
    this.options.height = isNaN(e) ? e : e + "px", this.element.style.height = this.options.height, this.rowManager.initializeRenderer(), this.rowManager.redraw();
  }
  //////////////////// Event Bus ///////////////////
  on(e, t) {
    this.externalEvents.subscribe(e, t);
  }
  off(e, t) {
    this.externalEvents.unsubscribe(e, t);
  }
  dispatchEvent() {
    var e = Array.from(arguments);
    e.shift(), this.externalEvents.dispatch(...arguments);
  }
  //////////////////// Alerts ///////////////////
  alert(e, t) {
    this.initGuard(), this.alertManager.alert(e, t);
  }
  clearAlert() {
    this.initGuard(), this.alertManager.clear();
  }
  ////////////// Extension Management //////////////
  modExists(e, t) {
    return this.modules[e] ? !0 : (t && console.error("Tabulator Module Not Installed: " + e), !1);
  }
  module(e) {
    var t = this.modules[e];
    return t || console.error("Tabulator module not installed: " + e), t;
  }
}
wi.defaultOptions = P5;
new zS(wi);
class B5 extends wi {
}
new zS(B5, Q5);
const q5 = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #888;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}
.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}
.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}
.tabulator.tabulator-block-select {
  user-select: none;
}
.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}
.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}
.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #e6e6e6;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #cdcdcd;
  pointer-events: none;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: 0.6;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: clip;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #cdcdcd;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}
.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: #f3f3f3 !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f3f3f3 !important;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle,
.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}
.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator .tabulator-tableholder:focus {
  outline: none;
}
.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: 700;
  font-size: 20px;
  white-space: normal;
}
.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: 700;
  background: #e2e2e2 !important;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}
.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}
.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}
.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}
.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: 400;
}
.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}
.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}
.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}
.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: hsla(0, 0%, 100%, 0.2);
}
.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}
.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}
.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}
.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}
.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}
.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: 700;
  font-size: 16px;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #d00;
  color: #590000;
}
.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}
.tabulator-row.tabulator-row-even {
  background-color: #efefef;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-selected {
  background-color: #9abcea;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769bcc;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}
.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}
.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}
.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}
.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}
.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}
.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}
.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}
.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1d68cd;
  outline: none;
  padding: 0;
}
.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #d00;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #d00;
}
.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: 700;
  font-size: 1.1em;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: 0.7;
    cursor: pointer;
  }
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}
.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}
.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}
.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}
.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}
.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}
.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}
.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}
.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}
.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #efefef;
  }
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu:after {
  display: inline-block;
  position: absolute;
  top: calc(5px + 0.4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: "";
  border-color: #aaa;
  border-style: solid;
  border-width: 1px 1px 0 0;
  vertical-align: top;
  transform: rotate(45deg);
}
.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}
.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}
.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1d68cd;
}
.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid hsla(0, 0%, 100%, 0.5);
}
.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1d68cd;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1d68cd;
  }
}
.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}
.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 6px 4px 4px;
  color: #333;
  font-weight: 700;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}
.tabulator.tabulator-ltr {
  direction: ltr;
}
.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: 0;
  margin-left: -1px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: auto;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: 0;
  margin-left: 5px;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: 0;
  margin-left: 5px;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}
.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}
.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}
body.tabulator-print-fullscreen-hide > :not(.tabulator-print-fullscreen) {
  display: none !important;
}
.tabulator-print-table {
  border-collapse: collapse;
}
.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
`, H5 = {
  setup() {
    const r = ro("style", {}, q5);
    return () => r;
  }
}, j5 = `
.tabulator {
  position: relative;
  border: 1px solid #ddd;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #ddd;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #ddd;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ececec !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #ddd;
  background-color: #e6e6e6;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #f9f9f9;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  background-color: #fff;
  margin-bottom: 20px;
  border: none;
}

.tabulator .tabulator-header {
  border-bottom: 2px solid #ddd;
  background-color: #fff;
  color: inherit;
}

.tabulator .tabulator-header .tabulator-col {
  background-color: #fff;
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 8px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  width: 100%;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-tableholder .tabulator-table {
  color: inherit;
}

.tabulator .tabulator-footer {
  border-top: 2px solid #ddd;
  background: inherit;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-footer .tabulator-paginator {
  color: inherit;
}

.tabulator.table-striped .tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

.tabulator.table-bordered {
  border: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #ddd;
}

.tabulator.table-condensed .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 5px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row {
  min-height: 24px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 5px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.active {
  background: #f5f5f5 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.success {
  background: #dff0d8 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.info {
  background: #d9edf7 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.warning {
  background: #fcf8e3 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.danger {
  background: #f2dede !important;
}

.tabulator-row {
  min-height: 30px;
  border-bottom: 1px solid #ddd;
}

.tabulator-row.tabulator-row-even {
  background-color: transparent;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5 !important;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC !important;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell {
  padding: 8px;
  border-right: none;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

.tabulator-row.tabulator-group {
  background: #fafafa;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-edit-select-list .tabulator-edit-select-list-item {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-notice {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-group {
  color: inherit;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  border: none;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-print-table-group {
  background: #fafafa;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #666;
}

.tabulator-print-table .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

/*# sourceMappingURL=tabulator_bootstrap3.css.map */
`, G5 = {
  setup() {
    const r = ro("style", {}, j5);
    return () => r;
  }
}, K5 = `
.tabulator {
  position: relative;
  border: 1px solid #fff;
  background-color: #fff;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #3759D7;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #fff;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #3759D7;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #fff;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #b7c3f1;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #3759D7;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #f3f3f3;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #fff;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #fff;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #fff;
  border-top: 1px solid #fff;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #3759D7;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #3759D7;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #fff;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #f3f3f3;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #f3f3f3;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #f3f3f3;
  border: 1px solid #fff;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #fff;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #fff;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #f3f3f3;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(243, 243, 243, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #f3f3f3;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #fff;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #fff;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator .tabulator-header {
  border-bottom: 3px solid #3759D7;
  margin-bottom: 4px;
  padding-left: 10px;
  font-size: 1.1em;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: 2px solid #fff;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-col:nth-child(1) {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  border: 1px solid #3759D7;
  font-size: 1em;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border-top: 2px solid #3759D7 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  padding-left: 0 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-top: 3px solid #3759D7 !important;
  border-bottom: 2px solid #3759D7 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid transparent;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  border-bottom: none !important;
}

.tabulator-row {
  margin-bottom: 2px;
}

.tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid #3759D7;
}

.tabulator-row:nth-child(even) {
  background-color: #627ce0;
}

.tabulator-row:nth-child(even) .tabulator-cell {
  background-color: #fff;
}

.tabulator-row:nth-child(even) .tabulator-cell:first-child {
  border-left: 10px solid #627ce0;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    cursor: pointer;
  }
  .tabulator-row.tabulator-selectable:hover .tabulator-cell {
    background-color: #bbb;
  }
}

.tabulator-row.tabulator-selected .tabulator-cell {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover .tabulator-cell {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-moving {
  pointer-events: none !important;
}

.tabulator-row .tabulator-cell {
  padding: 6px 4px;
  border-right: 2px solid #fff;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-group {
  min-width: 100%;
  margin-bottom: 2px;
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  border-right: none;
  background: #8ca0e8;
}

.tabulator-row.tabulator-group span {
  color: #3759D7;
}

.tabulator-edit-select-list {
  border: 1px solid #1D68CD;
}

.tabulator-print-table .tabulator-print-table-group {
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  background: #8ca0e8;
  margin-bottom: 2px;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #3759D7;
}

/*# sourceMappingURL=tabulator_modern.css.map */
`, J5 = {
  setup() {
    const r = ro("style", {}, K5);
    return () => r;
  }
}, eZ = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: white;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: transparent;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: rgba(0, 0, 0, 0);
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0);
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #363636;
  color: #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: rgba(13, 13, 13, 0) !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: transparent;
  white-space: nowrap;
  overflow: visible;
  color: #363636;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ededed !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: rgba(13, 13, 13, 0) !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #363636;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: transparent;
}

.tabulator-row.tabulator-row-even {
  background-color: #fafafa;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #fafafa;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: transparent;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: transparent;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: transparent;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fafafa;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #aaa;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #363636;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: transparent;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(0, 0, 0, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: transparent;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #363636;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 4px;
  padding-top: 6px;
  color: #363636;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator {
  border: none;
}

.tabulator .tabulator-header {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  border: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.5em 0.75em;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  right: 0px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input {
  border: 1px solid #dbdbdb;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  margin: -5px -10px 10px -10px;
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer .tabulator-page {
  margin: 0 0.1875em;
  padding: calc(0.375em - 1px) 0.75em;
  border: 1px solid #dbdbdb;
  font-size: 16px;
}

.tabulator .tabulator-footer .tabulator-page.active {
  border-color: #4a4a4a;
  color: #363636;
  font-weight: bold;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    border-color: #b5b5b5;
    background: inherit;
    color: inherit;
  }
}

.tabulator.is-striped .tabulator-row:nth-child(even) {
  background-color: #fafafa;
}

.tabulator.is-bordered {
  border: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-narrow .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.25em 0.5em;
}

.tabulator.is-narrow .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 0.25em 0.5em;
}

.tabulator-row {
  min-height: 22px;
}

.tabulator-row.tabulator-row-even {
  background-color: inherit;
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2 !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #009e86 !important;
  }
}

.tabulator-row .tabulator-cell {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 0 0 1px;
}

.tabulator-row.tabulator-group {
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-popup-container {
  background: white;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: white;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    color: white;
  }
}

/*# sourceMappingURL=tabulator_bulma.css.map */
`, tZ = {
  setup() {
    const r = ro("style", {}, eZ);
    return () => r;
  }
}, iZ = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #ddd;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #ddd;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #ddd;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  border: none;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #999;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator-row {
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #666;
}

/*# sourceMappingURL=tabulator_simple.css.map */
`, rZ = {
  setup() {
    const r = ro("style", {}, iZ);
    return () => r;
  }
}, oZ = { class: "ns-table-theme-box" }, nZ = /* @__PURE__ */ to({
  __name: "theme",
  props: {
    theme: {
      type: String,
      default: "default"
    }
  },
  setup(r) {
    return (e, t) => (et(), Fr("span", oZ, [
      r.theme === "default" ? (et(), Xi(H5, { key: 0 })) : lo("", !0),
      r.theme === "bootstrap3" ? (et(), Xi(G5, { key: 1 })) : lo("", !0),
      r.theme === "modern" ? (et(), Xi(J5, { key: 2 })) : lo("", !0),
      r.theme === "bulma" ? (et(), Xi(tZ, { key: 3 })) : lo("", !0),
      r.theme === "sample" ? (et(), Xi(rZ, { key: 4 })) : lo("", !0)
    ]));
  }
}), sZ = { class: "ns-table-box" }, aZ = ["id"], lZ = /* @__PURE__ */ to({
  __name: "table",
  props: {
    columns: {
      type: Array,
      default: () => []
    },
    data: {
      type: Array,
      default: () => []
    },
    options: {
      type: Object,
      default: () => ({})
    },
    theme: {
      type: String,
      default: "default"
    }
  },
  emits: [
    "loaded"
  ],
  setup(r, { emit: e }) {
    const t = r, i = A0.v4();
    let o = null;
    const n = gt(null), s = gt(!1);
    wi.registerModule(Kn), wi.registerModule(Ft), wi.registerModule(rg);
    function a() {
      n.value || setTimeout(() => {
        a();
      }, 1e3), delete t.options.data, delete t.options.columns;
      const l = {
        height: "300px",
        data: t.data,
        columns: t.columns,
        ...t.options
      };
      console.log(`↓↓↓↓↓↓↓↓↓↓ options ↓↓↓↓↓↓↓↓↓↓
`, l, `
↑↑↑↑↑↑↑↑↑↑ END ↑↑↑↑↑↑↑↑↑↑`), o = new wi(n.value, {
        ...l
      }), s.value = !0, e("loaded", i, o);
    }
    return yi(() => t.columns, (l) => {
      console.log(`↓↓↓↓↓↓↓↓↓↓ columns - 1 ↓↓↓↓↓↓↓↓↓↓
`, l, `
↑↑↑↑↑↑↑↑↑↑ END ↑↑↑↑↑↑↑↑↑↑`), l && console.log(`↓↓↓↓↓↓↓↓↓↓ columns - 2 ↓↓↓↓↓↓↓↓↓↓
`, l, `
↑↑↑↑↑↑↑↑↑↑ END ↑↑↑↑↑↑↑↑↑↑`);
    }, {
      deep: !0
    }), yi(() => t.data, (l) => {
      console.log(`↓↓↓↓↓↓↓↓↓↓ init data ↓↓↓↓↓↓↓↓↓↓
`, l, `
↑↑↑↑↑↑↑↑↑↑ END ↑↑↑↑↑↑↑↑↑↑`);
    }, {
      deep: !0,
      immediate: !0
    }), io(() => {
      a();
    }), (l, u) => (et(), Fr("div", sZ, [
      ke(nZ, { theme: r.theme }, null, 8, ["theme"]),
      Bn("div", {
        class: "ns-table-body",
        id: Yu(i),
        ref_key: "RefBox",
        ref: n
      }, null, 8, aZ)
    ]));
  }
}), uZ = "", hZ = `.ns-table-box[data-v-e6c53e70],.ns-table-box .ns-table-body[data-v-e6c53e70]{width:100%;height:100%;overflow:hidden;box-sizing:border-box}
`, cZ = /* @__PURE__ */ Sa(lZ, [["styles", [uZ, hZ]], ["__scopeId", "data-v-e6c53e70"]]), HO = {
  "ns-sandbox": c$,
  "ns-splitpane": w$,
  "ns-codeide": tV,
  "ns-table": cZ
};
for (let r in HO) {
  const e = HO[r], t = Ff(e);
  customElements.define(r, t);
}
