var Zq = Object.defineProperty;
var qq = (r, e, t) => e in r ? Zq(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var ai = (r, e, t) => (qq(r, typeof e != "symbol" ? e + "" : e, t), t);
function bi(r, e) {
  const t = /* @__PURE__ */ Object.create(null), i = r.split(",");
  for (let n = 0; n < i.length; n++)
    t[i[n]] = !0;
  return e ? (n) => !!t[n.toLowerCase()] : (n) => !!t[n];
}
const _t = {}.NODE_ENV !== "production" ? Object.freeze({}) : {}, tf = {}.NODE_ENV !== "production" ? Object.freeze([]) : [], dr = () => {
}, xp = () => !1, jq = /^on[^a-z]/, is = (r) => jq.test(r), TE = (r) => r.startsWith("onUpdate:"), ut = Object.assign, yw = (r, e) => {
  const t = r.indexOf(e);
  t > -1 && r.splice(t, 1);
}, Kq = Object.prototype.hasOwnProperty, Et = (r, e) => Kq.call(r, e), pe = Array.isArray, nc = (r) => Yf(r) === "[object Map]", Bc = (r) => Yf(r) === "[object Set]", JP = (r) => Yf(r) === "[object Date]", Jq = (r) => Yf(r) === "[object RegExp]", Ue = (r) => typeof r == "function", qe = (r) => typeof r == "string", Sl = (r) => typeof r == "symbol", Tt = (r) => r !== null && typeof r == "object", xS = (r) => Tt(r) && Ue(r.then) && Ue(r.catch), O5 = Object.prototype.toString, Yf = (r) => O5.call(r), Rw = (r) => Yf(r).slice(8, -1), m5 = (r) => Yf(r) === "[object Object]", Aw = (r) => qe(r) && r !== "NaN" && r[0] !== "-" && "" + parseInt(r, 10) === r, ac = /* @__PURE__ */ bi(
  // the leading comma is intentional so empty string "" is also included
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
), E5 = /* @__PURE__ */ bi(
  "bind,cloak,else-if,else,for,html,if,model,on,once,pre,show,slot,text,memo"
), PS = (r) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = r(t));
}, ej = /-(\w)/g, Cr = PS((r) => r.replace(ej, (e, t) => t ? t.toUpperCase() : "")), tj = /\B([A-Z])/g, Li = PS(
  (r) => r.replace(tj, "-$1").toLowerCase()
), bo = PS(
  (r) => r.charAt(0).toUpperCase() + r.slice(1)
), Ka = PS(
  (r) => r ? `on${bo(r)}` : ""
), mf = (r, e) => !Object.is(r, e), zs = (r, e) => {
  for (let t = 0; t < r.length; t++)
    r[t](e);
}, yE = (r, e, t) => {
  Object.defineProperty(r, e, {
    configurable: !0,
    enumerable: !1,
    value: t
  });
}, RE = (r) => {
  const e = parseFloat(r);
  return isNaN(e) ? r : e;
}, AE = (r) => {
  const e = qe(r) ? Number(r) : NaN;
  return isNaN(e) ? r : e;
};
let eL;
const _E = () => eL || (eL = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), po = {
  1: "TEXT",
  2: "CLASS",
  4: "STYLE",
  8: "PROPS",
  16: "FULL_PROPS",
  32: "HYDRATE_EVENTS",
  64: "STABLE_FRAGMENT",
  128: "KEYED_FRAGMENT",
  256: "UNKEYED_FRAGMENT",
  512: "NEED_PATCH",
  1024: "DYNAMIC_SLOTS",
  2048: "DEV_ROOT_FRAGMENT",
  [-1]: "HOISTED",
  [-2]: "BAIL"
}, rj = {
  1: "STABLE",
  2: "DYNAMIC",
  3: "FORWARDED"
}, ij = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console", nj = /* @__PURE__ */ bi(ij), tL = 2;
function aj(r, e = 0, t = r.length) {
  let i = r.split(/(\r?\n)/);
  const n = i.filter((s, l) => l % 2 === 1);
  i = i.filter((s, l) => l % 2 === 0);
  let a = 0;
  const o = [];
  for (let s = 0; s < i.length; s++)
    if (a += i[s].length + (n[s] && n[s].length || 0), a >= e) {
      for (let l = s - tL; l <= s + tL || t > a; l++) {
        if (l < 0 || l >= i.length)
          continue;
        const u = l + 1;
        o.push(
          `${u}${" ".repeat(Math.max(3 - String(u).length, 0))}|  ${i[l]}`
        );
        const c = i[l].length, h = n[l] && n[l].length || 0;
        if (l === s) {
          const f = e - (a - (c + h)), d = Math.max(
            1,
            t > a ? c - f : t - e
          );
          o.push("   |  " + " ".repeat(f) + "^".repeat(d));
        } else if (l > s) {
          if (t > a) {
            const f = Math.max(Math.min(t - a, c), 1);
            o.push("   |  " + "^".repeat(f));
          }
          a += c + h;
        }
      }
      break;
    }
  return o.join(`
`);
}
function Na(r) {
  if (pe(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
      const i = r[t], n = qe(i) ? b5(i) : Na(i);
      if (n)
        for (const a in n)
          e[a] = n[a];
    }
    return e;
  } else {
    if (qe(r))
      return r;
    if (Tt(r))
      return r;
  }
}
const oj = /;(?![^(]*\))/g, sj = /:([^]+)/, lj = /\/\*[^]*?\*\//g;
function b5(r) {
  const e = {};
  return r.replace(lj, "").split(oj).forEach((t) => {
    if (t) {
      const i = t.split(sj);
      i.length > 1 && (e[i[0].trim()] = i[1].trim());
    }
  }), e;
}
function Hf(r) {
  let e = "";
  if (qe(r))
    e = r;
  else if (pe(r))
    for (let t = 0; t < r.length; t++) {
      const i = Hf(r[t]);
      i && (e += i + " ");
    }
  else if (Tt(r))
    for (const t in r)
      r[t] && (e += t + " ");
  return e.trim();
}
function uj(r) {
  if (!r)
    return null;
  let { class: e, style: t } = r;
  return e && !qe(e) && (r.class = Hf(e)), t && (r.style = Na(t)), r;
}
const cj = "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,hgroup,h1,h2,h3,h4,h5,h6,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,summary,template,blockquote,iframe,tfoot", hj = "svg,animate,animateMotion,animateTransform,circle,clipPath,color-profile,defs,desc,discard,ellipse,feBlend,feColorMatrix,feComponentTransfer,feComposite,feConvolveMatrix,feDiffuseLighting,feDisplacementMap,feDistantLight,feDropShadow,feFlood,feFuncA,feFuncB,feFuncG,feFuncR,feGaussianBlur,feImage,feMerge,feMergeNode,feMorphology,feOffset,fePointLight,feSpecularLighting,feSpotLight,feTile,feTurbulence,filter,foreignObject,g,hatch,hatchpath,image,line,linearGradient,marker,mask,mesh,meshgradient,meshpatch,meshrow,metadata,mpath,path,pattern,polygon,polyline,radialGradient,rect,set,solidcolor,stop,switch,symbol,text,textPath,title,tspan,unknown,use,view", fj = "area,base,br,col,embed,hr,img,input,link,meta,param,source,track,wbr", S5 = /* @__PURE__ */ bi(cj), T5 = /* @__PURE__ */ bi(hj), dj = /* @__PURE__ */ bi(fj), pj = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", gj = /* @__PURE__ */ bi(pj);
function y5(r) {
  return !!r || r === "";
}
function vj(r, e) {
  if (r.length !== e.length)
    return !1;
  let t = !0;
  for (let i = 0; t && i < r.length; i++)
    t = Tl(r[i], e[i]);
  return t;
}
function Tl(r, e) {
  if (r === e)
    return !0;
  let t = JP(r), i = JP(e);
  if (t || i)
    return t && i ? r.getTime() === e.getTime() : !1;
  if (t = Sl(r), i = Sl(e), t || i)
    return r === e;
  if (t = pe(r), i = pe(e), t || i)
    return t && i ? vj(r, e) : !1;
  if (t = Tt(r), i = Tt(e), t || i) {
    if (!t || !i)
      return !1;
    const n = Object.keys(r).length, a = Object.keys(e).length;
    if (n !== a)
      return !1;
    for (const o in r) {
      const s = r.hasOwnProperty(o), l = e.hasOwnProperty(o);
      if (s && !l || !s && l || !Tl(r[o], e[o]))
        return !1;
    }
  }
  return String(r) === String(e);
}
function LS(r, e) {
  return r.findIndex((t) => Tl(t, e));
}
const R5 = (r) => qe(r) ? r : r == null ? "" : pe(r) || Tt(r) && (r.toString === O5 || !Ue(r.toString)) ? JSON.stringify(r, A5, 2) : String(r), A5 = (r, e) => e && e.__v_isRef ? A5(r, e.value) : nc(e) ? {
  [`Map(${e.size})`]: [...e.entries()].reduce((t, [i, n]) => (t[`${i} =>`] = n, t), {})
} : Bc(e) ? {
  [`Set(${e.size})`]: [...e.values()]
} : Tt(e) && !pe(e) && !m5(e) ? String(e) : e;
function CE(r, ...e) {
  console.warn(`[Vue warn] ${r}`, ...e);
}
let hn;
class _w {
  constructor(e = !1) {
    this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this.parent = hn, !e && hn && (this.index = (hn.scopes || (hn.scopes = [])).push(
      this
    ) - 1);
  }
  get active() {
    return this._active;
  }
  run(e) {
    if (this._active) {
      const t = hn;
      try {
        return hn = this, e();
      } finally {
        hn = t;
      }
    } else
      ({}).NODE_ENV !== "production" && CE("cannot run an inactive effect scope.");
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  on() {
    hn = this;
  }
  /**
   * This should only be called on non-detached scopes
   * @internal
   */
  off() {
    hn = this.parent;
  }
  stop(e) {
    if (this._active) {
      let t, i;
      for (t = 0, i = this.effects.length; t < i; t++)
        this.effects[t].stop();
      for (t = 0, i = this.cleanups.length; t < i; t++)
        this.cleanups[t]();
      if (this.scopes)
        for (t = 0, i = this.scopes.length; t < i; t++)
          this.scopes[t].stop(!0);
      if (!this.detached && this.parent && !e) {
        const n = this.parent.scopes.pop();
        n && n !== this && (this.parent.scopes[this.index] = n, n.index = this.index);
      }
      this.parent = void 0, this._active = !1;
    }
  }
}
function Oj(r) {
  return new _w(r);
}
function _5(r, e = hn) {
  e && e.active && e.effects.push(r);
}
function C5() {
  return hn;
}
function mj(r) {
  hn ? hn.cleanups.push(r) : {}.NODE_ENV !== "production" && CE(
    "onScopeDispose() is called when there is no active effect scope to be associated with."
  );
}
const ug = (r) => {
  const e = new Set(r);
  return e.w = 0, e.n = 0, e;
}, I5 = (r) => (r.w & yl) > 0, w5 = (r) => (r.n & yl) > 0, Ej = ({ deps: r }) => {
  if (r.length)
    for (let e = 0; e < r.length; e++)
      r[e].w |= yl;
}, bj = (r) => {
  const { deps: e } = r;
  if (e.length) {
    let t = 0;
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      I5(n) && !w5(n) ? n.delete(r) : e[t++] = n, n.w &= ~yl, n.n &= ~yl;
    }
    e.length = t;
  }
}, IE = /* @__PURE__ */ new WeakMap();
let up = 0, yl = 1;
const ZA = 30;
let Ni;
const oc = Symbol({}.NODE_ENV !== "production" ? "iterate" : ""), qA = Symbol({}.NODE_ENV !== "production" ? "Map key iterate" : "");
class pv {
  constructor(e, t = null, i) {
    this.fn = e, this.scheduler = t, this.active = !0, this.deps = [], this.parent = void 0, _5(this, i);
  }
  run() {
    if (!this.active)
      return this.fn();
    let e = Ni, t = ll;
    for (; e; ) {
      if (e === this)
        return;
      e = e.parent;
    }
    try {
      return this.parent = Ni, Ni = this, ll = !0, yl = 1 << ++up, up <= ZA ? Ej(this) : rL(this), this.fn();
    } finally {
      up <= ZA && bj(this), yl = 1 << --up, Ni = this.parent, ll = t, this.parent = void 0, this.deferStop && this.stop();
    }
  }
  stop() {
    Ni === this ? this.deferStop = !0 : this.active && (rL(this), this.onStop && this.onStop(), this.active = !1);
  }
}
function rL(r) {
  const { deps: e } = r;
  if (e.length) {
    for (let t = 0; t < e.length; t++)
      e[t].delete(r);
    e.length = 0;
  }
}
function Sj(r, e) {
  r.effect && (r = r.effect.fn);
  const t = new pv(r);
  e && (ut(t, e), e.scope && _5(t, e.scope)), (!e || !e.lazy) && t.run();
  const i = t.run.bind(t);
  return i.effect = t, i;
}
function Tj(r) {
  r.effect.stop();
}
let ll = !0;
const N5 = [];
function Fc() {
  N5.push(ll), ll = !1;
}
function Xc() {
  const r = N5.pop();
  ll = r === void 0 ? !0 : r;
}
function ei(r, e, t) {
  if (ll && Ni) {
    let i = IE.get(r);
    i || IE.set(r, i = /* @__PURE__ */ new Map());
    let n = i.get(t);
    n || i.set(t, n = ug());
    const a = {}.NODE_ENV !== "production" ? { effect: Ni, target: r, type: e, key: t } : void 0;
    jA(n, a);
  }
}
function jA(r, e) {
  let t = !1;
  up <= ZA ? w5(r) || (r.n |= yl, t = !I5(r)) : t = !r.has(Ni), t && (r.add(Ni), Ni.deps.push(r), {}.NODE_ENV !== "production" && Ni.onTrack && Ni.onTrack(
    ut(
      {
        effect: Ni
      },
      e
    )
  ));
}
function So(r, e, t, i, n, a) {
  const o = IE.get(r);
  if (!o)
    return;
  let s = [];
  if (e === "clear")
    s = [...o.values()];
  else if (t === "length" && pe(r)) {
    const u = Number(i);
    o.forEach((c, h) => {
      (h === "length" || h >= u) && s.push(c);
    });
  } else
    switch (t !== void 0 && s.push(o.get(t)), e) {
      case "add":
        pe(r) ? Aw(t) && s.push(o.get("length")) : (s.push(o.get(oc)), nc(r) && s.push(o.get(qA)));
        break;
      case "delete":
        pe(r) || (s.push(o.get(oc)), nc(r) && s.push(o.get(qA)));
        break;
      case "set":
        nc(r) && s.push(o.get(oc));
        break;
    }
  const l = {}.NODE_ENV !== "production" ? { target: r, type: e, key: t, newValue: i, oldValue: n, oldTarget: a } : void 0;
  if (s.length === 1)
    s[0] && ({}.NODE_ENV !== "production" ? Xh(s[0], l) : Xh(s[0]));
  else {
    const u = [];
    for (const c of s)
      c && u.push(...c);
    ({}).NODE_ENV !== "production" ? Xh(ug(u), l) : Xh(ug(u));
  }
}
function Xh(r, e) {
  const t = pe(r) ? r : [...r];
  for (const i of t)
    i.computed && iL(i, e);
  for (const i of t)
    i.computed || iL(i, e);
}
function iL(r, e) {
  (r !== Ni || r.allowRecurse) && ({}.NODE_ENV !== "production" && r.onTrigger && r.onTrigger(ut({ effect: r }, e)), r.scheduler ? r.scheduler() : r.run());
}
function yj(r, e) {
  var t;
  return (t = IE.get(r)) == null ? void 0 : t.get(e);
}
const Rj = /* @__PURE__ */ bi("__proto__,__v_isRef,__isVue"), x5 = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((r) => r !== "arguments" && r !== "caller").map((r) => Symbol[r]).filter(Sl)
), Aj = /* @__PURE__ */ DS(), _j = /* @__PURE__ */ DS(!1, !0), Cj = /* @__PURE__ */ DS(!0), Ij = /* @__PURE__ */ DS(!0, !0), nL = /* @__PURE__ */ wj();
function wj() {
  const r = {};
  return ["includes", "indexOf", "lastIndexOf"].forEach((e) => {
    r[e] = function(...t) {
      const i = je(this);
      for (let a = 0, o = this.length; a < o; a++)
        ei(i, "get", a + "");
      const n = i[e](...t);
      return n === -1 || n === !1 ? i[e](...t.map(je)) : n;
    };
  }), ["push", "pop", "shift", "unshift", "splice"].forEach((e) => {
    r[e] = function(...t) {
      Fc();
      const i = je(this)[e].apply(this, t);
      return Xc(), i;
    };
  }), r;
}
function Nj(r) {
  const e = je(this);
  return ei(e, "has", r), e.hasOwnProperty(r);
}
function DS(r = !1, e = !1) {
  return function(i, n, a) {
    if (n === "__v_isReactive")
      return !r;
    if (n === "__v_isReadonly")
      return r;
    if (n === "__v_isShallow")
      return e;
    if (n === "__v_raw" && a === (r ? e ? $5 : U5 : e ? Q5 : k5).get(i))
      return i;
    const o = pe(i);
    if (!r) {
      if (o && Et(nL, n))
        return Reflect.get(nL, n, a);
      if (n === "hasOwnProperty")
        return Nj;
    }
    const s = Reflect.get(i, n, a);
    return (Sl(n) ? x5.has(n) : Rj(n)) || (r || ei(i, "get", n), e) ? s : sr(s) ? o && Aw(n) ? s : s.value : Tt(s) ? r ? Iw(s) : QS(s) : s;
  };
}
const xj = /* @__PURE__ */ P5(), Pj = /* @__PURE__ */ P5(!0);
function P5(r = !1) {
  return function(t, i, n, a) {
    let o = t[i];
    if (ns(o) && sr(o) && !sr(n))
      return !1;
    if (!r && (!cg(n) && !ns(n) && (o = je(o), n = je(n)), !pe(t) && sr(o) && !sr(n)))
      return o.value = n, !0;
    const s = pe(t) && Aw(i) ? Number(i) < t.length : Et(t, i), l = Reflect.set(t, i, n, a);
    return t === je(a) && (s ? mf(n, o) && So(t, "set", i, n, o) : So(t, "add", i, n)), l;
  };
}
function Lj(r, e) {
  const t = Et(r, e), i = r[e], n = Reflect.deleteProperty(r, e);
  return n && t && So(r, "delete", e, void 0, i), n;
}
function Dj(r, e) {
  const t = Reflect.has(r, e);
  return (!Sl(e) || !x5.has(e)) && ei(r, "has", e), t;
}
function Mj(r) {
  return ei(r, "iterate", pe(r) ? "length" : oc), Reflect.ownKeys(r);
}
const L5 = {
  get: Aj,
  set: xj,
  deleteProperty: Lj,
  has: Dj,
  ownKeys: Mj
}, D5 = {
  get: Cj,
  set(r, e) {
    return {}.NODE_ENV !== "production" && CE(
      `Set operation on key "${String(e)}" failed: target is readonly.`,
      r
    ), !0;
  },
  deleteProperty(r, e) {
    return {}.NODE_ENV !== "production" && CE(
      `Delete operation on key "${String(e)}" failed: target is readonly.`,
      r
    ), !0;
  }
}, kj = /* @__PURE__ */ ut(
  {},
  L5,
  {
    get: _j,
    set: Pj
  }
), Qj = /* @__PURE__ */ ut(
  {},
  D5,
  {
    get: Ij
  }
), Cw = (r) => r, MS = (r) => Reflect.getPrototypeOf(r);
function tO(r, e, t = !1, i = !1) {
  r = r.__v_raw;
  const n = je(r), a = je(e);
  t || (e !== a && ei(n, "get", e), ei(n, "get", a));
  const { has: o } = MS(n), s = i ? Cw : t ? Nw : fg;
  if (o.call(n, e))
    return s(r.get(e));
  if (o.call(n, a))
    return s(r.get(a));
  r !== n && r.get(e);
}
function rO(r, e = !1) {
  const t = this.__v_raw, i = je(t), n = je(r);
  return e || (r !== n && ei(i, "has", r), ei(i, "has", n)), r === n ? t.has(r) : t.has(r) || t.has(n);
}
function iO(r, e = !1) {
  return r = r.__v_raw, !e && ei(je(r), "iterate", oc), Reflect.get(r, "size", r);
}
function aL(r) {
  r = je(r);
  const e = je(this);
  return MS(e).has.call(e, r) || (e.add(r), So(e, "add", r, r)), this;
}
function oL(r, e) {
  e = je(e);
  const t = je(this), { has: i, get: n } = MS(t);
  let a = i.call(t, r);
  a ? {}.NODE_ENV !== "production" && M5(t, i, r) : (r = je(r), a = i.call(t, r));
  const o = n.call(t, r);
  return t.set(r, e), a ? mf(e, o) && So(t, "set", r, e, o) : So(t, "add", r, e), this;
}
function sL(r) {
  const e = je(this), { has: t, get: i } = MS(e);
  let n = t.call(e, r);
  n ? {}.NODE_ENV !== "production" && M5(e, t, r) : (r = je(r), n = t.call(e, r));
  const a = i ? i.call(e, r) : void 0, o = e.delete(r);
  return n && So(e, "delete", r, void 0, a), o;
}
function lL() {
  const r = je(this), e = r.size !== 0, t = {}.NODE_ENV !== "production" ? nc(r) ? new Map(r) : new Set(r) : void 0, i = r.clear();
  return e && So(r, "clear", void 0, void 0, t), i;
}
function nO(r, e) {
  return function(i, n) {
    const a = this, o = a.__v_raw, s = je(o), l = e ? Cw : r ? Nw : fg;
    return !r && ei(s, "iterate", oc), o.forEach((u, c) => i.call(n, l(u), l(c), a));
  };
}
function aO(r, e, t) {
  return function(...i) {
    const n = this.__v_raw, a = je(n), o = nc(a), s = r === "entries" || r === Symbol.iterator && o, l = r === "keys" && o, u = n[r](...i), c = t ? Cw : e ? Nw : fg;
    return !e && ei(
      a,
      "iterate",
      l ? qA : oc
    ), {
      // iterator protocol
      next() {
        const { value: h, done: f } = u.next();
        return f ? { value: h, done: f } : {
          value: s ? [c(h[0]), c(h[1])] : c(h),
          done: f
        };
      },
      // iterable protocol
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function As(r) {
  return function(...e) {
    if ({}.NODE_ENV !== "production") {
      const t = e[0] ? `on key "${e[0]}" ` : "";
      console.warn(
        `${bo(r)} operation ${t}failed: target is readonly.`,
        je(this)
      );
    }
    return r === "delete" ? !1 : this;
  };
}
function Uj() {
  const r = {
    get(a) {
      return tO(this, a);
    },
    get size() {
      return iO(this);
    },
    has: rO,
    add: aL,
    set: oL,
    delete: sL,
    clear: lL,
    forEach: nO(!1, !1)
  }, e = {
    get(a) {
      return tO(this, a, !1, !0);
    },
    get size() {
      return iO(this);
    },
    has: rO,
    add: aL,
    set: oL,
    delete: sL,
    clear: lL,
    forEach: nO(!1, !0)
  }, t = {
    get(a) {
      return tO(this, a, !0);
    },
    get size() {
      return iO(this, !0);
    },
    has(a) {
      return rO.call(this, a, !0);
    },
    add: As("add"),
    set: As("set"),
    delete: As("delete"),
    clear: As("clear"),
    forEach: nO(!0, !1)
  }, i = {
    get(a) {
      return tO(this, a, !0, !0);
    },
    get size() {
      return iO(this, !0);
    },
    has(a) {
      return rO.call(this, a, !0);
    },
    add: As("add"),
    set: As("set"),
    delete: As("delete"),
    clear: As("clear"),
    forEach: nO(!0, !0)
  };
  return ["keys", "values", "entries", Symbol.iterator].forEach((a) => {
    r[a] = aO(
      a,
      !1,
      !1
    ), t[a] = aO(
      a,
      !0,
      !1
    ), e[a] = aO(
      a,
      !1,
      !0
    ), i[a] = aO(
      a,
      !0,
      !0
    );
  }), [
    r,
    t,
    e,
    i
  ];
}
const [
  $j,
  Vj,
  Gj,
  Bj
] = /* @__PURE__ */ Uj();
function kS(r, e) {
  const t = e ? r ? Bj : Gj : r ? Vj : $j;
  return (i, n, a) => n === "__v_isReactive" ? !r : n === "__v_isReadonly" ? r : n === "__v_raw" ? i : Reflect.get(
    Et(t, n) && n in i ? t : i,
    n,
    a
  );
}
const Fj = {
  get: /* @__PURE__ */ kS(!1, !1)
}, Xj = {
  get: /* @__PURE__ */ kS(!1, !0)
}, Yj = {
  get: /* @__PURE__ */ kS(!0, !1)
}, Hj = {
  get: /* @__PURE__ */ kS(!0, !0)
};
function M5(r, e, t) {
  const i = je(t);
  if (i !== t && e.call(r, i)) {
    const n = Rw(r);
    console.warn(
      `Reactive ${n} contains both the raw and reactive versions of the same object${n === "Map" ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`
    );
  }
}
const k5 = /* @__PURE__ */ new WeakMap(), Q5 = /* @__PURE__ */ new WeakMap(), U5 = /* @__PURE__ */ new WeakMap(), $5 = /* @__PURE__ */ new WeakMap();
function Wj(r) {
  switch (r) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function zj(r) {
  return r.__v_skip || !Object.isExtensible(r) ? 0 : Wj(Rw(r));
}
function QS(r) {
  return ns(r) ? r : US(
    r,
    !1,
    L5,
    Fj,
    k5
  );
}
function V5(r) {
  return US(
    r,
    !1,
    kj,
    Xj,
    Q5
  );
}
function Iw(r) {
  return US(
    r,
    !0,
    D5,
    Yj,
    U5
  );
}
function Yh(r) {
  return US(
    r,
    !0,
    Qj,
    Hj,
    $5
  );
}
function US(r, e, t, i, n) {
  if (!Tt(r))
    return {}.NODE_ENV !== "production" && console.warn(`value cannot be made reactive: ${String(r)}`), r;
  if (r.__v_raw && !(e && r.__v_isReactive))
    return r;
  const a = n.get(r);
  if (a)
    return a;
  const o = zj(r);
  if (o === 0)
    return r;
  const s = new Proxy(
    r,
    o === 2 ? i : t
  );
  return n.set(r, s), s;
}
function ul(r) {
  return ns(r) ? ul(r.__v_raw) : !!(r && r.__v_isReactive);
}
function ns(r) {
  return !!(r && r.__v_isReadonly);
}
function cg(r) {
  return !!(r && r.__v_isShallow);
}
function hg(r) {
  return ul(r) || ns(r);
}
function je(r) {
  const e = r && r.__v_raw;
  return e ? je(e) : r;
}
function ww(r) {
  return yE(r, "__v_skip", !0), r;
}
const fg = (r) => Tt(r) ? QS(r) : r, Nw = (r) => Tt(r) ? Iw(r) : r;
function xw(r) {
  ll && Ni && (r = je(r), {}.NODE_ENV !== "production" ? jA(r.dep || (r.dep = ug()), {
    target: r,
    type: "get",
    key: "value"
  }) : jA(r.dep || (r.dep = ug())));
}
function $S(r, e) {
  r = je(r);
  const t = r.dep;
  t && ({}.NODE_ENV !== "production" ? Xh(t, {
    target: r,
    type: "set",
    key: "value",
    newValue: e
  }) : Xh(t));
}
function sr(r) {
  return !!(r && r.__v_isRef === !0);
}
function Rr(r) {
  return G5(r, !1);
}
function Zj(r) {
  return G5(r, !0);
}
function G5(r, e) {
  return sr(r) ? r : new qj(r, e);
}
class qj {
  constructor(e, t) {
    this.__v_isShallow = t, this.dep = void 0, this.__v_isRef = !0, this._rawValue = t ? e : je(e), this._value = t ? e : fg(e);
  }
  get value() {
    return xw(this), this._value;
  }
  set value(e) {
    const t = this.__v_isShallow || cg(e) || ns(e);
    e = t ? e : je(e), mf(e, this._rawValue) && (this._rawValue = e, this._value = t ? e : fg(e), $S(this, e));
  }
}
function jj(r) {
  $S(r, {}.NODE_ENV !== "production" ? r.value : void 0);
}
function Ef(r) {
  return sr(r) ? r.value : r;
}
function Kj(r) {
  return Ue(r) ? r() : Ef(r);
}
const Jj = {
  get: (r, e, t) => Ef(Reflect.get(r, e, t)),
  set: (r, e, t, i) => {
    const n = r[e];
    return sr(n) && !sr(t) ? (n.value = t, !0) : Reflect.set(r, e, t, i);
  }
};
function Pw(r) {
  return ul(r) ? r : new Proxy(r, Jj);
}
class eK {
  constructor(e) {
    this.dep = void 0, this.__v_isRef = !0;
    const { get: t, set: i } = e(
      () => xw(this),
      () => $S(this)
    );
    this._get = t, this._set = i;
  }
  get value() {
    return this._get();
  }
  set value(e) {
    this._set(e);
  }
}
function tK(r) {
  return new eK(r);
}
function rK(r) {
  ({}).NODE_ENV !== "production" && !hg(r) && console.warn("toRefs() expects a reactive object but received a plain one.");
  const e = pe(r) ? new Array(r.length) : {};
  for (const t in r)
    e[t] = B5(r, t);
  return e;
}
class iK {
  constructor(e, t, i) {
    this._object = e, this._key = t, this._defaultValue = i, this.__v_isRef = !0;
  }
  get value() {
    const e = this._object[this._key];
    return e === void 0 ? this._defaultValue : e;
  }
  set value(e) {
    this._object[this._key] = e;
  }
  get dep() {
    return yj(je(this._object), this._key);
  }
}
class nK {
  constructor(e) {
    this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0;
  }
  get value() {
    return this._getter();
  }
}
function aK(r, e, t) {
  return sr(r) ? r : Ue(r) ? new nK(r) : Tt(r) && arguments.length > 1 ? B5(r, e, t) : Rr(r);
}
function B5(r, e, t) {
  const i = r[e];
  return sr(i) ? i : new iK(
    r,
    e,
    t
  );
}
class oK {
  constructor(e, t, i, n) {
    this._setter = t, this.dep = void 0, this.__v_isRef = !0, this.__v_isReadonly = !1, this._dirty = !0, this.effect = new pv(e, () => {
      this._dirty || (this._dirty = !0, $S(this));
    }), this.effect.computed = this, this.effect.active = this._cacheable = !n, this.__v_isReadonly = i;
  }
  get value() {
    const e = je(this);
    return xw(e), (e._dirty || !e._cacheable) && (e._dirty = !1, e._value = e.effect.run()), e._value;
  }
  set value(e) {
    this._setter(e);
  }
}
function sK(r, e, t = !1) {
  let i, n;
  const a = Ue(r);
  a ? (i = r, n = {}.NODE_ENV !== "production" ? () => {
    console.warn("Write operation failed: computed value is readonly");
  } : dr) : (i = r.get, n = r.set);
  const o = new oK(i, n, a || !n, t);
  return {}.NODE_ENV !== "production" && e && !t && (o.effect.onTrack = e.onTrack, o.effect.onTrigger = e.onTrigger), o;
}
const sc = [];
function Pp(r) {
  sc.push(r);
}
function Lp() {
  sc.pop();
}
function W(r, ...e) {
  if ({}.NODE_ENV === "production")
    return;
  Fc();
  const t = sc.length ? sc[sc.length - 1].component : null, i = t && t.appContext.config.warnHandler, n = lK();
  if (i)
    go(
      i,
      t,
      11,
      [
        r + e.join(""),
        t && t.proxy,
        n.map(
          ({ vnode: a }) => `at <${qS(t, a.type)}>`
        ).join(`
`),
        n
      ]
    );
  else {
    const a = [`[Vue warn]: ${r}`, ...e];
    n.length && a.push(`
`, ...uK(n)), console.warn(...a);
  }
  Xc();
}
function lK() {
  let r = sc[sc.length - 1];
  if (!r)
    return [];
  const e = [];
  for (; r; ) {
    const t = e[0];
    t && t.vnode === r ? t.recurseCount++ : e.push({
      vnode: r,
      recurseCount: 0
    });
    const i = r.component && r.component.parent;
    r = i && i.vnode;
  }
  return e;
}
function uK(r) {
  const e = [];
  return r.forEach((t, i) => {
    e.push(...i === 0 ? [] : [`
`], ...cK(t));
  }), e;
}
function cK({ vnode: r, recurseCount: e }) {
  const t = e > 0 ? `... (${e} recursive calls)` : "", i = r.component ? r.component.parent == null : !1, n = ` at <${qS(
    r.component,
    r.type,
    i
  )}`, a = ">" + t;
  return r.props ? [n, ...hK(r.props), a] : [n + a];
}
function hK(r) {
  const e = [], t = Object.keys(r);
  return t.slice(0, 3).forEach((i) => {
    e.push(...F5(i, r[i]));
  }), t.length > 3 && e.push(" ..."), e;
}
function F5(r, e, t) {
  return qe(e) ? (e = JSON.stringify(e), t ? e : [`${r}=${e}`]) : typeof e == "number" || typeof e == "boolean" || e == null ? t ? e : [`${r}=${e}`] : sr(e) ? (e = F5(r, je(e.value), !0), t ? e : [`${r}=Ref<`, e, ">"]) : Ue(e) ? [`${r}=fn${e.name ? `<${e.name}>` : ""}`] : (e = je(e), t ? e : [`${r}=`, e]);
}
function Lw(r, e) {
  ({}).NODE_ENV !== "production" && r !== void 0 && (typeof r != "number" ? W(`${e} is not a valid number - got ${JSON.stringify(r)}.`) : isNaN(r) && W(`${e} is NaN - the duration expression might be incorrect.`));
}
const Dw = {
  sp: "serverPrefetch hook",
  bc: "beforeCreate hook",
  c: "created hook",
  bm: "beforeMount hook",
  m: "mounted hook",
  bu: "beforeUpdate hook",
  u: "updated",
  bum: "beforeUnmount hook",
  um: "unmounted hook",
  a: "activated hook",
  da: "deactivated hook",
  ec: "errorCaptured hook",
  rtc: "renderTracked hook",
  rtg: "renderTriggered hook",
  0: "setup function",
  1: "render function",
  2: "watcher getter",
  3: "watcher callback",
  4: "watcher cleanup function",
  5: "native event handler",
  6: "component event handler",
  7: "vnode hook",
  8: "directive hook",
  9: "transition hook",
  10: "app errorHandler",
  11: "app warnHandler",
  12: "ref function",
  13: "async component loader",
  14: "scheduler flush. This is likely a Vue internals bug. Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core"
};
function go(r, e, t, i) {
  let n;
  try {
    n = i ? r(...i) : r();
  } catch (a) {
    Yc(a, e, t);
  }
  return n;
}
function En(r, e, t, i) {
  if (Ue(r)) {
    const a = go(r, e, t, i);
    return a && xS(a) && a.catch((o) => {
      Yc(o, e, t);
    }), a;
  }
  const n = [];
  for (let a = 0; a < r.length; a++)
    n.push(En(r[a], e, t, i));
  return n;
}
function Yc(r, e, t, i = !0) {
  const n = e ? e.vnode : null;
  if (e) {
    let a = e.parent;
    const o = e.proxy, s = {}.NODE_ENV !== "production" ? Dw[t] : t;
    for (; a; ) {
      const u = a.ec;
      if (u) {
        for (let c = 0; c < u.length; c++)
          if (u[c](r, o, s) === !1)
            return;
      }
      a = a.parent;
    }
    const l = e.appContext.config.errorHandler;
    if (l) {
      go(
        l,
        null,
        10,
        [r, o, s]
      );
      return;
    }
  }
  fK(r, t, n, i);
}
function fK(r, e, t, i = !0) {
  if ({}.NODE_ENV !== "production") {
    const n = Dw[e];
    if (t && Pp(t), W(`Unhandled error${n ? ` during execution of ${n}` : ""}`), t && Lp(), i)
      throw r;
    console.error(r);
  } else
    console.error(r);
}
let dg = !1, KA = !1;
const pi = [];
let eo = 0;
const rf = [];
let Za = null, Bs = 0;
const X5 = /* @__PURE__ */ Promise.resolve();
let Mw = null;
const dK = 100;
function Sc(r) {
  const e = Mw || X5;
  return r ? e.then(this ? r.bind(this) : r) : e;
}
function pK(r) {
  let e = eo + 1, t = pi.length;
  for (; e < t; ) {
    const i = e + t >>> 1;
    pg(pi[i]) < r ? e = i + 1 : t = i;
  }
  return e;
}
function gv(r) {
  (!pi.length || !pi.includes(
    r,
    dg && r.allowRecurse ? eo + 1 : eo
  )) && (r.id == null ? pi.push(r) : pi.splice(pK(r.id), 0, r), Y5());
}
function Y5() {
  !dg && !KA && (KA = !0, Mw = X5.then(H5));
}
function gK(r) {
  const e = pi.indexOf(r);
  e > eo && pi.splice(e, 1);
}
function VS(r) {
  pe(r) ? rf.push(...r) : (!Za || !Za.includes(
    r,
    r.allowRecurse ? Bs + 1 : Bs
  )) && rf.push(r), Y5();
}
function uL(r, e = dg ? eo + 1 : 0) {
  for ({}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()); e < pi.length; e++) {
    const t = pi[e];
    if (t && t.pre) {
      if ({}.NODE_ENV !== "production" && kw(r, t))
        continue;
      pi.splice(e, 1), e--, t();
    }
  }
}
function wE(r) {
  if (rf.length) {
    const e = [...new Set(rf)];
    if (rf.length = 0, Za) {
      Za.push(...e);
      return;
    }
    for (Za = e, {}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), Za.sort((t, i) => pg(t) - pg(i)), Bs = 0; Bs < Za.length; Bs++)
      ({}).NODE_ENV !== "production" && kw(r, Za[Bs]) || Za[Bs]();
    Za = null, Bs = 0;
  }
}
const pg = (r) => r.id == null ? 1 / 0 : r.id, vK = (r, e) => {
  const t = pg(r) - pg(e);
  if (t === 0) {
    if (r.pre && !e.pre)
      return -1;
    if (e.pre && !r.pre)
      return 1;
  }
  return t;
};
function H5(r) {
  KA = !1, dg = !0, {}.NODE_ENV !== "production" && (r = r || /* @__PURE__ */ new Map()), pi.sort(vK);
  const e = {}.NODE_ENV !== "production" ? (t) => kw(r, t) : dr;
  try {
    for (eo = 0; eo < pi.length; eo++) {
      const t = pi[eo];
      if (t && t.active !== !1) {
        if ({}.NODE_ENV !== "production" && e(t))
          continue;
        go(t, null, 14);
      }
    }
  } finally {
    eo = 0, pi.length = 0, wE(r), dg = !1, Mw = null, (pi.length || rf.length) && H5(r);
  }
}
function kw(r, e) {
  if (!r.has(e))
    r.set(e, 1);
  else {
    const t = r.get(e);
    if (t > dK) {
      const i = e.ownerInstance, n = i && bg(i.type);
      return W(
        `Maximum recursive updates exceeded${n ? ` in component <${n}>` : ""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`
      ), !0;
    } else
      r.set(e, t + 1);
  }
}
let cl = !1;
const Mh = /* @__PURE__ */ new Set();
({}).NODE_ENV !== "production" && (_E().__VUE_HMR_RUNTIME__ = {
  createRecord: by(W5),
  rerender: by(EK),
  reload: by(bK)
});
const Tc = /* @__PURE__ */ new Map();
function OK(r) {
  const e = r.type.__hmrId;
  let t = Tc.get(e);
  t || (W5(e, r.type), t = Tc.get(e)), t.instances.add(r);
}
function mK(r) {
  Tc.get(r.type.__hmrId).instances.delete(r);
}
function W5(r, e) {
  return Tc.has(r) ? !1 : (Tc.set(r, {
    initialDef: Dp(e),
    instances: /* @__PURE__ */ new Set()
  }), !0);
}
function Dp(r) {
  return HF(r) ? r.__vccOpts : r;
}
function EK(r, e) {
  const t = Tc.get(r);
  t && (t.initialDef.render = e, [...t.instances].forEach((i) => {
    e && (i.render = e, Dp(i.type).render = e), i.renderCache = [], cl = !0, i.update(), cl = !1;
  }));
}
function bK(r, e) {
  const t = Tc.get(r);
  if (!t)
    return;
  e = Dp(e), cL(t.initialDef, e);
  const i = [...t.instances];
  for (const n of i) {
    const a = Dp(n.type);
    Mh.has(a) || (a !== t.initialDef && cL(a, e), Mh.add(a)), n.appContext.propsCache.delete(n.type), n.appContext.emitsCache.delete(n.type), n.appContext.optionsCache.delete(n.type), n.ceReload ? (Mh.add(a), n.ceReload(e.styles), Mh.delete(a)) : n.parent ? gv(n.parent.update) : n.appContext.reload ? n.appContext.reload() : typeof window < "u" ? window.location.reload() : console.warn(
      "[HMR] Root or manually mounted instance modified. Full reload required."
    );
  }
  VS(() => {
    for (const n of i)
      Mh.delete(
        Dp(n.type)
      );
  });
}
function cL(r, e) {
  ut(r, e);
  for (const t in r)
    t !== "__file" && !(t in e) && delete r[t];
}
function by(r) {
  return (e, t) => {
    try {
      return r(e, t);
    } catch (i) {
      console.error(i), console.warn(
        "[HMR] Something went wrong during Vue component hot-reload. Full reload required."
      );
    }
  };
}
let ga, cp = [], JA = !1;
function vv(r, ...e) {
  ga ? ga.emit(r, ...e) : JA || cp.push({ event: r, args: e });
}
function Qw(r, e) {
  var t, i;
  ga = r, ga ? (ga.enabled = !0, cp.forEach(({ event: n, args: a }) => ga.emit(n, ...a)), cp = []) : /* handle late devtools injection - only do this if we are in an actual */ /* browser environment to avoid the timer handle stalling test runner exit */ /* (#4815) */ typeof window < "u" && // some envs mock window but not fully
  window.HTMLElement && // also exclude jsdom
  !((i = (t = window.navigator) == null ? void 0 : t.userAgent) != null && i.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push((a) => {
    Qw(a, e);
  }), setTimeout(() => {
    ga || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, JA = !0, cp = []);
  }, 3e3)) : (JA = !0, cp = []);
}
function SK(r, e) {
  vv("app:init", r, e, {
    Fragment: xr,
    Text: Rl,
    Comment: mr,
    Static: hl
  });
}
function TK(r) {
  vv("app:unmount", r);
}
const e_ = /* @__PURE__ */ Uw(
  "component:added"
  /* COMPONENT_ADDED */
), z5 = /* @__PURE__ */ Uw(
  "component:updated"
  /* COMPONENT_UPDATED */
), yK = /* @__PURE__ */ Uw(
  "component:removed"
  /* COMPONENT_REMOVED */
), RK = (r) => {
  ga && typeof ga.cleanupBuffer == "function" && // remove the component if it wasn't buffered
  !ga.cleanupBuffer(r) && yK(r);
};
function Uw(r) {
  return (e) => {
    vv(
      r,
      e.appContext.app,
      e.uid,
      e.parent ? e.parent.uid : void 0,
      e
    );
  };
}
const AK = /* @__PURE__ */ Z5(
  "perf:start"
  /* PERFORMANCE_START */
), _K = /* @__PURE__ */ Z5(
  "perf:end"
  /* PERFORMANCE_END */
);
function Z5(r) {
  return (e, t, i) => {
    vv(r, e.appContext.app, e.uid, e, t, i);
  };
}
function CK(r, e, t) {
  vv(
    "component:emit",
    r.appContext.app,
    r,
    e,
    t
  );
}
function IK(r, e, ...t) {
  if (r.isUnmounted)
    return;
  const i = r.vnode.props || _t;
  if ({}.NODE_ENV !== "production") {
    const {
      emitsOptions: c,
      propsOptions: [h]
    } = r;
    if (c)
      if (!(e in c))
        (!h || !(Ka(e) in h)) && W(
          `Component emitted event "${e}" but it is neither declared in the emits option nor as an "${Ka(e)}" prop.`
        );
      else {
        const f = c[e];
        Ue(f) && (f(...t) || W(
          `Invalid event arguments: event validation failed for event "${e}".`
        ));
      }
  }
  let n = t;
  const a = e.startsWith("update:"), o = a && e.slice(7);
  if (o && o in i) {
    const c = `${o === "modelValue" ? "model" : o}Modifiers`, { number: h, trim: f } = i[c] || _t;
    f && (n = t.map((d) => qe(d) ? d.trim() : d)), h && (n = t.map(RE));
  }
  if ({}.NODE_ENV !== "production" && CK(r, e, n), {}.NODE_ENV !== "production") {
    const c = e.toLowerCase();
    c !== e && i[Ka(c)] && W(
      `Event "${c}" is emitted in component ${qS(
        r,
        r.type
      )} but the handler is registered for "${e}". Note that HTML attributes are case-insensitive and you cannot use v-on to listen to camelCase events when using in-DOM templates. You should probably use "${Li(e)}" instead of "${e}".`
    );
  }
  let s, l = i[s = Ka(e)] || // also try camelCase event handler (#2249)
  i[s = Ka(Cr(e))];
  !l && a && (l = i[s = Ka(Li(e))]), l && En(
    l,
    r,
    6,
    n
  );
  const u = i[s + "Once"];
  if (u) {
    if (!r.emitted)
      r.emitted = {};
    else if (r.emitted[s])
      return;
    r.emitted[s] = !0, En(
      u,
      r,
      6,
      n
    );
  }
}
function q5(r, e, t = !1) {
  const i = e.emitsCache, n = i.get(r);
  if (n !== void 0)
    return n;
  const a = r.emits;
  let o = {}, s = !1;
  if (!Ue(r)) {
    const l = (u) => {
      const c = q5(u, e, !0);
      c && (s = !0, ut(o, c));
    };
    !t && e.mixins.length && e.mixins.forEach(l), r.extends && l(r.extends), r.mixins && r.mixins.forEach(l);
  }
  return !a && !s ? (Tt(r) && i.set(r, null), null) : (pe(a) ? a.forEach((l) => o[l] = null) : ut(o, a), Tt(r) && i.set(r, o), o);
}
function GS(r, e) {
  return !r || !is(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), Et(r, e[0].toLowerCase() + e.slice(1)) || Et(r, Li(e)) || Et(r, e));
}
let gr = null, BS = null;
function gg(r) {
  const e = gr;
  return gr = r, BS = r && r.type.__scopeId || null, e;
}
function j5(r) {
  BS = r;
}
function K5() {
  BS = null;
}
const wK = (r) => vg;
function vg(r, e = gr, t) {
  if (!e || r._n)
    return r;
  const i = (...n) => {
    i._d && l_(-1);
    const a = gg(e);
    let o;
    try {
      o = r(...n);
    } finally {
      gg(a), i._d && l_(1);
    }
    return {}.NODE_ENV !== "production" && z5(e), o;
  };
  return i._n = !0, i._c = !0, i._d = !0, i;
}
let t_ = !1;
function NE() {
  t_ = !0;
}
function $m(r) {
  const {
    type: e,
    vnode: t,
    proxy: i,
    withProxy: n,
    props: a,
    propsOptions: [o],
    slots: s,
    attrs: l,
    emit: u,
    render: c,
    renderCache: h,
    data: f,
    setupState: d,
    ctx: p,
    inheritAttrs: g
  } = r;
  let v, O;
  const m = gg(r);
  ({}).NODE_ENV !== "production" && (t_ = !1);
  try {
    if (t.shapeFlag & 4) {
      const S = n || i;
      v = Xi(
        c.call(
          S,
          S,
          h,
          a,
          d,
          f,
          p
        )
      ), O = l;
    } else {
      const S = e;
      ({}).NODE_ENV !== "production" && l === a && NE(), v = Xi(
        S.length > 1 ? S(
          a,
          {}.NODE_ENV !== "production" ? {
            get attrs() {
              return NE(), l;
            },
            slots: s,
            emit: u
          } : { attrs: l, slots: s, emit: u }
        ) : S(
          a,
          null
          /* we know it doesn't need it */
        )
      ), O = e.props ? l : xK(l);
    }
  } catch (S) {
    Up.length = 0, Yc(S, r, 1), v = Yt(mr);
  }
  let E = v, b;
  if ({}.NODE_ENV !== "production" && v.patchFlag > 0 && v.patchFlag & 2048 && ([E, b] = NK(v)), O && g !== !1) {
    const S = Object.keys(O), { shapeFlag: T } = E;
    if (S.length) {
      if (T & 7)
        o && S.some(TE) && (O = PK(
          O,
          o
        )), E = ia(E, O);
      else if ({}.NODE_ENV !== "production" && !t_ && E.type !== mr) {
        const y = Object.keys(l), R = [], _ = [];
        for (let C = 0, I = y.length; C < I; C++) {
          const w = y[C];
          is(w) ? TE(w) || R.push(w[2].toLowerCase() + w.slice(3)) : _.push(w);
        }
        _.length && W(
          `Extraneous non-props attributes (${_.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes.`
        ), R.length && W(
          `Extraneous non-emits event listeners (${R.join(", ")}) were passed to component but could not be automatically inherited because component renders fragment or text root nodes. If the listener is intended to be a component custom event listener only, declare it using the "emits" option.`
        );
      }
    }
  }
  return t.dirs && ({}.NODE_ENV !== "production" && !hL(E) && W(
    "Runtime directive used on component with non-element root node. The directives will not function as intended."
  ), E = ia(E), E.dirs = E.dirs ? E.dirs.concat(t.dirs) : t.dirs), t.transition && ({}.NODE_ENV !== "production" && !hL(E) && W(
    "Component inside <Transition> renders non-element root node that cannot be animated."
  ), E.transition = t.transition), {}.NODE_ENV !== "production" && b ? b(E) : v = E, gg(m), v;
}
const NK = (r) => {
  const e = r.children, t = r.dynamicChildren, i = $w(e);
  if (!i)
    return [r, void 0];
  const n = e.indexOf(i), a = t ? t.indexOf(i) : -1, o = (s) => {
    e[n] = s, t && (a > -1 ? t[a] = s : s.patchFlag > 0 && (r.dynamicChildren = [...t, s]));
  };
  return [Xi(i), o];
};
function $w(r) {
  let e;
  for (let t = 0; t < r.length; t++) {
    const i = r[t];
    if (as(i)) {
      if (i.type !== mr || i.children === "v-if") {
        if (e)
          return;
        e = i;
      }
    } else
      return;
  }
  return e;
}
const xK = (r) => {
  let e;
  for (const t in r)
    (t === "class" || t === "style" || is(t)) && ((e || (e = {}))[t] = r[t]);
  return e;
}, PK = (r, e) => {
  const t = {};
  for (const i in r)
    (!TE(i) || !(i.slice(9) in e)) && (t[i] = r[i]);
  return t;
}, hL = (r) => r.shapeFlag & 7 || r.type === mr;
function LK(r, e, t) {
  const { props: i, children: n, component: a } = r, { props: o, children: s, patchFlag: l } = e, u = a.emitsOptions;
  if ({}.NODE_ENV !== "production" && (n || s) && cl || e.dirs || e.transition)
    return !0;
  if (t && l >= 0) {
    if (l & 1024)
      return !0;
    if (l & 16)
      return i ? fL(i, o, u) : !!o;
    if (l & 8) {
      const c = e.dynamicProps;
      for (let h = 0; h < c.length; h++) {
        const f = c[h];
        if (o[f] !== i[f] && !GS(u, f))
          return !0;
      }
    }
  } else
    return (n || s) && (!s || !s.$stable) ? !0 : i === o ? !1 : i ? o ? fL(i, o, u) : !0 : !!o;
  return !1;
}
function fL(r, e, t) {
  const i = Object.keys(e);
  if (i.length !== Object.keys(r).length)
    return !0;
  for (let n = 0; n < i.length; n++) {
    const a = i[n];
    if (e[a] !== r[a] && !GS(t, a))
      return !0;
  }
  return !1;
}
function Vw({ vnode: r, parent: e }, t) {
  for (; e && e.subTree === r; )
    (r = e.vnode).el = t, e = e.parent;
}
const J5 = (r) => r.__isSuspense, DK = {
  name: "Suspense",
  // In order to make Suspense tree-shakable, we need to avoid importing it
  // directly in the renderer. The renderer checks for the __isSuspense flag
  // on a vnode's type and calls the `process` method, passing in renderer
  // internals.
  __isSuspense: !0,
  process(r, e, t, i, n, a, o, s, l, u) {
    r == null ? kK(
      e,
      t,
      i,
      n,
      a,
      o,
      s,
      l,
      u
    ) : QK(
      r,
      e,
      t,
      i,
      n,
      o,
      s,
      l,
      u
    );
  },
  hydrate: UK,
  create: Gw,
  normalize: $K
}, MK = DK;
function Og(r, e) {
  const t = r.props && r.props[e];
  Ue(t) && t();
}
function kK(r, e, t, i, n, a, o, s, l) {
  const {
    p: u,
    o: { createElement: c }
  } = l, h = c("div"), f = r.suspense = Gw(
    r,
    n,
    i,
    e,
    h,
    t,
    a,
    o,
    s,
    l
  );
  u(
    null,
    f.pendingBranch = r.ssContent,
    h,
    null,
    i,
    f,
    a,
    o
  ), f.deps > 0 ? (Og(r, "onPending"), Og(r, "onFallback"), u(
    null,
    r.ssFallback,
    e,
    t,
    i,
    null,
    // fallback tree will not have suspense context
    a,
    o
  ), nf(f, r.ssFallback)) : f.resolve(!1, !0);
}
function QK(r, e, t, i, n, a, o, s, { p: l, um: u, o: { createElement: c } }) {
  const h = e.suspense = r.suspense;
  h.vnode = e, e.el = r.el;
  const f = e.ssContent, d = e.ssFallback, { activeBranch: p, pendingBranch: g, isInFallback: v, isHydrating: O } = h;
  if (g)
    h.pendingBranch = f, Oa(f, g) ? (l(
      g,
      f,
      h.hiddenContainer,
      null,
      n,
      h,
      a,
      o,
      s
    ), h.deps <= 0 ? h.resolve() : v && (l(
      p,
      d,
      t,
      i,
      n,
      null,
      // fallback tree will not have suspense context
      a,
      o,
      s
    ), nf(h, d))) : (h.pendingId++, O ? (h.isHydrating = !1, h.activeBranch = g) : u(g, n, h), h.deps = 0, h.effects.length = 0, h.hiddenContainer = c("div"), v ? (l(
      null,
      f,
      h.hiddenContainer,
      null,
      n,
      h,
      a,
      o,
      s
    ), h.deps <= 0 ? h.resolve() : (l(
      p,
      d,
      t,
      i,
      n,
      null,
      // fallback tree will not have suspense context
      a,
      o,
      s
    ), nf(h, d))) : p && Oa(f, p) ? (l(
      p,
      f,
      t,
      i,
      n,
      h,
      a,
      o,
      s
    ), h.resolve(!0)) : (l(
      null,
      f,
      h.hiddenContainer,
      null,
      n,
      h,
      a,
      o,
      s
    ), h.deps <= 0 && h.resolve()));
  else if (p && Oa(f, p))
    l(
      p,
      f,
      t,
      i,
      n,
      h,
      a,
      o,
      s
    ), nf(h, f);
  else if (Og(e, "onPending"), h.pendingBranch = f, h.pendingId++, l(
    null,
    f,
    h.hiddenContainer,
    null,
    n,
    h,
    a,
    o,
    s
  ), h.deps <= 0)
    h.resolve();
  else {
    const { timeout: m, pendingId: E } = h;
    m > 0 ? setTimeout(() => {
      h.pendingId === E && h.fallback(d);
    }, m) : m === 0 && h.fallback(d);
  }
}
let dL = !1;
function Gw(r, e, t, i, n, a, o, s, l, u, c = !1) {
  ({}).NODE_ENV !== "production" && !dL && (dL = !0, console[console.info ? "info" : "log"](
    "<Suspense> is an experimental feature and its API will likely change."
  ));
  const {
    p: h,
    m: f,
    um: d,
    n: p,
    o: { parentNode: g, remove: v }
  } = u;
  let O;
  const m = VK(r);
  m && e != null && e.pendingBranch && (O = e.pendingId, e.deps++);
  const E = r.props ? AE(r.props.timeout) : void 0;
  ({}).NODE_ENV !== "production" && Lw(E, "Suspense timeout");
  const b = {
    vnode: r,
    parent: e,
    parentComponent: t,
    isSVG: o,
    container: i,
    hiddenContainer: n,
    anchor: a,
    deps: 0,
    pendingId: 0,
    timeout: typeof E == "number" ? E : -1,
    activeBranch: null,
    pendingBranch: null,
    isInFallback: !0,
    isHydrating: c,
    isUnmounted: !1,
    effects: [],
    resolve(S = !1, T = !1) {
      if ({}.NODE_ENV !== "production") {
        if (!S && !b.pendingBranch)
          throw new Error(
            "suspense.resolve() is called without a pending branch."
          );
        if (b.isUnmounted)
          throw new Error(
            "suspense.resolve() is called on an already unmounted suspense boundary."
          );
      }
      const {
        vnode: y,
        activeBranch: R,
        pendingBranch: _,
        pendingId: C,
        effects: I,
        parentComponent: w,
        container: x
      } = b;
      if (b.isHydrating)
        b.isHydrating = !1;
      else if (!S) {
        const D = R && _.transition && _.transition.mode === "out-in";
        D && (R.transition.afterLeave = () => {
          C === b.pendingId && f(_, x, U, 0);
        });
        let { anchor: U } = b;
        R && (U = p(R), d(R, w, b, !0)), D || f(_, x, U, 0);
      }
      nf(b, _), b.pendingBranch = null, b.isInFallback = !1;
      let P = b.parent, L = !1;
      for (; P; ) {
        if (P.pendingBranch) {
          P.effects.push(...I), L = !0;
          break;
        }
        P = P.parent;
      }
      L || VS(I), b.effects = [], m && e && e.pendingBranch && O === e.pendingId && (e.deps--, e.deps === 0 && !T && e.resolve()), Og(y, "onResolve");
    },
    fallback(S) {
      if (!b.pendingBranch)
        return;
      const { vnode: T, activeBranch: y, parentComponent: R, container: _, isSVG: C } = b;
      Og(T, "onFallback");
      const I = p(y), w = () => {
        b.isInFallback && (h(
          null,
          S,
          _,
          I,
          R,
          null,
          // fallback tree will not have suspense context
          C,
          s,
          l
        ), nf(b, S));
      }, x = S.transition && S.transition.mode === "out-in";
      x && (y.transition.afterLeave = w), b.isInFallback = !0, d(
        y,
        R,
        null,
        // no suspense so unmount hooks fire now
        !0
        // shouldRemove
      ), x || w();
    },
    move(S, T, y) {
      b.activeBranch && f(b.activeBranch, S, T, y), b.container = S;
    },
    next() {
      return b.activeBranch && p(b.activeBranch);
    },
    registerDep(S, T) {
      const y = !!b.pendingBranch;
      y && b.deps++;
      const R = S.vnode.el;
      S.asyncDep.catch((_) => {
        Yc(_, S, 0);
      }).then((_) => {
        if (S.isUnmounted || b.isUnmounted || b.pendingId !== S.suspenseId)
          return;
        S.asyncResolved = !0;
        const { vnode: C } = S;
        ({}).NODE_ENV !== "production" && Pp(C), h_(S, _, !1), R && (C.el = R);
        const I = !R && S.subTree.el;
        T(
          S,
          C,
          // component may have been moved before resolve.
          // if this is not a hydration, instance.subTree will be the comment
          // placeholder.
          g(R || S.subTree.el),
          // anchor will not be used if this is hydration, so only need to
          // consider the comment placeholder case.
          R ? null : p(S.subTree),
          b,
          o,
          l
        ), I && v(I), Vw(S, C.el), {}.NODE_ENV !== "production" && Lp(), y && --b.deps === 0 && b.resolve();
      });
    },
    unmount(S, T) {
      b.isUnmounted = !0, b.activeBranch && d(
        b.activeBranch,
        t,
        S,
        T
      ), b.pendingBranch && d(
        b.pendingBranch,
        t,
        S,
        T
      );
    }
  };
  return b;
}
function UK(r, e, t, i, n, a, o, s, l) {
  const u = e.suspense = Gw(
    e,
    i,
    t,
    r.parentNode,
    document.createElement("div"),
    null,
    n,
    a,
    o,
    s,
    !0
    /* hydrating */
  ), c = l(
    r,
    u.pendingBranch = e.ssContent,
    t,
    u,
    a,
    o
  );
  return u.deps === 0 && u.resolve(!1, !0), c;
}
function $K(r) {
  const { shapeFlag: e, children: t } = r, i = e & 32;
  r.ssContent = pL(
    i ? t.default : t
  ), r.ssFallback = i ? pL(t.fallback) : Yt(mr);
}
function pL(r) {
  let e;
  if (Ue(r)) {
    const t = Rc && r._c;
    t && (r._d = !1, xt()), r = r(), t && (r._d = !0, e = qi, LF());
  }
  if (pe(r)) {
    const t = $w(r);
    ({}).NODE_ENV !== "production" && !t && W("<Suspense> slots expect a single root node."), r = t;
  }
  return r = Xi(r), e && !r.dynamicChildren && (r.dynamicChildren = e.filter((t) => t !== r)), r;
}
function eF(r, e) {
  e && e.pendingBranch ? pe(r) ? e.effects.push(...r) : e.effects.push(r) : VS(r);
}
function nf(r, e) {
  r.activeBranch = e;
  const { vnode: t, parentComponent: i } = r, n = t.el = e.el;
  i && i.subTree === t && (i.vnode.el = n, Vw(i, n));
}
function VK(r) {
  var e;
  return ((e = r.props) == null ? void 0 : e.suspensible) != null && r.props.suspensible !== !1;
}
function GK(r, e) {
  return Ov(r, null, e);
}
function tF(r, e) {
  return Ov(
    r,
    null,
    {}.NODE_ENV !== "production" ? ut({}, e, { flush: "post" }) : { flush: "post" }
  );
}
function BK(r, e) {
  return Ov(
    r,
    null,
    {}.NODE_ENV !== "production" ? ut({}, e, { flush: "sync" }) : { flush: "sync" }
  );
}
const oO = {};
function Ra(r, e, t) {
  return {}.NODE_ENV !== "production" && !Ue(e) && W(
    "`watch(fn, options?)` signature has been moved to a separate API. Use `watchEffect(fn, options?)` instead. `watch` now only supports `watch(source, cb, options?) signature."
  ), Ov(r, e, t);
}
function Ov(r, e, { immediate: t, deep: i, flush: n, onTrack: a, onTrigger: o } = _t) {
  var s;
  ({}).NODE_ENV !== "production" && !e && (t !== void 0 && W(
    'watch() "immediate" option is only respected when using the watch(source, callback, options?) signature.'
  ), i !== void 0 && W(
    'watch() "deep" option is only respected when using the watch(source, callback, options?) signature.'
  ));
  const l = (S) => {
    W(
      "Invalid watch source: ",
      S,
      "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types."
    );
  }, u = C5() === ((s = pr) == null ? void 0 : s.scope) ? pr : null;
  let c, h = !1, f = !1;
  if (sr(r) ? (c = () => r.value, h = cg(r)) : ul(r) ? (c = () => r, i = !0) : pe(r) ? (f = !0, h = r.some((S) => ul(S) || cg(S)), c = () => r.map((S) => {
    if (sr(S))
      return S.value;
    if (ul(S))
      return Fu(S);
    if (Ue(S))
      return go(S, u, 2);
    ({}).NODE_ENV !== "production" && l(S);
  })) : Ue(r) ? e ? c = () => go(r, u, 2) : c = () => {
    if (!(u && u.isUnmounted))
      return d && d(), En(
        r,
        u,
        3,
        [p]
      );
  } : (c = dr, {}.NODE_ENV !== "production" && l(r)), e && i) {
    const S = c;
    c = () => Fu(S());
  }
  let d, p = (S) => {
    d = E.onStop = () => {
      go(S, u, 4);
    };
  }, g;
  if (Sf)
    if (p = dr, e ? t && En(e, u, 3, [
      c(),
      f ? [] : void 0,
      p
    ]) : c(), n === "sync") {
      const S = ZF();
      g = S.__watcherHandles || (S.__watcherHandles = []);
    } else
      return dr;
  let v = f ? new Array(r.length).fill(oO) : oO;
  const O = () => {
    if (E.active)
      if (e) {
        const S = E.run();
        (i || h || (f ? S.some(
          (T, y) => mf(T, v[y])
        ) : mf(S, v))) && (d && d(), En(e, u, 3, [
          S,
          // pass undefined as the old value when it's changed for the first time
          v === oO ? void 0 : f && v[0] === oO ? [] : v,
          p
        ]), v = S);
      } else
        E.run();
  };
  O.allowRecurse = !!e;
  let m;
  n === "sync" ? m = O : n === "post" ? m = () => Hr(O, u && u.suspense) : (O.pre = !0, u && (O.id = u.uid), m = () => gv(O));
  const E = new pv(c, m);
  ({}).NODE_ENV !== "production" && (E.onTrack = a, E.onTrigger = o), e ? t ? O() : v = E.run() : n === "post" ? Hr(
    E.run.bind(E),
    u && u.suspense
  ) : E.run();
  const b = () => {
    E.stop(), u && u.scope && yw(u.scope.effects, E);
  };
  return g && g.push(b), b;
}
function FK(r, e, t) {
  const i = this.proxy, n = qe(r) ? r.includes(".") ? rF(i, r) : () => i[r] : r.bind(i, i);
  let a;
  Ue(e) ? a = e : (a = e.handler, t = e);
  const o = pr;
  Al(this);
  const s = Ov(n, a.bind(i), t);
  return o ? Al(o) : fl(), s;
}
function rF(r, e) {
  const t = e.split(".");
  return () => {
    let i = r;
    for (let n = 0; n < t.length && i; n++)
      i = i[t[n]];
    return i;
  };
}
function Fu(r, e) {
  if (!Tt(r) || r.__v_skip || (e = e || /* @__PURE__ */ new Set(), e.has(r)))
    return r;
  if (e.add(r), sr(r))
    Fu(r.value, e);
  else if (pe(r))
    for (let t = 0; t < r.length; t++)
      Fu(r[t], e);
  else if (Bc(r) || nc(r))
    r.forEach((t) => {
      Fu(t, e);
    });
  else if (m5(r))
    for (const t in r)
      Fu(r[t], e);
  return r;
}
function iF(r) {
  E5(r) && W("Do not use built-in directive ids as custom directive id: " + r);
}
function XK(r, e) {
  const t = gr;
  if (t === null)
    return {}.NODE_ENV !== "production" && W("withDirectives can only be used inside render functions."), r;
  const i = ZS(t) || t.proxy, n = r.dirs || (r.dirs = []);
  for (let a = 0; a < e.length; a++) {
    let [o, s, l, u = _t] = e[a];
    o && (Ue(o) && (o = {
      mounted: o,
      updated: o
    }), o.deep && Fu(s), n.push({
      dir: o,
      instance: i,
      value: s,
      oldValue: void 0,
      arg: l,
      modifiers: u
    }));
  }
  return r;
}
function qa(r, e, t, i) {
  const n = r.dirs, a = e && e.dirs;
  for (let o = 0; o < n.length; o++) {
    const s = n[o];
    a && (s.oldValue = a[o].value);
    let l = s.dir[i];
    l && (Fc(), En(l, t, 8, [
      r.el,
      s,
      r,
      e
    ]), Xc());
  }
}
function Bw() {
  const r = {
    isMounted: !1,
    isLeaving: !1,
    isUnmounting: !1,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  return Os(() => {
    r.isMounted = !0;
  }), HS(() => {
    r.isUnmounting = !0;
  }), r;
}
const wn = [Function, Array], Fw = {
  mode: String,
  appear: Boolean,
  persisted: Boolean,
  // enter
  onBeforeEnter: wn,
  onEnter: wn,
  onAfterEnter: wn,
  onEnterCancelled: wn,
  // leave
  onBeforeLeave: wn,
  onLeave: wn,
  onAfterLeave: wn,
  onLeaveCancelled: wn,
  // appear
  onBeforeAppear: wn,
  onAppear: wn,
  onAfterAppear: wn,
  onAppearCancelled: wn
}, YK = {
  name: "BaseTransition",
  props: Fw,
  setup(r, { slots: e }) {
    const t = ms(), i = Bw();
    let n;
    return () => {
      const a = e.default && FS(e.default(), !0);
      if (!a || !a.length)
        return;
      let o = a[0];
      if (a.length > 1) {
        let g = !1;
        for (const v of a)
          if (v.type !== mr) {
            if ({}.NODE_ENV !== "production" && g) {
              W(
                "<transition> can only be used on a single element or component. Use <transition-group> for lists."
              );
              break;
            }
            if (o = v, g = !0, {}.NODE_ENV === "production")
              break;
          }
      }
      const s = je(r), { mode: l } = s;
      if ({}.NODE_ENV !== "production" && l && l !== "in-out" && l !== "out-in" && l !== "default" && W(`invalid <transition> mode: ${l}`), i.isLeaving)
        return Sy(o);
      const u = gL(o);
      if (!u)
        return Sy(o);
      const c = bf(
        u,
        s,
        i,
        t
      );
      yc(u, c);
      const h = t.subTree, f = h && gL(h);
      let d = !1;
      const { getTransitionKey: p } = u.type;
      if (p) {
        const g = p();
        n === void 0 ? n = g : g !== n && (n = g, d = !0);
      }
      if (f && f.type !== mr && (!Oa(u, f) || d)) {
        const g = bf(
          f,
          s,
          i,
          t
        );
        if (yc(f, g), l === "out-in")
          return i.isLeaving = !0, g.afterLeave = () => {
            i.isLeaving = !1, t.update.active !== !1 && t.update();
          }, Sy(o);
        l === "in-out" && u.type !== mr && (g.delayLeave = (v, O, m) => {
          const E = aF(
            i,
            f
          );
          E[String(f.key)] = f, v._leaveCb = () => {
            O(), v._leaveCb = void 0, delete c.delayedLeave;
          }, c.delayedLeave = m;
        });
      }
      return o;
    };
  }
}, nF = YK;
function aF(r, e) {
  const { leavingVNodes: t } = r;
  let i = t.get(e.type);
  return i || (i = /* @__PURE__ */ Object.create(null), t.set(e.type, i)), i;
}
function bf(r, e, t, i) {
  const {
    appear: n,
    mode: a,
    persisted: o = !1,
    onBeforeEnter: s,
    onEnter: l,
    onAfterEnter: u,
    onEnterCancelled: c,
    onBeforeLeave: h,
    onLeave: f,
    onAfterLeave: d,
    onLeaveCancelled: p,
    onBeforeAppear: g,
    onAppear: v,
    onAfterAppear: O,
    onAppearCancelled: m
  } = e, E = String(r.key), b = aF(t, r), S = (R, _) => {
    R && En(
      R,
      i,
      9,
      _
    );
  }, T = (R, _) => {
    const C = _[1];
    S(R, _), pe(R) ? R.every((I) => I.length <= 1) && C() : R.length <= 1 && C();
  }, y = {
    mode: a,
    persisted: o,
    beforeEnter(R) {
      let _ = s;
      if (!t.isMounted)
        if (n)
          _ = g || s;
        else
          return;
      R._leaveCb && R._leaveCb(
        !0
        /* cancelled */
      );
      const C = b[E];
      C && Oa(r, C) && C.el._leaveCb && C.el._leaveCb(), S(_, [R]);
    },
    enter(R) {
      let _ = l, C = u, I = c;
      if (!t.isMounted)
        if (n)
          _ = v || l, C = O || u, I = m || c;
        else
          return;
      let w = !1;
      const x = R._enterCb = (P) => {
        w || (w = !0, P ? S(I, [R]) : S(C, [R]), y.delayedLeave && y.delayedLeave(), R._enterCb = void 0);
      };
      _ ? T(_, [R, x]) : x();
    },
    leave(R, _) {
      const C = String(r.key);
      if (R._enterCb && R._enterCb(
        !0
        /* cancelled */
      ), t.isUnmounting)
        return _();
      S(h, [R]);
      let I = !1;
      const w = R._leaveCb = (x) => {
        I || (I = !0, _(), x ? S(p, [R]) : S(d, [R]), R._leaveCb = void 0, b[C] === r && delete b[C]);
      };
      b[C] = r, f ? T(f, [R, w]) : w();
    },
    clone(R) {
      return bf(R, e, t, i);
    }
  };
  return y;
}
function Sy(r) {
  if (Wf(r))
    return r = ia(r), r.children = null, r;
}
function gL(r) {
  return Wf(r) ? r.children ? r.children[0] : void 0 : r;
}
function yc(r, e) {
  r.shapeFlag & 6 && r.component ? yc(r.component.subTree, e) : r.shapeFlag & 128 ? (r.ssContent.transition = e.clone(r.ssContent), r.ssFallback.transition = e.clone(r.ssFallback)) : r.transition = e;
}
function FS(r, e = !1, t) {
  let i = [], n = 0;
  for (let a = 0; a < r.length; a++) {
    let o = r[a];
    const s = t == null ? o.key : String(t) + String(o.key != null ? o.key : a);
    o.type === xr ? (o.patchFlag & 128 && n++, i = i.concat(
      FS(o.children, e, s)
    )) : (e || o.type !== mr) && i.push(s != null ? ia(o, { key: s }) : o);
  }
  if (n > 1)
    for (let a = 0; a < i.length; a++)
      i[a].patchFlag = -2;
  return i;
}
function An(r, e) {
  return Ue(r) ? (
    // #8326: extend call and options.name access are considered side-effects
    // by Rollup, so we have to wrap it in a pure-annotated IIFE.
    /* @__PURE__ */ (() => ut({ name: r.name }, e, { setup: r }))()
  ) : r;
}
const lc = (r) => !!r.type.__asyncLoader;
function HK(r) {
  Ue(r) && (r = { loader: r });
  const {
    loader: e,
    loadingComponent: t,
    errorComponent: i,
    delay: n = 200,
    timeout: a,
    // undefined = never times out
    suspensible: o = !0,
    onError: s
  } = r;
  let l = null, u, c = 0;
  const h = () => (c++, l = null, f()), f = () => {
    let d;
    return l || (d = l = e().catch((p) => {
      if (p = p instanceof Error ? p : new Error(String(p)), s)
        return new Promise((g, v) => {
          s(p, () => g(h()), () => v(p), c + 1);
        });
      throw p;
    }).then((p) => {
      if (d !== l && l)
        return l;
      if ({}.NODE_ENV !== "production" && !p && W(
        "Async component loader resolved to undefined. If you are using retry(), make sure to return its return value."
      ), p && (p.__esModule || p[Symbol.toStringTag] === "Module") && (p = p.default), {}.NODE_ENV !== "production" && p && !Tt(p) && !Ue(p))
        throw new Error(`Invalid async component load result: ${p}`);
      return u = p, p;
    }));
  };
  return An({
    name: "AsyncComponentWrapper",
    __asyncLoader: f,
    get __asyncResolved() {
      return u;
    },
    setup() {
      const d = pr;
      if (u)
        return () => Ty(u, d);
      const p = (m) => {
        l = null, Yc(
          m,
          d,
          13,
          !i
          /* do not throw in dev if user provided error component */
        );
      };
      if (o && d.suspense || Sf)
        return f().then((m) => () => Ty(m, d)).catch((m) => (p(m), () => i ? Yt(i, {
          error: m
        }) : null));
      const g = Rr(!1), v = Rr(), O = Rr(!!n);
      return n && setTimeout(() => {
        O.value = !1;
      }, n), a != null && setTimeout(() => {
        if (!g.value && !v.value) {
          const m = new Error(
            `Async component timed out after ${a}ms.`
          );
          p(m), v.value = m;
        }
      }, a), f().then(() => {
        g.value = !0, d.parent && Wf(d.parent.vnode) && gv(d.parent.update);
      }).catch((m) => {
        p(m), v.value = m;
      }), () => {
        if (g.value && u)
          return Ty(u, d);
        if (v.value && i)
          return Yt(i, {
            error: v.value
          });
        if (t && !O.value)
          return Yt(t);
      };
    }
  });
}
function Ty(r, e) {
  const { ref: t, props: i, children: n, ce: a } = e.vnode, o = Yt(r, i, n);
  return o.ref = t, o.ce = a, delete e.vnode.ce, o;
}
const Wf = (r) => r.type.__isKeepAlive, WK = {
  name: "KeepAlive",
  // Marker for special handling inside the renderer. We are not using a ===
  // check directly on KeepAlive in the renderer, because importing it directly
  // would prevent it from being tree-shaken.
  __isKeepAlive: !0,
  props: {
    include: [String, RegExp, Array],
    exclude: [String, RegExp, Array],
    max: [String, Number]
  },
  setup(r, { slots: e }) {
    const t = ms(), i = t.ctx;
    if (!i.renderer)
      return () => {
        const m = e.default && e.default();
        return m && m.length === 1 ? m[0] : m;
      };
    const n = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Set();
    let o = null;
    ({}).NODE_ENV !== "production" && (t.__v_cache = n);
    const s = t.suspense, {
      renderer: {
        p: l,
        m: u,
        um: c,
        o: { createElement: h }
      }
    } = i, f = h("div");
    i.activate = (m, E, b, S, T) => {
      const y = m.component;
      u(m, E, b, 0, s), l(
        y.vnode,
        m,
        E,
        b,
        y,
        s,
        S,
        m.slotScopeIds,
        T
      ), Hr(() => {
        y.isDeactivated = !1, y.a && zs(y.a);
        const R = m.props && m.props.onVnodeMounted;
        R && Fi(R, y.parent, m);
      }, s), {}.NODE_ENV !== "production" && e_(y);
    }, i.deactivate = (m) => {
      const E = m.component;
      u(m, f, null, 1, s), Hr(() => {
        E.da && zs(E.da);
        const b = m.props && m.props.onVnodeUnmounted;
        b && Fi(b, E.parent, m), E.isDeactivated = !0;
      }, s), {}.NODE_ENV !== "production" && e_(E);
    };
    function d(m) {
      yy(m), c(m, t, s, !0);
    }
    function p(m) {
      n.forEach((E, b) => {
        const S = bg(E.type);
        S && (!m || !m(S)) && g(b);
      });
    }
    function g(m) {
      const E = n.get(m);
      !o || !Oa(E, o) ? d(E) : o && yy(o), n.delete(m), a.delete(m);
    }
    Ra(
      () => [r.include, r.exclude],
      ([m, E]) => {
        m && p((b) => hp(m, b)), E && p((b) => !hp(E, b));
      },
      // prune post-render after `current` has been updated
      { flush: "post", deep: !0 }
    );
    let v = null;
    const O = () => {
      v != null && n.set(v, Ry(t.subTree));
    };
    return Os(O), YS(O), HS(() => {
      n.forEach((m) => {
        const { subTree: E, suspense: b } = t, S = Ry(E);
        if (m.type === S.type && m.key === S.key) {
          yy(S);
          const T = S.component.da;
          T && Hr(T, b);
          return;
        }
        d(m);
      });
    }), () => {
      if (v = null, !e.default)
        return null;
      const m = e.default(), E = m[0];
      if (m.length > 1)
        return {}.NODE_ENV !== "production" && W("KeepAlive should contain exactly one component child."), o = null, m;
      if (!as(E) || !(E.shapeFlag & 4) && !(E.shapeFlag & 128))
        return o = null, E;
      let b = Ry(E);
      const S = b.type, T = bg(
        lc(b) ? b.type.__asyncResolved || {} : S
      ), { include: y, exclude: R, max: _ } = r;
      if (y && (!T || !hp(y, T)) || R && T && hp(R, T))
        return o = b, E;
      const C = b.key == null ? S : b.key, I = n.get(C);
      return b.el && (b = ia(b), E.shapeFlag & 128 && (E.ssContent = b)), v = C, I ? (b.el = I.el, b.component = I.component, b.transition && yc(b, b.transition), b.shapeFlag |= 512, a.delete(C), a.add(C)) : (a.add(C), _ && a.size > parseInt(_, 10) && g(a.values().next().value)), b.shapeFlag |= 256, o = b, J5(E.type) ? E : b;
    };
  }
}, zK = WK;
function hp(r, e) {
  return pe(r) ? r.some((t) => hp(t, e)) : qe(r) ? r.split(",").includes(e) : Jq(r) ? r.test(e) : !1;
}
function oF(r, e) {
  lF(r, "a", e);
}
function sF(r, e) {
  lF(r, "da", e);
}
function lF(r, e, t = pr) {
  const i = r.__wdc || (r.__wdc = () => {
    let n = t;
    for (; n; ) {
      if (n.isDeactivated)
        return;
      n = n.parent;
    }
    return r();
  });
  if (XS(e, i, t), t) {
    let n = t.parent;
    for (; n && n.parent; )
      Wf(n.parent.vnode) && ZK(i, e, t, n), n = n.parent;
  }
}
function ZK(r, e, t, i) {
  const n = XS(
    e,
    r,
    i,
    !0
    /* prepend */
  );
  WS(() => {
    yw(i[e], n);
  }, t);
}
function yy(r) {
  r.shapeFlag &= -257, r.shapeFlag &= -513;
}
function Ry(r) {
  return r.shapeFlag & 128 ? r.ssContent : r;
}
function XS(r, e, t = pr, i = !1) {
  if (t) {
    const n = t[r] || (t[r] = []), a = e.__weh || (e.__weh = (...o) => {
      if (t.isUnmounted)
        return;
      Fc(), Al(t);
      const s = En(e, t, r, o);
      return fl(), Xc(), s;
    });
    return i ? n.unshift(a) : n.push(a), a;
  } else if ({}.NODE_ENV !== "production") {
    const n = Ka(Dw[r].replace(/ hook$/, ""));
    W(
      `${n} is called when there is no active component instance to be associated with. Lifecycle injection APIs can only be used during execution of setup(). If you are using async setup(), make sure to register lifecycle hooks before the first await statement.`
    );
  }
}
const vs = (r) => (e, t = pr) => (
  // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
  (!Sf || r === "sp") && XS(r, (...i) => e(...i), t)
), uF = vs("bm"), Os = vs("m"), cF = vs("bu"), YS = vs("u"), HS = vs("bum"), WS = vs("um"), hF = vs("sp"), fF = vs(
  "rtg"
), dF = vs(
  "rtc"
);
function pF(r, e = pr) {
  XS("ec", r, e);
}
const xE = "components", qK = "directives";
function gF(r, e) {
  return Xw(xE, r, !0, e) || r;
}
const vF = Symbol.for("v-ndc");
function jK(r) {
  return qe(r) ? Xw(xE, r, !1) || r : r || vF;
}
function KK(r) {
  return Xw(qK, r);
}
function Xw(r, e, t = !0, i = !1) {
  const n = gr || pr;
  if (n) {
    const a = n.type;
    if (r === xE) {
      const s = bg(
        a,
        !1
        /* do not include inferred name to avoid breaking existing code */
      );
      if (s && (s === e || s === Cr(e) || s === bo(Cr(e))))
        return a;
    }
    const o = (
      // local registration
      // check instance[type] first which is resolved for options API
      vL(n[r] || a[r], e) || // global registration
      vL(n.appContext[r], e)
    );
    if (!o && i)
      return a;
    if ({}.NODE_ENV !== "production" && t && !o) {
      const s = r === xE ? `
If this is a native custom element, make sure to exclude it from component resolution via compilerOptions.isCustomElement.` : "";
      W(`Failed to resolve ${r.slice(0, -1)}: ${e}${s}`);
    }
    return o;
  } else
    ({}).NODE_ENV !== "production" && W(
      `resolve${bo(r.slice(0, -1))} can only be used in render() or setup().`
    );
}
function vL(r, e) {
  return r && (r[e] || r[Cr(e)] || r[bo(Cr(e))]);
}
function OF(r, e, t, i) {
  let n;
  const a = t && t[i];
  if (pe(r) || qe(r)) {
    n = new Array(r.length);
    for (let o = 0, s = r.length; o < s; o++)
      n[o] = e(r[o], o, void 0, a && a[o]);
  } else if (typeof r == "number") {
    ({}).NODE_ENV !== "production" && !Number.isInteger(r) && W(`The v-for range expect an integer value but got ${r}.`), n = new Array(r);
    for (let o = 0; o < r; o++)
      n[o] = e(o + 1, o, void 0, a && a[o]);
  } else if (Tt(r))
    if (r[Symbol.iterator])
      n = Array.from(
        r,
        (o, s) => e(o, s, void 0, a && a[s])
      );
    else {
      const o = Object.keys(r);
      n = new Array(o.length);
      for (let s = 0, l = o.length; s < l; s++) {
        const u = o[s];
        n[s] = e(r[u], u, s, a && a[s]);
      }
    }
  else
    n = [];
  return t && (t[i] = n), n;
}
function JK(r, e) {
  for (let t = 0; t < e.length; t++) {
    const i = e[t];
    if (pe(i))
      for (let n = 0; n < i.length; n++)
        r[i[n].name] = i[n].fn;
    else
      i && (r[i.name] = i.key ? (...n) => {
        const a = i.fn(...n);
        return a && (a.key = i.key), a;
      } : i.fn);
  }
  return r;
}
function Di(r, e, t = {}, i, n) {
  if (gr.isCE || gr.parent && lc(gr.parent) && gr.parent.isCE)
    return e !== "default" && (t.name = e), Yt("slot", t, i && i());
  let a = r[e];
  ({}).NODE_ENV !== "production" && a && a.length > 1 && (W(
    "SSR-optimized slot function detected in a non-SSR-optimized render function. You need to mark this component with $dynamic-slots in the parent template."
  ), a = () => []), a && a._c && (a._d = !1), xt();
  const o = a && mF(a(t)), s = va(
    xr,
    {
      key: t.key || // slot content array of a dynamic conditional slot may have a branch
      // key attached in the `createSlots` helper, respect that
      o && o.key || `_${e}`
    },
    o || (i ? i() : []),
    o && r._ === 1 ? 64 : -2
  );
  return !n && s.scopeId && (s.slotScopeIds = [s.scopeId + "-s"]), a && a._c && (a._d = !0), s;
}
function mF(r) {
  return r.some((e) => as(e) ? !(e.type === mr || e.type === xr && !mF(e.children)) : !0) ? r : null;
}
function eJ(r, e) {
  const t = {};
  if ({}.NODE_ENV !== "production" && !Tt(r))
    return W("v-on with no argument expects an object value."), t;
  for (const i in r)
    t[e && /[A-Z]/.test(i) ? `on:${i}` : Ka(i)] = r[i];
  return t;
}
const r_ = (r) => r ? GF(r) ? ZS(r) || r.proxy : r_(r.parent) : null, uc = (
  // Move PURE marker to new line to workaround compiler discarding it
  // due to type annotation
  /* @__PURE__ */ ut(/* @__PURE__ */ Object.create(null), {
    $: (r) => r,
    $el: (r) => r.vnode.el,
    $data: (r) => r.data,
    $props: (r) => ({}).NODE_ENV !== "production" ? Yh(r.props) : r.props,
    $attrs: (r) => ({}).NODE_ENV !== "production" ? Yh(r.attrs) : r.attrs,
    $slots: (r) => ({}).NODE_ENV !== "production" ? Yh(r.slots) : r.slots,
    $refs: (r) => ({}).NODE_ENV !== "production" ? Yh(r.refs) : r.refs,
    $parent: (r) => r_(r.parent),
    $root: (r) => r_(r.root),
    $emit: (r) => r.emit,
    $options: (r) => Hw(r),
    $forceUpdate: (r) => r.f || (r.f = () => gv(r.update)),
    $nextTick: (r) => r.n || (r.n = Sc.bind(r.proxy)),
    $watch: (r) => FK.bind(r)
  })
), Yw = (r) => r === "_" || r === "$", Ay = (r, e) => r !== _t && !r.__isScriptSetup && Et(r, e), Mp = {
  get({ _: r }, e) {
    const { ctx: t, setupState: i, data: n, props: a, accessCache: o, type: s, appContext: l } = r;
    if ({}.NODE_ENV !== "production" && e === "__isVue")
      return !0;
    let u;
    if (e[0] !== "$") {
      const d = o[e];
      if (d !== void 0)
        switch (d) {
          case 1:
            return i[e];
          case 2:
            return n[e];
          case 4:
            return t[e];
          case 3:
            return a[e];
        }
      else {
        if (Ay(i, e))
          return o[e] = 1, i[e];
        if (n !== _t && Et(n, e))
          return o[e] = 2, n[e];
        if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (u = r.propsOptions[0]) && Et(u, e)
        )
          return o[e] = 3, a[e];
        if (t !== _t && Et(t, e))
          return o[e] = 4, t[e];
        i_ && (o[e] = 0);
      }
    }
    const c = uc[e];
    let h, f;
    if (c)
      return e === "$attrs" ? (ei(r, "get", e), {}.NODE_ENV !== "production" && NE()) : {}.NODE_ENV !== "production" && e === "$slots" && ei(r, "get", e), c(r);
    if (
      // css module (injected by vue-loader)
      (h = s.__cssModules) && (h = h[e])
    )
      return h;
    if (t !== _t && Et(t, e))
      return o[e] = 4, t[e];
    if (
      // global properties
      f = l.config.globalProperties, Et(f, e)
    )
      return f[e];
    ({}).NODE_ENV !== "production" && gr && (!qe(e) || // #1091 avoid internal isRef/isVNode checks on component instance leading
    // to infinite warning loop
    e.indexOf("__v") !== 0) && (n !== _t && Yw(e[0]) && Et(n, e) ? W(
      `Property ${JSON.stringify(
        e
      )} must be accessed via $data because it starts with a reserved character ("$" or "_") and is not proxied on the render context.`
    ) : r === gr && W(
      `Property ${JSON.stringify(e)} was accessed during render but is not defined on instance.`
    ));
  },
  set({ _: r }, e, t) {
    const { data: i, setupState: n, ctx: a } = r;
    return Ay(n, e) ? (n[e] = t, !0) : {}.NODE_ENV !== "production" && n.__isScriptSetup && Et(n, e) ? (W(`Cannot mutate <script setup> binding "${e}" from Options API.`), !1) : i !== _t && Et(i, e) ? (i[e] = t, !0) : Et(r.props, e) ? ({}.NODE_ENV !== "production" && W(`Attempting to mutate prop "${e}". Props are readonly.`), !1) : e[0] === "$" && e.slice(1) in r ? ({}.NODE_ENV !== "production" && W(
      `Attempting to mutate public property "${e}". Properties starting with $ are reserved and readonly.`
    ), !1) : ({}.NODE_ENV !== "production" && e in r.appContext.config.globalProperties ? Object.defineProperty(a, e, {
      enumerable: !0,
      configurable: !0,
      value: t
    }) : a[e] = t, !0);
  },
  has({
    _: { data: r, setupState: e, accessCache: t, ctx: i, appContext: n, propsOptions: a }
  }, o) {
    let s;
    return !!t[o] || r !== _t && Et(r, o) || Ay(e, o) || (s = a[0]) && Et(s, o) || Et(i, o) || Et(uc, o) || Et(n.config.globalProperties, o);
  },
  defineProperty(r, e, t) {
    return t.get != null ? r._.accessCache[e] = 0 : Et(t, "value") && this.set(r, e, t.value, null), Reflect.defineProperty(r, e, t);
  }
};
({}).NODE_ENV !== "production" && (Mp.ownKeys = (r) => (W(
  "Avoid app logic that relies on enumerating keys on a component instance. The keys will be empty in production mode to avoid performance overhead."
), Reflect.ownKeys(r)));
const tJ = /* @__PURE__ */ ut(
  {},
  Mp,
  {
    get(r, e) {
      if (e !== Symbol.unscopables)
        return Mp.get(r, e, r);
    },
    has(r, e) {
      const t = e[0] !== "_" && !nj(e);
      return {}.NODE_ENV !== "production" && !t && Mp.has(r, e) && W(
        `Property ${JSON.stringify(
          e
        )} should not start with _ which is a reserved prefix for Vue internals.`
      ), t;
    }
  }
);
function rJ(r) {
  const e = {};
  return Object.defineProperty(e, "_", {
    configurable: !0,
    enumerable: !1,
    get: () => r
  }), Object.keys(uc).forEach((t) => {
    Object.defineProperty(e, t, {
      configurable: !0,
      enumerable: !1,
      get: () => uc[t](r),
      // intercepted by the proxy so no need for implementation,
      // but needed to prevent set errors
      set: dr
    });
  }), e;
}
function iJ(r) {
  const {
    ctx: e,
    propsOptions: [t]
  } = r;
  t && Object.keys(t).forEach((i) => {
    Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => r.props[i],
      set: dr
    });
  });
}
function nJ(r) {
  const { ctx: e, setupState: t } = r;
  Object.keys(je(t)).forEach((i) => {
    if (!t.__isScriptSetup) {
      if (Yw(i[0])) {
        W(
          `setup() return property ${JSON.stringify(
            i
          )} should not start with "$" or "_" which are reserved prefixes for Vue internals.`
        );
        return;
      }
      Object.defineProperty(e, i, {
        enumerable: !0,
        configurable: !0,
        get: () => t[i],
        set: dr
      });
    }
  });
}
const Hc = (r) => W(
  `${r}() is a compiler-hint helper that is only usable inside <script setup> of a single file component. Its arguments should be compiled away and passing it at runtime has no effect.`
);
function aJ() {
  return {}.NODE_ENV !== "production" && Hc("defineProps"), null;
}
function oJ() {
  return {}.NODE_ENV !== "production" && Hc("defineEmits"), null;
}
function sJ(r) {
  ({}).NODE_ENV !== "production" && Hc("defineExpose");
}
function lJ(r) {
  ({}).NODE_ENV !== "production" && Hc("defineOptions");
}
function uJ() {
  return {}.NODE_ENV !== "production" && Hc("defineSlots"), null;
}
function cJ() {
  ({}).NODE_ENV !== "production" && Hc("defineModel");
}
function hJ(r, e) {
  return {}.NODE_ENV !== "production" && Hc("withDefaults"), null;
}
function fJ() {
  return EF().slots;
}
function dJ() {
  return EF().attrs;
}
function pJ(r, e, t) {
  const i = ms();
  if ({}.NODE_ENV !== "production" && !i)
    return W("useModel() called without active instance."), Rr();
  if ({}.NODE_ENV !== "production" && !i.propsOptions[0][e])
    return W(`useModel() called with prop "${e}" which is not declared.`), Rr();
  if (t && t.local) {
    const n = Rr(r[e]);
    return Ra(
      () => r[e],
      (a) => n.value = a
    ), Ra(n, (a) => {
      a !== r[e] && i.emit(`update:${e}`, a);
    }), n;
  } else
    return {
      __v_isRef: !0,
      get value() {
        return r[e];
      },
      set value(n) {
        i.emit(`update:${e}`, n);
      }
    };
}
function EF() {
  const r = ms();
  return {}.NODE_ENV !== "production" && !r && W("useContext() called without active instance."), r.setupContext || (r.setupContext = YF(r));
}
function mg(r) {
  return pe(r) ? r.reduce(
    (e, t) => (e[t] = null, e),
    {}
  ) : r;
}
function gJ(r, e) {
  const t = mg(r);
  for (const i in e) {
    if (i.startsWith("__skip"))
      continue;
    let n = t[i];
    n ? pe(n) || Ue(n) ? n = t[i] = { type: n, default: e[i] } : n.default = e[i] : n === null ? n = t[i] = { default: e[i] } : {}.NODE_ENV !== "production" && W(`props default key "${i}" has no corresponding declaration.`), n && e[`__skip_${i}`] && (n.skipFactory = !0);
  }
  return t;
}
function vJ(r, e) {
  return !r || !e ? r || e : pe(r) && pe(e) ? r.concat(e) : ut({}, mg(r), mg(e));
}
function OJ(r, e) {
  const t = {};
  for (const i in r)
    e.includes(i) || Object.defineProperty(t, i, {
      enumerable: !0,
      get: () => r[i]
    });
  return t;
}
function mJ(r) {
  const e = ms();
  ({}).NODE_ENV !== "production" && !e && W(
    "withAsyncContext called without active current instance. This is likely a bug."
  );
  let t = r();
  return fl(), xS(t) && (t = t.catch((i) => {
    throw Al(e), i;
  })), [t, () => Al(e)];
}
function EJ() {
  const r = /* @__PURE__ */ Object.create(null);
  return (e, t) => {
    r[t] ? W(`${e} property "${t}" is already defined in ${r[t]}.`) : r[t] = e;
  };
}
let i_ = !0;
function bJ(r) {
  const e = Hw(r), t = r.proxy, i = r.ctx;
  i_ = !1, e.beforeCreate && OL(e.beforeCreate, r, "bc");
  const {
    // state
    data: n,
    computed: a,
    methods: o,
    watch: s,
    provide: l,
    inject: u,
    // lifecycle
    created: c,
    beforeMount: h,
    mounted: f,
    beforeUpdate: d,
    updated: p,
    activated: g,
    deactivated: v,
    beforeDestroy: O,
    beforeUnmount: m,
    destroyed: E,
    unmounted: b,
    render: S,
    renderTracked: T,
    renderTriggered: y,
    errorCaptured: R,
    serverPrefetch: _,
    // public API
    expose: C,
    inheritAttrs: I,
    // assets
    components: w,
    directives: x,
    filters: P
  } = e, L = {}.NODE_ENV !== "production" ? EJ() : null;
  if ({}.NODE_ENV !== "production") {
    const [U] = r.propsOptions;
    if (U)
      for (const Q in U)
        L("Props", Q);
  }
  if (u && SJ(u, i, L), o)
    for (const U in o) {
      const Q = o[U];
      Ue(Q) ? ({}.NODE_ENV !== "production" ? Object.defineProperty(i, U, {
        value: Q.bind(t),
        configurable: !0,
        enumerable: !0,
        writable: !0
      }) : i[U] = Q.bind(t), {}.NODE_ENV !== "production" && L("Methods", U)) : {}.NODE_ENV !== "production" && W(
        `Method "${U}" has type "${typeof Q}" in the component definition. Did you reference the function correctly?`
      );
    }
  if (n) {
    ({}).NODE_ENV !== "production" && !Ue(n) && W(
      "The data option must be a function. Plain object usage is no longer supported."
    );
    const U = n.call(t, t);
    if ({}.NODE_ENV !== "production" && xS(U) && W(
      "data() returned a Promise - note data() cannot be async; If you intend to perform data fetching before component renders, use async setup() + <Suspense>."
    ), !Tt(U))
      ({}).NODE_ENV !== "production" && W("data() should return an object.");
    else if (r.data = QS(U), {}.NODE_ENV !== "production")
      for (const Q in U)
        L("Data", Q), Yw(Q[0]) || Object.defineProperty(i, Q, {
          configurable: !0,
          enumerable: !0,
          get: () => U[Q],
          set: dr
        });
  }
  if (i_ = !0, a)
    for (const U in a) {
      const Q = a[U], V = Ue(Q) ? Q.bind(t, t) : Ue(Q.get) ? Q.get.bind(t, t) : dr;
      ({}).NODE_ENV !== "production" && V === dr && W(`Computed property "${U}" has no getter.`);
      const F = !Ue(Q) && Ue(Q.set) ? Q.set.bind(t) : {}.NODE_ENV !== "production" ? () => {
        W(
          `Write operation failed: computed property "${U}" is readonly.`
        );
      } : dr, j = WF({
        get: V,
        set: F
      });
      Object.defineProperty(i, U, {
        enumerable: !0,
        configurable: !0,
        get: () => j.value,
        set: (ae) => j.value = ae
      }), {}.NODE_ENV !== "production" && L("Computed", U);
    }
  if (s)
    for (const U in s)
      bF(s[U], i, t, U);
  if (l) {
    const U = Ue(l) ? l.call(t) : l;
    Reflect.ownKeys(U).forEach((Q) => {
      TF(Q, U[Q]);
    });
  }
  c && OL(c, r, "c");
  function D(U, Q) {
    pe(Q) ? Q.forEach((V) => U(V.bind(t))) : Q && U(Q.bind(t));
  }
  if (D(uF, h), D(Os, f), D(cF, d), D(YS, p), D(oF, g), D(sF, v), D(pF, R), D(dF, T), D(fF, y), D(HS, m), D(WS, b), D(hF, _), pe(C))
    if (C.length) {
      const U = r.exposed || (r.exposed = {});
      C.forEach((Q) => {
        Object.defineProperty(U, Q, {
          get: () => t[Q],
          set: (V) => t[Q] = V
        });
      });
    } else
      r.exposed || (r.exposed = {});
  S && r.render === dr && (r.render = S), I != null && (r.inheritAttrs = I), w && (r.components = w), x && (r.directives = x);
}
function SJ(r, e, t = dr) {
  pe(r) && (r = n_(r));
  for (const i in r) {
    const n = r[i];
    let a;
    Tt(n) ? "default" in n ? a = kp(
      n.from || i,
      n.default,
      !0
      /* treat default function as factory */
    ) : a = kp(n.from || i) : a = kp(n), sr(a) ? Object.defineProperty(e, i, {
      enumerable: !0,
      configurable: !0,
      get: () => a.value,
      set: (o) => a.value = o
    }) : e[i] = a, {}.NODE_ENV !== "production" && t("Inject", i);
  }
}
function OL(r, e, t) {
  En(
    pe(r) ? r.map((i) => i.bind(e.proxy)) : r.bind(e.proxy),
    e,
    t
  );
}
function bF(r, e, t, i) {
  const n = i.includes(".") ? rF(t, i) : () => t[i];
  if (qe(r)) {
    const a = e[r];
    Ue(a) ? Ra(n, a) : {}.NODE_ENV !== "production" && W(`Invalid watch handler specified by key "${r}"`, a);
  } else if (Ue(r))
    Ra(n, r.bind(t));
  else if (Tt(r))
    if (pe(r))
      r.forEach((a) => bF(a, e, t, i));
    else {
      const a = Ue(r.handler) ? r.handler.bind(t) : e[r.handler];
      Ue(a) ? Ra(n, a, r) : {}.NODE_ENV !== "production" && W(`Invalid watch handler specified by key "${r.handler}"`, a);
    }
  else
    ({}).NODE_ENV !== "production" && W(`Invalid watch option: "${i}"`, r);
}
function Hw(r) {
  const e = r.type, { mixins: t, extends: i } = e, {
    mixins: n,
    optionsCache: a,
    config: { optionMergeStrategies: o }
  } = r.appContext, s = a.get(e);
  let l;
  return s ? l = s : !n.length && !t && !i ? l = e : (l = {}, n.length && n.forEach(
    (u) => PE(l, u, o, !0)
  ), PE(l, e, o)), Tt(e) && a.set(e, l), l;
}
function PE(r, e, t, i = !1) {
  const { mixins: n, extends: a } = e;
  a && PE(r, a, t, !0), n && n.forEach(
    (o) => PE(r, o, t, !0)
  );
  for (const o in e)
    if (i && o === "expose")
      ({}).NODE_ENV !== "production" && W(
        '"expose" option is ignored when declared in mixins or extends. It should only be declared in the base component itself.'
      );
    else {
      const s = TJ[o] || t && t[o];
      r[o] = s ? s(r[o], e[o]) : e[o];
    }
  return r;
}
const TJ = {
  data: mL,
  props: EL,
  emits: EL,
  // objects
  methods: fp,
  computed: fp,
  // lifecycle
  beforeCreate: Ri,
  created: Ri,
  beforeMount: Ri,
  mounted: Ri,
  beforeUpdate: Ri,
  updated: Ri,
  beforeDestroy: Ri,
  beforeUnmount: Ri,
  destroyed: Ri,
  unmounted: Ri,
  activated: Ri,
  deactivated: Ri,
  errorCaptured: Ri,
  serverPrefetch: Ri,
  // assets
  components: fp,
  directives: fp,
  // watch
  watch: RJ,
  // provide / inject
  provide: mL,
  inject: yJ
};
function mL(r, e) {
  return e ? r ? function() {
    return ut(
      Ue(r) ? r.call(this, this) : r,
      Ue(e) ? e.call(this, this) : e
    );
  } : e : r;
}
function yJ(r, e) {
  return fp(n_(r), n_(e));
}
function n_(r) {
  if (pe(r)) {
    const e = {};
    for (let t = 0; t < r.length; t++)
      e[r[t]] = r[t];
    return e;
  }
  return r;
}
function Ri(r, e) {
  return r ? [...new Set([].concat(r, e))] : e;
}
function fp(r, e) {
  return r ? ut(/* @__PURE__ */ Object.create(null), r, e) : e;
}
function EL(r, e) {
  return r ? pe(r) && pe(e) ? [.../* @__PURE__ */ new Set([...r, ...e])] : ut(
    /* @__PURE__ */ Object.create(null),
    mg(r),
    mg(e ?? {})
  ) : e;
}
function RJ(r, e) {
  if (!r)
    return e;
  if (!e)
    return r;
  const t = ut(/* @__PURE__ */ Object.create(null), r);
  for (const i in e)
    t[i] = Ri(r[i], e[i]);
  return t;
}
function SF() {
  return {
    app: null,
    config: {
      isNativeTag: xp,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let AJ = 0;
function _J(r, e) {
  return function(i, n = null) {
    Ue(i) || (i = ut({}, i)), n != null && !Tt(n) && ({}.NODE_ENV !== "production" && W("root props passed to app.mount() must be an object."), n = null);
    const a = SF();
    ({}).NODE_ENV !== "production" && Object.defineProperty(a.config, "unwrapInjectedRef", {
      get() {
        return !0;
      },
      set() {
        W(
          "app.config.unwrapInjectedRef has been deprecated. 3.3 now alawys unwraps injected refs in Options API."
        );
      }
    });
    const o = /* @__PURE__ */ new Set();
    let s = !1;
    const l = a.app = {
      _uid: AJ++,
      _component: i,
      _props: n,
      _container: null,
      _context: a,
      _instance: null,
      version: d_,
      get config() {
        return a.config;
      },
      set config(u) {
        ({}).NODE_ENV !== "production" && W(
          "app.config cannot be replaced. Modify individual options instead."
        );
      },
      use(u, ...c) {
        return o.has(u) ? {}.NODE_ENV !== "production" && W("Plugin has already been applied to target app.") : u && Ue(u.install) ? (o.add(u), u.install(l, ...c)) : Ue(u) ? (o.add(u), u(l, ...c)) : {}.NODE_ENV !== "production" && W(
          'A plugin must either be a function or an object with an "install" function.'
        ), l;
      },
      mixin(u) {
        return a.mixins.includes(u) ? {}.NODE_ENV !== "production" && W(
          "Mixin has already been applied to target app" + (u.name ? `: ${u.name}` : "")
        ) : a.mixins.push(u), l;
      },
      component(u, c) {
        return {}.NODE_ENV !== "production" && c_(u, a.config), c ? ({}.NODE_ENV !== "production" && a.components[u] && W(`Component "${u}" has already been registered in target app.`), a.components[u] = c, l) : a.components[u];
      },
      directive(u, c) {
        return {}.NODE_ENV !== "production" && iF(u), c ? ({}.NODE_ENV !== "production" && a.directives[u] && W(`Directive "${u}" has already been registered in target app.`), a.directives[u] = c, l) : a.directives[u];
      },
      mount(u, c, h) {
        if (s)
          ({}).NODE_ENV !== "production" && W(
            "App has already been mounted.\nIf you want to remount the same app, move your app creation logic into a factory function and create fresh app instances for each mount - e.g. `const createMyApp = () => createApp(App)`"
          );
        else {
          ({}).NODE_ENV !== "production" && u.__vue_app__ && W(
            "There is already an app instance mounted on the host container.\n If you want to mount another app on the same host container, you need to unmount the previous app by calling `app.unmount()` first."
          );
          const f = Yt(
            i,
            n
          );
          return f.appContext = a, {}.NODE_ENV !== "production" && (a.reload = () => {
            r(ia(f), u, h);
          }), c && e ? e(f, u) : r(f, u, h), s = !0, l._container = u, u.__vue_app__ = l, {}.NODE_ENV !== "production" && (l._instance = f.component, SK(l, d_)), ZS(f.component) || f.component.proxy;
        }
      },
      unmount() {
        s ? (r(null, l._container), {}.NODE_ENV !== "production" && (l._instance = null, TK(l)), delete l._container.__vue_app__) : {}.NODE_ENV !== "production" && W("Cannot unmount an app that is not mounted.");
      },
      provide(u, c) {
        return {}.NODE_ENV !== "production" && u in a.provides && W(
          `App already provides property with key "${String(u)}". It will be overwritten with the new value.`
        ), a.provides[u] = c, l;
      },
      runWithContext(u) {
        Eg = l;
        try {
          return u();
        } finally {
          Eg = null;
        }
      }
    };
    return l;
  };
}
let Eg = null;
function TF(r, e) {
  if (!pr)
    ({}).NODE_ENV !== "production" && W("provide() can only be used inside setup().");
  else {
    let t = pr.provides;
    const i = pr.parent && pr.parent.provides;
    i === t && (t = pr.provides = Object.create(i)), t[r] = e;
  }
}
function kp(r, e, t = !1) {
  const i = pr || gr;
  if (i || Eg) {
    const n = i ? i.parent == null ? i.vnode.appContext && i.vnode.appContext.provides : i.parent.provides : Eg._context.provides;
    if (n && r in n)
      return n[r];
    if (arguments.length > 1)
      return t && Ue(e) ? e.call(i && i.proxy) : e;
    ({}).NODE_ENV !== "production" && W(`injection "${String(r)}" not found.`);
  } else
    ({}).NODE_ENV !== "production" && W("inject() can only be used inside setup() or functional components.");
}
function CJ() {
  return !!(pr || gr || Eg);
}
function IJ(r, e, t, i = !1) {
  const n = {}, a = {};
  yE(a, zS, 1), r.propsDefaults = /* @__PURE__ */ Object.create(null), yF(r, e, n, a);
  for (const o in r.propsOptions[0])
    o in n || (n[o] = void 0);
  ({}).NODE_ENV !== "production" && AF(e || {}, n, r), t ? r.props = i ? n : V5(n) : r.type.props ? r.props = n : r.props = a, r.attrs = a;
}
function wJ(r) {
  for (; r; ) {
    if (r.type.__hmrId)
      return !0;
    r = r.parent;
  }
}
function NJ(r, e, t, i) {
  const {
    props: n,
    attrs: a,
    vnode: { patchFlag: o }
  } = r, s = je(n), [l] = r.propsOptions;
  let u = !1;
  if (
    // always force full diff in dev
    // - #1942 if hmr is enabled with sfc component
    // - vite#872 non-sfc component used by sfc component
    !({}.NODE_ENV !== "production" && wJ(r)) && (i || o > 0) && !(o & 16)
  ) {
    if (o & 8) {
      const c = r.vnode.dynamicProps;
      for (let h = 0; h < c.length; h++) {
        let f = c[h];
        if (GS(r.emitsOptions, f))
          continue;
        const d = e[f];
        if (l)
          if (Et(a, f))
            d !== a[f] && (a[f] = d, u = !0);
          else {
            const p = Cr(f);
            n[p] = a_(
              l,
              s,
              p,
              d,
              r,
              !1
              /* isAbsent */
            );
          }
        else
          d !== a[f] && (a[f] = d, u = !0);
      }
    }
  } else {
    yF(r, e, n, a) && (u = !0);
    let c;
    for (const h in s)
      (!e || // for camelCase
      !Et(e, h) && // it's possible the original props was passed in as kebab-case
      // and converted to camelCase (#955)
      ((c = Li(h)) === h || !Et(e, c))) && (l ? t && // for camelCase
      (t[h] !== void 0 || // for kebab-case
      t[c] !== void 0) && (n[h] = a_(
        l,
        s,
        h,
        void 0,
        r,
        !0
        /* isAbsent */
      )) : delete n[h]);
    if (a !== s)
      for (const h in a)
        (!e || !Et(e, h)) && (delete a[h], u = !0);
  }
  u && So(r, "set", "$attrs"), {}.NODE_ENV !== "production" && AF(e || {}, n, r);
}
function yF(r, e, t, i) {
  const [n, a] = r.propsOptions;
  let o = !1, s;
  if (e)
    for (let l in e) {
      if (ac(l))
        continue;
      const u = e[l];
      let c;
      n && Et(n, c = Cr(l)) ? !a || !a.includes(c) ? t[c] = u : (s || (s = {}))[c] = u : GS(r.emitsOptions, l) || (!(l in i) || u !== i[l]) && (i[l] = u, o = !0);
    }
  if (a) {
    const l = je(t), u = s || _t;
    for (let c = 0; c < a.length; c++) {
      const h = a[c];
      t[h] = a_(
        n,
        l,
        h,
        u[h],
        r,
        !Et(u, h)
      );
    }
  }
  return o;
}
function a_(r, e, t, i, n, a) {
  const o = r[t];
  if (o != null) {
    const s = Et(o, "default");
    if (s && i === void 0) {
      const l = o.default;
      if (o.type !== Function && !o.skipFactory && Ue(l)) {
        const { propsDefaults: u } = n;
        t in u ? i = u[t] : (Al(n), i = u[t] = l.call(
          null,
          e
        ), fl());
      } else
        i = l;
    }
    o[
      0
      /* shouldCast */
    ] && (a && !s ? i = !1 : o[
      1
      /* shouldCastTrue */
    ] && (i === "" || i === Li(t)) && (i = !0));
  }
  return i;
}
function RF(r, e, t = !1) {
  const i = e.propsCache, n = i.get(r);
  if (n)
    return n;
  const a = r.props, o = {}, s = [];
  let l = !1;
  if (!Ue(r)) {
    const c = (h) => {
      l = !0;
      const [f, d] = RF(h, e, !0);
      ut(o, f), d && s.push(...d);
    };
    !t && e.mixins.length && e.mixins.forEach(c), r.extends && c(r.extends), r.mixins && r.mixins.forEach(c);
  }
  if (!a && !l)
    return Tt(r) && i.set(r, tf), tf;
  if (pe(a))
    for (let c = 0; c < a.length; c++) {
      ({}).NODE_ENV !== "production" && !qe(a[c]) && W("props must be strings when using array syntax.", a[c]);
      const h = Cr(a[c]);
      bL(h) && (o[h] = _t);
    }
  else if (a) {
    ({}).NODE_ENV !== "production" && !Tt(a) && W("invalid props options", a);
    for (const c in a) {
      const h = Cr(c);
      if (bL(h)) {
        const f = a[c], d = o[h] = pe(f) || Ue(f) ? { type: f } : ut({}, f);
        if (d) {
          const p = TL(Boolean, d.type), g = TL(String, d.type);
          d[
            0
            /* shouldCast */
          ] = p > -1, d[
            1
            /* shouldCastTrue */
          ] = g < 0 || p < g, (p > -1 || Et(d, "default")) && s.push(h);
        }
      }
    }
  }
  const u = [o, s];
  return Tt(r) && i.set(r, u), u;
}
function bL(r) {
  return r[0] !== "$" ? !0 : ({}.NODE_ENV !== "production" && W(`Invalid prop name: "${r}" is a reserved property.`), !1);
}
function o_(r) {
  const e = r && r.toString().match(/^\s*(function|class) (\w+)/);
  return e ? e[2] : r === null ? "null" : "";
}
function SL(r, e) {
  return o_(r) === o_(e);
}
function TL(r, e) {
  return pe(e) ? e.findIndex((t) => SL(t, r)) : Ue(e) && SL(e, r) ? 0 : -1;
}
function AF(r, e, t) {
  const i = je(e), n = t.propsOptions[0];
  for (const a in n) {
    let o = n[a];
    o != null && xJ(
      a,
      i[a],
      o,
      !Et(r, a) && !Et(r, Li(a))
    );
  }
}
function xJ(r, e, t, i) {
  const { type: n, required: a, validator: o, skipCheck: s } = t;
  if (a && i) {
    W('Missing required prop: "' + r + '"');
    return;
  }
  if (!(e == null && !a)) {
    if (n != null && n !== !0 && !s) {
      let l = !1;
      const u = pe(n) ? n : [n], c = [];
      for (let h = 0; h < u.length && !l; h++) {
        const { valid: f, expectedType: d } = LJ(e, u[h]);
        c.push(d || ""), l = f;
      }
      if (!l) {
        W(DJ(r, e, c));
        return;
      }
    }
    o && !o(e) && W('Invalid prop: custom validator check failed for prop "' + r + '".');
  }
}
const PJ = /* @__PURE__ */ bi(
  "String,Number,Boolean,Function,Symbol,BigInt"
);
function LJ(r, e) {
  let t;
  const i = o_(e);
  if (PJ(i)) {
    const n = typeof r;
    t = n === i.toLowerCase(), !t && n === "object" && (t = r instanceof e);
  } else
    i === "Object" ? t = Tt(r) : i === "Array" ? t = pe(r) : i === "null" ? t = r === null : t = r instanceof e;
  return {
    valid: t,
    expectedType: i
  };
}
function DJ(r, e, t) {
  let i = `Invalid prop: type check failed for prop "${r}". Expected ${t.map(bo).join(" | ")}`;
  const n = t[0], a = Rw(e), o = yL(e, n), s = yL(e, a);
  return t.length === 1 && RL(n) && !MJ(n, a) && (i += ` with value ${o}`), i += `, got ${a} `, RL(a) && (i += `with value ${s}.`), i;
}
function yL(r, e) {
  return e === "String" ? `"${r}"` : e === "Number" ? `${Number(r)}` : `${r}`;
}
function RL(r) {
  return ["string", "number", "boolean"].some((t) => r.toLowerCase() === t);
}
function MJ(...r) {
  return r.some((e) => e.toLowerCase() === "boolean");
}
const _F = (r) => r[0] === "_" || r === "$stable", Ww = (r) => pe(r) ? r.map(Xi) : [Xi(r)], kJ = (r, e, t) => {
  if (e._n)
    return e;
  const i = vg((...n) => ({}.NODE_ENV !== "production" && pr && W(
    `Slot "${r}" invoked outside of the render function: this will not track dependencies used in the slot. Invoke the slot function inside the render function instead.`
  ), Ww(e(...n))), t);
  return i._c = !1, i;
}, CF = (r, e, t) => {
  const i = r._ctx;
  for (const n in r) {
    if (_F(n))
      continue;
    const a = r[n];
    if (Ue(a))
      e[n] = kJ(n, a, i);
    else if (a != null) {
      ({}).NODE_ENV !== "production" && W(
        `Non-function value encountered for slot "${n}". Prefer function slots for better performance.`
      );
      const o = Ww(a);
      e[n] = () => o;
    }
  }
}, IF = (r, e) => {
  ({}).NODE_ENV !== "production" && !Wf(r.vnode) && W(
    "Non-function value encountered for default slot. Prefer function slots for better performance."
  );
  const t = Ww(e);
  r.slots.default = () => t;
}, QJ = (r, e) => {
  if (r.vnode.shapeFlag & 32) {
    const t = e._;
    t ? (r.slots = je(e), yE(e, "_", t)) : CF(
      e,
      r.slots = {}
    );
  } else
    r.slots = {}, e && IF(r, e);
  yE(r.slots, zS, 1);
}, UJ = (r, e, t) => {
  const { vnode: i, slots: n } = r;
  let a = !0, o = _t;
  if (i.shapeFlag & 32) {
    const s = e._;
    s ? {}.NODE_ENV !== "production" && cl ? (ut(n, e), So(r, "set", "$slots")) : t && s === 1 ? a = !1 : (ut(n, e), !t && s === 1 && delete n._) : (a = !e.$stable, CF(e, n)), o = e;
  } else
    e && (IF(r, e), o = { default: 1 });
  if (a)
    for (const s in n)
      !_F(s) && !(s in o) && delete n[s];
};
function LE(r, e, t, i, n = !1) {
  if (pe(r)) {
    r.forEach(
      (f, d) => LE(
        f,
        e && (pe(e) ? e[d] : e),
        t,
        i,
        n
      )
    );
    return;
  }
  if (lc(i) && !n)
    return;
  const a = i.shapeFlag & 4 ? ZS(i.component) || i.component.proxy : i.el, o = n ? null : a, { i: s, r: l } = r;
  if ({}.NODE_ENV !== "production" && !s) {
    W(
      "Missing ref owner context. ref cannot be used on hoisted vnodes. A vnode with ref must be created inside the render function."
    );
    return;
  }
  const u = e && e.r, c = s.refs === _t ? s.refs = {} : s.refs, h = s.setupState;
  if (u != null && u !== l && (qe(u) ? (c[u] = null, Et(h, u) && (h[u] = null)) : sr(u) && (u.value = null)), Ue(l))
    go(l, s, 12, [o, c]);
  else {
    const f = qe(l), d = sr(l);
    if (f || d) {
      const p = () => {
        if (r.f) {
          const g = f ? Et(h, l) ? h[l] : c[l] : l.value;
          n ? pe(g) && yw(g, a) : pe(g) ? g.includes(a) || g.push(a) : f ? (c[l] = [a], Et(h, l) && (h[l] = c[l])) : (l.value = [a], r.k && (c[r.k] = l.value));
        } else
          f ? (c[l] = o, Et(h, l) && (h[l] = o)) : d ? (l.value = o, r.k && (c[r.k] = o)) : {}.NODE_ENV !== "production" && W("Invalid template ref type:", l, `(${typeof l})`);
      };
      o ? (p.id = -1, Hr(p, t)) : p();
    } else
      ({}).NODE_ENV !== "production" && W("Invalid template ref type:", l, `(${typeof l})`);
  }
}
let _s = !1;
const sO = (r) => /svg/.test(r.namespaceURI) && r.tagName !== "foreignObject", bd = (r) => r.nodeType === 8;
function $J(r) {
  const {
    mt: e,
    p: t,
    o: {
      patchProp: i,
      createText: n,
      nextSibling: a,
      parentNode: o,
      remove: s,
      insert: l,
      createComment: u
    }
  } = r, c = (O, m) => {
    if (!m.hasChildNodes()) {
      ({}).NODE_ENV !== "production" && W(
        "Attempting to hydrate existing markup but container is empty. Performing full mount instead."
      ), t(null, O, m), wE(), m._vnode = O;
      return;
    }
    _s = !1, h(m.firstChild, O, null, null, null), wE(), m._vnode = O, _s && console.error("Hydration completed but contains mismatches.");
  }, h = (O, m, E, b, S, T = !1) => {
    const y = bd(O) && O.data === "[", R = () => g(
      O,
      m,
      E,
      b,
      S,
      y
    ), { type: _, ref: C, shapeFlag: I, patchFlag: w } = m;
    let x = O.nodeType;
    m.el = O, w === -2 && (T = !1, m.dynamicChildren = null);
    let P = null;
    switch (_) {
      case Rl:
        x !== 3 ? m.children === "" ? (l(m.el = n(""), o(O), O), P = O) : P = R() : (O.data !== m.children && (_s = !0, {}.NODE_ENV !== "production" && W(
          `Hydration text mismatch:
- Client: ${JSON.stringify(O.data)}
- Server: ${JSON.stringify(m.children)}`
        ), O.data = m.children), P = a(O));
        break;
      case mr:
        x !== 8 || y ? P = R() : P = a(O);
        break;
      case hl:
        if (y && (O = a(O), x = O.nodeType), x === 1 || x === 3) {
          P = O;
          const L = !m.children.length;
          for (let D = 0; D < m.staticCount; D++)
            L && (m.children += P.nodeType === 1 ? P.outerHTML : P.data), D === m.staticCount - 1 && (m.anchor = P), P = a(P);
          return y ? a(P) : P;
        } else
          R();
        break;
      case xr:
        y ? P = p(
          O,
          m,
          E,
          b,
          S,
          T
        ) : P = R();
        break;
      default:
        if (I & 1)
          x !== 1 || m.type.toLowerCase() !== O.tagName.toLowerCase() ? P = R() : P = f(
            O,
            m,
            E,
            b,
            S,
            T
          );
        else if (I & 6) {
          m.slotScopeIds = S;
          const L = o(O);
          if (e(
            m,
            L,
            null,
            E,
            b,
            sO(L),
            T
          ), P = y ? v(O) : a(O), P && bd(P) && P.data === "teleport end" && (P = a(P)), lc(m)) {
            let D;
            y ? (D = Yt(xr), D.anchor = P ? P.previousSibling : L.lastChild) : D = O.nodeType === 3 ? zw("") : Yt("div"), D.el = O, m.component.subTree = D;
          }
        } else
          I & 64 ? x !== 8 ? P = R() : P = m.type.hydrate(
            O,
            m,
            E,
            b,
            S,
            T,
            r,
            d
          ) : I & 128 ? P = m.type.hydrate(
            O,
            m,
            E,
            b,
            sO(o(O)),
            S,
            T,
            r,
            h
          ) : {}.NODE_ENV !== "production" && W("Invalid HostVNode type:", _, `(${typeof _})`);
    }
    return C != null && LE(C, null, b, m), P;
  }, f = (O, m, E, b, S, T) => {
    T = T || !!m.dynamicChildren;
    const { type: y, props: R, patchFlag: _, shapeFlag: C, dirs: I } = m, w = y === "input" && I || y === "option";
    if ({}.NODE_ENV !== "production" || w || _ !== -1) {
      if (I && qa(m, null, E, "created"), R)
        if (w || !T || _ & 48)
          for (const P in R)
            (w && P.endsWith("value") || is(P) && !ac(P)) && i(
              O,
              P,
              null,
              R[P],
              !1,
              void 0,
              E
            );
        else
          R.onClick && i(
            O,
            "onClick",
            null,
            R.onClick,
            !1,
            void 0,
            E
          );
      let x;
      if ((x = R && R.onVnodeBeforeMount) && Fi(x, E, m), I && qa(m, null, E, "beforeMount"), ((x = R && R.onVnodeMounted) || I) && eF(() => {
        x && Fi(x, E, m), I && qa(m, null, E, "mounted");
      }, b), C & 16 && // skip if element has innerHTML / textContent
      !(R && (R.innerHTML || R.textContent))) {
        let P = d(
          O.firstChild,
          m,
          O,
          E,
          b,
          S,
          T
        ), L = !1;
        for (; P; ) {
          _s = !0, {}.NODE_ENV !== "production" && !L && (W(
            `Hydration children mismatch in <${m.type}>: server rendered element contains more child nodes than client vdom.`
          ), L = !0);
          const D = P;
          P = P.nextSibling, s(D);
        }
      } else
        C & 8 && O.textContent !== m.children && (_s = !0, {}.NODE_ENV !== "production" && W(
          `Hydration text content mismatch in <${m.type}>:
- Client: ${O.textContent}
- Server: ${m.children}`
        ), O.textContent = m.children);
    }
    return O.nextSibling;
  }, d = (O, m, E, b, S, T, y) => {
    y = y || !!m.dynamicChildren;
    const R = m.children, _ = R.length;
    let C = !1;
    for (let I = 0; I < _; I++) {
      const w = y ? R[I] : R[I] = Xi(R[I]);
      if (O)
        O = h(
          O,
          w,
          b,
          S,
          T,
          y
        );
      else {
        if (w.type === Rl && !w.children)
          continue;
        _s = !0, {}.NODE_ENV !== "production" && !C && (W(
          `Hydration children mismatch in <${E.tagName.toLowerCase()}>: server rendered element contains fewer child nodes than client vdom.`
        ), C = !0), t(
          null,
          w,
          E,
          null,
          b,
          S,
          sO(E),
          T
        );
      }
    }
    return O;
  }, p = (O, m, E, b, S, T) => {
    const { slotScopeIds: y } = m;
    y && (S = S ? S.concat(y) : y);
    const R = o(O), _ = d(
      a(O),
      m,
      R,
      E,
      b,
      S,
      T
    );
    return _ && bd(_) && _.data === "]" ? a(m.anchor = _) : (_s = !0, l(m.anchor = u("]"), R, _), _);
  }, g = (O, m, E, b, S, T) => {
    if (_s = !0, {}.NODE_ENV !== "production" && W(
      `Hydration node mismatch:
- Client vnode:`,
      m.type,
      `
- Server rendered DOM:`,
      O,
      O.nodeType === 3 ? "(text)" : bd(O) && O.data === "[" ? "(start of fragment)" : ""
    ), m.el = null, T) {
      const _ = v(O);
      for (; ; ) {
        const C = a(O);
        if (C && C !== _)
          s(C);
        else
          break;
      }
    }
    const y = a(O), R = o(O);
    return s(O), t(
      null,
      m,
      R,
      y,
      E,
      b,
      sO(R),
      S
    ), y;
  }, v = (O) => {
    let m = 0;
    for (; O; )
      if (O = a(O), O && bd(O) && (O.data === "[" && m++, O.data === "]")) {
        if (m === 0)
          return a(O);
        m--;
      }
    return O;
  };
  return [c, h];
}
let Sd, Zs;
function $o(r, e) {
  r.appContext.config.performance && DE() && Zs.mark(`vue-${e}-${r.uid}`), {}.NODE_ENV !== "production" && AK(r, e, DE() ? Zs.now() : Date.now());
}
function Vo(r, e) {
  if (r.appContext.config.performance && DE()) {
    const t = `vue-${e}-${r.uid}`, i = t + ":end";
    Zs.mark(i), Zs.measure(
      `<${qS(r, r.type)}> ${e}`,
      t,
      i
    ), Zs.clearMarks(t), Zs.clearMarks(i);
  }
  ({}).NODE_ENV !== "production" && _K(r, e, DE() ? Zs.now() : Date.now());
}
function DE() {
  return Sd !== void 0 || (typeof window < "u" && window.performance ? (Sd = !0, Zs = window.performance) : Sd = !1), Sd;
}
function VJ() {
  const r = [];
  if ({}.NODE_ENV !== "production" && r.length) {
    const e = r.length > 1;
    console.warn(
      `Feature flag${e ? "s" : ""} ${r.join(", ")} ${e ? "are" : "is"} not explicitly defined. You are running the esm-bundler build of Vue, which expects these compile-time feature flags to be globally injected via the bundler config in order to get better tree-shaking in the production bundle.

For more details, see https://link.vuejs.org/feature-flags.`
    );
  }
}
const Hr = eF;
function wF(r) {
  return xF(r);
}
function NF(r) {
  return xF(r, $J);
}
function xF(r, e) {
  VJ();
  const t = _E();
  t.__VUE__ = !0, {}.NODE_ENV !== "production" && Qw(t.__VUE_DEVTOOLS_GLOBAL_HOOK__, t);
  const {
    insert: i,
    remove: n,
    patchProp: a,
    createElement: o,
    createText: s,
    createComment: l,
    setText: u,
    setElementText: c,
    parentNode: h,
    nextSibling: f,
    setScopeId: d = dr,
    insertStaticContent: p
  } = r, g = (M, k, G, H = null, z = null, te = null, se = !1, ie = null, oe = {}.NODE_ENV !== "production" && cl ? !1 : !!k.dynamicChildren) => {
    if (M === k)
      return;
    M && !Oa(M, k) && (H = Ee(M), ce(M, z, te, !0), M = null), k.patchFlag === -2 && (oe = !1, k.dynamicChildren = null);
    const { type: J, ref: Ae, shapeFlag: _e } = k;
    switch (J) {
      case Rl:
        v(M, k, G, H);
        break;
      case mr:
        O(M, k, G, H);
        break;
      case hl:
        M == null ? m(k, G, H, se) : {}.NODE_ENV !== "production" && E(M, k, G, se);
        break;
      case xr:
        x(
          M,
          k,
          G,
          H,
          z,
          te,
          se,
          ie,
          oe
        );
        break;
      default:
        _e & 1 ? T(
          M,
          k,
          G,
          H,
          z,
          te,
          se,
          ie,
          oe
        ) : _e & 6 ? P(
          M,
          k,
          G,
          H,
          z,
          te,
          se,
          ie,
          oe
        ) : _e & 64 || _e & 128 ? J.process(
          M,
          k,
          G,
          H,
          z,
          te,
          se,
          ie,
          oe,
          Ie
        ) : {}.NODE_ENV !== "production" && W("Invalid VNode type:", J, `(${typeof J})`);
    }
    Ae != null && z && LE(Ae, M && M.ref, te, k || M, !k);
  }, v = (M, k, G, H) => {
    if (M == null)
      i(
        k.el = s(k.children),
        G,
        H
      );
    else {
      const z = k.el = M.el;
      k.children !== M.children && u(z, k.children);
    }
  }, O = (M, k, G, H) => {
    M == null ? i(
      k.el = l(k.children || ""),
      G,
      H
    ) : k.el = M.el;
  }, m = (M, k, G, H) => {
    [M.el, M.anchor] = p(
      M.children,
      k,
      G,
      H,
      M.el,
      M.anchor
    );
  }, E = (M, k, G, H) => {
    if (k.children !== M.children) {
      const z = f(M.anchor);
      S(M), [k.el, k.anchor] = p(
        k.children,
        G,
        z,
        H
      );
    } else
      k.el = M.el, k.anchor = M.anchor;
  }, b = ({ el: M, anchor: k }, G, H) => {
    let z;
    for (; M && M !== k; )
      z = f(M), i(M, G, H), M = z;
    i(k, G, H);
  }, S = ({ el: M, anchor: k }) => {
    let G;
    for (; M && M !== k; )
      G = f(M), n(M), M = G;
    n(k);
  }, T = (M, k, G, H, z, te, se, ie, oe) => {
    se = se || k.type === "svg", M == null ? y(
      k,
      G,
      H,
      z,
      te,
      se,
      ie,
      oe
    ) : C(
      M,
      k,
      z,
      te,
      se,
      ie,
      oe
    );
  }, y = (M, k, G, H, z, te, se, ie) => {
    let oe, J;
    const { type: Ae, props: _e, shapeFlag: De, transition: Ke, dirs: bt } = M;
    if (oe = M.el = o(
      M.type,
      te,
      _e && _e.is,
      _e
    ), De & 8 ? c(oe, M.children) : De & 16 && _(
      M.children,
      oe,
      null,
      H,
      z,
      te && Ae !== "foreignObject",
      se,
      ie
    ), bt && qa(M, null, H, "created"), R(oe, M, M.scopeId, se, H), _e) {
      for (const Vt in _e)
        Vt !== "value" && !ac(Vt) && a(
          oe,
          Vt,
          null,
          _e[Vt],
          te,
          M.children,
          H,
          z,
          Ne
        );
      "value" in _e && a(oe, "value", null, _e.value), (J = _e.onVnodeBeforeMount) && Fi(J, H, M);
    }
    ({}).NODE_ENV !== "production" && (Object.defineProperty(oe, "__vnode", {
      value: M,
      enumerable: !1
    }), Object.defineProperty(oe, "__vueParentComponent", {
      value: H,
      enumerable: !1
    })), bt && qa(M, null, H, "beforeMount");
    const Gt = (!z || z && !z.pendingBranch) && Ke && !Ke.persisted;
    Gt && Ke.beforeEnter(oe), i(oe, k, G), ((J = _e && _e.onVnodeMounted) || Gt || bt) && Hr(() => {
      J && Fi(J, H, M), Gt && Ke.enter(oe), bt && qa(M, null, H, "mounted");
    }, z);
  }, R = (M, k, G, H, z) => {
    if (G && d(M, G), H)
      for (let te = 0; te < H.length; te++)
        d(M, H[te]);
    if (z) {
      let te = z.subTree;
      if ({}.NODE_ENV !== "production" && te.patchFlag > 0 && te.patchFlag & 2048 && (te = $w(te.children) || te), k === te) {
        const se = z.vnode;
        R(
          M,
          se,
          se.scopeId,
          se.slotScopeIds,
          z.parent
        );
      }
    }
  }, _ = (M, k, G, H, z, te, se, ie, oe = 0) => {
    for (let J = oe; J < M.length; J++) {
      const Ae = M[J] = ie ? Fs(M[J]) : Xi(M[J]);
      g(
        null,
        Ae,
        k,
        G,
        H,
        z,
        te,
        se,
        ie
      );
    }
  }, C = (M, k, G, H, z, te, se) => {
    const ie = k.el = M.el;
    let { patchFlag: oe, dynamicChildren: J, dirs: Ae } = k;
    oe |= M.patchFlag & 16;
    const _e = M.props || _t, De = k.props || _t;
    let Ke;
    G && eu(G, !1), (Ke = De.onVnodeBeforeUpdate) && Fi(Ke, G, k, M), Ae && qa(k, M, G, "beforeUpdate"), G && eu(G, !0), {}.NODE_ENV !== "production" && cl && (oe = 0, se = !1, J = null);
    const bt = z && k.type !== "foreignObject";
    if (J ? (I(
      M.dynamicChildren,
      J,
      ie,
      G,
      H,
      bt,
      te
    ), {}.NODE_ENV !== "production" && Qp(M, k)) : se || V(
      M,
      k,
      ie,
      null,
      G,
      H,
      bt,
      te,
      !1
    ), oe > 0) {
      if (oe & 16)
        w(
          ie,
          k,
          _e,
          De,
          G,
          H,
          z
        );
      else if (oe & 2 && _e.class !== De.class && a(ie, "class", null, De.class, z), oe & 4 && a(ie, "style", _e.style, De.style, z), oe & 8) {
        const Gt = k.dynamicProps;
        for (let Vt = 0; Vt < Gt.length; Vt++) {
          const Sr = Gt[Vt], ca = _e[Sr], oh = De[Sr];
          (oh !== ca || Sr === "value") && a(
            ie,
            Sr,
            ca,
            oh,
            z,
            M.children,
            G,
            H,
            Ne
          );
        }
      }
      oe & 1 && M.children !== k.children && c(ie, k.children);
    } else
      !se && J == null && w(
        ie,
        k,
        _e,
        De,
        G,
        H,
        z
      );
    ((Ke = De.onVnodeUpdated) || Ae) && Hr(() => {
      Ke && Fi(Ke, G, k, M), Ae && qa(k, M, G, "updated");
    }, H);
  }, I = (M, k, G, H, z, te, se) => {
    for (let ie = 0; ie < k.length; ie++) {
      const oe = M[ie], J = k[ie], Ae = (
        // oldVNode may be an errored async setup() component inside Suspense
        // which will not have a mounted element
        oe.el && // - In the case of a Fragment, we need to provide the actual parent
        // of the Fragment itself so it can move its children.
        (oe.type === xr || // - In the case of different nodes, there is going to be a replacement
        // which also requires the correct parent container
        !Oa(oe, J) || // - In the case of a component, it could contain anything.
        oe.shapeFlag & 70) ? h(oe.el) : (
          // In other cases, the parent container is not actually used so we
          // just pass the block element here to avoid a DOM parentNode call.
          G
        )
      );
      g(
        oe,
        J,
        Ae,
        null,
        H,
        z,
        te,
        se,
        !0
      );
    }
  }, w = (M, k, G, H, z, te, se) => {
    if (G !== H) {
      if (G !== _t)
        for (const ie in G)
          !ac(ie) && !(ie in H) && a(
            M,
            ie,
            G[ie],
            null,
            se,
            k.children,
            z,
            te,
            Ne
          );
      for (const ie in H) {
        if (ac(ie))
          continue;
        const oe = H[ie], J = G[ie];
        oe !== J && ie !== "value" && a(
          M,
          ie,
          J,
          oe,
          se,
          k.children,
          z,
          te,
          Ne
        );
      }
      "value" in H && a(M, "value", G.value, H.value);
    }
  }, x = (M, k, G, H, z, te, se, ie, oe) => {
    const J = k.el = M ? M.el : s(""), Ae = k.anchor = M ? M.anchor : s("");
    let { patchFlag: _e, dynamicChildren: De, slotScopeIds: Ke } = k;
    ({}).NODE_ENV !== "production" && // #5523 dev root fragment may inherit directives
    (cl || _e & 2048) && (_e = 0, oe = !1, De = null), Ke && (ie = ie ? ie.concat(Ke) : Ke), M == null ? (i(J, G, H), i(Ae, G, H), _(
      k.children,
      G,
      Ae,
      z,
      te,
      se,
      ie,
      oe
    )) : _e > 0 && _e & 64 && De && // #2715 the previous fragment could've been a BAILed one as a result
    // of renderSlot() with no valid children
    M.dynamicChildren ? (I(
      M.dynamicChildren,
      De,
      G,
      z,
      te,
      se,
      ie
    ), {}.NODE_ENV !== "production" ? Qp(M, k) : (
      // #2080 if the stable fragment has a key, it's a <template v-for> that may
      //  get moved around. Make sure all root level vnodes inherit el.
      // #2134 or if it's a component root, it may also get moved around
      // as the component is being moved.
      (k.key != null || z && k === z.subTree) && Qp(
        M,
        k,
        !0
        /* shallow */
      )
    )) : V(
      M,
      k,
      G,
      Ae,
      z,
      te,
      se,
      ie,
      oe
    );
  }, P = (M, k, G, H, z, te, se, ie, oe) => {
    k.slotScopeIds = ie, M == null ? k.shapeFlag & 512 ? z.ctx.activate(
      k,
      G,
      H,
      se,
      oe
    ) : L(
      k,
      G,
      H,
      z,
      te,
      se,
      oe
    ) : D(M, k, oe);
  }, L = (M, k, G, H, z, te, se) => {
    const ie = M.component = VF(
      M,
      H,
      z
    );
    if ({}.NODE_ENV !== "production" && ie.type.__hmrId && OK(ie), {}.NODE_ENV !== "production" && (Pp(M), $o(ie, "mount")), Wf(M) && (ie.ctx.renderer = Ie), {}.NODE_ENV !== "production" && $o(ie, "init"), BF(ie), {}.NODE_ENV !== "production" && Vo(ie, "init"), ie.asyncDep) {
      if (z && z.registerDep(ie, U), !M.el) {
        const oe = ie.subTree = Yt(mr);
        O(null, oe, k, G);
      }
      return;
    }
    U(
      ie,
      M,
      k,
      G,
      z,
      te,
      se
    ), {}.NODE_ENV !== "production" && (Lp(), Vo(ie, "mount"));
  }, D = (M, k, G) => {
    const H = k.component = M.component;
    if (LK(M, k, G))
      if (H.asyncDep && !H.asyncResolved) {
        ({}).NODE_ENV !== "production" && Pp(k), Q(H, k, G), {}.NODE_ENV !== "production" && Lp();
        return;
      } else
        H.next = k, gK(H.update), H.update();
    else
      k.el = M.el, H.vnode = k;
  }, U = (M, k, G, H, z, te, se) => {
    const ie = () => {
      if (M.isMounted) {
        let { next: Ae, bu: _e, u: De, parent: Ke, vnode: bt } = M, Gt = Ae, Vt;
        ({}).NODE_ENV !== "production" && Pp(Ae || M.vnode), eu(M, !1), Ae ? (Ae.el = bt.el, Q(M, Ae, se)) : Ae = bt, _e && zs(_e), (Vt = Ae.props && Ae.props.onVnodeBeforeUpdate) && Fi(Vt, Ke, Ae, bt), eu(M, !0), {}.NODE_ENV !== "production" && $o(M, "render");
        const Sr = $m(M);
        ({}).NODE_ENV !== "production" && Vo(M, "render");
        const ca = M.subTree;
        M.subTree = Sr, {}.NODE_ENV !== "production" && $o(M, "patch"), g(
          ca,
          Sr,
          // parent may have changed if it's in a teleport
          h(ca.el),
          // anchor may have changed if it's in a fragment
          Ee(ca),
          M,
          z,
          te
        ), {}.NODE_ENV !== "production" && Vo(M, "patch"), Ae.el = Sr.el, Gt === null && Vw(M, Sr.el), De && Hr(De, z), (Vt = Ae.props && Ae.props.onVnodeUpdated) && Hr(
          () => Fi(Vt, Ke, Ae, bt),
          z
        ), {}.NODE_ENV !== "production" && z5(M), {}.NODE_ENV !== "production" && Lp();
      } else {
        let Ae;
        const { el: _e, props: De } = k, { bm: Ke, m: bt, parent: Gt } = M, Vt = lc(k);
        if (eu(M, !1), Ke && zs(Ke), !Vt && (Ae = De && De.onVnodeBeforeMount) && Fi(Ae, Gt, k), eu(M, !0), _e && xe) {
          const Sr = () => {
            ({}).NODE_ENV !== "production" && $o(M, "render"), M.subTree = $m(M), {}.NODE_ENV !== "production" && Vo(M, "render"), {}.NODE_ENV !== "production" && $o(M, "hydrate"), xe(
              _e,
              M.subTree,
              M,
              z,
              null
            ), {}.NODE_ENV !== "production" && Vo(M, "hydrate");
          };
          Vt ? k.type.__asyncLoader().then(
            // note: we are moving the render call into an async callback,
            // which means it won't track dependencies - but it's ok because
            // a server-rendered async wrapper is already in resolved state
            // and it will never need to change.
            () => !M.isUnmounted && Sr()
          ) : Sr();
        } else {
          ({}).NODE_ENV !== "production" && $o(M, "render");
          const Sr = M.subTree = $m(M);
          ({}).NODE_ENV !== "production" && Vo(M, "render"), {}.NODE_ENV !== "production" && $o(M, "patch"), g(
            null,
            Sr,
            G,
            H,
            M,
            z,
            te
          ), {}.NODE_ENV !== "production" && Vo(M, "patch"), k.el = Sr.el;
        }
        if (bt && Hr(bt, z), !Vt && (Ae = De && De.onVnodeMounted)) {
          const Sr = k;
          Hr(
            () => Fi(Ae, Gt, Sr),
            z
          );
        }
        (k.shapeFlag & 256 || Gt && lc(Gt.vnode) && Gt.vnode.shapeFlag & 256) && M.a && Hr(M.a, z), M.isMounted = !0, {}.NODE_ENV !== "production" && e_(M), k = G = H = null;
      }
    }, oe = M.effect = new pv(
      ie,
      () => gv(J),
      M.scope
      // track it in component's effect scope
    ), J = M.update = () => oe.run();
    J.id = M.uid, eu(M, !0), {}.NODE_ENV !== "production" && (oe.onTrack = M.rtc ? (Ae) => zs(M.rtc, Ae) : void 0, oe.onTrigger = M.rtg ? (Ae) => zs(M.rtg, Ae) : void 0, J.ownerInstance = M), J();
  }, Q = (M, k, G) => {
    k.component = M;
    const H = M.vnode.props;
    M.vnode = k, M.next = null, NJ(M, k.props, H, G), UJ(M, k.children, G), Fc(), uL(), Xc();
  }, V = (M, k, G, H, z, te, se, ie, oe = !1) => {
    const J = M && M.children, Ae = M ? M.shapeFlag : 0, _e = k.children, { patchFlag: De, shapeFlag: Ke } = k;
    if (De > 0) {
      if (De & 128) {
        j(
          J,
          _e,
          G,
          H,
          z,
          te,
          se,
          ie,
          oe
        );
        return;
      } else if (De & 256) {
        F(
          J,
          _e,
          G,
          H,
          z,
          te,
          se,
          ie,
          oe
        );
        return;
      }
    }
    Ke & 8 ? (Ae & 16 && Ne(J, z, te), _e !== J && c(G, _e)) : Ae & 16 ? Ke & 16 ? j(
      J,
      _e,
      G,
      H,
      z,
      te,
      se,
      ie,
      oe
    ) : Ne(J, z, te, !0) : (Ae & 8 && c(G, ""), Ke & 16 && _(
      _e,
      G,
      H,
      z,
      te,
      se,
      ie,
      oe
    ));
  }, F = (M, k, G, H, z, te, se, ie, oe) => {
    M = M || tf, k = k || tf;
    const J = M.length, Ae = k.length, _e = Math.min(J, Ae);
    let De;
    for (De = 0; De < _e; De++) {
      const Ke = k[De] = oe ? Fs(k[De]) : Xi(k[De]);
      g(
        M[De],
        Ke,
        G,
        null,
        z,
        te,
        se,
        ie,
        oe
      );
    }
    J > Ae ? Ne(
      M,
      z,
      te,
      !0,
      !1,
      _e
    ) : _(
      k,
      G,
      H,
      z,
      te,
      se,
      ie,
      oe,
      _e
    );
  }, j = (M, k, G, H, z, te, se, ie, oe) => {
    let J = 0;
    const Ae = k.length;
    let _e = M.length - 1, De = Ae - 1;
    for (; J <= _e && J <= De; ) {
      const Ke = M[J], bt = k[J] = oe ? Fs(k[J]) : Xi(k[J]);
      if (Oa(Ke, bt))
        g(
          Ke,
          bt,
          G,
          null,
          z,
          te,
          se,
          ie,
          oe
        );
      else
        break;
      J++;
    }
    for (; J <= _e && J <= De; ) {
      const Ke = M[_e], bt = k[De] = oe ? Fs(k[De]) : Xi(k[De]);
      if (Oa(Ke, bt))
        g(
          Ke,
          bt,
          G,
          null,
          z,
          te,
          se,
          ie,
          oe
        );
      else
        break;
      _e--, De--;
    }
    if (J > _e) {
      if (J <= De) {
        const Ke = De + 1, bt = Ke < Ae ? k[Ke].el : H;
        for (; J <= De; )
          g(
            null,
            k[J] = oe ? Fs(k[J]) : Xi(k[J]),
            G,
            bt,
            z,
            te,
            se,
            ie,
            oe
          ), J++;
      }
    } else if (J > De)
      for (; J <= _e; )
        ce(M[J], z, te, !0), J++;
    else {
      const Ke = J, bt = J, Gt = /* @__PURE__ */ new Map();
      for (J = bt; J <= De; J++) {
        const Ti = k[J] = oe ? Fs(k[J]) : Xi(k[J]);
        Ti.key != null && ({}.NODE_ENV !== "production" && Gt.has(Ti.key) && W(
          "Duplicate keys found during update:",
          JSON.stringify(Ti.key),
          "Make sure keys are unique."
        ), Gt.set(Ti.key, J));
      }
      let Vt, Sr = 0;
      const ca = De - bt + 1;
      let oh = !1, qP = 0;
      const Ed = new Array(ca);
      for (J = 0; J < ca; J++)
        Ed[J] = 0;
      for (J = Ke; J <= _e; J++) {
        const Ti = M[J];
        if (Sr >= ca) {
          ce(Ti, z, te, !0);
          continue;
        }
        let ka;
        if (Ti.key != null)
          ka = Gt.get(Ti.key);
        else
          for (Vt = bt; Vt <= De; Vt++)
            if (Ed[Vt - bt] === 0 && Oa(Ti, k[Vt])) {
              ka = Vt;
              break;
            }
        ka === void 0 ? ce(Ti, z, te, !0) : (Ed[ka - bt] = J + 1, ka >= qP ? qP = ka : oh = !0, g(
          Ti,
          k[ka],
          G,
          null,
          z,
          te,
          se,
          ie,
          oe
        ), Sr++);
      }
      const jP = oh ? GJ(Ed) : tf;
      for (Vt = jP.length - 1, J = ca - 1; J >= 0; J--) {
        const Ti = bt + J, ka = k[Ti], KP = Ti + 1 < Ae ? k[Ti + 1].el : H;
        Ed[J] === 0 ? g(
          null,
          ka,
          G,
          KP,
          z,
          te,
          se,
          ie,
          oe
        ) : oh && (Vt < 0 || J !== jP[Vt] ? ae(ka, G, KP, 2) : Vt--);
      }
    }
  }, ae = (M, k, G, H, z = null) => {
    const { el: te, type: se, transition: ie, children: oe, shapeFlag: J } = M;
    if (J & 6) {
      ae(M.component.subTree, k, G, H);
      return;
    }
    if (J & 128) {
      M.suspense.move(k, G, H);
      return;
    }
    if (J & 64) {
      se.move(M, k, G, Ie);
      return;
    }
    if (se === xr) {
      i(te, k, G);
      for (let _e = 0; _e < oe.length; _e++)
        ae(oe[_e], k, G, H);
      i(M.anchor, k, G);
      return;
    }
    if (se === hl) {
      b(M, k, G);
      return;
    }
    if (H !== 2 && J & 1 && ie)
      if (H === 0)
        ie.beforeEnter(te), i(te, k, G), Hr(() => ie.enter(te), z);
      else {
        const { leave: _e, delayLeave: De, afterLeave: Ke } = ie, bt = () => i(te, k, G), Gt = () => {
          _e(te, () => {
            bt(), Ke && Ke();
          });
        };
        De ? De(te, bt, Gt) : Gt();
      }
    else
      i(te, k, G);
  }, ce = (M, k, G, H = !1, z = !1) => {
    const {
      type: te,
      props: se,
      ref: ie,
      children: oe,
      dynamicChildren: J,
      shapeFlag: Ae,
      patchFlag: _e,
      dirs: De
    } = M;
    if (ie != null && LE(ie, null, G, M, !0), Ae & 256) {
      k.ctx.deactivate(M);
      return;
    }
    const Ke = Ae & 1 && De, bt = !lc(M);
    let Gt;
    if (bt && (Gt = se && se.onVnodeBeforeUnmount) && Fi(Gt, k, M), Ae & 6)
      We(M.component, G, H);
    else {
      if (Ae & 128) {
        M.suspense.unmount(G, H);
        return;
      }
      Ke && qa(M, null, k, "beforeUnmount"), Ae & 64 ? M.type.remove(
        M,
        k,
        G,
        z,
        Ie,
        H
      ) : J && // #1153: fast path should not be taken for non-stable (v-for) fragments
      (te !== xr || _e > 0 && _e & 64) ? Ne(
        J,
        k,
        G,
        !1,
        !0
      ) : (te === xr && _e & 384 || !z && Ae & 16) && Ne(oe, k, G), H && ge(M);
    }
    (bt && (Gt = se && se.onVnodeUnmounted) || Ke) && Hr(() => {
      Gt && Fi(Gt, k, M), Ke && qa(M, null, k, "unmounted");
    }, G);
  }, ge = (M) => {
    const { type: k, el: G, anchor: H, transition: z } = M;
    if (k === xr) {
      ({}).NODE_ENV !== "production" && M.patchFlag > 0 && M.patchFlag & 2048 && z && !z.persisted ? M.children.forEach((se) => {
        se.type === mr ? n(se.el) : ge(se);
      }) : Be(G, H);
      return;
    }
    if (k === hl) {
      S(M);
      return;
    }
    const te = () => {
      n(G), z && !z.persisted && z.afterLeave && z.afterLeave();
    };
    if (M.shapeFlag & 1 && z && !z.persisted) {
      const { leave: se, delayLeave: ie } = z, oe = () => se(G, te);
      ie ? ie(M.el, te, oe) : oe();
    } else
      te();
  }, Be = (M, k) => {
    let G;
    for (; M !== k; )
      G = f(M), n(M), M = G;
    n(k);
  }, We = (M, k, G) => {
    ({}).NODE_ENV !== "production" && M.type.__hmrId && mK(M);
    const { bum: H, scope: z, update: te, subTree: se, um: ie } = M;
    H && zs(H), z.stop(), te && (te.active = !1, ce(se, M, k, G)), ie && Hr(ie, k), Hr(() => {
      M.isUnmounted = !0;
    }, k), k && k.pendingBranch && !k.isUnmounted && M.asyncDep && !M.asyncResolved && M.suspenseId === k.pendingId && (k.deps--, k.deps === 0 && k.resolve()), {}.NODE_ENV !== "production" && RK(M);
  }, Ne = (M, k, G, H = !1, z = !1, te = 0) => {
    for (let se = te; se < M.length; se++)
      ce(M[se], k, G, H, z);
  }, Ee = (M) => M.shapeFlag & 6 ? Ee(M.component.subTree) : M.shapeFlag & 128 ? M.suspense.next() : f(M.anchor || M.el), Ge = (M, k, G) => {
    M == null ? k._vnode && ce(k._vnode, null, null, !0) : g(k._vnode || null, M, k, null, null, null, G), uL(), wE(), k._vnode = M;
  }, Ie = {
    p: g,
    um: ce,
    m: ae,
    r: ge,
    mt: L,
    mc: _,
    pc: V,
    pbc: I,
    n: Ee,
    o: r
  };
  let he, xe;
  return e && ([he, xe] = e(
    Ie
  )), {
    render: Ge,
    hydrate: he,
    createApp: _J(Ge, he)
  };
}
function eu({ effect: r, update: e }, t) {
  r.allowRecurse = e.allowRecurse = t;
}
function Qp(r, e, t = !1) {
  const i = r.children, n = e.children;
  if (pe(i) && pe(n))
    for (let a = 0; a < i.length; a++) {
      const o = i[a];
      let s = n[a];
      s.shapeFlag & 1 && !s.dynamicChildren && ((s.patchFlag <= 0 || s.patchFlag === 32) && (s = n[a] = Fs(n[a]), s.el = o.el), t || Qp(o, s)), s.type === Rl && (s.el = o.el), {}.NODE_ENV !== "production" && s.type === mr && !s.el && (s.el = o.el);
    }
}
function GJ(r) {
  const e = r.slice(), t = [0];
  let i, n, a, o, s;
  const l = r.length;
  for (i = 0; i < l; i++) {
    const u = r[i];
    if (u !== 0) {
      if (n = t[t.length - 1], r[n] < u) {
        e[i] = n, t.push(i);
        continue;
      }
      for (a = 0, o = t.length - 1; a < o; )
        s = a + o >> 1, r[t[s]] < u ? a = s + 1 : o = s;
      u < r[t[a]] && (a > 0 && (e[i] = t[a - 1]), t[a] = i);
    }
  }
  for (a = t.length, o = t[a - 1]; a-- > 0; )
    t[a] = o, o = e[o];
  return t;
}
const BJ = (r) => r.__isTeleport, af = (r) => r && (r.disabled || r.disabled === ""), AL = (r) => typeof SVGElement < "u" && r instanceof SVGElement, s_ = (r, e) => {
  const t = r && r.to;
  if (qe(t))
    if (e) {
      const i = e(t);
      return i || {}.NODE_ENV !== "production" && W(
        `Failed to locate Teleport target with selector "${t}". Note the target element must exist before the component is mounted - i.e. the target cannot be rendered by the component itself, and ideally should be outside of the entire Vue component tree.`
      ), i;
    } else
      return {}.NODE_ENV !== "production" && W(
        "Current renderer does not support string target for Teleports. (missing querySelector renderer option)"
      ), null;
  else
    return {}.NODE_ENV !== "production" && !t && !af(r) && W(`Invalid Teleport target: ${t}`), t;
}, FJ = {
  __isTeleport: !0,
  process(r, e, t, i, n, a, o, s, l, u) {
    const {
      mc: c,
      pc: h,
      pbc: f,
      o: { insert: d, querySelector: p, createText: g, createComment: v }
    } = u, O = af(e.props);
    let { shapeFlag: m, children: E, dynamicChildren: b } = e;
    if ({}.NODE_ENV !== "production" && cl && (l = !1, b = null), r == null) {
      const S = e.el = {}.NODE_ENV !== "production" ? v("teleport start") : g(""), T = e.anchor = {}.NODE_ENV !== "production" ? v("teleport end") : g("");
      d(S, t, i), d(T, t, i);
      const y = e.target = s_(e.props, p), R = e.targetAnchor = g("");
      y ? (d(R, y), o = o || AL(y)) : {}.NODE_ENV !== "production" && !O && W("Invalid Teleport target on mount:", y, `(${typeof y})`);
      const _ = (C, I) => {
        m & 16 && c(
          E,
          C,
          I,
          n,
          a,
          o,
          s,
          l
        );
      };
      O ? _(t, T) : y && _(y, R);
    } else {
      e.el = r.el;
      const S = e.anchor = r.anchor, T = e.target = r.target, y = e.targetAnchor = r.targetAnchor, R = af(r.props), _ = R ? t : T, C = R ? S : y;
      if (o = o || AL(T), b ? (f(
        r.dynamicChildren,
        b,
        _,
        n,
        a,
        o,
        s
      ), Qp(r, e, !0)) : l || h(
        r,
        e,
        _,
        C,
        n,
        a,
        o,
        s,
        !1
      ), O)
        R || lO(
          e,
          t,
          S,
          u,
          1
        );
      else if ((e.props && e.props.to) !== (r.props && r.props.to)) {
        const I = e.target = s_(
          e.props,
          p
        );
        I ? lO(
          e,
          I,
          null,
          u,
          0
        ) : {}.NODE_ENV !== "production" && W(
          "Invalid Teleport target on update:",
          T,
          `(${typeof T})`
        );
      } else
        R && lO(
          e,
          T,
          y,
          u,
          1
        );
    }
    PF(e);
  },
  remove(r, e, t, i, { um: n, o: { remove: a } }, o) {
    const { shapeFlag: s, children: l, anchor: u, targetAnchor: c, target: h, props: f } = r;
    if (h && a(c), (o || !af(f)) && (a(u), s & 16))
      for (let d = 0; d < l.length; d++) {
        const p = l[d];
        n(
          p,
          e,
          t,
          !0,
          !!p.dynamicChildren
        );
      }
  },
  move: lO,
  hydrate: XJ
};
function lO(r, e, t, { o: { insert: i }, m: n }, a = 2) {
  a === 0 && i(r.targetAnchor, e, t);
  const { el: o, anchor: s, shapeFlag: l, children: u, props: c } = r, h = a === 2;
  if (h && i(o, e, t), (!h || af(c)) && l & 16)
    for (let f = 0; f < u.length; f++)
      n(
        u[f],
        e,
        t,
        2
      );
  h && i(s, e, t);
}
function XJ(r, e, t, i, n, a, {
  o: { nextSibling: o, parentNode: s, querySelector: l }
}, u) {
  const c = e.target = s_(
    e.props,
    l
  );
  if (c) {
    const h = c._lpa || c.firstChild;
    if (e.shapeFlag & 16)
      if (af(e.props))
        e.anchor = u(
          o(r),
          e,
          s(r),
          t,
          i,
          n,
          a
        ), e.targetAnchor = h;
      else {
        e.anchor = o(r);
        let f = h;
        for (; f; )
          if (f = o(f), f && f.nodeType === 8 && f.data === "teleport anchor") {
            e.targetAnchor = f, c._lpa = e.targetAnchor && o(e.targetAnchor);
            break;
          }
        u(
          h,
          e,
          c,
          t,
          i,
          n,
          a
        );
      }
    PF(e);
  }
  return e.anchor && o(e.anchor);
}
const YJ = FJ;
function PF(r) {
  const e = r.ctx;
  if (e && e.ut) {
    let t = r.children[0].el;
    for (; t !== r.targetAnchor; )
      t.nodeType === 1 && t.setAttribute("data-v-owner", e.uid), t = t.nextSibling;
    e.ut();
  }
}
const xr = Symbol.for("v-fgt"), Rl = Symbol.for("v-txt"), mr = Symbol.for("v-cmt"), hl = Symbol.for("v-stc"), Up = [];
let qi = null;
function xt(r = !1) {
  Up.push(qi = r ? null : []);
}
function LF() {
  Up.pop(), qi = Up[Up.length - 1] || null;
}
let Rc = 1;
function l_(r) {
  Rc += r;
}
function DF(r) {
  return r.dynamicChildren = Rc > 0 ? qi || tf : null, LF(), Rc > 0 && qi && qi.push(r), r;
}
function Pr(r, e, t, i, n, a) {
  return DF(
    er(
      r,
      e,
      t,
      i,
      n,
      a,
      !0
      /* isBlock */
    )
  );
}
function va(r, e, t, i, n) {
  return DF(
    Yt(
      r,
      e,
      t,
      i,
      n,
      !0
      /* isBlock: prevent a block from tracking itself */
    )
  );
}
function as(r) {
  return r ? r.__v_isVNode === !0 : !1;
}
function Oa(r, e) {
  return {}.NODE_ENV !== "production" && e.shapeFlag & 6 && Mh.has(e.type) ? (r.shapeFlag &= -257, e.shapeFlag &= -513, !1) : r.type === e.type && r.key === e.key;
}
let u_;
function HJ(r) {
  u_ = r;
}
const WJ = (...r) => kF(
  ...u_ ? u_(r, gr) : r
), zS = "__vInternal", MF = ({ key: r }) => r ?? null, Vm = ({
  ref: r,
  ref_key: e,
  ref_for: t
}) => (typeof r == "number" && (r = "" + r), r != null ? qe(r) || sr(r) || Ue(r) ? { i: gr, r, k: e, f: !!t } : r : null);
function er(r, e = null, t = null, i = 0, n = null, a = r === xr ? 0 : 1, o = !1, s = !1) {
  const l = {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r,
    props: e,
    key: e && MF(e),
    ref: e && Vm(e),
    scopeId: BS,
    slotScopeIds: null,
    children: t,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag: a,
    patchFlag: i,
    dynamicProps: n,
    dynamicChildren: null,
    appContext: null,
    ctx: gr
  };
  return s ? (Zw(l, t), a & 128 && r.normalize(l)) : t && (l.shapeFlag |= qe(t) ? 8 : 16), {}.NODE_ENV !== "production" && l.key !== l.key && W("VNode created with invalid key (NaN). VNode type:", l.type), Rc > 0 && // avoid a block node from tracking itself
  !o && // has current parent block
  qi && // presence of a patch flag indicates this node needs patching on updates.
  // component nodes also should always be patched, because even if the
  // component doesn't need to update, it needs to persist the instance on to
  // the next vnode so that it can be properly unmounted later.
  (l.patchFlag > 0 || a & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
  // vnode should not be considered dynamic due to handler caching.
  l.patchFlag !== 32 && qi.push(l), l;
}
const Yt = {}.NODE_ENV !== "production" ? WJ : kF;
function kF(r, e = null, t = null, i = 0, n = null, a = !1) {
  if ((!r || r === vF) && ({}.NODE_ENV !== "production" && !r && W(`Invalid vnode type when creating vnode: ${r}.`), r = mr), as(r)) {
    const s = ia(
      r,
      e,
      !0
      /* mergeRef: true */
    );
    return t && Zw(s, t), Rc > 0 && !a && qi && (s.shapeFlag & 6 ? qi[qi.indexOf(r)] = s : qi.push(s)), s.patchFlag |= -2, s;
  }
  if (HF(r) && (r = r.__vccOpts), e) {
    e = QF(e);
    let { class: s, style: l } = e;
    s && !qe(s) && (e.class = Hf(s)), Tt(l) && (hg(l) && !pe(l) && (l = ut({}, l)), e.style = Na(l));
  }
  const o = qe(r) ? 1 : J5(r) ? 128 : BJ(r) ? 64 : Tt(r) ? 4 : Ue(r) ? 2 : 0;
  return {}.NODE_ENV !== "production" && o & 4 && hg(r) && (r = je(r), W(
    "Vue received a Component which was made a reactive object. This can lead to unnecessary performance overhead, and should be avoided by marking the component with `markRaw` or using `shallowRef` instead of `ref`.",
    `
Component that was made reactive: `,
    r
  )), er(
    r,
    e,
    t,
    i,
    n,
    o,
    a,
    !0
  );
}
function QF(r) {
  return r ? hg(r) || zS in r ? ut({}, r) : r : null;
}
function ia(r, e, t = !1) {
  const { props: i, ref: n, patchFlag: a, children: o } = r, s = e ? $F(i || {}, e) : i;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: r.type,
    props: s,
    key: s && MF(s),
    ref: e && e.ref ? (
      // #2078 in the case of <component :is="vnode" ref="extra"/>
      // if the vnode itself already has a ref, cloneVNode will need to merge
      // the refs so the single vnode can be set on multiple refs
      t && n ? pe(n) ? n.concat(Vm(e)) : [n, Vm(e)] : Vm(e)
    ) : n,
    scopeId: r.scopeId,
    slotScopeIds: r.slotScopeIds,
    children: {}.NODE_ENV !== "production" && a === -1 && pe(o) ? o.map(UF) : o,
    target: r.target,
    targetAnchor: r.targetAnchor,
    staticCount: r.staticCount,
    shapeFlag: r.shapeFlag,
    // if the vnode is cloned with extra props, we can no longer assume its
    // existing patch flag to be reliable and need to add the FULL_PROPS flag.
    // note: preserve flag for fragments since they use the flag for children
    // fast paths only.
    patchFlag: e && r.type !== xr ? a === -1 ? 16 : a | 16 : a,
    dynamicProps: r.dynamicProps,
    dynamicChildren: r.dynamicChildren,
    appContext: r.appContext,
    dirs: r.dirs,
    transition: r.transition,
    // These should technically only be non-null on mounted VNodes. However,
    // they *should* be copied for kept-alive vnodes. So we just always copy
    // them since them being non-null during a mount doesn't affect the logic as
    // they will simply be overwritten.
    component: r.component,
    suspense: r.suspense,
    ssContent: r.ssContent && ia(r.ssContent),
    ssFallback: r.ssFallback && ia(r.ssFallback),
    el: r.el,
    anchor: r.anchor,
    ctx: r.ctx,
    ce: r.ce
  };
}
function UF(r) {
  const e = ia(r);
  return pe(r.children) && (e.children = r.children.map(UF)), e;
}
function zw(r = " ", e = 0) {
  return Yt(Rl, null, r, e);
}
function zJ(r, e) {
  const t = Yt(hl, null, r);
  return t.staticCount = e, t;
}
function Fn(r = "", e = !1) {
  return e ? (xt(), va(mr, null, r)) : Yt(mr, null, r);
}
function Xi(r) {
  return r == null || typeof r == "boolean" ? Yt(mr) : pe(r) ? Yt(
    xr,
    null,
    // #3666, avoid reference pollution when reusing vnode
    r.slice()
  ) : typeof r == "object" ? Fs(r) : Yt(Rl, null, String(r));
}
function Fs(r) {
  return r.el === null && r.patchFlag !== -1 || r.memo ? r : ia(r);
}
function Zw(r, e) {
  let t = 0;
  const { shapeFlag: i } = r;
  if (e == null)
    e = null;
  else if (pe(e))
    t = 16;
  else if (typeof e == "object")
    if (i & 65) {
      const n = e.default;
      n && (n._c && (n._d = !1), Zw(r, n()), n._c && (n._d = !0));
      return;
    } else {
      t = 32;
      const n = e._;
      !n && !(zS in e) ? e._ctx = gr : n === 3 && gr && (gr.slots._ === 1 ? e._ = 1 : (e._ = 2, r.patchFlag |= 1024));
    }
  else
    Ue(e) ? (e = { default: e, _ctx: gr }, t = 32) : (e = String(e), i & 64 ? (t = 16, e = [zw(e)]) : t = 8);
  r.children = e, r.shapeFlag |= t;
}
function $F(...r) {
  const e = {};
  for (let t = 0; t < r.length; t++) {
    const i = r[t];
    for (const n in i)
      if (n === "class")
        e.class !== i.class && (e.class = Hf([e.class, i.class]));
      else if (n === "style")
        e.style = Na([e.style, i.style]);
      else if (is(n)) {
        const a = e[n], o = i[n];
        o && a !== o && !(pe(a) && a.includes(o)) && (e[n] = a ? [].concat(a, o) : o);
      } else
        n !== "" && (e[n] = i[n]);
  }
  return e;
}
function Fi(r, e, t, i = null) {
  En(r, e, 7, [
    t,
    i
  ]);
}
const ZJ = SF();
let qJ = 0;
function VF(r, e, t) {
  const i = r.type, n = (e ? e.appContext : r.appContext) || ZJ, a = {
    uid: qJ++,
    vnode: r,
    type: i,
    parent: e,
    appContext: n,
    root: null,
    // to be immediately set
    next: null,
    subTree: null,
    // will be set synchronously right after creation
    effect: null,
    update: null,
    // will be set synchronously right after creation
    scope: new _w(
      !0
      /* detached */
    ),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: e ? e.provides : Object.create(n.provides),
    accessCache: null,
    renderCache: [],
    // local resolved assets
    components: null,
    directives: null,
    // resolved props and emits options
    propsOptions: RF(i, n),
    emitsOptions: q5(i, n),
    // emit
    emit: null,
    // to be set immediately
    emitted: null,
    // props default value
    propsDefaults: _t,
    // inheritAttrs
    inheritAttrs: i.inheritAttrs,
    // state
    ctx: _t,
    data: _t,
    props: _t,
    attrs: _t,
    slots: _t,
    refs: _t,
    setupState: _t,
    setupContext: null,
    attrsProxy: null,
    slotsProxy: null,
    // suspense related
    suspense: t,
    suspenseId: t ? t.pendingId : 0,
    asyncDep: null,
    asyncResolved: !1,
    // lifecycle hooks
    // not using enums here because it results in computed properties
    isMounted: !1,
    isUnmounted: !1,
    isDeactivated: !1,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  return {}.NODE_ENV !== "production" ? a.ctx = rJ(a) : a.ctx = { _: a }, a.root = e ? e.root : a, a.emit = IK.bind(null, a), r.ce && r.ce(a), a;
}
let pr = null;
const ms = () => pr || gr;
let qw, sh, _L = "__VUE_INSTANCE_SETTERS__";
(sh = _E()[_L]) || (sh = _E()[_L] = []), sh.push((r) => pr = r), qw = (r) => {
  sh.length > 1 ? sh.forEach((e) => e(r)) : sh[0](r);
};
const Al = (r) => {
  qw(r), r.scope.on();
}, fl = () => {
  pr && pr.scope.off(), qw(null);
}, jJ = /* @__PURE__ */ bi("slot,component");
function c_(r, e) {
  const t = e.isNativeTag || xp;
  (jJ(r) || t(r)) && W(
    "Do not use built-in or reserved HTML elements as component id: " + r
  );
}
function GF(r) {
  return r.vnode.shapeFlag & 4;
}
let Sf = !1;
function BF(r, e = !1) {
  Sf = e;
  const { props: t, children: i } = r.vnode, n = GF(r);
  IJ(r, t, n, e), QJ(r, i);
  const a = n ? KJ(r, e) : void 0;
  return Sf = !1, a;
}
function KJ(r, e) {
  var t;
  const i = r.type;
  if ({}.NODE_ENV !== "production") {
    if (i.name && c_(i.name, r.appContext.config), i.components) {
      const a = Object.keys(i.components);
      for (let o = 0; o < a.length; o++)
        c_(a[o], r.appContext.config);
    }
    if (i.directives) {
      const a = Object.keys(i.directives);
      for (let o = 0; o < a.length; o++)
        iF(a[o]);
    }
    i.compilerOptions && jw() && W(
      '"compilerOptions" is only supported when using a build of Vue that includes the runtime compiler. Since you are using a runtime-only build, the options should be passed via your build tool config instead.'
    );
  }
  r.accessCache = /* @__PURE__ */ Object.create(null), r.proxy = ww(new Proxy(r.ctx, Mp)), {}.NODE_ENV !== "production" && iJ(r);
  const { setup: n } = i;
  if (n) {
    const a = r.setupContext = n.length > 1 ? YF(r) : null;
    Al(r), Fc();
    const o = go(
      n,
      r,
      0,
      [{}.NODE_ENV !== "production" ? Yh(r.props) : r.props, a]
    );
    if (Xc(), fl(), xS(o)) {
      if (o.then(fl, fl), e)
        return o.then((s) => {
          h_(r, s, e);
        }).catch((s) => {
          Yc(s, r, 0);
        });
      if (r.asyncDep = o, {}.NODE_ENV !== "production" && !r.suspense) {
        const s = (t = i.name) != null ? t : "Anonymous";
        W(
          `Component <${s}>: setup function returned a promise, but no <Suspense> boundary was found in the parent component tree. A component with async setup() must be nested in a <Suspense> in order to be rendered.`
        );
      }
    } else
      h_(r, o, e);
  } else
    XF(r, e);
}
function h_(r, e, t) {
  Ue(e) ? r.type.__ssrInlineRender ? r.ssrRender = e : r.render = e : Tt(e) ? ({}.NODE_ENV !== "production" && as(e) && W(
    "setup() should not return VNodes directly - return a render function instead."
  ), {}.NODE_ENV !== "production" && (r.devtoolsRawSetupState = e), r.setupState = Pw(e), {}.NODE_ENV !== "production" && nJ(r)) : {}.NODE_ENV !== "production" && e !== void 0 && W(
    `setup() should return an object. Received: ${e === null ? "null" : typeof e}`
  ), XF(r, t);
}
let $p, f_;
function FF(r) {
  $p = r, f_ = (e) => {
    e.render._rc && (e.withProxy = new Proxy(e.ctx, tJ));
  };
}
const jw = () => !$p;
function XF(r, e, t) {
  const i = r.type;
  if (!r.render) {
    if (!e && $p && !i.render) {
      const n = i.template || Hw(r).template;
      if (n) {
        ({}).NODE_ENV !== "production" && $o(r, "compile");
        const { isCustomElement: a, compilerOptions: o } = r.appContext.config, { delimiters: s, compilerOptions: l } = i, u = ut(
          ut(
            {
              isCustomElement: a,
              delimiters: s
            },
            o
          ),
          l
        );
        i.render = $p(n, u), {}.NODE_ENV !== "production" && Vo(r, "compile");
      }
    }
    r.render = i.render || dr, f_ && f_(r);
  }
  Al(r), Fc(), bJ(r), Xc(), fl(), {}.NODE_ENV !== "production" && !i.render && r.render === dr && !e && (!$p && i.template ? W(
    'Component provided template option but runtime compilation is not supported in this build of Vue. Configure your bundler to alias "vue" to "vue/dist/vue.esm-bundler.js".'
    /* should not happen */
  ) : W("Component is missing template or render function."));
}
function CL(r) {
  return r.attrsProxy || (r.attrsProxy = new Proxy(
    r.attrs,
    {}.NODE_ENV !== "production" ? {
      get(e, t) {
        return NE(), ei(r, "get", "$attrs"), e[t];
      },
      set() {
        return W("setupContext.attrs is readonly."), !1;
      },
      deleteProperty() {
        return W("setupContext.attrs is readonly."), !1;
      }
    } : {
      get(e, t) {
        return ei(r, "get", "$attrs"), e[t];
      }
    }
  ));
}
function JJ(r) {
  return r.slotsProxy || (r.slotsProxy = new Proxy(r.slots, {
    get(e, t) {
      return ei(r, "get", "$slots"), e[t];
    }
  }));
}
function YF(r) {
  const e = (t) => {
    if ({}.NODE_ENV !== "production" && (r.exposed && W("expose() should be called only once per setup()."), t != null)) {
      let i = typeof t;
      i === "object" && (pe(t) ? i = "array" : sr(t) && (i = "ref")), i !== "object" && W(
        `expose() should be passed a plain object, received ${i}.`
      );
    }
    r.exposed = t || {};
  };
  return {}.NODE_ENV !== "production" ? Object.freeze({
    get attrs() {
      return CL(r);
    },
    get slots() {
      return JJ(r);
    },
    get emit() {
      return (t, ...i) => r.emit(t, ...i);
    },
    expose: e
  }) : {
    get attrs() {
      return CL(r);
    },
    slots: r.slots,
    emit: r.emit,
    expose: e
  };
}
function ZS(r) {
  if (r.exposed)
    return r.exposeProxy || (r.exposeProxy = new Proxy(Pw(ww(r.exposed)), {
      get(e, t) {
        if (t in e)
          return e[t];
        if (t in uc)
          return uc[t](r);
      },
      has(e, t) {
        return t in e || t in uc;
      }
    }));
}
const eee = /(?:^|[-_])(\w)/g, tee = (r) => r.replace(eee, (e) => e.toUpperCase()).replace(/[-_]/g, "");
function bg(r, e = !0) {
  return Ue(r) ? r.displayName || r.name : r.name || e && r.__name;
}
function qS(r, e, t = !1) {
  let i = bg(e);
  if (!i && e.__file) {
    const n = e.__file.match(/([^/\\]+)\.\w+$/);
    n && (i = n[1]);
  }
  if (!i && r && r.parent) {
    const n = (a) => {
      for (const o in a)
        if (a[o] === e)
          return o;
    };
    i = n(
      r.components || r.parent.type.components
    ) || n(r.appContext.components);
  }
  return i ? tee(i) : t ? "App" : "Anonymous";
}
function HF(r) {
  return Ue(r) && "__vccOpts" in r;
}
const WF = (r, e) => sK(r, e, Sf);
function Wl(r, e, t) {
  const i = arguments.length;
  return i === 2 ? Tt(e) && !pe(e) ? as(e) ? Yt(r, null, [e]) : Yt(r, e) : Yt(r, null, e) : (i > 3 ? t = Array.prototype.slice.call(arguments, 2) : i === 3 && as(t) && (t = [t]), Yt(r, e, t));
}
const zF = Symbol.for("v-scx"), ZF = () => {
  {
    const r = kp(zF);
    return r || {}.NODE_ENV !== "production" && W(
      "Server rendering context not provided. Make sure to only call useSSRContext() conditionally in the server build."
    ), r;
  }
};
function _y(r) {
  return !!(r && r.__v_isShallow);
}
function qF() {
  if ({}.NODE_ENV === "production" || typeof window > "u")
    return;
  const r = { style: "color:#3ba776" }, e = { style: "color:#0b1bc9" }, t = { style: "color:#b62e24" }, i = { style: "color:#9d288c" }, n = {
    header(h) {
      return Tt(h) ? h.__isVue ? ["div", r, "VueInstance"] : sr(h) ? [
        "div",
        {},
        ["span", r, c(h)],
        "<",
        s(h.value),
        ">"
      ] : ul(h) ? [
        "div",
        {},
        ["span", r, _y(h) ? "ShallowReactive" : "Reactive"],
        "<",
        s(h),
        `>${ns(h) ? " (readonly)" : ""}`
      ] : ns(h) ? [
        "div",
        {},
        ["span", r, _y(h) ? "ShallowReadonly" : "Readonly"],
        "<",
        s(h),
        ">"
      ] : null : null;
    },
    hasBody(h) {
      return h && h.__isVue;
    },
    body(h) {
      if (h && h.__isVue)
        return [
          "div",
          {},
          ...a(h.$)
        ];
    }
  };
  function a(h) {
    const f = [];
    h.type.props && h.props && f.push(o("props", je(h.props))), h.setupState !== _t && f.push(o("setup", h.setupState)), h.data !== _t && f.push(o("data", je(h.data)));
    const d = l(h, "computed");
    d && f.push(o("computed", d));
    const p = l(h, "inject");
    return p && f.push(o("injected", p)), f.push([
      "div",
      {},
      [
        "span",
        {
          style: i.style + ";opacity:0.66"
        },
        "$ (internal): "
      ],
      ["object", { object: h }]
    ]), f;
  }
  function o(h, f) {
    return f = ut({}, f), Object.keys(f).length ? [
      "div",
      { style: "line-height:1.25em;margin-bottom:0.6em" },
      [
        "div",
        {
          style: "color:#476582"
        },
        h
      ],
      [
        "div",
        {
          style: "padding-left:1.25em"
        },
        ...Object.keys(f).map((d) => [
          "div",
          {},
          ["span", i, d + ": "],
          s(f[d], !1)
        ])
      ]
    ] : ["span", {}];
  }
  function s(h, f = !0) {
    return typeof h == "number" ? ["span", e, h] : typeof h == "string" ? ["span", t, JSON.stringify(h)] : typeof h == "boolean" ? ["span", i, h] : Tt(h) ? ["object", { object: f ? je(h) : h }] : ["span", t, String(h)];
  }
  function l(h, f) {
    const d = h.type;
    if (Ue(d))
      return;
    const p = {};
    for (const g in h.ctx)
      u(d, g, f) && (p[g] = h.ctx[g]);
    return p;
  }
  function u(h, f, d) {
    const p = h[d];
    if (pe(p) && p.includes(f) || Tt(p) && f in p || h.extends && u(h.extends, f, d) || h.mixins && h.mixins.some((g) => u(g, f, d)))
      return !0;
  }
  function c(h) {
    return _y(h) ? "ShallowRef" : h.effect ? "ComputedRef" : "Ref";
  }
  window.devtoolsFormatters ? window.devtoolsFormatters.push(n) : window.devtoolsFormatters = [n];
}
function ree(r, e, t, i) {
  const n = t[i];
  if (n && jF(n, r))
    return n;
  const a = e();
  return a.memo = r.slice(), t[i] = a;
}
function jF(r, e) {
  const t = r.memo;
  if (t.length != e.length)
    return !1;
  for (let i = 0; i < t.length; i++)
    if (mf(t[i], e[i]))
      return !1;
  return Rc > 0 && qi && qi.push(r), !0;
}
const d_ = "3.3.4", iee = {
  createComponentInstance: VF,
  setupComponent: BF,
  renderComponentRoot: $m,
  setCurrentRenderingInstance: gg,
  isVNode: as,
  normalizeVNode: Xi
}, nee = iee, aee = null, oee = null, see = "http://www.w3.org/2000/svg", ku = typeof document < "u" ? document : null, IL = ku && /* @__PURE__ */ ku.createElement("template"), lee = {
  insert: (r, e, t) => {
    e.insertBefore(r, t || null);
  },
  remove: (r) => {
    const e = r.parentNode;
    e && e.removeChild(r);
  },
  createElement: (r, e, t, i) => {
    const n = e ? ku.createElementNS(see, r) : ku.createElement(r, t ? { is: t } : void 0);
    return r === "select" && i && i.multiple != null && n.setAttribute("multiple", i.multiple), n;
  },
  createText: (r) => ku.createTextNode(r),
  createComment: (r) => ku.createComment(r),
  setText: (r, e) => {
    r.nodeValue = e;
  },
  setElementText: (r, e) => {
    r.textContent = e;
  },
  parentNode: (r) => r.parentNode,
  nextSibling: (r) => r.nextSibling,
  querySelector: (r) => ku.querySelector(r),
  setScopeId(r, e) {
    r.setAttribute(e, "");
  },
  // __UNSAFE__
  // Reason: innerHTML.
  // Static content here can only come from compiled templates.
  // As long as the user only uses trusted templates, this is safe.
  insertStaticContent(r, e, t, i, n, a) {
    const o = t ? t.previousSibling : e.lastChild;
    if (n && (n === a || n.nextSibling))
      for (; e.insertBefore(n.cloneNode(!0), t), !(n === a || !(n = n.nextSibling)); )
        ;
    else {
      IL.innerHTML = i ? `<svg>${r}</svg>` : r;
      const s = IL.content;
      if (i) {
        const l = s.firstChild;
        for (; l.firstChild; )
          s.appendChild(l.firstChild);
        s.removeChild(l);
      }
      e.insertBefore(s, t);
    }
    return [
      // first
      o ? o.nextSibling : e.firstChild,
      // last
      t ? t.previousSibling : e.lastChild
    ];
  }
};
function uee(r, e, t) {
  const i = r._vtc;
  i && (e = (e ? [e, ...i] : [...i]).join(" ")), e == null ? r.removeAttribute("class") : t ? r.setAttribute("class", e) : r.className = e;
}
function cee(r, e, t) {
  const i = r.style, n = qe(t);
  if (t && !n) {
    if (e && !qe(e))
      for (const a in e)
        t[a] == null && p_(i, a, "");
    for (const a in t)
      p_(i, a, t[a]);
  } else {
    const a = i.display;
    n ? e !== t && (i.cssText = t) : e && r.removeAttribute("style"), "_vod" in r && (i.display = a);
  }
}
const hee = /[^\\];\s*$/, wL = /\s*!important$/;
function p_(r, e, t) {
  if (pe(t))
    t.forEach((i) => p_(r, e, i));
  else if (t == null && (t = ""), {}.NODE_ENV !== "production" && hee.test(t) && W(
    `Unexpected semicolon at the end of '${e}' style value: '${t}'`
  ), e.startsWith("--"))
    r.setProperty(e, t);
  else {
    const i = fee(r, e);
    wL.test(t) ? r.setProperty(
      Li(i),
      t.replace(wL, ""),
      "important"
    ) : r[i] = t;
  }
}
const NL = ["Webkit", "Moz", "ms"], Cy = {};
function fee(r, e) {
  const t = Cy[e];
  if (t)
    return t;
  let i = Cr(e);
  if (i !== "filter" && i in r)
    return Cy[e] = i;
  i = bo(i);
  for (let n = 0; n < NL.length; n++) {
    const a = NL[n] + i;
    if (a in r)
      return Cy[e] = a;
  }
  return e;
}
const xL = "http://www.w3.org/1999/xlink";
function dee(r, e, t, i, n) {
  if (i && e.startsWith("xlink:"))
    t == null ? r.removeAttributeNS(xL, e.slice(6, e.length)) : r.setAttributeNS(xL, e, t);
  else {
    const a = gj(e);
    t == null || a && !y5(t) ? r.removeAttribute(e) : r.setAttribute(e, a ? "" : t);
  }
}
function pee(r, e, t, i, n, a, o) {
  if (e === "innerHTML" || e === "textContent") {
    i && o(i, n, a), r[e] = t ?? "";
    return;
  }
  const s = r.tagName;
  if (e === "value" && s !== "PROGRESS" && // custom elements may use _value internally
  !s.includes("-")) {
    r._value = t;
    const u = s === "OPTION" ? r.getAttribute("value") : r.value, c = t ?? "";
    u !== c && (r.value = c), t == null && r.removeAttribute(e);
    return;
  }
  let l = !1;
  if (t === "" || t == null) {
    const u = typeof r[e];
    u === "boolean" ? t = y5(t) : t == null && u === "string" ? (t = "", l = !0) : u === "number" && (t = 0, l = !0);
  }
  try {
    r[e] = t;
  } catch (u) {
    ({}).NODE_ENV !== "production" && !l && W(
      `Failed setting prop "${e}" on <${s.toLowerCase()}>: value ${t} is invalid.`,
      u
    );
  }
  l && r.removeAttribute(e);
}
function Yo(r, e, t, i) {
  r.addEventListener(e, t, i);
}
function gee(r, e, t, i) {
  r.removeEventListener(e, t, i);
}
function vee(r, e, t, i, n = null) {
  const a = r._vei || (r._vei = {}), o = a[e];
  if (i && o)
    o.value = i;
  else {
    const [s, l] = Oee(e);
    if (i) {
      const u = a[e] = bee(i, n);
      Yo(r, s, u, l);
    } else
      o && (gee(r, s, o, l), a[e] = void 0);
  }
}
const PL = /(?:Once|Passive|Capture)$/;
function Oee(r) {
  let e;
  if (PL.test(r)) {
    e = {};
    let i;
    for (; i = r.match(PL); )
      r = r.slice(0, r.length - i[0].length), e[i[0].toLowerCase()] = !0;
  }
  return [r[2] === ":" ? r.slice(3) : Li(r.slice(2)), e];
}
let Iy = 0;
const mee = /* @__PURE__ */ Promise.resolve(), Eee = () => Iy || (mee.then(() => Iy = 0), Iy = Date.now());
function bee(r, e) {
  const t = (i) => {
    if (!i._vts)
      i._vts = Date.now();
    else if (i._vts <= t.attached)
      return;
    En(
      See(i, t.value),
      e,
      5,
      [i]
    );
  };
  return t.value = r, t.attached = Eee(), t;
}
function See(r, e) {
  if (pe(e)) {
    const t = r.stopImmediatePropagation;
    return r.stopImmediatePropagation = () => {
      t.call(r), r._stopped = !0;
    }, e.map((i) => (n) => !n._stopped && i && i(n));
  } else
    return e;
}
const LL = /^on[a-z]/, Tee = (r, e, t, i, n = !1, a, o, s, l) => {
  e === "class" ? uee(r, i, n) : e === "style" ? cee(r, t, i) : is(e) ? TE(e) || vee(r, e, t, i, o) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : yee(r, e, i, n)) ? pee(
    r,
    e,
    i,
    a,
    o,
    s,
    l
  ) : (e === "true-value" ? r._trueValue = i : e === "false-value" && (r._falseValue = i), dee(r, e, i, n));
};
function yee(r, e, t, i) {
  return i ? !!(e === "innerHTML" || e === "textContent" || e in r && LL.test(e) && Ue(t)) : e === "spellcheck" || e === "draggable" || e === "translate" || e === "form" || e === "list" && r.tagName === "INPUT" || e === "type" && r.tagName === "TEXTAREA" || LL.test(e) && qe(t) ? !1 : e in r;
}
function Kw(r, e) {
  const t = An(r);
  class i extends jS {
    constructor(a) {
      super(t, a, e);
    }
  }
  return i.def = t, i;
}
const Ree = (r) => Kw(r, dX), Aee = typeof HTMLElement < "u" ? HTMLElement : class {
};
class jS extends Aee {
  constructor(e, t = {}, i) {
    super(), this._def = e, this._props = t, this._instance = null, this._connected = !1, this._resolved = !1, this._numberProps = null, this.shadowRoot && i ? i(this._createVNode(), this.shadowRoot) : ({}.NODE_ENV !== "production" && this.shadowRoot && W(
      "Custom element has pre-rendered declarative shadow root but is not defined as hydratable. Use `defineSSRCustomElement`."
    ), this.attachShadow({ mode: "open" }), this._def.__asyncLoader || this._resolveProps(this._def));
  }
  connectedCallback() {
    this._connected = !0, this._instance || (this._resolved ? this._update() : this._resolveDef());
  }
  disconnectedCallback() {
    this._connected = !1, Sc(() => {
      this._connected || (O_(null, this.shadowRoot), this._instance = null);
    });
  }
  /**
   * resolve inner component definition (handle possible async component)
   */
  _resolveDef() {
    this._resolved = !0;
    for (let i = 0; i < this.attributes.length; i++)
      this._setAttr(this.attributes[i].name);
    new MutationObserver((i) => {
      for (const n of i)
        this._setAttr(n.attributeName);
    }).observe(this, { attributes: !0 });
    const e = (i, n = !1) => {
      const { props: a, styles: o } = i;
      let s;
      if (a && !pe(a))
        for (const l in a) {
          const u = a[l];
          (u === Number || u && u.type === Number) && (l in this._props && (this._props[l] = AE(this._props[l])), (s || (s = /* @__PURE__ */ Object.create(null)))[Cr(l)] = !0);
        }
      this._numberProps = s, n && this._resolveProps(i), this._applyStyles(o), this._update();
    }, t = this._def.__asyncLoader;
    t ? t().then((i) => e(i, !0)) : e(this._def);
  }
  _resolveProps(e) {
    const { props: t } = e, i = pe(t) ? t : Object.keys(t || {});
    for (const n of Object.keys(this))
      n[0] !== "_" && i.includes(n) && this._setProp(n, this[n], !0, !1);
    for (const n of i.map(Cr))
      Object.defineProperty(this, n, {
        get() {
          return this._getProp(n);
        },
        set(a) {
          this._setProp(n, a);
        }
      });
  }
  _setAttr(e) {
    let t = this.getAttribute(e);
    const i = Cr(e);
    this._numberProps && this._numberProps[i] && (t = AE(t)), this._setProp(i, t, !1);
  }
  /**
   * @internal
   */
  _getProp(e) {
    return this._props[e];
  }
  /**
   * @internal
   */
  _setProp(e, t, i = !0, n = !0) {
    t !== this._props[e] && (this._props[e] = t, n && this._instance && this._update(), i && (t === !0 ? this.setAttribute(Li(e), "") : typeof t == "string" || typeof t == "number" ? this.setAttribute(Li(e), t + "") : t || this.removeAttribute(Li(e))));
  }
  _update() {
    O_(this._createVNode(), this.shadowRoot);
  }
  _createVNode() {
    const e = Yt(this._def, ut({}, this._props));
    return this._instance || (e.ce = (t) => {
      this._instance = t, t.isCE = !0, {}.NODE_ENV !== "production" && (t.ceReload = (a) => {
        this._styles && (this._styles.forEach((o) => this.shadowRoot.removeChild(o)), this._styles.length = 0), this._applyStyles(a), this._instance = null, this._update();
      });
      const i = (a, o) => {
        this.dispatchEvent(
          new CustomEvent(a, {
            detail: o
          })
        );
      };
      t.emit = (a, ...o) => {
        i(a, o), Li(a) !== a && i(Li(a), o);
      };
      let n = this;
      for (; n = n && (n.parentNode || n.host); )
        if (n instanceof jS) {
          t.parent = n._instance, t.provides = n._instance.provides;
          break;
        }
    }), e;
  }
  _applyStyles(e) {
    e && e.forEach((t) => {
      const i = document.createElement("style");
      i.textContent = t, this.shadowRoot.appendChild(i), {}.NODE_ENV !== "production" && (this._styles || (this._styles = [])).push(i);
    });
  }
}
function _ee(r = "$style") {
  {
    const e = ms();
    if (!e)
      return {}.NODE_ENV !== "production" && W("useCssModule must be called inside setup()"), _t;
    const t = e.type.__cssModules;
    if (!t)
      return {}.NODE_ENV !== "production" && W("Current instance does not have CSS modules injected."), _t;
    const i = t[r];
    return i || ({}.NODE_ENV !== "production" && W(`Current instance does not have CSS module named "${r}".`), _t);
  }
}
function Cee(r) {
  const e = ms();
  if (!e) {
    ({}).NODE_ENV !== "production" && W("useCssVars is called without current active component instance.");
    return;
  }
  const t = e.ut = (n = r(e.proxy)) => {
    Array.from(
      document.querySelectorAll(`[data-v-owner="${e.uid}"]`)
    ).forEach((a) => v_(a, n));
  }, i = () => {
    const n = r(e.proxy);
    g_(e.subTree, n), t(n);
  };
  tF(i), Os(() => {
    const n = new MutationObserver(i);
    n.observe(e.subTree.el.parentNode, { childList: !0 }), WS(() => n.disconnect());
  });
}
function g_(r, e) {
  if (r.shapeFlag & 128) {
    const t = r.suspense;
    r = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => {
      g_(t.activeBranch, e);
    });
  }
  for (; r.component; )
    r = r.component.subTree;
  if (r.shapeFlag & 1 && r.el)
    v_(r.el, e);
  else if (r.type === xr)
    r.children.forEach((t) => g_(t, e));
  else if (r.type === hl) {
    let { el: t, anchor: i } = r;
    for (; t && (v_(t, e), t !== i); )
      t = t.nextSibling;
  }
}
function v_(r, e) {
  if (r.nodeType === 1) {
    const t = r.style;
    for (const i in e)
      t.setProperty(`--${i}`, e[i]);
  }
}
const Cs = "transition", Td = "animation", Jw = (r, { slots: e }) => Wl(nF, JF(r), e);
Jw.displayName = "Transition";
const KF = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: !0
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
}, Iee = Jw.props = /* @__PURE__ */ ut(
  {},
  Fw,
  KF
), tu = (r, e = []) => {
  pe(r) ? r.forEach((t) => t(...e)) : r && r(...e);
}, DL = (r) => r ? pe(r) ? r.some((e) => e.length > 1) : r.length > 1 : !1;
function JF(r) {
  const e = {};
  for (const w in r)
    w in KF || (e[w] = r[w]);
  if (r.css === !1)
    return e;
  const {
    name: t = "v",
    type: i,
    duration: n,
    enterFromClass: a = `${t}-enter-from`,
    enterActiveClass: o = `${t}-enter-active`,
    enterToClass: s = `${t}-enter-to`,
    appearFromClass: l = a,
    appearActiveClass: u = o,
    appearToClass: c = s,
    leaveFromClass: h = `${t}-leave-from`,
    leaveActiveClass: f = `${t}-leave-active`,
    leaveToClass: d = `${t}-leave-to`
  } = r, p = wee(n), g = p && p[0], v = p && p[1], {
    onBeforeEnter: O,
    onEnter: m,
    onEnterCancelled: E,
    onLeave: b,
    onLeaveCancelled: S,
    onBeforeAppear: T = O,
    onAppear: y = m,
    onAppearCancelled: R = E
  } = e, _ = (w, x, P) => {
    $s(w, x ? c : s), $s(w, x ? u : o), P && P();
  }, C = (w, x) => {
    w._isLeaving = !1, $s(w, h), $s(w, d), $s(w, f), x && x();
  }, I = (w) => (x, P) => {
    const L = w ? y : m, D = () => _(x, w, P);
    tu(L, [x, D]), ML(() => {
      $s(x, w ? l : a), Go(x, w ? c : s), DL(L) || kL(x, i, g, D);
    });
  };
  return ut(e, {
    onBeforeEnter(w) {
      tu(O, [w]), Go(w, a), Go(w, o);
    },
    onBeforeAppear(w) {
      tu(T, [w]), Go(w, l), Go(w, u);
    },
    onEnter: I(!1),
    onAppear: I(!0),
    onLeave(w, x) {
      w._isLeaving = !0;
      const P = () => C(w, x);
      Go(w, h), tX(), Go(w, f), ML(() => {
        w._isLeaving && ($s(w, h), Go(w, d), DL(b) || kL(w, i, v, P));
      }), tu(b, [w, P]);
    },
    onEnterCancelled(w) {
      _(w, !1), tu(E, [w]);
    },
    onAppearCancelled(w) {
      _(w, !0), tu(R, [w]);
    },
    onLeaveCancelled(w) {
      C(w), tu(S, [w]);
    }
  });
}
function wee(r) {
  if (r == null)
    return null;
  if (Tt(r))
    return [wy(r.enter), wy(r.leave)];
  {
    const e = wy(r);
    return [e, e];
  }
}
function wy(r) {
  const e = AE(r);
  return {}.NODE_ENV !== "production" && Lw(e, "<transition> explicit duration"), e;
}
function Go(r, e) {
  e.split(/\s+/).forEach((t) => t && r.classList.add(t)), (r._vtc || (r._vtc = /* @__PURE__ */ new Set())).add(e);
}
function $s(r, e) {
  e.split(/\s+/).forEach((i) => i && r.classList.remove(i));
  const { _vtc: t } = r;
  t && (t.delete(e), t.size || (r._vtc = void 0));
}
function ML(r) {
  requestAnimationFrame(() => {
    requestAnimationFrame(r);
  });
}
let Nee = 0;
function kL(r, e, t, i) {
  const n = r._endId = ++Nee, a = () => {
    n === r._endId && i();
  };
  if (t)
    return setTimeout(a, t);
  const { type: o, timeout: s, propCount: l } = eX(r, e);
  if (!o)
    return i();
  const u = o + "end";
  let c = 0;
  const h = () => {
    r.removeEventListener(u, f), a();
  }, f = (d) => {
    d.target === r && ++c >= l && h();
  };
  setTimeout(() => {
    c < l && h();
  }, s + 1), r.addEventListener(u, f);
}
function eX(r, e) {
  const t = window.getComputedStyle(r), i = (p) => (t[p] || "").split(", "), n = i(`${Cs}Delay`), a = i(`${Cs}Duration`), o = QL(n, a), s = i(`${Td}Delay`), l = i(`${Td}Duration`), u = QL(s, l);
  let c = null, h = 0, f = 0;
  e === Cs ? o > 0 && (c = Cs, h = o, f = a.length) : e === Td ? u > 0 && (c = Td, h = u, f = l.length) : (h = Math.max(o, u), c = h > 0 ? o > u ? Cs : Td : null, f = c ? c === Cs ? a.length : l.length : 0);
  const d = c === Cs && /\b(transform|all)(,|$)/.test(
    i(`${Cs}Property`).toString()
  );
  return {
    type: c,
    timeout: h,
    propCount: f,
    hasTransform: d
  };
}
function QL(r, e) {
  for (; r.length < e.length; )
    r = r.concat(r);
  return Math.max(...e.map((t, i) => UL(t) + UL(r[i])));
}
function UL(r) {
  return Number(r.slice(0, -1).replace(",", ".")) * 1e3;
}
function tX() {
  return document.body.offsetHeight;
}
const rX = /* @__PURE__ */ new WeakMap(), iX = /* @__PURE__ */ new WeakMap(), nX = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ ut({}, Iee, {
    tag: String,
    moveClass: String
  }),
  setup(r, { slots: e }) {
    const t = ms(), i = Bw();
    let n, a;
    return YS(() => {
      if (!n.length)
        return;
      const o = r.moveClass || `${r.name || "v"}-move`;
      if (!kee(
        n[0].el,
        t.vnode.el,
        o
      ))
        return;
      n.forEach(Lee), n.forEach(Dee);
      const s = n.filter(Mee);
      tX(), s.forEach((l) => {
        const u = l.el, c = u.style;
        Go(u, o), c.transform = c.webkitTransform = c.transitionDuration = "";
        const h = u._moveCb = (f) => {
          f && f.target !== u || (!f || /transform$/.test(f.propertyName)) && (u.removeEventListener("transitionend", h), u._moveCb = null, $s(u, o));
        };
        u.addEventListener("transitionend", h);
      });
    }), () => {
      const o = je(r), s = JF(o);
      let l = o.tag || xr;
      n = a, a = e.default ? FS(e.default()) : [];
      for (let u = 0; u < a.length; u++) {
        const c = a[u];
        c.key != null ? yc(
          c,
          bf(c, s, i, t)
        ) : {}.NODE_ENV !== "production" && W("<TransitionGroup> children must be keyed.");
      }
      if (n)
        for (let u = 0; u < n.length; u++) {
          const c = n[u];
          yc(
            c,
            bf(c, s, i, t)
          ), rX.set(c, c.el.getBoundingClientRect());
        }
      return Yt(l, null, a);
    };
  }
}, xee = (r) => delete r.mode;
nX.props;
const Pee = nX;
function Lee(r) {
  const e = r.el;
  e._moveCb && e._moveCb(), e._enterCb && e._enterCb();
}
function Dee(r) {
  iX.set(r, r.el.getBoundingClientRect());
}
function Mee(r) {
  const e = rX.get(r), t = iX.get(r), i = e.left - t.left, n = e.top - t.top;
  if (i || n) {
    const a = r.el.style;
    return a.transform = a.webkitTransform = `translate(${i}px,${n}px)`, a.transitionDuration = "0s", r;
  }
}
function kee(r, e, t) {
  const i = r.cloneNode();
  r._vtc && r._vtc.forEach((o) => {
    o.split(/\s+/).forEach((s) => s && i.classList.remove(s));
  }), t.split(/\s+/).forEach((o) => o && i.classList.add(o)), i.style.display = "none";
  const n = e.nodeType === 1 ? e : e.parentNode;
  n.appendChild(i);
  const { hasTransform: a } = eX(i);
  return n.removeChild(i), a;
}
const _l = (r) => {
  const e = r.props["onUpdate:modelValue"] || !1;
  return pe(e) ? (t) => zs(e, t) : e;
};
function Qee(r) {
  r.target.composing = !0;
}
function $L(r) {
  const e = r.target;
  e.composing && (e.composing = !1, e.dispatchEvent(new Event("input")));
}
const ME = {
  created(r, { modifiers: { lazy: e, trim: t, number: i } }, n) {
    r._assign = _l(n);
    const a = i || n.props && n.props.type === "number";
    Yo(r, e ? "change" : "input", (o) => {
      if (o.target.composing)
        return;
      let s = r.value;
      t && (s = s.trim()), a && (s = RE(s)), r._assign(s);
    }), t && Yo(r, "change", () => {
      r.value = r.value.trim();
    }), e || (Yo(r, "compositionstart", Qee), Yo(r, "compositionend", $L), Yo(r, "change", $L));
  },
  // set value on mounted so it's after min/max for type="range"
  mounted(r, { value: e }) {
    r.value = e ?? "";
  },
  beforeUpdate(r, { value: e, modifiers: { lazy: t, trim: i, number: n } }, a) {
    if (r._assign = _l(a), r.composing || document.activeElement === r && r.type !== "range" && (t || i && r.value.trim() === e || (n || r.type === "number") && RE(r.value) === e))
      return;
    const o = e ?? "";
    r.value !== o && (r.value = o);
  }
}, e1 = {
  // #4096 array checkboxes need to be deep traversed
  deep: !0,
  created(r, e, t) {
    r._assign = _l(t), Yo(r, "change", () => {
      const i = r._modelValue, n = Tf(r), a = r.checked, o = r._assign;
      if (pe(i)) {
        const s = LS(i, n), l = s !== -1;
        if (a && !l)
          o(i.concat(n));
        else if (!a && l) {
          const u = [...i];
          u.splice(s, 1), o(u);
        }
      } else if (Bc(i)) {
        const s = new Set(i);
        a ? s.add(n) : s.delete(n), o(s);
      } else
        o(oX(r, a));
    });
  },
  // set initial checked on mount to wait for true-value/false-value
  mounted: VL,
  beforeUpdate(r, e, t) {
    r._assign = _l(t), VL(r, e, t);
  }
};
function VL(r, { value: e, oldValue: t }, i) {
  r._modelValue = e, pe(e) ? r.checked = LS(e, i.props.value) > -1 : Bc(e) ? r.checked = e.has(i.props.value) : e !== t && (r.checked = Tl(e, oX(r, !0)));
}
const t1 = {
  created(r, { value: e }, t) {
    r.checked = Tl(e, t.props.value), r._assign = _l(t), Yo(r, "change", () => {
      r._assign(Tf(r));
    });
  },
  beforeUpdate(r, { value: e, oldValue: t }, i) {
    r._assign = _l(i), e !== t && (r.checked = Tl(e, i.props.value));
  }
}, aX = {
  // <select multiple> value need to be deep traversed
  deep: !0,
  created(r, { value: e, modifiers: { number: t } }, i) {
    const n = Bc(e);
    Yo(r, "change", () => {
      const a = Array.prototype.filter.call(r.options, (o) => o.selected).map(
        (o) => t ? RE(Tf(o)) : Tf(o)
      );
      r._assign(
        r.multiple ? n ? new Set(a) : a : a[0]
      );
    }), r._assign = _l(i);
  },
  // set value in mounted & updated because <select> relies on its children
  // <option>s.
  mounted(r, { value: e }) {
    GL(r, e);
  },
  beforeUpdate(r, e, t) {
    r._assign = _l(t);
  },
  updated(r, { value: e }) {
    GL(r, e);
  }
};
function GL(r, e) {
  const t = r.multiple;
  if (t && !pe(e) && !Bc(e)) {
    ({}).NODE_ENV !== "production" && W(
      `<select multiple v-model> expects an Array or Set value for its binding, but got ${Object.prototype.toString.call(e).slice(8, -1)}.`
    );
    return;
  }
  for (let i = 0, n = r.options.length; i < n; i++) {
    const a = r.options[i], o = Tf(a);
    if (t)
      pe(e) ? a.selected = LS(e, o) > -1 : a.selected = e.has(o);
    else if (Tl(Tf(a), e)) {
      r.selectedIndex !== i && (r.selectedIndex = i);
      return;
    }
  }
  !t && r.selectedIndex !== -1 && (r.selectedIndex = -1);
}
function Tf(r) {
  return "_value" in r ? r._value : r.value;
}
function oX(r, e) {
  const t = e ? "_trueValue" : "_falseValue";
  return t in r ? r[t] : e;
}
const sX = {
  created(r, e, t) {
    uO(r, e, t, null, "created");
  },
  mounted(r, e, t) {
    uO(r, e, t, null, "mounted");
  },
  beforeUpdate(r, e, t, i) {
    uO(r, e, t, i, "beforeUpdate");
  },
  updated(r, e, t, i) {
    uO(r, e, t, i, "updated");
  }
};
function lX(r, e) {
  switch (r) {
    case "SELECT":
      return aX;
    case "TEXTAREA":
      return ME;
    default:
      switch (e) {
        case "checkbox":
          return e1;
        case "radio":
          return t1;
        default:
          return ME;
      }
  }
}
function uO(r, e, t, i, n) {
  const o = lX(
    r.tagName,
    t.props && t.props.type
  )[n];
  o && o(r, e, t, i);
}
function Uee() {
  ME.getSSRProps = ({ value: r }) => ({ value: r }), t1.getSSRProps = ({ value: r }, e) => {
    if (e.props && Tl(e.props.value, r))
      return { checked: !0 };
  }, e1.getSSRProps = ({ value: r }, e) => {
    if (pe(r)) {
      if (e.props && LS(r, e.props.value) > -1)
        return { checked: !0 };
    } else if (Bc(r)) {
      if (e.props && r.has(e.props.value))
        return { checked: !0 };
    } else if (r)
      return { checked: !0 };
  }, sX.getSSRProps = (r, e) => {
    if (typeof e.type != "string")
      return;
    const t = lX(
      // resolveDynamicModel expects an uppercase tag name, but vnode.type is lowercase
      e.type.toUpperCase(),
      e.props && e.props.type
    );
    if (t.getSSRProps)
      return t.getSSRProps(r, e);
  };
}
const $ee = ["ctrl", "shift", "alt", "meta"], Vee = {
  stop: (r) => r.stopPropagation(),
  prevent: (r) => r.preventDefault(),
  self: (r) => r.target !== r.currentTarget,
  ctrl: (r) => !r.ctrlKey,
  shift: (r) => !r.shiftKey,
  alt: (r) => !r.altKey,
  meta: (r) => !r.metaKey,
  left: (r) => "button" in r && r.button !== 0,
  middle: (r) => "button" in r && r.button !== 1,
  right: (r) => "button" in r && r.button !== 2,
  exact: (r, e) => $ee.some((t) => r[`${t}Key`] && !e.includes(t))
}, Gee = (r, e) => (t, ...i) => {
  for (let n = 0; n < e.length; n++) {
    const a = Vee[e[n]];
    if (a && a(t, e))
      return;
  }
  return r(t, ...i);
}, Bee = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
}, Fee = (r, e) => (t) => {
  if (!("key" in t))
    return;
  const i = Li(t.key);
  if (e.some((n) => n === i || Bee[n] === i))
    return r(t);
}, uX = {
  beforeMount(r, { value: e }, { transition: t }) {
    r._vod = r.style.display === "none" ? "" : r.style.display, t && e ? t.beforeEnter(r) : yd(r, e);
  },
  mounted(r, { value: e }, { transition: t }) {
    t && e && t.enter(r);
  },
  updated(r, { value: e, oldValue: t }, { transition: i }) {
    !e != !t && (i ? e ? (i.beforeEnter(r), yd(r, !0), i.enter(r)) : i.leave(r, () => {
      yd(r, !1);
    }) : yd(r, e));
  },
  beforeUnmount(r, { value: e }) {
    yd(r, e);
  }
};
function yd(r, e) {
  r.style.display = e ? r._vod : "none";
}
function Xee() {
  uX.getSSRProps = ({ value: r }) => {
    if (!r)
      return { style: { display: "none" } };
  };
}
const cX = /* @__PURE__ */ ut({ patchProp: Tee }, lee);
let Vp, BL = !1;
function hX() {
  return Vp || (Vp = wF(cX));
}
function fX() {
  return Vp = BL ? Vp : NF(cX), BL = !0, Vp;
}
const O_ = (...r) => {
  hX().render(...r);
}, dX = (...r) => {
  fX().hydrate(...r);
}, Yee = (...r) => {
  const e = hX().createApp(...r);
  ({}).NODE_ENV !== "production" && (pX(e), gX(e));
  const { mount: t } = e;
  return e.mount = (i) => {
    const n = vX(i);
    if (!n)
      return;
    const a = e._component;
    !Ue(a) && !a.render && !a.template && (a.template = n.innerHTML), n.innerHTML = "";
    const o = t(n, !1, n instanceof SVGElement);
    return n instanceof Element && (n.removeAttribute("v-cloak"), n.setAttribute("data-v-app", "")), o;
  }, e;
}, Hee = (...r) => {
  const e = fX().createApp(...r);
  ({}).NODE_ENV !== "production" && (pX(e), gX(e));
  const { mount: t } = e;
  return e.mount = (i) => {
    const n = vX(i);
    if (n)
      return t(n, !0, n instanceof SVGElement);
  }, e;
};
function pX(r) {
  Object.defineProperty(r.config, "isNativeTag", {
    value: (e) => S5(e) || T5(e),
    writable: !1
  });
}
function gX(r) {
  if (jw()) {
    const e = r.config.isCustomElement;
    Object.defineProperty(r.config, "isCustomElement", {
      get() {
        return e;
      },
      set() {
        W(
          "The `isCustomElement` config option is deprecated. Use `compilerOptions.isCustomElement` instead."
        );
      }
    });
    const t = r.config.compilerOptions, i = 'The `compilerOptions` config option is only respected when using a build of Vue.js that includes the runtime compiler (aka "full build"). Since you are using the runtime-only build, `compilerOptions` must be passed to `@vue/compiler-dom` in the build setup instead.\n- For vue-loader: pass it via vue-loader\'s `compilerOptions` loader option.\n- For vue-cli: see https://cli.vuejs.org/guide/webpack.html#modifying-options-of-a-loader\n- For vite: pass it via @vitejs/plugin-vue options. See https://github.com/vitejs/vite-plugin-vue/tree/main/packages/plugin-vue#example-for-passing-options-to-vuecompiler-sfc';
    Object.defineProperty(r.config, "compilerOptions", {
      get() {
        return W(i), t;
      },
      set() {
        W(i);
      }
    });
  }
}
function vX(r) {
  if (qe(r)) {
    const e = document.querySelector(r);
    return {}.NODE_ENV !== "production" && !e && W(
      `Failed to mount app: mount target selector "${r}" returned null.`
    ), e;
  }
  return {}.NODE_ENV !== "production" && window.ShadowRoot && r instanceof window.ShadowRoot && r.mode === "closed" && W(
    'mounting on a ShadowRoot with `{mode: "closed"}` may lead to unpredictable bugs'
  ), r;
}
let FL = !1;
const Wee = () => {
  FL || (FL = !0, Uee(), Xee());
}, zee = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BaseTransition: nF,
  BaseTransitionPropsValidators: Fw,
  Comment: mr,
  EffectScope: _w,
  Fragment: xr,
  KeepAlive: zK,
  ReactiveEffect: pv,
  Static: hl,
  Suspense: MK,
  Teleport: YJ,
  Text: Rl,
  Transition: Jw,
  TransitionGroup: Pee,
  VueElement: jS,
  assertNumber: Lw,
  callWithAsyncErrorHandling: En,
  callWithErrorHandling: go,
  camelize: Cr,
  capitalize: bo,
  cloneVNode: ia,
  compatUtils: oee,
  computed: WF,
  createApp: Yee,
  createBlock: va,
  createCommentVNode: Fn,
  createElementBlock: Pr,
  createElementVNode: er,
  createHydrationRenderer: NF,
  createPropsRestProxy: OJ,
  createRenderer: wF,
  createSSRApp: Hee,
  createSlots: JK,
  createStaticVNode: zJ,
  createTextVNode: zw,
  createVNode: Yt,
  customRef: tK,
  defineAsyncComponent: HK,
  defineComponent: An,
  defineCustomElement: Kw,
  defineEmits: oJ,
  defineExpose: sJ,
  defineModel: cJ,
  defineOptions: lJ,
  defineProps: aJ,
  defineSSRCustomElement: Ree,
  defineSlots: uJ,
  get devtools() {
    return ga;
  },
  effect: Sj,
  effectScope: Oj,
  getCurrentInstance: ms,
  getCurrentScope: C5,
  getTransitionRawChildren: FS,
  guardReactiveProps: QF,
  h: Wl,
  handleError: Yc,
  hasInjectionContext: CJ,
  hydrate: dX,
  initCustomFormatter: qF,
  initDirectivesForSSR: Wee,
  inject: kp,
  isMemoSame: jF,
  isProxy: hg,
  isReactive: ul,
  isReadonly: ns,
  isRef: sr,
  isRuntimeOnly: jw,
  isShallow: cg,
  isVNode: as,
  markRaw: ww,
  mergeDefaults: gJ,
  mergeModels: vJ,
  mergeProps: $F,
  nextTick: Sc,
  normalizeClass: Hf,
  normalizeProps: uj,
  normalizeStyle: Na,
  onActivated: oF,
  onBeforeMount: uF,
  onBeforeUnmount: HS,
  onBeforeUpdate: cF,
  onDeactivated: sF,
  onErrorCaptured: pF,
  onMounted: Os,
  onRenderTracked: dF,
  onRenderTriggered: fF,
  onScopeDispose: mj,
  onServerPrefetch: hF,
  onUnmounted: WS,
  onUpdated: YS,
  openBlock: xt,
  popScopeId: K5,
  provide: TF,
  proxyRefs: Pw,
  pushScopeId: j5,
  queuePostFlushCb: VS,
  reactive: QS,
  readonly: Iw,
  ref: Rr,
  registerRuntimeCompiler: FF,
  render: O_,
  renderList: OF,
  renderSlot: Di,
  resolveComponent: gF,
  resolveDirective: KK,
  resolveDynamicComponent: jK,
  resolveFilter: aee,
  resolveTransitionHooks: bf,
  setBlockTracking: l_,
  setDevtoolsHook: Qw,
  setTransitionHooks: yc,
  shallowReactive: V5,
  shallowReadonly: Yh,
  shallowRef: Zj,
  ssrContextKey: zF,
  ssrUtils: nee,
  stop: Tj,
  toDisplayString: R5,
  toHandlerKey: Ka,
  toHandlers: eJ,
  toRaw: je,
  toRef: aK,
  toRefs: rK,
  toValue: Kj,
  transformVNodeArgs: HJ,
  triggerRef: jj,
  unref: Ef,
  useAttrs: dJ,
  useCssModule: _ee,
  useCssVars: Cee,
  useModel: pJ,
  useSSRContext: ZF,
  useSlots: fJ,
  useTransitionState: Bw,
  vModelCheckbox: e1,
  vModelDynamic: sX,
  vModelRadio: t1,
  vModelSelect: aX,
  vModelText: ME,
  vShow: uX,
  version: d_,
  warn: W,
  watch: Ra,
  watchEffect: GK,
  watchPostEffect: tF,
  watchSyncEffect: BK,
  withAsyncContext: mJ,
  withCtx: vg,
  withDefaults: hJ,
  withDirectives: XK,
  withKeys: Fee,
  withMemo: ree,
  withModifiers: Gee,
  withScopeId: wK
}, Symbol.toStringTag, { value: "Module" }));
function r1(r) {
  throw r;
}
function OX(r) {
  ({}).NODE_ENV !== "production" && console.warn(`[Vue warn] ${r.message}`);
}
function Pt(r, e, t, i) {
  const n = {}.NODE_ENV !== "production" ? (t || Zee)[r] + (i || "") : r, a = new SyntaxError(String(n));
  return a.code = r, a.loc = e, a;
}
const Zee = {
  // parse errors
  0: "Illegal comment.",
  1: "CDATA section is allowed only in XML context.",
  2: "Duplicate attribute.",
  3: "End tag cannot have attributes.",
  4: "Illegal '/' in tags.",
  5: "Unexpected EOF in tag.",
  6: "Unexpected EOF in CDATA section.",
  7: "Unexpected EOF in comment.",
  8: "Unexpected EOF in script.",
  9: "Unexpected EOF in tag.",
  10: "Incorrectly closed comment.",
  11: "Incorrectly opened comment.",
  12: "Illegal tag name. Use '&lt;' to print '<'.",
  13: "Attribute value was expected.",
  14: "End tag name was expected.",
  15: "Whitespace was expected.",
  16: "Unexpected '<!--' in comment.",
  17: `Attribute name cannot contain U+0022 ("), U+0027 ('), and U+003C (<).`,
  18: "Unquoted attribute value cannot contain U+0022 (\"), U+0027 ('), U+003C (<), U+003D (=), and U+0060 (`).",
  19: "Attribute name cannot start with '='.",
  21: "'<?' is allowed only in XML context.",
  20: "Unexpected null character.",
  22: "Illegal '/' in tags.",
  // Vue-specific parse errors
  23: "Invalid end tag.",
  24: "Element is missing end tag.",
  25: "Interpolation end sign was not found.",
  27: "End bracket for dynamic directive argument was not found. Note that dynamic directive argument cannot contain spaces.",
  26: "Legal directive name was expected.",
  // transform errors
  28: "v-if/v-else-if is missing expression.",
  29: "v-if/else branches must use unique keys.",
  30: "v-else/v-else-if has no adjacent v-if or v-else-if.",
  31: "v-for is missing expression.",
  32: "v-for has invalid expression.",
  33: "<template v-for> key should be placed on the <template> tag.",
  34: "v-bind is missing expression.",
  35: "v-on is missing expression.",
  36: "Unexpected custom directive on <slot> outlet.",
  37: "Mixed v-slot usage on both the component and nested <template>. When there are multiple named slots, all slots should use <template> syntax to avoid scope ambiguity.",
  38: "Duplicate slot names found. ",
  39: "Extraneous children found when component already has explicitly named default slot. These children will be ignored.",
  40: "v-slot can only be used on components or <template> tags.",
  41: "v-model is missing expression.",
  42: "v-model value must be a valid JavaScript member expression.",
  43: "v-model cannot be used on v-for or v-slot scope variables because they are not writable.",
  44: `v-model cannot be used on a prop, because local prop bindings are not writable.
Use a v-bind binding combined with a v-on listener that emits update:x event instead.`,
  45: "Error parsing JavaScript expression: ",
  46: "<KeepAlive> expects exactly one child component.",
  // generic errors
  47: '"prefixIdentifiers" option is not supported in this build of compiler.',
  48: "ES module mode is not supported in this build of compiler.",
  49: '"cacheHandlers" option is only supported when the "prefixIdentifiers" option is enabled.',
  50: '"scopeId" option is only supported in module mode.',
  // deprecations
  51: "@vnode-* hooks in templates are deprecated. Use the vue: prefix instead. For example, @vnode-mounted should be changed to @vue:mounted. @vnode-* hooks support will be removed in 3.4.",
  52: 'v-is="component-name" has been deprecated. Use is="vue:component-name" instead. v-is support will be removed in 3.4.',
  // just to fulfill types
  53: ""
}, Sg = Symbol({}.NODE_ENV !== "production" ? "Fragment" : ""), Gp = Symbol({}.NODE_ENV !== "production" ? "Teleport" : ""), i1 = Symbol({}.NODE_ENV !== "production" ? "Suspense" : ""), kE = Symbol({}.NODE_ENV !== "production" ? "KeepAlive" : ""), mX = Symbol({}.NODE_ENV !== "production" ? "BaseTransition" : ""), Ac = Symbol({}.NODE_ENV !== "production" ? "openBlock" : ""), EX = Symbol({}.NODE_ENV !== "production" ? "createBlock" : ""), bX = Symbol({}.NODE_ENV !== "production" ? "createElementBlock" : ""), n1 = Symbol({}.NODE_ENV !== "production" ? "createVNode" : ""), a1 = Symbol({}.NODE_ENV !== "production" ? "createElementVNode" : ""), mv = Symbol({}.NODE_ENV !== "production" ? "createCommentVNode" : ""), o1 = Symbol({}.NODE_ENV !== "production" ? "createTextVNode" : ""), SX = Symbol({}.NODE_ENV !== "production" ? "createStaticVNode" : ""), s1 = Symbol({}.NODE_ENV !== "production" ? "resolveComponent" : ""), QE = Symbol(
  {}.NODE_ENV !== "production" ? "resolveDynamicComponent" : ""
), l1 = Symbol({}.NODE_ENV !== "production" ? "resolveDirective" : ""), u1 = Symbol({}.NODE_ENV !== "production" ? "resolveFilter" : ""), c1 = Symbol({}.NODE_ENV !== "production" ? "withDirectives" : ""), h1 = Symbol({}.NODE_ENV !== "production" ? "renderList" : ""), TX = Symbol({}.NODE_ENV !== "production" ? "renderSlot" : ""), yX = Symbol({}.NODE_ENV !== "production" ? "createSlots" : ""), KS = Symbol({}.NODE_ENV !== "production" ? "toDisplayString" : ""), UE = Symbol({}.NODE_ENV !== "production" ? "mergeProps" : ""), f1 = Symbol({}.NODE_ENV !== "production" ? "normalizeClass" : ""), d1 = Symbol({}.NODE_ENV !== "production" ? "normalizeStyle" : ""), Tg = Symbol({}.NODE_ENV !== "production" ? "normalizeProps" : ""), Ev = Symbol({}.NODE_ENV !== "production" ? "guardReactiveProps" : ""), p1 = Symbol({}.NODE_ENV !== "production" ? "toHandlers" : ""), m_ = Symbol({}.NODE_ENV !== "production" ? "camelize" : ""), qee = Symbol({}.NODE_ENV !== "production" ? "capitalize" : ""), E_ = Symbol({}.NODE_ENV !== "production" ? "toHandlerKey" : ""), $E = Symbol({}.NODE_ENV !== "production" ? "setBlockTracking" : ""), jee = Symbol({}.NODE_ENV !== "production" ? "pushScopeId" : ""), Kee = Symbol({}.NODE_ENV !== "production" ? "popScopeId" : ""), g1 = Symbol({}.NODE_ENV !== "production" ? "withCtx" : ""), Jee = Symbol({}.NODE_ENV !== "production" ? "unref" : ""), ete = Symbol({}.NODE_ENV !== "production" ? "isRef" : ""), v1 = Symbol({}.NODE_ENV !== "production" ? "withMemo" : ""), RX = Symbol({}.NODE_ENV !== "production" ? "isMemoSame" : ""), yf = {
  [Sg]: "Fragment",
  [Gp]: "Teleport",
  [i1]: "Suspense",
  [kE]: "KeepAlive",
  [mX]: "BaseTransition",
  [Ac]: "openBlock",
  [EX]: "createBlock",
  [bX]: "createElementBlock",
  [n1]: "createVNode",
  [a1]: "createElementVNode",
  [mv]: "createCommentVNode",
  [o1]: "createTextVNode",
  [SX]: "createStaticVNode",
  [s1]: "resolveComponent",
  [QE]: "resolveDynamicComponent",
  [l1]: "resolveDirective",
  [u1]: "resolveFilter",
  [c1]: "withDirectives",
  [h1]: "renderList",
  [TX]: "renderSlot",
  [yX]: "createSlots",
  [KS]: "toDisplayString",
  [UE]: "mergeProps",
  [f1]: "normalizeClass",
  [d1]: "normalizeStyle",
  [Tg]: "normalizeProps",
  [Ev]: "guardReactiveProps",
  [p1]: "toHandlers",
  [m_]: "camelize",
  [qee]: "capitalize",
  [E_]: "toHandlerKey",
  [$E]: "setBlockTracking",
  [jee]: "pushScopeId",
  [Kee]: "popScopeId",
  [g1]: "withCtx",
  [Jee]: "unref",
  [ete]: "isRef",
  [v1]: "withMemo",
  [RX]: "isMemoSame"
};
function tte(r) {
  Object.getOwnPropertySymbols(r).forEach((e) => {
    yf[e] = r[e];
  });
}
const _n = {
  source: "",
  start: { line: 1, column: 1, offset: 0 },
  end: { line: 1, column: 1, offset: 0 }
};
function rte(r, e = _n) {
  return {
    type: 0,
    children: r,
    helpers: /* @__PURE__ */ new Set(),
    components: [],
    directives: [],
    hoists: [],
    imports: [],
    cached: 0,
    temps: 0,
    codegenNode: void 0,
    loc: e
  };
}
function yg(r, e, t, i, n, a, o, s = !1, l = !1, u = !1, c = _n) {
  return r && (s ? (r.helper(Ac), r.helper(_f(r.inSSR, u))) : r.helper(Af(r.inSSR, u)), o && r.helper(c1)), {
    type: 13,
    tag: e,
    props: t,
    children: i,
    patchFlag: n,
    dynamicProps: a,
    directives: o,
    isBlock: s,
    disableTracking: l,
    isComponent: u,
    loc: c
  };
}
function bv(r, e = _n) {
  return {
    type: 17,
    loc: e,
    elements: r
  };
}
function Wn(r, e = _n) {
  return {
    type: 15,
    loc: e,
    properties: r
  };
}
function lr(r, e) {
  return {
    type: 16,
    loc: _n,
    key: qe(r) ? vt(r, !0) : r,
    value: e
  };
}
function vt(r, e = !1, t = _n, i = 0) {
  return {
    type: 4,
    loc: t,
    content: r,
    isStatic: e,
    constType: e ? 3 : i
  };
}
function Aa(r, e = _n) {
  return {
    type: 8,
    loc: e,
    children: r
  };
}
function yr(r, e = [], t = _n) {
  return {
    type: 14,
    loc: t,
    callee: r,
    arguments: e
  };
}
function Rf(r, e = void 0, t = !1, i = !1, n = _n) {
  return {
    type: 18,
    params: r,
    returns: e,
    newline: t,
    isSlot: i,
    loc: n
  };
}
function b_(r, e, t, i = !0) {
  return {
    type: 19,
    test: r,
    consequent: e,
    alternate: t,
    newline: i,
    loc: _n
  };
}
function ite(r, e, t = !1) {
  return {
    type: 20,
    index: r,
    value: e,
    isVNode: t,
    loc: _n
  };
}
function nte(r) {
  return {
    type: 21,
    body: r,
    loc: _n
  };
}
function Af(r, e) {
  return r || e ? n1 : a1;
}
function _f(r, e) {
  return r || e ? EX : bX;
}
function O1(r, { helper: e, removeHelper: t, inSSR: i }) {
  r.isBlock || (r.isBlock = !0, t(Af(i, r.isComponent)), e(Ac), e(_f(i, r.isComponent)));
}
const ji = (r) => r.type === 4 && r.isStatic, Xu = (r, e) => r === e || r === Li(e);
function AX(r) {
  if (Xu(r, "Teleport"))
    return Gp;
  if (Xu(r, "Suspense"))
    return i1;
  if (Xu(r, "KeepAlive"))
    return kE;
  if (Xu(r, "BaseTransition"))
    return mX;
}
const ate = /^\d|[^\$\w]/, m1 = (r) => !ate.test(r), ote = /[A-Za-z_$\xA0-\uFFFF]/, ste = /[\.\?\w$\xA0-\uFFFF]/, lte = /\s+[.[]\s*|\s*[.[]\s+/g, ute = (r) => {
  r = r.trim().replace(lte, (o) => o.trim());
  let e = 0, t = [], i = 0, n = 0, a = null;
  for (let o = 0; o < r.length; o++) {
    const s = r.charAt(o);
    switch (e) {
      case 0:
        if (s === "[")
          t.push(e), e = 1, i++;
        else if (s === "(")
          t.push(e), e = 2, n++;
        else if (!(o === 0 ? ote : ste).test(s))
          return !1;
        break;
      case 1:
        s === "'" || s === '"' || s === "`" ? (t.push(e), e = 3, a = s) : s === "[" ? i++ : s === "]" && (--i || (e = t.pop()));
        break;
      case 2:
        if (s === "'" || s === '"' || s === "`")
          t.push(e), e = 3, a = s;
        else if (s === "(")
          n++;
        else if (s === ")") {
          if (o === r.length - 1)
            return !1;
          --n || (e = t.pop());
        }
        break;
      case 3:
        s === a && (e = t.pop(), a = null);
        break;
    }
  }
  return !i && !n;
}, _X = ute;
function CX(r, e, t) {
  const n = {
    source: r.source.slice(e, e + t),
    start: VE(r.start, r.source, e),
    end: r.end
  };
  return t != null && (n.end = VE(
    r.start,
    r.source,
    e + t
  )), n;
}
function VE(r, e, t = e.length) {
  return GE(
    ut({}, r),
    e,
    t
  );
}
function GE(r, e, t = e.length) {
  let i = 0, n = -1;
  for (let a = 0; a < t; a++)
    e.charCodeAt(a) === 10 && (i++, n = a);
  return r.offset += t, r.line += i, r.column = n === -1 ? r.column + t : t - n, r;
}
function XL(r, e) {
  if (!r)
    throw new Error(e || "unexpected compiler condition");
}
function Vn(r, e, t = !1) {
  for (let i = 0; i < r.props.length; i++) {
    const n = r.props[i];
    if (n.type === 7 && (t || n.exp) && (qe(e) ? n.name === e : e.test(n.name)))
      return n;
  }
}
function Cf(r, e, t = !1, i = !1) {
  for (let n = 0; n < r.props.length; n++) {
    const a = r.props[n];
    if (a.type === 6) {
      if (t)
        continue;
      if (a.name === e && (a.value || i))
        return a;
    } else if (a.name === "bind" && (a.exp || i) && Yu(a.arg, e))
      return a;
  }
}
function Yu(r, e) {
  return !!(r && ji(r) && r.content === e);
}
function cte(r) {
  return r.props.some(
    (e) => e.type === 7 && e.name === "bind" && (!e.arg || // v-bind="obj"
    e.arg.type !== 4 || // v-bind:[_ctx.foo]
    !e.arg.isStatic)
    // v-bind:[foo]
  );
}
function Ny(r) {
  return r.type === 5 || r.type === 2;
}
function hte(r) {
  return r.type === 7 && r.name === "slot";
}
function BE(r) {
  return r.type === 1 && r.tagType === 3;
}
function FE(r) {
  return r.type === 1 && r.tagType === 2;
}
const fte = /* @__PURE__ */ new Set([Tg, Ev]);
function IX(r, e = []) {
  if (r && !qe(r) && r.type === 14) {
    const t = r.callee;
    if (!qe(t) && fte.has(t))
      return IX(
        r.arguments[0],
        e.concat(r)
      );
  }
  return [r, e];
}
function XE(r, e, t) {
  let i, n = r.type === 13 ? r.props : r.arguments[2], a = [], o;
  if (n && !qe(n) && n.type === 14) {
    const s = IX(n);
    n = s[0], a = s[1], o = a[a.length - 1];
  }
  if (n == null || qe(n))
    i = Wn([e]);
  else if (n.type === 14) {
    const s = n.arguments[0];
    !qe(s) && s.type === 15 ? YL(e, s) || s.properties.unshift(e) : n.callee === p1 ? i = yr(t.helper(UE), [
      Wn([e]),
      n
    ]) : n.arguments.unshift(Wn([e])), !i && (i = n);
  } else
    n.type === 15 ? (YL(e, n) || n.properties.unshift(e), i = n) : (i = yr(t.helper(UE), [
      Wn([e]),
      n
    ]), o && o.callee === Ev && (o = a[a.length - 2]));
  r.type === 13 ? o ? o.arguments[0] = i : r.props = i : o ? o.arguments[0] = i : r.arguments[2] = i;
}
function YL(r, e) {
  let t = !1;
  if (r.key.type === 4) {
    const i = r.key.content;
    t = e.properties.some(
      (n) => n.key.type === 4 && n.key.content === i
    );
  }
  return t;
}
function Rg(r, e) {
  return `_${e}_${r.replace(/[^\w]/g, (t, i) => t === "-" ? "_" : r.charCodeAt(i).toString())}`;
}
function dte(r) {
  return r.type === 14 && r.callee === v1 ? r.arguments[1].returns : r;
}
const pte = {
  COMPILER_IS_ON_ELEMENT: {
    message: 'Platform-native elements with "is" prop will no longer be treated as components in Vue 3 unless the "is" value is explicitly prefixed with "vue:".',
    link: "https://v3-migration.vuejs.org/breaking-changes/custom-elements-interop.html"
  },
  COMPILER_V_BIND_SYNC: {
    message: (r) => `.sync modifier for v-bind has been removed. Use v-model with argument instead. \`v-bind:${r}.sync\` should be changed to \`v-model:${r}\`.`,
    link: "https://v3-migration.vuejs.org/breaking-changes/v-model.html"
  },
  COMPILER_V_BIND_PROP: {
    message: ".prop modifier for v-bind has been removed and no longer necessary. Vue 3 will automatically set a binding as DOM property when appropriate."
  },
  COMPILER_V_BIND_OBJECT_ORDER: {
    message: 'v-bind="obj" usage is now order sensitive and behaves like JavaScript object spread: it will now overwrite an existing non-mergeable attribute that appears before v-bind in the case of conflict. To retain 2.x behavior, move v-bind to make it the first attribute. You can also suppress this warning if the usage is intended.',
    link: "https://v3-migration.vuejs.org/breaking-changes/v-bind.html"
  },
  COMPILER_V_ON_NATIVE: {
    message: ".native modifier for v-on has been removed as is no longer necessary.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-on-native-modifier-removed.html"
  },
  COMPILER_V_IF_V_FOR_PRECEDENCE: {
    message: "v-if / v-for precedence when used on the same element has changed in Vue 3: v-if now takes higher precedence and will no longer have access to v-for scope variables. It is best to avoid the ambiguity with <template> tags or use a computed property that filters v-for data source.",
    link: "https://v3-migration.vuejs.org/breaking-changes/v-if-v-for.html"
  },
  COMPILER_NATIVE_TEMPLATE: {
    message: "<template> with no special directives will render as a native template element instead of its inner content in Vue 3."
  },
  COMPILER_INLINE_TEMPLATE: {
    message: '"inline-template" has been removed in Vue 3.',
    link: "https://v3-migration.vuejs.org/breaking-changes/inline-template-attribute.html"
  },
  COMPILER_FILTER: {
    message: 'filters have been removed in Vue 3. The "|" symbol will be treated as native JavaScript bitwise OR operator. Use method calls or computed properties instead.',
    link: "https://v3-migration.vuejs.org/breaking-changes/filters.html"
  }
};
function S_(r, e) {
  const t = e.options ? e.options.compatConfig : e.compatConfig, i = t && t[r];
  return r === "MODE" ? i || 3 : i;
}
function dl(r, e) {
  const t = S_("MODE", e), i = S_(r, e);
  return t === 3 ? i === !0 : i !== !1;
}
function _c(r, e, t, ...i) {
  const n = dl(r, e);
  return {}.NODE_ENV !== "production" && n && JS(r, e, t, ...i), n;
}
function JS(r, e, t, ...i) {
  if (S_(r, e) === "suppress-warning")
    return;
  const { message: a, link: o } = pte[r], s = `(deprecation ${r}) ${typeof a == "function" ? a(...i) : a}${o ? `
  Details: ${o}` : ""}`, l = new SyntaxError(s);
  l.code = r, t && (l.loc = t), e.onWarn(l);
}
const gte = /&(gt|lt|amp|apos|quot);/g, vte = {
  gt: ">",
  lt: "<",
  amp: "&",
  apos: "'",
  quot: '"'
}, HL = {
  delimiters: ["{{", "}}"],
  getNamespace: () => 0,
  getTextMode: () => 0,
  isVoidTag: xp,
  isPreTag: xp,
  isCustomElement: xp,
  decodeEntities: (r) => r.replace(gte, (e, t) => vte[t]),
  onError: r1,
  onWarn: OX,
  comments: {}.NODE_ENV !== "production"
};
function Ote(r, e = {}) {
  const t = mte(r, e), i = bn(t);
  return rte(
    E1(t, 0, []),
    yn(t, i)
  );
}
function mte(r, e) {
  const t = ut({}, HL);
  let i;
  for (i in e)
    t[i] = e[i] === void 0 ? HL[i] : e[i];
  return {
    options: t,
    column: 1,
    line: 1,
    offset: 0,
    originalSource: r,
    source: r,
    inPre: !1,
    inVPre: !1,
    onWarn: t.onWarn
  };
}
function E1(r, e, t) {
  const i = eT(t), n = i ? i.ns : 0, a = [];
  for (; !Cte(r, e, t); ) {
    const s = r.source;
    let l;
    if (e === 0 || e === 1) {
      if (!r.inVPre && gi(s, r.options.delimiters[0]))
        l = Ate(r, e);
      else if (e === 0 && s[0] === "<")
        if (s.length === 1)
          Dt(r, 5, 1);
        else if (s[1] === "!")
          gi(s, "<!--") ? l = bte(r) : gi(s, "<!DOCTYPE") ? l = Rd(r) : gi(s, "<![CDATA[") ? n !== 0 ? l = Ete(r, t) : (Dt(r, 1), l = Rd(r)) : (Dt(r, 11), l = Rd(r));
        else if (s[1] === "/")
          if (s.length === 2)
            Dt(r, 5, 2);
          else if (s[2] === ">") {
            Dt(r, 14, 2), Mr(r, 3);
            continue;
          } else if (/[a-z]/i.test(s[2])) {
            Dt(r, 23), T_(r, YE.End, i);
            continue;
          } else
            Dt(
              r,
              12,
              2
            ), l = Rd(r);
        else
          /[a-z]/i.test(s[1]) ? (l = Ste(r, t), dl(
            "COMPILER_NATIVE_TEMPLATE",
            r
          ) && l && l.tag === "template" && !l.props.some(
            (u) => u.type === 7 && wX(u.name)
          ) && ({}.NODE_ENV !== "production" && JS(
            "COMPILER_NATIVE_TEMPLATE",
            r,
            l.loc
          ), l = l.children)) : s[1] === "?" ? (Dt(
            r,
            21,
            1
          ), l = Rd(r)) : Dt(r, 12, 1);
    }
    if (l || (l = _te(r, e)), pe(l))
      for (let u = 0; u < l.length; u++)
        WL(a, l[u]);
    else
      WL(a, l);
  }
  let o = !1;
  if (e !== 2 && e !== 1) {
    const s = r.options.whitespace !== "preserve";
    for (let l = 0; l < a.length; l++) {
      const u = a[l];
      if (u.type === 2)
        if (r.inPre)
          u.content = u.content.replace(/\r\n/g, `
`);
        else if (/[^\t\r\n\f ]/.test(u.content))
          s && (u.content = u.content.replace(/[\t\r\n\f ]+/g, " "));
        else {
          const c = a[l - 1], h = a[l + 1];
          !c || !h || s && (c.type === 3 && h.type === 3 || c.type === 3 && h.type === 1 || c.type === 1 && h.type === 3 || c.type === 1 && h.type === 1 && /[\r\n]/.test(u.content)) ? (o = !0, a[l] = null) : u.content = " ";
        }
      else
        u.type === 3 && !r.options.comments && (o = !0, a[l] = null);
    }
    if (r.inPre && i && r.options.isPreTag(i.tag)) {
      const l = a[0];
      l && l.type === 2 && (l.content = l.content.replace(/^\r?\n/, ""));
    }
  }
  return o ? a.filter(Boolean) : a;
}
function WL(r, e) {
  if (e.type === 2) {
    const t = eT(r);
    if (t && t.type === 2 && t.loc.end.offset === e.loc.start.offset) {
      t.content += e.content, t.loc.end = e.loc.end, t.loc.source += e.loc.source;
      return;
    }
  }
  r.push(e);
}
function Ete(r, e) {
  Mr(r, 9);
  const t = E1(r, 3, e);
  return r.source.length === 0 ? Dt(r, 6) : Mr(r, 3), t;
}
function bte(r) {
  const e = bn(r);
  let t;
  const i = /--(\!)?>/.exec(r.source);
  if (!i)
    t = r.source.slice(4), Mr(r, r.source.length), Dt(r, 7);
  else {
    i.index <= 3 && Dt(r, 0), i[1] && Dt(r, 10), t = r.source.slice(4, i.index);
    const n = r.source.slice(0, i.index);
    let a = 1, o = 0;
    for (; (o = n.indexOf("<!--", a)) !== -1; )
      Mr(r, o - a + 1), o + 4 < n.length && Dt(r, 16), a = o + 1;
    Mr(r, i.index + i[0].length - a + 1);
  }
  return {
    type: 3,
    content: t,
    loc: yn(r, e)
  };
}
function Rd(r) {
  const e = bn(r), t = r.source[1] === "?" ? 1 : 2;
  let i;
  const n = r.source.indexOf(">");
  return n === -1 ? (i = r.source.slice(t), Mr(r, r.source.length)) : (i = r.source.slice(t, n), Mr(r, n + 1)), {
    type: 3,
    content: i,
    loc: yn(r, e)
  };
}
function Ste(r, e) {
  const t = r.inPre, i = r.inVPre, n = eT(e), a = T_(r, YE.Start, n), o = r.inPre && !t, s = r.inVPre && !i;
  if (a.isSelfClosing || r.options.isVoidTag(a.tag))
    return o && (r.inPre = !1), s && (r.inVPre = !1), a;
  e.push(a);
  const l = r.options.getTextMode(a, n), u = E1(r, l, e);
  e.pop();
  {
    const c = a.props.find(
      (h) => h.type === 6 && h.name === "inline-template"
    );
    if (c && _c(
      "COMPILER_INLINE_TEMPLATE",
      r,
      c.loc
    )) {
      const h = yn(r, a.loc.end);
      c.value = {
        type: 2,
        content: h.source,
        loc: h
      };
    }
  }
  if (a.children = u, y_(r.source, a.tag))
    T_(r, YE.End, n);
  else if (Dt(r, 24, 0, a.loc.start), r.source.length === 0 && a.tag.toLowerCase() === "script") {
    const c = u[0];
    c && gi(c.loc.source, "<!--") && Dt(r, 8);
  }
  return a.loc = yn(r, a.loc.start), o && (r.inPre = !1), s && (r.inVPre = !1), a;
}
var YE = /* @__PURE__ */ ((r) => (r[r.Start = 0] = "Start", r[r.End = 1] = "End", r))(YE || {});
const wX = /* @__PURE__ */ bi(
  "if,else,else-if,for,slot"
);
function T_(r, e, t) {
  const i = bn(r), n = /^<\/?([a-z][^\t\r\n\f />]*)/i.exec(r.source), a = n[1], o = r.options.getNamespace(a, t);
  Mr(r, n[0].length), Ag(r);
  const s = bn(r), l = r.source;
  r.options.isPreTag(a) && (r.inPre = !0);
  let u = zL(r, e);
  e === 0 && !r.inVPre && u.some((f) => f.type === 7 && f.name === "pre") && (r.inVPre = !0, ut(r, s), r.source = l, u = zL(r, e).filter((f) => f.name !== "v-pre"));
  let c = !1;
  if (r.source.length === 0 ? Dt(r, 9) : (c = gi(r.source, "/>"), e === 1 && c && Dt(r, 4), Mr(r, c ? 2 : 1)), e === 1)
    return;
  if ({}.NODE_ENV !== "production" && dl(
    "COMPILER_V_IF_V_FOR_PRECEDENCE",
    r
  )) {
    let f = !1, d = !1;
    for (let p = 0; p < u.length; p++) {
      const g = u[p];
      if (g.type === 7 && (g.name === "if" ? f = !0 : g.name === "for" && (d = !0)), f && d) {
        JS(
          "COMPILER_V_IF_V_FOR_PRECEDENCE",
          r,
          yn(r, i)
        );
        break;
      }
    }
  }
  let h = 0;
  return r.inVPre || (a === "slot" ? h = 2 : a === "template" ? u.some(
    (f) => f.type === 7 && wX(f.name)
  ) && (h = 3) : Tte(a, u, r) && (h = 1)), {
    type: 1,
    ns: o,
    tag: a,
    tagType: h,
    props: u,
    isSelfClosing: c,
    children: [],
    loc: yn(r, i),
    codegenNode: void 0
    // to be created during transform phase
  };
}
function Tte(r, e, t) {
  const i = t.options;
  if (i.isCustomElement(r))
    return !1;
  if (r === "component" || /^[A-Z]/.test(r) || AX(r) || i.isBuiltInComponent && i.isBuiltInComponent(r) || i.isNativeTag && !i.isNativeTag(r))
    return !0;
  for (let n = 0; n < e.length; n++) {
    const a = e[n];
    if (a.type === 6) {
      if (a.name === "is" && a.value) {
        if (a.value.content.startsWith("vue:"))
          return !0;
        if (_c(
          "COMPILER_IS_ON_ELEMENT",
          t,
          a.loc
        ))
          return !0;
      }
    } else {
      if (a.name === "is")
        return !0;
      if (
        // :is on plain element - only treat as component in compat mode
        a.name === "bind" && Yu(a.arg, "is") && _c(
          "COMPILER_IS_ON_ELEMENT",
          t,
          a.loc
        )
      )
        return !0;
    }
  }
}
function zL(r, e) {
  const t = [], i = /* @__PURE__ */ new Set();
  for (; r.source.length > 0 && !gi(r.source, ">") && !gi(r.source, "/>"); ) {
    if (gi(r.source, "/")) {
      Dt(r, 22), Mr(r, 1), Ag(r);
      continue;
    }
    e === 1 && Dt(r, 3);
    const n = yte(r, i);
    n.type === 6 && n.value && n.name === "class" && (n.value.content = n.value.content.replace(/\s+/g, " ").trim()), e === 0 && t.push(n), /^[^\t\r\n\f />]/.test(r.source) && Dt(r, 15), Ag(r);
  }
  return t;
}
function yte(r, e) {
  var t;
  const i = bn(r), a = /^[^\t\r\n\f />][^\t\r\n\f />=]*/.exec(r.source)[0];
  e.has(a) && Dt(r, 2), e.add(a), a[0] === "=" && Dt(r, 19);
  {
    const l = /["'<]/g;
    let u;
    for (; u = l.exec(a); )
      Dt(
        r,
        17,
        u.index
      );
  }
  Mr(r, a.length);
  let o;
  /^[\t\r\n\f ]*=/.test(r.source) && (Ag(r), Mr(r, 1), Ag(r), o = Rte(r), o || Dt(r, 13));
  const s = yn(r, i);
  if (!r.inVPre && /^(v-[A-Za-z0-9-]|:|\.|@|#)/.test(a)) {
    const l = /(?:^v-([a-z0-9-]+))?(?:(?::|^\.|^@|^#)(\[[^\]]+\]|[^\.]+))?(.+)?$/i.exec(
      a
    );
    let u = gi(a, "."), c = l[1] || (u || gi(a, ":") ? "bind" : gi(a, "@") ? "on" : "slot"), h;
    if (l[2]) {
      const d = c === "slot", p = a.lastIndexOf(
        l[2],
        a.length - (((t = l[3]) == null ? void 0 : t.length) || 0)
      ), g = yn(
        r,
        ZL(r, i, p),
        ZL(
          r,
          i,
          p + l[2].length + (d && l[3] || "").length
        )
      );
      let v = l[2], O = !0;
      v.startsWith("[") ? (O = !1, v.endsWith("]") ? v = v.slice(1, v.length - 1) : (Dt(
        r,
        27
      ), v = v.slice(1))) : d && (v += l[3] || ""), h = {
        type: 4,
        content: v,
        isStatic: O,
        constType: O ? 3 : 0,
        loc: g
      };
    }
    if (o && o.isQuoted) {
      const d = o.loc;
      d.start.offset++, d.start.column++, d.end = VE(d.start, o.content), d.source = d.source.slice(1, -1);
    }
    const f = l[3] ? l[3].slice(1).split(".") : [];
    return u && f.push("prop"), c === "bind" && h && (f.includes("sync") && _c(
      "COMPILER_V_BIND_SYNC",
      r,
      s,
      h.loc.source
    ) && (c = "model", f.splice(f.indexOf("sync"), 1)), {}.NODE_ENV !== "production" && f.includes("prop") && _c(
      "COMPILER_V_BIND_PROP",
      r,
      s
    )), {
      type: 7,
      name: c,
      exp: o && {
        type: 4,
        content: o.content,
        isStatic: !1,
        // Treat as non-constant by default. This can be potentially set to
        // other values by `transformExpression` to make it eligible for hoisting.
        constType: 0,
        loc: o.loc
      },
      arg: h,
      modifiers: f,
      loc: s
    };
  }
  return !r.inVPre && gi(a, "v-") && Dt(r, 26), {
    type: 6,
    name: a,
    value: o && {
      type: 2,
      content: o.content,
      loc: o.loc
    },
    loc: s
  };
}
function Rte(r) {
  const e = bn(r);
  let t;
  const i = r.source[0], n = i === '"' || i === "'";
  if (n) {
    Mr(r, 1);
    const a = r.source.indexOf(i);
    a === -1 ? t = Bp(
      r,
      r.source.length,
      4
    ) : (t = Bp(r, a, 4), Mr(r, 1));
  } else {
    const a = /^[^\t\r\n\f >]+/.exec(r.source);
    if (!a)
      return;
    const o = /["'<=`]/g;
    let s;
    for (; s = o.exec(a[0]); )
      Dt(
        r,
        18,
        s.index
      );
    t = Bp(r, a[0].length, 4);
  }
  return { content: t, isQuoted: n, loc: yn(r, e) };
}
function Ate(r, e) {
  const [t, i] = r.options.delimiters, n = r.source.indexOf(i, t.length);
  if (n === -1) {
    Dt(r, 25);
    return;
  }
  const a = bn(r);
  Mr(r, t.length);
  const o = bn(r), s = bn(r), l = n - t.length, u = r.source.slice(0, l), c = Bp(r, l, e), h = c.trim(), f = c.indexOf(h);
  f > 0 && GE(o, u, f);
  const d = l - (c.length - h.length - f);
  return GE(s, u, d), Mr(r, i.length), {
    type: 5,
    content: {
      type: 4,
      isStatic: !1,
      // Set `isConstant` to false by default and will decide in transformExpression
      constType: 0,
      content: h,
      loc: yn(r, o, s)
    },
    loc: yn(r, a)
  };
}
function _te(r, e) {
  const t = e === 3 ? ["]]>"] : ["<", r.options.delimiters[0]];
  let i = r.source.length;
  for (let o = 0; o < t.length; o++) {
    const s = r.source.indexOf(t[o], 1);
    s !== -1 && i > s && (i = s);
  }
  const n = bn(r);
  return {
    type: 2,
    content: Bp(r, i, e),
    loc: yn(r, n)
  };
}
function Bp(r, e, t) {
  const i = r.source.slice(0, e);
  return Mr(r, e), t === 2 || t === 3 || !i.includes("&") ? i : r.options.decodeEntities(
    i,
    t === 4
  );
}
function bn(r) {
  const { column: e, line: t, offset: i } = r;
  return { column: e, line: t, offset: i };
}
function yn(r, e, t) {
  return t = t || bn(r), {
    start: e,
    end: t,
    source: r.originalSource.slice(e.offset, t.offset)
  };
}
function eT(r) {
  return r[r.length - 1];
}
function gi(r, e) {
  return r.startsWith(e);
}
function Mr(r, e) {
  const { source: t } = r;
  GE(r, t, e), r.source = t.slice(e);
}
function Ag(r) {
  const e = /^[\t\r\n\f ]+/.exec(r.source);
  e && Mr(r, e[0].length);
}
function ZL(r, e, t) {
  return VE(
    e,
    r.originalSource.slice(e.offset, t),
    t
  );
}
function Dt(r, e, t, i = bn(r)) {
  t && (i.offset += t, i.column += t), r.options.onError(
    Pt(e, {
      start: i,
      end: i,
      source: ""
    })
  );
}
function Cte(r, e, t) {
  const i = r.source;
  switch (e) {
    case 0:
      if (gi(i, "</")) {
        for (let n = t.length - 1; n >= 0; --n)
          if (y_(i, t[n].tag))
            return !0;
      }
      break;
    case 1:
    case 2: {
      const n = eT(t);
      if (n && y_(i, n.tag))
        return !0;
      break;
    }
    case 3:
      if (gi(i, "]]>"))
        return !0;
      break;
  }
  return !i;
}
function y_(r, e) {
  return gi(r, "</") && r.slice(2, 2 + e.length).toLowerCase() === e.toLowerCase() && /[\t\r\n\f />]/.test(r[2 + e.length] || ">");
}
function Ite(r, e) {
  Gm(
    r,
    e,
    // Root node is unfortunately non-hoistable due to potential parent
    // fallthrough attributes.
    NX(r, r.children[0])
  );
}
function NX(r, e) {
  const { children: t } = r;
  return t.length === 1 && e.type === 1 && !FE(e);
}
function Gm(r, e, t = !1) {
  const { children: i } = r, n = i.length;
  let a = 0;
  for (let o = 0; o < i.length; o++) {
    const s = i[o];
    if (s.type === 1 && s.tagType === 0) {
      const l = t ? 0 : zn(s, e);
      if (l > 0) {
        if (l >= 2) {
          s.codegenNode.patchFlag = -1 + ({}.NODE_ENV !== "production" ? " /* HOISTED */" : ""), s.codegenNode = e.hoist(s.codegenNode), a++;
          continue;
        }
      } else {
        const u = s.codegenNode;
        if (u.type === 13) {
          const c = DX(u);
          if ((!c || c === 512 || c === 1) && PX(s, e) >= 2) {
            const h = LX(s);
            h && (u.props = e.hoist(h));
          }
          u.dynamicProps && (u.dynamicProps = e.hoist(u.dynamicProps));
        }
      }
    }
    if (s.type === 1) {
      const l = s.tagType === 1;
      l && e.scopes.vSlot++, Gm(s, e), l && e.scopes.vSlot--;
    } else if (s.type === 11)
      Gm(s, e, s.children.length === 1);
    else if (s.type === 9)
      for (let l = 0; l < s.branches.length; l++)
        Gm(
          s.branches[l],
          e,
          s.branches[l].children.length === 1
        );
  }
  a && e.transformHoist && e.transformHoist(i, e, r), a && a === n && r.type === 1 && r.tagType === 0 && r.codegenNode && r.codegenNode.type === 13 && pe(r.codegenNode.children) && (r.codegenNode.children = e.hoist(
    bv(r.codegenNode.children)
  ));
}
function zn(r, e) {
  const { constantCache: t } = e;
  switch (r.type) {
    case 1:
      if (r.tagType !== 0)
        return 0;
      const i = t.get(r);
      if (i !== void 0)
        return i;
      const n = r.codegenNode;
      if (n.type !== 13 || n.isBlock && r.tag !== "svg" && r.tag !== "foreignObject")
        return 0;
      if (DX(n))
        return t.set(r, 0), 0;
      {
        let s = 3;
        const l = PX(r, e);
        if (l === 0)
          return t.set(r, 0), 0;
        l < s && (s = l);
        for (let u = 0; u < r.children.length; u++) {
          const c = zn(r.children[u], e);
          if (c === 0)
            return t.set(r, 0), 0;
          c < s && (s = c);
        }
        if (s > 1)
          for (let u = 0; u < r.props.length; u++) {
            const c = r.props[u];
            if (c.type === 7 && c.name === "bind" && c.exp) {
              const h = zn(c.exp, e);
              if (h === 0)
                return t.set(r, 0), 0;
              h < s && (s = h);
            }
          }
        if (n.isBlock) {
          for (let u = 0; u < r.props.length; u++)
            if (r.props[u].type === 7)
              return t.set(r, 0), 0;
          e.removeHelper(Ac), e.removeHelper(
            _f(e.inSSR, n.isComponent)
          ), n.isBlock = !1, e.helper(Af(e.inSSR, n.isComponent));
        }
        return t.set(r, s), s;
      }
    case 2:
    case 3:
      return 3;
    case 9:
    case 11:
    case 10:
      return 0;
    case 5:
    case 12:
      return zn(r.content, e);
    case 4:
      return r.constType;
    case 8:
      let o = 3;
      for (let s = 0; s < r.children.length; s++) {
        const l = r.children[s];
        if (qe(l) || Sl(l))
          continue;
        const u = zn(l, e);
        if (u === 0)
          return 0;
        u < o && (o = u);
      }
      return o;
    default:
      return 0;
  }
}
const wte = /* @__PURE__ */ new Set([
  f1,
  d1,
  Tg,
  Ev
]);
function xX(r, e) {
  if (r.type === 14 && !qe(r.callee) && wte.has(r.callee)) {
    const t = r.arguments[0];
    if (t.type === 4)
      return zn(t, e);
    if (t.type === 14)
      return xX(t, e);
  }
  return 0;
}
function PX(r, e) {
  let t = 3;
  const i = LX(r);
  if (i && i.type === 15) {
    const { properties: n } = i;
    for (let a = 0; a < n.length; a++) {
      const { key: o, value: s } = n[a], l = zn(o, e);
      if (l === 0)
        return l;
      l < t && (t = l);
      let u;
      if (s.type === 4 ? u = zn(s, e) : s.type === 14 ? u = xX(s, e) : u = 0, u === 0)
        return u;
      u < t && (t = u);
    }
  }
  return t;
}
function LX(r) {
  const e = r.codegenNode;
  if (e.type === 13)
    return e.props;
}
function DX(r) {
  const e = r.patchFlag;
  return e ? parseInt(e, 10) : void 0;
}
function Nte(r, {
  filename: e = "",
  prefixIdentifiers: t = !1,
  hoistStatic: i = !1,
  cacheHandlers: n = !1,
  nodeTransforms: a = [],
  directiveTransforms: o = {},
  transformHoist: s = null,
  isBuiltInComponent: l = dr,
  isCustomElement: u = dr,
  expressionPlugins: c = [],
  scopeId: h = null,
  slotted: f = !0,
  ssr: d = !1,
  inSSR: p = !1,
  ssrCssVars: g = "",
  bindingMetadata: v = _t,
  inline: O = !1,
  isTS: m = !1,
  onError: E = r1,
  onWarn: b = OX,
  compatConfig: S
}) {
  const T = e.replace(/\?.*$/, "").match(/([^/\\]+)\.\w+$/), y = {
    // options
    selfName: T && bo(Cr(T[1])),
    prefixIdentifiers: t,
    hoistStatic: i,
    cacheHandlers: n,
    nodeTransforms: a,
    directiveTransforms: o,
    transformHoist: s,
    isBuiltInComponent: l,
    isCustomElement: u,
    expressionPlugins: c,
    scopeId: h,
    slotted: f,
    ssr: d,
    inSSR: p,
    ssrCssVars: g,
    bindingMetadata: v,
    inline: O,
    isTS: m,
    onError: E,
    onWarn: b,
    compatConfig: S,
    // state
    root: r,
    helpers: /* @__PURE__ */ new Map(),
    components: /* @__PURE__ */ new Set(),
    directives: /* @__PURE__ */ new Set(),
    hoists: [],
    imports: [],
    constantCache: /* @__PURE__ */ new Map(),
    temps: 0,
    cached: 0,
    identifiers: /* @__PURE__ */ Object.create(null),
    scopes: {
      vFor: 0,
      vSlot: 0,
      vPre: 0,
      vOnce: 0
    },
    parent: null,
    currentNode: r,
    childIndex: 0,
    inVOnce: !1,
    // methods
    helper(R) {
      const _ = y.helpers.get(R) || 0;
      return y.helpers.set(R, _ + 1), R;
    },
    removeHelper(R) {
      const _ = y.helpers.get(R);
      if (_) {
        const C = _ - 1;
        C ? y.helpers.set(R, C) : y.helpers.delete(R);
      }
    },
    helperString(R) {
      return `_${yf[y.helper(R)]}`;
    },
    replaceNode(R) {
      if ({}.NODE_ENV !== "production") {
        if (!y.currentNode)
          throw new Error("Node being replaced is already removed.");
        if (!y.parent)
          throw new Error("Cannot replace root node.");
      }
      y.parent.children[y.childIndex] = y.currentNode = R;
    },
    removeNode(R) {
      if ({}.NODE_ENV !== "production" && !y.parent)
        throw new Error("Cannot remove root node.");
      const _ = y.parent.children, C = R ? _.indexOf(R) : y.currentNode ? y.childIndex : -1;
      if ({}.NODE_ENV !== "production" && C < 0)
        throw new Error("node being removed is not a child of current parent");
      !R || R === y.currentNode ? (y.currentNode = null, y.onNodeRemoved()) : y.childIndex > C && (y.childIndex--, y.onNodeRemoved()), y.parent.children.splice(C, 1);
    },
    onNodeRemoved: () => {
    },
    addIdentifiers(R) {
    },
    removeIdentifiers(R) {
    },
    hoist(R) {
      qe(R) && (R = vt(R)), y.hoists.push(R);
      const _ = vt(
        `_hoisted_${y.hoists.length}`,
        !1,
        R.loc,
        2
      );
      return _.hoisted = R, _;
    },
    cache(R, _ = !1) {
      return ite(y.cached++, R, _);
    }
  };
  return y.filters = /* @__PURE__ */ new Set(), y;
}
function xte(r, e) {
  const t = Nte(r, e);
  tT(r, t), e.hoistStatic && Ite(r, t), e.ssr || Pte(r, t), r.helpers = /* @__PURE__ */ new Set([...t.helpers.keys()]), r.components = [...t.components], r.directives = [...t.directives], r.imports = t.imports, r.hoists = t.hoists, r.temps = t.temps, r.cached = t.cached, r.filters = [...t.filters];
}
function Pte(r, e) {
  const { helper: t } = e, { children: i } = r;
  if (i.length === 1) {
    const n = i[0];
    if (NX(r, n) && n.codegenNode) {
      const a = n.codegenNode;
      a.type === 13 && O1(a, e), r.codegenNode = a;
    } else
      r.codegenNode = n;
  } else if (i.length > 1) {
    let n = 64, a = po[64];
    ({}).NODE_ENV !== "production" && i.filter((o) => o.type !== 3).length === 1 && (n |= 2048, a += `, ${po[2048]}`), r.codegenNode = yg(
      e,
      t(Sg),
      void 0,
      r.children,
      n + ({}.NODE_ENV !== "production" ? ` /* ${a} */` : ""),
      void 0,
      void 0,
      !0,
      void 0,
      !1
      /* isComponent */
    );
  }
}
function Lte(r, e) {
  let t = 0;
  const i = () => {
    t--;
  };
  for (; t < r.children.length; t++) {
    const n = r.children[t];
    qe(n) || (e.parent = r, e.childIndex = t, e.onNodeRemoved = i, tT(n, e));
  }
}
function tT(r, e) {
  e.currentNode = r;
  const { nodeTransforms: t } = e, i = [];
  for (let a = 0; a < t.length; a++) {
    const o = t[a](r, e);
    if (o && (pe(o) ? i.push(...o) : i.push(o)), e.currentNode)
      r = e.currentNode;
    else
      return;
  }
  switch (r.type) {
    case 3:
      e.ssr || e.helper(mv);
      break;
    case 5:
      e.ssr || e.helper(KS);
      break;
    case 9:
      for (let a = 0; a < r.branches.length; a++)
        tT(r.branches[a], e);
      break;
    case 10:
    case 11:
    case 1:
    case 0:
      Lte(r, e);
      break;
  }
  e.currentNode = r;
  let n = i.length;
  for (; n--; )
    i[n]();
}
function MX(r, e) {
  const t = qe(r) ? (i) => i === r : (i) => r.test(i);
  return (i, n) => {
    if (i.type === 1) {
      const { props: a } = i;
      if (i.tagType === 3 && a.some(hte))
        return;
      const o = [];
      for (let s = 0; s < a.length; s++) {
        const l = a[s];
        if (l.type === 7 && t(l.name)) {
          a.splice(s, 1), s--;
          const u = e(i, l, n);
          u && o.push(u);
        }
      }
      return o;
    }
  };
}
const rT = "/*#__PURE__*/", kX = (r) => `${yf[r]}: _${yf[r]}`;
function qL(r, {
  mode: e = "function",
  prefixIdentifiers: t = e === "module",
  sourceMap: i = !1,
  filename: n = "template.vue.html",
  scopeId: a = null,
  optimizeImports: o = !1,
  runtimeGlobalName: s = "Vue",
  runtimeModuleName: l = "vue",
  ssrRuntimeModuleName: u = "vue/server-renderer",
  ssr: c = !1,
  isTS: h = !1,
  inSSR: f = !1
}) {
  const d = {
    mode: e,
    prefixIdentifiers: t,
    sourceMap: i,
    filename: n,
    scopeId: a,
    optimizeImports: o,
    runtimeGlobalName: s,
    runtimeModuleName: l,
    ssrRuntimeModuleName: u,
    ssr: c,
    isTS: h,
    inSSR: f,
    source: r.loc.source,
    code: "",
    column: 1,
    line: 1,
    offset: 0,
    indentLevel: 0,
    pure: !1,
    map: void 0,
    helper(g) {
      return `_${yf[g]}`;
    },
    push(g, v) {
      d.code += g;
    },
    indent() {
      p(++d.indentLevel);
    },
    deindent(g = !1) {
      g ? --d.indentLevel : p(--d.indentLevel);
    },
    newline() {
      p(d.indentLevel);
    }
  };
  function p(g) {
    d.push(`
` + "  ".repeat(g));
  }
  return d;
}
function Dte(r, e = {}) {
  const t = qL(r, e);
  e.onContextCreated && e.onContextCreated(t);
  const {
    mode: i,
    push: n,
    prefixIdentifiers: a,
    indent: o,
    deindent: s,
    newline: l,
    scopeId: u,
    ssr: c
  } = t, h = Array.from(r.helpers), f = h.length > 0, d = !a && i !== "module", p = !1, g = p ? qL(r, e) : t;
  Mte(r, g);
  const v = c ? "ssrRender" : "render", m = (c ? ["_ctx", "_push", "_parent", "_attrs"] : ["_ctx", "_cache"]).join(", ");
  if (n(`function ${v}(${m}) {`), o(), d && (n("with (_ctx) {"), o(), f && (n(`const { ${h.map(kX).join(", ")} } = _Vue`), n(`
`), l())), r.components.length && (xy(r.components, "component", t), (r.directives.length || r.temps > 0) && l()), r.directives.length && (xy(r.directives, "directive", t), r.temps > 0 && l()), r.filters && r.filters.length && (l(), xy(r.filters, "filter", t), l()), r.temps > 0) {
    n("let ");
    for (let E = 0; E < r.temps; E++)
      n(`${E > 0 ? ", " : ""}_temp${E}`);
  }
  return (r.components.length || r.directives.length || r.temps) && (n(`
`), l()), c || n("return "), r.codegenNode ? Oi(r.codegenNode, t) : n("null"), d && (s(), n("}")), s(), n("}"), {
    ast: r,
    code: t.code,
    preamble: p ? g.code : "",
    // SourceMapGenerator does have toJSON() method but it's not in the types
    map: t.map ? t.map.toJSON() : void 0
  };
}
function Mte(r, e) {
  const {
    ssr: t,
    prefixIdentifiers: i,
    push: n,
    newline: a,
    runtimeModuleName: o,
    runtimeGlobalName: s,
    ssrRuntimeModuleName: l
  } = e, u = s, c = Array.from(r.helpers);
  if (c.length > 0 && (n(`const _Vue = ${u}
`), r.hoists.length)) {
    const h = [
      n1,
      a1,
      mv,
      o1,
      SX
    ].filter((f) => c.includes(f)).map(kX).join(", ");
    n(`const { ${h} } = _Vue
`);
  }
  kte(r.hoists, e), a(), n("return ");
}
function xy(r, e, { helper: t, push: i, newline: n, isTS: a }) {
  const o = t(
    e === "filter" ? u1 : e === "component" ? s1 : l1
  );
  for (let s = 0; s < r.length; s++) {
    let l = r[s];
    const u = l.endsWith("__self");
    u && (l = l.slice(0, -6)), i(
      `const ${Rg(l, e)} = ${o}(${JSON.stringify(l)}${u ? ", true" : ""})${a ? "!" : ""}`
    ), s < r.length - 1 && n();
  }
}
function kte(r, e) {
  if (!r.length)
    return;
  e.pure = !0;
  const { push: t, newline: i, helper: n, scopeId: a, mode: o } = e;
  i();
  for (let s = 0; s < r.length; s++) {
    const l = r[s];
    l && (t(
      `const _hoisted_${s + 1} = `
    ), Oi(l, e), i());
  }
  e.pure = !1;
}
function Qte(r) {
  return qe(r) || r.type === 4 || r.type === 2 || r.type === 5 || r.type === 8;
}
function b1(r, e) {
  const t = r.length > 3 || {}.NODE_ENV !== "production" && r.some((i) => pe(i) || !Qte(i));
  e.push("["), t && e.indent(), Sv(r, e, t), t && e.deindent(), e.push("]");
}
function Sv(r, e, t = !1, i = !0) {
  const { push: n, newline: a } = e;
  for (let o = 0; o < r.length; o++) {
    const s = r[o];
    qe(s) ? n(s) : pe(s) ? b1(s, e) : Oi(s, e), o < r.length - 1 && (t ? (i && n(","), a()) : i && n(", "));
  }
}
function Oi(r, e) {
  if (qe(r)) {
    e.push(r);
    return;
  }
  if (Sl(r)) {
    e.push(e.helper(r));
    return;
  }
  switch (r.type) {
    case 1:
    case 9:
    case 11:
      ({}).NODE_ENV !== "production" && XL(
        r.codegenNode != null,
        "Codegen node is missing for element/if/for node. Apply appropriate transforms first."
      ), Oi(r.codegenNode, e);
      break;
    case 2:
      Ute(r, e);
      break;
    case 4:
      QX(r, e);
      break;
    case 5:
      $te(r, e);
      break;
    case 12:
      Oi(r.codegenNode, e);
      break;
    case 8:
      UX(r, e);
      break;
    case 3:
      Gte(r, e);
      break;
    case 13:
      Bte(r, e);
      break;
    case 14:
      Xte(r, e);
      break;
    case 15:
      Yte(r, e);
      break;
    case 17:
      Hte(r, e);
      break;
    case 18:
      Wte(r, e);
      break;
    case 19:
      zte(r, e);
      break;
    case 20:
      Zte(r, e);
      break;
    case 21:
      Sv(r.body, e, !0, !1);
      break;
    case 22:
      break;
    case 23:
      break;
    case 24:
      break;
    case 25:
      break;
    case 26:
      break;
    case 10:
      break;
    default:
      if ({}.NODE_ENV !== "production")
        return XL(!1, `unhandled codegen node type: ${r.type}`), r;
  }
}
function Ute(r, e) {
  e.push(JSON.stringify(r.content), r);
}
function QX(r, e) {
  const { content: t, isStatic: i } = r;
  e.push(i ? JSON.stringify(t) : t, r);
}
function $te(r, e) {
  const { push: t, helper: i, pure: n } = e;
  n && t(rT), t(`${i(KS)}(`), Oi(r.content, e), t(")");
}
function UX(r, e) {
  for (let t = 0; t < r.children.length; t++) {
    const i = r.children[t];
    qe(i) ? e.push(i) : Oi(i, e);
  }
}
function Vte(r, e) {
  const { push: t } = e;
  if (r.type === 8)
    t("["), UX(r, e), t("]");
  else if (r.isStatic) {
    const i = m1(r.content) ? r.content : JSON.stringify(r.content);
    t(i, r);
  } else
    t(`[${r.content}]`, r);
}
function Gte(r, e) {
  const { push: t, helper: i, pure: n } = e;
  n && t(rT), t(`${i(mv)}(${JSON.stringify(r.content)})`, r);
}
function Bte(r, e) {
  const { push: t, helper: i, pure: n } = e, {
    tag: a,
    props: o,
    children: s,
    patchFlag: l,
    dynamicProps: u,
    directives: c,
    isBlock: h,
    disableTracking: f,
    isComponent: d
  } = r;
  c && t(i(c1) + "("), h && t(`(${i(Ac)}(${f ? "true" : ""}), `), n && t(rT);
  const p = h ? _f(e.inSSR, d) : Af(e.inSSR, d);
  t(i(p) + "(", r), Sv(
    Fte([a, o, s, l, u]),
    e
  ), t(")"), h && t(")"), c && (t(", "), Oi(c, e), t(")"));
}
function Fte(r) {
  let e = r.length;
  for (; e-- && r[e] == null; )
    ;
  return r.slice(0, e + 1).map((t) => t || "null");
}
function Xte(r, e) {
  const { push: t, helper: i, pure: n } = e, a = qe(r.callee) ? r.callee : i(r.callee);
  n && t(rT), t(a + "(", r), Sv(r.arguments, e), t(")");
}
function Yte(r, e) {
  const { push: t, indent: i, deindent: n, newline: a } = e, { properties: o } = r;
  if (!o.length) {
    t("{}", r);
    return;
  }
  const s = o.length > 1 || {}.NODE_ENV !== "production" && o.some((l) => l.value.type !== 4);
  t(s ? "{" : "{ "), s && i();
  for (let l = 0; l < o.length; l++) {
    const { key: u, value: c } = o[l];
    Vte(u, e), t(": "), Oi(c, e), l < o.length - 1 && (t(","), a());
  }
  s && n(), t(s ? "}" : " }");
}
function Hte(r, e) {
  b1(r.elements, e);
}
function Wte(r, e) {
  const { push: t, indent: i, deindent: n } = e, { params: a, returns: o, body: s, newline: l, isSlot: u } = r;
  u && t(`_${yf[g1]}(`), t("(", r), pe(a) ? Sv(a, e) : a && Oi(a, e), t(") => "), (l || s) && (t("{"), i()), o ? (l && t("return "), pe(o) ? b1(o, e) : Oi(o, e)) : s && Oi(s, e), (l || s) && (n(), t("}")), u && (r.isNonScopedSlot && t(", undefined, true"), t(")"));
}
function zte(r, e) {
  const { test: t, consequent: i, alternate: n, newline: a } = r, { push: o, indent: s, deindent: l, newline: u } = e;
  if (t.type === 4) {
    const h = !m1(t.content);
    h && o("("), QX(t, e), h && o(")");
  } else
    o("("), Oi(t, e), o(")");
  a && s(), e.indentLevel++, a || o(" "), o("? "), Oi(i, e), e.indentLevel--, a && u(), a || o(" "), o(": ");
  const c = n.type === 19;
  c || e.indentLevel++, Oi(n, e), c || e.indentLevel--, a && l(
    !0
    /* without newline */
  );
}
function Zte(r, e) {
  const { push: t, helper: i, indent: n, deindent: a, newline: o } = e;
  t(`_cache[${r.index}] || (`), r.isVNode && (n(), t(`${i($E)}(-1),`), o()), t(`_cache[${r.index}] = `), Oi(r.value, e), r.isVNode && (t(","), o(), t(`${i($E)}(1),`), o(), t(`_cache[${r.index}]`), a()), t(")");
}
const qte = new RegExp(
  "\\b" + "arguments,await,break,case,catch,class,const,continue,debugger,default,delete,do,else,export,extends,finally,for,function,if,import,let,new,return,super,switch,throw,try,var,void,while,with,yield".split(",").join("\\b|\\b") + "\\b"
), jte = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;
function Hu(r, e, t = !1, i = !1) {
  const n = r.content;
  if (n.trim())
    try {
      new Function(
        i ? ` ${n} ` : `return ${t ? `(${n}) => {}` : `(${n})`}`
      );
    } catch (a) {
      let o = a.message;
      const s = n.replace(jte, "").match(qte);
      s && (o = `avoid using JavaScript keyword as property name: "${s[0]}"`), e.onError(
        Pt(
          45,
          r.loc,
          void 0,
          o
        )
      );
    }
}
const Kte = (r, e) => {
  if (r.type === 5)
    r.content = Py(
      r.content,
      e
    );
  else if (r.type === 1)
    for (let t = 0; t < r.props.length; t++) {
      const i = r.props[t];
      if (i.type === 7 && i.name !== "for") {
        const n = i.exp, a = i.arg;
        n && n.type === 4 && !(i.name === "on" && a) && (i.exp = Py(
          n,
          e,
          // slot args must be processed as function params
          i.name === "slot"
        )), a && a.type === 4 && !a.isStatic && (i.arg = Py(a, e));
      }
    }
};
function Py(r, e, t = !1, i = !1, n = Object.create(e.identifiers)) {
  return {}.NODE_ENV !== "production" && Hu(r, e, t, i), r;
}
const Jte = MX(
  /^(if|else|else-if)$/,
  (r, e, t) => ere(r, e, t, (i, n, a) => {
    const o = t.parent.children;
    let s = o.indexOf(i), l = 0;
    for (; s-- >= 0; ) {
      const u = o[s];
      u && u.type === 9 && (l += u.branches.length);
    }
    return () => {
      if (a)
        i.codegenNode = KL(
          n,
          l,
          t
        );
      else {
        const u = rre(i.codegenNode);
        u.alternate = KL(
          n,
          l + i.branches.length - 1,
          t
        );
      }
    };
  })
);
function ere(r, e, t, i) {
  if (e.name !== "else" && (!e.exp || !e.exp.content.trim())) {
    const n = e.exp ? e.exp.loc : r.loc;
    t.onError(
      Pt(28, e.loc)
    ), e.exp = vt("true", !1, n);
  }
  if ({}.NODE_ENV !== "production" && e.exp && Hu(e.exp, t), e.name === "if") {
    const n = jL(r, e), a = {
      type: 9,
      loc: r.loc,
      branches: [n]
    };
    if (t.replaceNode(a), i)
      return i(a, n, !0);
  } else {
    const n = t.parent.children, a = [];
    let o = n.indexOf(r);
    for (; o-- >= -1; ) {
      const s = n[o];
      if (s && s.type === 3) {
        t.removeNode(s), {}.NODE_ENV !== "production" && a.unshift(s);
        continue;
      }
      if (s && s.type === 2 && !s.content.trim().length) {
        t.removeNode(s);
        continue;
      }
      if (s && s.type === 9) {
        e.name === "else-if" && s.branches[s.branches.length - 1].condition === void 0 && t.onError(
          Pt(30, r.loc)
        ), t.removeNode();
        const l = jL(r, e);
        if ({}.NODE_ENV !== "production" && a.length && // #3619 ignore comments if the v-if is direct child of <transition>
        !(t.parent && t.parent.type === 1 && Xu(t.parent.tag, "transition")) && (l.children = [...a, ...l.children]), {}.NODE_ENV !== "production") {
          const c = l.userKey;
          c && s.branches.forEach(({ userKey: h }) => {
            tre(h, c) && t.onError(
              Pt(
                29,
                l.userKey.loc
              )
            );
          });
        }
        s.branches.push(l);
        const u = i && i(s, l, !1);
        tT(l, t), u && u(), t.currentNode = null;
      } else
        t.onError(
          Pt(30, r.loc)
        );
      break;
    }
  }
}
function jL(r, e) {
  const t = r.tagType === 3;
  return {
    type: 10,
    loc: r.loc,
    condition: e.name === "else" ? void 0 : e.exp,
    children: t && !Vn(r, "for") ? r.children : [r],
    userKey: Cf(r, "key"),
    isTemplateIf: t
  };
}
function KL(r, e, t) {
  return r.condition ? b_(
    r.condition,
    JL(r, e, t),
    // make sure to pass in asBlock: true so that the comment node call
    // closes the current block.
    yr(t.helper(mv), [
      {}.NODE_ENV !== "production" ? '"v-if"' : '""',
      "true"
    ])
  ) : JL(r, e, t);
}
function JL(r, e, t) {
  const { helper: i } = t, n = lr(
    "key",
    vt(
      `${e}`,
      !1,
      _n,
      2
    )
  ), { children: a } = r, o = a[0];
  if (a.length !== 1 || o.type !== 1)
    if (a.length === 1 && o.type === 11) {
      const l = o.codegenNode;
      return XE(l, n, t), l;
    } else {
      let l = 64, u = po[64];
      return {}.NODE_ENV !== "production" && !r.isTemplateIf && a.filter((c) => c.type !== 3).length === 1 && (l |= 2048, u += `, ${po[2048]}`), yg(
        t,
        i(Sg),
        Wn([n]),
        a,
        l + ({}.NODE_ENV !== "production" ? ` /* ${u} */` : ""),
        void 0,
        void 0,
        !0,
        !1,
        !1,
        r.loc
      );
    }
  else {
    const l = o.codegenNode, u = dte(l);
    return u.type === 13 && O1(u, t), XE(u, n, t), l;
  }
}
function tre(r, e) {
  if (!r || r.type !== e.type)
    return !1;
  if (r.type === 6) {
    if (r.value.content !== e.value.content)
      return !1;
  } else {
    const t = r.exp, i = e.exp;
    if (t.type !== i.type || t.type !== 4 || t.isStatic !== i.isStatic || t.content !== i.content)
      return !1;
  }
  return !0;
}
function rre(r) {
  for (; ; )
    if (r.type === 19)
      if (r.alternate.type === 19)
        r = r.alternate;
      else
        return r;
    else
      r.type === 20 && (r = r.value);
}
const ire = MX(
  "for",
  (r, e, t) => {
    const { helper: i, removeHelper: n } = t;
    return nre(r, e, t, (a) => {
      const o = yr(i(h1), [
        a.source
      ]), s = BE(r), l = Vn(r, "memo"), u = Cf(r, "key"), c = u && (u.type === 6 ? vt(u.value.content, !0) : u.exp), h = u ? lr("key", c) : null, f = a.source.type === 4 && a.source.constType > 0, d = f ? 64 : u ? 128 : 256;
      return a.codegenNode = yg(
        t,
        i(Sg),
        void 0,
        o,
        d + ({}.NODE_ENV !== "production" ? ` /* ${po[d]} */` : ""),
        void 0,
        void 0,
        !0,
        !f,
        !1,
        r.loc
      ), () => {
        let p;
        const { children: g } = a;
        ({}).NODE_ENV !== "production" && s && r.children.some((m) => {
          if (m.type === 1) {
            const E = Cf(m, "key");
            if (E)
              return t.onError(
                Pt(
                  33,
                  E.loc
                )
              ), !0;
          }
        });
        const v = g.length !== 1 || g[0].type !== 1, O = FE(r) ? r : s && r.children.length === 1 && FE(r.children[0]) ? r.children[0] : null;
        if (O ? (p = O.codegenNode, s && h && XE(p, h, t)) : v ? p = yg(
          t,
          i(Sg),
          h ? Wn([h]) : void 0,
          r.children,
          64 + ({}.NODE_ENV !== "production" ? ` /* ${po[64]} */` : ""),
          void 0,
          void 0,
          !0,
          void 0,
          !1
          /* isComponent */
        ) : (p = g[0].codegenNode, s && h && XE(p, h, t), p.isBlock !== !f && (p.isBlock ? (n(Ac), n(
          _f(t.inSSR, p.isComponent)
        )) : n(
          Af(t.inSSR, p.isComponent)
        )), p.isBlock = !f, p.isBlock ? (i(Ac), i(_f(t.inSSR, p.isComponent))) : i(Af(t.inSSR, p.isComponent))), l) {
          const m = Rf(
            R_(a.parseResult, [
              vt("_cached")
            ])
          );
          m.body = nte([
            Aa(["const _memo = (", l.exp, ")"]),
            Aa([
              "if (_cached",
              ...c ? [" && _cached.key === ", c] : [],
              ` && ${t.helperString(
                RX
              )}(_cached, _memo)) return _cached`
            ]),
            Aa(["const _item = ", p]),
            vt("_item.memo = _memo"),
            vt("return _item")
          ]), o.arguments.push(
            m,
            vt("_cache"),
            vt(String(t.cached++))
          );
        } else
          o.arguments.push(
            Rf(
              R_(a.parseResult),
              p,
              !0
              /* force newline */
            )
          );
      };
    });
  }
);
function nre(r, e, t, i) {
  if (!e.exp) {
    t.onError(
      Pt(31, e.loc)
    );
    return;
  }
  const n = $X(
    // can only be simple expression because vFor transform is applied
    // before expression transform.
    e.exp,
    t
  );
  if (!n) {
    t.onError(
      Pt(32, e.loc)
    );
    return;
  }
  const { addIdentifiers: a, removeIdentifiers: o, scopes: s } = t, { source: l, value: u, key: c, index: h } = n, f = {
    type: 11,
    loc: e.loc,
    source: l,
    valueAlias: u,
    keyAlias: c,
    objectIndexAlias: h,
    parseResult: n,
    children: BE(r) ? r.children : [r]
  };
  t.replaceNode(f), s.vFor++;
  const d = i && i(f);
  return () => {
    s.vFor--, d && d();
  };
}
const are = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/, eD = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/, ore = /^\(|\)$/g;
function $X(r, e) {
  const t = r.loc, i = r.content, n = i.match(are);
  if (!n)
    return;
  const [, a, o] = n, s = {
    source: cO(
      t,
      o.trim(),
      i.indexOf(o, a.length)
    ),
    value: void 0,
    key: void 0,
    index: void 0
  };
  ({}).NODE_ENV !== "production" && Hu(s.source, e);
  let l = a.trim().replace(ore, "").trim();
  const u = a.indexOf(l), c = l.match(eD);
  if (c) {
    l = l.replace(eD, "").trim();
    const h = c[1].trim();
    let f;
    if (h && (f = i.indexOf(h, u + l.length), s.key = cO(t, h, f), {}.NODE_ENV !== "production" && Hu(
      s.key,
      e,
      !0
    )), c[2]) {
      const d = c[2].trim();
      d && (s.index = cO(
        t,
        d,
        i.indexOf(
          d,
          s.key ? f + h.length : u + l.length
        )
      ), {}.NODE_ENV !== "production" && Hu(
        s.index,
        e,
        !0
      ));
    }
  }
  return l && (s.value = cO(t, l, u), {}.NODE_ENV !== "production" && Hu(
    s.value,
    e,
    !0
  )), s;
}
function cO(r, e, t) {
  return vt(
    e,
    !1,
    CX(r, t, e.length)
  );
}
function R_({ value: r, key: e, index: t }, i = []) {
  return sre([r, e, t, ...i]);
}
function sre(r) {
  let e = r.length;
  for (; e-- && !r[e]; )
    ;
  return r.slice(0, e + 1).map((t, i) => t || vt("_".repeat(i + 1), !1));
}
const tD = vt("undefined", !1), lre = (r, e) => {
  if (r.type === 1 && (r.tagType === 1 || r.tagType === 3)) {
    const t = Vn(r, "slot");
    if (t)
      return t.exp, e.scopes.vSlot++, () => {
        e.scopes.vSlot--;
      };
  }
}, ure = (r, e, t) => Rf(
  r,
  e,
  !1,
  !0,
  e.length ? e[0].loc : t
);
function cre(r, e, t = ure) {
  e.helper(g1);
  const { children: i, loc: n } = r, a = [], o = [];
  let s = e.scopes.vSlot > 0 || e.scopes.vFor > 0;
  const l = Vn(r, "slot", !0);
  if (l) {
    const { arg: v, exp: O } = l;
    v && !ji(v) && (s = !0), a.push(
      lr(
        v || vt("default", !0),
        t(O, i, n)
      )
    );
  }
  let u = !1, c = !1;
  const h = [], f = /* @__PURE__ */ new Set();
  let d = 0;
  for (let v = 0; v < i.length; v++) {
    const O = i[v];
    let m;
    if (!BE(O) || !(m = Vn(O, "slot", !0))) {
      O.type !== 3 && h.push(O);
      continue;
    }
    if (l) {
      e.onError(
        Pt(37, m.loc)
      );
      break;
    }
    u = !0;
    const { children: E, loc: b } = O, {
      arg: S = vt("default", !0),
      exp: T,
      loc: y
    } = m;
    let R;
    ji(S) ? R = S ? S.content : "default" : s = !0;
    const _ = t(T, E, b);
    let C, I, w;
    if (C = Vn(O, "if"))
      s = !0, o.push(
        b_(
          C.exp,
          hO(S, _, d++),
          tD
        )
      );
    else if (I = Vn(
      O,
      /^else(-if)?$/,
      !0
      /* allowEmpty */
    )) {
      let x = v, P;
      for (; x-- && (P = i[x], P.type === 3); )
        ;
      if (P && BE(P) && Vn(P, "if")) {
        i.splice(v, 1), v--;
        let L = o[o.length - 1];
        for (; L.alternate.type === 19; )
          L = L.alternate;
        L.alternate = I.exp ? b_(
          I.exp,
          hO(
            S,
            _,
            d++
          ),
          tD
        ) : hO(S, _, d++);
      } else
        e.onError(
          Pt(30, I.loc)
        );
    } else if (w = Vn(O, "for")) {
      s = !0;
      const x = w.parseResult || $X(w.exp, e);
      x ? o.push(
        yr(e.helper(h1), [
          x.source,
          Rf(
            R_(x),
            hO(S, _),
            !0
            /* force newline */
          )
        ])
      ) : e.onError(
        Pt(32, w.loc)
      );
    } else {
      if (R) {
        if (f.has(R)) {
          e.onError(
            Pt(
              38,
              y
            )
          );
          continue;
        }
        f.add(R), R === "default" && (c = !0);
      }
      a.push(lr(S, _));
    }
  }
  if (!l) {
    const v = (O, m) => {
      const E = t(O, m, n);
      return e.compatConfig && (E.isNonScopedSlot = !0), lr("default", E);
    };
    u ? h.length && // #3766
    // with whitespace: 'preserve', whitespaces between slots will end up in
    // implicitDefaultChildren. Ignore if all implicit children are whitespaces.
    h.some((O) => VX(O)) && (c ? e.onError(
      Pt(
        39,
        h[0].loc
      )
    ) : a.push(
      v(void 0, h)
    )) : a.push(v(void 0, i));
  }
  const p = s ? 2 : Bm(r.children) ? 3 : 1;
  let g = Wn(
    a.concat(
      lr(
        "_",
        // 2 = compiled but dynamic = can skip normalization, but must run diff
        // 1 = compiled and static = can skip normalization AND diff as optimized
        vt(
          p + ({}.NODE_ENV !== "production" ? ` /* ${rj[p]} */` : ""),
          !1
        )
      )
    ),
    n
  );
  return o.length && (g = yr(e.helper(yX), [
    g,
    bv(o)
  ])), {
    slots: g,
    hasDynamicSlots: s
  };
}
function hO(r, e, t) {
  const i = [
    lr("name", r),
    lr("fn", e)
  ];
  return t != null && i.push(
    lr("key", vt(String(t), !0))
  ), Wn(i);
}
function Bm(r) {
  for (let e = 0; e < r.length; e++) {
    const t = r[e];
    switch (t.type) {
      case 1:
        if (t.tagType === 2 || Bm(t.children))
          return !0;
        break;
      case 9:
        if (Bm(t.branches))
          return !0;
        break;
      case 10:
      case 11:
        if (Bm(t.children))
          return !0;
        break;
    }
  }
  return !1;
}
function VX(r) {
  return r.type !== 2 && r.type !== 12 ? !0 : r.type === 2 ? !!r.content.trim() : VX(r.content);
}
const GX = /* @__PURE__ */ new WeakMap(), hre = (r, e) => function() {
  if (r = e.currentNode, !(r.type === 1 && (r.tagType === 0 || r.tagType === 1)))
    return;
  const { tag: i, props: n } = r, a = r.tagType === 1;
  let o = a ? fre(r, e) : `"${i}"`;
  const s = Tt(o) && o.callee === QE;
  let l, u, c, h = 0, f, d, p, g = (
    // dynamic component may resolve to plain elements
    s || o === Gp || o === i1 || !a && // <svg> and <foreignObject> must be forced into blocks so that block
    // updates inside get proper isSVG flag at runtime. (#639, #643)
    // This is technically web-specific, but splitting the logic out of core
    // leads to too much unnecessary complexity.
    (i === "svg" || i === "foreignObject")
  );
  if (n.length > 0) {
    const v = BX(
      r,
      e,
      void 0,
      a,
      s
    );
    l = v.props, h = v.patchFlag, d = v.dynamicPropNames;
    const O = v.directives;
    p = O && O.length ? bv(
      O.map((m) => pre(m, e))
    ) : void 0, v.shouldUseBlock && (g = !0);
  }
  if (r.children.length > 0)
    if (o === kE && (g = !0, h |= 1024, {}.NODE_ENV !== "production" && r.children.length > 1 && e.onError(
      Pt(46, {
        start: r.children[0].loc.start,
        end: r.children[r.children.length - 1].loc.end,
        source: ""
      })
    )), a && // Teleport is not a real component and has dedicated runtime handling
    o !== Gp && // explained above.
    o !== kE) {
      const { slots: O, hasDynamicSlots: m } = cre(r, e);
      u = O, m && (h |= 1024);
    } else if (r.children.length === 1 && o !== Gp) {
      const O = r.children[0], m = O.type, E = m === 5 || m === 8;
      E && zn(O, e) === 0 && (h |= 1), E || m === 2 ? u = O : u = r.children;
    } else
      u = r.children;
  if (h !== 0) {
    if ({}.NODE_ENV !== "production")
      if (h < 0)
        c = h + ` /* ${po[h]} */`;
      else {
        const v = Object.keys(po).map(Number).filter((O) => O > 0 && h & O).map((O) => po[O]).join(", ");
        c = h + ` /* ${v} */`;
      }
    else
      c = String(h);
    d && d.length && (f = gre(d));
  }
  r.codegenNode = yg(
    e,
    o,
    l,
    u,
    c,
    f,
    p,
    !!g,
    !1,
    a,
    r.loc
  );
};
function fre(r, e, t = !1) {
  let { tag: i } = r;
  const n = A_(i), a = Cf(r, "is");
  if (a)
    if (n || dl(
      "COMPILER_IS_ON_ELEMENT",
      e
    )) {
      const l = a.type === 6 ? a.value && vt(a.value.content, !0) : a.exp;
      if (l)
        return yr(e.helper(QE), [
          l
        ]);
    } else
      a.type === 6 && a.value.content.startsWith("vue:") && (i = a.value.content.slice(4));
  const o = !n && Vn(r, "is");
  if (o && o.exp)
    return {}.NODE_ENV !== "production" && e.onWarn(
      Pt(52, o.loc)
    ), yr(e.helper(QE), [
      o.exp
    ]);
  const s = AX(i) || e.isBuiltInComponent(i);
  return s ? (t || e.helper(s), s) : (e.helper(s1), e.components.add(i), Rg(i, "component"));
}
function BX(r, e, t = r.props, i, n, a = !1) {
  const { tag: o, loc: s, children: l } = r;
  let u = [];
  const c = [], h = [], f = l.length > 0;
  let d = !1, p = 0, g = !1, v = !1, O = !1, m = !1, E = !1, b = !1;
  const S = [], T = (_) => {
    u.length && (c.push(
      Wn(rD(u), s)
    ), u = []), _ && c.push(_);
  }, y = ({ key: _, value: C }) => {
    if (ji(_)) {
      const I = _.content, w = is(I);
      if (w && (!i || n) && // omit the flag for click handlers because hydration gives click
      // dedicated fast path.
      I.toLowerCase() !== "onclick" && // omit v-model handlers
      I !== "onUpdate:modelValue" && // omit onVnodeXXX hooks
      !ac(I) && (m = !0), w && ac(I) && (b = !0), C.type === 20 || (C.type === 4 || C.type === 8) && zn(C, e) > 0)
        return;
      I === "ref" ? g = !0 : I === "class" ? v = !0 : I === "style" ? O = !0 : I !== "key" && !S.includes(I) && S.push(I), i && (I === "class" || I === "style") && !S.includes(I) && S.push(I);
    } else
      E = !0;
  };
  for (let _ = 0; _ < t.length; _++) {
    const C = t[_];
    if (C.type === 6) {
      const { loc: I, name: w, value: x } = C;
      let P = !0;
      if (w === "ref" && (g = !0, e.scopes.vFor > 0 && u.push(
        lr(
          vt("ref_for", !0),
          vt("true")
        )
      )), w === "is" && (A_(o) || x && x.content.startsWith("vue:") || dl(
        "COMPILER_IS_ON_ELEMENT",
        e
      )))
        continue;
      u.push(
        lr(
          vt(
            w,
            !0,
            CX(I, 0, w.length)
          ),
          vt(
            x ? x.content : "",
            P,
            x ? x.loc : I
          )
        )
      );
    } else {
      const { name: I, arg: w, exp: x, loc: P } = C, L = I === "bind", D = I === "on";
      if (I === "slot") {
        i || e.onError(
          Pt(40, P)
        );
        continue;
      }
      if (I === "once" || I === "memo" || I === "is" || L && Yu(w, "is") && (A_(o) || dl(
        "COMPILER_IS_ON_ELEMENT",
        e
      )) || D && a)
        continue;
      if (
        // #938: elements with dynamic keys should be forced into blocks
        (L && Yu(w, "key") || // inline before-update hooks need to force block so that it is invoked
        // before children
        D && f && Yu(w, "vue:before-update")) && (d = !0), L && Yu(w, "ref") && e.scopes.vFor > 0 && u.push(
          lr(
            vt("ref_for", !0),
            vt("true")
          )
        ), !w && (L || D)
      ) {
        if (E = !0, x)
          if (L) {
            if (T(), {}.NODE_ENV !== "production" && c.some((V) => V.type === 15 ? V.properties.some(({ key: F }) => F.type !== 4 || !F.isStatic ? !0 : F.content !== "class" && F.content !== "style" && !is(F.content)) : !0) && _c(
              "COMPILER_V_BIND_OBJECT_ORDER",
              e,
              P
            ), dl(
              "COMPILER_V_BIND_OBJECT_ORDER",
              e
            )) {
              c.unshift(x);
              continue;
            }
            c.push(x);
          } else
            T({
              type: 14,
              loc: P,
              callee: e.helper(p1),
              arguments: i ? [x] : [x, "true"]
            });
        else
          e.onError(
            Pt(
              L ? 34 : 35,
              P
            )
          );
        continue;
      }
      const U = e.directiveTransforms[I];
      if (U) {
        const { props: Q, needRuntime: V } = U(C, r, e);
        !a && Q.forEach(y), D && w && !ji(w) ? T(Wn(Q, s)) : u.push(...Q), V && (h.push(C), Sl(V) && GX.set(C, V));
      } else
        E5(I) || (h.push(C), f && (d = !0));
    }
  }
  let R;
  if (c.length ? (T(), c.length > 1 ? R = yr(
    e.helper(UE),
    c,
    s
  ) : R = c[0]) : u.length && (R = Wn(
    rD(u),
    s
  )), E ? p |= 16 : (v && !i && (p |= 2), O && !i && (p |= 4), S.length && (p |= 8), m && (p |= 32)), !d && (p === 0 || p === 32) && (g || b || h.length > 0) && (p |= 512), !e.inSSR && R)
    switch (R.type) {
      case 15:
        let _ = -1, C = -1, I = !1;
        for (let P = 0; P < R.properties.length; P++) {
          const L = R.properties[P].key;
          ji(L) ? L.content === "class" ? _ = P : L.content === "style" && (C = P) : L.isHandlerKey || (I = !0);
        }
        const w = R.properties[_], x = R.properties[C];
        I ? R = yr(
          e.helper(Tg),
          [R]
        ) : (w && !ji(w.value) && (w.value = yr(
          e.helper(f1),
          [w.value]
        )), x && // the static style is compiled into an object,
        // so use `hasStyleBinding` to ensure that it is a dynamic style binding
        (O || x.value.type === 4 && x.value.content.trim()[0] === "[" || // v-bind:style and style both exist,
        // v-bind:style with static literal object
        x.value.type === 17) && (x.value = yr(
          e.helper(d1),
          [x.value]
        )));
        break;
      case 14:
        break;
      default:
        R = yr(
          e.helper(Tg),
          [
            yr(e.helper(Ev), [
              R
            ])
          ]
        );
        break;
    }
  return {
    props: R,
    directives: h,
    patchFlag: p,
    dynamicPropNames: S,
    shouldUseBlock: d
  };
}
function rD(r) {
  const e = /* @__PURE__ */ new Map(), t = [];
  for (let i = 0; i < r.length; i++) {
    const n = r[i];
    if (n.key.type === 8 || !n.key.isStatic) {
      t.push(n);
      continue;
    }
    const a = n.key.content, o = e.get(a);
    o ? (a === "style" || a === "class" || is(a)) && dre(o, n) : (e.set(a, n), t.push(n));
  }
  return t;
}
function dre(r, e) {
  r.value.type === 17 ? r.value.elements.push(e.value) : r.value = bv(
    [r.value, e.value],
    r.loc
  );
}
function pre(r, e) {
  const t = [], i = GX.get(r);
  i ? t.push(e.helperString(i)) : (e.helper(l1), e.directives.add(r.name), t.push(Rg(r.name, "directive")));
  const { loc: n } = r;
  if (r.exp && t.push(r.exp), r.arg && (r.exp || t.push("void 0"), t.push(r.arg)), Object.keys(r.modifiers).length) {
    r.arg || (r.exp || t.push("void 0"), t.push("void 0"));
    const a = vt("true", !1, n);
    t.push(
      Wn(
        r.modifiers.map(
          (o) => lr(o, a)
        ),
        n
      )
    );
  }
  return bv(t, r.loc);
}
function gre(r) {
  let e = "[";
  for (let t = 0, i = r.length; t < i; t++)
    e += JSON.stringify(r[t]), t < i - 1 && (e += ", ");
  return e + "]";
}
function A_(r) {
  return r === "component" || r === "Component";
}
const vre = (r, e) => {
  if (FE(r)) {
    const { children: t, loc: i } = r, { slotName: n, slotProps: a } = Ore(r, e), o = [
      e.prefixIdentifiers ? "_ctx.$slots" : "$slots",
      n,
      "{}",
      "undefined",
      "true"
    ];
    let s = 2;
    a && (o[2] = a, s = 3), t.length && (o[3] = Rf([], t, !1, !1, i), s = 4), e.scopeId && !e.slotted && (s = 5), o.splice(s), r.codegenNode = yr(
      e.helper(TX),
      o,
      i
    );
  }
};
function Ore(r, e) {
  let t = '"default"', i;
  const n = [];
  for (let a = 0; a < r.props.length; a++) {
    const o = r.props[a];
    o.type === 6 ? o.value && (o.name === "name" ? t = JSON.stringify(o.value.content) : (o.name = Cr(o.name), n.push(o))) : o.name === "bind" && Yu(o.arg, "name") ? o.exp && (t = o.exp) : (o.name === "bind" && o.arg && ji(o.arg) && (o.arg.content = Cr(o.arg.content)), n.push(o));
  }
  if (n.length > 0) {
    const { props: a, directives: o } = BX(
      r,
      e,
      n,
      !1,
      !1
    );
    i = a, o.length && e.onError(
      Pt(
        36,
        o[0].loc
      )
    );
  }
  return {
    slotName: t,
    slotProps: i
  };
}
const mre = /^\s*([\w$_]+|(async\s*)?\([^)]*?\))\s*(:[^=]+)?=>|^\s*(async\s+)?function(?:\s+[\w$]+)?\s*\(/, FX = (r, e, t, i) => {
  const { loc: n, modifiers: a, arg: o } = r;
  !r.exp && !a.length && t.onError(Pt(35, n));
  let s;
  if (o.type === 4)
    if (o.isStatic) {
      let h = o.content;
      ({}).NODE_ENV !== "production" && h.startsWith("vnode") && t.onWarn(
        Pt(51, o.loc)
      ), h.startsWith("vue:") && (h = `vnode-${h.slice(4)}`);
      const f = e.tagType !== 0 || h.startsWith("vnode") || !/[A-Z]/.test(h) ? (
        // for non-element and vnode lifecycle event listeners, auto convert
        // it to camelCase. See issue #2249
        Ka(Cr(h))
      ) : (
        // preserve case for plain element listeners that have uppercase
        // letters, as these may be custom elements' custom events
        `on:${h}`
      );
      s = vt(f, !0, o.loc);
    } else
      s = Aa([
        `${t.helperString(E_)}(`,
        o,
        ")"
      ]);
  else
    s = o, s.children.unshift(`${t.helperString(E_)}(`), s.children.push(")");
  let l = r.exp;
  l && !l.content.trim() && (l = void 0);
  let u = t.cacheHandlers && !l && !t.inVOnce;
  if (l) {
    const h = _X(l.content), f = !(h || mre.test(l.content)), d = l.content.includes(";");
    ({}).NODE_ENV !== "production" && Hu(
      l,
      t,
      !1,
      d
    ), (f || u && h) && (l = Aa([
      `${f ? "$event" : "(...args)"} => ${d ? "{" : "("}`,
      l,
      d ? "}" : ")"
    ]));
  }
  let c = {
    props: [
      lr(
        s,
        l || vt("() => {}", !1, n)
      )
    ]
  };
  return i && (c = i(c)), u && (c.props[0].value = t.cache(c.props[0].value)), c.props.forEach((h) => h.key.isHandlerKey = !0), c;
}, Ere = (r, e, t) => {
  const { exp: i, modifiers: n, loc: a } = r, o = r.arg;
  return o.type !== 4 ? (o.children.unshift("("), o.children.push(') || ""')) : o.isStatic || (o.content = `${o.content} || ""`), n.includes("camel") && (o.type === 4 ? o.isStatic ? o.content = Cr(o.content) : o.content = `${t.helperString(m_)}(${o.content})` : (o.children.unshift(`${t.helperString(m_)}(`), o.children.push(")"))), t.inSSR || (n.includes("prop") && iD(o, "."), n.includes("attr") && iD(o, "^")), !i || i.type === 4 && !i.content.trim() ? (t.onError(Pt(34, a)), {
    props: [lr(o, vt("", !0, a))]
  }) : {
    props: [lr(o, i)]
  };
}, iD = (r, e) => {
  r.type === 4 ? r.isStatic ? r.content = e + r.content : r.content = `\`${e}\${${r.content}}\`` : (r.children.unshift(`'${e}' + (`), r.children.push(")"));
}, bre = (r, e) => {
  if (r.type === 0 || r.type === 1 || r.type === 11 || r.type === 10)
    return () => {
      const t = r.children;
      let i, n = !1;
      for (let a = 0; a < t.length; a++) {
        const o = t[a];
        if (Ny(o)) {
          n = !0;
          for (let s = a + 1; s < t.length; s++) {
            const l = t[s];
            if (Ny(l))
              i || (i = t[a] = Aa(
                [o],
                o.loc
              )), i.children.push(" + ", l), t.splice(s, 1), s--;
            else {
              i = void 0;
              break;
            }
          }
        }
      }
      if (!(!n || // if this is a plain element with a single text child, leave it
      // as-is since the runtime has dedicated fast path for this by directly
      // setting textContent of the element.
      // for component root it's always normalized anyway.
      t.length === 1 && (r.type === 0 || r.type === 1 && r.tagType === 0 && // #3756
      // custom directives can potentially add DOM elements arbitrarily,
      // we need to avoid setting textContent of the element at runtime
      // to avoid accidentally overwriting the DOM elements added
      // by the user through custom directives.
      !r.props.find(
        (a) => a.type === 7 && !e.directiveTransforms[a.name]
      ) && r.tag !== "template")))
        for (let a = 0; a < t.length; a++) {
          const o = t[a];
          if (Ny(o) || o.type === 8) {
            const s = [];
            (o.type !== 2 || o.content !== " ") && s.push(o), !e.ssr && zn(o, e) === 0 && s.push(
              1 + ({}.NODE_ENV !== "production" ? ` /* ${po[1]} */` : "")
            ), t[a] = {
              type: 12,
              content: o,
              loc: o.loc,
              codegenNode: yr(
                e.helper(o1),
                s
              )
            };
          }
        }
    };
}, nD = /* @__PURE__ */ new WeakSet(), Sre = (r, e) => {
  if (r.type === 1 && Vn(r, "once", !0))
    return nD.has(r) || e.inVOnce || e.inSSR ? void 0 : (nD.add(r), e.inVOnce = !0, e.helper($E), () => {
      e.inVOnce = !1;
      const t = e.currentNode;
      t.codegenNode && (t.codegenNode = e.cache(
        t.codegenNode,
        !0
        /* isVNode */
      ));
    });
}, XX = (r, e, t) => {
  const { exp: i, arg: n } = r;
  if (!i)
    return t.onError(
      Pt(41, r.loc)
    ), fO();
  const a = i.loc.source, o = i.type === 4 ? i.content : a, s = t.bindingMetadata[a];
  if (s === "props" || s === "props-aliased")
    return t.onError(Pt(44, i.loc)), fO();
  const l = !1;
  if (!o.trim() || !_X(o) && !l)
    return t.onError(
      Pt(42, i.loc)
    ), fO();
  const u = n || vt("modelValue", !0), c = n ? ji(n) ? `onUpdate:${Cr(n.content)}` : Aa(['"onUpdate:" + ', n]) : "onUpdate:modelValue";
  let h;
  const f = t.isTS ? "($event: any)" : "$event";
  h = Aa([
    `${f} => ((`,
    i,
    ") = $event)"
  ]);
  const d = [
    // modelValue: foo
    lr(u, r.exp),
    // "onUpdate:modelValue": $event => (foo = $event)
    lr(c, h)
  ];
  if (r.modifiers.length && e.tagType === 1) {
    const p = r.modifiers.map((v) => (m1(v) ? v : JSON.stringify(v)) + ": true").join(", "), g = n ? ji(n) ? `${n.content}Modifiers` : Aa([n, ' + "Modifiers"']) : "modelModifiers";
    d.push(
      lr(
        g,
        vt(
          `{ ${p} }`,
          !1,
          r.loc,
          2
        )
      )
    );
  }
  return fO(d);
};
function fO(r = []) {
  return { props: r };
}
const Tre = /[\w).+\-_$\]]/, yre = (r, e) => {
  dl("COMPILER_FILTER", e) && (r.type === 5 && HE(r.content, e), r.type === 1 && r.props.forEach((t) => {
    t.type === 7 && t.name !== "for" && t.exp && HE(t.exp, e);
  }));
};
function HE(r, e) {
  if (r.type === 4)
    aD(r, e);
  else
    for (let t = 0; t < r.children.length; t++) {
      const i = r.children[t];
      typeof i == "object" && (i.type === 4 ? aD(i, e) : i.type === 8 ? HE(r, e) : i.type === 5 && HE(i.content, e));
    }
}
function aD(r, e) {
  const t = r.content;
  let i = !1, n = !1, a = !1, o = !1, s = 0, l = 0, u = 0, c = 0, h, f, d, p, g = [];
  for (d = 0; d < t.length; d++)
    if (f = h, h = t.charCodeAt(d), i)
      h === 39 && f !== 92 && (i = !1);
    else if (n)
      h === 34 && f !== 92 && (n = !1);
    else if (a)
      h === 96 && f !== 92 && (a = !1);
    else if (o)
      h === 47 && f !== 92 && (o = !1);
    else if (h === 124 && // pipe
    t.charCodeAt(d + 1) !== 124 && t.charCodeAt(d - 1) !== 124 && !s && !l && !u)
      p === void 0 ? (c = d + 1, p = t.slice(0, d).trim()) : v();
    else {
      switch (h) {
        case 34:
          n = !0;
          break;
        case 39:
          i = !0;
          break;
        case 96:
          a = !0;
          break;
        case 40:
          u++;
          break;
        case 41:
          u--;
          break;
        case 91:
          l++;
          break;
        case 93:
          l--;
          break;
        case 123:
          s++;
          break;
        case 125:
          s--;
          break;
      }
      if (h === 47) {
        let O = d - 1, m;
        for (; O >= 0 && (m = t.charAt(O), m === " "); O--)
          ;
        (!m || !Tre.test(m)) && (o = !0);
      }
    }
  p === void 0 ? p = t.slice(0, d).trim() : c !== 0 && v();
  function v() {
    g.push(t.slice(c, d).trim()), c = d + 1;
  }
  if (g.length) {
    for ({}.NODE_ENV !== "production" && JS(
      "COMPILER_FILTER",
      e,
      r.loc
    ), d = 0; d < g.length; d++)
      p = Rre(p, g[d], e);
    r.content = p;
  }
}
function Rre(r, e, t) {
  t.helper(u1);
  const i = e.indexOf("(");
  if (i < 0)
    return t.filters.add(e), `${Rg(e, "filter")}(${r})`;
  {
    const n = e.slice(0, i), a = e.slice(i + 1);
    return t.filters.add(n), `${Rg(n, "filter")}(${r}${a !== ")" ? "," + a : a}`;
  }
}
const oD = /* @__PURE__ */ new WeakSet(), Are = (r, e) => {
  if (r.type === 1) {
    const t = Vn(r, "memo");
    return !t || oD.has(r) ? void 0 : (oD.add(r), () => {
      const i = r.codegenNode || e.currentNode.codegenNode;
      i && i.type === 13 && (r.tagType !== 1 && O1(i, e), r.codegenNode = yr(e.helper(v1), [
        t.exp,
        Rf(void 0, i),
        "_cache",
        String(e.cached++)
      ]));
    });
  }
};
function _re(r) {
  return [
    [
      Sre,
      Jte,
      Are,
      ire,
      yre,
      ...{}.NODE_ENV !== "production" ? [Kte] : [],
      vre,
      hre,
      lre,
      bre
    ],
    {
      on: FX,
      bind: Ere,
      model: XX
    }
  ];
}
function Cre(r, e = {}) {
  const t = e.onError || r1, i = e.mode === "module";
  e.prefixIdentifiers === !0 ? t(Pt(47)) : i && t(Pt(48));
  const n = !1;
  e.cacheHandlers && t(Pt(49)), e.scopeId && !i && t(Pt(50));
  const a = qe(r) ? Ote(r, e) : r, [o, s] = _re();
  return xte(
    a,
    ut({}, e, {
      prefixIdentifiers: n,
      nodeTransforms: [
        ...o,
        ...e.nodeTransforms || []
        // user transforms
      ],
      directiveTransforms: ut(
        {},
        s,
        e.directiveTransforms || {}
        // user transforms
      )
    })
  ), Dte(
    a,
    ut({}, e, {
      prefixIdentifiers: n
    })
  );
}
const Ire = () => ({ props: [] }), YX = Symbol({}.NODE_ENV !== "production" ? "vModelRadio" : ""), HX = Symbol({}.NODE_ENV !== "production" ? "vModelCheckbox" : ""), WX = Symbol({}.NODE_ENV !== "production" ? "vModelText" : ""), zX = Symbol({}.NODE_ENV !== "production" ? "vModelSelect" : ""), __ = Symbol({}.NODE_ENV !== "production" ? "vModelDynamic" : ""), ZX = Symbol({}.NODE_ENV !== "production" ? "vOnModifiersGuard" : ""), qX = Symbol({}.NODE_ENV !== "production" ? "vOnKeysGuard" : ""), jX = Symbol({}.NODE_ENV !== "production" ? "vShow" : ""), S1 = Symbol({}.NODE_ENV !== "production" ? "Transition" : ""), KX = Symbol({}.NODE_ENV !== "production" ? "TransitionGroup" : "");
tte({
  [YX]: "vModelRadio",
  [HX]: "vModelCheckbox",
  [WX]: "vModelText",
  [zX]: "vModelSelect",
  [__]: "vModelDynamic",
  [ZX]: "withModifiers",
  [qX]: "withKeys",
  [jX]: "vShow",
  [S1]: "Transition",
  [KX]: "TransitionGroup"
});
let lh;
function wre(r, e = !1) {
  return lh || (lh = document.createElement("div")), e ? (lh.innerHTML = `<div foo="${r.replace(/"/g, "&quot;")}">`, lh.children[0].getAttribute("foo")) : (lh.innerHTML = r, lh.textContent);
}
const Nre = /* @__PURE__ */ bi(
  "style,iframe,script,noscript",
  !0
), xre = {
  isVoidTag: dj,
  isNativeTag: (r) => S5(r) || T5(r),
  isPreTag: (r) => r === "pre",
  decodeEntities: wre,
  isBuiltInComponent: (r) => {
    if (Xu(r, "Transition"))
      return S1;
    if (Xu(r, "TransitionGroup"))
      return KX;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#tree-construction-dispatcher
  getNamespace(r, e) {
    let t = e ? e.ns : 0;
    if (e && t === 2)
      if (e.tag === "annotation-xml") {
        if (r === "svg")
          return 1;
        e.props.some(
          (i) => i.type === 6 && i.name === "encoding" && i.value != null && (i.value.content === "text/html" || i.value.content === "application/xhtml+xml")
        ) && (t = 0);
      } else
        /^m(?:[ions]|text)$/.test(e.tag) && r !== "mglyph" && r !== "malignmark" && (t = 0);
    else
      e && t === 1 && (e.tag === "foreignObject" || e.tag === "desc" || e.tag === "title") && (t = 0);
    if (t === 0) {
      if (r === "svg")
        return 1;
      if (r === "math")
        return 2;
    }
    return t;
  },
  // https://html.spec.whatwg.org/multipage/parsing.html#parsing-html-fragments
  getTextMode({ tag: r, ns: e }) {
    if (e === 0) {
      if (r === "textarea" || r === "title")
        return 1;
      if (Nre(r))
        return 2;
    }
    return 0;
  }
}, Pre = (r) => {
  r.type === 1 && r.props.forEach((e, t) => {
    e.type === 6 && e.name === "style" && e.value && (r.props[t] = {
      type: 7,
      name: "bind",
      arg: vt("style", !0, e.loc),
      exp: Lre(e.value.content, e.loc),
      modifiers: [],
      loc: e.loc
    });
  });
}, Lre = (r, e) => {
  const t = b5(r);
  return vt(
    JSON.stringify(t),
    !1,
    e,
    3
  );
};
function ma(r, e) {
  return Pt(
    r,
    e,
    {}.NODE_ENV !== "production" ? Dre : void 0
  );
}
const Dre = {
  53: "v-html is missing expression.",
  54: "v-html will override element children.",
  55: "v-text is missing expression.",
  56: "v-text will override element children.",
  57: "v-model can only be used on <input>, <textarea> and <select> elements.",
  58: "v-model argument is not supported on plain elements.",
  59: "v-model cannot be used on file inputs since they are read-only. Use a v-on:change listener instead.",
  60: "Unnecessary value binding used alongside v-model. It will interfere with v-model's behavior.",
  61: "v-show is missing expression.",
  62: "<Transition> expects exactly one child element or component.",
  63: "Tags with side effect (<script> and <style>) are ignored in client component templates."
}, Mre = (r, e, t) => {
  const { exp: i, loc: n } = r;
  return i || t.onError(
    ma(53, n)
  ), e.children.length && (t.onError(
    ma(54, n)
  ), e.children.length = 0), {
    props: [
      lr(
        vt("innerHTML", !0, n),
        i || vt("", !0)
      )
    ]
  };
}, kre = (r, e, t) => {
  const { exp: i, loc: n } = r;
  return i || t.onError(
    ma(55, n)
  ), e.children.length && (t.onError(
    ma(56, n)
  ), e.children.length = 0), {
    props: [
      lr(
        vt("textContent", !0),
        i ? zn(i, t) > 0 ? i : yr(
          t.helperString(KS),
          [i],
          n
        ) : vt("", !0)
      )
    ]
  };
}, Qre = (r, e, t) => {
  const i = XX(r, e, t);
  if (!i.props.length || e.tagType === 1)
    return i;
  r.arg && t.onError(
    ma(
      58,
      r.arg.loc
    )
  );
  function n() {
    const s = Cf(e, "value");
    s && t.onError(
      ma(
        60,
        s.loc
      )
    );
  }
  const { tag: a } = e, o = t.isCustomElement(a);
  if (a === "input" || a === "textarea" || a === "select" || o) {
    let s = WX, l = !1;
    if (a === "input" || o) {
      const u = Cf(e, "type");
      if (u) {
        if (u.type === 7)
          s = __;
        else if (u.value)
          switch (u.value.content) {
            case "radio":
              s = YX;
              break;
            case "checkbox":
              s = HX;
              break;
            case "file":
              l = !0, t.onError(
                ma(
                  59,
                  r.loc
                )
              );
              break;
            default:
              ({}).NODE_ENV !== "production" && n();
              break;
          }
      } else
        cte(e) ? s = __ : {}.NODE_ENV !== "production" && n();
    } else
      a === "select" ? s = zX : {}.NODE_ENV !== "production" && n();
    l || (i.needRuntime = t.helper(s));
  } else
    t.onError(
      ma(
        57,
        r.loc
      )
    );
  return i.props = i.props.filter(
    (s) => !(s.key.type === 4 && s.key.content === "modelValue")
  ), i;
}, Ure = /* @__PURE__ */ bi("passive,once,capture"), $re = /* @__PURE__ */ bi(
  // event propagation management
  "stop,prevent,self,ctrl,shift,alt,meta,exact,middle"
), Vre = /* @__PURE__ */ bi("left,right"), JX = /* @__PURE__ */ bi(
  "onkeyup,onkeydown,onkeypress",
  !0
), Gre = (r, e, t, i) => {
  const n = [], a = [], o = [];
  for (let s = 0; s < e.length; s++) {
    const l = e[s];
    l === "native" && _c(
      "COMPILER_V_ON_NATIVE",
      t,
      i
    ) || Ure(l) ? o.push(l) : Vre(l) ? ji(r) ? JX(r.content) ? n.push(l) : a.push(l) : (n.push(l), a.push(l)) : $re(l) ? a.push(l) : n.push(l);
  }
  return {
    keyModifiers: n,
    nonKeyModifiers: a,
    eventOptionModifiers: o
  };
}, sD = (r, e) => ji(r) && r.content.toLowerCase() === "onclick" ? vt(e, !0) : r.type !== 4 ? Aa([
  "(",
  r,
  `) === "onClick" ? "${e}" : (`,
  r,
  ")"
]) : r, Bre = (r, e, t) => FX(r, e, t, (i) => {
  const { modifiers: n } = r;
  if (!n.length)
    return i;
  let { key: a, value: o } = i.props[0];
  const { keyModifiers: s, nonKeyModifiers: l, eventOptionModifiers: u } = Gre(a, n, t, r.loc);
  if (l.includes("right") && (a = sD(a, "onContextmenu")), l.includes("middle") && (a = sD(a, "onMouseup")), l.length && (o = yr(t.helper(ZX), [
    o,
    JSON.stringify(l)
  ])), s.length && // if event name is dynamic, always wrap with keys guard
  (!ji(a) || JX(a.content)) && (o = yr(t.helper(qX), [
    o,
    JSON.stringify(s)
  ])), u.length) {
    const c = u.map(bo).join("");
    a = ji(a) ? vt(`${a.content}${c}`, !0) : Aa(["(", a, `) + "${c}"`]);
  }
  return {
    props: [lr(a, o)]
  };
}), Fre = (r, e, t) => {
  const { exp: i, loc: n } = r;
  return i || t.onError(
    ma(61, n)
  ), {
    props: [],
    needRuntime: t.helper(jX)
  };
}, Xre = (r, e) => {
  if (r.type === 1 && r.tagType === 1 && e.isBuiltInComponent(r.tag) === S1)
    return () => {
      if (!r.children.length)
        return;
      eY(r) && e.onError(
        ma(
          62,
          {
            start: r.children[0].loc.start,
            end: r.children[r.children.length - 1].loc.end,
            source: ""
          }
        )
      );
      const i = r.children[0];
      if (i.type === 1)
        for (const n of i.props)
          n.type === 7 && n.name === "show" && r.props.push({
            type: 6,
            name: "persisted",
            value: void 0,
            loc: r.loc
          });
    };
};
function eY(r) {
  const e = r.children = r.children.filter(
    (i) => i.type !== 3 && !(i.type === 2 && !i.content.trim())
  ), t = e[0];
  return e.length !== 1 || t.type === 11 || t.type === 9 && t.branches.some(eY);
}
const Yre = (r, e) => {
  r.type === 1 && r.tagType === 0 && (r.tag === "script" || r.tag === "style") && ({}.NODE_ENV !== "production" && e.onError(
    ma(
      63,
      r.loc
    )
  ), e.removeNode());
}, Hre = [
  Pre,
  ...{}.NODE_ENV !== "production" ? [Xre] : []
], Wre = {
  cloak: Ire,
  html: Mre,
  text: kre,
  model: Qre,
  // override compiler-core
  on: Bre,
  // override compiler-core
  show: Fre
};
function zre(r, e = {}) {
  return Cre(
    r,
    ut({}, xre, e, {
      nodeTransforms: [
        // ignore <script> and <tag>
        // this is not put inside DOMNodeTransforms because that list is used
        // by compiler-ssr to generate vnode fallback branches
        Yre,
        ...Hre,
        ...e.nodeTransforms || []
      ],
      directiveTransforms: ut(
        {},
        Wre,
        e.directiveTransforms || {}
      ),
      transformHoist: null
    })
  );
}
function Zre() {
  qF();
}
({}).NODE_ENV !== "production" && Zre();
const lD = /* @__PURE__ */ Object.create(null);
function qre(r, e) {
  if (!qe(r))
    if (r.nodeType)
      r = r.innerHTML;
    else
      return {}.NODE_ENV !== "production" && W("invalid template option: ", r), dr;
  const t = r, i = lD[t];
  if (i)
    return i;
  if (r[0] === "#") {
    const l = document.querySelector(r);
    ({}).NODE_ENV !== "production" && !l && W(`Template element not found or is empty: ${r}`), r = l ? l.innerHTML : "";
  }
  const n = ut(
    {
      hoistStatic: !0,
      onError: {}.NODE_ENV !== "production" ? o : void 0,
      onWarn: {}.NODE_ENV !== "production" ? (l) => o(l, !0) : dr
    },
    e
  );
  !n.isCustomElement && typeof customElements < "u" && (n.isCustomElement = (l) => !!customElements.get(l));
  const { code: a } = zre(r, n);
  function o(l, u = !1) {
    const c = u ? l.message : `Template compilation error: ${l.message}`, h = l.loc && aj(
      r,
      l.loc.start.offset,
      l.loc.end.offset
    );
    W(h ? `${c}
${h}` : c);
  }
  const s = new Function("Vue", a)(zee);
  return s._rc = !0, lD[t] = s;
}
FF(qre);
const jre = {
  "Content-Type": "application/json;charset=UTF-8;"
}, Kre = {
  mode: "cors",
  credentials: "include",
  cache: "no-cache"
};
class Jre {
  constructor(e = "") {
    ai(this, "headers", {
      ...jre
    });
    ai(this, "BasePath", "");
    this.setBasePath(e);
  }
  fetchHandler(e, t, i, n, a = "json") {
    let o = { ...Kre };
    const s = {
      ...this.headers,
      ...n || {}
    };
    let l = `${/^http/gi.test(e) ? "" : this.BasePath}${e}`;
    switch (t !== "formData" && t.toUpperCase(), o = {
      ...o,
      method: t.toUpperCase(),
      headers: s,
      responseType: a
    }, t.toLocaleLowerCase()) {
      case "get":
        i && (l += "?", Object.keys(i).forEach((u) => {
          l += `${u}=${i[u]}&`;
        }));
        break;
      case "formdata":
        o = {
          ...o,
          body: i
        }, delete o.headers["Content-Type"];
        break;
      default:
        o = {
          ...o,
          body: i ? JSON.stringify(i) : "{}"
        };
    }
    return new Promise((u, c) => window.fetch(l, o).then((h) => {
      switch (a) {
        case "arraybuffer":
        case "file":
          u(h.arrayBuffer());
          break;
        case "blob":
          u(h.blob());
          break;
        case "document":
          u(h.formData());
          break;
        case "text":
          u(h.text());
          break;
        default:
          u(h.json());
      }
    }).catch((h) => {
      c(h);
    }));
  }
  setBasePath(e) {
    this.BasePath = e;
  }
  setHeader(e) {
    e && (this.headers = {
      ...this.headers,
      ...e
    });
  }
  post(e, t, i, n = "json") {
    return this.fetchHandler(e, "POST", t, i, n);
  }
  get(e, t, i, n = "json") {
    return this.fetchHandler(e, "GET", t, i, n);
  }
  put(e, t, i, n = "json") {
    return this.fetchHandler(e, "PUT", t, i, n);
  }
  delete(e, t, i, n = "json") {
    return this.fetchHandler(e, "DELETE", t, i, n);
  }
}
function uD(r) {
  var h;
  const e = document.getElementById(r);
  if (!e)
    return null;
  const t = (h = e.shadowRoot) == null ? void 0 : h.querySelector(`#${r}`);
  if (!t)
    return null;
  const { width: i, height: n, x: a, y: o } = t.getBoundingClientRect(), { clientHeight: s, clientWidth: l, clientTop: u, clientLeft: c } = window.document.body;
  return {
    ele: {
      width: i,
      height: n,
      x: a,
      y: o,
      element: e
    },
    window: {
      clientHeight: s,
      clientWidth: l,
      clientTop: u,
      clientLeft: c
    }
  };
}
const Is = 10;
window.NsFloatingbox = {
  open(r, e) {
    var E;
    const t = uD(r);
    if (!t)
      return;
    const { clientX: i, clientY: n } = e, { width: a, height: o, x: s, y: l } = t.ele, { clientHeight: u, clientWidth: c, clientTop: h, clientLeft: f } = t.window;
    let d = i - Is, p = n - Is;
    const g = i - Is + a, v = n - Is + o;
    d < f && (d = f + Is), g > c + f && (d = c - a - Is), p < h && (p = h + Is), v > u + h && (p = u - o - Is);
    const { element: O } = t.ele, m = (E = O.shadowRoot) == null ? void 0 : E.querySelector("#" + r);
    m && (m.style.top = `${p}px`, m.style.left = `${d}px`, Sc(() => {
      m.style.opacity = "1";
    }));
  },
  close(r) {
    var n;
    const e = uD(r);
    if (!e)
      return;
    const { element: t } = e.ele, i = (n = t.shadowRoot) == null ? void 0 : n.querySelector("#" + r);
    i && (i.style.opacity = "0", setTimeout(() => {
      i.style.top = "-1000px", i.style.left = "-1000px";
    }, 200));
  }
};
var dO, eie = new Uint8Array(16);
function tY() {
  if (!dO && (dO = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !dO))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return dO(eie);
}
const tie = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function rY(r) {
  return typeof r == "string" && tie.test(r);
}
var Xr = [];
for (var Ly = 0; Ly < 256; ++Ly)
  Xr.push((Ly + 256).toString(16).substr(1));
function T1(r) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, t = (Xr[r[e + 0]] + Xr[r[e + 1]] + Xr[r[e + 2]] + Xr[r[e + 3]] + "-" + Xr[r[e + 4]] + Xr[r[e + 5]] + "-" + Xr[r[e + 6]] + Xr[r[e + 7]] + "-" + Xr[r[e + 8]] + Xr[r[e + 9]] + "-" + Xr[r[e + 10]] + Xr[r[e + 11]] + Xr[r[e + 12]] + Xr[r[e + 13]] + Xr[r[e + 14]] + Xr[r[e + 15]]).toLowerCase();
  if (!rY(t))
    throw TypeError("Stringified UUID is invalid");
  return t;
}
var cD, Dy, My = 0, ky = 0;
function rie(r, e, t) {
  var i = e && t || 0, n = e || new Array(16);
  r = r || {};
  var a = r.node || cD, o = r.clockseq !== void 0 ? r.clockseq : Dy;
  if (a == null || o == null) {
    var s = r.random || (r.rng || tY)();
    a == null && (a = cD = [s[0] | 1, s[1], s[2], s[3], s[4], s[5]]), o == null && (o = Dy = (s[6] << 8 | s[7]) & 16383);
  }
  var l = r.msecs !== void 0 ? r.msecs : Date.now(), u = r.nsecs !== void 0 ? r.nsecs : ky + 1, c = l - My + (u - ky) / 1e4;
  if (c < 0 && r.clockseq === void 0 && (o = o + 1 & 16383), (c < 0 || l > My) && r.nsecs === void 0 && (u = 0), u >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  My = l, ky = u, Dy = o, l += 122192928e5;
  var h = ((l & 268435455) * 1e4 + u) % 4294967296;
  n[i++] = h >>> 24 & 255, n[i++] = h >>> 16 & 255, n[i++] = h >>> 8 & 255, n[i++] = h & 255;
  var f = l / 4294967296 * 1e4 & 268435455;
  n[i++] = f >>> 8 & 255, n[i++] = f & 255, n[i++] = f >>> 24 & 15 | 16, n[i++] = f >>> 16 & 255, n[i++] = o >>> 8 | 128, n[i++] = o & 255;
  for (var d = 0; d < 6; ++d)
    n[i + d] = a[d];
  return e || T1(n);
}
function iie(r) {
  if (!rY(r))
    throw TypeError("Invalid UUID");
  var e, t = new Uint8Array(16);
  return t[0] = (e = parseInt(r.slice(0, 8), 16)) >>> 24, t[1] = e >>> 16 & 255, t[2] = e >>> 8 & 255, t[3] = e & 255, t[4] = (e = parseInt(r.slice(9, 13), 16)) >>> 8, t[5] = e & 255, t[6] = (e = parseInt(r.slice(14, 18), 16)) >>> 8, t[7] = e & 255, t[8] = (e = parseInt(r.slice(19, 23), 16)) >>> 8, t[9] = e & 255, t[10] = (e = parseInt(r.slice(24, 36), 16)) / 1099511627776 & 255, t[11] = e / 4294967296 & 255, t[12] = e >>> 24 & 255, t[13] = e >>> 16 & 255, t[14] = e >>> 8 & 255, t[15] = e & 255, t;
}
function nie(r) {
  r = unescape(encodeURIComponent(r));
  for (var e = [], t = 0; t < r.length; ++t)
    e.push(r.charCodeAt(t));
  return e;
}
var aie = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", oie = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function iY(r, e, t) {
  function i(n, a, o, s) {
    if (typeof n == "string" && (n = nie(n)), typeof a == "string" && (a = iie(a)), a.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var l = new Uint8Array(16 + n.length);
    if (l.set(a), l.set(n, a.length), l = t(l), l[6] = l[6] & 15 | e, l[8] = l[8] & 63 | 128, o) {
      s = s || 0;
      for (var u = 0; u < 16; ++u)
        o[s + u] = l[u];
      return o;
    }
    return T1(l);
  }
  try {
    i.name = r;
  } catch {
  }
  return i.DNS = aie, i.URL = oie, i;
}
function sie(r) {
  if (typeof r == "string") {
    var e = unescape(encodeURIComponent(r));
    r = new Uint8Array(e.length);
    for (var t = 0; t < e.length; ++t)
      r[t] = e.charCodeAt(t);
  }
  return lie(uie(cie(r), r.length * 8));
}
function lie(r) {
  for (var e = [], t = r.length * 32, i = "0123456789abcdef", n = 0; n < t; n += 8) {
    var a = r[n >> 5] >>> n % 32 & 255, o = parseInt(i.charAt(a >>> 4 & 15) + i.charAt(a & 15), 16);
    e.push(o);
  }
  return e;
}
function nY(r) {
  return (r + 64 >>> 9 << 4) + 14 + 1;
}
function uie(r, e) {
  r[e >> 5] |= 128 << e % 32, r[nY(e) - 1] = e;
  for (var t = 1732584193, i = -271733879, n = -1732584194, a = 271733878, o = 0; o < r.length; o += 16) {
    var s = t, l = i, u = n, c = a;
    t = oi(t, i, n, a, r[o], 7, -680876936), a = oi(a, t, i, n, r[o + 1], 12, -389564586), n = oi(n, a, t, i, r[o + 2], 17, 606105819), i = oi(i, n, a, t, r[o + 3], 22, -1044525330), t = oi(t, i, n, a, r[o + 4], 7, -176418897), a = oi(a, t, i, n, r[o + 5], 12, 1200080426), n = oi(n, a, t, i, r[o + 6], 17, -1473231341), i = oi(i, n, a, t, r[o + 7], 22, -45705983), t = oi(t, i, n, a, r[o + 8], 7, 1770035416), a = oi(a, t, i, n, r[o + 9], 12, -1958414417), n = oi(n, a, t, i, r[o + 10], 17, -42063), i = oi(i, n, a, t, r[o + 11], 22, -1990404162), t = oi(t, i, n, a, r[o + 12], 7, 1804603682), a = oi(a, t, i, n, r[o + 13], 12, -40341101), n = oi(n, a, t, i, r[o + 14], 17, -1502002290), i = oi(i, n, a, t, r[o + 15], 22, 1236535329), t = si(t, i, n, a, r[o + 1], 5, -165796510), a = si(a, t, i, n, r[o + 6], 9, -1069501632), n = si(n, a, t, i, r[o + 11], 14, 643717713), i = si(i, n, a, t, r[o], 20, -373897302), t = si(t, i, n, a, r[o + 5], 5, -701558691), a = si(a, t, i, n, r[o + 10], 9, 38016083), n = si(n, a, t, i, r[o + 15], 14, -660478335), i = si(i, n, a, t, r[o + 4], 20, -405537848), t = si(t, i, n, a, r[o + 9], 5, 568446438), a = si(a, t, i, n, r[o + 14], 9, -1019803690), n = si(n, a, t, i, r[o + 3], 14, -187363961), i = si(i, n, a, t, r[o + 8], 20, 1163531501), t = si(t, i, n, a, r[o + 13], 5, -1444681467), a = si(a, t, i, n, r[o + 2], 9, -51403784), n = si(n, a, t, i, r[o + 7], 14, 1735328473), i = si(i, n, a, t, r[o + 12], 20, -1926607734), t = li(t, i, n, a, r[o + 5], 4, -378558), a = li(a, t, i, n, r[o + 8], 11, -2022574463), n = li(n, a, t, i, r[o + 11], 16, 1839030562), i = li(i, n, a, t, r[o + 14], 23, -35309556), t = li(t, i, n, a, r[o + 1], 4, -1530992060), a = li(a, t, i, n, r[o + 4], 11, 1272893353), n = li(n, a, t, i, r[o + 7], 16, -155497632), i = li(i, n, a, t, r[o + 10], 23, -1094730640), t = li(t, i, n, a, r[o + 13], 4, 681279174), a = li(a, t, i, n, r[o], 11, -358537222), n = li(n, a, t, i, r[o + 3], 16, -722521979), i = li(i, n, a, t, r[o + 6], 23, 76029189), t = li(t, i, n, a, r[o + 9], 4, -640364487), a = li(a, t, i, n, r[o + 12], 11, -421815835), n = li(n, a, t, i, r[o + 15], 16, 530742520), i = li(i, n, a, t, r[o + 2], 23, -995338651), t = ui(t, i, n, a, r[o], 6, -198630844), a = ui(a, t, i, n, r[o + 7], 10, 1126891415), n = ui(n, a, t, i, r[o + 14], 15, -1416354905), i = ui(i, n, a, t, r[o + 5], 21, -57434055), t = ui(t, i, n, a, r[o + 12], 6, 1700485571), a = ui(a, t, i, n, r[o + 3], 10, -1894986606), n = ui(n, a, t, i, r[o + 10], 15, -1051523), i = ui(i, n, a, t, r[o + 1], 21, -2054922799), t = ui(t, i, n, a, r[o + 8], 6, 1873313359), a = ui(a, t, i, n, r[o + 15], 10, -30611744), n = ui(n, a, t, i, r[o + 6], 15, -1560198380), i = ui(i, n, a, t, r[o + 13], 21, 1309151649), t = ui(t, i, n, a, r[o + 4], 6, -145523070), a = ui(a, t, i, n, r[o + 11], 10, -1120210379), n = ui(n, a, t, i, r[o + 2], 15, 718787259), i = ui(i, n, a, t, r[o + 9], 21, -343485551), t = js(t, s), i = js(i, l), n = js(n, u), a = js(a, c);
  }
  return [t, i, n, a];
}
function cie(r) {
  if (r.length === 0)
    return [];
  for (var e = r.length * 8, t = new Uint32Array(nY(e)), i = 0; i < e; i += 8)
    t[i >> 5] |= (r[i / 8] & 255) << i % 32;
  return t;
}
function js(r, e) {
  var t = (r & 65535) + (e & 65535), i = (r >> 16) + (e >> 16) + (t >> 16);
  return i << 16 | t & 65535;
}
function hie(r, e) {
  return r << e | r >>> 32 - e;
}
function iT(r, e, t, i, n, a) {
  return js(hie(js(js(e, r), js(i, a)), n), t);
}
function oi(r, e, t, i, n, a, o) {
  return iT(e & t | ~e & i, r, e, n, a, o);
}
function si(r, e, t, i, n, a, o) {
  return iT(e & i | t & ~i, r, e, n, a, o);
}
function li(r, e, t, i, n, a, o) {
  return iT(e ^ t ^ i, r, e, n, a, o);
}
function ui(r, e, t, i, n, a, o) {
  return iT(t ^ (e | ~i), r, e, n, a, o);
}
var fie = iY("v3", 48, sie);
const die = fie;
function pie(r, e, t) {
  r = r || {};
  var i = r.random || (r.rng || tY)();
  if (i[6] = i[6] & 15 | 64, i[8] = i[8] & 63 | 128, e) {
    t = t || 0;
    for (var n = 0; n < 16; ++n)
      e[t + n] = i[n];
    return e;
  }
  return T1(i);
}
function gie(r, e, t, i) {
  switch (r) {
    case 0:
      return e & t ^ ~e & i;
    case 1:
      return e ^ t ^ i;
    case 2:
      return e & t ^ e & i ^ t & i;
    case 3:
      return e ^ t ^ i;
  }
}
function Qy(r, e) {
  return r << e | r >>> 32 - e;
}
function vie(r) {
  var e = [1518500249, 1859775393, 2400959708, 3395469782], t = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof r == "string") {
    var i = unescape(encodeURIComponent(r));
    r = [];
    for (var n = 0; n < i.length; ++n)
      r.push(i.charCodeAt(n));
  } else
    Array.isArray(r) || (r = Array.prototype.slice.call(r));
  r.push(128);
  for (var a = r.length / 4 + 2, o = Math.ceil(a / 16), s = new Array(o), l = 0; l < o; ++l) {
    for (var u = new Uint32Array(16), c = 0; c < 16; ++c)
      u[c] = r[l * 64 + c * 4] << 24 | r[l * 64 + c * 4 + 1] << 16 | r[l * 64 + c * 4 + 2] << 8 | r[l * 64 + c * 4 + 3];
    s[l] = u;
  }
  s[o - 1][14] = (r.length - 1) * 8 / Math.pow(2, 32), s[o - 1][14] = Math.floor(s[o - 1][14]), s[o - 1][15] = (r.length - 1) * 8 & 4294967295;
  for (var h = 0; h < o; ++h) {
    for (var f = new Uint32Array(80), d = 0; d < 16; ++d)
      f[d] = s[h][d];
    for (var p = 16; p < 80; ++p)
      f[p] = Qy(f[p - 3] ^ f[p - 8] ^ f[p - 14] ^ f[p - 16], 1);
    for (var g = t[0], v = t[1], O = t[2], m = t[3], E = t[4], b = 0; b < 80; ++b) {
      var S = Math.floor(b / 20), T = Qy(g, 5) + gie(S, v, O, m) + E + e[S] + f[b] >>> 0;
      E = m, m = O, O = Qy(v, 30) >>> 0, v = g, g = T;
    }
    t[0] = t[0] + g >>> 0, t[1] = t[1] + v >>> 0, t[2] = t[2] + O >>> 0, t[3] = t[3] + m >>> 0, t[4] = t[4] + E >>> 0;
  }
  return [t[0] >> 24 & 255, t[0] >> 16 & 255, t[0] >> 8 & 255, t[0] & 255, t[1] >> 24 & 255, t[1] >> 16 & 255, t[1] >> 8 & 255, t[1] & 255, t[2] >> 24 & 255, t[2] >> 16 & 255, t[2] >> 8 & 255, t[2] & 255, t[3] >> 24 & 255, t[3] >> 16 & 255, t[3] >> 8 & 255, t[3] & 255, t[4] >> 24 & 255, t[4] >> 16 & 255, t[4] >> 8 & 255, t[4] & 255];
}
var Oie = iY("v5", 80, vie);
const mie = Oie;
var WE = {
  v1: rie,
  v3: die,
  v4: pie,
  v5: mie
};
const Eie = { class: "ns-sandbox-box" }, bie = ["src", "id", "name", "sandbox"], Sie = /* @__PURE__ */ An({
  __name: "sandbox",
  props: {
    url: {
      type: String,
      default: ""
    },
    limit: {
      // , 
      type: String,
      default: "allow-same-origin allow-scripts allow-forms"
    }
  },
  emits: ["name", "loaded", "change"],
  setup(r, { expose: e, emit: t }) {
    const i = r, n = Rr(), a = Rr(WE.v4()), o = Rr(!1), s = Rr(), l = Rr(!0);
    function u() {
      if (!n.value) {
        setTimeout(() => {
          u();
        }, 100);
        return;
      }
      n.value.onload = function(f) {
        Sc(() => {
          t("loaded", i.url);
        });
      };
    }
    function c(f, d) {
      !o.value || !s.value || s.value.on(f, d);
    }
    function h(f, d) {
      return !o.value || !s.value ? Promise.reject() : s.value.send(f, d);
    }
    return Ra(() => i.url, (f, d) => {
      f && (d || (l.value = !1, Sc(() => {
        l.value = !0;
      })));
    }, {
      immediate: !0
    }), Os(() => {
      u(), t("name", a.value);
    }), e({
      on: c,
      send: h
    }), (f, d) => (xt(), Pr("div", Eie, [
      r.url && l.value ? (xt(), Pr("iframe", {
        key: 0,
        src: r.url,
        id: a.value,
        name: a.value,
        ref_key: "RefIframeBox",
        ref: n,
        sandbox: r.limit.toLocaleLowerCase() === "all" ? "" : r.limit
      }, null, 8, bie)) : Fn("", !0)
    ]));
  }
}), Tie = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box;padding:0}.ns-sandbox-box{width:100%;height:100%;overflow:hidden;box-sizing:border-box;padding:0}.ns-sandbox-box iframe{width:100%;height:100%;overflow:hidden;border:0;padding:0}
`, Es = (r, e) => {
  const t = r.__vccOpts || r;
  for (const [i, n] of e)
    t[i] = n;
  return t;
}, yie = /* @__PURE__ */ Es(Sie, [["styles", [Tie]]]), Rie = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "splitpanes",
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  props: {
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  provide() {
    return {
      requestUpdate: this.requestUpdate,
      onPaneAdd: this.onPaneAdd,
      onPaneRemove: this.onPaneRemove,
      onPaneClick: this.onPaneClick
    };
  },
  data: () => ({
    container: null,
    ready: !1,
    panes: [],
    touch: {
      mouseDown: !1,
      dragging: !1,
      activeSplitter: null
    },
    splitterTaps: {
      // Used to detect double click on touch devices.
      splitter: null,
      timeoutId: null
    }
  }),
  computed: {
    panesCount() {
      return this.panes.length;
    },
    // Indexed panes by `uid` of Pane components for fast lookup.
    // Every time a pane is destroyed this index is recomputed.
    indexedPanes() {
      return this.panes.reduce((r, e) => (r[e.id] = e) && r, {});
    }
  },
  methods: {
    updatePaneComponents() {
      this.panes.forEach((r) => {
        r.update && r.update({
          // Panes are indexed by Pane component uid, as they might be inserted at different index.
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[r.id].size}%`
        });
      });
    },
    bindEvents() {
      document.addEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.addEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.addEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.addEventListener("touchend", this.onMouseUp));
    },
    unbindEvents() {
      document.removeEventListener("mousemove", this.onMouseMove, { passive: !1 }), document.removeEventListener("mouseup", this.onMouseUp), "ontouchstart" in window && (document.removeEventListener("touchmove", this.onMouseMove, { passive: !1 }), document.removeEventListener("touchend", this.onMouseUp));
    },
    onMouseDown(r, e) {
      this.bindEvents(), this.touch.mouseDown = !0, this.touch.activeSplitter = e;
    },
    onMouseMove(r) {
      this.touch.mouseDown && (r.preventDefault(), this.touch.dragging = !0, this.calculatePanesSize(this.getCurrentMouseDrag(r)), this.$emit("resize", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size }))));
    },
    onMouseUp() {
      this.touch.dragging && this.$emit("resized", this.panes.map((r) => ({ min: r.min, max: r.max, size: r.size }))), this.touch.mouseDown = !1, setTimeout(() => {
        this.touch.dragging = !1, this.unbindEvents();
      }, 100);
    },
    // If touch device, detect double tap manually (2 taps separated by less than 500ms).
    onSplitterClick(r, e) {
      "ontouchstart" in window && (r.preventDefault(), this.dblClickSplitter && (this.splitterTaps.splitter === e ? (clearTimeout(this.splitterTaps.timeoutId), this.splitterTaps.timeoutId = null, this.onSplitterDblClick(r, e), this.splitterTaps.splitter = null) : (this.splitterTaps.splitter = e, this.splitterTaps.timeoutId = setTimeout(() => {
        this.splitterTaps.splitter = null;
      }, 500)))), this.touch.dragging || this.$emit("splitter-click", this.panes[e]);
    },
    // On splitter dbl click or dbl tap maximize this pane.
    onSplitterDblClick(r, e) {
      let t = 0;
      this.panes = this.panes.map((i, n) => (i.size = n === e ? i.max : i.min, n !== e && (t += i.min), i)), this.panes[e].size -= t, this.$emit("pane-maximize", this.panes[e]), this.$emit("resized", this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })));
    },
    onPaneClick(r, e) {
      this.$emit("pane-click", this.indexedPanes[e]);
    },
    // Get the cursor position relative to the splitpane container.
    getCurrentMouseDrag(r) {
      const e = this.container.getBoundingClientRect(), { clientX: t, clientY: i } = "ontouchstart" in window && r.touches ? r.touches[0] : r;
      return {
        x: t - e.left,
        y: i - e.top
      };
    },
    // Returns the drag percentage of the splitter relative to the 2 panes it's inbetween.
    // if the sum of size of the 2 cells is 60%, the dragPercentage range will be 0 to 100% of this 60%.
    getCurrentDragPercentage(r) {
      r = r[this.horizontal ? "y" : "x"];
      const e = this.container[this.horizontal ? "clientHeight" : "clientWidth"];
      return this.rtl && !this.horizontal && (r = e - r), r * 100 / e;
    },
    calculatePanesSize(r) {
      const e = this.touch.activeSplitter;
      let t = {
        prevPanesSize: this.sumPrevPanesSize(e),
        nextPanesSize: this.sumNextPanesSize(e),
        prevReachedMinPanes: 0,
        nextReachedMinPanes: 0
      };
      const i = 0 + (this.pushOtherPanes ? 0 : t.prevPanesSize), n = 100 - (this.pushOtherPanes ? 0 : t.nextPanesSize), a = Math.max(Math.min(this.getCurrentDragPercentage(r), n), i);
      let o = [e, e + 1], s = this.panes[o[0]] || null, l = this.panes[o[1]] || null;
      const u = s.max < 100 && a >= s.max + t.prevPanesSize, c = l.max < 100 && a <= 100 - (l.max + this.sumNextPanesSize(e + 1));
      if (u || c) {
        u ? (s.size = s.max, l.size = Math.max(100 - s.max - t.prevPanesSize - t.nextPanesSize, 0)) : (s.size = Math.max(100 - l.max - t.prevPanesSize - this.sumNextPanesSize(e + 1), 0), l.size = l.max);
        return;
      }
      if (this.pushOtherPanes) {
        const h = this.doPushOtherPanes(t, a);
        if (!h)
          return;
        ({ sums: t, panesToResize: o } = h), s = this.panes[o[0]] || null, l = this.panes[o[1]] || null;
      }
      s !== null && (s.size = Math.min(Math.max(a - t.prevPanesSize - t.prevReachedMinPanes, s.min), s.max)), l !== null && (l.size = Math.min(Math.max(100 - a - t.nextPanesSize - t.nextReachedMinPanes, l.min), l.max));
    },
    doPushOtherPanes(r, e) {
      const t = this.touch.activeSplitter, i = [t, t + 1];
      return e < r.prevPanesSize + this.panes[i[0]].min && (i[0] = this.findPrevExpandedPane(t).index, r.prevReachedMinPanes = 0, i[0] < t && this.panes.forEach((n, a) => {
        a > i[0] && a <= t && (n.size = n.min, r.prevReachedMinPanes += n.min);
      }), r.prevPanesSize = this.sumPrevPanesSize(i[0]), i[0] === void 0) ? (r.prevReachedMinPanes = 0, this.panes[0].size = this.panes[0].min, this.panes.forEach((n, a) => {
        a > 0 && a <= t && (n.size = n.min, r.prevReachedMinPanes += n.min);
      }), this.panes[i[1]].size = 100 - r.prevReachedMinPanes - this.panes[0].min - r.prevPanesSize - r.nextPanesSize, null) : e > 100 - r.nextPanesSize - this.panes[i[1]].min && (i[1] = this.findNextExpandedPane(t).index, r.nextReachedMinPanes = 0, i[1] > t + 1 && this.panes.forEach((n, a) => {
        a > t && a < i[1] && (n.size = n.min, r.nextReachedMinPanes += n.min);
      }), r.nextPanesSize = this.sumNextPanesSize(i[1] - 1), i[1] === void 0) ? (r.nextReachedMinPanes = 0, this.panes[this.panesCount - 1].size = this.panes[this.panesCount - 1].min, this.panes.forEach((n, a) => {
        a < this.panesCount - 1 && a >= t + 1 && (n.size = n.min, r.nextReachedMinPanes += n.min);
      }), this.panes[i[0]].size = 100 - r.prevPanesSize - r.nextReachedMinPanes - this.panes[this.panesCount - 1].min - r.nextPanesSize, null) : { sums: r, panesToResize: i };
    },
    sumPrevPanesSize(r) {
      return this.panes.reduce((e, t, i) => e + (i < r ? t.size : 0), 0);
    },
    sumNextPanesSize(r) {
      return this.panes.reduce((e, t, i) => e + (i > r + 1 ? t.size : 0), 0);
    },
    // Return the previous pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findPrevExpandedPane(r) {
      return [...this.panes].reverse().find((t) => t.index < r && t.size > t.min) || {};
    },
    // Return the next pane from siblings which has a size (width for vert or height for horz) of more than 0.
    findNextExpandedPane(r) {
      return this.panes.find((t) => t.index > r + 1 && t.size > t.min) || {};
    },
    checkSplitpanesNodes() {
      Array.from(this.container.children).forEach((e) => {
        const t = e.classList.contains("splitpanes__pane"), i = e.classList.contains("splitpanes__splitter");
        !t && !i && console.warn("Splitpanes: Only <pane> elements are allowed at the root of <splitpanes>. One of your DOM nodes was removed.");
      });
    },
    addSplitter(r, e, t = !1) {
      const i = r - 1, n = document.createElement("div");
      n.classList.add("splitpanes__splitter"), t || (n.onmousedown = (a) => this.onMouseDown(a, i), typeof window < "u" && "ontouchstart" in window && (n.ontouchstart = (a) => this.onMouseDown(a, i)), n.onclick = (a) => this.onSplitterClick(a, i + 1)), this.dblClickSplitter && (n.ondblclick = (a) => this.onSplitterDblClick(a, i + 1)), e.parentNode.insertBefore(n, e);
    },
    removeSplitter(r) {
      r.onmousedown = void 0, r.onclick = void 0, r.ondblclick = void 0, r.parentNode.removeChild(r);
    },
    redoSplitters() {
      const r = Array.from(this.container.children);
      r.forEach((t) => {
        t.className.includes("splitpanes__splitter") && this.removeSplitter(t);
      });
      let e = 0;
      r.forEach((t) => {
        t.className.includes("splitpanes__pane") && (!e && this.firstSplitter ? this.addSplitter(e, t, !0) : e && this.addSplitter(e, t), e++);
      });
    },
    // Called by Pane component on programmatic resize.
    requestUpdate({ target: r, ...e }) {
      const t = this.indexedPanes[r._.uid];
      Object.entries(e).forEach(([i, n]) => t[i] = n);
    },
    onPaneAdd(r) {
      let e = -1;
      Array.from(r.$el.parentNode.children).some((n) => (n.className.includes("splitpanes__pane") && e++, n === r.$el));
      const t = parseFloat(r.minSize), i = parseFloat(r.maxSize);
      this.panes.splice(e, 0, {
        id: r._.uid,
        index: e,
        min: isNaN(t) ? 0 : t,
        max: isNaN(i) ? 100 : i,
        size: r.size === null ? null : parseFloat(r.size),
        givenSize: r.size,
        update: r.update
      }), this.panes.forEach((n, a) => n.index = a), this.ready && this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ addedPane: this.panes[e] }), this.$emit("pane-add", { index: e, panes: this.panes.map((n) => ({ min: n.min, max: n.max, size: n.size })) });
      });
    },
    onPaneRemove(r) {
      const e = this.panes.findIndex((i) => i.id === r._.uid), t = this.panes.splice(e, 1)[0];
      this.panes.forEach((i, n) => i.index = n), this.$nextTick(() => {
        this.redoSplitters(), this.resetPaneSizes({ removedPane: { ...t, index: e } }), this.$emit("pane-remove", { removed: t, panes: this.panes.map((i) => ({ min: i.min, max: i.max, size: i.size })) });
      });
    },
    resetPaneSizes(r = {}) {
      !r.addedPane && !r.removedPane ? this.initialPanesSizing() : this.panes.some((e) => e.givenSize !== null || e.min || e.max < 100) ? this.equalizeAfterAddOrRemove(r) : this.equalize(), this.ready && this.$emit("resized", this.panes.map((e) => ({ min: e.min, max: e.max, size: e.size })));
    },
    equalize() {
      const r = 100 / this.panesCount;
      let e = 0;
      const t = [], i = [];
      this.panes.forEach((n) => {
        n.size = Math.max(Math.min(r, n.max), n.min), e -= n.size, n.size >= n.max && t.push(n.id), n.size <= n.min && i.push(n.id);
      }), e > 0.1 && this.readjustSizes(e, t, i);
    },
    initialPanesSizing() {
      let r = 100;
      const e = [], t = [];
      let i = 0;
      this.panes.forEach((a) => {
        r -= a.size, a.size !== null && i++, a.size >= a.max && e.push(a.id), a.size <= a.min && t.push(a.id);
      });
      let n = 100;
      r > 0.1 && (this.panes.forEach((a) => {
        a.size === null && (a.size = Math.max(Math.min(r / (this.panesCount - i), a.max), a.min)), n -= a.size;
      }), n > 0.1 && this.readjustSizes(r, e, t));
    },
    equalizeAfterAddOrRemove({ addedPane: r, removedPane: e } = {}) {
      let t = 100 / this.panesCount, i = 0;
      const n = [], a = [];
      r && r.givenSize !== null && (t = (100 - r.givenSize) / (this.panesCount - 1)), this.panes.forEach((o) => {
        i -= o.size, o.size >= o.max && n.push(o.id), o.size <= o.min && a.push(o.id);
      }), !(Math.abs(i) < 0.1) && (this.panes.forEach((o) => {
        r && r.givenSize !== null && r.id === o.id || (o.size = Math.max(Math.min(t, o.max), o.min)), i -= o.size, o.size >= o.max && n.push(o.id), o.size <= o.min && a.push(o.id);
      }), i > 0.1 && this.readjustSizes(i, n, a));
    },
    /* recalculatePaneSizes ({ addedPane, removedPane } = {}) {
          let leftToAllocate = 100
          let equalSpaceToAllocate = leftToAllocate / this.panesCount
          let ungrowable = []
          let unshrinkable = []
    
          // When adding a pane with no size, apply min-size if defined otherwise divide another pane
          // (next or prev) in 2.
          // if (addedPane && addedPane.size === null) {
          //   if (addedPane.min) addedPane.size = addedPane.min
          //   else {
          //     const paneToDivide = this.panes[addedPane.index + 1] || this.panes[addedPane.index - 1]
          //     if (paneToDivide) {
          //       // @todo: Dividing that pane in 2 could be incorrect if becoming lower than its min size.
          //       addedPane.size = paneToDivide.size / 2
          //       paneToDivide.size /= 2
          //     }
          //   }
          // }
    
          this.panes.forEach((pane, i) => {
            // Added pane - reduce the size of the next pane.
            if (addedPane && addedPane.index + 1 === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Removed pane - increase the size of the next pane.
            else if (removedPane && removedPane.index === i) {
              pane.size = Math.max(Math.min(100 - this.sumPrevPanesSize(i) - this.sumNextPanesSize(i + 1), pane.max), pane.min)
              // @todo: if could not allocate correctly, try to allocate in the next pane straight away,
              // then still do the second loop if not correct.
            }
    
            // Initial load and on demand recalculation.
            else if (!addedPane && !removedPane && pane.size === null) {
              pane.size = Math.max(Math.min(equalSpaceToAllocate, pane.max), pane.min)
            }
    
            leftToAllocate -= pane.size
    
            if (pane.size >= pane.max) ungrowable.push(pane.id)
            if (pane.size <= pane.min) unshrinkable.push(pane.id)
          })
    
          // Do one more loop to adjust sizes if still wrong.
          // > 0.1: Prevent maths rounding issues due to bytes.
          if (Math.abs(leftToAllocate) > 0.1) this.readjustSizes(leftToAllocate, ungrowable, unshrinkable)
        }, */
    // Second loop to adjust sizes now that we know more about the panes constraints.
    readjustSizes(r, e, t) {
      let i;
      r > 0 ? i = r / (this.panesCount - e.length) : i = r / (this.panesCount - t.length), this.panes.forEach((n, a) => {
        if (r > 0 && !e.includes(n.id)) {
          const o = Math.max(Math.min(n.size + i, n.max), n.min), s = o - n.size;
          r -= s, n.size = o;
        } else if (!t.includes(n.id)) {
          const o = Math.max(Math.min(n.size + i, n.max), n.min), s = o - n.size;
          r -= s, n.size = o;
        }
        n.update({
          [this.horizontal ? "height" : "width"]: `${this.indexedPanes[n.id].size}%`
        });
      }), Math.abs(r) > 0.1 && this.$nextTick(() => {
        this.ready && console.warn("Splitpanes: Could not resize panes correctly due to their constraints.");
      });
    }
    /* distributeEmptySpace () {
          let growablePanes = []
          let collapsedPanesCount = 0
          let growableAmount = 0 // Total of how much the current panes can grow to fill blank space.
          let spaceToDistribute = 100 - this.panes.reduce((sum, pane) => (sum += pane.size) && sum, 0)
          // Do a first loop to determine if we can distribute the new blank space between all the
          // expandedPanes, without expanding the collapsed ones.
          this.panes.forEach(pane => {
            if (pane.size < pane.max) growablePanes.push(pane)
    
            if (!pane.size) collapsedPanesCount++
            else growableAmount += pane.max - pane.size
          })
    
          // If the blank space to distribute is too great for the expanded panes, also expand collapsed ones.
          let expandCollapsedPanes = growableAmount < spaceToDistribute
    
          // New space to distribute equally.
          let growablePanesCount = (growablePanes.length - (expandCollapsedPanes ? 0 : collapsedPanesCount))
          let equalSpaceToDistribute = spaceToDistribute / growablePanesCount
          // if (growablePanesCount === 1) equalSpace = 100 / this.panesCount
          let spaceLeftToDistribute = spaceToDistribute
    
          // Now add the equalSpaceToDistribute to each pane size accordingly.
          growablePanes.forEach(pane => {
            if (pane.size < pane.max && (pane.size || (!pane.size && expandCollapsedPanes))) {
              const newSize = Math.min(pane.size + equalSpaceToDistribute, pane.max)
              let allocatedSpace = (newSize - pane.size)
              spaceLeftToDistribute -= allocatedSpace
              pane.size = newSize
              // If the equalSpaceToDistribute is not fully added to the current pane, distribute the remainder
              // to the next panes.
              // Also fix decimal issue due to bites - E.g. calculating 8.33 and getting 8.3299999999999
              if (equalSpaceToDistribute - allocatedSpace > 0.1) equalSpaceToDistribute = spaceLeftToDistribute / (--growablePanesCount)
            }
          })
    
          /* Disabled otherwise will show up on hot reload.
          // if there is still space to allocate show warning message.
          if (this.panesCount && ~~spaceLeftToDistribute) {
            // eslint-disable-next-line no-console
            console.warn('Splitpanes: Could not distribute all the empty space between panes due to their constraints.')
          } *\/
    
          this.$emit('resized', this.panes.map(pane => ({ min: pane.min, max: pane.max, size: pane.size })))
        } */
  },
  watch: {
    panes: {
      // Every time a pane is updated, update the panes accordingly.
      deep: !0,
      immediate: !1,
      handler() {
        this.updatePaneComponents();
      }
    },
    horizontal() {
      this.updatePaneComponents();
    },
    firstSplitter() {
      this.redoSplitters();
    },
    dblClickSplitter(r) {
      [...this.container.querySelectorAll(".splitpanes__splitter")].forEach((t, i) => {
        t.ondblclick = r ? (n) => this.onSplitterDblClick(n, i) : void 0;
      });
    }
  },
  beforeUnmount() {
    this.ready = !1;
  },
  mounted() {
    this.container = this.$refs.container, this.checkSplitpanesNodes(), this.redoSplitters(), this.resetPaneSizes(), this.$emit("ready"), this.ready = !0;
  },
  render() {
    return Wl(
      "div",
      {
        ref: "container",
        class: [
          "splitpanes",
          "default-theme",
          `splitpanes--${this.horizontal ? "horizontal" : "vertical"}`,
          {
            "splitpanes--dragging": this.touch.dragging
          }
        ]
      },
      this.$slots.default()
    );
  }
}, Aie = {
  // eslint-disable-next-line vue/multi-word-component-names
  name: "pane",
  inject: ["requestUpdate", "onPaneAdd", "onPaneRemove", "onPaneClick"],
  props: {
    size: { type: [Number, String], default: null },
    minSize: { type: [Number, String], default: 0 },
    maxSize: { type: [Number, String], default: 100 }
  },
  data: () => ({
    style: {}
  }),
  mounted() {
    this.onPaneAdd(this);
  },
  beforeUnmount() {
    this.onPaneRemove(this);
  },
  methods: {
    // Called from the splitpanes component.
    update(r) {
      this.style = r;
    }
  },
  computed: {
    sizeNumber() {
      return this.size || this.size === 0 ? parseFloat(this.size) : null;
    },
    minSizeNumber() {
      return parseFloat(this.minSize);
    },
    maxSizeNumber() {
      return parseFloat(this.maxSize);
    }
  },
  watch: {
    sizeNumber(r) {
      this.requestUpdate({ target: this, size: r });
    },
    minSizeNumber(r) {
      this.requestUpdate({ target: this, min: r });
    },
    maxSizeNumber(r) {
      this.requestUpdate({ target: this, max: r });
    }
  }
};
function _ie(r, e, t, i, n, a) {
  return xt(), Pr("div", {
    class: "splitpanes__pane",
    onClick: e[0] || (e[0] = (o) => a.onPaneClick(o, r._.uid)),
    style: Na(r.style)
  }, [
    Di(r.$slots, "default")
  ], 4);
}
const Cie = /* @__PURE__ */ Es(Aie, [["render", _ie]]), Iie = { class: "pane-box" }, wie = /* @__PURE__ */ An({
  __name: "splitpane",
  props: {
    keys: {
      type: Array,
      default: () => []
    },
    size: {
      type: Array,
      default: () => [25, 25, 25, 25]
    },
    minSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    maxSize: {
      type: Array,
      default: () => [0, 0, 0, 0]
    },
    horizontal: { type: Boolean },
    pushOtherPanes: { type: Boolean, default: !0 },
    dblClickSplitter: { type: Boolean, default: !0 },
    rtl: { type: Boolean, default: !1 },
    // Right to left direction.
    firstSplitter: { type: Boolean }
  },
  emits: ["ready", "resize", "resized", "pane-click", "pane-maximize", "pane-add", "pane-remove", "splitter-click"],
  setup(r, { emit: e }) {
    return (t, i) => (xt(), va(Rie, {
      onReady: i[0] || (i[0] = (n) => e("ready", n)),
      onResize: i[1] || (i[1] = (n) => e("resize", n)),
      onResized: i[2] || (i[2] = (n) => e("resized", n)),
      onPaneClick: i[3] || (i[3] = (n) => e("pane-click", n)),
      onPaneMaximize: i[4] || (i[4] = (n) => e("pane-maximize", n)),
      onPaneAdd: i[5] || (i[5] = (n) => e("pane-add", n)),
      onPaneRemove: i[6] || (i[6] = (n) => e("pane-remove", n)),
      onSplitterClick: i[7] || (i[7] = (n) => e("splitter-click", n)),
      horizontal: r.horizontal,
      pushOtherPanes: r.pushOtherPanes,
      dblClickSplitter: r.dblClickSplitter,
      rtl: r.rtl,
      firstSplitter: r.firstSplitter
    }, {
      default: vg(() => [
        (xt(!0), Pr(xr, null, OF(r.keys, (n, a) => (xt(), va(Cie, {
          size: r.size[a] ? r.size[a] : 10,
          "min-size": r.minSize[a] ? r.minSize[a] : 0,
          "max-size": r.maxSize[a] ? r.maxSize[a] : 100
        }, {
          default: vg(() => [
            er("div", Iie, [
              Di(t.$slots, n)
            ])
          ]),
          _: 2
        }, 1032, ["size", "min-size", "max-size"]))), 256))
      ]),
      _: 3
    }, 8, ["horizontal", "pushOtherPanes", "dblClickSplitter", "rtl", "firstSplitter"]));
  }
}), Nie = `:host{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.splitpanes{display:flex;width:100%;height:100%}.splitpanes--vertical{flex-direction:row}.splitpanes--horizontal{flex-direction:column}.splitpanes--dragging *{-webkit-user-select:none;user-select:none}.splitpanes__pane{width:100%;height:100%;overflow:hidden}.splitpanes--vertical .splitpanes__pane{transition:width .2s ease-out}.splitpanes--horizontal .splitpanes__pane{transition:height .2s ease-out}.splitpanes--dragging .splitpanes__pane{transition:none}.splitpanes__splitter{touch-action:none}.splitpanes--vertical>.splitpanes__splitter{min-width:1px;cursor:col-resize}.splitpanes--horizontal>.splitpanes__splitter{min-height:1px;cursor:row-resize}.splitpanes.default-theme .splitpanes__pane{background-color:#f2f2f2}.splitpanes.default-theme .splitpanes__splitter{background-color:#fff;box-sizing:border-box;position:relative;flex-shrink:0}.splitpanes.default-theme .splitpanes__splitter:before,.splitpanes.default-theme .splitpanes__splitter:after{content:"";position:absolute;top:50%;left:50%;background-color:#00000026;transition:background-color .3s}.splitpanes.default-theme .splitpanes__splitter:hover:before,.splitpanes.default-theme .splitpanes__splitter:hover:after{background-color:#00000040}.splitpanes.default-theme .splitpanes__splitter:first-child{cursor:auto}.default-theme.splitpanes .splitpanes .splitpanes__splitter{z-index:1}.default-theme.splitpanes--vertical>.splitpanes__splitter,.default-theme .splitpanes--vertical>.splitpanes__splitter{width:7px;border-left:1px solid #eee;margin-left:-1px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{transform:translateY(-50%);width:1px;height:30px}.default-theme.splitpanes--vertical>.splitpanes__splitter:before,.default-theme .splitpanes--vertical>.splitpanes__splitter:before{margin-left:-2px}.default-theme.splitpanes--vertical>.splitpanes__splitter:after,.default-theme .splitpanes--vertical>.splitpanes__splitter:after{margin-left:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter,.default-theme .splitpanes--horizontal>.splitpanes__splitter{height:7px;border-top:1px solid #eee;margin-top:-1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{transform:translate(-50%);width:30px;height:1px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:before,.default-theme .splitpanes--horizontal>.splitpanes__splitter:before{margin-top:-2px}.default-theme.splitpanes--horizontal>.splitpanes__splitter:after,.default-theme .splitpanes--horizontal>.splitpanes__splitter:after{margin-top:1px}
`, xie = `.pane-box{height:100%;width:100%;background-color:#fff;box-sizing:border-box;overflow:hidden;overflow-y:auto;overflow-x:auto;border-radius:4px}.splitpanes__splitter{background-color:#f0f0f0!important}
`, Pie = /* @__PURE__ */ Es(wie, [["styles", [Nie, xie]]]);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var C_ = function(r, e) {
  return C_ = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t, i) {
    t.__proto__ = i;
  } || function(t, i) {
    for (var n in i)
      Object.prototype.hasOwnProperty.call(i, n) && (t[n] = i[n]);
  }, C_(r, e);
};
function $(r, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Class extends value " + String(e) + " is not a constructor or null");
  C_(r, e);
  function t() {
    this.constructor = r;
  }
  r.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
var Lie = function() {
  function r() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return r;
}(), Die = function() {
  function r() {
    this.browser = new Lie(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return r;
}(), Iu = new Die();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (Iu.wxa = !0, Iu.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? Iu.worker = !0 : typeof navigator > "u" ? (Iu.node = !0, Iu.svgSupported = !0) : Mie(navigator.userAgent, Iu);
function Mie(r, e) {
  var t = e.browser, i = r.match(/Firefox\/([\d.]+)/), n = r.match(/MSIE\s([\d.]+)/) || r.match(/Trident\/.+?rv:(([\d.]+))/), a = r.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(r);
  i && (t.firefox = !0, t.version = i[1]), n && (t.ie = !0, t.version = n[1]), a && (t.edge = !0, t.version = a[1], t.newEdge = +a[1].split(".")[0] > 18), o && (t.weChat = !0), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u";
  var s = document.documentElement.style;
  e.transform3dSupported = (t.ie && "transition" in s || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9;
}
const ct = Iu;
var y1 = 12, aY = "sans-serif", Cl = y1 + "px " + aY, kie = 20, Qie = 100, Uie = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function $ie(r) {
  var e = {};
  if (typeof JSON > "u")
    return e;
  for (var t = 0; t < r.length; t++) {
    var i = String.fromCharCode(t + 32), n = (r.charCodeAt(t) - kie) / Qie;
    e[i] = n;
  }
  return e;
}
var Vie = $ie(Uie), Il = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: function() {
    var r, e;
    return function(t, i) {
      if (!r) {
        var n = Il.createCanvas();
        r = n && n.getContext("2d");
      }
      if (r)
        return e !== i && (e = r.font = i || Cl), r.measureText(t);
      t = t || "", i = i || Cl;
      var a = /(\d+)px/.exec(i), o = a && +a[1] || y1, s = 0;
      if (i.indexOf("mono") >= 0)
        s = o * t.length;
      else
        for (var l = 0; l < t.length; l++) {
          var u = Vie[t[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  }(),
  loadImage: function(r, e, t) {
    var i = new Image();
    return i.onload = e, i.onerror = t, i.src = r, i;
  }
}, oY = To([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(r, e) {
  return r["[object " + e + "]"] = !0, r;
}, {}), sY = To([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(r, e) {
  return r["[object " + e + "Array]"] = !0, r;
}, {}), zf = Object.prototype.toString, nT = Array.prototype, Gie = nT.forEach, Bie = nT.filter, R1 = nT.slice, Fie = nT.map, hD = (function() {
}).constructor, pO = hD ? hD.prototype : null, A1 = "__proto__", Xie = 2311;
function lY() {
  return Xie++;
}
function _a() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  typeof console < "u" && console.error.apply(console, r);
}
function ye(r) {
  if (r == null || typeof r != "object")
    return r;
  var e = r, t = zf.call(r);
  if (t === "[object Array]") {
    if (!Fp(r)) {
      e = [];
      for (var i = 0, n = r.length; i < n; i++)
        e[i] = ye(r[i]);
    }
  } else if (sY[t]) {
    if (!Fp(r)) {
      var a = r.constructor;
      if (a.from)
        e = a.from(r);
      else {
        e = new a(r.length);
        for (var i = 0, n = r.length; i < n; i++)
          e[i] = r[i];
      }
    }
  } else if (!oY[t] && !Fp(r) && !_g(r)) {
    e = {};
    for (var o in r)
      r.hasOwnProperty(o) && o !== A1 && (e[o] = ye(r[o]));
  }
  return e;
}
function $e(r, e, t) {
  if (!be(e) || !be(r))
    return t ? ye(e) : r;
  for (var i in e)
    if (e.hasOwnProperty(i) && i !== A1) {
      var n = r[i], a = e[i];
      be(a) && be(n) && !X(a) && !X(n) && !_g(a) && !_g(n) && !fD(a) && !fD(n) && !Fp(a) && !Fp(n) ? $e(n, a, t) : (t || !(i in r)) && (r[i] = ye(e[i]));
    }
  return r;
}
function _1(r, e) {
  for (var t = r[0], i = 1, n = r.length; i < n; i++)
    t = $e(t, r[i], e);
  return t;
}
function B(r, e) {
  if (Object.assign)
    Object.assign(r, e);
  else
    for (var t in e)
      e.hasOwnProperty(t) && t !== A1 && (r[t] = e[t]);
  return r;
}
function Te(r, e, t) {
  for (var i = Ze(e), n = 0; n < i.length; n++) {
    var a = i[n];
    (t ? e[a] != null : r[a] == null) && (r[a] = e[a]);
  }
  return r;
}
function Fe(r, e) {
  if (r) {
    if (r.indexOf)
      return r.indexOf(e);
    for (var t = 0, i = r.length; t < i; t++)
      if (r[t] === e)
        return t;
  }
  return -1;
}
function Yie(r, e) {
  var t = r.prototype;
  function i() {
  }
  i.prototype = e.prototype, r.prototype = new i();
  for (var n in t)
    t.hasOwnProperty(n) && (r.prototype[n] = t[n]);
  r.prototype.constructor = r, r.superClass = e;
}
function br(r, e, t) {
  if (r = "prototype" in r ? r.prototype : r, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames)
    for (var i = Object.getOwnPropertyNames(e), n = 0; n < i.length; n++) {
      var a = i[n];
      a !== "constructor" && (t ? e[a] != null : r[a] == null) && (r[a] = e[a]);
    }
  else
    Te(r, e, t);
}
function mi(r) {
  return !r || typeof r == "string" ? !1 : typeof r.length == "number";
}
function N(r, e, t) {
  if (r && e)
    if (r.forEach && r.forEach === Gie)
      r.forEach(e, t);
    else if (r.length === +r.length)
      for (var i = 0, n = r.length; i < n; i++)
        e.call(t, r[i], i, r);
    else
      for (var a in r)
        r.hasOwnProperty(a) && e.call(t, r[a], a, r);
}
function Y(r, e, t) {
  if (!r)
    return [];
  if (!e)
    return C1(r);
  if (r.map && r.map === Fie)
    return r.map(e, t);
  for (var i = [], n = 0, a = r.length; n < a; n++)
    i.push(e.call(t, r[n], n, r));
  return i;
}
function To(r, e, t, i) {
  if (r && e) {
    for (var n = 0, a = r.length; n < a; n++)
      t = e.call(i, t, r[n], n, r);
    return t;
  }
}
function At(r, e, t) {
  if (!r)
    return [];
  if (!e)
    return C1(r);
  if (r.filter && r.filter === Bie)
    return r.filter(e, t);
  for (var i = [], n = 0, a = r.length; n < a; n++)
    e.call(t, r[n], n, r) && i.push(r[n]);
  return i;
}
function Hie(r, e, t) {
  if (r && e) {
    for (var i = 0, n = r.length; i < n; i++)
      if (e.call(t, r[i], i, r))
        return r[i];
  }
}
function Ze(r) {
  if (!r)
    return [];
  if (Object.keys)
    return Object.keys(r);
  var e = [];
  for (var t in r)
    r.hasOwnProperty(t) && e.push(t);
  return e;
}
function Wie(r, e) {
  for (var t = [], i = 2; i < arguments.length; i++)
    t[i - 2] = arguments[i];
  return function() {
    return r.apply(e, t.concat(R1.call(arguments)));
  };
}
var ue = pO && ve(pO.bind) ? pO.call.bind(pO.bind) : Wie;
function Le(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return function() {
    return r.apply(this, e.concat(R1.call(arguments)));
  };
}
function X(r) {
  return Array.isArray ? Array.isArray(r) : zf.call(r) === "[object Array]";
}
function ve(r) {
  return typeof r == "function";
}
function ne(r) {
  return typeof r == "string";
}
function zE(r) {
  return zf.call(r) === "[object String]";
}
function pt(r) {
  return typeof r == "number";
}
function be(r) {
  var e = typeof r;
  return e === "function" || !!r && e === "object";
}
function fD(r) {
  return !!oY[zf.call(r)];
}
function en(r) {
  return !!sY[zf.call(r)];
}
function _g(r) {
  return typeof r == "object" && typeof r.nodeType == "number" && typeof r.ownerDocument == "object";
}
function aT(r) {
  return r.colorStops != null;
}
function zie(r) {
  return r.image != null;
}
function uY(r) {
  return zf.call(r) === "[object RegExp]";
}
function Cc(r) {
  return r !== r;
}
function vr() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  for (var t = 0, i = r.length; t < i; t++)
    if (r[t] != null)
      return r[t];
}
function ke(r, e) {
  return r ?? e;
}
function Kn(r, e, t) {
  return r ?? e ?? t;
}
function C1(r) {
  for (var e = [], t = 1; t < arguments.length; t++)
    e[t - 1] = arguments[t];
  return R1.apply(r, e);
}
function I1(r) {
  if (typeof r == "number")
    return [r, r, r, r];
  var e = r.length;
  return e === 2 ? [r[0], r[1], r[0], r[1]] : e === 3 ? [r[0], r[1], r[2], r[1]] : r;
}
function Se(r, e) {
  if (!r)
    throw new Error(e);
}
function Ea(r) {
  return r == null ? null : typeof r.trim == "function" ? r.trim() : r.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var cY = "__ec_primitive__";
function ZE(r) {
  r[cY] = !0;
}
function Fp(r) {
  return r[cY];
}
var Zie = function() {
  function r() {
    this.data = {};
  }
  return r.prototype.delete = function(e) {
    var t = this.has(e);
    return t && delete this.data[e], t;
  }, r.prototype.has = function(e) {
    return this.data.hasOwnProperty(e);
  }, r.prototype.get = function(e) {
    return this.data[e];
  }, r.prototype.set = function(e, t) {
    return this.data[e] = t, this;
  }, r.prototype.keys = function() {
    return Ze(this.data);
  }, r.prototype.forEach = function(e) {
    var t = this.data;
    for (var i in t)
      t.hasOwnProperty(i) && e(t[i], i);
  }, r;
}(), hY = typeof Map == "function";
function qie() {
  return hY ? /* @__PURE__ */ new Map() : new Zie();
}
var jie = function() {
  function r(e) {
    var t = X(e);
    this.data = qie();
    var i = this;
    e instanceof r ? e.each(n) : e && N(e, n);
    function n(a, o) {
      t ? i.set(a, o) : i.set(o, a);
    }
  }
  return r.prototype.hasKey = function(e) {
    return this.data.has(e);
  }, r.prototype.get = function(e) {
    return this.data.get(e);
  }, r.prototype.set = function(e, t) {
    return this.data.set(e, t), t;
  }, r.prototype.each = function(e, t) {
    this.data.forEach(function(i, n) {
      e.call(t, i, n);
    });
  }, r.prototype.keys = function() {
    var e = this.data.keys();
    return hY ? Array.from(e) : e;
  }, r.prototype.removeKey = function(e) {
    this.data.delete(e);
  }, r;
}();
function de(r) {
  return new jie(r);
}
function qE(r, e) {
  for (var t = new r.constructor(r.length + e.length), i = 0; i < r.length; i++)
    t[i] = r[i];
  for (var n = r.length, i = 0; i < e.length; i++)
    t[i + n] = e[i];
  return t;
}
function oT(r, e) {
  var t;
  if (Object.create)
    t = Object.create(r);
  else {
    var i = function() {
    };
    i.prototype = r, t = new i();
  }
  return e && B(t, e), t;
}
function fY(r) {
  var e = r.style;
  e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none";
}
function le(r, e) {
  return r.hasOwnProperty(e);
}
function ur() {
}
var Fm = 180 / Math.PI;
function Wc(r, e) {
  return r == null && (r = 0), e == null && (e = 0), [r, e];
}
function _i(r, e) {
  return r[0] = e[0], r[1] = e[1], r;
}
function Zo(r) {
  return [r[0], r[1]];
}
function Kie(r, e, t) {
  return r[0] = e, r[1] = t, r;
}
function dD(r, e, t) {
  return r[0] = e[0] + t[0], r[1] = e[1] + t[1], r;
}
function I_(r, e, t, i) {
  return r[0] = e[0] + t[0] * i, r[1] = e[1] + t[1] * i, r;
}
function Wu(r, e, t) {
  return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r;
}
function w_(r) {
  return Math.sqrt(Jie(r));
}
function Jie(r) {
  return r[0] * r[0] + r[1] * r[1];
}
function Xm(r, e, t) {
  return r[0] = e[0] * t, r[1] = e[1] * t, r;
}
function Zf(r, e) {
  var t = w_(e);
  return t === 0 ? (r[0] = 0, r[1] = 0) : (r[0] = e[0] / t, r[1] = e[1] / t), r;
}
function N_(r, e) {
  return Math.sqrt((r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]));
}
var Ks = N_;
function ene(r, e) {
  return (r[0] - e[0]) * (r[0] - e[0]) + (r[1] - e[1]) * (r[1] - e[1]);
}
var cc = ene;
function Ym(r, e, t, i) {
  return r[0] = e[0] + i * (t[0] - e[0]), r[1] = e[1] + i * (t[1] - e[1]), r;
}
function Kr(r, e, t) {
  var i = e[0], n = e[1];
  return r[0] = t[0] * i + t[2] * n + t[4], r[1] = t[1] * i + t[3] * n + t[5], r;
}
function Js(r, e, t) {
  return r[0] = Math.min(e[0], t[0]), r[1] = Math.min(e[1], t[1]), r;
}
function el(r, e, t) {
  return r[0] = Math.max(e[0], t[0]), r[1] = Math.max(e[1], t[1]), r;
}
var uh = function() {
  function r(e, t) {
    this.target = e, this.topTarget = t && t.topTarget;
  }
  return r;
}(), tne = function() {
  function r(e) {
    this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this);
  }
  return r.prototype._dragStart = function(e) {
    for (var t = e.target; t && !t.draggable; )
      t = t.parent || t.__hostTarget;
    t && (this._draggingTarget = t, t.dragging = !0, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new uh(t, e), "dragstart", e.event));
  }, r.prototype._drag = function(e) {
    var t = this._draggingTarget;
    if (t) {
      var i = e.offsetX, n = e.offsetY, a = i - this._x, o = n - this._y;
      this._x = i, this._y = n, t.drift(a, o, e), this.handler.dispatchToElement(new uh(t, e), "drag", e.event);
      var s = this.handler.findHover(i, n, t).target, l = this._dropTarget;
      this._dropTarget = s, t !== s && (l && s !== l && this.handler.dispatchToElement(new uh(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new uh(s, e), "dragenter", e.event));
    }
  }, r.prototype._dragEnd = function(e) {
    var t = this._draggingTarget;
    t && (t.dragging = !1), this.handler.dispatchToElement(new uh(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new uh(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null;
  }, r;
}();
const rne = tne;
var ine = function() {
  function r(e) {
    e && (this._$eventProcessor = e);
  }
  return r.prototype.on = function(e, t, i, n) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof t == "function" && (n = i, i = t, t = null), !i || !e)
      return this;
    var o = this._$eventProcessor;
    t != null && o && o.normalizeQuery && (t = o.normalizeQuery(t)), a[e] || (a[e] = []);
    for (var s = 0; s < a[e].length; s++)
      if (a[e][s].h === i)
        return this;
    var l = {
      h: i,
      query: t,
      ctx: n || this,
      callAtLast: i.zrEventfulCallAtLast
    }, u = a[e].length - 1, c = a[e][u];
    return c && c.callAtLast ? a[e].splice(u, 0, l) : a[e].push(l), this;
  }, r.prototype.isSilent = function(e) {
    var t = this._$handlers;
    return !t || !t[e] || !t[e].length;
  }, r.prototype.off = function(e, t) {
    var i = this._$handlers;
    if (!i)
      return this;
    if (!e)
      return this._$handlers = {}, this;
    if (t) {
      if (i[e]) {
        for (var n = [], a = 0, o = i[e].length; a < o; a++)
          i[e][a].h !== t && n.push(i[e][a]);
        i[e] = n;
      }
      i[e] && i[e].length === 0 && delete i[e];
    } else
      delete i[e];
    return this;
  }, r.prototype.trigger = function(e) {
    for (var t = [], i = 1; i < arguments.length; i++)
      t[i - 1] = arguments[i];
    if (!this._$handlers)
      return this;
    var n = this._$handlers[e], a = this._$eventProcessor;
    if (n)
      for (var o = t.length, s = n.length, l = 0; l < s; l++) {
        var u = n[l];
        if (!(a && a.filter && u.query != null && !a.filter(e, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, t[0]);
              break;
            case 2:
              u.h.call(u.ctx, t[0], t[1]);
              break;
            default:
              u.h.apply(u.ctx, t);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, r.prototype.triggerWithContext = function(e) {
    for (var t = [], i = 1; i < arguments.length; i++)
      t[i - 1] = arguments[i];
    if (!this._$handlers)
      return this;
    var n = this._$handlers[e], a = this._$eventProcessor;
    if (n)
      for (var o = t.length, s = t[o - 1], l = n.length, u = 0; u < l; u++) {
        var c = n[u];
        if (!(a && a.filter && c.query != null && !a.filter(e, c.query)))
          switch (o) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, t[0]);
              break;
            case 2:
              c.h.call(s, t[0], t[1]);
              break;
            default:
              c.h.apply(s, t.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(e), this;
  }, r;
}();
const oa = ine;
var nne = Math.log(2);
function x_(r, e, t, i, n, a) {
  var o = i + "-" + n, s = r.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (e === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~n) / nne);
    return r[t][l];
  }
  for (var u = i | 1 << t, c = t + 1; i & 1 << c; )
    c++;
  for (var h = 0, f = 0, d = 0; f < s; f++) {
    var p = 1 << f;
    p & n || (h += (d % 2 ? -1 : 1) * r[t][f] * x_(r, e - 1, c, u, n | p, a), d++);
  }
  return a[o] = h, h;
}
function pD(r, e) {
  var t = [
    [r[0], r[1], 1, 0, 0, 0, -e[0] * r[0], -e[0] * r[1]],
    [0, 0, 0, r[0], r[1], 1, -e[1] * r[0], -e[1] * r[1]],
    [r[2], r[3], 1, 0, 0, 0, -e[2] * r[2], -e[2] * r[3]],
    [0, 0, 0, r[2], r[3], 1, -e[3] * r[2], -e[3] * r[3]],
    [r[4], r[5], 1, 0, 0, 0, -e[4] * r[4], -e[4] * r[5]],
    [0, 0, 0, r[4], r[5], 1, -e[5] * r[4], -e[5] * r[5]],
    [r[6], r[7], 1, 0, 0, 0, -e[6] * r[6], -e[6] * r[7]],
    [0, 0, 0, r[6], r[7], 1, -e[7] * r[6], -e[7] * r[7]]
  ], i = {}, n = x_(t, 8, 0, 0, 0, i);
  if (n !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * x_(t, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, i) / n * e[o];
    return function(l, u, c) {
      var h = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
    };
  }
}
var gD = "___zrEVENTSAVED", Uy = [];
function ane(r, e, t, i, n) {
  return P_(Uy, e, i, n, !0) && P_(r, t, Uy[0], Uy[1]);
}
function P_(r, e, t, i, n) {
  if (e.getBoundingClientRect && ct.domSupported && !dY(e)) {
    var a = e[gD] || (e[gD] = {}), o = one(e, a), s = sne(o, a, n);
    if (s)
      return s(r, t, i), !0;
  }
  return !1;
}
function one(r, e) {
  var t = e.markers;
  if (t)
    return t;
  t = e.markers = [];
  for (var i = ["left", "right"], n = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      i[l] + ":0",
      n[u] + ":0",
      i[1 - l] + ":auto",
      n[1 - u] + ":auto",
      ""
    ].join("!important;"), r.appendChild(o), t.push(o);
  }
  return t;
}
function sne(r, e, t) {
  for (var i = t ? "invTrans" : "trans", n = e[i], a = e.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = r[u].getBoundingClientRect(), h = 2 * u, f = c.left, d = c.top;
    o.push(f, d), l = l && a && f === a[h] && d === a[h + 1], s.push(r[u].offsetLeft, r[u].offsetTop);
  }
  return l && n ? n : (e.srcCoords = o, e[i] = t ? pD(s, o) : pD(o, s));
}
function dY(r) {
  return r.nodeName.toUpperCase() === "CANVAS";
}
var lne = /([&<>"'])/g, une = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Yi(r) {
  return r == null ? "" : (r + "").replace(lne, function(e, t) {
    return une[t];
  });
}
var cne = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, $y = [], hne = ct.browser.firefox && +ct.browser.version.split(".")[0] < 39;
function L_(r, e, t, i) {
  return t = t || {}, i ? vD(r, e, t) : hne && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : vD(r, e, t), t;
}
function vD(r, e, t) {
  if (ct.domSupported && r.getBoundingClientRect) {
    var i = e.clientX, n = e.clientY;
    if (dY(r)) {
      var a = r.getBoundingClientRect();
      t.zrX = i - a.left, t.zrY = n - a.top;
      return;
    } else if (P_($y, r, i, n)) {
      t.zrX = $y[0], t.zrY = $y[1];
      return;
    }
  }
  t.zrX = t.zrY = 0;
}
function w1(r) {
  return r || window.event;
}
function kn(r, e, t) {
  if (e = w1(e), e.zrX != null)
    return e;
  var i = e.type, n = i && i.indexOf("touch") >= 0;
  if (n) {
    var o = i !== "touchend" ? e.targetTouches[0] : e.changedTouches[0];
    o && L_(r, o, e, t);
  } else {
    L_(r, e, e, t);
    var a = fne(e);
    e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3;
  }
  var s = e.button;
  return e.which == null && s !== void 0 && cne.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e;
}
function fne(r) {
  var e = r.wheelDelta;
  if (e)
    return e;
  var t = r.deltaX, i = r.deltaY;
  if (t == null || i == null)
    return e;
  var n = Math.abs(i !== 0 ? i : t), a = i > 0 ? -1 : i < 0 ? 1 : t > 0 ? -1 : 1;
  return 3 * n * a;
}
function D_(r, e, t, i) {
  r.addEventListener(e, t, i);
}
function dne(r, e, t, i) {
  r.removeEventListener(e, t, i);
}
var os = function(r) {
  r.preventDefault(), r.stopPropagation(), r.cancelBubble = !0;
};
function OD(r) {
  return r.which === 2 || r.which === 3;
}
var pne = function() {
  function r() {
    this._track = [];
  }
  return r.prototype.recognize = function(e, t, i) {
    return this._doTrack(e, t, i), this._recognize(e);
  }, r.prototype.clear = function() {
    return this._track.length = 0, this;
  }, r.prototype._doTrack = function(e, t, i) {
    var n = e.touches;
    if (n) {
      for (var a = {
        points: [],
        touches: [],
        target: t,
        event: e
      }, o = 0, s = n.length; o < s; o++) {
        var l = n[o], u = L_(i, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, r.prototype._recognize = function(e) {
    for (var t in Vy)
      if (Vy.hasOwnProperty(t)) {
        var i = Vy[t](this._track, e);
        if (i)
          return i;
      }
  }, r;
}();
function mD(r) {
  var e = r[1][0] - r[0][0], t = r[1][1] - r[0][1];
  return Math.sqrt(e * e + t * t);
}
function gne(r) {
  return [
    (r[0][0] + r[1][0]) / 2,
    (r[0][1] + r[1][1]) / 2
  ];
}
var Vy = {
  pinch: function(r, e) {
    var t = r.length;
    if (t) {
      var i = (r[t - 1] || {}).points, n = (r[t - 2] || {}).points || i;
      if (n && n.length > 1 && i && i.length > 1) {
        var a = mD(i) / mD(n);
        !isFinite(a) && (a = 1), e.pinchScale = a;
        var o = gne(i);
        return e.pinchX = o[0], e.pinchY = o[1], {
          type: "pinch",
          target: r[0].target,
          event: e
        };
      }
    }
  }
};
function na() {
  return [1, 0, 0, 1, 0, 0];
}
function sT(r) {
  return r[0] = 1, r[1] = 0, r[2] = 0, r[3] = 1, r[4] = 0, r[5] = 0, r;
}
function N1(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4], r[5] = e[5], r;
}
function qo(r, e, t) {
  var i = e[0] * t[0] + e[2] * t[1], n = e[1] * t[0] + e[3] * t[1], a = e[0] * t[2] + e[2] * t[3], o = e[1] * t[2] + e[3] * t[3], s = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5];
  return r[0] = i, r[1] = n, r[2] = a, r[3] = o, r[4] = s, r[5] = l, r;
}
function yo(r, e, t) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r[4] = e[4] + t[0], r[5] = e[5] + t[1], r;
}
function zc(r, e, t) {
  var i = e[0], n = e[2], a = e[4], o = e[1], s = e[3], l = e[5], u = Math.sin(t), c = Math.cos(t);
  return r[0] = i * c + o * u, r[1] = -i * u + o * c, r[2] = n * c + s * u, r[3] = -n * u + c * s, r[4] = c * a + u * l, r[5] = c * l - u * a, r;
}
function x1(r, e, t) {
  var i = t[0], n = t[1];
  return r[0] = e[0] * i, r[1] = e[1] * n, r[2] = e[2] * i, r[3] = e[3] * n, r[4] = e[4] * i, r[5] = e[5] * n, r;
}
function qf(r, e) {
  var t = e[0], i = e[2], n = e[4], a = e[1], o = e[3], s = e[5], l = t * o - a * i;
  return l ? (l = 1 / l, r[0] = o * l, r[1] = -a * l, r[2] = -i * l, r[3] = t * l, r[4] = (i * s - o * n) * l, r[5] = (a * n - t * s) * l, r) : null;
}
function vne(r) {
  var e = na();
  return N1(e, r), e;
}
var One = function() {
  function r(e, t) {
    this.x = e || 0, this.y = t || 0;
  }
  return r.prototype.copy = function(e) {
    return this.x = e.x, this.y = e.y, this;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y);
  }, r.prototype.set = function(e, t) {
    return this.x = e, this.y = t, this;
  }, r.prototype.equal = function(e) {
    return e.x === this.x && e.y === this.y;
  }, r.prototype.add = function(e) {
    return this.x += e.x, this.y += e.y, this;
  }, r.prototype.scale = function(e) {
    this.x *= e, this.y *= e;
  }, r.prototype.scaleAndAdd = function(e, t) {
    this.x += e.x * t, this.y += e.y * t;
  }, r.prototype.sub = function(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }, r.prototype.dot = function(e) {
    return this.x * e.x + this.y * e.y;
  }, r.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, r.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, r.prototype.normalize = function() {
    var e = this.len();
    return this.x /= e, this.y /= e, this;
  }, r.prototype.distance = function(e) {
    var t = this.x - e.x, i = this.y - e.y;
    return Math.sqrt(t * t + i * i);
  }, r.prototype.distanceSquare = function(e) {
    var t = this.x - e.x, i = this.y - e.y;
    return t * t + i * i;
  }, r.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, r.prototype.transform = function(e) {
    if (e) {
      var t = this.x, i = this.y;
      return this.x = e[0] * t + e[2] * i + e[4], this.y = e[1] * t + e[3] * i + e[5], this;
    }
  }, r.prototype.toArray = function(e) {
    return e[0] = this.x, e[1] = this.y, e;
  }, r.prototype.fromArray = function(e) {
    this.x = e[0], this.y = e[1];
  }, r.set = function(e, t, i) {
    e.x = t, e.y = i;
  }, r.copy = function(e, t) {
    e.x = t.x, e.y = t.y;
  }, r.len = function(e) {
    return Math.sqrt(e.x * e.x + e.y * e.y);
  }, r.lenSquare = function(e) {
    return e.x * e.x + e.y * e.y;
  }, r.dot = function(e, t) {
    return e.x * t.x + e.y * t.y;
  }, r.add = function(e, t, i) {
    e.x = t.x + i.x, e.y = t.y + i.y;
  }, r.sub = function(e, t, i) {
    e.x = t.x - i.x, e.y = t.y - i.y;
  }, r.scale = function(e, t, i) {
    e.x = t.x * i, e.y = t.y * i;
  }, r.scaleAndAdd = function(e, t, i, n) {
    e.x = t.x + i.x * n, e.y = t.y + i.y * n;
  }, r.lerp = function(e, t, i, n) {
    var a = 1 - n;
    e.x = a * t.x + n * i.x, e.y = a * t.y + n * i.y;
  }, r;
}();
const Me = One;
var gO = Math.min, vO = Math.max, ru = new Me(), iu = new Me(), nu = new Me(), au = new Me(), Ad = new Me(), _d = new Me(), mne = function() {
  function r(e, t, i, n) {
    i < 0 && (e = e + i, i = -i), n < 0 && (t = t + n, n = -n), this.x = e, this.y = t, this.width = i, this.height = n;
  }
  return r.prototype.union = function(e) {
    var t = gO(e.x, this.x), i = gO(e.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = vO(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = vO(e.y + e.height, this.y + this.height) - i : this.height = e.height, this.x = t, this.y = i;
  }, r.prototype.applyTransform = function(e) {
    r.applyTransform(this, this, e);
  }, r.prototype.calculateTransform = function(e) {
    var t = this, i = e.width / t.width, n = e.height / t.height, a = na();
    return yo(a, a, [-t.x, -t.y]), x1(a, a, [i, n]), yo(a, a, [e.x, e.y]), a;
  }, r.prototype.intersect = function(e, t) {
    if (!e)
      return !1;
    e instanceof r || (e = r.create(e));
    var i = this, n = i.x, a = i.x + i.width, o = i.y, s = i.y + i.height, l = e.x, u = e.x + e.width, c = e.y, h = e.y + e.height, f = !(a < l || u < n || s < c || h < o);
    if (t) {
      var d = 1 / 0, p = 0, g = Math.abs(a - l), v = Math.abs(u - n), O = Math.abs(s - c), m = Math.abs(h - o), E = Math.min(g, v), b = Math.min(O, m);
      a < l || u < n ? E > p && (p = E, g < v ? Me.set(_d, -g, 0) : Me.set(_d, v, 0)) : E < d && (d = E, g < v ? Me.set(Ad, g, 0) : Me.set(Ad, -v, 0)), s < c || h < o ? b > p && (p = b, O < m ? Me.set(_d, 0, -O) : Me.set(_d, 0, m)) : E < d && (d = E, O < m ? Me.set(Ad, 0, O) : Me.set(Ad, 0, -m));
    }
    return t && Me.copy(t, f ? Ad : _d), f;
  }, r.prototype.contain = function(e, t) {
    var i = this;
    return e >= i.x && e <= i.x + i.width && t >= i.y && t <= i.y + i.height;
  }, r.prototype.clone = function() {
    return new r(this.x, this.y, this.width, this.height);
  }, r.prototype.copy = function(e) {
    r.copy(this, e);
  }, r.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, r.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, r.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, r.create = function(e) {
    return new r(e.x, e.y, e.width, e.height);
  }, r.copy = function(e, t) {
    e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height;
  }, r.applyTransform = function(e, t, i) {
    if (!i) {
      e !== t && r.copy(e, t);
      return;
    }
    if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
      var n = i[0], a = i[3], o = i[4], s = i[5];
      e.x = t.x * n + o, e.y = t.y * a + s, e.width = t.width * n, e.height = t.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height);
      return;
    }
    ru.x = nu.x = t.x, ru.y = au.y = t.y, iu.x = au.x = t.x + t.width, iu.y = nu.y = t.y + t.height, ru.transform(i), au.transform(i), iu.transform(i), nu.transform(i), e.x = gO(ru.x, iu.x, nu.x, au.x), e.y = gO(ru.y, iu.y, nu.y, au.y);
    var l = vO(ru.x, iu.x, nu.x, au.x), u = vO(ru.y, iu.y, nu.y, au.y);
    e.width = l - e.x, e.height = u - e.y;
  }, r;
}();
const Ve = mne;
var pY = "silent";
function Ene(r, e, t) {
  return {
    type: r,
    event: t,
    target: e.target,
    topTarget: e.topTarget,
    cancelBubble: !1,
    offsetX: t.zrX,
    offsetY: t.zrY,
    gestureEvent: t.gestureEvent,
    pinchX: t.pinchX,
    pinchY: t.pinchY,
    pinchScale: t.pinchScale,
    wheelDelta: t.zrDelta,
    zrByTouch: t.zrByTouch,
    which: t.which,
    stop: bne
  };
}
function bne() {
  os(this.event);
}
var Sne = function(r) {
  $(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.handler = null, t;
  }
  return e.prototype.dispose = function() {
  }, e.prototype.setCursor = function() {
  }, e;
}(oa), Cd = function() {
  function r(e, t) {
    this.x = e, this.y = t;
  }
  return r;
}(), Tne = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], Gy = new Ve(0, 0, 0, 0), gY = function(r) {
  $(e, r);
  function e(t, i, n, a, o) {
    var s = r.call(this) || this;
    return s._hovered = new Cd(0, 0), s.storage = t, s.painter = i, s.painterRoot = a, s._pointerSize = o, n = n || new Sne(), s.proxy = null, s.setHandlerProxy(n), s._draggingMgr = new rne(s), s;
  }
  return e.prototype.setHandlerProxy = function(t) {
    this.proxy && this.proxy.dispose(), t && (N(Tne, function(i) {
      t.on && t.on(i, this[i], this);
    }, this), t.handler = this), this.proxy = t;
  }, e.prototype.mousemove = function(t) {
    var i = t.zrX, n = t.zrY, a = vY(this, i, n), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new Cd(i, n) : this.findHover(i, n), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(l, "mousemove", t), u && u !== s && this.dispatchToElement(l, "mouseover", t);
  }, e.prototype.mouseout = function(t) {
    var i = t.zrEventControl;
    i !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), i !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: t });
  }, e.prototype.resize = function() {
    this._hovered = new Cd(0, 0);
  }, e.prototype.dispatch = function(t, i) {
    var n = this[t];
    n && n.call(this, i);
  }, e.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, e.prototype.setCursorStyle = function(t) {
    var i = this.proxy;
    i.setCursor && i.setCursor(t);
  }, e.prototype.dispatchToElement = function(t, i, n) {
    t = t || {};
    var a = t.target;
    if (!(a && a.silent)) {
      for (var o = "on" + i, s = Ene(i, t, n); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(i, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(i, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(i, s);
      }));
    }
  }, e.prototype.findHover = function(t, i, n) {
    var a = this.storage.getDisplayList(), o = new Cd(t, i);
    if (ED(a, o, t, i, n), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new Ve(t - u, i - u, l, l), h = a.length - 1; h >= 0; h--) {
        var f = a[h];
        f !== n && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (Gy.copy(f.getBoundingRect()), f.transform && Gy.applyTransform(f.transform), Gy.intersect(c) && s.push(f));
      }
      if (s.length)
        for (var d = 4, p = Math.PI / 12, g = Math.PI * 2, v = 0; v < u; v += d)
          for (var O = 0; O < g; O += p) {
            var m = t + v * Math.cos(O), E = i + v * Math.sin(O);
            if (ED(s, o, m, E, n), o.target)
              return o;
          }
    }
    return o;
  }, e.prototype.processGesture = function(t, i) {
    this._gestureMgr || (this._gestureMgr = new pne());
    var n = this._gestureMgr;
    i === "start" && n.clear();
    var a = n.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom);
    if (i === "end" && n.clear(), a) {
      var o = a.type;
      t.gestureEvent = o;
      var s = new Cd();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, e;
}(oa);
N(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(r) {
  gY.prototype[r] = function(e) {
    var t = e.zrX, i = e.zrY, n = vY(this, t, i), a, o;
    if ((r !== "mouseup" || !n) && (a = this.findHover(t, i), o = a.target), r === "mousedown")
      this._downEl = o, this._downPoint = [e.zrX, e.zrY], this._upEl = o;
    else if (r === "mouseup")
      this._upEl = o;
    else if (r === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || Ks(this._downPoint, [e.zrX, e.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, r, e);
  };
});
function yne(r, e, t) {
  if (r[r.rectHover ? "rectContain" : "contain"](e, t)) {
    for (var i = r, n = void 0, a = !1; i; ) {
      if (i.ignoreClip && (a = !0), !a) {
        var o = i.getClipPath();
        if (o && !o.contain(e, t))
          return !1;
        i.silent && (n = !0);
      }
      var s = i.__hostTarget;
      i = s || i.parent;
    }
    return n ? pY : !0;
  }
  return !1;
}
function ED(r, e, t, i, n) {
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a], s = void 0;
    if (o !== n && !o.ignore && (s = yne(o, t, i)) && (!e.topTarget && (e.topTarget = o), s !== pY)) {
      e.target = o;
      break;
    }
  }
}
function vY(r, e, t) {
  var i = r.painter;
  return e < 0 || e > i.getWidth() || t < 0 || t > i.getHeight();
}
const Rne = gY;
var OY = 32, Id = 7;
function Ane(r) {
  for (var e = 0; r >= OY; )
    e |= r & 1, r >>= 1;
  return r + e;
}
function bD(r, e, t, i) {
  var n = e + 1;
  if (n === t)
    return 1;
  if (i(r[n++], r[e]) < 0) {
    for (; n < t && i(r[n], r[n - 1]) < 0; )
      n++;
    _ne(r, e, n);
  } else
    for (; n < t && i(r[n], r[n - 1]) >= 0; )
      n++;
  return n - e;
}
function _ne(r, e, t) {
  for (t--; e < t; ) {
    var i = r[e];
    r[e++] = r[t], r[t--] = i;
  }
}
function SD(r, e, t, i, n) {
  for (i === e && i++; i < t; i++) {
    for (var a = r[i], o = e, s = i, l; o < s; )
      l = o + s >>> 1, n(a, r[l]) < 0 ? s = l : o = l + 1;
    var u = i - o;
    switch (u) {
      case 3:
        r[o + 3] = r[o + 2];
      case 2:
        r[o + 2] = r[o + 1];
      case 1:
        r[o + 1] = r[o];
        break;
      default:
        for (; u > 0; )
          r[o + u] = r[o + u - 1], u--;
    }
    r[o] = a;
  }
}
function By(r, e, t, i, n, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, e[t + n]) > 0) {
    for (s = i - n; l < s && a(r, e[t + n + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += n, l += n;
  } else {
    for (s = n + 1; l < s && a(r, e[t + n - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = n - l, l = n - u;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(r, e[t + c]) > 0 ? o = c + 1 : l = c;
  }
  return l;
}
function Fy(r, e, t, i, n, a) {
  var o = 0, s = 0, l = 1;
  if (a(r, e[t + n]) < 0) {
    for (s = n + 1; l < s && a(r, e[t + n - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = n - l, l = n - u;
  } else {
    for (s = i - n; l < s && a(r, e[t + n + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += n, l += n;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(r, e[t + c]) < 0 ? l = c : o = c + 1;
  }
  return l;
}
function Cne(r, e) {
  var t = Id, i, n, a = 0;
  r.length;
  var o = [];
  i = [], n = [];
  function s(d, p) {
    i[a] = d, n[a] = p, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var d = a - 2;
      if (d >= 1 && n[d - 1] <= n[d] + n[d + 1] || d >= 2 && n[d - 2] <= n[d] + n[d - 1])
        n[d - 1] < n[d + 1] && d--;
      else if (n[d] > n[d + 1])
        break;
      c(d);
    }
  }
  function u() {
    for (; a > 1; ) {
      var d = a - 2;
      d > 0 && n[d - 1] < n[d + 1] && d--, c(d);
    }
  }
  function c(d) {
    var p = i[d], g = n[d], v = i[d + 1], O = n[d + 1];
    n[d] = g + O, d === a - 3 && (i[d + 1] = i[d + 2], n[d + 1] = n[d + 2]), a--;
    var m = Fy(r[v], r, p, g, 0, e);
    p += m, g -= m, g !== 0 && (O = By(r[p + g - 1], r, v, O, O - 1, e), O !== 0 && (g <= O ? h(p, g, v, O) : f(p, g, v, O)));
  }
  function h(d, p, g, v) {
    var O = 0;
    for (O = 0; O < p; O++)
      o[O] = r[d + O];
    var m = 0, E = g, b = d;
    if (r[b++] = r[E++], --v === 0) {
      for (O = 0; O < p; O++)
        r[b + O] = o[m + O];
      return;
    }
    if (p === 1) {
      for (O = 0; O < v; O++)
        r[b + O] = r[E + O];
      r[b + v] = o[m];
      return;
    }
    for (var S = t, T, y, R; ; ) {
      T = 0, y = 0, R = !1;
      do
        if (e(r[E], o[m]) < 0) {
          if (r[b++] = r[E++], y++, T = 0, --v === 0) {
            R = !0;
            break;
          }
        } else if (r[b++] = o[m++], T++, y = 0, --p === 1) {
          R = !0;
          break;
        }
      while ((T | y) < S);
      if (R)
        break;
      do {
        if (T = Fy(r[E], o, m, p, 0, e), T !== 0) {
          for (O = 0; O < T; O++)
            r[b + O] = o[m + O];
          if (b += T, m += T, p -= T, p <= 1) {
            R = !0;
            break;
          }
        }
        if (r[b++] = r[E++], --v === 0) {
          R = !0;
          break;
        }
        if (y = By(o[m], r, E, v, 0, e), y !== 0) {
          for (O = 0; O < y; O++)
            r[b + O] = r[E + O];
          if (b += y, E += y, v -= y, v === 0) {
            R = !0;
            break;
          }
        }
        if (r[b++] = o[m++], --p === 1) {
          R = !0;
          break;
        }
        S--;
      } while (T >= Id || y >= Id);
      if (R)
        break;
      S < 0 && (S = 0), S += 2;
    }
    if (t = S, t < 1 && (t = 1), p === 1) {
      for (O = 0; O < v; O++)
        r[b + O] = r[E + O];
      r[b + v] = o[m];
    } else {
      if (p === 0)
        throw new Error();
      for (O = 0; O < p; O++)
        r[b + O] = o[m + O];
    }
  }
  function f(d, p, g, v) {
    var O = 0;
    for (O = 0; O < v; O++)
      o[O] = r[g + O];
    var m = d + p - 1, E = v - 1, b = g + v - 1, S = 0, T = 0;
    if (r[b--] = r[m--], --p === 0) {
      for (S = b - (v - 1), O = 0; O < v; O++)
        r[S + O] = o[O];
      return;
    }
    if (v === 1) {
      for (b -= p, m -= p, T = b + 1, S = m + 1, O = p - 1; O >= 0; O--)
        r[T + O] = r[S + O];
      r[b] = o[E];
      return;
    }
    for (var y = t; ; ) {
      var R = 0, _ = 0, C = !1;
      do
        if (e(o[E], r[m]) < 0) {
          if (r[b--] = r[m--], R++, _ = 0, --p === 0) {
            C = !0;
            break;
          }
        } else if (r[b--] = o[E--], _++, R = 0, --v === 1) {
          C = !0;
          break;
        }
      while ((R | _) < y);
      if (C)
        break;
      do {
        if (R = p - Fy(o[E], r, d, p, p - 1, e), R !== 0) {
          for (b -= R, m -= R, p -= R, T = b + 1, S = m + 1, O = R - 1; O >= 0; O--)
            r[T + O] = r[S + O];
          if (p === 0) {
            C = !0;
            break;
          }
        }
        if (r[b--] = o[E--], --v === 1) {
          C = !0;
          break;
        }
        if (_ = v - By(r[m], o, 0, v, v - 1, e), _ !== 0) {
          for (b -= _, E -= _, v -= _, T = b + 1, S = E + 1, O = 0; O < _; O++)
            r[T + O] = o[S + O];
          if (v <= 1) {
            C = !0;
            break;
          }
        }
        if (r[b--] = r[m--], --p === 0) {
          C = !0;
          break;
        }
        y--;
      } while (R >= Id || _ >= Id);
      if (C)
        break;
      y < 0 && (y = 0), y += 2;
    }
    if (t = y, t < 1 && (t = 1), v === 1) {
      for (b -= p, m -= p, T = b + 1, S = m + 1, O = p - 1; O >= 0; O--)
        r[T + O] = r[S + O];
      r[b] = o[E];
    } else {
      if (v === 0)
        throw new Error();
      for (S = b - (v - 1), O = 0; O < v; O++)
        r[S + O] = o[O];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function Hm(r, e, t, i) {
  t || (t = 0), i || (i = r.length);
  var n = i - t;
  if (!(n < 2)) {
    var a = 0;
    if (n < OY) {
      a = bD(r, t, i, e), SD(r, t, i, t + a, e);
      return;
    }
    var o = Cne(r, e), s = Ane(n);
    do {
      if (a = bD(r, t, i, e), a < s) {
        var l = n;
        l > s && (l = s), SD(r, t, t + l, t + a, e), a = l;
      }
      o.pushRun(t, a), o.mergeRuns(), n -= a, t += a;
    } while (n !== 0);
    o.forceMergeRuns();
  }
}
var vn = 1, dp = 2, kh = 4, TD = !1;
function Xy() {
  TD || (TD = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function yD(r, e) {
  return r.zlevel === e.zlevel ? r.z === e.z ? r.z2 - e.z2 : r.z - e.z : r.zlevel - e.zlevel;
}
var Ine = function() {
  function r() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = yD;
  }
  return r.prototype.traverse = function(e, t) {
    for (var i = 0; i < this._roots.length; i++)
      this._roots[i].traverse(e, t);
  }, r.prototype.getDisplayList = function(e, t) {
    t = t || !1;
    var i = this._displayList;
    return (e || !i.length) && this.updateDisplayList(t), i;
  }, r.prototype.updateDisplayList = function(e) {
    this._displayListLen = 0;
    for (var t = this._roots, i = this._displayList, n = 0, a = t.length; n < a; n++)
      this._updateAndAddDisplayable(t[n], null, e);
    i.length = this._displayListLen, Hm(i, yD);
  }, r.prototype._updateAndAddDisplayable = function(e, t, i) {
    if (!(e.ignore && !i)) {
      e.beforeUpdate(), e.update(), e.afterUpdate();
      var n = e.getClipPath();
      if (e.ignoreClip)
        t = null;
      else if (n) {
        t ? t = t.slice() : t = [];
        for (var a = n, o = e; a; )
          a.parent = o, a.updateTransform(), t.push(a), o = a, a = a.getClipPath();
      }
      if (e.childrenRef) {
        for (var s = e.childrenRef(), l = 0; l < s.length; l++) {
          var u = s[l];
          e.__dirty && (u.__dirty |= vn), this._updateAndAddDisplayable(u, t, i);
        }
        e.__dirty = 0;
      } else {
        var c = e;
        t && t.length ? c.__clipPaths = t : c.__clipPaths && c.__clipPaths.length > 0 && (c.__clipPaths = []), isNaN(c.z) && (Xy(), c.z = 0), isNaN(c.z2) && (Xy(), c.z2 = 0), isNaN(c.zlevel) && (Xy(), c.zlevel = 0), this._displayList[this._displayListLen++] = c;
      }
      var h = e.getDecalElement && e.getDecalElement();
      h && this._updateAndAddDisplayable(h, t, i);
      var f = e.getTextGuideLine();
      f && this._updateAndAddDisplayable(f, t, i);
      var d = e.getTextContent();
      d && this._updateAndAddDisplayable(d, t, i);
    }
  }, r.prototype.addRoot = function(e) {
    e.__zr && e.__zr.storage === this || this._roots.push(e);
  }, r.prototype.delRoot = function(e) {
    if (e instanceof Array) {
      for (var t = 0, i = e.length; t < i; t++)
        this.delRoot(e[t]);
      return;
    }
    var n = Fe(this._roots, e);
    n >= 0 && this._roots.splice(n, 1);
  }, r.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, r.prototype.getRoots = function() {
    return this._roots;
  }, r.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, r;
}();
const wne = Ine;
var mY;
mY = ct.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(r) {
  return setTimeout(r, 16);
};
const M_ = mY;
var Wm = {
  linear: function(r) {
    return r;
  },
  quadraticIn: function(r) {
    return r * r;
  },
  quadraticOut: function(r) {
    return r * (2 - r);
  },
  quadraticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r : -0.5 * (--r * (r - 2) - 1);
  },
  cubicIn: function(r) {
    return r * r * r;
  },
  cubicOut: function(r) {
    return --r * r * r + 1;
  },
  cubicInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r : 0.5 * ((r -= 2) * r * r + 2);
  },
  quarticIn: function(r) {
    return r * r * r * r;
  },
  quarticOut: function(r) {
    return 1 - --r * r * r * r;
  },
  quarticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r : -0.5 * ((r -= 2) * r * r * r - 2);
  },
  quinticIn: function(r) {
    return r * r * r * r * r;
  },
  quinticOut: function(r) {
    return --r * r * r * r * r + 1;
  },
  quinticInOut: function(r) {
    return (r *= 2) < 1 ? 0.5 * r * r * r * r * r : 0.5 * ((r -= 2) * r * r * r * r + 2);
  },
  sinusoidalIn: function(r) {
    return 1 - Math.cos(r * Math.PI / 2);
  },
  sinusoidalOut: function(r) {
    return Math.sin(r * Math.PI / 2);
  },
  sinusoidalInOut: function(r) {
    return 0.5 * (1 - Math.cos(Math.PI * r));
  },
  exponentialIn: function(r) {
    return r === 0 ? 0 : Math.pow(1024, r - 1);
  },
  exponentialOut: function(r) {
    return r === 1 ? 1 : 1 - Math.pow(2, -10 * r);
  },
  exponentialInOut: function(r) {
    return r === 0 ? 0 : r === 1 ? 1 : (r *= 2) < 1 ? 0.5 * Math.pow(1024, r - 1) : 0.5 * (-Math.pow(2, -10 * (r - 1)) + 2);
  },
  circularIn: function(r) {
    return 1 - Math.sqrt(1 - r * r);
  },
  circularOut: function(r) {
    return Math.sqrt(1 - --r * r);
  },
  circularInOut: function(r) {
    return (r *= 2) < 1 ? -0.5 * (Math.sqrt(1 - r * r) - 1) : 0.5 * (Math.sqrt(1 - (r -= 2) * r) + 1);
  },
  elasticIn: function(r) {
    var e, t = 0.1, i = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = i / 4) : e = i * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / i)));
  },
  elasticOut: function(r) {
    var e, t = 0.1, i = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = i / 4) : e = i * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * r) * Math.sin((r - e) * (2 * Math.PI) / i) + 1);
  },
  elasticInOut: function(r) {
    var e, t = 0.1, i = 0.4;
    return r === 0 ? 0 : r === 1 ? 1 : (!t || t < 1 ? (t = 1, e = i / 4) : e = i * Math.asin(1 / t) / (2 * Math.PI), (r *= 2) < 1 ? -0.5 * (t * Math.pow(2, 10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / i)) : t * Math.pow(2, -10 * (r -= 1)) * Math.sin((r - e) * (2 * Math.PI) / i) * 0.5 + 1);
  },
  backIn: function(r) {
    var e = 1.70158;
    return r * r * ((e + 1) * r - e);
  },
  backOut: function(r) {
    var e = 1.70158;
    return --r * r * ((e + 1) * r + e) + 1;
  },
  backInOut: function(r) {
    var e = 2.5949095;
    return (r *= 2) < 1 ? 0.5 * (r * r * ((e + 1) * r - e)) : 0.5 * ((r -= 2) * r * ((e + 1) * r + e) + 2);
  },
  bounceIn: function(r) {
    return 1 - Wm.bounceOut(1 - r);
  },
  bounceOut: function(r) {
    return r < 1 / 2.75 ? 7.5625 * r * r : r < 2 / 2.75 ? 7.5625 * (r -= 1.5 / 2.75) * r + 0.75 : r < 2.5 / 2.75 ? 7.5625 * (r -= 2.25 / 2.75) * r + 0.9375 : 7.5625 * (r -= 2.625 / 2.75) * r + 0.984375;
  },
  bounceInOut: function(r) {
    return r < 0.5 ? Wm.bounceIn(r * 2) * 0.5 : Wm.bounceOut(r * 2 - 1) * 0.5 + 0.5;
  }
};
const EY = Wm;
var OO = Math.pow, pl = Math.sqrt, jE = 1e-8, bY = 1e-4, RD = pl(3), mO = 1 / 3, to = Wc(), Gn = Wc(), of = Wc();
function tl(r) {
  return r > -jE && r < jE;
}
function SY(r) {
  return r > jE || r < -jE;
}
function wr(r, e, t, i, n) {
  var a = 1 - n;
  return a * a * (a * r + 3 * n * e) + n * n * (n * i + 3 * a * t);
}
function AD(r, e, t, i, n) {
  var a = 1 - n;
  return 3 * (((e - r) * a + 2 * (t - e) * n) * a + (i - t) * n * n);
}
function KE(r, e, t, i, n, a) {
  var o = i + 3 * (e - t) - r, s = 3 * (t - e * 2 + r), l = 3 * (e - r), u = r - n, c = s * s - 3 * o * l, h = s * l - 9 * o * u, f = l * l - 3 * s * u, d = 0;
  if (tl(c) && tl(h))
    if (tl(s))
      a[0] = 0;
    else {
      var p = -l / s;
      p >= 0 && p <= 1 && (a[d++] = p);
    }
  else {
    var g = h * h - 4 * c * f;
    if (tl(g)) {
      var v = h / c, p = -s / o + v, O = -v / 2;
      p >= 0 && p <= 1 && (a[d++] = p), O >= 0 && O <= 1 && (a[d++] = O);
    } else if (g > 0) {
      var m = pl(g), E = c * s + 1.5 * o * (-h + m), b = c * s + 1.5 * o * (-h - m);
      E < 0 ? E = -OO(-E, mO) : E = OO(E, mO), b < 0 ? b = -OO(-b, mO) : b = OO(b, mO);
      var p = (-s - (E + b)) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p);
    } else {
      var S = (2 * c * s - 3 * o * h) / (2 * pl(c * c * c)), T = Math.acos(S) / 3, y = pl(c), R = Math.cos(T), p = (-s - 2 * y * R) / (3 * o), O = (-s + y * (R + RD * Math.sin(T))) / (3 * o), _ = (-s + y * (R - RD * Math.sin(T))) / (3 * o);
      p >= 0 && p <= 1 && (a[d++] = p), O >= 0 && O <= 1 && (a[d++] = O), _ >= 0 && _ <= 1 && (a[d++] = _);
    }
  }
  return d;
}
function TY(r, e, t, i, n) {
  var a = 6 * t - 12 * e + 6 * r, o = 9 * e + 3 * i - 3 * r - 9 * t, s = 3 * e - 3 * r, l = 0;
  if (tl(o)) {
    if (SY(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (n[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (tl(c))
      n[0] = -a / (2 * o);
    else if (c > 0) {
      var h = pl(c), u = (-a + h) / (2 * o), f = (-a - h) / (2 * o);
      u >= 0 && u <= 1 && (n[l++] = u), f >= 0 && f <= 1 && (n[l++] = f);
    }
  }
  return l;
}
function wl(r, e, t, i, n, a) {
  var o = (e - r) * n + r, s = (t - e) * n + e, l = (i - t) * n + t, u = (s - o) * n + o, c = (l - s) * n + s, h = (c - u) * n + u;
  a[0] = r, a[1] = o, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = i;
}
function yY(r, e, t, i, n, a, o, s, l, u, c) {
  var h, f = 5e-3, d = 1 / 0, p, g, v, O;
  to[0] = l, to[1] = u;
  for (var m = 0; m < 1; m += 0.05)
    Gn[0] = wr(r, t, n, o, m), Gn[1] = wr(e, i, a, s, m), v = cc(to, Gn), v < d && (h = m, d = v);
  d = 1 / 0;
  for (var E = 0; E < 32 && !(f < bY); E++)
    p = h - f, g = h + f, Gn[0] = wr(r, t, n, o, p), Gn[1] = wr(e, i, a, s, p), v = cc(Gn, to), p >= 0 && v < d ? (h = p, d = v) : (of[0] = wr(r, t, n, o, g), of[1] = wr(e, i, a, s, g), O = cc(of, to), g <= 1 && O < d ? (h = g, d = O) : f *= 0.5);
  return c && (c[0] = wr(r, t, n, o, h), c[1] = wr(e, i, a, s, h)), pl(d);
}
function Nne(r, e, t, i, n, a, o, s, l) {
  for (var u = r, c = e, h = 0, f = 1 / l, d = 1; d <= l; d++) {
    var p = d * f, g = wr(r, t, n, o, p), v = wr(e, i, a, s, p), O = g - u, m = v - c;
    h += Math.sqrt(O * O + m * m), u = g, c = v;
  }
  return h;
}
function Vr(r, e, t, i) {
  var n = 1 - i;
  return n * (n * r + 2 * i * e) + i * i * t;
}
function k_(r, e, t, i) {
  return 2 * ((1 - i) * (e - r) + i * (t - e));
}
function xne(r, e, t, i, n) {
  var a = r - 2 * e + t, o = 2 * (e - r), s = r - i, l = 0;
  if (tl(a)) {
    if (SY(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (n[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (tl(c)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (n[l++] = u);
    } else if (c > 0) {
      var h = pl(c), u = (-o + h) / (2 * a), f = (-o - h) / (2 * a);
      u >= 0 && u <= 1 && (n[l++] = u), f >= 0 && f <= 1 && (n[l++] = f);
    }
  }
  return l;
}
function RY(r, e, t) {
  var i = r + t - 2 * e;
  return i === 0 ? 0.5 : (r - e) / i;
}
function Cg(r, e, t, i, n) {
  var a = (e - r) * i + r, o = (t - e) * i + e, s = (o - a) * i + a;
  n[0] = r, n[1] = a, n[2] = s, n[3] = s, n[4] = o, n[5] = t;
}
function AY(r, e, t, i, n, a, o, s, l) {
  var u, c = 5e-3, h = 1 / 0;
  to[0] = o, to[1] = s;
  for (var f = 0; f < 1; f += 0.05) {
    Gn[0] = Vr(r, t, n, f), Gn[1] = Vr(e, i, a, f);
    var d = cc(to, Gn);
    d < h && (u = f, h = d);
  }
  h = 1 / 0;
  for (var p = 0; p < 32 && !(c < bY); p++) {
    var g = u - c, v = u + c;
    Gn[0] = Vr(r, t, n, g), Gn[1] = Vr(e, i, a, g);
    var d = cc(Gn, to);
    if (g >= 0 && d < h)
      u = g, h = d;
    else {
      of[0] = Vr(r, t, n, v), of[1] = Vr(e, i, a, v);
      var O = cc(of, to);
      v <= 1 && O < h ? (u = v, h = O) : c *= 0.5;
    }
  }
  return l && (l[0] = Vr(r, t, n, u), l[1] = Vr(e, i, a, u)), pl(h);
}
function Pne(r, e, t, i, n, a, o) {
  for (var s = r, l = e, u = 0, c = 1 / o, h = 1; h <= o; h++) {
    var f = h * c, d = Vr(r, t, n, f), p = Vr(e, i, a, f), g = d - s, v = p - l;
    u += Math.sqrt(g * g + v * v), s = d, l = p;
  }
  return u;
}
var Lne = /cubic-bezier\(([0-9,\.e ]+)\)/;
function P1(r) {
  var e = r && Lne.exec(r);
  if (e) {
    var t = e[1].split(","), i = +Ea(t[0]), n = +Ea(t[1]), a = +Ea(t[2]), o = +Ea(t[3]);
    if (isNaN(i + n + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : KE(0, i, a, 1, l, s) && wr(0, n, o, 1, s[0]);
    };
  }
}
var Dne = function() {
  function r(e) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || !1, this.onframe = e.onframe || ur, this.ondestroy = e.ondestroy || ur, this.onrestart = e.onrestart || ur, e.easing && this.setEasing(e.easing);
  }
  return r.prototype.step = function(e, t) {
    if (this._inited || (this._startTime = e + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += t;
      return;
    }
    var i = this._life, n = e - this._startTime - this._pausedTime, a = n / i;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = n % i;
        this._startTime = e - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, r.prototype.pause = function() {
    this._paused = !0;
  }, r.prototype.resume = function() {
    this._paused = !1;
  }, r.prototype.setEasing = function(e) {
    this.easing = e, this.easingFunc = ve(e) ? e : EY[e] || P1(e);
  }, r;
}();
const Mne = Dne;
var _Y = function() {
  function r(e) {
    this.value = e;
  }
  return r;
}(), kne = function() {
  function r() {
    this._len = 0;
  }
  return r.prototype.insert = function(e) {
    var t = new _Y(e);
    return this.insertEntry(t), t;
  }, r.prototype.insertEntry = function(e) {
    this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++;
  }, r.prototype.remove = function(e) {
    var t = e.prev, i = e.next;
    t ? t.next = i : this.head = i, i ? i.prev = t : this.tail = t, e.next = e.prev = null, this._len--;
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, r;
}(), Qne = function() {
  function r(e) {
    this._list = new kne(), this._maxSize = 10, this._map = {}, this._maxSize = e;
  }
  return r.prototype.put = function(e, t) {
    var i = this._list, n = this._map, a = null;
    if (n[e] == null) {
      var o = i.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = i.head;
        i.remove(l), delete n[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = t : s = new _Y(t), s.key = e, i.insertEntry(s), n[e] = s;
    }
    return a;
  }, r.prototype.get = function(e) {
    var t = this._map[e], i = this._list;
    if (t != null)
      return t !== i.tail && (i.remove(t), i.insertEntry(t)), t.value;
  }, r.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, r.prototype.len = function() {
    return this._list.len();
  }, r;
}();
const Tv = Qne;
var _D = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function Ca(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 255 ? 255 : r;
}
function Une(r) {
  return r = Math.round(r), r < 0 ? 0 : r > 360 ? 360 : r;
}
function Ig(r) {
  return r < 0 ? 0 : r > 1 ? 1 : r;
}
function Yy(r) {
  var e = r;
  return e.length && e.charAt(e.length - 1) === "%" ? Ca(parseFloat(e) / 100 * 255) : Ca(parseInt(e, 10));
}
function hc(r) {
  var e = r;
  return e.length && e.charAt(e.length - 1) === "%" ? Ig(parseFloat(e) / 100) : Ig(parseFloat(e));
}
function Hy(r, e, t) {
  return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? r + (e - r) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? r + (e - r) * (2 / 3 - t) * 6 : r;
}
function rl(r, e, t) {
  return r + (e - r) * t;
}
function Mn(r, e, t, i, n) {
  return r[0] = e, r[1] = t, r[2] = i, r[3] = n, r;
}
function Q_(r, e) {
  return r[0] = e[0], r[1] = e[1], r[2] = e[2], r[3] = e[3], r;
}
var CY = new Tv(20), EO = null;
function ch(r, e) {
  EO && Q_(EO, e), EO = CY.put(r, EO || e.slice());
}
function Sn(r, e) {
  if (r) {
    e = e || [];
    var t = CY.get(r);
    if (t)
      return Q_(e, t);
    r = r + "";
    var i = r.replace(/ /g, "").toLowerCase();
    if (i in _D)
      return Q_(e, _D[i]), ch(r, e), e;
    var n = i.length;
    if (i.charAt(0) === "#") {
      if (n === 4 || n === 5) {
        var a = parseInt(i.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          Mn(e, 0, 0, 0, 1);
          return;
        }
        return Mn(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, n === 5 ? parseInt(i.slice(4), 16) / 15 : 1), ch(r, e), e;
      } else if (n === 7 || n === 9) {
        var a = parseInt(i.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          Mn(e, 0, 0, 0, 1);
          return;
        }
        return Mn(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, n === 9 ? parseInt(i.slice(7), 16) / 255 : 1), ch(r, e), e;
      }
      return;
    }
    var o = i.indexOf("("), s = i.indexOf(")");
    if (o !== -1 && s + 1 === n) {
      var l = i.substr(0, o), u = i.substr(o + 1, s - (o + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? Mn(e, +u[0], +u[1], +u[2], 1) : Mn(e, 0, 0, 0, 1);
          c = hc(u.pop());
        case "rgb":
          if (u.length >= 3)
            return Mn(e, Yy(u[0]), Yy(u[1]), Yy(u[2]), u.length === 3 ? c : hc(u[3])), ch(r, e), e;
          Mn(e, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            Mn(e, 0, 0, 0, 1);
            return;
          }
          return u[3] = hc(u[3]), U_(u, e), ch(r, e), e;
        case "hsl":
          if (u.length !== 3) {
            Mn(e, 0, 0, 0, 1);
            return;
          }
          return U_(u, e), ch(r, e), e;
        default:
          return;
      }
    }
    Mn(e, 0, 0, 0, 1);
  }
}
function U_(r, e) {
  var t = (parseFloat(r[0]) % 360 + 360) % 360 / 360, i = hc(r[1]), n = hc(r[2]), a = n <= 0.5 ? n * (i + 1) : n + i - n * i, o = n * 2 - a;
  return e = e || [], Mn(e, Ca(Hy(o, a, t + 1 / 3) * 255), Ca(Hy(o, a, t) * 255), Ca(Hy(o, a, t - 1 / 3) * 255), 1), r.length === 4 && (e[3] = r[3]), e;
}
function $ne(r) {
  if (r) {
    var e = r[0] / 255, t = r[1] / 255, i = r[2] / 255, n = Math.min(e, t, i), a = Math.max(e, t, i), o = a - n, s = (a + n) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + n) : u = o / (2 - a - n);
      var c = ((a - e) / 6 + o / 2) / o, h = ((a - t) / 6 + o / 2) / o, f = ((a - i) / 6 + o / 2) / o;
      e === a ? l = f - h : t === a ? l = 1 / 3 + c - f : i === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var d = [l * 360, u, s];
    return r[3] != null && d.push(r[3]), d;
  }
}
function $_(r, e) {
  var t = Sn(r);
  if (t) {
    for (var i = 0; i < 3; i++)
      e < 0 ? t[i] = t[i] * (1 - e) | 0 : t[i] = (255 - t[i]) * e + t[i] | 0, t[i] > 255 ? t[i] = 255 : t[i] < 0 && (t[i] = 0);
    return jo(t, t.length === 4 ? "rgba" : "rgb");
  }
}
function Wy(r, e, t) {
  if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
    t = t || [];
    var i = r * (e.length - 1), n = Math.floor(i), a = Math.ceil(i), o = e[n], s = e[a], l = i - n;
    return t[0] = Ca(rl(o[0], s[0], l)), t[1] = Ca(rl(o[1], s[1], l)), t[2] = Ca(rl(o[2], s[2], l)), t[3] = Ig(rl(o[3], s[3], l)), t;
  }
}
function Vne(r, e, t) {
  if (!(!(e && e.length) || !(r >= 0 && r <= 1))) {
    var i = r * (e.length - 1), n = Math.floor(i), a = Math.ceil(i), o = Sn(e[n]), s = Sn(e[a]), l = i - n, u = jo([
      Ca(rl(o[0], s[0], l)),
      Ca(rl(o[1], s[1], l)),
      Ca(rl(o[2], s[2], l)),
      Ig(rl(o[3], s[3], l))
    ], "rgba");
    return t ? {
      color: u,
      leftIndex: n,
      rightIndex: a,
      value: i
    } : u;
  }
}
function Xp(r, e, t, i) {
  var n = Sn(r);
  if (r)
    return n = $ne(n), e != null && (n[0] = Une(e)), t != null && (n[1] = hc(t)), i != null && (n[2] = hc(i)), jo(U_(n), "rgba");
}
function JE(r, e) {
  var t = Sn(r);
  if (t && e != null)
    return t[3] = Ig(e), jo(t, "rgba");
}
function jo(r, e) {
  if (!(!r || !r.length)) {
    var t = r[0] + "," + r[1] + "," + r[2];
    return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + r[3]), e + "(" + t + ")";
  }
}
function eb(r, e) {
  var t = Sn(r);
  return t ? (0.299 * t[0] + 0.587 * t[1] + 0.114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0;
}
var tb = Math.round;
function wg(r) {
  var e;
  if (!r || r === "transparent")
    r = "none";
  else if (typeof r == "string" && r.indexOf("rgba") > -1) {
    var t = Sn(r);
    t && (r = "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")", e = t[3]);
  }
  return {
    color: r,
    opacity: e ?? 1
  };
}
var CD = 1e-4;
function il(r) {
  return r < CD && r > -CD;
}
function bO(r) {
  return tb(r * 1e3) / 1e3;
}
function V_(r) {
  return tb(r * 1e4) / 1e4;
}
function Gne(r) {
  return "matrix(" + bO(r[0]) + "," + bO(r[1]) + "," + bO(r[2]) + "," + bO(r[3]) + "," + V_(r[4]) + "," + V_(r[5]) + ")";
}
var Bne = {
  left: "start",
  right: "end",
  center: "middle",
  middle: "middle"
};
function Fne(r, e, t) {
  return t === "top" ? r += e / 2 : t === "bottom" && (r -= e / 2), r;
}
function Xne(r) {
  return r && (r.shadowBlur || r.shadowOffsetX || r.shadowOffsetY);
}
function Yne(r) {
  var e = r.style, t = r.getGlobalScale();
  return [
    e.shadowColor,
    (e.shadowBlur || 0).toFixed(2),
    (e.shadowOffsetX || 0).toFixed(2),
    (e.shadowOffsetY || 0).toFixed(2),
    t[0],
    t[1]
  ].join(",");
}
function IY(r) {
  return r && !!r.image;
}
function Hne(r) {
  return r && !!r.svgElement;
}
function L1(r) {
  return IY(r) || Hne(r);
}
function wY(r) {
  return r.type === "linear";
}
function NY(r) {
  return r.type === "radial";
}
function xY(r) {
  return r && (r.type === "linear" || r.type === "radial");
}
function lT(r) {
  return "url(#" + r + ")";
}
function PY(r) {
  var e = r.getGlobalScale(), t = Math.max(e[0], e[1]);
  return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1);
}
function LY(r) {
  var e = r.x || 0, t = r.y || 0, i = (r.rotation || 0) * Fm, n = ke(r.scaleX, 1), a = ke(r.scaleY, 1), o = r.skewX || 0, s = r.skewY || 0, l = [];
  return (e || t) && l.push("translate(" + e + "px," + t + "px)"), i && l.push("rotate(" + i + ")"), (n !== 1 || a !== 1) && l.push("scale(" + n + "," + a + ")"), (o || s) && l.push("skew(" + tb(o * Fm) + "deg, " + tb(s * Fm) + "deg)"), l.join(" ");
}
var Wne = function() {
  return ct.hasGlobalWindow && ve(window.btoa) ? function(r) {
    return window.btoa(unescape(encodeURIComponent(r)));
  } : typeof Buffer < "u" ? function(r) {
    return Buffer.from(r).toString("base64");
  } : function(r) {
    return {}.NODE_ENV !== "production" && _a("Base64 isn't natively supported in the current environment."), null;
  };
}(), G_ = Array.prototype.slice;
function Bo(r, e, t) {
  return (e - r) * t + r;
}
function zy(r, e, t, i) {
  for (var n = e.length, a = 0; a < n; a++)
    r[a] = Bo(e[a], t[a], i);
  return r;
}
function zne(r, e, t, i) {
  for (var n = e.length, a = n && e[0].length, o = 0; o < n; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = Bo(e[o][s], t[o][s], i);
  }
  return r;
}
function SO(r, e, t, i) {
  for (var n = e.length, a = 0; a < n; a++)
    r[a] = e[a] + t[a] * i;
  return r;
}
function ID(r, e, t, i) {
  for (var n = e.length, a = n && e[0].length, o = 0; o < n; o++) {
    r[o] || (r[o] = []);
    for (var s = 0; s < a; s++)
      r[o][s] = e[o][s] + t[o][s] * i;
  }
  return r;
}
function Zne(r, e) {
  for (var t = r.length, i = e.length, n = t > i ? e : r, a = Math.min(t, i), o = n[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(t, i); s++)
    n.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function qne(r, e, t) {
  var i = r, n = e;
  if (!(!i.push || !n.push)) {
    var a = i.length, o = n.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        i.length = o;
      else
        for (var l = a; l < o; l++)
          i.push(t === 1 ? n[l] : G_.call(n[l]));
    }
    for (var u = i[0] && i[0].length, l = 0; l < i.length; l++)
      if (t === 1)
        isNaN(i[l]) && (i[l] = n[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(i[l][c]) && (i[l][c] = n[l][c]);
  }
}
function Yp(r) {
  if (mi(r)) {
    var e = r.length;
    if (mi(r[0])) {
      for (var t = [], i = 0; i < e; i++)
        t.push(G_.call(r[i]));
      return t;
    }
    return G_.call(r);
  }
  return r;
}
function zm(r) {
  return r[0] = Math.floor(r[0]) || 0, r[1] = Math.floor(r[1]) || 0, r[2] = Math.floor(r[2]) || 0, r[3] = r[3] == null ? 1 : r[3], "rgba(" + r.join(",") + ")";
}
function jne(r) {
  return mi(r && r[0]) ? 2 : 1;
}
var TO = 0, Zm = 1, DY = 2, pp = 3, B_ = 4, F_ = 5, wD = 6;
function ND(r) {
  return r === B_ || r === F_;
}
function yO(r) {
  return r === Zm || r === DY;
}
var wd = [0, 0, 0, 0], Kne = function() {
  function r(e) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = e;
  }
  return r.prototype.isFinished = function() {
    return this._finished;
  }, r.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, r.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, r.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, r.prototype.addKeyframe = function(e, t, i) {
    this._needsSort = !0;
    var n = this.keyframes, a = n.length, o = !1, s = wD, l = t;
    if (mi(t)) {
      var u = jne(t);
      s = u, (u === 1 && !pt(t[0]) || u === 2 && !pt(t[0][0])) && (o = !0);
    } else if (pt(t) && !Cc(t))
      s = TO;
    else if (ne(t))
      if (!isNaN(+t))
        s = TO;
      else {
        var c = Sn(t);
        c && (l = c, s = pp);
      }
    else if (aT(t)) {
      var h = B({}, l);
      h.colorStops = Y(t.colorStops, function(d) {
        return {
          offset: d.offset,
          color: Sn(d.color)
        };
      }), wY(t) ? s = B_ : NY(t) && (s = F_), l = h;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === wD) && (o = !0), this.discrete = this.discrete || o;
    var f = {
      time: e,
      value: l,
      rawValue: t,
      percent: 0
    };
    return i && (f.easing = i, f.easingFunc = ve(i) ? i : EY[i] || P1(i)), n.push(f), f;
  }, r.prototype.prepare = function(e, t) {
    var i = this.keyframes;
    this._needsSort && i.sort(function(g, v) {
      return g.time - v.time;
    });
    for (var n = this.valType, a = i.length, o = i[a - 1], s = this.discrete, l = yO(n), u = ND(n), c = 0; c < a; c++) {
      var h = i[c], f = h.value, d = o.value;
      h.percent = h.time / e, s || (l && c !== a - 1 ? qne(f, d, n) : u && Zne(f.colorStops, d.colorStops));
    }
    if (!s && n !== F_ && t && this.needsAnimate() && t.needsAnimate() && n === t.valType && !t._finished) {
      this._additiveTrack = t;
      for (var p = i[0].value, c = 0; c < a; c++)
        n === TO ? i[c].additiveValue = i[c].value - p : n === pp ? i[c].additiveValue = SO([], i[c].value, p, -1) : yO(n) && (i[c].additiveValue = n === Zm ? SO([], i[c].value, p, -1) : ID([], i[c].value, p, -1));
    }
  }, r.prototype.step = function(e, t) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var i = this._additiveTrack != null, n = i ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === pp, c, h = this._lastFr, f = Math.min, d, p;
      if (s === 1)
        d = p = o[0];
      else {
        if (t < 0)
          c = 0;
        else if (t < this._lastFrP) {
          var g = f(h + 1, s - 1);
          for (c = g; c >= 0 && !(o[c].percent <= t); c--)
            ;
          c = f(c, s - 2);
        } else {
          for (c = h; c < s && !(o[c].percent > t); c++)
            ;
          c = f(c - 1, s - 2);
        }
        p = o[c + 1], d = o[c];
      }
      if (d && p) {
        this._lastFr = c, this._lastFrP = t;
        var v = p.percent - d.percent, O = v === 0 ? 1 : f((t - d.percent) / v, 1);
        p.easingFunc && (O = p.easingFunc(O));
        var m = i ? this._additiveValue : u ? wd : e[l];
        if ((yO(a) || u) && !m && (m = this._additiveValue = []), this.discrete)
          e[l] = O < 1 ? d.rawValue : p.rawValue;
        else if (yO(a))
          a === Zm ? zy(m, d[n], p[n], O) : zne(m, d[n], p[n], O);
        else if (ND(a)) {
          var E = d[n], b = p[n], S = a === B_;
          e[l] = {
            type: S ? "linear" : "radial",
            x: Bo(E.x, b.x, O),
            y: Bo(E.y, b.y, O),
            colorStops: Y(E.colorStops, function(y, R) {
              var _ = b.colorStops[R];
              return {
                offset: Bo(y.offset, _.offset, O),
                color: zm(zy([], y.color, _.color, O))
              };
            }),
            global: b.global
          }, S ? (e[l].x2 = Bo(E.x2, b.x2, O), e[l].y2 = Bo(E.y2, b.y2, O)) : e[l].r = Bo(E.r, b.r, O);
        } else if (u)
          zy(m, d[n], p[n], O), i || (e[l] = zm(m));
        else {
          var T = Bo(d[n], p[n], O);
          i ? this._additiveValue = T : e[l] = T;
        }
        i && this._addToTarget(e);
      }
    }
  }, r.prototype._addToTarget = function(e) {
    var t = this.valType, i = this.propName, n = this._additiveValue;
    t === TO ? e[i] = e[i] + n : t === pp ? (Sn(e[i], wd), SO(wd, wd, n, 1), e[i] = zm(wd)) : t === Zm ? SO(e[i], e[i], n, 1) : t === DY && ID(e[i], e[i], n, 1);
  }, r;
}(), D1 = function() {
  function r(e, t, i, n) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && n) {
      _a("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = n, this._allowDiscrete = i;
  }
  return r.prototype.getMaxTime = function() {
    return this._maxTime;
  }, r.prototype.getDelay = function() {
    return this._delay;
  }, r.prototype.getLoop = function() {
    return this._loop;
  }, r.prototype.getTarget = function() {
    return this._target;
  }, r.prototype.changeTarget = function(e) {
    this._target = e;
  }, r.prototype.when = function(e, t, i) {
    return this.whenWithKeys(e, t, Ze(t), i);
  }, r.prototype.whenWithKeys = function(e, t, i, n) {
    for (var a = this._tracks, o = 0; o < i.length; o++) {
      var s = i[o], l = a[s];
      if (!l) {
        l = a[s] = new Kne(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var h = c.keyframes, f = h[h.length - 1];
          u = f && f.value, c.valType === pp && u && (u = zm(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        e > 0 && l.addKeyframe(0, Yp(u), n), this._trackKeys.push(s);
      }
      l.addKeyframe(e, Yp(t[s]), n);
    }
    return this._maxTime = Math.max(this._maxTime, e), this;
  }, r.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, r.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, r.prototype.isPaused = function() {
    return !!this._paused;
  }, r.prototype.duration = function(e) {
    return this._maxTime = e, this._force = !0, this;
  }, r.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var e = this._doneCbs;
    if (e)
      for (var t = e.length, i = 0; i < t; i++)
        e[i].call(this);
  }, r.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var e = this.animation, t = this._abortedCbs;
    if (e && e.removeClip(this._clip), this._clip = null, t)
      for (var i = 0; i < t.length; i++)
        t[i].call(this);
  }, r.prototype._setTracksFinished = function() {
    for (var e = this._tracks, t = this._trackKeys, i = 0; i < t.length; i++)
      e[t[i]].setFinished();
  }, r.prototype._getAdditiveTrack = function(e) {
    var t, i = this._additiveAnimators;
    if (i)
      for (var n = 0; n < i.length; n++) {
        var a = i[n].getTrack(e);
        a && (t = a);
      }
    return t;
  }, r.prototype.start = function(e) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var t = this, i = [], n = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
        if (s.prepare(n, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var h = u[c - 1];
            h && (t._target[s.propName] = h.rawValue), s.setFinished();
          } else
            i.push(s);
      }
      if (i.length || this._force) {
        var f = new Mne({
          life: n,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(d) {
            t._started = 2;
            var p = t._additiveAnimators;
            if (p) {
              for (var g = !1, v = 0; v < p.length; v++)
                if (p[v]._clip) {
                  g = !0;
                  break;
                }
              g || (t._additiveAnimators = null);
            }
            for (var v = 0; v < i.length; v++)
              i[v].step(t._target, d);
            var O = t._onframeCbs;
            if (O)
              for (var v = 0; v < O.length; v++)
                O[v](t._target, d);
          },
          ondestroy: function() {
            t._doneCallback();
          }
        });
        this._clip = f, this.animation && this.animation.addClip(f), e && f.setEasing(e);
      } else
        this._doneCallback();
      return this;
    }
  }, r.prototype.stop = function(e) {
    if (this._clip) {
      var t = this._clip;
      e && t.onframe(1), this._abortedCallback();
    }
  }, r.prototype.delay = function(e) {
    return this._delay = e, this;
  }, r.prototype.during = function(e) {
    return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this;
  }, r.prototype.done = function(e) {
    return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this;
  }, r.prototype.aborted = function(e) {
    return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this;
  }, r.prototype.getClip = function() {
    return this._clip;
  }, r.prototype.getTrack = function(e) {
    return this._tracks[e];
  }, r.prototype.getTracks = function() {
    var e = this;
    return Y(this._trackKeys, function(t) {
      return e._tracks[t];
    });
  }, r.prototype.stopTracks = function(e, t) {
    if (!e.length || !this._clip)
      return !0;
    for (var i = this._tracks, n = this._trackKeys, a = 0; a < e.length; a++) {
      var o = i[e[a]];
      o && !o.isFinished() && (t ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < n.length; a++)
      if (!i[n[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, r.prototype.saveTo = function(e, t, i) {
    if (e) {
      t = t || this._trackKeys;
      for (var n = 0; n < t.length; n++) {
        var a = t[n], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[i ? 0 : s.length - 1];
          l && (e[a] = Yp(l.rawValue));
        }
      }
    }
  }, r.prototype.__changeFinalValue = function(e, t) {
    t = t || Ze(e);
    for (var i = 0; i < t.length; i++) {
      var n = t[i], a = this._tracks[n];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, e[n]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, r;
}();
function Hh() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var Jne = function(r) {
  $(e, r);
  function e(t) {
    var i = r.call(this) || this;
    return i._running = !1, i._time = 0, i._pausedTime = 0, i._pauseStart = 0, i._paused = !1, t = t || {}, i.stage = t.stage || {}, i;
  }
  return e.prototype.addClip = function(t) {
    t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this;
  }, e.prototype.addAnimator = function(t) {
    t.animation = this;
    var i = t.getClip();
    i && this.addClip(i);
  }, e.prototype.removeClip = function(t) {
    if (t.animation) {
      var i = t.prev, n = t.next;
      i ? i.next = n : this._head = n, n ? n.prev = i : this._tail = i, t.next = t.prev = t.animation = null;
    }
  }, e.prototype.removeAnimator = function(t) {
    var i = t.getClip();
    i && this.removeClip(i), t.animation = null;
  }, e.prototype.update = function(t) {
    for (var i = Hh() - this._pausedTime, n = i - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(i, n);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = i, t || (this.trigger("frame", n), this.stage.update && this.stage.update());
  }, e.prototype._startLoop = function() {
    var t = this;
    this._running = !0;
    function i() {
      t._running && (M_(i), !t._paused && t.update());
    }
    M_(i);
  }, e.prototype.start = function() {
    this._running || (this._time = Hh(), this._pausedTime = 0, this._startLoop());
  }, e.prototype.stop = function() {
    this._running = !1;
  }, e.prototype.pause = function() {
    this._paused || (this._pauseStart = Hh(), this._paused = !0);
  }, e.prototype.resume = function() {
    this._paused && (this._pausedTime += Hh() - this._pauseStart, this._paused = !1);
  }, e.prototype.clear = function() {
    for (var t = this._head; t; ) {
      var i = t.next;
      t.prev = t.next = t.animation = null, t = i;
    }
    this._head = this._tail = null;
  }, e.prototype.isFinished = function() {
    return this._head == null;
  }, e.prototype.animate = function(t, i) {
    i = i || {}, this.start();
    var n = new D1(t, i.loop);
    return this.addAnimator(n), n;
  }, e;
}(oa);
const eae = Jne;
var tae = 300, Zy = ct.domSupported, qy = function() {
  var r = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], e = [
    "touchstart",
    "touchend",
    "touchmove"
  ], t = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, i = Y(r, function(n) {
    var a = n.replace("mouse", "pointer");
    return t.hasOwnProperty(a) ? a : n;
  });
  return {
    mouse: r,
    touch: e,
    pointer: i
  };
}(), xD = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, PD = !1;
function X_(r) {
  var e = r.pointerType;
  return e === "pen" || e === "touch";
}
function rae(r) {
  r.touching = !0, r.touchTimer != null && (clearTimeout(r.touchTimer), r.touchTimer = null), r.touchTimer = setTimeout(function() {
    r.touching = !1, r.touchTimer = null;
  }, 700);
}
function jy(r) {
  r && (r.zrByTouch = !0);
}
function iae(r, e) {
  return kn(r.dom, new nae(r, e), !0);
}
function MY(r, e) {
  for (var t = e, i = !1; t && t.nodeType !== 9 && !(i = t.domBelongToZr || t !== e && t === r.painterRoot); )
    t = t.parentNode;
  return i;
}
var nae = function() {
  function r(e, t) {
    this.stopPropagation = ur, this.stopImmediatePropagation = ur, this.preventDefault = ur, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY;
  }
  return r;
}(), da = {
  mousedown: function(r) {
    r = kn(this.dom, r), this.__mayPointerCapture = [r.zrX, r.zrY], this.trigger("mousedown", r);
  },
  mousemove: function(r) {
    r = kn(this.dom, r);
    var e = this.__mayPointerCapture;
    e && (r.zrX !== e[0] || r.zrY !== e[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    r = kn(this.dom, r), this.__togglePointerCapture(!1), this.trigger("mouseup", r);
  },
  mouseout: function(r) {
    r = kn(this.dom, r);
    var e = r.toElement || r.relatedTarget;
    MY(this, e) || (this.__pointerCapturing && (r.zrEventControl = "no_globalout"), this.trigger("mouseout", r));
  },
  wheel: function(r) {
    PD = !0, r = kn(this.dom, r), this.trigger("mousewheel", r);
  },
  mousewheel: function(r) {
    PD || (r = kn(this.dom, r), this.trigger("mousewheel", r));
  },
  touchstart: function(r) {
    r = kn(this.dom, r), jy(r), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(r, "start"), da.mousemove.call(this, r), da.mousedown.call(this, r);
  },
  touchmove: function(r) {
    r = kn(this.dom, r), jy(r), this.handler.processGesture(r, "change"), da.mousemove.call(this, r);
  },
  touchend: function(r) {
    r = kn(this.dom, r), jy(r), this.handler.processGesture(r, "end"), da.mouseup.call(this, r), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < tae && da.click.call(this, r);
  },
  pointerdown: function(r) {
    da.mousedown.call(this, r);
  },
  pointermove: function(r) {
    X_(r) || da.mousemove.call(this, r);
  },
  pointerup: function(r) {
    da.mouseup.call(this, r);
  },
  pointerout: function(r) {
    X_(r) || da.mouseout.call(this, r);
  }
};
N(["click", "dblclick", "contextmenu"], function(r) {
  da[r] = function(e) {
    e = kn(this.dom, e), this.trigger(r, e);
  };
});
var Y_ = {
  pointermove: function(r) {
    X_(r) || Y_.mousemove.call(this, r);
  },
  pointerup: function(r) {
    Y_.mouseup.call(this, r);
  },
  mousemove: function(r) {
    this.trigger("mousemove", r);
  },
  mouseup: function(r) {
    var e = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", r), e && (r.zrEventControl = "only_globalout", this.trigger("mouseout", r));
  }
};
function aae(r, e) {
  var t = e.domHandlers;
  ct.pointerEventsSupported ? N(qy.pointer, function(i) {
    qm(e, i, function(n) {
      t[i].call(r, n);
    });
  }) : (ct.touchEventsSupported && N(qy.touch, function(i) {
    qm(e, i, function(n) {
      t[i].call(r, n), rae(e);
    });
  }), N(qy.mouse, function(i) {
    qm(e, i, function(n) {
      n = w1(n), e.touching || t[i].call(r, n);
    });
  }));
}
function oae(r, e) {
  ct.pointerEventsSupported ? N(xD.pointer, t) : ct.touchEventsSupported || N(xD.mouse, t);
  function t(i) {
    function n(a) {
      a = w1(a), MY(r, a.target) || (a = iae(r, a), e.domHandlers[i].call(r, a));
    }
    qm(e, i, n, { capture: !0 });
  }
}
function qm(r, e, t, i) {
  r.mounted[e] = t, r.listenerOpts[e] = i, D_(r.domTarget, e, t, i);
}
function Ky(r) {
  var e = r.mounted;
  for (var t in e)
    e.hasOwnProperty(t) && dne(r.domTarget, t, e[t], r.listenerOpts[t]);
  r.mounted = {};
}
var LD = function() {
  function r(e, t) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = e, this.domHandlers = t;
  }
  return r;
}(), sae = function(r) {
  $(e, r);
  function e(t, i) {
    var n = r.call(this) || this;
    return n.__pointerCapturing = !1, n.dom = t, n.painterRoot = i, n._localHandlerScope = new LD(t, da), Zy && (n._globalHandlerScope = new LD(document, Y_)), aae(n, n._localHandlerScope), n;
  }
  return e.prototype.dispose = function() {
    Ky(this._localHandlerScope), Zy && Ky(this._globalHandlerScope);
  }, e.prototype.setCursor = function(t) {
    this.dom.style && (this.dom.style.cursor = t || "default");
  }, e.prototype.__togglePointerCapture = function(t) {
    if (this.__mayPointerCapture = null, Zy && +this.__pointerCapturing ^ +t) {
      this.__pointerCapturing = t;
      var i = this._globalHandlerScope;
      t ? oae(this, i) : Ky(i);
    }
  }, e;
}(oa);
const lae = sae;
var kY = 1;
ct.hasGlobalWindow && (kY = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var rb = kY, H_ = 0.4, W_ = "#333", z_ = "#ccc", uae = "#eee", DD = sT, MD = 5e-5;
function ou(r) {
  return r > MD || r < -MD;
}
var su = [], hh = [], Jy = na(), e0 = Math.abs, cae = function() {
  function r() {
  }
  return r.prototype.getLocalTransform = function(e) {
    return r.getLocalTransform(this, e);
  }, r.prototype.setPosition = function(e) {
    this.x = e[0], this.y = e[1];
  }, r.prototype.setScale = function(e) {
    this.scaleX = e[0], this.scaleY = e[1];
  }, r.prototype.setSkew = function(e) {
    this.skewX = e[0], this.skewY = e[1];
  }, r.prototype.setOrigin = function(e) {
    this.originX = e[0], this.originY = e[1];
  }, r.prototype.needLocalTransform = function() {
    return ou(this.rotation) || ou(this.x) || ou(this.y) || ou(this.scaleX - 1) || ou(this.scaleY - 1) || ou(this.skewX) || ou(this.skewY);
  }, r.prototype.updateTransform = function() {
    var e = this.parent && this.parent.transform, t = this.needLocalTransform(), i = this.transform;
    if (!(t || e)) {
      i && (DD(i), this.invTransform = null);
      return;
    }
    i = i || na(), t ? this.getLocalTransform(i) : DD(i), e && (t ? qo(i, e, i) : N1(i, e)), this.transform = i, this._resolveGlobalScaleRatio(i);
  }, r.prototype._resolveGlobalScaleRatio = function(e) {
    var t = this.globalScaleRatio;
    if (t != null && t !== 1) {
      this.getGlobalScale(su);
      var i = su[0] < 0 ? -1 : 1, n = su[1] < 0 ? -1 : 1, a = ((su[0] - i) * t + i) / su[0] || 0, o = ((su[1] - n) * t + n) / su[1] || 0;
      e[0] *= a, e[1] *= a, e[2] *= o, e[3] *= o;
    }
    this.invTransform = this.invTransform || na(), qf(this.invTransform, e);
  }, r.prototype.getComputedTransform = function() {
    for (var e = this, t = []; e; )
      t.push(e), e = e.parent;
    for (; e = t.pop(); )
      e.updateTransform();
    return this.transform;
  }, r.prototype.setLocalTransform = function(e) {
    if (e) {
      var t = e[0] * e[0] + e[1] * e[1], i = e[2] * e[2] + e[3] * e[3], n = Math.atan2(e[1], e[0]), a = Math.PI / 2 + n - Math.atan2(e[3], e[2]);
      i = Math.sqrt(i) * Math.cos(a), t = Math.sqrt(t), this.skewX = a, this.skewY = 0, this.rotation = -n, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = i, this.originX = 0, this.originY = 0;
    }
  }, r.prototype.decomposeTransform = function() {
    if (this.transform) {
      var e = this.parent, t = this.transform;
      e && e.transform && (qo(hh, e.invTransform, t), t = hh);
      var i = this.originX, n = this.originY;
      (i || n) && (Jy[4] = i, Jy[5] = n, qo(hh, t, Jy), hh[4] -= i, hh[5] -= n, t = hh), this.setLocalTransform(t);
    }
  }, r.prototype.getGlobalScale = function(e) {
    var t = this.transform;
    return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e);
  }, r.prototype.transformCoordToLocal = function(e, t) {
    var i = [e, t], n = this.invTransform;
    return n && Kr(i, i, n), i;
  }, r.prototype.transformCoordToGlobal = function(e, t) {
    var i = [e, t], n = this.transform;
    return n && Kr(i, i, n), i;
  }, r.prototype.getLineScale = function() {
    var e = this.transform;
    return e && e0(e[0] - 1) > 1e-10 && e0(e[3] - 1) > 1e-10 ? Math.sqrt(e0(e[0] * e[3] - e[2] * e[1])) : 1;
  }, r.prototype.copyTransform = function(e) {
    QY(this, e);
  }, r.getLocalTransform = function(e, t) {
    t = t || [];
    var i = e.originX || 0, n = e.originY || 0, a = e.scaleX, o = e.scaleY, s = e.anchorX, l = e.anchorY, u = e.rotation || 0, c = e.x, h = e.y, f = e.skewX ? Math.tan(e.skewX) : 0, d = e.skewY ? Math.tan(-e.skewY) : 0;
    if (i || n || s || l) {
      var p = i + s, g = n + l;
      t[4] = -p * a - f * g * o, t[5] = -g * o - d * p * a;
    } else
      t[4] = t[5] = 0;
    return t[0] = a, t[3] = o, t[1] = d * a, t[2] = f * o, u && zc(t, t, u), t[4] += i + c, t[5] += n + h, t;
  }, r.initDefaultProps = function() {
    var e = r.prototype;
    e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0;
  }(), r;
}(), Ro = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function QY(r, e) {
  for (var t = 0; t < Ro.length; t++) {
    var i = Ro[t];
    r[i] = e[i];
  }
}
const Ho = cae;
var kD = {};
function Tn(r, e) {
  e = e || Cl;
  var t = kD[e];
  t || (t = kD[e] = new Tv(500));
  var i = t.get(r);
  return i == null && (i = Il.measureText(r, e).width, t.put(r, i)), i;
}
function QD(r, e, t, i) {
  var n = Tn(r, e), a = uT(e), o = gp(0, n, t), s = Qh(0, a, i), l = new Ve(o, s, n, a);
  return l;
}
function yv(r, e, t, i) {
  var n = ((r || "") + "").split(`
`), a = n.length;
  if (a === 1)
    return QD(n[0], e, t, i);
  for (var o = new Ve(0, 0, 0, 0), s = 0; s < n.length; s++) {
    var l = QD(n[s], e, t, i);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function gp(r, e, t) {
  return t === "right" ? r -= e : t === "center" && (r -= e / 2), r;
}
function Qh(r, e, t) {
  return t === "middle" ? r -= e / 2 : t === "bottom" && (r -= e), r;
}
function uT(r) {
  return Tn("", r);
}
function xa(r, e) {
  return typeof r == "string" ? r.lastIndexOf("%") >= 0 ? parseFloat(r) / 100 * e : parseFloat(r) : r;
}
function ib(r, e, t) {
  var i = e.position || "inside", n = e.distance != null ? e.distance : 5, a = t.height, o = t.width, s = a / 2, l = t.x, u = t.y, c = "left", h = "top";
  if (i instanceof Array)
    l += xa(i[0], t.width), u += xa(i[1], t.height), c = null, h = null;
  else
    switch (i) {
      case "left":
        l -= n, u += s, c = "right", h = "middle";
        break;
      case "right":
        l += n + o, u += s, h = "middle";
        break;
      case "top":
        l += o / 2, u -= n, c = "center", h = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + n, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += n, u += s, h = "middle";
        break;
      case "insideRight":
        l += o - n, u += s, c = "right", h = "middle";
        break;
      case "insideTop":
        l += o / 2, u += n, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - n, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += n, u += n;
        break;
      case "insideTopRight":
        l += o - n, u += n, c = "right";
        break;
      case "insideBottomLeft":
        l += n, u += a - n, h = "bottom";
        break;
      case "insideBottomRight":
        l += o - n, u += a - n, c = "right", h = "bottom";
        break;
    }
  return r = r || {}, r.x = l, r.y = u, r.align = c, r.verticalAlign = h, r;
}
var t0 = "__zr_normal__", r0 = Ro.concat(["ignore"]), hae = To(Ro, function(r, e) {
  return r[e] = !0, r;
}, { ignore: !1 }), fh = {}, fae = new Ve(0, 0, 0, 0), M1 = function() {
  function r(e) {
    this.id = lY(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e);
  }
  return r.prototype._init = function(e) {
    this.attr(e);
  }, r.prototype.drift = function(e, t, i) {
    switch (this.draggable) {
      case "horizontal":
        t = 0;
        break;
      case "vertical":
        e = 0;
        break;
    }
    var n = this.transform;
    n || (n = this.transform = [1, 0, 0, 1, 0, 0]), n[4] += e, n[5] += t, this.decomposeTransform(), this.markRedraw();
  }, r.prototype.beforeUpdate = function() {
  }, r.prototype.afterUpdate = function() {
  }, r.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, r.prototype.updateInnerText = function(e) {
    var t = this._textContent;
    if (t && (!t.ignore || e)) {
      this.textConfig || (this.textConfig = {});
      var i = this.textConfig, n = i.local, a = t.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = n ? this : null;
      var u = !1;
      if (a.copyTransform(t), i.position != null) {
        var c = fae;
        i.layoutRect ? c.copy(i.layoutRect) : c.copy(this.getBoundingRect()), n || c.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(fh, i, c) : ib(fh, i, c), a.x = fh.x, a.y = fh.y, o = fh.align, s = fh.verticalAlign;
        var h = i.origin;
        if (h && i.rotation != null) {
          var f = void 0, d = void 0;
          h === "center" ? (f = c.width * 0.5, d = c.height * 0.5) : (f = xa(h[0], c.width), d = xa(h[1], c.height)), u = !0, a.originX = -a.x + f + (n ? 0 : c.x), a.originY = -a.y + d + (n ? 0 : c.y);
        }
      }
      i.rotation != null && (a.rotation = i.rotation);
      var p = i.offset;
      p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
      var g = i.inside == null ? typeof i.position == "string" && i.position.indexOf("inside") >= 0 : i.inside, v = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), O = void 0, m = void 0, E = void 0;
      g && this.canBeInsideText() ? (O = i.insideFill, m = i.insideStroke, (O == null || O === "auto") && (O = this.getInsideTextFill()), (m == null || m === "auto") && (m = this.getInsideTextStroke(O), E = !0)) : (O = i.outsideFill, m = i.outsideStroke, (O == null || O === "auto") && (O = this.getOutsideFill()), (m == null || m === "auto") && (m = this.getOutsideStroke(O), E = !0)), O = O || "#000", (O !== v.fill || m !== v.stroke || E !== v.autoStroke || o !== v.align || s !== v.verticalAlign) && (l = !0, v.fill = O, v.stroke = m, v.autoStroke = E, v.align = o, v.verticalAlign = s, t.setDefaultTextStyle(v)), t.__dirty |= vn, l && t.dirtyStyle(!0);
    }
  }, r.prototype.canBeInsideText = function() {
    return !0;
  }, r.prototype.getInsideTextFill = function() {
    return "#fff";
  }, r.prototype.getInsideTextStroke = function(e) {
    return "#000";
  }, r.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? z_ : W_;
  }, r.prototype.getOutsideStroke = function(e) {
    var t = this.__zr && this.__zr.getBackgroundColor(), i = typeof t == "string" && Sn(t);
    i || (i = [255, 255, 255, 1]);
    for (var n = i[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      i[o] = i[o] * n + (a ? 0 : 255) * (1 - n);
    return i[3] = 1, jo(i, "rgba");
  }, r.prototype.traverse = function(e, t) {
  }, r.prototype.attrKV = function(e, t) {
    e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, B(this.extra, t)) : this[e] = t;
  }, r.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, r.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, r.prototype.attr = function(e, t) {
    if (typeof e == "string")
      this.attrKV(e, t);
    else if (be(e))
      for (var i = e, n = Ze(i), a = 0; a < n.length; a++) {
        var o = n[a];
        this.attrKV(o, e[o]);
      }
    return this.markRedraw(), this;
  }, r.prototype.saveCurrentToNormalState = function(e) {
    this._innerSaveToNormal(e);
    for (var t = this._normalState, i = 0; i < this.animators.length; i++) {
      var n = this.animators[i], a = n.__fromStateTransition;
      if (!(n.getLoop() || a && a !== t0)) {
        var o = n.targetName, s = o ? t[o] : t;
        n.saveTo(s);
      }
    }
  }, r.prototype._innerSaveToNormal = function(e) {
    var t = this._normalState;
    t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, r0);
  }, r.prototype._savePrimaryToNormal = function(e, t, i) {
    for (var n = 0; n < i.length; n++) {
      var a = i[n];
      e[a] != null && !(a in t) && (t[a] = this[a]);
    }
  }, r.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, r.prototype.getState = function(e) {
    return this.states[e];
  }, r.prototype.ensureState = function(e) {
    var t = this.states;
    return t[e] || (t[e] = {}), t[e];
  }, r.prototype.clearStates = function(e) {
    this.useState(t0, !1, e);
  }, r.prototype.useState = function(e, t, i, n) {
    var a = e === t0, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(Fe(s, e) >= 0 && (t || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(e)), u || (u = this.states && this.states[e]), !u && !a) {
          _a("State " + e + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || n);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(e, u, this._normalState, t, !i && !this.__inHover && l && l.duration > 0, l);
        var h = this._textContent, f = this._textGuide;
        return h && h.useState(e, t, i, c), f && f.useState(e, t, i, c), a ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [e], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~vn), u;
      }
    }
  }, r.prototype.useStates = function(e, t, i) {
    if (!e.length)
      this.clearStates();
    else {
      var n = [], a = this.currentStates, o = e.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (e[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = e[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, e)), c || (c = this.states[u]), c && n.push(c);
      }
      var h = n[o - 1], f = !!(h && h.hoverLayer || i);
      f && this._toggleHoverLayerFlag(!0);
      var d = this._mergeStates(n), p = this.stateTransition;
      this.saveCurrentToNormalState(d), this._applyStateObj(e.join(","), d, this._normalState, !1, !t && !this.__inHover && p && p.duration > 0, p);
      var g = this._textContent, v = this._textGuide;
      g && g.useStates(e, t, f), v && v.useStates(e, t, f), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~vn);
    }
  }, r.prototype._updateAnimationTargets = function() {
    for (var e = 0; e < this.animators.length; e++) {
      var t = this.animators[e];
      t.targetName && t.changeTarget(this[t.targetName]);
    }
  }, r.prototype.removeState = function(e) {
    var t = Fe(this.currentStates, e);
    if (t >= 0) {
      var i = this.currentStates.slice();
      i.splice(t, 1), this.useStates(i);
    }
  }, r.prototype.replaceState = function(e, t, i) {
    var n = this.currentStates.slice(), a = Fe(n, e), o = Fe(n, t) >= 0;
    a >= 0 ? o ? n.splice(a, 1) : n[a] = t : i && !o && n.push(t), this.useStates(n);
  }, r.prototype.toggleState = function(e, t) {
    t ? this.useState(e, !0) : this.removeState(e);
  }, r.prototype._mergeStates = function(e) {
    for (var t = {}, i, n = 0; n < e.length; n++) {
      var a = e[n];
      B(t, a), a.textConfig && (i = i || {}, B(i, a.textConfig));
    }
    return i && (t.textConfig = i), t;
  }, r.prototype._applyStateObj = function(e, t, i, n, a, o) {
    var s = !(t && n);
    t && t.textConfig ? (this.textConfig = B({}, n ? this.textConfig : i.textConfig), B(this.textConfig, t.textConfig)) : s && i.textConfig && (this.textConfig = i.textConfig);
    for (var l = {}, u = !1, c = 0; c < r0.length; c++) {
      var h = r0[c], f = a && hae[h];
      t && t[h] != null ? f ? (u = !0, l[h] = t[h]) : this[h] = t[h] : s && i[h] != null && (f ? (u = !0, l[h] = i[h]) : this[h] = i[h]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], p = d.targetName;
        d.getLoop() || d.__changeFinalValue(p ? (t || i)[p] : t || i);
      }
    u && this._transitionState(e, l, o);
  }, r.prototype._attachComponent = function(e) {
    if (e.__zr && !e.__hostTarget) {
      if ({}.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (e === this) {
      if ({}.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var t = this.__zr;
    t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this;
  }, r.prototype._detachComponent = function(e) {
    e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null;
  }, r.prototype.getClipPath = function() {
    return this._clipPath;
  }, r.prototype.setClipPath = function(e) {
    this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw();
  }, r.prototype.removeClipPath = function() {
    var e = this._clipPath;
    e && (this._detachComponent(e), this._clipPath = null, this.markRedraw());
  }, r.prototype.getTextContent = function() {
    return this._textContent;
  }, r.prototype.setTextContent = function(e) {
    var t = this._textContent;
    if (t !== e) {
      if (t && t !== e && this.removeTextContent(), {}.NODE_ENV !== "production" && e.__zr && !e.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      e.innerTransformable = new Ho(), this._attachComponent(e), this._textContent = e, this.markRedraw();
    }
  }, r.prototype.setTextConfig = function(e) {
    this.textConfig || (this.textConfig = {}), B(this.textConfig, e), this.markRedraw();
  }, r.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, r.prototype.removeTextContent = function() {
    var e = this._textContent;
    e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, r.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, r.prototype.setTextGuideLine = function(e) {
    this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw();
  }, r.prototype.removeTextGuideLine = function() {
    var e = this._textGuide;
    e && (this._detachComponent(e), this._textGuide = null, this.markRedraw());
  }, r.prototype.markRedraw = function() {
    this.__dirty |= vn;
    var e = this.__zr;
    e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, r.prototype.dirty = function() {
    this.markRedraw();
  }, r.prototype._toggleHoverLayerFlag = function(e) {
    this.__inHover = e;
    var t = this._textContent, i = this._textGuide;
    t && (t.__inHover = e), i && (i.__inHover = e);
  }, r.prototype.addSelfToZr = function(e) {
    if (this.__zr !== e) {
      this.__zr = e;
      var t = this.animators;
      if (t)
        for (var i = 0; i < t.length; i++)
          e.animation.addAnimator(t[i]);
      this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e);
    }
  }, r.prototype.removeSelfFromZr = function(e) {
    if (this.__zr) {
      this.__zr = null;
      var t = this.animators;
      if (t)
        for (var i = 0; i < t.length; i++)
          e.animation.removeAnimator(t[i]);
      this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e);
    }
  }, r.prototype.animate = function(e, t, i) {
    var n = e ? this[e] : this;
    if ({}.NODE_ENV !== "production" && !n) {
      _a('Property "' + e + '" is not existed in element ' + this.id);
      return;
    }
    var a = new D1(n, t, i);
    return e && (a.targetName = e), this.addAnimator(a, e), a;
  }, r.prototype.addAnimator = function(e, t) {
    var i = this.__zr, n = this;
    e.during(function() {
      n.updateDuringAnimation(t);
    }).done(function() {
      var a = n.animators, o = Fe(a, e);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(e), i && i.animation.addAnimator(e), i && i.wakeUp();
  }, r.prototype.updateDuringAnimation = function(e) {
    this.markRedraw();
  }, r.prototype.stopAnimation = function(e, t) {
    for (var i = this.animators, n = i.length, a = [], o = 0; o < n; o++) {
      var s = i[o];
      !e || e === s.scope ? s.stop(t) : a.push(s);
    }
    return this.animators = a, this;
  }, r.prototype.animateTo = function(e, t, i) {
    i0(this, e, t, i);
  }, r.prototype.animateFrom = function(e, t, i) {
    i0(this, e, t, i, !0);
  }, r.prototype._transitionState = function(e, t, i, n) {
    for (var a = i0(this, t, i, n), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = e;
  }, r.prototype.getBoundingRect = function() {
    return null;
  }, r.prototype.getPaintRect = function() {
    return null;
  }, r.initDefaultProps = function() {
    var e = r.prototype;
    e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = !1, e.__dirty = vn;
    var t = {};
    function i(a, o, s) {
      t[a + o + s] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + o + "', '" + s + "' instead"), t[a + o + s] = !0);
    }
    function n(a, o, s, l) {
      Object.defineProperty(e, a, {
        get: function() {
          if ({}.NODE_ENV !== "production" && i(a, s, l), !this[o]) {
            var c = this[o] = [];
            u(this, c);
          }
          return this[o];
        },
        set: function(c) {
          ({}).NODE_ENV !== "production" && i(a, s, l), this[s] = c[0], this[l] = c[1], this[o] = c, u(this, c);
        }
      });
      function u(c, h) {
        Object.defineProperty(h, 0, {
          get: function() {
            return c[s];
          },
          set: function(f) {
            c[s] = f;
          }
        }), Object.defineProperty(h, 1, {
          get: function() {
            return c[l];
          },
          set: function(f) {
            c[l] = f;
          }
        });
      }
    }
    Object.defineProperty && (n("position", "_legacyPos", "x", "y"), n("scale", "_legacyScale", "scaleX", "scaleY"), n("origin", "_legacyOrigin", "originX", "originY"));
  }(), r;
}();
br(M1, oa);
br(M1, Ho);
function i0(r, e, t, i, n) {
  t = t || {};
  var a = [];
  UY(r, "", r, e, t, i, a, n);
  var o = a.length, s = !1, l = t.done, u = t.aborted, c = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, h = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && t.during && a[0].during(function(p, g) {
    t.during(g);
  });
  for (var f = 0; f < a.length; f++) {
    var d = a[f];
    c && d.done(c), h && d.aborted(h), t.force && d.duration(t.duration), d.start(t.easing);
  }
  return a;
}
function n0(r, e, t) {
  for (var i = 0; i < t; i++)
    r[i] = e[i];
}
function dae(r) {
  return mi(r[0]);
}
function pae(r, e, t) {
  if (mi(e[t]))
    if (mi(r[t]) || (r[t] = []), en(e[t])) {
      var i = e[t].length;
      r[t].length !== i && (r[t] = new e[t].constructor(i), n0(r[t], e[t], i));
    } else {
      var n = e[t], a = r[t], o = n.length;
      if (dae(n))
        for (var s = n[0].length, l = 0; l < o; l++)
          a[l] ? n0(a[l], n[l], s) : a[l] = Array.prototype.slice.call(n[l]);
      else
        n0(a, n, o);
      a.length = n.length;
    }
  else
    r[t] = e[t];
}
function gae(r, e) {
  return r === e || mi(r) && mi(e) && vae(r, e);
}
function vae(r, e) {
  var t = r.length;
  if (t !== e.length)
    return !1;
  for (var i = 0; i < t; i++)
    if (r[i] !== e[i])
      return !1;
  return !0;
}
function UY(r, e, t, i, n, a, o, s) {
  for (var l = Ze(i), u = n.duration, c = n.delay, h = n.additive, f = n.setToFinal, d = !be(a), p = r.animators, g = [], v = 0; v < l.length; v++) {
    var O = l[v], m = i[O];
    if (m != null && t[O] != null && (d || a[O]))
      if (be(m) && !mi(m) && !aT(m)) {
        if (e) {
          s || (t[O] = m, r.updateDuringAnimation(e));
          continue;
        }
        UY(r, O, t[O], m, n, a && a[O], o, s);
      } else
        g.push(O);
    else
      s || (t[O] = m, r.updateDuringAnimation(e), g.push(O));
  }
  var E = g.length;
  if (!h && E)
    for (var b = 0; b < p.length; b++) {
      var S = p[b];
      if (S.targetName === e) {
        var T = S.stopTracks(g);
        if (T) {
          var y = Fe(p, S);
          p.splice(y, 1);
        }
      }
    }
  if (n.force || (g = At(g, function(I) {
    return !gae(i[I], t[I]);
  }), E = g.length), E > 0 || n.force && !o.length) {
    var R = void 0, _ = void 0, C = void 0;
    if (s) {
      _ = {}, f && (R = {});
      for (var b = 0; b < E; b++) {
        var O = g[b];
        _[O] = t[O], f ? R[O] = i[O] : t[O] = i[O];
      }
    } else if (f) {
      C = {};
      for (var b = 0; b < E; b++) {
        var O = g[b];
        C[O] = Yp(t[O]), pae(t, i, O);
      }
    }
    var S = new D1(t, !1, !1, h ? At(p, function(w) {
      return w.targetName === e;
    }) : null);
    S.targetName = e, n.scope && (S.scope = n.scope), f && R && S.whenWithKeys(0, R, g), C && S.whenWithKeys(0, C, g), S.whenWithKeys(u ?? 500, s ? _ : i, g).delay(c || 0), r.addAnimator(S, e), o.push(S);
  }
}
const $Y = M1;
var VY = function(r) {
  $(e, r);
  function e(t) {
    var i = r.call(this) || this;
    return i.isGroup = !0, i._children = [], i.attr(t), i;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.children = function() {
    return this._children.slice();
  }, e.prototype.childAt = function(t) {
    return this._children[t];
  }, e.prototype.childOfName = function(t) {
    for (var i = this._children, n = 0; n < i.length; n++)
      if (i[n].name === t)
        return i[n];
  }, e.prototype.childCount = function() {
    return this._children.length;
  }, e.prototype.add = function(t) {
    if (t && (t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), {}.NODE_ENV !== "production" && t.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, e.prototype.addBefore = function(t, i) {
    if (t && t !== this && t.parent !== this && i && i.parent === this) {
      var n = this._children, a = n.indexOf(i);
      a >= 0 && (n.splice(a, 0, t), this._doAdd(t));
    }
    return this;
  }, e.prototype.replace = function(t, i) {
    var n = Fe(this._children, t);
    return n >= 0 && this.replaceAt(i, n), this;
  }, e.prototype.replaceAt = function(t, i) {
    var n = this._children, a = n[i];
    if (t && t !== this && t.parent !== this && t !== a) {
      n[i] = t, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(t);
    }
    return this;
  }, e.prototype._doAdd = function(t) {
    t.parent && t.parent.remove(t), t.parent = this;
    var i = this.__zr;
    i && i !== t.__zr && t.addSelfToZr(i), i && i.refresh();
  }, e.prototype.remove = function(t) {
    var i = this.__zr, n = this._children, a = Fe(n, t);
    return a < 0 ? this : (n.splice(a, 1), t.parent = null, i && t.removeSelfFromZr(i), i && i.refresh(), this);
  }, e.prototype.removeAll = function() {
    for (var t = this._children, i = this.__zr, n = 0; n < t.length; n++) {
      var a = t[n];
      i && a.removeSelfFromZr(i), a.parent = null;
    }
    return t.length = 0, this;
  }, e.prototype.eachChild = function(t, i) {
    for (var n = this._children, a = 0; a < n.length; a++) {
      var o = n[a];
      t.call(i, o, a);
    }
    return this;
  }, e.prototype.traverse = function(t, i) {
    for (var n = 0; n < this._children.length; n++) {
      var a = this._children[n], o = t.call(i, a);
      a.isGroup && !o && a.traverse(t, i);
    }
    return this;
  }, e.prototype.addSelfToZr = function(t) {
    r.prototype.addSelfToZr.call(this, t);
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    r.prototype.removeSelfFromZr.call(this, t);
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.removeSelfFromZr(t);
    }
  }, e.prototype.getBoundingRect = function(t) {
    for (var i = new Ve(0, 0, 0, 0), n = t || this._children, a = [], o = null, s = 0; s < n.length; s++) {
      var l = n[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (Ve.applyTransform(i, u, c), o = o || i.clone(), o.union(i)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || i;
  }, e;
}($Y);
VY.prototype.type = "group";
const Re = VY;
/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/
var vp = {}, GY = {};
function Oae(r) {
  delete GY[r];
}
function mae(r) {
  if (!r)
    return !1;
  if (typeof r == "string")
    return eb(r, 1) < H_;
  if (r.colorStops) {
    for (var e = r.colorStops, t = 0, i = e.length, n = 0; n < i; n++)
      t += eb(e[n].color, 1);
    return t /= i, t < H_;
  }
  return !1;
}
var Eae = function() {
  function r(e, t, i) {
    var n = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, i = i || {}, this.dom = t, this.id = e;
    var a = new wne(), o = i.renderer || "canvas";
    if (vp[o] || (o = Ze(vp)[0]), {}.NODE_ENV !== "production" && !vp[o])
      throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
    i.useDirtyRect = i.useDirtyRect == null ? !1 : i.useDirtyRect;
    var s = new vp[o](t, a, i, e), l = i.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !ct.node && !ct.worker && !l ? new lae(s.getViewportRoot(), s.root) : null, c = i.useCoarsePointer, h = c == null || c === "auto" ? ct.touchEventsSupported : !!c, f = 44, d;
    h && (d = ke(i.pointerSize, f)), this.handler = new Rne(a, s, u, s.root, d), this.animation = new eae({
      stage: {
        update: l ? null : function() {
          return n._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return r.prototype.add = function(e) {
    e && (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh());
  }, r.prototype.remove = function(e) {
    e && (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh());
  }, r.prototype.configLayer = function(e, t) {
    this.painter.configLayer && this.painter.configLayer(e, t), this.refresh();
  }, r.prototype.setBackgroundColor = function(e) {
    this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = mae(e);
  }, r.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, r.prototype.setDarkMode = function(e) {
    this._darkMode = e;
  }, r.prototype.isDarkMode = function() {
    return this._darkMode;
  }, r.prototype.refreshImmediately = function(e) {
    e || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1;
  }, r.prototype.refresh = function() {
    this._needsRefresh = !0, this.animation.start();
  }, r.prototype.flush = function() {
    this._flush(!1);
  }, r.prototype._flush = function(e) {
    var t, i = Hh();
    this._needsRefresh && (t = !0, this.refreshImmediately(e)), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately());
    var n = Hh();
    t ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: n - i
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, r.prototype.setSleepAfterStill = function(e) {
    this._sleepAfterStill = e;
  }, r.prototype.wakeUp = function() {
    this.animation.start(), this._stillFrameAccum = 0;
  }, r.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, r.prototype.refreshHoverImmediately = function() {
    this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover();
  }, r.prototype.resize = function(e) {
    e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize();
  }, r.prototype.clearAnimation = function() {
    this.animation.clear();
  }, r.prototype.getWidth = function() {
    return this.painter.getWidth();
  }, r.prototype.getHeight = function() {
    return this.painter.getHeight();
  }, r.prototype.setCursorStyle = function(e) {
    this.handler.setCursorStyle(e);
  }, r.prototype.findHover = function(e, t) {
    return this.handler.findHover(e, t);
  }, r.prototype.on = function(e, t, i) {
    return this.handler.on(e, t, i), this;
  }, r.prototype.off = function(e, t) {
    this.handler.off(e, t);
  }, r.prototype.trigger = function(e, t) {
    this.handler.trigger(e, t);
  }, r.prototype.clear = function() {
    for (var e = this.storage.getRoots(), t = 0; t < e.length; t++)
      e[t] instanceof Re && e[t].removeSelfFromZr(this);
    this.storage.delAllRoots(), this.painter.clear();
  }, r.prototype.dispose = function() {
    this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, Oae(this.id);
  }, r;
}();
function UD(r, e) {
  var t = new Eae(lY(), r, e);
  return GY[t.id] = t, t;
}
function bae(r, e) {
  vp[r] = e;
}
var $D = 1e-4, BY = 20;
function Sae(r) {
  return r.replace(/^\s+|\s+$/g, "");
}
function yt(r, e, t, i) {
  var n = e[0], a = e[1], o = t[0], s = t[1], l = a - n, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (i)
    if (l > 0) {
      if (r <= n)
        return o;
      if (r >= a)
        return s;
    } else {
      if (r >= n)
        return o;
      if (r <= a)
        return s;
    }
  else {
    if (r === n)
      return o;
    if (r === a)
      return s;
  }
  return (r - n) / l * u + o;
}
function K(r, e) {
  switch (r) {
    case "center":
    case "middle":
      r = "50%";
      break;
    case "left":
    case "top":
      r = "0%";
      break;
    case "right":
    case "bottom":
      r = "100%";
      break;
  }
  return ne(r) ? Sae(r).match(/%$/) ? parseFloat(r) / 100 * e : parseFloat(r) : r == null ? NaN : +r;
}
function rr(r, e, t) {
  return e == null && (e = 10), e = Math.min(Math.max(0, e), BY), r = (+r).toFixed(e), t ? r : +r;
}
function Zn(r) {
  return r.sort(function(e, t) {
    return e - t;
  }), r;
}
function oo(r) {
  if (r = +r, isNaN(r))
    return 0;
  if (r > 1e-14) {
    for (var e = 1, t = 0; t < 15; t++, e *= 10)
      if (Math.round(r * e) / e === r)
        return t;
  }
  return Z_(r);
}
function Z_(r) {
  var e = r.toString().toLowerCase(), t = e.indexOf("e"), i = t > 0 ? +e.slice(t + 1) : 0, n = t > 0 ? t : e.length, a = e.indexOf("."), o = a < 0 ? 0 : n - 1 - a;
  return Math.max(0, o - i);
}
function FY(r, e) {
  var t = Math.log, i = Math.LN10, n = Math.floor(t(r[1] - r[0]) / i), a = Math.round(t(Math.abs(e[1] - e[0])) / i), o = Math.min(Math.max(-n + a, 0), 20);
  return isFinite(o) ? o : 20;
}
function Tae(r, e) {
  var t = To(r, function(d, p) {
    return d + (isNaN(p) ? 0 : p);
  }, 0);
  if (t === 0)
    return [];
  for (var i = Math.pow(10, e), n = Y(r, function(d) {
    return (isNaN(d) ? 0 : d) / t * i * 100;
  }), a = i * 100, o = Y(n, function(d) {
    return Math.floor(d);
  }), s = To(o, function(d, p) {
    return d + p;
  }, 0), l = Y(n, function(d, p) {
    return d - o[p];
  }); s < a; ) {
    for (var u = Number.NEGATIVE_INFINITY, c = null, h = 0, f = l.length; h < f; ++h)
      l[h] > u && (u = l[h], c = h);
    ++o[c], l[c] = 0, ++s;
  }
  return Y(o, function(d) {
    return d / i;
  });
}
function yae(r, e) {
  var t = Math.max(oo(r), oo(e)), i = r + e;
  return t > BY ? i : rr(i, t);
}
var VD = 9007199254740991;
function XY(r) {
  var e = Math.PI * 2;
  return (r % e + e) % e;
}
function nb(r) {
  return r > -$D && r < $D;
}
var Rae = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Ao(r) {
  if (r instanceof Date)
    return r;
  if (ne(r)) {
    var e = Rae.exec(r);
    if (!e)
      return /* @__PURE__ */ new Date(NaN);
    if (e[8]) {
      var t = +e[4] || 0;
      return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0));
    } else
      return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0);
  } else if (r == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(r));
}
function Aae(r) {
  return Math.pow(10, cT(r));
}
function cT(r) {
  if (r === 0)
    return 0;
  var e = Math.floor(Math.log(r) / Math.LN10);
  return r / Math.pow(10, e) >= 10 && e++, e;
}
function YY(r, e) {
  var t = cT(r), i = Math.pow(10, t), n = r / i, a;
  return e ? n < 1.5 ? a = 1 : n < 2.5 ? a = 2 : n < 4 ? a = 3 : n < 7 ? a = 5 : a = 10 : n < 1 ? a = 1 : n < 2 ? a = 2 : n < 3 ? a = 3 : n < 5 ? a = 5 : a = 10, r = a * i, t >= -20 ? +r.toFixed(t < 0 ? -t : 0) : r;
}
function a0(r, e) {
  var t = (r.length - 1) * e + 1, i = Math.floor(t), n = +r[i - 1], a = t - i;
  return a ? n + a * (r[i] - n) : n;
}
function GD(r) {
  r.sort(function(l, u) {
    return s(l, u, 0) ? -1 : 1;
  });
  for (var e = -1 / 0, t = 1, i = 0; i < r.length; ) {
    for (var n = r[i].interval, a = r[i].close, o = 0; o < 2; o++)
      n[o] <= e && (n[o] = e, a[o] = o ? 1 : 1 - t), e = n[o], t = a[o];
    n[0] === n[1] && a[0] * a[1] !== 1 ? r.splice(i, 1) : i++;
  }
  return r;
  function s(l, u, c) {
    return l.interval[c] < u.interval[c] || l.interval[c] === u.interval[c] && (l.close[c] - u.close[c] === (c ? -1 : 1) || !c && s(l, u, 1));
  }
}
function ss(r) {
  var e = parseFloat(r);
  return e == r && (e !== 0 || !ne(r) || r.indexOf("x") <= 0) ? e : NaN;
}
function k1(r) {
  return !isNaN(ss(r));
}
function HY() {
  return Math.round(Math.random() * 9);
}
function WY(r, e) {
  return e === 0 ? r : WY(e, r % e);
}
function BD(r, e) {
  return r == null ? e : e == null ? r : r * e / WY(r, e);
}
var _ae = "[ECharts] ", FD = {}, Cae = typeof console < "u" && console.warn && console.log;
function hT(r, e, t) {
  if (Cae) {
    if (t) {
      if (FD[e])
        return;
      FD[e] = !0;
    }
    console[r](_ae + e);
  }
}
function Iae(r, e) {
  hT("log", r, e);
}
function tr(r, e) {
  hT("warn", r, e);
}
function ti(r, e) {
  hT("error", r, e);
}
function Pa(r) {
  ({}).NODE_ENV !== "production" && hT("warn", "DEPRECATED: " + r, !0);
}
function fr(r, e, t) {
  ({}).NODE_ENV !== "production" && Pa((t ? "[" + t + "]" : "") + (r + " is deprecated, use " + e + " instead."));
}
function Ui() {
  for (var r = [], e = 0; e < arguments.length; e++)
    r[e] = arguments[e];
  var t = "";
  if ({}.NODE_ENV !== "production") {
    var i = function(n) {
      return n === void 0 ? "undefined" : n === 1 / 0 ? "Infinity" : n === -1 / 0 ? "-Infinity" : Cc(n) ? "NaN" : n instanceof Date ? "Date(" + n.toISOString() + ")" : ve(n) ? "function () { ... }" : uY(n) ? n + "" : null;
    };
    t = Y(r, function(n) {
      if (ne(n))
        return n;
      var a = i(n);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(n, function(o, s) {
            var l = i(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return t;
}
function St(r) {
  throw new Error(r);
}
function XD(r, e, t) {
  return (e - r) * t + r;
}
var zY = "series\0", ZY = "\0_ec_\0";
function It(r) {
  return r instanceof Array ? r : r == null ? [] : [r];
}
function Ic(r, e, t) {
  if (r) {
    r[e] = r[e] || {}, r.emphasis = r.emphasis || {}, r.emphasis[e] = r.emphasis[e] || {};
    for (var i = 0, n = t.length; i < n; i++) {
      var a = t[i];
      !r.emphasis[e].hasOwnProperty(a) && r[e].hasOwnProperty(a) && (r.emphasis[e][a] = r[e][a]);
    }
  }
}
var YD = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function jf(r) {
  return be(r) && !X(r) && !(r instanceof Date) ? r.value : r;
}
function wae(r) {
  return be(r) && !(r instanceof Array);
}
function qY(r, e, t) {
  var i = t === "normalMerge", n = t === "replaceMerge", a = t === "replaceAll";
  r = r || [], e = (e || []).slice();
  var o = de();
  N(e, function(l, u) {
    if (!be(l)) {
      e[u] = null;
      return;
    }
    ({}).NODE_ENV !== "production" && (l.id != null && !WD(l.id) && HD(l.id), l.name != null && !WD(l.name) && HD(l.name));
  });
  var s = Nae(r, o, t);
  return (i || n) && xae(s, r, o, e), i && Pae(s, e), i || n ? Lae(s, e, n) : a && Dae(s, e), Mae(s), s;
}
function Nae(r, e, t) {
  var i = [];
  if (t === "replaceAll")
    return i;
  for (var n = 0; n < r.length; n++) {
    var a = r[n];
    a && a.id != null && e.set(a.id, n), i.push({
      existing: t === "replaceMerge" || If(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return i;
}
function xae(r, e, t, i) {
  N(i, function(n, a) {
    if (!(!n || n.id == null)) {
      var o = Hp(n.id), s = t.get(o);
      if (s != null) {
        var l = r[s];
        Se(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = n, l.existing = e[s], i[a] = null;
      }
    }
  });
}
function Pae(r, e) {
  N(e, function(t, i) {
    if (!(!t || t.name == null))
      for (var n = 0; n < r.length; n++) {
        var a = r[n].existing;
        if (!r[n].newOption && a && (a.id == null || t.id == null) && !If(t) && !If(a) && jY("name", a, t)) {
          r[n].newOption = t, e[i] = null;
          return;
        }
      }
  });
}
function Lae(r, e, t) {
  N(e, function(i) {
    if (i) {
      for (
        var n, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (n = r[a]) && // (1) Existing models that already have id should be able to mapped to. Because
        // after mapping performed, model will always be assigned with an id if user not given.
        // After that all models have id.
        // (2) If new option has id, it can only set to a hole or append to the last. It should
        // not be merged to the existings with different id. Because id should not be overwritten.
        // (3) Name can be overwritten, because axis use name as 'show label text'.
        (n.newOption || If(n.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        n.existing && i.id != null && !jY("id", i, n.existing));
      )
        a++;
      n ? (n.newOption = i, n.brandNew = t) : r.push({
        newOption: i,
        brandNew: t,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function Dae(r, e) {
  N(e, function(t) {
    r.push({
      newOption: t,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function Mae(r) {
  var e = de();
  N(r, function(t) {
    var i = t.existing;
    i && e.set(i.id, t);
  }), N(r, function(t) {
    var i = t.newOption;
    Se(!i || i.id == null || !e.get(i.id) || e.get(i.id) === t, "id duplicates: " + (i && i.id)), i && i.id != null && e.set(i.id, t), !t.keyInfo && (t.keyInfo = {});
  }), N(r, function(t, i) {
    var n = t.existing, a = t.newOption, o = t.keyInfo;
    if (be(a)) {
      if (o.name = a.name != null ? Hp(a.name) : n ? n.name : zY + i, n)
        o.id = Hp(n.id);
      else if (a.id != null)
        o.id = Hp(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (e.get(o.id));
      }
      e.set(o.id, t);
    }
  });
}
function jY(r, e, t) {
  var i = Ar(e[r], null), n = Ar(t[r], null);
  return i != null && n != null && i === n;
}
function Hp(r) {
  if ({}.NODE_ENV !== "production" && r == null)
    throw new Error();
  return Ar(r, "");
}
function Ar(r, e) {
  return r == null ? e : ne(r) ? r : pt(r) || zE(r) ? r + "" : e;
}
function HD(r) {
  ({}).NODE_ENV !== "production" && tr("`" + r + "` is invalid id or name. Must be a string or number.");
}
function WD(r) {
  return zE(r) || k1(r);
}
function Q1(r) {
  var e = r.name;
  return !!(e && e.indexOf(zY));
}
function If(r) {
  return r && r.id != null && Hp(r.id).indexOf(ZY) === 0;
}
function kae(r) {
  return ZY + r;
}
function Qae(r, e, t) {
  N(r, function(i) {
    var n = i.newOption;
    be(n) && (i.keyInfo.mainType = e, i.keyInfo.subType = Uae(e, n, i.existing, t));
  });
}
function Uae(r, e, t, i) {
  var n = e.type ? e.type : t ? t.subType : i.determineSubType(r, e);
  return n;
}
function $ae(r, e) {
  var t = {}, i = {};
  return n(r || [], t), n(e || [], i, t), [a(t), a(i)];
  function n(o, s, l) {
    for (var u = 0, c = o.length; u < c; u++) {
      var h = Ar(o[u].seriesId, null);
      if (h == null)
        return;
      for (var f = It(o[u].dataIndex), d = l && l[h], p = 0, g = f.length; p < g; p++) {
        var v = f[p];
        d && d[v] ? d[v] = null : (s[h] || (s[h] = {}))[v] = 1;
      }
    }
  }
  function a(o, s) {
    var l = [];
    for (var u in o)
      if (o.hasOwnProperty(u) && o[u] != null)
        if (s)
          l.push(+u);
        else {
          var c = a(o[u], !0);
          c.length && l.push({
            seriesId: u,
            dataIndex: c
          });
        }
    return l;
  }
}
function wc(r, e) {
  if (e.dataIndexInside != null)
    return e.dataIndexInside;
  if (e.dataIndex != null)
    return X(e.dataIndex) ? Y(e.dataIndex, function(t) {
      return r.indexOfRawIndex(t);
    }) : r.indexOfRawIndex(e.dataIndex);
  if (e.name != null)
    return X(e.name) ? Y(e.name, function(t) {
      return r.indexOfName(t);
    }) : r.indexOfName(e.name);
}
function ft() {
  var r = "__ec_inner_" + Vae++;
  return function(e) {
    return e[r] || (e[r] = {});
  };
}
var Vae = HY();
function Wp(r, e, t) {
  var i = U1(e, t), n = i.mainTypeSpecified, a = i.queryOptionMap, o = i.others, s = o, l = t ? t.defaultMainType : null;
  return !n && l && a.set(l, {}), a.each(function(u, c) {
    var h = Rv(r, c, u, {
      useDefault: l === c,
      enableAll: t && t.enableAll != null ? t.enableAll : !0,
      enableNone: t && t.enableNone != null ? t.enableNone : !0
    });
    s[c + "Models"] = h.models, s[c + "Model"] = h.models[0];
  }), s;
}
function U1(r, e) {
  var t;
  if (ne(r)) {
    var i = {};
    i[r + "Index"] = 0, t = i;
  } else
    t = r;
  var n = de(), a = {}, o = !1;
  return N(t, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
    if (!(!c || !h || e && e.includeMainTypes && Fe(e.includeMainTypes, c) < 0)) {
      o = o || !!c;
      var f = n.get(c) || n.set(c, {});
      f[h] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: n,
    others: a
  };
}
var Or = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
}, Gae = {
  useDefault: !1,
  enableAll: !0,
  enableNone: !0
};
function Rv(r, e, t, i) {
  i = i || Or;
  var n = t.index, a = t.id, o = t.name, s = {
    models: null,
    specified: n != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = i.useDefault && (l = r.getComponent(e)) ? [l] : [], s;
  }
  return n === "none" || n === !1 ? (Se(i.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (n === "all" && (Se(i.enableAll, '`"all"` is not a valid value on index option.'), n = a = o = null), s.models = r.queryComponents({
    mainType: e,
    index: n,
    id: a,
    name: o
  }), s);
}
function Bae(r, e, t) {
  r.setAttribute ? r.setAttribute(e, t) : r[e] = t;
}
function Fae(r) {
  return r === "auto" ? ct.domSupported ? "html" : "richText" : r || "html";
}
function q_(r, e) {
  var t = de(), i = [];
  return N(r, function(n) {
    var a = e(n);
    (t.get(a) || (i.push(a), t.set(a, []))).push(n);
  }), {
    keys: i,
    buckets: t
  };
}
function KY(r, e, t, i, n) {
  var a = e == null || e === "auto";
  if (i == null)
    return i;
  if (pt(i)) {
    var o = XD(t || 0, i, n);
    return rr(o, a ? Math.max(oo(t || 0), oo(i)) : e);
  } else {
    if (ne(i))
      return n < 1 ? t : i;
    for (var s = [], l = t, u = i, c = Math.max(l ? l.length : 0, u.length), h = 0; h < c; ++h) {
      var f = r.getDimensionInfo(h);
      if (f && f.type === "ordinal")
        s[h] = (n < 1 && l ? l : u)[h];
      else {
        var d = l && l[h] ? l[h] : 0, p = u[h], o = XD(d, p, n);
        s[h] = rr(o, a ? Math.max(oo(d), oo(p)) : e);
      }
    }
    return s;
  }
}
var Xae = ".", lu = "___EC__COMPONENT__CONTAINER___", JY = "___EC__EXTENDED_CLASS___";
function so(r) {
  var e = {
    main: "",
    sub: ""
  };
  if (r) {
    var t = r.split(Xae);
    e.main = t[0] || "", e.sub = t[1] || "";
  }
  return e;
}
function Yae(r) {
  Se(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(r), 'componentType "' + r + '" illegal');
}
function Hae(r) {
  return !!(r && r[JY]);
}
function $1(r, e) {
  r.$constructor = r, r.extend = function(t) {
    ({}).NODE_ENV !== "production" && N(e, function(a) {
      t[a] || console.warn("Method `" + a + "` should be implemented" + (t.type ? " in " + t.type : "") + ".");
    });
    var i = this, n;
    return Wae(i) ? n = /** @class */
    function(a) {
      $(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    }(i) : (n = function() {
      (t.$constructor || i).apply(this, arguments);
    }, Yie(n, this)), B(n.prototype, t), n[JY] = !0, n.extend = this.extend, n.superCall = qae, n.superApply = jae, n.superClass = i, n;
  };
}
function Wae(r) {
  return ve(r) && /^class\s/.test(Function.prototype.toString.call(r));
}
function eH(r, e) {
  r.extend = e.extend;
}
var zae = Math.round(Math.random() * 10);
function Zae(r) {
  var e = ["__\0is_clz", zae++].join("_");
  r.prototype[e] = !0, {}.NODE_ENV !== "production" && Se(!r.isInstance, 'The method "is" can not be defined.'), r.isInstance = function(t) {
    return !!(t && t[e]);
  };
}
function qae(r, e) {
  for (var t = [], i = 2; i < arguments.length; i++)
    t[i - 2] = arguments[i];
  return this.superClass.prototype[e].apply(r, t);
}
function jae(r, e, t) {
  return this.superClass.prototype[e].apply(r, t);
}
function fT(r) {
  var e = {};
  r.registerClass = function(i) {
    var n = i.type || i.prototype.type;
    if (n) {
      Yae(n), i.prototype.type = n;
      var a = so(n);
      if (!a.sub)
        ({}).NODE_ENV !== "production" && e[a.main] && console.warn(a.main + " exists."), e[a.main] = i;
      else if (a.sub !== lu) {
        var o = t(a);
        o[a.sub] = i;
      }
    }
    return i;
  }, r.getClass = function(i, n, a) {
    var o = e[i];
    if (o && o[lu] && (o = n ? o[n] : null), a && !o)
      throw new Error(n ? "Component " + i + "." + (n || "") + " is used but not imported." : i + ".type should be specified.");
    return o;
  }, r.getClassesByMainType = function(i) {
    var n = so(i), a = [], o = e[n.main];
    return o && o[lu] ? N(o, function(s, l) {
      l !== lu && a.push(s);
    }) : a.push(o), a;
  }, r.hasClass = function(i) {
    var n = so(i);
    return !!e[n.main];
  }, r.getAllClassMainTypes = function() {
    var i = [];
    return N(e, function(n, a) {
      i.push(a);
    }), i;
  }, r.hasSubTypes = function(i) {
    var n = so(i), a = e[n.main];
    return a && a[lu];
  };
  function t(i) {
    var n = e[i.main];
    return (!n || !n[lu]) && (n = e[i.main] = {}, n[lu] = !0), n;
  }
}
function Nc(r, e) {
  for (var t = 0; t < r.length; t++)
    r[t][1] || (r[t][1] = r[t][0]);
  return e = e || !1, function(i, n, a) {
    for (var o = {}, s = 0; s < r.length; s++) {
      var l = r[s][1];
      if (!(n && Fe(n, l) >= 0 || a && Fe(a, l) < 0)) {
        var u = i.getShallow(l, e);
        u != null && (o[r[s][0]] = u);
      }
    }
    return o;
  };
}
var Kae = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], Jae = Nc(Kae), eoe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getAreaStyle = function(e, t) {
      return Jae(this, e, t);
    }, r;
  }()
), j_ = new Tv(50);
function toe(r) {
  if (typeof r == "string") {
    var e = j_.get(r);
    return e && e.image;
  } else
    return r;
}
function V1(r, e, t, i, n) {
  if (r)
    if (typeof r == "string") {
      if (e && e.__zrImageSrc === r || !t)
        return e;
      var a = j_.get(r), o = { hostEl: t, cb: i, cbPayload: n };
      return a ? (e = a.image, !dT(e) && a.pending.push(o)) : (e = Il.loadImage(r, zD, zD), e.__zrImageSrc = r, j_.put(r, e.__cachedImgObj = {
        image: e,
        pending: [o]
      })), e;
    } else
      return r;
  else
    return e;
}
function zD() {
  var r = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var e = 0; e < r.pending.length; e++) {
    var t = r.pending[e], i = t.cb;
    i && i(this, t.cbPayload), t.hostEl.dirty();
  }
  r.pending.length = 0;
}
function dT(r) {
  return r && r.width && r.height;
}
var o0 = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function roe(r, e, t, i, n) {
  if (!e)
    return "";
  var a = (r + "").split(`
`);
  n = tH(e, t, i, n);
  for (var o = 0, s = a.length; o < s; o++)
    a[o] = rH(a[o], n);
  return a.join(`
`);
}
function tH(r, e, t, i) {
  i = i || {};
  var n = B({}, i);
  n.font = e, t = ke(t, "..."), n.maxIterations = ke(i.maxIterations, 2);
  var a = n.minChar = ke(i.minChar, 0);
  n.cnCharWidth = Tn("", e);
  var o = n.ascCharWidth = Tn("a", e);
  n.placeholder = ke(i.placeholder, "");
  for (var s = r = Math.max(0, r - 1), l = 0; l < a && s >= o; l++)
    s -= o;
  var u = Tn(t, e);
  return u > s && (t = "", u = 0), s = r - u, n.ellipsis = t, n.ellipsisWidth = u, n.contentWidth = s, n.containerWidth = r, n;
}
function rH(r, e) {
  var t = e.containerWidth, i = e.font, n = e.contentWidth;
  if (!t)
    return "";
  var a = Tn(r, i);
  if (a <= t)
    return r;
  for (var o = 0; ; o++) {
    if (a <= n || o >= e.maxIterations) {
      r += e.ellipsis;
      break;
    }
    var s = o === 0 ? ioe(r, n, e.ascCharWidth, e.cnCharWidth) : a > 0 ? Math.floor(r.length * n / a) : 0;
    r = r.substr(0, s), a = Tn(r, i);
  }
  return r === "" && (r = e.placeholder), r;
}
function ioe(r, e, t, i) {
  for (var n = 0, a = 0, o = r.length; a < o && n < e; a++) {
    var s = r.charCodeAt(a);
    n += 0 <= s && s <= 127 ? t : i;
  }
  return a;
}
function noe(r, e) {
  r != null && (r += "");
  var t = e.overflow, i = e.padding, n = e.font, a = t === "truncate", o = uT(n), s = ke(e.lineHeight, o), l = !!e.backgroundColor, u = e.lineOverflow === "truncate", c = e.width, h;
  c != null && (t === "break" || t === "breakAll") ? h = r ? iH(r, e.font, c, t === "breakAll", 0).lines : [] : h = r ? r.split(`
`) : [];
  var f = h.length * s, d = ke(e.height, f);
  if (f > d && u) {
    var p = Math.floor(d / s);
    h = h.slice(0, p);
  }
  if (r && a && c != null)
    for (var g = tH(c, n, e.ellipsis, {
      minChar: e.truncateMinChar,
      placeholder: e.placeholder
    }), v = 0; v < h.length; v++)
      h[v] = rH(h[v], g);
  for (var O = d, m = 0, v = 0; v < h.length; v++)
    m = Math.max(Tn(h[v], n), m);
  c == null && (c = m);
  var E = m;
  return i && (O += i[0] + i[2], E += i[1] + i[3], c += i[1] + i[3]), l && (E = c), {
    lines: h,
    height: d,
    outerWidth: E,
    outerHeight: O,
    lineHeight: s,
    calculatedLineHeight: o,
    contentWidth: m,
    contentHeight: f,
    width: c
  };
}
var aoe = function() {
  function r() {
  }
  return r;
}(), ZD = function() {
  function r(e) {
    this.tokens = [], e && (this.tokens = e);
  }
  return r;
}(), ooe = function() {
  function r() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [];
  }
  return r;
}();
function soe(r, e) {
  var t = new ooe();
  if (r != null && (r += ""), !r)
    return t;
  for (var i = e.width, n = e.height, a = e.overflow, o = (a === "break" || a === "breakAll") && i != null ? { width: i, accumWidth: 0, breakAll: a === "breakAll" } : null, s = o0.lastIndex = 0, l; (l = o0.exec(r)) != null; ) {
    var u = l.index;
    u > s && s0(t, r.substring(s, u), e, o), s0(t, l[2], e, o, l[1]), s = o0.lastIndex;
  }
  s < r.length && s0(t, r.substring(s, r.length), e, o);
  var c = [], h = 0, f = 0, d = e.padding, p = a === "truncate", g = e.lineOverflow === "truncate";
  function v(Q, V, F) {
    Q.width = V, Q.lineHeight = F, h += F, f = Math.max(f, V);
  }
  e:
    for (var O = 0; O < t.lines.length; O++) {
      for (var m = t.lines[O], E = 0, b = 0, S = 0; S < m.tokens.length; S++) {
        var T = m.tokens[S], y = T.styleName && e.rich[T.styleName] || {}, R = T.textPadding = y.padding, _ = R ? R[1] + R[3] : 0, C = T.font = y.font || e.font;
        T.contentHeight = uT(C);
        var I = ke(y.height, T.contentHeight);
        if (T.innerHeight = I, R && (I += R[0] + R[2]), T.height = I, T.lineHeight = Kn(y.lineHeight, e.lineHeight, I), T.align = y && y.align || e.align, T.verticalAlign = y && y.verticalAlign || "middle", g && n != null && h + T.lineHeight > n) {
          S > 0 ? (m.tokens = m.tokens.slice(0, S), v(m, b, E), t.lines = t.lines.slice(0, O + 1)) : t.lines = t.lines.slice(0, O);
          break e;
        }
        var w = y.width, x = w == null || w === "auto";
        if (typeof w == "string" && w.charAt(w.length - 1) === "%")
          T.percentWidth = w, c.push(T), T.contentWidth = Tn(T.text, C);
        else {
          if (x) {
            var P = y.backgroundColor, L = P && P.image;
            L && (L = toe(L), dT(L) && (T.width = Math.max(T.width, L.width * I / L.height)));
          }
          var D = p && i != null ? i - b : null;
          D != null && D < T.width ? !x || D < _ ? (T.text = "", T.width = T.contentWidth = 0) : (T.text = roe(T.text, D - _, C, e.ellipsis, { minChar: e.truncateMinChar }), T.width = T.contentWidth = Tn(T.text, C)) : T.contentWidth = Tn(T.text, C);
        }
        T.width += _, b += T.width, y && (E = Math.max(E, T.lineHeight));
      }
      v(m, b, E);
    }
  t.outerWidth = t.width = ke(i, f), t.outerHeight = t.height = ke(n, h), t.contentHeight = h, t.contentWidth = f, d && (t.outerWidth += d[1] + d[3], t.outerHeight += d[0] + d[2]);
  for (var O = 0; O < c.length; O++) {
    var T = c[O], U = T.percentWidth;
    T.width = parseInt(U, 10) / 100 * t.width;
  }
  return t;
}
function s0(r, e, t, i, n) {
  var a = e === "", o = n && t.rich[n] || {}, s = r.lines, l = o.font || t.font, u = !1, c, h;
  if (i) {
    var f = o.padding, d = f ? f[1] + f[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var p = xa(o.width, i.width) + d;
      s.length > 0 && p + i.accumWidth > i.width && (c = e.split(`
`), u = !0), i.accumWidth = p;
    } else {
      var g = iH(e, l, i.width, i.breakAll, i.accumWidth);
      i.accumWidth = g.accumWidth + d, h = g.linesWidths, c = g.lines;
    }
  } else
    c = e.split(`
`);
  for (var v = 0; v < c.length; v++) {
    var O = c[v], m = new aoe();
    if (m.styleName = n, m.text = O, m.isLineHolder = !O && !a, typeof o.width == "number" ? m.width = o.width : m.width = h ? h[v] : Tn(O, l), !v && !u) {
      var E = (s[s.length - 1] || (s[0] = new ZD())).tokens, b = E.length;
      b === 1 && E[0].isLineHolder ? E[0] = m : (O || !b || a) && E.push(m);
    } else
      s.push(new ZD([m]));
  }
}
function loe(r) {
  var e = r.charCodeAt(0);
  return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303;
}
var uoe = To(",&?/;] ".split(""), function(r, e) {
  return r[e] = !0, r;
}, {});
function coe(r) {
  return loe(r) ? !!uoe[r] : !0;
}
function iH(r, e, t, i, n) {
  for (var a = [], o = [], s = "", l = "", u = 0, c = 0, h = 0; h < r.length; h++) {
    var f = r.charAt(h);
    if (f === `
`) {
      l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var d = Tn(f, e), p = i ? !1 : !coe(f);
    if (a.length ? c + d > t : n + c + d > t) {
      c ? (s || l) && (p ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += f, u += d, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = f, c = d)) : p ? (a.push(l), o.push(u), l = f, u = d) : (a.push(f), o.push(d));
      continue;
    }
    c += d, p ? (l += f, u += d) : (l && (s += l, l = "", u = 0), s += f);
  }
  return !a.length && !s && (s = r, l = "", u = 0), l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += n), {
    accumWidth: c,
    lines: a,
    linesWidths: o
  };
}
var K_ = "__zr_style_" + Math.round(Math.random() * 10), fc = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, pT = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
fc[K_] = !0;
var qD = ["z", "z2", "invisible"], hoe = ["invisible"], foe = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype._init = function(t) {
    for (var i = Ze(t), n = 0; n < i.length; n++) {
      var a = i[n];
      a === "style" ? this.useStyle(t[a]) : r.prototype.attrKV.call(this, a, t[a]);
    }
    this.style || this.useStyle({});
  }, e.prototype.beforeBrush = function() {
  }, e.prototype.afterBrush = function() {
  }, e.prototype.innerBeforeBrush = function() {
  }, e.prototype.innerAfterBrush = function() {
  }, e.prototype.shouldBePainted = function(t, i, n, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && doe(this, t, i) || o && !o[0] && !o[3])
      return !1;
    if (n && this.__clipPaths) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, e.prototype.contain = function(t, i) {
    return this.rectContain(t, i);
  }, e.prototype.traverse = function(t, i) {
    t.call(i, this);
  }, e.prototype.rectContain = function(t, i) {
    var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
    return a.contain(n[0], n[1]);
  }, e.prototype.getPaintRect = function() {
    var t = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var i = this.transform, n = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      t = this._paintRect || (this._paintRect = new Ve(0, 0, 0, 0)), i ? Ve.applyTransform(t, n, i) : t.copy(n), (o || s || l) && (t.width += o * 2 + Math.abs(s), t.height += o * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + s - o), t.y = Math.min(t.y, t.y + l - o));
      var u = this.dirtyRectTolerance;
      t.isZero() || (t.x = Math.floor(t.x - u), t.y = Math.floor(t.y - u), t.width = Math.ceil(t.width + 1 + u * 2), t.height = Math.ceil(t.height + 1 + u * 2));
    }
    return t;
  }, e.prototype.setPrevPaintRect = function(t) {
    t ? (this._prevPaintRect = this._prevPaintRect || new Ve(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null;
  }, e.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, e.prototype.animateStyle = function(t) {
    return this.animate("style", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : this.markRedraw();
  }, e.prototype.attrKV = function(t, i) {
    t !== "style" ? r.prototype.attrKV.call(this, t, i) : this.style ? this.setStyle(i) : this.useStyle(i);
  }, e.prototype.setStyle = function(t, i) {
    return typeof t == "string" ? this.style[t] = i : B(this.style, t), this.dirtyStyle(), this;
  }, e.prototype.dirtyStyle = function(t) {
    t || this.markRedraw(), this.__dirty |= dp, this._rect && (this._rect = null);
  }, e.prototype.dirty = function() {
    this.dirtyStyle();
  }, e.prototype.styleChanged = function() {
    return !!(this.__dirty & dp);
  }, e.prototype.styleUpdated = function() {
    this.__dirty &= ~dp;
  }, e.prototype.createStyle = function(t) {
    return oT(fc, t);
  }, e.prototype.useStyle = function(t) {
    t[K_] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle();
  }, e.prototype.isStyleObject = function(t) {
    return t[K_];
  }, e.prototype._innerSaveToNormal = function(t) {
    r.prototype._innerSaveToNormal.call(this, t);
    var i = this._normalState;
    t.style && !i.style && (i.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, i, qD);
  }, e.prototype._applyStateObj = function(t, i, n, a, o, s) {
    r.prototype._applyStateObj.call(this, t, i, n, a, o, s);
    var l = !(i && a), u;
    if (i && i.style ? o ? a ? u = i.style : (u = this._mergeStyle(this.createStyle(), n.style), this._mergeStyle(u, i.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : n.style), this._mergeStyle(u, i.style)) : l && (u = n.style), u)
      if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var h = Ze(c), f = 0; f < h.length; f++) {
            var d = h[f];
            d in u && (u[d] = u[d], this.style[d] = c[d]);
          }
        for (var p = Ze(u), f = 0; f < p.length; f++) {
          var d = p[f];
          this.style[d] = this.style[d];
        }
        this._transitionState(t, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? hoe : qD, f = 0; f < g.length; f++) {
      var d = g[f];
      i && i[d] != null ? this[d] = i[d] : l && n[d] != null && (this[d] = n[d]);
    }
  }, e.prototype._mergeStates = function(t) {
    for (var i = r.prototype._mergeStates.call(this, t), n, a = 0; a < t.length; a++) {
      var o = t[a];
      o.style && (n = n || {}, this._mergeStyle(n, o.style));
    }
    return n && (i.style = n), i;
  }, e.prototype._mergeStyle = function(t, i) {
    return B(t, i), t;
  }, e.prototype.getAnimationStyleProps = function() {
    return pT;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "displayable", t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = "pointer", t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = vn | dp;
  }(), e;
}($Y), l0 = new Ve(0, 0, 0, 0), u0 = new Ve(0, 0, 0, 0);
function doe(r, e, t) {
  return l0.copy(r.getBoundingRect()), r.transform && l0.applyTransform(r.transform), u0.width = e, u0.height = t, !l0.intersect(u0);
}
const aa = foe;
var Hi = Math.min, Wi = Math.max, c0 = Math.sin, h0 = Math.cos, uu = Math.PI * 2, RO = Wc(), AO = Wc(), _O = Wc();
function gT(r, e, t) {
  if (r.length !== 0) {
    for (var i = r[0], n = i[0], a = i[0], o = i[1], s = i[1], l = 1; l < r.length; l++)
      i = r[l], n = Hi(n, i[0]), a = Wi(a, i[0]), o = Hi(o, i[1]), s = Wi(s, i[1]);
    e[0] = n, e[1] = o, t[0] = a, t[1] = s;
  }
}
function jD(r, e, t, i, n, a) {
  n[0] = Hi(r, t), n[1] = Hi(e, i), a[0] = Wi(r, t), a[1] = Wi(e, i);
}
var KD = [], JD = [];
function poe(r, e, t, i, n, a, o, s, l, u) {
  var c = TY, h = wr, f = c(r, t, n, o, KD);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var d = 0; d < f; d++) {
    var p = h(r, t, n, o, KD[d]);
    l[0] = Hi(p, l[0]), u[0] = Wi(p, u[0]);
  }
  f = c(e, i, a, s, JD);
  for (var d = 0; d < f; d++) {
    var g = h(e, i, a, s, JD[d]);
    l[1] = Hi(g, l[1]), u[1] = Wi(g, u[1]);
  }
  l[0] = Hi(r, l[0]), u[0] = Wi(r, u[0]), l[0] = Hi(o, l[0]), u[0] = Wi(o, u[0]), l[1] = Hi(e, l[1]), u[1] = Wi(e, u[1]), l[1] = Hi(s, l[1]), u[1] = Wi(s, u[1]);
}
function goe(r, e, t, i, n, a, o, s) {
  var l = RY, u = Vr, c = Wi(Hi(l(r, t, n), 1), 0), h = Wi(Hi(l(e, i, a), 1), 0), f = u(r, t, n, c), d = u(e, i, a, h);
  o[0] = Hi(r, n, f), o[1] = Hi(e, a, d), s[0] = Wi(r, n, f), s[1] = Wi(e, a, d);
}
function voe(r, e, t, i, n, a, o, s, l) {
  var u = Js, c = el, h = Math.abs(n - a);
  if (h % uu < 1e-4 && h > 1e-4) {
    s[0] = r - t, s[1] = e - i, l[0] = r + t, l[1] = e + i;
    return;
  }
  if (RO[0] = h0(n) * t + r, RO[1] = c0(n) * i + e, AO[0] = h0(a) * t + r, AO[1] = c0(a) * i + e, u(s, RO, AO), c(l, RO, AO), n = n % uu, n < 0 && (n = n + uu), a = a % uu, a < 0 && (a = a + uu), n > a && !o ? a += uu : n < a && o && (n += uu), o) {
    var f = a;
    a = n, n = f;
  }
  for (var d = 0; d < a; d += Math.PI / 2)
    d > n && (_O[0] = h0(d) * t + r, _O[1] = c0(d) * i + e, u(s, _O, s), c(l, _O, l));
}
var Nt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, cu = [], hu = [], Qa = [], ws = [], Ua = [], $a = [], f0 = Math.min, d0 = Math.max, fu = Math.cos, du = Math.sin, ko = Math.abs, J_ = Math.PI, Vs = J_ * 2, p0 = typeof Float32Array < "u", Nd = [];
function g0(r) {
  var e = Math.round(r / J_ * 1e8) / 1e8;
  return e % 2 * J_;
}
function nH(r, e) {
  var t = g0(r[0]);
  t < 0 && (t += Vs);
  var i = t - r[0], n = r[1];
  n += i, !e && n - t >= Vs ? n = t + Vs : e && t - n >= Vs ? n = t - Vs : !e && t > n ? n = t + (Vs - g0(t - n)) : e && t < n && (n = t - (Vs - g0(n - t))), r[0] = t, r[1] = n;
}
var _o = function() {
  function r(e) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return r.prototype.increaseVersion = function() {
    this._version++;
  }, r.prototype.getVersion = function() {
    return this._version;
  }, r.prototype.setScale = function(e, t, i) {
    i = i || 0, i > 0 && (this._ux = ko(i / rb / e) || 0, this._uy = ko(i / rb / t) || 0);
  }, r.prototype.setDPR = function(e) {
    this.dpr = e;
  }, r.prototype.setContext = function(e) {
    this._ctx = e;
  }, r.prototype.getContext = function() {
    return this._ctx;
  }, r.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, r.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, r.prototype.moveTo = function(e, t) {
    return this._drawPendingPt(), this.addData(Nt.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this;
  }, r.prototype.lineTo = function(e, t) {
    var i = ko(e - this._xi), n = ko(t - this._yi), a = i > this._ux || n > this._uy;
    if (this.addData(Nt.L, e, t), this._ctx && a && this._ctx.lineTo(e, t), a)
      this._xi = e, this._yi = t, this._pendingPtDist = 0;
    else {
      var o = i * i + n * n;
      o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = o);
    }
    return this;
  }, r.prototype.bezierCurveTo = function(e, t, i, n, a, o) {
    return this._drawPendingPt(), this.addData(Nt.C, e, t, i, n, a, o), this._ctx && this._ctx.bezierCurveTo(e, t, i, n, a, o), this._xi = a, this._yi = o, this;
  }, r.prototype.quadraticCurveTo = function(e, t, i, n) {
    return this._drawPendingPt(), this.addData(Nt.Q, e, t, i, n), this._ctx && this._ctx.quadraticCurveTo(e, t, i, n), this._xi = i, this._yi = n, this;
  }, r.prototype.arc = function(e, t, i, n, a, o) {
    this._drawPendingPt(), Nd[0] = n, Nd[1] = a, nH(Nd, o), n = Nd[0], a = Nd[1];
    var s = a - n;
    return this.addData(Nt.A, e, t, i, i, n, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(e, t, i, n, a, o), this._xi = fu(a) * i + e, this._yi = du(a) * i + t, this;
  }, r.prototype.arcTo = function(e, t, i, n, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, i, n, a), this;
  }, r.prototype.rect = function(e, t, i, n) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, i, n), this.addData(Nt.R, e, t, i, n), this;
  }, r.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Nt.Z);
    var e = this._ctx, t = this._x0, i = this._y0;
    return e && e.closePath(), this._xi = t, this._yi = i, this;
  }, r.prototype.fill = function(e) {
    e && e.fill(), this.toStatic();
  }, r.prototype.stroke = function(e) {
    e && e.stroke(), this.toStatic();
  }, r.prototype.len = function() {
    return this._len;
  }, r.prototype.setData = function(e) {
    var t = e.length;
    !(this.data && this.data.length === t) && p0 && (this.data = new Float32Array(t));
    for (var i = 0; i < t; i++)
      this.data[i] = e[i];
    this._len = t;
  }, r.prototype.appendPath = function(e) {
    e instanceof Array || (e = [e]);
    for (var t = e.length, i = 0, n = this._len, a = 0; a < t; a++)
      i += e[a].len();
    p0 && this.data instanceof Float32Array && (this.data = new Float32Array(n + i));
    for (var a = 0; a < t; a++)
      for (var o = e[a].data, s = 0; s < o.length; s++)
        this.data[n++] = o[s];
    this._len = n;
  }, r.prototype.addData = function(e, t, i, n, a, o, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var h = 0; h < arguments.length; h++)
        c[this._len++] = arguments[h];
    }
  }, r.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, r.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var e = [], t = 0; t < this._len; t++)
        e[t] = this.data[t];
      this.data = e;
    }
  }, r.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var e = this.data;
      e instanceof Array && (e.length = this._len, p0 && this._len > 11 && (this.data = new Float32Array(e)));
    }
  }, r.prototype.getBoundingRect = function() {
    Qa[0] = Qa[1] = Ua[0] = Ua[1] = Number.MAX_VALUE, ws[0] = ws[1] = $a[0] = $a[1] = -Number.MAX_VALUE;
    var e = this.data, t = 0, i = 0, n = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = e[o++], l = o === 1;
      switch (l && (t = e[o], i = e[o + 1], n = t, a = i), s) {
        case Nt.M:
          t = n = e[o++], i = a = e[o++], Ua[0] = n, Ua[1] = a, $a[0] = n, $a[1] = a;
          break;
        case Nt.L:
          jD(t, i, e[o], e[o + 1], Ua, $a), t = e[o++], i = e[o++];
          break;
        case Nt.C:
          poe(t, i, e[o++], e[o++], e[o++], e[o++], e[o], e[o + 1], Ua, $a), t = e[o++], i = e[o++];
          break;
        case Nt.Q:
          goe(t, i, e[o++], e[o++], e[o], e[o + 1], Ua, $a), t = e[o++], i = e[o++];
          break;
        case Nt.A:
          var u = e[o++], c = e[o++], h = e[o++], f = e[o++], d = e[o++], p = e[o++] + d;
          o += 1;
          var g = !e[o++];
          l && (n = fu(d) * h + u, a = du(d) * f + c), voe(u, c, h, f, d, p, g, Ua, $a), t = fu(p) * h + u, i = du(p) * f + c;
          break;
        case Nt.R:
          n = t = e[o++], a = i = e[o++];
          var v = e[o++], O = e[o++];
          jD(n, a, n + v, a + O, Ua, $a);
          break;
        case Nt.Z:
          t = n, i = a;
          break;
      }
      Js(Qa, Qa, Ua), el(ws, ws, $a);
    }
    return o === 0 && (Qa[0] = Qa[1] = ws[0] = ws[1] = 0), new Ve(Qa[0], Qa[1], ws[0] - Qa[0], ws[1] - Qa[1]);
  }, r.prototype._calculateLength = function() {
    var e = this.data, t = this._len, i = this._ux, n = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, h = 0, f = 0; f < t; ) {
      var d = e[f++], p = f === 1;
      p && (a = e[f], o = e[f + 1], s = a, l = o);
      var g = -1;
      switch (d) {
        case Nt.M:
          a = s = e[f++], o = l = e[f++];
          break;
        case Nt.L: {
          var v = e[f++], O = e[f++], m = v - a, E = O - o;
          (ko(m) > i || ko(E) > n || f === t - 1) && (g = Math.sqrt(m * m + E * E), a = v, o = O);
          break;
        }
        case Nt.C: {
          var b = e[f++], S = e[f++], v = e[f++], O = e[f++], T = e[f++], y = e[f++];
          g = Nne(a, o, b, S, v, O, T, y, 10), a = T, o = y;
          break;
        }
        case Nt.Q: {
          var b = e[f++], S = e[f++], v = e[f++], O = e[f++];
          g = Pne(a, o, b, S, v, O, 10), a = v, o = O;
          break;
        }
        case Nt.A:
          var R = e[f++], _ = e[f++], C = e[f++], I = e[f++], w = e[f++], x = e[f++], P = x + w;
          f += 1, e[f++], p && (s = fu(w) * C + R, l = du(w) * I + _), g = d0(C, I) * f0(Vs, Math.abs(x)), a = fu(P) * C + R, o = du(P) * I + _;
          break;
        case Nt.R: {
          s = a = e[f++], l = o = e[f++];
          var L = e[f++], D = e[f++];
          g = L * 2 + D * 2;
          break;
        }
        case Nt.Z: {
          var m = s - a, E = l - o;
          g = Math.sqrt(m * m + E * E), a = s, o = l;
          break;
        }
      }
      g >= 0 && (u[h++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, r.prototype.rebuildPath = function(e, t) {
    var i = this.data, n = this._ux, a = this._uy, o = this._len, s, l, u, c, h, f, d = t < 1, p, g, v = 0, O = 0, m, E = 0, b, S;
    if (!(d && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, g = this._pathLen, m = t * g, !m)))
      e:
        for (var T = 0; T < o; ) {
          var y = i[T++], R = T === 1;
          switch (R && (u = i[T], c = i[T + 1], s = u, l = c), y !== Nt.L && E > 0 && (e.lineTo(b, S), E = 0), y) {
            case Nt.M:
              s = u = i[T++], l = c = i[T++], e.moveTo(u, c);
              break;
            case Nt.L: {
              h = i[T++], f = i[T++];
              var _ = ko(h - u), C = ko(f - c);
              if (_ > n || C > a) {
                if (d) {
                  var I = p[O++];
                  if (v + I > m) {
                    var w = (m - v) / I;
                    e.lineTo(u * (1 - w) + h * w, c * (1 - w) + f * w);
                    break e;
                  }
                  v += I;
                }
                e.lineTo(h, f), u = h, c = f, E = 0;
              } else {
                var x = _ * _ + C * C;
                x > E && (b = h, S = f, E = x);
              }
              break;
            }
            case Nt.C: {
              var P = i[T++], L = i[T++], D = i[T++], U = i[T++], Q = i[T++], V = i[T++];
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var w = (m - v) / I;
                  wl(u, P, D, Q, w, cu), wl(c, L, U, V, w, hu), e.bezierCurveTo(cu[1], hu[1], cu[2], hu[2], cu[3], hu[3]);
                  break e;
                }
                v += I;
              }
              e.bezierCurveTo(P, L, D, U, Q, V), u = Q, c = V;
              break;
            }
            case Nt.Q: {
              var P = i[T++], L = i[T++], D = i[T++], U = i[T++];
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var w = (m - v) / I;
                  Cg(u, P, D, w, cu), Cg(c, L, U, w, hu), e.quadraticCurveTo(cu[1], hu[1], cu[2], hu[2]);
                  break e;
                }
                v += I;
              }
              e.quadraticCurveTo(P, L, D, U), u = D, c = U;
              break;
            }
            case Nt.A:
              var F = i[T++], j = i[T++], ae = i[T++], ce = i[T++], ge = i[T++], Be = i[T++], We = i[T++], Ne = !i[T++], Ee = ae > ce ? ae : ce, Ge = ko(ae - ce) > 1e-3, Ie = ge + Be, he = !1;
              if (d) {
                var I = p[O++];
                v + I > m && (Ie = ge + Be * (m - v) / I, he = !0), v += I;
              }
              if (Ge && e.ellipse ? e.ellipse(F, j, ae, ce, We, ge, Ie, Ne) : e.arc(F, j, Ee, ge, Ie, Ne), he)
                break e;
              R && (s = fu(ge) * ae + F, l = du(ge) * ce + j), u = fu(Ie) * ae + F, c = du(Ie) * ce + j;
              break;
            case Nt.R:
              s = u = i[T], l = c = i[T + 1], h = i[T++], f = i[T++];
              var xe = i[T++], M = i[T++];
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var k = m - v;
                  e.moveTo(h, f), e.lineTo(h + f0(k, xe), f), k -= xe, k > 0 && e.lineTo(h + xe, f + f0(k, M)), k -= M, k > 0 && e.lineTo(h + d0(xe - k, 0), f + M), k -= xe, k > 0 && e.lineTo(h, f + d0(M - k, 0));
                  break e;
                }
                v += I;
              }
              e.rect(h, f, xe, M);
              break;
            case Nt.Z:
              if (d) {
                var I = p[O++];
                if (v + I > m) {
                  var w = (m - v) / I;
                  e.lineTo(u * (1 - w) + s * w, c * (1 - w) + l * w);
                  break e;
                }
                v += I;
              }
              e.closePath(), u = s, c = l;
          }
        }
  }, r.prototype.clone = function() {
    var e = new r(), t = this.data;
    return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e;
  }, r.CMD = Nt, r.initDefaultProps = function() {
    var e = r.prototype;
    e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0;
  }(), r;
}();
function Xs(r, e, t, i, n, a, o) {
  if (n === 0)
    return !1;
  var s = n, l = 0, u = r;
  if (o > e + s && o > i + s || o < e - s && o < i - s || a > r + s && a > t + s || a < r - s && a < t - s)
    return !1;
  if (r !== t)
    l = (e - i) / (r - t), u = (r * i - t * e) / (r - t);
  else
    return Math.abs(a - r) <= s / 2;
  var c = l * a - o + u, h = c * c / (l * l + 1);
  return h <= s / 2 * s / 2;
}
function Ooe(r, e, t, i, n, a, o, s, l, u, c) {
  if (l === 0)
    return !1;
  var h = l;
  if (c > e + h && c > i + h && c > a + h && c > s + h || c < e - h && c < i - h && c < a - h && c < s - h || u > r + h && u > t + h && u > n + h && u > o + h || u < r - h && u < t - h && u < n - h && u < o - h)
    return !1;
  var f = yY(r, e, t, i, n, a, o, s, u, c, null);
  return f <= h / 2;
}
function aH(r, e, t, i, n, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > e + u && l > i + u && l > a + u || l < e - u && l < i - u && l < a - u || s > r + u && s > t + u && s > n + u || s < r - u && s < t - u && s < n - u)
    return !1;
  var c = AY(r, e, t, i, n, a, s, l, null);
  return c <= u / 2;
}
var eM = Math.PI * 2;
function ba(r) {
  return r %= eM, r < 0 && (r += eM), r;
}
var xd = Math.PI * 2;
function moe(r, e, t, i, n, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= r, l -= e;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > t || c + u < t)
    return !1;
  if (Math.abs(i - n) % xd < 1e-4)
    return !0;
  if (a) {
    var h = i;
    i = ba(n), n = ba(h);
  } else
    i = ba(i), n = ba(n);
  i > n && (n += xd);
  var f = Math.atan2(l, s);
  return f < 0 && (f += xd), f >= i && f <= n || f + xd >= i && f + xd <= n;
}
function Fo(r, e, t, i, n, a) {
  if (a > e && a > i || a < e && a < i || i === e)
    return 0;
  var o = (a - e) / (i - e), s = i < e ? 1 : -1;
  (o === 1 || o === 0) && (s = i < e ? 0.5 : -0.5);
  var l = o * (t - r) + r;
  return l === n ? 1 / 0 : l > n ? s : 0;
}
var Ns = _o.CMD, pu = Math.PI * 2, Eoe = 1e-4;
function boe(r, e) {
  return Math.abs(r - e) < Eoe;
}
var Ci = [-1, -1, -1], Un = [-1, -1];
function Soe() {
  var r = Un[0];
  Un[0] = Un[1], Un[1] = r;
}
function Toe(r, e, t, i, n, a, o, s, l, u) {
  if (u > e && u > i && u > a && u > s || u < e && u < i && u < a && u < s)
    return 0;
  var c = KE(e, i, a, s, u, Ci);
  if (c === 0)
    return 0;
  for (var h = 0, f = -1, d = void 0, p = void 0, g = 0; g < c; g++) {
    var v = Ci[g], O = v === 0 || v === 1 ? 0.5 : 1, m = wr(r, t, n, o, v);
    m < l || (f < 0 && (f = TY(e, i, a, s, Un), Un[1] < Un[0] && f > 1 && Soe(), d = wr(e, i, a, s, Un[0]), f > 1 && (p = wr(e, i, a, s, Un[1]))), f === 2 ? v < Un[0] ? h += d < e ? O : -O : v < Un[1] ? h += p < d ? O : -O : h += s < p ? O : -O : v < Un[0] ? h += d < e ? O : -O : h += s < d ? O : -O);
  }
  return h;
}
function yoe(r, e, t, i, n, a, o, s) {
  if (s > e && s > i && s > a || s < e && s < i && s < a)
    return 0;
  var l = xne(e, i, a, s, Ci);
  if (l === 0)
    return 0;
  var u = RY(e, i, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = Vr(e, i, a, u), f = 0; f < l; f++) {
      var d = Ci[f] === 0 || Ci[f] === 1 ? 0.5 : 1, p = Vr(r, t, n, Ci[f]);
      p < o || (Ci[f] < u ? c += h < e ? d : -d : c += a < h ? d : -d);
    }
    return c;
  } else {
    var d = Ci[0] === 0 || Ci[0] === 1 ? 0.5 : 1, p = Vr(r, t, n, Ci[0]);
    return p < o ? 0 : a < e ? d : -d;
  }
}
function Roe(r, e, t, i, n, a, o, s) {
  if (s -= e, s > t || s < -t)
    return 0;
  var l = Math.sqrt(t * t - s * s);
  Ci[0] = -l, Ci[1] = l;
  var u = Math.abs(i - n);
  if (u < 1e-4)
    return 0;
  if (u >= pu - 1e-4) {
    i = 0, n = pu;
    var c = a ? 1 : -1;
    return o >= Ci[0] + r && o <= Ci[1] + r ? c : 0;
  }
  if (i > n) {
    var h = i;
    i = n, n = h;
  }
  i < 0 && (i += pu, n += pu);
  for (var f = 0, d = 0; d < 2; d++) {
    var p = Ci[d];
    if (p + r > o) {
      var g = Math.atan2(s, p), c = a ? 1 : -1;
      g < 0 && (g = pu + g), (g >= i && g <= n || g + pu >= i && g + pu <= n) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), f += c);
    }
  }
  return f;
}
function oH(r, e, t, i, n) {
  for (var a = r.data, o = r.len(), s = 0, l = 0, u = 0, c = 0, h = 0, f, d, p = 0; p < o; ) {
    var g = a[p++], v = p === 1;
    switch (g === Ns.M && p > 1 && (t || (s += Fo(l, u, c, h, i, n))), v && (l = a[p], u = a[p + 1], c = l, h = u), g) {
      case Ns.M:
        c = a[p++], h = a[p++], l = c, u = h;
        break;
      case Ns.L:
        if (t) {
          if (Xs(l, u, a[p], a[p + 1], e, i, n))
            return !0;
        } else
          s += Fo(l, u, a[p], a[p + 1], i, n) || 0;
        l = a[p++], u = a[p++];
        break;
      case Ns.C:
        if (t) {
          if (Ooe(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], e, i, n))
            return !0;
        } else
          s += Toe(l, u, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], i, n) || 0;
        l = a[p++], u = a[p++];
        break;
      case Ns.Q:
        if (t) {
          if (aH(l, u, a[p++], a[p++], a[p], a[p + 1], e, i, n))
            return !0;
        } else
          s += yoe(l, u, a[p++], a[p++], a[p], a[p + 1], i, n) || 0;
        l = a[p++], u = a[p++];
        break;
      case Ns.A:
        var O = a[p++], m = a[p++], E = a[p++], b = a[p++], S = a[p++], T = a[p++];
        p += 1;
        var y = !!(1 - a[p++]);
        f = Math.cos(S) * E + O, d = Math.sin(S) * b + m, v ? (c = f, h = d) : s += Fo(l, u, f, d, i, n);
        var R = (i - O) * b / E + O;
        if (t) {
          if (moe(O, m, b, S, S + T, y, e, R, n))
            return !0;
        } else
          s += Roe(O, m, b, S, S + T, y, R, n);
        l = Math.cos(S + T) * E + O, u = Math.sin(S + T) * b + m;
        break;
      case Ns.R:
        c = l = a[p++], h = u = a[p++];
        var _ = a[p++], C = a[p++];
        if (f = c + _, d = h + C, t) {
          if (Xs(c, h, f, h, e, i, n) || Xs(f, h, f, d, e, i, n) || Xs(f, d, c, d, e, i, n) || Xs(c, d, c, h, e, i, n))
            return !0;
        } else
          s += Fo(f, h, f, d, i, n), s += Fo(c, d, c, h, i, n);
        break;
      case Ns.Z:
        if (t) {
          if (Xs(l, u, c, h, e, i, n))
            return !0;
        } else
          s += Fo(l, u, c, h, i, n);
        l = c, u = h;
        break;
    }
  }
  return !t && !boe(u, h) && (s += Fo(l, u, c, h, i, n) || 0), s !== 0;
}
function Aoe(r, e, t) {
  return oH(r, 0, !1, e, t);
}
function _oe(r, e, t, i) {
  return oH(r, e, !0, t, i);
}
var ab = Te({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, fc), Coe = {
  style: Te({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, pT.style)
}, v0 = Ro.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Ioe = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.update = function() {
    var t = this;
    r.prototype.update.call(this);
    var i = this.style;
    if (i.decal) {
      var n = this._decalEl = this._decalEl || new e();
      n.buildPath === e.prototype.buildPath && (n.buildPath = function(l) {
        t.buildPath(l, t.shape);
      }), n.silent = !0;
      var a = n.style;
      for (var o in i)
        a[o] !== i[o] && (a[o] = i[o]);
      a.fill = i.fill ? i.decal : null, a.decal = null, a.shadowColor = null, i.strokeFirst && (a.stroke = null);
      for (var s = 0; s < v0.length; ++s)
        n[v0[s]] = this[v0[s]];
      n.__dirty |= vn;
    } else
      this._decalEl && (this._decalEl = null);
  }, e.prototype.getDecalElement = function() {
    return this._decalEl;
  }, e.prototype._init = function(t) {
    var i = Ze(t);
    this.shape = this.getDefaultShape();
    var n = this.getDefaultStyle();
    n && this.useStyle(n);
    for (var a = 0; a < i.length; a++) {
      var o = i[a], s = t[o];
      o === "style" ? this.style ? B(this.style, s) : this.useStyle(s) : o === "shape" ? B(this.shape, s) : r.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, e.prototype.getDefaultStyle = function() {
    return null;
  }, e.prototype.getDefaultShape = function() {
    return {};
  }, e.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, e.prototype.getInsideTextFill = function() {
    var t = this.style.fill;
    if (t !== "none") {
      if (ne(t)) {
        var i = eb(t, 0);
        return i > 0.5 ? W_ : i > 0.2 ? uae : z_;
      } else if (t)
        return z_;
    }
    return W_;
  }, e.prototype.getInsideTextStroke = function(t) {
    var i = this.style.fill;
    if (ne(i)) {
      var n = this.__zr, a = !!(n && n.isDarkMode()), o = eb(t, 0) < H_;
      if (a === o)
        return i;
    }
  }, e.prototype.buildPath = function(t, i, n) {
  }, e.prototype.pathUpdated = function() {
    this.__dirty &= ~kh;
  }, e.prototype.getUpdatedPathProxy = function(t) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path;
  }, e.prototype.createPathProxy = function() {
    this.path = new _o(!1);
  }, e.prototype.hasStroke = function() {
    var t = this.style, i = t.stroke;
    return !(i == null || i === "none" || !(t.lineWidth > 0));
  }, e.prototype.hasFill = function() {
    var t = this.style, i = t.fill;
    return i != null && i !== "none";
  }, e.prototype.getBoundingRect = function() {
    var t = this._rect, i = this.style, n = !t;
    if (n) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & kh) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), t = o.getBoundingRect();
    }
    if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = t.clone());
      if (this.__dirty || n) {
        s.copy(t);
        var l = i.strokeNoScale ? this.getLineScale() : 1, u = i.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return t;
  }, e.prototype.contain = function(t, i) {
    var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect(), o = this.style;
    if (t = n[0], i = n[1], a.contain(t, i)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), _oe(s, l / u, t, i)))
          return !0;
      }
      if (this.hasFill())
        return Aoe(s, t, i);
    }
    return !1;
  }, e.prototype.dirtyShape = function() {
    this.__dirty |= kh, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, e.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, e.prototype.animateShape = function(t) {
    return this.animate("shape", t);
  }, e.prototype.updateDuringAnimation = function(t) {
    t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw();
  }, e.prototype.attrKV = function(t, i) {
    t === "shape" ? this.setShape(i) : r.prototype.attrKV.call(this, t, i);
  }, e.prototype.setShape = function(t, i) {
    var n = this.shape;
    return n || (n = this.shape = {}), typeof t == "string" ? n[t] = i : B(n, t), this.dirtyShape(), this;
  }, e.prototype.shapeChanged = function() {
    return !!(this.__dirty & kh);
  }, e.prototype.createStyle = function(t) {
    return oT(ab, t);
  }, e.prototype._innerSaveToNormal = function(t) {
    r.prototype._innerSaveToNormal.call(this, t);
    var i = this._normalState;
    t.shape && !i.shape && (i.shape = B({}, this.shape));
  }, e.prototype._applyStateObj = function(t, i, n, a, o, s) {
    r.prototype._applyStateObj.call(this, t, i, n, a, o, s);
    var l = !(i && a), u;
    if (i && i.shape ? o ? a ? u = i.shape : (u = B({}, n.shape), B(u, i.shape)) : (u = B({}, a ? this.shape : n.shape), B(u, i.shape)) : l && (u = n.shape), u)
      if (o) {
        this.shape = B({}, this.shape);
        for (var c = {}, h = Ze(u), f = 0; f < h.length; f++) {
          var d = h[f];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(t, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, e.prototype._mergeStates = function(t) {
    for (var i = r.prototype._mergeStates.call(this, t), n, a = 0; a < t.length; a++) {
      var o = t[a];
      o.shape && (n = n || {}, this._mergeStyle(n, o.shape));
    }
    return n && (i.shape = n), i;
  }, e.prototype.getAnimationStyleProps = function() {
    return Coe;
  }, e.prototype.isZeroArea = function() {
    return !1;
  }, e.extend = function(t) {
    var i = function(a) {
      $(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return t.init && t.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return ye(t.style);
      }, o.prototype.getDefaultShape = function() {
        return ye(t.shape);
      }, o;
    }(e);
    for (var n in t)
      typeof t[n] == "function" && (i.prototype[n] = t[n]);
    return i;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = vn | dp | kh;
  }(), e;
}(aa);
const He = Ioe;
var woe = Te({
  strokeFirst: !0,
  font: Cl,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, ab), sH = function(r) {
  $(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.hasStroke = function() {
    var t = this.style, i = t.stroke;
    return i != null && i !== "none" && t.lineWidth > 0;
  }, e.prototype.hasFill = function() {
    var t = this.style, i = t.fill;
    return i != null && i !== "none";
  }, e.prototype.createStyle = function(t) {
    return oT(woe, t);
  }, e.prototype.setBoundingRect = function(t) {
    this._rect = t;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    if (!this._rect) {
      var i = t.text;
      i != null ? i += "" : i = "";
      var n = yv(i, t.font, t.textAlign, t.textBaseline);
      if (n.x += t.x || 0, n.y += t.y || 0, this.hasStroke()) {
        var a = t.lineWidth;
        n.x -= a / 2, n.y -= a / 2, n.width += a, n.height += a;
      }
      this._rect = n;
    }
    return this._rect;
  }, e.initDefaultProps = function() {
    var t = e.prototype;
    t.dirtyRectTolerance = 10;
  }(), e;
}(aa);
sH.prototype.type = "tspan";
const Ng = sH;
var Noe = Te({
  x: 0,
  y: 0
}, fc), xoe = {
  style: Te({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, pT.style)
};
function Poe(r) {
  return !!(r && typeof r != "string" && r.width && r.height);
}
var lH = function(r) {
  $(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.createStyle = function(t) {
    return oT(Noe, t);
  }, e.prototype._getSize = function(t) {
    var i = this.style, n = i[t];
    if (n != null)
      return n;
    var a = Poe(i.image) ? i.image : this.__image;
    if (!a)
      return 0;
    var o = t === "width" ? "height" : "width", s = i[o];
    return s == null ? a[t] : a[t] / a[o] * s;
  }, e.prototype.getWidth = function() {
    return this._getSize("width");
  }, e.prototype.getHeight = function() {
    return this._getSize("height");
  }, e.prototype.getAnimationStyleProps = function() {
    return xoe;
  }, e.prototype.getBoundingRect = function() {
    var t = this.style;
    return this._rect || (this._rect = new Ve(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, e;
}(aa);
lH.prototype.type = "image";
const ni = lH;
function Loe(r, e) {
  var t = e.x, i = e.y, n = e.width, a = e.height, o = e.r, s, l, u, c;
  n < 0 && (t = t + n, n = -n), a < 0 && (i = i + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
  var h;
  s + l > n && (h = s + l, s *= n / h, l *= n / h), u + c > n && (h = u + c, u *= n / h, c *= n / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), s + c > a && (h = s + c, s *= a / h, c *= a / h), r.moveTo(t + s, i), r.lineTo(t + n - l, i), l !== 0 && r.arc(t + n - l, i + l, l, -Math.PI / 2, 0), r.lineTo(t + n, i + a - u), u !== 0 && r.arc(t + n - u, i + a - u, u, 0, Math.PI / 2), r.lineTo(t + c, i + a), c !== 0 && r.arc(t + c, i + a - c, c, Math.PI / 2, Math.PI), r.lineTo(t, i + s), s !== 0 && r.arc(t + s, i + s, s, Math.PI, Math.PI * 1.5);
}
var Wh = Math.round;
function uH(r, e, t) {
  if (e) {
    var i = e.x1, n = e.x2, a = e.y1, o = e.y2;
    r.x1 = i, r.x2 = n, r.y1 = a, r.y2 = o;
    var s = t && t.lineWidth;
    return s && (Wh(i * 2) === Wh(n * 2) && (r.x1 = r.x2 = zu(i, s, !0)), Wh(a * 2) === Wh(o * 2) && (r.y1 = r.y2 = zu(a, s, !0))), r;
  }
}
function cH(r, e, t) {
  if (e) {
    var i = e.x, n = e.y, a = e.width, o = e.height;
    r.x = i, r.y = n, r.width = a, r.height = o;
    var s = t && t.lineWidth;
    return s && (r.x = zu(i, s, !0), r.y = zu(n, s, !0), r.width = Math.max(zu(i + a, s, !1) - r.x, a === 0 ? 0 : 1), r.height = Math.max(zu(n + o, s, !1) - r.y, o === 0 ? 0 : 1)), r;
  }
}
function zu(r, e, t) {
  if (!e)
    return r;
  var i = Wh(r * 2);
  return (i + Wh(e)) % 2 === 0 ? i / 2 : (i + (t ? 1 : -1)) / 2;
}
var Doe = function() {
  function r() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return r;
}(), Moe = {}, hH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new Doe();
  }, e.prototype.buildPath = function(t, i) {
    var n, a, o, s;
    if (this.subPixelOptimize) {
      var l = cH(Moe, i, this.style);
      n = l.x, a = l.y, o = l.width, s = l.height, l.r = i.r, i = l;
    } else
      n = i.x, a = i.y, o = i.width, s = i.height;
    i.r ? Loe(t, i) : t.rect(n, a, o, s);
  }, e.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, e;
}(He);
hH.prototype.type = "rect";
const ht = hH;
var tM = {
  fill: "#000"
}, rM = 2, koe = {
  style: Te({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, pT.style)
}, fH = function(r) {
  $(e, r);
  function e(t) {
    var i = r.call(this) || this;
    return i.type = "text", i._children = [], i._defaultStyle = tM, i.attr(t), i;
  }
  return e.prototype.childrenRef = function() {
    return this._children;
  }, e.prototype.update = function() {
    r.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var t = 0; t < this._children.length; t++) {
      var i = this._children[t];
      i.zlevel = this.zlevel, i.z = this.z, i.z2 = this.z2, i.culling = this.culling, i.cursor = this.cursor, i.invisible = this.invisible;
    }
  }, e.prototype.updateTransform = function() {
    var t = this.innerTransformable;
    t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : r.prototype.updateTransform.call(this);
  }, e.prototype.getLocalTransform = function(t) {
    var i = this.innerTransformable;
    return i ? i.getLocalTransform(t) : r.prototype.getLocalTransform.call(this, t);
  }, e.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), r.prototype.getComputedTransform.call(this);
  }, e.prototype._updateSubTexts = function() {
    this._childCursor = 0, $oe(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, e.prototype.addSelfToZr = function(t) {
    r.prototype.addSelfToZr.call(this, t);
    for (var i = 0; i < this._children.length; i++)
      this._children[i].__zr = t;
  }, e.prototype.removeSelfFromZr = function(t) {
    r.prototype.removeSelfFromZr.call(this, t);
    for (var i = 0; i < this._children.length; i++)
      this._children[i].__zr = null;
  }, e.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var t = new Ve(0, 0, 0, 0), i = this._children, n = [], a = null, o = 0; o < i.length; o++) {
        var s = i[o], l = s.getBoundingRect(), u = s.getLocalTransform(n);
        u ? (t.copy(l), t.applyTransform(u), a = a || t.clone(), a.union(t)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || t;
    }
    return this._rect;
  }, e.prototype.setDefaultTextStyle = function(t) {
    this._defaultStyle = t || tM;
  }, e.prototype.setTextContent = function(t) {
    if ({}.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, e.prototype._mergeStyle = function(t, i) {
    if (!i)
      return t;
    var n = i.rich, a = t.rich || n && {};
    return B(t, i), n && a ? (this._mergeRich(a, n), t.rich = a) : a && (t.rich = a), t;
  }, e.prototype._mergeRich = function(t, i) {
    for (var n = Ze(i), a = 0; a < n.length; a++) {
      var o = n[a];
      t[o] = t[o] || {}, B(t[o], i[o]);
    }
  }, e.prototype.getAnimationStyleProps = function() {
    return koe;
  }, e.prototype._getOrCreateChild = function(t) {
    var i = this._children[this._childCursor];
    return (!i || !(i instanceof t)) && (i = new t()), this._children[this._childCursor++] = i, i.__zr = this.__zr, i.parent = this, i;
  }, e.prototype._updatePlainTexts = function() {
    var t = this.style, i = t.font || Cl, n = t.padding, a = uM(t), o = noe(a, t), s = O0(t), l = !!t.backgroundColor, u = o.outerHeight, c = o.outerWidth, h = o.contentWidth, f = o.lines, d = o.lineHeight, p = this._defaultStyle, g = t.x || 0, v = t.y || 0, O = t.align || p.align || "left", m = t.verticalAlign || p.verticalAlign || "top", E = g, b = Qh(v, o.contentHeight, m);
    if (s || n) {
      var S = gp(g, c, O), T = Qh(v, u, m);
      s && this._renderBackground(t, t, S, T, c, u);
    }
    b += d / 2, n && (E = lM(g, O, n), m === "top" ? b += n[0] : m === "bottom" && (b -= n[2]));
    for (var y = 0, R = !1, _ = sM("fill" in t ? t.fill : (R = !0, p.fill)), C = oM("stroke" in t ? t.stroke : !l && (!p.autoStroke || R) ? (y = rM, p.stroke) : null), I = t.textShadowBlur > 0, w = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), x = o.calculatedLineHeight, P = 0; P < f.length; P++) {
      var L = this._getOrCreateChild(Ng), D = L.createStyle();
      L.useStyle(D), D.text = f[P], D.x = E, D.y = b, O && (D.textAlign = O), D.textBaseline = "middle", D.opacity = t.opacity, D.strokeFirst = !0, I && (D.shadowBlur = t.textShadowBlur || 0, D.shadowColor = t.textShadowColor || "transparent", D.shadowOffsetX = t.textShadowOffsetX || 0, D.shadowOffsetY = t.textShadowOffsetY || 0), D.stroke = C, D.fill = _, C && (D.lineWidth = t.lineWidth || y, D.lineDash = t.lineDash, D.lineDashOffset = t.lineDashOffset || 0), D.font = i, nM(D, t), b += d, w && L.setBoundingRect(new Ve(gp(D.x, t.width, D.textAlign), Qh(D.y, x, D.textBaseline), h, x));
    }
  }, e.prototype._updateRichTexts = function() {
    var t = this.style, i = uM(t), n = soe(i, t), a = n.width, o = n.outerWidth, s = n.outerHeight, l = t.padding, u = t.x || 0, c = t.y || 0, h = this._defaultStyle, f = t.align || h.align, d = t.verticalAlign || h.verticalAlign, p = gp(u, o, f), g = Qh(c, s, d), v = p, O = g;
    l && (v += l[3], O += l[0]);
    var m = v + a;
    O0(t) && this._renderBackground(t, t, p, g, o, s);
    for (var E = !!t.backgroundColor, b = 0; b < n.lines.length; b++) {
      for (var S = n.lines[b], T = S.tokens, y = T.length, R = S.lineHeight, _ = S.width, C = 0, I = v, w = m, x = y - 1, P = void 0; C < y && (P = T[C], !P.align || P.align === "left"); )
        this._placeToken(P, t, R, O, I, "left", E), _ -= P.width, I += P.width, C++;
      for (; x >= 0 && (P = T[x], P.align === "right"); )
        this._placeToken(P, t, R, O, w, "right", E), _ -= P.width, w -= P.width, x--;
      for (I += (a - (I - v) - (m - w) - _) / 2; C <= x; )
        P = T[C], this._placeToken(P, t, R, O, I + P.width / 2, "center", E), I += P.width, C++;
      O += R;
    }
  }, e.prototype._placeToken = function(t, i, n, a, o, s, l) {
    var u = i.rich[t.styleName] || {};
    u.text = t.text;
    var c = t.verticalAlign, h = a + n / 2;
    c === "top" ? h = a + t.height / 2 : c === "bottom" && (h = a + n - t.height / 2);
    var f = !t.isLineHolder && O0(u);
    f && this._renderBackground(u, i, s === "right" ? o - t.width : s === "center" ? o - t.width / 2 : o, h - t.height / 2, t.width, t.height);
    var d = !!u.backgroundColor, p = t.textPadding;
    p && (o = lM(o, s, p), h -= t.height / 2 - p[0] - t.innerHeight / 2);
    var g = this._getOrCreateChild(Ng), v = g.createStyle();
    g.useStyle(v);
    var O = this._defaultStyle, m = !1, E = 0, b = sM("fill" in u ? u.fill : "fill" in i ? i.fill : (m = !0, O.fill)), S = oM("stroke" in u ? u.stroke : "stroke" in i ? i.stroke : !d && !l && (!O.autoStroke || m) ? (E = rM, O.stroke) : null), T = u.textShadowBlur > 0 || i.textShadowBlur > 0;
    v.text = t.text, v.x = o, v.y = h, T && (v.shadowBlur = u.textShadowBlur || i.textShadowBlur || 0, v.shadowColor = u.textShadowColor || i.textShadowColor || "transparent", v.shadowOffsetX = u.textShadowOffsetX || i.textShadowOffsetX || 0, v.shadowOffsetY = u.textShadowOffsetY || i.textShadowOffsetY || 0), v.textAlign = s, v.textBaseline = "middle", v.font = t.font || Cl, v.opacity = Kn(u.opacity, i.opacity, 1), nM(v, u), S && (v.lineWidth = Kn(u.lineWidth, i.lineWidth, E), v.lineDash = ke(u.lineDash, i.lineDash), v.lineDashOffset = i.lineDashOffset || 0, v.stroke = S), b && (v.fill = b);
    var y = t.contentWidth, R = t.contentHeight;
    g.setBoundingRect(new Ve(gp(v.x, y, v.textAlign), Qh(v.y, R, v.textBaseline), y, R));
  }, e.prototype._renderBackground = function(t, i, n, a, o, s) {
    var l = t.backgroundColor, u = t.borderWidth, c = t.borderColor, h = l && l.image, f = l && !h, d = t.borderRadius, p = this, g, v;
    if (f || t.lineHeight || u && c) {
      g = this._getOrCreateChild(ht), g.useStyle(g.createStyle()), g.style.fill = null;
      var O = g.shape;
      O.x = n, O.y = a, O.width = o, O.height = s, O.r = d, g.dirtyShape();
    }
    if (f) {
      var m = g.style;
      m.fill = l || null, m.fillOpacity = ke(t.fillOpacity, 1);
    } else if (h) {
      v = this._getOrCreateChild(ni), v.onload = function() {
        p.dirtyStyle();
      };
      var E = v.style;
      E.image = l.image, E.x = n, E.y = a, E.width = o, E.height = s;
    }
    if (u && c) {
      var m = g.style;
      m.lineWidth = u, m.stroke = c, m.strokeOpacity = ke(t.strokeOpacity, 1), m.lineDash = t.borderDash, m.lineDashOffset = t.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (m.strokeFirst = !0, m.lineWidth *= 2);
    }
    var b = (g || v).style;
    b.shadowBlur = t.shadowBlur || 0, b.shadowColor = t.shadowColor || "transparent", b.shadowOffsetX = t.shadowOffsetX || 0, b.shadowOffsetY = t.shadowOffsetY || 0, b.opacity = Kn(t.opacity, i.opacity, 1);
  }, e.makeFont = function(t) {
    var i = "";
    return pH(t) && (i = [
      t.fontStyle,
      t.fontWeight,
      dH(t.fontSize),
      t.fontFamily || "sans-serif"
    ].join(" ")), i && Ea(i) || t.textFont || t.font;
  }, e;
}(aa), Qoe = { left: !0, right: 1, center: 1 }, Uoe = { top: 1, bottom: 1, middle: 1 }, iM = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function dH(r) {
  return typeof r == "string" && (r.indexOf("px") !== -1 || r.indexOf("rem") !== -1 || r.indexOf("em") !== -1) ? r : isNaN(+r) ? y1 + "px" : r + "px";
}
function nM(r, e) {
  for (var t = 0; t < iM.length; t++) {
    var i = iM[t], n = e[i];
    n != null && (r[i] = n);
  }
}
function pH(r) {
  return r.fontSize != null || r.fontFamily || r.fontWeight;
}
function $oe(r) {
  return aM(r), N(r.rich, aM), r;
}
function aM(r) {
  if (r) {
    r.font = fH.makeFont(r);
    var e = r.align;
    e === "middle" && (e = "center"), r.align = e == null || Qoe[e] ? e : "left";
    var t = r.verticalAlign;
    t === "center" && (t = "middle"), r.verticalAlign = t == null || Uoe[t] ? t : "top";
    var i = r.padding;
    i && (r.padding = I1(r.padding));
  }
}
function oM(r, e) {
  return r == null || e <= 0 || r === "transparent" || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function sM(r) {
  return r == null || r === "none" ? null : r.image || r.colorStops ? "#000" : r;
}
function lM(r, e, t) {
  return e === "right" ? r - t[1] : e === "center" ? r + t[3] / 2 - t[1] / 2 : r + t[3];
}
function uM(r) {
  var e = r.text;
  return e != null && (e += ""), e;
}
function O0(r) {
  return !!(r.backgroundColor || r.lineHeight || r.borderWidth && r.borderColor);
}
const dt = fH;
var Pe = ft(), eC = function(r, e, t, i) {
  if (i) {
    var n = Pe(i);
    n.dataIndex = t, n.dataType = e, n.seriesIndex = r, i.type === "group" && i.traverse(function(a) {
      var o = Pe(a);
      o.seriesIndex = r, o.dataIndex = t, o.dataType = e;
    });
  }
}, cM = 1, hM = {}, gH = ft(), G1 = ft(), B1 = 0, Av = 1, vT = 2, $i = ["emphasis", "blur", "select"], xg = ["normal", "emphasis", "blur", "select"], Kf = 10, Voe = 9, dc = "highlight", jm = "downplay", zp = "select", Km = "unselect", Zp = "toggleSelect";
function dh(r) {
  return r != null && r !== "none";
}
var fM = new Tv(100);
function dM(r) {
  if (ne(r)) {
    var e = fM.get(r);
    return e || (e = $_(r, -0.1), fM.put(r, e)), e;
  } else if (aT(r)) {
    var t = B({}, r);
    return t.colorStops = Y(r.colorStops, function(i) {
      return {
        offset: i.offset,
        color: $_(i.color, -0.1)
      };
    }), t;
  }
  return r;
}
function OT(r, e, t) {
  r.onHoverStateChange && (r.hoverState || 0) !== t && r.onHoverStateChange(e), r.hoverState = t;
}
function vH(r) {
  OT(r, "emphasis", vT);
}
function OH(r) {
  r.hoverState === vT && OT(r, "normal", B1);
}
function F1(r) {
  OT(r, "blur", Av);
}
function mH(r) {
  r.hoverState === Av && OT(r, "normal", B1);
}
function Goe(r) {
  r.selected = !0;
}
function Boe(r) {
  r.selected = !1;
}
function pM(r, e, t) {
  e(r, t);
}
function bs(r, e, t) {
  pM(r, e, t), r.isGroup && r.traverse(function(i) {
    pM(i, e, t);
  });
}
function ob(r, e) {
  switch (e) {
    case "emphasis":
      r.hoverState = vT;
      break;
    case "normal":
      r.hoverState = B1;
      break;
    case "blur":
      r.hoverState = Av;
      break;
    case "select":
      r.selected = !0;
  }
}
function Foe(r, e, t, i) {
  for (var n = r.style, a = {}, o = 0; o < e.length; o++) {
    var s = e[o], l = n[s];
    a[s] = l ?? (i && i[s]);
  }
  for (var o = 0; o < r.animators.length; o++) {
    var u = r.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(t) < 0 && u.targetName === "style" && u.saveTo(a, e);
  }
  return a;
}
function Xoe(r, e, t, i) {
  var n = t && Fe(t, "select") >= 0, a = !1;
  if (r instanceof He) {
    var o = gH(r), s = n && o.selectFill || o.normalFill, l = n && o.selectStroke || o.normalStroke;
    if (dh(s) || dh(l)) {
      i = i || {};
      var u = i.style || {};
      u.fill === "inherit" ? (a = !0, i = B({}, i), u = B({}, u), u.fill = s) : !dh(u.fill) && dh(s) ? (a = !0, i = B({}, i), u = B({}, u), u.fill = dM(s)) : !dh(u.stroke) && dh(l) && (a || (i = B({}, i), u = B({}, u)), u.stroke = dM(l)), i.style = u;
    }
  }
  if (i && i.z2 == null) {
    a || (i = B({}, i));
    var c = r.z2EmphasisLift;
    i.z2 = r.z2 + (c ?? Kf);
  }
  return i;
}
function Yoe(r, e, t) {
  if (t && t.z2 == null) {
    t = B({}, t);
    var i = r.z2SelectLift;
    t.z2 = r.z2 + (i ?? Voe);
  }
  return t;
}
function Hoe(r, e, t) {
  var i = Fe(r.currentStates, e) >= 0, n = r.style.opacity, a = i ? null : Foe(r, ["opacity"], e, {
    opacity: 1
  });
  t = t || {};
  var o = t.style || {};
  return o.opacity == null && (t = B({}, t), o = B({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: i ? n : a.opacity * 0.1
  }, o), t.style = o), t;
}
function m0(r, e) {
  var t = this.states[r];
  if (this.style) {
    if (r === "emphasis")
      return Xoe(this, r, e, t);
    if (r === "blur")
      return Hoe(this, r, t);
    if (r === "select")
      return Yoe(this, r, t);
  }
  return t;
}
function xc(r) {
  r.stateProxy = m0;
  var e = r.getTextContent(), t = r.getTextGuideLine();
  e && (e.stateProxy = m0), t && (t.stateProxy = m0);
}
function gM(r, e) {
  !TH(r, e) && !r.__highByOuter && bs(r, vH);
}
function vM(r, e) {
  !TH(r, e) && !r.__highByOuter && bs(r, OH);
}
function ls(r, e) {
  r.__highByOuter |= 1 << (e || 0), bs(r, vH);
}
function us(r, e) {
  !(r.__highByOuter &= ~(1 << (e || 0))) && bs(r, OH);
}
function EH(r) {
  bs(r, F1);
}
function X1(r) {
  bs(r, mH);
}
function bH(r) {
  bs(r, Goe);
}
function SH(r) {
  bs(r, Boe);
}
function TH(r, e) {
  return r.__highDownSilentOnTouch && e.zrByTouch;
}
function yH(r) {
  var e = r.getModel(), t = [], i = [];
  e.eachComponent(function(n, a) {
    var o = G1(a), s = n === "series", l = s ? r.getViewOfSeriesModel(a) : r.getViewOfComponentModel(a);
    !s && i.push(l), o.isBlured && (l.group.traverse(function(u) {
      mH(u);
    }), s && t.push(a)), o.isBlured = !1;
  }), N(i, function(n) {
    n && n.toggleBlurSeries && n.toggleBlurSeries(t, !1, e);
  });
}
function tC(r, e, t, i) {
  var n = i.getModel();
  t = t || "coordinateSystem";
  function a(u, c) {
    for (var h = 0; h < c.length; h++) {
      var f = u.getItemGraphicEl(c[h]);
      f && X1(f);
    }
  }
  if (r != null && !(!e || e === "none")) {
    var o = n.getSeriesByIndex(r), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    n.eachSeries(function(u) {
      var c = o === u, h = u.coordinateSystem;
      h && h.master && (h = h.master);
      var f = h && s ? h === s : c;
      if (!// Not blur other series if blurScope series
      (t === "series" && !c || t === "coordinateSystem" && !f || e === "series" && c)) {
        var d = i.getViewOfSeriesModel(u);
        if (d.group.traverse(function(v) {
          v.__highByOuter && c && e === "self" || F1(v);
        }), mi(e))
          a(u.getData(), e);
        else if (be(e))
          for (var p = Ze(e), g = 0; g < p.length; g++)
            a(u.getData(p[g]), e[p[g]]);
        l.push(u), G1(u).isBlured = !0;
      }
    }), n.eachComponent(function(u, c) {
      if (u !== "series") {
        var h = i.getViewOfComponentModel(c);
        h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, n);
      }
    });
  }
}
function rC(r, e, t) {
  if (!(r == null || e == null)) {
    var i = t.getModel().getComponent(r, e);
    if (i) {
      G1(i).isBlured = !0;
      var n = t.getViewOfComponentModel(i);
      !n || !n.focusBlurEnabled || n.group.traverse(function(a) {
        F1(a);
      });
    }
  }
}
function Woe(r, e, t) {
  var i = r.seriesIndex, n = r.getData(e.dataType);
  if (!n) {
    ({}).NODE_ENV !== "production" && ti("Unknown dataType " + e.dataType);
    return;
  }
  var a = wc(n, e);
  a = (X(a) ? a[0] : a) || 0;
  var o = n.getItemGraphicEl(a);
  if (!o)
    for (var s = n.count(), l = 0; !o && l < s; )
      o = n.getItemGraphicEl(l++);
  if (o) {
    var u = Pe(o);
    tC(i, u.focus, u.blurScope, t);
  } else {
    var c = r.get(["emphasis", "focus"]), h = r.get(["emphasis", "blurScope"]);
    c != null && tC(i, c, h, t);
  }
}
function Y1(r, e, t, i) {
  var n = {
    focusSelf: !1,
    dispatchers: null
  };
  if (r == null || r === "series" || e == null || t == null)
    return n;
  var a = i.getModel().getComponent(r, e);
  if (!a)
    return n;
  var o = i.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return n;
  for (var s = o.findHighDownDispatchers(t), l, u = 0; u < s.length; u++)
    if ({}.NODE_ENV !== "production" && !Nl(s[u]) && ti("param should be highDownDispatcher"), Pe(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function zoe(r, e, t) {
  ({}).NODE_ENV !== "production" && !Nl(r) && ti("param should be highDownDispatcher");
  var i = Pe(r), n = Y1(i.componentMainType, i.componentIndex, i.componentHighDownName, t), a = n.dispatchers, o = n.focusSelf;
  a ? (o && rC(i.componentMainType, i.componentIndex, t), N(a, function(s) {
    return gM(s, e);
  })) : (tC(i.seriesIndex, i.focus, i.blurScope, t), i.focus === "self" && rC(i.componentMainType, i.componentIndex, t), gM(r, e));
}
function Zoe(r, e, t) {
  ({}).NODE_ENV !== "production" && !Nl(r) && ti("param should be highDownDispatcher"), yH(t);
  var i = Pe(r), n = Y1(i.componentMainType, i.componentIndex, i.componentHighDownName, t).dispatchers;
  n ? N(n, function(a) {
    return vM(a, e);
  }) : vM(r, e);
}
function qoe(r, e, t) {
  if (nC(e)) {
    var i = e.dataType, n = r.getData(i), a = wc(n, e);
    X(a) || (a = [a]), r[e.type === Zp ? "toggleSelect" : e.type === zp ? "select" : "unselect"](a, i);
  }
}
function OM(r) {
  var e = r.getAllData();
  N(e, function(t) {
    var i = t.data, n = t.type;
    i.eachItemGraphicEl(function(a, o) {
      r.isSelected(o, n) ? bH(a) : SH(a);
    });
  });
}
function joe(r) {
  var e = [];
  return r.eachSeries(function(t) {
    var i = t.getAllData();
    N(i, function(n) {
      n.data;
      var a = n.type, o = t.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: t.seriesIndex
        };
        a != null && (s.dataType = a), e.push(s);
      }
    });
  }), e;
}
function pc(r, e, t) {
  Zu(r, !0), bs(r, xc), iC(r, e, t);
}
function Koe(r) {
  Zu(r, !1);
}
function qt(r, e, t, i) {
  i ? Koe(r) : pc(r, e, t);
}
function iC(r, e, t) {
  var i = Pe(r);
  e != null ? (i.focus = e, i.blurScope = t) : i.focus && (i.focus = null);
}
var mM = ["emphasis", "blur", "select"], Joe = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function ri(r, e, t, i) {
  t = t || "itemStyle";
  for (var n = 0; n < mM.length; n++) {
    var a = mM[n], o = e.getModel([a, t]), s = r.ensureState(a);
    s.style = i ? i(o) : o[Joe[t]]();
  }
}
function Zu(r, e) {
  var t = e === !1, i = r;
  r.highDownSilentOnTouch && (i.__highDownSilentOnTouch = r.highDownSilentOnTouch), (!t || i.__highDownDispatcher) && (i.__highByOuter = i.__highByOuter || 0, i.__highDownDispatcher = !t);
}
function Nl(r) {
  return !!(r && r.__highDownDispatcher);
}
function ese(r, e, t) {
  var i = Pe(r);
  i.componentMainType = e.mainType, i.componentIndex = e.componentIndex, i.componentHighDownName = t;
}
function tse(r) {
  var e = hM[r];
  return e == null && cM <= 32 && (e = hM[r] = cM++), e;
}
function nC(r) {
  var e = r.type;
  return e === zp || e === Km || e === Zp;
}
function EM(r) {
  var e = r.type;
  return e === dc || e === jm;
}
function rse(r) {
  var e = gH(r);
  e.normalFill = r.style.fill, e.normalStroke = r.style.stroke;
  var t = r.states.select || {};
  e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null;
}
var ph = _o.CMD, ise = [[], [], []], bM = Math.sqrt, nse = Math.atan2;
function RH(r, e) {
  if (e) {
    var t = r.data, i = r.len(), n, a, o, s, l, u, c = ph.M, h = ph.C, f = ph.L, d = ph.R, p = ph.A, g = ph.Q;
    for (o = 0, s = 0; o < i; ) {
      switch (n = t[o++], s = o, a = 0, n) {
        case c:
          a = 1;
          break;
        case f:
          a = 1;
          break;
        case h:
          a = 3;
          break;
        case g:
          a = 2;
          break;
        case p:
          var v = e[4], O = e[5], m = bM(e[0] * e[0] + e[1] * e[1]), E = bM(e[2] * e[2] + e[3] * e[3]), b = nse(-e[1] / E, e[0] / m);
          t[o] *= m, t[o++] += v, t[o] *= E, t[o++] += O, t[o++] *= m, t[o++] *= E, t[o++] += b, t[o++] += b, o += 2, s = o;
          break;
        case d:
          u[0] = t[o++], u[1] = t[o++], Kr(u, u, e), t[s++] = u[0], t[s++] = u[1], u[0] += t[o++], u[1] += t[o++], Kr(u, u, e), t[s++] = u[0], t[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var S = ise[l];
        S[0] = t[o++], S[1] = t[o++], Kr(S, S, e), t[s++] = S[0], t[s++] = S[1];
      }
    }
    r.increaseVersion();
  }
}
var E0 = Math.sqrt, CO = Math.sin, IO = Math.cos, Pd = Math.PI;
function SM(r) {
  return Math.sqrt(r[0] * r[0] + r[1] * r[1]);
}
function aC(r, e) {
  return (r[0] * e[0] + r[1] * e[1]) / (SM(r) * SM(e));
}
function TM(r, e) {
  return (r[0] * e[1] < r[1] * e[0] ? -1 : 1) * Math.acos(aC(r, e));
}
function yM(r, e, t, i, n, a, o, s, l, u, c) {
  var h = l * (Pd / 180), f = IO(h) * (r - t) / 2 + CO(h) * (e - i) / 2, d = -1 * CO(h) * (r - t) / 2 + IO(h) * (e - i) / 2, p = f * f / (o * o) + d * d / (s * s);
  p > 1 && (o *= E0(p), s *= E0(p));
  var g = (n === a ? -1 : 1) * E0((o * o * (s * s) - o * o * (d * d) - s * s * (f * f)) / (o * o * (d * d) + s * s * (f * f))) || 0, v = g * o * d / s, O = g * -s * f / o, m = (r + t) / 2 + IO(h) * v - CO(h) * O, E = (e + i) / 2 + CO(h) * v + IO(h) * O, b = TM([1, 0], [(f - v) / o, (d - O) / s]), S = [(f - v) / o, (d - O) / s], T = [(-1 * f - v) / o, (-1 * d - O) / s], y = TM(S, T);
  if (aC(S, T) <= -1 && (y = Pd), aC(S, T) >= 1 && (y = 0), y < 0) {
    var R = Math.round(y / Pd * 1e6) / 1e6;
    y = Pd * 2 + R % 2 * Pd;
  }
  c.addData(u, m, E, o, s, b, y, h, a);
}
var ase = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, ose = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function sse(r) {
  var e = new _o();
  if (!r)
    return e;
  var t = 0, i = 0, n = t, a = i, o, s = _o.CMD, l = r.match(ase);
  if (!l)
    return e;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], h = c.charAt(0), f = void 0, d = c.match(ose) || [], p = d.length, g = 0; g < p; g++)
      d[g] = parseFloat(d[g]);
    for (var v = 0; v < p; ) {
      var O = void 0, m = void 0, E = void 0, b = void 0, S = void 0, T = void 0, y = void 0, R = t, _ = i, C = void 0, I = void 0;
      switch (h) {
        case "l":
          t += d[v++], i += d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "L":
          t = d[v++], i = d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "m":
          t += d[v++], i += d[v++], f = s.M, e.addData(f, t, i), n = t, a = i, h = "l";
          break;
        case "M":
          t = d[v++], i = d[v++], f = s.M, e.addData(f, t, i), n = t, a = i, h = "L";
          break;
        case "h":
          t += d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "H":
          t = d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "v":
          i += d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "V":
          i = d[v++], f = s.L, e.addData(f, t, i);
          break;
        case "C":
          f = s.C, e.addData(f, d[v++], d[v++], d[v++], d[v++], d[v++], d[v++]), t = d[v - 2], i = d[v - 1];
          break;
        case "c":
          f = s.C, e.addData(f, d[v++] + t, d[v++] + i, d[v++] + t, d[v++] + i, d[v++] + t, d[v++] + i), t += d[v - 2], i += d[v - 1];
          break;
        case "S":
          O = t, m = i, C = e.len(), I = e.data, o === s.C && (O += t - I[C - 4], m += i - I[C - 3]), f = s.C, R = d[v++], _ = d[v++], t = d[v++], i = d[v++], e.addData(f, O, m, R, _, t, i);
          break;
        case "s":
          O = t, m = i, C = e.len(), I = e.data, o === s.C && (O += t - I[C - 4], m += i - I[C - 3]), f = s.C, R = t + d[v++], _ = i + d[v++], t += d[v++], i += d[v++], e.addData(f, O, m, R, _, t, i);
          break;
        case "Q":
          R = d[v++], _ = d[v++], t = d[v++], i = d[v++], f = s.Q, e.addData(f, R, _, t, i);
          break;
        case "q":
          R = d[v++] + t, _ = d[v++] + i, t += d[v++], i += d[v++], f = s.Q, e.addData(f, R, _, t, i);
          break;
        case "T":
          O = t, m = i, C = e.len(), I = e.data, o === s.Q && (O += t - I[C - 4], m += i - I[C - 3]), t = d[v++], i = d[v++], f = s.Q, e.addData(f, O, m, t, i);
          break;
        case "t":
          O = t, m = i, C = e.len(), I = e.data, o === s.Q && (O += t - I[C - 4], m += i - I[C - 3]), t += d[v++], i += d[v++], f = s.Q, e.addData(f, O, m, t, i);
          break;
        case "A":
          E = d[v++], b = d[v++], S = d[v++], T = d[v++], y = d[v++], R = t, _ = i, t = d[v++], i = d[v++], f = s.A, yM(R, _, t, i, T, y, E, b, S, f, e);
          break;
        case "a":
          E = d[v++], b = d[v++], S = d[v++], T = d[v++], y = d[v++], R = t, _ = i, t += d[v++], i += d[v++], f = s.A, yM(R, _, t, i, T, y, E, b, S, f, e);
          break;
      }
    }
    (h === "z" || h === "Z") && (f = s.Z, e.addData(f), t = n, i = a), o = f;
  }
  return e.toStatic(), e;
}
var AH = function(r) {
  $(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e.prototype.applyTransform = function(t) {
  }, e;
}(He);
function _H(r) {
  return r.setData != null;
}
function CH(r, e) {
  var t = sse(r), i = B({}, e);
  return i.buildPath = function(n) {
    if (_H(n)) {
      n.setData(t.data);
      var a = n.getContext();
      a && n.rebuildPath(a, 1);
    } else {
      var a = n;
      t.rebuildPath(a, 1);
    }
  }, i.applyTransform = function(n) {
    RH(t, n), this.dirtyShape();
  }, i;
}
function IH(r, e) {
  return new AH(CH(r, e));
}
function lse(r, e) {
  var t = CH(r, e), i = function(n) {
    $(a, n);
    function a(o) {
      var s = n.call(this, o) || this;
      return s.applyTransform = t.applyTransform, s.buildPath = t.buildPath, s;
    }
    return a;
  }(AH);
  return i;
}
function use(r, e) {
  for (var t = [], i = r.length, n = 0; n < i; n++) {
    var a = r[n];
    t.push(a.getUpdatedPathProxy(!0));
  }
  var o = new He(e);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (_H(s)) {
      s.appendPath(t);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
function H1(r, e) {
  e = e || {};
  var t = new He();
  return r.shape && t.setShape(r.shape), t.setStyle(r.style), e.bakeTransform ? RH(t.path, r.getComputedTransform()) : e.toLocal ? t.setLocalTransform(r.getComputedTransform()) : t.copyTransform(r), t.buildPath = r.buildPath, t.applyTransform = t.applyTransform, t.z = r.z, t.z2 = r.z2, t.zlevel = r.zlevel, t;
}
var cse = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return r;
}(), wH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new cse();
  }, e.prototype.buildPath = function(t, i) {
    t.moveTo(i.cx + i.r, i.cy), t.arc(i.cx, i.cy, i.r, 0, Math.PI * 2);
  }, e;
}(He);
wH.prototype.type = "circle";
const Co = wH;
var hse = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return r;
}(), NH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new hse();
  }, e.prototype.buildPath = function(t, i) {
    var n = 0.5522848, a = i.cx, o = i.cy, s = i.rx, l = i.ry, u = s * n, c = l * n;
    t.moveTo(a - s, o), t.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), t.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), t.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), t.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), t.closePath();
  }, e;
}(He);
NH.prototype.type = "ellipse";
const W1 = NH;
var xH = Math.PI, b0 = xH * 2, gu = Math.sin, gh = Math.cos, fse = Math.acos, ci = Math.atan2, RM = Math.abs, qp = Math.sqrt, Op = Math.max, Va = Math.min, fa = 1e-4;
function dse(r, e, t, i, n, a, o, s) {
  var l = t - r, u = i - e, c = o - n, h = s - a, f = h * l - c * u;
  if (!(f * f < fa))
    return f = (c * (e - a) - h * (r - n)) / f, [r + f * l, e + f * u];
}
function wO(r, e, t, i, n, a, o) {
  var s = r - t, l = e - i, u = (o ? a : -a) / qp(s * s + l * l), c = u * l, h = -u * s, f = r + c, d = e + h, p = t + c, g = i + h, v = (f + p) / 2, O = (d + g) / 2, m = p - f, E = g - d, b = m * m + E * E, S = n - a, T = f * g - p * d, y = (E < 0 ? -1 : 1) * qp(Op(0, S * S * b - T * T)), R = (T * E - m * y) / b, _ = (-T * m - E * y) / b, C = (T * E + m * y) / b, I = (-T * m + E * y) / b, w = R - v, x = _ - O, P = C - v, L = I - O;
  return w * w + x * x > P * P + L * L && (R = C, _ = I), {
    cx: R,
    cy: _,
    x0: -c,
    y0: -h,
    x1: R * (n / S - 1),
    y1: _ * (n / S - 1)
  };
}
function pse(r) {
  var e;
  if (X(r)) {
    var t = r.length;
    if (!t)
      return r;
    t === 1 ? e = [r[0], r[0], 0, 0] : t === 2 ? e = [r[0], r[0], r[1], r[1]] : t === 3 ? e = r.concat(r[2]) : e = r;
  } else
    e = [r, r, r, r];
  return e;
}
function gse(r, e) {
  var t, i = Op(e.r, 0), n = Op(e.r0 || 0, 0), a = i > 0, o = n > 0;
  if (!(!a && !o)) {
    if (a || (i = n, n = 0), n > i) {
      var s = i;
      i = n, n = s;
    }
    var l = e.startAngle, u = e.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = e.cx, h = e.cy, f = !!e.clockwise, d = RM(u - l), p = d > b0 && d % b0;
      if (p > fa && (d = p), !(i > fa))
        r.moveTo(c, h);
      else if (d > b0 - fa)
        r.moveTo(c + i * gh(l), h + i * gu(l)), r.arc(c, h, i, l, u, !f), n > fa && (r.moveTo(c + n * gh(u), h + n * gu(u)), r.arc(c, h, n, u, l, f));
      else {
        var g = void 0, v = void 0, O = void 0, m = void 0, E = void 0, b = void 0, S = void 0, T = void 0, y = void 0, R = void 0, _ = void 0, C = void 0, I = void 0, w = void 0, x = void 0, P = void 0, L = i * gh(l), D = i * gu(l), U = n * gh(u), Q = n * gu(u), V = d > fa;
        if (V) {
          var F = e.cornerRadius;
          F && (t = pse(F), g = t[0], v = t[1], O = t[2], m = t[3]);
          var j = RM(i - n) / 2;
          if (E = Va(j, O), b = Va(j, m), S = Va(j, g), T = Va(j, v), _ = y = Op(E, b), C = R = Op(S, T), (y > fa || R > fa) && (I = i * gh(u), w = i * gu(u), x = n * gh(l), P = n * gu(l), d < xH)) {
            var ae = dse(L, D, x, P, I, w, U, Q);
            if (ae) {
              var ce = L - ae[0], ge = D - ae[1], Be = I - ae[0], We = w - ae[1], Ne = 1 / gu(fse((ce * Be + ge * We) / (qp(ce * ce + ge * ge) * qp(Be * Be + We * We))) / 2), Ee = qp(ae[0] * ae[0] + ae[1] * ae[1]);
              _ = Va(y, (i - Ee) / (Ne + 1)), C = Va(R, (n - Ee) / (Ne - 1));
            }
          }
        }
        if (!V)
          r.moveTo(c + L, h + D);
        else if (_ > fa) {
          var Ge = Va(O, _), Ie = Va(m, _), he = wO(x, P, L, D, i, Ge, f), xe = wO(I, w, U, Q, i, Ie, f);
          r.moveTo(c + he.cx + he.x0, h + he.cy + he.y0), _ < y && Ge === Ie ? r.arc(c + he.cx, h + he.cy, _, ci(he.y0, he.x0), ci(xe.y0, xe.x0), !f) : (Ge > 0 && r.arc(c + he.cx, h + he.cy, Ge, ci(he.y0, he.x0), ci(he.y1, he.x1), !f), r.arc(c, h, i, ci(he.cy + he.y1, he.cx + he.x1), ci(xe.cy + xe.y1, xe.cx + xe.x1), !f), Ie > 0 && r.arc(c + xe.cx, h + xe.cy, Ie, ci(xe.y1, xe.x1), ci(xe.y0, xe.x0), !f));
        } else
          r.moveTo(c + L, h + D), r.arc(c, h, i, l, u, !f);
        if (!(n > fa) || !V)
          r.lineTo(c + U, h + Q);
        else if (C > fa) {
          var Ge = Va(g, C), Ie = Va(v, C), he = wO(U, Q, I, w, n, -Ie, f), xe = wO(L, D, x, P, n, -Ge, f);
          r.lineTo(c + he.cx + he.x0, h + he.cy + he.y0), C < R && Ge === Ie ? r.arc(c + he.cx, h + he.cy, C, ci(he.y0, he.x0), ci(xe.y0, xe.x0), !f) : (Ie > 0 && r.arc(c + he.cx, h + he.cy, Ie, ci(he.y0, he.x0), ci(he.y1, he.x1), !f), r.arc(c, h, n, ci(he.cy + he.y1, he.cx + he.x1), ci(xe.cy + xe.y1, xe.cx + xe.x1), f), Ge > 0 && r.arc(c + xe.cx, h + xe.cy, Ge, ci(xe.y1, xe.x1), ci(xe.y0, xe.x0), !f));
        } else
          r.lineTo(c + U, h + Q), r.arc(c, h, n, u, l, f);
      }
      r.closePath();
    }
  }
}
var vse = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return r;
}(), PH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new vse();
  }, e.prototype.buildPath = function(t, i) {
    gse(t, i);
  }, e.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, e;
}(He);
PH.prototype.type = "sector";
const tn = PH;
var Ose = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return r;
}(), LH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new Ose();
  }, e.prototype.buildPath = function(t, i) {
    var n = i.cx, a = i.cy, o = Math.PI * 2;
    t.moveTo(n + i.r, a), t.arc(n, a, i.r, 0, o, !1), t.moveTo(n + i.r0, a), t.arc(n, a, i.r0, 0, o, !0);
  }, e;
}(He);
LH.prototype.type = "ring";
const mT = LH;
function mse(r, e, t, i) {
  var n = [], a = [], o = [], s = [], l, u, c, h;
  if (i) {
    c = [1 / 0, 1 / 0], h = [-1 / 0, -1 / 0];
    for (var f = 0, d = r.length; f < d; f++)
      Js(c, c, r[f]), el(h, h, r[f]);
    Js(c, c, i[0]), el(h, h, i[1]);
  }
  for (var f = 0, d = r.length; f < d; f++) {
    var p = r[f];
    if (t)
      l = r[f ? f - 1 : d - 1], u = r[(f + 1) % d];
    else if (f === 0 || f === d - 1) {
      n.push(Zo(r[f]));
      continue;
    } else
      l = r[f - 1], u = r[f + 1];
    Wu(a, u, l), Xm(a, a, e);
    var g = N_(p, l), v = N_(p, u), O = g + v;
    O !== 0 && (g /= O, v /= O), Xm(o, a, -g), Xm(s, a, v);
    var m = dD([], p, o), E = dD([], p, s);
    i && (el(m, m, c), Js(m, m, h), el(E, E, c), Js(E, E, h)), n.push(m), n.push(E);
  }
  return t && n.push(n.shift()), n;
}
function DH(r, e, t) {
  var i = e.smooth, n = e.points;
  if (n && n.length >= 2) {
    if (i) {
      var a = mse(n, i, t, e.smoothConstraint);
      r.moveTo(n[0][0], n[0][1]);
      for (var o = n.length, s = 0; s < (t ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], c = n[(s + 1) % o];
        r.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      r.moveTo(n[0][0], n[0][1]);
      for (var s = 1, h = n.length; s < h; s++)
        r.lineTo(n[s][0], n[s][1]);
    }
    t && r.closePath();
  }
}
var Ese = function() {
  function r() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), MH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultShape = function() {
    return new Ese();
  }, e.prototype.buildPath = function(t, i) {
    DH(t, i, !0);
  }, e;
}(He);
MH.prototype.type = "polygon";
const rn = MH;
var bse = function() {
  function r() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return r;
}(), kH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new bse();
  }, e.prototype.buildPath = function(t, i) {
    DH(t, i, !1);
  }, e;
}(He);
kH.prototype.type = "polyline";
const nn = kH;
var Sse = {}, Tse = function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return r;
}(), QH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new Tse();
  }, e.prototype.buildPath = function(t, i) {
    var n, a, o, s;
    if (this.subPixelOptimize) {
      var l = uH(Sse, i, this.style);
      n = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      n = i.x1, a = i.y1, o = i.x2, s = i.y2;
    var u = i.percent;
    u !== 0 && (t.moveTo(n, a), u < 1 && (o = n * (1 - u) + o * u, s = a * (1 - u) + s * u), t.lineTo(o, s));
  }, e.prototype.pointAt = function(t) {
    var i = this.shape;
    return [
      i.x1 * (1 - t) + i.x2 * t,
      i.y1 * (1 - t) + i.y2 * t
    ];
  }, e;
}(He);
QH.prototype.type = "line";
const Gr = QH;
var Gi = [], yse = function() {
  function r() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return r;
}();
function AM(r, e, t) {
  var i = r.cpx2, n = r.cpy2;
  return i != null || n != null ? [
    (t ? AD : wr)(r.x1, r.cpx1, r.cpx2, r.x2, e),
    (t ? AD : wr)(r.y1, r.cpy1, r.cpy2, r.y2, e)
  ] : [
    (t ? k_ : Vr)(r.x1, r.cpx1, r.x2, e),
    (t ? k_ : Vr)(r.y1, r.cpy1, r.y2, e)
  ];
}
var UH = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new yse();
  }, e.prototype.buildPath = function(t, i) {
    var n = i.x1, a = i.y1, o = i.x2, s = i.y2, l = i.cpx1, u = i.cpy1, c = i.cpx2, h = i.cpy2, f = i.percent;
    f !== 0 && (t.moveTo(n, a), c == null || h == null ? (f < 1 && (Cg(n, l, o, f, Gi), l = Gi[1], o = Gi[2], Cg(a, u, s, f, Gi), u = Gi[1], s = Gi[2]), t.quadraticCurveTo(l, u, o, s)) : (f < 1 && (wl(n, l, c, o, f, Gi), l = Gi[1], c = Gi[2], o = Gi[3], wl(a, u, h, s, f, Gi), u = Gi[1], h = Gi[2], s = Gi[3]), t.bezierCurveTo(l, u, c, h, o, s)));
  }, e.prototype.pointAt = function(t) {
    return AM(this.shape, t, !1);
  }, e.prototype.tangentAt = function(t) {
    var i = AM(this.shape, t, !0);
    return Zf(i, i);
  }, e;
}(He);
UH.prototype.type = "bezier-curve";
const ET = UH;
var Rse = function() {
  function r() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return r;
}(), $H = function(r) {
  $(e, r);
  function e(t) {
    return r.call(this, t) || this;
  }
  return e.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, e.prototype.getDefaultShape = function() {
    return new Rse();
  }, e.prototype.buildPath = function(t, i) {
    var n = i.cx, a = i.cy, o = Math.max(i.r, 0), s = i.startAngle, l = i.endAngle, u = i.clockwise, c = Math.cos(s), h = Math.sin(s);
    t.moveTo(c * o + n, h * o + a), t.arc(n, a, o, s, l, !u);
  }, e;
}(He);
$H.prototype.type = "arc";
const z1 = $H;
var Ase = function(r) {
  $(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.type = "compound", t;
  }
  return e.prototype._updatePathDirty = function() {
    for (var t = this.shape.paths, i = this.shapeChanged(), n = 0; n < t.length; n++)
      i = i || t[n].shapeChanged();
    i && this.dirtyShape();
  }, e.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var t = this.shape.paths || [], i = this.getGlobalScale(), n = 0; n < t.length; n++)
      t[n].path || t[n].createPathProxy(), t[n].path.setScale(i[0], i[1], t[n].segmentIgnoreThreshold);
  }, e.prototype.buildPath = function(t, i) {
    for (var n = i.paths || [], a = 0; a < n.length; a++)
      n[a].buildPath(t, n[a].shape, !0);
  }, e.prototype.afterBrush = function() {
    for (var t = this.shape.paths || [], i = 0; i < t.length; i++)
      t[i].pathUpdated();
  }, e.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), He.prototype.getBoundingRect.call(this);
  }, e;
}(He);
const Z1 = Ase;
var _se = function() {
  function r(e) {
    this.colorStops = e || [];
  }
  return r.prototype.addColorStop = function(e, t) {
    this.colorStops.push({
      offset: e,
      color: t
    });
  }, r;
}();
const VH = _se;
var Cse = function(r) {
  $(e, r);
  function e(t, i, n, a, o, s) {
    var l = r.call(this, o) || this;
    return l.x = t ?? 0, l.y = i ?? 0, l.x2 = n ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return e;
}(VH);
const _v = Cse;
var Ise = function(r) {
  $(e, r);
  function e(t, i, n, a, o) {
    var s = r.call(this, a) || this;
    return s.x = t ?? 0.5, s.y = i ?? 0.5, s.r = n ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return e;
}(VH);
const GH = Ise;
var vu = [0, 0], Ou = [0, 0], NO = new Me(), xO = new Me(), wse = function() {
  function r(e, t) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var i = 0; i < 4; i++)
      this._corners[i] = new Me();
    for (var i = 0; i < 2; i++)
      this._axes[i] = new Me();
    e && this.fromBoundingRect(e, t);
  }
  return r.prototype.fromBoundingRect = function(e, t) {
    var i = this._corners, n = this._axes, a = e.x, o = e.y, s = a + e.width, l = o + e.height;
    if (i[0].set(a, o), i[1].set(s, o), i[2].set(s, l), i[3].set(a, l), t)
      for (var u = 0; u < 4; u++)
        i[u].transform(t);
    Me.sub(n[0], i[1], i[0]), Me.sub(n[1], i[3], i[0]), n[0].normalize(), n[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = n[u].dot(i[0]);
  }, r.prototype.intersect = function(e, t) {
    var i = !0, n = !t;
    return NO.set(1 / 0, 1 / 0), xO.set(0, 0), !this._intersectCheckOneSide(this, e, NO, xO, n, 1) && (i = !1, n) || !this._intersectCheckOneSide(e, this, NO, xO, n, -1) && (i = !1, n) || n || Me.copy(t, i ? NO : xO), i;
  }, r.prototype._intersectCheckOneSide = function(e, t, i, n, a, o) {
    for (var s = !0, l = 0; l < 2; l++) {
      var u = this._axes[l];
      if (this._getProjMinMaxOnAxis(l, e._corners, vu), this._getProjMinMaxOnAxis(l, t._corners, Ou), vu[1] < Ou[0] || vu[0] > Ou[1]) {
        if (s = !1, a)
          return s;
        var c = Math.abs(Ou[0] - vu[1]), h = Math.abs(vu[0] - Ou[1]);
        Math.min(c, h) > n.len() && (c < h ? Me.scale(n, u, -c * o) : Me.scale(n, u, h * o));
      } else if (i) {
        var c = Math.abs(Ou[0] - vu[1]), h = Math.abs(vu[0] - Ou[1]);
        Math.min(c, h) < i.len() && (c < h ? Me.scale(i, u, c * o) : Me.scale(i, u, -h * o));
      }
    }
    return s;
  }, r.prototype._getProjMinMaxOnAxis = function(e, t, i) {
    for (var n = this._axes[e], a = this._origin, o = t[0].dot(n) + a[e], s = o, l = o, u = 1; u < t.length; u++) {
      var c = t[u].dot(n) + a[e];
      s = Math.min(c, s), l = Math.max(c, l);
    }
    i[0] = s, i[1] = l;
  }, r;
}();
const sb = wse;
var Nse = [], xse = function(r) {
  $(e, r);
  function e() {
    var t = r !== null && r.apply(this, arguments) || this;
    return t.notClear = !0, t.incremental = !0, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t;
  }
  return e.prototype.traverse = function(t, i) {
    t.call(i, this);
  }, e.prototype.useStyle = function() {
    this.style = {};
  }, e.prototype.getCursor = function() {
    return this._cursor;
  }, e.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, e.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, e.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, e.prototype.addDisplayable = function(t, i) {
    i ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw();
  }, e.prototype.addDisplayables = function(t, i) {
    i = i || !1;
    for (var n = 0; n < t.length; n++)
      this.addDisplayable(t[n], i);
  }, e.prototype.getDisplayables = function() {
    return this._displayables;
  }, e.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, e.prototype.eachPendingDisplayable = function(t) {
    for (var i = this._cursor; i < this._displayables.length; i++)
      t && t(this._displayables[i]);
    for (var i = 0; i < this._temporaryDisplayables.length; i++)
      t && t(this._temporaryDisplayables[i]);
  }, e.prototype.update = function() {
    this.updateTransform();
    for (var t = this._cursor; t < this._displayables.length; t++) {
      var i = this._displayables[t];
      i.parent = this, i.update(), i.parent = null;
    }
    for (var t = 0; t < this._temporaryDisplayables.length; t++) {
      var i = this._temporaryDisplayables[t];
      i.parent = this, i.update(), i.parent = null;
    }
  }, e.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var t = new Ve(1 / 0, 1 / 0, -1 / 0, -1 / 0), i = 0; i < this._displayables.length; i++) {
        var n = this._displayables[i], a = n.getBoundingRect().clone();
        n.needLocalTransform() && a.applyTransform(n.getLocalTransform(Nse)), t.union(a);
      }
      this._rect = t;
    }
    return this._rect;
  }, e.prototype.contain = function(t, i) {
    var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
    if (a.contain(n[0], n[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(t, i))
          return !0;
      }
    return !1;
  }, e;
}(aa);
const Pse = xse;
var BH = ft();
function Jf(r, e, t, i, n) {
  var a;
  if (e && e.ecModel) {
    var o = e.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = e && e.isAnimationEnabled(), l = r === "update";
  if (s) {
    var u = void 0, c = void 0, h = void 0;
    i ? (u = ke(i.duration, 200), c = ke(i.easing, "cubicOut"), h = 0) : (u = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), ve(h) && (h = h(t, n)), ve(u) && (u = u(t));
    var f = {
      duration: u || 0,
      delay: h,
      easing: c
    };
    return f;
  } else
    return null;
}
function q1(r, e, t, i, n, a, o) {
  var s = !1, l;
  ve(n) ? (o = a, a = n, n = null) : be(n) && (a = n.cb, o = n.during, s = n.isFrom, l = n.removeOpt, n = n.dataIndex);
  var u = r === "leave";
  u || e.stopAnimation("leave");
  var c = Jf(r, i, n, u ? l || {} : null, i && i.getAnimationDelayParams ? i.getAnimationDelayParams(e, n) : null);
  if (c && c.duration > 0) {
    var h = c.duration, f = c.delay, d = c.easing, p = {
      duration: h,
      delay: f || 0,
      easing: d,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: r,
      during: o
    };
    s ? e.animateFrom(t, p) : e.animateTo(t, p);
  } else
    e.stopAnimation(), !s && e.attr(t), o && o(1), a && a();
}
function Ot(r, e, t, i, n, a) {
  q1("update", r, e, t, i, n, a);
}
function Bt(r, e, t, i, n, a) {
  q1("enter", r, e, t, i, n, a);
}
function sf(r) {
  if (!r.__zr)
    return !0;
  for (var e = 0; e < r.animators.length; e++) {
    var t = r.animators[e];
    if (t.scope === "leave")
      return !0;
  }
  return !1;
}
function xl(r, e, t, i, n, a) {
  sf(r) || q1("leave", r, e, t, i, n, a);
}
function _M(r, e, t, i) {
  r.removeTextContent(), r.removeTextGuideLine(), xl(r, {
    style: {
      opacity: 0
    }
  }, e, t, i);
}
function Pg(r, e, t) {
  function i() {
    r.parent && r.parent.remove(r);
  }
  r.isGroup ? r.traverse(function(n) {
    n.isGroup || _M(n, e, t, i);
  }) : _M(r, e, t, i);
}
function La(r) {
  BH(r).oldStyle = r.style;
}
function Lse(r) {
  return BH(r).oldStyle;
}
var lb = Math.max, ub = Math.min, oC = {};
function Dse(r) {
  return He.extend(r);
}
var Mse = lse;
function kse(r, e) {
  return Mse(r, e);
}
function Da(r, e) {
  oC[r] = e;
}
function j1(r) {
  if (oC.hasOwnProperty(r))
    return oC[r];
}
function bT(r, e, t, i) {
  var n = IH(r, e);
  return t && (i === "center" && (t = XH(t, n.getBoundingRect())), YH(n, t)), n;
}
function FH(r, e, t) {
  var i = new ni({
    style: {
      image: r,
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    onload: function(n) {
      if (t === "center") {
        var a = {
          width: n.width,
          height: n.height
        };
        i.setStyle(XH(e, a));
      }
    }
  });
  return i;
}
function XH(r, e) {
  var t = e.width / e.height, i = r.height * t, n;
  i <= r.width ? n = r.height : (i = r.width, n = i / t);
  var a = r.x + r.width / 2, o = r.y + r.height / 2;
  return {
    x: a - i / 2,
    y: o - n / 2,
    width: i,
    height: n
  };
}
var Xn = use;
function YH(r, e) {
  if (r.applyTransform) {
    var t = r.getBoundingRect(), i = t.calculateTransform(e);
    r.applyTransform(i);
  }
}
function wf(r, e) {
  return uH(r, r, {
    lineWidth: e
  }), r;
}
function Qse(r) {
  return cH(r.shape, r.shape, r.style), r;
}
var Jm = zu;
function gc(r, e) {
  for (var t = sT([]); r && r !== e; )
    qo(t, r.getLocalTransform(), t), r = r.parent;
  return t;
}
function Ia(r, e, t) {
  return e && !mi(e) && (e = Ho.getLocalTransform(e)), t && (e = qf([], e)), Kr([], r, e);
}
function ST(r, e, t) {
  var i = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), n = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [r === "left" ? -i : r === "right" ? i : 0, r === "top" ? -n : r === "bottom" ? n : 0];
  return a = Ia(a, e, t), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function CM(r) {
  return !r.isGroup;
}
function Use(r) {
  return r.shape != null;
}
function Cv(r, e, t) {
  if (!r || !e)
    return;
  function i(o) {
    var s = {};
    return o.traverse(function(l) {
      CM(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function n(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return Use(o) && (s.shape = B({}, o.shape)), s;
  }
  var a = i(r);
  e.traverse(function(o) {
    if (CM(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = n(o);
        o.attr(n(s)), Ot(o, l, t, Pe(o).dataIndex);
      }
    }
  });
}
function HH(r, e) {
  return Y(r, function(t) {
    var i = t[0];
    i = lb(i, e.x), i = ub(i, e.x + e.width);
    var n = t[1];
    return n = lb(n, e.y), n = ub(n, e.y + e.height), [i, n];
  });
}
function $se(r, e) {
  var t = lb(r.x, e.x), i = ub(r.x + r.width, e.x + e.width), n = lb(r.y, e.y), a = ub(r.y + r.height, e.y + e.height);
  if (i >= t && a >= n)
    return {
      x: t,
      y: n,
      width: i - t,
      height: a - n
    };
}
function Iv(r, e, t) {
  var i = B({
    rectHover: !0
  }, e), n = i.style = {
    strokeNoScale: !0
  };
  if (t = t || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, r)
    return r.indexOf("image://") === 0 ? (n.image = r.slice(8), Te(n, t), new ni(i)) : bT(r.replace("path://", ""), i, t, "center");
}
function mp(r, e, t, i, n) {
  for (var a = 0, o = n[n.length - 1]; a < n.length; a++) {
    var s = n[a];
    if (WH(r, e, t, i, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function WH(r, e, t, i, n, a, o, s) {
  var l = t - r, u = i - e, c = o - n, h = s - a, f = S0(c, h, l, u);
  if (Vse(f))
    return !1;
  var d = r - n, p = e - a, g = S0(d, p, l, u) / f;
  if (g < 0 || g > 1)
    return !1;
  var v = S0(d, p, c, h) / f;
  return !(v < 0 || v > 1);
}
function S0(r, e, t, i) {
  return r * i - t * e;
}
function Vse(r) {
  return r <= 1e-6 && r >= -1e-6;
}
function ed(r) {
  var e = r.itemTooltipOption, t = r.componentModel, i = r.itemName, n = ne(e) ? {
    formatter: e
  } : e, a = t.mainType, o = t.componentIndex, s = {
    componentType: a,
    name: i,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = r.formatterParamsExtra;
  l && N(Ze(l), function(c) {
    le(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = Pe(r.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: i,
    option: Te({
      content: i,
      formatterParams: s
    }, n)
  };
}
function IM(r, e) {
  var t;
  r.isGroup && (t = e(r)), t || r.traverse(e);
}
function zl(r, e) {
  if (r)
    if (X(r))
      for (var t = 0; t < r.length; t++)
        IM(r[t], e);
    else
      IM(r, e);
}
Da("circle", Co);
Da("ellipse", W1);
Da("sector", tn);
Da("ring", mT);
Da("polygon", rn);
Da("polyline", nn);
Da("rect", ht);
Da("line", Gr);
Da("bezierCurve", ET);
Da("arc", z1);
const wv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: z1,
  BezierCurve: ET,
  BoundingRect: Ve,
  Circle: Co,
  CompoundPath: Z1,
  Ellipse: W1,
  Group: Re,
  Image: ni,
  IncrementalDisplayable: Pse,
  Line: Gr,
  LinearGradient: _v,
  OrientedBoundingRect: sb,
  Path: He,
  Point: Me,
  Polygon: rn,
  Polyline: nn,
  RadialGradient: GH,
  Rect: ht,
  Ring: mT,
  Sector: tn,
  Text: dt,
  applyTransform: Ia,
  clipPointsByRect: HH,
  clipRectByRect: $se,
  createIcon: Iv,
  extendPath: kse,
  extendShape: Dse,
  getShapeClass: j1,
  getTransform: gc,
  groupTransition: Cv,
  initProps: Bt,
  isElementRemoved: sf,
  lineLineIntersect: WH,
  linePolygonIntersect: mp,
  makeImage: FH,
  makePath: bT,
  mergePath: Xn,
  registerShape: Da,
  removeElement: xl,
  removeElementWithFadeOut: Pg,
  resizePath: YH,
  setTooltipConfig: ed,
  subPixelOptimize: Jm,
  subPixelOptimizeLine: wf,
  subPixelOptimizeRect: Qse,
  transformDirection: ST,
  traverseElements: zl,
  updateProps: Ot
}, Symbol.toStringTag, { value: "Module" }));
var TT = {};
function zH(r, e) {
  for (var t = 0; t < $i.length; t++) {
    var i = $i[t], n = e[i], a = r.ensureState(i);
    a.style = a.style || {}, a.style.text = n;
  }
  var o = r.currentStates.slice();
  r.clearStates(!0), r.setStyle({
    text: e.normal
  }), r.useStates(o, !0);
}
function sC(r, e, t) {
  var i = r.labelFetcher, n = r.labelDataIndex, a = r.labelDimIndex, o = e.normal, s;
  i && (s = i.getFormattedLabel(n, "normal", null, a, o && o.get("formatter"), t != null ? {
    interpolatedValue: t
  } : null)), s == null && (s = ve(r.defaultText) ? r.defaultText(n, r, t) : r.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < $i.length; u++) {
    var c = $i[u], h = e[c];
    l[c] = ke(i ? i.getFormattedLabel(n, c, null, a, h && h.get("formatter")) : null, s);
  }
  return l;
}
function ii(r, e, t, i) {
  t = t || TT;
  for (var n = r instanceof dt, a = !1, o = 0; o < xg.length; o++) {
    var s = e[xg[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = n ? r : r.getTextContent();
  if (a) {
    n || (l || (l = new dt(), r.setTextContent(l)), r.stateProxy && (l.stateProxy = r.stateProxy));
    var u = sC(t, e), c = e.normal, h = !!c.getShallow("show"), f = Qt(c, i && i.normal, t, !1, !n);
    f.text = u.normal, n || r.setTextConfig(cb(c, t, !1));
    for (var o = 0; o < $i.length; o++) {
      var d = $i[o], s = e[d];
      if (s) {
        var p = l.ensureState(d), g = !!ke(s.getShallow("show"), h);
        if (g !== h && (p.ignore = !g), p.style = Qt(s, i && i[d], t, !0, !n), p.style.text = u[d], !n) {
          var v = r.ensureState(d);
          v.textConfig = cb(s, t, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !h, l.useStyle(f), l.dirty(), t.enableTextSetter && (td(l).setLabelText = function(O) {
      var m = sC(t, e, O);
      zH(l, m);
    });
  } else
    l && (l.ignore = !0);
  r.dirty();
}
function kr(r, e) {
  e = e || "label";
  for (var t = {
    normal: r.getModel(e)
  }, i = 0; i < $i.length; i++) {
    var n = $i[i];
    t[n] = r.getModel([n, e]);
  }
  return t;
}
function Qt(r, e, t, i, n) {
  var a = {};
  return Gse(a, r, t, i, n), e && B(a, e), a;
}
function cb(r, e, t) {
  e = e || {};
  var i = {}, n, a = r.getShallow("rotate"), o = ke(r.getShallow("distance"), t ? null : 5), s = r.getShallow("offset");
  return n = r.getShallow("position") || (t ? null : "inside"), n === "outside" && (n = e.defaultOutsidePosition || "top"), n != null && (i.position = n), s != null && (i.offset = s), a != null && (a *= Math.PI / 180, i.rotation = a), o != null && (i.distance = o), i.outsideFill = r.get("color") === "inherit" ? e.inheritColor || null : "auto", i;
}
function Gse(r, e, t, i, n) {
  t = t || TT;
  var a = e.ecModel, o = a && a.option.textStyle, s = Bse(e), l;
  if (s) {
    l = {};
    for (var u in s)
      if (s.hasOwnProperty(u)) {
        var c = e.getModel(["rich", u]);
        PM(l[u] = {}, c, o, t, i, n, !1, !0);
      }
  }
  l && (r.rich = l);
  var h = e.get("overflow");
  h && (r.overflow = h);
  var f = e.get("minMargin");
  f != null && (r.margin = f), PM(r, e, o, t, i, n, !0, !1);
}
function Bse(r) {
  for (var e; r && r !== r.ecModel; ) {
    var t = (r.option || TT).rich;
    if (t) {
      e = e || {};
      for (var i = Ze(t), n = 0; n < i.length; n++) {
        var a = i[n];
        e[a] = 1;
      }
    }
    r = r.parentModel;
  }
  return e;
}
var wM = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], NM = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], xM = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function PM(r, e, t, i, n, a, o, s) {
  t = !n && t || TT;
  var l = i && i.inheritColor, u = e.getShallow("color"), c = e.getShallow("textBorderColor"), h = ke(e.getShallow("opacity"), t.opacity);
  (u === "inherit" || u === "auto") && ({}.NODE_ENV !== "production" && u === "auto" && fr("color: 'auto'", "color: 'inherit'"), l ? u = l : u = null), (c === "inherit" || c === "auto") && ({}.NODE_ENV !== "production" && c === "auto" && fr("color: 'auto'", "color: 'inherit'"), l ? c = l : c = null), a || (u = u || t.color, c = c || t.textBorderColor), u != null && (r.fill = u), c != null && (r.stroke = c);
  var f = ke(e.getShallow("textBorderWidth"), t.textBorderWidth);
  f != null && (r.lineWidth = f);
  var d = ke(e.getShallow("textBorderType"), t.textBorderType);
  d != null && (r.lineDash = d);
  var p = ke(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset);
  p != null && (r.lineDashOffset = p), !n && h == null && !s && (h = i && i.defaultOpacity), h != null && (r.opacity = h), !n && !a && r.fill == null && i.inheritColor && (r.fill = i.inheritColor);
  for (var g = 0; g < wM.length; g++) {
    var v = wM[g], O = ke(e.getShallow(v), t[v]);
    O != null && (r[v] = O);
  }
  for (var g = 0; g < NM.length; g++) {
    var v = NM[g], O = e.getShallow(v);
    O != null && (r[v] = O);
  }
  if (r.verticalAlign == null) {
    var m = e.getShallow("baseline");
    m != null && (r.verticalAlign = m);
  }
  if (!o || !i.disableBox) {
    for (var g = 0; g < xM.length; g++) {
      var v = xM[g], O = e.getShallow(v);
      O != null && (r[v] = O);
    }
    var E = e.getShallow("borderType");
    E != null && (r.borderDash = E), (r.backgroundColor === "auto" || r.backgroundColor === "inherit") && l && ({}.NODE_ENV !== "production" && r.backgroundColor === "auto" && fr("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), r.backgroundColor = l), (r.borderColor === "auto" || r.borderColor === "inherit") && l && ({}.NODE_ENV !== "production" && r.borderColor === "auto" && fr("borderColor: 'auto'", "borderColor: 'inherit'"), r.borderColor = l);
  }
}
function ZH(r, e) {
  var t = e && e.getModel("textStyle");
  return Ea([
    // FIXME in node-canvas fontWeight is before fontStyle
    r.fontStyle || t && t.getShallow("fontStyle") || "",
    r.fontWeight || t && t.getShallow("fontWeight") || "",
    (r.fontSize || t && t.getShallow("fontSize") || 12) + "px",
    r.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var td = ft();
function qH(r, e, t, i) {
  if (r) {
    var n = td(r);
    n.prevValue = n.value, n.value = t;
    var a = e.normal;
    n.valueAnimation = a.get("valueAnimation"), n.valueAnimation && (n.precision = a.get("precision"), n.defaultInterpolatedText = i, n.statesModels = e);
  }
}
function jH(r, e, t, i, n) {
  var a = td(r);
  if (!a.valueAnimation || a.prevValue === a.value)
    return;
  var o = a.defaultInterpolatedText, s = ke(a.interpolatedValue, a.prevValue), l = a.value;
  function u(c) {
    var h = KY(t, a.precision, s, l, c);
    a.interpolatedValue = c === 1 ? null : h;
    var f = sC({
      labelDataIndex: e,
      labelFetcher: n,
      defaultText: o ? o(h) : h + ""
    }, a.statesModels, h);
    zH(r, f);
  }
  r.percent = 0, (a.prevValue == null ? Bt : Ot)(r, {
    // percent is used to prevent animation from being aborted #15916
    percent: 1
  }, i, e, null, u);
}
var Fse = ["textStyle", "color"], T0 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], y0 = new dt(), Xse = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getTextColor = function(e) {
      var t = this.ecModel;
      return this.getShallow("color") || (!e && t ? t.get(Fse) : null);
    }, r.prototype.getFont = function() {
      return ZH({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, r.prototype.getTextRect = function(e) {
      for (var t = {
        text: e,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, i = 0; i < T0.length; i++)
        t[T0[i]] = this.getShallow(T0[i]);
      return y0.useStyle(t), y0.update(), y0.getBoundingRect();
    }, r;
  }()
);
const Yse = Xse;
var KH = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], Hse = Nc(KH), Wse = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getLineStyle = function(e) {
      return Hse(this, e);
    }, r;
  }()
), JH = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], zse = Nc(JH), Zse = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getItemStyle = function(e, t) {
      return zse(this, e, t);
    }, r;
  }()
), Zc = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.parentModel = t, this.ecModel = i, this.option = e;
    }
    return r.prototype.init = function(e, t, i) {
    }, r.prototype.mergeOption = function(e, t) {
      $e(this.option, e, !0);
    }, r.prototype.get = function(e, t) {
      return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel);
    }, r.prototype.getShallow = function(e, t) {
      var i = this.option, n = i == null ? i : i[e];
      if (n == null && !t) {
        var a = this.parentModel;
        a && (n = a.getShallow(e));
      }
      return n;
    }, r.prototype.getModel = function(e, t) {
      var i = e != null, n = i ? this.parsePath(e) : null, a = i ? this._doGet(n) : this.option;
      return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(n)), new r(a, t, this.ecModel);
    }, r.prototype.isEmpty = function() {
      return this.option == null;
    }, r.prototype.restoreData = function() {
    }, r.prototype.clone = function() {
      var e = this.constructor;
      return new e(ye(this.option));
    }, r.prototype.parsePath = function(e) {
      return typeof e == "string" ? e.split(".") : e;
    }, r.prototype.resolveParentPath = function(e) {
      return e;
    }, r.prototype.isAnimationEnabled = function() {
      if (!ct.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, r.prototype._doGet = function(e, t) {
      var i = this.option;
      if (!e)
        return i;
      for (var n = 0; n < e.length && !(e[n] && (i = i && typeof i == "object" ? i[e[n]] : null, i == null)); n++)
        ;
      return i == null && t && (i = t._doGet(this.resolveParentPath(e), t.parentModel)), i;
    }, r;
  }()
);
$1(Zc);
Zae(Zc);
br(Zc, Wse);
br(Zc, Zse);
br(Zc, eoe);
br(Zc, Yse);
const Ut = Zc;
var qse = Math.round(Math.random() * 10);
function rd(r) {
  return [r || "", qse++].join("_");
}
function jse(r) {
  var e = {};
  r.registerSubTypeDefaulter = function(t, i) {
    var n = so(t);
    e[n.main] = i;
  }, r.determineSubType = function(t, i) {
    var n = i.type;
    if (!n) {
      var a = so(t).main;
      r.hasSubTypes(t) && e[a] && (n = e[a](i));
    }
    return n;
  };
}
function Kse(r, e) {
  r.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = t(o), c = u.graph, h = u.noEntryList, f = {};
    for (N(a, function(m) {
      f[m] = !0;
    }); h.length; ) {
      var d = h.pop(), p = c[d], g = !!f[d];
      g && (s.call(l, d, p.originalDeps.slice()), delete f[d]), N(p.successor, g ? O : v);
    }
    N(f, function() {
      var m = "";
      throw {}.NODE_ENV !== "production" && (m = Ui("Circular dependency may exists: ", f, a, o)), new Error(m);
    });
    function v(m) {
      c[m].entryCount--, c[m].entryCount === 0 && h.push(m);
    }
    function O(m) {
      f[m] = !0, v(m);
    }
  };
  function t(a) {
    var o = {}, s = [];
    return N(a, function(l) {
      var u = i(o, l), c = u.originalDeps = e(l), h = n(c, a);
      u.entryCount = h.length, u.entryCount === 0 && s.push(l), N(h, function(f) {
        Fe(u.predecessor, f) < 0 && u.predecessor.push(f);
        var d = i(o, f);
        Fe(d.successor, f) < 0 && d.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function i(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function n(a, o) {
    var s = [];
    return N(a, function(l) {
      Fe(o, l) >= 0 && s.push(l);
    }), s;
  }
}
function Zl(r, e) {
  return $e($e({}, r, !0), e, !0);
}
const Jse = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, ele = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var hb = "ZH", K1 = "EN", Lg = K1, eE = {}, J1 = {}, eW = ct.domSupported ? function() {
  var r = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase()
  );
  return r.indexOf(hb) > -1 ? hb : Lg;
}() : Lg;
function tW(r, e) {
  r = r.toUpperCase(), J1[r] = new Ut(e), eE[r] = e;
}
function tle(r) {
  if (ne(r)) {
    var e = eE[r.toUpperCase()] || {};
    return r === hb || r === K1 ? ye(e) : $e(ye(e), ye(eE[Lg]), !1);
  } else
    return $e(ye(r), ye(eE[Lg]), !1);
}
function lC(r) {
  return J1[r];
}
function rle() {
  return J1[Lg];
}
tW(K1, Jse);
tW(hb, ele);
var eN = 1e3, tN = eN * 60, jp = tN * 60, Yn = jp * 24, LM = Yn * 365, Ep = {
  year: "{yyyy}",
  month: "{MMM}",
  day: "{d}",
  hour: "{HH}:{mm}",
  minute: "{HH}:{mm}",
  second: "{HH}:{mm}:{ss}",
  millisecond: "{HH}:{mm}:{ss} {SSS}",
  none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}"
}, PO = "{yyyy}-{MM}-{dd}", DM = {
  year: "{yyyy}",
  month: "{yyyy}-{MM}",
  day: PO,
  hour: PO + " " + Ep.hour,
  minute: PO + " " + Ep.minute,
  second: PO + " " + Ep.second,
  millisecond: Ep.none
}, R0 = ["year", "month", "day", "hour", "minute", "second", "millisecond"], rW = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"];
function xs(r, e) {
  return r += "", "0000".substr(0, e - r.length) + r;
}
function lf(r) {
  switch (r) {
    case "half-year":
    case "quarter":
      return "month";
    case "week":
    case "half-week":
      return "day";
    case "half-day":
    case "quarter-day":
      return "hour";
    default:
      return r;
  }
}
function ile(r) {
  return r === lf(r);
}
function nle(r) {
  switch (r) {
    case "year":
    case "month":
      return "day";
    case "millisecond":
      return "millisecond";
    default:
      return "second";
  }
}
function yT(r, e, t, i) {
  var n = Ao(r), a = n[rN(t)](), o = n[uf(t)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = n[RT(t)](), u = n["get" + (t ? "UTC" : "") + "Day"](), c = n[Dg(t)](), h = (c - 1) % 12 + 1, f = n[AT(t)](), d = n[_T(t)](), p = n[CT(t)](), g = i instanceof Ut ? i : lC(i || eW) || rle(), v = g.getModel("time"), O = v.get("month"), m = v.get("monthAbbr"), E = v.get("dayOfWeek"), b = v.get("dayOfWeekAbbr");
  return (e || "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, xs(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, O[o - 1]).replace(/{MMM}/g, m[o - 1]).replace(/{MM}/g, xs(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, xs(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, E[u]).replace(/{ee}/g, b[u]).replace(/{e}/g, u + "").replace(/{HH}/g, xs(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, xs(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, xs(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, xs(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, xs(p, 3)).replace(/{S}/g, p + "");
}
function ale(r, e, t, i, n) {
  var a = null;
  if (ne(t))
    a = t;
  else if (ve(t))
    a = t(r.value, e, {
      level: r.level
    });
  else {
    var o = B({}, Ep);
    if (r.level > 0)
      for (var s = 0; s < R0.length; ++s)
        o[R0[s]] = "{primary|" + o[R0[s]] + "}";
    var l = t ? t.inherit === !1 ? t : Te(t, o) : o, u = iW(r.value, n);
    if (l[u])
      a = l[u];
    else if (l.inherit) {
      for (var c = rW.indexOf(u), s = c - 1; s >= 0; --s)
        if (l[u]) {
          a = l[u];
          break;
        }
      a = a || o.none;
    }
    if (X(a)) {
      var h = r.level == null ? 0 : r.level >= 0 ? r.level : a.length + r.level;
      h = Math.min(h, a.length - 1), a = a[h];
    }
  }
  return yT(new Date(r.value), a, n, i);
}
function iW(r, e) {
  var t = Ao(r), i = t[uf(e)]() + 1, n = t[RT(e)](), a = t[Dg(e)](), o = t[AT(e)](), s = t[_T(e)](), l = t[CT(e)](), u = l === 0, c = u && s === 0, h = c && o === 0, f = h && a === 0, d = f && n === 1, p = d && i === 1;
  return p ? "year" : d ? "month" : f ? "day" : h ? "hour" : c ? "minute" : u ? "second" : "millisecond";
}
function MM(r, e, t) {
  var i = pt(r) ? Ao(r) : r;
  switch (e = e || iW(r, t), e) {
    case "year":
      return i[rN(t)]();
    case "half-year":
      return i[uf(t)]() >= 6 ? 1 : 0;
    case "quarter":
      return Math.floor((i[uf(t)]() + 1) / 4);
    case "month":
      return i[uf(t)]();
    case "day":
      return i[RT(t)]();
    case "half-day":
      return i[Dg(t)]() / 24;
    case "hour":
      return i[Dg(t)]();
    case "minute":
      return i[AT(t)]();
    case "second":
      return i[_T(t)]();
    case "millisecond":
      return i[CT(t)]();
  }
}
function rN(r) {
  return r ? "getUTCFullYear" : "getFullYear";
}
function uf(r) {
  return r ? "getUTCMonth" : "getMonth";
}
function RT(r) {
  return r ? "getUTCDate" : "getDate";
}
function Dg(r) {
  return r ? "getUTCHours" : "getHours";
}
function AT(r) {
  return r ? "getUTCMinutes" : "getMinutes";
}
function _T(r) {
  return r ? "getUTCSeconds" : "getSeconds";
}
function CT(r) {
  return r ? "getUTCMilliseconds" : "getMilliseconds";
}
function ole(r) {
  return r ? "setUTCFullYear" : "setFullYear";
}
function nW(r) {
  return r ? "setUTCMonth" : "setMonth";
}
function aW(r) {
  return r ? "setUTCDate" : "setDate";
}
function oW(r) {
  return r ? "setUTCHours" : "setHours";
}
function sW(r) {
  return r ? "setUTCMinutes" : "setMinutes";
}
function lW(r) {
  return r ? "setUTCSeconds" : "setSeconds";
}
function uW(r) {
  return r ? "setUTCMilliseconds" : "setMilliseconds";
}
function cW(r) {
  if (!k1(r))
    return ne(r) ? r : "-";
  var e = (r + "").split(".");
  return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "");
}
function hW(r, e) {
  return r = (r || "").toLowerCase().replace(/-(.)/g, function(t, i) {
    return i.toUpperCase();
  }), e && r && (r = r.charAt(0).toUpperCase() + r.slice(1)), r;
}
var id = I1;
function uC(r, e, t) {
  var i = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function n(c) {
    return c && Ea(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var o = e === "time", s = r instanceof Date;
  if (o || s) {
    var l = o ? Ao(r) : r;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else
      return yT(l, i, t);
  }
  if (e === "ordinal")
    return zE(r) ? n(r) : pt(r) && a(r) ? r + "" : "-";
  var u = ss(r);
  return a(u) ? cW(u) : zE(r) ? n(r) : typeof r == "boolean" ? r + "" : "-";
}
var kM = ["a", "b", "c", "d", "e", "f", "g"], A0 = function(r, e) {
  return "{" + r + (e ?? "") + "}";
};
function fW(r, e, t) {
  X(e) || (e = [e]);
  var i = e.length;
  if (!i)
    return "";
  for (var n = e[0].$vars || [], a = 0; a < n.length; a++) {
    var o = kM[a];
    r = r.replace(A0(o), A0(o, 0));
  }
  for (var s = 0; s < i; s++)
    for (var l = 0; l < n.length; l++) {
      var u = e[s][n[l]];
      r = r.replace(A0(kM[l], s), t ? Yi(u) : u);
    }
  return r;
}
function sle(r, e, t) {
  return N(e, function(i, n) {
    r = r.replace("{" + n + "}", t ? Yi(i) : i);
  }), r;
}
function lle(r, e) {
  var t = ne(r) ? {
    color: r,
    extraCssText: e
  } : r || {}, i = t.color, n = t.type;
  e = t.extraCssText;
  var a = t.renderMode || "html";
  if (!i)
    return "";
  if (a === "html")
    return n === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Yi(i) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Yi(i) + ";" + (e || "") + '"></span>';
  var o = t.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: n === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: i
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: i
    }
  };
}
function Pc(r, e) {
  return e = e || "transparent", ne(r) ? r : be(r) && r.colorStops && (r.colorStops[0] || {}).color || e;
}
function fb(r, e) {
  if (e === "_blank" || e === "blank") {
    var t = window.open();
    t.opener = null, t.location.href = r;
  } else
    window.open(r, e);
}
var tE = N, dW = ["left", "right", "top", "bottom", "width", "height"], qu = [["width", "left", "right"], ["height", "top", "bottom"]];
function iN(r, e, t, i, n) {
  var a = 0, o = 0;
  i == null && (i = 1 / 0), n == null && (n = 1 / 0);
  var s = 0;
  e.eachChild(function(l, u) {
    var c = l.getBoundingRect(), h = e.childAt(u + 1), f = h && h.getBoundingRect(), d, p;
    if (r === "horizontal") {
      var g = c.width + (f ? -f.x + c.x : 0);
      d = a + g, d > i || l.newline ? (a = 0, d = g, o += s + t, s = c.height) : s = Math.max(s, c.height);
    } else {
      var v = c.height + (f ? -f.y + c.y : 0);
      p = o + v, p > n || l.newline ? (a += s + t, o = 0, p = v, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), r === "horizontal" ? a = d + t : o = p + t);
  });
}
var vc = iN;
Le(iN, "vertical");
Le(iN, "horizontal");
function ule(r, e, t) {
  var i = e.width, n = e.height, a = K(r.left, i), o = K(r.top, n), s = K(r.right, i), l = K(r.bottom, n);
  return (isNaN(a) || isNaN(parseFloat(r.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(r.right))) && (s = i), (isNaN(o) || isNaN(parseFloat(r.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(r.bottom))) && (l = n), t = id(t || 0), {
    width: Math.max(s - a - t[1] - t[3], 0),
    height: Math.max(l - o - t[0] - t[2], 0)
  };
}
function Ir(r, e, t) {
  t = id(t || 0);
  var i = e.width, n = e.height, a = K(r.left, i), o = K(r.top, n), s = K(r.right, i), l = K(r.bottom, n), u = K(r.width, i), c = K(r.height, n), h = t[2] + t[0], f = t[1] + t[3], d = r.aspect;
  switch (isNaN(u) && (u = i - s - f - a), isNaN(c) && (c = n - l - h - o), d != null && (isNaN(u) && isNaN(c) && (d > i / n ? u = i * 0.8 : c = n * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(a) && (a = i - s - u - f), isNaN(o) && (o = n - l - c - h), r.left || r.right) {
    case "center":
      a = i / 2 - u / 2 - t[3];
      break;
    case "right":
      a = i - u - f;
      break;
  }
  switch (r.top || r.bottom) {
    case "middle":
    case "center":
      o = n / 2 - c / 2 - t[0];
      break;
    case "bottom":
      o = n - c - h;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = i - f - a - (s || 0)), isNaN(c) && (c = n - h - o - (l || 0));
  var p = new Ve(a + t[3], o + t[0], u, c);
  return p.margin = t, p;
}
function IT(r, e, t, i, n, a) {
  var o = !n || !n.hv || n.hv[0], s = !n || !n.hv || n.hv[1], l = n && n.boundingMode || "all";
  if (a = a || r, a.x = r.x, a.y = r.y, !o && !s)
    return !1;
  var u;
  if (l === "raw")
    u = r.type === "group" ? new Ve(0, 0, +e.width || 0, +e.height || 0) : r.getBoundingRect();
  else if (u = r.getBoundingRect(), r.needLocalTransform()) {
    var c = r.getLocalTransform();
    u = u.clone(), u.applyTransform(c);
  }
  var h = Ir(Te({
    width: u.width,
    height: u.height
  }, e), t, i), f = o ? h.x - u.x : 0, d = s ? h.y - u.y : 0;
  return l === "raw" ? (a.x = f, a.y = d) : (a.x += f, a.y += d), a === r && r.markRedraw(), !0;
}
function cle(r, e) {
  return r[qu[e][0]] != null || r[qu[e][1]] != null && r[qu[e][2]] != null;
}
function Mg(r) {
  var e = r.layoutMode || r.constructor.layoutMode;
  return be(e) ? e : e ? {
    type: e
  } : null;
}
function Pl(r, e, t) {
  var i = t && t.ignoreSize;
  !X(i) && (i = [i, i]);
  var n = o(qu[0], 0), a = o(qu[1], 1);
  u(qu[0], r, n), u(qu[1], r, a);
  function o(c, h) {
    var f = {}, d = 0, p = {}, g = 0, v = 2;
    if (tE(c, function(E) {
      p[E] = r[E];
    }), tE(c, function(E) {
      s(e, E) && (f[E] = p[E] = e[E]), l(f, E) && d++, l(p, E) && g++;
    }), i[h])
      return l(e, c[1]) ? p[c[2]] = null : l(e, c[2]) && (p[c[1]] = null), p;
    if (g === v || !d)
      return p;
    if (d >= v)
      return f;
    for (var O = 0; O < c.length; O++) {
      var m = c[O];
      if (!s(f, m) && s(r, m)) {
        f[m] = r[m];
        break;
      }
    }
    return f;
  }
  function s(c, h) {
    return c.hasOwnProperty(h);
  }
  function l(c, h) {
    return c[h] != null && c[h] !== "auto";
  }
  function u(c, h, f) {
    tE(c, function(d) {
      h[d] = f[d];
    });
  }
}
function nd(r) {
  return pW({}, r);
}
function pW(r, e) {
  return e && r && tE(dW, function(t) {
    e.hasOwnProperty(t) && (r[t] = e[t]);
  }), r;
}
var hle = ft(), ad = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this, t, i, n) || this;
      return a.uid = rd("ec_cpt_model"), a;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n);
    }, e.prototype.mergeDefaultAndTheme = function(t, i) {
      var n = Mg(this), a = n ? nd(t) : {}, o = i.getTheme();
      $e(t, o.get(this.mainType)), $e(t, this.getDefaultOption()), n && Pl(t, a, n);
    }, e.prototype.mergeOption = function(t, i) {
      $e(this.option, t, !0);
      var n = Mg(this);
      n && Pl(this.option, t, n);
    }, e.prototype.optionUpdated = function(t, i) {
    }, e.prototype.getDefaultOption = function() {
      var t = this.constructor;
      if (!Hae(t))
        return t.defaultOption;
      var i = hle(this);
      if (!i.defaultOption) {
        for (var n = [], a = t; a; ) {
          var o = a.prototype.defaultOption;
          o && n.push(o), a = a.superClass;
        }
        for (var s = {}, l = n.length - 1; l >= 0; l--)
          s = $e(s, n[l], !0);
        i.defaultOption = s;
      }
      return i.defaultOption;
    }, e.prototype.getReferringComponents = function(t, i) {
      var n = t + "Index", a = t + "Id";
      return Rv(this.ecModel, t, {
        index: this.get(n, !0),
        id: this.get(a, !0)
      }, i);
    }, e.prototype.getBoxLayoutParams = function() {
      var t = this;
      return {
        left: t.get("left"),
        top: t.get("top"),
        right: t.get("right"),
        bottom: t.get("bottom"),
        width: t.get("width"),
        height: t.get("height")
      };
    }, e.prototype.getZLevelKey = function() {
      return "";
    }, e.prototype.setZLevel = function(t) {
      this.option.zlevel = t;
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0;
    }(), e;
  }(Ut)
);
eH(ad, Ut);
fT(ad);
jse(ad);
Kse(ad, fle);
function fle(r) {
  var e = [];
  return N(ad.getClassesByMainType(r), function(t) {
    e = e.concat(t.dependencies || t.prototype.dependencies || []);
  }), e = Y(e, function(t) {
    return so(t).main;
  }), r !== "dataset" && Fe(e, "dataset") <= 0 && e.unshift("dataset"), e;
}
const st = ad;
var gW = "";
typeof navigator < "u" && (gW = navigator.platform || "");
var vh = "rgba(0, 0, 0, 0.2)";
const dle = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"],
  gradientColor: ["#f6efa6", "#d88273", "#bf444c"],
  aria: {
    decal: {
      decals: [{
        color: vh,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: vh,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: vh,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: vh,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: vh,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: vh,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: gW.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var cC = de(["tooltip", "label", "itemName", "itemId", "itemGroupId", "seriesName"]), sa = "original", Ei = "arrayRows", la = "objectRows", xo = "keyedColumns", Ko = "typedArray", vW = "unknown", vo = "column", od = "row", Wr = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, OW = ft();
function ple(r) {
  OW(r).datasetMap = de();
}
function mW(r, e, t) {
  var i = {}, n = aN(e);
  if (!n || !r)
    return i;
  var a = [], o = [], s = e.ecModel, l = OW(s).datasetMap, u = n.uid + "_" + t.seriesLayoutBy, c, h;
  r = r.slice(), N(r, function(g, v) {
    var O = be(g) ? g : r[v] = {
      name: g
    };
    O.type === "ordinal" && c == null && (c = v, h = p(O)), i[O.name] = [];
  });
  var f = l.get(u) || l.set(u, {
    categoryWayDim: h,
    valueWayDim: 0
  });
  N(r, function(g, v) {
    var O = g.name, m = p(g);
    if (c == null) {
      var E = f.valueWayDim;
      d(i[O], E, m), d(o, E, m), f.valueWayDim += m;
    } else if (c === v)
      d(i[O], 0, m), d(a, 0, m);
    else {
      var E = f.categoryWayDim;
      d(i[O], E, m), d(o, E, m), f.categoryWayDim += m;
    }
  });
  function d(g, v, O) {
    for (var m = 0; m < O; m++)
      g.push(v + m);
  }
  function p(g) {
    var v = g.dimsDef;
    return v ? v.length : 1;
  }
  return a.length && (i.itemName = a), o.length && (i.seriesName = o), i;
}
function nN(r, e, t) {
  var i = {}, n = aN(r);
  if (!n)
    return i;
  var a = e.sourceFormat, o = e.dimensionsDefine, s;
  (a === la || a === xo) && N(o, function(c, h) {
    (be(c) ? c.name : c) === "name" && (s = h);
  });
  var l = function() {
    for (var c = {}, h = {}, f = [], d = 0, p = Math.min(5, t); d < p; d++) {
      var g = bW(e.data, a, e.seriesLayoutBy, o, e.startIndex, d);
      f.push(g);
      var v = g === Wr.Not;
      if (v && c.v == null && d !== s && (c.v = d), (c.n == null || c.n === c.v || !v && f[c.n] === Wr.Not) && (c.n = d), O(c) && f[c.n] !== Wr.Not)
        return c;
      v || (g === Wr.Might && h.v == null && d !== s && (h.v = d), (h.n == null || h.n === h.v) && (h.n = d));
    }
    function O(m) {
      return m.v != null && m.n != null;
    }
    return O(c) ? c : O(h) ? h : null;
  }();
  if (l) {
    i.value = [l.v];
    var u = s ?? l.n;
    i.itemName = [u], i.seriesName = [u];
  }
  return i;
}
function aN(r) {
  var e = r.get("data", !0);
  if (!e)
    return Rv(r.ecModel, "dataset", {
      index: r.get("datasetIndex", !0),
      id: r.get("datasetId", !0)
    }, Or).models[0];
}
function gle(r) {
  return !r.get("transform", !0) && !r.get("fromTransformResult", !0) ? [] : Rv(r.ecModel, "dataset", {
    index: r.get("fromDatasetIndex", !0),
    id: r.get("fromDatasetId", !0)
  }, Or).models;
}
function EW(r, e) {
  return bW(r.data, r.sourceFormat, r.seriesLayoutBy, r.dimensionsDefine, r.startIndex, e);
}
function bW(r, e, t, i, n, a) {
  var o, s = 5;
  if (en(r))
    return Wr.Not;
  var l, u;
  if (i) {
    var c = i[a];
    be(c) ? (l = c.name, u = c.type) : ne(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? Wr.Must : Wr.Not;
  if (e === Ei) {
    var h = r;
    if (t === od) {
      for (var f = h[a], d = 0; d < (f || []).length && d < s; d++)
        if ((o = b(f[n + d])) != null)
          return o;
    } else
      for (var d = 0; d < h.length && d < s; d++) {
        var p = h[n + d];
        if (p && (o = b(p[a])) != null)
          return o;
      }
  } else if (e === la) {
    var g = r;
    if (!l)
      return Wr.Not;
    for (var d = 0; d < g.length && d < s; d++) {
      var v = g[d];
      if (v && (o = b(v[l])) != null)
        return o;
    }
  } else if (e === xo) {
    var O = r;
    if (!l)
      return Wr.Not;
    var f = O[l];
    if (!f || en(f))
      return Wr.Not;
    for (var d = 0; d < f.length && d < s; d++)
      if ((o = b(f[d])) != null)
        return o;
  } else if (e === sa)
    for (var m = r, d = 0; d < m.length && d < s; d++) {
      var v = m[d], E = jf(v);
      if (!X(E))
        return Wr.Not;
      if ((o = b(E[a])) != null)
        return o;
    }
  function b(S) {
    var T = ne(S);
    if (S != null && isFinite(S) && S !== "")
      return T ? Wr.Might : Wr.Not;
    if (T && S !== "-")
      return Wr.Must;
  }
  return Wr.Not;
}
var hC = de();
function vle(r, e) {
  Se(hC.get(r) == null && e), hC.set(r, e);
}
function Ole(r, e, t) {
  var i = hC.get(e);
  if (!i)
    return t;
  var n = i(r);
  if (!n)
    return t;
  if ({}.NODE_ENV !== "production")
    for (var a = 0; a < n.length; a++)
      Se(If(n[a]));
  return t.concat(n);
}
var QM = ft(), mle = ft(), oN = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getColorFromPalette = function(e, t, i) {
      var n = It(this.get("color", !0)), a = this.get("colorLayer", !0);
      return SW(this, QM, n, a, e, t, i);
    }, r.prototype.clearColorPalette = function() {
      ble(this, QM);
    }, r;
  }()
);
function fC(r, e, t, i) {
  var n = It(r.get(["aria", "decal", "decals"]));
  return SW(r, mle, n, null, e, t, i);
}
function Ele(r, e) {
  for (var t = r.length, i = 0; i < t; i++)
    if (r[i].length > e)
      return r[i];
  return r[t - 1];
}
function SW(r, e, t, i, n, a, o) {
  a = a || r;
  var s = e(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(n))
    return u[n];
  var c = o == null || !i ? t : Ele(i, o);
  if (c = c || t, !(!c || !c.length)) {
    var h = c[l];
    return n && (u[n] = h), s.paletteIdx = (l + 1) % c.length, h;
  }
}
function ble(r, e) {
  e(r).paletteIdx = 0, e(r).paletteNameMap = {};
}
var LO, Ld, UM, _0 = "\0_ec_inner", $M = 1, Sle = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, Tle = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, db = {};
function yle(r) {
  N(r, function(e, t) {
    if (!st.hasClass(t)) {
      var i = Sle[t];
      i && !db[i] && (ti("Component " + t + ` is used but not imported.
import { ` + i + ` } from 'echarts/components';
echarts.use([` + i + "]);"), db[i] = !0);
    }
  });
}
var TW = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t, i, n, a, o, s) {
      a = a || {}, this.option = null, this._theme = new Ut(a), this._locale = new Ut(o), this._optionManager = s;
    }, e.prototype.setOption = function(t, i, n) {
      ({}).NODE_ENV !== "production" && (Se(t != null, "option is null/undefined"), Se(t[_0] !== $M, "please use chart.getOption()"));
      var a = BM(i);
      this._optionManager.setOption(t, n, a), this._resetOption(null, a);
    }, e.prototype.resetOption = function(t, i) {
      return this._resetOption(t, BM(i));
    }, e.prototype._resetOption = function(t, i) {
      var n = !1, a = this._optionManager;
      if (!t || t === "recreate") {
        var o = a.mountOption(t === "recreate");
        ({}).NODE_ENV !== "production" && yle(o), !this.option || t === "recreate" ? UM(this, o) : (this.restoreData(), this._mergeOption(o, i)), n = !0;
      }
      if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") {
        var s = a.getTimelineOption(this);
        s && (n = !0, this._mergeOption(s, i));
      }
      if (!t || t === "recreate" || t === "media") {
        var l = a.getMediaOption(this);
        l.length && N(l, function(u) {
          n = !0, this._mergeOption(u, i);
        }, this);
      }
      return n;
    }, e.prototype.mergeOption = function(t) {
      this._mergeOption(t, null);
    }, e.prototype._mergeOption = function(t, i) {
      var n = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = de(), u = i && i.replaceMergeMainTypeMap;
      ple(this), N(t, function(h, f) {
        h != null && (st.hasClass(f) ? f && (s.push(f), l.set(f, !0)) : n[f] = n[f] == null ? ye(h) : $e(n[f], h, !0));
      }), u && u.each(function(h, f) {
        st.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, !0));
      }), st.topologicalTravel(s, st.getAllClassMainTypes(), c, this);
      function c(h) {
        var f = Ole(this, h, It(t[h])), d = a.get(h), p = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          d ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = qY(d, f, p);
        Qae(g, h, st), n[h] = null, a.set(h, null), o.set(h, 0);
        var v = [], O = [], m = 0, E, b;
        N(g, function(S, T) {
          var y = S.existing, R = S.newOption;
          if (!R)
            y && (y.mergeOption({}, this), y.optionUpdated({}, !1));
          else {
            var _ = h === "series", C = st.getClass(
              h,
              S.keyInfo.subType,
              !_
              // Give a more detailed warn later if series don't exists
            );
            if (!C) {
              if ({}.NODE_ENV !== "production") {
                var I = S.keyInfo.subType, w = Tle[I];
                db[I] || (db[I] = !0, ti(w ? "Series " + I + ` is used but not imported.
import { ` + w + ` } from 'echarts/charts';
echarts.use([` + w + "]);" : "Unknown series " + I));
              }
              return;
            }
            if (h === "tooltip") {
              if (E) {
                ({}).NODE_ENV !== "production" && (b || (tr("Currently only one tooltip component is allowed."), b = !0));
                return;
              }
              E = !0;
            }
            if (y && y.constructor === C)
              y.name = S.keyInfo.name, y.mergeOption(R, this), y.optionUpdated(R, !1);
            else {
              var x = B({
                componentIndex: T
              }, S.keyInfo);
              y = new C(R, this, this, x), B(y, x), S.brandNew && (y.__requireNewView = !0), y.init(R, this, this), y.optionUpdated(null, !0);
            }
          }
          y ? (v.push(y.option), O.push(y), m++) : (v.push(void 0), O.push(void 0));
        }, this), n[h] = v, a.set(h, O), o.set(h, m), h === "series" && LO(this);
      }
      this._seriesIndices || LO(this);
    }, e.prototype.getOption = function() {
      var t = ye(this.option);
      return N(t, function(i, n) {
        if (st.hasClass(n)) {
          for (var a = It(i), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !If(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, t[n] = a;
        }
      }), delete t[_0], t;
    }, e.prototype.getTheme = function() {
      return this._theme;
    }, e.prototype.getLocaleModel = function() {
      return this._locale;
    }, e.prototype.setUpdatePayload = function(t) {
      this._payload = t;
    }, e.prototype.getUpdatePayload = function() {
      return this._payload;
    }, e.prototype.getComponent = function(t, i) {
      var n = this._componentsMap.get(t);
      if (n) {
        var a = n[i || 0];
        if (a)
          return a;
        if (i == null) {
          for (var o = 0; o < n.length; o++)
            if (n[o])
              return n[o];
        }
      }
    }, e.prototype.queryComponents = function(t) {
      var i = t.mainType;
      if (!i)
        return [];
      var n = t.index, a = t.id, o = t.name, s = this._componentsMap.get(i);
      if (!s || !s.length)
        return [];
      var l;
      return n != null ? (l = [], N(It(n), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = VM("id", a, s) : o != null ? l = VM("name", o, s) : l = At(s, function(u) {
        return !!u;
      }), GM(l, t);
    }, e.prototype.findComponents = function(t) {
      var i = t.query, n = t.mainType, a = s(i), o = a ? this.queryComponents(a) : At(this._componentsMap.get(n), function(u) {
        return !!u;
      });
      return l(GM(o, t));
      function s(u) {
        var c = n + "Index", h = n + "Id", f = n + "Name";
        return u && (u[c] != null || u[h] != null || u[f] != null) ? {
          mainType: n,
          // subType will be filtered finally.
          index: u[c],
          id: u[h],
          name: u[f]
        } : null;
      }
      function l(u) {
        return t.filter ? At(u, t.filter) : u;
      }
    }, e.prototype.eachComponent = function(t, i, n) {
      var a = this._componentsMap;
      if (ve(t)) {
        var o = i, s = t;
        a.each(function(h, f) {
          for (var d = 0; h && d < h.length; d++) {
            var p = h[d];
            p && s.call(o, f, p, p.componentIndex);
          }
        });
      } else
        for (var l = ne(t) ? a.get(t) : be(t) ? this.findComponents(t) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && i.call(n, c, c.componentIndex);
        }
    }, e.prototype.getSeriesByName = function(t) {
      var i = Ar(t, null);
      return At(this._componentsMap.get("series"), function(n) {
        return !!n && i != null && n.name === i;
      });
    }, e.prototype.getSeriesByIndex = function(t) {
      return this._componentsMap.get("series")[t];
    }, e.prototype.getSeriesByType = function(t) {
      return At(this._componentsMap.get("series"), function(i) {
        return !!i && i.subType === t;
      });
    }, e.prototype.getSeries = function() {
      return At(this._componentsMap.get("series"), function(t) {
        return !!t;
      });
    }, e.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, e.prototype.eachSeries = function(t, i) {
      Ld(this), N(this._seriesIndices, function(n) {
        var a = this._componentsMap.get("series")[n];
        t.call(i, a, n);
      }, this);
    }, e.prototype.eachRawSeries = function(t, i) {
      N(this._componentsMap.get("series"), function(n) {
        n && t.call(i, n, n.componentIndex);
      });
    }, e.prototype.eachSeriesByType = function(t, i, n) {
      Ld(this), N(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === t && i.call(n, o, a);
      }, this);
    }, e.prototype.eachRawSeriesByType = function(t, i, n) {
      return N(this.getSeriesByType(t), i, n);
    }, e.prototype.isSeriesFiltered = function(t) {
      return Ld(this), this._seriesIndicesMap.get(t.componentIndex) == null;
    }, e.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, e.prototype.filterSeries = function(t, i) {
      Ld(this);
      var n = [];
      N(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        t.call(i, o, a) && n.push(a);
      }, this), this._seriesIndices = n, this._seriesIndicesMap = de(n);
    }, e.prototype.restoreData = function(t) {
      LO(this);
      var i = this._componentsMap, n = [];
      i.each(function(a, o) {
        st.hasClass(o) && n.push(o);
      }), st.topologicalTravel(n, st.getAllClassMainTypes(), function(a) {
        N(i.get(a), function(o) {
          o && (a !== "series" || !Rle(o, t)) && o.restoreData();
        });
      });
    }, e.internalField = function() {
      LO = function(t) {
        var i = t._seriesIndices = [];
        N(t._componentsMap.get("series"), function(n) {
          n && i.push(n.componentIndex);
        }), t._seriesIndicesMap = de(i);
      }, Ld = function(t) {
        if ({}.NODE_ENV !== "production" && !t._seriesIndices)
          throw new Error("Option should contains series.");
      }, UM = function(t, i) {
        t.option = {}, t.option[_0] = $M, t._componentsMap = de({
          series: []
        }), t._componentsCount = de();
        var n = i.aria;
        be(n) && n.enabled == null && (n.enabled = !0), Ale(i, t._theme.option), $e(i, dle, !1), t._mergeOption(i, null);
      };
    }(), e;
  }(Ut)
);
function Rle(r, e) {
  if (e) {
    var t = e.seriesIndex, i = e.seriesId, n = e.seriesName;
    return t != null && r.componentIndex !== t || i != null && r.id !== i || n != null && r.name !== n;
  }
}
function Ale(r, e) {
  var t = r.color && !r.colorLayer;
  N(e, function(i, n) {
    n === "colorLayer" && t || st.hasClass(n) || (typeof i == "object" ? r[n] = r[n] ? $e(r[n], i, !1) : ye(i) : r[n] == null && (r[n] = i));
  });
}
function VM(r, e, t) {
  if (X(e)) {
    var i = de();
    return N(e, function(a) {
      if (a != null) {
        var o = Ar(a, null);
        o != null && i.set(a, !0);
      }
    }), At(t, function(a) {
      return a && i.get(a[r]);
    });
  } else {
    var n = Ar(e, null);
    return At(t, function(a) {
      return a && n != null && a[r] === n;
    });
  }
}
function GM(r, e) {
  return e.hasOwnProperty("subType") ? At(r, function(t) {
    return t && t.subType === e.subType;
  }) : r;
}
function BM(r) {
  var e = de();
  return r && N(It(r.replaceMerge), function(t) {
    ({}).NODE_ENV !== "production" && Se(st.hasClass(t), '"' + t + '" is not valid component main type in "replaceMerge"'), e.set(t, !0);
  }), {
    replaceMergeMainTypeMap: e
  };
}
br(TW, oN);
const yW = TW;
var _le = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], Cle = (
  /** @class */
  function() {
    function r(e) {
      N(_le, function(t) {
        this[t] = ue(e[t], e);
      }, this);
    }
    return r;
  }()
);
const RW = Cle;
var C0 = {}, Ile = (
  /** @class */
  function() {
    function r() {
      this._coordinateSystems = [];
    }
    return r.prototype.create = function(e, t) {
      var i = [];
      N(C0, function(n, a) {
        var o = n.create(e, t);
        i = i.concat(o || []);
      }), this._coordinateSystems = i;
    }, r.prototype.update = function(e, t) {
      N(this._coordinateSystems, function(i) {
        i.update && i.update(e, t);
      });
    }, r.prototype.getCoordinateSystems = function() {
      return this._coordinateSystems.slice();
    }, r.register = function(e, t) {
      C0[e] = t;
    }, r.get = function(e) {
      return C0[e];
    }, r;
  }()
);
const sd = Ile;
var wle = /^(min|max)?(.+)$/, Nle = (
  /** @class */
  function() {
    function r(e) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e;
    }
    return r.prototype.setOption = function(e, t, i) {
      e && (N(It(e.series), function(o) {
        o && o.data && en(o.data) && ZE(o.data);
      }), N(It(e.dataset), function(o) {
        o && o.source && en(o.source) && ZE(o.source);
      })), e = ye(e);
      var n = this._optionBackup, a = xle(e, t, !n);
      this._newBaseOption = a.baseOption, n ? (a.timelineOptions.length && (n.timelineOptions = a.timelineOptions), a.mediaList.length && (n.mediaList = a.mediaList), a.mediaDefault && (n.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, r.prototype.mountOption = function(e) {
      var t = this._optionBackup;
      return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], ye(e ? t.baseOption : this._newBaseOption);
    }, r.prototype.getTimelineOption = function(e) {
      var t, i = this._timelineOptions;
      if (i.length) {
        var n = e.getComponent("timeline");
        n && (t = ye(
          // FIXME:TS as TimelineModel or quivlant interface
          i[n.getCurrentIndex()]
        ));
      }
      return t;
    }, r.prototype.getMediaOption = function(e) {
      var t = this._api.getWidth(), i = this._api.getHeight(), n = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!n.length && !a)
        return s;
      for (var l = 0, u = n.length; l < u; l++)
        Ple(n[l].query, t, i) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !Dle(o, this._currentMediaIndices) && (s = Y(o, function(c) {
        return ye(c === -1 ? a.option : n[c].option);
      })), this._currentMediaIndices = o, s;
    }, r;
  }()
);
function xle(r, e, t) {
  var i = [], n, a, o = r.baseOption, s = r.timeline, l = r.options, u = r.media, c = !!r.media, h = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((h || c) && (r.options = r.media = null), a = r), c && (X(u) ? N(u, function(d) {
    ({}).NODE_ENV !== "production" && d && !d.option && be(d.query) && be(d.query.option) && ti("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), d && d.option && (d.query ? i.push(d) : n || (n = d));
  }) : {}.NODE_ENV !== "production" && ti("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), f(a), N(l, function(d) {
    return f(d);
  }), N(i, function(d) {
    return f(d.option);
  });
  function f(d) {
    N(e, function(p) {
      p(d, t);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: n,
    mediaList: i
  };
}
function Ple(r, e, t) {
  var i = {
    width: e,
    height: t,
    aspectratio: e / t
    // lower case for convenience.
  }, n = !0;
  return N(r, function(a, o) {
    var s = o.match(wle);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      Lle(i[u], a, l) || (n = !1);
    }
  }), n;
}
function Lle(r, e, t) {
  return t === "min" ? r >= e : t === "max" ? r <= e : r === e;
}
function Dle(r, e) {
  return r.join(",") === e.join(",");
}
const Mle = Nle;
var Nn = N, kg = be, FM = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function I0(r) {
  var e = r && r.itemStyle;
  if (e)
    for (var t = 0, i = FM.length; t < i; t++) {
      var n = FM[t], a = e.normal, o = e.emphasis;
      a && a[n] && ({}.NODE_ENV !== "production" && fr("itemStyle.normal." + n, n), r[n] = r[n] || {}, r[n].normal ? $e(r[n].normal, a[n]) : r[n].normal = a[n], a[n] = null), o && o[n] && ({}.NODE_ENV !== "production" && fr("itemStyle.emphasis." + n, "emphasis." + n), r[n] = r[n] || {}, r[n].emphasis ? $e(r[n].emphasis, o[n]) : r[n].emphasis = o[n], o[n] = null);
    }
}
function fi(r, e, t) {
  if (r && r[e] && (r[e].normal || r[e].emphasis)) {
    var i = r[e].normal, n = r[e].emphasis;
    i && ({}.NODE_ENV !== "production" && Pa("'normal' hierarchy in " + e + " has been removed since 4.0. All style properties are configured in " + e + " directly now."), t ? (r[e].normal = r[e].emphasis = null, Te(r[e], i)) : r[e] = i), n && ({}.NODE_ENV !== "production" && Pa(e + ".emphasis has been changed to emphasis." + e + " since 4.0"), r.emphasis = r.emphasis || {}, r.emphasis[e] = n, n.focus && (r.emphasis.focus = n.focus), n.blurScope && (r.emphasis.blurScope = n.blurScope));
  }
}
function bp(r) {
  fi(r, "itemStyle"), fi(r, "lineStyle"), fi(r, "areaStyle"), fi(r, "label"), fi(r, "labelLine"), fi(r, "upperLabel"), fi(r, "edgeLabel");
}
function cr(r, e) {
  var t = kg(r) && r[e], i = kg(t) && t.textStyle;
  if (i) {
    ({}).NODE_ENV !== "production" && Pa("textStyle hierarchy in " + e + " has been removed since 4.0. All textStyle properties are configured in " + e + " directly now.");
    for (var n = 0, a = YD.length; n < a; n++) {
      var o = YD[n];
      i.hasOwnProperty(o) && (t[o] = i[o]);
    }
  }
}
function Qn(r) {
  r && (bp(r), cr(r, "label"), r.emphasis && cr(r.emphasis, "label"));
}
function kle(r) {
  if (kg(r)) {
    I0(r), bp(r), cr(r, "label"), cr(r, "upperLabel"), cr(r, "edgeLabel"), r.emphasis && (cr(r.emphasis, "label"), cr(r.emphasis, "upperLabel"), cr(r.emphasis, "edgeLabel"));
    var e = r.markPoint;
    e && (I0(e), Qn(e));
    var t = r.markLine;
    t && (I0(t), Qn(t));
    var i = r.markArea;
    i && Qn(i);
    var n = r.data;
    if (r.type === "graph") {
      n = n || r.nodes;
      var a = r.links || r.edges;
      if (a && !en(a))
        for (var o = 0; o < a.length; o++)
          Qn(a[o]);
      N(r.categories, function(u) {
        bp(u);
      });
    }
    if (n && !en(n))
      for (var o = 0; o < n.length; o++)
        Qn(n[o]);
    if (e = r.markPoint, e && e.data)
      for (var s = e.data, o = 0; o < s.length; o++)
        Qn(s[o]);
    if (t = r.markLine, t && t.data)
      for (var l = t.data, o = 0; o < l.length; o++)
        X(l[o]) ? (Qn(l[o][0]), Qn(l[o][1])) : Qn(l[o]);
    r.type === "gauge" ? (cr(r, "axisLabel"), cr(r, "title"), cr(r, "detail")) : r.type === "treemap" ? (fi(r.breadcrumb, "itemStyle"), N(r.levels, function(u) {
      bp(u);
    })) : r.type === "tree" && bp(r.leaves);
  }
}
function Qo(r) {
  return X(r) ? r : r ? [r] : [];
}
function XM(r) {
  return (X(r) ? r[0] : r) || {};
}
function Qle(r, e) {
  Nn(Qo(r.series), function(i) {
    kg(i) && kle(i);
  });
  var t = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Nn(t, function(i) {
    Nn(Qo(r[i]), function(n) {
      n && (cr(n, "axisLabel"), cr(n.axisPointer, "label"));
    });
  }), Nn(Qo(r.parallel), function(i) {
    var n = i && i.parallelAxisDefault;
    cr(n, "axisLabel"), cr(n && n.axisPointer, "label");
  }), Nn(Qo(r.calendar), function(i) {
    fi(i, "itemStyle"), cr(i, "dayLabel"), cr(i, "monthLabel"), cr(i, "yearLabel");
  }), Nn(Qo(r.radar), function(i) {
    cr(i, "name"), i.name && i.axisName == null && (i.axisName = i.name, delete i.name, {}.NODE_ENV !== "production" && Pa("name property in radar component has been changed to axisName")), i.nameGap != null && i.axisNameGap == null && (i.axisNameGap = i.nameGap, delete i.nameGap, {}.NODE_ENV !== "production" && Pa("nameGap property in radar component has been changed to axisNameGap")), {}.NODE_ENV !== "production" && Nn(i.indicator, function(n) {
      n.text && fr("text", "name", "radar.indicator");
    });
  }), Nn(Qo(r.geo), function(i) {
    kg(i) && (Qn(i), Nn(Qo(i.regions), function(n) {
      Qn(n);
    }));
  }), Nn(Qo(r.timeline), function(i) {
    Qn(i), fi(i, "label"), fi(i, "itemStyle"), fi(i, "controlStyle", !0);
    var n = i.data;
    X(n) && N(n, function(a) {
      be(a) && (fi(a, "label"), fi(a, "itemStyle"));
    });
  }), Nn(Qo(r.toolbox), function(i) {
    fi(i, "iconStyle"), Nn(i.feature, function(n) {
      fi(n, "iconStyle");
    });
  }), cr(XM(r.axisPointer), "label"), cr(XM(r.tooltip).axisPointer, "label");
}
function Ule(r, e) {
  for (var t = e.split(","), i = r, n = 0; n < t.length && (i = i && i[t[n]], i != null); n++)
    ;
  return i;
}
function $le(r, e, t, i) {
  for (var n = e.split(","), a = r, o, s = 0; s < n.length - 1; s++)
    o = n[s], a[o] == null && (a[o] = {}), a = a[o];
  (i || a[n[s]] == null) && (a[n[s]] = t);
}
function YM(r) {
  r && N(Vle, function(e) {
    e[0] in r && !(e[1] in r) && (r[e[1]] = r[e[0]]);
  });
}
var Vle = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], Gle = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], w0 = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Dd(r) {
  var e = r && r.itemStyle;
  if (e)
    for (var t = 0; t < w0.length; t++) {
      var i = w0[t][1], n = w0[t][0];
      e[i] != null && (e[n] = e[i], {}.NODE_ENV !== "production" && fr(i, n));
    }
}
function HM(r) {
  r && r.alignTo === "edge" && r.margin != null && r.edgeDistance == null && ({}.NODE_ENV !== "production" && fr("label.margin", "label.edgeDistance", "pie"), r.edgeDistance = r.margin);
}
function WM(r) {
  r && r.downplay && !r.blur && (r.blur = r.downplay, {}.NODE_ENV !== "production" && fr("downplay", "blur", "sunburst"));
}
function Ble(r) {
  r && r.focusNodeAdjacency != null && (r.emphasis = r.emphasis || {}, r.emphasis.focus == null && ({}.NODE_ENV !== "production" && fr("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), r.emphasis.focus = "adjacency"));
}
function AW(r, e) {
  if (r)
    for (var t = 0; t < r.length; t++)
      e(r[t]), r[t] && AW(r[t].children, e);
}
function _W(r, e) {
  Qle(r, e), r.series = It(r.series), N(r.series, function(t) {
    if (be(t)) {
      var i = t.type;
      if (i === "line")
        t.clipOverflow != null && (t.clip = t.clipOverflow, {}.NODE_ENV !== "production" && fr("clipOverflow", "clip", "line"));
      else if (i === "pie" || i === "gauge") {
        t.clockWise != null && (t.clockwise = t.clockWise, {}.NODE_ENV !== "production" && fr("clockWise", "clockwise")), HM(t.label);
        var n = t.data;
        if (n && !en(n))
          for (var a = 0; a < n.length; a++)
            HM(n[a]);
        t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && ({}.NODE_ENV !== "production" && fr("hoverOffset", "emphasis.scaleSize"), t.emphasis.scaleSize = t.hoverOffset));
      } else if (i === "gauge") {
        var o = Ule(t, "pointer.color");
        o != null && $le(t, "itemStyle.color", o);
      } else if (i === "bar") {
        Dd(t), Dd(t.backgroundStyle), Dd(t.emphasis);
        var n = t.data;
        if (n && !en(n))
          for (var a = 0; a < n.length; a++)
            typeof n[a] == "object" && (Dd(n[a]), Dd(n[a] && n[a].emphasis));
      } else if (i === "sunburst") {
        var s = t.highlightPolicy;
        s && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = s, {}.NODE_ENV !== "production" && fr("highlightPolicy", "emphasis.focus", "sunburst"))), WM(t), AW(t.data, WM);
      } else
        i === "graph" || i === "sankey" ? Ble(t) : i === "map" && (t.mapType && !t.map && ({}.NODE_ENV !== "production" && fr("mapType", "map", "map"), t.map = t.mapType), t.mapLocation && ({}.NODE_ENV !== "production" && Pa("`mapLocation` is not used anymore."), Te(t, t.mapLocation)));
      t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && ({}.NODE_ENV !== "production" && fr("hoverAnimation", "emphasis.scale"), t.emphasis.scale = t.hoverAnimation)), YM(t);
    }
  }), r.dataRange && (r.visualMap = r.dataRange), N(Gle, function(t) {
    var i = r[t];
    i && (X(i) || (i = [i]), N(i, function(n) {
      YM(n);
    }));
  });
}
function Fle(r) {
  var e = de();
  r.eachSeries(function(t) {
    var i = t.get("stack");
    if (i) {
      var n = e.get(i) || e.set(i, []), a = t.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: t
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      n.length && a.setCalculationInfo("stackedOnSeries", n[n.length - 1].seriesModel), n.push(o);
    }
  }), e.each(Xle);
}
function Xle(r) {
  N(r, function(e, t) {
    var i = [], n = [NaN, NaN], a = [e.stackResultDimension, e.stackedOverDimension], o = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, c, h) {
      var f = o.get(e.stackedDimension, h);
      if (isNaN(f))
        return n;
      var d, p;
      s ? p = o.getRawIndex(h) : d = o.get(e.stackedByDimension, h);
      for (var g = NaN, v = t - 1; v >= 0; v--) {
        var O = r[v];
        if (s || (p = O.data.rawIndexOf(O.stackedByDimension, d)), p >= 0) {
          var m = O.data.getByRawIndex(O.stackResultDimension, p);
          if (l === "all" || l === "positive" && m > 0 || l === "negative" && m < 0 || l === "samesign" && f >= 0 && m > 0 || l === "samesign" && f <= 0 && m < 0) {
            f = yae(f, m), g = m;
            break;
          }
        }
      }
      return i[0] = f, i[1] = g, i;
    });
  });
}
var wT = (
  /** @class */
  function() {
    function r(e) {
      this.data = e.data || (e.sourceFormat === xo ? {} : []), this.sourceFormat = e.sourceFormat || vW, this.seriesLayoutBy = e.seriesLayoutBy || vo, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption;
      var t = this.dimensionsDefine = e.dimensionsDefine;
      if (t)
        for (var i = 0; i < t.length; i++) {
          var n = t[i];
          n.type == null && EW(this, i) === Wr.Must && (n.type = "ordinal");
        }
    }
    return r;
  }()
);
function sN(r) {
  return r instanceof wT;
}
function dC(r, e, t) {
  t = t || CW(r);
  var i = e.seriesLayoutBy, n = Hle(r, t, i, e.sourceHeader, e.dimensions), a = new wT({
    data: r,
    sourceFormat: t,
    seriesLayoutBy: i,
    dimensionsDefine: n.dimensionsDefine,
    startIndex: n.startIndex,
    dimensionsDetectedCount: n.dimensionsDetectedCount,
    metaRawOption: ye(e)
  });
  return a;
}
function lN(r) {
  return new wT({
    data: r,
    sourceFormat: en(r) ? Ko : sa
  });
}
function Yle(r) {
  return new wT({
    data: r.data,
    sourceFormat: r.sourceFormat,
    seriesLayoutBy: r.seriesLayoutBy,
    dimensionsDefine: ye(r.dimensionsDefine),
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount
  });
}
function CW(r) {
  var e = vW;
  if (en(r))
    e = Ko;
  else if (X(r)) {
    r.length === 0 && (e = Ei);
    for (var t = 0, i = r.length; t < i; t++) {
      var n = r[t];
      if (n != null) {
        if (X(n)) {
          e = Ei;
          break;
        } else if (be(n)) {
          e = la;
          break;
        }
      }
    }
  } else if (be(r)) {
    for (var a in r)
      if (le(r, a) && mi(r[a])) {
        e = xo;
        break;
      }
  }
  return e;
}
function Hle(r, e, t, i, n) {
  var a, o;
  if (!r)
    return {
      dimensionsDefine: zM(n),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (e === Ei) {
    var s = r;
    i === "auto" || i == null ? ZM(function(u) {
      u != null && u !== "-" && (ne(u) ? o == null && (o = 1) : o = 0);
    }, t, s, 10) : o = pt(i) ? i : i ? 1 : 0, !n && o === 1 && (n = [], ZM(function(u, c) {
      n[c] = u != null ? u + "" : "";
    }, t, s, 1 / 0)), a = n ? n.length : t === od ? s.length : s[0] ? s[0].length : null;
  } else if (e === la)
    n || (n = Wle(r));
  else if (e === xo)
    n || (n = [], N(r, function(u, c) {
      n.push(c);
    }));
  else if (e === sa) {
    var l = jf(r[0]);
    a = X(l) && l.length || 1;
  } else
    e === Ko && {}.NODE_ENV !== "production" && Se(!!n, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: o,
    dimensionsDefine: zM(n),
    dimensionsDetectedCount: a
  };
}
function Wle(r) {
  for (var e = 0, t; e < r.length && !(t = r[e++]); )
    ;
  if (t)
    return Ze(t);
}
function zM(r) {
  if (r) {
    var e = de();
    return Y(r, function(t, i) {
      t = be(t) ? t : {
        name: t
      };
      var n = {
        name: t.name,
        displayName: t.displayName,
        type: t.type
      };
      if (n.name == null)
        return n;
      n.name += "", n.displayName == null && (n.displayName = n.name);
      var a = e.get(n.name);
      return a ? n.name += "-" + a.count++ : e.set(n.name, {
        count: 1
      }), n;
    });
  }
}
function ZM(r, e, t, i) {
  if (e === od)
    for (var n = 0; n < t.length && n < i; n++)
      r(t[n] ? t[n][0] : null, n);
  else
    for (var a = t[0] || [], n = 0; n < a.length && n < i; n++)
      r(a[n], n);
}
function IW(r) {
  var e = r.sourceFormat;
  return e === la || e === xo;
}
var mu, Eu, bu, qM, jM, wW = (
  /** @class */
  function() {
    function r(e, t) {
      var i = sN(e) ? e : lN(e);
      this._source = i;
      var n = this._data = i.data;
      if (i.sourceFormat === Ko) {
        if ({}.NODE_ENV !== "production" && t == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = t, this._data = n;
      }
      jM(this, n, i);
    }
    return r.prototype.getSource = function() {
      return this._source;
    }, r.prototype.count = function() {
      return 0;
    }, r.prototype.getItem = function(e, t) {
    }, r.prototype.appendData = function(e) {
    }, r.prototype.clean = function() {
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.pure = !1, e.persistent = !0;
    }(), r.internalField = function() {
      var e;
      jM = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, f = l.dimensionsDefine, d = qM[uN(u, c)];
        if ({}.NODE_ENV !== "production" && Se(d, "Invalide sourceFormat: " + u), B(o, d), u === Ko)
          o.getItem = t, o.count = n, o.fillStorage = i;
        else {
          var p = NW(u, c);
          o.getItem = ue(p, null, s, h, f);
          var g = xW(u, c);
          o.count = ue(g, null, s, h, f);
        }
      };
      var t = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, h = 0; h < u; h++)
          s[h] = l[c + h];
        return s;
      }, i = function(o, s, l, u) {
        for (var c = this._data, h = this._dimSize, f = 0; f < h; f++) {
          for (var d = u[f], p = d[0] == null ? 1 / 0 : d[0], g = d[1] == null ? -1 / 0 : d[1], v = s - o, O = l[f], m = 0; m < v; m++) {
            var E = c[m * h + f];
            O[o + m] = E, E < p && (p = E), E > g && (g = E);
          }
          d[0] = p, d[1] = g;
        }
      }, n = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      qM = (e = {}, e[Ei + "_" + vo] = {
        pure: !0,
        appendData: a
      }, e[Ei + "_" + od] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, e[la] = {
        pure: !0,
        appendData: a
      }, e[xo] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          N(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), h = 0; h < (l || []).length; h++)
              c.push(l[h]);
          });
        }
      }, e[sa] = {
        appendData: a
      }, e[Ko] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
          ({}).NODE_ENV !== "production" && Se(en(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, e);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    }(), r;
  }()
), KM = function(r, e, t, i) {
  return r[i];
}, zle = (mu = {}, mu[Ei + "_" + vo] = function(r, e, t, i) {
  return r[i + e];
}, mu[Ei + "_" + od] = function(r, e, t, i, n) {
  i += e;
  for (var a = n || [], o = r, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[i] : null;
  }
  return a;
}, mu[la] = KM, mu[xo] = function(r, e, t, i, n) {
  for (var a = n || [], o = 0; o < t.length; o++) {
    var s = t[o].name;
    if ({}.NODE_ENV !== "production" && s == null)
      throw new Error();
    var l = r[s];
    a[o] = l ? l[i] : null;
  }
  return a;
}, mu[sa] = KM, mu);
function NW(r, e) {
  var t = zle[uN(r, e)];
  return {}.NODE_ENV !== "production" && Se(t, 'Do not support get item on "' + r + '", "' + e + '".'), t;
}
var JM = function(r, e, t) {
  return r.length;
}, Zle = (Eu = {}, Eu[Ei + "_" + vo] = function(r, e, t) {
  return Math.max(0, r.length - e);
}, Eu[Ei + "_" + od] = function(r, e, t) {
  var i = r[0];
  return i ? Math.max(0, i.length - e) : 0;
}, Eu[la] = JM, Eu[xo] = function(r, e, t) {
  var i = t[0].name;
  if ({}.NODE_ENV !== "production" && i == null)
    throw new Error();
  var n = r[i];
  return n ? n.length : 0;
}, Eu[sa] = JM, Eu);
function xW(r, e) {
  var t = Zle[uN(r, e)];
  return {}.NODE_ENV !== "production" && Se(t, 'Do not support count on "' + r + '", "' + e + '".'), t;
}
var N0 = function(r, e, t) {
  return r[e];
}, qle = (bu = {}, bu[Ei] = N0, bu[la] = function(r, e, t) {
  return r[t];
}, bu[xo] = N0, bu[sa] = function(r, e, t) {
  var i = jf(r);
  return i instanceof Array ? i[e] : i;
}, bu[Ko] = N0, bu);
function PW(r) {
  var e = qle[r];
  return {}.NODE_ENV !== "production" && Se(e, 'Do not support get value on "' + r + '".'), e;
}
function uN(r, e) {
  return r === Ei ? r + "_" + e : r;
}
function Nf(r, e, t) {
  if (r) {
    var i = r.getRawDataItem(e);
    if (i != null) {
      var n = r.getStore(), a = n.getSource().sourceFormat;
      if (t != null) {
        var o = r.getDimensionIndex(t), s = n.getDimensionProperty(o);
        return PW(a)(i, o, s);
      } else {
        var l = i;
        return a === sa && (l = jf(i)), l;
      }
    }
  }
}
var jle = /\{@(.+?)\}/g, cN = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getDataParams = function(e, t) {
      var i = this.getData(t), n = this.getRawValue(e, t), a = i.getRawIndex(e), o = i.getName(e), s = i.getRawDataItem(e), l = i.getItemVisual(e, "style"), u = l && l[i.getItemVisual(e, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, f = h === "series", d = i.userOutput && i.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: t,
        value: n,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, r.prototype.getFormattedLabel = function(e, t, i, n, a, o) {
      t = t || "normal";
      var s = this.getData(i), l = this.getDataParams(e, i);
      if (o && (l.value = o.interpolatedValue), n != null && X(l.value) && (l.value = l.value[n]), !a) {
        var u = s.getItemModel(e);
        a = u.get(t === "normal" ? ["label", "formatter"] : [t, "label", "formatter"]);
      }
      if (ve(a))
        return l.status = t, l.dimensionIndex = n, a(l);
      if (ne(a)) {
        var c = fW(a, l);
        return c.replace(jle, function(h, f) {
          var d = f.length, p = f;
          p.charAt(0) === "[" && p.charAt(d - 1) === "]" && (p = +p.slice(1, d - 1), {}.NODE_ENV !== "production" && isNaN(p) && ti("Invalide label formatter: @" + f + ", only support @[0], @[1], @[2], ..."));
          var g = Nf(s, e, p);
          if (o && X(o.interpolatedValue)) {
            var v = s.getDimensionIndex(p);
            v >= 0 && (g = o.interpolatedValue[v]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, r.prototype.getRawValue = function(e, t) {
      return Nf(this.getData(t), e);
    }, r.prototype.formatTooltip = function(e, t, i) {
    }, r;
  }()
);
function ek(r) {
  var e, t;
  return be(r) ? r.type ? t = r : {}.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + Ui(r)) : e = r, {
    text: e,
    // markers: markers || markersExisting,
    frag: t
  };
}
function Kp(r) {
  return new Kle(r);
}
var Kle = (
  /** @class */
  function() {
    function r(e) {
      e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = !0;
    }
    return r.prototype.perform = function(e) {
      var t = this._upstream, i = e && e.skip;
      if (this._dirty && t) {
        var n = this.context;
        n.data = n.outputData = t.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !i && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(e && e.modBy), u = e && e.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(m) {
        return !(m >= 1) && (m = 1), m;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = !1, h = this._doReset(i)), this._modBy = l, this._modDataCount = u;
      var f = e && e.step;
      if (t ? ({}.NODE_ENV !== "production" && Se(t._outputDueEnd != null), this._dueEnd = t._outputDueEnd) : ({}.NODE_ENV !== "production" && Se(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var d = this._dueIndex, p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!i && (h || d < p)) {
          var g = this._progress;
          if (X(g))
            for (var v = 0; v < g.length; v++)
              this._doProgress(g[v], d, p, l, u);
          else
            this._doProgress(g, d, p, l, u);
        }
        this._dueIndex = p;
        var O = this._settedOutputEnd != null ? this._settedOutputEnd : p;
        ({}).NODE_ENV !== "production" && Se(O >= this._outputDueEnd), this._outputDueEnd = O;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, r.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, r.prototype._doProgress = function(e, t, i, n, a) {
      tk.reset(t, i, n, a), this._callingProgress = e, this._callingProgress({
        start: t,
        end: i,
        count: i - t,
        next: tk.next
      }, this.context);
    }, r.prototype._doReset = function(e) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var t, i;
      !e && this._reset && (t = this._reset(this.context), t && t.progress && (i = t.forceFirstProgress, t = t.progress), X(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null;
      var n = this._downstream;
      return n && n.dirty(), i;
    }, r.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, r.prototype.pipe = function(e) {
      ({}).NODE_ENV !== "production" && Se(e && !e._disposed && e !== this), (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty());
    }, r.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, r.prototype.getUpstream = function() {
      return this._upstream;
    }, r.prototype.getDownstream = function() {
      return this._downstream;
    }, r.prototype.setOutputEnd = function(e) {
      this._outputDueEnd = this._settedOutputEnd = e;
    }, r;
  }()
), tk = function() {
  var r, e, t, i, n, a = {
    reset: function(l, u, c, h) {
      e = l, r = u, t = c, i = h, n = Math.ceil(i / t), a.next = t > 1 && i > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return e < r ? e++ : null;
  }
  function s() {
    var l = e % n * t + Math.ceil(e / n), u = e >= r ? null : l < i ? l : e;
    return e++, u;
  }
}();
function gl(r, e) {
  var t = e && e.type;
  return t === "ordinal" ? r : (t === "time" && !pt(r) && r != null && r !== "-" && (r = +Ao(r)), r == null || r === "" ? NaN : +r);
}
var Jle = de({
  number: function(r) {
    return parseFloat(r);
  },
  time: function(r) {
    return +Ao(r);
  },
  trim: function(r) {
    return ne(r) ? Ea(r) : r;
  }
});
function LW(r) {
  return Jle.get(r);
}
var DW = {
  lt: function(r, e) {
    return r < e;
  },
  lte: function(r, e) {
    return r <= e;
  },
  gt: function(r, e) {
    return r > e;
  },
  gte: function(r, e) {
    return r >= e;
  }
}, eue = (
  /** @class */
  function() {
    function r(e, t) {
      if (!pt(t)) {
        var i = "";
        ({}).NODE_ENV !== "production" && (i = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'), St(i);
      }
      this._opFn = DW[e], this._rvalFloat = ss(t);
    }
    return r.prototype.evaluate = function(e) {
      return pt(e) ? this._opFn(e, this._rvalFloat) : this._opFn(ss(e), this._rvalFloat);
    }, r;
  }()
), MW = (
  /** @class */
  function() {
    function r(e, t) {
      var i = e === "desc";
      this._resultLT = i ? 1 : -1, t == null && (t = i ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0;
    }
    return r.prototype.evaluate = function(e, t) {
      var i = pt(e) ? e : ss(e), n = pt(t) ? t : ss(t), a = isNaN(i), o = isNaN(n);
      if (a && (i = this._incomparable), o && (n = this._incomparable), a && o) {
        var s = ne(e), l = ne(t);
        s && (i = l ? e : 0), l && (n = s ? t : 0);
      }
      return i < n ? this._resultLT : i > n ? -this._resultLT : 0;
    }, r;
  }()
), tue = (
  /** @class */
  function() {
    function r(e, t) {
      this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = ss(t);
    }
    return r.prototype.evaluate = function(e) {
      var t = e === this._rval;
      if (!t) {
        var i = typeof e;
        i !== this._rvalTypeof && (i === "number" || this._rvalTypeof === "number") && (t = ss(e) === this._rvalFloat);
      }
      return this._isEQ ? t : !t;
    }, r;
  }()
);
function rue(r, e) {
  return r === "eq" || r === "ne" ? new tue(r === "eq", e) : le(DW, r) ? new eue(r, e) : null;
}
var iue = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getRawData = function() {
      throw new Error("not supported");
    }, r.prototype.getRawDataItem = function(e) {
      throw new Error("not supported");
    }, r.prototype.cloneRawData = function() {
    }, r.prototype.getDimensionInfo = function(e) {
    }, r.prototype.cloneAllDimensionInfo = function() {
    }, r.prototype.count = function() {
    }, r.prototype.retrieveValue = function(e, t) {
    }, r.prototype.retrieveValueFromItem = function(e, t) {
    }, r.prototype.convertValue = function(e, t) {
      return gl(e, t);
    }, r;
  }()
);
function nue(r, e) {
  var t = new iue(), i = r.data, n = t.sourceFormat = r.sourceFormat, a = r.startIndex, o = "";
  r.seriesLayoutBy !== vo && ({}.NODE_ENV !== "production" && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), St(o));
  var s = [], l = {}, u = r.dimensionsDefine;
  if (u)
    N(u, function(g, v) {
      var O = g.name, m = {
        index: v,
        name: O,
        displayName: g.displayName
      };
      if (s.push(m), O != null) {
        var E = "";
        le(l, O) && ({}.NODE_ENV !== "production" && (E = 'dimension name "' + O + '" duplicated.'), St(E)), l[O] = m;
      }
    });
  else
    for (var c = 0; c < r.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var h = NW(n, vo);
  e.__isBuiltIn && (t.getRawDataItem = function(g) {
    return h(i, a, s, g);
  }, t.getRawData = ue(aue, null, r)), t.cloneRawData = ue(oue, null, r);
  var f = xW(n, vo);
  t.count = ue(f, null, i, a, s);
  var d = PW(n);
  t.retrieveValue = function(g, v) {
    var O = h(i, a, s, g);
    return p(O, v);
  };
  var p = t.retrieveValueFromItem = function(g, v) {
    if (g != null) {
      var O = s[v];
      if (O)
        return d(g, v, O.name);
    }
  };
  return t.getDimensionInfo = ue(sue, null, s, l), t.cloneAllDimensionInfo = ue(lue, null, s), t;
}
function aue(r) {
  var e = r.sourceFormat;
  if (!hN(e)) {
    var t = "";
    ({}).NODE_ENV !== "production" && (t = "`getRawData` is not supported in source format " + e), St(t);
  }
  return r.data;
}
function oue(r) {
  var e = r.sourceFormat, t = r.data;
  if (!hN(e)) {
    var i = "";
    ({}).NODE_ENV !== "production" && (i = "`cloneRawData` is not supported in source format " + e), St(i);
  }
  if (e === Ei) {
    for (var n = [], a = 0, o = t.length; a < o; a++)
      n.push(t[a].slice());
    return n;
  } else if (e === la) {
    for (var n = [], a = 0, o = t.length; a < o; a++)
      n.push(B({}, t[a]));
    return n;
  }
}
function sue(r, e, t) {
  if (t != null) {
    if (pt(t) || !isNaN(t) && !le(e, t))
      return r[t];
    if (le(e, t))
      return e[t];
  }
}
function lue(r) {
  return ye(r);
}
var kW = de();
function uue(r) {
  r = ye(r);
  var e = r.type, t = "";
  e || ({}.NODE_ENV !== "production" && (t = "Must have a `type` when `registerTransform`."), St(t));
  var i = e.split(":");
  i.length !== 2 && ({}.NODE_ENV !== "production" && (t = 'Name must include namespace like "ns:regression".'), St(t));
  var n = !1;
  i[0] === "echarts" && (e = i[1], n = !0), r.__isBuiltIn = n, kW.set(e, r);
}
function cue(r, e, t) {
  var i = It(r), n = i.length, a = "";
  n || ({}.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), St(a));
  for (var o = 0, s = n; o < s; o++) {
    var l = i[o];
    e = hue(l, e, t, n === 1 ? null : o), o !== s - 1 && (e.length = Math.max(e.length, 1));
  }
  return e;
}
function hue(r, e, t, i) {
  var n = "";
  e.length || ({}.NODE_ENV !== "production" && (n = "Must have at least one upstream dataset."), St(n)), be(r) || ({}.NODE_ENV !== "production" && (n = "transform declaration must be an object rather than " + typeof r + "."), St(n));
  var a = r.type, o = kW.get(a);
  o || ({}.NODE_ENV !== "production" && (n = 'Can not find transform on type "' + a + '".'), St(n));
  var s = Y(e, function(c) {
    return nue(c, o);
  }), l = It(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: ye(r.config)
  }));
  if ({}.NODE_ENV !== "production" && r.print) {
    var u = Y(l, function(c) {
      var h = i != null ? " === pipe index: " + i : "";
      return ["=== dataset index: " + t.datasetIndex + h + " ===", "- transform result data:", Ui(c.data), "- transform result dimensions:", Ui(c.dimensions)].join(`
`);
    }).join(`
`);
    Iae(u);
  }
  return Y(l, function(c, h) {
    var f = "";
    be(c) || ({}.NODE_ENV !== "production" && (f = "A transform should not return some empty results."), St(f)), c.data || ({}.NODE_ENV !== "production" && (f = "Transform result data should be not be null or undefined"), St(f));
    var d = CW(c.data);
    hN(d) || ({}.NODE_ENV !== "production" && (f = "Transform result data should be array rows or object rows."), St(f));
    var p, g = e[0];
    if (g && h === 0 && !c.dimensions) {
      var v = g.startIndex;
      v && (c.data = g.data.slice(0, v).concat(c.data)), p = {
        seriesLayoutBy: vo,
        sourceHeader: v,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      p = {
        seriesLayoutBy: vo,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return dC(c.data, p, null);
  });
}
function hN(r) {
  return r === Ei || r === la;
}
var NT = "undefined", fue = typeof Uint32Array === NT ? Array : Uint32Array, due = typeof Uint16Array === NT ? Array : Uint16Array, QW = typeof Int32Array === NT ? Array : Int32Array, rk = typeof Float64Array === NT ? Array : Float64Array, UW = {
  float: rk,
  int: QW,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: rk
}, x0;
function Md(r) {
  return r > 65535 ? fue : due;
}
function Oh() {
  return [1 / 0, -1 / 0];
}
function pue(r) {
  var e = r.constructor;
  return e === Array ? r.slice() : new e(r);
}
function ik(r, e, t, i, n) {
  var a = UW[t || "float"];
  if (n) {
    var o = r[e], s = o && o.length;
    if (s !== i) {
      for (var l = new a(i), u = 0; u < s; u++)
        l[u] = o[u];
      r[e] = l;
    }
  } else
    r[e] = new a(i);
}
var pC = (
  /** @class */
  function() {
    function r() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = de();
    }
    return r.prototype.initData = function(e, t, i) {
      ({}).NODE_ENV !== "production" && Se(ve(e.getItem) && ve(e.count), "Invalid data provider."), this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var n = e.getSource(), a = this.defaultDimValueGetter = x0[n.sourceFormat];
      this._dimValueGetter = i || a, this._rawExtent = [];
      var o = IW(n);
      this._dimensions = Y(t, function(s) {
        return {}.NODE_ENV !== "production" && o && Se(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, e.count());
    }, r.prototype.getProvider = function() {
      return this._provider;
    }, r.prototype.getSource = function() {
      return this._provider.getSource();
    }, r.prototype.ensureCalculationDimension = function(e, t) {
      var i = this._calcDimNameToIdx, n = this._dimensions, a = i.get(e);
      if (a != null) {
        if (n[a].type === t)
          return a;
      } else
        a = n.length;
      return n[a] = {
        type: t
      }, i.set(e, a), this._chunks[a] = new UW[t || "float"](this._rawCount), this._rawExtent[a] = Oh(), a;
    }, r.prototype.collectOrdinalMeta = function(e, t) {
      var i = this._chunks[e], n = this._dimensions[e], a = this._rawExtent, o = n.ordinalOffset || 0, s = i.length;
      o === 0 && (a[e] = Oh());
      for (var l = a[e], u = o; u < s; u++) {
        var c = i[u] = t.parseAndCollect(i[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      n.ordinalMeta = t, n.ordinalOffset = s, n.type = "ordinal";
    }, r.prototype.getOrdinalMeta = function(e) {
      var t = this._dimensions[e], i = t.ordinalMeta;
      return i;
    }, r.prototype.getDimensionProperty = function(e) {
      var t = this._dimensions[e];
      return t && t.property;
    }, r.prototype.appendData = function(e) {
      ({}).NODE_ENV !== "production" && Se(!this._indices, "appendData can only be called on raw data.");
      var t = this._provider, i = this.count();
      t.appendData(e);
      var n = t.count();
      return t.persistent || (n += i), i < n && this._initDataFromProvider(i, n, !0), [i, n];
    }, r.prototype.appendValues = function(e, t) {
      for (var i = this._chunks, n = this._dimensions, a = n.length, o = this._rawExtent, s = this.count(), l = s + Math.max(e.length, t || 0), u = 0; u < a; u++) {
        var c = n[u];
        ik(i, u, c.type, l, !0);
      }
      for (var h = [], f = s; f < l; f++)
        for (var d = f - s, p = 0; p < a; p++) {
          var c = n[p], g = x0.arrayRows.call(this, e[d] || h, c.property, d, p);
          i[p][f] = g;
          var v = o[p];
          g < v[0] && (v[0] = g), g > v[1] && (v[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, r.prototype._initDataFromProvider = function(e, t, i) {
      for (var n = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = Y(o, function(m) {
        return m.property;
      }), c = 0; c < s; c++) {
        var h = o[c];
        l[c] || (l[c] = Oh()), ik(a, c, h.type, t, i);
      }
      if (n.fillStorage)
        n.fillStorage(e, t, a, l);
      else
        for (var f = [], d = e; d < t; d++) {
          f = n.getItem(d, f);
          for (var p = 0; p < s; p++) {
            var g = a[p], v = this._dimValueGetter(f, u[p], d, p);
            g[d] = v;
            var O = l[p];
            v < O[0] && (O[0] = v), v > O[1] && (O[1] = v);
          }
        }
      !n.persistent && n.clean && n.clean(), this._rawCount = this._count = t, this._extent = [];
    }, r.prototype.count = function() {
      return this._count;
    }, r.prototype.get = function(e, t) {
      if (!(t >= 0 && t < this._count))
        return NaN;
      var i = this._chunks[e];
      return i ? i[this.getRawIndex(t)] : NaN;
    }, r.prototype.getValues = function(e, t) {
      var i = [], n = [];
      if (t == null) {
        t = e, e = [];
        for (var a = 0; a < this._dimensions.length; a++)
          n.push(a);
      } else
        n = e;
      for (var a = 0, o = n.length; a < o; a++)
        i.push(this.get(n[a], t));
      return i;
    }, r.prototype.getByRawIndex = function(e, t) {
      if (!(t >= 0 && t < this._rawCount))
        return NaN;
      var i = this._chunks[e];
      return i ? i[t] : NaN;
    }, r.prototype.getSum = function(e) {
      var t = this._chunks[e], i = 0;
      if (t)
        for (var n = 0, a = this.count(); n < a; n++) {
          var o = this.get(e, n);
          isNaN(o) || (i += o);
        }
      return i;
    }, r.prototype.getMedian = function(e) {
      var t = [];
      this.each([e], function(a) {
        isNaN(a) || t.push(a);
      });
      var i = t.sort(function(a, o) {
        return a - o;
      }), n = this.count();
      return n === 0 ? 0 : n % 2 === 1 ? i[(n - 1) / 2] : (i[n / 2] + i[n / 2 - 1]) / 2;
    }, r.prototype.indexOfRawIndex = function(e) {
      if (e >= this._rawCount || e < 0)
        return -1;
      if (!this._indices)
        return e;
      var t = this._indices, i = t[e];
      if (i != null && i < this._count && i === e)
        return e;
      for (var n = 0, a = this._count - 1; n <= a; ) {
        var o = (n + a) / 2 | 0;
        if (t[o] < e)
          n = o + 1;
        else if (t[o] > e)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, r.prototype.indicesOfNearest = function(e, t, i) {
      var n = this._chunks, a = n[e], o = [];
      if (!a)
        return o;
      i == null && (i = 1 / 0);
      for (var s = 1 / 0, l = -1, u = 0, c = 0, h = this.count(); c < h; c++) {
        var f = this.getRawIndex(c), d = t - a[f], p = Math.abs(d);
        p <= i && ((p < s || p === s && d >= 0 && l < 0) && (s = p, l = d, u = 0), d === l && (o[u++] = c));
      }
      return o.length = u, o;
    }, r.prototype.getIndices = function() {
      var e, t = this._indices;
      if (t) {
        var i = t.constructor, n = this._count;
        if (i === Array) {
          e = new i(n);
          for (var a = 0; a < n; a++)
            e[a] = t[a];
        } else
          e = new i(t.buffer, 0, n);
      } else {
        var i = Md(this._rawCount);
        e = new i(this.count());
        for (var a = 0; a < e.length; a++)
          e[a] = a;
      }
      return e;
    }, r.prototype.filter = function(e, t) {
      if (!this._count)
        return this;
      for (var i = this.clone(), n = i.count(), a = Md(i._rawCount), o = new a(n), s = [], l = e.length, u = 0, c = e[0], h = i._chunks, f = 0; f < n; f++) {
        var d = void 0, p = i.getRawIndex(f);
        if (l === 0)
          d = t(f);
        else if (l === 1) {
          var g = h[c][p];
          d = t(g, f);
        } else {
          for (var v = 0; v < l; v++)
            s[v] = h[e[v]][p];
          s[v] = f, d = t.apply(null, s);
        }
        d && (o[u++] = p);
      }
      return u < n && (i._indices = o), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
    }, r.prototype.selectRange = function(e) {
      var t = this.clone(), i = t._count;
      if (!i)
        return this;
      var n = Ze(e), a = n.length;
      if (!a)
        return this;
      var o = t.count(), s = Md(t._rawCount), l = new s(o), u = 0, c = n[0], h = e[c][0], f = e[c][1], d = t._chunks, p = !1;
      if (!t._indices) {
        var g = 0;
        if (a === 1) {
          for (var v = d[n[0]], O = 0; O < i; O++) {
            var m = v[O];
            (m >= h && m <= f || isNaN(m)) && (l[u++] = g), g++;
          }
          p = !0;
        } else if (a === 2) {
          for (var v = d[n[0]], E = d[n[1]], b = e[n[1]][0], S = e[n[1]][1], O = 0; O < i; O++) {
            var m = v[O], T = E[O];
            (m >= h && m <= f || isNaN(m)) && (T >= b && T <= S || isNaN(T)) && (l[u++] = g), g++;
          }
          p = !0;
        }
      }
      if (!p)
        if (a === 1)
          for (var O = 0; O < o; O++) {
            var y = t.getRawIndex(O), m = d[n[0]][y];
            (m >= h && m <= f || isNaN(m)) && (l[u++] = y);
          }
        else
          for (var O = 0; O < o; O++) {
            for (var R = !0, y = t.getRawIndex(O), _ = 0; _ < a; _++) {
              var C = n[_], m = d[C][y];
              (m < e[C][0] || m > e[C][1]) && (R = !1);
            }
            R && (l[u++] = t.getRawIndex(O));
          }
      return u < o && (t._indices = l), t._count = u, t._extent = [], t._updateGetRawIdx(), t;
    }, r.prototype.map = function(e, t) {
      var i = this.clone(e);
      return this._updateDims(i, e, t), i;
    }, r.prototype.modify = function(e, t) {
      this._updateDims(this, e, t);
    }, r.prototype._updateDims = function(e, t, i) {
      for (var n = e._chunks, a = [], o = t.length, s = e.count(), l = [], u = e._rawExtent, c = 0; c < t.length; c++)
        u[t[c]] = Oh();
      for (var h = 0; h < s; h++) {
        for (var f = e.getRawIndex(h), d = 0; d < o; d++)
          l[d] = n[t[d]][f];
        l[o] = h;
        var p = i && i.apply(null, l);
        if (p != null) {
          typeof p != "object" && (a[0] = p, p = a);
          for (var c = 0; c < p.length; c++) {
            var g = t[c], v = p[c], O = u[g], m = n[g];
            m && (m[f] = v), v < O[0] && (O[0] = v), v > O[1] && (O[1] = v);
          }
        }
      }
    }, r.prototype.lttbDownSample = function(e, t) {
      var i = this.clone([e], !0), n = i._chunks, a = n[e], o = this.count(), s = 0, l = Math.floor(1 / t), u = this.getRawIndex(0), c, h, f, d = new (Md(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      d[s++] = u;
      for (var p = 1; p < o - 1; p += l) {
        for (var g = Math.min(p + l, o - 1), v = Math.min(p + l * 2, o), O = (v + g) / 2, m = 0, E = g; E < v; E++) {
          var b = this.getRawIndex(E), S = a[b];
          isNaN(S) || (m += S);
        }
        m /= v - g;
        var T = p, y = Math.min(p + l, o), R = p - 1, _ = a[u];
        c = -1, f = T;
        for (var C = -1, I = 0, E = T; E < y; E++) {
          var b = this.getRawIndex(E), S = a[b];
          if (isNaN(S)) {
            I++, C < 0 && (C = b);
            continue;
          }
          h = Math.abs((R - O) * (S - _) - (R - E) * (m - _)), h > c && (c = h, f = b);
        }
        I > 0 && I < y - T && (d[s++] = Math.min(C, f), f = Math.max(C, f)), d[s++] = f, u = f;
      }
      return d[s++] = this.getRawIndex(o - 1), i._count = s, i._indices = d, i.getRawIndex = this._getRawIdx, i;
    }, r.prototype.downSample = function(e, t, i, n) {
      for (var a = this.clone([e], !0), o = a._chunks, s = [], l = Math.floor(1 / t), u = o[e], c = this.count(), h = a._rawExtent[e] = Oh(), f = new (Md(this._rawCount))(Math.ceil(c / l)), d = 0, p = 0; p < c; p += l) {
        l > c - p && (l = c - p, s.length = l);
        for (var g = 0; g < l; g++) {
          var v = this.getRawIndex(p + g);
          s[g] = u[v];
        }
        var O = i(s), m = this.getRawIndex(Math.min(p + n(s, O) || 0, c - 1));
        u[m] = O, O < h[0] && (h[0] = O), O > h[1] && (h[1] = O), f[d++] = m;
      }
      return a._count = d, a._indices = f, a._updateGetRawIdx(), a;
    }, r.prototype.each = function(e, t) {
      if (this._count)
        for (var i = e.length, n = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (i) {
            case 0:
              t(a);
              break;
            case 1:
              t(n[e[0]][s], a);
              break;
            case 2:
              t(n[e[0]][s], n[e[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < i; l++)
                u[l] = n[e[l]][s];
              u[l] = a, t.apply(null, u);
          }
        }
    }, r.prototype.getDataExtent = function(e) {
      var t = this._chunks[e], i = Oh();
      if (!t)
        return i;
      var n = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[e].slice();
      if (o = this._extent[e], o)
        return o.slice();
      o = i;
      for (var s = o[0], l = o[1], u = 0; u < n; u++) {
        var c = this.getRawIndex(u), h = t[c];
        h < s && (s = h), h > l && (l = h);
      }
      return o = [s, l], this._extent[e] = o, o;
    }, r.prototype.getRawDataItem = function(e) {
      var t = this.getRawIndex(e);
      if (this._provider.persistent)
        return this._provider.getItem(t);
      for (var i = [], n = this._chunks, a = 0; a < n.length; a++)
        i.push(n[a][t]);
      return i;
    }, r.prototype.clone = function(e, t) {
      var i = new r(), n = this._chunks, a = e && To(e, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < n.length; o++)
          i._chunks[o] = a[o] ? pue(n[o]) : n[o];
      else
        i._chunks = n;
      return this._copyCommonProps(i), t || (i._indices = this._cloneIndices()), i._updateGetRawIdx(), i;
    }, r.prototype._copyCommonProps = function(e) {
      e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = ye(this._extent), e._rawExtent = ye(this._rawExtent);
    }, r.prototype._cloneIndices = function() {
      if (this._indices) {
        var e = this._indices.constructor, t = void 0;
        if (e === Array) {
          var i = this._indices.length;
          t = new e(i);
          for (var n = 0; n < i; n++)
            t[n] = this._indices[n];
        } else
          t = new e(this._indices);
        return t;
      }
      return null;
    }, r.prototype._getRawIdxIdentity = function(e) {
      return e;
    }, r.prototype._getRawIdx = function(e) {
      return e < this._count && e >= 0 ? this._indices[e] : -1;
    }, r.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, r.internalField = function() {
      function e(t, i, n, a) {
        return gl(t[a], this._dimensions[a]);
      }
      x0 = {
        arrayRows: e,
        objectRows: function(t, i, n, a) {
          return gl(t[i], this._dimensions[a]);
        },
        keyedColumns: e,
        original: function(t, i, n, a) {
          var o = t && (t.value == null ? t : t.value);
          return gl(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(t, i, n, a) {
          return t[a];
        }
      };
    }(), r;
  }()
), $W = (
  /** @class */
  function() {
    function r(e) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = e;
    }
    return r.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, r.prototype._setLocalSource = function(e, t) {
      this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, r.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, r.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, r.prototype._createSource = function() {
      this._setLocalSource([], []);
      var e = this._sourceHost, t = this._getUpstreamSourceManagers(), i = !!t.length, n, a;
      if (kd(e)) {
        var o = e, s = void 0, l = void 0, u = void 0;
        if (i) {
          var c = t[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          s = o.get("data", !0), l = en(s) ? Ko : sa, a = [];
        var h = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, d = ke(h.seriesLayoutBy, f.seriesLayoutBy) || null, p = ke(h.sourceHeader, f.sourceHeader), g = ke(h.dimensions, f.dimensions), v = d !== f.seriesLayoutBy || !!p != !!f.sourceHeader || g;
        n = v ? [dC(s, {
          seriesLayoutBy: d,
          sourceHeader: p,
          dimensions: g
        }, l)] : [];
      } else {
        var O = e;
        if (i) {
          var m = this._applyTransform(t);
          n = m.sourceList, a = m.upstreamSignList;
        } else {
          var E = O.get("source", !0);
          n = [dC(E, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      ({}).NODE_ENV !== "production" && Se(n && a), this._setLocalSource(n, a);
    }, r.prototype._applyTransform = function(e) {
      var t = this._sourceHost, i = t.get("transform", !0), n = t.get("fromTransformResult", !0);
      if ({}.NODE_ENV !== "production" && Se(n != null || i != null), n != null) {
        var a = "";
        e.length !== 1 && ({}.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), ak(a));
      }
      var o, s = [], l = [];
      return N(e, function(u) {
        u.prepareSource();
        var c = u.getSource(n || 0), h = "";
        n != null && !c && ({}.NODE_ENV !== "production" && (h = "Can not retrieve result by `fromTransformResult`: " + n), ak(h)), s.push(c), l.push(u._getVersionSign());
      }), i ? o = cue(i, s, {
        datasetIndex: t.componentIndex
      }) : n != null && (o = [Yle(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, r.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) {
        var i = e[t];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          i._isDirty() || this._upstreamSignList[t] !== i._getVersionSign()
        )
          return !0;
      }
    }, r.prototype.getSource = function(e) {
      e = e || 0;
      var t = this._sourceList[e];
      if (!t) {
        var i = this._getUpstreamSourceManagers();
        return i[0] && i[0].getSource(e);
      }
      return t;
    }, r.prototype.getSharedDataStore = function(e) {
      ({}).NODE_ENV !== "production" && Se(kd(this._sourceHost), "Can only call getDataStore on series source manager.");
      var t = e.makeStoreSchema();
      return this._innerGetDataStore(t.dimensions, e.source, t.hash);
    }, r.prototype._innerGetDataStore = function(e, t, i) {
      var n = 0, a = this._storeList, o = a[n];
      o || (o = a[n] = {});
      var s = o[i];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        kd(this._sourceHost) && l ? s = l._innerGetDataStore(e, t, i) : (s = new pC(), s.initData(new wW(t, e.length), e)), o[i] = s;
      }
      return s;
    }, r.prototype._getUpstreamSourceManagers = function() {
      var e = this._sourceHost;
      if (kd(e)) {
        var t = aN(e);
        return t ? [t.getSourceManager()] : [];
      } else
        return Y(gle(e), function(i) {
          return i.getSourceManager();
        });
    }, r.prototype._getSourceMetaRawOption = function() {
      var e = this._sourceHost, t, i, n;
      if (kd(e))
        t = e.get("seriesLayoutBy", !0), i = e.get("sourceHeader", !0), n = e.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = e;
        t = a.get("seriesLayoutBy", !0), i = a.get("sourceHeader", !0), n = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: t,
        sourceHeader: i,
        dimensions: n
      };
    }, r;
  }()
);
function nk(r) {
  var e = r.option.transform;
  e && ZE(r.option.transform);
}
function kd(r) {
  return r.mainType === "series";
}
function ak(r) {
  throw new Error(r);
}
var VW = "line-height:1";
function GW(r, e) {
  var t = r.color || "#6e7079", i = r.fontSize || 12, n = r.fontWeight || "400", a = r.color || "#464646", o = r.fontSize || 14, s = r.fontWeight || "900";
  return e === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Yi(i + "") + "px;color:" + Yi(t) + ";font-weight:" + Yi(n + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Yi(o + "") + "px;color:" + Yi(a) + ";font-weight:" + Yi(s + "")
  } : {
    nameStyle: {
      fontSize: i,
      fill: t,
      fontWeight: n
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var gue = [0, 10, 20, 30], vue = ["", `
`, `

`, `


`];
function Qr(r, e) {
  return e.type = r, e;
}
function gC(r) {
  return r.type === "section";
}
function BW(r) {
  return gC(r) ? Oue : mue;
}
function FW(r) {
  if (gC(r)) {
    var e = 0, t = r.blocks.length, i = t > 1 || t > 0 && !r.noHeader;
    return N(r.blocks, function(n) {
      var a = FW(n);
      a >= e && (e = a + +(i && // 0 always can not be readable gap level.
      (!a || gC(n) && !n.noHeader)));
    }), e;
  }
  return 0;
}
function Oue(r, e, t, i) {
  var n = e.noHeader, a = Eue(FW(e)), o = [], s = e.blocks || [];
  Se(!s || X(s)), s = s || [];
  var l = r.orderMode;
  if (e.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (le(u, l)) {
      var c = new MW(u[l], null);
      s.sort(function(p, g) {
        return c.evaluate(p.sortParam, g.sortParam);
      });
    } else
      l === "seriesDesc" && s.reverse();
  }
  N(s, function(p, g) {
    var v = e.valueFormatter, O = BW(p)(
      // Inherit valueFormatter
      v ? B(B({}, r), {
        valueFormatter: v
      }) : r,
      p,
      g > 0 ? a.html : 0,
      i
    );
    O != null && o.push(O);
  });
  var h = r.renderMode === "richText" ? o.join(a.richText) : vC(o.join(""), n ? t : a.html);
  if (n)
    return h;
  var f = uC(e.header, "ordinal", r.useUTC), d = GW(i, r.renderMode).nameStyle;
  return r.renderMode === "richText" ? XW(r, f, d) + a.richText + h : vC('<div style="' + d + ";" + VW + ';">' + Yi(f) + "</div>" + h, t);
}
function mue(r, e, t, i) {
  var n = r.renderMode, a = e.noName, o = e.noValue, s = !e.markerType, l = e.name, u = r.useUTC, c = e.valueFormatter || r.valueFormatter || function(b) {
    return b = X(b) ? b : [b], Y(b, function(S, T) {
      return uC(S, X(d) ? d[T] : d, u);
    });
  };
  if (!(a && o)) {
    var h = s ? "" : r.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", n), f = a ? "" : uC(l, "ordinal", u), d = e.valueType, p = o ? [] : c(e.value), g = !s || !a, v = !s && a, O = GW(i, n), m = O.nameStyle, E = O.valueStyle;
    return n === "richText" ? (s ? "" : h) + (a ? "" : XW(r, f, m)) + (o ? "" : Tue(r, p, g, v, E)) : vC((s ? "" : h) + (a ? "" : bue(f, !s, m)) + (o ? "" : Sue(p, g, v, E)), t);
  }
}
function ok(r, e, t, i, n, a) {
  if (r) {
    var o = BW(r), s = {
      useUTC: n,
      renderMode: t,
      orderMode: i,
      markupStyleCreator: e,
      valueFormatter: r.valueFormatter
    };
    return o(s, r, 0, a);
  }
}
function Eue(r) {
  return {
    html: gue[r],
    richText: vue[r]
  };
}
function vC(r, e) {
  var t = '<div style="clear:both"></div>', i = "margin: " + e + "px 0 0";
  return '<div style="' + i + ";" + VW + ';">' + r + t + "</div>";
}
function bue(r, e, t) {
  var i = e ? "margin-left:2px" : "";
  return '<span style="' + t + ";" + i + '">' + Yi(r) + "</span>";
}
function Sue(r, e, t, i) {
  var n = t ? "10px" : "20px", a = e ? "float:right;margin-left:" + n : "";
  return r = X(r) ? r : [r], '<span style="' + a + ";" + i + '">' + Y(r, function(o) {
    return Yi(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function XW(r, e, t) {
  return r.markupStyleCreator.wrapRichTextStyle(e, t);
}
function Tue(r, e, t, i, n) {
  var a = [n], o = i ? 10 : 20;
  return t && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), r.markupStyleCreator.wrapRichTextStyle(X(e) ? e.join("  ") : e, a);
}
function YW(r, e) {
  var t = r.getData().getItemVisual(e, "style"), i = t[r.visualDrawType];
  return Pc(i);
}
function HW(r, e) {
  var t = r.get("padding");
  return t ?? (e === "richText" ? [8, 10] : 10);
}
var P0 = (
  /** @class */
  function() {
    function r() {
      this.richTextStyles = {}, this._nextStyleNameId = HY();
    }
    return r.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, r.prototype.makeTooltipMarker = function(e, t, i) {
      var n = i === "richText" ? this._generateStyleName() : null, a = lle({
        color: t,
        type: e,
        renderMode: i,
        markerId: n
      });
      return ne(a) ? a : ({}.NODE_ENV !== "production" && Se(n), this.richTextStyles[n] = a.style, a.content);
    }, r.prototype.wrapRichTextStyle = function(e, t) {
      var i = {};
      X(t) ? N(t, function(a) {
        return B(i, a);
      }) : B(i, t);
      var n = this._generateStyleName();
      return this.richTextStyles[n] = i, "{" + n + "|" + e + "}";
    }, r;
  }()
);
function WW(r) {
  var e = r.series, t = r.dataIndex, i = r.multipleSeries, n = e.getData(), a = n.mapDimensionsAll("defaultedTooltip"), o = a.length, s = e.getRawValue(t), l = X(s), u = YW(e, t), c, h, f, d;
  if (o > 1 || l && !o) {
    var p = yue(s, e, t, a, u);
    c = p.inlineValues, h = p.inlineValueTypes, f = p.blocks, d = p.inlineValues[0];
  } else if (o) {
    var g = n.getDimensionInfo(a[0]);
    d = c = Nf(n, t, a[0]), h = g.type;
  } else
    d = c = l ? s[0] : s;
  var v = Q1(e), O = v && e.name || "", m = n.getName(t), E = i ? O : m;
  return Qr("section", {
    header: O,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: i || !v,
    sortParam: d,
    blocks: [Qr("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: E,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !Ea(E),
      value: c,
      valueType: h
    })].concat(f || [])
  });
}
function yue(r, e, t, i, n) {
  var a = e.getData(), o = To(r, function(h, f, d) {
    var p = a.getDimensionInfo(d);
    return h = h || p && p.tooltip !== !1 && p.displayName != null;
  }, !1), s = [], l = [], u = [];
  i.length ? N(i, function(h) {
    c(Nf(a, t, h), h);
  }) : N(r, c);
  function c(h, f) {
    var d = a.getDimensionInfo(f);
    !d || d.otherDims.tooltip === !1 || (o ? u.push(Qr("nameValue", {
      markerType: "subItem",
      markerColor: n,
      name: d.displayName,
      value: h,
      valueType: d.type
    })) : (s.push(h), l.push(d.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var Ps = ft();
function DO(r, e) {
  return r.getName(e) || r.getId(e);
}
var rE = "__universalTransitionEnabled", xT = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._selectedDataIndicesMap = {}, t;
    }
    return e.prototype.init = function(t, i, n) {
      this.seriesIndex = this.componentIndex, this.dataTask = Kp({
        count: Aue,
        reset: _ue
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(t, n);
      var a = Ps(this).sourceManager = new $W(this);
      a.prepareSource();
      var o = this.getInitialData(t, n);
      lk(o, this), this.dataTask.context.data = o, {}.NODE_ENV !== "production" && Se(o, "getInitialData returned invalid data."), Ps(this).dataBeforeProcessed = o, sk(this), this._initSelectedMapFromData(o);
    }, e.prototype.mergeDefaultAndTheme = function(t, i) {
      var n = Mg(this), a = n ? nd(t) : {}, o = this.subType;
      st.hasClass(o) && (o += "Series"), $e(t, i.getTheme().get(this.subType)), $e(t, this.getDefaultOption()), Ic(t, "label", ["show"]), this.fillDataTextStyle(t.data), n && Pl(t, a, n);
    }, e.prototype.mergeOption = function(t, i) {
      t = $e(this.option, t, !0), this.fillDataTextStyle(t.data);
      var n = Mg(this);
      n && Pl(this.option, t, n);
      var a = Ps(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(t, i);
      lk(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, Ps(this).dataBeforeProcessed = o, sk(this), this._initSelectedMapFromData(o);
    }, e.prototype.fillDataTextStyle = function(t) {
      if (t && !en(t))
        for (var i = ["show"], n = 0; n < t.length; n++)
          t[n] && t[n].label && Ic(t[n], "label", i);
    }, e.prototype.getInitialData = function(t, i) {
    }, e.prototype.appendData = function(t) {
      var i = this.getRawData();
      i.appendData(t.data);
    }, e.prototype.getData = function(t) {
      var i = OC(this);
      if (i) {
        var n = i.context.data;
        return t == null ? n : n.getLinkedData(t);
      } else
        return Ps(this).data;
    }, e.prototype.getAllData = function() {
      var t = this.getData();
      return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{
        data: t
      }];
    }, e.prototype.setData = function(t) {
      var i = OC(this);
      if (i) {
        var n = i.context;
        n.outputData = t, i !== this.dataTask && (n.data = t);
      }
      Ps(this).data = t;
    }, e.prototype.getEncode = function() {
      var t = this.get("encode", !0);
      if (t)
        return de(t);
    }, e.prototype.getSourceManager = function() {
      return Ps(this).sourceManager;
    }, e.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, e.prototype.getRawData = function() {
      return Ps(this).dataBeforeProcessed;
    }, e.prototype.getColorBy = function() {
      var t = this.get("colorBy");
      return t || "series";
    }, e.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, e.prototype.getBaseAxis = function() {
      var t = this.coordinateSystem;
      return t && t.getBaseAxis && t.getBaseAxis();
    }, e.prototype.formatTooltip = function(t, i, n) {
      return WW({
        series: this,
        dataIndex: t,
        multipleSeries: i
      });
    }, e.prototype.isAnimationEnabled = function() {
      var t = this.ecModel;
      if (ct.node && !(t && t.ssr))
        return !1;
      var i = this.getShallow("animation");
      return i && this.getData().count() > this.getShallow("animationThreshold") && (i = !1), !!i;
    }, e.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, e.prototype.getColorFromPalette = function(t, i, n) {
      var a = this.ecModel, o = oN.prototype.getColorFromPalette.call(this, t, i, n);
      return o || (o = a.getColorFromPalette(t, i, n)), o;
    }, e.prototype.coordDimToDataDim = function(t) {
      return this.getRawData().mapDimensionsAll(t);
    }, e.prototype.getProgressive = function() {
      return this.get("progressive");
    }, e.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, e.prototype.select = function(t, i) {
      this._innerSelect(this.getData(i), t);
    }, e.prototype.unselect = function(t, i) {
      var n = this.option.selectedMap;
      if (n) {
        var a = this.option.selectedMode, o = this.getData(i);
        if (a === "series" || n === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < t.length; s++) {
          var l = t[s], u = DO(o, l);
          n[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, e.prototype.toggleSelect = function(t, i) {
      for (var n = [], a = 0; a < t.length; a++)
        n[0] = t[a], this.isSelected(t[a], i) ? this.unselect(n, i) : this.select(n, i);
    }, e.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var t = this._selectedDataIndicesMap, i = Ze(t), n = [], a = 0; a < i.length; a++) {
        var o = t[i[a]];
        o >= 0 && n.push(o);
      }
      return n;
    }, e.prototype.isSelected = function(t, i) {
      var n = this.option.selectedMap;
      if (!n)
        return !1;
      var a = this.getData(i);
      return (n === "all" || n[DO(a, t)]) && !a.getItemModel(t).get(["select", "disabled"]);
    }, e.prototype.isUniversalTransitionEnabled = function() {
      if (this[rE])
        return !0;
      var t = this.option.universalTransition;
      return t ? t === !0 ? !0 : t && t.enabled : !1;
    }, e.prototype._innerSelect = function(t, i) {
      var n, a, o = this.option, s = o.selectedMode, l = i.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          be(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var h = i[c], f = DO(t, h);
            u[f] = !0, this._selectedDataIndicesMap[f] = t.getRawIndex(h);
          }
        } else if (s === "single" || s === !0) {
          var d = i[l - 1], f = DO(t, d);
          o.selectedMap = (n = {}, n[f] = !0, n), this._selectedDataIndicesMap = (a = {}, a[f] = t.getRawIndex(d), a);
        }
      }
    }, e.prototype._initSelectedMapFromData = function(t) {
      if (!this.option.selectedMap) {
        var i = [];
        t.hasItemOption && t.each(function(n) {
          var a = t.getRawDataItem(n);
          a && a.selected && i.push(n);
        }), i.length > 0 && this._innerSelect(t, i);
      }
    }, e.registerClass = function(t) {
      return st.registerClass(t);
    }, e.protoInitialize = function() {
      var t = e.prototype;
      t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill";
    }(), e;
  }(st)
);
br(xT, cN);
br(xT, oN);
eH(xT, st);
function sk(r) {
  var e = r.name;
  Q1(r) || (r.name = Rue(r) || e);
}
function Rue(r) {
  var e = r.getRawData(), t = e.mapDimensionsAll("seriesName"), i = [];
  return N(t, function(n) {
    var a = e.getDimensionInfo(n);
    a.displayName && i.push(a.displayName);
  }), i.join(" ");
}
function Aue(r) {
  return r.model.getRawData().count();
}
function _ue(r) {
  var e = r.model;
  return e.setData(e.getRawData().cloneShallow()), Cue;
}
function Cue(r, e) {
  e.outputData && r.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData);
}
function lk(r, e) {
  N(qE(r.CHANGABLE_METHODS, r.DOWNSAMPLE_METHODS), function(t) {
    r.wrapMethod(t, Le(Iue, e));
  });
}
function Iue(r, e) {
  var t = OC(r);
  return t && t.setOutputEnd((e || this).count()), e;
}
function OC(r) {
  var e = (r.ecModel || {}).scheduler, t = e && e.getPipeline(r.uid);
  if (t) {
    var i = t.currentTask;
    if (i) {
      var n = i.agentStubMap;
      n && (i = n.get(r.uid));
    }
    return i;
  }
}
const Wt = xT;
var fN = (
  /** @class */
  function() {
    function r() {
      this.group = new Re(), this.uid = rd("viewComponent");
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, i, n) {
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, i, n) {
    }, r.prototype.updateLayout = function(e, t, i, n) {
    }, r.prototype.updateVisual = function(e, t, i, n) {
    }, r.prototype.toggleBlurSeries = function(e, t, i) {
    }, r.prototype.eachRendered = function(e) {
      var t = this.group;
      t && t.traverse(e);
    }, r;
  }()
);
$1(fN);
fT(fN);
const jt = fN;
function ld() {
  var r = ft();
  return function(e) {
    var t = r(e), i = e.pipelineContext, n = !!t.large, a = !!t.progressiveRender, o = t.large = !!(i && i.large), s = t.progressiveRender = !!(i && i.progressiveRender);
    return (n !== o || a !== s) && "reset";
  };
}
var zW = ft(), wue = ld(), dN = (
  /** @class */
  function() {
    function r() {
      this.group = new Re(), this.uid = rd("viewChart"), this.renderTask = Kp({
        plan: Nue,
        reset: xue
      }), this.renderTask.context = {
        view: this
      };
    }
    return r.prototype.init = function(e, t) {
    }, r.prototype.render = function(e, t, i, n) {
      if ({}.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, r.prototype.highlight = function(e, t, i, n) {
      var a = e.getData(n && n.dataType);
      if (!a) {
        ({}).NODE_ENV !== "production" && ti("Unknown dataType " + n.dataType);
        return;
      }
      ck(a, n, "emphasis");
    }, r.prototype.downplay = function(e, t, i, n) {
      var a = e.getData(n && n.dataType);
      if (!a) {
        ({}).NODE_ENV !== "production" && ti("Unknown dataType " + n.dataType);
        return;
      }
      ck(a, n, "normal");
    }, r.prototype.remove = function(e, t) {
      this.group.removeAll();
    }, r.prototype.dispose = function(e, t) {
    }, r.prototype.updateView = function(e, t, i, n) {
      this.render(e, t, i, n);
    }, r.prototype.updateLayout = function(e, t, i, n) {
      this.render(e, t, i, n);
    }, r.prototype.updateVisual = function(e, t, i, n) {
      this.render(e, t, i, n);
    }, r.prototype.eachRendered = function(e) {
      zl(this.group, e);
    }, r.markUpdateMethod = function(e, t) {
      zW(e).updateMethod = t;
    }, r.protoInitialize = function() {
      var e = r.prototype;
      e.type = "chart";
    }(), r;
  }()
);
function uk(r, e, t) {
  r && Nl(r) && (e === "emphasis" ? ls : us)(r, t);
}
function ck(r, e, t) {
  var i = wc(r, e), n = e && e.highlightKey != null ? tse(e.highlightKey) : null;
  i != null ? N(It(i), function(a) {
    uk(r.getItemGraphicEl(a), t, n);
  }) : r.eachItemGraphicEl(function(a) {
    uk(a, t, n);
  });
}
$1(dN, ["dispose"]);
fT(dN);
function Nue(r) {
  return wue(r.model);
}
function xue(r) {
  var e = r.model, t = r.ecModel, i = r.api, n = r.payload, a = e.pipelineContext.progressiveRender, o = r.view, s = n && zW(n).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](e, t, i, n), Pue[l];
}
var Pue = {
  incrementalPrepareRender: {
    progress: function(r, e) {
      e.view.incrementalRender(r, e.model, e.ecModel, e.api, e.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(r, e) {
      e.view.render(e.model, e.ecModel, e.api, e.payload);
    }
  }
};
const $t = dN;
var pb = "\0__throttleOriginMethod", hk = "\0__throttleRate", fk = "\0__throttleType";
function pN(r, e, t) {
  var i, n = 0, a = 0, o = null, s, l, u, c;
  e = e || 0;
  function h() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, r.apply(l, u || []);
  }
  var f = function() {
    for (var d = [], p = 0; p < arguments.length; p++)
      d[p] = arguments[p];
    i = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
    var g = c || e, v = c || t;
    c = null, s = i - (v ? n : a) - g, clearTimeout(o), v ? o = setTimeout(h, g) : s >= 0 ? h() : o = setTimeout(h, -s), n = i;
  };
  return f.clear = function() {
    o && (clearTimeout(o), o = null);
  }, f.debounceNextCall = function(d) {
    c = d;
  }, f;
}
function ud(r, e, t, i) {
  var n = r[e];
  if (n) {
    var a = n[pb] || n, o = n[fk], s = n[hk];
    if (s !== t || o !== i) {
      if (t == null || !i)
        return r[e] = a;
      n = r[e] = pN(a, t, i === "debounce"), n[pb] = a, n[fk] = i, n[hk] = t;
    }
    return n;
  }
}
function Qg(r, e) {
  var t = r[e];
  t && t[pb] && (t.clear && t.clear(), r[e] = t[pb]);
}
var dk = ft(), pk = {
  itemStyle: Nc(JH, !0),
  lineStyle: Nc(KH, !0)
}, Lue = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function ZW(r, e) {
  var t = r.visualStyleMapper || pk[e];
  return t || (console.warn("Unknown style type '" + e + "'."), pk.itemStyle);
}
function qW(r, e) {
  var t = r.visualDrawType || Lue[e];
  return t || (console.warn("Unknown style type '" + e + "'."), "fill");
}
var Due = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, e) {
    var t = r.getData(), i = r.visualStyleAccessPath || "itemStyle", n = r.getModel(i), a = ZW(r, i), o = a(n), s = n.getShallow("decal");
    s && (t.setVisual("decal", s), s.dirty = !0);
    var l = qW(r, i), u = o[l], c = ve(u) ? u : null, h = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || c || h) {
      var f = r.getColorFromPalette(
        // TODO series count changed.
        r.name,
        null,
        e.getSeriesCount()
      );
      o[l] || (o[l] = f, t.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || ve(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || ve(o.stroke) ? f : o.stroke;
    }
    if (t.setVisual("style", o), t.setVisual("drawType", l), !e.isSeriesFiltered(r) && c)
      return t.setVisual("colorFromPalette", !1), {
        dataEach: function(d, p) {
          var g = r.getDataParams(p), v = B({}, o);
          v[l] = c(g), d.setItemVisual(p, "style", v);
        }
      };
  }
}, Qd = new Ut(), Mue = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(r, e) {
    if (!(r.ignoreStyleOnData || e.isSeriesFiltered(r))) {
      var t = r.getData(), i = r.visualStyleAccessPath || "itemStyle", n = ZW(r, i), a = t.getVisual("drawType");
      return {
        dataEach: t.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[i]) {
            Qd.option = l[i];
            var u = n(Qd), c = o.ensureUniqueItemVisual(s, "style");
            B(c, u), Qd.option.decal && (o.setItemVisual(s, "decal", Qd.option.decal), Qd.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, kue = {
  performRawSeries: !0,
  overallReset: function(r) {
    var e = de();
    r.eachSeries(function(t) {
      var i = t.getColorBy();
      if (!t.isColorBySeries()) {
        var n = t.type + "-" + i, a = e.get(n);
        a || (a = {}, e.set(n, a)), dk(t).scope = a;
      }
    }), r.eachSeries(function(t) {
      if (!(t.isColorBySeries() || r.isSeriesFiltered(t))) {
        var i = t.getRawData(), n = {}, a = t.getData(), o = dk(t).scope, s = t.visualStyleAccessPath || "itemStyle", l = qW(t, s);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          n[c] = u;
        }), i.each(function(u) {
          var c = n[u], h = a.getItemVisual(c, "colorFromPalette");
          if (h) {
            var f = a.ensureUniqueItemVisual(c, "style"), d = i.getName(u) || u + "", p = i.count();
            f[l] = t.getColorFromPalette(d, o, p);
          }
        });
      }
    });
  }
}, MO = Math.PI;
function Que(r, e) {
  e = e || {}, Te(e, {
    text: "loading",
    textColor: "#000",
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255, 255, 255, 0.8)",
    showSpinner: !0,
    color: "#5470c6",
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var t = new Re(), i = new ht({
    style: {
      fill: e.maskColor
    },
    zlevel: e.zlevel,
    z: 1e4
  });
  t.add(i);
  var n = new dt({
    style: {
      text: e.text,
      fill: e.textColor,
      fontSize: e.fontSize,
      fontWeight: e.fontWeight,
      fontStyle: e.fontStyle,
      fontFamily: e.fontFamily
    },
    zlevel: e.zlevel,
    z: 10001
  }), a = new ht({
    style: {
      fill: "none"
    },
    textContent: n,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: e.zlevel,
    z: 10001
  });
  t.add(a);
  var o;
  return e.showSpinner && (o = new z1({
    shape: {
      startAngle: -MO / 2,
      endAngle: -MO / 2 + 0.1,
      r: e.spinnerRadius
    },
    style: {
      stroke: e.color,
      lineCap: "round",
      lineWidth: e.lineWidth
    },
    zlevel: e.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: MO * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: MO * 3 / 2
  }).delay(300).start("circularInOut"), t.add(o)), t.resize = function() {
    var s = n.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, u = (r.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = r.getHeight() / 2;
    e.showSpinner && o.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), i.setShape({
      x: 0,
      y: 0,
      width: r.getWidth(),
      height: r.getHeight()
    });
  }, t.resize(), t;
}
var Uue = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      this._stageTaskMap = de(), this.ecInstance = e, this.api = t, i = this._dataProcessorHandlers = i.slice(), n = this._visualHandlers = n.slice(), this._allHandlers = i.concat(n);
    }
    return r.prototype.restoreData = function(e, t) {
      e.restoreData(t), this._stageTaskMap.each(function(i) {
        var n = i.overallTask;
        n && n.dirty();
      });
    }, r.prototype.getPerformArgs = function(e, t) {
      if (e.__pipeline) {
        var i = this._pipelineMap.get(e.__pipeline.id), n = i.context, a = !t && i.progressiveEnabled && (!n || n.progressiveRender) && e.__idxInPipeline > i.blockIndex, o = a ? i.step : null, s = n && n.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, r.prototype.getPipeline = function(e) {
      return this._pipelineMap.get(e);
    }, r.prototype.updateStreamModes = function(e, t) {
      var i = this._pipelineMap.get(e.uid), n = e.getData(), a = n.count(), o = i.progressiveEnabled && t.incrementalPrepareRender && a >= i.threshold, s = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null;
      e.pipelineContext = i.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, r.prototype.restorePipelines = function(e) {
      var t = this, i = t._pipelineMap = de();
      e.eachSeries(function(n) {
        var a = n.getProgressive(), o = n.uid;
        i.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: n.getProgressiveThreshold(),
          progressiveEnabled: a && !(n.preventIncremental && n.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), t._pipe(n, n.dataTask);
      });
    }, r.prototype.prepareStageTasks = function() {
      var e = this._stageTaskMap, t = this.api.getModel(), i = this.api;
      N(this._allHandlers, function(n) {
        var a = e.get(n.uid) || e.set(n.uid, {}), o = "";
        ({}).NODE_ENV !== "production" && (o = '"reset" and "overallReset" must not be both specified.'), Se(!(n.reset && n.overallReset), o), n.reset && this._createSeriesStageTask(n, a, t, i), n.overallReset && this._createOverallStageTask(n, a, t, i);
      }, this);
    }, r.prototype.prepareView = function(e, t, i, n) {
      var a = e.renderTask, o = a.context;
      o.model = t, o.ecModel = i, o.api = n, a.__block = !e.incrementalPrepareRender, this._pipe(t, a);
    }, r.prototype.performDataProcessorTasks = function(e, t) {
      this._performStageTasks(this._dataProcessorHandlers, e, t, {
        block: !0
      });
    }, r.prototype.performVisualTasks = function(e, t, i) {
      this._performStageTasks(this._visualHandlers, e, t, i);
    }, r.prototype._performStageTasks = function(e, t, i, n) {
      n = n || {};
      var a = !1, o = this;
      N(e, function(l, u) {
        if (!(n.visualType && n.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), h = c.seriesTaskMap, f = c.overallTask;
          if (f) {
            var d, p = f.agentStubMap;
            p.each(function(v) {
              s(n, v) && (v.dirty(), d = !0);
            }), d && f.dirty(), o.updatePayload(f, i);
            var g = o.getPerformArgs(f, n.block);
            p.each(function(v) {
              v.perform(g);
            }), f.perform(g) && (a = !0);
          } else
            h && h.each(function(v, O) {
              s(n, v) && v.dirty();
              var m = o.getPerformArgs(v, n.block);
              m.skip = !l.performRawSeries && t.isSeriesFiltered(v.context.model), o.updatePayload(v, i), v.perform(m) && (a = !0);
            });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, r.prototype.performSeriesTasks = function(e) {
      var t;
      e.eachSeries(function(i) {
        t = i.dataTask.perform() || t;
      }), this.unfinished = t || this.unfinished;
    }, r.prototype.plan = function() {
      this._pipelineMap.each(function(e) {
        var t = e.tail;
        do {
          if (t.__block) {
            e.blockIndex = t.__idxInPipeline;
            break;
          }
          t = t.getUpstream();
        } while (t);
      });
    }, r.prototype.updatePayload = function(e, t) {
      t !== "remain" && (e.context.payload = t);
    }, r.prototype._createSeriesStageTask = function(e, t, i, n) {
      var a = this, o = t.seriesTaskMap, s = t.seriesTaskMap = de(), l = e.seriesType, u = e.getTargetSeries;
      e.createOnAllSeries ? i.eachRawSeries(c) : l ? i.eachRawSeriesByType(l, c) : u && u(i, n).each(c);
      function c(h) {
        var f = h.uid, d = s.set(f, o && o.get(f) || Kp({
          plan: Fue,
          reset: Xue,
          count: Hue
        }));
        d.context = {
          model: h,
          ecModel: i,
          api: n,
          // PENDING: `useClearVisual` not used?
          useClearVisual: e.isVisual && !e.isLayout,
          plan: e.plan,
          reset: e.reset,
          scheduler: a
        }, a._pipe(h, d);
      }
    }, r.prototype._createOverallStageTask = function(e, t, i, n) {
      var a = this, o = t.overallTask = t.overallTask || Kp({
        reset: $ue
      });
      o.context = {
        ecModel: i,
        api: n,
        overallReset: e.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = de(), u = e.seriesType, c = e.getTargetSeries, h = !0, f = !1, d = "";
      ({}).NODE_ENV !== "production" && (d = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), Se(!e.createOnAllSeries, d), u ? i.eachRawSeriesByType(u, p) : c ? c(i, n).each(p) : (h = !1, N(i.getSeries(), p));
      function p(g) {
        var v = g.uid, O = l.set(v, s && s.get(v) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (f = !0, Kp({
          reset: Vue,
          onDirty: Bue
        })));
        O.context = {
          model: g,
          overallProgress: h
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, O.agent = o, O.__block = h, a._pipe(g, O);
      }
      f && o.dirty();
    }, r.prototype._pipe = function(e, t) {
      var i = e.uid, n = this._pipelineMap.get(i);
      !n.head && (n.head = t), n.tail && n.tail.pipe(t), n.tail = t, t.__idxInPipeline = n.count++, t.__pipeline = n;
    }, r.wrapStageHandler = function(e, t) {
      return ve(e) && (e = {
        overallReset: e,
        seriesType: Wue(e)
      }), e.uid = rd("stageHandler"), t && (e.visualType = t), e;
    }, r;
  }()
);
function $ue(r) {
  r.overallReset(r.ecModel, r.api, r.payload);
}
function Vue(r) {
  return r.overallProgress && Gue;
}
function Gue() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function Bue() {
  this.agent && this.agent.dirty();
}
function Fue(r) {
  return r.plan ? r.plan(r.model, r.ecModel, r.api, r.payload) : null;
}
function Xue(r) {
  r.useClearVisual && r.data.clearAllVisual();
  var e = r.resetDefines = It(r.reset(r.model, r.ecModel, r.api, r.payload));
  return e.length > 1 ? Y(e, function(t, i) {
    return jW(i);
  }) : Yue;
}
var Yue = jW(0);
function jW(r) {
  return function(e, t) {
    var i = t.data, n = t.resetDefines[r];
    if (n && n.dataEach)
      for (var a = e.start; a < e.end; a++)
        n.dataEach(i, a);
    else
      n && n.progress && n.progress(e, i);
  };
}
function Hue(r) {
  return r.data.count();
}
function Wue(r) {
  gb = null;
  try {
    r(Ug, KW);
  } catch {
  }
  return gb;
}
var Ug = {}, KW = {}, gb;
JW(Ug, yW);
JW(KW, RW);
Ug.eachSeriesByType = Ug.eachRawSeriesByType = function(r) {
  gb = r;
};
Ug.eachComponent = function(r) {
  r.mainType === "series" && r.subType && (gb = r.subType);
};
function JW(r, e) {
  for (var t in e.prototype)
    r[t] = ur;
}
const ez = Uue;
var gk = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"];
const zue = {
  color: gk,
  colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], gk]
};
var Ai = "#B9B8CE", vk = "#100C2A", kO = function() {
  return {
    axisLine: {
      lineStyle: {
        color: Ai
      }
    },
    splitLine: {
      lineStyle: {
        color: "#484753"
      }
    },
    splitArea: {
      areaStyle: {
        color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: "#20203B"
      }
    }
  };
}, Ok = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], tz = {
  darkMode: !0,
  color: Ok,
  backgroundColor: vk,
  axisPointer: {
    lineStyle: {
      color: "#817f91"
    },
    crossStyle: {
      color: "#817f91"
    },
    label: {
      // TODO Contrast of label backgorundColor
      color: "#fff"
    }
  },
  legend: {
    textStyle: {
      color: Ai
    }
  },
  textStyle: {
    color: Ai
  },
  title: {
    textStyle: {
      color: "#EEF1FA"
    },
    subtextStyle: {
      color: "#B9B8CE"
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: Ai
    }
  },
  dataZoom: {
    borderColor: "#71708A",
    textStyle: {
      color: Ai
    },
    brushStyle: {
      color: "rgba(135,163,206,0.3)"
    },
    handleStyle: {
      color: "#353450",
      borderColor: "#C5CBE3"
    },
    moveHandleStyle: {
      color: "#B0B6C3",
      opacity: 0.3
    },
    fillerColor: "rgba(135,163,206,0.2)",
    emphasis: {
      handleStyle: {
        borderColor: "#91B7F2",
        color: "#4D587D"
      },
      moveHandleStyle: {
        color: "#636D9A",
        opacity: 0.7
      }
    },
    dataBackground: {
      lineStyle: {
        color: "#71708A",
        width: 1
      },
      areaStyle: {
        color: "#71708A"
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: "#87A3CE"
      },
      areaStyle: {
        color: "#87A3CE"
      }
    }
  },
  visualMap: {
    textStyle: {
      color: Ai
    }
  },
  timeline: {
    lineStyle: {
      color: Ai
    },
    label: {
      color: Ai
    },
    controlStyle: {
      color: Ai,
      borderColor: Ai
    }
  },
  calendar: {
    itemStyle: {
      color: vk
    },
    dayLabel: {
      color: Ai
    },
    monthLabel: {
      color: Ai
    },
    yearLabel: {
      color: Ai
    }
  },
  timeAxis: kO(),
  logAxis: kO(),
  valueAxis: kO(),
  categoryAxis: kO(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: Ok
  },
  gauge: {
    title: {
      color: Ai
    },
    axisLine: {
      lineStyle: {
        color: [[1, "rgba(207,212,219,0.2)"]]
      }
    },
    axisLabel: {
      color: Ai
    },
    detail: {
      color: "#EEF1FA"
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  }
};
tz.categoryAxis.splitLine.show = !1;
const Zue = tz;
var que = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.normalizeQuery = function(e) {
      var t = {}, i = {}, n = {};
      if (ne(e)) {
        var a = so(e);
        t.mainType = a.main || null, t.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        N(e, function(l, u) {
          for (var c = !1, h = 0; h < o.length; h++) {
            var f = o[h], d = u.lastIndexOf(f);
            if (d > 0 && d === u.length - f.length) {
              var p = u.slice(0, d);
              p !== "data" && (t.mainType = p, t[f.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (i[u] = l, c = !0), c || (n[u] = l);
        });
      }
      return {
        cptQuery: t,
        dataQuery: i,
        otherQuery: n
      };
    }, r.prototype.filter = function(e, t) {
      var i = this.eventInfo;
      if (!i)
        return !0;
      var n = i.targetEl, a = i.packedEvent, o = i.model, s = i.view;
      if (!o || !s)
        return !0;
      var l = t.cptQuery, u = t.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, t.otherQuery, n, a));
      function c(h, f, d, p) {
        return h[d] == null || f[p || d] === h[d];
      }
    }, r.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, r;
  }()
), mC = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], mk = mC.concat(["symbolKeepAspect"]), jue = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    var t = r.getData();
    if (r.legendIcon && t.setVisual("legendIcon", r.legendIcon), !r.hasSymbolVisual)
      return;
    for (var i = {}, n = {}, a = !1, o = 0; o < mC.length; o++) {
      var s = mC[o], l = r.get(s);
      ve(l) ? (a = !0, n[s] = l) : i[s] = l;
    }
    if (i.symbol = i.symbol || r.defaultSymbol, t.setVisual(B({
      legendIcon: r.legendIcon || i.symbol,
      symbolKeepAspect: r.get("symbolKeepAspect")
    }, i)), e.isSeriesFiltered(r))
      return;
    var u = Ze(n);
    function c(h, f) {
      for (var d = r.getRawValue(f), p = r.getDataParams(f), g = 0; g < u.length; g++) {
        var v = u[g];
        h.setItemVisual(f, v, n[v](d, p));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, Kue = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    if (!r.hasSymbolVisual || e.isSeriesFiltered(r))
      return;
    var t = r.getData();
    function i(n, a) {
      for (var o = n.getItemModel(a), s = 0; s < mk.length; s++) {
        var l = mk[s], u = o.getShallow(l, !0);
        u != null && n.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: t.hasItemOption ? i : null
    };
  }
};
function gN(r, e, t) {
  switch (t) {
    case "color":
      var i = r.getItemVisual(e, "style");
      return i[r.getVisual("drawType")];
    case "opacity":
      return r.getItemVisual(e, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getItemVisual(e, t);
    default:
      ({}).NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Nv(r, e) {
  switch (e) {
    case "color":
      var t = r.getVisual("style");
      return t[r.getVisual("drawType")];
    case "opacity":
      return r.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return r.getVisual(e);
    default:
      ({}).NODE_ENV !== "production" && console.warn("Unknown visual type " + e);
  }
}
function rz(r, e, t, i) {
  switch (t) {
    case "color":
      var n = r.ensureUniqueItemVisual(e, "style");
      n[r.getVisual("drawType")] = i, r.setItemVisual(e, "colorFromPalette", !1);
      break;
    case "opacity":
      r.ensureUniqueItemVisual(e, "style").opacity = i;
      break;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      r.setItemVisual(e, t, i);
      break;
    default:
      ({}).NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function iz(r, e) {
  function t(i, n) {
    var a = [];
    return i.eachComponent({
      mainType: "series",
      subType: r,
      query: n
    }, function(o) {
      a.push(o.seriesIndex);
    }), a;
  }
  N([[r + "ToggleSelect", "toggleSelect"], [r + "Select", "select"], [r + "UnSelect", "unselect"]], function(i) {
    e(i[0], function(n, a, o) {
      n = B({}, n), {}.NODE_ENV !== "production" && fr(n.type, i[1]), o.dispatchAction(B(n, {
        type: i[1],
        seriesIndex: t(a, n)
      }));
    });
  });
}
function mh(r, e, t, i, n) {
  var a = r + e;
  t.isSilent(a) || ({}.NODE_ENV !== "production" && Pa("event " + a + " is deprecated."), i.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = n.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var h = o.getData(), f = wc(h, n.fromActionPayload);
        t.trigger(a, {
          type: a,
          seriesId: o.id,
          name: X(f) ? h.getName(f[0]) : h.getName(f),
          selected: ne(l) ? l : B({}, l)
        });
      }
  }));
}
function Jue(r, e, t) {
  r.on("selectchanged", function(i) {
    var n = t.getModel();
    i.isFromClick ? (mh("map", "selectchanged", e, n, i), mh("pie", "selectchanged", e, n, i)) : i.fromAction === "select" ? (mh("map", "selected", e, n, i), mh("pie", "selected", e, n, i)) : i.fromAction === "unselect" && (mh("map", "unselected", e, n, i), mh("pie", "unselected", e, n, i));
  });
}
function ju(r, e, t) {
  for (var i; r && !(e(r) && (i = r, t)); )
    r = r.__hostTarget || r.parent;
  return i;
}
var ece = Math.round(Math.random() * 9), tce = typeof Object.defineProperty == "function", rce = function() {
  function r() {
    this._id = "__ec_inner_" + ece++;
  }
  return r.prototype.get = function(e) {
    return this._guard(e)[this._id];
  }, r.prototype.set = function(e, t) {
    var i = this._guard(e);
    return tce ? Object.defineProperty(i, this._id, {
      value: t,
      enumerable: !1,
      configurable: !0
    }) : i[this._id] = t, this;
  }, r.prototype.delete = function(e) {
    return this.has(e) ? (delete this._guard(e)[this._id], !0) : !1;
  }, r.prototype.has = function(e) {
    return !!this._guard(e)[this._id];
  }, r.prototype._guard = function(e) {
    if (e !== Object(e))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return e;
  }, r;
}();
const ice = rce;
var nce = He.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.cx, i = e.cy, n = e.width / 2, a = e.height / 2;
    r.moveTo(t, i - a), r.lineTo(t + n, i + a), r.lineTo(t - n, i + a), r.closePath();
  }
}), ace = He.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.cx, i = e.cy, n = e.width / 2, a = e.height / 2;
    r.moveTo(t, i - a), r.lineTo(t + n, i), r.lineTo(t, i + a), r.lineTo(t - n, i), r.closePath();
  }
}), oce = He.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.x, i = e.y, n = e.width / 5 * 3, a = Math.max(n, e.height), o = n / 2, s = o * o / (a - o), l = i - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, h = Math.sin(u), f = Math.cos(u), d = o * 0.6, p = o * 0.7;
    r.moveTo(t - c, l + s), r.arc(t, l, o, Math.PI - u, Math.PI * 2 + u), r.bezierCurveTo(t + c - h * d, l + s + f * d, t, i - p, t, i), r.bezierCurveTo(t, i - p, t - c + h * d, l + s + f * d, t - c, l + s), r.closePath();
  }
}), sce = He.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(r, e) {
    var t = e.height, i = e.width, n = e.x, a = e.y, o = i / 3 * 2;
    r.moveTo(n, a), r.lineTo(n + o, a + t), r.lineTo(n, a + t / 4 * 3), r.lineTo(n - o, a + t), r.lineTo(n, a), r.closePath();
  }
}), lce = {
  line: Gr,
  rect: ht,
  roundRect: ht,
  square: ht,
  circle: Co,
  diamond: ace,
  pin: oce,
  arrow: sce,
  triangle: nce
}, uce = {
  line: function(r, e, t, i, n) {
    n.x1 = r, n.y1 = e + i / 2, n.x2 = r + t, n.y2 = e + i / 2;
  },
  rect: function(r, e, t, i, n) {
    n.x = r, n.y = e, n.width = t, n.height = i;
  },
  roundRect: function(r, e, t, i, n) {
    n.x = r, n.y = e, n.width = t, n.height = i, n.r = Math.min(t, i) / 4;
  },
  square: function(r, e, t, i, n) {
    var a = Math.min(t, i);
    n.x = r, n.y = e, n.width = a, n.height = a;
  },
  circle: function(r, e, t, i, n) {
    n.cx = r + t / 2, n.cy = e + i / 2, n.r = Math.min(t, i) / 2;
  },
  diamond: function(r, e, t, i, n) {
    n.cx = r + t / 2, n.cy = e + i / 2, n.width = t, n.height = i;
  },
  pin: function(r, e, t, i, n) {
    n.x = r + t / 2, n.y = e + i / 2, n.width = t, n.height = i;
  },
  arrow: function(r, e, t, i, n) {
    n.x = r + t / 2, n.y = e + i / 2, n.width = t, n.height = i;
  },
  triangle: function(r, e, t, i, n) {
    n.cx = r + t / 2, n.cy = e + i / 2, n.width = t, n.height = i;
  }
}, vb = {};
N(lce, function(r, e) {
  vb[e] = new r();
});
var cce = He.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(r, e, t) {
    var i = ib(r, e, t), n = this.shape;
    return n && n.symbolType === "pin" && e.position === "inside" && (i.y = t.y + t.height * 0.4), i;
  },
  buildPath: function(r, e, t) {
    var i = e.symbolType;
    if (i !== "none") {
      var n = vb[i];
      n || (i = "rect", n = vb[i]), uce[i](e.x, e.y, e.width, e.height, n.shape), n.buildPath(r, n.shape, t);
    }
  }
});
function hce(r, e) {
  if (this.type !== "image") {
    var t = this.style;
    this.__isEmptyBrush ? (t.stroke = r, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = r : t.fill = r, this.markRedraw();
  }
}
function Er(r, e, t, i, n, a, o) {
  var s = r.indexOf("empty") === 0;
  s && (r = r.substr(5, 1).toLowerCase() + r.substr(6));
  var l;
  return r.indexOf("image://") === 0 ? l = FH(r.slice(8), new Ve(e, t, i, n), o ? "center" : "cover") : r.indexOf("path://") === 0 ? l = bT(r.slice(7), {}, new Ve(e, t, i, n), o ? "center" : "cover") : l = new cce({
    shape: {
      symbolType: r,
      x: e,
      y: t,
      width: i,
      height: n
    }
  }), l.__isEmptyBrush = s, l.setColor = hce, a && l.setColor(a), l;
}
function cd(r) {
  return X(r) || (r = [+r, +r]), [r[0] || 0, r[1] || 0];
}
function qc(r, e) {
  if (r != null)
    return X(r) || (r = [r, r]), [K(r[0], e[0]) || 0, K(ke(r[1], r[0]), e[1]) || 0];
}
function Ku(r) {
  return isFinite(r);
}
function fce(r, e, t) {
  var i = e.x == null ? 0 : e.x, n = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, o = e.y2 == null ? 0 : e.y2;
  e.global || (i = i * t.width + t.x, n = n * t.width + t.x, a = a * t.height + t.y, o = o * t.height + t.y), i = Ku(i) ? i : 0, n = Ku(n) ? n : 1, a = Ku(a) ? a : 0, o = Ku(o) ? o : 0;
  var s = r.createLinearGradient(i, a, n, o);
  return s;
}
function dce(r, e, t) {
  var i = t.width, n = t.height, a = Math.min(i, n), o = e.x == null ? 0.5 : e.x, s = e.y == null ? 0.5 : e.y, l = e.r == null ? 0.5 : e.r;
  e.global || (o = o * i + t.x, s = s * n + t.y, l = l * a), o = Ku(o) ? o : 0.5, s = Ku(s) ? s : 0.5, l = l >= 0 && Ku(l) ? l : 0.5;
  var u = r.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function EC(r, e, t) {
  for (var i = e.type === "radial" ? dce(r, e, t) : fce(r, e, t), n = e.colorStops, a = 0; a < n.length; a++)
    i.addColorStop(n[a].offset, n[a].color);
  return i;
}
function pce(r, e) {
  if (r === e || !r && !e)
    return !1;
  if (!r || !e || r.length !== e.length)
    return !0;
  for (var t = 0; t < r.length; t++)
    if (r[t] !== e[t])
      return !0;
  return !1;
}
function QO(r) {
  return parseInt(r, 10);
}
function zh(r, e, t) {
  var i = ["width", "height"][e], n = ["clientWidth", "clientHeight"][e], a = ["paddingLeft", "paddingTop"][e], o = ["paddingRight", "paddingBottom"][e];
  if (t[i] != null && t[i] !== "auto")
    return parseFloat(t[i]);
  var s = document.defaultView.getComputedStyle(r);
  return (r[n] || QO(s[i]) || QO(r.style[i])) - (QO(s[a]) || 0) - (QO(s[o]) || 0) | 0;
}
function gce(r, e) {
  return !r || r === "solid" || !(e > 0) ? null : r === "dashed" ? [4 * e, 2 * e] : r === "dotted" ? [e] : pt(r) ? [r] : X(r) ? r : null;
}
function vN(r) {
  var e = r.style, t = e.lineDash && e.lineWidth > 0 && gce(e.lineDash, e.lineWidth), i = e.lineDashOffset;
  if (t) {
    var n = e.strokeNoScale && r.getLineScale ? r.getLineScale() : 1;
    n && n !== 1 && (t = Y(t, function(a) {
      return a / n;
    }), i /= n);
  }
  return [t, i];
}
var vce = new _o(!0);
function Ob(r) {
  var e = r.stroke;
  return !(e == null || e === "none" || !(r.lineWidth > 0));
}
function Ek(r) {
  return typeof r == "string" && r !== "none";
}
function mb(r) {
  var e = r.fill;
  return e != null && e !== "none";
}
function bk(r, e) {
  if (e.fillOpacity != null && e.fillOpacity !== 1) {
    var t = r.globalAlpha;
    r.globalAlpha = e.fillOpacity * e.opacity, r.fill(), r.globalAlpha = t;
  } else
    r.fill();
}
function Sk(r, e) {
  if (e.strokeOpacity != null && e.strokeOpacity !== 1) {
    var t = r.globalAlpha;
    r.globalAlpha = e.strokeOpacity * e.opacity, r.stroke(), r.globalAlpha = t;
  } else
    r.stroke();
}
function bC(r, e, t) {
  var i = V1(e.image, e.__image, t);
  if (dT(i)) {
    var n = r.createPattern(i, e.repeat || "repeat");
    if (typeof DOMMatrix == "function" && n && n.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * Fm), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), n.setTransform(a);
    }
    return n;
  }
}
function Oce(r, e, t, i) {
  var n, a = Ob(t), o = mb(t), s = t.strokePercent, l = s < 1, u = !e.path;
  (!e.silent || l) && u && e.createPathProxy();
  var c = e.path || vce, h = e.__dirty;
  if (!i) {
    var f = t.fill, d = t.stroke, p = o && !!f.colorStops, g = a && !!d.colorStops, v = o && !!f.image, O = a && !!d.image, m = void 0, E = void 0, b = void 0, S = void 0, T = void 0;
    (p || g) && (T = e.getBoundingRect()), p && (m = h ? EC(r, f, T) : e.__canvasFillGradient, e.__canvasFillGradient = m), g && (E = h ? EC(r, d, T) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = E), v && (b = h || !e.__canvasFillPattern ? bC(r, f, e) : e.__canvasFillPattern, e.__canvasFillPattern = b), O && (S = h || !e.__canvasStrokePattern ? bC(r, d, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = b), p ? r.fillStyle = m : v && (b ? r.fillStyle = b : o = !1), g ? r.strokeStyle = E : O && (S ? r.strokeStyle = S : a = !1);
  }
  var y = e.getGlobalScale();
  c.setScale(y[0], y[1], e.segmentIgnoreThreshold);
  var R, _;
  r.setLineDash && t.lineDash && (n = vN(e), R = n[0], _ = n[1]);
  var C = !0;
  (u || h & kh) && (c.setDPR(r.dpr), l ? c.setContext(null) : (c.setContext(r), C = !1), c.reset(), e.buildPath(c, e.shape, i), c.toStatic(), e.pathUpdated()), C && c.rebuildPath(r, l ? s : 1), R && (r.setLineDash(R), r.lineDashOffset = _), i || (t.strokeFirst ? (a && Sk(r, t), o && bk(r, t)) : (o && bk(r, t), a && Sk(r, t))), R && r.setLineDash([]);
}
function mce(r, e, t) {
  var i = e.__image = V1(t.image, e.__image, e, e.onload);
  if (!(!i || !dT(i))) {
    var n = t.x || 0, a = t.y || 0, o = e.getWidth(), s = e.getHeight(), l = i.width / i.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = i.width, s = i.height), t.sWidth && t.sHeight) {
      var u = t.sx || 0, c = t.sy || 0;
      r.drawImage(i, u, c, t.sWidth, t.sHeight, n, a, o, s);
    } else if (t.sx && t.sy) {
      var u = t.sx, c = t.sy, h = o - u, f = s - c;
      r.drawImage(i, u, c, h, f, n, a, o, s);
    } else
      r.drawImage(i, n, a, o, s);
  }
}
function Ece(r, e, t) {
  var i, n = t.text;
  if (n != null && (n += ""), n) {
    r.font = t.font || Cl, r.textAlign = t.textAlign, r.textBaseline = t.textBaseline;
    var a = void 0, o = void 0;
    r.setLineDash && t.lineDash && (i = vN(e), a = i[0], o = i[1]), a && (r.setLineDash(a), r.lineDashOffset = o), t.strokeFirst ? (Ob(t) && r.strokeText(n, t.x, t.y), mb(t) && r.fillText(n, t.x, t.y)) : (mb(t) && r.fillText(n, t.x, t.y), Ob(t) && r.strokeText(n, t.x, t.y)), a && r.setLineDash([]);
  }
}
var Tk = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], yk = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function nz(r, e, t, i, n) {
  var a = !1;
  if (!i && (t = t || {}, e === t))
    return !1;
  if (i || e.opacity !== t.opacity) {
    Zi(r, n), a = !0;
    var o = Math.max(Math.min(e.opacity, 1), 0);
    r.globalAlpha = isNaN(o) ? fc.opacity : o;
  }
  (i || e.blend !== t.blend) && (a || (Zi(r, n), a = !0), r.globalCompositeOperation = e.blend || fc.blend);
  for (var s = 0; s < Tk.length; s++) {
    var l = Tk[s];
    (i || e[l] !== t[l]) && (a || (Zi(r, n), a = !0), r[l] = r.dpr * (e[l] || 0));
  }
  return (i || e.shadowColor !== t.shadowColor) && (a || (Zi(r, n), a = !0), r.shadowColor = e.shadowColor || fc.shadowColor), a;
}
function Rk(r, e, t, i, n) {
  var a = $g(e, n.inHover), o = i ? null : t && $g(t, n.inHover) || {};
  if (a === o)
    return !1;
  var s = nz(r, a, o, i, n);
  if ((i || a.fill !== o.fill) && (s || (Zi(r, n), s = !0), Ek(a.fill) && (r.fillStyle = a.fill)), (i || a.stroke !== o.stroke) && (s || (Zi(r, n), s = !0), Ek(a.stroke) && (r.strokeStyle = a.stroke)), (i || a.opacity !== o.opacity) && (s || (Zi(r, n), s = !0), r.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1);
    r.lineWidth !== u && (s || (Zi(r, n), s = !0), r.lineWidth = u);
  }
  for (var c = 0; c < yk.length; c++) {
    var h = yk[c], f = h[0];
    (i || a[f] !== o[f]) && (s || (Zi(r, n), s = !0), r[f] = a[f] || h[1]);
  }
  return s;
}
function bce(r, e, t, i, n) {
  return nz(r, $g(e, n.inHover), t && $g(t, n.inHover), i, n);
}
function az(r, e) {
  var t = e.transform, i = r.dpr || 1;
  t ? r.setTransform(i * t[0], i * t[1], i * t[2], i * t[3], i * t[4], i * t[5]) : r.setTransform(i, 0, 0, i, 0, 0);
}
function Sce(r, e, t) {
  for (var i = !1, n = 0; n < r.length; n++) {
    var a = r[n];
    i = i || a.isZeroArea(), az(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip();
  }
  t.allClipped = i;
}
function Tce(r, e) {
  return r && e ? r[0] !== e[0] || r[1] !== e[1] || r[2] !== e[2] || r[3] !== e[3] || r[4] !== e[4] || r[5] !== e[5] : !(!r && !e);
}
var Ak = 1, _k = 2, Ck = 3, Ik = 4;
function yce(r) {
  var e = mb(r), t = Ob(r);
  return !(r.lineDash || !(+e ^ +t) || e && typeof r.fill != "string" || t && typeof r.stroke != "string" || r.strokePercent < 1 || r.strokeOpacity < 1 || r.fillOpacity < 1);
}
function Zi(r, e) {
  e.batchFill && r.fill(), e.batchStroke && r.stroke(), e.batchFill = "", e.batchStroke = "";
}
function $g(r, e) {
  return e && r.__hoverStyle || r.style;
}
function oz(r, e) {
  Ju(r, e, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Ju(r, e, t, i) {
  var n = e.transform;
  if (!e.shouldBePainted(t.viewWidth, t.viewHeight, !1, !1)) {
    e.__dirty &= ~vn, e.__isRendered = !1;
    return;
  }
  var a = e.__clipPaths, o = t.prevElClipPaths, s = !1, l = !1;
  if ((!o || pce(a, o)) && (o && o.length && (Zi(r, t), r.restore(), l = s = !0, t.prevElClipPaths = null, t.allClipped = !1, t.prevEl = null), a && a.length && (Zi(r, t), r.save(), Sce(a, r, t), s = !0), t.prevElClipPaths = a), t.allClipped) {
    e.__isRendered = !1;
    return;
  }
  e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush();
  var u = t.prevEl;
  u || (l = s = !0);
  var c = e instanceof He && e.autoBatch && yce(e.style);
  s || Tce(n, u.transform) ? (Zi(r, t), az(r, e)) : c || Zi(r, t);
  var h = $g(e, t.inHover);
  e instanceof He ? (t.lastDrawType !== Ak && (l = !0, t.lastDrawType = Ak), Rk(r, e, u, l, t), (!c || !t.batchFill && !t.batchStroke) && r.beginPath(), Oce(r, e, h, c), c && (t.batchFill = h.fill || "", t.batchStroke = h.stroke || "")) : e instanceof Ng ? (t.lastDrawType !== Ck && (l = !0, t.lastDrawType = Ck), Rk(r, e, u, l, t), Ece(r, e, h)) : e instanceof ni ? (t.lastDrawType !== _k && (l = !0, t.lastDrawType = _k), bce(r, e, u, l, t), mce(r, e, h)) : e.getTemporalDisplayables && (t.lastDrawType !== Ik && (l = !0, t.lastDrawType = Ik), Rce(r, e, t)), c && i && Zi(r, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = !0;
}
function Rce(r, e, t) {
  var i = e.getDisplayables(), n = e.getTemporalDisplayables();
  r.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: t.viewWidth,
    viewHeight: t.viewHeight,
    inHover: t.inHover
  }, o, s;
  for (o = e.getCursor(), s = i.length; o < s; o++) {
    var l = i[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ju(r, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = n.length; u < c; u++) {
    var l = n[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ju(r, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  e.clearTemporalDisplayables(), e.notClear = !0, r.restore();
}
var L0 = new ice(), wk = new Tv(100), Nk = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function xf(r, e) {
  if (r === "none")
    return null;
  var t = e.getDevicePixelRatio(), i = e.getZr(), n = i.painter.type === "svg";
  r.dirty && L0.delete(r);
  var a = L0.get(r);
  if (a)
    return a;
  var o = Te(r, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = n ? 1 : 1 / t, L0.set(r, s), r.dirty = !1, s;
  function l(u) {
    for (var c = [t], h = !0, f = 0; f < Nk.length; ++f) {
      var d = o[Nk[f]];
      if (d != null && !X(d) && !ne(d) && !pt(d) && typeof d != "boolean") {
        h = !1;
        break;
      }
      c.push(d);
    }
    var p;
    if (h) {
      p = c.join(",") + (n ? "-svg" : "");
      var g = wk.get(p);
      g && (n ? u.svgElement = g : u.image = g);
    }
    var v = lz(o.dashArrayX), O = Ace(o.dashArrayY), m = sz(o.symbol), E = _ce(v), b = uz(O), S = !n && Il.createCanvas(), T = n && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, y = _(), R;
    S && (S.width = y.width * t, S.height = y.height * t, R = S.getContext("2d")), C(), h && wk.put(p, S || T), u.image = S, u.svgElement = T, u.svgWidth = y.width, u.svgHeight = y.height;
    function _() {
      for (var I = 1, w = 0, x = E.length; w < x; ++w)
        I = BD(I, E[w]);
      for (var P = 1, w = 0, x = m.length; w < x; ++w)
        P = BD(P, m[w].length);
      I *= P;
      var L = b * E.length * m.length;
      if ({}.NODE_ENV !== "production") {
        var D = function(U) {
          console.warn("Calculated decal size is greater than " + U + " due to decal option settings so " + U + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + U + " to be larger to avoid incontinuity.");
        };
        I > o.maxTileWidth && D("maxTileWidth"), L > o.maxTileHeight && D("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(I, o.maxTileWidth)),
        height: Math.max(1, Math.min(L, o.maxTileHeight))
      };
    }
    function C() {
      R && (R.clearRect(0, 0, S.width, S.height), o.backgroundColor && (R.fillStyle = o.backgroundColor, R.fillRect(0, 0, S.width, S.height)));
      for (var I = 0, w = 0; w < O.length; ++w)
        I += O[w];
      if (I <= 0)
        return;
      for (var x = -b, P = 0, L = 0, D = 0; x < y.height; ) {
        if (P % 2 === 0) {
          for (var U = L / 2 % m.length, Q = 0, V = 0, F = 0; Q < y.width * 2; ) {
            for (var j = 0, w = 0; w < v[D].length; ++w)
              j += v[D][w];
            if (j <= 0)
              break;
            if (V % 2 === 0) {
              var ae = (1 - o.symbolSize) * 0.5, ce = Q + v[D][V] * ae, ge = x + O[P] * ae, Be = v[D][V] * o.symbolSize, We = O[P] * o.symbolSize, Ne = F / 2 % m[U].length;
              Ee(ce, ge, Be, We, m[U][Ne]);
            }
            Q += v[D][V], ++F, ++V, V === v[D].length && (V = 0);
          }
          ++D, D === v.length && (D = 0);
        }
        x += O[P], ++L, ++P, P === O.length && (P = 0);
      }
      function Ee(Ge, Ie, he, xe, M) {
        var k = n ? 1 : t, G = Er(M, Ge * k, Ie * k, he * k, xe * k, o.color, o.symbolKeepAspect);
        if (n) {
          var H = i.painter.renderOneToVNode(G);
          H && T.children.push(H);
        } else
          oz(R, G);
      }
    }
  }
}
function sz(r) {
  if (!r || r.length === 0)
    return [["rect"]];
  if (ne(r))
    return [[r]];
  for (var e = !0, t = 0; t < r.length; ++t)
    if (!ne(r[t])) {
      e = !1;
      break;
    }
  if (e)
    return sz([r]);
  for (var i = [], t = 0; t < r.length; ++t)
    ne(r[t]) ? i.push([r[t]]) : i.push(r[t]);
  return i;
}
function lz(r) {
  if (!r || r.length === 0)
    return [[0, 0]];
  if (pt(r)) {
    var e = Math.ceil(r);
    return [[e, e]];
  }
  for (var t = !0, i = 0; i < r.length; ++i)
    if (!pt(r[i])) {
      t = !1;
      break;
    }
  if (t)
    return lz([r]);
  for (var n = [], i = 0; i < r.length; ++i)
    if (pt(r[i])) {
      var e = Math.ceil(r[i]);
      n.push([e, e]);
    } else {
      var e = Y(r[i], function(s) {
        return Math.ceil(s);
      });
      e.length % 2 === 1 ? n.push(e.concat(e)) : n.push(e);
    }
  return n;
}
function Ace(r) {
  if (!r || typeof r == "object" && r.length === 0)
    return [0, 0];
  if (pt(r)) {
    var e = Math.ceil(r);
    return [e, e];
  }
  var t = Y(r, function(i) {
    return Math.ceil(i);
  });
  return r.length % 2 ? t.concat(t) : t;
}
function _ce(r) {
  return Y(r, function(e) {
    return uz(e);
  });
}
function uz(r) {
  for (var e = 0, t = 0; t < r.length; ++t)
    e += r[t];
  return r.length % 2 === 1 ? e * 2 : e;
}
function Cce(r, e) {
  r.eachRawSeries(function(t) {
    if (!r.isSeriesFiltered(t)) {
      var i = t.getData();
      i.hasItemVisual() && i.each(function(o) {
        var s = i.getItemVisual(o, "decal");
        if (s) {
          var l = i.ensureUniqueItemVisual(o, "style");
          l.decal = xf(s, e);
        }
      });
      var n = i.getVisual("decal");
      if (n) {
        var a = i.getVisual("style");
        a.decal = xf(n, e);
      }
    }
  });
}
var Ice = new oa();
const Ya = Ice;
var Eb = {};
function wce(r, e) {
  ({}).NODE_ENV !== "production" && Eb[r] && ti("Already has an implementation of " + r + "."), Eb[r] = e;
}
function Nce(r) {
  return {}.NODE_ENV !== "production" && (Eb[r] || ti("Implementation of " + r + " doesn't exists.")), Eb[r];
}
var xce = 1, Pce = 800, Lce = 900, Dce = 1e3, Mce = 2e3, kce = 5e3, cz = 1e3, Qce = 1100, ON = 2e3, hz = 3e3, Uce = 4e3, PT = 4500, $ce = 4600, Vce = 5e3, Gce = 6e3, fz = 7e3, Bce = {
  PROCESSOR: {
    FILTER: Dce,
    SERIES_FILTER: Pce,
    STATISTIC: kce
  },
  VISUAL: {
    LAYOUT: cz,
    PROGRESSIVE_LAYOUT: Qce,
    GLOBAL: ON,
    CHART: hz,
    POST_CHART_LAYOUT: $ce,
    COMPONENT: Uce,
    BRUSH: Vce,
    CHART_ITEM: PT,
    ARIA: Gce,
    DECAL: fz
  }
}, hi = "__flagInMainProcess", Bi = "__pendingUpdate", D0 = "__needsUpdateStatus", xk = /^[a-zA-Z0-9_]+$/;
function dz(r) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    if (this.isDisposed()) {
      cn(this.id);
      return;
    }
    return gz(this, r, e);
  };
}
function pz(r) {
  return function() {
    for (var e = [], t = 0; t < arguments.length; t++)
      e[t] = arguments[t];
    return gz(this, r, e);
  };
}
function gz(r, e, t) {
  return t[0] = t[0] && t[0].toLowerCase(), oa.prototype[e].apply(r, t);
}
var vz = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(oa)
), Oz = vz.prototype;
Oz.on = pz("on");
Oz.off = pz("off");
var Eh, M0, UO, Ls, k0, Q0, U0, Ud, $d, Pk, Lk, $0, Dk, $O, Mk, xn, kk, Fce = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this, new que()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], n = n || {}, ne(i) && (i = mz[i]), a._dom = t;
      var o = "canvas", s = "auto", l = !1;
      if ({}.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          ct.hasGlobalWindow ? window : global
        );
        o = u.__ECHARTS__DEFAULT__RENDERER__ || o, s = ke(u.__ECHARTS__DEFAULT__COARSE_POINTER, s);
        var c = u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__;
        l = c ?? l;
      }
      var h = a._zr = UD(t, {
        renderer: n.renderer || o,
        devicePixelRatio: n.devicePixelRatio,
        width: n.width,
        height: n.height,
        ssr: n.ssr,
        useDirtyRect: ke(n.useDirtyRect, l),
        useCoarsePointer: ke(n.useCoarsePointer, s),
        pointerSize: n.pointerSize
      });
      a._ssr = n.ssr, a._throttledZrFlush = pN(ue(h.flush, h), 17), i = ye(i), i && _W(i, !0), a._theme = i, a._locale = tle(n.locale || eW), a._coordSysMgr = new sd();
      var f = a._api = Mk(a);
      function d(p, g) {
        return p.__prio - g.__prio;
      }
      return Hm(Tb, d), Hm(SC, d), a._scheduler = new ez(a, f, SC, Tb), a._messageCenter = new vz(), a._initEvents(), a.resize = ue(a.resize, a), h.animation.on("frame", a._onframe, a), Pk(h, a), Lk(h, a), ZE(a), a;
    }
    return e.prototype._onframe = function() {
      if (!this._disposed) {
        kk(this);
        var t = this._scheduler;
        if (this[Bi]) {
          var i = this[Bi].silent;
          this[hi] = !0;
          try {
            Eh(this), Ls.update.call(this, null, this[Bi].updateParams);
          } catch (l) {
            throw this[hi] = !1, this[Bi] = null, l;
          }
          this._zr.flush(), this[hi] = !1, this[Bi] = null, Ud.call(this, i), $d.call(this, i);
        } else if (t.unfinished) {
          var n = xce, a = this._model, o = this._api;
          t.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            t.performSeriesTasks(a), t.performDataProcessorTasks(a), Q0(this, a), t.performVisualTasks(a), $O(this, this._model, o, "remain", {}), n -= +/* @__PURE__ */ new Date() - s;
          } while (n > 0 && t.unfinished);
          t.unfinished || this._zr.flush();
        }
      }
    }, e.prototype.getDom = function() {
      return this._dom;
    }, e.prototype.getId = function() {
      return this.id;
    }, e.prototype.getZr = function() {
      return this._zr;
    }, e.prototype.isSSR = function() {
      return this._ssr;
    }, e.prototype.setOption = function(t, i, n) {
      if (this[hi]) {
        ({}).NODE_ENV !== "production" && ti("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        cn(this.id);
        return;
      }
      var a, o, s;
      if (be(i) && (n = i.lazyUpdate, a = i.silent, o = i.replaceMerge, s = i.transition, i = i.notMerge), this[hi] = !0, !this._model || i) {
        var l = new Mle(this._api), u = this._theme, c = this._model = new yW();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(t, {
        replaceMerge: o
      }, TC);
      var h = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (n)
        this[Bi] = {
          silent: a,
          updateParams: h
        }, this[hi] = !1, this.getZr().wakeUp();
      else {
        try {
          Eh(this), Ls.update.call(this, null, h);
        } catch (f) {
          throw this[Bi] = null, this[hi] = !1, f;
        }
        this._ssr || this._zr.flush(), this[Bi] = null, this[hi] = !1, Ud.call(this, a), $d.call(this, a);
      }
    }, e.prototype.setTheme = function() {
      Pa("ECharts#setTheme() is DEPRECATED in ECharts 3.0");
    }, e.prototype.getModel = function() {
      return this._model;
    }, e.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, e.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, e.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, e.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || ct.hasGlobalWindow && window.devicePixelRatio || 1;
    }, e.prototype.getRenderedCanvas = function(t) {
      return {}.NODE_ENV !== "production" && fr("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(t);
    }, e.prototype.renderToCanvas = function(t) {
      t = t || {};
      var i = this._zr.painter;
      if ({}.NODE_ENV !== "production" && i.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return i.getRenderedCanvas({
        backgroundColor: t.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: t.pixelRatio || this.getDevicePixelRatio()
      });
    }, e.prototype.renderToSVGString = function(t) {
      t = t || {};
      var i = this._zr.painter;
      if ({}.NODE_ENV !== "production" && i.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return i.renderToString({
        useViewBox: t.useViewBox
      });
    }, e.prototype.getSvgDataURL = function() {
      if (ct.svgSupported) {
        var t = this._zr, i = t.storage.getDisplayList();
        return N(i, function(n) {
          n.stopAnimation(null, !0);
        }), t.painter.toDataURL();
      }
    }, e.prototype.getDataURL = function(t) {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      t = t || {};
      var i = t.excludeComponents, n = this._model, a = [], o = this;
      N(i, function(l) {
        n.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png"));
      return N(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, e.prototype.getConnectedDataURL = function(t) {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      var i = t.type === "svg", n = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (Yce[n]) {
        var l = s, u = s, c = -s, h = -s, f = [], d = t && t.pixelRatio || this.getDevicePixelRatio();
        N(Qk, function(E, b) {
          if (E.group === n) {
            var S = i ? E.getZr().painter.getSvgDom().innerHTML : E.renderToCanvas(ye(t)), T = E.getDom().getBoundingClientRect();
            l = a(T.left, l), u = a(T.top, u), c = o(T.right, c), h = o(T.bottom, h), f.push({
              dom: S,
              left: T.left,
              top: T.top
            });
          }
        }), l *= d, u *= d, c *= d, h *= d;
        var p = c - l, g = h - u, v = Il.createCanvas(), O = UD(v, {
          renderer: i ? "svg" : "canvas"
        });
        if (O.resize({
          width: p,
          height: g
        }), i) {
          var m = "";
          return N(f, function(E) {
            var b = E.left - l, S = E.top - u;
            m += '<g transform="translate(' + b + "," + S + ')">' + E.dom + "</g>";
          }), O.painter.getSvgRoot().innerHTML = m, t.connectedBackgroundColor && O.painter.setBackgroundColor(t.connectedBackgroundColor), O.refreshImmediately(), O.painter.toDataURL();
        } else
          return t.connectedBackgroundColor && O.add(new ht({
            shape: {
              x: 0,
              y: 0,
              width: p,
              height: g
            },
            style: {
              fill: t.connectedBackgroundColor
            }
          })), N(f, function(E) {
            var b = new ni({
              style: {
                x: E.left * d - l,
                y: E.top * d - u,
                image: E.dom
              }
            });
            O.add(b);
          }), O.refreshImmediately(), v.toDataURL("image/" + (t && t.type || "png"));
      } else
        return this.getDataURL(t);
    }, e.prototype.convertToPixel = function(t, i) {
      return k0(this, "convertToPixel", t, i);
    }, e.prototype.convertFromPixel = function(t, i) {
      return k0(this, "convertFromPixel", t, i);
    }, e.prototype.containPixel = function(t, i) {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      var n = this._model, a, o = Wp(n, t);
      return N(o, function(s, l) {
        l.indexOf("Models") >= 0 && N(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(i);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint ? a = a || h.containPoint(i, u) : {}.NODE_ENV !== "production" && tr(l + ": " + (h ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            ({}).NODE_ENV !== "production" && tr(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, e.prototype.getVisual = function(t, i) {
      var n = this._model, a = Wp(n, t, {
        defaultMainType: "series"
      }), o = a.seriesModel;
      ({}).NODE_ENV !== "production" && (o || tr("There is no specified series model"));
      var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? gN(s, l, i) : Nv(s, i);
    }, e.prototype.getViewOfComponentModel = function(t) {
      return this._componentsMap[t.__viewId];
    }, e.prototype.getViewOfSeriesModel = function(t) {
      return this._chartsMap[t.__viewId];
    }, e.prototype._initEvents = function() {
      var t = this;
      N(Xce, function(i) {
        var n = function(a) {
          var o = t.getModel(), s = a.target, l, u = i === "globalout";
          if (u ? l = {} : s && ju(s, function(p) {
            var g = Pe(p);
            if (g && g.dataIndex != null) {
              var v = g.dataModel || o.getSeriesByIndex(g.seriesIndex);
              return l = v && v.getDataParams(g.dataIndex, g.dataType, s) || {}, !0;
            } else if (g.eventData)
              return l = B({}, g.eventData), !0;
          }, !0), l) {
            var c = l.componentType, h = l.componentIndex;
            (c === "markLine" || c === "markPoint" || c === "markArea") && (c = "series", h = l.seriesIndex);
            var f = c && h != null && o.getComponent(c, h), d = f && t[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            ({}).NODE_ENV !== "production" && !u && !(f && d) && tr("model or view can not be found by params"), l.event = a, l.type = i, t._$eventProcessor.eventInfo = {
              targetEl: s,
              packedEvent: l,
              model: f,
              view: d
            }, t.trigger(i, l);
          }
        };
        n.zrEventfulCallAtLast = !0, t._zr.on(i, n, t);
      }), N(Sb, function(i, n) {
        t._messageCenter.on(n, function(a) {
          this.trigger(n, a);
        }, t);
      }), N(["selectchanged"], function(i) {
        t._messageCenter.on(i, function(n) {
          this.trigger(i, n);
        }, t);
      }), Jue(this._messageCenter, this, this._api);
    }, e.prototype.isDisposed = function() {
      return this._disposed;
    }, e.prototype.clear = function() {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, e.prototype.dispose = function() {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      this._disposed = !0;
      var t = this.getDom();
      t && Bae(this.getDom(), Hce, "");
      var i = this, n = i._api, a = i._model;
      N(i._componentsViews, function(o) {
        o.dispose(a, n);
      }), N(i._chartsViews, function(o) {
        o.dispose(a, n);
      }), i._zr.dispose(), i._dom = i._model = i._chartsMap = i._componentsMap = i._chartsViews = i._componentsViews = i._scheduler = i._api = i._zr = i._throttledZrFlush = i._theme = i._coordSysMgr = i._messageCenter = null, delete Qk[i.id];
    }, e.prototype.resize = function(t) {
      if (this[hi]) {
        ({}).NODE_ENV !== "production" && ti("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        cn(this.id);
        return;
      }
      this._zr.resize(t);
      var i = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!i) {
        var n = i.resetOption("media"), a = t && t.silent;
        this[Bi] && (a == null && (a = this[Bi].silent), n = !0, this[Bi] = null), this[hi] = !0;
        try {
          n && Eh(this), Ls.update.call(this, {
            type: "resize",
            animation: B({
              // Disable animation
              duration: 0
            }, t && t.animation)
          });
        } catch (o) {
          throw this[hi] = !1, o;
        }
        this[hi] = !1, Ud.call(this, a), $d.call(this, a);
      }
    }, e.prototype.showLoading = function(t, i) {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      if (be(t) && (i = t, t = ""), t = t || "default", this.hideLoading(), !yC[t]) {
        ({}).NODE_ENV !== "production" && tr("Loading effects " + t + " not exists.");
        return;
      }
      var n = yC[t](this._api, i), a = this._zr;
      this._loadingFX = n, a.add(n);
    }, e.prototype.hideLoading = function() {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, e.prototype.makeActionFromEvent = function(t) {
      var i = B({}, t);
      return i.type = Sb[t.type], i;
    }, e.prototype.dispatchAction = function(t, i) {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      if (be(i) || (i = {
        silent: !!i
      }), !!bb[t.type] && this._model) {
        if (this[hi]) {
          this._pendingActions.push(t);
          return;
        }
        var n = i.silent;
        U0.call(this, t, n);
        var a = i.flush;
        a ? this._zr.flush() : a !== !1 && ct.browser.weChat && this._throttledZrFlush(), Ud.call(this, n), $d.call(this, n);
      }
    }, e.prototype.updateLabelLayout = function() {
      Ya.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, e.prototype.appendData = function(t) {
      if (this._disposed) {
        cn(this.id);
        return;
      }
      var i = t.seriesIndex, n = this.getModel(), a = n.getSeriesByIndex(i);
      ({}).NODE_ENV !== "production" && Se(t.data && a), a.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, e.internalField = function() {
      Eh = function(h) {
        var f = h._scheduler;
        f.restorePipelines(h._model), f.prepareStageTasks(), M0(h, !0), M0(h, !1), f.plan();
      }, M0 = function(h, f) {
        for (var d = h._model, p = h._scheduler, g = f ? h._componentsViews : h._chartsViews, v = f ? h._componentsMap : h._chartsMap, O = h._zr, m = h._api, E = 0; E < g.length; E++)
          g[E].__alive = !1;
        f ? d.eachComponent(function(T, y) {
          T !== "series" && b(y);
        }) : d.eachSeries(b);
        function b(T) {
          var y = T.__requireNewView;
          T.__requireNewView = !1;
          var R = "_ec_" + T.id + "_" + T.type, _ = !y && v[R];
          if (!_) {
            var C = so(T.type), I = f ? jt.getClass(C.main, C.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              $t.getClass(C.sub)
            );
            ({}).NODE_ENV !== "production" && Se(I, C.sub + " does not exist."), _ = new I(), _.init(d, m), v[R] = _, g.push(_), O.add(_.group);
          }
          T.__viewId = _.__id = R, _.__alive = !0, _.__model = T, _.group.__ecComponentInfo = {
            mainType: T.mainType,
            index: T.componentIndex
          }, !f && p.prepareView(_, T, d, m);
        }
        for (var E = 0; E < g.length; ) {
          var S = g[E];
          S.__alive ? E++ : (!f && S.renderTask.dispose(), O.remove(S.group), S.dispose(d, m), g.splice(E, 1), v[S.__id] === S && delete v[S.__id], S.__id = S.group.__ecComponentInfo = null);
        }
      }, UO = function(h, f, d, p, g) {
        var v = h._model;
        if (v.setUpdatePayload(d), !p) {
          N([].concat(h._componentsViews).concat(h._chartsViews), S);
          return;
        }
        var O = {};
        O[p + "Id"] = d[p + "Id"], O[p + "Index"] = d[p + "Index"], O[p + "Name"] = d[p + "Name"];
        var m = {
          mainType: p,
          query: O
        };
        g && (m.subType = g);
        var E = d.excludeSeriesId, b;
        E != null && (b = de(), N(It(E), function(T) {
          var y = Ar(T, null);
          y != null && b.set(y, !0);
        })), v && v.eachComponent(m, function(T) {
          var y = b && b.get(T.id) != null;
          if (!y)
            if (EM(d))
              if (T instanceof Wt)
                d.type === dc && !d.notBlur && !T.get(["emphasis", "disabled"]) && Woe(T, d, h._api);
              else {
                var R = Y1(T.mainType, T.componentIndex, d.name, h._api), _ = R.focusSelf, C = R.dispatchers;
                d.type === dc && _ && !d.notBlur && rC(T.mainType, T.componentIndex, h._api), C && N(C, function(I) {
                  d.type === dc ? ls(I) : us(I);
                });
              }
            else
              nC(d) && T instanceof Wt && (qoe(T, d, h._api), OM(T), xn(h));
        }, h), v && v.eachComponent(m, function(T) {
          var y = b && b.get(T.id) != null;
          y || S(h[p === "series" ? "_chartsMap" : "_componentsMap"][T.__viewId]);
        }, h);
        function S(T) {
          T && T.__alive && T[f] && T[f](T.__model, v, h._api, d);
        }
      }, Ls = {
        prepareAndUpdate: function(h) {
          Eh(this), Ls.update.call(this, h, {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: h.newOption != null
          });
        },
        update: function(h, f) {
          var d = this._model, p = this._api, g = this._zr, v = this._coordSysMgr, O = this._scheduler;
          if (d) {
            d.setUpdatePayload(h), O.restoreData(d, h), O.performSeriesTasks(d), v.create(d, p), O.performDataProcessorTasks(d, h), Q0(this, d), v.update(d, p), t(d), O.performVisualTasks(d, h), $0(this, d, p, h, f);
            var m = d.get("backgroundColor") || "transparent", E = d.get("darkMode");
            g.setBackgroundColor(m), E != null && E !== "auto" && g.setDarkMode(E), Ya.trigger("afterupdate", d, p);
          }
        },
        updateTransform: function(h) {
          var f = this, d = this._model, p = this._api;
          if (d) {
            d.setUpdatePayload(h);
            var g = [];
            d.eachComponent(function(O, m) {
              if (O !== "series") {
                var E = f.getViewOfComponentModel(m);
                if (E && E.__alive)
                  if (E.updateTransform) {
                    var b = E.updateTransform(m, d, p, h);
                    b && b.update && g.push(E);
                  } else
                    g.push(E);
              }
            });
            var v = de();
            d.eachSeries(function(O) {
              var m = f._chartsMap[O.__viewId];
              if (m.updateTransform) {
                var E = m.updateTransform(O, d, p, h);
                E && E.update && v.set(O.uid, 1);
              } else
                v.set(O.uid, 1);
            }), t(d), this._scheduler.performVisualTasks(d, h, {
              setDirty: !0,
              dirtyMap: v
            }), $O(this, d, p, h, {}, v), Ya.trigger("afterupdate", d, p);
          }
        },
        updateView: function(h) {
          var f = this._model;
          f && (f.setUpdatePayload(h), $t.markUpdateMethod(h, "updateView"), t(f), this._scheduler.performVisualTasks(f, h, {
            setDirty: !0
          }), $0(this, f, this._api, h, {}), Ya.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(h) {
          var f = this, d = this._model;
          d && (d.setUpdatePayload(h), d.eachSeries(function(p) {
            p.getData().clearAllVisual();
          }), $t.markUpdateMethod(h, "updateVisual"), t(d), this._scheduler.performVisualTasks(d, h, {
            visualType: "visual",
            setDirty: !0
          }), d.eachComponent(function(p, g) {
            if (p !== "series") {
              var v = f.getViewOfComponentModel(g);
              v && v.__alive && v.updateVisual(g, d, f._api, h);
            }
          }), d.eachSeries(function(p) {
            var g = f._chartsMap[p.__viewId];
            g.updateVisual(p, d, f._api, h);
          }), Ya.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(h) {
          Ls.update.call(this, h);
        }
      }, k0 = function(h, f, d, p) {
        if (h._disposed) {
          cn(h.id);
          return;
        }
        for (var g = h._model, v = h._coordSysMgr.getCoordinateSystems(), O, m = Wp(g, d), E = 0; E < v.length; E++) {
          var b = v[E];
          if (b[f] && (O = b[f](g, m, p)) != null)
            return O;
        }
        ({}).NODE_ENV !== "production" && tr("No coordinate system that supports " + f + " found by the given finder.");
      }, Q0 = function(h, f) {
        var d = h._chartsMap, p = h._scheduler;
        f.eachSeries(function(g) {
          p.updateStreamModes(g, d[g.__viewId]);
        });
      }, U0 = function(h, f) {
        var d = this, p = this.getModel(), g = h.type, v = h.escapeConnect, O = bb[g], m = O.actionInfo, E = (m.update || "update").split(":"), b = E.pop(), S = E[0] != null && so(E[0]);
        this[hi] = !0;
        var T = [h], y = !1;
        h.batch && (y = !0, T = Y(h.batch, function(P) {
          return P = Te(B({}, P), h), P.batch = null, P;
        }));
        var R = [], _, C = nC(h), I = EM(h);
        if (I && yH(this._api), N(T, function(P) {
          if (_ = O.action(P, d._model, d._api), _ = _ || B({}, P), _.type = m.event || _.type, R.push(_), I) {
            var L = U1(h), D = L.queryOptionMap, U = L.mainTypeSpecified, Q = U ? D.keys()[0] : "series";
            UO(d, b, P, Q), xn(d);
          } else
            C ? (UO(d, b, P, "series"), xn(d)) : S && UO(d, b, P, S.main, S.sub);
        }), b !== "none" && !I && !C && !S)
          try {
            this[Bi] ? (Eh(this), Ls.update.call(this, h), this[Bi] = null) : Ls[b].call(this, h);
          } catch (P) {
            throw this[hi] = !1, P;
          }
        if (y ? _ = {
          type: m.event || g,
          escapeConnect: v,
          batch: R
        } : _ = R[0], this[hi] = !1, !f) {
          var w = this._messageCenter;
          if (w.trigger(_.type, _), C) {
            var x = {
              type: "selectchanged",
              escapeConnect: v,
              selected: joe(p),
              isFromClick: h.isFromClick || !1,
              fromAction: h.type,
              fromActionPayload: h
            };
            w.trigger(x.type, x);
          }
        }
      }, Ud = function(h) {
        for (var f = this._pendingActions; f.length; ) {
          var d = f.shift();
          U0.call(this, d, h);
        }
      }, $d = function(h) {
        !h && this.trigger("updated");
      }, Pk = function(h, f) {
        h.on("rendered", function(d) {
          f.trigger("rendered", d), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          h.animation.isFinished() && !f[Bi] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, Lk = function(h, f) {
        h.on("mouseover", function(d) {
          var p = d.target, g = ju(p, Nl);
          g && (zoe(g, d, f._api), xn(f));
        }).on("mouseout", function(d) {
          var p = d.target, g = ju(p, Nl);
          g && (Zoe(g, d, f._api), xn(f));
        }).on("click", function(d) {
          var p = d.target, g = ju(p, function(m) {
            return Pe(m).dataIndex != null;
          }, !0);
          if (g) {
            var v = g.selected ? "unselect" : "select", O = Pe(g);
            f._api.dispatchAction({
              type: v,
              dataType: O.dataType,
              dataIndexInside: O.dataIndex,
              seriesIndex: O.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function t(h) {
        h.clearColorPalette(), h.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function i(h) {
        var f = [], d = [], p = !1;
        if (h.eachComponent(function(m, E) {
          var b = E.get("zlevel") || 0, S = E.get("z") || 0, T = E.getZLevelKey();
          p = p || !!T, (m === "series" ? d : f).push({
            zlevel: b,
            z: S,
            idx: E.componentIndex,
            type: m,
            key: T
          });
        }), p) {
          var g = f.concat(d), v, O;
          Hm(g, function(m, E) {
            return m.zlevel === E.zlevel ? m.z - E.z : m.zlevel - E.zlevel;
          }), N(g, function(m) {
            var E = h.getComponent(m.type, m.idx), b = m.zlevel, S = m.key;
            v != null && (b = Math.max(v, b)), S ? (b === v && S !== O && b++, O = S) : O && (b === v && b++, O = ""), v = b, E.setZLevel(b);
          });
        }
      }
      $0 = function(h, f, d, p, g) {
        i(f), Dk(h, f, d, p, g), N(h._chartsViews, function(v) {
          v.__alive = !1;
        }), $O(h, f, d, p, g), N(h._chartsViews, function(v) {
          v.__alive || v.remove(f, d);
        });
      }, Dk = function(h, f, d, p, g, v) {
        N(v || h._componentsViews, function(O) {
          var m = O.__model;
          u(m, O), O.render(m, f, d, p), s(m, O), c(m, O);
        });
      }, $O = function(h, f, d, p, g, v) {
        var O = h._scheduler;
        g = B(g || {}, {
          updatedSeries: f.getSeries()
        }), Ya.trigger("series:beforeupdate", f, d, g);
        var m = !1;
        f.eachSeries(function(E) {
          var b = h._chartsMap[E.__viewId];
          b.__alive = !0;
          var S = b.renderTask;
          O.updatePayload(S, p), u(E, b), v && v.get(E.uid) && S.dirty(), S.perform(O.getPerformArgs(S)) && (m = !0), b.group.silent = !!E.get("silent"), o(E, b), OM(E);
        }), O.unfinished = m || O.unfinished, Ya.trigger("series:layoutlabels", f, d, g), Ya.trigger("series:transition", f, d, g), f.eachSeries(function(E) {
          var b = h._chartsMap[E.__viewId];
          s(E, b), c(E, b);
        }), a(h, f), Ya.trigger("series:afterupdate", f, d, g);
      }, xn = function(h) {
        h[D0] = !0, h.getZr().wakeUp();
      }, kk = function(h) {
        h[D0] && (h.getZr().storage.traverse(function(f) {
          sf(f) || n(f);
        }), h[D0] = !1);
      };
      function n(h) {
        for (var f = [], d = h.currentStates, p = 0; p < d.length; p++) {
          var g = d[p];
          g === "emphasis" || g === "blur" || g === "select" || f.push(g);
        }
        h.selected && h.states.select && f.push("select"), h.hoverState === vT && h.states.emphasis ? f.push("emphasis") : h.hoverState === Av && h.states.blur && f.push("blur"), h.useStates(f);
      }
      function a(h, f) {
        var d = h._zr, p = d.storage, g = 0;
        p.traverse(function(v) {
          v.isGroup || g++;
        }), g > f.get("hoverLayerThreshold") && !ct.node && !ct.worker && f.eachSeries(function(v) {
          if (!v.preventUsingHoverLayer) {
            var O = h._chartsMap[v.__viewId];
            O.__alive && O.eachRendered(function(m) {
              m.states.emphasis && (m.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function o(h, f) {
        var d = h.get("blendMode") || null;
        f.eachRendered(function(p) {
          p.isGroup || (p.style.blend = d);
        });
      }
      function s(h, f) {
        if (!h.preventAutoZ) {
          var d = h.get("z") || 0, p = h.get("zlevel") || 0;
          f.eachRendered(function(g) {
            return l(g, d, p, -1 / 0), !0;
          });
        }
      }
      function l(h, f, d, p) {
        var g = h.getTextContent(), v = h.getTextGuideLine(), O = h.isGroup;
        if (O)
          for (var m = h.childrenRef(), E = 0; E < m.length; E++)
            p = Math.max(l(m[E], f, d, p), p);
        else
          h.z = f, h.zlevel = d, p = Math.max(h.z2, p);
        if (g && (g.z = f, g.zlevel = d, isFinite(p) && (g.z2 = p + 2)), v) {
          var b = h.textGuideLineConfig;
          v.z = f, v.zlevel = d, isFinite(p) && (v.z2 = p + (b && b.showAbove ? 1 : -1));
        }
        return p;
      }
      function u(h, f) {
        f.eachRendered(function(d) {
          if (!sf(d)) {
            var p = d.getTextContent(), g = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(h, f) {
        var d = h.getModel("stateAnimation"), p = h.isAnimationEnabled(), g = d.get("duration"), v = g > 0 ? {
          duration: g,
          delay: d.get("delay"),
          easing: d.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        f.eachRendered(function(O) {
          if (O.states && O.states.emphasis) {
            if (sf(O))
              return;
            if (O instanceof He && rse(O), O.__dirty) {
              var m = O.prevStates;
              m && O.useStates(m);
            }
            if (p) {
              O.stateTransition = v;
              var E = O.getTextContent(), b = O.getTextGuideLine();
              E && (E.stateTransition = v), b && (b.stateTransition = v);
            }
            O.__dirty && n(O);
          }
        });
      }
      Mk = function(h) {
        return new /** @class */
        (function(f) {
          $(d, f);
          function d() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(p) {
            for (; p; ) {
              var g = p.__ecComponentInfo;
              if (g != null)
                return h._model.getComponent(g.mainType, g.index);
              p = p.parent;
            }
          }, d.prototype.enterEmphasis = function(p, g) {
            ls(p, g), xn(h);
          }, d.prototype.leaveEmphasis = function(p, g) {
            us(p, g), xn(h);
          }, d.prototype.enterBlur = function(p) {
            EH(p), xn(h);
          }, d.prototype.leaveBlur = function(p) {
            X1(p), xn(h);
          }, d.prototype.enterSelect = function(p) {
            bH(p), xn(h);
          }, d.prototype.leaveSelect = function(p) {
            SH(p), xn(h);
          }, d.prototype.getModel = function() {
            return h.getModel();
          }, d.prototype.getViewOfComponentModel = function(p) {
            return h.getViewOfComponentModel(p);
          }, d.prototype.getViewOfSeriesModel = function(p) {
            return h.getViewOfSeriesModel(p);
          }, d;
        }(RW))(h);
      };
    }(), e;
  }(oa)
), mN = Fce.prototype;
mN.on = dz("on");
mN.off = dz("off");
mN.one = function(r, e, t) {
  var i = this;
  Pa("ECharts#one is deprecated.");
  function n() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    e && e.apply && e.apply(this, a), i.off(r, n);
  }
  this.on.call(this, r, n, t);
};
var Xce = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function cn(r) {
  ({}).NODE_ENV !== "production" && tr("Instance " + r + " has been disposed");
}
var bb = {}, Sb = {}, SC = [], TC = [], Tb = [], mz = {}, yC = {}, Qk = {}, Yce = {}, Hce = "_echarts_instance_";
function Ez(r, e) {
  mz[r] = e;
}
function bz(r) {
  Fe(TC, r) < 0 && TC.push(r);
}
function Sz(r, e) {
  bN(SC, r, e, Mce);
}
function Wce(r) {
  EN("afterinit", r);
}
function zce(r) {
  EN("afterupdate", r);
}
function EN(r, e) {
  Ya.on(r, e);
}
function Po(r, e, t) {
  ve(e) && (t = e, e = "");
  var i = be(r) ? r.type : [r, r = {
    event: e
  }][0];
  r.event = (r.event || i).toLowerCase(), e = r.event, !Sb[e] && (Se(xk.test(i) && xk.test(e)), bb[i] || (bb[i] = {
    action: t,
    actionInfo: r
  }), Sb[e] = i);
}
function Zce(r, e) {
  sd.register(r, e);
}
function qce(r, e) {
  bN(Tb, r, e, cz, "layout");
}
function jc(r, e) {
  bN(Tb, r, e, hz, "visual");
}
var Uk = [];
function bN(r, e, t, i, n) {
  if ((ve(e) || be(e)) && (t = e, e = i), {}.NODE_ENV !== "production") {
    if (isNaN(e) || e == null)
      throw new Error("Illegal priority");
    N(r, function(o) {
      Se(o.__raw !== t);
    });
  }
  if (!(Fe(Uk, t) >= 0)) {
    Uk.push(t);
    var a = ez.wrapStageHandler(t, n);
    a.__prio = e, a.__raw = t, r.push(a);
  }
}
function Tz(r, e) {
  yC[r] = e;
}
function jce(r, e, t) {
  var i = Nce("registerMap");
  i && i(r, e, t);
}
var Kce = uue;
jc(ON, Due);
jc(PT, Mue);
jc(PT, kue);
jc(ON, jue);
jc(PT, Kue);
jc(fz, Cce);
bz(_W);
Sz(Lce, Fle);
Tz("default", Que);
Po({
  type: dc,
  event: dc,
  update: dc
}, ur);
Po({
  type: jm,
  event: jm,
  update: jm
}, ur);
Po({
  type: zp,
  event: zp,
  update: zp
}, ur);
Po({
  type: Km,
  event: Km,
  update: Km
}, ur);
Po({
  type: Zp,
  event: Zp,
  update: Zp
}, ur);
Ez("light", zue);
Ez("dark", Zue);
var $k = [], Jce = {
  registerPreprocessor: bz,
  registerProcessor: Sz,
  registerPostInit: Wce,
  registerPostUpdate: zce,
  registerUpdateLifecycle: EN,
  registerAction: Po,
  registerCoordinateSystem: Zce,
  registerLayout: qce,
  registerVisual: jc,
  registerTransform: Kce,
  registerLoading: Tz,
  registerMap: jce,
  registerImpl: wce,
  PRIORITY: Bce,
  ComponentModel: st,
  ComponentView: jt,
  SeriesModel: Wt,
  ChartView: $t,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(r) {
    st.registerClass(r);
  },
  registerComponentView: function(r) {
    jt.registerClass(r);
  },
  registerSeriesModel: function(r) {
    Wt.registerClass(r);
  },
  registerChartView: function(r) {
    $t.registerClass(r);
  },
  registerSubTypeDefaulter: function(r, e) {
    st.registerSubTypeDefaulter(r, e);
  },
  registerPainter: function(r, e) {
    bae(r, e);
  }
};
function Ye(r) {
  if (X(r)) {
    N(r, function(e) {
      Ye(e);
    });
    return;
  }
  Fe($k, r) >= 0 || ($k.push(r), ve(r) && (r = {
    install: r
  }), r.install(Jce));
}
function Vd(r) {
  return r == null ? 0 : r.length || 1;
}
function Vk(r) {
  return r;
}
var ehe = (
  /** @class */
  function() {
    function r(e, t, i, n, a, o) {
      this._old = e, this._new = t, this._oldKeyGetter = i || Vk, this._newKeyGetter = n || Vk, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return r.prototype.add = function(e) {
      return this._add = e, this;
    }, r.prototype.update = function(e) {
      return this._update = e, this;
    }, r.prototype.updateManyToOne = function(e) {
      return this._updateManyToOne = e, this;
    }, r.prototype.updateOneToMany = function(e) {
      return this._updateOneToMany = e, this;
    }, r.prototype.updateManyToMany = function(e) {
      return this._updateManyToMany = e, this;
    }, r.prototype.remove = function(e) {
      return this._remove = e, this;
    }, r.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, r.prototype._executeOneToOne = function() {
      var e = this._old, t = this._new, i = {}, n = new Array(e.length), a = new Array(t.length);
      this._initIndexMap(e, null, n, "_oldKeyGetter"), this._initIndexMap(t, i, a, "_newKeyGetter");
      for (var o = 0; o < e.length; o++) {
        var s = n[o], l = i[s], u = Vd(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (i[s] = l[0]), this._update && this._update(c, o);
        } else
          u === 1 ? (i[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, i);
    }, r.prototype._executeMultiple = function() {
      var e = this._old, t = this._new, i = {}, n = {}, a = [], o = [];
      this._initIndexMap(e, i, a, "_oldKeyGetter"), this._initIndexMap(t, n, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = i[l], c = n[l], h = Vd(u), f = Vd(c);
        if (h > 1 && f === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), n[l] = null;
        else if (h === 1 && f > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), n[l] = null;
        else if (h === 1 && f === 1)
          this._update && this._update(c, u), n[l] = null;
        else if (h > 1 && f > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), n[l] = null;
        else if (h > 1)
          for (var d = 0; d < h; d++)
            this._remove && this._remove(u[d]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, n);
    }, r.prototype._performRestAdd = function(e, t) {
      for (var i = 0; i < e.length; i++) {
        var n = e[i], a = t[n], o = Vd(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else
          o === 1 && this._add && this._add(a);
        t[n] = null;
      }
    }, r.prototype._initIndexMap = function(e, t, i, n) {
      for (var a = this._diffModeMultiple, o = 0; o < e.length; o++) {
        var s = "_ec_" + this[n](e[o], o);
        if (a || (i[o] = s), !!t) {
          var l = t[s], u = Vd(l);
          u === 0 ? (t[s] = o, a && i.push(s)) : u === 1 ? t[s] = [l, o] : l.push(o);
        }
      }
    }, r;
  }()
);
const cs = ehe;
var the = (
  /** @class */
  function() {
    function r(e, t) {
      this._encode = e, this._schema = t;
    }
    return r.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, r.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, r;
  }()
);
function rhe(r, e) {
  var t = {}, i = t.encode = {}, n = de(), a = [], o = [], s = {};
  N(r.dimensions, function(f) {
    var d = r.getDimensionInfo(f), p = d.coordDim;
    if (p) {
      ({}).NODE_ENV !== "production" && Se(cC.get(p) == null);
      var g = d.coordDimIndex;
      V0(i, p)[g] = f, d.isExtraCoord || (n.set(p, 1), ihe(d.type) && (a[0] = f), V0(s, p)[g] = r.getDimensionIndex(d.name)), d.defaultTooltip && o.push(f);
    }
    cC.each(function(v, O) {
      var m = V0(i, O), E = d.otherDims[O];
      E != null && E !== !1 && (m[E] = d.name);
    });
  });
  var l = [], u = {};
  n.each(function(f, d) {
    var p = i[d];
    u[d] = p[0], l = l.concat(p);
  }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = Y(l, function(f) {
    return r.getDimensionInfo(f).storeDimIndex;
  }), t.encodeFirstDimNotExtra = u;
  var c = i.label;
  c && c.length && (a = c.slice());
  var h = i.tooltip;
  return h && h.length ? o = h.slice() : o.length || (o = a.slice()), i.defaultedLabel = a, i.defaultedTooltip = o, t.userOutput = new the(s, e), t;
}
function V0(r, e) {
  return r.hasOwnProperty(e) || (r[e] = []), r[e];
}
function yb(r) {
  return r === "category" ? "ordinal" : r === "time" ? "time" : "float";
}
function ihe(r) {
  return !(r === "ordinal" || r === "time");
}
var nhe = (
  /** @class */
  function() {
    function r(e) {
      this.otherDims = {}, e != null && B(this, e);
    }
    return r;
  }()
);
const iE = nhe;
var ahe = ft(), ohe = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, yz = (
  /** @class */
  function() {
    function r(e) {
      this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted);
    }
    return r.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, r.prototype._updateDimOmitted = function(e) {
      this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = _z(this.source)));
    }, r.prototype.getSourceDimensionIndex = function(e) {
      return ke(this._dimNameMap.get(e), -1);
    }, r.prototype.getSourceDimension = function(e) {
      var t = this.source.dimensionsDefine;
      if (t)
        return t[e];
    }, r.prototype.makeStoreSchema = function() {
      for (var e = this._fullDimCount, t = IW(this.source), i = !Cz(e), n = "", a = [], o = 0, s = 0; o < e; o++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[s];
        if (h && h.storeDimIndex === o)
          l = t ? h.name : null, u = h.type, c = h.ordinalMeta, s++;
        else {
          var f = this.getSourceDimension(o);
          f && (l = t ? f.name : null, u = f.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), t && l != null && (!h || !h.isCalculationCoord) && (n += i ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), n += "$", n += ohe[u] || "f", c && (n += c.uid), n += "$";
      }
      var d = this.source, p = [d.seriesLayoutBy, d.startIndex, n].join("$$");
      return {
        dimensions: a,
        hash: p
      };
    }, r.prototype.makeOutputDimensionNames = function() {
      for (var e = [], t = 0, i = 0; t < this._fullDimCount; t++) {
        var n = void 0, a = this.dimensions[i];
        if (a && a.storeDimIndex === t)
          a.isCalculationCoord || (n = a.name), i++;
        else {
          var o = this.getSourceDimension(t);
          o && (n = o.name);
        }
        e.push(n);
      }
      return e;
    }, r.prototype.appendCalculationDimension = function(e) {
      this.dimensions.push(e), e.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, r;
  }()
);
function Rz(r) {
  return r instanceof yz;
}
function Az(r) {
  for (var e = de(), t = 0; t < (r || []).length; t++) {
    var i = r[t], n = be(i) ? i.name : i;
    n != null && e.get(n) == null && e.set(n, t);
  }
  return e;
}
function _z(r) {
  var e = ahe(r);
  return e.dimNameMap || (e.dimNameMap = Az(r.dimensionsDefine));
}
function Cz(r) {
  return r > 30;
}
var Gd = be, Ds = Y, she = typeof Int32Array > "u" ? Array : Int32Array, lhe = "e\0\0", Gk = -1, uhe = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], che = ["_approximateExtent"], Bk, VO, Bd, bh, G0, GO, B0, hhe = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "lttbDownSample"];
      var i, n = !1;
      Rz(e) ? (i = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (n = !0, i = e), i = i || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, c = 0; c < i.length; c++) {
        var h = i[c], f = ne(h) ? new iE({
          name: h
        }) : h instanceof iE ? h : new iE(h), d = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = d, f.coordDimIndex = 0);
        var p = f.otherDims = f.otherDims || {};
        o.push(d), a[d] = f, u[d] != null && (l = !0), f.createInvertedIndices && (s[d] = []), p.itemName === 0 && (this._nameDimIdx = c), p.itemId === 0 && (this._idDimIdx = c), {}.NODE_ENV !== "production" && Se(n || f.storeDimIndex >= 0), n && (f.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = s, this._dimOmitted) {
        var g = this._dimIdxToName = de();
        N(o, function(v) {
          g.set(a[v].storeDimIndex, v);
        });
      }
    }
    return r.prototype.getDimension = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t == null)
        return e;
      if (t = e, !this._dimOmitted)
        return this.dimensions[t];
      var i = this._dimIdxToName.get(t);
      if (i != null)
        return i;
      var n = this._schema.getSourceDimension(t);
      if (n)
        return n.name;
    }, r.prototype.getDimensionIndex = function(e) {
      var t = this._recognizeDimIndex(e);
      if (t != null)
        return t;
      if (e == null)
        return -1;
      var i = this._getDimInfo(e);
      return i ? i.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1;
    }, r.prototype._recognizeDimIndex = function(e) {
      if (pt(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0))
        return +e;
    }, r.prototype._getStoreDimIndex = function(e) {
      var t = this.getDimensionIndex(e);
      if ({}.NODE_ENV !== "production" && t == null)
        throw new Error("Unknown dimension " + e);
      return t;
    }, r.prototype.getDimensionInfo = function(e) {
      return this._getDimInfo(this.getDimension(e));
    }, r.prototype._initGetDimensionInfo = function(e) {
      var t = this._dimInfos;
      this._getDimInfo = e ? function(i) {
        return t.hasOwnProperty(i) ? t[i] : void 0;
      } : function(i) {
        return t[i];
      };
    }, r.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, r.prototype.mapDimension = function(e, t) {
      var i = this._dimSummary;
      if (t == null)
        return i.encodeFirstDimNotExtra[e];
      var n = i.encode[e];
      return n ? n[t] : null;
    }, r.prototype.mapDimensionsAll = function(e) {
      var t = this._dimSummary, i = t.encode[e];
      return (i || []).slice();
    }, r.prototype.getStore = function() {
      return this._store;
    }, r.prototype.initData = function(e, t, i) {
      var n = this, a;
      if (e instanceof pC && (a = e), !a) {
        var o = this.dimensions, s = sN(e) || mi(e) ? new wW(e, o.length) : e;
        a = new pC();
        var l = Ds(o, function(u) {
          return {
            type: n._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, i);
      }
      this._store = a, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = rhe(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, r.prototype.appendData = function(e) {
      var t = this._store.appendData(e);
      this._doInit(t[0], t[1]);
    }, r.prototype.appendValues = function(e, t) {
      var i = this._store.appendValues(e, t.length), n = i.start, a = i.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), t)
        for (var s = n; s < a; s++) {
          var l = s - n;
          this._nameList[s] = t[l], o && B0(this, s);
        }
    }, r.prototype._updateOrdinalMeta = function() {
      for (var e = this._store, t = this.dimensions, i = 0; i < t.length; i++) {
        var n = this._dimInfos[t[i]];
        n.ordinalMeta && e.collectOrdinalMeta(n.storeDimIndex, n.ordinalMeta);
      }
    }, r.prototype._shouldMakeIdFromName = function() {
      var e = this._store.getProvider();
      return this._idDimIdx == null && e.getSource().sourceFormat !== Ko && !e.fillStorage;
    }, r.prototype._doInit = function(e, t) {
      if (!(e >= t)) {
        var i = this._store, n = i.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = n.getSource().sourceFormat, l = s === sa;
        if (l && !n.pure)
          for (var u = [], c = e; c < t; c++) {
            var h = n.getItem(c, u);
            if (!this.hasItemOption && wae(h) && (this.hasItemOption = !0), h) {
              var f = h.name;
              a[c] == null && f != null && (a[c] = Ar(f, null));
              var d = h.id;
              o[c] == null && d != null && (o[c] = Ar(d, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = e; c < t; c++)
            B0(this, c);
        Bk(this);
      }
    }, r.prototype.getApproximateExtent = function(e) {
      return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.setApproximateExtent = function(e, t) {
      t = this.getDimension(t), this._approximateExtent[t] = e.slice();
    }, r.prototype.getCalculationInfo = function(e) {
      return this._calculationInfo[e];
    }, r.prototype.setCalculationInfo = function(e, t) {
      Gd(e) ? B(this._calculationInfo, e) : this._calculationInfo[e] = t;
    }, r.prototype.getName = function(e) {
      var t = this.getRawIndex(e), i = this._nameList[t];
      return i == null && this._nameDimIdx != null && (i = Bd(this, this._nameDimIdx, t)), i == null && (i = ""), i;
    }, r.prototype._getCategory = function(e, t) {
      var i = this._store.get(e, t), n = this._store.getOrdinalMeta(e);
      return n ? n.categories[i] : i;
    }, r.prototype.getId = function(e) {
      return VO(this, this.getRawIndex(e));
    }, r.prototype.count = function() {
      return this._store.count();
    }, r.prototype.get = function(e, t) {
      var i = this._store, n = this._dimInfos[e];
      if (n)
        return i.get(n.storeDimIndex, t);
    }, r.prototype.getByRawIndex = function(e, t) {
      var i = this._store, n = this._dimInfos[e];
      if (n)
        return i.getByRawIndex(n.storeDimIndex, t);
    }, r.prototype.getIndices = function() {
      return this._store.getIndices();
    }, r.prototype.getDataExtent = function(e) {
      return this._store.getDataExtent(this._getStoreDimIndex(e));
    }, r.prototype.getSum = function(e) {
      return this._store.getSum(this._getStoreDimIndex(e));
    }, r.prototype.getMedian = function(e) {
      return this._store.getMedian(this._getStoreDimIndex(e));
    }, r.prototype.getValues = function(e, t) {
      var i = this, n = this._store;
      return X(e) ? n.getValues(Ds(e, function(a) {
        return i._getStoreDimIndex(a);
      }), t) : n.getValues(e);
    }, r.prototype.hasValue = function(e) {
      for (var t = this._dimSummary.dataDimIndicesOnCoord, i = 0, n = t.length; i < n; i++)
        if (isNaN(this._store.get(t[i], e)))
          return !1;
      return !0;
    }, r.prototype.indexOfName = function(e) {
      for (var t = 0, i = this._store.count(); t < i; t++)
        if (this.getName(t) === e)
          return t;
      return -1;
    }, r.prototype.getRawIndex = function(e) {
      return this._store.getRawIndex(e);
    }, r.prototype.indexOfRawIndex = function(e) {
      return this._store.indexOfRawIndex(e);
    }, r.prototype.rawIndexOf = function(e, t) {
      var i = e && this._invertedIndicesMap[e];
      if ({}.NODE_ENV !== "production" && !i)
        throw new Error("Do not supported yet");
      var n = i[t];
      return n == null || isNaN(n) ? Gk : n;
    }, r.prototype.indicesOfNearest = function(e, t, i) {
      return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, i);
    }, r.prototype.each = function(e, t, i) {
      ve(e) && (i = t, t = e, e = []);
      var n = i || this, a = Ds(bh(e), this._getStoreDimIndex, this);
      this._store.each(a, n ? ue(t, n) : t);
    }, r.prototype.filterSelf = function(e, t, i) {
      ve(e) && (i = t, t = e, e = []);
      var n = i || this, a = Ds(bh(e), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, n ? ue(t, n) : t), this;
    }, r.prototype.selectRange = function(e) {
      var t = this, i = {}, n = Ze(e);
      return N(n, function(a) {
        var o = t._getStoreDimIndex(a);
        i[o] = e[a];
      }), this._store = this._store.selectRange(i), this;
    }, r.prototype.mapArray = function(e, t, i) {
      ve(e) && (i = t, t = e, e = []), i = i || this;
      var n = [];
      return this.each(e, function() {
        n.push(t && t.apply(this, arguments));
      }, i), n;
    }, r.prototype.map = function(e, t, i, n) {
      var a = i || n || this, o = Ds(bh(e), this._getStoreDimIndex, this), s = GO(this);
      return s._store = this._store.map(o, a ? ue(t, a) : t), s;
    }, r.prototype.modify = function(e, t, i, n) {
      var a = this, o = i || n || this;
      ({}).NODE_ENV !== "production" && N(bh(e), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = Ds(bh(e), this._getStoreDimIndex, this);
      this._store.modify(s, o ? ue(t, o) : t);
    }, r.prototype.downSample = function(e, t, i, n) {
      var a = GO(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(e), t, i, n), a;
    }, r.prototype.lttbDownSample = function(e, t) {
      var i = GO(this);
      return i._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), i;
    }, r.prototype.getRawDataItem = function(e) {
      return this._store.getRawDataItem(e);
    }, r.prototype.getItemModel = function(e) {
      var t = this.hostModel, i = this.getRawDataItem(e);
      return new Ut(i, t, t && t.ecModel);
    }, r.prototype.diff = function(e) {
      var t = this;
      return new cs(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function(i) {
        return VO(e, i);
      }, function(i) {
        return VO(t, i);
      });
    }, r.prototype.getVisual = function(e) {
      var t = this._visual;
      return t && t[e];
    }, r.prototype.setVisual = function(e, t) {
      this._visual = this._visual || {}, Gd(e) ? B(this._visual, e) : this._visual[e] = t;
    }, r.prototype.getItemVisual = function(e, t) {
      var i = this._itemVisuals[e], n = i && i[t];
      return n ?? this.getVisual(t);
    }, r.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, r.prototype.ensureUniqueItemVisual = function(e, t) {
      var i = this._itemVisuals, n = i[e];
      n || (n = i[e] = {});
      var a = n[t];
      return a == null && (a = this.getVisual(t), X(a) ? a = a.slice() : Gd(a) && (a = B({}, a)), n[t] = a), a;
    }, r.prototype.setItemVisual = function(e, t, i) {
      var n = this._itemVisuals[e] || {};
      this._itemVisuals[e] = n, Gd(t) ? B(n, t) : n[t] = i;
    }, r.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, r.prototype.setLayout = function(e, t) {
      Gd(e) ? B(this._layout, e) : this._layout[e] = t;
    }, r.prototype.getLayout = function(e) {
      return this._layout[e];
    }, r.prototype.getItemLayout = function(e) {
      return this._itemLayouts[e];
    }, r.prototype.setItemLayout = function(e, t, i) {
      this._itemLayouts[e] = i ? B(this._itemLayouts[e] || {}, t) : t;
    }, r.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, r.prototype.setItemGraphicEl = function(e, t) {
      var i = this.hostModel && this.hostModel.seriesIndex;
      eC(i, this.dataType, e, t), this._graphicEls[e] = t;
    }, r.prototype.getItemGraphicEl = function(e) {
      return this._graphicEls[e];
    }, r.prototype.eachItemGraphicEl = function(e, t) {
      N(this._graphicEls, function(i, n) {
        i && e && e.call(t, i, n);
      });
    }, r.prototype.cloneShallow = function(e) {
      return e || (e = new r(this._schema ? this._schema : Ds(this.dimensions, this._getDimInfo, this), this.hostModel)), G0(e, this), e._store = this._store, e;
    }, r.prototype.wrapMethod = function(e, t) {
      var i = this[e];
      ve(i) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function() {
        var n = i.apply(this, arguments);
        return t.apply(this, [n].concat(C1(arguments)));
      });
    }, r.internalField = function() {
      Bk = function(e) {
        var t = e._invertedIndicesMap;
        N(t, function(i, n) {
          var a = e._dimInfos[n], o = a.ordinalMeta, s = e._store;
          if (o) {
            i = t[n] = new she(o.categories.length);
            for (var l = 0; l < i.length; l++)
              i[l] = Gk;
            for (var l = 0; l < s.count(); l++)
              i[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, Bd = function(e, t, i) {
        return Ar(e._getCategory(t, i), null);
      }, VO = function(e, t) {
        var i = e._idList[t];
        return i == null && e._idDimIdx != null && (i = Bd(e, e._idDimIdx, t)), i == null && (i = lhe + t), i;
      }, bh = function(e) {
        return X(e) || (e = e != null ? [e] : []), e;
      }, GO = function(e) {
        var t = new r(e._schema ? e._schema : Ds(e.dimensions, e._getDimInfo, e), e.hostModel);
        return G0(t, e), t;
      }, G0 = function(e, t) {
        N(uhe.concat(t.__wrappedMethods || []), function(i) {
          t.hasOwnProperty(i) && (e[i] = t[i]);
        }), e.__wrappedMethods = t.__wrappedMethods, N(che, function(i) {
          e[i] = ye(t[i]);
        }), e._calculationInfo = B({}, t._calculationInfo);
      }, B0 = function(e, t) {
        var i = e._nameList, n = e._idList, a = e._nameDimIdx, o = e._idDimIdx, s = i[t], l = n[t];
        if (s == null && a != null && (i[t] = s = Bd(e, a, t)), l == null && o != null && (n[t] = l = Bd(e, o, t)), l == null && s != null) {
          var u = e._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), n[t] = l;
        }
      };
    }(), r;
  }()
);
const ki = hhe;
function xv(r, e) {
  sN(r) || (r = lN(r)), e = e || {};
  var t = e.coordDimensions || [], i = e.dimensionsDefine || r.dimensionsDefine || [], n = de(), a = [], o = dhe(r, t, i, e.dimensionsCount), s = e.canOmitUnusedDimensions && Cz(o), l = i === r.dimensionsDefine, u = l ? _z(r) : Az(i), c = e.encodeDefine;
  !c && e.encodeDefaulter && (c = e.encodeDefaulter(r, o));
  for (var h = de(c), f = new QW(o), d = 0; d < f.length; d++)
    f[d] = -1;
  function p(_) {
    var C = f[_];
    if (C < 0) {
      var I = i[_], w = be(I) ? I : {
        name: I
      }, x = new iE(), P = w.name;
      P != null && u.get(P) != null && (x.name = x.displayName = P), w.type != null && (x.type = w.type), w.displayName != null && (x.displayName = w.displayName);
      var L = a.length;
      return f[_] = L, x.storeDimIndex = _, a.push(x), x;
    }
    return a[C];
  }
  if (!s)
    for (var d = 0; d < o; d++)
      p(d);
  h.each(function(_, C) {
    var I = It(_).slice();
    if (I.length === 1 && !ne(I[0]) && I[0] < 0) {
      h.set(C, !1);
      return;
    }
    var w = h.set(C, []);
    N(I, function(x, P) {
      var L = ne(x) ? u.get(x) : x;
      L != null && L < o && (w[P] = L, v(p(L), C, P));
    });
  });
  var g = 0;
  N(t, function(_) {
    var C, I, w, x;
    if (ne(_))
      C = _, x = {};
    else {
      x = _, C = x.name;
      var P = x.ordinalMeta;
      x.ordinalMeta = null, x = B({}, x), x.ordinalMeta = P, I = x.dimsDef, w = x.otherDims, x.name = x.coordDim = x.coordDimIndex = x.dimsDef = x.otherDims = null;
    }
    var L = h.get(C);
    if (L !== !1) {
      if (L = It(L), !L.length)
        for (var D = 0; D < (I && I.length || 1); D++) {
          for (; g < o && p(g).coordDim != null; )
            g++;
          g < o && L.push(g++);
        }
      N(L, function(U, Q) {
        var V = p(U);
        if (l && x.type != null && (V.type = x.type), v(Te(V, x), C, Q), V.name == null && I) {
          var F = I[Q];
          !be(F) && (F = {
            name: F
          }), V.name = V.displayName = F.name, V.defaultTooltip = F.defaultTooltip;
        }
        w && Te(V.otherDims, w);
      });
    }
  });
  function v(_, C, I) {
    cC.get(C) != null ? _.otherDims[C] = I : (_.coordDim = C, _.coordDimIndex = I, n.set(C, !0));
  }
  var O = e.generateCoord, m = e.generateCoordCount, E = m != null;
  m = O ? m || 1 : 0;
  var b = O || "value";
  function S(_) {
    _.name == null && (_.name = _.coordDim);
  }
  if (s)
    N(a, function(_) {
      S(_);
    }), a.sort(function(_, C) {
      return _.storeDimIndex - C.storeDimIndex;
    });
  else
    for (var T = 0; T < o; T++) {
      var y = p(T), R = y.coordDim;
      R == null && (y.coordDim = phe(b, n, E), y.coordDimIndex = 0, (!O || m <= 0) && (y.isExtraCoord = !0), m--), S(y), y.type == null && (EW(r, T) === Wr.Must || y.isExtraCoord && (y.otherDims.itemName != null || y.otherDims.seriesName != null)) && (y.type = "ordinal");
    }
  return fhe(a), new yz({
    source: r,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function fhe(r) {
  for (var e = de(), t = 0; t < r.length; t++) {
    var i = r[t], n = i.name, a = e.get(n) || 0;
    a > 0 && (i.name = n + (a - 1)), a++, e.set(n, a);
  }
}
function dhe(r, e, t, i) {
  var n = Math.max(r.dimensionsDetectedCount || 1, e.length, t.length, i || 0);
  return N(e, function(a) {
    var o;
    be(a) && (o = a.dimsDef) && (n = Math.max(n, o.length));
  }), n;
}
function phe(r, e, t) {
  if (t || e.hasKey(r)) {
    for (var i = 0; e.hasKey(r + i); )
      i++;
    r += i;
  }
  return e.set(r, !0), r;
}
var ghe = (
  /** @class */
  function() {
    function r(e) {
      this.coordSysDims = [], this.axisMap = de(), this.categoryAxisMap = de(), this.coordSysName = e;
    }
    return r;
  }()
);
function vhe(r) {
  var e = r.get("coordinateSystem"), t = new ghe(e), i = Ohe[e];
  if (i)
    return i(r, t, t.axisMap, t.categoryAxisMap), t;
}
var Ohe = {
  cartesian2d: function(r, e, t, i) {
    var n = r.getReferringComponents("xAxis", Or).models[0], a = r.getReferringComponents("yAxis", Or).models[0];
    if ({}.NODE_ENV !== "production") {
      if (!n)
        throw new Error('xAxis "' + vr(r.get("xAxisIndex"), r.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + vr(r.get("xAxisIndex"), r.get("yAxisId"), 0) + '" not found');
    }
    e.coordSysDims = ["x", "y"], t.set("x", n), t.set("y", a), Sh(n) && (i.set("x", n), e.firstCategoryDimIndex = 0), Sh(a) && (i.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  singleAxis: function(r, e, t, i) {
    var n = r.getReferringComponents("singleAxis", Or).models[0];
    if ({}.NODE_ENV !== "production" && !n)
      throw new Error("singleAxis should be specified.");
    e.coordSysDims = ["single"], t.set("single", n), Sh(n) && (i.set("single", n), e.firstCategoryDimIndex = 0);
  },
  polar: function(r, e, t, i) {
    var n = r.getReferringComponents("polar", Or).models[0], a = n.findAxisModel("radiusAxis"), o = n.findAxisModel("angleAxis");
    if ({}.NODE_ENV !== "production") {
      if (!o)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    e.coordSysDims = ["radius", "angle"], t.set("radius", a), t.set("angle", o), Sh(a) && (i.set("radius", a), e.firstCategoryDimIndex = 0), Sh(o) && (i.set("angle", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1));
  },
  geo: function(r, e, t, i) {
    e.coordSysDims = ["lng", "lat"];
  },
  parallel: function(r, e, t, i) {
    var n = r.ecModel, a = n.getComponent("parallel", r.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice();
    N(a.parallelAxisIndex, function(s, l) {
      var u = n.getComponent("parallelAxis", s), c = o[l];
      t.set(c, u), Sh(u) && (i.set(c, u), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l));
    });
  }
};
function Sh(r) {
  return r.get("type") === "category";
}
function mhe(r, e, t) {
  t = t || {};
  var i = t.byIndex, n = t.stackedCoordDimension, a, o, s;
  Ehe(e) ? a = e : (o = e.schema, a = o.dimensions, s = e.store);
  var l = !!(r && r.get("stack")), u, c, h, f;
  if (N(a, function(m, E) {
    ne(m) && (a[E] = m = {
      name: m
    }), l && !m.isExtraCoord && (!i && !u && m.ordinalMeta && (u = m), !c && m.type !== "ordinal" && m.type !== "time" && (!n || n === m.coordDim) && (c = m));
  }), c && !i && !u && (i = !0), c) {
    h = "__\0ecstackresult_" + r.id, f = "__\0ecstackedover_" + r.id, u && (u.createInvertedIndices = !0);
    var d = c.coordDim, p = c.type, g = 0;
    N(a, function(m) {
      m.coordDim === d && g++;
    });
    var v = {
      name: h,
      coordDim: d,
      coordDimIndex: g,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, O = {
      name: f,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: f,
      coordDimIndex: g + 1,
      type: p,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (v.storeDimIndex = s.ensureCalculationDimension(f, p), O.storeDimIndex = s.ensureCalculationDimension(h, p)), o.appendCalculationDimension(v), o.appendCalculationDimension(O)) : (a.push(v), a.push(O));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: i,
    stackedOverDimension: f,
    stackResultDimension: h
  };
}
function Ehe(r) {
  return !Rz(r.schema);
}
function Ll(r, e) {
  return !!e && e === r.getCalculationInfo("stackedDimension");
}
function Iz(r, e) {
  return Ll(r, e) ? r.getCalculationInfo("stackResultDimension") : e;
}
function bhe(r, e) {
  var t = r.get("coordinateSystem"), i = sd.get(t), n;
  return e && e.coordSysDims && (n = Y(e.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = e.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = yb(l);
    }
    return o;
  })), n || (n = i && (i.getDimensionsInfo ? i.getDimensionsInfo() : i.dimensions.slice()) || ["x", "y"]), n;
}
function She(r, e, t) {
  var i, n;
  return t && N(r, function(a, o) {
    var s = a.coordDim, l = t.categoryAxisMap.get(s);
    l && (i == null && (i = o), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (n = !0);
  }), !n && i != null && (r[i].otherDims.itemName = 0), i;
}
function Ss(r, e, t) {
  t = t || {};
  var i = e.getSourceManager(), n, a = !1;
  r ? (a = !0, n = lN(r)) : (n = i.getSource(), a = n.sourceFormat === sa);
  var o = vhe(e), s = bhe(e, o), l = t.useEncodeDefaulter, u = ve(l) ? l : l ? Le(mW, s, e) : null, c = {
    coordDimensions: s,
    generateCoord: t.generateCoord,
    encodeDefine: e.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, h = xv(n, c), f = She(h.dimensions, t.createInvertedIndices, o), d = a ? null : i.getSharedDataStore(h), p = mhe(e, {
    schema: h,
    store: d
  }), g = new ki(h, e);
  g.setCalculationInfo(p);
  var v = f != null && The(n) ? function(O, m, E, b) {
    return b === f ? E : this.defaultDimValueGetter(O, m, E, b);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? n : d,
    null,
    v
  ), g;
}
function The(r) {
  if (r.sourceFormat === sa) {
    var e = yhe(r.data || []);
    return !X(jf(e));
  }
}
function yhe(r) {
  for (var e = 0; e < r.length && r[e] == null; )
    e++;
  return r[e];
}
var wz = (
  /** @class */
  function() {
    function r(e) {
      this._setting = e || {}, this._extent = [1 / 0, -1 / 0];
    }
    return r.prototype.getSetting = function(e) {
      return this._setting[e];
    }, r.prototype.unionExtent = function(e) {
      var t = this._extent;
      e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]);
    }, r.prototype.unionExtentFromData = function(e, t) {
      this.unionExtent(e.getApproximateExtent(t));
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.setExtent = function(e, t) {
      var i = this._extent;
      isNaN(e) || (i[0] = e), isNaN(t) || (i[1] = t);
    }, r.prototype.isInExtentRange = function(e) {
      return this._extent[0] <= e && this._extent[1] >= e;
    }, r.prototype.isBlank = function() {
      return this._isBlank;
    }, r.prototype.setBlank = function(e) {
      this._isBlank = e;
    }, r;
  }()
);
fT(wz);
const Ts = wz;
var Rhe = 0, Ahe = (
  /** @class */
  function() {
    function r(e) {
      this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++Rhe;
    }
    return r.createByAxisModel = function(e) {
      var t = e.option, i = t.data, n = i && Y(i, _he);
      return new r({
        categories: n,
        needCollect: !n,
        // deduplication is default in axis.
        deduplication: t.dedplication !== !1
      });
    }, r.prototype.getOrdinal = function(e) {
      return this._getOrCreateMap().get(e);
    }, r.prototype.parseAndCollect = function(e) {
      var t, i = this._needCollect;
      if (!ne(e) && !i)
        return e;
      if (i && !this._deduplication)
        return t = this.categories.length, this.categories[t] = e, t;
      var n = this._getOrCreateMap();
      return t = n.get(e), t == null && (i ? (t = this.categories.length, this.categories[t] = e, n.set(e, t)) : t = NaN), t;
    }, r.prototype._getOrCreateMap = function() {
      return this._map || (this._map = de(this.categories));
    }, r;
  }()
);
function _he(r) {
  return be(r) && r.value != null ? r.value : r + "";
}
const RC = Ahe;
function Che(r) {
  var e = Math.pow(10, cT(Math.abs(r))), t = Math.abs(r / e);
  return t === 0 || t === 1 || t === 2 || t === 3 || t === 5;
}
function AC(r) {
  return r.type === "interval" || r.type === "log";
}
function Ihe(r, e, t, i) {
  var n = {}, a = r[1] - r[0], o = n.interval = YY(a / e, !0);
  t != null && o < t && (o = n.interval = t), i != null && o > i && (o = n.interval = i);
  var s = n.intervalPrecision = Nz(o), l = n.niceTickExtent = [rr(Math.ceil(r[0] / o) * o, s), rr(Math.floor(r[1] / o) * o, s)];
  return whe(l, r), n;
}
function F0(r) {
  var e = Math.pow(10, cT(r)), t = r / e;
  return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, rr(t * e);
}
function Nz(r) {
  return oo(r) + 2;
}
function Fk(r, e, t) {
  r[e] = Math.max(Math.min(r[e], t[1]), t[0]);
}
function whe(r, e) {
  !isFinite(r[0]) && (r[0] = e[0]), !isFinite(r[1]) && (r[1] = e[1]), Fk(r, 0, e), Fk(r, 1, e), r[0] > r[1] && (r[0] = r[1]);
}
function LT(r, e) {
  return r >= e[0] && r <= e[1];
}
function DT(r, e) {
  return e[1] === e[0] ? 0.5 : (r - e[0]) / (e[1] - e[0]);
}
function MT(r, e) {
  return r * (e[1] - e[0]) + e[0];
}
var xz = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      i.type = "ordinal";
      var n = i.getSetting("ordinalMeta");
      return n || (n = new RC({})), X(n) && (n = new RC({
        categories: Y(n, function(a) {
          return be(a) ? a.value : a;
        })
      })), i._ordinalMeta = n, i._extent = i.getSetting("extent") || [0, n.categories.length - 1], i;
    }
    return e.prototype.parse = function(t) {
      return t == null ? NaN : ne(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t);
    }, e.prototype.contain = function(t) {
      return t = this.parse(t), LT(t, this._extent) && this._ordinalMeta.categories[t] != null;
    }, e.prototype.normalize = function(t) {
      return t = this._getTickNumber(this.parse(t)), DT(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = Math.round(MT(t, this._extent)), this.getRawOrdinalNumber(t);
    }, e.prototype.getTicks = function() {
      for (var t = [], i = this._extent, n = i[0]; n <= i[1]; )
        t.push({
          value: n
        }), n++;
      return t;
    }, e.prototype.getMinorTicks = function(t) {
    }, e.prototype.setSortInfo = function(t) {
      if (t == null) {
        this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null;
        return;
      }
      for (var i = t.ordinalNumbers, n = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, i.length); o < l; ++o) {
        var u = i[o];
        n[o] = u, a[u] = o;
      }
      for (var c = 0; o < s; ++o) {
        for (; a[c] != null; )
          c++;
        n.push(c), a[c] = o;
      }
    }, e.prototype._getTickNumber = function(t) {
      var i = this._ticksByOrdinalNumber;
      return i && t >= 0 && t < i.length ? i[t] : t;
    }, e.prototype.getRawOrdinalNumber = function(t) {
      var i = this._ordinalNumbersByTick;
      return i && t >= 0 && t < i.length ? i[t] : t;
    }, e.prototype.getLabel = function(t) {
      if (!this.isBlank()) {
        var i = this.getRawOrdinalNumber(t.value), n = this._ordinalMeta.categories[i];
        return n == null ? "" : n + "";
      }
    }, e.prototype.count = function() {
      return this._extent[1] - this._extent[0] + 1;
    }, e.prototype.unionExtentFromData = function(t, i) {
      this.unionExtent(t.getApproximateExtent(i));
    }, e.prototype.isInExtentRange = function(t) {
      return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t;
    }, e.prototype.getOrdinalMeta = function() {
      return this._ordinalMeta;
    }, e.prototype.calcNiceTicks = function() {
    }, e.prototype.calcNiceExtent = function() {
    }, e.type = "ordinal", e;
  }(Ts)
);
Ts.registerClass(xz);
const SN = xz;
var Su = rr, Pz = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t;
    }
    return e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return LT(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return DT(t, this._extent);
    }, e.prototype.scale = function(t) {
      return MT(t, this._extent);
    }, e.prototype.setExtent = function(t, i) {
      var n = this._extent;
      isNaN(t) || (n[0] = parseFloat(t)), isNaN(i) || (n[1] = parseFloat(i));
    }, e.prototype.unionExtent = function(t) {
      var i = this._extent;
      t[0] < i[0] && (i[0] = t[0]), t[1] > i[1] && (i[1] = t[1]), this.setExtent(i[0], i[1]);
    }, e.prototype.getInterval = function() {
      return this._interval;
    }, e.prototype.setInterval = function(t) {
      this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = Nz(t);
    }, e.prototype.getTicks = function(t) {
      var i = this._interval, n = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = [];
      if (!i)
        return s;
      var l = 1e4;
      n[0] < a[0] && (t ? s.push({
        value: Su(a[0] - i, o)
      }) : s.push({
        value: n[0]
      }));
      for (var u = a[0]; u <= a[1] && (s.push({
        value: u
      }), u = Su(u + i, o), u !== s[s.length - 1].value); )
        if (s.length > l)
          return [];
      var c = s.length ? s[s.length - 1].value : a[1];
      return n[1] > c && (t ? s.push({
        value: Su(c + i, o)
      }) : s.push({
        value: n[1]
      })), s;
    }, e.prototype.getMinorTicks = function(t) {
      for (var i = this.getTicks(!0), n = [], a = this.getExtent(), o = 1; o < i.length; o++) {
        for (var s = i[o], l = i[o - 1], u = 0, c = [], h = s.value - l.value, f = h / t; u < t - 1; ) {
          var d = Su(l.value + (u + 1) * f);
          d > a[0] && d < a[1] && c.push(d), u++;
        }
        n.push(c);
      }
      return n;
    }, e.prototype.getLabel = function(t, i) {
      if (t == null)
        return "";
      var n = i && i.precision;
      n == null ? n = oo(t.value) || 0 : n === "auto" && (n = this._intervalPrecision);
      var a = Su(t.value, n, !0);
      return cW(a);
    }, e.prototype.calcNiceTicks = function(t, i, n) {
      t = t || 5;
      var a = this._extent, o = a[1] - a[0];
      if (isFinite(o)) {
        o < 0 && (o = -o, a.reverse());
        var s = Ihe(a, t, i, n);
        this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      var i = this._extent;
      if (i[0] === i[1])
        if (i[0] !== 0) {
          var n = Math.abs(i[0]);
          t.fixMax || (i[1] += n / 2), i[0] -= n / 2;
        } else
          i[1] = 1;
      var a = i[1] - i[0];
      isFinite(a) || (i[0] = 0, i[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
      var o = this._interval;
      t.fixMin || (i[0] = Su(Math.floor(i[0] / o) * o)), t.fixMax || (i[1] = Su(Math.ceil(i[1] / o) * o));
    }, e.prototype.setNiceExtent = function(t, i) {
      this._niceExtent = [t, i];
    }, e.type = "interval", e;
  }(Ts)
);
Ts.registerClass(Pz);
const Dl = Pz;
var Lz = typeof Float32Array < "u", Nhe = Lz ? Float32Array : Array;
function lo(r) {
  return X(r) ? Lz ? new Float32Array(r) : r : new Nhe(r);
}
var _C = "__ec_stack_";
function TN(r) {
  return r.get("stack") || _C + r.seriesIndex;
}
function yN(r) {
  return r.dim + r.index;
}
function xhe(r) {
  var e = [], t = r.axis, i = "axis0";
  if (t.type === "category") {
    for (var n = t.getBandWidth(), a = 0; a < r.count; a++)
      e.push(Te({
        bandWidth: n,
        axisKey: i,
        stackId: _C + a
      }, r));
    for (var o = kz(e), s = [], a = 0; a < r.count; a++) {
      var l = o[i][_C + a];
      l.offsetCenter = l.offset + l.width / 2, s.push(l);
    }
    return s;
  }
}
function Dz(r, e) {
  var t = [];
  return e.eachSeriesByType(r, function(i) {
    $z(i) && t.push(i);
  }), t;
}
function Phe(r) {
  var e = {};
  N(r, function(l) {
    var u = l.coordinateSystem, c = u.getBaseAxis();
    if (!(c.type !== "time" && c.type !== "value"))
      for (var h = l.getData(), f = c.dim + "_" + c.index, d = h.getDimensionIndex(h.mapDimension(c.dim)), p = h.getStore(), g = 0, v = p.count(); g < v; ++g) {
        var O = p.get(d, g);
        e[f] ? e[f].push(O) : e[f] = [O];
      }
  });
  var t = {};
  for (var i in e)
    if (e.hasOwnProperty(i)) {
      var n = e[i];
      if (n) {
        n.sort(function(l, u) {
          return l - u;
        });
        for (var a = null, o = 1; o < n.length; ++o) {
          var s = n[o] - n[o - 1];
          s > 0 && (a = a === null ? s : Math.min(a, s));
        }
        t[i] = a;
      }
    }
  return t;
}
function Mz(r) {
  var e = Phe(r), t = [];
  return N(r, function(i) {
    var n = i.coordinateSystem, a = n.getBaseAxis(), o = a.getExtent(), s;
    if (a.type === "category")
      s = a.getBandWidth();
    else if (a.type === "value" || a.type === "time") {
      var l = a.dim + "_" + a.index, u = e[l], c = Math.abs(o[1] - o[0]), h = a.scale.getExtent(), f = Math.abs(h[1] - h[0]);
      s = u ? c / f * u : c;
    } else {
      var d = i.getData();
      s = Math.abs(o[1] - o[0]) / d.count();
    }
    var p = K(i.get("barWidth"), s), g = K(i.get("barMaxWidth"), s), v = K(
      // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
      // the auto-calculated bar width might be less than 0.5 / 1.
      i.get("barMinWidth") || (Vz(i) ? 0.5 : 1),
      s
    ), O = i.get("barGap"), m = i.get("barCategoryGap");
    t.push({
      bandWidth: s,
      barWidth: p,
      barMaxWidth: g,
      barMinWidth: v,
      barGap: O,
      barCategoryGap: m,
      axisKey: yN(a),
      stackId: TN(i)
    });
  }), kz(t);
}
function kz(r) {
  var e = {};
  N(r, function(i, n) {
    var a = i.axisKey, o = i.bandWidth, s = e[a] || {
      bandWidth: o,
      remainedWidth: o,
      autoWidthCount: 0,
      categoryGap: null,
      gap: "20%",
      stacks: {}
    }, l = s.stacks;
    e[a] = s;
    var u = i.stackId;
    l[u] || s.autoWidthCount++, l[u] = l[u] || {
      width: 0,
      maxWidth: 0
    };
    var c = i.barWidth;
    c && !l[u].width && (l[u].width = c, c = Math.min(s.remainedWidth, c), s.remainedWidth -= c);
    var h = i.barMaxWidth;
    h && (l[u].maxWidth = h);
    var f = i.barMinWidth;
    f && (l[u].minWidth = f);
    var d = i.barGap;
    d != null && (s.gap = d);
    var p = i.barCategoryGap;
    p != null && (s.categoryGap = p);
  });
  var t = {};
  return N(e, function(i, n) {
    t[n] = {};
    var a = i.stacks, o = i.bandWidth, s = i.categoryGap;
    if (s == null) {
      var l = Ze(a).length;
      s = Math.max(35 - l * 4, 15) + "%";
    }
    var u = K(s, o), c = K(i.gap, 1), h = i.remainedWidth, f = i.autoWidthCount, d = (h - u) / (f + (f - 1) * c);
    d = Math.max(d, 0), N(a, function(O) {
      var m = O.maxWidth, E = O.minWidth;
      if (O.width) {
        var b = O.width;
        m && (b = Math.min(b, m)), E && (b = Math.max(b, E)), O.width = b, h -= b + c * b, f--;
      } else {
        var b = d;
        m && m < b && (b = Math.min(m, h)), E && E > b && (b = E), b !== d && (O.width = b, h -= b + c * b, f--);
      }
    }), d = (h - u) / (f + (f - 1) * c), d = Math.max(d, 0);
    var p = 0, g;
    N(a, function(O, m) {
      O.width || (O.width = d), g = O, p += O.width * (1 + c);
    }), g && (p -= g.width * c);
    var v = -p / 2;
    N(a, function(O, m) {
      t[n][m] = t[n][m] || {
        bandWidth: o,
        offset: v,
        width: O.width
      }, v += O.width * (1 + c);
    });
  }), t;
}
function Lhe(r, e, t) {
  if (r && e) {
    var i = r[yN(e)];
    return i != null && t != null ? i[TN(t)] : i;
  }
}
function Qz(r, e) {
  var t = Dz(r, e), i = Mz(t);
  N(t, function(n) {
    var a = n.getData(), o = n.coordinateSystem, s = o.getBaseAxis(), l = TN(n), u = i[yN(s)][l], c = u.offset, h = u.width;
    a.setLayout({
      bandWidth: u.bandWidth,
      offset: c,
      size: h
    });
  });
}
function Uz(r) {
  return {
    seriesType: r,
    plan: ld(),
    reset: function(e) {
      if ($z(e)) {
        var t = e.getData(), i = e.coordinateSystem, n = i.getBaseAxis(), a = i.getOtherAxis(n), o = t.getDimensionIndex(t.mapDimension(a.dim)), s = t.getDimensionIndex(t.mapDimension(n.dim)), l = e.get("showBackground", !0), u = t.mapDimension(a.dim), c = t.getCalculationInfo("stackResultDimension"), h = Ll(t, u) && !!t.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), d = Dhe(n, a), p = Vz(e), g = e.get("barMinHeight") || 0, v = c && t.getDimensionIndex(c), O = t.getLayout("size"), m = t.getLayout("offset");
        return {
          progress: function(E, b) {
            for (var S = E.count, T = p && lo(S * 3), y = p && l && lo(S * 3), R = p && lo(S), _ = i.master.getRect(), C = f ? _.width : _.height, I, w = b.getStore(), x = 0; (I = E.next()) != null; ) {
              var P = w.get(h ? v : o, I), L = w.get(s, I), D = d, U = void 0;
              h && (U = +P - w.get(o, I));
              var Q = void 0, V = void 0, F = void 0, j = void 0;
              if (f) {
                var ae = i.dataToPoint([P, L]);
                if (h) {
                  var ce = i.dataToPoint([U, L]);
                  D = ce[0];
                }
                Q = D, V = ae[1] + m, F = ae[0] - D, j = O, Math.abs(F) < g && (F = (F < 0 ? -1 : 1) * g);
              } else {
                var ae = i.dataToPoint([L, P]);
                if (h) {
                  var ce = i.dataToPoint([L, U]);
                  D = ce[1];
                }
                Q = ae[0] + m, V = D, F = O, j = ae[1] - D, Math.abs(j) < g && (j = (j <= 0 ? -1 : 1) * g);
              }
              p ? (T[x] = Q, T[x + 1] = V, T[x + 2] = f ? F : j, y && (y[x] = f ? _.x : Q, y[x + 1] = f ? V : _.y, y[x + 2] = C), R[I] = I) : b.setItemLayout(I, {
                x: Q,
                y: V,
                width: F,
                height: j
              }), x += 3;
            }
            p && b.setLayout({
              largePoints: T,
              largeDataIndices: R,
              largeBackgroundPoints: y,
              valueAxisHorizontal: f
            });
          }
        };
      }
    }
  };
}
function $z(r) {
  return r.coordinateSystem && r.coordinateSystem.type === "cartesian2d";
}
function Vz(r) {
  return r.pipelineContext && r.pipelineContext.large;
}
function Dhe(r, e) {
  return e.toGlobalCoord(e.dataToCoord(e.type === "log" ? 1 : 0));
}
var Mhe = function(r, e, t, i) {
  for (; t < i; ) {
    var n = t + i >>> 1;
    r[n][1] < e ? t = n + 1 : i = n;
  }
  return t;
}, Gz = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "time", i;
    }
    return e.prototype.getLabel = function(t) {
      var i = this.getSetting("useUTC");
      return yT(t.value, DM[nle(lf(this._minLevelUnit))] || DM.second, i, this.getSetting("locale"));
    }, e.prototype.getFormattedLabel = function(t, i, n) {
      var a = this.getSetting("useUTC"), o = this.getSetting("locale");
      return ale(t, i, n, o, a);
    }, e.prototype.getTicks = function() {
      var t = this._interval, i = this._extent, n = [];
      if (!t)
        return n;
      n.push({
        value: i[0],
        level: 0
      });
      var a = this.getSetting("useUTC"), o = Bhe(this._minLevelUnit, this._approxInterval, a, i);
      return n = n.concat(o), n.push({
        value: i[1],
        level: 0
      }), n;
    }, e.prototype.calcNiceExtent = function(t) {
      var i = this._extent;
      if (i[0] === i[1] && (i[0] -= Yn, i[1] += Yn), i[1] === -1 / 0 && i[0] === 1 / 0) {
        var n = /* @__PURE__ */ new Date();
        i[1] = +new Date(n.getFullYear(), n.getMonth(), n.getDate()), i[0] = i[1] - Yn;
      }
      this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval);
    }, e.prototype.calcNiceTicks = function(t, i, n) {
      t = t || 10;
      var a = this._extent, o = a[1] - a[0];
      this._approxInterval = o / t, i != null && this._approxInterval < i && (this._approxInterval = i), n != null && this._approxInterval > n && (this._approxInterval = n);
      var s = BO.length, l = Math.min(Mhe(BO, this._approxInterval, 0, s), s - 1);
      this._interval = BO[l][1], this._minLevelUnit = BO[Math.max(l - 1, 0)][0];
    }, e.prototype.parse = function(t) {
      return pt(t) ? t : +Ao(t);
    }, e.prototype.contain = function(t) {
      return LT(this.parse(t), this._extent);
    }, e.prototype.normalize = function(t) {
      return DT(this.parse(t), this._extent);
    }, e.prototype.scale = function(t) {
      return MT(t, this._extent);
    }, e.type = "time", e;
  }(Dl)
), BO = [
  // Format                           interval
  ["second", eN],
  ["minute", tN],
  ["hour", jp],
  ["quarter-day", jp * 6],
  ["half-day", jp * 12],
  ["day", Yn * 1.2],
  ["half-week", Yn * 3.5],
  ["week", Yn * 7],
  ["month", Yn * 31],
  ["quarter", Yn * 95],
  ["half-year", LM / 2],
  ["year", LM]
  // 1Y
];
function khe(r, e, t, i) {
  var n = Ao(e), a = Ao(t), o = function(p) {
    return MM(n, p, i) === MM(a, p, i);
  }, s = function() {
    return o("year");
  }, l = function() {
    return s() && o("month");
  }, u = function() {
    return l() && o("day");
  }, c = function() {
    return u() && o("hour");
  }, h = function() {
    return c() && o("minute");
  }, f = function() {
    return h() && o("second");
  }, d = function() {
    return f() && o("millisecond");
  };
  switch (r) {
    case "year":
      return s();
    case "month":
      return l();
    case "day":
      return u();
    case "hour":
      return c();
    case "minute":
      return h();
    case "second":
      return f();
    case "millisecond":
      return d();
  }
}
function Qhe(r, e) {
  return r /= Yn, r > 16 ? 16 : r > 7.5 ? 7 : r > 3.5 ? 4 : r > 1.5 ? 2 : 1;
}
function Uhe(r) {
  var e = 30 * Yn;
  return r /= e, r > 6 ? 6 : r > 3 ? 3 : r > 2 ? 2 : 1;
}
function $he(r) {
  return r /= jp, r > 12 ? 12 : r > 6 ? 6 : r > 3.5 ? 4 : r > 2 ? 2 : 1;
}
function Xk(r, e) {
  return r /= e ? tN : eN, r > 30 ? 30 : r > 20 ? 20 : r > 15 ? 15 : r > 10 ? 10 : r > 5 ? 5 : r > 2 ? 2 : 1;
}
function Vhe(r) {
  return YY(r, !0);
}
function Ghe(r, e, t) {
  var i = new Date(r);
  switch (lf(e)) {
    case "year":
    case "month":
      i[nW(t)](0);
    case "day":
      i[aW(t)](1);
    case "hour":
      i[oW(t)](0);
    case "minute":
      i[sW(t)](0);
    case "second":
      i[lW(t)](0), i[uW(t)](0);
  }
  return i.getTime();
}
function Bhe(r, e, t, i) {
  var n = 1e4, a = rW, o = 0;
  function s(C, I, w, x, P, L, D) {
    for (var U = new Date(I), Q = I, V = U[x](); Q < w && Q <= i[1]; )
      D.push({
        value: Q
      }), V += C, U[P](V), Q = U.getTime();
    D.push({
      value: Q,
      notAdd: !0
    });
  }
  function l(C, I, w) {
    var x = [], P = !I.length;
    if (!khe(lf(C), i[0], i[1], t)) {
      P && (I = [{
        // TODO Optimize. Not include so may ticks.
        value: Ghe(new Date(i[0]), C, t)
      }, {
        value: i[1]
      }]);
      for (var L = 0; L < I.length - 1; L++) {
        var D = I[L].value, U = I[L + 1].value;
        if (D !== U) {
          var Q = void 0, V = void 0, F = void 0, j = !1;
          switch (C) {
            case "year":
              Q = Math.max(1, Math.round(e / Yn / 365)), V = rN(t), F = ole(t);
              break;
            case "half-year":
            case "quarter":
            case "month":
              Q = Uhe(e), V = uf(t), F = nW(t);
              break;
            case "week":
            case "half-week":
            case "day":
              Q = Qhe(e), V = RT(t), F = aW(t), j = !0;
              break;
            case "half-day":
            case "quarter-day":
            case "hour":
              Q = $he(e), V = Dg(t), F = oW(t);
              break;
            case "minute":
              Q = Xk(e, !0), V = AT(t), F = sW(t);
              break;
            case "second":
              Q = Xk(e, !1), V = _T(t), F = lW(t);
              break;
            case "millisecond":
              Q = Vhe(e), V = CT(t), F = uW(t);
              break;
          }
          s(Q, D, U, V, F, j, x), C === "year" && w.length > 1 && L === 0 && w.unshift({
            value: w[0].value - Q
          });
        }
      }
      for (var L = 0; L < x.length; L++)
        w.push(x[L]);
      return x;
    }
  }
  for (var u = [], c = [], h = 0, f = 0, d = 0; d < a.length && o++ < n; ++d) {
    var p = lf(a[d]);
    if (ile(a[d])) {
      l(a[d], u[u.length - 1] || [], c);
      var g = a[d + 1] ? lf(a[d + 1]) : null;
      if (p !== g) {
        if (c.length) {
          f = h, c.sort(function(C, I) {
            return C.value - I.value;
          });
          for (var v = [], O = 0; O < c.length; ++O) {
            var m = c[O].value;
            (O === 0 || c[O - 1].value !== m) && (v.push(c[O]), m >= i[0] && m <= i[1] && h++);
          }
          var E = (i[1] - i[0]) / e;
          if (h > E * 1.5 && f > E / 1.5 || (u.push(v), h > E || r === a[d]))
            break;
        }
        c = [];
      }
    }
  }
  ({}).NODE_ENV !== "production" && o >= n && tr("Exceed safe limit.");
  for (var b = At(Y(u, function(C) {
    return At(C, function(I) {
      return I.value >= i[0] && I.value <= i[1] && !I.notAdd;
    });
  }), function(C) {
    return C.length > 0;
  }), S = [], T = b.length - 1, d = 0; d < b.length; ++d)
    for (var y = b[d], R = 0; R < y.length; ++R)
      S.push({
        value: y[R].value,
        level: T - d
      });
  S.sort(function(C, I) {
    return C.value - I.value;
  });
  for (var _ = [], d = 0; d < S.length; ++d)
    (d === 0 || S[d].value !== S[d - 1].value) && _.push(S[d]);
  return _;
}
Ts.registerClass(Gz);
const Bz = Gz;
var Yk = Ts.prototype, Jp = Dl.prototype, Fhe = rr, Xhe = Math.floor, Yhe = Math.ceil, FO = Math.pow, ha = Math.log, RN = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "log", t.base = 10, t._originalScale = new Dl(), t._interval = 0, t;
    }
    return e.prototype.getTicks = function(t) {
      var i = this._originalScale, n = this._extent, a = i.getExtent(), o = Jp.getTicks.call(this, t);
      return Y(o, function(s) {
        var l = s.value, u = rr(FO(this.base, l));
        return u = l === n[0] && this._fixMin ? XO(u, a[0]) : u, u = l === n[1] && this._fixMax ? XO(u, a[1]) : u, {
          value: u
        };
      }, this);
    }, e.prototype.setExtent = function(t, i) {
      var n = ha(this.base);
      t = ha(Math.max(0, t)) / n, i = ha(Math.max(0, i)) / n, Jp.setExtent.call(this, t, i);
    }, e.prototype.getExtent = function() {
      var t = this.base, i = Yk.getExtent.call(this);
      i[0] = FO(t, i[0]), i[1] = FO(t, i[1]);
      var n = this._originalScale, a = n.getExtent();
      return this._fixMin && (i[0] = XO(i[0], a[0])), this._fixMax && (i[1] = XO(i[1], a[1])), i;
    }, e.prototype.unionExtent = function(t) {
      this._originalScale.unionExtent(t);
      var i = this.base;
      t[0] = ha(t[0]) / ha(i), t[1] = ha(t[1]) / ha(i), Yk.unionExtent.call(this, t);
    }, e.prototype.unionExtentFromData = function(t, i) {
      this.unionExtent(t.getApproximateExtent(i));
    }, e.prototype.calcNiceTicks = function(t) {
      t = t || 10;
      var i = this._extent, n = i[1] - i[0];
      if (!(n === 1 / 0 || n <= 0)) {
        var a = Aae(n), o = t / n * a;
        for (o <= 0.5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0; )
          a *= 10;
        var s = [rr(Yhe(i[0] / a) * a), rr(Xhe(i[1] / a) * a)];
        this._interval = a, this._niceExtent = s;
      }
    }, e.prototype.calcNiceExtent = function(t) {
      Jp.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax;
    }, e.prototype.parse = function(t) {
      return t;
    }, e.prototype.contain = function(t) {
      return t = ha(t) / ha(this.base), LT(t, this._extent);
    }, e.prototype.normalize = function(t) {
      return t = ha(t) / ha(this.base), DT(t, this._extent);
    }, e.prototype.scale = function(t) {
      return t = MT(t, this._extent), FO(this.base, t);
    }, e.type = "log", e;
  }(Ts)
), Fz = RN.prototype;
Fz.getMinorTicks = Jp.getMinorTicks;
Fz.getLabel = Jp.getLabel;
function XO(r, e) {
  return Fhe(r, oo(e));
}
Ts.registerClass(RN);
const Hhe = RN;
var Whe = (
  /** @class */
  function() {
    function r(e, t, i) {
      this._prepareParams(e, t, i);
    }
    return r.prototype._prepareParams = function(e, t, i) {
      i[1] < i[0] && (i = [NaN, NaN]), this._dataMin = i[0], this._dataMax = i[1];
      var n = this._isOrdinal = e.type === "ordinal";
      this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero();
      var a = this._modelMinRaw = t.get("min", !0);
      ve(a) ? this._modelMinNum = YO(e, a({
        min: i[0],
        max: i[1]
      })) : a !== "dataMin" && (this._modelMinNum = YO(e, a));
      var o = this._modelMaxRaw = t.get("max", !0);
      if (ve(o) ? this._modelMaxNum = YO(e, o({
        min: i[0],
        max: i[1]
      })) : o !== "dataMax" && (this._modelMaxNum = YO(e, o)), n)
        this._axisDataLen = t.getCategories().length;
      else {
        var s = t.get("boundaryGap"), l = X(s) ? s : [s || 0, s || 0];
        typeof l[0] == "boolean" || typeof l[1] == "boolean" ? ({}.NODE_ENV !== "production" && console.warn('Boolean type for boundaryGap is only allowed for ordinal axis. Please use string in percentage instead, e.g., "20%". Currently, boundaryGap is set to be 0.'), this._boundaryGapInner = [0, 0]) : this._boundaryGapInner = [xa(l[0], 1), xa(l[1], 1)];
      }
    }, r.prototype.calculate = function() {
      var e = this._isOrdinal, t = this._dataMin, i = this._dataMax, n = this._axisDataLen, a = this._boundaryGapInner, o = e ? null : i - t || Math.abs(t), s = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? i : this._modelMaxNum, u = s != null, c = l != null;
      s == null && (s = e ? n ? 0 : NaN : t - a[0] * o), l == null && (l = e ? n ? n - 1 : NaN : i + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN);
      var h = Cc(s) || Cc(l) || e && !n;
      this._needCrossZero && (s > 0 && l > 0 && !u && (s = 0), s < 0 && l < 0 && !c && (l = 0));
      var f = this._determinedMin, d = this._determinedMax;
      return f != null && (s = f, u = !0), d != null && (l = d, c = !0), {
        min: s,
        max: l,
        minFixed: u,
        maxFixed: c,
        isBlank: h
      };
    }, r.prototype.modifyDataMinMax = function(e, t) {
      ({}).NODE_ENV !== "production" && Se(!this.frozen), this[Zhe[e]] = t;
    }, r.prototype.setDeterminedMinMax = function(e, t) {
      var i = zhe[e];
      ({}).NODE_ENV !== "production" && Se(!this.frozen && this[i] == null), this[i] = t;
    }, r.prototype.freeze = function() {
      this.frozen = !0;
    }, r;
  }()
), zhe = {
  min: "_determinedMin",
  max: "_determinedMax"
}, Zhe = {
  min: "_dataMin",
  max: "_dataMax"
};
function Xz(r, e, t) {
  var i = r.rawExtentInfo;
  return i || (i = new Whe(r, e, t), r.rawExtentInfo = i, i);
}
function YO(r, e) {
  return e == null ? null : Cc(e) ? NaN : r.parse(e);
}
function Yz(r, e) {
  var t = r.type, i = Xz(r, e, r.getExtent()).calculate();
  r.setBlank(i.isBlank);
  var n = i.min, a = i.max, o = e.ecModel;
  if (o && t === "time") {
    var s = Dz("bar", o), l = !1;
    if (N(s, function(h) {
      l = l || h.getBaseAxis() === e.axis;
    }), l) {
      var u = Mz(s), c = qhe(n, a, e, u);
      n = c.min, a = c.max;
    }
  }
  return {
    extent: [n, a],
    // "fix" means "fixed", the value should not be
    // changed in the subsequent steps.
    fixMin: i.minFixed,
    fixMax: i.maxFixed
  };
}
function qhe(r, e, t, i) {
  var n = t.axis.getExtent(), a = n[1] - n[0], o = Lhe(i, t.axis);
  if (o === void 0)
    return {
      min: r,
      max: e
    };
  var s = 1 / 0;
  N(o, function(d) {
    s = Math.min(d.offset, s);
  });
  var l = -1 / 0;
  N(o, function(d) {
    l = Math.max(d.offset + d.width, l);
  }), s = Math.abs(s), l = Math.abs(l);
  var u = s + l, c = e - r, h = 1 - (s + l) / a, f = c / h - c;
  return e += f * (l / u), r -= f * (s / u), {
    min: r,
    max: e
  };
}
function Pf(r, e) {
  var t = e, i = Yz(r, t), n = i.extent, a = t.get("splitNumber");
  r instanceof Hhe && (r.base = t.get("logBase"));
  var o = r.type, s = t.get("interval"), l = o === "interval" || o === "time";
  r.setExtent(n[0], n[1]), r.calcNiceExtent({
    splitNumber: a,
    fixMin: i.fixMin,
    fixMax: i.fixMax,
    minInterval: l ? t.get("minInterval") : null,
    maxInterval: l ? t.get("maxInterval") : null
  }), s != null && r.setInterval && r.setInterval(s);
}
function kT(r, e) {
  if (e = e || r.get("type"), e)
    switch (e) {
      case "category":
        return new SN({
          ordinalMeta: r.getOrdinalMeta ? r.getOrdinalMeta() : r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new Bz({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new (Ts.getClass(e) || Dl)();
    }
}
function jhe(r) {
  var e = r.scale.getExtent(), t = e[0], i = e[1];
  return !(t > 0 && i > 0 || t < 0 && i < 0);
}
function Pv(r) {
  var e = r.getLabelModel().get("formatter"), t = r.type === "category" ? r.scale.getExtent()[0] : null;
  return r.scale.type === "time" ? function(i) {
    return function(n, a) {
      return r.scale.getFormattedLabel(n, a, i);
    };
  }(e) : ne(e) ? function(i) {
    return function(n) {
      var a = r.scale.getLabel(n), o = i.replace("{value}", a ?? "");
      return o;
    };
  }(e) : ve(e) ? function(i) {
    return function(n, a) {
      return t != null && (a = n.value - t), i(AN(r, n), a, n.level != null ? {
        level: n.level
      } : null);
    };
  }(e) : function(i) {
    return r.scale.getLabel(i);
  };
}
function AN(r, e) {
  return r.type === "category" ? r.scale.getLabel(e) : e.value;
}
function Khe(r) {
  var e = r.model, t = r.scale;
  if (!(!e.get(["axisLabel", "show"]) || t.isBlank())) {
    var i, n, a = t.getExtent();
    t instanceof SN ? n = t.count() : (i = t.getTicks(), n = i.length);
    var o = r.getLabelModel(), s = Pv(r), l, u = 1;
    n > 40 && (u = Math.ceil(n / 40));
    for (var c = 0; c < n; c += u) {
      var h = i ? i[c] : {
        value: a[0] + c
      }, f = s(h, c), d = o.getTextRect(f), p = Jhe(d, o.get("rotate") || 0);
      l ? l.union(p) : l = p;
    }
    return l;
  }
}
function Jhe(r, e) {
  var t = e * Math.PI / 180, i = r.width, n = r.height, a = i * Math.abs(Math.cos(t)) + Math.abs(n * Math.sin(t)), o = i * Math.abs(Math.sin(t)) + Math.abs(n * Math.cos(t)), s = new Ve(r.x, r.y, a, o);
  return s;
}
function _N(r) {
  var e = r.get("interval");
  return e ?? "auto";
}
function Hz(r) {
  return r.type === "category" && _N(r.getLabelModel()) === 0;
}
function Rb(r, e) {
  var t = {};
  return N(r.mapDimensionsAll(e), function(i) {
    t[Iz(r, i)] = !0;
  }), Ze(t);
}
function efe(r, e, t) {
  e && N(Rb(e, t), function(i) {
    var n = e.getApproximateExtent(i);
    n[0] < r[0] && (r[0] = n[0]), n[1] > r[1] && (r[1] = n[1]);
  });
}
var Lv = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getNeedCrossZero = function() {
      var e = this.option;
      return !e.scale;
    }, r.prototype.getCoordSysModel = function() {
    }, r;
  }()
), tfe = 1e-8;
function Hk(r, e) {
  return Math.abs(r - e) < tfe;
}
function Qu(r, e, t) {
  var i = 0, n = r[0];
  if (!n)
    return !1;
  for (var a = 1; a < r.length; a++) {
    var o = r[a];
    i += Fo(n[0], n[1], o[0], o[1], e, t), n = o;
  }
  var s = r[0];
  return (!Hk(n[0], s[0]) || !Hk(n[1], s[1])) && (i += Fo(n[0], n[1], s[0], s[1], e, t)), i !== 0;
}
var rfe = [];
function X0(r, e) {
  for (var t = 0; t < r.length; t++)
    Kr(r[t], r[t], e);
}
function Wk(r, e, t, i) {
  for (var n = 0; n < r.length; n++) {
    var a = r[n];
    i && (a = i.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Js(e, e, a), el(t, t, a));
  }
}
function ife(r) {
  for (var e = 0, t = 0, i = 0, n = r.length, a = r[n - 1][0], o = r[n - 1][1], s = 0; s < n; s++) {
    var l = r[s][0], u = r[s][1], c = a * u - l * o;
    e += c, t += (a + l) * c, i += (o + u) * c, a = l, o = u;
  }
  return e ? [t / e / 3, i / e / 3, e] : [r[0][0] || 0, r[0][1] || 0];
}
var Wz = (
  /** @class */
  function() {
    function r(e) {
      this.name = e;
    }
    return r.prototype.setCenter = function(e) {
      this._center = e;
    }, r.prototype.getCenter = function() {
      var e = this._center;
      return e || (e = this._center = this.calcCenter()), e;
    }, r;
  }()
), zk = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "polygon", this.exterior = e, this.interiors = t;
    }
    return r;
  }()
), Zk = (
  /** @class */
  function() {
    function r(e) {
      this.type = "linestring", this.points = e;
    }
    return r;
  }()
), zz = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this, t) || this;
      return a.type = "geoJSON", a.geometries = i, a._center = n && [n[0], n[1]], a;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this.geometries, i, n = 0, a = 0; a < t.length; a++) {
        var o = t[a], s = o.exterior, l = s && s.length;
        l > n && (i = o, n = l);
      }
      if (i)
        return ife(i.exterior);
      var u = this.getBoundingRect();
      return [u.x + u.width / 2, u.y + u.height / 2];
    }, e.prototype.getBoundingRect = function(t) {
      var i = this._rect;
      if (i && !t)
        return i;
      var n = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries;
      return N(o, function(s) {
        s.type === "polygon" ? Wk(s.exterior, n, a, t) : N(s.points, function(l) {
          Wk(l, n, a, t);
        });
      }), isFinite(n[0]) && isFinite(n[1]) && isFinite(a[0]) && isFinite(a[1]) || (n[0] = n[1] = a[0] = a[1] = 0), i = new Ve(n[0], n[1], a[0] - n[0], a[1] - n[1]), t || (this._rect = i), i;
    }, e.prototype.contain = function(t) {
      var i = this.getBoundingRect(), n = this.geometries;
      if (!i.contain(t[0], t[1]))
        return !1;
      e:
        for (var a = 0, o = n.length; a < o; a++) {
          var s = n[a];
          if (s.type === "polygon") {
            var l = s.exterior, u = s.interiors;
            if (Qu(l, t[0], t[1])) {
              for (var c = 0; c < (u ? u.length : 0); c++)
                if (Qu(u[c], t[0], t[1]))
                  continue e;
              return !0;
            }
          }
        }
      return !1;
    }, e.prototype.transformTo = function(t, i, n, a) {
      var o = this.getBoundingRect(), s = o.width / o.height;
      n ? a || (a = n / s) : n = s * a;
      for (var l = new Ve(t, i, n, a), u = o.calculateTransform(l), c = this.geometries, h = 0; h < c.length; h++) {
        var f = c[h];
        f.type === "polygon" ? (X0(f.exterior, u), N(f.interiors, function(d) {
          X0(d, u);
        })) : N(f.points, function(d) {
          X0(d, u);
        });
      }
      o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2];
    }, e.prototype.cloneShallow = function(t) {
      t == null && (t = this.name);
      var i = new e(t, this.geometries, this._center);
      return i._rect = this._rect, i.transformTo = null, i;
    }, e;
  }(Wz)
), nfe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i) {
      var n = r.call(this, t) || this;
      return n.type = "geoSVG", n._elOnlyForCalculate = i, n;
    }
    return e.prototype.calcCenter = function() {
      for (var t = this._elOnlyForCalculate, i = t.getBoundingRect(), n = [i.x + i.width / 2, i.y + i.height / 2], a = sT(rfe), o = t; o && !o.isGeoSVGGraphicRoot; )
        qo(a, o.getLocalTransform(), a), o = o.parent;
      return qf(a, a), Kr(n, n, a), n;
    }, e;
  }(Wz)
);
function afe(r) {
  if (!r.UTF8Encoding)
    return r;
  var e = r, t = e.UTF8Scale;
  t == null && (t = 1024);
  var i = e.features;
  return N(i, function(n) {
    var a = n.geometry, o = a.encodeOffsets, s = a.coordinates;
    if (o)
      switch (a.type) {
        case "LineString":
          a.coordinates = Zz(s, o, t);
          break;
        case "Polygon":
          Y0(s, o, t);
          break;
        case "MultiLineString":
          Y0(s, o, t);
          break;
        case "MultiPolygon":
          N(s, function(l, u) {
            return Y0(l, o[u], t);
          });
      }
  }), e.UTF8Encoding = !1, e;
}
function Y0(r, e, t) {
  for (var i = 0; i < r.length; i++)
    r[i] = Zz(r[i], e[i], t);
}
function Zz(r, e, t) {
  for (var i = [], n = e[0], a = e[1], o = 0; o < r.length; o += 2) {
    var s = r.charCodeAt(o) - 64, l = r.charCodeAt(o + 1) - 64;
    s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += n, l += a, n = s, a = l, i.push([s / t, l / t]);
  }
  return i;
}
function ofe(r, e) {
  return r = afe(r), Y(At(r.features, function(t) {
    return t.geometry && t.properties && t.geometry.coordinates.length > 0;
  }), function(t) {
    var i = t.properties, n = t.geometry, a = [];
    switch (n.type) {
      case "Polygon":
        var o = n.coordinates;
        a.push(new zk(o[0], o.slice(1)));
        break;
      case "MultiPolygon":
        N(n.coordinates, function(l) {
          l[0] && a.push(new zk(l[0], l.slice(1)));
        });
        break;
      case "LineString":
        a.push(new Zk([n.coordinates]));
        break;
      case "MultiLineString":
        a.push(new Zk(n.coordinates));
    }
    var s = new zz(i[e || "name"], a, i.cp);
    return s.properties = i, s;
  });
}
var Vg = ft();
function sfe(r) {
  return r.type === "category" ? ufe(r) : hfe(r);
}
function lfe(r, e) {
  return r.type === "category" ? cfe(r, e) : {
    ticks: Y(r.scale.getTicks(), function(t) {
      return t.value;
    })
  };
}
function ufe(r) {
  var e = r.getLabelModel(), t = qz(r, e);
  return !e.get("show") || r.scale.isBlank() ? {
    labels: [],
    labelCategoryInterval: t.labelCategoryInterval
  } : t;
}
function qz(r, e) {
  var t = jz(r, "labels"), i = _N(e), n = Kz(t, i);
  if (n)
    return n;
  var a, o;
  return ve(i) ? a = t3(r, i) : (o = i === "auto" ? ffe(r) : i, a = e3(r, o)), Jz(t, i, {
    labels: a,
    labelCategoryInterval: o
  });
}
function cfe(r, e) {
  var t = jz(r, "ticks"), i = _N(e), n = Kz(t, i);
  if (n)
    return n;
  var a, o;
  if ((!e.get("show") || r.scale.isBlank()) && (a = []), ve(i))
    a = t3(r, i, !0);
  else if (i === "auto") {
    var s = qz(r, r.getLabelModel());
    o = s.labelCategoryInterval, a = Y(s.labels, function(l) {
      return l.tickValue;
    });
  } else
    o = i, a = e3(r, o, !0);
  return Jz(t, i, {
    ticks: a,
    tickCategoryInterval: o
  });
}
function hfe(r) {
  var e = r.scale.getTicks(), t = Pv(r);
  return {
    labels: Y(e, function(i, n) {
      return {
        level: i.level,
        formattedLabel: t(i, n),
        rawLabel: r.scale.getLabel(i),
        tickValue: i.value
      };
    })
  };
}
function jz(r, e) {
  return Vg(r)[e] || (Vg(r)[e] = []);
}
function Kz(r, e) {
  for (var t = 0; t < r.length; t++)
    if (r[t].key === e)
      return r[t].value;
}
function Jz(r, e, t) {
  return r.push({
    key: e,
    value: t
  }), t;
}
function ffe(r) {
  var e = Vg(r).autoInterval;
  return e ?? (Vg(r).autoInterval = r.calculateCategoryInterval());
}
function dfe(r) {
  var e = pfe(r), t = Pv(r), i = (e.axisRotate - e.labelRotate) / 180 * Math.PI, n = r.scale, a = n.getExtent(), o = n.count();
  if (a[1] - a[0] < 1)
    return 0;
  var s = 1;
  o > 40 && (s = Math.max(1, Math.floor(o / 40)));
  for (var l = a[0], u = r.dataToCoord(l + 1) - r.dataToCoord(l), c = Math.abs(u * Math.cos(i)), h = Math.abs(u * Math.sin(i)), f = 0, d = 0; l <= a[1]; l += s) {
    var p = 0, g = 0, v = yv(t({
      value: l
    }), e.font, "center", "top");
    p = v.width * 1.3, g = v.height * 1.3, f = Math.max(f, p, 7), d = Math.max(d, g, 7);
  }
  var O = f / c, m = d / h;
  isNaN(O) && (O = 1 / 0), isNaN(m) && (m = 1 / 0);
  var E = Math.max(0, Math.floor(Math.min(O, m))), b = Vg(r.model), S = r.getExtent(), T = b.lastAutoInterval, y = b.lastTickCount;
  return T != null && y != null && Math.abs(T - E) <= 1 && Math.abs(y - o) <= 1 && T > E && b.axisExtent0 === S[0] && b.axisExtent1 === S[1] ? E = T : (b.lastTickCount = o, b.lastAutoInterval = E, b.axisExtent0 = S[0], b.axisExtent1 = S[1]), E;
}
function pfe(r) {
  var e = r.getLabelModel();
  return {
    axisRotate: r.getRotate ? r.getRotate() : r.isHorizontal && !r.isHorizontal() ? 90 : 0,
    labelRotate: e.get("rotate") || 0,
    font: e.getFont()
  };
}
function e3(r, e, t) {
  var i = Pv(r), n = r.scale, a = n.getExtent(), o = r.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), u = a[0], c = n.count();
  u !== 0 && l > 1 && c / l > 2 && (u = Math.round(Math.ceil(u / l) * l));
  var h = Hz(r), f = o.get("showMinLabel") || h, d = o.get("showMaxLabel") || h;
  f && u !== a[0] && g(a[0]);
  for (var p = u; p <= a[1]; p += l)
    g(p);
  d && p - l !== a[1] && g(a[1]);
  function g(v) {
    var O = {
      value: v
    };
    s.push(t ? v : {
      formattedLabel: i(O),
      rawLabel: n.getLabel(O),
      tickValue: v
    });
  }
  return s;
}
function t3(r, e, t) {
  var i = r.scale, n = Pv(r), a = [];
  return N(i.getTicks(), function(o) {
    var s = i.getLabel(o), l = o.value;
    e(o.value, s) && a.push(t ? l : {
      formattedLabel: n(o),
      rawLabel: s,
      tickValue: l
    });
  }), a;
}
var qk = [0, 1], gfe = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.onBand = !1, this.inverse = !1, this.dim = e, this.scale = t, this._extent = i || [0, 0];
    }
    return r.prototype.contain = function(e) {
      var t = this._extent, i = Math.min(t[0], t[1]), n = Math.max(t[0], t[1]);
      return e >= i && e <= n;
    }, r.prototype.containData = function(e) {
      return this.scale.contain(e);
    }, r.prototype.getExtent = function() {
      return this._extent.slice();
    }, r.prototype.getPixelPrecision = function(e) {
      return FY(e || this.scale.getExtent(), this._extent);
    }, r.prototype.setExtent = function(e, t) {
      var i = this._extent;
      i[0] = e, i[1] = t;
    }, r.prototype.dataToCoord = function(e, t) {
      var i = this._extent, n = this.scale;
      return e = n.normalize(e), this.onBand && n.type === "ordinal" && (i = i.slice(), jk(i, n.count())), yt(e, qk, i, t);
    }, r.prototype.coordToData = function(e, t) {
      var i = this._extent, n = this.scale;
      this.onBand && n.type === "ordinal" && (i = i.slice(), jk(i, n.count()));
      var a = yt(e, i, qk, t);
      return this.scale.scale(a);
    }, r.prototype.pointToData = function(e, t) {
    }, r.prototype.getTicksCoords = function(e) {
      e = e || {};
      var t = e.tickModel || this.getTickModel(), i = lfe(this, t), n = i.ticks, a = Y(n, function(s) {
        return {
          coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s),
          tickValue: s
        };
      }, this), o = t.get("alignWithLabel");
      return vfe(this, a, o, e.clamp), a;
    }, r.prototype.getMinorTicksCoords = function() {
      if (this.scale.type === "ordinal")
        return [];
      var e = this.model.getModel("minorTick"), t = e.get("splitNumber");
      t > 0 && t < 100 || (t = 5);
      var i = this.scale.getMinorTicks(t), n = Y(i, function(a) {
        return Y(a, function(o) {
          return {
            coord: this.dataToCoord(o),
            tickValue: o
          };
        }, this);
      }, this);
      return n;
    }, r.prototype.getViewLabels = function() {
      return sfe(this).labels;
    }, r.prototype.getLabelModel = function() {
      return this.model.getModel("axisLabel");
    }, r.prototype.getTickModel = function() {
      return this.model.getModel("axisTick");
    }, r.prototype.getBandWidth = function() {
      var e = this._extent, t = this.scale.getExtent(), i = t[1] - t[0] + (this.onBand ? 1 : 0);
      i === 0 && (i = 1);
      var n = Math.abs(e[1] - e[0]);
      return Math.abs(n) / i;
    }, r.prototype.calculateCategoryInterval = function() {
      return dfe(this);
    }, r;
  }()
);
function jk(r, e) {
  var t = r[1] - r[0], i = e, n = t / i / 2;
  r[0] += n, r[1] -= n;
}
function vfe(r, e, t, i) {
  var n = e.length;
  if (!r.onBand || t || !n)
    return;
  var a = r.getExtent(), o, s;
  if (n === 1)
    e[0].coord = a[0], o = e[1] = {
      coord: a[1]
    };
  else {
    var l = e[n - 1].tickValue - e[0].tickValue, u = (e[n - 1].coord - e[0].coord) / l;
    N(e, function(d) {
      d.coord -= u / 2;
    });
    var c = r.scale.getExtent();
    s = 1 + c[1] - e[n - 1].tickValue, o = {
      coord: e[n - 1].coord + u * s
    }, e.push(o);
  }
  var h = a[0] > a[1];
  f(e[0].coord, a[0]) && (i ? e[0].coord = a[0] : e.shift()), i && f(a[0], e[0].coord) && e.unshift({
    coord: a[0]
  }), f(a[1], o.coord) && (i ? o.coord = a[1] : e.pop()), i && f(o.coord, a[1]) && e.push({
    coord: a[1]
  });
  function f(d, p) {
    return d = rr(d), p = rr(p), h ? d > p : d < p;
  }
}
const Ma = gfe;
var Fd = Math.PI * 2, Tu = _o.CMD, Ofe = ["top", "right", "bottom", "left"];
function mfe(r, e, t, i, n) {
  var a = t.width, o = t.height;
  switch (r) {
    case "top":
      i.set(t.x + a / 2, t.y - e), n.set(0, -1);
      break;
    case "bottom":
      i.set(t.x + a / 2, t.y + o + e), n.set(0, 1);
      break;
    case "left":
      i.set(t.x - e, t.y + o / 2), n.set(-1, 0);
      break;
    case "right":
      i.set(t.x + a + e, t.y + o / 2), n.set(1, 0);
      break;
  }
}
function Efe(r, e, t, i, n, a, o, s, l) {
  o -= r, s -= e;
  var u = Math.sqrt(o * o + s * s);
  o /= u, s /= u;
  var c = o * t + r, h = s * t + e;
  if (Math.abs(i - n) % Fd < 1e-4)
    return l[0] = c, l[1] = h, u - t;
  if (a) {
    var f = i;
    i = ba(n), n = ba(f);
  } else
    i = ba(i), n = ba(n);
  i > n && (n += Fd);
  var d = Math.atan2(s, o);
  if (d < 0 && (d += Fd), d >= i && d <= n || d + Fd >= i && d + Fd <= n)
    return l[0] = c, l[1] = h, u - t;
  var p = t * Math.cos(i) + r, g = t * Math.sin(i) + e, v = t * Math.cos(n) + r, O = t * Math.sin(n) + e, m = (p - o) * (p - o) + (g - s) * (g - s), E = (v - o) * (v - o) + (O - s) * (O - s);
  return m < E ? (l[0] = p, l[1] = g, Math.sqrt(m)) : (l[0] = v, l[1] = O, Math.sqrt(E));
}
function Ab(r, e, t, i, n, a, o, s) {
  var l = n - r, u = a - e, c = t - r, h = i - e, f = Math.sqrt(c * c + h * h);
  c /= f, h /= f;
  var d = l * c + u * h, p = d / f;
  s && (p = Math.min(Math.max(p, 0), 1)), p *= f;
  var g = o[0] = r + p * c, v = o[1] = e + p * h;
  return Math.sqrt((g - n) * (g - n) + (v - a) * (v - a));
}
function r3(r, e, t, i, n, a, o) {
  t < 0 && (r = r + t, t = -t), i < 0 && (e = e + i, i = -i);
  var s = r + t, l = e + i, u = o[0] = Math.min(Math.max(n, r), s), c = o[1] = Math.min(Math.max(a, e), l);
  return Math.sqrt((u - n) * (u - n) + (c - a) * (c - a));
}
var pa = [];
function bfe(r, e, t) {
  var i = r3(e.x, e.y, e.width, e.height, r.x, r.y, pa);
  return t.set(pa[0], pa[1]), i;
}
function Sfe(r, e, t) {
  for (var i = 0, n = 0, a = 0, o = 0, s, l, u = 1 / 0, c = e.data, h = r.x, f = r.y, d = 0; d < c.length; ) {
    var p = c[d++];
    d === 1 && (i = c[d], n = c[d + 1], a = i, o = n);
    var g = u;
    switch (p) {
      case Tu.M:
        a = c[d++], o = c[d++], i = a, n = o;
        break;
      case Tu.L:
        g = Ab(i, n, c[d], c[d + 1], h, f, pa, !0), i = c[d++], n = c[d++];
        break;
      case Tu.C:
        g = yY(i, n, c[d++], c[d++], c[d++], c[d++], c[d], c[d + 1], h, f, pa), i = c[d++], n = c[d++];
        break;
      case Tu.Q:
        g = AY(i, n, c[d++], c[d++], c[d], c[d + 1], h, f, pa), i = c[d++], n = c[d++];
        break;
      case Tu.A:
        var v = c[d++], O = c[d++], m = c[d++], E = c[d++], b = c[d++], S = c[d++];
        d += 1;
        var T = !!(1 - c[d++]);
        s = Math.cos(b) * m + v, l = Math.sin(b) * E + O, d <= 1 && (a = s, o = l);
        var y = (h - v) * E / m + v;
        g = Efe(v, O, E, b, b + S, T, y, f, pa), i = Math.cos(b + S) * m + v, n = Math.sin(b + S) * E + O;
        break;
      case Tu.R:
        a = i = c[d++], o = n = c[d++];
        var R = c[d++], _ = c[d++];
        g = r3(a, o, R, _, h, f, pa);
        break;
      case Tu.Z:
        g = Ab(i, n, a, o, h, f, pa, !0), i = a, n = o;
        break;
    }
    g < u && (u = g, t.set(pa[0], pa[1]));
  }
  return u;
}
var Sa = new Me(), Lt = new Me(), or = new Me(), uo = new Me(), ro = new Me();
function Kk(r, e) {
  if (r) {
    var t = r.getTextGuideLine(), i = r.getTextContent();
    if (i && t) {
      var n = r.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = n.candidates || Ofe, s = i.getBoundingRect().clone();
      s.applyTransform(i.getComputedTransform());
      var l = 1 / 0, u = n.anchor, c = r.getComputedTransform(), h = c && qf([], c), f = e.get("length2") || 0;
      u && or.copy(u);
      for (var d = 0; d < o.length; d++) {
        var p = o[d];
        mfe(p, 0, s, Sa, uo), Me.scaleAndAdd(Lt, Sa, uo, f), Lt.transform(h);
        var g = r.getBoundingRect(), v = u ? u.distance(Lt) : r instanceof He ? Sfe(Lt, r.path, or) : bfe(Lt, g, or);
        v < l && (l = v, Lt.transform(c), or.transform(c), or.toArray(a[0]), Lt.toArray(a[1]), Sa.toArray(a[2]));
      }
      i3(a, e.get("minTurnAngle")), t.setShape({
        points: a
      });
    }
  }
}
var _b = [], Ii = new Me();
function i3(r, e) {
  if (e <= 180 && e > 0) {
    e = e / 180 * Math.PI, Sa.fromArray(r[0]), Lt.fromArray(r[1]), or.fromArray(r[2]), Me.sub(uo, Sa, Lt), Me.sub(ro, or, Lt);
    var t = uo.len(), i = ro.len();
    if (!(t < 1e-3 || i < 1e-3)) {
      uo.scale(1 / t), ro.scale(1 / i);
      var n = uo.dot(ro), a = Math.cos(e);
      if (a < n) {
        var o = Ab(Lt.x, Lt.y, or.x, or.y, Sa.x, Sa.y, _b, !1);
        Ii.fromArray(_b), Ii.scaleAndAdd(ro, o / Math.tan(Math.PI - e));
        var s = or.x !== Lt.x ? (Ii.x - Lt.x) / (or.x - Lt.x) : (Ii.y - Lt.y) / (or.y - Lt.y);
        if (isNaN(s))
          return;
        s < 0 ? Me.copy(Ii, Lt) : s > 1 && Me.copy(Ii, or), Ii.toArray(r[1]);
      }
    }
  }
}
function Tfe(r, e, t) {
  if (t <= 180 && t > 0) {
    t = t / 180 * Math.PI, Sa.fromArray(r[0]), Lt.fromArray(r[1]), or.fromArray(r[2]), Me.sub(uo, Lt, Sa), Me.sub(ro, or, Lt);
    var i = uo.len(), n = ro.len();
    if (!(i < 1e-3 || n < 1e-3)) {
      uo.scale(1 / i), ro.scale(1 / n);
      var a = uo.dot(e), o = Math.cos(t);
      if (a < o) {
        var s = Ab(Lt.x, Lt.y, or.x, or.y, Sa.x, Sa.y, _b, !1);
        Ii.fromArray(_b);
        var l = Math.PI / 2, u = Math.acos(ro.dot(e)), c = l + u - t;
        if (c >= l)
          Me.copy(Ii, or);
        else {
          Ii.scaleAndAdd(ro, s / Math.tan(Math.PI / 2 - c));
          var h = or.x !== Lt.x ? (Ii.x - Lt.x) / (or.x - Lt.x) : (Ii.y - Lt.y) / (or.y - Lt.y);
          if (isNaN(h))
            return;
          h < 0 ? Me.copy(Ii, Lt) : h > 1 && Me.copy(Ii, or);
        }
        Ii.toArray(r[1]);
      }
    }
  }
}
function Jk(r, e, t, i) {
  var n = t === "normal", a = n ? r : r.ensureState(t);
  a.ignore = e;
  var o = i.get("smooth");
  o && o === !0 && (o = 0.3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o);
  var s = i.getModel("lineStyle").getLineStyle();
  n ? r.useStyle(s) : a.style = s;
}
function yfe(r, e) {
  var t = e.smooth, i = e.points;
  if (i)
    if (r.moveTo(i[0][0], i[0][1]), t > 0 && i.length >= 3) {
      var n = Ks(i[0], i[1]), a = Ks(i[1], i[2]);
      if (!n || !a) {
        r.lineTo(i[1][0], i[1][1]), r.lineTo(i[2][0], i[2][1]);
        return;
      }
      var o = Math.min(n, a) * t, s = Ym([], i[1], i[0], o / n), l = Ym([], i[1], i[2], o / a), u = Ym([], s, l, 0.5);
      r.bezierCurveTo(s[0], s[1], s[0], s[1], u[0], u[1]), r.bezierCurveTo(l[0], l[1], l[0], l[1], i[2][0], i[2][1]);
    } else
      for (var c = 1; c < i.length; c++)
        r.lineTo(i[c][0], i[c][1]);
}
function CN(r, e, t) {
  var i = r.getTextGuideLine(), n = r.getTextContent();
  if (!n) {
    i && r.removeTextGuideLine();
    return;
  }
  for (var a = e.normal, o = a.get("show"), s = n.ignore, l = 0; l < xg.length; l++) {
    var u = xg[l], c = e[u], h = u === "normal";
    if (c) {
      var f = c.get("show"), d = h ? s : ke(n.states[u] && n.states[u].ignore, s);
      if (d || !ke(f, o)) {
        var p = h ? i : i && i.states[u];
        p && (p.ignore = !0);
        continue;
      }
      i || (i = new nn(), r.setTextGuideLine(i), !h && (s || !o) && Jk(i, !0, "normal", e.normal), r.stateProxy && (i.stateProxy = r.stateProxy)), Jk(i, !1, u, c);
    }
  }
  if (i) {
    Te(i.style, t), i.style.fill = null;
    var g = a.get("showAbove"), v = r.textGuideLineConfig = r.textGuideLineConfig || {};
    v.showAbove = g || !1, i.buildPath = yfe;
  }
}
function IN(r, e) {
  e = e || "labelLine";
  for (var t = {
    normal: r.getModel(e)
  }, i = 0; i < $i.length; i++) {
    var n = $i[i];
    t[n] = r.getModel([n, e]);
  }
  return t;
}
function n3(r) {
  for (var e = [], t = 0; t < r.length; t++) {
    var i = r[t];
    if (!i.defaultAttr.ignore) {
      var n = i.label, a = n.getComputedTransform(), o = n.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = n.style.margin || 0, u = o.clone();
      u.applyTransform(a), u.x -= l / 2, u.y -= l / 2, u.width += l, u.height += l;
      var c = s ? new sb(o, a) : null;
      e.push({
        label: n,
        labelLine: i.labelLine,
        rect: u,
        localRect: o,
        obb: c,
        priority: i.priority,
        defaultAttr: i.defaultAttr,
        layoutOption: i.computedLayoutOption,
        axisAligned: s,
        transform: a
      });
    }
  }
  return e;
}
function a3(r, e, t, i, n, a) {
  var o = r.length;
  if (o < 2)
    return;
  r.sort(function(R, _) {
    return R.rect[e] - _.rect[e];
  });
  for (var s = 0, l, u = !1, c = 0, h = 0; h < o; h++) {
    var f = r[h], d = f.rect;
    l = d[e] - s, l < 0 && (d[e] -= l, f.label[e] -= l, u = !0);
    var p = Math.max(-l, 0);
    c += p, s = d[e] + d[t];
  }
  c > 0 && a && S(-c / o, 0, o);
  var g = r[0], v = r[o - 1], O, m;
  E(), O < 0 && T(-O, 0.8), m < 0 && T(m, 0.8), E(), b(O, m, 1), b(m, O, -1), E(), O < 0 && y(-O), m < 0 && y(m);
  function E() {
    O = g.rect[e] - i, m = n - v.rect[e] - v.rect[t];
  }
  function b(R, _, C) {
    if (R < 0) {
      var I = Math.min(_, -R);
      if (I > 0) {
        S(I * C, 0, o);
        var w = I + R;
        w < 0 && T(-w * C, 1);
      } else
        T(-R * C, 1);
    }
  }
  function S(R, _, C) {
    R !== 0 && (u = !0);
    for (var I = _; I < C; I++) {
      var w = r[I], x = w.rect;
      x[e] += R, w.label[e] += R;
    }
  }
  function T(R, _) {
    for (var C = [], I = 0, w = 1; w < o; w++) {
      var x = r[w - 1].rect, P = Math.max(r[w].rect[e] - x[e] - x[t], 0);
      C.push(P), I += P;
    }
    if (I) {
      var L = Math.min(Math.abs(R) / I, _);
      if (R > 0)
        for (var w = 0; w < o - 1; w++) {
          var D = C[w] * L;
          S(D, 0, w + 1);
        }
      else
        for (var w = o - 1; w > 0; w--) {
          var D = C[w - 1] * L;
          S(-D, w, o);
        }
    }
  }
  function y(R) {
    var _ = R < 0 ? -1 : 1;
    R = Math.abs(R);
    for (var C = Math.ceil(R / (o - 1)), I = 0; I < o - 1; I++)
      if (_ > 0 ? S(C, 0, I + 1) : S(-C, o - I - 1, o), R -= C, R <= 0)
        return;
  }
  return u;
}
function Rfe(r, e, t, i) {
  return a3(r, "x", "width", e, t, i);
}
function o3(r, e, t, i) {
  return a3(r, "y", "height", e, t, i);
}
function s3(r) {
  var e = [];
  r.sort(function(g, v) {
    return v.priority - g.priority;
  });
  var t = new Ve(0, 0, 0, 0);
  function i(g) {
    if (!g.ignore) {
      var v = g.ensureState("emphasis");
      v.ignore == null && (v.ignore = !1);
    }
    g.ignore = !0;
  }
  for (var n = 0; n < r.length; n++) {
    var a = r[n], o = a.axisAligned, s = a.localRect, l = a.transform, u = a.label, c = a.labelLine;
    t.copy(a.rect), t.width -= 0.1, t.height -= 0.1, t.x += 0.05, t.y += 0.05;
    for (var h = a.obb, f = !1, d = 0; d < e.length; d++) {
      var p = e[d];
      if (t.intersect(p.rect)) {
        if (o && p.axisAligned) {
          f = !0;
          break;
        }
        if (p.obb || (p.obb = new sb(p.localRect, p.transform)), h || (h = new sb(s, l)), h.intersect(p.obb)) {
          f = !0;
          break;
        }
      }
    }
    f ? (i(u), c && i(c)) : (u.attr("ignore", a.defaultAttr.ignore), c && c.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a));
  }
}
function Afe(r) {
  if (r) {
    for (var e = [], t = 0; t < r.length; t++)
      e.push(r[t].slice());
    return e;
  }
}
function _fe(r, e) {
  var t = r.label, i = e && e.getTextGuideLine();
  return {
    dataIndex: r.dataIndex,
    dataType: r.dataType,
    seriesIndex: r.seriesModel.seriesIndex,
    text: r.label.style.text,
    rect: r.hostRect,
    labelRect: r.rect,
    // x: labelAttr.x,
    // y: labelAttr.y,
    align: t.style.align,
    verticalAlign: t.style.verticalAlign,
    labelLinePoints: Afe(i && i.shape.points)
  };
}
var eQ = ["align", "verticalAlign", "width", "height", "fontSize"], yi = new Ho(), H0 = ft(), Cfe = ft();
function HO(r, e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i];
    e[n] != null && (r[n] = e[n]);
  }
}
var WO = ["x", "y", "rotation"], Ife = (
  /** @class */
  function() {
    function r() {
      this._labelList = [], this._chartViewList = [];
    }
    return r.prototype.clearLabels = function() {
      this._labelList = [], this._chartViewList = [];
    }, r.prototype._addLabel = function(e, t, i, n, a) {
      var o = n.style, s = n.__hostTarget, l = s.textConfig || {}, u = n.getComputedTransform(), c = n.getBoundingRect().plain();
      Ve.applyTransform(c, c, u), u ? yi.setLocalTransform(u) : (yi.x = yi.y = yi.rotation = yi.originX = yi.originY = 0, yi.scaleX = yi.scaleY = 1), yi.rotation = ba(yi.rotation);
      var h = n.__hostTarget, f;
      if (h) {
        f = h.getBoundingRect().plain();
        var d = h.getComputedTransform();
        Ve.applyTransform(f, f, d);
      }
      var p = f && h.getTextGuideLine();
      this._labelList.push({
        label: n,
        labelLine: p,
        seriesModel: i,
        dataIndex: e,
        dataType: t,
        layoutOption: a,
        computedLayoutOption: null,
        rect: c,
        hostRect: f,
        // Label with lower priority will be hidden when overlapped
        // Use rect size as default priority
        priority: f ? f.width * f.height : 0,
        // Save default label attributes.
        // For restore if developers want get back to default value in callback.
        defaultAttr: {
          ignore: n.ignore,
          labelGuideIgnore: p && p.ignore,
          x: yi.x,
          y: yi.y,
          scaleX: yi.scaleX,
          scaleY: yi.scaleY,
          rotation: yi.rotation,
          style: {
            x: o.x,
            y: o.y,
            align: o.align,
            verticalAlign: o.verticalAlign,
            width: o.width,
            height: o.height,
            fontSize: o.fontSize
          },
          cursor: n.cursor,
          attachedPos: l.position,
          attachedRot: l.rotation
        }
      });
    }, r.prototype.addLabelsOfSeries = function(e) {
      var t = this;
      this._chartViewList.push(e);
      var i = e.__model, n = i.get("labelLayout");
      (ve(n) || Ze(n).length) && e.group.traverse(function(a) {
        if (a.ignore)
          return !0;
        var o = a.getTextContent(), s = Pe(a);
        o && !o.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, i, o, n);
      });
    }, r.prototype.updateLayoutConfig = function(e) {
      var t = e.getWidth(), i = e.getHeight();
      function n(E, b) {
        return function() {
          Kk(E, b);
        };
      }
      for (var a = 0; a < this._labelList.length; a++) {
        var o = this._labelList[a], s = o.label, l = s.__hostTarget, u = o.defaultAttr, c = void 0;
        ve(o.layoutOption) ? c = o.layoutOption(_fe(o, l)) : c = o.layoutOption, c = c || {}, o.computedLayoutOption = c;
        var h = Math.PI / 180;
        l && l.setTextConfig({
          // Force to set local false.
          local: !1,
          // Ignore position and rotation config on the host el if x or y is changed.
          position: c.x != null || c.y != null ? null : u.attachedPos,
          // Ignore rotation config on the host el if rotation is changed.
          rotation: c.rotate != null ? c.rotate * h : u.attachedRot,
          offset: [c.dx || 0, c.dy || 0]
        });
        var f = !1;
        if (c.x != null ? (s.x = K(c.x, t), s.setStyle("x", 0), f = !0) : (s.x = u.x, s.setStyle("x", u.style.x)), c.y != null ? (s.y = K(c.y, i), s.setStyle("y", 0), f = !0) : (s.y = u.y, s.setStyle("y", u.style.y)), c.labelLinePoints) {
          var d = l.getTextGuideLine();
          d && (d.setShape({
            points: c.labelLinePoints
          }), f = !1);
        }
        var p = H0(s);
        p.needsUpdateLabelLine = f, s.rotation = c.rotate != null ? c.rotate * h : u.rotation, s.scaleX = u.scaleX, s.scaleY = u.scaleY;
        for (var g = 0; g < eQ.length; g++) {
          var v = eQ[g];
          s.setStyle(v, c[v] != null ? c[v] : u.style[v]);
        }
        if (c.draggable) {
          if (s.draggable = !0, s.cursor = "move", l) {
            var O = o.seriesModel;
            if (o.dataIndex != null) {
              var m = o.seriesModel.getData(o.dataType);
              O = m.getItemModel(o.dataIndex);
            }
            s.on("drag", n(l, O.getModel("labelLine")));
          }
        } else
          s.off("drag"), s.cursor = u.cursor;
      }
    }, r.prototype.layout = function(e) {
      var t = e.getWidth(), i = e.getHeight(), n = n3(this._labelList), a = At(n, function(l) {
        return l.layoutOption.moveOverlap === "shiftX";
      }), o = At(n, function(l) {
        return l.layoutOption.moveOverlap === "shiftY";
      });
      Rfe(a, 0, t), o3(o, 0, i);
      var s = At(n, function(l) {
        return l.layoutOption.hideOverlap;
      });
      s3(s);
    }, r.prototype.processLabelsOverall = function() {
      var e = this;
      N(this._chartViewList, function(t) {
        var i = t.__model, n = t.ignoreLabelLineUpdate, a = i.isAnimationEnabled();
        t.group.traverse(function(o) {
          if (o.ignore && !o.forceLabelAnimation)
            return !0;
          var s = !n, l = o.getTextContent();
          !s && l && (s = H0(l).needsUpdateLabelLine), s && e._updateLabelLine(o, i), a && e._animateLabels(o, i);
        });
      });
    }, r.prototype._updateLabelLine = function(e, t) {
      var i = e.getTextContent(), n = Pe(e), a = n.dataIndex;
      if (i && a != null) {
        var o = t.getData(n.dataType), s = o.getItemModel(a), l = {}, u = o.getItemVisual(a, "style");
        if (u) {
          var c = o.getVisual("drawType");
          l.stroke = u[c];
        }
        var h = s.getModel("labelLine");
        CN(e, IN(s), l), Kk(e, h);
      }
    }, r.prototype._animateLabels = function(e, t) {
      var i = e.getTextContent(), n = e.getTextGuideLine();
      if (i && (e.forceLabelAnimation || !i.ignore && !i.invisible && !e.disableLabelAnimation && !sf(e))) {
        var a = H0(i), o = a.oldLayout, s = Pe(e), l = s.dataIndex, u = {
          x: i.x,
          y: i.y,
          rotation: i.rotation
        }, c = t.getData(s.dataType);
        if (o) {
          i.attr(o);
          var f = e.prevStates;
          f && (Fe(f, "select") >= 0 && i.attr(a.oldLayoutSelect), Fe(f, "emphasis") >= 0 && i.attr(a.oldLayoutEmphasis)), Ot(i, u, t, l);
        } else if (i.attr(u), !td(i).valueAnimation) {
          var h = ke(i.style.opacity, 1);
          i.style.opacity = 0, Bt(i, {
            style: {
              opacity: h
            }
          }, t, l);
        }
        if (a.oldLayout = u, i.states.select) {
          var d = a.oldLayoutSelect = {};
          HO(d, u, WO), HO(d, i.states.select, WO);
        }
        if (i.states.emphasis) {
          var p = a.oldLayoutEmphasis = {};
          HO(p, u, WO), HO(p, i.states.emphasis, WO);
        }
        jH(i, l, c, t, t);
      }
      if (n && !n.ignore && !n.invisible) {
        var a = Cfe(n), o = a.oldLayout, g = {
          points: n.shape.points
        };
        o ? (n.attr({
          shape: o
        }), Ot(n, {
          shape: g
        }, t)) : (n.setShape(g), n.style.strokePercent = 0, Bt(n, {
          style: {
            strokePercent: 1
          }
        }, t)), a.oldLayout = g;
      }
    }, r;
  }()
);
const wfe = Ife;
var W0 = ft();
function Nfe(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(e, t, i) {
    var n = W0(t).labelManager;
    n || (n = W0(t).labelManager = new wfe()), n.clearLabels();
  }), r.registerUpdateLifecycle("series:layoutlabels", function(e, t, i) {
    var n = W0(t).labelManager;
    i.updatedSeries.forEach(function(a) {
      n.addLabelsOfSeries(t.getViewOfSeriesModel(a));
    }), n.updateLayoutConfig(t), n.layout(t), n.processLabelsOverall();
  });
}
var z0 = Math.sin, Z0 = Math.cos, l3 = Math.PI, yu = Math.PI * 2, xfe = 180 / l3, Pfe = function() {
  function r() {
  }
  return r.prototype.reset = function(e) {
    this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, e || 4);
  }, r.prototype.moveTo = function(e, t) {
    this._add("M", e, t);
  }, r.prototype.lineTo = function(e, t) {
    this._add("L", e, t);
  }, r.prototype.bezierCurveTo = function(e, t, i, n, a, o) {
    this._add("C", e, t, i, n, a, o);
  }, r.prototype.quadraticCurveTo = function(e, t, i, n) {
    this._add("Q", e, t, i, n);
  }, r.prototype.arc = function(e, t, i, n, a, o) {
    this.ellipse(e, t, i, i, 0, n, a, o);
  }, r.prototype.ellipse = function(e, t, i, n, a, o, s, l) {
    var u = s - o, c = !l, h = Math.abs(u), f = il(h - yu) || (c ? u >= yu : -u >= yu), d = u > 0 ? u % yu : u % yu + yu, p = !1;
    f ? p = !0 : il(h) ? p = !1 : p = d >= l3 == !!c;
    var g = e + i * Z0(o), v = t + n * z0(o);
    this._start && this._add("M", g, v);
    var O = Math.round(a * xfe);
    if (f) {
      var m = 1 / this._p, E = (c ? 1 : -1) * (yu - m);
      this._add("A", i, n, O, 1, +c, e + i * Z0(o + E), t + n * z0(o + E)), m > 0.01 && this._add("A", i, n, O, 0, +c, g, v);
    } else {
      var b = e + i * Z0(s), S = t + n * z0(s);
      this._add("A", i, n, O, +p, +c, b, S);
    }
  }, r.prototype.rect = function(e, t, i, n) {
    this._add("M", e, t), this._add("l", i, 0), this._add("l", 0, n), this._add("l", -i, 0), this._add("Z");
  }, r.prototype.closePath = function() {
    this._d.length > 0 && this._add("Z");
  }, r.prototype._add = function(e, t, i, n, a, o, s, l, u) {
    for (var c = [], h = this._p, f = 1; f < arguments.length; f++) {
      var d = arguments[f];
      if (isNaN(d)) {
        this._invalid = !0;
        return;
      }
      c.push(Math.round(d * h) / h);
    }
    this._d.push(e + c.join(" ")), this._start = e === "Z";
  }, r.prototype.generateStr = function() {
    this._str = this._invalid ? "" : this._d.join(""), this._d = [];
  }, r.prototype.getStr = function() {
    return this._str;
  }, r;
}();
const u3 = Pfe;
var eg = "none", Lfe = Math.round;
function Dfe(r) {
  var e = r.fill;
  return e != null && e !== eg;
}
function Mfe(r) {
  var e = r.stroke;
  return e != null && e !== eg;
}
var CC = ["lineCap", "miterLimit", "lineJoin"], kfe = Y(CC, function(r) {
  return "stroke-" + r.toLowerCase();
});
function Qfe(r, e, t, i) {
  var n = e.opacity == null ? 1 : e.opacity;
  if (t instanceof ni) {
    r("opacity", n);
    return;
  }
  if (Dfe(e)) {
    var a = wg(e.fill);
    r("fill", a.color);
    var o = e.fillOpacity != null ? e.fillOpacity * a.opacity * n : a.opacity * n;
    (i || o < 1) && r("fill-opacity", o);
  } else
    r("fill", eg);
  if (Mfe(e)) {
    var s = wg(e.stroke);
    r("stroke", s.color);
    var l = e.strokeNoScale ? t.getLineScale() : 1, u = l ? (e.lineWidth || 0) / l : 0, c = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * n : s.opacity * n, h = e.strokeFirst;
    if ((i || u !== 1) && r("stroke-width", u), (i || h) && r("paint-order", h ? "stroke" : "fill"), (i || c < 1) && r("stroke-opacity", c), e.lineDash) {
      var f = vN(t), d = f[0], p = f[1];
      d && (p = Lfe(p || 0), r("stroke-dasharray", d.join(",")), (p || i) && r("stroke-dashoffset", p));
    } else
      i && r("stroke-dasharray", eg);
    for (var g = 0; g < CC.length; g++) {
      var v = CC[g];
      if (i || e[v] !== ab[v]) {
        var O = e[v] || ab[v];
        O && r(kfe[g], O);
      }
    }
  } else
    i && r("stroke", eg);
}
var c3 = "http://www.w3.org/2000/svg", h3 = "http://www.w3.org/1999/xlink", Ufe = "http://www.w3.org/2000/xmlns/", $fe = "http://www.w3.org/XML/1998/namespace";
function f3(r) {
  return document.createElementNS(c3, r);
}
function Lr(r, e, t, i, n) {
  return {
    tag: r,
    attrs: t || {},
    children: i,
    text: n,
    key: e
  };
}
function Vfe(r, e) {
  var t = [];
  if (e)
    for (var i in e) {
      var n = e[i], a = i;
      n !== !1 && (n !== !0 && n != null && (a += '="' + n + '"'), t.push(a));
    }
  return "<" + r + " " + t.join(" ") + ">";
}
function Gfe(r) {
  return "</" + r + ">";
}
function wN(r, e) {
  e = e || {};
  var t = e.newline ? `
` : "";
  function i(n) {
    var a = n.children, o = n.tag, s = n.attrs, l = n.text;
    return Vfe(o, s) + (o !== "style" ? Yi(l) : l || "") + (a ? "" + t + Y(a, function(u) {
      return i(u);
    }).join(t) + t : "") + Gfe(o);
  }
  return i(r);
}
function Bfe(r, e, t) {
  t = t || {};
  var i = t.newline ? `
` : "", n = " {" + i, a = i + "}", o = Y(Ze(r), function(l) {
    return l + n + Y(Ze(r[l]), function(u) {
      return u + ":" + r[l][u] + ";";
    }).join(i) + a;
  }).join(i), s = Y(Ze(e), function(l) {
    return "@keyframes " + l + n + Y(Ze(e[l]), function(u) {
      return u + n + Y(Ze(e[l][u]), function(c) {
        var h = e[l][u][c];
        return c === "d" && (h = 'path("' + h + '")'), c + ":" + h + ";";
      }).join(i) + a;
    }).join(i) + a;
  }).join(i);
  return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(i);
}
function IC(r) {
  return {
    zrId: r,
    shadowCache: {},
    patternCache: {},
    gradientCache: {},
    clipPathCache: {},
    defs: {},
    cssNodes: {},
    cssAnims: {},
    cssClassIdx: 0,
    cssAnimIdx: 0,
    shadowIdx: 0,
    gradientIdx: 0,
    patternIdx: 0,
    clipPathIdx: 0
  };
}
function tQ(r, e, t, i) {
  return Lr("svg", "root", {
    width: r,
    height: e,
    xmlns: c3,
    "xmlns:xlink": h3,
    version: "1.1",
    baseProfile: "full",
    viewBox: i ? "0 0 " + r + " " + e : !1
  }, t);
}
var rQ = {
  cubicIn: "0.32,0,0.67,0",
  cubicOut: "0.33,1,0.68,1",
  cubicInOut: "0.65,0,0.35,1",
  quadraticIn: "0.11,0,0.5,0",
  quadraticOut: "0.5,1,0.89,1",
  quadraticInOut: "0.45,0,0.55,1",
  quarticIn: "0.5,0,0.75,0",
  quarticOut: "0.25,1,0.5,1",
  quarticInOut: "0.76,0,0.24,1",
  quinticIn: "0.64,0,0.78,0",
  quinticOut: "0.22,1,0.36,1",
  quinticInOut: "0.83,0,0.17,1",
  sinusoidalIn: "0.12,0,0.39,0",
  sinusoidalOut: "0.61,1,0.88,1",
  sinusoidalInOut: "0.37,0,0.63,1",
  exponentialIn: "0.7,0,0.84,0",
  exponentialOut: "0.16,1,0.3,1",
  exponentialInOut: "0.87,0,0.13,1",
  circularIn: "0.55,0,1,0.45",
  circularOut: "0,0.55,0.45,1",
  circularInOut: "0.85,0,0.15,1"
}, wu = "transform-origin";
function Ffe(r, e, t) {
  var i = B({}, r.shape);
  B(i, e), r.buildPath(t, i);
  var n = new u3();
  return n.reset(PY(r)), t.rebuildPath(n, 1), n.generateStr(), n.getStr();
}
function Xfe(r, e) {
  var t = e.originX, i = e.originY;
  (t || i) && (r[wu] = t + "px " + i + "px");
}
var Yfe = {
  fill: "fill",
  opacity: "opacity",
  lineWidth: "stroke-width",
  lineDashOffset: "stroke-dashoffset"
};
function d3(r, e) {
  var t = e.zrId + "-ani-" + e.cssAnimIdx++;
  return e.cssAnims[t] = r, t;
}
function Hfe(r, e, t) {
  var i = r.shape.paths, n = {}, a, o;
  if (N(i, function(l) {
    var u = IC(t.zrId);
    u.animation = !0, QT(l, {}, u, !0);
    var c = u.cssAnims, h = u.cssNodes, f = Ze(c), d = f.length;
    if (d) {
      o = f[d - 1];
      var p = c[o];
      for (var g in p) {
        var v = p[g];
        n[g] = n[g] || { d: "" }, n[g].d += v.d || "";
      }
      for (var O in h) {
        var m = h[O].animation;
        m.indexOf(o) >= 0 && (a = m);
      }
    }
  }), !!a) {
    e.d = !1;
    var s = d3(n, t);
    return a.replace(o, s);
  }
}
function iQ(r) {
  return ne(r) ? rQ[r] ? "cubic-bezier(" + rQ[r] + ")" : P1(r) ? r : "" : "";
}
function QT(r, e, t, i) {
  var n = r.animators, a = n.length, o = [];
  if (r instanceof Z1) {
    var s = Hfe(r, e, t);
    if (s)
      o.push(s);
    else if (!a)
      return;
  } else if (!a)
    return;
  for (var l = {}, u = 0; u < a; u++) {
    var c = n[u], h = [c.getMaxTime() / 1e3 + "s"], f = iQ(c.getClip().easing), d = c.getDelay();
    f ? h.push(f) : h.push("linear"), d && h.push(d / 1e3 + "s"), c.getLoop() && h.push("infinite");
    var p = h.join(" ");
    l[p] = l[p] || [p, []], l[p][1].push(c);
  }
  function g(m) {
    var E = m[1], b = E.length, S = {}, T = {}, y = {}, R = "animation-timing-function";
    function _(Ee, Ge, Ie) {
      for (var he = Ee.getTracks(), xe = Ee.getMaxTime(), M = 0; M < he.length; M++) {
        var k = he[M];
        if (k.needsAnimate()) {
          var G = k.keyframes, H = k.propName;
          if (Ie && (H = Ie(H)), H)
            for (var z = 0; z < G.length; z++) {
              var te = G[z], se = Math.round(te.time / xe * 100) + "%", ie = iQ(te.easing), oe = te.rawValue;
              (ne(oe) || pt(oe)) && (Ge[se] = Ge[se] || {}, Ge[se][H] = te.rawValue, ie && (Ge[se][R] = ie));
            }
        }
      }
    }
    for (var C = 0; C < b; C++) {
      var I = E[C], w = I.targetName;
      w ? w === "shape" && _(I, T) : !i && _(I, S);
    }
    for (var x in S) {
      var P = {};
      QY(P, r), B(P, S[x]);
      var L = LY(P), D = S[x][R];
      y[x] = L ? {
        transform: L
      } : {}, Xfe(y[x], P), D && (y[x][R] = D);
    }
    var U, Q = !0;
    for (var x in T) {
      y[x] = y[x] || {};
      var V = !U, D = T[x][R];
      V && (U = new _o());
      var F = U.len();
      U.reset(), y[x].d = Ffe(r, T[x], U);
      var j = U.len();
      if (!V && F !== j) {
        Q = !1;
        break;
      }
      D && (y[x][R] = D);
    }
    if (!Q)
      for (var x in y)
        delete y[x].d;
    if (!i)
      for (var C = 0; C < b; C++) {
        var I = E[C], w = I.targetName;
        w === "style" && _(I, y, function(he) {
          return Yfe[he];
        });
      }
    for (var ae = Ze(y), ce = !0, ge, C = 1; C < ae.length; C++) {
      var Be = ae[C - 1], We = ae[C];
      if (y[Be][wu] !== y[We][wu]) {
        ce = !1;
        break;
      }
      ge = y[Be][wu];
    }
    if (ce && ge) {
      for (var x in y)
        y[x][wu] && delete y[x][wu];
      e[wu] = ge;
    }
    if (At(ae, function(Ee) {
      return Ze(y[Ee]).length > 0;
    }).length) {
      var Ne = d3(y, t);
      return Ne + " " + m[0] + " both";
    }
  }
  for (var v in l) {
    var s = g(l[v]);
    s && o.push(s);
  }
  if (o.length) {
    var O = t.zrId + "-cls-" + t.cssClassIdx++;
    t.cssNodes["." + O] = {
      animation: o.join(",")
    }, e.class = O;
  }
}
var Gg = Math.round;
function p3(r) {
  return r && ne(r.src);
}
function g3(r) {
  return r && ve(r.toDataURL);
}
function NN(r, e, t, i) {
  Qfe(function(n, a) {
    var o = n === "fill" || n === "stroke";
    o && xY(a) ? O3(e, r, n, i) : o && L1(a) ? m3(t, r, n, i) : r[n] = a;
  }, e, t, !1), Jfe(t, r, i);
}
function nQ(r) {
  return il(r[0] - 1) && il(r[1]) && il(r[2]) && il(r[3] - 1);
}
function Wfe(r) {
  return il(r[4]) && il(r[5]);
}
function xN(r, e, t) {
  if (e && !(Wfe(e) && nQ(e))) {
    var i = t ? 10 : 1e4;
    r.transform = nQ(e) ? "translate(" + Gg(e[4] * i) / i + " " + Gg(e[5] * i) / i + ")" : Gne(e);
  }
}
function aQ(r, e, t) {
  for (var i = r.points, n = [], a = 0; a < i.length; a++)
    n.push(Gg(i[a][0] * t) / t), n.push(Gg(i[a][1] * t) / t);
  e.points = n.join(" ");
}
function oQ(r) {
  return !r.smooth;
}
function zfe(r) {
  var e = Y(r, function(t) {
    return typeof t == "string" ? [t, t] : t;
  });
  return function(t, i, n) {
    for (var a = 0; a < e.length; a++) {
      var o = e[a], s = t[o[0]];
      s != null && (i[o[1]] = Gg(s * n) / n);
    }
  };
}
var Zfe = {
  circle: [zfe(["cx", "cy", "r"])],
  polyline: [aQ, oQ],
  polygon: [aQ, oQ]
};
function qfe(r) {
  for (var e = r.animators, t = 0; t < e.length; t++)
    if (e[t].targetName === "shape")
      return !0;
  return !1;
}
function v3(r, e) {
  var t = r.style, i = r.shape, n = Zfe[r.type], a = {}, o = e.animation, s = "path", l = r.style.strokePercent, u = e.compress && PY(r) || 4;
  if (n && !e.willUpdate && !(n[1] && !n[1](i)) && !(o && qfe(r)) && !(l < 1)) {
    s = r.type;
    var c = Math.pow(10, u);
    n[0](i, a, c);
  } else {
    var h = !r.path || r.shapeChanged();
    r.path || r.createPathProxy();
    var f = r.path;
    h && (f.beginPath(), r.buildPath(f, r.shape), r.pathUpdated());
    var d = f.getVersion(), p = r, g = p.__svgPathBuilder;
    (p.__svgPathVersion !== d || !g || l !== p.__svgPathStrokePercent) && (g || (g = p.__svgPathBuilder = new u3()), g.reset(u), f.rebuildPath(g, l), g.generateStr(), p.__svgPathVersion = d, p.__svgPathStrokePercent = l), a.d = g.getStr();
  }
  return xN(a, r.transform), NN(a, t, r, e), e.animation && QT(r, a, e), Lr(s, r.id + "", a);
}
function jfe(r, e) {
  var t = r.style, i = t.image;
  if (i && !ne(i) && (p3(i) ? i = i.src : g3(i) && (i = i.toDataURL())), !!i) {
    var n = t.x || 0, a = t.y || 0, o = t.width, s = t.height, l = {
      href: i,
      width: o,
      height: s
    };
    return n && (l.x = n), a && (l.y = a), xN(l, r.transform), NN(l, t, r, e), e.animation && QT(r, l, e), Lr("image", r.id + "", l);
  }
}
function Kfe(r, e) {
  var t = r.style, i = t.text;
  if (i != null && (i += ""), !(!i || isNaN(t.x) || isNaN(t.y))) {
    var n = t.font || Cl, a = t.x || 0, o = Fne(t.y || 0, uT(n), t.textBaseline), s = Bne[t.textAlign] || t.textAlign, l = {
      "dominant-baseline": "central",
      "text-anchor": s
    };
    if (pH(t)) {
      var u = "", c = t.fontStyle, h = dH(t.fontSize);
      if (!parseFloat(h))
        return;
      var f = t.fontFamily || aY, d = t.fontWeight;
      u += "font-size:" + h + ";font-family:" + f + ";", c && c !== "normal" && (u += "font-style:" + c + ";"), d && d !== "normal" && (u += "font-weight:" + d + ";"), l.style = u;
    } else
      l.style = "font: " + n;
    return i.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), xN(l, r.transform), NN(l, t, r, e), e.animation && QT(r, l, e), Lr("text", r.id + "", l, void 0, i);
  }
}
function sQ(r, e) {
  if (r instanceof He)
    return v3(r, e);
  if (r instanceof ni)
    return jfe(r, e);
  if (r instanceof Ng)
    return Kfe(r, e);
}
function Jfe(r, e, t) {
  var i = r.style;
  if (Xne(i)) {
    var n = Yne(r), a = t.shadowCache, o = a[n];
    if (!o) {
      var s = r.getGlobalScale(), l = s[0], u = s[1];
      if (!l || !u)
        return;
      var c = i.shadowOffsetX || 0, h = i.shadowOffsetY || 0, f = i.shadowBlur, d = wg(i.shadowColor), p = d.opacity, g = d.color, v = f / 2 / l, O = f / 2 / u, m = v + " " + O;
      o = t.zrId + "-s" + t.shadowIdx++, t.defs[o] = Lr("filter", o, {
        id: o,
        x: "-100%",
        y: "-100%",
        width: "300%",
        height: "300%"
      }, [
        Lr("feDropShadow", "", {
          dx: c / l,
          dy: h / u,
          stdDeviation: m,
          "flood-color": g,
          "flood-opacity": p
        })
      ]), a[n] = o;
    }
    e.filter = lT(o);
  }
}
function O3(r, e, t, i) {
  var n = r[t], a, o = {
    gradientUnits: n.global ? "userSpaceOnUse" : "objectBoundingBox"
  };
  if (wY(n))
    a = "linearGradient", o.x1 = n.x, o.y1 = n.y, o.x2 = n.x2, o.y2 = n.y2;
  else if (NY(n))
    a = "radialGradient", o.cx = ke(n.x, 0.5), o.cy = ke(n.y, 0.5), o.r = ke(n.r, 0.5);
  else {
    ({}).NODE_ENV !== "production" && _a("Illegal gradient type.");
    return;
  }
  for (var s = n.colorStops, l = [], u = 0, c = s.length; u < c; ++u) {
    var h = V_(s[u].offset) * 100 + "%", f = s[u].color, d = wg(f), p = d.color, g = d.opacity, v = {
      offset: h
    };
    v["stop-color"] = p, g < 1 && (v["stop-opacity"] = g), l.push(Lr("stop", u + "", v));
  }
  var O = Lr(a, "", o, l), m = wN(O), E = i.gradientCache, b = E[m];
  b || (b = i.zrId + "-g" + i.gradientIdx++, E[m] = b, o.id = b, i.defs[b] = Lr(a, b, o, l)), e[t] = lT(b);
}
function m3(r, e, t, i) {
  var n = r.style[t], a = r.getBoundingRect(), o = {}, s = n.repeat, l = s === "no-repeat", u = s === "repeat-x", c = s === "repeat-y", h;
  if (IY(n)) {
    var f = n.imageWidth, d = n.imageHeight, p = void 0, g = n.image;
    if (ne(g) ? p = g : p3(g) ? p = g.src : g3(g) && (p = g.toDataURL()), typeof Image > "u") {
      var v = "Image width/height must been given explictly in svg-ssr renderer.";
      Se(f, v), Se(d, v);
    } else if (f == null || d == null) {
      var O = function(C, I) {
        if (C) {
          var w = C.elm, x = f || I.width, P = d || I.height;
          C.tag === "pattern" && (u ? (P = 1, x /= a.width) : c && (x = 1, P /= a.height)), C.attrs.width = x, C.attrs.height = P, w && (w.setAttribute("width", x), w.setAttribute("height", P));
        }
      }, m = V1(p, null, r, function(C) {
        l || O(T, C), O(h, C);
      });
      m && m.width && m.height && (f = f || m.width, d = d || m.height);
    }
    h = Lr("image", "img", {
      href: p,
      width: f,
      height: d
    }), o.width = f, o.height = d;
  } else
    n.svgElement && (h = ye(n.svgElement), o.width = n.svgWidth, o.height = n.svgHeight);
  if (h) {
    var E, b;
    l ? E = b = 1 : u ? (b = 1, E = o.width / a.width) : c ? (E = 1, b = o.height / a.height) : o.patternUnits = "userSpaceOnUse", E != null && !isNaN(E) && (o.width = E), b != null && !isNaN(b) && (o.height = b);
    var S = LY(n);
    S && (o.patternTransform = S);
    var T = Lr("pattern", "", o, [h]), y = wN(T), R = i.patternCache, _ = R[y];
    _ || (_ = i.zrId + "-p" + i.patternIdx++, R[y] = _, o.id = _, T = i.defs[_] = Lr("pattern", _, o, [h])), e[t] = lT(_);
  }
}
function ede(r, e, t) {
  var i = t.clipPathCache, n = t.defs, a = i[r.id];
  if (!a) {
    a = t.zrId + "-c" + t.clipPathIdx++;
    var o = {
      id: a
    };
    i[r.id] = a, n[a] = Lr("clipPath", a, o, [v3(r, t)]);
  }
  e["clip-path"] = lT(a);
}
function lQ(r) {
  return document.createTextNode(r);
}
function Uu(r, e, t) {
  r.insertBefore(e, t);
}
function uQ(r, e) {
  r.removeChild(e);
}
function cQ(r, e) {
  r.appendChild(e);
}
function E3(r) {
  return r.parentNode;
}
function b3(r) {
  return r.nextSibling;
}
function q0(r, e) {
  r.textContent = e;
}
var hQ = 58, tde = 120, rde = Lr("", "");
function wC(r) {
  return r === void 0;
}
function ja(r) {
  return r !== void 0;
}
function ide(r, e, t) {
  for (var i = {}, n = e; n <= t; ++n) {
    var a = r[n].key;
    a !== void 0 && ({}.NODE_ENV !== "production" && i[a] != null && console.error("Duplicate key " + a), i[a] = n);
  }
  return i;
}
function Sp(r, e) {
  var t = r.key === e.key, i = r.tag === e.tag;
  return i && t;
}
function Bg(r) {
  var e, t = r.children, i = r.tag;
  if (ja(i)) {
    var n = r.elm = f3(i);
    if (PN(rde, r), X(t))
      for (e = 0; e < t.length; ++e) {
        var a = t[e];
        a != null && cQ(n, Bg(a));
      }
    else
      ja(r.text) && !be(r.text) && cQ(n, lQ(r.text));
  } else
    r.elm = lQ(r.text);
  return r.elm;
}
function S3(r, e, t, i, n) {
  for (; i <= n; ++i) {
    var a = t[i];
    a != null && Uu(r, Bg(a), e);
  }
}
function Cb(r, e, t, i) {
  for (; t <= i; ++t) {
    var n = e[t];
    if (n != null)
      if (ja(n.tag)) {
        var a = E3(n.elm);
        uQ(a, n.elm);
      } else
        uQ(r, n.elm);
  }
}
function PN(r, e) {
  var t, i = e.elm, n = r && r.attrs || {}, a = e.attrs || {};
  if (n !== a) {
    for (t in a) {
      var o = a[t], s = n[t];
      s !== o && (o === !0 ? i.setAttribute(t, "") : o === !1 ? i.removeAttribute(t) : t.charCodeAt(0) !== tde ? i.setAttribute(t, o) : t === "xmlns:xlink" || t === "xmlns" ? i.setAttributeNS(Ufe, t, o) : t.charCodeAt(3) === hQ ? i.setAttributeNS($fe, t, o) : t.charCodeAt(5) === hQ ? i.setAttributeNS(h3, t, o) : i.setAttribute(t, o));
    }
    for (t in n)
      t in a || i.removeAttribute(t);
  }
}
function nde(r, e, t) {
  for (var i = 0, n = 0, a = e.length - 1, o = e[0], s = e[a], l = t.length - 1, u = t[0], c = t[l], h, f, d, p; i <= a && n <= l; )
    o == null ? o = e[++i] : s == null ? s = e[--a] : u == null ? u = t[++n] : c == null ? c = t[--l] : Sp(o, u) ? (Uh(o, u), o = e[++i], u = t[++n]) : Sp(s, c) ? (Uh(s, c), s = e[--a], c = t[--l]) : Sp(o, c) ? (Uh(o, c), Uu(r, o.elm, b3(s.elm)), o = e[++i], c = t[--l]) : Sp(s, u) ? (Uh(s, u), Uu(r, s.elm, o.elm), s = e[--a], u = t[++n]) : (wC(h) && (h = ide(e, i, a)), f = h[u.key], wC(f) ? Uu(r, Bg(u), o.elm) : (d = e[f], d.tag !== u.tag ? Uu(r, Bg(u), o.elm) : (Uh(d, u), e[f] = void 0, Uu(r, d.elm, o.elm))), u = t[++n]);
  (i <= a || n <= l) && (i > a ? (p = t[l + 1] == null ? null : t[l + 1].elm, S3(r, p, t, n, l)) : Cb(r, e, i, a));
}
function Uh(r, e) {
  var t = e.elm = r.elm, i = r.children, n = e.children;
  r !== e && (PN(r, e), wC(e.text) ? ja(i) && ja(n) ? i !== n && nde(t, i, n) : ja(n) ? (ja(r.text) && q0(t, ""), S3(t, null, n, 0, n.length - 1)) : ja(i) ? Cb(t, i, 0, i.length - 1) : ja(r.text) && q0(t, "") : r.text !== e.text && (ja(i) && Cb(t, i, 0, i.length - 1), q0(t, e.text)));
}
function ade(r, e) {
  if (Sp(r, e))
    Uh(r, e);
  else {
    var t = r.elm, i = E3(t);
    Bg(e), i !== null && (Uu(i, e.elm, b3(t)), Cb(i, [r], 0, 0));
  }
  return e;
}
var ode = 0, sde = function() {
  function r(e, t, i) {
    if (this.type = "svg", this.refreshHover = fQ("refreshHover"), this.configLayer = fQ("configLayer"), this.storage = t, this._opts = i = B({}, i), this.root = e, this._id = "zr" + ode++, this._oldVNode = tQ(i.width, i.height), e && !i.ssr) {
      var n = this._viewport = document.createElement("div");
      n.style.cssText = "position:relative;overflow:hidden";
      var a = this._svgDom = this._oldVNode.elm = f3("svg");
      PN(null, this._oldVNode), n.appendChild(a), e.appendChild(n);
    }
    this.resize(i.width, i.height);
  }
  return r.prototype.getType = function() {
    return this.type;
  }, r.prototype.getViewportRoot = function() {
    return this._viewport;
  }, r.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, r.prototype.getSvgDom = function() {
    return this._svgDom;
  }, r.prototype.refresh = function() {
    if (this.root) {
      var e = this.renderToVNode({
        willUpdate: !0
      });
      e.attrs.style = "position:absolute;left:0;top:0;user-select:none", ade(this._oldVNode, e), this._oldVNode = e;
    }
  }, r.prototype.renderOneToVNode = function(e) {
    return sQ(e, IC(this._id));
  }, r.prototype.renderToVNode = function(e) {
    e = e || {};
    var t = this.storage.getDisplayList(!0), i = this._width, n = this._height, a = IC(this._id);
    a.animation = e.animation, a.willUpdate = e.willUpdate, a.compress = e.compress;
    var o = [], s = this._bgVNode = lde(i, n, this._backgroundColor, a);
    s && o.push(s);
    var l = e.compress ? null : this._mainVNode = Lr("g", "main", {}, []);
    this._paintList(t, a, l ? l.children : o), l && o.push(l);
    var u = Y(Ze(a.defs), function(f) {
      return a.defs[f];
    });
    if (u.length && o.push(Lr("defs", "defs", {}, u)), e.animation) {
      var c = Bfe(a.cssNodes, a.cssAnims, { newline: !0 });
      if (c) {
        var h = Lr("style", "stl", {}, [], c);
        o.push(h);
      }
    }
    return tQ(i, n, o, e.useViewBox);
  }, r.prototype.renderToString = function(e) {
    return e = e || {}, wN(this.renderToVNode({
      animation: ke(e.cssAnimation, !0),
      willUpdate: !1,
      compress: !0,
      useViewBox: ke(e.useViewBox, !0)
    }), { newline: !0 });
  }, r.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e;
  }, r.prototype.getSvgRoot = function() {
    return this._mainVNode && this._mainVNode.elm;
  }, r.prototype._paintList = function(e, t, i) {
    for (var n = e.length, a = [], o = 0, s, l, u = 0, c = 0; c < n; c++) {
      var h = e[c];
      if (!h.invisible) {
        var f = h.__clipPaths, d = f && f.length || 0, p = l && l.length || 0, g = void 0;
        for (g = Math.max(d - 1, p - 1); g >= 0 && !(f && l && f[g] === l[g]); g--)
          ;
        for (var v = p - 1; v > g; v--)
          o--, s = a[o - 1];
        for (var O = g + 1; O < d; O++) {
          var m = {};
          ede(f[O], m, t);
          var E = Lr("g", "clip-g-" + u++, m, []);
          (s ? s.children : i).push(E), a[o++] = E, s = E;
        }
        l = f;
        var b = sQ(h, t);
        b && (s ? s.children : i).push(b);
      }
    }
  }, r.prototype.resize = function(e, t) {
    var i = this._opts, n = this.root, a = this._viewport;
    if (e != null && (i.width = e), t != null && (i.height = t), n && a && (a.style.display = "none", e = zh(n, 0, i), t = zh(n, 1, i), a.style.display = ""), this._width !== e || this._height !== t) {
      if (this._width = e, this._height = t, a) {
        var o = a.style;
        o.width = e + "px", o.height = t + "px";
      }
      if (L1(this._backgroundColor))
        this.refresh();
      else {
        var s = this._svgDom;
        s && (s.setAttribute("width", e), s.setAttribute("height", t));
        var l = this._bgVNode && this._bgVNode.elm;
        l && (l.setAttribute("width", e), l.setAttribute("height", t));
      }
    }
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r.prototype.dispose = function() {
    this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null;
  }, r.prototype.clear = function() {
    this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null;
  }, r.prototype.toDataURL = function(e) {
    var t = this.renderToString(), i = "data:image/svg+xml;";
    return e ? (t = Wne(t), t && i + "base64," + t) : i + "charset=UTF-8," + encodeURIComponent(t);
  }, r;
}();
function fQ(r) {
  return function() {
    ({}).NODE_ENV !== "production" && _a('In SVG mode painter not support method "' + r + '"');
  };
}
function lde(r, e, t, i) {
  var n;
  if (t && t !== "none")
    if (n = Lr("rect", "bg", {
      width: r,
      height: e,
      x: "0",
      y: "0",
      id: "0"
    }), xY(t))
      O3({ fill: t }, n.attrs, "fill", i);
    else if (L1(t))
      m3({
        style: {
          fill: t
        },
        dirty: ur,
        getBoundingRect: function() {
          return { width: r, height: e };
        }
      }, n.attrs, "fill", i);
    else {
      var a = wg(t), o = a.color, s = a.opacity;
      n.attrs.fill = o, s < 1 && (n.attrs["fill-opacity"] = s);
    }
  return n;
}
const ude = sde;
function cde(r) {
  r.registerPainter("svg", ude);
}
function dQ(r, e, t) {
  var i = Il.createCanvas(), n = e.getWidth(), a = e.getHeight(), o = i.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = n + "px", o.height = a + "px", i.setAttribute("data-zr-dom-id", r)), i.width = n * t, i.height = a * t, i;
}
var hde = function(r) {
  $(e, r);
  function e(t, i, n) {
    var a = r.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    n = n || rb, typeof t == "string" ? o = dQ(t, i, n) : be(t) && (o = t, t = o.id), a.id = t, a.dom = o;
    var s = o.style;
    return s && (fY(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = i, a.dpr = n, a;
  }
  return e.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, e.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, e.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, e.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, e.prototype.createBackBuffer = function() {
    var t = this.dpr;
    this.domBack = dQ("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t);
  }, e.prototype.createRepaintRects = function(t, i, n, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new Ve(0, 0, 0, 0);
    function c(m) {
      if (!(!m.isFinite() || m.isZero()))
        if (o.length === 0) {
          var E = new Ve(0, 0, 0, 0);
          E.copy(m), o.push(E);
        } else {
          for (var b = !1, S = 1 / 0, T = 0, y = 0; y < o.length; ++y) {
            var R = o[y];
            if (R.intersect(m)) {
              var _ = new Ve(0, 0, 0, 0);
              _.copy(R), _.union(m), o[y] = _, b = !0;
              break;
            } else if (l) {
              u.copy(m), u.union(R);
              var C = m.width * m.height, I = R.width * R.height, w = u.width * u.height, x = w - C - I;
              x < S && (S = x, T = y);
            }
          }
          if (l && (o[T].union(m), b = !0), !b) {
            var E = new Ve(0, 0, 0, 0);
            E.copy(m), o.push(E);
          }
          l || (l = o.length >= s);
        }
    }
    for (var h = this.__startIndex; h < this.__endIndex; ++h) {
      var f = t[h];
      if (f) {
        var d = f.shouldBePainted(n, a, !0, !0), p = f.__isRendered && (f.__dirty & vn || !d) ? f.getPrevPaintRect() : null;
        p && c(p);
        var g = d && (f.__dirty & vn || !f.__isRendered) ? f.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
      var f = i[h], d = f.shouldBePainted(n, a, !0, !0);
      if (f && (!d || !f.__zr) && f.__isRendered) {
        var p = f.getPrevPaintRect();
        p && c(p);
      }
    }
    var v;
    do {
      v = !1;
      for (var h = 0; h < o.length; ) {
        if (o[h].isZero()) {
          o.splice(h, 1);
          continue;
        }
        for (var O = h + 1; O < o.length; )
          o[h].intersect(o[O]) ? (v = !0, o[h].union(o[O]), o.splice(O, 1)) : O++;
        h++;
      }
    } while (v);
    return this._paintRects = o, o;
  }, e.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, e.prototype.resize = function(t, i) {
    var n = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = t + "px", o.height = i + "px"), a.width = t * n, a.height = i * n, s && (s.width = t * n, s.height = i * n, n !== 1 && this.ctxBack.scale(n, n));
  }, e.prototype.clear = function(t, i, n) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    i = i || this.clearColor;
    var u = this.motionBlur && !t, c = this.lastFrameAlpha, h = this.dpr, f = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / h, l / h));
    var d = this.domBack;
    function p(g, v, O, m) {
      if (o.clearRect(g, v, O, m), i && i !== "transparent") {
        var E = void 0;
        if (aT(i)) {
          var b = i.global || i.__width === O && i.__height === m;
          E = b && i.__canvasGradient || EC(o, i, {
            x: 0,
            y: 0,
            width: O,
            height: m
          }), i.__canvasGradient = E, i.__width = O, i.__height = m;
        } else
          zie(i) && (i.scaleX = i.scaleX || h, i.scaleY = i.scaleY || h, E = bC(o, i, {
            dirty: function() {
              f.setUnpainted(), f.__painter.refresh();
            }
          }));
        o.save(), o.fillStyle = E || i, o.fillRect(g, v, O, m), o.restore();
      }
      u && (o.save(), o.globalAlpha = c, o.drawImage(d, g, v, O, m), o.restore());
    }
    !n || u ? p(0, 0, s, l) : n.length && N(n, function(g) {
      p(g.x * h, g.y * h, g.width * h, g.height * h);
    });
  }, e;
}(oa);
const j0 = hde;
var pQ = 1e5, Ru = 314159, zO = 0.01, fde = 1e-3;
function dde(r) {
  return r ? r.__builtin__ ? !0 : !(typeof r.resize != "function" || typeof r.refresh != "function") : !1;
}
function pde(r, e) {
  var t = document.createElement("div");
  return t.style.cssText = [
    "position:relative",
    "width:" + r + "px",
    "height:" + e + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", t;
}
var gde = function() {
  function r(e, t, i, n) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS";
    this._opts = i = B({}, i || {}), this.dpr = i.devicePixelRatio || rb, this._singleCanvas = a, this.root = e;
    var o = e.style;
    o && (fY(e), e.innerHTML = ""), this.storage = t;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = e, h = c.width, f = c.height;
      i.width != null && (h = i.width), i.height != null && (f = i.height), this.dpr = i.devicePixelRatio || 1, c.width = h * this.dpr, c.height = f * this.dpr, this._width = h, this._height = f;
      var d = new j0(c, this, this.dpr);
      d.__builtin__ = !0, d.initContext(), l[Ru] = d, d.zlevel = Ru, s.push(Ru), this._domRoot = e;
    } else {
      this._width = zh(e, 0, i), this._height = zh(e, 1, i);
      var u = this._domRoot = pde(this._width, this._height);
      e.appendChild(u);
    }
  }
  return r.prototype.getType = function() {
    return "canvas";
  }, r.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, r.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, r.prototype.getViewportRootOffset = function() {
    var e = this.getViewportRoot();
    if (e)
      return {
        offsetLeft: e.offsetLeft || 0,
        offsetTop: e.offsetTop || 0
      };
  }, r.prototype.refresh = function(e) {
    var t = this.storage.getDisplayList(!0), i = this._prevDisplayList, n = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(t, i, e, this._redrawId);
    for (var a = 0; a < n.length; a++) {
      var o = n[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this;
  }, r.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, r.prototype._paintHoverList = function(e) {
    var t = e.length, i = this._hoverlayer;
    if (i && i.clear(), !!t) {
      for (var n = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < t; o++) {
        var s = e[o];
        s.__inHover && (i || (i = this._hoverlayer = this.getLayer(pQ)), a || (a = i.ctx, a.save()), Ju(a, s, n, o === t - 1));
      }
      a && a.restore();
    }
  }, r.prototype.getHoverLayer = function() {
    return this.getLayer(pQ);
  }, r.prototype.paintOne = function(e, t) {
    oz(e, t);
  }, r.prototype._paintList = function(e, t, i, n) {
    if (this._redrawId === n) {
      i = i || !1, this._updateLayerStatus(e);
      var a = this._doPaintList(e, t, i), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        M_(function() {
          l._paintList(e, t, i, n);
        });
      }
    }
  }, r.prototype._compositeManually = function() {
    var e = this.getLayer(Ru).ctx, t = this._domRoot.width, i = this._domRoot.height;
    e.clearRect(0, 0, t, i), this.eachBuiltinLayer(function(n) {
      n.virtual && e.drawImage(n.dom, 0, 0, t, i);
    });
  }, r.prototype._doPaintList = function(e, t, i) {
    for (var n = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || i) && a.push(u);
    }
    for (var c = !0, h = !1, f = function(g) {
      var v = a[g], O = v.ctx, m = o && v.createRepaintRects(e, t, d._width, d._height), E = i ? v.__startIndex : v.__drawIndex, b = !i && v.incremental && Date.now, S = b && Date.now(), T = v.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
      if (v.__startIndex === v.__endIndex)
        v.clear(!1, T, m);
      else if (E === v.__startIndex) {
        var y = e[E];
        (!y.incremental || !y.notClear || i) && v.clear(!1, T, m);
      }
      E === -1 && (console.error("For some unknown reason. drawIndex is -1"), E = v.__startIndex);
      var R, _ = function(x) {
        var P = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: n._width,
          viewHeight: n._height
        };
        for (R = E; R < v.__endIndex; R++) {
          var L = e[R];
          if (L.__inHover && (h = !0), n._doPaintEl(L, v, o, x, P, R === v.__endIndex - 1), b) {
            var D = Date.now() - S;
            if (D > 15)
              break;
          }
        }
        P.prevElClipPaths && O.restore();
      };
      if (m)
        if (m.length === 0)
          R = v.__endIndex;
        else
          for (var C = d.dpr, I = 0; I < m.length; ++I) {
            var w = m[I];
            O.save(), O.beginPath(), O.rect(w.x * C, w.y * C, w.width * C, w.height * C), O.clip(), _(w), O.restore();
          }
      else
        O.save(), _(), O.restore();
      v.__drawIndex = R, v.__drawIndex < v.__endIndex && (c = !1);
    }, d = this, p = 0; p < a.length; p++)
      f(p);
    return ct.wxa && N(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: h
    };
  }, r.prototype._doPaintEl = function(e, t, i, n, a, o) {
    var s = t.ctx;
    if (i) {
      var l = e.getPaintRect();
      (!n || l && l.intersect(n)) && (Ju(s, e, a, o), e.setPrevPaintRect(l));
    } else
      Ju(s, e, a, o);
  }, r.prototype.getLayer = function(e, t) {
    this._singleCanvas && !this._needsManuallyCompositing && (e = Ru);
    var i = this._layers[e];
    return i || (i = new j0("zr_" + e, this, this.dpr), i.zlevel = e, i.__builtin__ = !0, this._layerConfig[e] ? $e(i, this._layerConfig[e], !0) : this._layerConfig[e - zO] && $e(i, this._layerConfig[e - zO], !0), t && (i.virtual = t), this.insertLayer(e, i), i.initContext()), i;
  }, r.prototype.insertLayer = function(e, t) {
    var i = this._layers, n = this._zlevelList, a = n.length, o = this._domRoot, s = null, l = -1;
    if (i[e]) {
      ({}).NODE_ENV !== "production" && _a("ZLevel " + e + " has been used already");
      return;
    }
    if (!dde(t)) {
      ({}).NODE_ENV !== "production" && _a("Layer of zlevel " + e + " is not valid");
      return;
    }
    if (a > 0 && e > n[0]) {
      for (l = 0; l < a - 1 && !(n[l] < e && n[l + 1] > e); l++)
        ;
      s = i[n[l]];
    }
    if (n.splice(l + 1, 0, e), i[e] = t, !t.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? o.insertBefore(t.dom, u.nextSibling) : o.appendChild(t.dom);
      } else
        o.firstChild ? o.insertBefore(t.dom, o.firstChild) : o.appendChild(t.dom);
    t.__painter = this;
  }, r.prototype.eachLayer = function(e, t) {
    for (var i = this._zlevelList, n = 0; n < i.length; n++) {
      var a = i[n];
      e.call(t, this._layers[a], a);
    }
  }, r.prototype.eachBuiltinLayer = function(e, t) {
    for (var i = this._zlevelList, n = 0; n < i.length; n++) {
      var a = i[n], o = this._layers[a];
      o.__builtin__ && e.call(t, o, a);
    }
  }, r.prototype.eachOtherLayer = function(e, t) {
    for (var i = this._zlevelList, n = 0; n < i.length; n++) {
      var a = i[n], o = this._layers[a];
      o.__builtin__ || e.call(t, o, a);
    }
  }, r.prototype.getLayers = function() {
    return this._layers;
  }, r.prototype._updateLayerStatus = function(e) {
    this.eachBuiltinLayer(function(h, f) {
      h.__dirty = h.__used = !1;
    });
    function t(h) {
      a && (a.__endIndex !== h && (a.__dirty = !0), a.__endIndex = h);
    }
    if (this._singleCanvas)
      for (var i = 1; i < e.length; i++) {
        var n = e[i];
        if (n.zlevel !== e[i - 1].zlevel || n.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < e.length; l++) {
      var n = e[l], u = n.zlevel, c = void 0;
      s !== u && (s = u, o = 0), n.incremental ? (c = this.getLayer(u + fde, this._needsManuallyCompositing), c.incremental = !0, o = 1) : c = this.getLayer(u + (o > 0 ? zO : 0), this._needsManuallyCompositing), c.__builtin__ || _a("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, t(l), a = c), n.__dirty & vn && !n.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    t(l), this.eachBuiltinLayer(function(h, f) {
      !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
    });
  }, r.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, r.prototype._clearLayer = function(e) {
    e.clear();
  }, r.prototype.setBackgroundColor = function(e) {
    this._backgroundColor = e, N(this._layers, function(t) {
      t.setUnpainted();
    });
  }, r.prototype.configLayer = function(e, t) {
    if (t) {
      var i = this._layerConfig;
      i[e] ? $e(i[e], t, !0) : i[e] = t;
      for (var n = 0; n < this._zlevelList.length; n++) {
        var a = this._zlevelList[n];
        if (a === e || a === e + zO) {
          var o = this._layers[a];
          $e(o, i[e], !0);
        }
      }
    }
  }, r.prototype.delLayer = function(e) {
    var t = this._layers, i = this._zlevelList, n = t[e];
    n && (n.dom.parentNode.removeChild(n.dom), delete t[e], i.splice(Fe(i, e), 1));
  }, r.prototype.resize = function(e, t) {
    if (this._domRoot.style) {
      var i = this._domRoot;
      i.style.display = "none";
      var n = this._opts, a = this.root;
      if (e != null && (n.width = e), t != null && (n.height = t), e = zh(a, 0, n), t = zh(a, 1, n), i.style.display = "", this._width !== e || t !== this._height) {
        i.style.width = e + "px", i.style.height = t + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(e, t);
        this.refresh(!0);
      }
      this._width = e, this._height = t;
    } else {
      if (e == null || t == null)
        return;
      this._width = e, this._height = t, this.getLayer(Ru).resize(e, t);
    }
    return this;
  }, r.prototype.clearLayer = function(e) {
    var t = this._layers[e];
    t && t.clear();
  }, r.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, r.prototype.getRenderedCanvas = function(e) {
    if (e = e || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Ru].dom;
    var t = new j0("image", this, e.pixelRatio || this.dpr);
    t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor);
    var i = t.ctx;
    if (e.pixelRatio <= this.dpr) {
      this.refresh();
      var n = t.dom.width, a = t.dom.height;
      this.eachLayer(function(h) {
        h.__builtin__ ? i.drawImage(h.dom, 0, 0, n, a) : h.renderToCanvas && (i.save(), h.renderToCanvas(i), i.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        Ju(i, c, o, l === u - 1);
      }
    return t.dom;
  }, r.prototype.getWidth = function() {
    return this._width;
  }, r.prototype.getHeight = function() {
    return this._height;
  }, r;
}();
const vde = gde;
function Ode(r) {
  r.registerPainter("canvas", vde);
}
var mde = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      if ({}.NODE_ENV !== "production") {
        var i = t.coordinateSystem;
        if (i !== "polar" && i !== "cartesian2d")
          throw new Error("Line not support coordinateSystem besides cartesian and polar");
      }
      return Ss(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getLegendIcon = function(t) {
      var i = new Re(), n = Er("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1);
      i.add(n), n.setStyle(t.lineStyle);
      var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = t.itemHeight * 0.8, u = Er(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill);
      i.add(u), u.setStyle(t.itemStyle);
      var c = t.iconRotate === "inherit" ? o : t.iconRotate || 0;
      return u.rotation = c * Math.PI / 180, u.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (u.style.stroke = u.style.fill, u.style.fill = "#fff", u.style.lineWidth = 2), i;
    }, e.type = "series.line", e.dependencies = ["grid", "polar"], e.defaultOption = {
      // zlevel: 0,
      z: 3,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      clip: !0,
      label: {
        position: "top"
      },
      // itemStyle: {
      // },
      endLabel: {
        show: !1,
        valueAnimation: !0,
        distance: 8
      },
      lineStyle: {
        width: 2,
        type: "solid"
      },
      emphasis: {
        scale: !0
      },
      // areaStyle: {
      // origin of areaStyle. Valid values:
      // `'auto'/null/undefined`: from axisLine to data
      // `'start'`: from min to data
      // `'end'`: from data to max
      // origin: 'auto'
      // },
      // false, 'start', 'end', 'middle'
      step: !1,
      // Disabled if step is true
      smooth: !1,
      smoothMonotone: null,
      symbol: "emptyCircle",
      symbolSize: 4,
      symbolRotate: null,
      showSymbol: !0,
      // `false`: follow the label interval strategy.
      // `true`: show all symbols.
      // `'auto'`: If possible, show all symbols, otherwise
      //           follow the label interval strategy.
      showAllSymbol: "auto",
      // Whether to connect break point.
      connectNulls: !1,
      // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
      sampling: "none",
      animationEasing: "linear",
      // Disable progressive
      progressive: 0,
      hoverLayerThreshold: 1 / 0,
      universalTransition: {
        divideShape: "clone"
      },
      triggerLineEvent: !1
    }, e;
  }(Wt)
);
const Ede = mde;
function Lf(r, e) {
  var t = r.mapDimensionsAll("defaultedLabel"), i = t.length;
  if (i === 1) {
    var n = Nf(r, e, t[0]);
    return n != null ? n + "" : null;
  } else if (i) {
    for (var a = [], o = 0; o < t.length; o++)
      a.push(Nf(r, e, t[o]));
    return a.join(" ");
  }
}
function T3(r, e) {
  var t = r.mapDimensionsAll("defaultedLabel");
  if (!X(e))
    return e + "";
  for (var i = [], n = 0; n < t.length; n++) {
    var a = r.getDimensionIndex(t[n]);
    a >= 0 && i.push(e[a]);
  }
  return i.join(" ");
}
var bde = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n, a) {
      var o = r.call(this) || this;
      return o.updateData(t, i, n, a), o;
    }
    return e.prototype._createSymbol = function(t, i, n, a, o) {
      this.removeAll();
      var s = Er(t, -1, -1, 2, 2, null, o);
      s.attr({
        z2: 100,
        culling: !0,
        scaleX: a[0] / 2,
        scaleY: a[1] / 2
      }), s.drift = Sde, this._symbolType = t, this.add(s);
    }, e.prototype.stopSymbolAnimation = function(t) {
      this.childAt(0).stopAnimation(null, t);
    }, e.prototype.getSymbolType = function() {
      return this._symbolType;
    }, e.prototype.getSymbolPath = function() {
      return this.childAt(0);
    }, e.prototype.highlight = function() {
      ls(this.childAt(0));
    }, e.prototype.downplay = function() {
      us(this.childAt(0));
    }, e.prototype.setZ = function(t, i) {
      var n = this.childAt(0);
      n.zlevel = t, n.z = i;
    }, e.prototype.setDraggable = function(t, i) {
      var n = this.childAt(0);
      n.draggable = t, n.cursor = !i && t ? "move" : n.cursor;
    }, e.prototype.updateData = function(t, i, n, a) {
      this.silent = !1;
      var o = t.getItemVisual(i, "symbol") || "circle", s = t.hostModel, l = e.getSymbolSize(t, i), u = o !== this._symbolType, c = a && a.disableAnimation;
      if (u) {
        var h = t.getItemVisual(i, "symbolKeepAspect");
        this._createSymbol(o, t, i, l, h);
      } else {
        var f = this.childAt(0);
        f.silent = !1;
        var d = {
          scaleX: l[0] / 2,
          scaleY: l[1] / 2
        };
        c ? f.attr(d) : Ot(f, d, s, i), La(f);
      }
      if (this._updateCommon(t, i, l, n, a), u) {
        var f = this.childAt(0);
        if (!c) {
          var d = {
            scaleX: this._sizeX,
            scaleY: this._sizeY,
            style: {
              // Always fadeIn. Because it has fadeOut animation when symbol is removed..
              opacity: f.style.opacity
            }
          };
          f.scaleX = f.scaleY = 0, f.style.opacity = 0, Bt(f, d, s, i);
        }
      }
      c && this.childAt(0).stopAnimation("leave");
    }, e.prototype._updateCommon = function(t, i, n, a, o) {
      var s = this.childAt(0), l = t.hostModel, u, c, h, f, d, p, g, v, O;
      if (a && (u = a.emphasisItemStyle, c = a.blurItemStyle, h = a.selectItemStyle, f = a.focus, d = a.blurScope, g = a.labelStatesModels, v = a.hoverScale, O = a.cursorStyle, p = a.emphasisDisabled), !a || t.hasItemOption) {
        var m = a && a.itemModel ? a.itemModel : t.getItemModel(i), E = m.getModel("emphasis");
        u = E.getModel("itemStyle").getItemStyle(), h = m.getModel(["select", "itemStyle"]).getItemStyle(), c = m.getModel(["blur", "itemStyle"]).getItemStyle(), f = E.get("focus"), d = E.get("blurScope"), p = E.get("disabled"), g = kr(m), v = E.getShallow("scale"), O = m.getShallow("cursor");
      }
      var b = t.getItemVisual(i, "symbolRotate");
      s.attr("rotation", (b || 0) * Math.PI / 180 || 0);
      var S = qc(t.getItemVisual(i, "symbolOffset"), n);
      S && (s.x = S[0], s.y = S[1]), O && s.attr("cursor", O);
      var T = t.getItemVisual(i, "style"), y = T.fill;
      if (s instanceof ni) {
        var R = s.style;
        s.useStyle(B({
          // TODO other properties like x, y ?
          image: R.image,
          x: R.x,
          y: R.y,
          width: R.width,
          height: R.height
        }, T));
      } else
        s.__isEmptyBrush ? s.useStyle(B({}, T)) : s.useStyle(T), s.style.decal = null, s.setColor(y, o && o.symbolInnerColor), s.style.strokeNoScale = !0;
      var _ = t.getItemVisual(i, "liftZ"), C = this._z2;
      _ != null ? C == null && (this._z2 = s.z2, s.z2 += _) : C != null && (s.z2 = C, this._z2 = null);
      var I = o && o.useNameLabel;
      ii(s, g, {
        labelFetcher: l,
        labelDataIndex: i,
        defaultText: w,
        inheritColor: y,
        defaultOpacity: T.opacity
      });
      function w(L) {
        return I ? t.getName(L) : Lf(t, L);
      }
      this._sizeX = n[0] / 2, this._sizeY = n[1] / 2;
      var x = s.ensureState("emphasis");
      x.style = u, s.ensureState("select").style = h, s.ensureState("blur").style = c;
      var P = v == null || v === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(v) && v > 0 ? +v : 1;
      x.scaleX = this._sizeX * P, x.scaleY = this._sizeY * P, this.setSymbolScale(1), qt(this, f, d, p);
    }, e.prototype.setSymbolScale = function(t) {
      this.scaleX = this.scaleY = t;
    }, e.prototype.fadeOut = function(t, i, n) {
      var a = this.childAt(0), o = Pe(this).dataIndex, s = n && n.animation;
      if (this.silent = a.silent = !0, n && n.fadeLabel) {
        var l = a.getTextContent();
        l && xl(l, {
          style: {
            opacity: 0
          }
        }, i, {
          dataIndex: o,
          removeOpt: s,
          cb: function() {
            a.removeTextContent();
          }
        });
      } else
        a.removeTextContent();
      xl(a, {
        style: {
          opacity: 0
        },
        scaleX: 0,
        scaleY: 0
      }, i, {
        dataIndex: o,
        cb: t,
        removeOpt: s
      });
    }, e.getSymbolSize = function(t, i) {
      return cd(t.getItemVisual(i, "symbolSize"));
    }, e;
  }(Re)
);
function Sde(r, e) {
  this.parent.drift(r, e);
}
const Dv = bde;
function K0(r, e, t, i) {
  return e && !isNaN(e[0]) && !isNaN(e[1]) && !(i.isIgnore && i.isIgnore(t)) && !(i.clipShape && !i.clipShape.contain(e[0], e[1])) && r.getItemVisual(t, "symbol") !== "none";
}
function gQ(r) {
  return r != null && !be(r) && (r = {
    isIgnore: r
  }), r || {};
}
function vQ(r) {
  var e = r.hostModel, t = e.getModel("emphasis");
  return {
    emphasisItemStyle: t.getModel("itemStyle").getItemStyle(),
    blurItemStyle: e.getModel(["blur", "itemStyle"]).getItemStyle(),
    selectItemStyle: e.getModel(["select", "itemStyle"]).getItemStyle(),
    focus: t.get("focus"),
    blurScope: t.get("blurScope"),
    emphasisDisabled: t.get("disabled"),
    hoverScale: t.get("scale"),
    labelStatesModels: kr(e),
    cursorStyle: e.get("cursor")
  };
}
var Tde = (
  /** @class */
  function() {
    function r(e) {
      this.group = new Re(), this._SymbolCtor = e || Dv;
    }
    return r.prototype.updateData = function(e, t) {
      this._progressiveEls = null, t = gQ(t);
      var i = this.group, n = e.hostModel, a = this._data, o = this._SymbolCtor, s = t.disableAnimation, l = vQ(e), u = {
        disableAnimation: s
      }, c = t.getSymbolPoint || function(h) {
        return e.getItemLayout(h);
      };
      a || i.removeAll(), e.diff(a).add(function(h) {
        var f = c(h);
        if (K0(e, f, h, t)) {
          var d = new o(e, h, l, u);
          d.setPosition(f), e.setItemGraphicEl(h, d), i.add(d);
        }
      }).update(function(h, f) {
        var d = a.getItemGraphicEl(f), p = c(h);
        if (!K0(e, p, h, t)) {
          i.remove(d);
          return;
        }
        var g = e.getItemVisual(h, "symbol") || "circle", v = d && d.getSymbolType && d.getSymbolType();
        if (!d || v && v !== g)
          i.remove(d), d = new o(e, h, l, u), d.setPosition(p);
        else {
          d.updateData(e, h, l, u);
          var O = {
            x: p[0],
            y: p[1]
          };
          s ? d.attr(O) : Ot(d, O, n);
        }
        i.add(d), e.setItemGraphicEl(h, d);
      }).remove(function(h) {
        var f = a.getItemGraphicEl(h);
        f && f.fadeOut(function() {
          i.remove(f);
        }, n);
      }).execute(), this._getSymbolPoint = c, this._data = e;
    }, r.prototype.updateLayout = function() {
      var e = this, t = this._data;
      t && t.eachItemGraphicEl(function(i, n) {
        var a = e._getSymbolPoint(n);
        i.setPosition(a), i.markRedraw();
      });
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = vQ(e), this._data = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t, i) {
      this._progressiveEls = [], i = gQ(i);
      function n(l) {
        l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0);
      }
      for (var a = e.start; a < e.end; a++) {
        var o = t.getItemLayout(a);
        if (K0(t, o, a, i)) {
          var s = new this._SymbolCtor(t, a, this._seriesScope);
          s.traverse(n), s.setPosition(o), this.group.add(s), t.setItemGraphicEl(a, s), this._progressiveEls.push(s);
        }
      }
    }, r.prototype.eachRendered = function(e) {
      zl(this._progressiveEls || this.group, e);
    }, r.prototype.remove = function(e) {
      var t = this.group, i = this._data;
      i && e ? i.eachItemGraphicEl(function(n) {
        n.fadeOut(function() {
          t.remove(n);
        }, i.hostModel);
      }) : t.removeAll();
    }, r;
  }()
);
const Mv = Tde;
function y3(r, e, t) {
  var i = r.getBaseAxis(), n = r.getOtherAxis(i), a = yde(n, t), o = i.dim, s = n.dim, l = e.mapDimension(s), u = e.mapDimension(o), c = s === "x" || s === "radius" ? 1 : 0, h = Y(r.dimensions, function(p) {
    return e.mapDimension(p);
  }), f = !1, d = e.getCalculationInfo("stackResultDimension");
  return Ll(
    e,
    h[0]
    /* , dims[1] */
  ) && (f = !0, h[0] = d), Ll(
    e,
    h[1]
    /* , dims[0] */
  ) && (f = !0, h[1] = d), {
    dataDimsForPoint: h,
    valueStart: a,
    valueAxisDim: s,
    baseAxisDim: o,
    stacked: !!f,
    valueDim: l,
    baseDim: u,
    baseDataOffset: c,
    stackedOverDimension: e.getCalculationInfo("stackedOverDimension")
  };
}
function yde(r, e) {
  var t = 0, i = r.scale.getExtent();
  return e === "start" ? t = i[0] : e === "end" ? t = i[1] : pt(e) && !isNaN(e) ? t = e : i[0] > 0 ? t = i[0] : i[1] < 0 && (t = i[1]), t;
}
function R3(r, e, t, i) {
  var n = NaN;
  r.stacked && (n = t.get(t.getCalculationInfo("stackedOverDimension"), i)), isNaN(n) && (n = r.valueStart);
  var a = r.baseDataOffset, o = [];
  return o[a] = t.get(r.baseDim, i), o[1 - a] = n, e.dataToPoint(o);
}
function Rde(r, e) {
  var t = [];
  return e.diff(r).add(function(i) {
    t.push({
      cmd: "+",
      idx: i
    });
  }).update(function(i, n) {
    t.push({
      cmd: "=",
      idx: n,
      idx1: i
    });
  }).remove(function(i) {
    t.push({
      cmd: "-",
      idx: i
    });
  }).execute(), t;
}
function Ade(r, e, t, i, n, a, o, s) {
  for (var l = Rde(r, e), u = [], c = [], h = [], f = [], d = [], p = [], g = [], v = y3(n, e, o), O = r.getLayout("points") || [], m = e.getLayout("points") || [], E = 0; E < l.length; E++) {
    var b = l[E], S = !0, T = void 0, y = void 0;
    switch (b.cmd) {
      case "=":
        T = b.idx * 2, y = b.idx1 * 2;
        var R = O[T], _ = O[T + 1], C = m[y], I = m[y + 1];
        (isNaN(R) || isNaN(_)) && (R = C, _ = I), u.push(R, _), c.push(C, I), h.push(t[T], t[T + 1]), f.push(i[y], i[y + 1]), g.push(e.getRawIndex(b.idx1));
        break;
      case "+":
        var w = b.idx, x = v.dataDimsForPoint, P = n.dataToPoint([e.get(x[0], w), e.get(x[1], w)]);
        y = w * 2, u.push(P[0], P[1]), c.push(m[y], m[y + 1]);
        var L = R3(v, n, e, w);
        h.push(L[0], L[1]), f.push(i[y], i[y + 1]), g.push(e.getRawIndex(w));
        break;
      case "-":
        S = !1;
    }
    S && (d.push(b), p.push(p.length));
  }
  p.sort(function(Be, We) {
    return g[Be] - g[We];
  });
  for (var D = u.length, U = lo(D), Q = lo(D), V = lo(D), F = lo(D), j = [], E = 0; E < p.length; E++) {
    var ae = p[E], ce = E * 2, ge = ae * 2;
    U[ce] = u[ge], U[ce + 1] = u[ge + 1], Q[ce] = c[ge], Q[ce + 1] = c[ge + 1], V[ce] = h[ge], V[ce + 1] = h[ge + 1], F[ce] = f[ge], F[ce + 1] = f[ge + 1], j[E] = d[ae];
  }
  return {
    current: U,
    next: Q,
    stackedOnCurrent: V,
    stackedOnNext: F,
    status: j
  };
}
var Ms = Math.min, ks = Math.max;
function Oc(r, e) {
  return isNaN(r) || isNaN(e);
}
function NC(r, e, t, i, n, a, o, s, l) {
  for (var u, c, h, f, d, p, g = t, v = 0; v < i; v++) {
    var O = e[g * 2], m = e[g * 2 + 1];
    if (g >= n || g < 0)
      break;
    if (Oc(O, m)) {
      if (l) {
        g += a;
        continue;
      }
      break;
    }
    if (g === t)
      r[a > 0 ? "moveTo" : "lineTo"](O, m), h = O, f = m;
    else {
      var E = O - u, b = m - c;
      if (E * E + b * b < 0.5) {
        g += a;
        continue;
      }
      if (o > 0) {
        for (var S = g + a, T = e[S * 2], y = e[S * 2 + 1]; T === O && y === m && v < i; )
          v++, S += a, g += a, T = e[S * 2], y = e[S * 2 + 1], O = e[g * 2], m = e[g * 2 + 1], E = O - u, b = m - c;
        var R = v + 1;
        if (l)
          for (; Oc(T, y) && R < i; )
            R++, S += a, T = e[S * 2], y = e[S * 2 + 1];
        var _ = 0.5, C = 0, I = 0, w = void 0, x = void 0;
        if (R >= i || Oc(T, y))
          d = O, p = m;
        else {
          C = T - u, I = y - c;
          var P = O - u, L = T - O, D = m - c, U = y - m, Q = void 0, V = void 0;
          if (s === "x") {
            Q = Math.abs(P), V = Math.abs(L);
            var F = C > 0 ? 1 : -1;
            d = O - F * Q * o, p = m, w = O + F * V * o, x = m;
          } else if (s === "y") {
            Q = Math.abs(D), V = Math.abs(U);
            var j = I > 0 ? 1 : -1;
            d = O, p = m - j * Q * o, w = O, x = m + j * V * o;
          } else
            Q = Math.sqrt(P * P + D * D), V = Math.sqrt(L * L + U * U), _ = V / (V + Q), d = O - C * o * (1 - _), p = m - I * o * (1 - _), w = O + C * o * _, x = m + I * o * _, w = Ms(w, ks(T, O)), x = Ms(x, ks(y, m)), w = ks(w, Ms(T, O)), x = ks(x, Ms(y, m)), C = w - O, I = x - m, d = O - C * Q / V, p = m - I * Q / V, d = Ms(d, ks(u, O)), p = Ms(p, ks(c, m)), d = ks(d, Ms(u, O)), p = ks(p, Ms(c, m)), C = O - d, I = m - p, w = O + C * V / Q, x = m + I * V / Q;
        }
        r.bezierCurveTo(h, f, d, p, O, m), h = w, f = x;
      } else
        r.lineTo(O, m);
    }
    u = O, c = m, g += a;
  }
  return v;
}
var A3 = (
  /** @class */
  function() {
    function r() {
      this.smooth = 0, this.smoothConstraint = !0;
    }
    return r;
  }()
), _de = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "ec-polyline", i;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new A3();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = 0, o = n.length / 2;
      if (i.connectNulls) {
        for (; o > 0 && Oc(n[o * 2 - 2], n[o * 2 - 1]); o--)
          ;
        for (; a < o && Oc(n[a * 2], n[a * 2 + 1]); a++)
          ;
      }
      for (; a < o; )
        a += NC(t, n, a, o, o, 1, i.smooth, i.smoothMonotone, i.connectNulls) + 1;
    }, e.prototype.getPointOn = function(t, i) {
      this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape));
      for (var n = this.path, a = n.data, o = _o.CMD, s, l, u = i === "x", c = [], h = 0; h < a.length; ) {
        var f = a[h++], d = void 0, p = void 0, g = void 0, v = void 0, O = void 0, m = void 0, E = void 0;
        switch (f) {
          case o.M:
            s = a[h++], l = a[h++];
            break;
          case o.L:
            if (d = a[h++], p = a[h++], E = u ? (t - s) / (d - s) : (t - l) / (p - l), E <= 1 && E >= 0) {
              var b = u ? (p - l) * E + l : (d - s) * E + s;
              return u ? [t, b] : [b, t];
            }
            s = d, l = p;
            break;
          case o.C:
            d = a[h++], p = a[h++], g = a[h++], v = a[h++], O = a[h++], m = a[h++];
            var S = u ? KE(s, d, g, O, t, c) : KE(l, p, v, m, t, c);
            if (S > 0)
              for (var T = 0; T < S; T++) {
                var y = c[T];
                if (y <= 1 && y >= 0) {
                  var b = u ? wr(l, p, v, m, y) : wr(s, d, g, O, y);
                  return u ? [t, b] : [b, t];
                }
              }
            s = O, l = m;
            break;
        }
      }
    }, e;
  }(He)
), Cde = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e;
  }(A3)
), _3 = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "ec-polygon", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new Cde();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = i.stackedOnPoints, o = 0, s = n.length / 2, l = i.smoothMonotone;
      if (i.connectNulls) {
        for (; s > 0 && Oc(n[s * 2 - 2], n[s * 2 - 1]); s--)
          ;
        for (; o < s && Oc(n[o * 2], n[o * 2 + 1]); o++)
          ;
      }
      for (; o < s; ) {
        var u = NC(t, n, o, s, s, 1, i.smooth, l, i.connectNulls);
        NC(t, a, o + u - 1, u, s, -1, i.stackedOnSmooth, l, i.connectNulls), o += u + 1, t.closePath();
      }
    }, e;
  }(He)
);
function C3(r, e, t, i, n) {
  var a = r.getArea(), o = a.x, s = a.y, l = a.width, u = a.height, c = t.get(["lineStyle", "width"]) || 2;
  o -= c / 2, s -= c / 2, l += c, u += c, o = Math.floor(o), l = Math.round(l);
  var h = new ht({
    shape: {
      x: o,
      y: s,
      width: l,
      height: u
    }
  });
  if (e) {
    var f = r.getBaseAxis(), d = f.isHorizontal(), p = f.inverse;
    d ? (p && (h.shape.x += l), h.shape.width = 0) : (p || (h.shape.y += u), h.shape.height = 0);
    var g = ve(n) ? function(v) {
      n(v, h);
    } : null;
    Bt(h, {
      shape: {
        width: l,
        height: u,
        x: o,
        y: s
      }
    }, t, null, i, g);
  }
  return h;
}
function I3(r, e, t) {
  var i = r.getArea(), n = rr(i.r0, 1), a = rr(i.r, 1), o = new tn({
    shape: {
      cx: rr(r.cx, 1),
      cy: rr(r.cy, 1),
      r0: n,
      r: a,
      startAngle: i.startAngle,
      endAngle: i.endAngle,
      clockwise: i.clockwise
    }
  });
  if (e) {
    var s = r.getBaseAxis().dim === "angle";
    s ? o.shape.endAngle = i.startAngle : o.shape.r = n, Bt(o, {
      shape: {
        endAngle: i.endAngle,
        r: a
      }
    }, t);
  }
  return o;
}
function UT(r, e, t, i, n) {
  if (r) {
    if (r.type === "polar")
      return I3(r, e, t);
    if (r.type === "cartesian2d")
      return C3(r, e, t, i, n);
  } else
    return null;
  return null;
}
function Kc(r, e) {
  return r.type === e;
}
function OQ(r, e) {
  if (r.length === e.length) {
    for (var t = 0; t < r.length; t++)
      if (r[t] !== e[t])
        return;
    return !0;
  }
}
function mQ(r) {
  for (var e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0, a = 0; a < r.length; ) {
    var o = r[a++], s = r[a++];
    isNaN(o) || (e = Math.min(o, e), i = Math.max(o, i)), isNaN(s) || (t = Math.min(s, t), n = Math.max(s, n));
  }
  return [[e, t], [i, n]];
}
function EQ(r, e) {
  var t = mQ(r), i = t[0], n = t[1], a = mQ(e), o = a[0], s = a[1];
  return Math.max(Math.abs(i[0] - o[0]), Math.abs(i[1] - o[1]), Math.abs(n[0] - s[0]), Math.abs(n[1] - s[1]));
}
function bQ(r) {
  return pt(r) ? r : r ? 0.5 : 0;
}
function Ide(r, e, t) {
  if (!t.valueDim)
    return [];
  for (var i = e.count(), n = lo(i * 2), a = 0; a < i; a++) {
    var o = R3(t, r, e, a);
    n[a * 2] = o[0], n[a * 2 + 1] = o[1];
  }
  return n;
}
function Qs(r, e, t, i) {
  var n = e.getBaseAxis(), a = n.dim === "x" || n.dim === "radius" ? 0 : 1, o = [], s = 0, l = [], u = [], c = [], h = [];
  if (i) {
    for (s = 0; s < r.length; s += 2)
      !isNaN(r[s]) && !isNaN(r[s + 1]) && h.push(r[s], r[s + 1]);
    r = h;
  }
  for (s = 0; s < r.length - 2; s += 2)
    switch (c[0] = r[s + 2], c[1] = r[s + 3], u[0] = r[s], u[1] = r[s + 1], o.push(u[0], u[1]), t) {
      case "end":
        l[a] = c[a], l[1 - a] = u[1 - a], o.push(l[0], l[1]);
        break;
      case "middle":
        var f = (u[a] + c[a]) / 2, d = [];
        l[a] = d[a] = f, l[1 - a] = u[1 - a], d[1 - a] = c[1 - a], o.push(l[0], l[1]), o.push(d[0], d[1]);
        break;
      default:
        l[a] = u[a], l[1 - a] = c[1 - a], o.push(l[0], l[1]);
    }
  return o.push(r[s++], r[s++]), o;
}
function wde(r, e) {
  var t = [], i = r.length, n, a;
  function o(c, h, f) {
    var d = c.coord, p = (f - d) / (h.coord - d), g = Vne(p, [c.color, h.color]);
    return {
      coord: f,
      color: g
    };
  }
  for (var s = 0; s < i; s++) {
    var l = r[s], u = l.coord;
    if (u < 0)
      n = l;
    else if (u > e) {
      a ? t.push(o(a, l, e)) : n && t.push(o(n, l, 0), o(n, l, e));
      break;
    } else
      n && (t.push(o(n, l, 0)), n = null), t.push(l), a = l;
  }
  return t;
}
function Nde(r, e, t) {
  var i = r.getVisual("visualMeta");
  if (!(!i || !i.length || !r.count())) {
    if (e.type !== "cartesian2d") {
      ({}).NODE_ENV !== "production" && console.warn("Visual map on line style is only supported on cartesian2d.");
      return;
    }
    for (var n, a, o = i.length - 1; o >= 0; o--) {
      var s = r.getDimensionInfo(i[o].dimension);
      if (n = s && s.coordDim, n === "x" || n === "y") {
        a = i[o];
        break;
      }
    }
    if (!a) {
      ({}).NODE_ENV !== "production" && console.warn("Visual map on line style only support x or y dimension.");
      return;
    }
    var l = e.getAxis(n), u = Y(a.stops, function(E) {
      return {
        coord: l.toGlobalCoord(l.dataToCoord(E.value)),
        color: E.color
      };
    }), c = u.length, h = a.outerColors.slice();
    c && u[0].coord > u[c - 1].coord && (u.reverse(), h.reverse());
    var f = wde(u, n === "x" ? t.getWidth() : t.getHeight()), d = f.length;
    if (!d && c)
      return u[0].coord < 0 ? h[1] ? h[1] : u[c - 1].color : h[0] ? h[0] : u[0].color;
    var p = 10, g = f[0].coord - p, v = f[d - 1].coord + p, O = v - g;
    if (O < 1e-3)
      return "transparent";
    N(f, function(E) {
      E.offset = (E.coord - g) / O;
    }), f.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: d ? f[d - 1].offset : 0.5,
      color: h[1] || "transparent"
    }), f.unshift({
      offset: d ? f[0].offset : 0.5,
      color: h[0] || "transparent"
    });
    var m = new _v(0, 0, 0, 0, f, !0);
    return m[n] = g, m[n + "2"] = v, m;
  }
}
function xde(r, e, t) {
  var i = r.get("showAllSymbol"), n = i === "auto";
  if (!(i && !n)) {
    var a = t.getAxesByScale("ordinal")[0];
    if (a && !(n && Pde(a, e))) {
      var o = e.mapDimension(a.dim), s = {};
      return N(a.getViewLabels(), function(l) {
        var u = a.scale.getRawOrdinalNumber(l.tickValue);
        s[u] = 1;
      }), function(l) {
        return !s.hasOwnProperty(e.get(o, l));
      };
    }
  }
}
function Pde(r, e) {
  var t = r.getExtent(), i = Math.abs(t[1] - t[0]) / r.scale.count();
  isNaN(i) && (i = 0);
  for (var n = e.count(), a = Math.max(1, Math.round(n / 5)), o = 0; o < n; o += a)
    if (Dv.getSymbolSize(
      e,
      o
      // Only for cartesian, where `isHorizontal` exists.
    )[r.isHorizontal() ? 1 : 0] * 1.5 > i)
      return !1;
  return !0;
}
function Lde(r, e) {
  return isNaN(r) || isNaN(e);
}
function Dde(r) {
  for (var e = r.length / 2; e > 0 && Lde(r[e * 2 - 2], r[e * 2 - 1]); e--)
    ;
  return e - 1;
}
function SQ(r, e) {
  return [r[e * 2], r[e * 2 + 1]];
}
function Mde(r, e, t) {
  for (var i = r.length / 2, n = t === "x" ? 0 : 1, a, o, s = 0, l = -1, u = 0; u < i; u++)
    if (o = r[u * 2 + n], !(isNaN(o) || isNaN(r[u * 2 + 1 - n]))) {
      if (u === 0) {
        a = o;
        continue;
      }
      if (a <= e && o >= e || a >= e && o <= e) {
        l = u;
        break;
      }
      s = u, a = o;
    }
  return {
    range: [s, l],
    t: (e - a) / (o - a)
  };
}
function w3(r) {
  if (r.get(["endLabel", "show"]))
    return !0;
  for (var e = 0; e < $i.length; e++)
    if (r.get([$i[e], "endLabel", "show"]))
      return !0;
  return !1;
}
function J0(r, e, t, i) {
  if (Kc(e, "cartesian2d")) {
    var n = i.getModel("endLabel"), a = n.get("valueAnimation"), o = i.getData(), s = {
      lastFrameIndex: 0
    }, l = w3(i) ? function(d, p) {
      r._endLabelOnDuring(d, p, o, s, a, n, e);
    } : null, u = e.getBaseAxis().isHorizontal(), c = C3(e, t, i, function() {
      var d = r._endLabel;
      d && t && s.originalX != null && d.attr({
        x: s.originalX,
        y: s.originalY
      });
    }, l);
    if (!i.get("clip", !0)) {
      var h = c.shape, f = Math.max(h.width, h.height);
      u ? (h.y -= f, h.height += f * 2) : (h.x -= f, h.width += f * 2);
    }
    return l && l(1, c), c;
  } else
    return {}.NODE_ENV !== "production" && i.get(["endLabel", "show"]) && console.warn("endLabel is not supported for lines in polar systems."), I3(e, t, i);
}
function kde(r, e) {
  var t = e.getBaseAxis(), i = t.isHorizontal(), n = t.inverse, a = i ? n ? "right" : "left" : "center", o = i ? "middle" : n ? "top" : "bottom";
  return {
    normal: {
      align: r.get("align") || a,
      verticalAlign: r.get("verticalAlign") || o
    }
  };
}
var Qde = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function() {
      var t = new Re(), i = new Mv();
      this.group.add(i.group), this._symbolDraw = i, this._lineGroup = t;
    }, e.prototype.render = function(t, i, n) {
      var a = this, o = t.coordinateSystem, s = this.group, l = t.getData(), u = t.getModel("lineStyle"), c = t.getModel("areaStyle"), h = l.getLayout("points") || [], f = o.type === "polar", d = this._coordSys, p = this._symbolDraw, g = this._polyline, v = this._polygon, O = this._lineGroup, m = !i.ssr && t.isAnimationEnabled(), E = !c.isEmpty(), b = c.get("origin"), S = y3(o, l, b), T = E && Ide(o, l, S), y = t.get("showSymbol"), R = t.get("connectNulls"), _ = y && !f && xde(t, l, o), C = this._data;
      C && C.eachItemGraphicEl(function(We, Ne) {
        We.__temp && (s.remove(We), C.setItemGraphicEl(Ne, null));
      }), y || p.remove(), s.add(O);
      var I = f ? !1 : t.get("step"), w;
      o && o.getArea && t.get("clip", !0) && (w = o.getArea(), w.width != null ? (w.x -= 0.1, w.y -= 0.1, w.width += 0.2, w.height += 0.2) : w.r0 && (w.r0 -= 0.5, w.r += 0.5)), this._clipShapeForSymbol = w;
      var x = Nde(l, o, n) || l.getVisual("style")[l.getVisual("drawType")];
      if (!(g && d.type === o.type && I === this._step))
        y && p.updateData(l, {
          isIgnore: _,
          clipShape: w,
          disableAnimation: !0,
          getSymbolPoint: function(We) {
            return [h[We * 2], h[We * 2 + 1]];
          }
        }), m && this._initSymbolLabelAnimation(l, o, w), I && (h = Qs(h, o, I, R), T && (T = Qs(T, o, I, R))), g = this._newPolyline(h), E ? v = this._newPolygon(h, T) : v && (O.remove(v), v = this._polygon = null), f || this._initOrUpdateEndLabel(t, o, Pc(x)), O.setClipPath(J0(this, o, !0, t));
      else {
        E && !v ? v = this._newPolygon(h, T) : v && !E && (O.remove(v), v = this._polygon = null), f || this._initOrUpdateEndLabel(t, o, Pc(x));
        var P = O.getClipPath();
        if (P) {
          var L = J0(this, o, !1, t);
          Bt(P, {
            shape: L.shape
          }, t);
        } else
          O.setClipPath(J0(this, o, !0, t));
        y && p.updateData(l, {
          isIgnore: _,
          clipShape: w,
          disableAnimation: !0,
          getSymbolPoint: function(We) {
            return [h[We * 2], h[We * 2 + 1]];
          }
        }), (!OQ(this._stackedOnPoints, T) || !OQ(this._points, h)) && (m ? this._doUpdateAnimation(l, T, o, n, I, b, R) : (I && (h = Qs(h, o, I, R), T && (T = Qs(T, o, I, R))), g.setShape({
          points: h
        }), v && v.setShape({
          points: h,
          stackedOnPoints: T
        })));
      }
      var D = t.getModel("emphasis"), U = D.get("focus"), Q = D.get("blurScope"), V = D.get("disabled");
      if (g.useStyle(Te(
        // Use color in lineStyle first
        u.getLineStyle(),
        {
          fill: "none",
          stroke: x,
          lineJoin: "bevel"
        }
      )), ri(g, t, "lineStyle"), g.style.lineWidth > 0 && t.get(["emphasis", "lineStyle", "width"]) === "bolder") {
        var F = g.getState("emphasis").style;
        F.lineWidth = +g.style.lineWidth + 1;
      }
      Pe(g).seriesIndex = t.seriesIndex, qt(g, U, Q, V);
      var j = bQ(t.get("smooth")), ae = t.get("smoothMonotone");
      if (g.setShape({
        smooth: j,
        smoothMonotone: ae,
        connectNulls: R
      }), v) {
        var ce = l.getCalculationInfo("stackedOnSeries"), ge = 0;
        v.useStyle(Te(c.getAreaStyle(), {
          fill: x,
          opacity: 0.7,
          lineJoin: "bevel",
          decal: l.getVisual("style").decal
        })), ce && (ge = bQ(ce.get("smooth"))), v.setShape({
          smooth: j,
          stackedOnSmooth: ge,
          smoothMonotone: ae,
          connectNulls: R
        }), ri(v, t, "areaStyle"), Pe(v).seriesIndex = t.seriesIndex, qt(v, U, Q, V);
      }
      var Be = function(We) {
        a._changePolyState(We);
      };
      l.eachItemGraphicEl(function(We) {
        We && (We.onHoverStateChange = Be);
      }), this._polyline.onHoverStateChange = Be, this._data = l, this._coordSys = o, this._stackedOnPoints = T, this._points = h, this._step = I, this._valueOrigin = b, t.get("triggerLineEvent") && (this.packEventData(t, g), v && this.packEventData(t, v));
    }, e.prototype.packEventData = function(t, i) {
      Pe(i).eventData = {
        componentType: "series",
        componentSubType: "line",
        componentIndex: t.componentIndex,
        seriesIndex: t.seriesIndex,
        seriesName: t.name,
        seriesType: "line"
      };
    }, e.prototype.highlight = function(t, i, n, a) {
      var o = t.getData(), s = wc(o, a);
      if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) {
        var l = o.getLayout("points"), u = o.getItemGraphicEl(s);
        if (!u) {
          var c = l[s * 2], h = l[s * 2 + 1];
          if (isNaN(c) || isNaN(h) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(c, h))
            return;
          var f = t.get("zlevel") || 0, d = t.get("z") || 0;
          u = new Dv(o, s), u.x = c, u.y = h, u.setZ(f, d);
          var p = u.getSymbolPath().getTextContent();
          p && (p.zlevel = f, p.z = d, p.z2 = this._polyline.z2 + 1), u.__temp = !0, o.setItemGraphicEl(s, u), u.stopSymbolAnimation(!0), this.group.add(u);
        }
        u.highlight();
      } else
        $t.prototype.highlight.call(this, t, i, n, a);
    }, e.prototype.downplay = function(t, i, n, a) {
      var o = t.getData(), s = wc(o, a);
      if (this._changePolyState("normal"), s != null && s >= 0) {
        var l = o.getItemGraphicEl(s);
        l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay());
      } else
        $t.prototype.downplay.call(this, t, i, n, a);
    }, e.prototype._changePolyState = function(t) {
      var i = this._polygon;
      ob(this._polyline, t), i && ob(i, t);
    }, e.prototype._newPolyline = function(t) {
      var i = this._polyline;
      return i && this._lineGroup.remove(i), i = new _de({
        shape: {
          points: t
        },
        segmentIgnoreThreshold: 2,
        z2: 10
      }), this._lineGroup.add(i), this._polyline = i, i;
    }, e.prototype._newPolygon = function(t, i) {
      var n = this._polygon;
      return n && this._lineGroup.remove(n), n = new _3({
        shape: {
          points: t,
          stackedOnPoints: i
        },
        segmentIgnoreThreshold: 2
      }), this._lineGroup.add(n), this._polygon = n, n;
    }, e.prototype._initSymbolLabelAnimation = function(t, i, n) {
      var a, o, s = i.getBaseAxis(), l = s.inverse;
      i.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : i.type === "polar" && (a = s.dim === "angle", o = !0);
      var u = t.hostModel, c = u.get("animationDuration");
      ve(c) && (c = c(null));
      var h = u.get("animationDelay") || 0, f = ve(h) ? h(null) : h;
      t.eachItemGraphicEl(function(d, p) {
        var g = d;
        if (g) {
          var v = [d.x, d.y], O = void 0, m = void 0, E = void 0;
          if (n)
            if (o) {
              var b = n, S = i.pointToCoord(v);
              a ? (O = b.startAngle, m = b.endAngle, E = -S[1] / 180 * Math.PI) : (O = b.r0, m = b.r, E = S[0]);
            } else {
              var T = n;
              a ? (O = T.x, m = T.x + T.width, E = d.x) : (O = T.y + T.height, m = T.y, E = d.y);
            }
          var y = m === O ? 0 : (E - O) / (m - O);
          l && (y = 1 - y);
          var R = ve(h) ? h(p) : c * y + f, _ = g.getSymbolPath(), C = _.getTextContent();
          g.attr({
            scaleX: 0,
            scaleY: 0
          }), g.animateTo({
            scaleX: 1,
            scaleY: 1
          }, {
            duration: 200,
            setToFinal: !0,
            delay: R
          }), C && C.animateFrom({
            style: {
              opacity: 0
            }
          }, {
            duration: 300,
            delay: R
          }), _.disableLabelAnimation = !0;
        }
      });
    }, e.prototype._initOrUpdateEndLabel = function(t, i, n) {
      var a = t.getModel("endLabel");
      if (w3(t)) {
        var o = t.getData(), s = this._polyline, l = o.getLayout("points");
        if (!l) {
          s.removeTextContent(), this._endLabel = null;
          return;
        }
        var u = this._endLabel;
        u || (u = this._endLabel = new dt({
          z2: 200
          // should be higher than item symbol
        }), u.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0);
        var c = Dde(l);
        c >= 0 && (ii(s, kr(t, "endLabel"), {
          inheritColor: n,
          labelFetcher: t,
          labelDataIndex: c,
          defaultText: function(h, f, d) {
            return d != null ? T3(o, d) : Lf(o, h);
          },
          enableTextSetter: !0
        }, kde(a, i)), s.textConfig.position = null);
      } else
        this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null);
    }, e.prototype._endLabelOnDuring = function(t, i, n, a, o, s, l) {
      var u = this._endLabel, c = this._polyline;
      if (u) {
        t < 1 && a.originalX == null && (a.originalX = u.x, a.originalY = u.y);
        var h = n.getLayout("points"), f = n.hostModel, d = f.get("connectNulls"), p = s.get("precision"), g = s.get("distance") || 0, v = l.getBaseAxis(), O = v.isHorizontal(), m = v.inverse, E = i.shape, b = m ? O ? E.x : E.y + E.height : O ? E.x + E.width : E.y, S = (O ? g : 0) * (m ? -1 : 1), T = (O ? 0 : -g) * (m ? -1 : 1), y = O ? "x" : "y", R = Mde(h, b, y), _ = R.range, C = _[1] - _[0], I = void 0;
        if (C >= 1) {
          if (C > 1 && !d) {
            var w = SQ(h, _[0]);
            u.attr({
              x: w[0] + S,
              y: w[1] + T
            }), o && (I = f.getRawValue(_[0]));
          } else {
            var w = c.getPointOn(b, y);
            w && u.attr({
              x: w[0] + S,
              y: w[1] + T
            });
            var x = f.getRawValue(_[0]), P = f.getRawValue(_[1]);
            o && (I = KY(n, p, x, P, R.t));
          }
          a.lastFrameIndex = _[0];
        } else {
          var L = t === 1 || a.lastFrameIndex > 0 ? _[0] : 0, w = SQ(h, L);
          o && (I = f.getRawValue(L)), u.attr({
            x: w[0] + S,
            y: w[1] + T
          });
        }
        if (o) {
          var D = td(u);
          typeof D.setLabelText == "function" && D.setLabelText(I);
        }
      }
    }, e.prototype._doUpdateAnimation = function(t, i, n, a, o, s, l) {
      var u = this._polyline, c = this._polygon, h = t.hostModel, f = Ade(this._data, t, this._stackedOnPoints, i, this._coordSys, n, this._valueOrigin), d = f.current, p = f.stackedOnCurrent, g = f.next, v = f.stackedOnNext;
      if (o && (d = Qs(f.current, n, o, l), p = Qs(f.stackedOnCurrent, n, o, l), g = Qs(f.next, n, o, l), v = Qs(f.stackedOnNext, n, o, l)), EQ(d, g) > 3e3 || c && EQ(p, v) > 3e3) {
        u.stopAnimation(), u.setShape({
          points: g
        }), c && (c.stopAnimation(), c.setShape({
          points: g,
          stackedOnPoints: v
        }));
        return;
      }
      u.shape.__points = f.current, u.shape.points = d;
      var O = {
        shape: {
          points: g
        }
      };
      f.current !== d && (O.shape.__points = f.next), u.stopAnimation(), Ot(u, O, h), c && (c.setShape({
        // Reuse the points with polyline.
        points: d,
        stackedOnPoints: p
      }), c.stopAnimation(), Ot(c, {
        shape: {
          stackedOnPoints: v
        }
      }, h), u.shape.points !== c.shape.points && (c.shape.points = u.shape.points));
      for (var m = [], E = f.status, b = 0; b < E.length; b++) {
        var S = E[b].cmd;
        if (S === "=") {
          var T = t.getItemGraphicEl(E[b].idx1);
          T && m.push({
            el: T,
            ptIdx: b
            // Index of points
          });
        }
      }
      u.animators && u.animators.length && u.animators[0].during(function() {
        c && c.dirtyShape();
        for (var y = u.shape.__points, R = 0; R < m.length; R++) {
          var _ = m[R].el, C = m[R].ptIdx * 2;
          _.x = y[C], _.y = y[C + 1], _.markRedraw();
        }
      });
    }, e.prototype.remove = function(t) {
      var i = this.group, n = this._data;
      this._lineGroup.removeAll(), this._symbolDraw.remove(!0), n && n.eachItemGraphicEl(function(a, o) {
        a.__temp && (i.remove(a), n.setItemGraphicEl(o, null));
      }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null;
    }, e.type = "line", e;
  }($t)
);
const Ude = Qde;
function kv(r, e) {
  return {
    seriesType: r,
    plan: ld(),
    reset: function(t) {
      var i = t.getData(), n = t.coordinateSystem, a = t.pipelineContext, o = e || a.large;
      if (n) {
        var s = Y(n.dimensions, function(d) {
          return i.mapDimension(d);
        }).slice(0, 2), l = s.length, u = i.getCalculationInfo("stackResultDimension");
        Ll(i, s[0]) && (s[0] = u), Ll(i, s[1]) && (s[1] = u);
        var c = i.getStore(), h = i.getDimensionIndex(s[0]), f = i.getDimensionIndex(s[1]);
        return l && {
          progress: function(d, p) {
            for (var g = d.end - d.start, v = o && lo(g * l), O = [], m = [], E = d.start, b = 0; E < d.end; E++) {
              var S = void 0;
              if (l === 1) {
                var T = c.get(h, E);
                S = n.dataToPoint(T, null, m);
              } else
                O[0] = c.get(h, E), O[1] = c.get(f, E), S = n.dataToPoint(O, null, m);
              o ? (v[b++] = S[0], v[b++] = S[1]) : p.setItemLayout(E, S.slice());
            }
            o && p.setLayout("points", v);
          }
        };
      }
    }
  };
}
var $de = {
  average: function(r) {
    for (var e = 0, t = 0, i = 0; i < r.length; i++)
      isNaN(r[i]) || (e += r[i], t++);
    return t === 0 ? NaN : e / t;
  },
  sum: function(r) {
    for (var e = 0, t = 0; t < r.length; t++)
      e += r[t] || 0;
    return e;
  },
  max: function(r) {
    for (var e = -1 / 0, t = 0; t < r.length; t++)
      r[t] > e && (e = r[t]);
    return isFinite(e) ? e : NaN;
  },
  min: function(r) {
    for (var e = 1 / 0, t = 0; t < r.length; t++)
      r[t] < e && (e = r[t]);
    return isFinite(e) ? e : NaN;
  },
  // TODO
  // Median
  nearest: function(r) {
    return r[0];
  }
}, Vde = function(r) {
  return Math.round(r.length / 2);
};
function N3(r) {
  return {
    seriesType: r,
    // FIXME:TS never used, so comment it
    // modifyOutputEnd: true,
    reset: function(e, t, i) {
      var n = e.getData(), a = e.get("sampling"), o = e.coordinateSystem, s = n.count();
      if (s > 10 && o.type === "cartesian2d" && a) {
        var l = o.getBaseAxis(), u = o.getOtherAxis(l), c = l.getExtent(), h = i.getDevicePixelRatio(), f = Math.abs(c[1] - c[0]) * (h || 1), d = Math.round(s / f);
        if (isFinite(d) && d > 1) {
          a === "lttb" && e.setData(n.lttbDownSample(n.mapDimension(u.dim), 1 / d));
          var p = void 0;
          ne(a) ? p = $de[a] : ve(a) && (p = a), p && e.setData(n.downSample(n.mapDimension(u.dim), 1 / d, p, Vde));
        }
      }
    }
  };
}
function Gde(r) {
  r.registerChartView(Ude), r.registerSeriesModel(Ede), r.registerLayout(kv("line", !0)), r.registerVisual({
    seriesType: "line",
    reset: function(e) {
      var t = e.getData(), i = e.getModel("lineStyle").getLineStyle();
      i && !i.stroke && (i.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", i);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, N3("line"));
}
var x3 = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return Ss(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getMarkerPosition = function(t, i, n) {
      var a = this.coordinateSystem;
      if (a && a.clampData) {
        var o = a.clampData(t), s = a.dataToPoint(o);
        if (n)
          N(a.getAxes(), function(f, d) {
            if (f.type === "category" && i != null) {
              var p = f.getTicksCoords(), g = o[d], v = i[d] === "x1" || i[d] === "y1";
              if (v && (g += 1), p.length < 2)
                return;
              if (p.length === 2) {
                s[d] = f.toGlobalCoord(f.getExtent()[v ? 1 : 0]);
                return;
              }
              for (var O = void 0, m = void 0, E = 1, b = 0; b < p.length; b++) {
                var S = p[b].coord, T = b === p.length - 1 ? p[b - 1].tickValue + E : p[b].tickValue;
                if (T === g) {
                  m = S;
                  break;
                } else if (T < g)
                  O = S;
                else if (O != null && T > g) {
                  m = (S + O) / 2;
                  break;
                }
                b === 1 && (E = T - p[0].tickValue);
              }
              m == null && (O ? O && (m = p[p.length - 1].coord) : m = p[0].coord), s[d] = f.toGlobalCoord(m);
            }
          });
        else {
          var l = this.getData(), u = l.getLayout("offset"), c = l.getLayout("size"), h = a.getBaseAxis().isHorizontal() ? 0 : 1;
          s[h] += u + c / 2;
        }
        return s;
      }
      return [NaN, NaN];
    }, e.type = "series.__base_bar__", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // stack: null
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      barMinHeight: 0,
      barMinAngle: 0,
      // cursor: null,
      large: !1,
      largeThreshold: 400,
      progressive: 3e3,
      progressiveChunkMode: "mod"
    }, e;
  }(Wt)
);
Wt.registerClass(x3);
const Ib = x3;
var Bde = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function() {
      return Ss(null, this, {
        useEncodeDefaulter: !0,
        createInvertedIndices: !!this.get("realtimeSort", !0) || null
      });
    }, e.prototype.getProgressive = function() {
      return this.get("large") ? this.get("progressive") : !1;
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.get("progressiveThreshold"), i = this.get("largeThreshold");
      return i > t && (t = i), t;
    }, e.prototype.brushSelector = function(t, i, n) {
      return n.rect(i.getItemLayout(t));
    }, e.type = "series.bar", e.dependencies = ["grid", "polar"], e.defaultOption = Zl(Ib.defaultOption, {
      // If clipped
      // Only available on cartesian2d
      clip: !0,
      roundCap: !1,
      showBackground: !1,
      backgroundStyle: {
        color: "rgba(180, 180, 180, 0.2)",
        borderColor: null,
        borderWidth: 0,
        borderType: "solid",
        borderRadius: 0,
        shadowBlur: 0,
        shadowColor: null,
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      realtimeSort: !1
    }), e;
  }(Ib)
);
const Fde = Bde;
var Xde = (
  /** @class */
  function() {
    function r() {
      this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
    }
    return r;
  }()
), Yde = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "sausage", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new Xde();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.cx, a = i.cy, o = Math.max(i.r0 || 0, 0), s = Math.max(i.r, 0), l = (s - o) * 0.5, u = o + l, c = i.startAngle, h = i.endAngle, f = i.clockwise, d = Math.PI * 2, p = f ? h - c < d : c - h < d;
      p || (c = h - (f ? d : -d));
      var g = Math.cos(c), v = Math.sin(c), O = Math.cos(h), m = Math.sin(h);
      p ? (t.moveTo(g * o + n, v * o + a), t.arc(g * u + n, v * u + a, l, -Math.PI + c, c, !f)) : t.moveTo(g * s + n, v * s + a), t.arc(n, a, s, c, h, !f), t.arc(O * u + n, m * u + a, l, h - Math.PI * 2, h - Math.PI, !f), o !== 0 && t.arc(n, a, o, h, c, f);
    }, e;
  }(He)
);
const wb = Yde;
function Hde(r, e) {
  e = e || {};
  var t = e.isRoundCap;
  return function(i, n, a) {
    var o = n.position;
    if (!o || o instanceof Array)
      return ib(i, n, a);
    var s = r(o), l = n.distance != null ? n.distance : 5, u = this.shape, c = u.cx, h = u.cy, f = u.r, d = u.r0, p = (f + d) / 2, g = u.startAngle, v = u.endAngle, O = (g + v) / 2, m = t ? Math.abs(f - d) / 2 : 0, E = Math.cos, b = Math.sin, S = c + f * E(g), T = h + f * b(g), y = "left", R = "top";
    switch (s) {
      case "startArc":
        S = c + (d - l) * E(O), T = h + (d - l) * b(O), y = "center", R = "top";
        break;
      case "insideStartArc":
        S = c + (d + l) * E(O), T = h + (d + l) * b(O), y = "center", R = "bottom";
        break;
      case "startAngle":
        S = c + p * E(g) + ZO(g, l + m, !1), T = h + p * b(g) + qO(g, l + m, !1), y = "right", R = "middle";
        break;
      case "insideStartAngle":
        S = c + p * E(g) + ZO(g, -l + m, !1), T = h + p * b(g) + qO(g, -l + m, !1), y = "left", R = "middle";
        break;
      case "middle":
        S = c + p * E(O), T = h + p * b(O), y = "center", R = "middle";
        break;
      case "endArc":
        S = c + (f + l) * E(O), T = h + (f + l) * b(O), y = "center", R = "bottom";
        break;
      case "insideEndArc":
        S = c + (f - l) * E(O), T = h + (f - l) * b(O), y = "center", R = "top";
        break;
      case "endAngle":
        S = c + p * E(v) + ZO(v, l + m, !0), T = h + p * b(v) + qO(v, l + m, !0), y = "left", R = "middle";
        break;
      case "insideEndAngle":
        S = c + p * E(v) + ZO(v, -l + m, !0), T = h + p * b(v) + qO(v, -l + m, !0), y = "right", R = "middle";
        break;
      default:
        return ib(i, n, a);
    }
    return i = i || {}, i.x = S, i.y = T, i.align = y, i.verticalAlign = R, i;
  };
}
function Wde(r, e, t, i) {
  if (pt(i)) {
    r.setTextConfig({
      rotation: i
    });
    return;
  } else if (X(e)) {
    r.setTextConfig({
      rotation: 0
    });
    return;
  }
  var n = r.shape, a = n.clockwise ? n.startAngle : n.endAngle, o = n.clockwise ? n.endAngle : n.startAngle, s = (a + o) / 2, l, u = t(e);
  switch (u) {
    case "startArc":
    case "insideStartArc":
    case "middle":
    case "insideEndArc":
    case "endArc":
      l = s;
      break;
    case "startAngle":
    case "insideStartAngle":
      l = a;
      break;
    case "endAngle":
    case "insideEndAngle":
      l = o;
      break;
    default:
      r.setTextConfig({
        rotation: 0
      });
      return;
  }
  var c = Math.PI * 1.5 - l;
  u === "middle" && c > Math.PI / 2 && c < Math.PI * 1.5 && (c -= Math.PI), r.setTextConfig({
    rotation: c
  });
}
function ZO(r, e, t) {
  return e * Math.sin(r) * (t ? -1 : 1);
}
function qO(r, e, t) {
  return e * Math.cos(r) * (t ? 1 : -1);
}
function ec(r, e, t) {
  var i = r.get("borderRadius");
  if (i == null)
    return t ? {
      cornerRadius: 0
    } : null;
  X(i) || (i = [i, i, i, i]);
  var n = Math.abs(e.r || 0 - e.r0 || 0);
  return {
    cornerRadius: Y(i, function(a) {
      return xa(a, n);
    })
  };
}
var eR = Math.max, tR = Math.min;
function zde(r, e) {
  var t = r.getArea && r.getArea();
  if (Kc(r, "cartesian2d")) {
    var i = r.getBaseAxis();
    if (i.type !== "category" || !i.onBand) {
      var n = e.getLayout("bandWidth");
      i.isHorizontal() ? (t.x -= n, t.width += n * 2) : (t.y -= n, t.height += n * 2);
    }
  }
  return t;
}
var Zde = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r.call(this) || this;
      return t.type = e.type, t._isFirstFrame = !0, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this._model = t, this._removeOnRenderedListener(n), this._updateDrawMode(t);
      var o = t.get("coordinateSystem");
      o === "cartesian2d" || o === "polar" ? (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, i, n) : this._renderNormal(t, i, n, a)) : {}.NODE_ENV !== "production" && tr("Only cartesian2d and polar supported for bar.");
    }, e.prototype.incrementalPrepareRender = function(t) {
      this._clear(), this._updateDrawMode(t), this._updateLargeClip(t);
    }, e.prototype.incrementalRender = function(t, i) {
      this._progressiveEls = [], this._incrementalRenderLarge(t, i);
    }, e.prototype.eachRendered = function(t) {
      zl(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var i = t.pipelineContext.large;
      (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
    }, e.prototype._renderNormal = function(t, i, n, a) {
      var o = this.group, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.getBaseAxis(), h;
      u.type === "cartesian2d" ? h = c.isHorizontal() : u.type === "polar" && (h = c.dim === "angle");
      var f = t.isAnimationEnabled() ? t : null, d = qde(t, u);
      d && this._enableRealtimeSort(d, s, n);
      var p = t.get("clip", !0) || d, g = zde(u, s);
      o.removeClipPath();
      var v = t.get("roundCap", !0), O = t.get("showBackground", !0), m = t.getModel("backgroundStyle"), E = m.get("borderRadius") || 0, b = [], S = this._backgroundEls, T = a && a.isInitSort, y = a && a.type === "changeAxisOrder";
      function R(I) {
        var w = jO[u.type](s, I), x = ipe(u, h, w);
        return x.useStyle(m.getItemStyle()), u.type === "cartesian2d" ? x.setShape("r", E) : x.setShape("cornerRadius", E), b[I] = x, x;
      }
      s.diff(l).add(function(I) {
        var w = s.getItemModel(I), x = jO[u.type](s, I, w);
        if (O && R(I), !(!s.hasValue(I) || !_Q[u.type](x))) {
          var P = !1;
          p && (P = TQ[u.type](g, x));
          var L = yQ[u.type](t, s, I, x, h, f, c.model, !1, v);
          d && (L.forceLabelAnimation = !0), CQ(L, s, I, w, x, t, h, u.type === "polar"), T ? L.attr({
            shape: x
          }) : d ? RQ(d, f, L, x, I, h, !1, !1) : Bt(L, {
            shape: x
          }, t, I), s.setItemGraphicEl(I, L), o.add(L), L.ignore = P;
        }
      }).update(function(I, w) {
        var x = s.getItemModel(I), P = jO[u.type](s, I, x);
        if (O) {
          var L = void 0;
          S.length === 0 ? L = R(w) : (L = S[w], L.useStyle(m.getItemStyle()), u.type === "cartesian2d" ? L.setShape("r", E) : L.setShape("cornerRadius", E), b[I] = L);
          var D = jO[u.type](s, I), U = L3(h, D, u);
          Ot(L, {
            shape: U
          }, f, I);
        }
        var Q = l.getItemGraphicEl(w);
        if (!s.hasValue(I) || !_Q[u.type](P)) {
          o.remove(Q);
          return;
        }
        var V = !1;
        if (p && (V = TQ[u.type](g, P), V && o.remove(Q)), Q ? La(Q) : Q = yQ[u.type](t, s, I, P, h, f, c.model, !!Q, v), d && (Q.forceLabelAnimation = !0), y) {
          var F = Q.getTextContent();
          if (F) {
            var j = td(F);
            j.prevValue != null && (j.prevValue = j.value);
          }
        } else
          CQ(Q, s, I, x, P, t, h, u.type === "polar");
        T ? Q.attr({
          shape: P
        }) : d ? RQ(d, f, Q, P, I, h, !0, y) : Ot(Q, {
          shape: P
        }, t, I, null), s.setItemGraphicEl(I, Q), Q.ignore = V, o.add(Q);
      }).remove(function(I) {
        var w = l.getItemGraphicEl(I);
        w && Pg(w, t, I);
      }).execute();
      var _ = this._backgroundGroup || (this._backgroundGroup = new Re());
      _.removeAll();
      for (var C = 0; C < b.length; ++C)
        _.add(b[C]);
      o.add(_), this._backgroundEls = b, this._data = s;
    }, e.prototype._renderLarge = function(t, i, n) {
      this._clear(), wQ(t, this.group), this._updateLargeClip(t);
    }, e.prototype._incrementalRenderLarge = function(t, i) {
      this._removeBackground(), wQ(i, this.group, this._progressiveEls, !0);
    }, e.prototype._updateLargeClip = function(t) {
      var i = t.get("clip", !0) && UT(t.coordinateSystem, !1, t), n = this.group;
      i ? n.setClipPath(i) : n.removeClipPath();
    }, e.prototype._enableRealtimeSort = function(t, i, n) {
      var a = this;
      if (i.count()) {
        var o = t.baseAxis;
        if (this._isFirstFrame)
          this._dispatchInitSort(i, t, n), this._isFirstFrame = !1;
        else {
          var s = function(l) {
            var u = i.getItemGraphicEl(l), c = u && u.shape;
            return c && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(o.isHorizontal() ? c.height : c.width) || 0;
          };
          this._onRendered = function() {
            a._updateSortWithinSameData(i, s, o, n);
          }, n.getZr().on("rendered", this._onRendered);
        }
      }
    }, e.prototype._dataSort = function(t, i, n) {
      var a = [];
      return t.each(t.mapDimension(i.dim), function(o, s) {
        var l = n(s);
        l = l ?? NaN, a.push({
          dataIndex: s,
          mappedValue: l,
          ordinalNumber: o
        });
      }), a.sort(function(o, s) {
        return s.mappedValue - o.mappedValue;
      }), {
        ordinalNumbers: Y(a, function(o) {
          return o.ordinalNumber;
        })
      };
    }, e.prototype._isOrderChangedWithinSameData = function(t, i, n) {
      for (var a = n.scale, o = t.mapDimension(n.dim), s = Number.MAX_VALUE, l = 0, u = a.getOrdinalMeta().categories.length; l < u; ++l) {
        var c = t.rawIndexOf(o, a.getRawOrdinalNumber(l)), h = c < 0 ? Number.MIN_VALUE : i(t.indexOfRawIndex(c));
        if (h > s)
          return !0;
        s = h;
      }
      return !1;
    }, e.prototype._isOrderDifferentInView = function(t, i) {
      for (var n = i.scale, a = n.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], n.getOrdinalMeta().categories.length - 1); o <= s; ++o)
        if (t.ordinalNumbers[o] !== n.getRawOrdinalNumber(o))
          return !0;
    }, e.prototype._updateSortWithinSameData = function(t, i, n, a) {
      if (this._isOrderChangedWithinSameData(t, i, n)) {
        var o = this._dataSort(t, n, i);
        this._isOrderDifferentInView(o, n) && (this._removeOnRenderedListener(a), a.dispatchAction({
          type: "changeAxisOrder",
          componentType: n.dim + "Axis",
          axisId: n.index,
          sortInfo: o
        }));
      }
    }, e.prototype._dispatchInitSort = function(t, i, n) {
      var a = i.baseAxis, o = this._dataSort(t, a, function(s) {
        return t.get(t.mapDimension(i.otherAxis.dim), s);
      });
      n.dispatchAction({
        type: "changeAxisOrder",
        componentType: a.dim + "Axis",
        isInitSort: !0,
        axisId: a.index,
        sortInfo: o
      });
    }, e.prototype.remove = function(t, i) {
      this._clear(this._model), this._removeOnRenderedListener(i);
    }, e.prototype.dispose = function(t, i) {
      this._removeOnRenderedListener(i);
    }, e.prototype._removeOnRenderedListener = function(t) {
      this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null);
    }, e.prototype._clear = function(t) {
      var i = this.group, n = this._data;
      t && t.isAnimationEnabled() && n && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], n.eachItemGraphicEl(function(a) {
        Pg(a, t, Pe(a).dataIndex);
      })) : i.removeAll(), this._data = null, this._isFirstFrame = !0;
    }, e.prototype._removeBackground = function() {
      this.group.remove(this._backgroundGroup), this._backgroundGroup = null;
    }, e.type = "bar", e;
  }($t)
), TQ = {
  cartesian2d: function(r, e) {
    var t = e.width < 0 ? -1 : 1, i = e.height < 0 ? -1 : 1;
    t < 0 && (e.x += e.width, e.width = -e.width), i < 0 && (e.y += e.height, e.height = -e.height);
    var n = r.x + r.width, a = r.y + r.height, o = eR(e.x, r.x), s = tR(e.x + e.width, n), l = eR(e.y, r.y), u = tR(e.y + e.height, a), c = s < o, h = u < l;
    return e.x = c && o > n ? s : o, e.y = h && l > a ? u : l, e.width = c ? 0 : s - o, e.height = h ? 0 : u - l, t < 0 && (e.x += e.width, e.width = -e.width), i < 0 && (e.y += e.height, e.height = -e.height), c || h;
  },
  polar: function(r, e) {
    var t = e.r0 <= e.r ? 1 : -1;
    if (t < 0) {
      var i = e.r;
      e.r = e.r0, e.r0 = i;
    }
    var n = tR(e.r, r.r), a = eR(e.r0, r.r0);
    e.r = n, e.r0 = a;
    var o = n - a < 0;
    if (t < 0) {
      var i = e.r;
      e.r = e.r0, e.r0 = i;
    }
    return o;
  }
}, yQ = {
  cartesian2d: function(r, e, t, i, n, a, o, s, l) {
    var u = new ht({
      shape: B({}, i),
      z2: 1
    });
    if (u.__dataIndex = t, u.name = "item", a) {
      var c = u.shape, h = n ? "height" : "width";
      c[h] = 0;
    }
    return u;
  },
  polar: function(r, e, t, i, n, a, o, s, l) {
    var u = !n && l ? wb : tn, c = new u({
      shape: i,
      z2: 1
    });
    c.name = "item";
    var h = P3(n);
    if (c.calculateTextPosition = Hde(h, {
      isRoundCap: u === wb
    }), a) {
      var f = c.shape, d = n ? "r" : "endAngle", p = {};
      f[d] = n ? i.r0 : i.startAngle, p[d] = i[d], (s ? Ot : Bt)(c, {
        shape: p
        // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue
      }, a);
    }
    return c;
  }
};
function qde(r, e) {
  var t = r.get("realtimeSort", !0), i = e.getBaseAxis();
  if ({}.NODE_ENV !== "production" && t && (i.type !== "category" && tr("`realtimeSort` will not work because this bar series is not based on a category axis."), e.type !== "cartesian2d" && tr("`realtimeSort` will not work because this bar series is not on cartesian2d.")), t && i.type === "category" && e.type === "cartesian2d")
    return {
      baseAxis: i,
      otherAxis: e.getOtherAxis(i)
    };
}
function RQ(r, e, t, i, n, a, o, s) {
  var l, u;
  a ? (u = {
    x: i.x,
    width: i.width
  }, l = {
    y: i.y,
    height: i.height
  }) : (u = {
    y: i.y,
    height: i.height
  }, l = {
    x: i.x,
    width: i.width
  }), s || (o ? Ot : Bt)(t, {
    shape: l
  }, e, n, null);
  var c = e ? r.baseAxis.model : null;
  (o ? Ot : Bt)(t, {
    shape: u
  }, c, n);
}
function AQ(r, e) {
  for (var t = 0; t < e.length; t++)
    if (!isFinite(r[e[t]]))
      return !0;
  return !1;
}
var jde = ["x", "y", "width", "height"], Kde = ["cx", "cy", "r", "startAngle", "endAngle"], _Q = {
  cartesian2d: function(r) {
    return !AQ(r, jde);
  },
  polar: function(r) {
    return !AQ(r, Kde);
  }
}, jO = {
  // itemModel is only used to get borderWidth, which is not needed
  // when calculating bar background layout.
  cartesian2d: function(r, e, t) {
    var i = r.getItemLayout(e), n = t ? epe(t, i) : 0, a = i.width > 0 ? 1 : -1, o = i.height > 0 ? 1 : -1;
    return {
      x: i.x + a * n / 2,
      y: i.y + o * n / 2,
      width: i.width - a * n,
      height: i.height - o * n
    };
  },
  polar: function(r, e, t) {
    var i = r.getItemLayout(e);
    return {
      cx: i.cx,
      cy: i.cy,
      r0: i.r0,
      r: i.r,
      startAngle: i.startAngle,
      endAngle: i.endAngle,
      clockwise: i.clockwise
    };
  }
};
function Jde(r) {
  return r.startAngle != null && r.endAngle != null && r.startAngle === r.endAngle;
}
function P3(r) {
  return function(e) {
    var t = e ? "Arc" : "Angle";
    return function(i) {
      switch (i) {
        case "start":
        case "insideStart":
        case "end":
        case "insideEnd":
          return i + t;
        default:
          return i;
      }
    };
  }(r);
}
function CQ(r, e, t, i, n, a, o, s) {
  var l = e.getItemVisual(t, "style");
  if (s) {
    if (!a.get("roundCap")) {
      var c = r.shape, h = ec(i.getModel("itemStyle"), c, !0);
      B(c, h), r.setShape(c);
    }
  } else {
    var u = i.get(["itemStyle", "borderRadius"]) || 0;
    r.setShape("r", u);
  }
  r.useStyle(l);
  var f = i.getShallow("cursor");
  f && r.attr("cursor", f);
  var d = s ? o ? n.r >= n.r0 ? "endArc" : "startArc" : n.endAngle >= n.startAngle ? "endAngle" : "startAngle" : o ? n.height >= 0 ? "bottom" : "top" : n.width >= 0 ? "right" : "left", p = kr(i);
  ii(r, p, {
    labelFetcher: a,
    labelDataIndex: t,
    defaultText: Lf(a.getData(), t),
    inheritColor: l.fill,
    defaultOpacity: l.opacity,
    defaultOutsidePosition: d
  });
  var g = r.getTextContent();
  if (s && g) {
    var v = i.get(["label", "position"]);
    r.textConfig.inside = v === "middle" ? !0 : null, Wde(r, v === "outside" ? d : v, P3(o), i.get(["label", "rotate"]));
  }
  qH(g, p, a.getRawValue(t), function(m) {
    return T3(e, m);
  });
  var O = i.getModel(["emphasis"]);
  qt(r, O.get("focus"), O.get("blurScope"), O.get("disabled")), ri(r, i), Jde(n) && (r.style.fill = "none", r.style.stroke = "none", N(r.states, function(m) {
    m.style && (m.style.fill = m.style.stroke = "none");
  }));
}
function epe(r, e) {
  var t = r.get(["itemStyle", "borderColor"]);
  if (!t || t === "none")
    return 0;
  var i = r.get(["itemStyle", "borderWidth"]) || 0, n = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height);
  return Math.min(i, n, a);
}
var tpe = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), IQ = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "largeBar", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new tpe();
    }, e.prototype.buildPath = function(t, i) {
      for (var n = i.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], u = this.barWidth, c = 0; c < n.length; c += 3)
        l[a] = u, l[o] = n[c + 2], s[a] = n[c + a], s[o] = n[c + o], t.rect(s[0], s[1], l[0], l[1]);
    }, e;
  }(He)
);
function wQ(r, e, t, i) {
  var n = r.getData(), a = n.getLayout("valueAxisHorizontal") ? 1 : 0, o = n.getLayout("largeDataIndices"), s = n.getLayout("size"), l = r.getModel("backgroundStyle"), u = n.getLayout("largeBackgroundPoints");
  if (u) {
    var c = new IQ({
      shape: {
        points: u
      },
      incremental: !!i,
      silent: !0,
      z2: 0
    });
    c.baseDimIdx = a, c.largeDataIndices = o, c.barWidth = s, c.useStyle(l.getItemStyle()), e.add(c), t && t.push(c);
  }
  var h = new IQ({
    shape: {
      points: n.getLayout("largePoints")
    },
    incremental: !!i,
    ignoreCoarsePointer: !0,
    z2: 1
  });
  h.baseDimIdx = a, h.largeDataIndices = o, h.barWidth = s, e.add(h), h.useStyle(n.getVisual("style")), Pe(h).seriesIndex = r.seriesIndex, r.get("silent") || (h.on("mousedown", NQ), h.on("mousemove", NQ)), t && t.push(h);
}
var NQ = pN(function(r) {
  var e = this, t = rpe(e, r.offsetX, r.offsetY);
  Pe(e).dataIndex = t >= 0 ? t : null;
}, 30, !1);
function rpe(r, e, t) {
  for (var i = r.baseDimIdx, n = 1 - i, a = r.shape.points, o = r.largeDataIndices, s = [], l = [], u = r.barWidth, c = 0, h = a.length / 3; c < h; c++) {
    var f = c * 3;
    if (l[i] = u, l[n] = a[f + 2], s[i] = a[f + i], s[n] = a[f + n], l[n] < 0 && (s[n] += l[n], l[n] = -l[n]), e >= s[0] && e <= s[0] + l[0] && t >= s[1] && t <= s[1] + l[1])
      return o[c];
  }
  return -1;
}
function L3(r, e, t) {
  if (Kc(t, "cartesian2d")) {
    var i = e, n = t.getArea();
    return {
      x: r ? i.x : n.x,
      y: r ? n.y : i.y,
      width: r ? i.width : n.width,
      height: r ? n.height : i.height
    };
  } else {
    var n = t.getArea(), a = e;
    return {
      cx: n.cx,
      cy: n.cy,
      r0: r ? n.r0 : a.r0,
      r: r ? n.r : a.r,
      startAngle: r ? a.startAngle : 0,
      endAngle: r ? a.endAngle : Math.PI * 2
    };
  }
}
function ipe(r, e, t) {
  var i = r.type === "polar" ? tn : ht;
  return new i({
    shape: L3(e, t, r),
    silent: !0,
    z2: 0
  });
}
const npe = Zde;
function ape(r) {
  r.registerChartView(npe), r.registerSeriesModel(Fde), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Le(Qz, "bar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, Uz("bar")), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, N3("bar")), r.registerAction({
    type: "changeAxisOrder",
    event: "changeAxisOrder",
    update: "update"
  }, function(e, t) {
    var i = e.componentType || "series";
    t.eachComponent({
      mainType: i,
      query: e
    }, function(n) {
      e.sortInfo && n.axis.setCategorySortInfo(e.sortInfo);
    });
  });
}
var KO = Math.PI * 2, xQ = Math.PI / 180;
function D3(r, e) {
  return Ir(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function M3(r, e) {
  var t = D3(r, e), i = r.get("center"), n = r.get("radius");
  X(n) || (n = [0, n]);
  var a = K(t.width, e.getWidth()), o = K(t.height, e.getHeight()), s = Math.min(a, o), l = K(n[0], s / 2), u = K(n[1], s / 2), c, h, f = r.coordinateSystem;
  if (f) {
    var d = f.dataToPoint(i);
    c = d[0] || 0, h = d[1] || 0;
  } else
    X(i) || (i = [i, i]), c = K(i[0], a) + t.x, h = K(i[1], o) + t.y;
  return {
    cx: c,
    cy: h,
    r0: l,
    r: u
  };
}
function ope(r, e, t) {
  e.eachSeriesByType(r, function(i) {
    var n = i.getData(), a = n.mapDimension("value"), o = D3(i, t), s = M3(i, t), l = s.cx, u = s.cy, c = s.r, h = s.r0, f = -i.get("startAngle") * xQ, d = i.get("minAngle") * xQ, p = 0;
    n.each(a, function(C) {
      !isNaN(C) && p++;
    });
    var g = n.getSum(a), v = Math.PI / (g || p) * 2, O = i.get("clockwise"), m = i.get("roseType"), E = i.get("stillShowZeroSum"), b = n.getDataExtent(a);
    b[0] = 0;
    var S = KO, T = 0, y = f, R = O ? 1 : -1;
    if (n.setLayout({
      viewRect: o,
      r: c
    }), n.each(a, function(C, I) {
      var w;
      if (isNaN(C)) {
        n.setItemLayout(I, {
          angle: NaN,
          startAngle: NaN,
          endAngle: NaN,
          clockwise: O,
          cx: l,
          cy: u,
          r0: h,
          r: m ? NaN : c
        });
        return;
      }
      m !== "area" ? w = g === 0 && E ? v : C * v : w = KO / p, w < d ? (w = d, S -= d) : T += C;
      var x = y + R * w;
      n.setItemLayout(I, {
        angle: w,
        startAngle: y,
        endAngle: x,
        clockwise: O,
        cx: l,
        cy: u,
        r0: h,
        r: m ? yt(C, b, [h, c]) : c
      }), y = x;
    }), S < KO && p)
      if (S <= 1e-3) {
        var _ = KO / p;
        n.each(a, function(C, I) {
          if (!isNaN(C)) {
            var w = n.getItemLayout(I);
            w.angle = _, w.startAngle = f + R * I * _, w.endAngle = f + R * (I + 1) * _;
          }
        });
      } else
        v = S / T, y = f, n.each(a, function(C, I) {
          if (!isNaN(C)) {
            var w = n.getItemLayout(I), x = w.angle === d ? d : C * v;
            w.startAngle = y, w.endAngle = y + R * x, y += R * x;
          }
        });
  });
}
function Qv(r) {
  return {
    seriesType: r,
    reset: function(e, t) {
      var i = t.findComponents({
        mainType: "legend"
      });
      if (!(!i || !i.length)) {
        var n = e.getData();
        n.filterSelf(function(a) {
          for (var o = n.getName(a), s = 0; s < i.length; s++)
            if (!i[s].isSelected(o))
              return !1;
          return !0;
        });
      }
    }
  };
}
var spe = Math.PI / 180;
function PQ(r, e, t, i, n, a, o, s, l, u) {
  if (r.length < 2)
    return;
  function c(g) {
    for (var v = g.rB, O = v * v, m = 0; m < g.list.length; m++) {
      var E = g.list[m], b = Math.abs(E.label.y - t), S = i + E.len, T = S * S, y = Math.sqrt((1 - Math.abs(b * b / O)) * T), R = e + (y + E.len2) * n, _ = R - E.label.x, C = E.targetTextWidth - _ * n;
      k3(E, C, !0), E.label.x = R;
    }
  }
  function h(g) {
    for (var v = {
      list: [],
      maxY: 0
    }, O = {
      list: [],
      maxY: 0
    }, m = 0; m < g.length; m++)
      if (g[m].labelAlignTo === "none") {
        var E = g[m], b = E.label.y > t ? O : v, S = Math.abs(E.label.y - t);
        if (S >= b.maxY) {
          var T = E.label.x - e - E.len2 * n, y = i + E.len, R = Math.abs(T) < y ? Math.sqrt(S * S / (1 - T * T / y / y)) : y;
          b.rB = R, b.maxY = S;
        }
        b.list.push(E);
      }
    c(v), c(O);
  }
  for (var f = r.length, d = 0; d < f; d++)
    if (r[d].position === "outer" && r[d].labelAlignTo === "labelLine") {
      var p = r[d].label.x - u;
      r[d].linePoints[1][0] += p, r[d].label.x = u;
    }
  o3(r, l, l + o) && h(r);
}
function lpe(r, e, t, i, n, a, o, s) {
  for (var l = [], u = [], c = Number.MAX_VALUE, h = -Number.MAX_VALUE, f = 0; f < r.length; f++) {
    var d = r[f].label;
    rR(r[f]) || (d.x < e ? (c = Math.min(c, d.x), l.push(r[f])) : (h = Math.max(h, d.x), u.push(r[f])));
  }
  for (var f = 0; f < r.length; f++) {
    var p = r[f];
    if (!rR(p) && p.linePoints) {
      if (p.labelStyleWidth != null)
        continue;
      var d = p.label, g = p.linePoints, v = void 0;
      p.labelAlignTo === "edge" ? d.x < e ? v = g[2][0] - p.labelDistance - o - p.edgeDistance : v = o + n - p.edgeDistance - g[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? d.x < e ? v = c - o - p.bleedMargin : v = o + n - h - p.bleedMargin : d.x < e ? v = d.x - o - p.bleedMargin : v = o + n - d.x - p.bleedMargin, p.targetTextWidth = v, k3(p, v);
    }
  }
  PQ(u, e, t, i, 1, n, a, o, s, h), PQ(l, e, t, i, -1, n, a, o, s, c);
  for (var f = 0; f < r.length; f++) {
    var p = r[f];
    if (!rR(p) && p.linePoints) {
      var d = p.label, g = p.linePoints, O = p.labelAlignTo === "edge", m = d.style.padding, E = m ? m[1] + m[3] : 0, b = d.style.backgroundColor ? 0 : E, S = p.rect.width + b, T = g[1][0] - g[2][0];
      O ? d.x < e ? g[2][0] = o + p.edgeDistance + S + p.labelDistance : g[2][0] = o + n - p.edgeDistance - S - p.labelDistance : (d.x < e ? g[2][0] = d.x + p.labelDistance : g[2][0] = d.x - p.labelDistance, g[1][0] = g[2][0] + T), g[1][1] = g[2][1] = d.y;
    }
  }
}
function k3(r, e, t) {
  if (t === void 0 && (t = !1), r.labelStyleWidth == null) {
    var i = r.label, n = i.style, a = r.rect, o = n.backgroundColor, s = n.padding, l = s ? s[1] + s[3] : 0, u = n.overflow, c = a.width + (o ? 0 : l);
    if (e < c || t) {
      var h = a.height;
      if (u && u.match("break")) {
        i.setStyle("backgroundColor", null), i.setStyle("width", e - l);
        var f = i.getBoundingRect();
        i.setStyle("width", Math.ceil(f.width)), i.setStyle("backgroundColor", o);
      } else {
        var d = e - l, p = e < c ? d : (
          // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          t ? d > r.unconstrainedWidth ? null : d : (
            // Current available width is enough, so no need to
            // constrain.
            null
          )
        );
        i.setStyle("width", p);
      }
      var g = i.getBoundingRect();
      a.width = g.width;
      var v = (i.style.margin || 0) + 2.1;
      a.height = g.height + v, a.y -= (a.height - h) / 2;
    }
  }
}
function rR(r) {
  return r.position === "center";
}
function upe(r) {
  var e = r.getData(), t = [], i, n, a = !1, o = (r.get("minShowLabelAngle") || 0) * spe, s = e.getLayout("viewRect"), l = e.getLayout("r"), u = s.width, c = s.x, h = s.y, f = s.height;
  function d(T) {
    T.ignore = !0;
  }
  function p(T) {
    if (!T.ignore)
      return !0;
    for (var y in T.states)
      if (T.states[y].ignore === !1)
        return !0;
    return !1;
  }
  e.each(function(T) {
    var y = e.getItemGraphicEl(T), R = y.shape, _ = y.getTextContent(), C = y.getTextGuideLine(), I = e.getItemModel(T), w = I.getModel("label"), x = w.get("position") || I.get(["emphasis", "label", "position"]), P = w.get("distanceToLabelLine"), L = w.get("alignTo"), D = K(w.get("edgeDistance"), u), U = w.get("bleedMargin"), Q = I.getModel("labelLine"), V = Q.get("length");
    V = K(V, u);
    var F = Q.get("length2");
    if (F = K(F, u), Math.abs(R.endAngle - R.startAngle) < o) {
      N(_.states, d), _.ignore = !0, C && (N(C.states, d), C.ignore = !0);
      return;
    }
    if (p(_)) {
      var j = (R.startAngle + R.endAngle) / 2, ae = Math.cos(j), ce = Math.sin(j), ge, Be, We, Ne;
      i = R.cx, n = R.cy;
      var Ee = x === "inside" || x === "inner";
      if (x === "center")
        ge = R.cx, Be = R.cy, Ne = "center";
      else {
        var Ge = (Ee ? (R.r + R.r0) / 2 * ae : R.r * ae) + i, Ie = (Ee ? (R.r + R.r0) / 2 * ce : R.r * ce) + n;
        if (ge = Ge + ae * 3, Be = Ie + ce * 3, !Ee) {
          var he = Ge + ae * (V + l - R.r), xe = Ie + ce * (V + l - R.r), M = he + (ae < 0 ? -1 : 1) * F, k = xe;
          L === "edge" ? ge = ae < 0 ? c + D : c + u - D : ge = M + (ae < 0 ? -P : P), Be = k, We = [[Ge, Ie], [he, xe], [M, k]];
        }
        Ne = Ee ? "center" : L === "edge" ? ae > 0 ? "right" : "left" : ae > 0 ? "left" : "right";
      }
      var G = Math.PI, H = 0, z = w.get("rotate");
      if (pt(z))
        H = z * (G / 180);
      else if (x === "center")
        H = 0;
      else if (z === "radial" || z === !0) {
        var te = ae < 0 ? -j + G : -j;
        H = te;
      } else if (z === "tangential" && x !== "outside" && x !== "outer") {
        var se = Math.atan2(ae, ce);
        se < 0 && (se = G * 2 + se);
        var ie = ce > 0;
        ie && (se = G + se), H = se - G;
      }
      if (a = !!H, _.x = ge, _.y = Be, _.rotation = H, _.setStyle({
        verticalAlign: "middle"
      }), Ee) {
        _.setStyle({
          align: Ne
        });
        var Ae = _.states.select;
        Ae && (Ae.x += _.x, Ae.y += _.y);
      } else {
        var oe = _.getBoundingRect().clone();
        oe.applyTransform(_.getComputedTransform());
        var J = (_.style.margin || 0) + 2.1;
        oe.y -= J / 2, oe.height += J, t.push({
          label: _,
          labelLine: C,
          position: x,
          len: V,
          len2: F,
          minTurnAngle: Q.get("minTurnAngle"),
          maxSurfaceAngle: Q.get("maxSurfaceAngle"),
          surfaceNormal: new Me(ae, ce),
          linePoints: We,
          textAlign: Ne,
          labelDistance: P,
          labelAlignTo: L,
          edgeDistance: D,
          bleedMargin: U,
          rect: oe,
          unconstrainedWidth: oe.width,
          labelStyleWidth: _.style.width
        });
      }
      y.setTextConfig({
        inside: Ee
      });
    }
  }), !a && r.get("avoidLabelOverlap") && lpe(t, i, n, l, u, f, c, h);
  for (var g = 0; g < t.length; g++) {
    var v = t[g], O = v.label, m = v.labelLine, E = isNaN(O.x) || isNaN(O.y);
    if (O) {
      O.setStyle({
        align: v.textAlign
      }), E && (N(O.states, d), O.ignore = !0);
      var b = O.states.select;
      b && (b.x += O.x, b.y += O.y);
    }
    if (m) {
      var S = v.linePoints;
      E || !S ? (N(m.states, d), m.ignore = !0) : (i3(S, v.minTurnAngle), Tfe(S, v.surfaceNormal, v.maxSurfaceAngle), m.setShape({
        points: S
      }), O.__hostTarget.textGuideLineConfig = {
        anchor: new Me(S[0][0], S[0][1])
      });
    }
  }
}
var cpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      a.z2 = 2;
      var o = new dt();
      return a.setTextContent(o), a.updateData(t, i, n, !0), a;
    }
    return e.prototype.updateData = function(t, i, n, a) {
      var o = this, s = t.hostModel, l = t.getItemModel(i), u = l.getModel("emphasis"), c = t.getItemLayout(i), h = B(ec(l.getModel("itemStyle"), c, !0), c);
      if (isNaN(h.startAngle)) {
        o.setShape(h);
        return;
      }
      if (a) {
        o.setShape(h);
        var f = s.getShallow("animationType");
        s.ecModel.ssr ? (Bt(o, {
          scaleX: 0,
          scaleY: 0
        }, s, {
          dataIndex: i,
          isFrom: !0
        }), o.originX = h.cx, o.originY = h.cy) : f === "scale" ? (o.shape.r = c.r0, Bt(o, {
          shape: {
            r: c.r
          }
        }, s, i)) : n != null ? (o.setShape({
          startAngle: n,
          endAngle: n
        }), Bt(o, {
          shape: {
            startAngle: c.startAngle,
            endAngle: c.endAngle
          }
        }, s, i)) : (o.shape.endAngle = c.startAngle, Ot(o, {
          shape: {
            endAngle: c.endAngle
          }
        }, s, i));
      } else
        La(o), Ot(o, {
          shape: h
        }, s, i);
      o.useStyle(t.getItemVisual(i, "style")), ri(o, l);
      var d = (c.startAngle + c.endAngle) / 2, p = s.get("selectedOffset"), g = Math.cos(d) * p, v = Math.sin(d) * p, O = l.getShallow("cursor");
      O && o.attr("cursor", O), this._updateLabel(s, t, i), o.ensureState("emphasis").shape = B({
        r: c.r + (u.get("scale") && u.get("scaleSize") || 0)
      }, ec(u.getModel("itemStyle"), c)), B(o.ensureState("select"), {
        x: g,
        y: v,
        shape: ec(l.getModel(["select", "itemStyle"]), c)
      }), B(o.ensureState("blur"), {
        shape: ec(l.getModel(["blur", "itemStyle"]), c)
      });
      var m = o.getTextGuideLine(), E = o.getTextContent();
      m && B(m.ensureState("select"), {
        x: g,
        y: v
      }), B(E.ensureState("select"), {
        x: g,
        y: v
      }), qt(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, i, n) {
      var a = this, o = i.getItemModel(n), s = o.getModel("labelLine"), l = i.getItemVisual(n, "style"), u = l && l.fill, c = l && l.opacity;
      ii(a, kr(o), {
        labelFetcher: i.hostModel,
        labelDataIndex: n,
        inheritColor: u,
        defaultOpacity: c,
        defaultText: t.getFormattedLabel(n, "normal") || i.getName(n)
      });
      var h = a.getTextContent();
      a.setTextConfig({
        // reset position, rotation
        position: null,
        rotation: null
      }), h.attr({
        z2: 10
      });
      var f = t.get(["label", "position"]);
      if (f !== "outside" && f !== "outer")
        a.removeTextGuideLine();
      else {
        var d = this.getTextGuideLine();
        d || (d = new nn(), this.setTextGuideLine(d)), CN(this, IN(o), {
          stroke: u,
          opacity: Kn(s.get(["lineStyle", "opacity"]), c, 1)
        });
      }
    }, e;
  }(tn)
), hpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = t.getData(), s = this._data, l = this.group, u;
      if (!s && o.count() > 0) {
        for (var c = o.getItemLayout(0), h = 1; isNaN(c && c.startAngle) && h < o.count(); ++h)
          c = o.getItemLayout(h);
        c && (u = c.startAngle);
      }
      if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && t.get("showEmptyCircle")) {
        var f = new tn({
          shape: M3(t, n)
        });
        f.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = f, l.add(f);
      }
      o.diff(s).add(function(d) {
        var p = new cpe(o, d, u);
        o.setItemGraphicEl(d, p), l.add(p);
      }).update(function(d, p) {
        var g = s.getItemGraphicEl(p);
        g.updateData(o, d, u), g.off("click"), l.add(g), o.setItemGraphicEl(d, g);
      }).remove(function(d) {
        var p = s.getItemGraphicEl(d);
        Pg(p, t, d);
      }).execute(), upe(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = o);
    }, e.prototype.dispose = function() {
    }, e.prototype.containPoint = function(t, i) {
      var n = i.getData(), a = n.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "pie", e;
  }($t)
);
const fpe = hpe;
function hd(r, e, t) {
  e = X(e) && {
    coordDimensions: e
  } || B({
    encodeDefine: r.getEncode()
  }, e);
  var i = r.getSource(), n = xv(i, e).dimensions, a = new ki(n, r);
  return a.initData(i, t), a;
}
var dpe = (
  /** @class */
  function() {
    function r(e, t) {
      this._getDataWithEncodedVisual = e, this._getRawData = t;
    }
    return r.prototype.getAllNames = function() {
      var e = this._getRawData();
      return e.mapArray(e.getName);
    }, r.prototype.containName = function(e) {
      var t = this._getRawData();
      return t.indexOfName(e) >= 0;
    }, r.prototype.indexOfName = function(e) {
      var t = this._getDataWithEncodedVisual();
      return t.indexOfName(e);
    }, r.prototype.getItemVisual = function(e, t) {
      var i = this._getDataWithEncodedVisual();
      return i.getItemVisual(e, t);
    }, r;
  }()
);
const Uv = dpe;
var ppe = ft(), gpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Uv(ue(this.getData, this), ue(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.mergeOption = function() {
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.getInitialData = function() {
      return hd(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Le(nN, this)
      });
    }, e.prototype.getDataParams = function(t) {
      var i = this.getData(), n = ppe(i), a = n.seats;
      if (!a) {
        var o = [];
        i.each(i.mapDimension("value"), function(l) {
          o.push(l);
        }), a = n.seats = Tae(o, i.hostModel.get("percentPrecision"));
      }
      var s = r.prototype.getDataParams.call(this, t);
      return s.percent = a[t] || 0, s.$vars.push("percent"), s;
    }, e.prototype._defaultLabelLine = function(t) {
      Ic(t, "labelLine", ["show"]);
      var i = t.labelLine, n = t.emphasis.labelLine;
      i.show = i.show && t.label.show, n.show = n.show && t.emphasis.label.show;
    }, e.type = "series.pie", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      // 0
      minAngle: 0,
      // If the angle of a sector less than `minShowLabelAngle`,
      // the label will not be displayed.
      minShowLabelAngle: 0,
      // 
      selectedOffset: 10,
      // singlemultiple
      // selectedMode: false,
      // 'radius' | 'area'
      // roseType: null,
      percentPrecision: 2,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // cursor: null,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0,
      width: null,
      height: null,
      label: {
        // color: 'inherit',
        // If rotate around circle
        rotate: 0,
        show: !0,
        overflow: "truncate",
        // 'outer', 'inside', 'center'
        position: "outer",
        // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
        alignTo: "none",
        // Closest distance between label and chart edge.
        // Works only position is 'outer' and alignTo is 'edge'.
        edgeDistance: "25%",
        // Works only position is 'outer' and alignTo is not 'edge'.
        bleedMargin: 10,
        // Distance between text and label line.
        distanceToLabelLine: 5
        // formatter:  tooltip.formatter
        //  textStyle
        // distance: positioninnerlabel()
      },
      // Enabled when label.normal.position is 'outer'
      labelLine: {
        show: !0,
        // 
        length: 15,
        // 
        length2: 15,
        smooth: !1,
        minTurnAngle: 90,
        maxSurfaceAngle: 90,
        lineStyle: {
          // color: ,
          width: 1,
          type: "solid"
        }
      },
      itemStyle: {
        borderWidth: 1,
        borderJoin: "round"
      },
      showEmptyCircle: !0,
      emptyCircleStyle: {
        color: "lightgray",
        opacity: 1
      },
      labelLayout: {
        // Hide the overlapped label.
        hideOverlap: !0
      },
      emphasis: {
        scale: !0,
        scaleSize: 5
      },
      // If use strategy to avoid label overlapping
      avoidLabelOverlap: !0,
      // Animation type. Valid values: expansion, scale
      animationType: "expansion",
      animationDuration: 1e3,
      // Animation type when update. Valid values: transition, expansion
      animationTypeUpdate: "transition",
      animationEasingUpdate: "cubicInOut",
      animationDurationUpdate: 500,
      animationEasing: "cubicInOut"
    }, e;
  }(Wt)
);
const vpe = gpe;
function Ope(r) {
  return {
    seriesType: r,
    reset: function(e, t) {
      var i = e.getData();
      i.filterSelf(function(n) {
        var a = i.mapDimension("value"), o = i.get(a, n);
        return !(pt(o) && !isNaN(o) && o < 0);
      });
    }
  };
}
function mpe(r) {
  r.registerChartView(fpe), r.registerSeriesModel(vpe), iz("pie", r.registerAction), r.registerLayout(Le(ope, "pie")), r.registerProcessor(Qv("pie")), r.registerProcessor(Ope("pie"));
}
var Epe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return Ss(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 5e3 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 1e4 : this.get("progressiveThreshold"));
    }, e.prototype.brushSelector = function(t, i, n) {
      return n.point(i.getItemLayout(t));
    }, e.prototype.getZLevelKey = function() {
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : "";
    }, e.type = "series.scatter", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      symbolSize: 10,
      // symbolRotate: null,  // 
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      // cursor: null,
      itemStyle: {
        opacity: 0.8
        // color: 
      },
      emphasis: {
        scale: !0
      },
      // If clip the overflow graphics
      // Works on cartesian / polar series
      clip: !0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      universalTransition: {
        divideShape: "clone"
      }
      // progressive: null
    }, e;
  }(Wt)
);
const bpe = Epe;
var Q3 = 4, Spe = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), Tpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i._off = 0, i.hoverDataIdx = -1, i;
    }
    return e.prototype.getDefaultShape = function() {
      return new Spe();
    }, e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = i.size, o = this.symbolProxy, s = o.shape, l = t.getContext ? t.getContext() : t, u = l && a[0] < Q3, c = this.softClipShape, h;
      if (u) {
        this._ctx = l;
        return;
      }
      for (this._ctx = null, h = this._off; h < n.length; ) {
        var f = n[h++], d = n[h++];
        isNaN(f) || isNaN(d) || c && !c.contain(f, d) || (s.x = f - a[0] / 2, s.y = d - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(t, s, !0));
      }
      this.incremental && (this._off = h, this.notClear = !0);
    }, e.prototype.afterBrush = function() {
      var t = this.shape, i = t.points, n = t.size, a = this._ctx, o = this.softClipShape, s;
      if (a) {
        for (s = this._off; s < i.length; ) {
          var l = i[s++], u = i[s++];
          isNaN(l) || isNaN(u) || o && !o.contain(l, u) || a.fillRect(l - n[0] / 2, u - n[1] / 2, n[0], n[1]);
        }
        this.incremental && (this._off = s, this.notClear = !0);
      }
    }, e.prototype.findDataIndex = function(t, i) {
      for (var n = this.shape, a = n.points, o = n.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), u = a.length / 2 - 1; u >= 0; u--) {
        var c = u * 2, h = a[c] - s / 2, f = a[c + 1] - l / 2;
        if (t >= h && i >= f && t <= h + s && i <= f + l)
          return u;
      }
      return -1;
    }, e.prototype.contain = function(t, i) {
      var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
      if (t = n[0], i = n[1], a.contain(t, i)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, i);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var i = this.shape, n = i.points, a = i.size, o = a[0], s = a[1], l = 1 / 0, u = 1 / 0, c = -1 / 0, h = -1 / 0, f = 0; f < n.length; ) {
          var d = n[f++], p = n[f++];
          l = Math.min(d, l), c = Math.max(d, c), u = Math.min(p, u), h = Math.max(p, h);
        }
        t = this._rect = new Ve(l - o / 2, u - s / 2, c - l + o, h - u + s);
      }
      return t;
    }, e;
  }(He)
), ype = (
  /** @class */
  function() {
    function r() {
      this.group = new Re();
    }
    return r.prototype.updateData = function(e, t) {
      this._clear();
      var i = this._create();
      i.setShape({
        points: e.getLayout("points")
      }), this._setCommon(i, e, t);
    }, r.prototype.updateLayout = function(e) {
      var t = e.getLayout("points");
      this.group.eachChild(function(i) {
        if (i.startIndex != null) {
          var n = (i.endIndex - i.startIndex) * 2, a = i.startIndex * 4 * 2;
          t = new Float32Array(t.buffer, a, n);
        }
        i.setShape("points", t), i.reset();
      });
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._clear();
    }, r.prototype.incrementalUpdate = function(e, t, i) {
      var n = this._newAdded[0], a = t.getLayout("points"), o = n && n.shape.points;
      if (o && o.length < 2e4) {
        var s = o.length, l = new Float32Array(s + a.length);
        l.set(o), l.set(a, s), n.endIndex = e.end, n.setShape({
          points: l
        });
      } else {
        this._newAdded = [];
        var u = this._create();
        u.startIndex = e.start, u.endIndex = e.end, u.incremental = !0, u.setShape({
          points: a
        }), this._setCommon(u, t, i);
      }
    }, r.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, r.prototype._create = function() {
      var e = new Tpe({
        cursor: "default"
      });
      return e.ignoreCoarsePointer = !0, this.group.add(e), this._newAdded.push(e), e;
    }, r.prototype._setCommon = function(e, t, i) {
      var n = t.hostModel;
      i = i || {};
      var a = t.getVisual("symbolSize");
      e.setShape("size", a instanceof Array ? a : [a, a]), e.softClipShape = i.clipShape || null, e.symbolProxy = Er(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor;
      var o = e.shape.size[0] < Q3;
      e.useStyle(
        // Draw shadow when doing fillRect is extremely slow.
        n.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"])
      );
      var s = t.getVisual("style"), l = s && s.fill;
      l && e.setColor(l);
      var u = Pe(e);
      u.seriesIndex = n.seriesIndex, e.on("mousemove", function(c) {
        u.dataIndex = null;
        var h = e.hoverDataIdx;
        h >= 0 && (u.dataIndex = h + (e.startIndex || 0));
      });
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
);
const Rpe = ype;
var Ape = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.updateData(a, {
        // TODO
        // If this parameter should be a shape or a bounding volume
        // shape will be more general.
        // But bounding volume like bounding rect will be much faster in the contain calculation
        clipShape: this._getClipShape(t)
      }), this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      var a = t.getData(), o = this._updateSymbolDraw(a, t);
      o.incrementalPrepareUpdate(a), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, i, n) {
      this._symbolDraw.incrementalUpdate(t, i.getData(), {
        clipShape: this._getClipShape(i)
      }), this._finished = t.end === i.getData().count();
    }, e.prototype.updateTransform = function(t, i, n) {
      var a = t.getData();
      if (this.group.dirty(), !this._finished || a.count() > 1e4)
        return {
          update: !0
        };
      var o = kv("").reset(t, i, n);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout(a);
    }, e.prototype.eachRendered = function(t) {
      this._symbolDraw && this._symbolDraw.eachRendered(t);
    }, e.prototype._getClipShape = function(t) {
      var i = t.coordinateSystem, n = i && i.getArea && i.getArea();
      return t.get("clip", !0) ? n : null;
    }, e.prototype._updateSymbolDraw = function(t, i) {
      var n = this._symbolDraw, a = i.pipelineContext, o = a.large;
      return (!n || o !== this._isLargeDraw) && (n && n.remove(), n = this._symbolDraw = o ? new Rpe() : new Mv(), this._isLargeDraw = o, this.group.removeAll()), this.group.add(n.group), n;
    }, e.prototype.remove = function(t, i) {
      this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null;
    }, e.prototype.dispose = function() {
    }, e.type = "scatter", e;
  }($t)
);
const _pe = Ape;
var Cpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.type = "grid", e.dependencies = ["xAxis", "yAxis"], e.layoutMode = "box", e.defaultOption = {
      show: !1,
      // zlevel: 0,
      z: 0,
      left: "10%",
      top: 60,
      right: "10%",
      bottom: 70,
      // If grid size contain label
      containLabel: !1,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      backgroundColor: "rgba(0,0,0,0)",
      borderWidth: 1,
      borderColor: "#ccc"
    }, e;
  }(st)
);
const Ipe = Cpe;
var xC = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("grid", Or).models[0];
    }, e.type = "cartesian2dAxis", e;
  }(st)
);
br(xC, Lv);
var U3 = {
  show: !0,
  // zlevel: 0,
  z: 0,
  // Inverse the axis.
  inverse: !1,
  // Axis name displayed.
  name: "",
  // 'start' | 'middle' | 'end'
  nameLocation: "end",
  // By degree. By default auto rotate by nameLocation.
  nameRotate: null,
  nameTruncate: {
    maxWidth: null,
    ellipsis: "...",
    placeholder: "."
  },
  // Use global text style by default.
  nameTextStyle: {},
  // The gap between axisName and axisLine.
  nameGap: 15,
  // Default `false` to support tooltip.
  silent: !1,
  // Default `false` to avoid legacy user event listener fail.
  triggerEvent: !1,
  tooltip: {
    show: !1
  },
  axisPointer: {},
  axisLine: {
    show: !0,
    onZero: !0,
    onZeroAxisIndex: null,
    lineStyle: {
      color: "#6E7079",
      width: 1,
      type: "solid"
    },
    // The arrow at both ends the the axis.
    symbol: ["none", "none"],
    symbolSize: [10, 15]
  },
  axisTick: {
    show: !0,
    // Whether axisTick is inside the grid or outside the grid.
    inside: !1,
    // The length of axisTick.
    length: 5,
    lineStyle: {
      width: 1
    }
  },
  axisLabel: {
    show: !0,
    // Whether axisLabel is inside the grid or outside the grid.
    inside: !1,
    rotate: 0,
    // true | false | null/undefined (auto)
    showMinLabel: null,
    // true | false | null/undefined (auto)
    showMaxLabel: null,
    margin: 8,
    // formatter: null,
    fontSize: 12
  },
  splitLine: {
    show: !0,
    lineStyle: {
      color: ["#E0E6F1"],
      width: 1,
      type: "solid"
    }
  },
  splitArea: {
    show: !1,
    areaStyle: {
      color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"]
    }
  }
}, wpe = $e({
  // The gap at both ends of the axis. For categoryAxis, boolean.
  boundaryGap: !0,
  // Set false to faster category collection.
  deduplication: null,
  // splitArea: {
  // show: false
  // },
  splitLine: {
    show: !1
  },
  axisTick: {
    // If tick is align with label when boundaryGap is true
    alignWithLabel: !1,
    interval: "auto"
  },
  axisLabel: {
    interval: "auto"
  }
}, U3), LN = $e({
  boundaryGap: [0, 0],
  axisLine: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  axisTick: {
    // Not shown when other axis is categoryAxis in cartesian
    show: "auto"
  },
  // TODO
  // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
  splitNumber: 5,
  minorTick: {
    // Minor tick, not available for cateogry axis.
    show: !1,
    // Split number of minor ticks. The value should be in range of (0, 100)
    splitNumber: 5,
    // Length of minor tick
    length: 3,
    // Line style
    lineStyle: {
      // Default to be same with axisTick
    }
  },
  minorSplitLine: {
    show: !1,
    lineStyle: {
      color: "#F4F7FD",
      width: 1
    }
  }
}, U3), Npe = $e({
  splitNumber: 6,
  axisLabel: {
    // To eliminate labels that are not nice
    showMinLabel: !1,
    showMaxLabel: !1,
    rich: {
      primary: {
        fontWeight: "bold"
      }
    }
  },
  splitLine: {
    show: !1
  }
}, LN), xpe = Te({
  logBase: 10
}, LN);
const $3 = {
  category: wpe,
  value: LN,
  time: Npe,
  log: xpe
};
var Ppe = {
  value: 1,
  category: 1,
  time: 1,
  log: 1
};
function Df(r, e, t, i) {
  N(Ppe, function(n, a) {
    var o = $e($e({}, $3[a], !0), i, !0), s = (
      /** @class */
      function(l) {
        $(u, l);
        function u() {
          var c = l !== null && l.apply(this, arguments) || this;
          return c.type = e + "Axis." + a, c;
        }
        return u.prototype.mergeDefaultAndTheme = function(c, h) {
          var f = Mg(this), d = f ? nd(c) : {}, p = h.getTheme();
          $e(c, p.get(a + "Axis")), $e(c, this.getDefaultOption()), c.type = LQ(c), f && Pl(c, d, f);
        }, u.prototype.optionUpdated = function() {
          var c = this.option;
          c.type === "category" && (this.__ordinalMeta = RC.createByAxisModel(this));
        }, u.prototype.getCategories = function(c) {
          var h = this.option;
          if (h.type === "category")
            return c ? h.data : this.__ordinalMeta.categories;
        }, u.prototype.getOrdinalMeta = function() {
          return this.__ordinalMeta;
        }, u.type = e + "Axis." + a, u.defaultOption = o, u;
      }(t)
    );
    r.registerComponentModel(s);
  }), r.registerSubTypeDefaulter(e + "Axis", LQ);
}
function LQ(r) {
  return r.type || (r.data ? "category" : "value");
}
var Lpe = (
  /** @class */
  function() {
    function r(e) {
      this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "";
    }
    return r.prototype.getAxis = function(e) {
      return this._axes[e];
    }, r.prototype.getAxes = function() {
      return Y(this._dimList, function(e) {
        return this._axes[e];
      }, this);
    }, r.prototype.getAxesByScale = function(e) {
      return e = e.toLowerCase(), At(this.getAxes(), function(t) {
        return t.scale.type === e;
      });
    }, r.prototype.addAxis = function(e) {
      var t = e.dim;
      this._axes[t] = e, this._dimList.push(t);
    }, r;
  }()
);
const Dpe = Lpe;
var PC = ["x", "y"];
function DQ(r) {
  return r.type === "interval" || r.type === "time";
}
var Mpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "cartesian2d", t.dimensions = PC, t;
    }
    return e.prototype.calcAffineTransform = function() {
      this._transform = this._invTransform = null;
      var t = this.getAxis("x").scale, i = this.getAxis("y").scale;
      if (!(!DQ(t) || !DQ(i))) {
        var n = t.getExtent(), a = i.getExtent(), o = this.dataToPoint([n[0], a[0]]), s = this.dataToPoint([n[1], a[1]]), l = n[1] - n[0], u = a[1] - a[0];
        if (!(!l || !u)) {
          var c = (s[0] - o[0]) / l, h = (s[1] - o[1]) / u, f = o[0] - n[0] * c, d = o[1] - a[0] * h, p = this._transform = [c, 0, 0, h, f, d];
          this._invTransform = qf([], p);
        }
      }
    }, e.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x");
    }, e.prototype.containPoint = function(t) {
      var i = this.getAxis("x"), n = this.getAxis("y");
      return i.contain(i.toLocalCoord(t[0])) && n.contain(n.toLocalCoord(t[1]));
    }, e.prototype.containData = function(t) {
      return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]);
    }, e.prototype.containZone = function(t, i) {
      var n = this.dataToPoint(t), a = this.dataToPoint(i), o = this.getArea(), s = new Ve(n[0], n[1], a[0] - n[0], a[1] - n[1]);
      return o.intersect(s);
    }, e.prototype.dataToPoint = function(t, i, n) {
      n = n || [];
      var a = t[0], o = t[1];
      if (this._transform && a != null && isFinite(a) && o != null && isFinite(o))
        return Kr(n, t, this._transform);
      var s = this.getAxis("x"), l = this.getAxis("y");
      return n[0] = s.toGlobalCoord(s.dataToCoord(a, i)), n[1] = l.toGlobalCoord(l.dataToCoord(o, i)), n;
    }, e.prototype.clampData = function(t, i) {
      var n = this.getAxis("x").scale, a = this.getAxis("y").scale, o = n.getExtent(), s = a.getExtent(), l = n.parse(t[0]), u = a.parse(t[1]);
      return i = i || [], i[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), i[1] = Math.min(Math.max(Math.min(s[0], s[1]), u), Math.max(s[0], s[1])), i;
    }, e.prototype.pointToData = function(t, i) {
      var n = [];
      if (this._invTransform)
        return Kr(n, t, this._invTransform);
      var a = this.getAxis("x"), o = this.getAxis("y");
      return n[0] = a.coordToData(a.toLocalCoord(t[0]), i), n[1] = o.coordToData(o.toLocalCoord(t[1]), i), n;
    }, e.prototype.getOtherAxis = function(t) {
      return this.getAxis(t.dim === "x" ? "y" : "x");
    }, e.prototype.getArea = function() {
      var t = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), n = Math.min(t[0], t[1]), a = Math.min(i[0], i[1]), o = Math.max(t[0], t[1]) - n, s = Math.max(i[0], i[1]) - a;
      return new Ve(n, a, o, s);
    }, e;
  }(Dpe)
), kpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n, a, o) {
      var s = r.call(this, t, i, n) || this;
      return s.index = 0, s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.getGlobalExtent = function(t) {
      var i = this.getExtent();
      return i[0] = this.toGlobalCoord(i[0]), i[1] = this.toGlobalCoord(i[1]), t && i[0] > i[1] && i.reverse(), i;
    }, e.prototype.pointToData = function(t, i) {
      return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), i);
    }, e.prototype.setCategorySortInfo = function(t) {
      if (this.type !== "category")
        return !1;
      this.model.option.categorySortInfo = t, this.scale.setSortInfo(t);
    }, e;
  }(Ma)
);
const Qpe = kpe;
function LC(r, e, t) {
  t = t || {};
  var i = r.coordinateSystem, n = e.axis, a = {}, o = n.getAxesOnZeroOf()[0], s = n.position, l = o ? "onZero" : s, u = n.dim, c = i.getRect(), h = [c.x, c.x + c.width, c.y, c.y + c.height], f = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, d = e.get("offset") || 0, p = u === "x" ? [h[2] - d, h[3] + d] : [h[0] - d, h[1] + d];
  if (o) {
    var g = o.toGlobalCoord(o.dataToCoord(0));
    p[f.onZero] = Math.max(Math.min(g, p[1]), p[0]);
  }
  a.position = [u === "y" ? p[f[l]] : h[0], u === "x" ? p[f[l]] : h[3]], a.rotation = Math.PI / 2 * (u === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  a.labelDirection = a.tickDirection = a.nameDirection = v[s], a.labelOffset = o ? p[f[s]] - p[f.onZero] : 0, e.get(["axisTick", "inside"]) && (a.tickDirection = -a.tickDirection), vr(t.labelInside, e.get(["axisLabel", "inside"])) && (a.labelDirection = -a.labelDirection);
  var O = e.get(["axisLabel", "rotate"]);
  return a.labelRotate = l === "top" ? -O : O, a.z2 = 1, a;
}
function MQ(r) {
  return r.get("coordinateSystem") === "cartesian2d";
}
function kQ(r) {
  var e = {
    xAxisModel: null,
    yAxisModel: null
  };
  return N(e, function(t, i) {
    var n = i.replace(/Model$/, ""), a = r.getReferringComponents(n, Or).models[0];
    if ({}.NODE_ENV !== "production" && !a)
      throw new Error(n + ' "' + Kn(r.get(n + "Index"), r.get(n + "Id"), 0) + '" not found');
    e[i] = a;
  }), e;
}
var iR = Math.log;
function V3(r, e, t) {
  var i = Dl.prototype, n = i.getTicks.call(t), a = i.getTicks.call(t, !0), o = n.length - 1, s = i.getInterval.call(t), l = Yz(r, e), u = l.extent, c = l.fixMin, h = l.fixMax;
  if (r.type === "log") {
    var f = iR(r.base);
    u = [iR(u[0]) / f, iR(u[1]) / f];
  }
  r.setExtent(u[0], u[1]), r.calcNiceExtent({
    splitNumber: o,
    fixMin: c,
    fixMax: h
  });
  var d = i.getExtent.call(r);
  c && (u[0] = d[0]), h && (u[1] = d[1]);
  var p = i.getInterval.call(r), g = u[0], v = u[1];
  if (c && h)
    p = (v - g) / o;
  else if (c)
    for (v = u[0] + p * o; v < u[1] && isFinite(v) && isFinite(u[1]); )
      p = F0(p), v = u[0] + p * o;
  else if (h)
    for (g = u[1] - p * o; g > u[0] && isFinite(g) && isFinite(u[0]); )
      p = F0(p), g = u[1] - p * o;
  else {
    var O = r.getTicks().length - 1;
    O > o && (p = F0(p));
    var m = p * o;
    v = Math.ceil(u[1] / p) * p, g = rr(v - m), g < 0 && u[0] >= 0 ? (g = 0, v = rr(m)) : v > 0 && u[1] <= 0 && (v = 0, g = -rr(m));
  }
  var E = (n[0].value - a[0].value) / s, b = (n[o].value - a[o].value) / s;
  if (i.setExtent.call(r, g + p * E, v + p * b), i.setInterval.call(r, p), (E || b) && i.setNiceExtent.call(r, g + p, v - p), {}.NODE_ENV !== "production") {
    var S = i.getTicks.call(r);
    S[1] && (!Che(p) || Z_(S[1].value) > Z_(p)) && tr(
      // eslint-disable-next-line
      "The ticks may be not readable when set min: " + e.get("min") + ", max: " + e.get("max") + " and alignTicks: true"
    );
  }
}
var Upe = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = PC, this._initCartesian(e, t, i), this.model = e;
    }
    return r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.update = function(e, t) {
      var i = this._axesMap;
      this._updateScale(e, this.model);
      function n(o) {
        var s, l = Ze(o), u = l.length;
        if (u) {
          for (var c = [], h = u - 1; h >= 0; h--) {
            var f = +l[h], d = o[f], p = d.model, g = d.scale;
            // Only value and log axis without interval support alignTicks.
            AC(g) && p.get("alignTicks") && p.get("interval") == null ? c.push(d) : (Pf(g, p), AC(g) && (s = d));
          }
          c.length && (s || (s = c.pop(), Pf(s.scale, s.model)), N(c, function(v) {
            V3(v.scale, v.model, s.scale);
          }));
        }
      }
      n(i.x), n(i.y);
      var a = {};
      N(i.x, function(o) {
        QQ(i, "y", o, a);
      }), N(i.y, function(o) {
        QQ(i, "x", o, a);
      }), this.resize(this.model, t);
    }, r.prototype.resize = function(e, t, i) {
      var n = e.getBoxLayoutParams(), a = !i && e.get("containLabel"), o = Ir(n, {
        width: t.getWidth(),
        height: t.getHeight()
      });
      this._rect = o;
      var s = this._axesList;
      l(), a && (N(s, function(u) {
        if (!u.model.get(["axisLabel", "inside"])) {
          var c = Khe(u);
          if (c) {
            var h = u.isHorizontal() ? "height" : "width", f = u.model.get(["axisLabel", "margin"]);
            o[h] -= c[h] + f, u.position === "top" ? o.y += c.height + f : u.position === "left" && (o.x += c.width + f);
          }
        }
      }), l()), N(this._coordsList, function(u) {
        u.calcAffineTransform();
      });
      function l() {
        N(s, function(u) {
          var c = u.isHorizontal(), h = c ? [0, o.width] : [0, o.height], f = u.inverse ? 1 : 0;
          u.setExtent(h[f], h[1 - f]), $pe(u, c ? o.x : o.y);
        });
      }
    }, r.prototype.getAxis = function(e, t) {
      var i = this._axesMap[e];
      if (i != null)
        return i[t || 0];
    }, r.prototype.getAxes = function() {
      return this._axesList.slice();
    }, r.prototype.getCartesian = function(e, t) {
      if (e != null && t != null) {
        var i = "x" + e + "y" + t;
        return this._coordsMap[i];
      }
      be(e) && (t = e.yAxisIndex, e = e.xAxisIndex);
      for (var n = 0, a = this._coordsList; n < a.length; n++)
        if (a[n].getAxis("x").index === e || a[n].getAxis("y").index === t)
          return a[n];
    }, r.prototype.getCartesians = function() {
      return this._coordsList.slice();
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = this._findConvertTarget(t);
      return n.cartesian ? n.cartesian.dataToPoint(i) : n.axis ? n.axis.toGlobalCoord(n.axis.dataToCoord(i)) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = this._findConvertTarget(t);
      return n.cartesian ? n.cartesian.pointToData(i) : n.axis ? n.axis.coordToData(n.axis.toLocalCoord(i)) : null;
    }, r.prototype._findConvertTarget = function(e) {
      var t = e.seriesModel, i = e.xAxisModel || t && t.getReferringComponents("xAxis", Or).models[0], n = e.yAxisModel || t && t.getReferringComponents("yAxis", Or).models[0], a = e.gridModel, o = this._coordsList, s, l;
      if (t)
        s = t.coordinateSystem, Fe(o, s) < 0 && (s = null);
      else if (i && n)
        s = this.getCartesian(i.componentIndex, n.componentIndex);
      else if (i)
        l = this.getAxis("x", i.componentIndex);
      else if (n)
        l = this.getAxis("y", n.componentIndex);
      else if (a) {
        var u = a.coordinateSystem;
        u === this && (s = this._coordsList[0]);
      }
      return {
        cartesian: s,
        axis: l
      };
    }, r.prototype.containPoint = function(e) {
      var t = this._coordsList[0];
      if (t)
        return t.containPoint(e);
    }, r.prototype._initCartesian = function(e, t, i) {
      var n = this, a = this, o = {
        left: !1,
        right: !1,
        top: !1,
        bottom: !1
      }, s = {
        x: {},
        y: {}
      }, l = {
        x: 0,
        y: 0
      };
      if (t.eachComponent("xAxis", u("x"), this), t.eachComponent("yAxis", u("y"), this), !l.x || !l.y) {
        this._axesMap = {}, this._axesList = [];
        return;
      }
      this._axesMap = s, N(s.x, function(c, h) {
        N(s.y, function(f, d) {
          var p = "x" + h + "y" + d, g = new Mpe(p);
          g.master = n, g.model = e, n._coordsMap[p] = g, n._coordsList.push(g), g.addAxis(c), g.addAxis(f);
        });
      });
      function u(c) {
        return function(h, f) {
          if (nR(h, e)) {
            var d = h.get("position");
            c === "x" ? d !== "top" && d !== "bottom" && (d = o.bottom ? "top" : "bottom") : d !== "left" && d !== "right" && (d = o.left ? "right" : "left"), o[d] = !0;
            var p = new Qpe(c, kT(h), [0, 0], h.get("type"), d), g = p.type === "category";
            p.onBand = g && h.get("boundaryGap"), p.inverse = h.get("inverse"), h.axis = p, p.model = h, p.grid = a, p.index = f, a._axesList.push(p), s[c][f] = p, l[c]++;
          }
        };
      }
    }, r.prototype._updateScale = function(e, t) {
      N(this._axesList, function(n) {
        if (n.scale.setExtent(1 / 0, -1 / 0), n.type === "category") {
          var a = n.model.get("categorySortInfo");
          n.scale.setSortInfo(a);
        }
      }), e.eachSeries(function(n) {
        if (MQ(n)) {
          var a = kQ(n), o = a.xAxisModel, s = a.yAxisModel;
          if (!nR(o, t) || !nR(s, t))
            return;
          var l = this.getCartesian(o.componentIndex, s.componentIndex), u = n.getData(), c = l.getAxis("x"), h = l.getAxis("y");
          i(u, c), i(u, h);
        }
      }, this);
      function i(n, a) {
        N(Rb(n, a.dim), function(o) {
          a.scale.unionExtentFromData(n, o);
        });
      }
    }, r.prototype.getTooltipAxes = function(e) {
      var t = [], i = [];
      return N(this.getCartesians(), function(n) {
        var a = e != null && e !== "auto" ? n.getAxis(e) : n.getBaseAxis(), o = n.getOtherAxis(a);
        Fe(t, a) < 0 && t.push(a), Fe(i, o) < 0 && i.push(o);
      }), {
        baseAxes: t,
        otherAxes: i
      };
    }, r.create = function(e, t) {
      var i = [];
      return e.eachComponent("grid", function(n, a) {
        var o = new r(n, e, t);
        o.name = "grid_" + a, o.resize(n, t, !0), n.coordinateSystem = o, i.push(o);
      }), e.eachSeries(function(n) {
        if (MQ(n)) {
          var a = kQ(n), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel();
          if ({}.NODE_ENV !== "production") {
            if (!l)
              throw new Error('Grid "' + Kn(o.get("gridIndex"), o.get("gridId"), 0) + '" not found');
            if (o.getCoordSysModel() !== s.getCoordSysModel())
              throw new Error("xAxis and yAxis must use the same grid");
          }
          var u = l.coordinateSystem;
          n.coordinateSystem = u.getCartesian(o.componentIndex, s.componentIndex);
        }
      }), i;
    }, r.dimensions = PC, r;
  }()
);
function nR(r, e) {
  return r.getCoordSysModel() === e;
}
function QQ(r, e, t, i) {
  t.getAxesOnZeroOf = function() {
    return a ? [a] : [];
  };
  var n = r[e], a, o = t.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]);
  if (!s)
    return;
  if (l != null)
    UQ(n[l]) && (a = n[l]);
  else
    for (var u in n)
      if (n.hasOwnProperty(u) && UQ(n[u]) && !i[c(n[u])]) {
        a = n[u];
        break;
      }
  a && (i[c(a)] = !0);
  function c(h) {
    return h.dim + "_" + h.index;
  }
}
function UQ(r) {
  return r && r.type !== "category" && r.type !== "time" && jhe(r);
}
function $pe(r, e) {
  var t = r.getExtent(), i = t[0] + t[1];
  r.toGlobalCoord = r.dim === "x" ? function(n) {
    return n + e;
  } : function(n) {
    return i - n + e;
  }, r.toLocalCoord = r.dim === "x" ? function(n) {
    return n - e;
  } : function(n) {
    return i - n + e;
  };
}
const Vpe = Upe;
var nl = Math.PI, mc = (
  /** @class */
  function() {
    function r(e, t) {
      this.group = new Re(), this.opt = t, this.axisModel = e, Te(t, {
        labelOffset: 0,
        nameDirection: 1,
        tickDirection: 1,
        labelDirection: 1,
        silent: !0,
        handleAutoShown: function() {
          return !0;
        }
      });
      var i = new Re({
        x: t.position[0],
        y: t.position[1],
        rotation: t.rotation
      });
      i.updateTransform(), this._transformGroup = i;
    }
    return r.prototype.hasBuilder = function(e) {
      return !!$Q[e];
    }, r.prototype.add = function(e) {
      $Q[e](this.opt, this.axisModel, this.group, this._transformGroup);
    }, r.prototype.getGroup = function() {
      return this.group;
    }, r.innerTextLayout = function(e, t, i) {
      var n = XY(t - e), a, o;
      return nb(n) ? (o = i > 0 ? "top" : "bottom", a = "center") : nb(n - nl) ? (o = i > 0 ? "bottom" : "top", a = "center") : (o = "middle", n > 0 && n < nl ? a = i > 0 ? "right" : "left" : a = i > 0 ? "left" : "right"), {
        rotation: n,
        textAlign: a,
        textVerticalAlign: o
      };
    }, r.makeAxisEventDataBase = function(e) {
      var t = {
        componentType: e.mainType,
        componentIndex: e.componentIndex
      };
      return t[e.mainType + "Index"] = e.componentIndex, t;
    }, r.isLabelSilent = function(e) {
      var t = e.get("tooltip");
      return e.get("silent") || !(e.get("triggerEvent") || t && t.show);
    }, r;
  }()
), $Q = {
  axisLine: function(r, e, t, i) {
    var n = e.get(["axisLine", "show"]);
    if (n === "auto" && r.handleAutoShown && (n = r.handleAutoShown("axisLine")), !!n) {
      var a = e.axis.getExtent(), o = i.transform, s = [a[0], 0], l = [a[1], 0], u = s[0] > l[0];
      o && (Kr(s, s, o), Kr(l, l, o));
      var c = B({
        lineCap: "round"
      }, e.getModel(["axisLine", "lineStyle"]).getLineStyle()), h = new Gr({
        shape: {
          x1: s[0],
          y1: s[1],
          x2: l[0],
          y2: l[1]
        },
        style: c,
        strokeContainThreshold: r.strokeContainThreshold || 5,
        silent: !0,
        z2: 1
      });
      wf(h.shape, h.style.lineWidth), h.anid = "line", t.add(h);
      var f = e.get(["axisLine", "symbol"]);
      if (f != null) {
        var d = e.get(["axisLine", "symbolSize"]);
        ne(f) && (f = [f, f]), (ne(d) || pt(d)) && (d = [d, d]);
        var p = qc(e.get(["axisLine", "symbolOffset"]) || 0, d), g = d[0], v = d[1];
        N([{
          rotate: r.rotation + Math.PI / 2,
          offset: p[0],
          r: 0
        }, {
          rotate: r.rotation - Math.PI / 2,
          offset: p[1],
          r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1]))
        }], function(O, m) {
          if (f[m] !== "none" && f[m] != null) {
            var E = Er(f[m], -g / 2, -v / 2, g, v, c.stroke, !0), b = O.r + O.offset, S = u ? l : s;
            E.attr({
              rotation: O.rotate,
              x: S[0] + b * Math.cos(r.rotation),
              y: S[1] - b * Math.sin(r.rotation),
              silent: !0,
              z2: 11
            }), t.add(E);
          }
        });
      }
    }
  },
  axisTickLabel: function(r, e, t, i) {
    var n = Fpe(t, i, e, r), a = Ype(t, i, e, r);
    if (Bpe(e, a, n), Xpe(t, i, e, r.tickDirection), e.get(["axisLabel", "hideOverlap"])) {
      var o = n3(Y(a, function(s) {
        return {
          label: s,
          priority: s.z2,
          defaultAttr: {
            ignore: s.ignore
          }
        };
      }));
      s3(o);
    }
  },
  axisName: function(r, e, t, i) {
    var n = vr(r.axisName, e.get("name"));
    if (n) {
      var a = e.get("nameLocation"), o = r.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, u = e.axis.getExtent(), c = u[0] > u[1] ? -1 : 1, h = [
        a === "start" ? u[0] - c * l : a === "end" ? u[1] + c * l : (u[0] + u[1]) / 2,
        // Reuse labelOffset.
        GQ(a) ? r.labelOffset + o * l : 0
      ], f, d = e.get("nameRotate");
      d != null && (d = d * nl / 180);
      var p;
      GQ(a) ? f = mc.innerTextLayout(
        r.rotation,
        d ?? r.rotation,
        // Adapt to axis.
        o
      ) : (f = Gpe(r.rotation, a, d || 0, u), p = r.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(f.rotation)), !isFinite(p) && (p = null)));
      var g = s.getFont(), v = e.get("nameTruncate", !0) || {}, O = v.ellipsis, m = vr(r.nameTruncateMaxWidth, v.maxWidth, p), E = new dt({
        x: h[0],
        y: h[1],
        rotation: f.rotation,
        silent: mc.isLabelSilent(e),
        style: Qt(s, {
          text: n,
          font: g,
          overflow: "truncate",
          width: m,
          ellipsis: O,
          fill: s.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          align: s.get("align") || f.textAlign,
          verticalAlign: s.get("verticalAlign") || f.textVerticalAlign
        }),
        z2: 1
      });
      if (ed({
        el: E,
        componentModel: e,
        itemName: n
      }), E.__fullText = n, E.anid = "name", e.get("triggerEvent")) {
        var b = mc.makeAxisEventDataBase(e);
        b.targetType = "axisName", b.name = n, Pe(E).eventData = b;
      }
      i.add(E), E.updateTransform(), t.add(E), E.decomposeTransform();
    }
  }
};
function Gpe(r, e, t, i) {
  var n = XY(t - r), a, o, s = i[0] > i[1], l = e === "start" && !s || e !== "start" && s;
  return nb(n - nl / 2) ? (o = l ? "bottom" : "top", a = "center") : nb(n - nl * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", n < nl * 1.5 && n > nl / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: n,
    textAlign: a,
    textVerticalAlign: o
  };
}
function Bpe(r, e, t) {
  if (!Hz(r.axis)) {
    var i = r.get(["axisLabel", "showMinLabel"]), n = r.get(["axisLabel", "showMaxLabel"]);
    e = e || [], t = t || [];
    var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], u = t[0], c = t[1], h = t[t.length - 1], f = t[t.length - 2];
    i === !1 ? (Pn(a), Pn(u)) : VQ(a, o) && (i ? (Pn(o), Pn(c)) : (Pn(a), Pn(u))), n === !1 ? (Pn(s), Pn(h)) : VQ(l, s) && (n ? (Pn(l), Pn(f)) : (Pn(s), Pn(h)));
  }
}
function Pn(r) {
  r && (r.ignore = !0);
}
function VQ(r, e) {
  var t = r && r.getBoundingRect().clone(), i = e && e.getBoundingRect().clone();
  if (!(!t || !i)) {
    var n = sT([]);
    return zc(n, n, -r.rotation), t.applyTransform(qo([], n, r.getLocalTransform())), i.applyTransform(qo([], n, e.getLocalTransform())), t.intersect(i);
  }
}
function GQ(r) {
  return r === "middle" || r === "center";
}
function G3(r, e, t, i, n) {
  for (var a = [], o = [], s = [], l = 0; l < r.length; l++) {
    var u = r[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = t, e && (Kr(o, o, e), Kr(s, s, e));
    var c = new Gr({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: i,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    wf(c.shape, c.style.lineWidth), c.anid = n + "_" + r[l].tickValue, a.push(c);
  }
  return a;
}
function Fpe(r, e, t, i) {
  var n = t.axis, a = t.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && i.handleAutoShown && (o = i.handleAutoShown("axisTick")), !(!o || n.scale.isBlank())) {
    for (var s = a.getModel("lineStyle"), l = i.tickDirection * a.get("length"), u = n.getTicksCoords(), c = G3(u, e.transform, l, Te(s.getLineStyle(), {
      stroke: t.get(["axisLine", "lineStyle", "color"])
    }), "ticks"), h = 0; h < c.length; h++)
      r.add(c[h]);
    return c;
  }
}
function Xpe(r, e, t, i) {
  var n = t.axis, a = t.getModel("minorTick");
  if (!(!a.get("show") || n.scale.isBlank())) {
    var o = n.getMinorTicksCoords();
    if (o.length)
      for (var s = a.getModel("lineStyle"), l = i * a.get("length"), u = Te(s.getLineStyle(), Te(t.getModel("axisTick").getLineStyle(), {
        stroke: t.get(["axisLine", "lineStyle", "color"])
      })), c = 0; c < o.length; c++)
        for (var h = G3(o[c], e.transform, l, u, "minorticks_" + c), f = 0; f < h.length; f++)
          r.add(h[f]);
  }
}
function Ype(r, e, t, i) {
  var n = t.axis, a = vr(i.axisLabelShow, t.get(["axisLabel", "show"]));
  if (!(!a || n.scale.isBlank())) {
    var o = t.getModel("axisLabel"), s = o.get("margin"), l = n.getViewLabels(), u = (vr(i.labelRotate, o.get("rotate")) || 0) * nl / 180, c = mc.innerTextLayout(i.rotation, u, i.labelDirection), h = t.getCategories && t.getCategories(!0), f = [], d = mc.isLabelSilent(t), p = t.get("triggerEvent");
    return N(l, function(g, v) {
      var O = n.scale.type === "ordinal" ? n.scale.getRawOrdinalNumber(g.tickValue) : g.tickValue, m = g.formattedLabel, E = g.rawLabel, b = o;
      if (h && h[O]) {
        var S = h[O];
        be(S) && S.textStyle && (b = new Ut(S.textStyle, o, t.ecModel));
      }
      var T = b.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), y = n.dataToCoord(O), R = new dt({
        x: y,
        y: i.labelOffset + i.labelDirection * s,
        rotation: c.rotation,
        silent: d,
        z2: 10 + (g.level || 0),
        style: Qt(b, {
          text: m,
          align: b.getShallow("align", !0) || c.textAlign,
          verticalAlign: b.getShallow("verticalAlign", !0) || b.getShallow("baseline", !0) || c.textVerticalAlign,
          fill: ve(T) ? T(
            // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user replace ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            n.type === "category" ? E : n.type === "value" ? O + "" : O,
            v
          ) : T
        })
      });
      if (R.anid = "label_" + O, p) {
        var _ = mc.makeAxisEventDataBase(t);
        _.targetType = "axisLabel", _.value = E, _.tickIndex = v, n.type === "category" && (_.dataIndex = O), Pe(R).eventData = _;
      }
      e.add(R), R.updateTransform(), f.push(R), r.add(R), R.decomposeTransform();
    }), f;
  }
}
const hs = mc;
function Hpe(r, e) {
  var t = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return Wpe(t, r, e), t.seriesInvolved && Zpe(t, r), t;
}
function Wpe(r, e, t) {
  var i = e.getComponent("tooltip"), n = e.getComponent("axisPointer"), a = n.get("link", !0) || [], o = [];
  N(t.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = Fg(s.model), u = r.coordSysAxesInfo[l] = {};
    r.coordSysMap[l] = s;
    var c = s.model, h = c.getModel("tooltip", i);
    if (N(s.getAxes(), Le(g, !1, null)), s.getTooltipAxes && i && h.get("show")) {
      var f = h.get("trigger") === "axis", d = h.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(h.get(["axisPointer", "axis"]));
      (f || d) && N(p.baseAxes, Le(g, d ? "cross" : !0, f)), d && N(p.otherAxes, Le(g, "cross", !1));
    }
    function g(v, O, m) {
      var E = m.model.getModel("axisPointer", n), b = E.get("show");
      if (!(!b || b === "auto" && !v && !DC(E))) {
        O == null && (O = E.get("triggerTooltip")), E = v ? zpe(m, h, n, e, v, O) : E;
        var S = E.get("snap"), T = E.get("triggerEmphasis"), y = Fg(m.model), R = O || S || m.type === "category", _ = r.axesInfo[y] = {
          key: y,
          axis: m,
          coordSys: s,
          axisPointerModel: E,
          triggerTooltip: O,
          triggerEmphasis: T,
          involveSeries: R,
          snap: S,
          useHandle: DC(E),
          seriesModels: [],
          linkGroup: null
        };
        u[y] = _, r.seriesInvolved = r.seriesInvolved || R;
        var C = qpe(a, m);
        if (C != null) {
          var I = o[C] || (o[C] = {
            axesInfo: {}
          });
          I.axesInfo[y] = _, I.mapper = a[C].mapper, _.linkGroup = I;
        }
      }
    }
  });
}
function zpe(r, e, t, i, n, a) {
  var o = e.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  N(s, function(f) {
    l[f] = ye(o.get(f));
  }), l.snap = r.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), n === "cross") {
    var c = o.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var h = l.lineStyle = o.get("crossStyle");
      h && Te(u, h.textStyle);
    }
  }
  return r.model.getModel("axisPointer", new Ut(l, t, i));
}
function Zpe(r, e) {
  e.eachSeries(function(t) {
    var i = t.coordinateSystem, n = t.get(["tooltip", "trigger"], !0), a = t.get(["tooltip", "show"], !0);
    !i || n === "none" || n === !1 || n === "item" || a === !1 || t.get(["axisPointer", "show"], !0) === !1 || N(r.coordSysAxesInfo[Fg(i.model)], function(o) {
      var s = o.axis;
      i.getAxis(s.dim) === s && (o.seriesModels.push(t), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += t.getData().count());
    });
  });
}
function qpe(r, e) {
  for (var t = e.model, i = e.dim, n = 0; n < r.length; n++) {
    var a = r[n] || {};
    if (aR(a[i + "AxisId"], t.id) || aR(a[i + "AxisIndex"], t.componentIndex) || aR(a[i + "AxisName"], t.name))
      return n;
  }
}
function aR(r, e) {
  return r === "all" || X(r) && Fe(r, e) >= 0 || r === e;
}
function jpe(r) {
  var e = DN(r);
  if (e) {
    var t = e.axisPointerModel, i = e.axis.scale, n = t.option, a = t.get("status"), o = t.get("value");
    o != null && (o = i.parse(o));
    var s = DC(t);
    a == null && (n.status = s ? "show" : "hide");
    var l = i.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), n.value = o, s && (n.status = e.axis.scale.isBlank() ? "hide" : "show");
  }
}
function DN(r) {
  var e = (r.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return e && e.axesInfo[Fg(r)];
}
function Kpe(r) {
  var e = DN(r);
  return e && e.axisPointerModel;
}
function DC(r) {
  return !!r.get(["handle", "show"]);
}
function Fg(r) {
  return r.type + "||" + r.id;
}
var oR = {}, Jpe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this.axisPointerClass && jpe(t), r.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, n, !0);
    }, e.prototype.updateAxisPointer = function(t, i, n, a) {
      this._doUpdateAxisPointerClass(t, n, !1);
    }, e.prototype.remove = function(t, i) {
      var n = this._axisPointer;
      n && n.remove(i);
    }, e.prototype.dispose = function(t, i) {
      this._disposeAxisPointer(i), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._doUpdateAxisPointerClass = function(t, i, n) {
      var a = e.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = Kpe(t);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(t, o, i, n) : this._disposeAxisPointer(i);
      }
    }, e.prototype._disposeAxisPointer = function(t) {
      this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null;
    }, e.registerAxisPointerClass = function(t, i) {
      if ({}.NODE_ENV !== "production" && oR[t])
        throw new Error("axisPointer " + t + " exists");
      oR[t] = i;
    }, e.getAxisPointerClass = function(t) {
      return t && oR[t];
    }, e.type = "axis", e;
  }(jt)
);
const Jc = Jpe;
var MC = ft();
function B3(r, e, t, i) {
  var n = t.axis;
  if (!n.scale.isBlank()) {
    var a = t.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = i.coordinateSystem.getRect(), u = n.getTicksCoords({
      tickModel: a,
      clamp: !0
    });
    if (u.length) {
      var c = s.length, h = MC(r).splitAreaColors, f = de(), d = 0;
      if (h)
        for (var p = 0; p < u.length; p++) {
          var g = h.get(u[p].tickValue);
          if (g != null) {
            d = (g + (c - 1) * p) % c;
            break;
          }
        }
      var v = n.toGlobalCoord(u[0].coord), O = o.getAreaStyle();
      s = X(s) ? s : [s];
      for (var p = 1; p < u.length; p++) {
        var m = n.toGlobalCoord(u[p].coord), E = void 0, b = void 0, S = void 0, T = void 0;
        n.isHorizontal() ? (E = v, b = l.y, S = m - E, T = l.height, v = E + S) : (E = l.x, b = v, S = l.width, T = m - b, v = b + T);
        var y = u[p - 1].tickValue;
        y != null && f.set(y, d), e.add(new ht({
          anid: y != null ? "area_" + y : null,
          shape: {
            x: E,
            y: b,
            width: S,
            height: T
          },
          style: Te({
            fill: s[d]
          }, O),
          autoBatch: !0,
          silent: !0
        })), d = (d + 1) % c;
      }
      MC(r).splitAreaColors = f;
    }
  }
}
function F3(r) {
  MC(r).splitAreaColors = null;
}
var ege = ["axisLine", "axisTickLabel", "axisName"], tge = ["splitArea", "splitLine", "minorSplitLine"], X3 = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this.group.removeAll();
      var o = this._axisGroup;
      if (this._axisGroup = new Re(), this.group.add(this._axisGroup), !!t.get("show")) {
        var s = t.getCoordSysModel(), l = LC(s, t), u = new hs(t, B({
          handleAutoShown: function(h) {
            for (var f = s.coordinateSystem.getCartesians(), d = 0; d < f.length; d++)
              if (AC(f[d].getOtherAxis(t.axis).scale))
                return !0;
            return !1;
          }
        }, l));
        N(ege, u.add, u), this._axisGroup.add(u.getGroup()), N(tge, function(h) {
          t.get([h, "show"]) && rge[h](this, this._axisGroup, t, s);
        }, this);
        var c = a && a.type === "changeAxisOrder" && a.isInitSort;
        c || Cv(o, this._axisGroup, t), r.prototype.render.call(this, t, i, n, a);
      }
    }, e.prototype.remove = function() {
      F3(this);
    }, e.type = "cartesianAxis", e;
  }(Jc)
), rge = {
  splitLine: function(r, e, t, i) {
    var n = t.axis;
    if (!n.scale.isBlank()) {
      var a = t.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
      s = X(s) ? s : [s];
      for (var l = i.coordinateSystem.getRect(), u = n.isHorizontal(), c = 0, h = n.getTicksCoords({
        tickModel: a
      }), f = [], d = [], p = o.getLineStyle(), g = 0; g < h.length; g++) {
        var v = n.toGlobalCoord(h[g].coord);
        u ? (f[0] = v, f[1] = l.y, d[0] = v, d[1] = l.y + l.height) : (f[0] = l.x, f[1] = v, d[0] = l.x + l.width, d[1] = v);
        var O = c++ % s.length, m = h[g].tickValue, E = new Gr({
          anid: m != null ? "line_" + h[g].tickValue : null,
          autoBatch: !0,
          shape: {
            x1: f[0],
            y1: f[1],
            x2: d[0],
            y2: d[1]
          },
          style: Te({
            stroke: s[O]
          }, p),
          silent: !0
        });
        wf(E.shape, p.lineWidth), e.add(E);
      }
    }
  },
  minorSplitLine: function(r, e, t, i) {
    var n = t.axis, a = t.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = i.coordinateSystem.getRect(), l = n.isHorizontal(), u = n.getMinorTicksCoords();
    if (u.length)
      for (var c = [], h = [], f = o.getLineStyle(), d = 0; d < u.length; d++)
        for (var p = 0; p < u[d].length; p++) {
          var g = n.toGlobalCoord(u[d][p].coord);
          l ? (c[0] = g, c[1] = s.y, h[0] = g, h[1] = s.y + s.height) : (c[0] = s.x, c[1] = g, h[0] = s.x + s.width, h[1] = g);
          var v = new Gr({
            anid: "minor_line_" + u[d][p].tickValue,
            autoBatch: !0,
            shape: {
              x1: c[0],
              y1: c[1],
              x2: h[0],
              y2: h[1]
            },
            style: f,
            silent: !0
          });
          wf(v.shape, f.lineWidth), e.add(v);
        }
  },
  splitArea: function(r, e, t, i) {
    B3(r, e, t, i);
  }
}, Y3 = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "xAxis", e;
  }(X3)
), ige = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = Y3.type, t;
    }
    return e.type = "yAxis", e;
  }(X3)
), nge = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "grid", t;
    }
    return e.prototype.render = function(t, i) {
      this.group.removeAll(), t.get("show") && this.group.add(new ht({
        shape: t.coordinateSystem.getRect(),
        style: Te({
          fill: t.get("backgroundColor")
        }, t.getItemStyle()),
        silent: !0,
        z2: -1
      }));
    }, e.type = "grid", e;
  }(jt)
), BQ = {
  // gridIndex: 0,
  // gridId: '',
  offset: 0
};
function H3(r) {
  r.registerComponentView(nge), r.registerComponentModel(Ipe), r.registerCoordinateSystem("cartesian2d", Vpe), Df(r, "x", xC, BQ), Df(r, "y", xC, BQ), r.registerComponentView(Y3), r.registerComponentView(ige), r.registerPreprocessor(function(e) {
    e.xAxis && e.yAxis && !e.grid && (e.grid = {});
  });
}
function age(r) {
  Ye(H3), r.registerSeriesModel(bpe), r.registerChartView(_pe), r.registerLayout(kv("scatter"));
}
function oge(r) {
  r.eachSeriesByType("radar", function(e) {
    var t = e.getData(), i = [], n = e.coordinateSystem;
    if (n) {
      var a = n.getIndicatorAxes();
      N(a, function(o, s) {
        t.each(t.mapDimension(a[s].dim), function(l, u) {
          i[u] = i[u] || [];
          var c = n.dataToPoint(l, s);
          i[u][s] = FQ(c) ? c : XQ(n);
        });
      }), t.each(function(o) {
        var s = Hie(i[o], function(l) {
          return FQ(l);
        }) || XQ(n);
        i[o].push(s.slice()), t.setItemLayout(o, i[o]);
      });
    }
  });
}
function FQ(r) {
  return !isNaN(r[0]) && !isNaN(r[1]);
}
function XQ(r) {
  return [r.cx, r.cy];
}
function sge(r) {
  var e = r.polar;
  if (e) {
    X(e) || (e = [e]);
    var t = [];
    N(e, function(i, n) {
      i.indicator ? (i.type && !i.shape && (i.shape = i.type), r.radar = r.radar || [], X(r.radar) || (r.radar = [r.radar]), r.radar.push(i)) : t.push(i);
    }), r.polar = t;
  }
  N(r.series, function(i) {
    i && i.type === "radar" && i.polarIndex && (i.radarIndex = i.polarIndex);
  });
}
var lge = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.coordinateSystem, o = this.group, s = t.getData(), l = this._data;
      function u(f, d) {
        var p = f.getItemVisual(d, "symbol") || "circle";
        if (p !== "none") {
          var g = cd(f.getItemVisual(d, "symbolSize")), v = Er(p, -1, -1, 2, 2), O = f.getItemVisual(d, "symbolRotate") || 0;
          return v.attr({
            style: {
              strokeNoScale: !0
            },
            z2: 100,
            scaleX: g[0] / 2,
            scaleY: g[1] / 2,
            rotation: O * Math.PI / 180 || 0
          }), v;
        }
      }
      function c(f, d, p, g, v, O) {
        p.removeAll();
        for (var m = 0; m < d.length - 1; m++) {
          var E = u(g, v);
          E && (E.__dimIdx = m, f[m] ? (E.setPosition(f[m]), wv[O ? "initProps" : "updateProps"](E, {
            x: d[m][0],
            y: d[m][1]
          }, t, v)) : E.setPosition(d[m]), p.add(E));
        }
      }
      function h(f) {
        return Y(f, function(d) {
          return [a.cx, a.cy];
        });
      }
      s.diff(l).add(function(f) {
        var d = s.getItemLayout(f);
        if (d) {
          var p = new rn(), g = new nn(), v = {
            shape: {
              points: d
            }
          };
          p.shape.points = h(d), g.shape.points = h(d), Bt(p, v, t, f), Bt(g, v, t, f);
          var O = new Re(), m = new Re();
          O.add(g), O.add(p), O.add(m), c(g.shape.points, d, m, s, f, !0), s.setItemGraphicEl(f, O);
        }
      }).update(function(f, d) {
        var p = l.getItemGraphicEl(d), g = p.childAt(0), v = p.childAt(1), O = p.childAt(2), m = {
          shape: {
            points: s.getItemLayout(f)
          }
        };
        m.shape.points && (c(g.shape.points, m.shape.points, O, s, f, !1), La(v), La(g), Ot(g, m, t), Ot(v, m, t), s.setItemGraphicEl(f, p));
      }).remove(function(f) {
        o.remove(l.getItemGraphicEl(f));
      }).execute(), s.eachItemGraphicEl(function(f, d) {
        var p = s.getItemModel(d), g = f.childAt(0), v = f.childAt(1), O = f.childAt(2), m = s.getItemVisual(d, "style"), E = m.fill;
        o.add(f), g.useStyle(Te(p.getModel("lineStyle").getLineStyle(), {
          fill: "none",
          stroke: E
        })), ri(g, p, "lineStyle"), ri(v, p, "areaStyle");
        var b = p.getModel("areaStyle"), S = b.isEmpty() && b.parentModel.isEmpty();
        v.ignore = S, N(["emphasis", "select", "blur"], function(R) {
          var _ = p.getModel([R, "areaStyle"]), C = _.isEmpty() && _.parentModel.isEmpty();
          v.ensureState(R).ignore = C && S;
        }), v.useStyle(Te(b.getAreaStyle(), {
          fill: E,
          opacity: 0.7,
          decal: m.decal
        }));
        var T = p.getModel("emphasis"), y = T.getModel("itemStyle").getItemStyle();
        O.eachChild(function(R) {
          if (R instanceof ni) {
            var _ = R.style;
            R.useStyle(B({
              // TODO other properties like x, y ?
              image: _.image,
              x: _.x,
              y: _.y,
              width: _.width,
              height: _.height
            }, m));
          } else
            R.useStyle(m), R.setColor(E), R.style.strokeNoScale = !0;
          var C = R.ensureState("emphasis");
          C.style = ye(y);
          var I = s.getStore().get(s.getDimensionIndex(R.__dimIdx), d);
          (I == null || isNaN(I)) && (I = ""), ii(R, kr(p), {
            labelFetcher: s.hostModel,
            labelDataIndex: d,
            labelDimIndex: R.__dimIdx,
            defaultText: I,
            inheritColor: E,
            defaultOpacity: m.opacity
          });
        }), qt(f, T.get("focus"), T.get("blurScope"), T.get("disabled"));
      }), this._data = s;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "radar", e;
  }($t)
);
const uge = lge;
var cge = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Uv(ue(this.getData, this), ue(this.getRawData, this));
    }, e.prototype.getInitialData = function(t, i) {
      return hd(this, {
        generateCoord: "indicator_",
        generateCoordCount: 1 / 0
      });
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(t), u = l === "" ? this.name : l, c = YW(this, t);
      return Qr("section", {
        header: u,
        sortBlocks: !0,
        blocks: Y(s, function(h) {
          var f = a.get(a.mapDimension(h.dim), t);
          return Qr("nameValue", {
            markerType: "subItem",
            markerColor: c,
            name: h.name,
            value: f,
            sortParam: f
          });
        })
      });
    }, e.prototype.getTooltipPosition = function(t) {
      if (t != null) {
        for (var i = this.getData(), n = this.coordinateSystem, a = i.getValues(Y(n.dimensions, function(u) {
          return i.mapDimension(u);
        }), t), o = 0, s = a.length; o < s; o++)
          if (!isNaN(a[o])) {
            var l = n.getIndicatorAxes();
            return n.coordToPoint(l[o].dataToCoord(a[o]), o);
          }
      }
    }, e.type = "series.radar", e.dependencies = ["radar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "radar",
      legendHoverLink: !0,
      radarIndex: 0,
      lineStyle: {
        width: 2,
        type: "solid",
        join: "round"
      },
      label: {
        position: "top"
      },
      // areaStyle: {
      // },
      // itemStyle: {}
      symbolSize: 8
      // symbolRotate: null
    }, e;
  }(Wt)
);
const hge = cge;
var Xd = $3.value;
function JO(r, e) {
  return Te({
    show: e
  }, r);
}
var fge = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      var t = this.get("boundaryGap"), i = this.get("splitNumber"), n = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), u = this.get(["axisName", "show"]), c = this.get(["axisName", "formatter"]), h = this.get("axisNameGap"), f = this.get("triggerEvent"), d = Y(this.get("indicator") || [], function(p) {
        p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0);
        var g = l;
        p.color != null && (g = Te({
          color: p.color
        }, l));
        var v = $e(ye(p), {
          boundaryGap: t,
          splitNumber: i,
          scale: n,
          axisLine: a,
          axisTick: o,
          // axisType: axisType,
          axisLabel: s,
          // Compatible with 2 and use text
          name: p.text,
          showName: u,
          nameLocation: "end",
          nameGap: h,
          // min: 0,
          nameTextStyle: g,
          triggerEvent: f
        }, !1);
        if (ne(c)) {
          var O = v.name;
          v.name = c.replace("{value}", O ?? "");
        } else
          ve(c) && (v.name = c(v.name, v));
        var m = new Ut(v, null, this.ecModel);
        return br(m, Lv.prototype), m.mainType = "radar", m.componentIndex = this.componentIndex, m;
      }, this);
      this._indicatorModels = d;
    }, e.prototype.getIndicatorModels = function() {
      return this._indicatorModels;
    }, e.type = "radar", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "75%",
      startAngle: 90,
      axisName: {
        show: !0
        // formatter: null
        // textStyle: {}
      },
      boundaryGap: [0, 0],
      splitNumber: 5,
      axisNameGap: 15,
      scale: !1,
      // Polygon or circle
      shape: "polygon",
      axisLine: $e({
        lineStyle: {
          color: "#bbb"
        }
      }, Xd.axisLine),
      axisLabel: JO(Xd.axisLabel, !1),
      axisTick: JO(Xd.axisTick, !1),
      // axisType: 'value',
      splitLine: JO(Xd.splitLine, !0),
      splitArea: JO(Xd.splitArea, !0),
      // {text, min, max}
      indicator: []
    }, e;
  }(st)
);
const dge = fge;
var pge = ["axisLine", "axisTickLabel", "axisName"], gge = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this.group;
      a.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t);
    }, e.prototype._buildAxes = function(t) {
      var i = t.coordinateSystem, n = i.getIndicatorAxes(), a = Y(n, function(o) {
        var s = o.model.get("showName") ? o.name : "", l = new hs(o.model, {
          axisName: s,
          position: [i.cx, i.cy],
          rotation: o.angle,
          labelDirection: -1,
          tickDirection: -1,
          nameDirection: 1
        });
        return l;
      });
      N(a, function(o) {
        N(pge, o.add, o), this.group.add(o.getGroup());
      }, this);
    }, e.prototype._buildSplitLineAndArea = function(t) {
      var i = t.coordinateSystem, n = i.getIndicatorAxes();
      if (!n.length)
        return;
      var a = t.get("shape"), o = t.getModel("splitLine"), s = t.getModel("splitArea"), l = o.getModel("lineStyle"), u = s.getModel("areaStyle"), c = o.get("show"), h = s.get("show"), f = l.get("color"), d = u.get("color"), p = X(f) ? f : [f], g = X(d) ? d : [d], v = [], O = [];
      function m(L, D, U) {
        var Q = U % D.length;
        return L[Q] = L[Q] || [], Q;
      }
      if (a === "circle")
        for (var E = n[0].getTicksCoords(), b = i.cx, S = i.cy, T = 0; T < E.length; T++) {
          if (c) {
            var y = m(v, p, T);
            v[y].push(new Co({
              shape: {
                cx: b,
                cy: S,
                r: E[T].coord
              }
            }));
          }
          if (h && T < E.length - 1) {
            var y = m(O, g, T);
            O[y].push(new mT({
              shape: {
                cx: b,
                cy: S,
                r0: E[T].coord,
                r: E[T + 1].coord
              }
            }));
          }
        }
      else
        for (var R, _ = Y(n, function(L, D) {
          var U = L.getTicksCoords();
          return R = R == null ? U.length - 1 : Math.min(U.length - 1, R), Y(U, function(Q) {
            return i.coordToPoint(Q.coord, D);
          });
        }), C = [], T = 0; T <= R; T++) {
          for (var I = [], w = 0; w < n.length; w++)
            I.push(_[w][T]);
          if (I[0] ? I.push(I[0].slice()) : {}.NODE_ENV !== "production" && console.error("Can't draw value axis " + T), c) {
            var y = m(v, p, T);
            v[y].push(new nn({
              shape: {
                points: I
              }
            }));
          }
          if (h && C) {
            var y = m(O, g, T - 1);
            O[y].push(new rn({
              shape: {
                points: I.concat(C)
              }
            }));
          }
          C = I.slice().reverse();
        }
      var x = l.getLineStyle(), P = u.getAreaStyle();
      N(O, function(L, D) {
        this.group.add(Xn(L, {
          style: Te({
            stroke: "none",
            fill: g[D % g.length]
          }, P),
          silent: !0
        }));
      }, this), N(v, function(L, D) {
        this.group.add(Xn(L, {
          style: Te({
            fill: "none",
            stroke: p[D % p.length]
          }, x),
          silent: !0
        }));
      }, this);
    }, e.type = "radar", e;
  }(jt)
);
const vge = gge;
var Oge = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this, t, i, n) || this;
      return a.type = "value", a.angle = 0, a.name = "", a;
    }
    return e;
  }(Ma)
);
const mge = Oge;
var Ege = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.dimensions = [], this._model = e, this._indicatorAxes = Y(e.getIndicatorModels(), function(n, a) {
        var o = "indicator_" + a, s = new mge(
          o,
          new Dl()
          // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
        );
        return s.name = n.get("name"), s.model = n, n.axis = s, this.dimensions.push(o), s;
      }, this), this.resize(e, i);
    }
    return r.prototype.getIndicatorAxes = function() {
      return this._indicatorAxes;
    }, r.prototype.dataToPoint = function(e, t) {
      var i = this._indicatorAxes[t];
      return this.coordToPoint(i.dataToCoord(e), t);
    }, r.prototype.coordToPoint = function(e, t) {
      var i = this._indicatorAxes[t], n = i.angle, a = this.cx + e * Math.cos(n), o = this.cy - e * Math.sin(n);
      return [a, o];
    }, r.prototype.pointToData = function(e) {
      var t = e[0] - this.cx, i = e[1] - this.cy, n = Math.sqrt(t * t + i * i);
      t /= n, i /= n;
      for (var a = Math.atan2(-i, t), o = 1 / 0, s, l = -1, u = 0; u < this._indicatorAxes.length; u++) {
        var c = this._indicatorAxes[u], h = Math.abs(a - c.angle);
        h < o && (s = c, l = u, o = h);
      }
      return [l, +(s && s.coordToData(n))];
    }, r.prototype.resize = function(e, t) {
      var i = e.get("center"), n = t.getWidth(), a = t.getHeight(), o = Math.min(n, a) / 2;
      this.cx = K(i[0], n), this.cy = K(i[1], a), this.startAngle = e.get("startAngle") * Math.PI / 180;
      var s = e.get("radius");
      (ne(s) || pt(s)) && (s = [0, s]), this.r0 = K(s[0], o), this.r = K(s[1], o), N(this._indicatorAxes, function(l, u) {
        l.setExtent(this.r0, this.r);
        var c = this.startAngle + u * Math.PI * 2 / this._indicatorAxes.length;
        c = Math.atan2(Math.sin(c), Math.cos(c)), l.angle = c;
      }, this);
    }, r.prototype.update = function(e, t) {
      var i = this._indicatorAxes, n = this._model;
      N(i, function(s) {
        s.scale.setExtent(1 / 0, -1 / 0);
      }), e.eachSeriesByType("radar", function(s, l) {
        if (!(s.get("coordinateSystem") !== "radar" || e.getComponent("radar", s.get("radarIndex")) !== n)) {
          var u = s.getData();
          N(i, function(c) {
            c.scale.unionExtentFromData(u, u.mapDimension(c.dim));
          });
        }
      }, this);
      var a = n.get("splitNumber"), o = new Dl();
      o.setExtent(0, a), o.setInterval(1), N(i, function(s, l) {
        V3(s.scale, s.model, o);
      });
    }, r.prototype.convertToPixel = function(e, t, i) {
      return console.warn("Not implemented."), null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      return console.warn("Not implemented."), null;
    }, r.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, r.create = function(e, t) {
      var i = [];
      return e.eachComponent("radar", function(n) {
        var a = new r(n, e, t);
        i.push(a), n.coordinateSystem = a;
      }), e.eachSeriesByType("radar", function(n) {
        n.get("coordinateSystem") === "radar" && (n.coordinateSystem = i[n.get("radarIndex") || 0]);
      }), i;
    }, r.dimensions = [], r;
  }()
);
const bge = Ege;
function Sge(r) {
  r.registerCoordinateSystem("radar", bge), r.registerComponentModel(dge), r.registerComponentView(vge), r.registerVisual({
    seriesType: "radar",
    reset: function(e) {
      var t = e.getData();
      t.each(function(i) {
        t.setItemVisual(i, "legendIcon", "roundRect");
      }), t.setVisual("legendIcon", "roundRect");
    }
  });
}
function Tge(r) {
  Ye(Sge), r.registerChartView(uge), r.registerSeriesModel(hge), r.registerLayout(oge), r.registerProcessor(Qv("radar")), r.registerPreprocessor(sge);
}
var YQ = "\0_ec_interaction_mutex";
function yge(r, e, t) {
  var i = MN(r);
  i[e] = t;
}
function Rge(r, e, t) {
  var i = MN(r), n = i[e];
  n === t && (i[e] = null);
}
function HQ(r, e) {
  return !!MN(r)[e];
}
function MN(r) {
  return r[YQ] || (r[YQ] = {});
}
Po({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, ur);
var Age = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this) || this;
      i._zr = t;
      var n = ue(i._mousedownHandler, i), a = ue(i._mousemoveHandler, i), o = ue(i._mouseupHandler, i), s = ue(i._mousewheelHandler, i), l = ue(i._pinchHandler, i);
      return i.enable = function(u, c) {
        this.disable(), this._opt = Te(ye(c) || {}, {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0
        }), u == null && (u = !0), (u === !0 || u === "move" || u === "pan") && (t.on("mousedown", n), t.on("mousemove", a), t.on("mouseup", o)), (u === !0 || u === "scale" || u === "zoom") && (t.on("mousewheel", s), t.on("pinch", l));
      }, i.disable = function() {
        t.off("mousedown", n), t.off("mousemove", a), t.off("mouseup", o), t.off("mousewheel", s), t.off("pinch", l);
      }, i;
    }
    return e.prototype.isDragging = function() {
      return this._dragging;
    }, e.prototype.isPinching = function() {
      return this._pinching;
    }, e.prototype.setPointerChecker = function(t) {
      this.pointerChecker = t;
    }, e.prototype.dispose = function() {
      this.disable();
    }, e.prototype._mousedownHandler = function(t) {
      if (!OD(t)) {
        for (var i = t.target; i; ) {
          if (i.draggable)
            return;
          i = i.__hostTarget || i.parent;
        }
        var n = t.offsetX, a = t.offsetY;
        this.pointerChecker && this.pointerChecker(t, n, a) && (this._x = n, this._y = a, this._dragging = !0);
      }
    }, e.prototype._mousemoveHandler = function(t) {
      if (!(!this._dragging || !nE("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || HQ(this._zr, "globalPan"))) {
        var i = t.offsetX, n = t.offsetY, a = this._x, o = this._y, s = i - a, l = n - o;
        this._x = i, this._y = n, this._opt.preventDefaultMouseMove && os(t.event), W3(this, "pan", "moveOnMouseMove", t, {
          dx: s,
          dy: l,
          oldX: a,
          oldY: o,
          newX: i,
          newY: n,
          isAvailableBehavior: null
        });
      }
    }, e.prototype._mouseupHandler = function(t) {
      OD(t) || (this._dragging = !1);
    }, e.prototype._mousewheelHandler = function(t) {
      var i = nE("zoomOnMouseWheel", t, this._opt), n = nE("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, o = Math.abs(a), s = t.offsetX, l = t.offsetY;
      if (!(a === 0 || !i && !n)) {
        if (i) {
          var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
          sR(this, "zoom", "zoomOnMouseWheel", t, {
            scale: c,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
        if (n) {
          var h = Math.abs(a), f = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
          sR(this, "scrollMove", "moveOnMouseWheel", t, {
            scrollDelta: f,
            originX: s,
            originY: l,
            isAvailableBehavior: null
          });
        }
      }
    }, e.prototype._pinchHandler = function(t) {
      if (!HQ(this._zr, "globalPan")) {
        var i = t.pinchScale > 1 ? 1.1 : 1 / 1.1;
        sR(this, "zoom", null, t, {
          scale: i,
          originX: t.pinchX,
          originY: t.pinchY,
          isAvailableBehavior: null
        });
      }
    }, e;
  }(oa)
);
function sR(r, e, t, i, n) {
  r.pointerChecker && r.pointerChecker(i, n.originX, n.originY) && (os(i.event), W3(r, e, t, i, n));
}
function W3(r, e, t, i, n) {
  n.isAvailableBehavior = ue(nE, null, t, i), r.trigger(e, n);
}
function nE(r, e, t) {
  var i = t[r];
  return !r || i && (!ne(i) || e.event[i + "Key"]);
}
const $v = Age;
function kN(r, e, t) {
  var i = r.target;
  i.x += e, i.y += t, i.dirty();
}
function QN(r, e, t, i) {
  var n = r.target, a = r.zoomLimit, o = r.zoom = r.zoom || 1;
  if (o *= e, a) {
    var s = a.min || 0, l = a.max || 1 / 0;
    o = Math.max(Math.min(l, o), s);
  }
  var u = o / r.zoom;
  r.zoom = o, n.x -= (t - n.x) * (u - 1), n.y -= (i - n.y) * (u - 1), n.scaleX *= u, n.scaleY *= u, n.dirty();
}
var _ge = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function $T(r, e, t) {
  var i = e.getComponentByElement(r.topTarget), n = i && i.coordinateSystem;
  return i && i !== t && !_ge.hasOwnProperty(i.mainType) && n && n.model !== t;
}
function z3(r) {
  if (ne(r)) {
    var e = new DOMParser();
    r = e.parseFromString(r, "text/xml");
  }
  var t = r;
  for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1; )
    t = t.nextSibling;
  return t;
}
var lR, Nb = {
  fill: "fill",
  stroke: "stroke",
  "stroke-width": "lineWidth",
  opacity: "opacity",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-miterlimit": "miterLimit",
  "font-family": "fontFamily",
  "font-size": "fontSize",
  "font-style": "fontStyle",
  "font-weight": "fontWeight",
  "text-anchor": "textAlign",
  visibility: "visibility",
  display: "display"
}, WQ = Ze(Nb), xb = {
  "alignment-baseline": "textBaseline",
  "stop-color": "stopColor"
}, zQ = Ze(xb), Cge = function() {
  function r() {
    this._defs = {}, this._root = null;
  }
  return r.prototype.parse = function(e, t) {
    t = t || {};
    var i = z3(e);
    if ({}.NODE_ENV !== "production" && !i)
      throw new Error("Illegal svg");
    this._defsUsePending = [];
    var n = new Re();
    this._root = n;
    var a = [], o = i.getAttribute("viewBox") || "", s = parseFloat(i.getAttribute("width") || t.width), l = parseFloat(i.getAttribute("height") || t.height);
    isNaN(s) && (s = null), isNaN(l) && (l = null), on(i, n, null, !0, !1);
    for (var u = i.firstChild; u; )
      this._parseNode(u, n, a, null, !1, !1), u = u.nextSibling;
    Nge(this._defs, this._defsUsePending), this._defsUsePending = [];
    var c, h;
    if (o) {
      var f = VT(o);
      f.length >= 4 && (c = {
        x: parseFloat(f[0] || 0),
        y: parseFloat(f[1] || 0),
        width: parseFloat(f[2]),
        height: parseFloat(f[3])
      });
    }
    if (c && s != null && l != null && (h = q3(c, { x: 0, y: 0, width: s, height: l }), !t.ignoreViewBox)) {
      var d = n;
      n = new Re(), n.add(d), d.scaleX = d.scaleY = h.scale, d.x = h.x, d.y = h.y;
    }
    return !t.ignoreRootClip && s != null && l != null && n.setClipPath(new ht({
      shape: { x: 0, y: 0, width: s, height: l }
    })), {
      root: n,
      width: s,
      height: l,
      viewBoxRect: c,
      viewBoxTransform: h,
      named: a
    };
  }, r.prototype._parseNode = function(e, t, i, n, a, o) {
    var s = e.nodeName.toLowerCase(), l, u = n;
    if (s === "defs" && (a = !0), s === "text" && (o = !0), s === "defs" || s === "switch")
      l = t;
    else {
      if (!a) {
        var c = lR[s];
        if (c && le(lR, s)) {
          l = c.call(this, e, t);
          var h = e.getAttribute("name");
          if (h) {
            var f = {
              name: h,
              namedFrom: null,
              svgNodeTagLower: s,
              el: l
            };
            i.push(f), s === "g" && (u = f);
          } else
            n && i.push({
              name: n.name,
              namedFrom: n,
              svgNodeTagLower: s,
              el: l
            });
          t.add(l);
        }
      }
      var d = ZQ[s];
      if (d && le(ZQ, s)) {
        var p = d.call(this, e), g = e.getAttribute("id");
        g && (this._defs[g] = p);
      }
    }
    if (l && l.isGroup)
      for (var v = e.firstChild; v; )
        v.nodeType === 1 ? this._parseNode(v, l, i, u, a, o) : v.nodeType === 3 && o && this._parseText(v, l), v = v.nextSibling;
  }, r.prototype._parseText = function(e, t) {
    var i = new Ng({
      style: {
        text: e.textContent
      },
      silent: !0,
      x: this._textX || 0,
      y: this._textY || 0
    });
    Ln(t, i), on(e, i, this._defsUsePending, !1, !1), Ige(i, t);
    var n = i.style, a = n.fontSize;
    a && a < 9 && (n.fontSize = 9, i.scaleX *= a / 9, i.scaleY *= a / 9);
    var o = (n.fontSize || n.fontFamily) && [
      n.fontStyle,
      n.fontWeight,
      (n.fontSize || 12) + "px",
      n.fontFamily || "sans-serif"
    ].join(" ");
    n.font = o;
    var s = i.getBoundingRect();
    return this._textX += s.width, t.add(i), i;
  }, r.internalField = function() {
    lR = {
      g: function(e, t) {
        var i = new Re();
        return Ln(t, i), on(e, i, this._defsUsePending, !1, !1), i;
      },
      rect: function(e, t) {
        var i = new ht();
        return Ln(t, i), on(e, i, this._defsUsePending, !1, !1), i.setShape({
          x: parseFloat(e.getAttribute("x") || "0"),
          y: parseFloat(e.getAttribute("y") || "0"),
          width: parseFloat(e.getAttribute("width") || "0"),
          height: parseFloat(e.getAttribute("height") || "0")
        }), i.silent = !0, i;
      },
      circle: function(e, t) {
        var i = new Co();
        return Ln(t, i), on(e, i, this._defsUsePending, !1, !1), i.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          r: parseFloat(e.getAttribute("r") || "0")
        }), i.silent = !0, i;
      },
      line: function(e, t) {
        var i = new Gr();
        return Ln(t, i), on(e, i, this._defsUsePending, !1, !1), i.setShape({
          x1: parseFloat(e.getAttribute("x1") || "0"),
          y1: parseFloat(e.getAttribute("y1") || "0"),
          x2: parseFloat(e.getAttribute("x2") || "0"),
          y2: parseFloat(e.getAttribute("y2") || "0")
        }), i.silent = !0, i;
      },
      ellipse: function(e, t) {
        var i = new W1();
        return Ln(t, i), on(e, i, this._defsUsePending, !1, !1), i.setShape({
          cx: parseFloat(e.getAttribute("cx") || "0"),
          cy: parseFloat(e.getAttribute("cy") || "0"),
          rx: parseFloat(e.getAttribute("rx") || "0"),
          ry: parseFloat(e.getAttribute("ry") || "0")
        }), i.silent = !0, i;
      },
      polygon: function(e, t) {
        var i = e.getAttribute("points"), n;
        i && (n = KQ(i));
        var a = new rn({
          shape: {
            points: n || []
          },
          silent: !0
        });
        return Ln(t, a), on(e, a, this._defsUsePending, !1, !1), a;
      },
      polyline: function(e, t) {
        var i = e.getAttribute("points"), n;
        i && (n = KQ(i));
        var a = new nn({
          shape: {
            points: n || []
          },
          silent: !0
        });
        return Ln(t, a), on(e, a, this._defsUsePending, !1, !1), a;
      },
      image: function(e, t) {
        var i = new ni();
        return Ln(t, i), on(e, i, this._defsUsePending, !1, !1), i.setStyle({
          image: e.getAttribute("xlink:href") || e.getAttribute("href"),
          x: +e.getAttribute("x"),
          y: +e.getAttribute("y"),
          width: +e.getAttribute("width"),
          height: +e.getAttribute("height")
        }), i.silent = !0, i;
      },
      text: function(e, t) {
        var i = e.getAttribute("x") || "0", n = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0";
        this._textX = parseFloat(i) + parseFloat(a), this._textY = parseFloat(n) + parseFloat(o);
        var s = new Re();
        return Ln(t, s), on(e, s, this._defsUsePending, !1, !0), s;
      },
      tspan: function(e, t) {
        var i = e.getAttribute("x"), n = e.getAttribute("y");
        i != null && (this._textX = parseFloat(i)), n != null && (this._textY = parseFloat(n));
        var a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0", s = new Re();
        return Ln(t, s), on(e, s, this._defsUsePending, !1, !0), this._textX += parseFloat(a), this._textY += parseFloat(o), s;
      },
      path: function(e, t) {
        var i = e.getAttribute("d") || "", n = IH(i);
        return Ln(t, n), on(e, n, this._defsUsePending, !1, !1), n.silent = !0, n;
      }
    };
  }(), r;
}(), ZQ = {
  lineargradient: function(r) {
    var e = parseInt(r.getAttribute("x1") || "0", 10), t = parseInt(r.getAttribute("y1") || "0", 10), i = parseInt(r.getAttribute("x2") || "10", 10), n = parseInt(r.getAttribute("y2") || "0", 10), a = new _v(e, t, i, n);
    return qQ(r, a), jQ(r, a), a;
  },
  radialgradient: function(r) {
    var e = parseInt(r.getAttribute("cx") || "0", 10), t = parseInt(r.getAttribute("cy") || "0", 10), i = parseInt(r.getAttribute("r") || "0", 10), n = new GH(e, t, i);
    return qQ(r, n), jQ(r, n), n;
  }
};
function qQ(r, e) {
  var t = r.getAttribute("gradientUnits");
  t === "userSpaceOnUse" && (e.global = !0);
}
function jQ(r, e) {
  for (var t = r.firstChild; t; ) {
    if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") {
      var i = t.getAttribute("offset"), n = void 0;
      i && i.indexOf("%") > 0 ? n = parseInt(i, 10) / 100 : i ? n = parseFloat(i) : n = 0;
      var a = {};
      Z3(t, a, a);
      var o = a.stopColor || t.getAttribute("stop-color") || "#000000";
      e.colorStops.push({
        offset: n,
        color: o
      });
    }
    t = t.nextSibling;
  }
}
function Ln(r, e) {
  r && r.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), Te(e.__inheritedStyle, r.__inheritedStyle));
}
function KQ(r) {
  for (var e = VT(r), t = [], i = 0; i < e.length; i += 2) {
    var n = parseFloat(e[i]), a = parseFloat(e[i + 1]);
    t.push([n, a]);
  }
  return t;
}
function on(r, e, t, i, n) {
  var a = e, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {};
  r.nodeType === 1 && (Lge(r, e), Z3(r, o, s), i || Dge(r, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = JQ(a, "fill", o.fill, t)), o.stroke != null && (a.style.stroke = JQ(a, "stroke", o.stroke, t)), N([
    "lineWidth",
    "opacity",
    "fillOpacity",
    "strokeOpacity",
    "miterLimit",
    "fontSize"
  ], function(l) {
    o[l] != null && (a.style[l] = parseFloat(o[l]));
  }), N([
    "lineDashOffset",
    "lineCap",
    "lineJoin",
    "fontWeight",
    "fontFamily",
    "fontStyle",
    "textAlign"
  ], function(l) {
    o[l] != null && (a.style[l] = o[l]);
  }), n && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = Y(VT(o.lineDash), function(l) {
    return parseFloat(l);
  })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = !0), o.display === "none" && (a.ignore = !0);
}
function Ige(r, e) {
  var t = e.__selfStyle;
  if (t) {
    var i = t.textBaseline, n = i;
    !i || i === "auto" || i === "baseline" ? n = "alphabetic" : i === "before-edge" || i === "text-before-edge" ? n = "top" : i === "after-edge" || i === "text-after-edge" ? n = "bottom" : (i === "central" || i === "mathematical") && (n = "middle"), r.style.textBaseline = n;
  }
  var a = e.__inheritedStyle;
  if (a) {
    var o = a.textAlign, s = o;
    o && (o === "middle" && (s = "center"), r.style.textAlign = s);
  }
}
var wge = /^url\(\s*#(.*?)\)/;
function JQ(r, e, t, i) {
  var n = t && t.match(wge);
  if (n) {
    var a = Ea(n[1]);
    i.push([r, e, a]);
    return;
  }
  return t === "none" && (t = null), t;
}
function Nge(r, e) {
  for (var t = 0; t < e.length; t++) {
    var i = e[t];
    i[0].style[i[1]] = r[i[2]];
  }
}
var xge = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function VT(r) {
  return r.match(xge) || [];
}
var Pge = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, uR = Math.PI / 180;
function Lge(r, e) {
  var t = r.getAttribute("transform");
  if (t) {
    t = t.replace(/,/g, " ");
    var i = [], n = null;
    t.replace(Pge, function(h, f, d) {
      return i.push(f, d), "";
    });
    for (var a = i.length - 1; a > 0; a -= 2) {
      var o = i[a], s = i[a - 1], l = VT(o);
      switch (n = n || na(), s) {
        case "translate":
          yo(n, n, [parseFloat(l[0]), parseFloat(l[1] || "0")]);
          break;
        case "scale":
          x1(n, n, [parseFloat(l[0]), parseFloat(l[1] || l[0])]);
          break;
        case "rotate":
          zc(n, n, -parseFloat(l[0]) * uR);
          break;
        case "skewX":
          var u = Math.tan(parseFloat(l[0]) * uR);
          qo(n, [1, 0, u, 1, 0, 0], n);
          break;
        case "skewY":
          var c = Math.tan(parseFloat(l[0]) * uR);
          qo(n, [1, c, 0, 1, 0, 0], n);
          break;
        case "matrix":
          n[0] = parseFloat(l[0]), n[1] = parseFloat(l[1]), n[2] = parseFloat(l[2]), n[3] = parseFloat(l[3]), n[4] = parseFloat(l[4]), n[5] = parseFloat(l[5]);
          break;
      }
    }
    e.setLocalTransform(n);
  }
}
var e2 = /([^\s:;]+)\s*:\s*([^:;]+)/g;
function Z3(r, e, t) {
  var i = r.getAttribute("style");
  if (i) {
    e2.lastIndex = 0;
    for (var n; (n = e2.exec(i)) != null; ) {
      var a = n[1], o = le(Nb, a) ? Nb[a] : null;
      o && (e[o] = n[2]);
      var s = le(xb, a) ? xb[a] : null;
      s && (t[s] = n[2]);
    }
  }
}
function Dge(r, e, t) {
  for (var i = 0; i < WQ.length; i++) {
    var n = WQ[i], a = r.getAttribute(n);
    a != null && (e[Nb[n]] = a);
  }
  for (var i = 0; i < zQ.length; i++) {
    var n = zQ[i], a = r.getAttribute(n);
    a != null && (t[xb[n]] = a);
  }
}
function q3(r, e) {
  var t = e.width / r.width, i = e.height / r.height, n = Math.min(t, i);
  return {
    scale: n,
    x: -(r.x + r.width / 2) * n + (e.x + e.width / 2),
    y: -(r.y + r.height / 2) * n + (e.y + e.height / 2)
  };
}
function Mge(r, e) {
  var t = new Cge();
  return t.parse(r, e);
}
var kge = de([
  "rect",
  "circle",
  "line",
  "ellipse",
  "polygon",
  "polyline",
  "path",
  // <text> <tspan> are also enabled because some SVG might paint text itself,
  // but still need to trigger events or tooltip.
  "text",
  "tspan",
  // <g> is also enabled because this case: if multiple tags share one name
  // and need label displayed, every tags will display the name, which is not
  // expected. So we can put them into a <g name="xxx">. Thereby only one label
  // displayed and located based on the bounding rect of the <g>.
  "g"
]), Qge = (
  /** @class */
  function() {
    function r(e, t) {
      this.type = "geoSVG", this._usedGraphicMap = de(), this._freedGraphics = [], this._mapName = e, this._parsedXML = z3(t);
    }
    return r.prototype.load = function() {
      var e = this._firstGraphic;
      if (!e) {
        e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone();
        var t = $ge(e.named), i = t.regions, n = t.regionsMap;
        this._regions = i, this._regionsMap = n;
      }
      return {
        boundingRect: this._boundingRect,
        regions: this._regions,
        regionsMap: this._regionsMap
      };
    }, r.prototype._buildGraphic = function(e) {
      var t, i;
      try {
        t = e && Mge(e, {
          ignoreViewBox: !0,
          ignoreRootClip: !0
        }) || {}, i = t.root, Se(i != null);
      } catch (v) {
        throw new Error(`Invalid svg format
` + v.message);
      }
      var n = new Re();
      n.add(i), n.isGeoSVGGraphicRoot = !0;
      var a = t.width, o = t.height, s = t.viewBoxRect, l = this._boundingRect;
      if (!l) {
        var u = void 0, c = void 0, h = void 0, f = void 0;
        if (a != null ? (u = 0, h = a) : s && (u = s.x, h = s.width), o != null ? (c = 0, f = o) : s && (c = s.y, f = s.height), u == null || c == null) {
          var d = i.getBoundingRect();
          u == null && (u = d.x, h = d.width), c == null && (c = d.y, f = d.height);
        }
        l = this._boundingRect = new Ve(u, c, h, f);
      }
      if (s) {
        var p = q3(s, l);
        i.scaleX = i.scaleY = p.scale, i.x = p.x, i.y = p.y;
      }
      n.setClipPath(new ht({
        shape: l.plain()
      }));
      var g = [];
      return N(t.named, function(v) {
        kge.get(v.svgNodeTagLower) != null && (g.push(v), Uge(v.el));
      }), {
        root: n,
        boundingRect: l,
        named: g
      };
    }, r.prototype.useGraphic = function(e) {
      var t = this._usedGraphicMap, i = t.get(e);
      return i || (i = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, i), i);
    }, r.prototype.freeGraphic = function(e) {
      var t = this._usedGraphicMap, i = t.get(e);
      i && (t.removeKey(e), this._freedGraphics.push(i));
    }, r;
  }()
);
function Uge(r) {
  r.silent = !1, r.isGroup && r.traverse(function(e) {
    e.silent = !1;
  });
}
function $ge(r) {
  var e = [], t = de();
  return N(r, function(i) {
    if (i.namedFrom == null) {
      var n = new nfe(i.name, i.el);
      e.push(n), t.set(i.name, n);
    }
  }), {
    regions: e,
    regionsMap: t
  };
}
var kC = [126, 25], t2 = "", Nu = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]];
for (var Au = 0; Au < Nu.length; Au++)
  for (var Th = 0; Th < Nu[Au].length; Th++)
    Nu[Au][Th][0] /= 10.5, Nu[Au][Th][1] /= -10.5 / 0.75, Nu[Au][Th][0] += kC[0], Nu[Au][Th][1] += kC[1];
function Vge(r, e) {
  if (r === "china") {
    for (var t = 0; t < e.length; t++)
      if (e[t].name === t2)
        return;
    e.push(new zz(t2, Y(Nu, function(i) {
      return {
        type: "polygon",
        exterior: i
      };
    }), kC));
  }
}
var Gge = {
  : [32, 80],
  // 
  : [0, -10],
  : [10, 5],
  : [-10, 10],
  // '': [-10, 0],
  : [5, 5]
};
function Bge(r, e) {
  if (r === "china") {
    var t = Gge[e.name];
    if (t) {
      var i = e.getCenter();
      i[0] += t[0] / 10.5, i[1] += -t[1] / (10.5 / 0.75), e.setCenter(i);
    }
  }
}
var Fge = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]];
function Xge(r, e) {
  r === "china" && e.name === "" && e.geometries.push({
    type: "polygon",
    exterior: Fge[0]
  });
}
var Yge = "name", Hge = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "geoJSON", this._parsedMap = de(), this._mapName = e, this._specialAreas = i, this._geoJSON = zge(t);
    }
    return r.prototype.load = function(e, t) {
      t = t || Yge;
      var i = this._parsedMap.get(t);
      if (!i) {
        var n = this._parseToRegions(t);
        i = this._parsedMap.set(t, {
          regions: n,
          boundingRect: Wge(n)
        });
      }
      var a = de(), o = [];
      return N(i.regions, function(s) {
        var l = s.name;
        e && le(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), a.set(l, s);
      }), {
        regions: o,
        boundingRect: i.boundingRect || new Ve(0, 0, 0, 0),
        regionsMap: a
      };
    }, r.prototype._parseToRegions = function(e) {
      var t = this._mapName, i = this._geoJSON, n;
      try {
        n = i ? ofe(i, e) : [];
      } catch (a) {
        throw new Error(`Invalid geoJson format
` + a.message);
      }
      return Vge(t, n), N(n, function(a) {
        var o = a.name;
        Bge(t, a), Xge(t, a);
        var s = this._specialAreas && this._specialAreas[o];
        s && a.transformTo(s.left, s.top, s.width, s.height);
      }, this), n;
    }, r.prototype.getMapForUser = function() {
      return {
        // For backward compatibility, use geoJson
        // PENDING: it has been returning them without clone.
        // do we need to avoid outsite modification?
        geoJson: this._geoJSON,
        geoJSON: this._geoJSON,
        specialAreas: this._specialAreas
      };
    }, r;
  }()
);
function Wge(r) {
  for (var e, t = 0; t < r.length; t++) {
    var i = r[t].getBoundingRect();
    e = e || i.clone(), e.union(i);
  }
  return e;
}
function zge(r) {
  return ne(r) ? typeof JSON < "u" && JSON.parse ? JSON.parse(r) : new Function("return (" + r + ");")() : r;
}
var Yd = de();
const fs = {
  /**
   * Compatible with previous `echarts.registerMap`.
   *
   * @usage
   * ```js
   *
   * echarts.registerMap('USA', geoJson, specialAreas);
   *
   * echarts.registerMap('USA', {
   *     geoJson: geoJson,
   *     specialAreas: {...}
   * });
   * echarts.registerMap('USA', {
   *     geoJSON: geoJson,
   *     specialAreas: {...}
   * });
   *
   * echarts.registerMap('airport', {
   *     svg: svg
   * }
   * ```
   *
   * Note:
   * Do not support that register multiple geoJSON or SVG
   * one map name. Because different geoJSON and SVG have
   * different unit. It's not easy to make sure how those
   * units are mapping/normalize.
   * If intending to use multiple geoJSON or SVG, we can
   * use multiple geo coordinate system.
   */
  registerMap: function(r, e, t) {
    if (e.svg) {
      var i = new Qge(r, e.svg);
      Yd.set(r, i);
    } else {
      var n = e.geoJson || e.geoJSON;
      n && !e.features ? t = e.specialAreas : n = e;
      var i = new Hge(r, n, t);
      Yd.set(r, i);
    }
  },
  getGeoResource: function(r) {
    return Yd.get(r);
  },
  /**
   * Only for exporting to users.
   * **MUST NOT** used internally.
   */
  getMapForUser: function(r) {
    var e = Yd.get(r);
    return e && e.type === "geoJSON" && e.getMapForUser();
  },
  load: function(r, e, t) {
    var i = Yd.get(r);
    if (!i) {
      ({}).NODE_ENV !== "production" && console.error("Map " + r + " not exists. The GeoJSON of the map must be provided.");
      return;
    }
    return i.load(e, t);
  }
};
var UN = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], Zge = de(UN), qge = de(UN.concat(["g"])), jge = de(UN.concat(["g"])), j3 = ft();
function em(r) {
  var e = r.getItemStyle(), t = r.get("areaColor");
  return t != null && (e.fill = t), e;
}
function r2(r) {
  var e = r.style;
  e && (e.stroke = e.stroke || e.fill, e.fill = null);
}
var Kge = (
  /** @class */
  function() {
    function r(e) {
      var t = new Re();
      this.uid = rd("ec_map_draw"), this._controller = new $v(e.getZr()), this._controllerHost = {
        target: t
      }, this.group = t, t.add(this._regionsGroup = new Re()), t.add(this._svgGroup = new Re());
    }
    return r.prototype.draw = function(e, t, i, n, a) {
      var o = e.mainType === "geo", s = e.getData && e.getData();
      o && t.eachComponent({
        mainType: "series",
        subType: "map"
      }, function(O) {
        !s && O.getHostGeoModel() === e && (s = O.getData());
      });
      var l = e.coordinateSystem, u = this._regionsGroup, c = this.group, h = l.getTransformInfo(), f = h.raw, d = h.roam, p = !u.childAt(0) || a;
      p ? (c.x = d.x, c.y = d.y, c.scaleX = d.scaleX, c.scaleY = d.scaleY, c.dirty()) : Ot(c, d, e);
      var g = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, v = {
        api: i,
        geo: l,
        mapOrGeoModel: e,
        data: s,
        isVisualEncodedByVisualMap: g,
        isGeo: o,
        transformInfoRaw: f
      };
      l.resourceType === "geoJSON" ? this._buildGeoJSON(v) : l.resourceType === "geoSVG" && this._buildSVG(v), this._updateController(e, t, i), this._updateMapSelectHandler(e, u, i, n);
    }, r.prototype._buildGeoJSON = function(e) {
      var t = this._regionsGroupByName = de(), i = de(), n = this._regionsGroup, a = e.transformInfoRaw, o = e.mapOrGeoModel, s = e.data, l = e.geo.projection, u = l && l.stream;
      function c(d, p) {
        return p && (d = p(d)), d && [d[0] * a.scaleX + a.x, d[1] * a.scaleY + a.y];
      }
      function h(d) {
        for (var p = [], g = !u && l && l.project, v = 0; v < d.length; ++v) {
          var O = c(d[v], g);
          O && p.push(O);
        }
        return p;
      }
      function f(d) {
        return {
          shape: {
            points: h(d)
          }
        };
      }
      n.removeAll(), N(e.geo.regions, function(d) {
        var p = d.name, g = t.get(p), v = i.get(p) || {}, O = v.dataIdx, m = v.regionModel;
        g || (g = t.set(p, new Re()), n.add(g), O = s ? s.indexOfName(p) : null, m = e.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(O) : null, i.set(p, {
          dataIdx: O,
          regionModel: m
        }));
        var E = [], b = [];
        N(d.geometries, function(y) {
          if (y.type === "polygon") {
            var R = [y.exterior].concat(y.interiors || []);
            u && (R = l2(R, u)), N(R, function(C) {
              E.push(new rn(f(C)));
            });
          } else {
            var _ = y.points;
            u && (_ = l2(_, u, !0)), N(_, function(C) {
              b.push(new nn(f(C)));
            });
          }
        });
        var S = c(d.getCenter(), l && l.project);
        function T(y, R) {
          if (y.length) {
            var _ = new Z1({
              culling: !0,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: y
              }
            });
            g.add(_), i2(e, _, O, m), n2(e, _, p, m, o, O, S), R && (r2(_), N(_.states, r2));
          }
        }
        T(E), T(b, !0);
      }), t.each(function(d, p) {
        var g = i.get(p), v = g.dataIdx, O = g.regionModel;
        a2(e, d, p, O, o, v), o2(e, d, p, O, o), s2(e, d, p, O, o);
      }, this);
    }, r.prototype._buildSVG = function(e) {
      var t = e.geo.map, i = e.transformInfoRaw;
      this._svgGroup.x = i.x, this._svgGroup.y = i.y, this._svgGroup.scaleX = i.scaleX, this._svgGroup.scaleY = i.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t));
      var n = this._svgDispatcherMap = de(), a = !1;
      N(this._svgGraphicRecord.named, function(o) {
        var s = o.name, l = e.mapOrGeoModel, u = e.data, c = o.svgNodeTagLower, h = o.el, f = u ? u.indexOfName(s) : null, d = l.getRegionModel(s);
        if (Zge.get(c) != null && h instanceof aa && i2(e, h, f, d), h instanceof aa && (h.culling = !0), h.z2EmphasisLift = 0, !o.namedFrom && (jge.get(c) != null && n2(e, h, s, d, l, f, null), a2(e, h, s, d, l, f), o2(e, h, s, d, l), qge.get(c) != null)) {
          var p = s2(e, h, s, d, l);
          p === "self" && (a = !0);
          var g = n.get(s) || n.set(s, []);
          g.push(h);
        }
      }, this), this._enableBlurEntireSVG(a, e);
    }, r.prototype._enableBlurEntireSVG = function(e, t) {
      if (e && t.isGeo) {
        var i = t.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), n = i.opacity;
        this._svgGraphicRecord.root.traverse(function(a) {
          if (!a.isGroup) {
            xc(a);
            var o = a.ensureState("blur").style || {};
            o.opacity == null && n != null && (o.opacity = n), a.ensureState("emphasis");
          }
        });
      }
    }, r.prototype.remove = function() {
      this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null;
    }, r.prototype.findHighDownDispatchers = function(e, t) {
      if (e == null)
        return [];
      var i = t.coordinateSystem;
      if (i.resourceType === "geoJSON") {
        var n = this._regionsGroupByName;
        if (n) {
          var a = n.get(e);
          return a ? [a] : [];
        }
      } else if (i.resourceType === "geoSVG")
        return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [];
    }, r.prototype._svgResourceChanged = function(e) {
      return this._svgMapName !== e;
    }, r.prototype._useSVG = function(e) {
      var t = fs.getGeoResource(e);
      if (t && t.type === "geoSVG") {
        var i = t.useGraphic(this.uid);
        this._svgGroup.add(i.root), this._svgGraphicRecord = i, this._svgMapName = e;
      }
    }, r.prototype._freeSVG = function() {
      var e = this._svgMapName;
      if (e != null) {
        var t = fs.getGeoResource(e);
        t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null;
      }
    }, r.prototype._updateController = function(e, t, i) {
      var n = e.coordinateSystem, a = this._controller, o = this._controllerHost;
      o.zoomLimit = e.get("scaleLimit"), o.zoom = n.getZoom(), a.enable(e.get("roam") || !1);
      var s = e.mainType;
      function l() {
        var u = {
          type: "geoRoam",
          componentType: s
        };
        return u[s + "Id"] = e.id, u;
      }
      a.off("pan").on("pan", function(u) {
        this._mouseDownFlag = !1, kN(o, u.dx, u.dy), i.dispatchAction(B(l(), {
          dx: u.dx,
          dy: u.dy,
          animation: {
            duration: 0
          }
        }));
      }, this), a.off("zoom").on("zoom", function(u) {
        this._mouseDownFlag = !1, QN(o, u.scale, u.originX, u.originY), i.dispatchAction(B(l(), {
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY,
          animation: {
            duration: 0
          }
        }));
      }, this), a.setPointerChecker(function(u, c, h) {
        return n.containPoint([c, h]) && !$T(u, i, e);
      });
    }, r.prototype.resetForLabelLayout = function() {
      this.group.traverse(function(e) {
        var t = e.getTextContent();
        t && (t.ignore = j3(t).ignore);
      });
    }, r.prototype._updateMapSelectHandler = function(e, t, i, n) {
      var a = this;
      t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function() {
        a._mouseDownFlag = !0;
      }), t.on("click", function(o) {
        a._mouseDownFlag && (a._mouseDownFlag = !1);
      }));
    }, r;
  }()
);
function i2(r, e, t, i) {
  var n = i.getModel("itemStyle"), a = i.getModel(["emphasis", "itemStyle"]), o = i.getModel(["blur", "itemStyle"]), s = i.getModel(["select", "itemStyle"]), l = em(n), u = em(a), c = em(s), h = em(o), f = r.data;
  if (f) {
    var d = f.getItemVisual(t, "style"), p = f.getItemVisual(t, "decal");
    r.isVisualEncodedByVisualMap && d.fill && (l.fill = d.fill), p && (l.decal = xf(p, r.api));
  }
  e.setStyle(l), e.style.strokeNoScale = !0, e.ensureState("emphasis").style = u, e.ensureState("select").style = c, e.ensureState("blur").style = h, xc(e);
}
function n2(r, e, t, i, n, a, o) {
  var s = r.data, l = r.isGeo, u = s && isNaN(s.get(s.mapDimension("value"), a)), c = s && s.getItemLayout(a);
  if (l || u || c && c.showLabel) {
    var h = l ? t : a, f = void 0;
    (!s || a >= 0) && (f = n);
    var d = o ? {
      normal: {
        align: "center",
        verticalAlign: "middle"
      }
    } : null;
    ii(e, kr(i), {
      labelFetcher: f,
      labelDataIndex: h,
      defaultText: t
    }, d);
    var p = e.getTextContent();
    if (p && (j3(p).ignore = p.ignore, e.textConfig && o)) {
      var g = e.getBoundingRect().clone();
      e.textConfig.layoutRect = g, e.textConfig.position = [(o[0] - g.x) / g.width * 100 + "%", (o[1] - g.y) / g.height * 100 + "%"];
    }
    e.disableLabelAnimation = !0;
  } else
    e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null;
}
function a2(r, e, t, i, n, a) {
  r.data ? r.data.setItemGraphicEl(a, e) : Pe(e).eventData = {
    componentType: "geo",
    componentIndex: n.componentIndex,
    geoIndex: n.componentIndex,
    name: t,
    region: i && i.option || {}
  };
}
function o2(r, e, t, i, n) {
  r.data || ed({
    el: e,
    componentModel: n,
    itemName: t,
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    itemTooltipOption: i.get("tooltip")
  });
}
function s2(r, e, t, i, n) {
  e.highDownSilentOnTouch = !!n.get("selectedMode");
  var a = i.getModel("emphasis"), o = a.get("focus");
  return qt(e, o, a.get("blurScope"), a.get("disabled")), r.isGeo && ese(e, n, t), o;
}
function l2(r, e, t) {
  var i = [], n;
  function a() {
    n = [];
  }
  function o() {
    n.length && (i.push(n), n = []);
  }
  var s = e({
    polygonStart: a,
    polygonEnd: o,
    lineStart: a,
    lineEnd: o,
    point: function(l, u) {
      isFinite(l) && isFinite(u) && n.push([l, u]);
    },
    sphere: function() {
    }
  });
  return !t && s.polygonStart(), N(r, function(l) {
    s.lineStart();
    for (var u = 0; u < l.length; u++)
      s.point(l[u][0], l[u][1]);
    s.lineEnd();
  }), !t && s.polygonEnd(), i;
}
const K3 = Kge;
var Jge = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) {
        var o = this.group;
        if (o.removeAll(), !t.getHostGeoModel()) {
          if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) {
            var s = this._mapDraw;
            s && o.add(s.group);
          } else if (t.needsDrawMap) {
            var s = this._mapDraw || new K3(n);
            o.add(s.group), s.draw(t, i, n, this, a), this._mapDraw = s;
          } else
            this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
          t.get("showLegendSymbol") && i.getComponent("legend") && this._renderSymbols(t, i, n);
        }
      }
    }, e.prototype.remove = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
    }, e.prototype._renderSymbols = function(t, i, n) {
      var a = t.originalData, o = this.group;
      a.each(a.mapDimension("value"), function(s, l) {
        if (!isNaN(s)) {
          var u = a.getItemLayout(l);
          if (!(!u || !u.point)) {
            var c = u.point, h = u.offset, f = new Co({
              style: {
                // Because the special of map draw.
                // Which needs statistic of multiple series and draw on one map.
                // And each series also need a symbol with legend color
                //
                // Layout and visual are put one the different data
                // TODO
                fill: t.getData().getVisual("style").fill
              },
              shape: {
                cx: c[0] + h * 9,
                cy: c[1],
                r: 3
              },
              silent: !0,
              // Do not overlap the first series, on which labels are displayed.
              z2: 8 + (h ? 0 : Kf + 1)
            });
            if (!h) {
              var d = t.mainSeries.getData(), p = a.getName(l), g = d.indexOfName(p), v = a.getItemModel(l), O = v.getModel("label"), m = d.getItemGraphicEl(g);
              ii(f, kr(v), {
                labelFetcher: {
                  getFormattedLabel: function(E, b) {
                    return t.getFormattedLabel(g, b);
                  }
                },
                defaultText: p
              }), f.disableLabelAnimation = !0, O.get("position") || f.setTextConfig({
                position: "bottom"
              }), m.onHoverStateChange = function(E) {
                ob(f, E);
              };
            }
            o.add(f);
          }
        }
      });
    }, e.type = "map", e;
  }($t)
);
const eve = Jge;
var tve = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.needsDrawMap = !1, t.seriesGroup = [], t.getTooltipPosition = function(i) {
        if (i != null) {
          var n = this.getData().getName(i), a = this.coordinateSystem, o = a.getRegion(n);
          return o && a.dataToPoint(o.getCenter());
        }
      }, t;
    }
    return e.prototype.getInitialData = function(t) {
      for (var i = hd(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Le(nN, this)
      }), n = de(), a = [], o = 0, s = i.count(); o < s; o++) {
        var l = i.getName(o);
        n.set(l, !0);
      }
      var u = fs.load(this.getMapType(), this.option.nameMap, this.option.nameProperty);
      return N(u.regions, function(c) {
        var h = c.name;
        n.get(h) || a.push(h);
      }), i.appendValues([], a), i;
    }, e.prototype.getHostGeoModel = function() {
      var t = this.option.geoIndex;
      return t != null ? this.ecModel.getComponent("geo", t) : null;
    }, e.prototype.getMapType = function() {
      return (this.getHostGeoModel() || this).option.map;
    }, e.prototype.getRawValue = function(t) {
      var i = this.getData();
      return i.get(i.mapDimension("value"), t);
    }, e.prototype.getRegionModel = function(t) {
      var i = this.getData();
      return i.getItemModel(i.indexOfName(t));
    }, e.prototype.formatTooltip = function(t, i, n) {
      for (var a = this.getData(), o = this.getRawValue(t), s = a.getName(t), l = this.seriesGroup, u = [], c = 0; c < l.length; c++) {
        var h = l[c].originalData.indexOfName(s), f = a.mapDimension("value");
        isNaN(l[c].originalData.get(f, h)) || u.push(l[c].name);
      }
      return Qr("section", {
        header: u.join(", "),
        noHeader: !u.length,
        blocks: [Qr("nameValue", {
          name: s,
          value: o
        })]
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.getLegendIcon = function(t) {
      var i = t.icon || "roundRect", n = Er(i, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill);
      return n.setStyle(t.itemStyle), n.style.stroke = "none", i.indexOf("empty") > -1 && (n.style.stroke = n.style.fill, n.style.fill = "#fff", n.style.lineWidth = 2), n;
    }, e.type = "series.map", e.dependencies = ["geo"], e.layoutMode = "box", e.defaultOption = {
      // 
      // zlevel: 0,
      // 
      z: 2,
      coordinateSystem: "geo",
      // map should be explicitly specified since ec3.
      map: "",
      // If `geoIndex` is not specified, a exclusive geo will be
      // created. Otherwise use the specified geo component, and
      // `map` and `mapType` are ignored.
      // geoIndex: 0,
      // 'center' | 'left' | 'right' | 'x%' | {number}
      left: "center",
      // 'center' | 'top' | 'bottom' | 'x%' | {number}
      top: "center",
      // right
      // bottom
      // width:
      // height
      // Aspect is width / height. Inited to be geoJson bbox aspect
      // This parameter is used for scale this aspect
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient.
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      showLegendSymbol: !0,
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ],
      // higher priority than center and zoom
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      selectedMode: !0,
      label: {
        show: !1,
        color: "#000"
      },
      // scaleLimit: null,
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444",
        areaColor: "#eee"
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          areaColor: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      nameProperty: "name"
    }, e;
  }(Wt)
);
const rve = tve;
function ive(r, e) {
  var t = {};
  return N(r, function(i) {
    i.each(i.mapDimension("value"), function(n, a) {
      var o = "ec-" + i.getName(a);
      t[o] = t[o] || [], isNaN(n) || t[o].push(n);
    });
  }), r[0].map(r[0].mapDimension("value"), function(i, n) {
    for (var a = "ec-" + r[0].getName(n), o = 0, s = 1 / 0, l = -1 / 0, u = t[a].length, c = 0; c < u; c++)
      s = Math.min(s, t[a][c]), l = Math.max(l, t[a][c]), o += t[a][c];
    var h;
    return e === "min" ? h = s : e === "max" ? h = l : e === "average" ? h = o / u : h = o, u === 0 ? NaN : h;
  });
}
function nve(r) {
  var e = {};
  r.eachSeriesByType("map", function(t) {
    var i = t.getHostGeoModel(), n = i ? "o" + i.id : "i" + t.getMapType();
    (e[n] = e[n] || []).push(t);
  }), N(e, function(t, i) {
    for (var n = ive(Y(t, function(o) {
      return o.getData();
    }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++)
      t[a].originalData = t[a].getData();
    for (var a = 0; a < t.length; a++)
      t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(n.cloneShallow()), t[a].mainSeries = t[0];
  });
}
function ave(r) {
  var e = {};
  r.eachSeriesByType("map", function(t) {
    var i = t.getMapType();
    if (!(t.getHostGeoModel() || e[i])) {
      var n = {};
      N(t.seriesGroup, function(o) {
        var s = o.coordinateSystem, l = o.originalData;
        o.get("showLegendSymbol") && r.getComponent("legend") && l.each(l.mapDimension("value"), function(u, c) {
          var h = l.getName(c), f = s.getRegion(h);
          if (!(!f || isNaN(u))) {
            var d = n[h] || 0, p = s.dataToPoint(f.getCenter());
            n[h] = d + 1, l.setItemLayout(c, {
              point: p,
              offset: d
            });
          }
        });
      });
      var a = t.getData();
      a.each(function(o) {
        var s = a.getName(o), l = a.getItemLayout(o) || {};
        l.showLabel = !n[s], a.setItemLayout(o, l);
      }), e[i] = !0;
    }
  });
}
var u2 = Kr, ove = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this) || this;
      return i.type = "view", i.dimensions = ["x", "y"], i._roamTransformable = new Ho(), i._rawTransformable = new Ho(), i.name = t, i;
    }
    return e.prototype.setBoundingRect = function(t, i, n, a) {
      return this._rect = new Ve(t, i, n, a), this._rect;
    }, e.prototype.getBoundingRect = function() {
      return this._rect;
    }, e.prototype.setViewRect = function(t, i, n, a) {
      this._transformTo(t, i, n, a), this._viewRect = new Ve(t, i, n, a);
    }, e.prototype._transformTo = function(t, i, n, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new Ve(t, i, n, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, e.prototype.setCenter = function(t, i) {
      t && (this._center = [K(t[0], i.getWidth()), K(t[1], i.getHeight())], this._updateCenterAndZoom());
    }, e.prototype.setZoom = function(t) {
      t = t || 1;
      var i = this.zoomLimit;
      i && (i.max != null && (t = Math.min(i.max, t)), i.min != null && (t = Math.max(i.min, t))), this._zoom = t, this._updateCenterAndZoom();
    }, e.prototype.getDefaultCenter = function() {
      var t = this.getBoundingRect(), i = t.x + t.width / 2, n = t.y + t.height / 2;
      return [i, n];
    }, e.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, e.prototype.getZoom = function() {
      return this._zoom || 1;
    }, e.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, e.prototype._updateCenterAndZoom = function() {
      var t = this._rawTransformable.getLocalTransform(), i = this._roamTransformable, n = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom();
      a = Kr([], a, t), n = Kr([], n, t), i.originX = a[0], i.originY = a[1], i.x = n[0] - a[0], i.y = n[1] - a[1], i.scaleX = i.scaleY = o, this._updateTransform();
    }, e.prototype._updateTransform = function() {
      var t = this._roamTransformable, i = this._rawTransformable;
      i.parent = t, t.updateTransform(), i.updateTransform(), N1(this.transform || (this.transform = []), i.transform || na()), this._rawTransform = i.getLocalTransform(), this.invTransform = this.invTransform || [], qf(this.invTransform, this.transform), this.decomposeTransform();
    }, e.prototype.getTransformInfo = function() {
      var t = this._rawTransformable, i = this._roamTransformable, n = new Ho();
      return n.transform = i.transform, n.decomposeTransform(), {
        roam: {
          x: n.x,
          y: n.y,
          scaleX: n.scaleX,
          scaleY: n.scaleY
        },
        raw: {
          x: t.x,
          y: t.y,
          scaleX: t.scaleX,
          scaleY: t.scaleY
        }
      };
    }, e.prototype.getViewRect = function() {
      return this._viewRect;
    }, e.prototype.getViewRectAfterRoam = function() {
      var t = this.getBoundingRect().clone();
      return t.applyTransform(this.transform), t;
    }, e.prototype.dataToPoint = function(t, i, n) {
      var a = i ? this._rawTransform : this.transform;
      return n = n || [], a ? u2(n, t, a) : _i(n, t);
    }, e.prototype.pointToData = function(t) {
      var i = this.invTransform;
      return i ? u2([], t, i) : [t[0], t[1]];
    }, e.prototype.convertToPixel = function(t, i, n) {
      var a = c2(i);
      return a === this ? a.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, i, n) {
      var a = c2(i);
      return a === this ? a.pointToData(n) : null;
    }, e.prototype.containPoint = function(t) {
      return this.getViewRectAfterRoam().contain(t[0], t[1]);
    }, e.dimensions = ["x", "y"], e;
  }(Ho)
);
function c2(r) {
  var e = r.seriesModel;
  return e ? e.coordinateSystem : null;
}
const Vv = ove;
var sve = {
  geoJSON: {
    aspectScale: 0.75,
    invertLongitute: !0
  },
  geoSVG: {
    aspectScale: 1,
    invertLongitute: !1
  }
}, J3 = ["lng", "lat"], e4 = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this, t) || this;
      a.dimensions = J3, a.type = "geo", a._nameCoordMap = de(), a.map = i;
      var o = n.projection, s = fs.load(i, n.nameMap, n.nameProperty), l = fs.getGeoResource(i), u = a.resourceType = l ? l.type : null, c = a.regions = s.regions, h = sve[l.type];
      a._regionsMap = s.regionsMap, a.regions = s.regions, {}.NODE_ENV !== "production" && o && (u === "geoSVG" && ({}.NODE_ENV !== "production" && tr("Map " + i + " with SVG source can't use projection. Only GeoJSON source supports projection."), o = null), o.project && o.unproject || ({}.NODE_ENV !== "production" && tr("project and unproject must be both provided in the projeciton."), o = null)), a.projection = o;
      var f;
      if (o)
        for (var d = 0; d < c.length; d++) {
          var p = c[d].getBoundingRect(o);
          f = f || p.clone(), f.union(p);
        }
      else
        f = s.boundingRect;
      return a.setBoundingRect(f.x, f.y, f.width, f.height), a.aspectScale = o ? 1 : ke(n.aspectScale, h.aspectScale), a._invertLongitute = o ? !1 : h.invertLongitute, a;
    }
    return e.prototype._transformTo = function(t, i, n, a) {
      var o = this.getBoundingRect(), s = this._invertLongitute;
      o = o.clone(), s && (o.y = -o.y - o.height);
      var l = this._rawTransformable;
      l.transform = o.calculateTransform(new Ve(t, i, n, a));
      var u = l.parent;
      l.parent = null, l.decomposeTransform(), l.parent = u, s && (l.scaleY = -l.scaleY), this._updateTransform();
    }, e.prototype.getRegion = function(t) {
      return this._regionsMap.get(t);
    }, e.prototype.getRegionByCoord = function(t) {
      for (var i = this.regions, n = 0; n < i.length; n++) {
        var a = i[n];
        if (a.type === "geoJSON" && a.contain(t))
          return i[n];
      }
    }, e.prototype.addGeoCoord = function(t, i) {
      this._nameCoordMap.set(t, i);
    }, e.prototype.getGeoCoord = function(t) {
      var i = this._regionsMap.get(t);
      return this._nameCoordMap.get(t) || i && i.getCenter();
    }, e.prototype.dataToPoint = function(t, i, n) {
      if (ne(t) && (t = this.getGeoCoord(t)), t) {
        var a = this.projection;
        return a && (t = a.project(t)), t && this.projectedToPoint(t, i, n);
      }
    }, e.prototype.pointToData = function(t) {
      var i = this.projection;
      return i && (t = i.unproject(t)), t && this.pointToProjected(t);
    }, e.prototype.pointToProjected = function(t) {
      return r.prototype.pointToData.call(this, t);
    }, e.prototype.projectedToPoint = function(t, i, n) {
      return r.prototype.dataToPoint.call(this, t, i, n);
    }, e.prototype.convertToPixel = function(t, i, n) {
      var a = h2(i);
      return a === this ? a.dataToPoint(n) : null;
    }, e.prototype.convertFromPixel = function(t, i, n) {
      var a = h2(i);
      return a === this ? a.pointToData(n) : null;
    }, e;
  }(Vv)
);
br(e4, Vv);
function h2(r) {
  var e = r.geoModel, t = r.seriesModel;
  return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", Or).models[0] || {}).coordinateSystem : null;
}
const f2 = e4;
function d2(r, e) {
  var t = r.get("boundingCoords");
  if (t != null) {
    var i = t[0], n = t[1];
    if (!(isFinite(i[0]) && isFinite(i[1]) && isFinite(n[0]) && isFinite(n[1])))
      ({}).NODE_ENV !== "production" && console.error("Invalid boundingCoords");
    else {
      var a = this.projection;
      if (a) {
        var o = i[0], s = i[1], l = n[0], u = n[1];
        i = [1 / 0, 1 / 0], n = [-1 / 0, -1 / 0];
        var c = function(T, y, R, _) {
          for (var C = R - T, I = _ - y, w = 0; w <= 100; w++) {
            var x = w / 100, P = a.project([T + C * x, y + I * x]);
            Js(i, i, P), el(n, n, P);
          }
        };
        c(o, s, l, s), c(l, s, l, u), c(l, u, o, u), c(o, u, l, s);
      }
      this.setBoundingRect(i[0], i[1], n[0] - i[0], n[1] - i[1]);
    }
  }
  var h = this.getBoundingRect(), f = r.get("layoutCenter"), d = r.get("layoutSize"), p = e.getWidth(), g = e.getHeight(), v = h.width / h.height * this.aspectScale, O = !1, m, E;
  f && d && (m = [K(f[0], p), K(f[1], g)], E = K(d, Math.min(p, g)), !isNaN(m[0]) && !isNaN(m[1]) && !isNaN(E) ? O = !0 : {}.NODE_ENV !== "production" && console.warn("Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead."));
  var b;
  if (O)
    b = {}, v > 1 ? (b.width = E, b.height = E / v) : (b.height = E, b.width = E * v), b.y = m[1] - b.height / 2, b.x = m[0] - b.width / 2;
  else {
    var S = r.getBoxLayoutParams();
    S.aspect = v, b = Ir(S, {
      width: p,
      height: g
    });
  }
  this.setViewRect(b.x, b.y, b.width, b.height), this.setCenter(r.get("center"), e), this.setZoom(r.get("zoom"));
}
function lve(r, e) {
  N(e.get("geoCoord"), function(t, i) {
    r.addGeoCoord(i, t);
  });
}
var uve = (
  /** @class */
  function() {
    function r() {
      this.dimensions = J3;
    }
    return r.prototype.create = function(e, t) {
      var i = [];
      function n(o) {
        return {
          nameProperty: o.get("nameProperty"),
          aspectScale: o.get("aspectScale"),
          projection: o.get("projection")
        };
      }
      e.eachComponent("geo", function(o, s) {
        var l = o.get("map"), u = new f2(l + s, l, B({
          nameMap: o.get("nameMap")
        }, n(o)));
        u.zoomLimit = o.get("scaleLimit"), i.push(u), o.coordinateSystem = u, u.model = o, u.resize = d2, u.resize(o, t);
      }), e.eachSeries(function(o) {
        var s = o.get("coordinateSystem");
        if (s === "geo") {
          var l = o.get("geoIndex") || 0;
          o.coordinateSystem = i[l];
        }
      });
      var a = {};
      return e.eachSeriesByType("map", function(o) {
        if (!o.getHostGeoModel()) {
          var s = o.getMapType();
          a[s] = a[s] || [], a[s].push(o);
        }
      }), N(a, function(o, s) {
        var l = Y(o, function(c) {
          return c.get("nameMap");
        }), u = new f2(s, s, B({
          nameMap: _1(l)
        }, n(o[0])));
        u.zoomLimit = vr.apply(null, Y(o, function(c) {
          return c.get("scaleLimit");
        })), i.push(u), u.resize = d2, u.resize(o[0], t), N(o, function(c) {
          c.coordinateSystem = u, lve(u, c);
        });
      }), i;
    }, r.prototype.getFilledRegions = function(e, t, i, n) {
      for (var a = (e || []).slice(), o = de(), s = 0; s < a.length; s++)
        o.set(a[s].name, a[s]);
      var l = fs.load(t, i, n);
      return N(l.regions, function(u) {
        var c = u.name;
        !o.get(c) && a.push({
          name: c
        });
      }), a;
    }, r;
  }()
), cve = new uve();
const t4 = cve;
var hve = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i, n) {
      var a = fs.getGeoResource(t.map);
      if (a && a.type === "geoJSON") {
        var o = t.itemStyle = t.itemStyle || {};
        "color" in o || (o.color = "#eee");
      }
      this.mergeDefaultAndTheme(t, n), Ic(t, "label", ["show"]);
    }, e.prototype.optionUpdated = function() {
      var t = this, i = this.option;
      i.regions = t4.getFilledRegions(i.regions, i.map, i.nameMap, i.nameProperty);
      var n = {};
      this._optionModelMap = To(i.regions || [], function(a, o) {
        var s = o.name;
        return s && (a.set(s, new Ut(o, t, t.ecModel)), o.selected && (n[s] = !0)), a;
      }, de()), i.selectedMap || (i.selectedMap = n);
    }, e.prototype.getRegionModel = function(t) {
      return this._optionModelMap.get(t) || new Ut(null, this, this.ecModel);
    }, e.prototype.getFormattedLabel = function(t, i) {
      var n = this.getRegionModel(t), a = i === "normal" ? n.get(["label", "formatter"]) : n.get(["emphasis", "label", "formatter"]), o = {
        name: t
      };
      if (ve(a))
        return o.status = i, a(o);
      if (ne(a))
        return a.replace("{a}", t ?? "");
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.select = function(t) {
      var i = this.option, n = i.selectedMode;
      if (n) {
        n !== "multiple" && (i.selectedMap = null);
        var a = i.selectedMap || (i.selectedMap = {});
        a[t] = !0;
      }
    }, e.prototype.unSelect = function(t) {
      var i = this.option.selectedMap;
      i && (i[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      this[this.isSelected(t) ? "unSelect" : "select"](t);
    }, e.prototype.isSelected = function(t) {
      var i = this.option.selectedMap;
      return !!(i && i[t]);
    }, e.type = "geo", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      show: !0,
      left: "center",
      top: "center",
      // Default value:
      // for geoSVG source: 1,
      // for geoJSON source: 0.75.
      aspectScale: null,
      // /// Layout with center and size
      // If you want to put map in a fixed size box with right aspect ratio
      // This two properties may be more convenient
      // layoutCenter: [50%, 50%]
      // layoutSize: 100
      silent: !1,
      // Map type
      map: "",
      // Define left-top, right-bottom coords to control view
      // For example, [ [180, 90], [-180, -90] ]
      boundingCoords: null,
      // Default on center of map
      center: null,
      zoom: 1,
      scaleLimit: null,
      // selectedMode: false
      label: {
        show: !1,
        color: "#000"
      },
      itemStyle: {
        borderWidth: 0.5,
        borderColor: "#444"
        // Default color:
        // + geoJSON: #eee
        // + geoSVG: null (use SVG original `fill`)
        // color: '#eee'
      },
      emphasis: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      select: {
        label: {
          show: !0,
          color: "rgb(100,0,0)"
        },
        itemStyle: {
          color: "rgba(255,215,0,0.8)"
        }
      },
      regions: []
      // tooltip: {
      //     show: false
      // }
    }, e;
  }(st)
);
const fve = hve;
function p2(r, e) {
  return r.pointToProjected ? r.pointToProjected(e) : r.pointToData(e);
}
function $N(r, e, t, i) {
  var n = r.getZoom(), a = r.getCenter(), o = e.zoom, s = r.projectedToPoint ? r.projectedToPoint(a) : r.dataToPoint(a);
  if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, r.setCenter(p2(r, s), i)), o != null) {
    if (t) {
      var l = t.min || 0, u = t.max || 1 / 0;
      o = Math.max(Math.min(n * o, u), l) / n;
    }
    r.scaleX *= o, r.scaleY *= o;
    var c = (e.originX - r.x) * (o - 1), h = (e.originY - r.y) * (o - 1);
    r.x -= c, r.y -= h, r.updateTransform(), r.setCenter(p2(r, s), i), r.setZoom(o * n);
  }
  return {
    center: r.getCenter(),
    zoom: r.getZoom()
  };
}
var dve = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.focusBlurEnabled = !0, t;
    }
    return e.prototype.init = function(t, i) {
      this._api = i;
    }, e.prototype.render = function(t, i, n, a) {
      if (this._model = t, !t.get("show")) {
        this._mapDraw && this._mapDraw.remove(), this._mapDraw = null;
        return;
      }
      this._mapDraw || (this._mapDraw = new K3(n));
      var o = this._mapDraw;
      o.draw(t, i, n, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, i, n);
    }, e.prototype._handleRegionClick = function(t) {
      var i;
      ju(t.target, function(n) {
        return (i = Pe(n).eventData) != null;
      }, !0), i && this._api.dispatchAction({
        type: "geoToggleSelect",
        geoId: this._model.id,
        name: i.name
      });
    }, e.prototype.updateSelectStatus = function(t, i, n) {
      var a = this;
      this._mapDraw.group.traverse(function(o) {
        var s = Pe(o).eventData;
        if (s)
          return a._model.isSelected(s.name) ? n.enterSelect(o) : n.leaveSelect(o), !0;
      });
    }, e.prototype.findHighDownDispatchers = function(t) {
      return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model);
    }, e.prototype.dispose = function() {
      this._mapDraw && this._mapDraw.remove();
    }, e.type = "geo", e;
  }(jt)
);
const pve = dve;
function gve(r, e, t) {
  fs.registerMap(r, e, t);
}
function r4(r) {
  r.registerCoordinateSystem("geo", t4), r.registerComponentModel(fve), r.registerComponentView(pve), r.registerImpl("registerMap", gve), r.registerImpl("getMap", function(t) {
    return fs.getMapForUser(t);
  });
  function e(t, i) {
    i.update = "geo:updateSelectStatus", r.registerAction(i, function(n, a) {
      var o = {}, s = [];
      return a.eachComponent({
        mainType: "geo",
        query: n
      }, function(l) {
        l[t](n.name);
        var u = l.coordinateSystem;
        N(u.regions, function(h) {
          o[h.name] = l.isSelected(h.name) || !1;
        });
        var c = [];
        N(o, function(h, f) {
          o[f] && c.push(f);
        }), s.push({
          geoIndex: l.componentIndex,
          // Use singular, the same naming convention as the event `selectchanged`.
          name: c
        });
      }), {
        selected: o,
        allSelected: s,
        name: n.name
      };
    });
  }
  e("toggleSelected", {
    type: "geoToggleSelect",
    event: "geoselectchanged"
  }), e("select", {
    type: "geoSelect",
    event: "geoselected"
  }), e("unSelect", {
    type: "geoUnSelect",
    event: "geounselected"
  }), r.registerAction({
    type: "geoRoam",
    event: "geoRoam",
    update: "updateTransform"
  }, function(t, i, n) {
    var a = t.componentType || "series";
    i.eachComponent({
      mainType: a,
      query: t
    }, function(o) {
      var s = o.coordinateSystem;
      if (s.type === "geo") {
        var l = $N(s, t, o.get("scaleLimit"), n);
        o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && N(o.seriesGroup, function(u) {
          u.setCenter(l.center), u.setZoom(l.zoom);
        });
      }
    });
  });
}
function vve(r) {
  Ye(r4), r.registerChartView(eve), r.registerSeriesModel(rve), r.registerLayout(ave), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, nve), iz("map", r.registerAction);
}
function Ove(r) {
  var e = r;
  e.hierNode = {
    defaultAncestor: null,
    ancestor: e,
    prelim: 0,
    modifier: 0,
    change: 0,
    shift: 0,
    i: 0,
    thread: null
  };
  for (var t = [e], i, n; i = t.pop(); )
    if (n = i.children, i.isExpand && n.length)
      for (var a = n.length, o = a - 1; o >= 0; o--) {
        var s = n[o];
        s.hierNode = {
          defaultAncestor: null,
          ancestor: s,
          prelim: 0,
          modifier: 0,
          change: 0,
          shift: 0,
          i: o,
          thread: null
        }, t.push(s);
      }
}
function mve(r, e) {
  var t = r.isExpand ? r.children : [], i = r.parentNode.children, n = r.hierNode.i ? i[r.hierNode.i - 1] : null;
  if (t.length) {
    Sve(r);
    var a = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2;
    n ? (r.hierNode.prelim = n.hierNode.prelim + e(r, n), r.hierNode.modifier = r.hierNode.prelim - a) : r.hierNode.prelim = a;
  } else
    n && (r.hierNode.prelim = n.hierNode.prelim + e(r, n));
  r.parentNode.hierNode.defaultAncestor = Tve(r, n, r.parentNode.hierNode.defaultAncestor || i[0], e);
}
function Eve(r) {
  var e = r.hierNode.prelim + r.parentNode.hierNode.modifier;
  r.setLayout({
    x: e
  }, !0), r.hierNode.modifier += r.parentNode.hierNode.modifier;
}
function g2(r) {
  return arguments.length ? r : Ave;
}
function Tp(r, e) {
  return r -= Math.PI / 2, {
    x: e * Math.cos(r),
    y: e * Math.sin(r)
  };
}
function bve(r, e) {
  return Ir(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function Sve(r) {
  for (var e = r.children, t = e.length, i = 0, n = 0; --t >= 0; ) {
    var a = e[t];
    a.hierNode.prelim += i, a.hierNode.modifier += i, n += a.hierNode.change, i += a.hierNode.shift + n;
  }
}
function Tve(r, e, t, i) {
  if (e) {
    for (var n = r, a = r, o = a.parentNode.children[0], s = e, l = n.hierNode.modifier, u = a.hierNode.modifier, c = o.hierNode.modifier, h = s.hierNode.modifier; s = cR(s), a = hR(a), s && a; ) {
      n = cR(n), o = hR(o), n.hierNode.ancestor = r;
      var f = s.hierNode.prelim + h - a.hierNode.prelim - u + i(s, a);
      f > 0 && (Rve(yve(s, r, t), r, f), u += f, l += f), h += s.hierNode.modifier, u += a.hierNode.modifier, l += n.hierNode.modifier, c += o.hierNode.modifier;
    }
    s && !cR(n) && (n.hierNode.thread = s, n.hierNode.modifier += h - l), a && !hR(o) && (o.hierNode.thread = a, o.hierNode.modifier += u - c, t = r);
  }
  return t;
}
function cR(r) {
  var e = r.children;
  return e.length && r.isExpand ? e[e.length - 1] : r.hierNode.thread;
}
function hR(r) {
  var e = r.children;
  return e.length && r.isExpand ? e[0] : r.hierNode.thread;
}
function yve(r, e, t) {
  return r.hierNode.ancestor.parentNode === e.parentNode ? r.hierNode.ancestor : t;
}
function Rve(r, e, t) {
  var i = t / (e.hierNode.i - r.hierNode.i);
  e.hierNode.change -= i, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, r.hierNode.change += i;
}
function Ave(r, e) {
  return r.parentNode === e.parentNode ? 1 : 2;
}
var _ve = (
  /** @class */
  function() {
    function r() {
      this.parentPoint = [], this.childPoints = [];
    }
    return r;
  }()
), Cve = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new _ve();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.childPoints, a = n.length, o = i.parentPoint, s = n[0], l = n[a - 1];
      if (a === 1) {
        t.moveTo(o[0], o[1]), t.lineTo(s[0], s[1]);
        return;
      }
      var u = i.orient, c = u === "TB" || u === "BT" ? 0 : 1, h = 1 - c, f = K(i.forkPosition, 1), d = [];
      d[c] = o[c], d[h] = o[h] + (l[h] - o[h]) * f, t.moveTo(o[0], o[1]), t.lineTo(d[0], d[1]), t.moveTo(s[0], s[1]), d[c] = s[c], t.lineTo(d[0], d[1]), d[c] = l[c], t.lineTo(d[0], d[1]), t.lineTo(l[0], l[1]);
      for (var p = 1; p < a - 1; p++) {
        var g = n[p];
        t.moveTo(g[0], g[1]), d[c] = g[c], t.lineTo(d[0], d[1]);
      }
    }, e;
  }(He)
), Ive = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._mainGroup = new Re(), t;
    }
    return e.prototype.init = function(t, i) {
      this._controller = new $v(i.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = t.layoutInfo, s = this._mainGroup, l = t.get("layout");
      l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(t, n), this._updateController(t, i, n);
      var u = this._data;
      a.diff(u).add(function(c) {
        v2(a, c) && O2(a, c, null, s, t);
      }).update(function(c, h) {
        var f = u.getItemGraphicEl(h);
        if (!v2(a, c)) {
          f && E2(u, h, f, s, t);
          return;
        }
        O2(a, c, f, s, t);
      }).remove(function(c) {
        var h = u.getItemGraphicEl(c);
        h && E2(u, c, h, s, t);
      }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === !0 && a.eachItemGraphicEl(function(c, h) {
        c.off("click").on("click", function() {
          n.dispatchAction({
            type: "treeExpandAndCollapse",
            seriesId: t.id,
            dataIndex: h
          });
        });
      }), this._data = a;
    }, e.prototype._updateViewCoordSys = function(t, i) {
      var n = t.getData(), a = [];
      n.each(function(h) {
        var f = n.getItemLayout(h);
        f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y]);
      });
      var o = [], s = [];
      gT(a, o, s);
      var l = this._min, u = this._max;
      s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = u ? u[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = u ? u[1] : s[1] + 1);
      var c = t.coordinateSystem = new Vv();
      c.zoomLimit = t.get("scaleLimit"), c.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), c.setCenter(t.get("center"), i), c.setZoom(t.get("zoom")), this.group.attr({
        x: c.x,
        y: c.y,
        scaleX: c.scaleX,
        scaleY: c.scaleY
      }), this._min = o, this._max = s;
    }, e.prototype._updateController = function(t, i, n) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      o.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !$T(u, n, t);
      }), o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        kN(s, u.dx, u.dy), n.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        QN(s, u.scale, u.originX, u.originY), n.dispatchAction({
          seriesId: t.id,
          type: "treeRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(t), n.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function(t) {
      var i = t.getData(), n = this._getNodeGlobalScale(t);
      i.eachItemGraphicEl(function(a, o) {
        a.setSymbolScale(n);
      });
    }, e.prototype._getNodeGlobalScale = function(t) {
      var i = t.coordinateSystem;
      if (i.type !== "view")
        return 1;
      var n = this._nodeScaleRatio, a = i.scaleX || 1, o = i.getZoom(), s = (o - 1) * n + 1;
      return s / a;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype.remove = function() {
      this._mainGroup.removeAll(), this._data = null;
    }, e.type = "tree", e;
  }($t)
);
function v2(r, e) {
  var t = r.getItemLayout(e);
  return t && !isNaN(t.x) && !isNaN(t.y);
}
function O2(r, e, t, i, n) {
  var a = !t, o = r.tree.getNodeByDataIndex(e), s = o.getModel(), l = o.getVisual("style").fill, u = o.isExpand === !1 && o.children.length !== 0 ? l : "#fff", c = r.tree.root, h = o.parentNode === c ? o : o.parentNode || o, f = r.getItemGraphicEl(h.dataIndex), d = h.getLayout(), p = f ? {
    x: f.__oldX,
    y: f.__oldY,
    rawX: f.__radialOldRawX,
    rawY: f.__radialOldRawY
  } : d, g = o.getLayout();
  a ? (t = new Dv(r, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.x = p.x, t.y = p.y) : t.updateData(r, e, null, {
    symbolInnerColor: u,
    useNameLabel: !0
  }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = g.rawX, t.__radialRawY = g.rawY, i.add(t), r.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, Ot(t, {
    x: g.x,
    y: g.y
  }, n);
  var v = t.getSymbolPath();
  if (n.get("layout") === "radial") {
    var O = c.children[0], m = O.getLayout(), E = O.children.length, b = void 0, S = void 0;
    if (g.x === m.x && o.isExpand === !0 && O.children.length) {
      var T = {
        x: (O.children[0].getLayout().x + O.children[E - 1].getLayout().x) / 2,
        y: (O.children[0].getLayout().y + O.children[E - 1].getLayout().y) / 2
      };
      b = Math.atan2(T.y - m.y, T.x - m.x), b < 0 && (b = Math.PI * 2 + b), S = T.x < m.x, S && (b = b - Math.PI);
    } else
      b = Math.atan2(g.y - m.y, g.x - m.x), b < 0 && (b = Math.PI * 2 + b), o.children.length === 0 || o.children.length !== 0 && o.isExpand === !1 ? (S = g.x < m.x, S && (b = b - Math.PI)) : (S = g.x > m.x, S || (b = b - Math.PI));
    var y = S ? "left" : "right", R = s.getModel("label"), _ = R.get("rotate"), C = _ * (Math.PI / 180), I = v.getTextContent();
    I && (v.setTextConfig({
      position: R.get("position") || y,
      rotation: _ == null ? -b : C,
      origin: "center"
    }), I.setStyle("verticalAlign", "middle"));
  }
  var w = s.get(["emphasis", "focus"]), x = w === "relative" ? qE(o.getAncestorsIndices(), o.getDescendantIndices()) : w === "ancestor" ? o.getAncestorsIndices() : w === "descendant" ? o.getDescendantIndices() : null;
  x && (Pe(t).focus = x), wve(n, o, c, t, p, d, g, i), t.__edge && (t.onHoverStateChange = function(P) {
    if (P !== "blur") {
      var L = o.parentNode && r.getItemGraphicEl(o.parentNode.dataIndex);
      L && L.hoverState === Av || ob(t.__edge, P);
    }
  });
}
function wve(r, e, t, i, n, a, o, s) {
  var l = e.getModel(), u = r.get("edgeShape"), c = r.get("layout"), h = r.getOrient(), f = r.get(["lineStyle", "curveness"]), d = r.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), g = i.__edge;
  if (u === "curve")
    e.parentNode && e.parentNode !== t && (g || (g = i.__edge = new ET({
      shape: QC(c, h, f, n, n)
    })), Ot(g, {
      shape: QC(c, h, f, a, o)
    }, r));
  else if (u === "polyline") {
    if (c === "orthogonal") {
      if (e !== t && e.children && e.children.length !== 0 && e.isExpand === !0) {
        for (var v = e.children, O = [], m = 0; m < v.length; m++) {
          var E = v[m].getLayout();
          O.push([E.x, E.y]);
        }
        g || (g = i.__edge = new Cve({
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: [[o.x, o.y]],
            orient: h,
            forkPosition: d
          }
        })), Ot(g, {
          shape: {
            parentPoint: [o.x, o.y],
            childPoints: O
          }
        }, r);
      }
    } else if ({}.NODE_ENV !== "production")
      throw new Error("The polyline edgeShape can only be used in orthogonal layout");
  }
  g && !(u === "polyline" && !e.isExpand) && (g.useStyle(Te({
    strokeNoScale: !0,
    fill: null
  }, p)), ri(g, l, "lineStyle"), xc(g), s.add(g));
}
function m2(r, e, t, i, n) {
  var a = e.tree.root, o = i4(a, r), s = o.source, l = o.sourceLayout, u = e.getItemGraphicEl(r.dataIndex);
  if (u) {
    var c = e.getItemGraphicEl(s.dataIndex), h = c.__edge, f = u.__edge || (s.isExpand === !1 || s.children.length === 1 ? h : void 0), d = i.get("edgeShape"), p = i.get("layout"), g = i.get("orient"), v = i.get(["lineStyle", "curveness"]);
    f && (d === "curve" ? xl(f, {
      shape: QC(p, g, v, l, l),
      style: {
        opacity: 0
      }
    }, i, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: n
    }) : d === "polyline" && i.get("layout") === "orthogonal" && xl(f, {
      shape: {
        parentPoint: [l.x, l.y],
        childPoints: [[l.x, l.y]]
      },
      style: {
        opacity: 0
      }
    }, i, {
      cb: function() {
        t.remove(f);
      },
      removeOpt: n
    }));
  }
}
function i4(r, e) {
  for (var t = e.parentNode === r ? e : e.parentNode || e, i; i = t.getLayout(), i == null; )
    t = t.parentNode === r ? t : t.parentNode || t;
  return {
    source: t,
    sourceLayout: i
  };
}
function E2(r, e, t, i, n) {
  var a = r.tree.getNodeByDataIndex(e), o = r.tree.root, s = i4(o, a).sourceLayout, l = {
    duration: n.get("animationDurationUpdate"),
    easing: n.get("animationEasingUpdate")
  };
  xl(t, {
    x: s.x + 1,
    y: s.y + 1
  }, n, {
    cb: function() {
      i.remove(t), r.setItemGraphicEl(e, null);
    },
    removeOpt: l
  }), t.fadeOut(null, r.hostModel, {
    fadeLabel: !0,
    animation: l
  }), a.children.forEach(function(u) {
    m2(u, r, i, n, l);
  }), m2(a, r, i, n, l);
}
function QC(r, e, t, i, n) {
  var a, o, s, l, u, c, h, f;
  if (r === "radial") {
    u = i.rawX, h = i.rawY, c = n.rawX, f = n.rawY;
    var d = Tp(u, h), p = Tp(u, h + (f - h) * t), g = Tp(c, f + (h - f) * t), v = Tp(c, f);
    return {
      x1: d.x || 0,
      y1: d.y || 0,
      x2: v.x || 0,
      y2: v.y || 0,
      cpx1: p.x || 0,
      cpy1: p.y || 0,
      cpx2: g.x || 0,
      cpy2: g.y || 0
    };
  } else
    u = i.x, h = i.y, c = n.x, f = n.y, (e === "LR" || e === "RL") && (a = u + (c - u) * t, o = h, s = c + (u - c) * t, l = f), (e === "TB" || e === "BT") && (a = u, o = h + (f - h) * t, s = c, l = f + (h - f) * t);
  return {
    x1: u,
    y1: h,
    x2: c,
    y2: f,
    cpx1: a,
    cpy1: o,
    cpx2: s,
    cpy2: l
  };
}
const Nve = Ive;
var Jn = ft();
function n4(r) {
  var e = r.mainData, t = r.datas;
  t || (t = {
    main: e
  }, r.datasAttr = {
    main: "data"
  }), r.datas = r.mainData = null, a4(e, t, r), N(t, function(i) {
    N(e.TRANSFERABLE_METHODS, function(n) {
      i.wrapMethod(n, Le(xve, r));
    });
  }), e.wrapMethod("cloneShallow", Le(Lve, r)), N(e.CHANGABLE_METHODS, function(i) {
    e.wrapMethod(i, Le(Pve, r));
  }), Se(t[e.dataType] === e);
}
function xve(r, e) {
  if (kve(this)) {
    var t = B({}, Jn(this).datas);
    t[this.dataType] = e, a4(e, t, r);
  } else
    VN(e, this.dataType, Jn(this).mainData, r);
  return e;
}
function Pve(r, e) {
  return r.struct && r.struct.update(), e;
}
function Lve(r, e) {
  return N(Jn(e).datas, function(t, i) {
    t !== e && VN(t.cloneShallow(), i, e, r);
  }), e;
}
function Dve(r) {
  var e = Jn(this).mainData;
  return r == null || e == null ? e : Jn(e).datas[r];
}
function Mve() {
  var r = Jn(this).mainData;
  return r == null ? [{
    data: r
  }] : Y(Ze(Jn(r).datas), function(e) {
    return {
      type: e,
      data: Jn(r).datas[e]
    };
  });
}
function kve(r) {
  return Jn(r).mainData === r;
}
function a4(r, e, t) {
  Jn(r).datas = {}, N(e, function(i, n) {
    VN(i, n, r, t);
  });
}
function VN(r, e, t, i) {
  Jn(t).datas[e] = r, Jn(r).mainData = t, r.dataType = e, i.struct && (r[i.structAttr] = i.struct, i.struct[i.datasAttr[e]] = r), r.getLinkedData = Dve, r.getLinkedDataAll = Mve;
}
var Qve = (
  /** @class */
  function() {
    function r(e, t) {
      this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = e || "", this.hostTree = t;
    }
    return r.prototype.isRemoved = function() {
      return this.dataIndex < 0;
    }, r.prototype.eachNode = function(e, t, i) {
      ve(e) && (i = t, t = e, e = null), e = e || {}, ne(e) && (e = {
        order: e
      });
      var n = e.order || "preorder", a = this[e.attr || "children"], o;
      n === "preorder" && (o = t.call(i, this));
      for (var s = 0; !o && s < a.length; s++)
        a[s].eachNode(e, t, i);
      n === "postorder" && t.call(i, this);
    }, r.prototype.updateDepthAndHeight = function(e) {
      var t = 0;
      this.depth = e;
      for (var i = 0; i < this.children.length; i++) {
        var n = this.children[i];
        n.updateDepthAndHeight(e + 1), n.height > t && (t = n.height);
      }
      this.height = t + 1;
    }, r.prototype.getNodeById = function(e) {
      if (this.getId() === e)
        return this;
      for (var t = 0, i = this.children, n = i.length; t < n; t++) {
        var a = i[t].getNodeById(e);
        if (a)
          return a;
      }
    }, r.prototype.contains = function(e) {
      if (e === this)
        return !0;
      for (var t = 0, i = this.children, n = i.length; t < n; t++) {
        var a = i[t].contains(e);
        if (a)
          return a;
      }
    }, r.prototype.getAncestors = function(e) {
      for (var t = [], i = e ? this : this.parentNode; i; )
        t.push(i), i = i.parentNode;
      return t.reverse(), t;
    }, r.prototype.getAncestorsIndices = function() {
      for (var e = [], t = this; t; )
        e.push(t.dataIndex), t = t.parentNode;
      return e.reverse(), e;
    }, r.prototype.getDescendantIndices = function() {
      var e = [];
      return this.eachNode(function(t) {
        e.push(t.dataIndex);
      }), e;
    }, r.prototype.getValue = function(e) {
      var t = this.hostTree.data;
      return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex);
    }, r.prototype.setLayout = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t);
    }, r.prototype.getLayout = function() {
      return this.hostTree.data.getItemLayout(this.dataIndex);
    }, r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostTree, i = t.data.getItemModel(this.dataIndex);
        return i.getModel(e);
      }
    }, r.prototype.getLevelModel = function() {
      return (this.hostTree.levelModels || [])[this.depth];
    }, r.prototype.setVisual = function(e, t) {
      this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t);
    }, r.prototype.getVisual = function(e) {
      return this.hostTree.data.getItemVisual(this.dataIndex, e);
    }, r.prototype.getRawIndex = function() {
      return this.hostTree.data.getRawIndex(this.dataIndex);
    }, r.prototype.getId = function() {
      return this.hostTree.data.getId(this.dataIndex);
    }, r.prototype.getChildIndex = function() {
      if (this.parentNode) {
        for (var e = this.parentNode.children, t = 0; t < e.length; ++t)
          if (e[t] === this)
            return t;
        return -1;
      }
      return -1;
    }, r.prototype.isAncestorOf = function(e) {
      for (var t = e.parentNode; t; ) {
        if (t === this)
          return !0;
        t = t.parentNode;
      }
      return !1;
    }, r.prototype.isDescendantOf = function(e) {
      return e !== this && e.isAncestorOf(this);
    }, r;
  }()
), Uve = (
  /** @class */
  function() {
    function r(e) {
      this.type = "tree", this._nodes = [], this.hostModel = e;
    }
    return r.prototype.eachNode = function(e, t, i) {
      this.root.eachNode(e, t, i);
    }, r.prototype.getNodeByDataIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this._nodes[t];
    }, r.prototype.getNodeById = function(e) {
      return this.root.getNodeById(e);
    }, r.prototype.update = function() {
      for (var e = this.data, t = this._nodes, i = 0, n = t.length; i < n; i++)
        t[i].dataIndex = -1;
      for (var i = 0, n = e.count(); i < n; i++)
        t[e.getRawIndex(i)].dataIndex = i;
    }, r.prototype.clearLayouts = function() {
      this.data.clearItemLayouts();
    }, r.createTree = function(e, t, i) {
      var n = new r(t), a = [], o = 1;
      s(e);
      function s(c, h) {
        var f = c.value;
        o = Math.max(o, X(f) ? f.length : 1), a.push(c);
        var d = new Qve(Ar(c.name, ""), n);
        h ? $ve(d, h) : n.root = d, n._nodes.push(d);
        var p = c.children;
        if (p)
          for (var g = 0; g < p.length; g++)
            s(p[g], d);
      }
      n.root.updateDepthAndHeight(0);
      var l = xv(a, {
        coordDimensions: ["value"],
        dimensionsCount: o
      }).dimensions, u = new ki(l, t);
      return u.initData(a), i && i(u), n4({
        mainData: u,
        struct: n,
        structAttr: "tree"
      }), n.update(), n;
    }, r;
  }()
);
function $ve(r, e) {
  var t = e.children;
  r.parentNode !== e && (t.push(r), r.parentNode = e);
}
const GN = Uve;
function Xg(r, e, t) {
  if (r && Fe(e, r.type) >= 0) {
    var i = t.getData().tree.root, n = r.targetNode;
    if (ne(n) && (n = i.getNodeById(n)), n && i.contains(n))
      return {
        node: n
      };
    var a = r.targetNodeId;
    if (a != null && (n = i.getNodeById(a)))
      return {
        node: n
      };
  }
}
function o4(r) {
  for (var e = []; r; )
    r = r.parentNode, r && e.push(r);
  return e.reverse();
}
function BN(r, e) {
  var t = o4(r);
  return Fe(t, e) >= 0;
}
function GT(r, e) {
  for (var t = []; r; ) {
    var i = r.dataIndex;
    t.push({
      name: r.name,
      dataIndex: i,
      value: e.getRawValue(i)
    }), r = r.parentNode;
  }
  return t.reverse(), t;
}
var Vve = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.hasSymbolVisual = !0, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t) {
      var i = {
        name: t.name,
        children: t.data
      }, n = t.leaves || {}, a = new Ut(n, this, this.ecModel), o = GN.createTree(i, this, s);
      function s(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = o.getNodeByDataIndex(d);
          return p && p.children.length && p.isExpand || (f.parentModel = a), f;
        });
      }
      var l = 0;
      o.eachNode("preorder", function(h) {
        h.depth > l && (l = h.depth);
      });
      var u = t.expandAndCollapse, c = u && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l;
      return o.root.eachNode("preorder", function(h) {
        var f = h.hostTree.data.getRawDataItem(h.dataIndex);
        h.isExpand = f && f.collapsed != null ? !f.collapsed : h.depth <= c;
      }), o.data;
    }, e.prototype.getOrient = function() {
      var t = this.get("orient");
      return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t;
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.formatTooltip = function(t, i, n) {
      for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(t), l = s.getValue(), u = s.name; s && s !== o; )
        u = s.parentNode.name + "." + u, s = s.parentNode;
      return Qr("nameValue", {
        name: u,
        value: l,
        noValue: isNaN(l) || l == null
      });
    }, e.prototype.getDataParams = function(t) {
      var i = r.prototype.getDataParams.apply(this, arguments), n = this.getData().tree.getNodeByDataIndex(t);
      return i.treeAncestors = GT(n, this), i.collapsed = !n.isExpand, i;
    }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // the position of the whole view
      left: "12%",
      top: "12%",
      right: "12%",
      bottom: "12%",
      // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
      layout: "orthogonal",
      // value can be 'polyline'
      edgeShape: "curve",
      edgeForkPosition: "50%",
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.4,
      // Default on center of graph
      center: null,
      zoom: 1,
      orient: "LR",
      symbol: "emptyCircle",
      symbolSize: 7,
      expandAndCollapse: !0,
      initialTreeDepth: 2,
      lineStyle: {
        color: "#ccc",
        width: 1.5,
        curveness: 0.5
      },
      itemStyle: {
        color: "lightsteelblue",
        // borderColor: '#c23531',
        borderWidth: 1.5
      },
      label: {
        show: !0
      },
      animationEasing: "linear",
      animationDuration: 700,
      animationDurationUpdate: 500
    }, e;
  }(Wt)
);
const Gve = Vve;
function Bve(r, e, t) {
  for (var i = [r], n = [], a; a = i.pop(); )
    if (n.push(a), a.isExpand) {
      var o = a.children;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          i.push(o[s]);
    }
  for (; a = n.pop(); )
    e(a, t);
}
function Hd(r, e) {
  for (var t = [r], i; i = t.pop(); )
    if (e(i), i.isExpand) {
      var n = i.children;
      if (n.length)
        for (var a = n.length - 1; a >= 0; a--)
          t.push(n[a]);
    }
}
function Fve(r, e) {
  r.eachSeriesByType("tree", function(t) {
    Xve(t, e);
  });
}
function Xve(r, e) {
  var t = bve(r, e);
  r.layoutInfo = t;
  var i = r.get("layout"), n = 0, a = 0, o = null;
  i === "radial" ? (n = 2 * Math.PI, a = Math.min(t.height, t.width) / 2, o = g2(function(E, b) {
    return (E.parentNode === b.parentNode ? 1 : 2) / E.depth;
  })) : (n = t.width, a = t.height, o = g2());
  var s = r.getData().tree.root, l = s.children[0];
  if (l) {
    Ove(s), Bve(l, mve, o), s.hierNode.modifier = -l.hierNode.prelim, Hd(l, Eve);
    var u = l, c = l, h = l;
    Hd(l, function(E) {
      var b = E.getLayout().x;
      b < u.getLayout().x && (u = E), b > c.getLayout().x && (c = E), E.depth > h.depth && (h = E);
    });
    var f = u === c ? 1 : o(u, c) / 2, d = f - u.getLayout().x, p = 0, g = 0, v = 0, O = 0;
    if (i === "radial")
      p = n / (c.getLayout().x + f + d), g = a / (h.depth - 1 || 1), Hd(l, function(E) {
        v = (E.getLayout().x + d) * p, O = (E.depth - 1) * g;
        var b = Tp(v, O);
        E.setLayout({
          x: b.x,
          y: b.y,
          rawX: v,
          rawY: O
        }, !0);
      });
    else {
      var m = r.getOrient();
      m === "RL" || m === "LR" ? (g = a / (c.getLayout().x + f + d), p = n / (h.depth - 1 || 1), Hd(l, function(E) {
        O = (E.getLayout().x + d) * g, v = m === "LR" ? (E.depth - 1) * p : n - (E.depth - 1) * p, E.setLayout({
          x: v,
          y: O
        }, !0);
      })) : (m === "TB" || m === "BT") && (p = n / (c.getLayout().x + f + d), g = a / (h.depth - 1 || 1), Hd(l, function(E) {
        v = (E.getLayout().x + d) * p, O = m === "TB" ? (E.depth - 1) * g : a - (E.depth - 1) * g, E.setLayout({
          x: v,
          y: O
        }, !0);
      }));
    }
  }
}
function Yve(r) {
  r.eachSeriesByType("tree", function(e) {
    var t = e.getData(), i = t.tree;
    i.eachNode(function(n) {
      var a = n.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = t.ensureUniqueItemVisual(n.dataIndex, "style");
      B(s, o);
    });
  });
}
function Hve(r) {
  r.registerAction({
    type: "treeExpandAndCollapse",
    event: "treeExpandAndCollapse",
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(i) {
      var n = e.dataIndex, a = i.getData().tree, o = a.getNodeByDataIndex(n);
      o.isExpand = !o.isExpand;
    });
  }), r.registerAction({
    type: "treeRoam",
    event: "treeRoam",
    // Here we set 'none' instead of 'update', because roam action
    // just need to update the transform matrix without having to recalculate
    // the layout. So don't need to go through the whole update process, such
    // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
    update: "none"
  }, function(e, t, i) {
    t.eachComponent({
      mainType: "series",
      subType: "tree",
      query: e
    }, function(n) {
      var a = n.coordinateSystem, o = $N(a, e, void 0, i);
      n.setCenter && n.setCenter(o.center), n.setZoom && n.setZoom(o.zoom);
    });
  });
}
function Wve(r) {
  r.registerChartView(Nve), r.registerSeriesModel(Gve), r.registerLayout(Fve), r.registerVisual(Yve), Hve(r);
}
var b2 = ["treemapZoomToNode", "treemapRender", "treemapMove"];
function zve(r) {
  for (var e = 0; e < b2.length; e++)
    r.registerAction({
      type: b2[e],
      update: "updateView"
    }, ur);
  r.registerAction({
    type: "treemapRootToNode",
    update: "updateView"
  }, function(t, i) {
    i.eachComponent({
      mainType: "series",
      subType: "treemap",
      query: t
    }, n);
    function n(a, o) {
      var s = ["treemapZoomToNode", "treemapRootToNode"], l = Xg(t, s, a);
      if (l) {
        var u = a.getViewRoot();
        u && (t.direction = BN(u, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node);
      }
    }
  });
}
function s4(r) {
  var e = r.getData(), t = e.tree, i = {};
  t.eachNode(function(n) {
    for (var a = n; a && a.depth > 1; )
      a = a.parentNode;
    var o = fC(r.ecModel, a.name || a.dataIndex + "", i);
    n.setVisual("decal", o);
  });
}
var Zve = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.preventUsingHoverLayer = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      var n = {
        name: t.name,
        children: t.data
      };
      l4(n);
      var a = t.levels || [], o = this.designatedVisualItemStyle = {}, s = new Ut({
        itemStyle: o
      }, this, i);
      a = t.levels = qve(a, i);
      var l = Y(a || [], function(h) {
        return new Ut(h, s, i);
      }, this), u = GN.createTree(n, this, c);
      function c(h) {
        h.wrapMethod("getItemModel", function(f, d) {
          var p = u.getNodeByDataIndex(d), g = p ? l[p.depth] : null;
          return f.parentModel = g || s, f;
        });
      }
      return u.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return Qr("nameValue", {
        name: s,
        value: o
      });
    }, e.prototype.getDataParams = function(t) {
      var i = r.prototype.getDataParams.apply(this, arguments), n = this.getData().tree.getNodeByDataIndex(t);
      return i.treeAncestors = GT(n, this), i.treePathInfo = i.treeAncestors, i;
    }, e.prototype.setLayoutInfo = function(t) {
      this.layoutInfo = this.layoutInfo || {}, B(this.layoutInfo, t);
    }, e.prototype.mapIdToIndex = function(t) {
      var i = this._idIndexMap;
      i || (i = this._idIndexMap = de(), this._idIndexMapCount = 0);
      var n = i.get(t);
      return n == null && i.set(t, n = this._idIndexMapCount++), n;
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var i = this.getRawData().tree.root;
      (!t || t !== i && !i.contains(t)) && (this._viewRoot = i);
    }, e.prototype.enableAriaDecal = function() {
      s4(this);
    }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = {
      // Disable progressive rendering
      progressive: 0,
      // size: ['80%', '80%'],            // deprecated, compatible with ec2.
      left: "center",
      top: "middle",
      width: "80%",
      height: "80%",
      sort: !0,
      clipWindow: "origin",
      squareRatio: 0.5 * (1 + Math.sqrt(5)),
      leafDepth: null,
      drillDownIcon: "",
      // to align specialized icon. 
      zoomToNodeRatio: 0.32 * 0.32,
      roam: !0,
      nodeClick: "zoomToNode",
      animation: !0,
      animationDurationUpdate: 900,
      animationEasing: "quinticInOut",
      breadcrumb: {
        show: !0,
        height: 22,
        left: "center",
        top: "bottom",
        // right
        // bottom
        emptyItemWidth: 25,
        itemStyle: {
          color: "rgba(0,0,0,0.7)",
          textStyle: {
            color: "#fff"
          }
        },
        emphasis: {
          itemStyle: {
            color: "rgba(0,0,0,0.9)"
            // '#5793f3',
          }
        }
      },
      label: {
        show: !0,
        // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
        distance: 0,
        padding: 5,
        position: "inside",
        // formatter: null,
        color: "#fff",
        overflow: "truncate"
        // align
        // verticalAlign
      },
      upperLabel: {
        show: !1,
        position: [0, "50%"],
        height: 20,
        // formatter: null,
        // color: '#fff',
        overflow: "truncate",
        // align: null,
        verticalAlign: "middle"
      },
      itemStyle: {
        color: null,
        colorAlpha: null,
        colorSaturation: null,
        borderWidth: 0,
        gapWidth: 0,
        borderColor: "#fff",
        borderColorSaturation: null
        // If specified, borderColor will be ineffective, and the
        // border color is evaluated by color of current node and
        // borderColorSaturation.
      },
      emphasis: {
        upperLabel: {
          show: !0,
          position: [0, "50%"],
          overflow: "truncate",
          verticalAlign: "middle"
        }
      },
      visualDimension: 0,
      visualMin: null,
      visualMax: null,
      color: [],
      // level[n].color (if necessary).
      // + Specify color list of each level. level[0].color would be global
      // color list if not specified. (see method `setDefault`).
      // + But set as a empty array to forbid fetch color from global palette
      // when using nodeModel.get('color'), otherwise nodes on deep level
      // will always has color palette set and are not able to inherit color
      // from parent node.
      // + TreemapSeries.color can not be set as 'none', otherwise effect
      // legend color fetching (see seriesColor.js).
      colorAlpha: null,
      colorSaturation: null,
      colorMappingBy: "index",
      visibleMin: 10,
      // be rendered. Only works when sort is 'asc' or 'desc'.
      childrenVisibleMin: null,
      // grandchildren will not show.
      // Why grandchildren? If not grandchildren but children,
      // some siblings show children and some not,
      // the appearance may be mess and not consistent,
      levels: []
      // Each item: {
      //     visibleMin, itemStyle, visualDimension, label
      // }
    }, e;
  }(Wt)
);
function l4(r) {
  var e = 0;
  N(r.children, function(i) {
    l4(i);
    var n = i.value;
    X(n) && (n = n[0]), e += n;
  });
  var t = r.value;
  X(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), X(r.value) ? r.value[0] = t : r.value = t;
}
function qve(r, e) {
  var t = It(e.get("color")), i = It(e.get(["aria", "decal", "decals"]));
  if (t) {
    r = r || [];
    var n, a;
    N(r, function(s) {
      var l = new Ut(s), u = l.get("color"), c = l.get("decal");
      (l.get(["itemStyle", "color"]) || u && u !== "none") && (n = !0), (l.get(["itemStyle", "decal"]) || c && c !== "none") && (a = !0);
    });
    var o = r[0] || (r[0] = {});
    return n || (o.color = t.slice()), !a && i && (o.decal = i.slice()), r;
  }
}
const jve = Zve;
var Kve = 8, S2 = 8, fR = 5, Jve = (
  /** @class */
  function() {
    function r(e) {
      this.group = new Re(), e.add(this.group);
    }
    return r.prototype.render = function(e, t, i, n) {
      var a = e.getModel("breadcrumb"), o = this.group;
      if (o.removeAll(), !(!a.get("show") || !i)) {
        var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), u = s.getModel("textStyle"), c = l.getModel(["itemStyle", "textStyle"]), h = {
          pos: {
            left: a.get("left"),
            right: a.get("right"),
            top: a.get("top"),
            bottom: a.get("bottom")
          },
          box: {
            width: t.getWidth(),
            height: t.getHeight()
          },
          emptyItemWidth: a.get("emptyItemWidth"),
          totalWidth: 0,
          renderList: []
        };
        this._prepare(i, h, u), this._renderContent(e, h, s, l, u, c, n), IT(o, h.pos, h.box);
      }
    }, r.prototype._prepare = function(e, t, i) {
      for (var n = e; n; n = n.parentNode) {
        var a = Ar(n.getModel().get("name"), ""), o = i.getTextRect(a), s = Math.max(o.width + Kve * 2, t.emptyItemWidth);
        t.totalWidth += s + S2, t.renderList.push({
          node: n,
          text: a,
          width: s
        });
      }
    }, r.prototype._renderContent = function(e, t, i, n, a, o, s) {
      for (var l = 0, u = t.emptyItemWidth, c = e.get(["breadcrumb", "height"]), h = ule(t.pos, t.box), f = t.totalWidth, d = t.renderList, p = n.getModel("itemStyle").getItemStyle(), g = d.length - 1; g >= 0; g--) {
        var v = d[g], O = v.node, m = v.width, E = v.text;
        f > h.width && (f -= m - u, m = u, E = null);
        var b = new rn({
          shape: {
            points: eOe(l, 0, m, c, g === d.length - 1, g === 0)
          },
          style: Te(i.getItemStyle(), {
            lineJoin: "bevel"
          }),
          textContent: new dt({
            style: Qt(a, {
              text: E
            })
          }),
          textConfig: {
            position: "inside"
          },
          z2: Kf * 1e4,
          onclick: Le(s, O)
        });
        b.disableLabelAnimation = !0, b.getTextContent().ensureState("emphasis").style = Qt(o, {
          text: E
        }), b.ensureState("emphasis").style = p, qt(b, n.get("focus"), n.get("blurScope"), n.get("disabled")), this.group.add(b), tOe(b, e, O), l += m + S2;
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r;
  }()
);
function eOe(r, e, t, i, n, a) {
  var o = [[n ? r : r - fR, e], [r + t, e], [r + t, e + i], [n ? r : r - fR, e + i]];
  return !a && o.splice(2, 0, [r + t + fR, e + i / 2]), !n && o.push([r, e + i / 2]), o;
}
function tOe(r, e, t) {
  Pe(r).eventData = {
    componentType: "series",
    componentSubType: "treemap",
    componentIndex: e.componentIndex,
    seriesIndex: e.seriesIndex,
    seriesName: e.name,
    seriesType: "treemap",
    selfType: "breadcrumb",
    nodeData: {
      dataIndex: t && t.dataIndex,
      name: t && t.name
    },
    treePathInfo: t && GT(t, e)
  };
}
const rOe = Jve;
var iOe = (
  /** @class */
  function() {
    function r() {
      this._storage = [], this._elExistsMap = {};
    }
    return r.prototype.add = function(e, t, i, n, a) {
      return this._elExistsMap[e.id] ? !1 : (this._elExistsMap[e.id] = !0, this._storage.push({
        el: e,
        target: t,
        duration: i,
        delay: n,
        easing: a
      }), !0);
    }, r.prototype.finished = function(e) {
      return this._finishedCallback = e, this;
    }, r.prototype.start = function() {
      for (var e = this, t = this._storage.length, i = function() {
        t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback());
      }, n = 0, a = this._storage.length; n < a; n++) {
        var o = this._storage[n];
        o.el.animateTo(o.target, {
          duration: o.duration,
          delay: o.delay,
          easing: o.easing,
          setToFinal: !0,
          done: i,
          aborted: i
        });
      }
      return this;
    }, r;
  }()
);
function nOe() {
  return new iOe();
}
var UC = Re, T2 = ht, y2 = 3, R2 = "label", A2 = "upperLabel", aOe = Kf * 10, oOe = Kf * 2, sOe = Kf * 3, xu = Nc([
  ["fill", "color"],
  // `borderColor` and `borderWidth` has been occupied,
  // so use `stroke` to indicate the stroke of the rect.
  ["stroke", "strokeColor"],
  ["lineWidth", "strokeWidth"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
]), _2 = function(r) {
  var e = xu(r);
  return e.stroke = e.fill = e.lineWidth = null, e;
}, Pb = ft(), lOe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._state = "ready", t._storage = Wd(), t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = i.findComponents({
        mainType: "series",
        subType: "treemap",
        query: a
      });
      if (!(Fe(o, t) < 0)) {
        this.seriesModel = t, this.api = n, this.ecModel = i;
        var s = ["treemapZoomToNode", "treemapRootToNode"], l = Xg(a, s, t), u = a && a.type, c = t.layoutInfo, h = !this._oldTree, f = this._storage, d = u === "treemapRootToNode" && l && f ? {
          rootNodeGroup: f.nodeGroup[l.node.getRawIndex()],
          direction: a.direction
        } : null, p = this._giveContainerGroup(c), g = t.get("animation"), v = this._doRender(p, t, d);
        g && !h && (!u || u === "treemapZoomToNode" || u === "treemapRootToNode") ? this._doAnimation(p, v, t, d) : v.renderFinally(), this._resetController(n), this._renderBreadcrumb(t, n, l);
      }
    }, e.prototype._giveContainerGroup = function(t) {
      var i = this._containerGroup;
      return i || (i = this._containerGroup = new UC(), this._initEvents(i), this.group.add(i)), i.x = t.x, i.y = t.y, i;
    }, e.prototype._doRender = function(t, i, n) {
      var a = i.getData().tree, o = this._oldTree, s = Wd(), l = Wd(), u = this._storage, c = [];
      function h(v, O, m, E) {
        return uOe(i, l, u, n, s, c, v, O, m, E);
      }
      d(a.root ? [a.root] : [], o && o.root ? [o.root] : [], t, a === o || !o, 0);
      var f = p(u);
      return this._oldTree = a, this._storage = l, {
        lastsForAnimation: s,
        willDeleteEls: f,
        renderFinally: g
      };
      function d(v, O, m, E, b) {
        E ? (O = v, N(v, function(y, R) {
          !y.isRemoved() && T(R, R);
        })) : new cs(O, v, S, S).add(T).update(T).remove(Le(T, null)).execute();
        function S(y) {
          return y.getId();
        }
        function T(y, R) {
          var _ = y != null ? v[y] : null, C = R != null ? O[R] : null, I = h(_, C, m, b);
          I && d(_ && _.viewChildren || [], C && C.viewChildren || [], I, E, b + 1);
        }
      }
      function p(v) {
        var O = Wd();
        return v && N(v, function(m, E) {
          var b = O[E];
          N(m, function(S) {
            S && (b.push(S), Pb(S).willDelete = !0);
          });
        }), O;
      }
      function g() {
        N(f, function(v) {
          N(v, function(O) {
            O.parent && O.parent.remove(O);
          });
        }), N(c, function(v) {
          v.invisible = !0, v.dirty();
        });
      }
    }, e.prototype._doAnimation = function(t, i, n, a) {
      var o = n.get("animationDurationUpdate"), s = n.get("animationEasing"), l = (ve(o) ? 0 : o) || 0, u = (ve(s) ? null : s) || "cubicOut", c = nOe();
      N(i.willDeleteEls, function(h, f) {
        N(h, function(d, p) {
          if (!d.invisible) {
            var g = d.parent, v, O = Pb(g);
            if (a && a.direction === "drillDown")
              v = g === a.rootNodeGroup ? {
                shape: {
                  x: 0,
                  y: 0,
                  width: O.nodeWidth,
                  height: O.nodeHeight
                },
                style: {
                  opacity: 0
                }
              } : {
                style: {
                  opacity: 0
                }
              };
            else {
              var m = 0, E = 0;
              O.willDelete || (m = O.nodeWidth / 2, E = O.nodeHeight / 2), v = f === "nodeGroup" ? {
                x: m,
                y: E,
                style: {
                  opacity: 0
                }
              } : {
                shape: {
                  x: m,
                  y: E,
                  width: 0,
                  height: 0
                },
                style: {
                  opacity: 0
                }
              };
            }
            v && c.add(d, v, l, 0, u);
          }
        });
      }), N(this._storage, function(h, f) {
        N(h, function(d, p) {
          var g = i.lastsForAnimation[f][p], v = {};
          g && (d instanceof Re ? g.oldX != null && (v.x = d.x, v.y = d.y, d.x = g.oldX, d.y = g.oldY) : (g.oldShape && (v.shape = B({}, d.shape), d.setShape(g.oldShape)), g.fadein ? (d.setStyle("opacity", 0), v.style = {
            opacity: 1
          }) : d.style.opacity !== 1 && (v.style = {
            opacity: 1
          })), c.add(d, v, l, 0, u));
        });
      }, this), this._state = "animating", c.finished(ue(function() {
        this._state = "ready", i.renderFinally();
      }, this)).start();
    }, e.prototype._resetController = function(t) {
      var i = this._controller;
      i || (i = this._controller = new $v(t.getZr()), i.enable(this.seriesModel.get("roam")), i.on("pan", ue(this._onPan, this)), i.on("zoom", ue(this._onZoom, this)));
      var n = new Ve(0, 0, t.getWidth(), t.getHeight());
      i.setPointerChecker(function(a, o, s) {
        return n.contain(o, s);
      });
    }, e.prototype._clearController = function() {
      var t = this._controller;
      t && (t.dispose(), t = null);
    }, e.prototype._onPan = function(t) {
      if (this._state !== "animating" && (Math.abs(t.dx) > y2 || Math.abs(t.dy) > y2)) {
        var i = this.seriesModel.getData().tree.root;
        if (!i)
          return;
        var n = i.getLayout();
        if (!n)
          return;
        this.api.dispatchAction({
          type: "treemapMove",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: n.x + t.dx,
            y: n.y + t.dy,
            width: n.width,
            height: n.height
          }
        });
      }
    }, e.prototype._onZoom = function(t) {
      var i = t.originX, n = t.originY;
      if (this._state !== "animating") {
        var a = this.seriesModel.getData().tree.root;
        if (!a)
          return;
        var o = a.getLayout();
        if (!o)
          return;
        var s = new Ve(o.x, o.y, o.width, o.height), l = this.seriesModel.layoutInfo;
        i -= l.x, n -= l.y;
        var u = na();
        yo(u, u, [-i, -n]), x1(u, u, [t.scale, t.scale]), yo(u, u, [i, n]), s.applyTransform(u), this.api.dispatchAction({
          type: "treemapRender",
          from: this.uid,
          seriesId: this.seriesModel.id,
          rootRect: {
            x: s.x,
            y: s.y,
            width: s.width,
            height: s.height
          }
        });
      }
    }, e.prototype._initEvents = function(t) {
      var i = this;
      t.on("click", function(n) {
        if (i._state === "ready") {
          var a = i.seriesModel.get("nodeClick", !0);
          if (a) {
            var o = i.findTarget(n.offsetX, n.offsetY);
            if (o) {
              var s = o.node;
              if (s.getLayout().isLeafRoot)
                i._rootToNode(o);
              else if (a === "zoomToNode")
                i._zoomToNode(o);
              else if (a === "link") {
                var l = s.hostTree.data.getItemModel(s.dataIndex), u = l.get("link", !0), c = l.get("target", !0) || "blank";
                u && fb(u, c);
              }
            }
          }
        }
      }, this);
    }, e.prototype._renderBreadcrumb = function(t, i, n) {
      var a = this;
      n || (n = t.get("leafDepth", !0) != null ? {
        node: t.getViewRoot()
      } : this.findTarget(i.getWidth() / 2, i.getHeight() / 2), n || (n = {
        node: t.getData().tree.root
      })), (this._breadcrumb || (this._breadcrumb = new rOe(this.group))).render(t, i, n.node, function(o) {
        a._state !== "animating" && (BN(t.getViewRoot(), o) ? a._rootToNode({
          node: o
        }) : a._zoomToNode({
          node: o
        }));
      });
    }, e.prototype.remove = function() {
      this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = Wd(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove();
    }, e.prototype.dispose = function() {
      this._clearController();
    }, e.prototype._zoomToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapZoomToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype._rootToNode = function(t) {
      this.api.dispatchAction({
        type: "treemapRootToNode",
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t.node
      });
    }, e.prototype.findTarget = function(t, i) {
      var n, a = this.seriesModel.getViewRoot();
      return a.eachNode({
        attr: "viewChildren",
        order: "preorder"
      }, function(o) {
        var s = this._storage.background[o.getRawIndex()];
        if (s) {
          var l = s.transformCoordToLocal(t, i), u = s.shape;
          if (u.x <= l[0] && l[0] <= u.x + u.width && u.y <= l[1] && l[1] <= u.y + u.height)
            n = {
              node: o,
              offsetX: l[0],
              offsetY: l[1]
            };
          else
            return !1;
        }
      }, this), n;
    }, e.type = "treemap", e;
  }($t)
);
function Wd() {
  return {
    nodeGroup: [],
    background: [],
    content: []
  };
}
function uOe(r, e, t, i, n, a, o, s, l, u) {
  if (!o)
    return;
  var c = o.getLayout(), h = r.getData(), f = o.getModel();
  if (h.setItemGraphicEl(o.dataIndex, null), !c || !c.isInView)
    return;
  var d = c.width, p = c.height, g = c.borderWidth, v = c.invisible, O = o.getRawIndex(), m = s && s.getRawIndex(), E = o.viewChildren, b = c.upperHeight, S = E && E.length, T = f.getModel("itemStyle"), y = f.getModel(["emphasis", "itemStyle"]), R = f.getModel(["blur", "itemStyle"]), _ = f.getModel(["select", "itemStyle"]), C = T.get("borderRadius") || 0, I = ge("nodeGroup", UC);
  if (!I)
    return;
  if (l.add(I), I.x = c.x || 0, I.y = c.y || 0, I.markRedraw(), Pb(I).nodeWidth = d, Pb(I).nodeHeight = p, c.isAboveViewRoot)
    return I;
  var w = ge("background", T2, u, oOe);
  w && V(I, w, S && c.upperLabelHeight);
  var x = f.getModel("emphasis"), P = x.get("focus"), L = x.get("blurScope"), D = x.get("disabled"), U = P === "ancestor" ? o.getAncestorsIndices() : P === "descendant" ? o.getDescendantIndices() : P;
  if (S)
    Nl(I) && Zu(I, !1), w && (Zu(w, !D), h.setItemGraphicEl(o.dataIndex, w), iC(w, U, L));
  else {
    var Q = ge("content", T2, u, sOe);
    Q && F(I, Q), w.disableMorphing = !0, w && Nl(w) && Zu(w, !1), Zu(I, !D), h.setItemGraphicEl(o.dataIndex, I), iC(I, U, L);
  }
  return I;
  function V(Ne, Ee, Ge) {
    var Ie = Pe(Ee);
    if (Ie.dataIndex = o.dataIndex, Ie.seriesIndex = r.seriesIndex, Ee.setShape({
      x: 0,
      y: 0,
      width: d,
      height: p,
      r: C
    }), v)
      j(Ee);
    else {
      Ee.invisible = !1;
      var he = o.getVisual("style"), xe = he.stroke, M = _2(T);
      M.fill = xe;
      var k = xu(y);
      k.fill = y.get("borderColor");
      var G = xu(R);
      G.fill = R.get("borderColor");
      var H = xu(_);
      if (H.fill = _.get("borderColor"), Ge) {
        var z = d - 2 * g;
        ae(
          // PENDING: convert ZRColor to ColorString for text.
          Ee,
          xe,
          he.opacity,
          {
            x: g,
            y: 0,
            width: z,
            height: b
          }
        );
      } else
        Ee.removeTextContent();
      Ee.setStyle(M), Ee.ensureState("emphasis").style = k, Ee.ensureState("blur").style = G, Ee.ensureState("select").style = H, xc(Ee);
    }
    Ne.add(Ee);
  }
  function F(Ne, Ee) {
    var Ge = Pe(Ee);
    Ge.dataIndex = o.dataIndex, Ge.seriesIndex = r.seriesIndex;
    var Ie = Math.max(d - 2 * g, 0), he = Math.max(p - 2 * g, 0);
    if (Ee.culling = !0, Ee.setShape({
      x: g,
      y: g,
      width: Ie,
      height: he,
      r: C
    }), v)
      j(Ee);
    else {
      Ee.invisible = !1;
      var xe = o.getVisual("style"), M = xe.fill, k = _2(T);
      k.fill = M, k.decal = xe.decal;
      var G = xu(y), H = xu(R), z = xu(_);
      ae(Ee, M, xe.opacity, null), Ee.setStyle(k), Ee.ensureState("emphasis").style = G, Ee.ensureState("blur").style = H, Ee.ensureState("select").style = z, xc(Ee);
    }
    Ne.add(Ee);
  }
  function j(Ne) {
    !Ne.invisible && a.push(Ne);
  }
  function ae(Ne, Ee, Ge, Ie) {
    var he = f.getModel(Ie ? A2 : R2), xe = Ar(f.get("name"), null), M = he.getShallow("show");
    ii(Ne, kr(f, Ie ? A2 : R2), {
      defaultText: M ? xe : null,
      inheritColor: Ee,
      defaultOpacity: Ge,
      labelFetcher: r,
      labelDataIndex: o.dataIndex
    });
    var k = Ne.getTextContent();
    if (k) {
      var G = k.style, H = I1(G.padding || 0);
      Ie && (Ne.setTextConfig({
        layoutRect: Ie
      }), k.disableLabelLayout = !0), k.beforeUpdate = function() {
        var te = Math.max((Ie ? Ie.width : Ne.shape.width) - H[1] - H[3], 0), se = Math.max((Ie ? Ie.height : Ne.shape.height) - H[0] - H[2], 0);
        (G.width !== te || G.height !== se) && k.setStyle({
          width: te,
          height: se
        });
      }, G.truncateMinChar = 2, G.lineOverflow = "truncate", ce(G, Ie, c);
      var z = k.getState("emphasis");
      ce(z ? z.style : null, Ie, c);
    }
  }
  function ce(Ne, Ee, Ge) {
    var Ie = Ne ? Ne.text : null;
    if (!Ee && Ge.isLeafRoot && Ie != null) {
      var he = r.get("drillDownIcon", !0);
      Ne.text = he ? he + " " + Ie : Ie;
    }
  }
  function ge(Ne, Ee, Ge, Ie) {
    var he = m != null && t[Ne][m], xe = n[Ne];
    return he ? (t[Ne][m] = null, Be(xe, he)) : v || (he = new Ee(), he instanceof aa && (he.z2 = cOe(Ge, Ie)), We(xe, he)), e[Ne][O] = he;
  }
  function Be(Ne, Ee) {
    var Ge = Ne[O] = {};
    Ee instanceof UC ? (Ge.oldX = Ee.x, Ge.oldY = Ee.y) : Ge.oldShape = B({}, Ee.shape);
  }
  function We(Ne, Ee) {
    var Ge = Ne[O] = {}, Ie = o.parentNode, he = Ee instanceof Re;
    if (Ie && (!i || i.direction === "drillDown")) {
      var xe = 0, M = 0, k = n.background[Ie.getRawIndex()];
      !i && k && k.oldShape && (xe = k.oldShape.width, M = k.oldShape.height), he ? (Ge.oldX = 0, Ge.oldY = M) : Ge.oldShape = {
        x: xe,
        y: M,
        width: 0,
        height: 0
      };
    }
    Ge.fadein = !he;
  }
}
function cOe(r, e) {
  return r * aOe + e;
}
const hOe = lOe;
var Yg = N, fOe = be, Lb = -1, FN = (
  /** @class */
  function() {
    function r(e) {
      var t = e.mappingMethod, i = e.type, n = this.option = ye(e);
      this.type = i, this.mappingMethod = t, this._normalizeData = gOe[t];
      var a = r.visualHandlers[i];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[t], t === "piecewise" ? (dR(n), dOe(n)) : t === "category" ? n.categories ? pOe(n) : dR(n, !0) : (Se(t !== "linear" || n.dataExtent), dR(n));
    }
    return r.prototype.mapValueToVisual = function(e) {
      var t = this._normalizeData(e);
      return this._normalizedToVisual(t, e);
    }, r.prototype.getNormalizer = function() {
      return ue(this._normalizeData, this);
    }, r.listVisualTypes = function() {
      return Ze(r.visualHandlers);
    }, r.isValidType = function(e) {
      return r.visualHandlers.hasOwnProperty(e);
    }, r.eachVisual = function(e, t, i) {
      be(e) ? N(e, t, i) : t.call(i, e);
    }, r.mapVisual = function(e, t, i) {
      var n, a = X(e) ? [] : be(e) ? {} : (n = !0, null);
      return r.eachVisual(e, function(o, s) {
        var l = t.call(i, o, s);
        n ? a = l : a[s] = l;
      }), a;
    }, r.retrieveVisuals = function(e) {
      var t = {}, i;
      return e && Yg(r.visualHandlers, function(n, a) {
        e.hasOwnProperty(a) && (t[a] = e[a], i = !0);
      }), i ? t : null;
    }, r.prepareVisualTypes = function(e) {
      if (X(e))
        e = e.slice();
      else if (fOe(e)) {
        var t = [];
        Yg(e, function(i, n) {
          t.push(n);
        }), e = t;
      } else
        return [];
      return e.sort(function(i, n) {
        return n === "color" && i !== "color" && i.indexOf("color") === 0 ? 1 : -1;
      }), e;
    }, r.dependsOn = function(e, t) {
      return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t;
    }, r.findPieceIndex = function(e, t, i) {
      for (var n, a = 1 / 0, o = 0, s = t.length; o < s; o++) {
        var l = t[o].value;
        if (l != null) {
          if (l === e || ne(l) && l === e + "")
            return o;
          i && f(l, o);
        }
      }
      for (var o = 0, s = t.length; o < s; o++) {
        var u = t[o], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (rm(h[1], e, c[1]))
              return o;
          } else if (c[1] === 1 / 0) {
            if (rm(h[0], c[0], e))
              return o;
          } else if (rm(h[0], c[0], e) && rm(h[1], e, c[1]))
            return o;
          i && f(c[0], o), i && f(c[1], o);
        }
      }
      if (i)
        return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : n;
      function f(d, p) {
        var g = Math.abs(d - e);
        g < a && (a = g, n = p);
      }
    }, r.visualHandlers = {
      color: {
        applyVisual: zd("color"),
        getColorMapper: function() {
          var e = this.option;
          return ue(e.mappingMethod === "category" ? function(t, i) {
            return !i && (t = this._normalizeData(t)), yp.call(this, t);
          } : function(t, i, n) {
            var a = !!n;
            return !i && (t = this._normalizeData(t)), n = Wy(t, e.parsedVisual, n), a ? n : jo(n, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(e) {
            return jo(Wy(e, this.option.parsedVisual), "rgba");
          },
          category: yp,
          piecewise: function(e, t) {
            var i = VC.call(this, t);
            return i == null && (i = jo(Wy(e, this.option.parsedVisual), "rgba")), i;
          },
          fixed: Pu
        }
      },
      colorHue: tm(function(e, t) {
        return Xp(e, t);
      }),
      colorSaturation: tm(function(e, t) {
        return Xp(e, null, t);
      }),
      colorLightness: tm(function(e, t) {
        return Xp(e, null, null, t);
      }),
      colorAlpha: tm(function(e, t) {
        return JE(e, t);
      }),
      decal: {
        applyVisual: zd("decal"),
        _normalizedToVisual: {
          linear: null,
          category: yp,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: zd("opacity"),
        _normalizedToVisual: $C([0, 1])
      },
      liftZ: {
        applyVisual: zd("liftZ"),
        _normalizedToVisual: {
          linear: Pu,
          category: Pu,
          piecewise: Pu,
          fixed: Pu
        }
      },
      symbol: {
        applyVisual: function(e, t, i) {
          var n = this.mapValueToVisual(e);
          i("symbol", n);
        },
        _normalizedToVisual: {
          linear: C2,
          category: yp,
          piecewise: function(e, t) {
            var i = VC.call(this, t);
            return i == null && (i = C2.call(this, e)), i;
          },
          fixed: Pu
        }
      },
      symbolSize: {
        applyVisual: zd("symbolSize"),
        _normalizedToVisual: $C([0, 1])
      }
    }, r;
  }()
);
function dOe(r) {
  var e = r.pieceList;
  r.hasSpecialVisual = !1, N(e, function(t, i) {
    t.originIndex = i, t.visual != null && (r.hasSpecialVisual = !0);
  });
}
function pOe(r) {
  var e = r.categories, t = r.categoryMap = {}, i = r.visual;
  if (Yg(e, function(o, s) {
    t[o] = s;
  }), !X(i)) {
    var n = [];
    be(i) ? Yg(i, function(o, s) {
      var l = t[s];
      n[l ?? Lb] = o;
    }) : n[Lb] = i, i = u4(r, n);
  }
  for (var a = e.length - 1; a >= 0; a--)
    i[a] == null && (delete t[e[a]], e.pop());
}
function dR(r, e) {
  var t = r.visual, i = [];
  be(t) ? Yg(t, function(a) {
    i.push(a);
  }) : t != null && i.push(t);
  var n = {
    color: 1,
    symbol: 1
  };
  !e && i.length === 1 && !n.hasOwnProperty(r.type) && (i[1] = i[0]), u4(r, i);
}
function tm(r) {
  return {
    applyVisual: function(e, t, i) {
      var n = this.mapValueToVisual(e);
      i("color", r(t("color"), n));
    },
    _normalizedToVisual: $C([0, 1])
  };
}
function C2(r) {
  var e = this.option.visual;
  return e[Math.round(yt(r, [0, 1], [0, e.length - 1], !0))] || {};
}
function zd(r) {
  return function(e, t, i) {
    i(r, this.mapValueToVisual(e));
  };
}
function yp(r) {
  var e = this.option.visual;
  return e[this.option.loop && r !== Lb ? r % e.length : r];
}
function Pu() {
  return this.option.visual[0];
}
function $C(r) {
  return {
    linear: function(e) {
      return yt(e, r, this.option.visual, !0);
    },
    category: yp,
    piecewise: function(e, t) {
      var i = VC.call(this, t);
      return i == null && (i = yt(e, r, this.option.visual, !0)), i;
    },
    fixed: Pu
  };
}
function VC(r) {
  var e = this.option, t = e.pieceList;
  if (e.hasSpecialVisual) {
    var i = FN.findPieceIndex(r, t), n = t[i];
    if (n && n.visual)
      return n.visual[this.type];
  }
}
function u4(r, e) {
  return r.visual = e, r.type === "color" && (r.parsedVisual = Y(e, function(t) {
    var i = Sn(t);
    return !i && {}.NODE_ENV !== "production" && tr("'" + t + "' is an illegal color, fallback to '#000000'", !0), i || [0, 0, 0, 1];
  })), e;
}
var gOe = {
  linear: function(r) {
    return yt(r, this.option.dataExtent, [0, 1], !0);
  },
  piecewise: function(r) {
    var e = this.option.pieceList, t = FN.findPieceIndex(r, e, !0);
    if (t != null)
      return yt(t, [0, e.length - 1], [0, 1], !0);
  },
  category: function(r) {
    var e = this.option.categories ? this.option.categoryMap[r] : r;
    return e ?? Lb;
  },
  fixed: ur
};
function rm(r, e, t) {
  return r ? e <= t : e < t;
}
const Jr = FN;
var vOe = "itemStyle", c4 = ft();
const OOe = {
  seriesType: "treemap",
  reset: function(r) {
    var e = r.getData().tree, t = e.root;
    t.isRemoved() || h4(
      t,
      // Visual should calculate from tree root but not view root.
      {},
      r.getViewRoot().getAncestors(),
      r
    );
  }
};
function h4(r, e, t, i) {
  var n = r.getModel(), a = r.getLayout(), o = r.hostTree.data;
  if (!(!a || a.invisible || !a.isInView)) {
    var s = n.getModel(vOe), l = mOe(s, e, i), u = o.ensureUniqueItemVisual(r.dataIndex, "style"), c = s.get("borderColor"), h = s.get("borderColorSaturation"), f;
    h != null && (f = I2(l), c = EOe(h, f)), u.stroke = c;
    var d = r.viewChildren;
    if (!d || !d.length)
      f = I2(l), u.fill = f;
    else {
      var p = bOe(r, n, a, s, l, d);
      N(d, function(g, v) {
        if (g.depth >= t.length || g === t[g.depth]) {
          var O = SOe(n, l, g, v, p, i);
          h4(g, O, t, i);
        }
      });
    }
  }
}
function mOe(r, e, t) {
  var i = B({}, e), n = t.designatedVisualItemStyle;
  return N(["color", "colorAlpha", "colorSaturation"], function(a) {
    n[a] = e[a];
    var o = r.get(a);
    n[a] = null, o != null && (i[a] = o);
  }), i;
}
function I2(r) {
  var e = pR(r, "color");
  if (e) {
    var t = pR(r, "colorAlpha"), i = pR(r, "colorSaturation");
    return i && (e = Xp(e, null, null, i)), t && (e = JE(e, t)), e;
  }
}
function EOe(r, e) {
  return e != null ? Xp(e, null, null, r) : null;
}
function pR(r, e) {
  var t = r[e];
  if (t != null && t !== "none")
    return t;
}
function bOe(r, e, t, i, n, a) {
  if (!(!a || !a.length)) {
    var o = gR(e, "color") || n.color != null && n.color !== "none" && (gR(e, "colorAlpha") || gR(e, "colorSaturation"));
    if (o) {
      var s = e.get("visualMin"), l = e.get("visualMax"), u = t.dataExtent.slice();
      s != null && s < u[0] && (u[0] = s), l != null && l > u[1] && (u[1] = l);
      var c = e.get("colorMappingBy"), h = {
        type: o.name,
        dataExtent: u,
        visual: o.range
      };
      h.type === "color" && (c === "index" || c === "id") ? (h.mappingMethod = "category", h.loop = !0) : h.mappingMethod = "linear";
      var f = new Jr(h);
      return c4(f).drColorMappingBy = c, f;
    }
  }
}
function gR(r, e) {
  var t = r.get(e);
  return X(t) && t.length ? {
    name: e,
    range: t
  } : null;
}
function SOe(r, e, t, i, n, a) {
  var o = B({}, e);
  if (n) {
    var s = n.type, l = s === "color" && c4(n).drColorMappingBy, u = l === "index" ? i : l === "id" ? a.mapIdToIndex(t.getId()) : t.getValue(r.get("visualDimension"));
    o[s] = n.mapValueToVisual(u);
  }
  return o;
}
var Hg = Math.max, Db = Math.min, w2 = vr, XN = N, f4 = ["itemStyle", "borderWidth"], TOe = ["itemStyle", "gapWidth"], yOe = ["upperLabel", "show"], ROe = ["upperLabel", "height"];
const AOe = {
  seriesType: "treemap",
  reset: function(r, e, t, i) {
    var n = t.getWidth(), a = t.getHeight(), o = r.option, s = Ir(r.getBoxLayoutParams(), {
      width: t.getWidth(),
      height: t.getHeight()
    }), l = o.size || [], u = K(w2(s.width, l[0]), n), c = K(w2(s.height, l[1]), a), h = i && i.type, f = ["treemapZoomToNode", "treemapRootToNode"], d = Xg(i, f, r), p = h === "treemapRender" || h === "treemapMove" ? i.rootRect : null, g = r.getViewRoot(), v = o4(g);
    if (h !== "treemapMove") {
      var O = h === "treemapZoomToNode" ? xOe(r, d, g, u, c) : p ? [p.width, p.height] : [u, c], m = o.sort;
      m && m !== "asc" && m !== "desc" && (m = "desc");
      var E = {
        squareRatio: o.squareRatio,
        sort: m,
        leafDepth: o.leafDepth
      };
      g.hostTree.clearLayouts();
      var b = {
        x: 0,
        y: 0,
        width: O[0],
        height: O[1],
        area: O[0] * O[1]
      };
      g.setLayout(b), d4(g, E, !1, 0), b = g.getLayout(), XN(v, function(T, y) {
        var R = (v[y + 1] || g).getValue();
        T.setLayout(B({
          dataExtent: [R, R],
          borderWidth: 0,
          upperHeight: 0
        }, b));
      });
    }
    var S = r.getData().tree.root;
    S.setLayout(POe(s, p, d), !0), r.setLayoutInfo(s), p4(
      S,
      // Transform to base element coordinate system.
      new Ve(-s.x, -s.y, n, a),
      v,
      g,
      0
    );
  }
};
function d4(r, e, t, i) {
  var n, a;
  if (!r.isRemoved()) {
    var o = r.getLayout();
    n = o.width, a = o.height;
    var s = r.getModel(), l = s.get(f4), u = s.get(TOe) / 2, c = g4(s), h = Math.max(l, c), f = l - u, d = h - u;
    r.setLayout({
      borderWidth: l,
      upperHeight: h,
      upperLabelHeight: c
    }, !0), n = Hg(n - 2 * f, 0), a = Hg(a - f - d, 0);
    var p = n * a, g = _Oe(r, s, p, e, t, i);
    if (g.length) {
      var v = {
        x: f,
        y: d,
        width: n,
        height: a
      }, O = Db(n, a), m = 1 / 0, E = [];
      E.area = 0;
      for (var b = 0, S = g.length; b < S; ) {
        var T = g[b];
        E.push(T), E.area += T.getLayout().area;
        var y = NOe(E, O, e.squareRatio);
        y <= m ? (b++, m = y) : (E.area -= E.pop().getLayout().area, N2(E, O, v, u, !1), O = Db(v.width, v.height), E.length = E.area = 0, m = 1 / 0);
      }
      if (E.length && N2(E, O, v, u, !0), !t) {
        var R = s.get("childrenVisibleMin");
        R != null && p < R && (t = !0);
      }
      for (var b = 0, S = g.length; b < S; b++)
        d4(g[b], e, t, i + 1);
    }
  }
}
function _Oe(r, e, t, i, n, a) {
  var o = r.children || [], s = i.sort;
  s !== "asc" && s !== "desc" && (s = null);
  var l = i.leafDepth != null && i.leafDepth <= a;
  if (n && !l)
    return r.viewChildren = [];
  o = At(o, function(d) {
    return !d.isRemoved();
  }), IOe(o, s);
  var u = wOe(e, o, s);
  if (u.sum === 0)
    return r.viewChildren = [];
  if (u.sum = COe(e, t, u.sum, s, o), u.sum === 0)
    return r.viewChildren = [];
  for (var c = 0, h = o.length; c < h; c++) {
    var f = o[c].getValue() / u.sum * t;
    o[c].setLayout({
      area: f
    });
  }
  return l && (o.length && r.setLayout({
    isLeafRoot: !0
  }, !0), o.length = 0), r.viewChildren = o, r.setLayout({
    dataExtent: u.dataExtent
  }, !0), o;
}
function COe(r, e, t, i, n) {
  if (!i)
    return t;
  for (var a = r.get("visibleMin"), o = n.length, s = o, l = o - 1; l >= 0; l--) {
    var u = n[i === "asc" ? o - l - 1 : l].getValue();
    u / t * e < a && (s = l, t -= u);
  }
  return i === "asc" ? n.splice(0, o - s) : n.splice(s, o - s), t;
}
function IOe(r, e) {
  return e && r.sort(function(t, i) {
    var n = e === "asc" ? t.getValue() - i.getValue() : i.getValue() - t.getValue();
    return n === 0 ? e === "asc" ? t.dataIndex - i.dataIndex : i.dataIndex - t.dataIndex : n;
  }), r;
}
function wOe(r, e, t) {
  for (var i = 0, n = 0, a = e.length; n < a; n++)
    i += e[n].getValue();
  var o = r.get("visualDimension"), s;
  return !e || !e.length ? s = [NaN, NaN] : o === "value" && t ? (s = [e[e.length - 1].getValue(), e[0].getValue()], t === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], XN(e, function(l) {
    var u = l.getValue(o);
    u < s[0] && (s[0] = u), u > s[1] && (s[1] = u);
  })), {
    sum: i,
    dataExtent: s
  };
}
function NOe(r, e, t) {
  for (var i = 0, n = 1 / 0, a = 0, o = void 0, s = r.length; a < s; a++)
    o = r[a].getLayout().area, o && (o < n && (n = o), o > i && (i = o));
  var l = r.area * r.area, u = e * e * t;
  return l ? Hg(u * i / l, l / (u * n)) : 1 / 0;
}
function N2(r, e, t, i, n) {
  var a = e === t.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], u = t[s[a]], c = e ? r.area / e : 0;
  (n || c > t[l[o]]) && (c = t[l[o]]);
  for (var h = 0, f = r.length; h < f; h++) {
    var d = r[h], p = {}, g = c ? d.getLayout().area / c : 0, v = p[l[o]] = Hg(c - 2 * i, 0), O = t[s[a]] + t[l[a]] - u, m = h === f - 1 || O < g ? O : g, E = p[l[a]] = Hg(m - 2 * i, 0);
    p[s[o]] = t[s[o]] + Db(i, v / 2), p[s[a]] = u + Db(i, E / 2), u += m, d.setLayout(p, !0);
  }
  t[s[o]] += c, t[l[o]] -= c;
}
function xOe(r, e, t, i, n) {
  var a = (e || {}).node, o = [i, n];
  if (!a || a === t)
    return o;
  for (var s, l = i * n, u = l * r.option.zoomToNodeRatio; s = a.parentNode; ) {
    for (var c = 0, h = s.children, f = 0, d = h.length; f < d; f++)
      c += h[f].getValue();
    var p = a.getValue();
    if (p === 0)
      return o;
    u *= c / p;
    var g = s.getModel(), v = g.get(f4), O = Math.max(v, g4(g));
    u += 4 * v * v + (3 * v + O) * Math.pow(u, 0.5), u > VD && (u = VD), a = s;
  }
  u < l && (u = l);
  var m = Math.pow(u / l, 0.5);
  return [i * m, n * m];
}
function POe(r, e, t) {
  if (e)
    return {
      x: e.x,
      y: e.y
    };
  var i = {
    x: 0,
    y: 0
  };
  if (!t)
    return i;
  var n = t.node, a = n.getLayout();
  if (!a)
    return i;
  for (var o = [a.width / 2, a.height / 2], s = n; s; ) {
    var l = s.getLayout();
    o[0] += l.x, o[1] += l.y, s = s.parentNode;
  }
  return {
    x: r.width / 2 - o[0],
    y: r.height / 2 - o[1]
  };
}
function p4(r, e, t, i, n) {
  var a = r.getLayout(), o = t[n], s = o && o === r;
  if (!(o && !s || n === t.length && r !== i)) {
    r.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: !0,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !s && !e.intersect(a),
      isAboveViewRoot: s
    }, !0);
    var l = new Ve(e.x - a.x, e.y - a.y, e.width, e.height);
    XN(r.viewChildren || [], function(u) {
      p4(u, l, t, i, n + 1);
    });
  }
}
function g4(r) {
  return r.get(yOe) ? r.get(ROe) : 0;
}
function LOe(r) {
  r.registerSeriesModel(jve), r.registerChartView(hOe), r.registerVisual(OOe), r.registerLayout(AOe), zve(r);
}
function DOe(r) {
  var e = r.findComponents({
    mainType: "legend"
  });
  !e || !e.length || r.eachSeriesByType("graph", function(t) {
    var i = t.getCategoriesData(), n = t.getGraph(), a = n.data, o = i.mapArray(i.getName);
    a.filterSelf(function(s) {
      var l = a.getItemModel(s), u = l.getShallow("category");
      if (u != null) {
        pt(u) && (u = o[u]);
        for (var c = 0; c < e.length; c++)
          if (!e[c].isSelected(u))
            return !1;
      }
      return !0;
    });
  });
}
function MOe(r) {
  var e = {};
  r.eachSeriesByType("graph", function(t) {
    var i = t.getCategoriesData(), n = t.getData(), a = {};
    i.each(function(o) {
      var s = i.getName(o);
      a["ec-" + s] = o;
      var l = i.getItemModel(o), u = l.getModel("itemStyle").getItemStyle();
      u.fill || (u.fill = t.getColorFromPalette(s, e)), i.setItemVisual(o, "style", u);
      for (var c = ["symbol", "symbolSize", "symbolKeepAspect"], h = 0; h < c.length; h++) {
        var f = l.getShallow(c[h], !0);
        f != null && i.setItemVisual(o, c[h], f);
      }
    }), i.count() && n.each(function(o) {
      var s = n.getItemModel(o), l = s.getShallow("category");
      if (l != null) {
        ne(l) && (l = a["ec-" + l]);
        var u = i.getItemVisual(l, "style"), c = n.ensureUniqueItemVisual(o, "style");
        B(c, u);
        for (var h = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < h.length; f++)
          n.setItemVisual(o, h[f], i.getItemVisual(l, h[f]));
      }
    });
  });
}
function im(r) {
  return r instanceof Array || (r = [r, r]), r;
}
function kOe(r) {
  r.eachSeriesByType("graph", function(e) {
    var t = e.getGraph(), i = e.getEdgeData(), n = im(e.get("edgeSymbol")), a = im(e.get("edgeSymbolSize"));
    i.setVisual("fromSymbol", n && n[0]), i.setVisual("toSymbol", n && n[1]), i.setVisual("fromSymbolSize", a && a[0]), i.setVisual("toSymbolSize", a && a[1]), i.setVisual("style", e.getModel("lineStyle").getLineStyle()), i.each(function(o) {
      var s = i.getItemModel(o), l = t.getEdgeByIndex(o), u = im(s.getShallow("symbol", !0)), c = im(s.getShallow("symbolSize", !0)), h = s.getModel("lineStyle").getLineStyle(), f = i.ensureUniqueItemVisual(o, "style");
      switch (B(f, h), f.stroke) {
        case "source": {
          var d = l.node1.getVisual("style");
          f.stroke = d && d.fill;
          break;
        }
        case "target": {
          var d = l.node2.getVisual("style");
          f.stroke = d && d.fill;
          break;
        }
      }
      u[0] && l.setVisual("fromSymbol", u[0]), u[1] && l.setVisual("toSymbol", u[1]), c[0] && l.setVisual("fromSymbolSize", c[0]), c[1] && l.setVisual("toSymbolSize", c[1]);
    });
  });
}
var GC = "-->", BT = function(r) {
  return r.get("autoCurveness") || null;
}, v4 = function(r, e) {
  var t = BT(r), i = 20, n = [];
  if (pt(t))
    i = t;
  else if (X(t)) {
    r.__curvenessList = t;
    return;
  }
  e > i && (i = e);
  var a = i % 2 ? i + 2 : i + 3;
  n = [];
  for (var o = 0; o < a; o++)
    n.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1));
  r.__curvenessList = n;
}, Wg = function(r, e, t) {
  var i = [r.id, r.dataIndex].join("."), n = [e.id, e.dataIndex].join(".");
  return [t.uid, i, n].join(GC);
}, O4 = function(r) {
  var e = r.split(GC);
  return [e[0], e[2], e[1]].join(GC);
}, QOe = function(r, e) {
  var t = Wg(r.node1, r.node2, e);
  return e.__edgeMap[t];
}, UOe = function(r, e) {
  var t = BC(Wg(r.node1, r.node2, e), e), i = BC(Wg(r.node2, r.node1, e), e);
  return t + i;
}, BC = function(r, e) {
  var t = e.__edgeMap;
  return t[r] ? t[r].length : 0;
};
function $Oe(r) {
  BT(r) && (r.__curvenessList = [], r.__edgeMap = {}, v4(r));
}
function VOe(r, e, t, i) {
  if (BT(t)) {
    var n = Wg(r, e, t), a = t.__edgeMap, o = a[O4(n)];
    a[n] && !o ? a[n].isForward = !0 : o && a[n] && (o.isForward = !0, a[n].isForward = !1), a[n] = a[n] || [], a[n].push(i);
  }
}
function YN(r, e, t, i) {
  var n = BT(e), a = X(n);
  if (!n)
    return null;
  var o = QOe(r, e);
  if (!o)
    return null;
  for (var s = -1, l = 0; l < o.length; l++)
    if (o[l] === t) {
      s = l;
      break;
    }
  var u = UOe(r, e);
  v4(e, u), r.lineStyle = r.lineStyle || {};
  var c = Wg(r.node1, r.node2, e), h = e.__curvenessList, f = a || u % 2 ? 0 : 1;
  if (o.isForward)
    return h[f + s];
  var d = O4(c), p = BC(d, e), g = h[s + p + f];
  return i ? a ? n && n[0] === 0 ? (p + f) % 2 ? g : -g : ((p % 2 ? 0 : 1) + f) % 2 ? g : -g : (p + f) % 2 ? g : -g : h[s + p + f];
}
function m4(r) {
  var e = r.coordinateSystem;
  if (!(e && e.type !== "view")) {
    var t = r.getGraph();
    t.eachNode(function(i) {
      var n = i.getModel();
      i.setLayout([+n.get("x"), +n.get("y")]);
    }), HN(t, r);
  }
}
function HN(r, e) {
  r.eachEdge(function(t, i) {
    var n = Kn(t.getModel().get(["lineStyle", "curveness"]), -YN(t, e, i, !0), 0), a = Zo(t.node1.getLayout()), o = Zo(t.node2.getLayout()), s = [a, o];
    +n && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * n, (a[1] + o[1]) / 2 - (o[0] - a[0]) * n]), t.setLayout(s);
  });
}
function GOe(r, e) {
  r.eachSeriesByType("graph", function(t) {
    var i = t.get("layout"), n = t.coordinateSystem;
    if (n && n.type !== "view") {
      var a = t.getData(), o = [];
      N(n.dimensions, function(f) {
        o = o.concat(a.mapDimensionsAll(f));
      });
      for (var s = 0; s < a.count(); s++) {
        for (var l = [], u = !1, c = 0; c < o.length; c++) {
          var h = a.get(o[c], s);
          isNaN(h) || (u = !0), l.push(h);
        }
        u ? a.setItemLayout(s, n.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]);
      }
      HN(a.graph, t);
    } else
      (!i || i === "none") && m4(t);
  });
}
function Rp(r) {
  var e = r.coordinateSystem;
  if (e.type !== "view")
    return 1;
  var t = r.option.nodeScaleRatio, i = e.scaleX, n = e.getZoom(), a = (n - 1) * t + 1;
  return a / i;
}
function Ap(r) {
  var e = r.getVisual("symbolSize");
  return e instanceof Array && (e = (e[0] + e[1]) / 2), +e;
}
var x2 = Math.PI, vR = [];
function WN(r, e, t, i) {
  var n = r.coordinateSystem;
  if (!(n && n.type !== "view")) {
    var a = n.getBoundingRect(), o = r.getData(), s = o.graph, l = a.width / 2 + a.x, u = a.height / 2 + a.y, c = Math.min(a.width, a.height) / 2, h = o.count();
    if (o.setLayout({
      cx: l,
      cy: u
    }), !!h) {
      if (t) {
        var f = n.pointToData(i), d = f[0], p = f[1], g = [d - l, p - u];
        Zf(g, g), Xm(g, g, c), t.setLayout([l + g[0], u + g[1]], !0);
        var v = r.get(["circular", "rotateLabel"]);
        E4(t, v, l, u);
      }
      BOe[e](r, s, o, c, l, u, h), s.eachEdge(function(O, m) {
        var E = Kn(O.getModel().get(["lineStyle", "curveness"]), YN(O, r, m), 0), b = Zo(O.node1.getLayout()), S = Zo(O.node2.getLayout()), T, y = (b[0] + S[0]) / 2, R = (b[1] + S[1]) / 2;
        +E && (E *= 3, T = [l * E + y * (1 - E), u * E + R * (1 - E)]), O.setLayout([b, S, T]);
      });
    }
  }
}
var BOe = {
  value: function(r, e, t, i, n, a, o) {
    var s = 0, l = t.getSum("value"), u = Math.PI * 2 / (l || o);
    e.eachNode(function(c) {
      var h = c.getValue("value"), f = u * (l ? h : 1) / 2;
      s += f, c.setLayout([i * Math.cos(s) + n, i * Math.sin(s) + a]), s += f;
    });
  },
  symbolSize: function(r, e, t, i, n, a, o) {
    var s = 0;
    vR.length = o;
    var l = Rp(r);
    e.eachNode(function(h) {
      var f = Ap(h);
      isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l;
      var d = Math.asin(f / 2 / i);
      isNaN(d) && (d = x2 / 2), vR[h.dataIndex] = d, s += d * 2;
    });
    var u = (2 * x2 - s) / o / 2, c = 0;
    e.eachNode(function(h) {
      var f = u + vR[h.dataIndex];
      c += f, (!h.getLayout() || !h.getLayout().fixed) && h.setLayout([i * Math.cos(c) + n, i * Math.sin(c) + a]), c += f;
    });
  }
};
function E4(r, e, t, i) {
  var n = r.getGraphicEl();
  if (n) {
    var a = r.getModel(), o = a.get(["label", "rotate"]) || 0, s = n.getSymbolPath();
    if (e) {
      var l = r.getLayout(), u = Math.atan2(l[1] - i, l[0] - t);
      u < 0 && (u = Math.PI * 2 + u);
      var c = l[0] < t;
      c && (u = u - Math.PI);
      var h = c ? "left" : "right";
      s.setTextConfig({
        rotation: -u,
        position: h,
        origin: "center"
      });
      var f = s.ensureState("emphasis");
      B(f.textConfig || (f.textConfig = {}), {
        position: h
      });
    } else
      s.setTextConfig({
        rotation: o *= Math.PI / 180
      });
  }
}
function FOe(r) {
  r.eachSeriesByType("graph", function(e) {
    e.get("layout") === "circular" && WN(e, "symbolSize");
  });
}
var yh = I_;
function XOe(r, e, t) {
  for (var i = r, n = e, a = t.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], u = t.gravity == null ? 0.1 : t.gravity, c = 0; c < i.length; c++) {
    var h = i[c];
    h.p || (h.p = Wc(o * (Math.random() - 0.5) + l[0], s * (Math.random() - 0.5) + l[1])), h.pp = Zo(h.p), h.edges = null;
  }
  var f = t.friction == null ? 0.6 : t.friction, d = f, p, g;
  return {
    warmUp: function() {
      d = f * 0.8;
    },
    setFixed: function(v) {
      i[v].fixed = !0;
    },
    setUnfixed: function(v) {
      i[v].fixed = !1;
    },
    /**
     * Before step hook
     */
    beforeStep: function(v) {
      p = v;
    },
    /**
     * After step hook
     */
    afterStep: function(v) {
      g = v;
    },
    /**
     * Some formulas were originally copied from "d3.js"
     * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
     * with some modifications made for this project.
     * See the license statement at the head of this file.
     */
    step: function(v) {
      p && p(i, n);
      for (var O = [], m = i.length, E = 0; E < n.length; E++) {
        var b = n[E];
        if (!b.ignoreForceLayout) {
          var S = b.n1, T = b.n2;
          Wu(O, T.p, S.p);
          var y = w_(O) - b.d, R = T.w / (S.w + T.w);
          isNaN(R) && (R = 0), Zf(O, O), !S.fixed && yh(S.p, S.p, O, R * y * d), !T.fixed && yh(T.p, T.p, O, -(1 - R) * y * d);
        }
      }
      for (var E = 0; E < m; E++) {
        var _ = i[E];
        _.fixed || (Wu(O, l, _.p), yh(_.p, _.p, O, u * d));
      }
      for (var E = 0; E < m; E++)
        for (var S = i[E], C = E + 1; C < m; C++) {
          var T = i[C];
          Wu(O, T.p, S.p);
          var y = w_(O);
          y === 0 && (Kie(O, Math.random() - 0.5, Math.random() - 0.5), y = 1);
          var I = (S.rep + T.rep) / y / y;
          !S.fixed && yh(S.pp, S.pp, O, I), !T.fixed && yh(T.pp, T.pp, O, -I);
        }
      for (var w = [], E = 0; E < m; E++) {
        var _ = i[E];
        _.fixed || (Wu(w, _.p, _.pp), yh(_.p, _.p, w, d), _i(_.pp, _.p));
      }
      d = d * 0.992;
      var x = d < 0.01;
      g && g(i, n, x), v && v(x);
    }
  };
}
function YOe(r) {
  r.eachSeriesByType("graph", function(e) {
    var t = e.coordinateSystem;
    if (!(t && t.type !== "view"))
      if (e.get("layout") === "force") {
        var i = e.preservedPoints || {}, n = e.getGraph(), a = n.data, o = n.edgeData, s = e.getModel("force"), l = s.get("initLayout");
        e.preservedPoints ? a.each(function(E) {
          var b = a.getId(E);
          a.setItemLayout(E, i[b] || [NaN, NaN]);
        }) : !l || l === "none" ? m4(e) : l === "circular" && WN(e, "value");
        var u = a.getDataExtent("value"), c = o.getDataExtent("value"), h = s.get("repulsion"), f = s.get("edgeLength"), d = X(h) ? h : [h, h], p = X(f) ? f : [f, f];
        p = [p[1], p[0]];
        var g = a.mapArray("value", function(E, b) {
          var S = a.getItemLayout(b), T = yt(E, u, d);
          return isNaN(T) && (T = (d[0] + d[1]) / 2), {
            w: T,
            rep: T,
            fixed: a.getItemModel(b).get("fixed"),
            p: !S || isNaN(S[0]) || isNaN(S[1]) ? null : S
          };
        }), v = o.mapArray("value", function(E, b) {
          var S = n.getEdgeByIndex(b), T = yt(E, c, p);
          isNaN(T) && (T = (p[0] + p[1]) / 2);
          var y = S.getModel(), R = Kn(S.getModel().get(["lineStyle", "curveness"]), -YN(S, e, b, !0), 0);
          return {
            n1: g[S.node1.dataIndex],
            n2: g[S.node2.dataIndex],
            d: T,
            curveness: R,
            ignoreForceLayout: y.get("ignoreForceLayout")
          };
        }), O = t.getBoundingRect(), m = XOe(g, v, {
          rect: O,
          gravity: s.get("gravity"),
          friction: s.get("friction")
        });
        m.beforeStep(function(E, b) {
          for (var S = 0, T = E.length; S < T; S++)
            E[S].fixed && _i(E[S].p, n.getNodeByIndex(S).getLayout());
        }), m.afterStep(function(E, b, S) {
          for (var T = 0, y = E.length; T < y; T++)
            E[T].fixed || n.getNodeByIndex(T).setLayout(E[T].p), i[a.getId(T)] = E[T].p;
          for (var T = 0, y = b.length; T < y; T++) {
            var R = b[T], _ = n.getEdgeByIndex(T), C = R.n1.p, I = R.n2.p, w = _.getLayout();
            w = w ? w.slice() : [], w[0] = w[0] || [], w[1] = w[1] || [], _i(w[0], C), _i(w[1], I), +R.curveness && (w[2] = [(C[0] + I[0]) / 2 - (C[1] - I[1]) * R.curveness, (C[1] + I[1]) / 2 - (I[0] - C[0]) * R.curveness]), _.setLayout(w);
          }
        }), e.forceLayout = m, e.preservedPoints = i, m.step();
      } else
        e.forceLayout = null;
  });
}
function HOe(r, e, t) {
  var i = B(r.getBoxLayoutParams(), {
    aspect: t
  });
  return Ir(i, {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function WOe(r, e) {
  var t = [];
  return r.eachSeriesByType("graph", function(i) {
    var n = i.get("coordinateSystem");
    if (!n || n === "view") {
      var a = i.getData(), o = a.mapArray(function(v) {
        var O = a.getItemModel(v);
        return [+O.get("x"), +O.get("y")];
      }), s = [], l = [];
      gT(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1);
      var u = (l[0] - s[0]) / (l[1] - s[1]), c = HOe(i, e, u);
      isNaN(u) && (s = [c.x, c.y], l = [c.x + c.width, c.y + c.height]);
      var h = l[0] - s[0], f = l[1] - s[1], d = c.width, p = c.height, g = i.coordinateSystem = new Vv();
      g.zoomLimit = i.get("scaleLimit"), g.setBoundingRect(s[0], s[1], h, f), g.setViewRect(c.x, c.y, d, p), g.setCenter(i.get("center"), e), g.setZoom(i.get("zoom")), t.push(g);
    }
  }), t;
}
var P2 = Gr.prototype, mR = ET.prototype, b4 = (
  /** @class */
  function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
    }
    return r;
  }()
);
(function(r) {
  $(e, r);
  function e() {
    return r !== null && r.apply(this, arguments) || this;
  }
  return e;
})(b4);
function ER(r) {
  return isNaN(+r.cpx1) || isNaN(+r.cpy1);
}
var zOe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "ec-line", i;
    }
    return e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new b4();
    }, e.prototype.buildPath = function(t, i) {
      ER(i) ? P2.buildPath.call(this, t, i) : mR.buildPath.call(this, t, i);
    }, e.prototype.pointAt = function(t) {
      return ER(this.shape) ? P2.pointAt.call(this, t) : mR.pointAt.call(this, t);
    }, e.prototype.tangentAt = function(t) {
      var i = this.shape, n = ER(i) ? [i.x2 - i.x1, i.y2 - i.y1] : mR.tangentAt.call(this, t);
      return Zf(n, n);
    }, e;
  }(He)
);
const ZOe = zOe;
var bR = ["fromSymbol", "toSymbol"];
function L2(r) {
  return "_" + r + "Type";
}
function D2(r, e, t) {
  var i = e.getItemVisual(t, r);
  if (!i || i === "none")
    return i;
  var n = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = cd(n), u = qc(o || 0, l);
  return i + l + u + (a || "") + (s || "");
}
function M2(r, e, t) {
  var i = e.getItemVisual(t, r);
  if (!(!i || i === "none")) {
    var n = e.getItemVisual(t, r + "Size"), a = e.getItemVisual(t, r + "Rotate"), o = e.getItemVisual(t, r + "Offset"), s = e.getItemVisual(t, r + "KeepAspect"), l = cd(n), u = qc(o || 0, l), c = Er(i, -l[0] / 2 + u[0], -l[1] / 2 + u[1], l[0], l[1], null, s);
    return c.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, c.name = r, c;
  }
}
function qOe(r) {
  var e = new ZOe({
    name: "line",
    subPixelOptimize: !0
  });
  return FC(e.shape, r), e;
}
function FC(r, e) {
  r.x1 = e[0][0], r.y1 = e[0][1], r.x2 = e[1][0], r.y2 = e[1][1], r.percent = 1;
  var t = e[2];
  t ? (r.cpx1 = t[0], r.cpy1 = t[1]) : (r.cpx1 = NaN, r.cpy1 = NaN);
}
var jOe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      return a._createLine(t, i, n), a;
    }
    return e.prototype._createLine = function(t, i, n) {
      var a = t.hostModel, o = t.getItemLayout(i), s = qOe(o);
      s.shape.percent = 0, Bt(s, {
        shape: {
          percent: 1
        }
      }, a, i), this.add(s), N(bR, function(l) {
        var u = M2(l, t, i);
        this.add(u), this[L2(l)] = D2(l, t, i);
      }, this), this._updateCommonStl(t, i, n);
    }, e.prototype.updateData = function(t, i, n) {
      var a = t.hostModel, o = this.childOfName("line"), s = t.getItemLayout(i), l = {
        shape: {}
      };
      FC(l.shape, s), Ot(o, l, a, i), N(bR, function(u) {
        var c = D2(u, t, i), h = L2(u);
        if (this[h] !== c) {
          this.remove(this.childOfName(u));
          var f = M2(u, t, i);
          this.add(f);
        }
        this[h] = c;
      }, this), this._updateCommonStl(t, i, n);
    }, e.prototype.getLinePath = function() {
      return this.childAt(0);
    }, e.prototype._updateCommonStl = function(t, i, n) {
      var a = t.hostModel, o = this.childOfName("line"), s = n && n.emphasisLineStyle, l = n && n.blurLineStyle, u = n && n.selectLineStyle, c = n && n.labelStatesModels, h = n && n.emphasisDisabled, f = n && n.focus, d = n && n.blurScope;
      if (!n || t.hasItemOption) {
        var p = t.getItemModel(i), g = p.getModel("emphasis");
        s = g.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), u = p.getModel(["select", "lineStyle"]).getLineStyle(), h = g.get("disabled"), f = g.get("focus"), d = g.get("blurScope"), c = kr(p);
      }
      var v = t.getItemVisual(i, "style"), O = v.stroke;
      o.useStyle(v), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = u, N(bR, function(T) {
        var y = this.childOfName(T);
        if (y) {
          y.setColor(O), y.style.opacity = v.opacity;
          for (var R = 0; R < $i.length; R++) {
            var _ = $i[R], C = o.getState(_);
            if (C) {
              var I = C.style || {}, w = y.ensureState(_), x = w.style || (w.style = {});
              I.stroke != null && (x[y.__isEmptyBrush ? "stroke" : "fill"] = I.stroke), I.opacity != null && (x.opacity = I.opacity);
            }
          }
          y.markRedraw();
        }
      }, this);
      var m = a.getRawValue(i);
      ii(this, c, {
        labelDataIndex: i,
        labelFetcher: {
          getFormattedLabel: function(T, y) {
            return a.getFormattedLabel(T, y, t.dataType);
          }
        },
        inheritColor: O || "#000",
        defaultOpacity: v.opacity,
        defaultText: (m == null ? t.getName(i) : isFinite(m) ? rr(m) : m) + ""
      });
      var E = this.getTextContent();
      if (E) {
        var b = c.normal;
        E.__align = E.style.align, E.__verticalAlign = E.style.verticalAlign, E.__position = b.get("position") || "middle";
        var S = b.get("distance");
        X(S) || (S = [S, S]), E.__labelDistance = S;
      }
      this.setTextConfig({
        position: null,
        local: !0,
        inside: !1
        // Can't be inside for stroke element.
      }), qt(this, f, d, h);
    }, e.prototype.highlight = function() {
      ls(this);
    }, e.prototype.downplay = function() {
      us(this);
    }, e.prototype.updateLayout = function(t, i) {
      this.setLinePoints(t.getItemLayout(i));
    }, e.prototype.setLinePoints = function(t) {
      var i = this.childOfName("line");
      FC(i.shape, t), i.dirty();
    }, e.prototype.beforeUpdate = function() {
      var t = this, i = t.childOfName("fromSymbol"), n = t.childOfName("toSymbol"), a = t.getTextContent();
      if (!i && !n && (!a || a.ignore))
        return;
      for (var o = 1, s = this.parent; s; )
        s.scaleX && (o /= s.scaleX), s = s.parent;
      var l = t.childOfName("line");
      if (!this.__dirty && !l.__dirty)
        return;
      var u = l.shape.percent, c = l.pointAt(0), h = l.pointAt(u), f = Wu([], h, c);
      Zf(f, f);
      function d(C, I) {
        var w = C.__specifiedRotation;
        if (w == null) {
          var x = l.tangentAt(I);
          C.attr("rotation", (I === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(x[1], x[0]));
        } else
          C.attr("rotation", w);
      }
      if (i && (i.setPosition(c), d(i, 0), i.scaleX = i.scaleY = o * u, i.markRedraw()), n && (n.setPosition(h), d(n, 1), n.scaleX = n.scaleY = o * u, n.markRedraw()), a && !a.ignore) {
        a.x = a.y = 0, a.originX = a.originY = 0;
        var p = void 0, g = void 0, v = a.__labelDistance, O = v[0] * o, m = v[1] * o, E = u / 2, b = l.tangentAt(E), S = [b[1], -b[0]], T = l.pointAt(E);
        S[1] > 0 && (S[0] = -S[0], S[1] = -S[1]);
        var y = b[0] < 0 ? -1 : 1;
        if (a.__position !== "start" && a.__position !== "end") {
          var R = -Math.atan2(b[1], b[0]);
          h[0] < c[0] && (R = Math.PI + R), a.rotation = R;
        }
        var _ = void 0;
        switch (a.__position) {
          case "insideStartTop":
          case "insideMiddleTop":
          case "insideEndTop":
          case "middle":
            _ = -m, g = "bottom";
            break;
          case "insideStartBottom":
          case "insideMiddleBottom":
          case "insideEndBottom":
            _ = m, g = "top";
            break;
          default:
            _ = 0, g = "middle";
        }
        switch (a.__position) {
          case "end":
            a.x = f[0] * O + h[0], a.y = f[1] * m + h[1], p = f[0] > 0.8 ? "left" : f[0] < -0.8 ? "right" : "center", g = f[1] > 0.8 ? "top" : f[1] < -0.8 ? "bottom" : "middle";
            break;
          case "start":
            a.x = -f[0] * O + c[0], a.y = -f[1] * m + c[1], p = f[0] > 0.8 ? "right" : f[0] < -0.8 ? "left" : "center", g = f[1] > 0.8 ? "bottom" : f[1] < -0.8 ? "top" : "middle";
            break;
          case "insideStartTop":
          case "insideStart":
          case "insideStartBottom":
            a.x = O * y + c[0], a.y = c[1] + _, p = b[0] < 0 ? "right" : "left", a.originX = -O * y, a.originY = -_;
            break;
          case "insideMiddleTop":
          case "insideMiddle":
          case "insideMiddleBottom":
          case "middle":
            a.x = T[0], a.y = T[1] + _, p = "center", a.originY = -_;
            break;
          case "insideEndTop":
          case "insideEnd":
          case "insideEndBottom":
            a.x = -O * y + h[0], a.y = h[1] + _, p = b[0] >= 0 ? "right" : "left", a.originX = O * y, a.originY = -_;
            break;
        }
        a.scaleX = a.scaleY = o, a.setStyle({
          // Use the user specified text align and baseline first
          verticalAlign: a.__verticalAlign || g,
          align: a.__align || p
        });
      }
    }, e;
  }(Re)
);
const zN = jOe;
var KOe = (
  /** @class */
  function() {
    function r(e) {
      this.group = new Re(), this._LineCtor = e || zN;
    }
    return r.prototype.updateData = function(e) {
      var t = this;
      this._progressiveEls = null;
      var i = this, n = i.group, a = i._lineData;
      i._lineData = e, a || n.removeAll();
      var o = k2(e);
      e.diff(a).add(function(s) {
        t._doAdd(e, s, o);
      }).update(function(s, l) {
        t._doUpdate(a, e, l, s, o);
      }).remove(function(s) {
        n.remove(a.getItemGraphicEl(s));
      }).execute();
    }, r.prototype.updateLayout = function() {
      var e = this._lineData;
      e && e.eachItemGraphicEl(function(t, i) {
        t.updateLayout(e, i);
      }, this);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this._seriesScope = k2(e), this._lineData = null, this.group.removeAll();
    }, r.prototype.incrementalUpdate = function(e, t) {
      this._progressiveEls = [];
      function i(s) {
        !s.isGroup && !JOe(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0);
      }
      for (var n = e.start; n < e.end; n++) {
        var a = t.getItemLayout(n);
        if (SR(a)) {
          var o = new this._LineCtor(t, n, this._seriesScope);
          o.traverse(i), this.group.add(o), t.setItemGraphicEl(n, o), this._progressiveEls.push(o);
        }
      }
    }, r.prototype.remove = function() {
      this.group.removeAll();
    }, r.prototype.eachRendered = function(e) {
      zl(this._progressiveEls || this.group, e);
    }, r.prototype._doAdd = function(e, t, i) {
      var n = e.getItemLayout(t);
      if (SR(n)) {
        var a = new this._LineCtor(e, t, i);
        e.setItemGraphicEl(t, a), this.group.add(a);
      }
    }, r.prototype._doUpdate = function(e, t, i, n, a) {
      var o = e.getItemGraphicEl(i);
      if (!SR(t.getItemLayout(n))) {
        this.group.remove(o);
        return;
      }
      o ? o.updateData(t, n, a) : o = new this._LineCtor(t, n, a), t.setItemGraphicEl(n, o), this.group.add(o);
    }, r;
  }()
);
function JOe(r) {
  return r.animators && r.animators.length > 0;
}
function k2(r) {
  var e = r.hostModel, t = e.getModel("emphasis");
  return {
    lineStyle: e.getModel("lineStyle").getLineStyle(),
    emphasisLineStyle: t.getModel(["lineStyle"]).getLineStyle(),
    blurLineStyle: e.getModel(["blur", "lineStyle"]).getLineStyle(),
    selectLineStyle: e.getModel(["select", "lineStyle"]).getLineStyle(),
    emphasisDisabled: t.get("disabled"),
    blurScope: t.get("blurScope"),
    focus: t.get("focus"),
    labelStatesModels: kr(e)
  };
}
function Q2(r) {
  return isNaN(r[0]) || isNaN(r[1]);
}
function SR(r) {
  return r && !Q2(r[0]) && !Q2(r[1]);
}
const ZN = KOe;
var TR = [], yR = [], RR = [], Rh = Vr, AR = cc, U2 = Math.abs;
function $2(r, e, t) {
  for (var i = r[0], n = r[1], a = r[2], o = 1 / 0, s, l = t * t, u = 0.1, c = 0.1; c <= 0.9; c += 0.1) {
    TR[0] = Rh(i[0], n[0], a[0], c), TR[1] = Rh(i[1], n[1], a[1], c);
    var h = U2(AR(TR, e) - l);
    h < o && (o = h, s = c);
  }
  for (var f = 0; f < 32; f++) {
    var d = s + u;
    yR[0] = Rh(i[0], n[0], a[0], s), yR[1] = Rh(i[1], n[1], a[1], s), RR[0] = Rh(i[0], n[0], a[0], d), RR[1] = Rh(i[1], n[1], a[1], d);
    var h = AR(yR, e) - l;
    if (U2(h) < 0.01)
      break;
    var p = AR(RR, e) - l;
    u /= 2, h < 0 ? p >= 0 ? s = s + u : s = s - u : p >= 0 ? s = s - u : s = s + u;
  }
  return s;
}
function _R(r, e) {
  var t = [], i = Cg, n = [[], [], []], a = [[], []], o = [];
  e /= 2, r.eachEdge(function(s, l) {
    var u = s.getLayout(), c = s.getVisual("fromSymbol"), h = s.getVisual("toSymbol");
    u.__original || (u.__original = [Zo(u[0]), Zo(u[1])], u[2] && u.__original.push(Zo(u[2])));
    var f = u.__original;
    if (u[2] != null) {
      if (_i(n[0], f[0]), _i(n[1], f[2]), _i(n[2], f[1]), c && c !== "none") {
        var d = Ap(s.node1), p = $2(n, f[0], d * e);
        i(n[0][0], n[1][0], n[2][0], p, t), n[0][0] = t[3], n[1][0] = t[4], i(n[0][1], n[1][1], n[2][1], p, t), n[0][1] = t[3], n[1][1] = t[4];
      }
      if (h && h !== "none") {
        var d = Ap(s.node2), p = $2(n, f[1], d * e);
        i(n[0][0], n[1][0], n[2][0], p, t), n[1][0] = t[1], n[2][0] = t[2], i(n[0][1], n[1][1], n[2][1], p, t), n[1][1] = t[1], n[2][1] = t[2];
      }
      _i(u[0], n[0]), _i(u[1], n[2]), _i(u[2], n[1]);
    } else {
      if (_i(a[0], f[0]), _i(a[1], f[1]), Wu(o, a[1], a[0]), Zf(o, o), c && c !== "none") {
        var d = Ap(s.node1);
        I_(a[0], a[0], o, d * e);
      }
      if (h && h !== "none") {
        var d = Ap(s.node2);
        I_(a[1], a[1], o, -d * e);
      }
      _i(u[0], a[0]), _i(u[1], a[1]);
    }
  });
}
function V2(r) {
  return r.type === "view";
}
var eme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      var n = new Mv(), a = new ZN(), o = this.group;
      this._controller = new $v(i.getZr()), this._controllerHost = {
        target: o
      }, o.add(n.group), o.add(a.group), this._symbolDraw = n, this._lineDraw = a, this._firstRender = !0;
    }, e.prototype.render = function(t, i, n) {
      var a = this, o = t.coordinateSystem;
      this._model = t;
      var s = this._symbolDraw, l = this._lineDraw, u = this.group;
      if (V2(o)) {
        var c = {
          x: o.x,
          y: o.y,
          scaleX: o.scaleX,
          scaleY: o.scaleY
        };
        this._firstRender ? u.attr(c) : Ot(u, c, t);
      }
      _R(t.getGraph(), Rp(t));
      var h = t.getData();
      s.updateData(h);
      var f = t.getEdgeData();
      l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(t, i, n), clearTimeout(this._layoutTimeout);
      var d = t.forceLayout, p = t.get(["force", "layoutAnimation"]);
      d && this._startForceLayoutIteration(d, p);
      var g = t.get("layout");
      h.graph.eachNode(function(E) {
        var b = E.dataIndex, S = E.getGraphicEl(), T = E.getModel();
        if (S) {
          S.off("drag").off("dragend");
          var y = T.get("draggable");
          y && S.on("drag", function(_) {
            switch (g) {
              case "force":
                d.warmUp(), !a._layouting && a._startForceLayoutIteration(d, p), d.setFixed(b), h.setItemLayout(b, [S.x, S.y]);
                break;
              case "circular":
                h.setItemLayout(b, [S.x, S.y]), E.setLayout({
                  fixed: !0
                }, !0), WN(t, "symbolSize", E, [_.offsetX, _.offsetY]), a.updateLayout(t);
                break;
              case "none":
              default:
                h.setItemLayout(b, [S.x, S.y]), HN(t.getGraph(), t), a.updateLayout(t);
                break;
            }
          }).on("dragend", function() {
            d && d.setUnfixed(b);
          }), S.setDraggable(y, !!T.get("cursor"));
          var R = T.get(["emphasis", "focus"]);
          R === "adjacency" && (Pe(S).focus = E.getAdjacentDataIndices());
        }
      }), h.graph.eachEdge(function(E) {
        var b = E.getGraphicEl(), S = E.getModel().get(["emphasis", "focus"]);
        b && S === "adjacency" && (Pe(b).focus = {
          edge: [E.dataIndex],
          node: [E.node1.dataIndex, E.node2.dataIndex]
        });
      });
      var v = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]), O = h.getLayout("cx"), m = h.getLayout("cy");
      h.graph.eachNode(function(E) {
        E4(E, v, O, m);
      }), this._firstRender = !1;
    }, e.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, e.prototype._startForceLayoutIteration = function(t, i) {
      var n = this;
      (function a() {
        t.step(function(o) {
          n.updateLayout(n._model), (n._layouting = !o) && (i ? n._layoutTimeout = setTimeout(a, 16) : a());
        });
      })();
    }, e.prototype._updateController = function(t, i, n) {
      var a = this, o = this._controller, s = this._controllerHost, l = this.group;
      if (o.setPointerChecker(function(u, c, h) {
        var f = l.getBoundingRect();
        return f.applyTransform(l.transform), f.contain(c, h) && !$T(u, n, t);
      }), !V2(t.coordinateSystem)) {
        o.disable();
        return;
      }
      o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function(u) {
        kN(s, u.dx, u.dy), n.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          dx: u.dx,
          dy: u.dy
        });
      }).on("zoom", function(u) {
        QN(s, u.scale, u.originX, u.originY), n.dispatchAction({
          seriesId: t.id,
          type: "graphRoam",
          zoom: u.scale,
          originX: u.originX,
          originY: u.originY
        }), a._updateNodeAndLinkScale(), _R(t.getGraph(), Rp(t)), a._lineDraw.updateLayout(), n.updateLabelLayout();
      });
    }, e.prototype._updateNodeAndLinkScale = function() {
      var t = this._model, i = t.getData(), n = Rp(t);
      i.eachItemGraphicEl(function(a, o) {
        a && a.setSymbolScale(n);
      });
    }, e.prototype.updateLayout = function(t) {
      _R(t.getGraph(), Rp(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout();
    }, e.prototype.remove = function(t, i) {
      this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove();
    }, e.type = "graph", e;
  }($t)
);
const tme = eme;
function Ah(r) {
  return "_EC_" + r;
}
var rme = (
  /** @class */
  function() {
    function r(e) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || !1;
    }
    return r.prototype.isDirected = function() {
      return this._directed;
    }, r.prototype.addNode = function(e, t) {
      e = e == null ? "" + t : "" + e;
      var i = this._nodesMap;
      if (i[Ah(e)]) {
        ({}).NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var n = new Lu(e, t);
      return n.hostGraph = this, this.nodes.push(n), i[Ah(e)] = n, n;
    }, r.prototype.getNodeByIndex = function(e) {
      var t = this.data.getRawIndex(e);
      return this.nodes[t];
    }, r.prototype.getNodeById = function(e) {
      return this._nodesMap[Ah(e)];
    }, r.prototype.addEdge = function(e, t, i) {
      var n = this._nodesMap, a = this._edgesMap;
      if (pt(e) && (e = this.nodes[e]), pt(t) && (t = this.nodes[t]), e instanceof Lu || (e = n[Ah(e)]), t instanceof Lu || (t = n[Ah(t)]), !(!e || !t)) {
        var o = e.id + "-" + t.id, s = new S4(e, t, i);
        return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, r.prototype.getEdgeByIndex = function(e) {
      var t = this.edgeData.getRawIndex(e);
      return this.edges[t];
    }, r.prototype.getEdge = function(e, t) {
      e instanceof Lu && (e = e.id), t instanceof Lu && (t = t.id);
      var i = this._edgesMap;
      return this._directed ? i[e + "-" + t] : i[e + "-" + t] || i[t + "-" + e];
    }, r.prototype.eachNode = function(e, t) {
      for (var i = this.nodes, n = i.length, a = 0; a < n; a++)
        i[a].dataIndex >= 0 && e.call(t, i[a], a);
    }, r.prototype.eachEdge = function(e, t) {
      for (var i = this.edges, n = i.length, a = 0; a < n; a++)
        i[a].dataIndex >= 0 && i[a].node1.dataIndex >= 0 && i[a].node2.dataIndex >= 0 && e.call(t, i[a], a);
    }, r.prototype.breadthFirstTraverse = function(e, t, i, n) {
      if (t instanceof Lu || (t = this._nodesMap[Ah(t)]), !!t) {
        for (var a = i === "out" ? "outEdges" : i === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!e.call(n, t, null))
          for (var s = [t]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var c = u[o], h = c.node1 === l ? c.node2 : c.node1;
              if (!h.__visited) {
                if (e.call(n, h, l))
                  return;
                s.push(h), h.__visited = !0;
              }
            }
      }
    }, r.prototype.update = function() {
      for (var e = this.data, t = this.edgeData, i = this.nodes, n = this.edges, a = 0, o = i.length; a < o; a++)
        i[a].dataIndex = -1;
      for (var a = 0, o = e.count(); a < o; a++)
        i[e.getRawIndex(a)].dataIndex = a;
      t.filterSelf(function(s) {
        var l = n[t.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = n.length; a < o; a++)
        n[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        n[t.getRawIndex(a)].dataIndex = a;
    }, r.prototype.clone = function() {
      for (var e = new r(this._directed), t = this.nodes, i = this.edges, n = 0; n < t.length; n++)
        e.addNode(t[n].id, t[n].dataIndex);
      for (var n = 0; n < i.length; n++) {
        var a = i[n];
        e.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return e;
    }, r;
  }()
), Lu = (
  /** @class */
  function() {
    function r(e, t) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1;
    }
    return r.prototype.degree = function() {
      return this.edges.length;
    }, r.prototype.inDegree = function() {
      return this.inEdges.length;
    }, r.prototype.outDegree = function() {
      return this.outEdges.length;
    }, r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, i = t.data.getItemModel(this.dataIndex);
        return i.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      for (var e = {
        edge: [],
        node: []
      }, t = 0; t < this.edges.length; t++) {
        var i = this.edges[t];
        i.dataIndex < 0 || (e.edge.push(i.dataIndex), e.node.push(i.node1.dataIndex, i.node2.dataIndex));
      }
      return e;
    }, r.prototype.getTrajectoryDataIndices = function() {
      for (var e = de(), t = de(), i = 0; i < this.edges.length; i++) {
        var n = this.edges[i];
        if (!(n.dataIndex < 0)) {
          e.set(n.dataIndex, !0);
          for (var a = [n.node1], o = [n.node2], s = 0; s < a.length; ) {
            var l = a[s];
            s++, t.set(l.dataIndex, !0);
            for (var u = 0; u < l.inEdges.length; u++)
              e.set(l.inEdges[u].dataIndex, !0), a.push(l.inEdges[u].node1);
          }
          for (s = 0; s < o.length; ) {
            var c = o[s];
            s++, t.set(c.dataIndex, !0);
            for (var u = 0; u < c.outEdges.length; u++)
              e.set(c.outEdges[u].dataIndex, !0), o.push(c.outEdges[u].node2);
          }
        }
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }()
), S4 = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = i ?? -1;
    }
    return r.prototype.getModel = function(e) {
      if (!(this.dataIndex < 0)) {
        var t = this.hostGraph, i = t.edgeData.getItemModel(this.dataIndex);
        return i.getModel(e);
      }
    }, r.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, r.prototype.getTrajectoryDataIndices = function() {
      var e = de(), t = de();
      e.set(this.dataIndex, !0);
      for (var i = [this.node1], n = [this.node2], a = 0; a < i.length; ) {
        var o = i[a];
        a++, t.set(o.dataIndex, !0);
        for (var s = 0; s < o.inEdges.length; s++)
          e.set(o.inEdges[s].dataIndex, !0), i.push(o.inEdges[s].node1);
      }
      for (a = 0; a < n.length; ) {
        var l = n[a];
        a++, t.set(l.dataIndex, !0);
        for (var s = 0; s < l.outEdges.length; s++)
          e.set(l.outEdges[s].dataIndex, !0), n.push(l.outEdges[s].node2);
      }
      return {
        edge: e.keys(),
        node: t.keys()
      };
    }, r;
  }()
);
function T4(r, e) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(t) {
      var i = this[r][e];
      return i.getStore().get(i.getDimensionIndex(t || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(t, i) {
      this.dataIndex >= 0 && this[r][e].setItemVisual(this.dataIndex, t, i);
    },
    getVisual: function(t) {
      return this[r][e].getItemVisual(this.dataIndex, t);
    },
    setLayout: function(t, i) {
      this.dataIndex >= 0 && this[r][e].setItemLayout(this.dataIndex, t, i);
    },
    getLayout: function() {
      return this[r][e].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[r][e].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[r][e].getRawIndex(this.dataIndex);
    }
  };
}
br(Lu, T4("hostGraph", "data"));
br(S4, T4("hostGraph", "edgeData"));
const ime = rme;
function y4(r, e, t, i, n) {
  for (var a = new ime(i), o = 0; o < r.length; o++)
    a.addNode(vr(
      // Id, name, dataIndex
      r[o].id,
      r[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < e.length; o++) {
    var c = e[o], h = c.source, f = c.target;
    a.addEdge(h, f, u) && (l.push(c), s.push(vr(Ar(c.id, null), h + " > " + f)), u++);
  }
  var d = t.get("coordinateSystem"), p;
  if (d === "cartesian2d" || d === "polar")
    p = Ss(r, t);
  else {
    var g = sd.get(d), v = g ? g.dimensions || [] : [];
    Fe(v, "value") < 0 && v.concat(["value"]);
    var O = xv(r, {
      coordDimensions: v,
      encodeDefine: t.getEncode()
    }).dimensions;
    p = new ki(O, t), p.initData(r);
  }
  var m = new ki(["value"], t);
  return m.initData(l, s), n && n(p, m), n4({
    mainData: p,
    struct: a,
    structAttr: "graph",
    datas: {
      node: p,
      edge: m
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var nme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments);
      var i = this;
      function n() {
        return i._categoriesData;
      }
      this.legendVisualProvider = new Uv(n, n), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData();
    }, e.prototype.mergeDefaultAndTheme = function(t) {
      r.prototype.mergeDefaultAndTheme.apply(this, arguments), Ic(t, "edgeLabel", ["show"]);
    }, e.prototype.getInitialData = function(t, i) {
      var n = t.edges || t.links || [], a = t.data || t.nodes || [], o = this;
      if (a && n) {
        $Oe(this);
        var s = y4(a, n, this, !0, l);
        return N(s.edges, function(u) {
          VOe(u.node1, u.node2, this, u.dataIndex);
        }, this), s.data;
      }
      function l(u, c) {
        u.wrapMethod("getItemModel", function(p) {
          var g = o._categoriesModels, v = p.getShallow("category"), O = g[v];
          return O && (O.parentModel = p.parentModel, p.parentModel = O), p;
        });
        var h = Ut.prototype.getModel;
        function f(p, g) {
          var v = h.call(this, p, g);
          return v.resolveParentPath = d, v;
        }
        c.wrapMethod("getItemModel", function(p) {
          return p.resolveParentPath = d, p.getModel = f, p;
        });
        function d(p) {
          if (p && (p[0] === "label" || p[1] === "label")) {
            var g = p.slice();
            return p[0] === "label" ? g[0] = "edgeLabel" : p[1] === "label" && (g[1] = "edgeLabel"), g;
          }
          return p;
        }
      }
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.getCategoriesData = function() {
      return this._categoriesData;
    }, e.prototype.formatTooltip = function(t, i, n) {
      if (n === "edge") {
        var a = this.getData(), o = this.getDataParams(t, n), s = a.graph.getEdgeByIndex(t), l = a.getName(s.node1.dataIndex), u = a.getName(s.node2.dataIndex), c = [];
        return l != null && c.push(l), u != null && c.push(u), Qr("nameValue", {
          name: c.join(" > "),
          value: o.value,
          noValue: o.value == null
        });
      }
      var h = WW({
        series: this,
        dataIndex: t,
        multipleSeries: i
      });
      return h;
    }, e.prototype._updateCategoriesData = function() {
      var t = Y(this.option.categories || [], function(n) {
        return n.value != null ? n : B({
          value: 0
        }, n);
      }), i = new ki(["value"], this);
      i.initData(t), this._categoriesData = i, this._categoriesModels = i.mapArray(function(n) {
        return i.getItemModel(n);
      });
    }, e.prototype.setZoom = function(t) {
      this.option.zoom = t;
    }, e.prototype.setCenter = function(t) {
      this.option.center = t;
    }, e.prototype.isAnimationEnabled = function() {
      return r.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"]));
    }, e.type = "series.graph", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      // Default option for all coordinate systems
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // polarIndex: 0,
      // geoIndex: 0,
      legendHoverLink: !0,
      layout: null,
      // Configuration of circular layout
      circular: {
        rotateLabel: !1
      },
      // Configuration of force directed layout
      force: {
        initLayout: null,
        // Node repulsion. Can be an array to represent range.
        repulsion: [0, 50],
        gravity: 0.1,
        // Initial friction
        friction: 0.6,
        // Edge length. Can be an array to represent range.
        edgeLength: 30,
        layoutAnimation: !0
      },
      left: "center",
      top: "center",
      // right: null,
      // bottom: null,
      // width: '80%',
      // height: '80%',
      symbol: "circle",
      symbolSize: 10,
      edgeSymbol: ["none", "none"],
      edgeSymbolSize: 10,
      edgeLabel: {
        position: "middle",
        distance: 5
      },
      draggable: !1,
      roam: !1,
      // Default on center of graph
      center: null,
      zoom: 1,
      // Symbol size scale ratio in roam
      nodeScaleRatio: 0.6,
      // cursor: null,
      // categories: [],
      // data: []
      // Or
      // nodes: []
      //
      // links: []
      // Or
      // edges: []
      label: {
        show: !1,
        formatter: "{b}"
      },
      itemStyle: {},
      lineStyle: {
        color: "#aaa",
        width: 1,
        opacity: 0.5
      },
      emphasis: {
        scale: !0,
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Wt)
);
const ame = nme;
var ome = {
  type: "graphRoam",
  event: "graphRoam",
  update: "none"
};
function sme(r) {
  r.registerChartView(tme), r.registerSeriesModel(ame), r.registerProcessor(DOe), r.registerVisual(MOe), r.registerVisual(kOe), r.registerLayout(GOe), r.registerLayout(r.PRIORITY.VISUAL.POST_CHART_LAYOUT, FOe), r.registerLayout(YOe), r.registerCoordinateSystem("graphView", {
    dimensions: Vv.dimensions,
    create: WOe
  }), r.registerAction({
    type: "focusNodeAdjacency",
    event: "focusNodeAdjacency",
    update: "series:focusNodeAdjacency"
  }, ur), r.registerAction({
    type: "unfocusNodeAdjacency",
    event: "unfocusNodeAdjacency",
    update: "series:unfocusNodeAdjacency"
  }, ur), r.registerAction(ome, function(e, t, i) {
    t.eachComponent({
      mainType: "series",
      query: e
    }, function(n) {
      var a = n.coordinateSystem, o = $N(a, e, void 0, i);
      n.setCenter && n.setCenter(o.center), n.setZoom && n.setZoom(o.zoom);
    });
  });
}
var lme = (
  /** @class */
  function() {
    function r() {
      this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0;
    }
    return r;
  }()
), ume = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "pointer", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new lme();
    }, e.prototype.buildPath = function(t, i) {
      var n = Math.cos, a = Math.sin, o = i.r, s = i.width, l = i.angle, u = i.x - n(l) * s * (s >= o / 3 ? 1 : 2), c = i.y - a(l) * s * (s >= o / 3 ? 1 : 2);
      l = i.angle - Math.PI / 2, t.moveTo(u, c), t.lineTo(i.x + n(l) * s, i.y + a(l) * s), t.lineTo(i.x + n(i.angle) * o, i.y + a(i.angle) * o), t.lineTo(i.x - n(l) * s, i.y - a(l) * s), t.lineTo(u, c);
    }, e;
  }(He)
);
const cme = ume;
function hme(r, e) {
  var t = r.get("center"), i = e.getWidth(), n = e.getHeight(), a = Math.min(i, n), o = K(t[0], e.getWidth()), s = K(t[1], e.getHeight()), l = K(r.get("radius"), a / 2);
  return {
    cx: o,
    cy: s,
    r: l
  };
}
function nm(r, e) {
  var t = r == null ? "" : r + "";
  return e && (ne(e) ? t = e.replace("{value}", t) : ve(e) && (t = e(r))), t;
}
var fme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      this.group.removeAll();
      var a = t.get(["axisLine", "lineStyle", "color"]), o = hme(t, n);
      this._renderMain(t, i, n, a, o), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.prototype._renderMain = function(t, i, n, a, o) {
      var s = this.group, l = t.get("clockwise"), u = -t.get("startAngle") / 180 * Math.PI, c = -t.get("endAngle") / 180 * Math.PI, h = t.getModel("axisLine"), f = h.get("roundCap"), d = f ? wb : tn, p = h.get("show"), g = h.getModel("lineStyle"), v = g.get("width"), O = [u, c];
      nH(O, !l), u = O[0], c = O[1];
      for (var m = c - u, E = u, b = [], S = 0; p && S < a.length; S++) {
        var T = Math.min(Math.max(a[S][0], 0), 1);
        c = u + m * T;
        var y = new d({
          shape: {
            startAngle: E,
            endAngle: c,
            cx: o.cx,
            cy: o.cy,
            clockwise: l,
            r0: o.r - v,
            r: o.r
          },
          silent: !0
        });
        y.setStyle({
          fill: a[S][1]
        }), y.setStyle(g.getLineStyle(
          // Because we use sector to simulate arc
          // so the properties for stroking are useless
          ["color", "width"]
        )), b.push(y), E = c;
      }
      b.reverse(), N(b, function(_) {
        return s.add(_);
      });
      var R = function(_) {
        if (_ <= 0)
          return a[0][1];
        var C;
        for (C = 0; C < a.length; C++)
          if (a[C][0] >= _ && (C === 0 ? 0 : a[C - 1][0]) < _)
            return a[C][1];
        return a[C - 1][1];
      };
      this._renderTicks(t, i, n, R, o, u, c, l, v), this._renderTitleAndDetail(t, i, n, R, o), this._renderAnchor(t, o), this._renderPointer(t, i, n, R, o, u, c, l, v);
    }, e.prototype._renderTicks = function(t, i, n, a, o, s, l, u, c) {
      for (var h = this.group, f = o.cx, d = o.cy, p = o.r, g = +t.get("min"), v = +t.get("max"), O = t.getModel("splitLine"), m = t.getModel("axisTick"), E = t.getModel("axisLabel"), b = t.get("splitNumber"), S = m.get("splitNumber"), T = K(O.get("length"), p), y = K(m.get("length"), p), R = s, _ = (l - s) / b, C = _ / S, I = O.getModel("lineStyle").getLineStyle(), w = m.getModel("lineStyle").getLineStyle(), x = O.get("distance"), P, L, D = 0; D <= b; D++) {
        if (P = Math.cos(R), L = Math.sin(R), O.get("show")) {
          var U = x ? x + c : c, Q = new Gr({
            shape: {
              x1: P * (p - U) + f,
              y1: L * (p - U) + d,
              x2: P * (p - T - U) + f,
              y2: L * (p - T - U) + d
            },
            style: I,
            silent: !0
          });
          I.stroke === "auto" && Q.setStyle({
            stroke: a(D / b)
          }), h.add(Q);
        }
        if (E.get("show")) {
          var U = E.get("distance") + x, V = nm(rr(D / b * (v - g) + g), E.get("formatter")), F = a(D / b), j = P * (p - T - U) + f, ae = L * (p - T - U) + d, ce = E.get("rotate"), ge = 0;
          ce === "radial" ? (ge = -R + 2 * Math.PI, ge > Math.PI / 2 && (ge += Math.PI)) : ce === "tangential" ? ge = -R - Math.PI / 2 : pt(ce) && (ge = ce * Math.PI / 180), ge === 0 ? h.add(new dt({
            style: Qt(E, {
              text: V,
              x: j,
              y: ae,
              verticalAlign: L < -0.8 ? "top" : L > 0.8 ? "bottom" : "middle",
              align: P < -0.4 ? "left" : P > 0.4 ? "right" : "center"
            }, {
              inheritColor: F
            }),
            silent: !0
          })) : h.add(new dt({
            style: Qt(E, {
              text: V,
              x: j,
              y: ae,
              verticalAlign: "middle",
              align: "center"
            }, {
              inheritColor: F
            }),
            silent: !0,
            originX: j,
            originY: ae,
            rotation: ge
          }));
        }
        if (m.get("show") && D !== b) {
          var U = m.get("distance");
          U = U ? U + c : c;
          for (var Be = 0; Be <= S; Be++) {
            P = Math.cos(R), L = Math.sin(R);
            var We = new Gr({
              shape: {
                x1: P * (p - U) + f,
                y1: L * (p - U) + d,
                x2: P * (p - y - U) + f,
                y2: L * (p - y - U) + d
              },
              silent: !0,
              style: w
            });
            w.stroke === "auto" && We.setStyle({
              stroke: a((D + Be / S) / b)
            }), h.add(We), R += C;
          }
          R -= C;
        } else
          R += _;
      }
    }, e.prototype._renderPointer = function(t, i, n, a, o, s, l, u, c) {
      var h = this.group, f = this._data, d = this._progressEls, p = [], g = t.get(["pointer", "show"]), v = t.getModel("progress"), O = v.get("show"), m = t.getData(), E = m.mapDimension("value"), b = +t.get("min"), S = +t.get("max"), T = [b, S], y = [s, l];
      function R(C, I) {
        var w = m.getItemModel(C), x = w.getModel("pointer"), P = K(x.get("width"), o.r), L = K(x.get("length"), o.r), D = t.get(["pointer", "icon"]), U = x.get("offsetCenter"), Q = K(U[0], o.r), V = K(U[1], o.r), F = x.get("keepAspect"), j;
        return D ? j = Er(D, Q - P / 2, V - L, P, L, null, F) : j = new cme({
          shape: {
            angle: -Math.PI / 2,
            width: P,
            r: L,
            x: Q,
            y: V
          }
        }), j.rotation = -(I + Math.PI / 2), j.x = o.cx, j.y = o.cy, j;
      }
      function _(C, I) {
        var w = v.get("roundCap"), x = w ? wb : tn, P = v.get("overlap"), L = P ? v.get("width") : c / m.count(), D = P ? o.r - L : o.r - (C + 1) * L, U = P ? o.r : o.r - C * L, Q = new x({
          shape: {
            startAngle: s,
            endAngle: I,
            cx: o.cx,
            cy: o.cy,
            clockwise: u,
            r0: D,
            r: U
          }
        });
        return P && (Q.z2 = S - m.get(E, C) % S), Q;
      }
      (O || g) && (m.diff(f).add(function(C) {
        var I = m.get(E, C);
        if (g) {
          var w = R(C, s);
          Bt(w, {
            rotation: -((isNaN(+I) ? y[0] : yt(I, T, y, !0)) + Math.PI / 2)
          }, t), h.add(w), m.setItemGraphicEl(C, w);
        }
        if (O) {
          var x = _(C, s), P = v.get("clip");
          Bt(x, {
            shape: {
              endAngle: yt(I, T, y, P)
            }
          }, t), h.add(x), eC(t.seriesIndex, m.dataType, C, x), p[C] = x;
        }
      }).update(function(C, I) {
        var w = m.get(E, C);
        if (g) {
          var x = f.getItemGraphicEl(I), P = x ? x.rotation : s, L = R(C, P);
          L.rotation = P, Ot(L, {
            rotation: -((isNaN(+w) ? y[0] : yt(w, T, y, !0)) + Math.PI / 2)
          }, t), h.add(L), m.setItemGraphicEl(C, L);
        }
        if (O) {
          var D = d[I], U = D ? D.shape.endAngle : s, Q = _(C, U), V = v.get("clip");
          Ot(Q, {
            shape: {
              endAngle: yt(w, T, y, V)
            }
          }, t), h.add(Q), eC(t.seriesIndex, m.dataType, C, Q), p[C] = Q;
        }
      }).execute(), m.each(function(C) {
        var I = m.getItemModel(C), w = I.getModel("emphasis"), x = w.get("focus"), P = w.get("blurScope"), L = w.get("disabled");
        if (g) {
          var D = m.getItemGraphicEl(C), U = m.getItemVisual(C, "style"), Q = U.fill;
          if (D instanceof ni) {
            var V = D.style;
            D.useStyle(B({
              image: V.image,
              x: V.x,
              y: V.y,
              width: V.width,
              height: V.height
            }, U));
          } else
            D.useStyle(U), D.type !== "pointer" && D.setColor(Q);
          D.setStyle(I.getModel(["pointer", "itemStyle"]).getItemStyle()), D.style.fill === "auto" && D.setStyle("fill", a(yt(m.get(E, C), T, [0, 1], !0))), D.z2EmphasisLift = 0, ri(D, I), qt(D, x, P, L);
        }
        if (O) {
          var F = p[C];
          F.useStyle(m.getItemVisual(C, "style")), F.setStyle(I.getModel(["progress", "itemStyle"]).getItemStyle()), F.z2EmphasisLift = 0, ri(F, I), qt(F, x, P, L);
        }
      }), this._progressEls = p);
    }, e.prototype._renderAnchor = function(t, i) {
      var n = t.getModel("anchor"), a = n.get("show");
      if (a) {
        var o = n.get("size"), s = n.get("icon"), l = n.get("offsetCenter"), u = n.get("keepAspect"), c = Er(s, i.cx - o / 2 + K(l[0], i.r), i.cy - o / 2 + K(l[1], i.r), o, o, null, u);
        c.z2 = n.get("showAbove") ? 1 : 0, c.setStyle(n.getModel("itemStyle").getItemStyle()), this.group.add(c);
      }
    }, e.prototype._renderTitleAndDetail = function(t, i, n, a, o) {
      var s = this, l = t.getData(), u = l.mapDimension("value"), c = +t.get("min"), h = +t.get("max"), f = new Re(), d = [], p = [], g = t.isAnimationEnabled(), v = t.get(["pointer", "showAbove"]);
      l.diff(this._data).add(function(O) {
        d[O] = new dt({
          silent: !0
        }), p[O] = new dt({
          silent: !0
        });
      }).update(function(O, m) {
        d[O] = s._titleEls[m], p[O] = s._detailEls[m];
      }).execute(), l.each(function(O) {
        var m = l.getItemModel(O), E = l.get(u, O), b = new Re(), S = a(yt(E, [c, h], [0, 1], !0)), T = m.getModel("title");
        if (T.get("show")) {
          var y = T.get("offsetCenter"), R = o.cx + K(y[0], o.r), _ = o.cy + K(y[1], o.r), C = d[O];
          C.attr({
            z2: v ? 0 : 2,
            style: Qt(T, {
              x: R,
              y: _,
              text: l.getName(O),
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: S
            })
          }), b.add(C);
        }
        var I = m.getModel("detail");
        if (I.get("show")) {
          var w = I.get("offsetCenter"), x = o.cx + K(w[0], o.r), P = o.cy + K(w[1], o.r), L = K(I.get("width"), o.r), D = K(I.get("height"), o.r), U = t.get(["progress", "show"]) ? l.getItemVisual(O, "style").fill : S, C = p[O], Q = I.get("formatter");
          C.attr({
            z2: v ? 0 : 2,
            style: Qt(I, {
              x,
              y: P,
              text: nm(E, Q),
              width: isNaN(L) ? null : L,
              height: isNaN(D) ? null : D,
              align: "center",
              verticalAlign: "middle"
            }, {
              inheritColor: U
            })
          }), qH(C, {
            normal: I
          }, E, function(F) {
            return nm(F, Q);
          }), g && jH(C, O, l, t, {
            getFormattedLabel: function(F, j, ae, ce, ge, Be) {
              return nm(Be ? Be.interpolatedValue : E, Q);
            }
          }), b.add(C);
        }
        f.add(b);
      }), this.group.add(f), this._titleEls = d, this._detailEls = p;
    }, e.type = "gauge", e;
  }($t)
);
const dme = fme;
var pme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return hd(this, ["value"]);
    }, e.type = "series.gauge", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      // 
      center: ["50%", "50%"],
      legendHoverLink: !0,
      radius: "75%",
      startAngle: 225,
      endAngle: -45,
      clockwise: !0,
      // 
      min: 0,
      // 
      max: 100,
      // 10
      splitNumber: 10,
      // 
      axisLine: {
        // show
        show: !0,
        roundCap: !1,
        lineStyle: {
          color: [[1, "#E6EBF8"]],
          width: 10
        }
      },
      // 
      progress: {
        // show
        show: !1,
        overlap: !0,
        width: 10,
        roundCap: !1,
        clip: !0
      },
      // 
      splitLine: {
        // show
        show: !0,
        // length
        length: 10,
        distance: 10,
        // lineStylelineStyle
        lineStyle: {
          color: "#63677A",
          width: 3,
          type: "solid"
        }
      },
      // 
      axisTick: {
        // show
        show: !0,
        // split
        splitNumber: 5,
        // length
        length: 6,
        distance: 10,
        // lineStyle
        lineStyle: {
          color: "#63677A",
          width: 1,
          type: "solid"
        }
      },
      axisLabel: {
        show: !0,
        distance: 15,
        // formatter: null,
        color: "#464646",
        fontSize: 12,
        rotate: 0
      },
      pointer: {
        icon: null,
        offsetCenter: [0, 0],
        show: !0,
        showAbove: !0,
        length: "60%",
        width: 6,
        keepAspect: !1
      },
      anchor: {
        show: !1,
        showAbove: !1,
        size: 6,
        icon: "circle",
        offsetCenter: [0, 0],
        keepAspect: !1,
        itemStyle: {
          color: "#fff",
          borderWidth: 0,
          borderColor: "#5470c6"
        }
      },
      title: {
        show: !0,
        // x, ypx
        offsetCenter: [0, "20%"],
        // TEXTSTYLE
        color: "#464646",
        fontSize: 16,
        valueAnimation: !1
      },
      detail: {
        show: !0,
        backgroundColor: "rgba(0,0,0,0)",
        borderWidth: 0,
        borderColor: "#ccc",
        width: 100,
        height: null,
        padding: [5, 10],
        // x, ypx
        offsetCenter: [0, "40%"],
        // formatter: null,
        // TEXTSTYLE
        color: "#464646",
        fontSize: 30,
        fontWeight: "bold",
        lineHeight: 30,
        valueAnimation: !1
      }
    }, e;
  }(Wt)
);
const gme = pme;
function vme(r) {
  r.registerChartView(dme), r.registerSeriesModel(gme);
}
var Ome = ["itemStyle", "opacity"], mme = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i) {
      var n = r.call(this) || this, a = n, o = new nn(), s = new dt();
      return a.setTextContent(s), n.setTextGuideLine(o), n.updateData(t, i, !0), n;
    }
    return e.prototype.updateData = function(t, i, n) {
      var a = this, o = t.hostModel, s = t.getItemModel(i), l = t.getItemLayout(i), u = s.getModel("emphasis"), c = s.get(Ome);
      c = c ?? 1, n || La(a), a.useStyle(t.getItemVisual(i, "style")), a.style.lineJoin = "round", n ? (a.setShape({
        points: l.points
      }), a.style.opacity = 0, Bt(a, {
        style: {
          opacity: c
        }
      }, o, i)) : Ot(a, {
        style: {
          opacity: c
        },
        shape: {
          points: l.points
        }
      }, o, i), ri(a, s), this._updateLabel(t, i), qt(this, u.get("focus"), u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t, i) {
      var n = this, a = this.getTextGuideLine(), o = n.getTextContent(), s = t.hostModel, l = t.getItemModel(i), u = t.getItemLayout(i), c = u.label, h = t.getItemVisual(i, "style"), f = h.fill;
      ii(
        // position will not be used in setLabelStyle
        o,
        kr(l),
        {
          labelFetcher: t.hostModel,
          labelDataIndex: i,
          defaultOpacity: h.opacity,
          defaultText: t.getName(i)
        },
        {
          normal: {
            align: c.textAlign,
            verticalAlign: c.verticalAlign
          }
        }
      ), n.setTextConfig({
        local: !0,
        inside: !!c.inside,
        insideStroke: f,
        // insideFill: 'auto',
        outsideFill: f
      });
      var d = c.linePoints;
      a.setShape({
        points: d
      }), n.textGuideLineConfig = {
        anchor: d ? new Me(d[0][0], d[0][1]) : null
      }, Ot(o, {
        style: {
          x: c.x,
          y: c.y
        }
      }, s, i), o.attr({
        rotation: c.rotation,
        originX: c.x,
        originY: c.y,
        z2: 10
      }), CN(n, IN(l), {
        // Default use item visual color
        stroke: f
      });
    }, e;
  }(rn)
), Eme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreLabelLineUpdate = !0, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._data, s = this.group;
      a.diff(o).add(function(l) {
        var u = new mme(a, l);
        a.setItemGraphicEl(l, u), s.add(u);
      }).update(function(l, u) {
        var c = o.getItemGraphicEl(u);
        c.updateData(a, l), s.add(c), a.setItemGraphicEl(l, c);
      }).remove(function(l) {
        var u = o.getItemGraphicEl(l);
        Pg(u, t, l);
      }).execute(), this._data = a;
    }, e.prototype.remove = function() {
      this.group.removeAll(), this._data = null;
    }, e.prototype.dispose = function() {
    }, e.type = "funnel", e;
  }($t)
);
const bme = Eme;
var Sme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Uv(ue(this.getData, this), ue(this.getRawData, this)), this._defaultLabelLine(t);
    }, e.prototype.getInitialData = function(t, i) {
      return hd(this, {
        coordDimensions: ["value"],
        encodeDefaulter: Le(nN, this)
      });
    }, e.prototype._defaultLabelLine = function(t) {
      Ic(t, "labelLine", ["show"]);
      var i = t.labelLine, n = t.emphasis.labelLine;
      i.show = i.show && t.label.show, n.show = n.show && t.emphasis.label.show;
    }, e.prototype.getDataParams = function(t) {
      var i = this.getData(), n = r.prototype.getDataParams.call(this, t), a = i.mapDimension("value"), o = i.getSum(a);
      return n.percent = o ? +(i.get(a, t) / o * 100).toFixed(2) : 0, n.$vars.push("percent"), n;
    }, e.type = "series.funnel", e.defaultOption = {
      // zlevel: 0,                  // 
      z: 2,
      legendHoverLink: !0,
      colorBy: "data",
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      // 
      // min: 0,
      // max: 100,
      minSize: "0%",
      maxSize: "100%",
      sort: "descending",
      orient: "vertical",
      gap: 0,
      funnelAlign: "center",
      label: {
        show: !0,
        position: "outer"
        // formatter: Tooltip.formatter
      },
      labelLine: {
        show: !0,
        length: 20,
        lineStyle: {
          // color: ,
          width: 1
        }
      },
      itemStyle: {
        // color: ,
        borderColor: "#fff",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Wt)
);
const Tme = Sme;
function yme(r, e) {
  return Ir(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function Rme(r, e) {
  for (var t = r.mapDimension("value"), i = r.mapArray(t, function(l) {
    return l;
  }), n = [], a = e === "ascending", o = 0, s = r.count(); o < s; o++)
    n[o] = o;
  return ve(e) ? n.sort(e) : e !== "none" && n.sort(function(l, u) {
    return a ? i[l] - i[u] : i[u] - i[l];
  }), n;
}
function Ame(r) {
  var e = r.hostModel, t = e.get("orient");
  r.each(function(i) {
    var n = r.getItemModel(i), a = n.getModel("label"), o = a.get("position"), s = n.getModel("labelLine"), l = r.getItemLayout(i), u = l.points, c = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", h, f, d, p;
    if (c)
      o === "insideLeft" ? (f = (u[0][0] + u[3][0]) / 2 + 5, d = (u[0][1] + u[3][1]) / 2, h = "left") : o === "insideRight" ? (f = (u[1][0] + u[2][0]) / 2 - 5, d = (u[1][1] + u[2][1]) / 2, h = "right") : (f = (u[0][0] + u[1][0] + u[2][0] + u[3][0]) / 4, d = (u[0][1] + u[1][1] + u[2][1] + u[3][1]) / 4, h = "center"), p = [[f, d], [f, d]];
    else {
      var g = void 0, v = void 0, O = void 0, m = void 0, E = s.get("length");
      ({}).NODE_ENV !== "production" && (t === "vertical" && ["top", "bottom"].indexOf(o) > -1 && (o = "left", console.warn("Position error: Funnel chart on vertical orient dose not support top and bottom.")), t === "horizontal" && ["left", "right"].indexOf(o) > -1 && (o = "bottom", console.warn("Position error: Funnel chart on horizontal orient dose not support left and right."))), o === "left" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, O = g - E, f = O - 5, h = "right") : o === "right" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, O = g + E, f = O + 5, h = "left") : o === "top" ? (g = (u[3][0] + u[0][0]) / 2, v = (u[3][1] + u[0][1]) / 2, m = v - E, d = m - 5, h = "center") : o === "bottom" ? (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, m = v + E, d = m + 5, h = "center") : o === "rightTop" ? (g = t === "horizontal" ? u[3][0] : u[1][0], v = t === "horizontal" ? u[3][1] : u[1][1], t === "horizontal" ? (m = v - E, d = m - 5, h = "center") : (O = g + E, f = O + 5, h = "top")) : o === "rightBottom" ? (g = u[2][0], v = u[2][1], t === "horizontal" ? (m = v + E, d = m + 5, h = "center") : (O = g + E, f = O + 5, h = "bottom")) : o === "leftTop" ? (g = u[0][0], v = t === "horizontal" ? u[0][1] : u[1][1], t === "horizontal" ? (m = v - E, d = m - 5, h = "center") : (O = g - E, f = O - 5, h = "right")) : o === "leftBottom" ? (g = t === "horizontal" ? u[1][0] : u[3][0], v = t === "horizontal" ? u[1][1] : u[2][1], t === "horizontal" ? (m = v + E, d = m + 5, h = "center") : (O = g - E, f = O - 5, h = "right")) : (g = (u[1][0] + u[2][0]) / 2, v = (u[1][1] + u[2][1]) / 2, t === "horizontal" ? (m = v + E, d = m + 5, h = "center") : (O = g + E, f = O + 5, h = "left")), t === "horizontal" ? (O = g, f = O) : (m = v, d = m), p = [[g, v], [O, m]];
    }
    l.label = {
      linePoints: p,
      x: f,
      y: d,
      verticalAlign: "middle",
      textAlign: h,
      inside: c
    };
  });
}
function _me(r, e) {
  r.eachSeriesByType("funnel", function(t) {
    var i = t.getData(), n = i.mapDimension("value"), a = t.get("sort"), o = yme(t, e), s = t.get("orient"), l = o.width, u = o.height, c = Rme(i, a), h = o.x, f = o.y, d = s === "horizontal" ? [K(t.get("minSize"), u), K(t.get("maxSize"), u)] : [K(t.get("minSize"), l), K(t.get("maxSize"), l)], p = i.getDataExtent(n), g = t.get("min"), v = t.get("max");
    g == null && (g = Math.min(p[0], 0)), v == null && (v = p[1]);
    var O = t.get("funnelAlign"), m = t.get("gap"), E = s === "horizontal" ? l : u, b = (E - m * (i.count() - 1)) / i.count(), S = function(P, L) {
      if (s === "horizontal") {
        var D = i.get(n, P) || 0, U = yt(D, [g, v], d, !0), Q = void 0;
        switch (O) {
          case "top":
            Q = f;
            break;
          case "center":
            Q = f + (u - U) / 2;
            break;
          case "bottom":
            Q = f + (u - U);
            break;
        }
        return [[L, Q], [L, Q + U]];
      }
      var V = i.get(n, P) || 0, F = yt(V, [g, v], d, !0), j;
      switch (O) {
        case "left":
          j = h;
          break;
        case "center":
          j = h + (l - F) / 2;
          break;
        case "right":
          j = h + l - F;
          break;
      }
      return [[j, L], [j + F, L]];
    };
    a === "ascending" && (b = -b, m = -m, s === "horizontal" ? h += l : f += u, c = c.reverse());
    for (var T = 0; T < c.length; T++) {
      var y = c[T], R = c[T + 1], _ = i.getItemModel(y);
      if (s === "horizontal") {
        var C = _.get(["itemStyle", "width"]);
        C == null ? C = b : (C = K(C, l), a === "ascending" && (C = -C));
        var I = S(y, h), w = S(R, h + C);
        h += C + m, i.setItemLayout(y, {
          points: I.concat(w.slice().reverse())
        });
      } else {
        var x = _.get(["itemStyle", "height"]);
        x == null ? x = b : (x = K(x, u), a === "ascending" && (x = -x));
        var I = S(y, f), w = S(R, f + x);
        f += x + m, i.setItemLayout(y, {
          points: I.concat(w.slice().reverse())
        });
      }
    }
    Ame(i);
  });
}
function Cme(r) {
  r.registerChartView(bme), r.registerSeriesModel(Tme), r.registerLayout(_me), r.registerProcessor(Qv("funnel"));
}
var Ime = 0.3, wme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._dataGroup = new Re(), t._initialized = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._dataGroup);
    }, e.prototype.render = function(t, i, n, a) {
      this._progressiveEls = null;
      var o = this._dataGroup, s = t.getData(), l = this._data, u = t.coordinateSystem, c = u.dimensions, h = B2(t);
      s.diff(l).add(f).update(d).remove(p).execute();
      function f(v) {
        var O = G2(s, o, v, c, u);
        CR(O, s, v, h);
      }
      function d(v, O) {
        var m = l.getItemGraphicEl(O), E = R4(s, v, c, u);
        s.setItemGraphicEl(v, m), Ot(m, {
          shape: {
            points: E
          }
        }, t, v), La(m), CR(m, s, v, h);
      }
      function p(v) {
        var O = l.getItemGraphicEl(v);
        o.remove(O);
      }
      if (!this._initialized) {
        this._initialized = !0;
        var g = Nme(u, t, function() {
          setTimeout(function() {
            o.removeClipPath();
          });
        });
        o.setClipPath(g);
      }
      this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this._initialized = !0, this._data = null, this._dataGroup.removeAll();
    }, e.prototype.incrementalRender = function(t, i, n) {
      for (var a = i.getData(), o = i.coordinateSystem, s = o.dimensions, l = B2(i), u = this._progressiveEls = [], c = t.start; c < t.end; c++) {
        var h = G2(a, this._dataGroup, c, s, o);
        h.incremental = !0, CR(h, a, c, l), u.push(h);
      }
    }, e.prototype.remove = function() {
      this._dataGroup && this._dataGroup.removeAll(), this._data = null;
    }, e.type = "parallel", e;
  }($t)
);
function Nme(r, e, t) {
  var i = r.model, n = r.getRect(), a = new ht({
    shape: {
      x: n.x,
      y: n.y,
      width: n.width,
      height: n.height
    }
  }), o = i.get("layout") === "horizontal" ? "width" : "height";
  return a.setShape(o, 0), Bt(a, {
    shape: {
      width: n.width,
      height: n.height
    }
  }, e, t), a;
}
function R4(r, e, t, i) {
  for (var n = [], a = 0; a < t.length; a++) {
    var o = t[a], s = r.get(r.mapDimension(o), e);
    xme(s, i.getAxis(o).type) || n.push(i.dataToPoint(s, o));
  }
  return n;
}
function G2(r, e, t, i, n) {
  var a = R4(r, t, i, n), o = new nn({
    shape: {
      points: a
    },
    // silent: true,
    z2: 10
  });
  return e.add(o), r.setItemGraphicEl(t, o), o;
}
function B2(r) {
  var e = r.get("smooth", !0);
  return e === !0 && (e = Ime), e = ss(e), Cc(e) && (e = 0), {
    smooth: e
  };
}
function CR(r, e, t, i) {
  r.useStyle(e.getItemVisual(t, "style")), r.style.fill = null, r.setShape("smooth", i.smooth);
  var n = e.getItemModel(t), a = n.getModel("emphasis");
  ri(r, n, "lineStyle"), qt(r, a.get("focus"), a.get("blurScope"), a.get("disabled"));
}
function xme(r, e) {
  return e === "category" ? r == null : r == null || isNaN(r);
}
const Pme = wme;
var Lme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return Ss(null, this, {
        useEncodeDefaulter: ue(Dme, null, this)
      });
    }, e.prototype.getRawIndicesByActiveState = function(t) {
      var i = this.coordinateSystem, n = this.getData(), a = [];
      return i.eachActiveState(n, function(o, s) {
        t === o && a.push(n.getRawIndex(s));
      }), a;
    }, e.type = "series.parallel", e.dependencies = ["parallel"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "parallel",
      parallelIndex: 0,
      label: {
        show: !1
      },
      inactiveOpacity: 0.05,
      activeOpacity: 1,
      lineStyle: {
        width: 1,
        opacity: 0.45,
        type: "solid"
      },
      emphasis: {
        label: {
          show: !1
        }
      },
      progressive: 500,
      smooth: !1,
      animationEasing: "linear"
    }, e;
  }(Wt)
);
function Dme(r) {
  var e = r.ecModel.getComponent("parallel", r.get("parallelIndex"));
  if (e) {
    var t = {};
    return N(e.dimensions, function(i) {
      var n = Mme(i);
      t[i] = n;
    }), t;
  }
}
function Mme(r) {
  return +r.replace("dim", "");
}
const kme = Lme;
var Qme = ["lineStyle", "opacity"], Ume = {
  seriesType: "parallel",
  reset: function(r, e) {
    var t = r.coordinateSystem, i = {
      normal: r.get(["lineStyle", "opacity"]),
      active: r.get("activeOpacity"),
      inactive: r.get("inactiveOpacity")
    };
    return {
      progress: function(n, a) {
        t.eachActiveState(a, function(o, s) {
          var l = i[o];
          if (o === "normal" && a.hasItemOption) {
            var u = a.getItemModel(s).get(Qme, !0);
            u != null && (l = u);
          }
          var c = a.ensureUniqueItemVisual(s, "style");
          c.opacity = l;
        }, n.start, n.end);
      }
    };
  }
};
const $me = Ume;
function Vme(r) {
  Gme(r), Bme(r);
}
function Gme(r) {
  if (!r.parallel) {
    var e = !1;
    N(r.series, function(t) {
      t && t.type === "parallel" && (e = !0);
    }), e && (r.parallel = [{}]);
  }
}
function Bme(r) {
  var e = It(r.parallelAxis);
  N(e, function(t) {
    if (be(t)) {
      var i = t.parallelIndex || 0, n = It(r.parallel)[i];
      n && n.parallelAxisDefault && $e(t, n.parallelAxisDefault, !1);
    }
  });
}
var Fme = 5, Xme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      this._model = t, this._api = n, this._handlers || (this._handlers = {}, N(Yme, function(a, o) {
        n.getZr().on(o, this._handlers[o] = ue(a, this));
      }, this)), ud(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate");
    }, e.prototype.dispose = function(t, i) {
      Qg(this, "_throttledDispatchExpand"), N(this._handlers, function(n, a) {
        i.getZr().off(a, n);
      }), this._handlers = null;
    }, e.prototype._throttledDispatchExpand = function(t) {
      this._dispatchExpand(t);
    }, e.prototype._dispatchExpand = function(t) {
      t && this._api.dispatchAction(B({
        type: "parallelAxisExpand"
      }, t));
    }, e.type = "parallel", e;
  }(jt)
), Yme = {
  mousedown: function(r) {
    IR(this, "click") && (this._mouseDownPoint = [r.offsetX, r.offsetY]);
  },
  mouseup: function(r) {
    var e = this._mouseDownPoint;
    if (IR(this, "click") && e) {
      var t = [r.offsetX, r.offsetY], i = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
      if (i > Fme)
        return;
      var n = this._model.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]);
      n.behavior !== "none" && this._dispatchExpand({
        axisExpandWindow: n.axisExpandWindow
      });
    }
    this._mouseDownPoint = null;
  },
  mousemove: function(r) {
    if (!(this._mouseDownPoint || !IR(this, "mousemove"))) {
      var e = this._model, t = e.coordinateSystem.getSlidedAxisExpandWindow([r.offsetX, r.offsetY]), i = t.behavior;
      i === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(i === "none" ? null : {
        axisExpandWindow: t.axisExpandWindow,
        // Jumping uses animation, and sliding suppresses animation.
        animation: i === "jump" ? null : {
          duration: 0
          // Disable animation.
        }
      });
    }
  }
};
function IR(r, e) {
  var t = r._model;
  return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e;
}
const Hme = Xme;
var Wme = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      r.prototype.init.apply(this, arguments), this.mergeOption({});
    }, e.prototype.mergeOption = function(t) {
      var i = this.option;
      t && $e(i, t, !0), this._initDimensions();
    }, e.prototype.contains = function(t, i) {
      var n = t.get("parallelIndex");
      return n != null && i.getComponent("parallel", n) === this;
    }, e.prototype.setAxisExpand = function(t) {
      N(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function(i) {
        t.hasOwnProperty(i) && (this.option[i] = t[i]);
      }, this);
    }, e.prototype._initDimensions = function() {
      var t = this.dimensions = [], i = this.parallelAxisIndex = [], n = At(this.ecModel.queryComponents({
        mainType: "parallelAxis"
      }), function(a) {
        return (a.get("parallelIndex") || 0) === this.componentIndex;
      }, this);
      N(n, function(a) {
        t.push("dim" + a.get("dim")), i.push(a.componentIndex);
      });
    }, e.type = "parallel", e.dependencies = ["parallelAxis"], e.layoutMode = "box", e.defaultOption = {
      // zlevel: 0,
      z: 0,
      left: 80,
      top: 60,
      right: 80,
      bottom: 60,
      // width: {totalWidth} - left - right,
      // height: {totalHeight} - top - bottom,
      layout: "horizontal",
      // FIXME
      // naming?
      axisExpandable: !1,
      axisExpandCenter: null,
      axisExpandCount: 0,
      axisExpandWidth: 50,
      axisExpandRate: 17,
      axisExpandDebounce: 50,
      // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
      // Do not doc to user until necessary.
      axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
      axisExpandTriggerOn: "click",
      parallelAxisDefault: null
    }, e;
  }(st)
);
const zme = Wme;
var Zme = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n, a, o) {
      var s = r.call(this, t, i, n) || this;
      return s.type = a || "value", s.axisIndex = o, s;
    }
    return e.prototype.isHorizontal = function() {
      return this.coordinateSystem.getModel().get("layout") !== "horizontal";
    }, e;
  }(Ma)
);
const qme = Zme;
function eh(r, e, t, i, n, a) {
  r = r || 0;
  var o = t[1] - t[0];
  if (n != null && (n = _h(n, [0, o])), a != null && (a = Math.max(a, n ?? 0)), i === "all") {
    var s = Math.abs(e[1] - e[0]);
    s = _h(s, [0, o]), n = a = _h(s, [n, a]), i = 0;
  }
  e[0] = _h(e[0], t), e[1] = _h(e[1], t);
  var l = wR(e, i);
  e[i] += r;
  var u = n || 0, c = t.slice();
  l.sign < 0 ? c[0] += u : c[1] -= u, e[i] = _h(e[i], c);
  var h;
  return h = wR(e, i), n != null && (h.sign !== l.sign || h.span < n) && (e[1 - i] = e[i] + l.sign * n), h = wR(e, i), a != null && h.span > a && (e[1 - i] = e[i] + h.sign * a), e;
}
function wR(r, e) {
  var t = r[e] - r[1 - e];
  return {
    span: Math.abs(t),
    sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1
  };
}
function _h(r, e) {
  return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, r));
}
var NR = N, A4 = Math.min, _4 = Math.max, F2 = Math.floor, jme = Math.ceil, X2 = rr, Kme = Math.PI, Jme = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "parallel", this._axesMap = de(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, i);
    }
    return r.prototype._init = function(e, t, i) {
      var n = e.dimensions, a = e.parallelAxisIndex;
      NR(n, function(o, s) {
        var l = a[s], u = t.getComponent("parallelAxis", l), c = this._axesMap.set(o, new qme(o, kT(u), [0, 0], u.get("type"), l)), h = c.type === "category";
        c.onBand = h && u.get("boundaryGap"), c.inverse = u.get("inverse"), u.axis = c, c.model = u, c.coordinateSystem = u.coordinateSystem = this;
      }, this);
    }, r.prototype.update = function(e, t) {
      this._updateAxesFromSeries(this._model, e);
    }, r.prototype.containPoint = function(e) {
      var t = this._makeLayoutInfo(), i = t.axisBase, n = t.layoutBase, a = t.pixelDimIndex, o = e[1 - a], s = e[a];
      return o >= i && o <= i + t.axisLength && s >= n && s <= n + t.layoutLength;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype._updateAxesFromSeries = function(e, t) {
      t.eachSeries(function(i) {
        if (e.contains(i, t)) {
          var n = i.getData();
          NR(this.dimensions, function(a) {
            var o = this._axesMap.get(a);
            o.scale.unionExtentFromData(n, n.mapDimension(a)), Pf(o.scale, o.model);
          }, this);
        }
      }, this);
    }, r.prototype.resize = function(e, t) {
      this._rect = Ir(e.getBoxLayoutParams(), {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._layoutAxes();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._makeLayoutInfo = function() {
      var e = this._model, t = this._rect, i = ["x", "y"], n = ["width", "height"], a = e.get("layout"), o = a === "horizontal" ? 0 : 1, s = t[n[o]], l = [0, s], u = this.dimensions.length, c = am(e.get("axisExpandWidth"), l), h = am(e.get("axisExpandCount") || 0, [0, u]), f = e.get("axisExpandable") && u > 3 && u > h && h > 1 && c > 0 && s > 0, d = e.get("axisExpandWindow"), p;
      if (d)
        p = am(d[1] - d[0], l), d[1] = d[0] + p;
      else {
        p = am(c * (h - 1), l);
        var g = e.get("axisExpandCenter") || F2(u / 2);
        d = [c * g - p / 2], d[1] = d[0] + p;
      }
      var v = (s - p) / (u - h);
      v < 3 && (v = 0);
      var O = [F2(X2(d[0] / c, 1)) + 1, jme(X2(d[1] / c, 1)) - 1], m = v / c * d[0];
      return {
        layout: a,
        pixelDimIndex: o,
        layoutBase: t[i[o]],
        layoutLength: s,
        axisBase: t[i[1 - o]],
        axisLength: t[n[1 - o]],
        axisExpandable: f,
        axisExpandWidth: c,
        axisCollapseWidth: v,
        axisExpandWindow: d,
        axisCount: u,
        winInnerIndices: O,
        axisExpandWindow0Pos: m
      };
    }, r.prototype._layoutAxes = function() {
      var e = this._rect, t = this._axesMap, i = this.dimensions, n = this._makeLayoutInfo(), a = n.layout;
      t.each(function(o) {
        var s = [0, n.axisLength], l = o.inverse ? 1 : 0;
        o.setExtent(s[l], s[1 - l]);
      }), NR(i, function(o, s) {
        var l = (n.axisExpandable ? tEe : eEe)(s, n), u = {
          horizontal: {
            x: l.position,
            y: n.axisLength
          },
          vertical: {
            x: 0,
            y: l.position
          }
        }, c = {
          horizontal: Kme / 2,
          vertical: 0
        }, h = [u[a].x + e.x, u[a].y + e.y], f = c[a], d = na();
        zc(d, d, f), yo(d, d, h), this._axesLayout[o] = {
          position: h,
          rotation: f,
          transform: d,
          axisNameAvailableWidth: l.axisNameAvailableWidth,
          axisLabelShow: l.axisLabelShow,
          nameTruncateMaxWidth: l.nameTruncateMaxWidth,
          tickDirection: 1,
          labelDirection: 1
        };
      }, this);
    }, r.prototype.getAxis = function(e) {
      return this._axesMap.get(e);
    }, r.prototype.dataToPoint = function(e, t) {
      return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t);
    }, r.prototype.eachActiveState = function(e, t, i, n) {
      i == null && (i = 0), n == null && (n = e.count());
      var a = this._axesMap, o = this.dimensions, s = [], l = [];
      N(o, function(v) {
        s.push(e.mapDimension(v)), l.push(a.get(v).model);
      });
      for (var u = this.hasAxisBrushed(), c = i; c < n; c++) {
        var h = void 0;
        if (!u)
          h = "normal";
        else {
          h = "active";
          for (var f = e.getValues(s, c), d = 0, p = o.length; d < p; d++) {
            var g = l[d].getActiveState(f[d]);
            if (g === "inactive") {
              h = "inactive";
              break;
            }
          }
        }
        t(h, c);
      }
    }, r.prototype.hasAxisBrushed = function() {
      for (var e = this.dimensions, t = this._axesMap, i = !1, n = 0, a = e.length; n < a; n++)
        t.get(e[n]).model.getActiveState() !== "normal" && (i = !0);
      return i;
    }, r.prototype.axisCoordToPoint = function(e, t) {
      var i = this._axesLayout[t];
      return Ia([e, 0], i.transform);
    }, r.prototype.getAxisLayout = function(e) {
      return ye(this._axesLayout[e]);
    }, r.prototype.getSlidedAxisExpandWindow = function(e) {
      var t = this._makeLayoutInfo(), i = t.pixelDimIndex, n = t.axisExpandWindow.slice(), a = n[1] - n[0], o = [0, t.axisExpandWidth * (t.axisCount - 1)];
      if (!this.containPoint(e))
        return {
          behavior: "none",
          axisExpandWindow: n
        };
      var s = e[i] - t.layoutBase - t.axisExpandWindow0Pos, l, u = "slide", c = t.axisCollapseWidth, h = this._model.get("axisExpandSlideTriggerArea"), f = h[0] != null;
      if (c)
        f && c && s < a * h[0] ? (u = "jump", l = s - a * h[2]) : f && c && s > a * (1 - h[0]) ? (u = "jump", l = s - a * (1 - h[2])) : (l = s - a * h[1]) >= 0 && (l = s - a * (1 - h[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / c, l ? eh(l, n, o, "all") : u = "none";
      else {
        var d = n[1] - n[0], p = o[1] * s / d;
        n = [_4(0, p - d / 2)], n[1] = A4(o[1], n[0] + d), n[0] = n[1] - d;
      }
      return {
        axisExpandWindow: n,
        behavior: u
      };
    }, r;
  }()
);
function am(r, e) {
  return A4(_4(r, e[0]), e[1]);
}
function eEe(r, e) {
  var t = e.layoutLength / (e.axisCount - 1);
  return {
    position: t * r,
    axisNameAvailableWidth: t,
    axisLabelShow: !0
  };
}
function tEe(r, e) {
  var t = e.layoutLength, i = e.axisExpandWidth, n = e.axisCount, a = e.axisCollapseWidth, o = e.winInnerIndices, s, l = a, u = !1, c;
  return r < o[0] ? (s = r * a, c = a) : r <= o[1] ? (s = e.axisExpandWindow0Pos + r * i - e.axisExpandWindow[0], l = i, u = !0) : (s = t - (n - 1 - r) * a, c = a), {
    position: s,
    axisNameAvailableWidth: l,
    axisLabelShow: u,
    nameTruncateMaxWidth: c
  };
}
const rEe = Jme;
function iEe(r, e) {
  var t = [];
  return r.eachComponent("parallel", function(i, n) {
    var a = new rEe(i, r, e);
    a.name = "parallel_" + n, a.resize(i, e), i.coordinateSystem = a, a.model = i, t.push(a);
  }), r.eachSeries(function(i) {
    if (i.get("coordinateSystem") === "parallel") {
      var n = i.getReferringComponents("parallel", Or).models[0];
      i.coordinateSystem = n.coordinateSystem;
    }
  }), t;
}
var nEe = {
  create: iEe
};
const aEe = nEe;
var C4 = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.activeIntervals = [], t;
    }
    return e.prototype.getAreaSelectStyle = function() {
      return Nc([
        ["fill", "color"],
        ["lineWidth", "borderWidth"],
        ["stroke", "borderColor"],
        ["width", "width"],
        ["opacity", "opacity"]
        // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
      ])(this.getModel("areaSelectStyle"));
    }, e.prototype.setActiveIntervals = function(t) {
      var i = this.activeIntervals = ye(t);
      if (i)
        for (var n = i.length - 1; n >= 0; n--)
          Zn(i[n]);
    }, e.prototype.getActiveState = function(t) {
      var i = this.activeIntervals;
      if (!i.length)
        return "normal";
      if (t == null || isNaN(+t))
        return "inactive";
      if (i.length === 1) {
        var n = i[0];
        if (n[0] <= t && t <= n[1])
          return "active";
      } else
        for (var a = 0, o = i.length; a < o; a++)
          if (i[a][0] <= t && t <= i[a][1])
            return "active";
      return "inactive";
    }, e;
  }(st)
);
br(C4, Lv);
const Y2 = C4;
var Lc = !0, zg = Math.min, Mf = Math.max, oEe = Math.pow, sEe = 1e4, lEe = 6, uEe = 6, H2 = "globalPan", cEe = {
  w: [0, 0],
  e: [0, 1],
  n: [1, 0],
  s: [1, 1]
}, hEe = {
  w: "ew",
  e: "ew",
  n: "ns",
  s: "ns",
  ne: "nesw",
  sw: "nesw",
  nw: "nwse",
  se: "nwse"
}, W2 = {
  brushStyle: {
    lineWidth: 2,
    stroke: "rgba(210,219,238,0.3)",
    fill: "#D2DBEE"
  },
  transformable: !0,
  brushMode: "single",
  removeOnClick: !1
}, fEe = 0, dEe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this) || this;
      return i._track = [], i._covers = [], i._handlers = {}, {}.NODE_ENV !== "production" && Se(t), i._zr = t, i.group = new Re(), i._uid = "brushController_" + fEe++, N(bEe, function(n, a) {
        this._handlers[a] = ue(n, this);
      }, i), i;
    }
    return e.prototype.enableBrush = function(t) {
      return {}.NODE_ENV !== "production" && Se(this._mounted), this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this;
    }, e.prototype._doEnableBrush = function(t) {
      var i = this._zr;
      this._enableGlobalPan || yge(i, H2, this._uid), N(this._handlers, function(n, a) {
        i.on(a, n);
      }), this._brushType = t.brushType, this._brushOption = $e(ye(W2), t, !0);
    }, e.prototype._doDisableBrush = function() {
      var t = this._zr;
      Rge(t, H2, this._uid), N(this._handlers, function(i, n) {
        t.off(n, i);
      }), this._brushType = this._brushOption = null;
    }, e.prototype.setPanels = function(t) {
      if (t && t.length) {
        var i = this._panels = {};
        N(t, function(n) {
          i[n.panelId] = ye(n);
        });
      } else
        this._panels = null;
      return this;
    }, e.prototype.mount = function(t) {
      t = t || {}, {}.NODE_ENV !== "production" && (this._mounted = !0), this._enableGlobalPan = t.enableGlobalPan;
      var i = this.group;
      return this._zr.add(i), i.attr({
        x: t.x || 0,
        y: t.y || 0,
        rotation: t.rotation || 0,
        scaleX: t.scaleX || 1,
        scaleY: t.scaleY || 1
      }), this._transform = i.getLocalTransform(), this;
    }, e.prototype.updateCovers = function(t) {
      ({}).NODE_ENV !== "production" && Se(this._mounted), t = Y(t, function(f) {
        return $e(ye(W2), f, !0);
      });
      var i = "\0-brush-index-", n = this._covers, a = this._covers = [], o = this, s = this._creatingCover;
      return new cs(n, t, u, l).add(c).update(c).remove(h).execute(), this;
      function l(f, d) {
        return (f.id != null ? f.id : i + d) + "-" + f.brushType;
      }
      function u(f, d) {
        return l(f.__brushOption, d);
      }
      function c(f, d) {
        var p = t[f];
        if (d != null && n[d] === s)
          a[f] = n[d];
        else {
          var g = a[f] = d != null ? (n[d].__brushOption = p, n[d]) : w4(o, I4(o, p));
          qN(o, g);
        }
      }
      function h(f) {
        n[f] !== s && o.group.remove(n[f]);
      }
    }, e.prototype.unmount = function() {
      if (!({}.NODE_ENV !== "production" && !this._mounted))
        return this.enableBrush(!1), XC(this), this._zr.remove(this.group), {}.NODE_ENV !== "production" && (this._mounted = !1), this;
    }, e.prototype.dispose = function() {
      this.unmount(), this.off();
    }, e;
  }(oa)
);
function I4(r, e) {
  var t = FT[e.brushType].createCover(r, e);
  return t.__brushOption = e, x4(t, e), r.group.add(t), t;
}
function w4(r, e) {
  var t = jN(e);
  return t.endCreating && (t.endCreating(r, e), x4(e, e.__brushOption)), e;
}
function N4(r, e) {
  var t = e.__brushOption;
  jN(e).updateCoverShape(r, e, t.range, t);
}
function x4(r, e) {
  var t = e.z;
  t == null && (t = sEe), r.traverse(function(i) {
    i.z = t, i.z2 = t;
  });
}
function qN(r, e) {
  jN(e).updateCommon(r, e), N4(r, e);
}
function jN(r) {
  return FT[r.__brushOption.brushType];
}
function KN(r, e, t) {
  var i = r._panels;
  if (!i)
    return Lc;
  var n, a = r._transform;
  return N(i, function(o) {
    o.isTargetByCursor(e, t, a) && (n = o);
  }), n;
}
function P4(r, e) {
  var t = r._panels;
  if (!t)
    return Lc;
  var i = e.__brushOption.panelId;
  return i != null ? t[i] : Lc;
}
function XC(r) {
  var e = r._covers, t = e.length;
  return N(e, function(i) {
    r.group.remove(i);
  }, r), e.length = 0, !!t;
}
function Dc(r, e) {
  var t = Y(r._covers, function(i) {
    var n = i.__brushOption, a = ye(n.range);
    return {
      brushType: n.brushType,
      panelId: n.panelId,
      range: a
    };
  });
  r.trigger("brush", {
    areas: t,
    isEnd: !!e.isEnd,
    removeOnClick: !!e.removeOnClick
  });
}
function pEe(r) {
  var e = r._track;
  if (!e.length)
    return !1;
  var t = e[e.length - 1], i = e[0], n = t[0] - i[0], a = t[1] - i[1], o = oEe(n * n + a * a, 0.5);
  return o > lEe;
}
function L4(r) {
  var e = r.length - 1;
  return e < 0 && (e = 0), [r[0], r[e]];
}
function D4(r, e, t, i) {
  var n = new Re();
  return n.add(new ht({
    name: "main",
    style: JN(t),
    silent: !0,
    draggable: !0,
    cursor: "move",
    drift: Le(z2, r, e, n, ["n", "s", "w", "e"]),
    ondragend: Le(Dc, e, {
      isEnd: !0
    })
  })), N(i, function(a) {
    n.add(new ht({
      name: a.join(""),
      style: {
        opacity: 0
      },
      draggable: !0,
      silent: !0,
      invisible: !0,
      drift: Le(z2, r, e, n, a),
      ondragend: Le(Dc, e, {
        isEnd: !0
      })
    }));
  }), n;
}
function M4(r, e, t, i) {
  var n = i.brushStyle.lineWidth || 0, a = Mf(n, uEe), o = t[0][0], s = t[1][0], l = o - n / 2, u = s - n / 2, c = t[0][1], h = t[1][1], f = c - a + n / 2, d = h - a + n / 2, p = c - o, g = h - s, v = p + n, O = g + n;
  Uo(r, e, "main", o, s, p, g), i.transformable && (Uo(r, e, "w", l, u, a, O), Uo(r, e, "e", f, u, a, O), Uo(r, e, "n", l, u, v, a), Uo(r, e, "s", l, d, v, a), Uo(r, e, "nw", l, u, a, a), Uo(r, e, "ne", f, u, a, a), Uo(r, e, "sw", l, d, a, a), Uo(r, e, "se", f, d, a, a));
}
function YC(r, e) {
  var t = e.__brushOption, i = t.transformable, n = e.childAt(0);
  n.useStyle(JN(t)), n.attr({
    silent: !i,
    cursor: i ? "move" : "default"
  }), N([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function(a) {
    var o = e.childOfName(a.join("")), s = a.length === 1 ? HC(r, a[0]) : vEe(r, a);
    o && o.attr({
      silent: !i,
      invisible: !i,
      cursor: i ? hEe[s] + "-resize" : null
    });
  });
}
function Uo(r, e, t, i, n, a, o) {
  var s = e.childOfName(t);
  s && s.setShape(mEe(ex(r, e, [[i, n], [i + a, n + o]])));
}
function JN(r) {
  return Te({
    strokeNoScale: !0
  }, r.brushStyle);
}
function k4(r, e, t, i) {
  var n = [zg(r, t), zg(e, i)], a = [Mf(r, t), Mf(e, i)];
  return [
    [n[0], a[0]],
    [n[1], a[1]]
    // y range
  ];
}
function gEe(r) {
  return gc(r.group);
}
function HC(r, e) {
  var t = {
    w: "left",
    e: "right",
    n: "top",
    s: "bottom"
  }, i = {
    left: "w",
    right: "e",
    top: "n",
    bottom: "s"
  }, n = ST(t[e], gEe(r));
  return i[n];
}
function vEe(r, e) {
  var t = [HC(r, e[0]), HC(r, e[1])];
  return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("");
}
function z2(r, e, t, i, n, a) {
  var o = t.__brushOption, s = r.toRectRange(o.range), l = Q4(e, n, a);
  N(i, function(u) {
    var c = cEe[u];
    s[c[0]][c[1]] += l[c[0]];
  }), o.range = r.fromRectRange(k4(s[0][0], s[1][0], s[0][1], s[1][1])), qN(e, t), Dc(e, {
    isEnd: !1
  });
}
function OEe(r, e, t, i) {
  var n = e.__brushOption.range, a = Q4(r, t, i);
  N(n, function(o) {
    o[0] += a[0], o[1] += a[1];
  }), qN(r, e), Dc(r, {
    isEnd: !1
  });
}
function Q4(r, e, t) {
  var i = r.group, n = i.transformCoordToLocal(e, t), a = i.transformCoordToLocal(0, 0);
  return [n[0] - a[0], n[1] - a[1]];
}
function ex(r, e, t) {
  var i = P4(r, e);
  return i && i !== Lc ? i.clipPath(t, r._transform) : ye(t);
}
function mEe(r) {
  var e = zg(r[0][0], r[1][0]), t = zg(r[0][1], r[1][1]), i = Mf(r[0][0], r[1][0]), n = Mf(r[0][1], r[1][1]);
  return {
    x: e,
    y: t,
    width: i - e,
    height: n - t
  };
}
function EEe(r, e, t) {
  if (
    // Check active
    !(!r._brushType || SEe(r, e.offsetX, e.offsetY))
  ) {
    var i = r._zr, n = r._covers, a = KN(r, e, t);
    if (!r._dragging)
      for (var o = 0; o < n.length; o++) {
        var s = n[o].__brushOption;
        if (a && (a === Lc || s.panelId === a.panelId) && FT[s.brushType].contain(n[o], t[0], t[1]))
          return;
      }
    a && i.setCursorStyle("crosshair");
  }
}
function WC(r) {
  var e = r.event;
  e.preventDefault && e.preventDefault();
}
function zC(r, e, t) {
  return r.childOfName("main").contain(e, t);
}
function U4(r, e, t, i) {
  var n = r._creatingCover, a = r._creatingPanel, o = r._brushOption, s;
  if (r._track.push(t.slice()), pEe(r) || n) {
    if (a && !n) {
      o.brushMode === "single" && XC(r);
      var l = ye(o);
      l.brushType = Z2(l.brushType, a), l.panelId = a === Lc ? null : a.panelId, n = r._creatingCover = I4(r, l), r._covers.push(n);
    }
    if (n) {
      var u = FT[Z2(r._brushType, a)], c = n.__brushOption;
      c.range = u.getCreatingRange(ex(r, n, r._track)), i && (w4(r, n), u.updateCommon(r, n)), N4(r, n), s = {
        isEnd: i
      };
    }
  } else
    i && o.brushMode === "single" && o.removeOnClick && KN(r, e, t) && XC(r) && (s = {
      isEnd: i,
      removeOnClick: !0
    });
  return s;
}
function Z2(r, e) {
  return r === "auto" ? ({}.NODE_ENV !== "production" && Se(e && e.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"'), e.defaultBrushType) : r;
}
var bEe = {
  mousedown: function(r) {
    if (this._dragging)
      q2(this, r);
    else if (!r.target || !r.target.draggable) {
      WC(r);
      var e = this.group.transformCoordToLocal(r.offsetX, r.offsetY);
      this._creatingCover = null;
      var t = this._creatingPanel = KN(this, r, e);
      t && (this._dragging = !0, this._track = [e.slice()]);
    }
  },
  mousemove: function(r) {
    var e = r.offsetX, t = r.offsetY, i = this.group.transformCoordToLocal(e, t);
    if (EEe(this, r, i), this._dragging) {
      WC(r);
      var n = U4(this, r, i, !1);
      n && Dc(this, n);
    }
  },
  mouseup: function(r) {
    q2(this, r);
  }
};
function q2(r, e) {
  if (r._dragging) {
    WC(e);
    var t = e.offsetX, i = e.offsetY, n = r.group.transformCoordToLocal(t, i), a = U4(r, e, n, !0);
    r._dragging = !1, r._track = [], r._creatingCover = null, a && Dc(r, a);
  }
}
function SEe(r, e, t) {
  var i = r._zr;
  return e < 0 || e > i.getWidth() || t < 0 || t > i.getHeight();
}
var FT = {
  lineX: j2(0),
  lineY: j2(1),
  rect: {
    createCover: function(r, e) {
      function t(i) {
        return i;
      }
      return D4({
        toRectRange: t,
        fromRectRange: t
      }, r, e, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]);
    },
    getCreatingRange: function(r) {
      var e = L4(r);
      return k4(e[1][0], e[1][1], e[0][0], e[0][1]);
    },
    updateCoverShape: function(r, e, t, i) {
      M4(r, e, t, i);
    },
    updateCommon: YC,
    contain: zC
  },
  polygon: {
    createCover: function(r, e) {
      var t = new Re();
      return t.add(new nn({
        name: "main",
        style: JN(e),
        silent: !0
      })), t;
    },
    getCreatingRange: function(r) {
      return r;
    },
    endCreating: function(r, e) {
      e.remove(e.childAt(0)), e.add(new rn({
        name: "main",
        draggable: !0,
        drift: Le(OEe, r, e),
        ondragend: Le(Dc, r, {
          isEnd: !0
        })
      }));
    },
    updateCoverShape: function(r, e, t, i) {
      e.childAt(0).setShape({
        points: ex(r, e, t)
      });
    },
    updateCommon: YC,
    contain: zC
  }
};
function j2(r) {
  return {
    createCover: function(e, t) {
      return D4({
        toRectRange: function(i) {
          var n = [i, [0, 100]];
          return r && n.reverse(), n;
        },
        fromRectRange: function(i) {
          return i[r];
        }
      }, e, t, [[["w"], ["e"]], [["n"], ["s"]]][r]);
    },
    getCreatingRange: function(e) {
      var t = L4(e), i = zg(t[0][r], t[1][r]), n = Mf(t[0][r], t[1][r]);
      return [i, n];
    },
    updateCoverShape: function(e, t, i, n) {
      var a, o = P4(e, t);
      if (o !== Lc && o.getLinearBrushOtherExtent)
        a = o.getLinearBrushOtherExtent(r);
      else {
        var s = e._zr;
        a = [0, [s.getWidth(), s.getHeight()][1 - r]];
      }
      var l = [i, a];
      r && l.reverse(), M4(e, t, l, n);
    },
    updateCommon: YC,
    contain: zC
  };
}
const tx = dEe;
function $4(r) {
  return r = rx(r), function(e) {
    return HH(e, r);
  };
}
function V4(r, e) {
  return r = rx(r), function(t) {
    var i = e ?? t, n = i ? r.width : r.height, a = i ? r.x : r.y;
    return [a, a + (n || 0)];
  };
}
function G4(r, e, t) {
  var i = rx(r);
  return function(n, a) {
    return i.contain(a[0], a[1]) && !$T(n, e, t);
  };
}
function rx(r) {
  return Ve.create(r);
}
var TEe = ["axisLine", "axisTickLabel", "axisName"], yEe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      r.prototype.init.apply(this, arguments), (this._brushController = new tx(i.getZr())).on("brush", ue(this._onBrush, this));
    }, e.prototype.render = function(t, i, n, a) {
      if (!REe(t, i, a)) {
        this.axisModel = t, this.api = n, this.group.removeAll();
        var o = this._axisGroup;
        if (this._axisGroup = new Re(), this.group.add(this._axisGroup), !!t.get("show")) {
          var s = _Ee(t, i), l = s.coordinateSystem, u = t.getAreaSelectStyle(), c = u.width, h = t.axis.dim, f = l.getAxisLayout(h), d = B({
            strokeContainThreshold: c
          }, f), p = new hs(t, d);
          N(TEe, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(d, u, t, s, c, n), Cv(o, this._axisGroup, t);
        }
      }
    }, e.prototype._refreshBrushController = function(t, i, n, a, o, s) {
      var l = n.axis.getExtent(), u = l[1] - l[0], c = Math.min(30, Math.abs(u) * 0.1), h = Ve.create({
        x: l[0],
        y: -o / 2,
        width: u,
        height: o
      });
      h.x -= c, h.width += 2 * c, this._brushController.mount({
        enableGlobalPan: !0,
        rotation: t.rotation,
        x: t.position[0],
        y: t.position[1]
      }).setPanels([{
        panelId: "pl",
        clipPath: $4(h),
        isTargetByCursor: G4(h, s, a),
        getLinearBrushOtherExtent: V4(h, 0)
      }]).enableBrush({
        brushType: "lineX",
        brushStyle: i,
        removeOnClick: !0
      }).updateCovers(AEe(n));
    }, e.prototype._onBrush = function(t) {
      var i = t.areas, n = this.axisModel, a = n.axis, o = Y(i, function(s) {
        return [a.coordToData(s.range[0], !0), a.coordToData(s.range[1], !0)];
      });
      (!n.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "axisAreaSelect",
        parallelAxisId: n.id,
        intervals: o
      });
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.type = "parallelAxis", e;
  }(jt)
);
function REe(r, e, t) {
  return t && t.type === "axisAreaSelect" && e.findComponents({
    mainType: "parallelAxis",
    query: t
  })[0] === r;
}
function AEe(r) {
  var e = r.axis;
  return Y(r.activeIntervals, function(t) {
    return {
      brushType: "lineX",
      panelId: "pl",
      range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)]
    };
  });
}
function _Ee(r, e) {
  return e.getComponent("parallel", r.get("parallelIndex"));
}
const CEe = yEe;
var IEe = {
  type: "axisAreaSelect",
  event: "axisAreaSelected"
  // update: 'updateVisual'
};
function wEe(r) {
  r.registerAction(IEe, function(e, t) {
    t.eachComponent({
      mainType: "parallelAxis",
      query: e
    }, function(i) {
      i.axis.model.setActiveIntervals(e.intervals);
    });
  }), r.registerAction("parallelAxisExpand", function(e, t) {
    t.eachComponent({
      mainType: "parallel",
      query: e
    }, function(i) {
      i.setAxisExpand(e);
    });
  });
}
var NEe = {
  type: "value",
  areaSelectStyle: {
    width: 20,
    borderWidth: 1,
    borderColor: "rgba(160,197,232)",
    color: "rgba(160,197,232)",
    opacity: 0.3
  },
  realtime: !0,
  z: 10
};
function B4(r) {
  r.registerComponentView(Hme), r.registerComponentModel(zme), r.registerCoordinateSystem("parallel", aEe), r.registerPreprocessor(Vme), r.registerComponentModel(Y2), r.registerComponentView(CEe), Df(r, "parallel", Y2, NEe), wEe(r);
}
function xEe(r) {
  Ye(B4), r.registerChartView(Pme), r.registerSeriesModel(kme), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, $me);
}
var PEe = (
  /** @class */
  function() {
    function r() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return r;
  }()
), LEe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      return r.call(this, t) || this;
    }
    return e.prototype.getDefaultShape = function() {
      return new PEe();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.extent;
      t.moveTo(i.x1, i.y1), t.bezierCurveTo(i.cpx1, i.cpy1, i.cpx2, i.cpy2, i.x2, i.y2), i.orient === "vertical" ? (t.lineTo(i.x2 + n, i.y2), t.bezierCurveTo(i.cpx2 + n, i.cpy2, i.cpx1 + n, i.cpy1, i.x1 + n, i.y1)) : (t.lineTo(i.x2, i.y2 + n), t.bezierCurveTo(i.cpx2, i.cpy2 + n, i.cpx1, i.cpy1 + n, i.x1, i.y1 + n)), t.closePath();
    }, e.prototype.highlight = function() {
      ls(this);
    }, e.prototype.downplay = function() {
      us(this);
    }, e;
  }(He)
), DEe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._focusAdjacencyDisabled = !1, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this, o = t.getGraph(), s = this.group, l = t.layoutInfo, u = l.width, c = l.height, h = t.getData(), f = t.getData("edge"), d = t.get("orient");
      this._model = t, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function(p) {
        var g = new LEe(), v = Pe(g);
        v.dataIndex = p.dataIndex, v.seriesIndex = t.seriesIndex, v.dataType = "edge";
        var O = p.getModel(), m = O.getModel("lineStyle"), E = m.get("curveness"), b = p.node1.getLayout(), S = p.node1.getModel(), T = S.get("localX"), y = S.get("localY"), R = p.node2.getLayout(), _ = p.node2.getModel(), C = _.get("localX"), I = _.get("localY"), w = p.getLayout(), x, P, L, D, U, Q, V, F;
        g.shape.extent = Math.max(1, w.dy), g.shape.orient = d, d === "vertical" ? (x = (T != null ? T * u : b.x) + w.sy, P = (y != null ? y * c : b.y) + b.dy, L = (C != null ? C * u : R.x) + w.ty, D = I != null ? I * c : R.y, U = x, Q = P * (1 - E) + D * E, V = L, F = P * E + D * (1 - E)) : (x = (T != null ? T * u : b.x) + b.dx, P = (y != null ? y * c : b.y) + w.sy, L = C != null ? C * u : R.x, D = (I != null ? I * c : R.y) + w.ty, U = x * (1 - E) + L * E, Q = P, V = x * E + L * (1 - E), F = D), g.setShape({
          x1: x,
          y1: P,
          x2: L,
          y2: D,
          cpx1: U,
          cpy1: Q,
          cpx2: V,
          cpy2: F
        }), g.useStyle(m.getItemStyle()), K2(g.style, d, p);
        var j = "" + O.get("value"), ae = kr(O, "edgeLabel");
        ii(g, ae, {
          labelFetcher: {
            getFormattedLabel: function(Be, We, Ne, Ee, Ge, Ie) {
              return t.getFormattedLabel(
                Be,
                We,
                "edge",
                Ee,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Kn(Ge, ae.normal && ae.normal.get("formatter"), j),
                Ie
              );
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: j
        }), g.setTextConfig({
          position: "inside"
        });
        var ce = O.getModel("emphasis");
        ri(g, O, "lineStyle", function(Be) {
          var We = Be.getItemStyle();
          return K2(We, d, p), We;
        }), s.add(g), f.setItemGraphicEl(p.dataIndex, g);
        var ge = ce.get("focus");
        qt(g, ge === "adjacency" ? p.getAdjacentDataIndices() : ge === "trajectory" ? p.getTrajectoryDataIndices() : ge, ce.get("blurScope"), ce.get("disabled"));
      }), o.eachNode(function(p) {
        var g = p.getLayout(), v = p.getModel(), O = v.get("localX"), m = v.get("localY"), E = v.getModel("emphasis"), b = new ht({
          shape: {
            x: O != null ? O * u : g.x,
            y: m != null ? m * c : g.y,
            width: g.dx,
            height: g.dy
          },
          style: v.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        ii(b, kr(v), {
          labelFetcher: {
            getFormattedLabel: function(T, y) {
              return t.getFormattedLabel(T, y, "node");
            }
          },
          labelDataIndex: p.dataIndex,
          defaultText: p.id
        }), b.disableLabelAnimation = !0, b.setStyle("fill", p.getVisual("color")), b.setStyle("decal", p.getVisual("style").decal), ri(b, v), s.add(b), h.setItemGraphicEl(p.dataIndex, b), Pe(b).dataType = "node";
        var S = E.get("focus");
        qt(b, S === "adjacency" ? p.getAdjacentDataIndices() : S === "trajectory" ? p.getTrajectoryDataIndices() : S, E.get("blurScope"), E.get("disabled"));
      }), h.eachItemGraphicEl(function(p, g) {
        var v = h.getItemModel(g);
        v.get("draggable") && (p.drift = function(O, m) {
          a._focusAdjacencyDisabled = !0, this.shape.x += O, this.shape.y += m, this.dirty(), n.dispatchAction({
            type: "dragNode",
            seriesId: t.id,
            dataIndex: h.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, p.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, p.draggable = !0, p.cursor = "move");
      }), !this._data && t.isAnimationEnabled() && s.setClipPath(MEe(s.getBoundingRect(), t, function() {
        s.removeClipPath();
      })), this._data = t.getData();
    }, e.prototype.dispose = function() {
    }, e.type = "sankey", e;
  }($t)
);
function K2(r, e, t) {
  switch (r.fill) {
    case "source":
      r.fill = t.node1.getVisual("color"), r.decal = t.node1.getVisual("style").decal;
      break;
    case "target":
      r.fill = t.node2.getVisual("color"), r.decal = t.node2.getVisual("style").decal;
      break;
    case "gradient":
      var i = t.node1.getVisual("color"), n = t.node2.getVisual("color");
      ne(i) && ne(n) && (r.fill = new _v(0, 0, +(e === "horizontal"), +(e === "vertical"), [{
        color: i,
        offset: 0
      }, {
        color: n,
        offset: 1
      }]));
  }
}
function MEe(r, e, t) {
  var i = new ht({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return Bt(i, {
    shape: {
      width: r.width + 20
    }
  }, e, t), i;
}
const kEe = DEe;
var QEe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      var n = t.edges || t.links, a = t.data || t.nodes, o = t.levels;
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        if (o[l].depth != null && o[l].depth >= 0)
          s[o[l].depth] = new Ut(o[l], this, i);
        else if ({}.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      if (a && n) {
        var u = y4(a, n, this, !0, c);
        return u.data;
      }
      function c(h, f) {
        h.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getData().getItemLayout(p);
          if (v) {
            var O = v.depth, m = g.levelModels[O];
            m && (d.parentModel = m);
          }
          return d;
        }), f.wrapMethod("getItemModel", function(d, p) {
          var g = d.parentModel, v = g.getGraph().getEdgeByIndex(p), O = v.node1.getLayout();
          if (O) {
            var m = O.depth, E = g.levelModels[m];
            E && (d.parentModel = E);
          }
          return d;
        });
      }
    }, e.prototype.setNodePosition = function(t, i) {
      var n = this.option.data || this.option.nodes, a = n[t];
      a.localX = i[0], a.localY = i[1];
    }, e.prototype.getGraph = function() {
      return this.getData().graph;
    }, e.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, e.prototype.formatTooltip = function(t, i, n) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (n === "edge") {
        var o = this.getDataParams(t, n), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return Qr("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(t), h = c.getLayout().value, f = this.getDataParams(t, n).data.name;
        return Qr("nameValue", {
          name: f != null ? f + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, e.prototype.optionUpdated = function() {
    }, e.prototype.getDataParams = function(t, i) {
      var n = r.prototype.getDataParams.call(this, t, i);
      if (n.value == null && i === "node") {
        var a = this.getGraph().getNodeByIndex(t), o = a.getLayout().value;
        n.value = o;
      }
      return n;
    }, e.type = "series.sankey", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "view",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: "#314656",
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, e;
  }(Wt)
);
const UEe = QEe;
function $Ee(r, e) {
  r.eachSeriesByType("sankey", function(t) {
    var i = t.get("nodeWidth"), n = t.get("nodeGap"), a = VEe(t, e);
    t.layoutInfo = a;
    var o = a.width, s = a.height, l = t.getGraph(), u = l.nodes, c = l.edges;
    BEe(u);
    var h = At(u, function(g) {
      return g.getLayout().value === 0;
    }), f = h.length !== 0 ? 0 : t.get("layoutIterations"), d = t.get("orient"), p = t.get("nodeAlign");
    GEe(u, c, i, n, o, s, f, d, p);
  });
}
function VEe(r, e) {
  return Ir(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  });
}
function GEe(r, e, t, i, n, a, o, s, l) {
  FEe(r, e, t, n, a, s, l), WEe(r, e, a, n, i, o, s), rbe(r, s);
}
function BEe(r) {
  N(r, function(e) {
    var t = vl(e.outEdges, Mb), i = vl(e.inEdges, Mb), n = e.getValue() || 0, a = Math.max(t, i, n);
    e.setLayout({
      value: a
    }, !0);
  });
}
function FEe(r, e, t, i, n, a, o) {
  for (var s = [], l = [], u = [], c = [], h = 0, f = 0; f < e.length; f++)
    s[f] = 1;
  for (var f = 0; f < r.length; f++)
    l[f] = r[f].inEdges.length, l[f] === 0 && u.push(r[f]);
  for (var d = -1; u.length; ) {
    for (var p = 0; p < u.length; p++) {
      var g = u[p], v = g.hostGraph.data.getRawDataItem(g.dataIndex), O = v.depth != null && v.depth >= 0;
      O && v.depth > d && (d = v.depth), g.setLayout({
        depth: O ? v.depth : h
      }, !0), a === "vertical" ? g.setLayout({
        dy: t
      }, !0) : g.setLayout({
        dx: t
      }, !0);
      for (var m = 0; m < g.outEdges.length; m++) {
        var E = g.outEdges[m], b = e.indexOf(E);
        s[b] = 0;
        var S = E.node2, T = r.indexOf(S);
        --l[T] === 0 && c.indexOf(S) < 0 && c.push(S);
      }
    }
    ++h, u = c, c = [];
  }
  for (var f = 0; f < s.length; f++)
    if (s[f] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var y = d > h - 1 ? d : h - 1;
  o && o !== "left" && XEe(r, o, a, y);
  var R = a === "vertical" ? (n - t) / y : (i - t) / y;
  HEe(r, R, a);
}
function F4(r) {
  var e = r.hostGraph.data.getRawDataItem(r.dataIndex);
  return e.depth != null && e.depth >= 0;
}
function XEe(r, e, t, i) {
  if (e === "right") {
    for (var n = [], a = r, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s];
        l.setLayout({
          skNodeHeight: o
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          n.indexOf(c.node1) < 0 && n.push(c.node1);
        }
      }
      a = n, n = [], ++o;
    }
    N(r, function(h) {
      F4(h) || h.setLayout({
        depth: Math.max(0, i - h.getLayout().skNodeHeight)
      }, !0);
    });
  } else
    e === "justify" && YEe(r, i);
}
function YEe(r, e) {
  N(r, function(t) {
    !F4(t) && !t.outEdges.length && t.setLayout({
      depth: e
    }, !0);
  });
}
function HEe(r, e, t) {
  N(r, function(i) {
    var n = i.getLayout().depth * e;
    t === "vertical" ? i.setLayout({
      y: n
    }, !0) : i.setLayout({
      x: n
    }, !0);
  });
}
function WEe(r, e, t, i, n, a, o) {
  var s = zEe(r, o);
  ZEe(s, e, t, i, n, o), xR(s, n, t, i, o);
  for (var l = 1; a > 0; a--)
    l *= 0.99, qEe(s, l, o), xR(s, n, t, i, o), tbe(s, l, o), xR(s, n, t, i, o);
}
function zEe(r, e) {
  var t = [], i = e === "vertical" ? "y" : "x", n = q_(r, function(a) {
    return a.getLayout()[i];
  });
  return n.keys.sort(function(a, o) {
    return a - o;
  }), N(n.keys, function(a) {
    t.push(n.buckets.get(a));
  }), t;
}
function ZEe(r, e, t, i, n, a) {
  var o = 1 / 0;
  N(r, function(s) {
    var l = s.length, u = 0;
    N(s, function(h) {
      u += h.getLayout().value;
    });
    var c = a === "vertical" ? (i - (l - 1) * n) / u : (t - (l - 1) * n) / u;
    c < o && (o = c);
  }), N(r, function(s) {
    N(s, function(l, u) {
      var c = l.getLayout().value * o;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), N(e, function(s) {
    var l = +s.getValue() * o;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function xR(r, e, t, i, n) {
  var a = n === "vertical" ? "x" : "y";
  N(r, function(o) {
    o.sort(function(g, v) {
      return g.getLayout()[a] - v.getLayout()[a];
    });
    for (var s, l, u, c = 0, h = o.length, f = n === "vertical" ? "dx" : "dy", d = 0; d < h; d++)
      l = o[d], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, n === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[a] + l.getLayout()[f] + e;
    var p = n === "vertical" ? i : t;
    if (u = c - e - p, u > 0) {
      s = l.getLayout()[a] - u, n === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var d = h - 2; d >= 0; --d)
        l = o[d], u = l.getLayout()[a] + l.getLayout()[f] + e - c, u > 0 && (s = l.getLayout()[a] - u, n === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function qEe(r, e, t) {
  N(r.slice().reverse(), function(i) {
    N(i, function(n) {
      if (n.outEdges.length) {
        var a = vl(n.outEdges, jEe, t) / vl(n.outEdges, Mb);
        if (isNaN(a)) {
          var o = n.outEdges.length;
          a = o ? vl(n.outEdges, KEe, t) / o : 0;
        }
        if (t === "vertical") {
          var s = n.getLayout().x + (a - Ml(n, t)) * e;
          n.setLayout({
            x: s
          }, !0);
        } else {
          var l = n.getLayout().y + (a - Ml(n, t)) * e;
          n.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function jEe(r, e) {
  return Ml(r.node2, e) * r.getValue();
}
function KEe(r, e) {
  return Ml(r.node2, e);
}
function JEe(r, e) {
  return Ml(r.node1, e) * r.getValue();
}
function ebe(r, e) {
  return Ml(r.node1, e);
}
function Ml(r, e) {
  return e === "vertical" ? r.getLayout().x + r.getLayout().dx / 2 : r.getLayout().y + r.getLayout().dy / 2;
}
function Mb(r) {
  return r.getValue();
}
function vl(r, e, t) {
  for (var i = 0, n = r.length, a = -1; ++a < n; ) {
    var o = +e(r[a], t);
    isNaN(o) || (i += o);
  }
  return i;
}
function tbe(r, e, t) {
  N(r, function(i) {
    N(i, function(n) {
      if (n.inEdges.length) {
        var a = vl(n.inEdges, JEe, t) / vl(n.inEdges, Mb);
        if (isNaN(a)) {
          var o = n.inEdges.length;
          a = o ? vl(n.inEdges, ebe, t) / o : 0;
        }
        if (t === "vertical") {
          var s = n.getLayout().x + (a - Ml(n, t)) * e;
          n.setLayout({
            x: s
          }, !0);
        } else {
          var l = n.getLayout().y + (a - Ml(n, t)) * e;
          n.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function rbe(r, e) {
  var t = e === "vertical" ? "x" : "y";
  N(r, function(i) {
    i.outEdges.sort(function(n, a) {
      return n.node2.getLayout()[t] - a.node2.getLayout()[t];
    }), i.inEdges.sort(function(n, a) {
      return n.node1.getLayout()[t] - a.node1.getLayout()[t];
    });
  }), N(r, function(i) {
    var n = 0, a = 0;
    N(i.outEdges, function(o) {
      o.setLayout({
        sy: n
      }, !0), n += o.getLayout().dy;
    }), N(i.inEdges, function(o) {
      o.setLayout({
        ty: a
      }, !0), a += o.getLayout().dy;
    });
  });
}
function ibe(r) {
  r.eachSeriesByType("sankey", function(e) {
    var t = e.getGraph(), i = t.nodes, n = t.edges;
    if (i.length) {
      var a = 1 / 0, o = -1 / 0;
      N(i, function(s) {
        var l = s.getLayout().value;
        l < a && (a = l), l > o && (o = l);
      }), N(i, function(s) {
        var l = new Jr({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, o],
          visual: e.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    n.length && N(n, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function nbe(r) {
  r.registerChartView(kEe), r.registerSeriesModel(UEe), r.registerLayout($Ee), r.registerVisual(ibe), r.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: e
    }, function(i) {
      i.setNodePosition(e.dataIndex, [e.localX, e.localY]);
    });
  });
}
var X4 = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.getInitialData = function(e, t) {
      var i, n = t.getComponent("xAxis", this.get("xAxisIndex")), a = t.getComponent("yAxis", this.get("yAxisIndex")), o = n.get("type"), s = a.get("type"), l;
      o === "category" ? (e.layout = "horizontal", i = n.getOrdinalMeta(), l = !0) : s === "category" ? (e.layout = "vertical", i = a.getOrdinalMeta(), l = !0) : e.layout = e.layout || "horizontal";
      var u = ["x", "y"], c = e.layout === "horizontal" ? 0 : 1, h = this._baseAxisDim = u[c], f = u[1 - c], d = [n, a], p = d[c].get("type"), g = d[1 - c].get("type"), v = e.data;
      if (v && l) {
        var O = [];
        N(v, function(b, S) {
          var T;
          X(b) ? (T = b.slice(), b.unshift(S)) : X(b.value) ? (T = B({}, b), T.value = T.value.slice(), b.value.unshift(S)) : T = b, O.push(T);
        }), e.data = O;
      }
      var m = this.defaultValueDimensions, E = [{
        name: h,
        type: yb(p),
        ordinalMeta: i,
        otherDims: {
          tooltip: !1,
          itemName: 0
        },
        dimsDef: ["base"]
      }, {
        name: f,
        type: yb(g),
        dimsDef: m.slice()
      }];
      return hd(this, {
        coordDimensions: E,
        dimensionsCount: m.length + 1,
        encodeDefaulter: Le(mW, E, this)
      });
    }, r.prototype.getBaseAxis = function() {
      var e = this._baseAxisDim;
      return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis;
    }, r;
  }()
), Y4 = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "min",
        defaultTooltip: !0
      }, {
        name: "Q1",
        defaultTooltip: !0
      }, {
        name: "median",
        defaultTooltip: !0
      }, {
        name: "Q3",
        defaultTooltip: !0
      }, {
        name: "max",
        defaultTooltip: !0
      }], t.visualDrawType = "stroke", t;
    }
    return e.type = "series.boxplot", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      layout: null,
      boxWidth: [7, 50],
      itemStyle: {
        color: "#fff",
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2,
          shadowBlur: 5,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: "rgba(0,0,0,0.2)"
        }
      },
      animationDuration: 800
    }, e;
  }(Wt)
);
br(Y4, X4, !0);
const abe = Y4;
var obe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this.group, s = this._data;
      this._data || o.removeAll();
      var l = t.get("layout") === "horizontal" ? 1 : 0;
      a.diff(s).add(function(u) {
        if (a.hasValue(u)) {
          var c = a.getItemLayout(u), h = J2(c, a, u, l, !0);
          a.setItemGraphicEl(u, h), o.add(h);
        }
      }).update(function(u, c) {
        var h = s.getItemGraphicEl(c);
        if (!a.hasValue(u)) {
          o.remove(h);
          return;
        }
        var f = a.getItemLayout(u);
        h ? (La(h), H4(f, h, a, u)) : h = J2(f, a, u, l), o.add(h), a.setItemGraphicEl(u, h);
      }).remove(function(u) {
        var c = s.getItemGraphicEl(u);
        c && o.remove(c);
      }).execute(), this._data = a;
    }, e.prototype.remove = function(t) {
      var i = this.group, n = this._data;
      this._data = null, n && n.eachItemGraphicEl(function(a) {
        a && i.remove(a);
      });
    }, e.type = "boxplot", e;
  }($t)
), sbe = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), lbe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "boxplotBoxPath", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new sbe();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points, a = 0;
      for (t.moveTo(n[a][0], n[a][1]), a++; a < 4; a++)
        t.lineTo(n[a][0], n[a][1]);
      for (t.closePath(); a < n.length; a++)
        t.moveTo(n[a][0], n[a][1]), a++, t.lineTo(n[a][0], n[a][1]);
    }, e;
  }(He)
);
function J2(r, e, t, i, n) {
  var a = r.ends, o = new lbe({
    shape: {
      points: n ? ube(a, i, r) : a
    }
  });
  return H4(r, o, e, t, n), o;
}
function H4(r, e, t, i, n) {
  var a = t.hostModel, o = wv[n ? "initProps" : "updateProps"];
  o(e, {
    shape: {
      points: r.ends
    }
  }, a, i), e.useStyle(t.getItemVisual(i, "style")), e.style.strokeNoScale = !0, e.z2 = 100;
  var s = t.getItemModel(i), l = s.getModel("emphasis");
  ri(e, s), qt(e, l.get("focus"), l.get("blurScope"), l.get("disabled"));
}
function ube(r, e, t) {
  return Y(r, function(i) {
    return i = i.slice(), i[e] = t.initBaseline, i;
  });
}
const cbe = obe;
var tg = N;
function hbe(r) {
  var e = fbe(r);
  tg(e, function(t) {
    var i = t.seriesModels;
    i.length && (dbe(t), tg(i, function(n, a) {
      pbe(n, t.boxOffsetList[a], t.boxWidthList[a]);
    }));
  });
}
function fbe(r) {
  var e = [], t = [];
  return r.eachSeriesByType("boxplot", function(i) {
    var n = i.getBaseAxis(), a = Fe(t, n);
    a < 0 && (a = t.length, t[a] = n, e[a] = {
      axis: n,
      seriesModels: []
    }), e[a].seriesModels.push(i);
  }), e;
}
function dbe(r) {
  var e = r.axis, t = r.seriesModels, i = t.length, n = r.boxWidthList = [], a = r.boxOffsetList = [], o = [], s;
  if (e.type === "category")
    s = e.getBandWidth();
  else {
    var l = 0;
    tg(t, function(p) {
      l = Math.max(l, p.getData().count());
    });
    var u = e.getExtent();
    s = Math.abs(u[1] - u[0]) / l;
  }
  tg(t, function(p) {
    var g = p.get("boxWidth");
    X(g) || (g = [g, g]), o.push([K(g[0], s) || 0, K(g[1], s) || 0]);
  });
  var c = s * 0.8 - 2, h = c / i * 0.3, f = (c - h * (i - 1)) / i, d = f / 2 - c / 2;
  tg(t, function(p, g) {
    a.push(d), d += h + f, n.push(Math.min(Math.max(f, o[g][0]), o[g][1]));
  });
}
function pbe(r, e, t) {
  var i = r.coordinateSystem, n = r.getData(), a = t / 2, o = r.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], u = n.mapDimension(l[o]), c = n.mapDimensionsAll(l[s]);
  if (u == null || c.length < 5)
    return;
  for (var h = 0; h < n.count(); h++) {
    var f = n.get(u, h), d = E(f, c[2], h), p = E(f, c[0], h), g = E(f, c[1], h), v = E(f, c[3], h), O = E(f, c[4], h), m = [];
    b(m, g, !1), b(m, v, !0), m.push(p, g, O, v), S(m, p), S(m, O), S(m, d), n.setItemLayout(h, {
      initBaseline: d[s],
      ends: m
    });
  }
  function E(T, y, R) {
    var _ = n.get(y, R), C = [];
    C[o] = T, C[s] = _;
    var I;
    return isNaN(T) || isNaN(_) ? I = [NaN, NaN] : (I = i.dataToPoint(C), I[o] += e), I;
  }
  function b(T, y, R) {
    var _ = y.slice(), C = y.slice();
    _[o] += a, C[o] -= a, R ? T.push(_, C) : T.push(C, _);
  }
  function S(T, y) {
    var R = y.slice(), _ = y.slice();
    R[o] -= a, _[o] += a, T.push(R, _);
  }
}
function gbe(r, e) {
  e = e || {};
  for (var t = [], i = [], n = e.boundIQR, a = n === "none" || n === 0, o = 0; o < r.length; o++) {
    var s = Zn(r[o].slice()), l = a0(s, 0.25), u = a0(s, 0.5), c = a0(s, 0.75), h = s[0], f = s[s.length - 1], d = (n ?? 1.5) * (c - l), p = a ? h : Math.max(h, l - d), g = a ? f : Math.min(f, c + d), v = e.itemNameFormatter, O = ve(v) ? v({
      value: o
    }) : ne(v) ? v.replace("{value}", o + "") : o + "";
    t.push([O, p, l, u, c, g]);
    for (var m = 0; m < s.length; m++) {
      var E = s[m];
      if (E < p || E > g) {
        var b = [O, E];
        i.push(b);
      }
    }
  }
  return {
    boxData: t,
    outliers: i
  };
}
var vbe = {
  type: "echarts:boxplot",
  transform: function(e) {
    var t = e.upstream;
    if (t.sourceFormat !== Ei) {
      var i = "";
      ({}).NODE_ENV !== "production" && (i = Ui("source data is not applicable for this boxplot transform. Expect number[][].")), St(i);
    }
    var n = gbe(t.getRawData(), e.config);
    return [{
      dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"],
      data: n.boxData
    }, {
      data: n.outliers
    }];
  }
};
function Obe(r) {
  r.registerSeriesModel(abe), r.registerChartView(cbe), r.registerLayout(hbe), r.registerTransform(vbe);
}
var mbe = ["color", "borderColor"], Ebe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t);
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this._clear(), this._updateDrawMode(t);
    }, e.prototype.incrementalRender = function(t, i, n, a) {
      this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, i) : this._incrementalRenderNormal(t, i);
    }, e.prototype.eachRendered = function(t) {
      zl(this._progressiveEls || this.group, t);
    }, e.prototype._updateDrawMode = function(t) {
      var i = t.pipelineContext.large;
      (this._isLargeDraw == null || i !== this._isLargeDraw) && (this._isLargeDraw = i, this._clear());
    }, e.prototype._renderNormal = function(t) {
      var i = t.getData(), n = this._data, a = this.group, o = i.getLayout("isSimpleBox"), s = t.get("clip", !0), l = t.coordinateSystem, u = l.getArea && l.getArea();
      this._data || a.removeAll(), i.diff(n).add(function(c) {
        if (i.hasValue(c)) {
          var h = i.getItemLayout(c);
          if (s && eU(u, h))
            return;
          var f = PR(h, c, !0);
          Bt(f, {
            shape: {
              points: h.ends
            }
          }, t, c), LR(f, i, c, o), a.add(f), i.setItemGraphicEl(c, f);
        }
      }).update(function(c, h) {
        var f = n.getItemGraphicEl(h);
        if (!i.hasValue(c)) {
          a.remove(f);
          return;
        }
        var d = i.getItemLayout(c);
        if (s && eU(u, d)) {
          a.remove(f);
          return;
        }
        f ? (Ot(f, {
          shape: {
            points: d.ends
          }
        }, t, c), La(f)) : f = PR(d), LR(f, i, c, o), a.add(f), i.setItemGraphicEl(c, f);
      }).remove(function(c) {
        var h = n.getItemGraphicEl(c);
        h && a.remove(h);
      }).execute(), this._data = i;
    }, e.prototype._renderLarge = function(t) {
      this._clear(), tU(t, this.group);
      var i = t.get("clip", !0) ? UT(t.coordinateSystem, !1, t) : null;
      i ? this.group.setClipPath(i) : this.group.removeClipPath();
    }, e.prototype._incrementalRenderNormal = function(t, i) {
      for (var n = i.getData(), a = n.getLayout("isSimpleBox"), o; (o = t.next()) != null; ) {
        var s = n.getItemLayout(o), l = PR(s);
        LR(l, n, o, a), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l);
      }
    }, e.prototype._incrementalRenderLarge = function(t, i) {
      tU(i, this.group, this._progressiveEls, !0);
    }, e.prototype.remove = function(t) {
      this._clear();
    }, e.prototype._clear = function() {
      this.group.removeAll(), this._data = null;
    }, e.type = "candlestick", e;
  }($t)
), bbe = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), Sbe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "normalCandlestickBox", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new bbe();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.points;
      this.__simpleBox ? (t.moveTo(n[4][0], n[4][1]), t.lineTo(n[6][0], n[6][1])) : (t.moveTo(n[0][0], n[0][1]), t.lineTo(n[1][0], n[1][1]), t.lineTo(n[2][0], n[2][1]), t.lineTo(n[3][0], n[3][1]), t.closePath(), t.moveTo(n[4][0], n[4][1]), t.lineTo(n[5][0], n[5][1]), t.moveTo(n[6][0], n[6][1]), t.lineTo(n[7][0], n[7][1]));
    }, e;
  }(He)
);
function PR(r, e, t) {
  var i = r.ends;
  return new Sbe({
    shape: {
      points: t ? Tbe(i, r) : i
    },
    z2: 100
  });
}
function eU(r, e) {
  for (var t = !0, i = 0; i < e.ends.length; i++)
    if (r.contain(e.ends[i][0], e.ends[i][1])) {
      t = !1;
      break;
    }
  return t;
}
function LR(r, e, t, i) {
  var n = e.getItemModel(t);
  r.useStyle(e.getItemVisual(t, "style")), r.style.strokeNoScale = !0, r.__simpleBox = i, ri(r, n);
}
function Tbe(r, e) {
  return Y(r, function(t) {
    return t = t.slice(), t[1] = e.initBaseline, t;
  });
}
var ybe = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), DR = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i.type = "largeCandlestickBox", i;
    }
    return e.prototype.getDefaultShape = function() {
      return new ybe();
    }, e.prototype.buildPath = function(t, i) {
      for (var n = i.points, a = 0; a < n.length; )
        if (this.__sign === n[a++]) {
          var o = n[a++];
          t.moveTo(o, n[a++]), t.lineTo(o, n[a++]);
        } else
          a += 3;
    }, e;
  }(He)
);
function tU(r, e, t, i) {
  var n = r.getData(), a = n.getLayout("largePoints"), o = new DR({
    shape: {
      points: a
    },
    __sign: 1,
    ignoreCoarsePointer: !0
  });
  e.add(o);
  var s = new DR({
    shape: {
      points: a
    },
    __sign: -1,
    ignoreCoarsePointer: !0
  });
  e.add(s);
  var l = new DR({
    shape: {
      points: a
    },
    __sign: 0,
    ignoreCoarsePointer: !0
  });
  e.add(l), MR(1, o, r), MR(-1, s, r), MR(0, l, r), i && (o.incremental = !0, s.incremental = !0), t && t.push(o, s);
}
function MR(r, e, t, i) {
  var n = t.get(["itemStyle", r > 0 ? "borderColor" : "borderColor0"]) || t.get(["itemStyle", r > 0 ? "color" : "color0"]);
  r === 0 && (n = t.get(["itemStyle", "borderColorDoji"]));
  var a = t.getModel("itemStyle").getItemStyle(mbe);
  e.useStyle(a), e.style.fill = null, e.style.stroke = n;
}
const Rbe = Ebe;
var W4 = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.defaultValueDimensions = [{
        name: "open",
        defaultTooltip: !0
      }, {
        name: "close",
        defaultTooltip: !0
      }, {
        name: "lowest",
        defaultTooltip: !0
      }, {
        name: "highest",
        defaultTooltip: !0
      }], t;
    }
    return e.prototype.getShadowDim = function() {
      return "open";
    }, e.prototype.brushSelector = function(t, i, n) {
      var a = i.getItemLayout(t);
      return a && n.rect(a.brushRect);
    }, e.type = "series.candlestick", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      coordinateSystem: "cartesian2d",
      legendHoverLink: !0,
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      layout: null,
      clip: !0,
      itemStyle: {
        color: "#eb5454",
        color0: "#47b262",
        borderColor: "#eb5454",
        borderColor0: "#47b262",
        borderColorDoji: null,
        // borderColor: '#d24040',
        // borderColor0: '#398f4f',
        borderWidth: 1
      },
      emphasis: {
        scale: !0,
        itemStyle: {
          borderWidth: 2
        }
      },
      barMaxWidth: null,
      barMinWidth: null,
      barWidth: null,
      large: !0,
      largeThreshold: 600,
      progressive: 3e3,
      progressiveThreshold: 1e4,
      progressiveChunkMode: "mod",
      animationEasing: "linear",
      animationDuration: 300
    }, e;
  }(Wt)
);
br(W4, X4, !0);
const Abe = W4;
function _be(r) {
  !r || !X(r.series) || N(r.series, function(e) {
    be(e) && e.type === "k" && (e.type = "candlestick");
  });
}
var Cbe = ["itemStyle", "borderColor"], Ibe = ["itemStyle", "borderColor0"], wbe = ["itemStyle", "borderColorDoji"], Nbe = ["itemStyle", "color"], xbe = ["itemStyle", "color0"], Pbe = {
  seriesType: "candlestick",
  plan: ld(),
  // For legend.
  performRawSeries: !0,
  reset: function(r, e) {
    function t(a, o) {
      return o.get(a > 0 ? Nbe : xbe);
    }
    function i(a, o) {
      return o.get(a === 0 ? wbe : a > 0 ? Cbe : Ibe);
    }
    if (!e.isSeriesFiltered(r)) {
      var n = r.pipelineContext.large;
      return !n && {
        progress: function(a, o) {
          for (var s; (s = a.next()) != null; ) {
            var l = o.getItemModel(s), u = o.getItemLayout(s).sign, c = l.getItemStyle();
            c.fill = t(u, l), c.stroke = i(u, l) || c.fill;
            var h = o.ensureUniqueItemVisual(s, "style");
            B(h, c);
          }
        }
      };
    }
  }
};
const Lbe = Pbe;
var Dbe = {
  seriesType: "candlestick",
  plan: ld(),
  reset: function(r) {
    var e = r.coordinateSystem, t = r.getData(), i = Mbe(r, t), n = 0, a = 1, o = ["x", "y"], s = t.getDimensionIndex(t.mapDimension(o[n])), l = Y(t.mapDimensionsAll(o[a]), t.getDimensionIndex, t), u = l[0], c = l[1], h = l[2], f = l[3];
    if (t.setLayout({
      candleWidth: i,
      // The value is experimented visually.
      isSimpleBox: i <= 1.3
    }), s < 0 || l.length < 4)
      return;
    return {
      progress: r.pipelineContext.large ? p : d
    };
    function d(g, v) {
      for (var O, m = v.getStore(); (O = g.next()) != null; ) {
        var E = m.get(s, O), b = m.get(u, O), S = m.get(c, O), T = m.get(h, O), y = m.get(f, O), R = Math.min(b, S), _ = Math.max(b, S), C = U(R, E), I = U(_, E), w = U(T, E), x = U(y, E), P = [];
        Q(P, I, 0), Q(P, C, 1), P.push(F(x), F(I), F(w), F(C));
        var L = v.getItemModel(O), D = !!L.get(["itemStyle", "borderColorDoji"]);
        v.setItemLayout(O, {
          sign: rU(m, O, b, S, c, D),
          initBaseline: b > S ? I[a] : C[a],
          ends: P,
          brushRect: V(T, y, E)
        });
      }
      function U(j, ae) {
        var ce = [];
        return ce[n] = ae, ce[a] = j, isNaN(ae) || isNaN(j) ? [NaN, NaN] : e.dataToPoint(ce);
      }
      function Q(j, ae, ce) {
        var ge = ae.slice(), Be = ae.slice();
        ge[n] = Jm(ge[n] + i / 2, 1, !1), Be[n] = Jm(Be[n] - i / 2, 1, !0), ce ? j.push(ge, Be) : j.push(Be, ge);
      }
      function V(j, ae, ce) {
        var ge = U(j, ce), Be = U(ae, ce);
        return ge[n] -= i / 2, Be[n] -= i / 2, {
          x: ge[0],
          y: ge[1],
          width: i,
          height: Be[1] - ge[1]
        };
      }
      function F(j) {
        return j[n] = Jm(j[n], 1), j;
      }
    }
    function p(g, v) {
      for (var O = lo(g.count * 4), m = 0, E, b = [], S = [], T, y = v.getStore(), R = !!r.get(["itemStyle", "borderColorDoji"]); (T = g.next()) != null; ) {
        var _ = y.get(s, T), C = y.get(u, T), I = y.get(c, T), w = y.get(h, T), x = y.get(f, T);
        if (isNaN(_) || isNaN(w) || isNaN(x)) {
          O[m++] = NaN, m += 3;
          continue;
        }
        O[m++] = rU(y, T, C, I, c, R), b[n] = _, b[a] = w, E = e.dataToPoint(b, null, S), O[m++] = E ? E[0] : NaN, O[m++] = E ? E[1] : NaN, b[a] = x, E = e.dataToPoint(b, null, S), O[m++] = E ? E[1] : NaN;
      }
      v.setLayout("largePoints", O);
    }
  }
};
function rU(r, e, t, i, n, a) {
  var o;
  return t > i ? o = -1 : t < i ? o = 1 : o = a ? 0 : e > 0 ? r.get(n, e - 1) <= i ? 1 : -1 : (
    // No record of previous, set to be positive
    1
  ), o;
}
function Mbe(r, e) {
  var t = r.getBaseAxis(), i, n = t.type === "category" ? t.getBandWidth() : (i = t.getExtent(), Math.abs(i[1] - i[0]) / e.count()), a = K(ke(r.get("barMaxWidth"), n), n), o = K(ke(r.get("barMinWidth"), 1), n), s = r.get("barWidth");
  return s != null ? K(s, n) : Math.max(Math.min(n / 2, a), o);
}
const kbe = Dbe;
function Qbe(r) {
  r.registerChartView(Rbe), r.registerSeriesModel(Abe), r.registerPreprocessor(_be), r.registerVisual(Lbe), r.registerLayout(kbe);
}
function iU(r, e) {
  var t = e.rippleEffectColor || e.color;
  r.eachChild(function(i) {
    i.attr({
      z: e.z,
      zlevel: e.zlevel,
      style: {
        stroke: e.brushType === "stroke" ? t : null,
        fill: e.brushType === "fill" ? t : null
      }
    });
  });
}
var Ube = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i) {
      var n = r.call(this) || this, a = new Dv(t, i), o = new Re();
      return n.add(a), n.add(o), n.updateData(t, i), n;
    }
    return e.prototype.stopEffectAnimation = function() {
      this.childAt(1).removeAll();
    }, e.prototype.startEffectAnimation = function(t) {
      for (var i = t.symbolType, n = t.color, a = t.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) {
        var l = Er(i, -1, -1, 2, 2, n);
        l.attr({
          style: {
            strokeNoScale: !0
          },
          z2: 99,
          silent: !0,
          scaleX: 0.5,
          scaleY: 0.5
        });
        var u = -s / a * t.period + t.effectOffset;
        l.animate("", !0).when(t.period, {
          scaleX: t.rippleScale / 2,
          scaleY: t.rippleScale / 2
        }).delay(u).start(), l.animateStyle(!0).when(t.period, {
          opacity: 0
        }).delay(u).start(), o.add(l);
      }
      iU(o, t);
    }, e.prototype.updateEffectAnimation = function(t) {
      for (var i = this._effectCfg, n = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) {
        var s = a[o];
        if (i[s] !== t[s]) {
          this.stopEffectAnimation(), this.startEffectAnimation(t);
          return;
        }
      }
      iU(n, t);
    }, e.prototype.highlight = function() {
      ls(this);
    }, e.prototype.downplay = function() {
      us(this);
    }, e.prototype.getSymbolType = function() {
      var t = this.childAt(0);
      return t && t.getSymbolType();
    }, e.prototype.updateData = function(t, i) {
      var n = this, a = t.hostModel;
      this.childAt(0).updateData(t, i);
      var o = this.childAt(1), s = t.getItemModel(i), l = t.getItemVisual(i, "symbol"), u = cd(t.getItemVisual(i, "symbolSize")), c = t.getItemVisual(i, "style"), h = c && c.fill, f = s.getModel("emphasis");
      o.setScale(u), o.traverse(function(v) {
        v.setStyle("fill", h);
      });
      var d = qc(t.getItemVisual(i, "symbolOffset"), u);
      d && (o.x = d[0], o.y = d[1]);
      var p = t.getItemVisual(i, "symbolRotate");
      o.rotation = (p || 0) * Math.PI / 180 || 0;
      var g = {};
      g.showEffectOn = a.get("showEffectOn"), g.rippleScale = s.get(["rippleEffect", "scale"]), g.brushType = s.get(["rippleEffect", "brushType"]), g.period = s.get(["rippleEffect", "period"]) * 1e3, g.effectOffset = i / t.count(), g.z = a.getShallow("z") || 0, g.zlevel = a.getShallow("zlevel") || 0, g.symbolType = l, g.color = h, g.rippleEffectColor = s.get(["rippleEffect", "color"]), g.rippleNumber = s.get(["rippleEffect", "number"]), g.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(g) : this.startEffectAnimation(g), this._effectCfg = g) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function(v) {
        v === "emphasis" ? g.showEffectOn !== "render" && n.startEffectAnimation(g) : v === "normal" && g.showEffectOn !== "render" && n.stopEffectAnimation();
      }), this._effectCfg = g, qt(this, f.get("focus"), f.get("blurScope"), f.get("disabled"));
    }, e.prototype.fadeOut = function(t) {
      t && t();
    }, e;
  }(Re)
);
const $be = Ube;
var Vbe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._symbolDraw = new Mv($be);
    }, e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._symbolDraw;
      o.updateData(a, {
        clipShape: this._getClipShape(t)
      }), this.group.add(o.group);
    }, e.prototype._getClipShape = function(t) {
      var i = t.coordinateSystem, n = i && i.getArea && i.getArea();
      return t.get("clip", !0) ? n : null;
    }, e.prototype.updateTransform = function(t, i, n) {
      var a = t.getData();
      this.group.dirty();
      var o = kv("").reset(t, i, n);
      o.progress && o.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._symbolDraw.updateLayout();
    }, e.prototype._updateGroupTransform = function(t) {
      var i = t.coordinateSystem;
      i && i.getRoamTransform && (this.group.transform = vne(i.getRoamTransform()), this.group.decomposeTransform());
    }, e.prototype.remove = function(t, i) {
      this._symbolDraw && this._symbolDraw.remove(!0);
    }, e.type = "effectScatter", e;
  }($t)
);
const Gbe = Vbe;
var Bbe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return Ss(null, this, {
        useEncodeDefaulter: !0
      });
    }, e.prototype.brushSelector = function(t, i, n) {
      return n.point(i.getItemLayout(t));
    }, e.type = "series.effectScatter", e.dependencies = ["grid", "polar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      effectType: "ripple",
      progressive: 0,
      // When to show the effect, option: 'render'|'emphasis'
      showEffectOn: "render",
      clip: !0,
      // Ripple effect config
      rippleEffect: {
        period: 4,
        // Scale of ripple
        scale: 2.5,
        // Brush type can be fill or stroke
        brushType: "fill",
        // Ripple number
        number: 3
      },
      universalTransition: {
        divideShape: "clone"
      },
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
      // symbol: null,        // 
      symbolSize: 10
      // symbolSize * 2
      // symbolRotate: null,  // 
      // itemStyle: {
      //     opacity: 1
      // }
    }, e;
  }(Wt)
);
const Fbe = Bbe;
function Xbe(r) {
  r.registerChartView(Gbe), r.registerSeriesModel(Fbe), r.registerLayout(kv("effectScatter"));
}
var Ybe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      return a.add(a.createLine(t, i, n)), a._updateEffectSymbol(t, i), a;
    }
    return e.prototype.createLine = function(t, i, n) {
      return new zN(t, i, n);
    }, e.prototype._updateEffectSymbol = function(t, i) {
      var n = t.getItemModel(i), a = n.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol");
      X(o) || (o = [o, o]);
      var l = t.getItemVisual(i, "style"), u = a.get("color") || l && l.stroke, c = this.childAt(1);
      this._symbolType !== s && (this.remove(c), c = Er(s, -0.5, -0.5, 1, 1, u), c.z2 = 100, c.culling = !0, this.add(c)), c && (c.setStyle("shadowColor", u), c.setStyle(a.getItemStyle(["color"])), c.scaleX = o[0], c.scaleY = o[1], c.setColor(u), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(t, a, i));
    }, e.prototype._updateEffectAnimation = function(t, i, n) {
      var a = this.childAt(1);
      if (a) {
        var o = t.getItemLayout(n), s = i.get("period") * 1e3, l = i.get("loop"), u = i.get("roundTrip"), c = i.get("constantSpeed"), h = vr(i.get("delay"), function(d) {
          return d / t.count() * s / 3;
        });
        if (a.ignore = !0, this._updateAnimationPoints(a, o), c > 0 && (s = this._getLineLength(a) / c * 1e3), s !== this._period || l !== this._loop || u !== this._roundTrip) {
          a.stopAnimation();
          var f = void 0;
          ve(h) ? f = h(n) : f = h, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, u);
        }
        this._period = s, this._loop = l, this._roundTrip = u;
      }
    }, e.prototype._animateSymbol = function(t, i, n, a, o) {
      if (i > 0) {
        t.__t = 0;
        var s = this, l = t.animate("", a).when(o ? i * 2 : i, {
          __t: o ? 2 : 1
        }).delay(n).during(function() {
          s._updateSymbolPosition(t);
        });
        a || l.done(function() {
          s.remove(t);
        }), l.start();
      }
    }, e.prototype._getLineLength = function(t) {
      return Ks(t.__p1, t.__cp1) + Ks(t.__cp1, t.__p2);
    }, e.prototype._updateAnimationPoints = function(t, i) {
      t.__p1 = i[0], t.__p2 = i[1], t.__cp1 = i[2] || [(i[0][0] + i[1][0]) / 2, (i[0][1] + i[1][1]) / 2];
    }, e.prototype.updateData = function(t, i, n) {
      this.childAt(0).updateData(t, i, n), this._updateEffectSymbol(t, i);
    }, e.prototype._updateSymbolPosition = function(t) {
      var i = t.__p1, n = t.__p2, a = t.__cp1, o = t.__t < 1 ? t.__t : 2 - t.__t, s = [t.x, t.y], l = s.slice(), u = Vr, c = k_;
      s[0] = u(i[0], a[0], n[0], o), s[1] = u(i[1], a[1], n[1], o);
      var h = t.__t < 1 ? c(i[0], a[0], n[0], o) : c(n[0], a[0], i[0], 1 - o), f = t.__t < 1 ? c(i[1], a[1], n[1], o) : c(n[1], a[1], i[1], 1 - o);
      t.rotation = -Math.atan2(f, h) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = Ks(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * Ks(i, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1];
    }, e.prototype.updateLayout = function(t, i) {
      this.childAt(0).updateLayout(t, i);
      var n = t.getItemModel(i).getModel("effect");
      this._updateEffectAnimation(t, n, i);
    }, e;
  }(Re)
);
const z4 = Ybe;
var Hbe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n) {
      var a = r.call(this) || this;
      return a._createPolyline(t, i, n), a;
    }
    return e.prototype._createPolyline = function(t, i, n) {
      var a = t.getItemLayout(i), o = new nn({
        shape: {
          points: a
        }
      });
      this.add(o), this._updateCommonStl(t, i, n);
    }, e.prototype.updateData = function(t, i, n) {
      var a = t.hostModel, o = this.childAt(0), s = {
        shape: {
          points: t.getItemLayout(i)
        }
      };
      Ot(o, s, a, i), this._updateCommonStl(t, i, n);
    }, e.prototype._updateCommonStl = function(t, i, n) {
      var a = this.childAt(0), o = t.getItemModel(i), s = n && n.emphasisLineStyle, l = n && n.focus, u = n && n.blurScope, c = n && n.emphasisDisabled;
      if (!n || t.hasItemOption) {
        var h = o.getModel("emphasis");
        s = h.getModel("lineStyle").getLineStyle(), c = h.get("disabled"), l = h.get("focus"), u = h.get("blurScope");
      }
      a.useStyle(t.getItemVisual(i, "style")), a.style.fill = null, a.style.strokeNoScale = !0;
      var f = a.ensureState("emphasis");
      f.style = s, qt(this, l, u, c);
    }, e.prototype.updateLayout = function(t, i) {
      var n = this.childAt(0);
      n.setShape("points", t.getItemLayout(i));
    }, e;
  }(Re)
);
const Z4 = Hbe;
var Wbe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t._lastFrame = 0, t._lastFramePercent = 0, t;
    }
    return e.prototype.createLine = function(t, i, n) {
      return new Z4(t, i, n);
    }, e.prototype._updateAnimationPoints = function(t, i) {
      this._points = i;
      for (var n = [0], a = 0, o = 1; o < i.length; o++) {
        var s = i[o - 1], l = i[o];
        a += Ks(s, l), n.push(a);
      }
      if (a === 0) {
        this._length = 0;
        return;
      }
      for (var o = 0; o < n.length; o++)
        n[o] /= a;
      this._offsets = n, this._length = a;
    }, e.prototype._getLineLength = function() {
      return this._length;
    }, e.prototype._updateSymbolPosition = function(t) {
      var i = t.__t < 1 ? t.__t : 2 - t.__t, n = this._points, a = this._offsets, o = n.length;
      if (a) {
        var s = this._lastFrame, l;
        if (i < this._lastFramePercent) {
          var u = Math.min(s + 1, o - 1);
          for (l = u; l >= 0 && !(a[l] <= i); l--)
            ;
          l = Math.min(l, o - 2);
        } else {
          for (l = s; l < o && !(a[l] > i); l++)
            ;
          l = Math.min(l - 1, o - 2);
        }
        var c = (i - a[l]) / (a[l + 1] - a[l]), h = n[l], f = n[l + 1];
        t.x = h[0] * (1 - c) + c * f[0], t.y = h[1] * (1 - c) + c * f[1];
        var d = t.__t < 1 ? f[0] - h[0] : h[0] - f[0], p = t.__t < 1 ? f[1] - h[1] : h[1] - f[1];
        t.rotation = -Math.atan2(p, d) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = i, t.ignore = !1;
      }
    }, e;
  }(z4)
);
const zbe = Wbe;
var Zbe = (
  /** @class */
  function() {
    function r() {
      this.polyline = !1, this.curveness = 0, this.segs = [];
    }
    return r;
  }()
), qbe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t) {
      var i = r.call(this, t) || this;
      return i._off = 0, i.hoverDataIdx = -1, i;
    }
    return e.prototype.reset = function() {
      this.notClear = !1, this._off = 0;
    }, e.prototype.getDefaultStyle = function() {
      return {
        stroke: "#000",
        fill: null
      };
    }, e.prototype.getDefaultShape = function() {
      return new Zbe();
    }, e.prototype.buildPath = function(t, i) {
      var n = i.segs, a = i.curveness, o;
      if (i.polyline)
        for (o = this._off; o < n.length; ) {
          var s = n[o++];
          if (s > 0) {
            t.moveTo(n[o++], n[o++]);
            for (var l = 1; l < s; l++)
              t.lineTo(n[o++], n[o++]);
          }
        }
      else
        for (o = this._off; o < n.length; ) {
          var u = n[o++], c = n[o++], h = n[o++], f = n[o++];
          if (t.moveTo(u, c), a > 0) {
            var d = (u + h) / 2 - (c - f) * a, p = (c + f) / 2 - (h - u) * a;
            t.quadraticCurveTo(d, p, h, f);
          } else
            t.lineTo(h, f);
        }
      this.incremental && (this._off = o, this.notClear = !0);
    }, e.prototype.findDataIndex = function(t, i) {
      var n = this.shape, a = n.segs, o = n.curveness, s = this.style.lineWidth;
      if (n.polyline)
        for (var l = 0, u = 0; u < a.length; ) {
          var c = a[u++];
          if (c > 0)
            for (var h = a[u++], f = a[u++], d = 1; d < c; d++) {
              var p = a[u++], g = a[u++];
              if (Xs(h, f, p, g, s, t, i))
                return l;
            }
          l++;
        }
      else
        for (var l = 0, u = 0; u < a.length; ) {
          var h = a[u++], f = a[u++], p = a[u++], g = a[u++];
          if (o > 0) {
            var v = (h + p) / 2 - (f - g) * o, O = (f + g) / 2 - (p - h) * o;
            if (aH(h, f, v, O, p, g, s, t, i))
              return l;
          } else if (Xs(h, f, p, g, s, t, i))
            return l;
          l++;
        }
      return -1;
    }, e.prototype.contain = function(t, i) {
      var n = this.transformCoordToLocal(t, i), a = this.getBoundingRect();
      if (t = n[0], i = n[1], a.contain(t, i)) {
        var o = this.hoverDataIdx = this.findDataIndex(t, i);
        return o >= 0;
      }
      return this.hoverDataIdx = -1, !1;
    }, e.prototype.getBoundingRect = function() {
      var t = this._rect;
      if (!t) {
        for (var i = this.shape, n = i.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, u = 0; u < n.length; ) {
          var c = n[u++], h = n[u++];
          a = Math.min(c, a), s = Math.max(c, s), o = Math.min(h, o), l = Math.max(h, l);
        }
        t = this._rect = new Ve(a, o, s, l);
      }
      return t;
    }, e;
  }(He)
), jbe = (
  /** @class */
  function() {
    function r() {
      this.group = new Re();
    }
    return r.prototype.updateData = function(e) {
      this._clear();
      var t = this._create();
      t.setShape({
        segs: e.getLayout("linesPoints")
      }), this._setCommon(t, e);
    }, r.prototype.incrementalPrepareUpdate = function(e) {
      this.group.removeAll(), this._clear();
    }, r.prototype.incrementalUpdate = function(e, t) {
      var i = this._newAdded[0], n = t.getLayout("linesPoints"), a = i && i.shape.segs;
      if (a && a.length < 2e4) {
        var o = a.length, s = new Float32Array(o + n.length);
        s.set(a), s.set(n, o), i.setShape({
          segs: s
        });
      } else {
        this._newAdded = [];
        var l = this._create();
        l.incremental = !0, l.setShape({
          segs: n
        }), this._setCommon(l, t), l.__startIndex = e.start;
      }
    }, r.prototype.remove = function() {
      this._clear();
    }, r.prototype.eachRendered = function(e) {
      this._newAdded[0] && e(this._newAdded[0]);
    }, r.prototype._create = function() {
      var e = new qbe({
        cursor: "default",
        ignoreCoarsePointer: !0
      });
      return this._newAdded.push(e), this.group.add(e), e;
    }, r.prototype._setCommon = function(e, t, i) {
      var n = t.hostModel;
      e.setShape({
        polyline: n.get("polyline"),
        curveness: n.get(["lineStyle", "curveness"])
      }), e.useStyle(n.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = !0;
      var a = t.getVisual("style");
      a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null);
      var o = Pe(e);
      o.seriesIndex = n.seriesIndex, e.on("mousemove", function(s) {
        o.dataIndex = null;
        var l = e.hoverDataIdx;
        l > 0 && (o.dataIndex = l + e.__startIndex);
      });
    }, r.prototype._clear = function() {
      this._newAdded = [], this.group.removeAll();
    }, r;
  }()
);
const Kbe = jbe;
var Jbe = {
  seriesType: "lines",
  plan: ld(),
  reset: function(r) {
    var e = r.coordinateSystem;
    if (!e) {
      ({}).NODE_ENV !== "production" && ti("The lines series must have a coordinate system.");
      return;
    }
    var t = r.get("polyline"), i = r.pipelineContext.large;
    return {
      progress: function(n, a) {
        var o = [];
        if (i) {
          var s = void 0, l = n.end - n.start;
          if (t) {
            for (var u = 0, c = n.start; c < n.end; c++)
              u += r.getLineCoordsCount(c);
            s = new Float32Array(l + u * 2);
          } else
            s = new Float32Array(l * 4);
          for (var h = 0, f = [], c = n.start; c < n.end; c++) {
            var d = r.getLineCoords(c, o);
            t && (s[h++] = d);
            for (var p = 0; p < d; p++)
              f = e.dataToPoint(o[p], !1, f), s[h++] = f[0], s[h++] = f[1];
          }
          a.setLayout("linesPoints", s);
        } else
          for (var c = n.start; c < n.end; c++) {
            var g = a.getItemModel(c), d = r.getLineCoords(c, o), v = [];
            if (t)
              for (var O = 0; O < d; O++)
                v.push(e.dataToPoint(o[O]));
            else {
              v[0] = e.dataToPoint(o[0]), v[1] = e.dataToPoint(o[1]);
              var m = g.get(["lineStyle", "curveness"]);
              +m && (v[2] = [(v[0][0] + v[1][0]) / 2 - (v[0][1] - v[1][1]) * m, (v[0][1] + v[1][1]) / 2 - (v[1][0] - v[0][0]) * m]);
            }
            a.setItemLayout(c, v);
          }
      }
    };
  }
};
const q4 = Jbe;
var eSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this._updateLineDraw(a, t), s = t.get("zlevel"), l = t.get(["effect", "trailLength"]), u = n.getZr(), c = u.painter.getType() === "svg";
      c || u.painter.getLayer(s).clear(!0), this._lastZlevel != null && !c && u.configLayer(this._lastZlevel, {
        motionBlur: !1
      }), this._showEffect(t) && l > 0 && (c ? {}.NODE_ENV !== "production" && console.warn("SVG render mode doesn't support lines with trail effect") : u.configLayer(s, {
        motionBlur: !0,
        lastFrameAlpha: Math.max(Math.min(l / 10 + 0.9, 1), 0)
      })), o.updateData(a);
      var h = t.get("clip", !0) && UT(t.coordinateSystem, !1, t);
      h ? this.group.setClipPath(h) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      var a = t.getData(), o = this._updateLineDraw(a, t);
      o.incrementalPrepareUpdate(a), this._clearLayer(n), this._finished = !1;
    }, e.prototype.incrementalRender = function(t, i, n) {
      this._lineDraw.incrementalUpdate(t, i.getData()), this._finished = t.end === i.getData().count();
    }, e.prototype.eachRendered = function(t) {
      this._lineDraw && this._lineDraw.eachRendered(t);
    }, e.prototype.updateTransform = function(t, i, n) {
      var a = t.getData(), o = t.pipelineContext;
      if (!this._finished || o.large || o.progressiveRender)
        return {
          update: !0
        };
      var s = q4.reset(t, i, n);
      s.progress && s.progress({
        start: 0,
        end: a.count(),
        count: a.count()
      }, a), this._lineDraw.updateLayout(), this._clearLayer(n);
    }, e.prototype._updateLineDraw = function(t, i) {
      var n = this._lineDraw, a = this._showEffect(i), o = !!i.get("polyline"), s = i.pipelineContext, l = s.large;
      return {}.NODE_ENV !== "production" && a && l && console.warn("Large lines not support effect"), (!n || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (n && n.remove(), n = this._lineDraw = l ? new Kbe() : new ZN(o ? a ? zbe : Z4 : a ? z4 : zN), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(n.group), n;
    }, e.prototype._showEffect = function(t) {
      return !!t.get(["effect", "show"]);
    }, e.prototype._clearLayer = function(t) {
      var i = t.getZr(), n = i.painter.getType() === "svg";
      !n && this._lastZlevel != null && i.painter.getLayer(this._lastZlevel).clear(!0);
    }, e.prototype.remove = function(t, i) {
      this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(i);
    }, e.prototype.dispose = function(t, i) {
      this.remove(t, i);
    }, e.type = "lines", e;
  }($t)
);
const tSe = eSe;
var rSe = typeof Uint32Array > "u" ? Array : Uint32Array, iSe = typeof Float64Array > "u" ? Array : Float64Array;
function nU(r) {
  var e = r.data;
  e && e[0] && e[0][0] && e[0][0].coord && ({}.NODE_ENV !== "production" && console.warn("Lines data configuration has been changed to { coords:[[1,2],[2,3]] }"), r.data = Y(e, function(t) {
    var i = [t[0].coord, t[1].coord], n = {
      coords: i
    };
    return t[0].name && (n.fromName = t[0].name), t[1].name && (n.toName = t[1].name), _1([n, t[0], t[1]]);
  }));
}
var nSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t;
    }
    return e.prototype.init = function(t) {
      t.data = t.data || [], nU(t);
      var i = this._processFlatCoordsArray(t.data);
      this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (t.data = new Float32Array(i.count)), r.prototype.init.apply(this, arguments);
    }, e.prototype.mergeOption = function(t) {
      if (nU(t), t.data) {
        var i = this._processFlatCoordsArray(t.data);
        this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset, i.flatCoords && (t.data = new Float32Array(i.count));
      }
      r.prototype.mergeOption.apply(this, arguments);
    }, e.prototype.appendData = function(t) {
      var i = this._processFlatCoordsArray(t.data);
      i.flatCoords && (this._flatCoords ? (this._flatCoords = qE(this._flatCoords, i.flatCoords), this._flatCoordsOffset = qE(this._flatCoordsOffset, i.flatCoordsOffset)) : (this._flatCoords = i.flatCoords, this._flatCoordsOffset = i.flatCoordsOffset), t.data = new Float32Array(i.count)), this.getRawData().appendData(t.data);
    }, e.prototype._getCoordsFromItemModel = function(t) {
      var i = this.getData().getItemModel(t), n = i.option instanceof Array ? i.option : i.getShallow("coords");
      if ({}.NODE_ENV !== "production" && !(n instanceof Array && n.length > 0 && n[0] instanceof Array))
        throw new Error("Invalid coords " + JSON.stringify(n) + ". Lines must have 2d coords array in data item.");
      return n;
    }, e.prototype.getLineCoordsCount = function(t) {
      return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length;
    }, e.prototype.getLineCoords = function(t, i) {
      if (this._flatCoordsOffset) {
        for (var n = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], o = 0; o < a; o++)
          i[o] = i[o] || [], i[o][0] = this._flatCoords[n + o * 2], i[o][1] = this._flatCoords[n + o * 2 + 1];
        return a;
      } else {
        for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++)
          i[o] = i[o] || [], i[o][0] = s[o][0], i[o][1] = s[o][1];
        return s.length;
      }
    }, e.prototype._processFlatCoordsArray = function(t) {
      var i = 0;
      if (this._flatCoords && (i = this._flatCoords.length), pt(t[0])) {
        for (var n = t.length, a = new rSe(n), o = new iSe(n), s = 0, l = 0, u = 0, c = 0; c < n; ) {
          u++;
          var h = t[c++];
          a[l++] = s + i, a[l++] = h;
          for (var f = 0; f < h; f++) {
            var d = t[c++], p = t[c++];
            if (o[s++] = d, o[s++] = p, c > n && {}.NODE_ENV !== "production")
              throw new Error("Invalid data format.");
          }
        }
        return {
          flatCoordsOffset: new Uint32Array(a.buffer, 0, l),
          flatCoords: o,
          count: u
        };
      }
      return {
        flatCoordsOffset: null,
        flatCoords: null,
        count: t.length
      };
    }, e.prototype.getInitialData = function(t, i) {
      if ({}.NODE_ENV !== "production") {
        var n = sd.get(t.coordinateSystem);
        if (!n)
          throw new Error("Unknown coordinate system " + t.coordinateSystem);
      }
      var a = new ki(["value"], this);
      return a.hasItemOption = !1, a.initData(t.data, [], function(o, s, l, u) {
        if (o instanceof Array)
          return NaN;
        a.hasItemOption = !0;
        var c = o.value;
        if (c != null)
          return c instanceof Array ? c[u] : c;
      }), a;
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = a.getItemModel(t), s = o.get("name");
      if (s)
        return s;
      var l = o.get("fromName"), u = o.get("toName"), c = [];
      return l != null && c.push(l), u != null && c.push(u), Qr("nameValue", {
        name: c.join(" > ")
      });
    }, e.prototype.preventIncremental = function() {
      return !!this.get(["effect", "show"]);
    }, e.prototype.getProgressive = function() {
      var t = this.option.progressive;
      return t ?? (this.option.large ? 1e4 : this.get("progressive"));
    }, e.prototype.getProgressiveThreshold = function() {
      var t = this.option.progressiveThreshold;
      return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold"));
    }, e.prototype.getZLevelKey = function() {
      var t = this.getModel("effect"), i = t.get("trailLength");
      return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && i > 0 ? i + "" : "";
    }, e.type = "series.lines", e.dependencies = ["grid", "polar", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "geo",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Cartesian coordinate system
      xAxisIndex: 0,
      yAxisIndex: 0,
      symbol: ["none", "none"],
      symbolSize: [10, 10],
      // Geo coordinate system
      geoIndex: 0,
      effect: {
        show: !1,
        period: 4,
        constantSpeed: 0,
        symbol: "circle",
        symbolSize: 3,
        loop: !0,
        trailLength: 0.2
      },
      large: !1,
      // Available when large is true
      largeThreshold: 2e3,
      polyline: !1,
      clip: !0,
      label: {
        show: !1,
        position: "end"
        // distance: 5,
        // formatter: Tooltip.formatter
      },
      lineStyle: {
        opacity: 0.5
      }
    }, e;
  }(Wt)
);
const aSe = nSe;
function om(r) {
  return r instanceof Array || (r = [r, r]), r;
}
var oSe = {
  seriesType: "lines",
  reset: function(r) {
    var e = om(r.get("symbol")), t = om(r.get("symbolSize")), i = r.getData();
    i.setVisual("fromSymbol", e && e[0]), i.setVisual("toSymbol", e && e[1]), i.setVisual("fromSymbolSize", t && t[0]), i.setVisual("toSymbolSize", t && t[1]);
    function n(a, o) {
      var s = a.getItemModel(o), l = om(s.getShallow("symbol", !0)), u = om(s.getShallow("symbolSize", !0));
      l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), u[0] && a.setItemVisual(o, "fromSymbolSize", u[0]), u[1] && a.setItemVisual(o, "toSymbolSize", u[1]);
    }
    return {
      dataEach: i.hasItemOption ? n : null
    };
  }
};
const sSe = oSe;
function lSe(r) {
  r.registerChartView(tSe), r.registerSeriesModel(aSe), r.registerLayout(q4), r.registerVisual(sSe);
}
var uSe = 256, cSe = (
  /** @class */
  function() {
    function r() {
      this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = {
        inRange: null,
        outOfRange: null
      };
      var e = Il.createCanvas();
      this.canvas = e;
    }
    return r.prototype.update = function(e, t, i, n, a, o) {
      var s = this._getBrush(), l = this._getGradient(a, "inRange"), u = this._getGradient(a, "outOfRange"), c = this.pointSize + this.blurSize, h = this.canvas, f = h.getContext("2d"), d = e.length;
      h.width = t, h.height = i;
      for (var p = 0; p < d; ++p) {
        var g = e[p], v = g[0], O = g[1], m = g[2], E = n(m);
        f.globalAlpha = E, f.drawImage(s, v - c, O - c);
      }
      if (!h.width || !h.height)
        return h;
      for (var b = f.getImageData(0, 0, h.width, h.height), S = b.data, T = 0, y = S.length, R = this.minOpacity, _ = this.maxOpacity, C = _ - R; T < y; ) {
        var E = S[T + 3] / 256, I = Math.floor(E * (uSe - 1)) * 4;
        if (E > 0) {
          var w = o(E) ? l : u;
          E > 0 && (E = E * C + R), S[T++] = w[I], S[T++] = w[I + 1], S[T++] = w[I + 2], S[T++] = w[I + 3] * E * 256;
        } else
          T += 4;
      }
      return f.putImageData(b, 0, 0), h;
    }, r.prototype._getBrush = function() {
      var e = this._brushCanvas || (this._brushCanvas = Il.createCanvas()), t = this.pointSize + this.blurSize, i = t * 2;
      e.width = i, e.height = i;
      var n = e.getContext("2d");
      return n.clearRect(0, 0, i, i), n.shadowOffsetX = i, n.shadowBlur = this.blurSize, n.shadowColor = "#000", n.beginPath(), n.arc(-t, t, this.pointSize, 0, Math.PI * 2, !0), n.closePath(), n.fill(), e;
    }, r.prototype._getGradient = function(e, t) {
      for (var i = this._gradientPixels, n = i[t] || (i[t] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++)
        e[t](s / 255, !0, a), n[o++] = a[0], n[o++] = a[1], n[o++] = a[2], n[o++] = a[3];
      return n;
    }, r;
  }()
);
const hSe = cSe;
function fSe(r, e, t) {
  var i = r[1] - r[0];
  e = Y(e, function(o) {
    return {
      interval: [(o.interval[0] - r[0]) / i, (o.interval[1] - r[0]) / i]
    };
  });
  var n = e.length, a = 0;
  return function(o) {
    var s;
    for (s = a; s < n; s++) {
      var l = e[s].interval;
      if (l[0] <= o && o <= l[1]) {
        a = s;
        break;
      }
    }
    if (s === n)
      for (s = a - 1; s >= 0; s--) {
        var l = e[s].interval;
        if (l[0] <= o && o <= l[1]) {
          a = s;
          break;
        }
      }
    return s >= 0 && s < n && t[s];
  };
}
function dSe(r, e) {
  var t = r[1] - r[0];
  return e = [(e[0] - r[0]) / t, (e[1] - r[0]) / t], function(i) {
    return i >= e[0] && i <= e[1];
  };
}
function aU(r) {
  var e = r.dimensions;
  return e[0] === "lng" && e[1] === "lat";
}
var pSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a;
      if (i.eachComponent("visualMap", function(s) {
        s.eachTargetSeries(function(l) {
          l === t && (a = s);
        });
      }), {}.NODE_ENV !== "production" && !a)
        throw new Error("Heatmap must use with visualMap");
      this._progressiveEls = null, this.group.removeAll();
      var o = t.coordinateSystem;
      o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, n, 0, t.getData().count()) : aU(o) && this._renderOnGeo(o, t, a, n);
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this.group.removeAll();
    }, e.prototype.incrementalRender = function(t, i, n, a) {
      var o = i.coordinateSystem;
      o && (aU(o) ? this.render(i, n, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(i, a, t.start, t.end, !0)));
    }, e.prototype.eachRendered = function(t) {
      zl(this._progressiveEls || this.group, t);
    }, e.prototype._renderOnCartesianAndCalendar = function(t, i, n, a, o) {
      var s = t.coordinateSystem, l = Kc(s, "cartesian2d"), u, c, h, f;
      if (l) {
        var d = s.getAxis("x"), p = s.getAxis("y");
        if ({}.NODE_ENV !== "production") {
          if (!(d.type === "category" && p.type === "category"))
            throw new Error("Heatmap on cartesian must have two category axes");
          if (!(d.onBand && p.onBand))
            throw new Error("Heatmap on cartesian must have two axes with boundaryGap true");
        }
        u = d.getBandWidth() + 0.5, c = p.getBandWidth() + 0.5, h = d.scale.getExtent(), f = p.scale.getExtent();
      }
      for (var g = this.group, v = t.getData(), O = t.getModel(["emphasis", "itemStyle"]).getItemStyle(), m = t.getModel(["blur", "itemStyle"]).getItemStyle(), E = t.getModel(["select", "itemStyle"]).getItemStyle(), b = t.get(["itemStyle", "borderRadius"]), S = kr(t), T = t.getModel("emphasis"), y = T.get("focus"), R = T.get("blurScope"), _ = T.get("disabled"), C = l ? [v.mapDimension("x"), v.mapDimension("y"), v.mapDimension("value")] : [v.mapDimension("time"), v.mapDimension("value")], I = n; I < a; I++) {
        var w = void 0, x = v.getItemVisual(I, "style");
        if (l) {
          var P = v.get(C[0], I), L = v.get(C[1], I);
          if (isNaN(v.get(C[2], I)) || isNaN(P) || isNaN(L) || P < h[0] || P > h[1] || L < f[0] || L > f[1])
            continue;
          var D = s.dataToPoint([P, L]);
          w = new ht({
            shape: {
              x: D[0] - u / 2,
              y: D[1] - c / 2,
              width: u,
              height: c
            },
            style: x
          });
        } else {
          if (isNaN(v.get(C[1], I)))
            continue;
          w = new ht({
            z2: 1,
            shape: s.dataToRect([v.get(C[0], I)]).contentShape,
            style: x
          });
        }
        if (v.hasItemOption) {
          var U = v.getItemModel(I), Q = U.getModel("emphasis");
          O = Q.getModel("itemStyle").getItemStyle(), m = U.getModel(["blur", "itemStyle"]).getItemStyle(), E = U.getModel(["select", "itemStyle"]).getItemStyle(), b = U.get(["itemStyle", "borderRadius"]), y = Q.get("focus"), R = Q.get("blurScope"), _ = Q.get("disabled"), S = kr(U);
        }
        w.shape.r = b;
        var V = t.getRawValue(I), F = "-";
        V && V[2] != null && (F = V[2] + ""), ii(w, S, {
          labelFetcher: t,
          labelDataIndex: I,
          defaultOpacity: x.opacity,
          defaultText: F
        }), w.ensureState("emphasis").style = O, w.ensureState("blur").style = m, w.ensureState("select").style = E, qt(w, y, R, _), w.incremental = o, o && (w.states.emphasis.hoverLayer = !0), g.add(w), v.setItemGraphicEl(I, w), this._progressiveEls && this._progressiveEls.push(w);
      }
    }, e.prototype._renderOnGeo = function(t, i, n, a) {
      var o = n.targetVisuals.inRange, s = n.targetVisuals.outOfRange, l = i.getData(), u = this._hmLayer || this._hmLayer || new hSe();
      u.blurSize = i.get("blurSize"), u.pointSize = i.get("pointSize"), u.minOpacity = i.get("minOpacity"), u.maxOpacity = i.get("maxOpacity");
      var c = t.getViewRect().clone(), h = t.getRoamTransform();
      c.applyTransform(h);
      var f = Math.max(c.x, 0), d = Math.max(c.y, 0), p = Math.min(c.width + c.x, a.getWidth()), g = Math.min(c.height + c.y, a.getHeight()), v = p - f, O = g - d, m = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], E = l.mapArray(m, function(y, R, _) {
        var C = t.dataToPoint([y, R]);
        return C[0] -= f, C[1] -= d, C.push(_), C;
      }), b = n.getExtent(), S = n.type === "visualMap.continuous" ? dSe(b, n.option.range) : fSe(b, n.getPieceList(), n.option.selected);
      u.update(E, v, O, o.color.getNormalizer(), {
        inRange: o.color.getColorMapper(),
        outOfRange: s.color.getColorMapper()
      }, S);
      var T = new ni({
        style: {
          width: v,
          height: O,
          x: f,
          y: d,
          image: u.canvas
        },
        silent: !0
      });
      this.group.add(T);
    }, e.type = "heatmap", e;
  }($t)
);
const gSe = pSe;
var vSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      return Ss(null, this, {
        generateCoord: "value"
      });
    }, e.prototype.preventIncremental = function() {
      var t = sd.get(this.get("coordinateSystem"));
      if (t && t.dimensions)
        return t.dimensions[0] === "lng" && t.dimensions[1] === "lat";
    }, e.type = "series.heatmap", e.dependencies = ["grid", "geo", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Geo coordinate system
      geoIndex: 0,
      blurSize: 30,
      pointSize: 20,
      maxOpacity: 1,
      minOpacity: 0,
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }, e;
  }(Wt)
);
const OSe = vSe;
function mSe(r) {
  r.registerChartView(gSe), r.registerSeriesModel(OSe);
}
var ESe = ["itemStyle", "borderWidth"], oU = [{
  xy: "x",
  wh: "width",
  index: 0,
  posDesc: ["left", "right"]
}, {
  xy: "y",
  wh: "height",
  index: 1,
  posDesc: ["top", "bottom"]
}], kR = new Co(), bSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this.group, o = t.getData(), s = this._data, l = t.coordinateSystem, u = l.getBaseAxis(), c = u.isHorizontal(), h = l.master.getRect(), f = {
        ecSize: {
          width: n.getWidth(),
          height: n.getHeight()
        },
        seriesModel: t,
        coordSys: l,
        coordSysExtent: [[h.x, h.x + h.width], [h.y, h.y + h.height]],
        isHorizontal: c,
        valueDim: oU[+c],
        categoryDim: oU[1 - +c]
      };
      return o.diff(s).add(function(d) {
        if (o.hasValue(d)) {
          var p = lU(o, d), g = sU(o, d, p, f), v = uU(o, f, g);
          o.setItemGraphicEl(d, v), a.add(v), hU(v, f, g);
        }
      }).update(function(d, p) {
        var g = s.getItemGraphicEl(p);
        if (!o.hasValue(d)) {
          a.remove(g);
          return;
        }
        var v = lU(o, d), O = sU(o, d, v, f), m = rZ(o, O);
        g && m !== g.__pictorialShapeStr && (a.remove(g), o.setItemGraphicEl(d, null), g = null), g ? CSe(g, f, O) : g = uU(o, f, O, !0), o.setItemGraphicEl(d, g), g.__pictorialSymbolMeta = O, a.add(g), hU(g, f, O);
      }).remove(function(d) {
        var p = s.getItemGraphicEl(d);
        p && cU(s, d, p.__pictorialSymbolMeta.animationModel, p);
      }).execute(), this._data = o, this.group;
    }, e.prototype.remove = function(t, i) {
      var n = this.group, a = this._data;
      t.get("animation") ? a && a.eachItemGraphicEl(function(o) {
        cU(a, Pe(o).dataIndex, t, o);
      }) : n.removeAll();
    }, e.type = "pictorialBar", e;
  }($t)
);
function sU(r, e, t, i) {
  var n = r.getItemLayout(e), a = t.get("symbolRepeat"), o = t.get("symbolClip"), s = t.get("symbolPosition") || "start", l = t.get("symbolRotate"), u = (l || 0) * Math.PI / 180 || 0, c = t.get("symbolPatternSize") || 2, h = t.isAnimationEnabled(), f = {
    dataIndex: e,
    layout: n,
    itemModel: t,
    symbolType: r.getItemVisual(e, "symbol") || "circle",
    style: r.getItemVisual(e, "style"),
    symbolClip: o,
    symbolRepeat: a,
    symbolRepeatDirection: t.get("symbolRepeatDirection"),
    symbolPatternSize: c,
    rotation: u,
    animationModel: h ? t : null,
    hoverScale: h && t.get(["emphasis", "scale"]),
    z2: t.getShallow("z", !0) || 0
  };
  SSe(t, a, n, i, f), TSe(r, e, n, a, o, f.boundingLength, f.pxSign, c, i, f), ySe(t, f.symbolScale, u, i, f);
  var d = f.symbolSize, p = qc(t.get("symbolOffset"), d);
  return RSe(t, d, n, a, o, p, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, i, f), f;
}
function SSe(r, e, t, i, n) {
  var a = i.valueDim, o = r.get("symbolBoundingData"), s = i.coordSys.getOtherAxis(i.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), u = 1 - +(t[a.wh] <= 0), c;
  if (X(o)) {
    var h = [QR(s, o[0]) - l, QR(s, o[1]) - l];
    h[1] < h[0] && h.reverse(), c = h[u];
  } else
    o != null ? c = QR(s, o) - l : e ? c = i.coordSysExtent[a.index][u] - l : c = t[a.wh];
  n.boundingLength = c, e && (n.repeatCutLength = t[a.wh]), n.pxSign = c > 0 ? 1 : -1;
}
function QR(r, e) {
  return r.toGlobalCoord(r.dataToCoord(r.scale.parse(e)));
}
function TSe(r, e, t, i, n, a, o, s, l, u) {
  var c = l.valueDim, h = l.categoryDim, f = Math.abs(t[h.wh]), d = r.getItemVisual(e, "symbolSize"), p;
  X(d) ? p = d.slice() : d == null ? p = ["100%", "100%"] : p = [d, d], p[h.index] = K(p[h.index], f), p[c.index] = K(p[c.index], i ? f : Math.abs(a)), u.symbolSize = p;
  var g = u.symbolScale = [p[0] / s, p[1] / s];
  g[c.index] *= (l.isHorizontal ? -1 : 1) * o;
}
function ySe(r, e, t, i, n) {
  var a = r.get(ESe) || 0;
  a && (kR.attr({
    scaleX: e[0],
    scaleY: e[1],
    rotation: t
  }), kR.updateTransform(), a /= kR.getLineScale(), a *= e[i.valueDim.index]), n.valueLineWidth = a || 0;
}
function RSe(r, e, t, i, n, a, o, s, l, u, c, h) {
  var f = c.categoryDim, d = c.valueDim, p = h.pxSign, g = Math.max(e[d.index] + s, 0), v = g;
  if (i) {
    var O = Math.abs(l), m = vr(r.get("symbolMargin"), "15%") + "", E = !1;
    m.lastIndexOf("!") === m.length - 1 && (E = !0, m = m.slice(0, m.length - 1));
    var b = K(m, e[d.index]), S = Math.max(g + b * 2, 0), T = E ? 0 : b * 2, y = k1(i), R = y ? i : fU((O + T) / S), _ = O - R * g;
    b = _ / 2 / (E ? R : Math.max(R - 1, 1)), S = g + b * 2, T = E ? 0 : b * 2, !y && i !== "fixed" && (R = u ? fU((Math.abs(u) + T) / S) : 0), v = R * S - T, h.repeatTimes = R, h.symbolMargin = b;
  }
  var C = p * (v / 2), I = h.pathPosition = [];
  I[f.index] = t[f.wh] / 2, I[d.index] = o === "start" ? C : o === "end" ? l - C : l / 2, a && (I[0] += a[0], I[1] += a[1]);
  var w = h.bundlePosition = [];
  w[f.index] = t[f.xy], w[d.index] = t[d.xy];
  var x = h.barRectShape = B({}, t);
  x[d.wh] = p * Math.max(Math.abs(t[d.wh]), Math.abs(I[d.index] + C)), x[f.wh] = t[f.wh];
  var P = h.clipShape = {};
  P[f.xy] = -t[f.xy], P[f.wh] = c.ecSize[f.wh], P[d.xy] = 0, P[d.wh] = t[d.wh];
}
function j4(r) {
  var e = r.symbolPatternSize, t = Er(
    // Consider texture img, make a big size.
    r.symbolType,
    -e / 2,
    -e / 2,
    e,
    e
  );
  return t.attr({
    culling: !0
  }), t.type !== "image" && t.setStyle({
    strokeNoScale: !0
  }), t;
}
function K4(r, e, t, i) {
  var n = r.__pictorialBundle, a = t.symbolSize, o = t.valueLineWidth, s = t.pathPosition, l = e.valueDim, u = t.repeatTimes || 0, c = 0, h = a[e.valueDim.index] + o + t.symbolMargin * 2;
  for (ix(r, function(g) {
    g.__pictorialAnimationIndex = c, g.__pictorialRepeatTimes = u, c < u ? cf(g, null, p(c), t, i) : cf(g, null, {
      scaleX: 0,
      scaleY: 0
    }, t, i, function() {
      n.remove(g);
    }), c++;
  }); c < u; c++) {
    var f = j4(t);
    f.__pictorialAnimationIndex = c, f.__pictorialRepeatTimes = u, n.add(f);
    var d = p(c);
    cf(f, {
      x: d.x,
      y: d.y,
      scaleX: 0,
      scaleY: 0
    }, {
      scaleX: d.scaleX,
      scaleY: d.scaleY,
      rotation: d.rotation
    }, t, i);
  }
  function p(g) {
    var v = s.slice(), O = t.pxSign, m = g;
    return (t.symbolRepeatDirection === "start" ? O > 0 : O < 0) && (m = u - 1 - g), v[l.index] = h * (m - u / 2 + 0.5) + s[l.index], {
      x: v[0],
      y: v[1],
      scaleX: t.symbolScale[0],
      scaleY: t.symbolScale[1],
      rotation: t.rotation
    };
  }
}
function J4(r, e, t, i) {
  var n = r.__pictorialBundle, a = r.__pictorialMainPath;
  a ? cf(a, null, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1],
    rotation: t.rotation
  }, t, i) : (a = r.__pictorialMainPath = j4(t), n.add(a), cf(a, {
    x: t.pathPosition[0],
    y: t.pathPosition[1],
    scaleX: 0,
    scaleY: 0,
    rotation: t.rotation
  }, {
    scaleX: t.symbolScale[0],
    scaleY: t.symbolScale[1]
  }, t, i));
}
function eZ(r, e, t) {
  var i = B({}, e.barRectShape), n = r.__pictorialBarRect;
  n ? cf(n, null, {
    shape: i
  }, e, t) : (n = r.__pictorialBarRect = new ht({
    z2: 2,
    shape: i,
    silent: !0,
    style: {
      stroke: "transparent",
      fill: "transparent",
      lineWidth: 0
    }
  }), n.disableMorphing = !0, r.add(n));
}
function tZ(r, e, t, i) {
  if (t.symbolClip) {
    var n = r.__pictorialClipPath, a = B({}, t.clipShape), o = e.valueDim, s = t.animationModel, l = t.dataIndex;
    if (n)
      Ot(n, {
        shape: a
      }, s, l);
    else {
      a[o.wh] = 0, n = new ht({
        shape: a
      }), r.__pictorialBundle.setClipPath(n), r.__pictorialClipPath = n;
      var u = {};
      u[o.wh] = t.clipShape[o.wh], wv[i ? "updateProps" : "initProps"](n, {
        shape: u
      }, s, l);
    }
  }
}
function lU(r, e) {
  var t = r.getItemModel(e);
  return t.getAnimationDelayParams = ASe, t.isAnimationEnabled = _Se, t;
}
function ASe(r) {
  return {
    index: r.__pictorialAnimationIndex,
    count: r.__pictorialRepeatTimes
  };
}
function _Se() {
  return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation");
}
function uU(r, e, t, i) {
  var n = new Re(), a = new Re();
  return n.add(a), n.__pictorialBundle = a, a.x = t.bundlePosition[0], a.y = t.bundlePosition[1], t.symbolRepeat ? K4(n, e, t) : J4(n, e, t), eZ(n, t, i), tZ(n, e, t, i), n.__pictorialShapeStr = rZ(r, t), n.__pictorialSymbolMeta = t, n;
}
function CSe(r, e, t) {
  var i = t.animationModel, n = t.dataIndex, a = r.__pictorialBundle;
  Ot(a, {
    x: t.bundlePosition[0],
    y: t.bundlePosition[1]
  }, i, n), t.symbolRepeat ? K4(r, e, t, !0) : J4(r, e, t, !0), eZ(r, t, !0), tZ(r, e, t, !0);
}
function cU(r, e, t, i) {
  var n = i.__pictorialBarRect;
  n && n.removeTextContent();
  var a = [];
  ix(i, function(o) {
    a.push(o);
  }), i.__pictorialMainPath && a.push(i.__pictorialMainPath), i.__pictorialClipPath && (t = null), N(a, function(o) {
    xl(o, {
      scaleX: 0,
      scaleY: 0
    }, t, e, function() {
      i.parent && i.parent.remove(i);
    });
  }), r.setItemGraphicEl(e, null);
}
function rZ(r, e) {
  return [r.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":");
}
function ix(r, e, t) {
  N(r.__pictorialBundle.children(), function(i) {
    i !== r.__pictorialBarRect && e.call(t, i);
  });
}
function cf(r, e, t, i, n, a) {
  e && r.attr(e), i.symbolClip && !n ? t && r.attr(t) : t && wv[n ? "updateProps" : "initProps"](r, t, i.animationModel, i.dataIndex, a);
}
function hU(r, e, t) {
  var i = t.dataIndex, n = t.itemModel, a = n.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = n.getModel(["blur", "itemStyle"]).getItemStyle(), l = n.getModel(["select", "itemStyle"]).getItemStyle(), u = n.getShallow("cursor"), c = a.get("focus"), h = a.get("blurScope"), f = a.get("scale");
  ix(r, function(g) {
    if (g instanceof ni) {
      var v = g.style;
      g.useStyle(B({
        // TODO other properties like dx, dy ?
        image: v.image,
        x: v.x,
        y: v.y,
        width: v.width,
        height: v.height
      }, t.style));
    } else
      g.useStyle(t.style);
    var O = g.ensureState("emphasis");
    O.style = o, f && (O.scaleX = g.scaleX * 1.1, O.scaleY = g.scaleY * 1.1), g.ensureState("blur").style = s, g.ensureState("select").style = l, u && (g.cursor = u), g.z2 = t.z2;
  });
  var d = e.valueDim.posDesc[+(t.boundingLength > 0)], p = r.__pictorialBarRect;
  ii(p, kr(n), {
    labelFetcher: e.seriesModel,
    labelDataIndex: i,
    defaultText: Lf(e.seriesModel.getData(), i),
    inheritColor: t.style.fill,
    defaultOpacity: t.style.opacity,
    defaultOutsidePosition: d
  }), qt(r, c, h, a.get("disabled"));
}
function fU(r) {
  var e = Math.round(r);
  return Math.abs(r - e) < 1e-4 ? e : Math.ceil(r);
}
const ISe = bSe;
var wSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.hasSymbolVisual = !0, t.defaultSymbol = "roundRect", t;
    }
    return e.prototype.getInitialData = function(t) {
      return t.stack = null, r.prototype.getInitialData.apply(this, arguments);
    }, e.type = "series.pictorialBar", e.dependencies = ["grid"], e.defaultOption = Zl(Ib.defaultOption, {
      symbol: "circle",
      symbolSize: null,
      symbolRotate: null,
      symbolPosition: null,
      symbolOffset: null,
      symbolMargin: null,
      symbolRepeat: !1,
      symbolRepeatDirection: "end",
      symbolClip: !1,
      symbolBoundingData: null,
      symbolPatternSize: 400,
      barGap: "-100%",
      // z can be set in data item, which is z2 actually.
      // Disable progressive
      progressive: 0,
      emphasis: {
        // By default pictorialBar do not hover scale. Hover scale is not suitable
        // for the case that both has foreground and background.
        scale: !1
      },
      select: {
        itemStyle: {
          borderColor: "#212121"
        }
      }
    }), e;
  }(Ib)
);
const NSe = wSe;
function xSe(r) {
  r.registerChartView(ISe), r.registerSeriesModel(NSe), r.registerLayout(r.PRIORITY.VISUAL.LAYOUT, Le(Qz, "pictorialBar")), r.registerLayout(r.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, Uz("pictorialBar"));
}
var PSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._layers = [], t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = t.getData(), o = this, s = this.group, l = t.getLayerSeries(), u = a.getLayout("layoutInfo"), c = u.rect, h = u.boundaryGap;
      s.x = 0, s.y = c.y + h[0];
      function f(v) {
        return v.name;
      }
      var d = new cs(this._layersSeries || [], l, f, f), p = [];
      d.add(ue(g, this, "add")).update(ue(g, this, "update")).remove(ue(g, this, "remove")).execute();
      function g(v, O, m) {
        var E = o._layers;
        if (v === "remove") {
          s.remove(E[O]);
          return;
        }
        for (var b = [], S = [], T, y = l[O].indices, R = 0; R < y.length; R++) {
          var _ = a.getItemLayout(y[R]), C = _.x, I = _.y0, w = _.y;
          b.push(C, I), S.push(C, I + w), T = a.getItemVisual(y[R], "style");
        }
        var x, P = a.getItemLayout(y[0]), L = t.getModel("label"), D = L.get("margin"), U = t.getModel("emphasis");
        if (v === "add") {
          var Q = p[O] = new Re();
          x = new _3({
            shape: {
              points: b,
              stackedOnPoints: S,
              smooth: 0.4,
              stackedOnSmooth: 0.4,
              smoothConstraint: !1
            },
            z2: 0
          }), Q.add(x), s.add(Q), t.isAnimationEnabled() && x.setClipPath(LSe(x.getBoundingRect(), t, function() {
            x.removeClipPath();
          }));
        } else {
          var Q = E[m];
          x = Q.childAt(0), s.add(Q), p[O] = Q, Ot(x, {
            shape: {
              points: b,
              stackedOnPoints: S
            }
          }, t), La(x);
        }
        ii(x, kr(t), {
          labelDataIndex: y[R - 1],
          defaultText: a.getName(y[R - 1]),
          inheritColor: T.fill
        }, {
          normal: {
            verticalAlign: "middle"
            // align: 'right'
          }
        }), x.setTextConfig({
          position: null,
          local: !0
        });
        var V = x.getTextContent();
        V && (V.x = P.x - D, V.y = P.y0 + P.y / 2), x.useStyle(T), a.setItemGraphicEl(O, x), ri(x, t), qt(x, U.get("focus"), U.get("blurScope"), U.get("disabled"));
      }
      this._layersSeries = l, this._layers = p;
    }, e.type = "themeRiver", e;
  }($t)
);
function LSe(r, e, t) {
  var i = new ht({
    shape: {
      x: r.x - 10,
      y: r.y - 10,
      width: 0,
      height: r.height + 20
    }
  });
  return Bt(i, {
    shape: {
      x: r.x - 50,
      width: r.width + 100,
      height: r.height + 20
    }
  }, e, t), i;
}
const DSe = PSe;
var UR = 2, MSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t) {
      r.prototype.init.apply(this, arguments), this.legendVisualProvider = new Uv(ue(this.getData, this), ue(this.getRawData, this));
    }, e.prototype.fixData = function(t) {
      var i = t.length, n = {}, a = q_(t, function(f) {
        return n.hasOwnProperty(f[0] + "") || (n[f[0] + ""] = -1), f[2];
      }), o = [];
      a.buckets.each(function(f, d) {
        o.push({
          name: d,
          dataList: f
        });
      });
      for (var s = o.length, l = 0; l < s; ++l) {
        for (var u = o[l].name, c = 0; c < o[l].dataList.length; ++c) {
          var h = o[l].dataList[c][0] + "";
          n[h] = l;
        }
        for (var h in n)
          n.hasOwnProperty(h) && n[h] !== l && (n[h] = l, t[i] = [h, 0, u], i++);
      }
      return t;
    }, e.prototype.getInitialData = function(t, i) {
      for (var n = this.getReferringComponents("singleAxis", Or).models[0], a = n.get("type"), o = At(t.data, function(p) {
        return p[2] !== void 0;
      }), s = this.fixData(o || []), l = [], u = this.nameMap = de(), c = 0, h = 0; h < s.length; ++h)
        l.push(s[h][UR]), u.get(s[h][UR]) || (u.set(s[h][UR], c), c++);
      var f = xv(s, {
        coordDimensions: ["single"],
        dimensionsDefine: [{
          name: "time",
          type: yb(a)
        }, {
          name: "value",
          type: "float"
        }, {
          name: "name",
          type: "ordinal"
        }],
        encodeDefine: {
          single: 0,
          value: 1,
          itemName: 2
        }
      }).dimensions, d = new ki(f, this);
      return d.initData(s), d;
    }, e.prototype.getLayerSeries = function() {
      for (var t = this.getData(), i = t.count(), n = [], a = 0; a < i; ++a)
        n[a] = a;
      var o = t.mapDimension("single"), s = q_(n, function(u) {
        return t.get("name", u);
      }), l = [];
      return s.buckets.each(function(u, c) {
        u.sort(function(h, f) {
          return t.get(o, h) - t.get(o, f);
        }), l.push({
          name: c,
          indices: u
        });
      }), l;
    }, e.prototype.getAxisTooltipData = function(t, i, n) {
      X(t) || (t = t ? [t] : []);
      for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, u, c = 0; c < l; ++c) {
        for (var h = Number.MAX_VALUE, f = -1, d = o[c].indices.length, p = 0; p < d; ++p) {
          var g = a.get(t[0], o[c].indices[p]), v = Math.abs(g - i);
          v <= h && (u = g, h = v, f = o[c].indices[p]);
        }
        s.push(f);
      }
      return {
        dataIndices: s,
        nestestValue: u
      };
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = a.getName(t), s = a.get(a.mapDimension("value"), t);
      return Qr("nameValue", {
        name: o,
        value: s
      });
    }, e.type = "series.themeRiver", e.dependencies = ["singleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 2,
      colorBy: "data",
      coordinateSystem: "singleAxis",
      // gap in axis's orthogonal orientation
      boundaryGap: ["10%", "10%"],
      // legendHoverLink: true,
      singleAxisIndex: 0,
      animationEasing: "linear",
      label: {
        margin: 4,
        show: !0,
        position: "left",
        fontSize: 11
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(Wt)
);
const kSe = MSe;
function QSe(r, e) {
  r.eachSeriesByType("themeRiver", function(t) {
    var i = t.getData(), n = t.coordinateSystem, a = {}, o = n.getRect();
    a.rect = o;
    var s = t.get("boundaryGap"), l = n.getAxis();
    if (a.boundaryGap = s, l.orient === "horizontal") {
      s[0] = K(s[0], o.height), s[1] = K(s[1], o.height);
      var u = o.height - s[0] - s[1];
      dU(i, t, u);
    } else {
      s[0] = K(s[0], o.width), s[1] = K(s[1], o.width);
      var c = o.width - s[0] - s[1];
      dU(i, t, c);
    }
    i.setLayout("layoutInfo", a);
  });
}
function dU(r, e, t) {
  if (r.count())
    for (var i = e.coordinateSystem, n = e.getLayerSeries(), a = r.mapDimension("single"), o = r.mapDimension("value"), s = Y(n, function(v) {
      return Y(v.indices, function(O) {
        var m = i.dataToPoint(r.get(a, O));
        return m[1] = r.get(o, O), m;
      });
    }), l = USe(s), u = l.y0, c = t / l.max, h = n.length, f = n[0].indices.length, d, p = 0; p < f; ++p) {
      d = u[p] * c, r.setItemLayout(n[0].indices[p], {
        layerIndex: 0,
        x: s[0][p][0],
        y0: d,
        y: s[0][p][1] * c
      });
      for (var g = 1; g < h; ++g)
        d += s[g - 1][p][1] * c, r.setItemLayout(n[g].indices[p], {
          layerIndex: g,
          x: s[g][p][0],
          y0: d,
          y: s[g][p][1] * c
        });
    }
}
function USe(r) {
  for (var e = r.length, t = r[0].length, i = [], n = [], a = 0, o = 0; o < t; ++o) {
    for (var s = 0, l = 0; l < e; ++l)
      s += r[l][o][1];
    s > a && (a = s), i.push(s);
  }
  for (var u = 0; u < t; ++u)
    n[u] = (a - i[u]) / 2;
  a = 0;
  for (var c = 0; c < t; ++c) {
    var h = i[c] + n[c];
    h > a && (a = h);
  }
  return {
    y0: n,
    max: a
  };
}
function $Se(r) {
  r.registerChartView(DSe), r.registerSeriesModel(kSe), r.registerLayout(QSe), r.registerProcessor(Qv("themeRiver"));
}
var VSe = 2, GSe = 4, BSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n, a) {
      var o = r.call(this) || this;
      o.z2 = VSe, o.textConfig = {
        inside: !0
      }, Pe(o).seriesIndex = i.seriesIndex;
      var s = new dt({
        z2: GSe,
        silent: t.getModel().get(["label", "silent"])
      });
      return o.setTextContent(s), o.updateData(!0, t, i, n, a), o;
    }
    return e.prototype.updateData = function(t, i, n, a, o) {
      this.node = i, i.piece = this, n = n || this._seriesModel, a = a || this._ecModel;
      var s = this;
      Pe(s).dataIndex = i.dataIndex;
      var l = i.getModel(), u = l.getModel("emphasis"), c = i.getLayout(), h = B({}, c);
      h.label = null;
      var f = i.getVisual("style");
      f.lineJoin = "bevel";
      var d = i.getVisual("decal");
      d && (f.decal = xf(d, o));
      var p = ec(l.getModel("itemStyle"), h, !0);
      B(h, p), N($i, function(m) {
        var E = s.ensureState(m), b = l.getModel([m, "itemStyle"]);
        E.style = b.getItemStyle();
        var S = ec(b, h);
        S && (E.shape = S);
      }), t ? (s.setShape(h), s.shape.r = c.r0, Bt(s, {
        shape: {
          r: c.r
        }
      }, n, i.dataIndex)) : (Ot(s, {
        shape: h
      }, n), La(s)), s.useStyle(f), this._updateLabel(n);
      var g = l.getShallow("cursor");
      g && s.attr("cursor", g), this._seriesModel = n || this._seriesModel, this._ecModel = a || this._ecModel;
      var v = u.get("focus"), O = v === "ancestor" ? i.getAncestorsIndices() : v === "descendant" ? i.getDescendantIndices() : v;
      qt(this, O, u.get("blurScope"), u.get("disabled"));
    }, e.prototype._updateLabel = function(t) {
      var i = this, n = this.node.getModel(), a = n.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, u = Math.cos(l), c = Math.sin(l), h = this, f = h.getTextContent(), d = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, g = a.get("show") && !(p != null && Math.abs(s) < p);
      f.ignore = !g, N(xg, function(O) {
        var m = O === "normal" ? n.getModel("label") : n.getModel([O, "label"]), E = O === "normal", b = E ? f : f.ensureState(O), S = t.getFormattedLabel(d, O);
        E && (S = S || i.node.name), b.style = Qt(m, {}, null, O !== "normal", !0), S && (b.style.text = S);
        var T = m.get("show");
        T != null && !E && (b.ignore = !T);
        var y = v(m, "position"), R = E ? h : h.states[O], _ = R.style.fill;
        R.textConfig = {
          outsideFill: m.get("color") === "inherit" ? _ : null,
          inside: y !== "outside"
        };
        var C, I = v(m, "distance") || 0, w = v(m, "align");
        y === "outside" ? (C = o.r + I, w = l > Math.PI / 2 ? "right" : "left") : !w || w === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? C = 0 : C = (o.r + o.r0) / 2, w = "center") : w === "left" ? (C = o.r0 + I, l > Math.PI / 2 && (w = "right")) : w === "right" && (C = o.r - I, l > Math.PI / 2 && (w = "left")), b.style.align = w, b.style.verticalAlign = v(m, "verticalAlign") || "middle", b.x = C * u + o.cx, b.y = C * c + o.cy;
        var x = v(m, "rotate"), P = 0;
        x === "radial" ? (P = ba(-l), P > Math.PI / 2 && P < Math.PI * 1.5 && (P += Math.PI)) : x === "tangential" ? (P = Math.PI / 2 - l, P > Math.PI / 2 ? P -= Math.PI : P < -Math.PI / 2 && (P += Math.PI)) : pt(x) && (P = x * Math.PI / 180), b.rotation = ba(P);
      });
      function v(O, m) {
        var E = O.get(m);
        return E ?? a.get(m);
      }
      f.dirtyStyle();
    }, e;
  }(tn)
);
const pU = BSe;
var ZC = "sunburstRootToNode", gU = "sunburstHighlight", FSe = "sunburstUnhighlight";
function XSe(r) {
  r.registerAction({
    type: ZC,
    update: "updateView"
  }, function(e, t) {
    t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, i);
    function i(n, a) {
      var o = Xg(e, [ZC], n);
      if (o) {
        var s = n.getViewRoot();
        s && (e.direction = BN(s, o.node) ? "rollUp" : "drillDown"), n.resetViewRoot(o.node);
      }
    }
  }), r.registerAction({
    type: gU,
    update: "none"
  }, function(e, t, i) {
    e = B({}, e), t.eachComponent({
      mainType: "series",
      subType: "sunburst",
      query: e
    }, n);
    function n(a) {
      var o = Xg(e, [gU], a);
      o && (e.dataIndex = o.node.dataIndex);
    }
    ({}).NODE_ENV !== "production" && fr("sunburstHighlight", "highlight"), i.dispatchAction(B(e, {
      type: "highlight"
    }));
  }), r.registerAction({
    type: FSe,
    update: "updateView"
  }, function(e, t, i) {
    e = B({}, e), {}.NODE_ENV !== "production" && fr("sunburstUnhighlight", "downplay"), i.dispatchAction(B(e, {
      type: "downplay"
    }));
  });
}
var YSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = this;
      this.seriesModel = t, this.api = n, this.ecModel = i;
      var s = t.getData(), l = s.tree.root, u = t.getViewRoot(), c = this.group, h = t.get("renderLabelForZeroData"), f = [];
      u.eachNode(function(m) {
        f.push(m);
      });
      var d = this._oldChildren || [];
      p(f, d), O(l, u), this._initEvents(), this._oldChildren = f;
      function p(m, E) {
        if (m.length === 0 && E.length === 0)
          return;
        new cs(E, m, b, b).add(S).update(S).remove(Le(S, null)).execute();
        function b(T) {
          return T.getId();
        }
        function S(T, y) {
          var R = T == null ? null : m[T], _ = y == null ? null : E[y];
          g(R, _);
        }
      }
      function g(m, E) {
        if (!h && m && !m.getValue() && (m = null), m !== l && E !== l) {
          if (E && E.piece)
            m ? (E.piece.updateData(!1, m, t, i, n), s.setItemGraphicEl(m.dataIndex, E.piece)) : v(E);
          else if (m) {
            var b = new pU(m, t, i, n);
            c.add(b), s.setItemGraphicEl(m.dataIndex, b);
          }
        }
      }
      function v(m) {
        m && m.piece && (c.remove(m.piece), m.piece = null);
      }
      function O(m, E) {
        E.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, m, t, i, n) : (o.virtualPiece = new pU(m, t, i, n), c.add(o.virtualPiece)), E.piece.off("click"), o.virtualPiece.on("click", function(b) {
          o._rootToNode(E.parentNode);
        })) : o.virtualPiece && (c.remove(o.virtualPiece), o.virtualPiece = null);
      }
    }, e.prototype._initEvents = function() {
      var t = this;
      this.group.off("click"), this.group.on("click", function(i) {
        var n = !1, a = t.seriesModel.getViewRoot();
        a.eachNode(function(o) {
          if (!n && o.piece && o.piece === i.target) {
            var s = o.getModel().get("nodeClick");
            if (s === "rootToNode")
              t._rootToNode(o);
            else if (s === "link") {
              var l = o.getModel(), u = l.get("link");
              if (u) {
                var c = l.get("target", !0) || "_blank";
                fb(u, c);
              }
            }
            n = !0;
          }
        });
      });
    }, e.prototype._rootToNode = function(t) {
      t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({
        type: ZC,
        from: this.uid,
        seriesId: this.seriesModel.id,
        targetNode: t
      });
    }, e.prototype.containPoint = function(t, i) {
      var n = i.getData(), a = n.getItemLayout(0);
      if (a) {
        var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s);
        return l <= a.r && l >= a.r0;
      }
    }, e.type = "sunburst", e;
  }($t)
);
const HSe = YSe;
var WSe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.ignoreStyleOnData = !0, t;
    }
    return e.prototype.getInitialData = function(t, i) {
      var n = {
        name: t.name,
        children: t.data
      };
      iZ(n);
      var a = this._levelModels = Y(t.levels || [], function(l) {
        return new Ut(l, this, i);
      }, this), o = GN.createTree(n, this, s);
      function s(l) {
        l.wrapMethod("getItemModel", function(u, c) {
          var h = o.getNodeByDataIndex(c), f = a[h.depth];
          return f && (u.parentModel = f), u;
        });
      }
      return o.data;
    }, e.prototype.optionUpdated = function() {
      this.resetViewRoot();
    }, e.prototype.getDataParams = function(t) {
      var i = r.prototype.getDataParams.apply(this, arguments), n = this.getData().tree.getNodeByDataIndex(t);
      return i.treePathInfo = GT(n, this), i;
    }, e.prototype.getLevelModel = function(t) {
      return this._levelModels && this._levelModels[t.depth];
    }, e.prototype.getViewRoot = function() {
      return this._viewRoot;
    }, e.prototype.resetViewRoot = function(t) {
      t ? this._viewRoot = t : t = this._viewRoot;
      var i = this.getRawData().tree.root;
      (!t || t !== i && !i.contains(t)) && (this._viewRoot = i);
    }, e.prototype.enableAriaDecal = function() {
      s4(this);
    }, e.type = "series.sunburst", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      // 
      center: ["50%", "50%"],
      radius: [0, "75%"],
      // 
      clockwise: !0,
      startAngle: 90,
      // 0
      minAngle: 0,
      // If still show when all data zero.
      stillShowZeroSum: !0,
      // 'rootToNode', 'link', or false
      nodeClick: "rootToNode",
      renderLabelForZeroData: !1,
      label: {
        // could be: 'radial', 'tangential', or 'none'
        rotate: "radial",
        show: !0,
        opacity: 1,
        // 'left' is for inner side of inside, and 'right' is for outer
        // side for inside
        align: "center",
        position: "inside",
        distance: 5,
        silent: !0
      },
      itemStyle: {
        borderWidth: 1,
        borderColor: "white",
        borderType: "solid",
        shadowBlur: 0,
        shadowColor: "rgba(0, 0, 0, 0.2)",
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        opacity: 1
      },
      emphasis: {
        focus: "descendant"
      },
      blur: {
        itemStyle: {
          opacity: 0.2
        },
        label: {
          opacity: 0.1
        }
      },
      // Animation type can be expansion, scale.
      animationType: "expansion",
      animationDuration: 1e3,
      animationDurationUpdate: 500,
      data: [],
      /**
       * Sort order.
       *
       * Valid values: 'desc', 'asc', null, or callback function.
       * 'desc' and 'asc' for descend and ascendant order;
       * null for not sorting;
       * example of callback function:
       * function(nodeA, nodeB) {
       *     return nodeA.getValue() - nodeB.getValue();
       * }
       */
      sort: "desc"
    }, e;
  }(Wt)
);
function iZ(r) {
  var e = 0;
  N(r.children, function(i) {
    iZ(i);
    var n = i.value;
    X(n) && (n = n[0]), e += n;
  });
  var t = r.value;
  X(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), X(r.value) ? r.value[0] = t : r.value = t;
}
const zSe = WSe;
var vU = Math.PI / 180;
function ZSe(r, e, t) {
  e.eachSeriesByType(r, function(i) {
    var n = i.get("center"), a = i.get("radius");
    X(a) || (a = [0, a]), X(n) || (n = [n, n]);
    var o = t.getWidth(), s = t.getHeight(), l = Math.min(o, s), u = K(n[0], o), c = K(n[1], s), h = K(a[0], l / 2), f = K(a[1], l / 2), d = -i.get("startAngle") * vU, p = i.get("minAngle") * vU, g = i.getData().tree.root, v = i.getViewRoot(), O = v.depth, m = i.get("sort");
    m != null && nZ(v, m);
    var E = 0;
    N(v.children, function(D) {
      !isNaN(D.getValue()) && E++;
    });
    var b = v.getValue(), S = Math.PI / (b || E) * 2, T = v.depth > 0, y = v.height - (T ? -1 : 1), R = (f - h) / (y || 1), _ = i.get("clockwise"), C = i.get("stillShowZeroSum"), I = _ ? 1 : -1, w = function(D, U) {
      if (D) {
        var Q = U;
        if (D !== g) {
          var V = D.getValue(), F = b === 0 && C ? S : V * S;
          F < p && (F = p), Q = U + I * F;
          var j = D.depth - O - (T ? -1 : 1), ae = h + R * j, ce = h + R * (j + 1), ge = i.getLevelModel(D);
          if (ge) {
            var Be = ge.get("r0", !0), We = ge.get("r", !0), Ne = ge.get("radius", !0);
            Ne != null && (Be = Ne[0], We = Ne[1]), Be != null && (ae = K(Be, l / 2)), We != null && (ce = K(We, l / 2));
          }
          D.setLayout({
            angle: F,
            startAngle: U,
            endAngle: Q,
            clockwise: _,
            cx: u,
            cy: c,
            r0: ae,
            r: ce
          });
        }
        if (D.children && D.children.length) {
          var Ee = 0;
          N(D.children, function(Ge) {
            Ee += w(Ge, U + Ee);
          });
        }
        return Q - U;
      }
    };
    if (T) {
      var x = h, P = h + R, L = Math.PI * 2;
      g.setLayout({
        angle: L,
        startAngle: d,
        endAngle: d + L,
        clockwise: _,
        cx: u,
        cy: c,
        r0: x,
        r: P
      });
    }
    w(v, d);
  });
}
function nZ(r, e) {
  var t = r.children || [];
  r.children = qSe(t, e), t.length && N(r.children, function(i) {
    nZ(i, e);
  });
}
function qSe(r, e) {
  if (ve(e)) {
    var t = Y(r, function(n, a) {
      var o = n.getValue();
      return {
        params: {
          depth: n.depth,
          height: n.height,
          dataIndex: n.dataIndex,
          getValue: function() {
            return o;
          }
        },
        index: a
      };
    });
    return t.sort(function(n, a) {
      return e(n.params, a.params);
    }), Y(t, function(n) {
      return r[n.index];
    });
  } else {
    var i = e === "asc";
    return r.sort(function(n, a) {
      var o = (n.getValue() - a.getValue()) * (i ? 1 : -1);
      return o === 0 ? (n.dataIndex - a.dataIndex) * (i ? -1 : 1) : o;
    });
  }
}
function jSe(r) {
  var e = {};
  function t(i, n, a) {
    for (var o = i; o && o.depth > 1; )
      o = o.parentNode;
    var s = n.getColorFromPalette(o.name || o.dataIndex + "", e);
    return i.depth > 1 && ne(s) && (s = $_(s, (i.depth - 1) / (a - 1) * 0.5)), s;
  }
  r.eachSeriesByType("sunburst", function(i) {
    var n = i.getData(), a = n.tree;
    a.eachNode(function(o) {
      var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle();
      l.fill || (l.fill = t(o, i, a.root.height));
      var u = n.ensureUniqueItemVisual(o.dataIndex, "style");
      B(u, l);
    });
  });
}
function KSe(r) {
  r.registerChartView(HSe), r.registerSeriesModel(zSe), r.registerLayout(Le(ZSe, "sunburst")), r.registerProcessor(Le(Qv, "sunburst")), r.registerVisual(jSe), XSe(r);
}
var OU = {
  color: "fill",
  borderColor: "stroke"
}, JSe = {
  symbol: 1,
  symbolSize: 1,
  symbolKeepAspect: 1,
  legendIcon: 1,
  visualMeta: 1,
  liftZ: 1,
  decal: 1
}, Jo = ft(), eTe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0);
    }, e.prototype.getInitialData = function(t, i) {
      return Ss(null, this);
    }, e.prototype.getDataParams = function(t, i, n) {
      var a = r.prototype.getDataParams.call(this, t, i);
      return n && (a.info = Jo(n).info), a;
    }, e.type = "series.custom", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = {
      coordinateSystem: "cartesian2d",
      // zlevel: 0,
      z: 2,
      legendHoverLink: !0,
      // Custom series will not clip by default.
      // Some case will use custom series to draw label
      // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
      clip: !1
      // Cartesian coordinate system
      // xAxisIndex: 0,
      // yAxisIndex: 0,
      // Polar coordinate system
      // polarIndex: 0,
      // Geo coordinate system
      // geoIndex: 0,
    }, e;
  }(Wt)
);
const tTe = eTe;
function rTe(r, e) {
  return e = e || [0, 0], Y(["x", "y"], function(t, i) {
    var n = this.getAxis(t), a = e[i], o = r[i] / 2;
    return n.type === "category" ? n.getBandWidth() : Math.abs(n.dataToCoord(a - o) - n.dataToCoord(a + o));
  }, this);
}
function iTe(r) {
  var e = r.master.getRect();
  return {
    coordSys: {
      // The name exposed to user is always 'cartesian2d' but not 'grid'.
      type: "cartesian2d",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return r.dataToPoint(t);
      },
      size: ue(rTe, r)
    }
  };
}
function nTe(r, e) {
  return e = e || [0, 0], Y([0, 1], function(t) {
    var i = e[t], n = r[t] / 2, a = [], o = [];
    return a[t] = i - n, o[t] = i + n, a[1 - t] = o[1 - t] = e[1 - t], Math.abs(this.dataToPoint(a)[t] - this.dataToPoint(o)[t]);
  }, this);
}
function aTe(r) {
  var e = r.getBoundingRect();
  return {
    coordSys: {
      type: "geo",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      zoom: r.getZoom()
    },
    api: {
      coord: function(t) {
        return r.dataToPoint(t);
      },
      size: ue(nTe, r)
    }
  };
}
function oTe(r, e) {
  var t = this.getAxis(), i = e instanceof Array ? e[0] : e, n = (r instanceof Array ? r[0] : r) / 2;
  return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(i - n) - t.dataToCoord(i + n));
}
function sTe(r) {
  var e = r.getRect();
  return {
    coordSys: {
      type: "singleAxis",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height
    },
    api: {
      coord: function(t) {
        return r.dataToPoint(t);
      },
      size: ue(oTe, r)
    }
  };
}
function lTe(r, e) {
  return e = e || [0, 0], Y(["Radius", "Angle"], function(t, i) {
    var n = "get" + t + "Axis", a = this[n](), o = e[i], s = r[i] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s));
    return t === "Angle" && (l = l * Math.PI / 180), l;
  }, this);
}
function uTe(r) {
  var e = r.getRadiusAxis(), t = r.getAngleAxis(), i = e.getExtent();
  return i[0] > i[1] && i.reverse(), {
    coordSys: {
      type: "polar",
      cx: r.cx,
      cy: r.cy,
      r: i[1],
      r0: i[0]
    },
    api: {
      coord: function(n) {
        var a = e.dataToRadius(n[0]), o = t.dataToAngle(n[1]), s = r.coordToPoint([a, o]);
        return s.push(a, o * Math.PI / 180), s;
      },
      size: ue(lTe, r)
    }
  };
}
function cTe(r) {
  var e = r.getRect(), t = r.getRangeInfo();
  return {
    coordSys: {
      type: "calendar",
      x: e.x,
      y: e.y,
      width: e.width,
      height: e.height,
      cellWidth: r.getCellWidth(),
      cellHeight: r.getCellHeight(),
      rangeInfo: {
        start: t.start,
        end: t.end,
        weeks: t.weeks,
        dayCount: t.allDay
      }
    },
    api: {
      coord: function(i, n) {
        return r.dataToPoint(i, n);
      }
    }
  };
}
var mU = {};
function aZ(r, e, t, i) {
  return r && (r.legacy || r.legacy !== !1 && !t && !i && e !== "tspan" && (e === "text" || le(r, "text")));
}
function oZ(r, e, t) {
  var i = r, n, a, o;
  if (e === "text")
    o = i;
  else {
    o = {}, le(i, "text") && (o.text = i.text), le(i, "rich") && (o.rich = i.rich), le(i, "textFill") && (o.fill = i.textFill), le(i, "textStroke") && (o.stroke = i.textStroke), le(i, "fontFamily") && (o.fontFamily = i.fontFamily), le(i, "fontSize") && (o.fontSize = i.fontSize), le(i, "fontStyle") && (o.fontStyle = i.fontStyle), le(i, "fontWeight") && (o.fontWeight = i.fontWeight), a = {
      type: "text",
      style: o,
      // ec4 does not support rectText trigger.
      // And when text position is different in normal and emphasis
      // => hover text trigger emphasis;
      // => text position changed, leave mouse pointer immediately;
      // That might cause incorrect state.
      silent: !0
    }, n = {};
    var s = le(i, "textPosition");
    t ? n.position = s ? i.textPosition : "inside" : s && (n.position = i.textPosition), le(i, "textPosition") && (n.position = i.textPosition), le(i, "textOffset") && (n.offset = i.textOffset), le(i, "textRotation") && (n.rotation = i.textRotation), le(i, "textDistance") && (n.distance = i.textDistance);
  }
  return EU(o, r), N(o.rich, function(l) {
    EU(l, l);
  }), {
    textConfig: n,
    textContent: a
  };
}
function EU(r, e) {
  e && (e.font = e.textFont || e.font, le(e, "textStrokeWidth") && (r.lineWidth = e.textStrokeWidth), le(e, "textAlign") && (r.align = e.textAlign), le(e, "textVerticalAlign") && (r.verticalAlign = e.textVerticalAlign), le(e, "textLineHeight") && (r.lineHeight = e.textLineHeight), le(e, "textWidth") && (r.width = e.textWidth), le(e, "textHeight") && (r.height = e.textHeight), le(e, "textBackgroundColor") && (r.backgroundColor = e.textBackgroundColor), le(e, "textPadding") && (r.padding = e.textPadding), le(e, "textBorderColor") && (r.borderColor = e.textBorderColor), le(e, "textBorderWidth") && (r.borderWidth = e.textBorderWidth), le(e, "textBorderRadius") && (r.borderRadius = e.textBorderRadius), le(e, "textBoxShadowColor") && (r.shadowColor = e.textBoxShadowColor), le(e, "textBoxShadowBlur") && (r.shadowBlur = e.textBoxShadowBlur), le(e, "textBoxShadowOffsetX") && (r.shadowOffsetX = e.textBoxShadowOffsetX), le(e, "textBoxShadowOffsetY") && (r.shadowOffsetY = e.textBoxShadowOffsetY));
}
function bU(r, e, t) {
  var i = r;
  i.textPosition = i.textPosition || t.position || "inside", t.offset != null && (i.textOffset = t.offset), t.rotation != null && (i.textRotation = t.rotation), t.distance != null && (i.textDistance = t.distance);
  var n = i.textPosition.indexOf("inside") >= 0, a = r.fill || "#000";
  SU(i, e);
  var o = i.textFill == null;
  return n ? o && (i.textFill = t.insideFill || "#fff", !i.textStroke && t.insideStroke && (i.textStroke = t.insideStroke), !i.textStroke && (i.textStroke = a), i.textStrokeWidth == null && (i.textStrokeWidth = 2)) : (o && (i.textFill = r.fill || t.outsideFill || "#000"), !i.textStroke && t.outsideStroke && (i.textStroke = t.outsideStroke)), i.text = e.text, i.rich = e.rich, N(e.rich, function(s) {
    SU(s, s);
  }), i;
}
function SU(r, e) {
  e && (le(e, "fill") && (r.textFill = e.fill), le(e, "stroke") && (r.textStroke = e.fill), le(e, "lineWidth") && (r.textStrokeWidth = e.lineWidth), le(e, "font") && (r.font = e.font), le(e, "fontStyle") && (r.fontStyle = e.fontStyle), le(e, "fontWeight") && (r.fontWeight = e.fontWeight), le(e, "fontSize") && (r.fontSize = e.fontSize), le(e, "fontFamily") && (r.fontFamily = e.fontFamily), le(e, "align") && (r.textAlign = e.align), le(e, "verticalAlign") && (r.textVerticalAlign = e.verticalAlign), le(e, "lineHeight") && (r.textLineHeight = e.lineHeight), le(e, "width") && (r.textWidth = e.width), le(e, "height") && (r.textHeight = e.height), le(e, "backgroundColor") && (r.textBackgroundColor = e.backgroundColor), le(e, "padding") && (r.textPadding = e.padding), le(e, "borderColor") && (r.textBorderColor = e.borderColor), le(e, "borderWidth") && (r.textBorderWidth = e.borderWidth), le(e, "borderRadius") && (r.textBorderRadius = e.borderRadius), le(e, "shadowColor") && (r.textBoxShadowColor = e.shadowColor), le(e, "shadowBlur") && (r.textBoxShadowBlur = e.shadowBlur), le(e, "shadowOffsetX") && (r.textBoxShadowOffsetX = e.shadowOffsetX), le(e, "shadowOffsetY") && (r.textBoxShadowOffsetY = e.shadowOffsetY), le(e, "textShadowColor") && (r.textShadowColor = e.textShadowColor), le(e, "textShadowBlur") && (r.textShadowBlur = e.textShadowBlur), le(e, "textShadowOffsetX") && (r.textShadowOffsetX = e.textShadowOffsetX), le(e, "textShadowOffsetY") && (r.textShadowOffsetY = e.textShadowOffsetY));
}
function TU(r, e) {
  if ({}.NODE_ENV !== "production") {
    var t = r + "^_^" + e;
    mU[t] || (console.warn('[ECharts] DEPRECATED: "' + r + '" has been deprecated. ' + e), mU[t] = !0);
  }
}
var sZ = {
  position: ["x", "y"],
  scale: ["scaleX", "scaleY"],
  origin: ["originX", "originY"]
}, yU = Ze(sZ), kb = To(Ro, function(r, e) {
  return r[e] = 1, r;
}, {}), RU = Ro.join(", "), Qb = ["", "style", "shape", "extra"], kf = ft();
function nx(r, e, t, i, n) {
  var a = r + "Animation", o = Jf(r, i, n) || {}, s = kf(e).userDuring;
  return o.duration > 0 && (o.during = s ? ue(gTe, {
    el: e,
    userDuring: s
  }) : null, o.setToFinal = !0, o.scope = r), B(o, t[a]), o;
}
function aE(r, e, t, i) {
  i = i || {};
  var n = i.dataIndex, a = i.isInit, o = i.clearStyle, s = t.isAnimationEnabled(), l = kf(r), u = e.style;
  l.userDuring = e.during;
  var c = {}, h = {};
  if (OTe(r, e, h), _U("shape", e, h), _U("extra", e, h), !a && s && (vTe(r, e, c), AU("shape", r, e, c), AU("extra", r, e, c), mTe(r, e, u, c)), h.style = u, hTe(r, h, o), dTe(r, e), s)
    if (a) {
      var f = {};
      N(Qb, function(p) {
        var g = p ? e[p] : e;
        g && g.enterFrom && (p && (f[p] = f[p] || {}), B(p ? f[p] : f, g.enterFrom));
      });
      var d = nx("enter", r, e, t, n);
      d.duration > 0 && r.animateFrom(f, d);
    } else
      fTe(r, e, n || 0, t, c);
  lZ(r, e), u ? r.dirty() : r.markRedraw();
}
function lZ(r, e) {
  for (var t = kf(r).leaveToProps, i = 0; i < Qb.length; i++) {
    var n = Qb[i], a = n ? e[n] : e;
    a && a.leaveTo && (t || (t = kf(r).leaveToProps = {}), n && (t[n] = t[n] || {}), B(n ? t[n] : t, a.leaveTo));
  }
}
function XT(r, e, t, i) {
  if (r) {
    var n = r.parent, a = kf(r).leaveToProps;
    if (a) {
      var o = nx("update", r, e, t, 0);
      o.done = function() {
        n.remove(r), i && i();
      }, r.animateTo(a, o);
    } else
      n.remove(r), i && i();
  }
}
function Ec(r) {
  return r === "all";
}
function hTe(r, e, t) {
  var i = e.style;
  if (!r.isGroup && i) {
    if (t) {
      r.useStyle({});
      for (var n = r.animators, a = 0; a < n.length; a++) {
        var o = n[a];
        o.targetName === "style" && o.changeTarget(r.style);
      }
    }
    r.setStyle(i);
  }
  e && (e.style = null, e && r.attr(e), e.style = i);
}
function fTe(r, e, t, i, n) {
  if (n) {
    var a = nx("update", r, e, i, t);
    a.duration > 0 && r.animateFrom(n, a);
  }
}
function dTe(r, e) {
  le(e, "silent") && (r.silent = e.silent), le(e, "ignore") && (r.ignore = e.ignore), r instanceof aa && le(e, "invisible") && (r.invisible = e.invisible), r instanceof He && le(e, "autoBatch") && (r.autoBatch = e.autoBatch);
}
var Ha = {}, pTe = {
  // Usually other props do not need to be changed in animation during.
  setTransform: function(r, e) {
    return {}.NODE_ENV !== "production" && Se(le(kb, r), "Only " + RU + " available in `setTransform`."), Ha.el[r] = e, this;
  },
  getTransform: function(r) {
    return {}.NODE_ENV !== "production" && Se(le(kb, r), "Only " + RU + " available in `getTransform`."), Ha.el[r];
  },
  setShape: function(r, e) {
    ({}).NODE_ENV !== "production" && Ch(r);
    var t = Ha.el, i = t.shape || (t.shape = {});
    return i[r] = e, t.dirtyShape && t.dirtyShape(), this;
  },
  getShape: function(r) {
    ({}).NODE_ENV !== "production" && Ch(r);
    var e = Ha.el.shape;
    if (e)
      return e[r];
  },
  setStyle: function(r, e) {
    ({}).NODE_ENV !== "production" && Ch(r);
    var t = Ha.el, i = t.style;
    return i && ({}.NODE_ENV !== "production" && Cc(e) && tr("style." + r + " must not be assigned with NaN."), i[r] = e, t.dirtyStyle && t.dirtyStyle()), this;
  },
  getStyle: function(r) {
    ({}).NODE_ENV !== "production" && Ch(r);
    var e = Ha.el.style;
    if (e)
      return e[r];
  },
  setExtra: function(r, e) {
    ({}).NODE_ENV !== "production" && Ch(r);
    var t = Ha.el.extra || (Ha.el.extra = {});
    return t[r] = e, this;
  },
  getExtra: function(r) {
    ({}).NODE_ENV !== "production" && Ch(r);
    var e = Ha.el.extra;
    if (e)
      return e[r];
  }
};
function Ch(r) {
  if ({}.NODE_ENV !== "production" && (r === "transition" || r === "enterFrom" || r === "leaveTo"))
    throw new Error('key must not be "' + r + '"');
}
function gTe() {
  var r = this, e = r.el;
  if (e) {
    var t = kf(e).userDuring, i = r.userDuring;
    if (t !== i) {
      r.el = r.userDuring = null;
      return;
    }
    Ha.el = e, i(pTe);
  }
}
function AU(r, e, t, i) {
  var n = t[r];
  if (n) {
    var a = e[r], o;
    if (a) {
      var s = t.transition, l = n.transition;
      if (l)
        if (!o && (o = i[r] = {}), Ec(l))
          B(o, a);
        else
          for (var u = It(l), c = 0; c < u.length; c++) {
            var h = u[c], f = a[h];
            o[h] = f;
          }
      else if (Ec(s) || Fe(s, r) >= 0) {
        !o && (o = i[r] = {});
        for (var d = Ze(a), c = 0; c < d.length; c++) {
          var h = d[c], f = a[h];
          ETe(n[h], f) && (o[h] = f);
        }
      }
    }
  }
}
function _U(r, e, t) {
  var i = e[r];
  if (i)
    for (var n = t[r] = {}, a = Ze(i), o = 0; o < a.length; o++) {
      var s = a[o];
      n[s] = Yp(i[s]);
    }
}
function vTe(r, e, t) {
  for (var i = e.transition, n = Ec(i) ? Ro : It(i || []), a = 0; a < n.length; a++) {
    var o = n[a];
    if (!(o === "style" || o === "shape" || o === "extra")) {
      var s = r[o];
      ({}).NODE_ENV !== "production" && uZ(o, "el.transition"), t[o] = s;
    }
  }
}
function OTe(r, e, t) {
  for (var i = 0; i < yU.length; i++) {
    var n = yU[i], a = sZ[n], o = e[n];
    o && (t[a[0]] = o[0], t[a[1]] = o[1]);
  }
  for (var i = 0; i < Ro.length; i++) {
    var s = Ro[i];
    e[s] != null && (t[s] = e[s]);
  }
}
function mTe(r, e, t, i) {
  if (t) {
    var n = r.style, a;
    if (n) {
      var o = t.transition, s = e.transition;
      if (o && !Ec(o)) {
        var l = It(o);
        !a && (a = i.style = {});
        for (var u = 0; u < l.length; u++) {
          var c = l[u], h = n[c];
          a[c] = h;
        }
      } else if (r.getAnimationStyleProps && (Ec(s) || Ec(o) || Fe(s, "style") >= 0)) {
        var f = r.getAnimationStyleProps(), d = f ? f.style : null;
        if (d) {
          !a && (a = i.style = {});
          for (var p = Ze(t), u = 0; u < p.length; u++) {
            var c = p[u];
            if (d[c]) {
              var h = n[c];
              a[c] = h;
            }
          }
        }
      }
    }
  }
}
function ETe(r, e) {
  return mi(r) ? r !== e : r != null && isFinite(r);
}
var uZ;
({}).NODE_ENV !== "production" && (uZ = function(r, e) {
  le(kb, r) || tr("Prop `" + r + "` is not a permitted in `" + e + "`. Only `" + Ze(kb).join("`, `") + "` are permitted.");
});
var cZ = ft(), bTe = ["percent", "easing", "shape", "style", "extra"];
function hZ(r) {
  r.stopAnimation("keyframe"), r.attr(cZ(r));
}
function Ub(r, e, t) {
  if (!(!t.isAnimationEnabled() || !e)) {
    if (X(e)) {
      N(e, function(s) {
        Ub(r, s, t);
      });
      return;
    }
    var i = e.keyframes, n = e.duration;
    if (t && n == null) {
      var a = Jf("enter", t, 0);
      n = a && a.duration;
    }
    if (!(!i || !n)) {
      var o = cZ(r);
      N(Qb, function(s) {
        if (!(s && !r[s])) {
          var l, u = !1;
          i.sort(function(c, h) {
            return c.percent - h.percent;
          }), N(i, function(c) {
            var h = r.animators, f = s ? c[s] : c;
            if ({}.NODE_ENV !== "production" && c.percent >= 1 && (u = !0), !!f) {
              var d = Ze(f);
              if (s || (d = At(d, function(v) {
                return Fe(bTe, v) < 0;
              })), !!d.length) {
                l || (l = r.animate(s, e.loop, !0), l.scope = "keyframe");
                for (var p = 0; p < h.length; p++)
                  h[p] !== l && h[p].targetName === l.targetName && h[p].stopTracks(d);
                s && (o[s] = o[s] || {});
                var g = s ? o[s] : o;
                N(d, function(v) {
                  g[v] = ((s ? r[s] : r) || {})[v];
                }), l.whenWithKeys(n * c.percent, f, d, c.easing);
              }
            }
          }), l && ({}.NODE_ENV !== "production" && (u || tr("End frame with percent: 1 is missing in the keyframeAnimation.", !0)), l.delay(e.delay || 0).duration(n).start(e.easing));
        }
      });
    }
  }
}
var es = "emphasis", al = "normal", ax = "blur", ox = "select", kl = [al, es, ax, ox], $R = {
  normal: ["itemStyle"],
  emphasis: [es, "itemStyle"],
  blur: [ax, "itemStyle"],
  select: [ox, "itemStyle"]
}, VR = {
  normal: ["label"],
  emphasis: [es, "label"],
  blur: [ax, "label"],
  select: [ox, "label"]
}, STe = ["x", "y"], TTe = "e\0\0", Dn = {
  normal: {},
  emphasis: {},
  blur: {},
  select: {}
}, CU = {
  cartesian2d: iTe,
  geo: aTe,
  single: sTe,
  polar: uTe,
  calendar: cTe
};
function $b(r) {
  return r instanceof He;
}
function qC(r) {
  return r instanceof aa;
}
function yTe(r, e) {
  e.copyTransform(r), qC(e) && qC(r) && (e.setStyle(r.style), e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel, e.invisible = r.invisible, e.ignore = r.ignore, $b(e) && $b(r) && e.setShape(r.shape));
}
var RTe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this._progressiveEls = null;
      var o = this._data, s = t.getData(), l = this.group, u = IU(t, s, i, n);
      o || l.removeAll(), s.diff(o).add(function(h) {
        GR(n, null, h, u(h, a), t, l, s);
      }).remove(function(h) {
        var f = o.getItemGraphicEl(h);
        f && XT(f, Jo(f).option, t);
      }).update(function(h, f) {
        var d = o.getItemGraphicEl(f);
        GR(n, d, h, u(h, a), t, l, s);
      }).execute();
      var c = t.get("clip", !0) ? UT(t.coordinateSystem, !1, t) : null;
      c ? l.setClipPath(c) : l.removeClipPath(), this._data = s;
    }, e.prototype.incrementalPrepareRender = function(t, i, n) {
      this.group.removeAll(), this._data = null;
    }, e.prototype.incrementalRender = function(t, i, n, a, o) {
      var s = i.getData(), l = IU(i, s, n, a), u = this._progressiveEls = [];
      function c(d) {
        d.isGroup || (d.incremental = !0, d.ensureState("emphasis").hoverLayer = !0);
      }
      for (var h = t.start; h < t.end; h++) {
        var f = GR(null, null, h, l(h, o), i, this.group, s);
        f && (f.traverse(c), u.push(f));
      }
    }, e.prototype.eachRendered = function(t) {
      zl(this._progressiveEls || this.group, t);
    }, e.prototype.filterForExposedEvent = function(t, i, n, a) {
      var o = i.element;
      if (o == null || n.name === o)
        return !0;
      for (; (n = n.__hostTarget || n.parent) && n !== this.group; )
        if (n.name === o)
          return !0;
      return !1;
    }, e.type = "custom", e;
  }($t)
);
const ATe = RTe;
function sx(r) {
  var e = r.type, t;
  if (e === "path") {
    var i = r.shape, n = i.width != null && i.height != null ? {
      x: i.x || 0,
      y: i.y || 0,
      width: i.width,
      height: i.height
    } : null, a = pZ(i);
    t = bT(a, null, n, i.layout || "center"), Jo(t).customPathData = a;
  } else if (e === "image")
    t = new ni({}), Jo(t).customImagePath = r.style.image;
  else if (e === "text")
    t = new dt({});
  else if (e === "group")
    t = new Re();
  else {
    if (e === "compoundPath")
      throw new Error('"compoundPath" is not supported yet.');
    var o = j1(e);
    if (!o) {
      var s = "";
      ({}).NODE_ENV !== "production" && (s = 'graphic type "' + e + '" can not be found.'), St(s);
    }
    t = new o();
  }
  return Jo(t).customGraphicType = e, t.name = r.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t;
}
function lx(r, e, t, i, n, a, o) {
  hZ(e);
  var s = n && n.normal.cfg;
  s && e.setTextConfig(s), i && i.transition == null && (i.transition = STe);
  var l = i && i.style;
  if (l) {
    if (e.type === "text") {
      var u = l;
      le(u, "textFill") && (u.fill = u.textFill), le(u, "textStroke") && (u.stroke = u.textStroke);
    }
    var c = void 0, h = $b(e) ? l.decal : null;
    r && h && (h.dirty = !0, c = xf(h, r)), l.__decalPattern = c;
  }
  if (qC(e) && l) {
    var c = l.__decalPattern;
    c && (l.decal = c);
  }
  aE(e, i, a, {
    dataIndex: t,
    isInit: o,
    clearStyle: !0
  }), Ub(e, i.keyframeAnimation, a);
}
function fZ(r, e, t, i, n) {
  var a = e.isGroup ? null : e, o = n && n[r].cfg;
  if (a) {
    var s = a.ensureState(r);
    if (i === !1) {
      var l = a.getState(r);
      l && (l.style = null);
    } else
      s.style = i || null;
    o && (s.textConfig = o), xc(a);
  }
}
function _Te(r, e, t) {
  if (!r.isGroup) {
    var i = r, n = t.currentZ, a = t.currentZLevel;
    i.z = n, i.zlevel = a;
    var o = e.z2;
    o != null && (i.z2 = o || 0);
    for (var s = 0; s < kl.length; s++)
      CTe(i, e, kl[s]);
  }
}
function CTe(r, e, t) {
  var i = t === al, n = i ? e : Vb(e, t), a = n ? n.z2 : null, o;
  a != null && (o = i ? r : r.ensureState(t), o.z2 = a || 0);
}
function IU(r, e, t, i) {
  var n = r.get("renderItem"), a = r.coordinateSystem, o = {};
  a && ({}.NODE_ENV !== "production" && (Se(n, "series.render is required."), Se(a.prepareCustoms || CU[a.type], "This coordSys does not support custom series.")), o = a.prepareCustoms ? a.prepareCustoms(a) : CU[a.type](a));
  for (var s = Te({
    getWidth: i.getWidth,
    getHeight: i.getHeight,
    getZr: i.getZr,
    getDevicePixelRatio: i.getDevicePixelRatio,
    value: b,
    style: T,
    ordinalRawValue: S,
    styleEmphasis: y,
    visual: C,
    barLayout: I,
    currentSeriesIndices: w,
    font: x
  }, o.api || {}), l = {
    // The life cycle of context: current round of rendering.
    // The global life cycle is probably not necessary, because
    // user can store global status by themselves.
    context: {},
    seriesId: r.id,
    seriesName: r.name,
    seriesIndex: r.seriesIndex,
    coordSys: o.coordSys,
    dataInsideLength: e.count(),
    encode: ITe(r.getData())
  }, u, c, h = {}, f = {}, d = {}, p = {}, g = 0; g < kl.length; g++) {
    var v = kl[g];
    d[v] = r.getModel($R[v]), p[v] = r.getModel(VR[v]);
  }
  function O(P) {
    return P === u ? c || (c = e.getItemModel(P)) : e.getItemModel(P);
  }
  function m(P, L) {
    return e.hasItemOption ? P === u ? h[L] || (h[L] = O(P).getModel($R[L])) : O(P).getModel($R[L]) : d[L];
  }
  function E(P, L) {
    return e.hasItemOption ? P === u ? f[L] || (f[L] = O(P).getModel(VR[L])) : O(P).getModel(VR[L]) : p[L];
  }
  return function(P, L) {
    return u = P, c = null, h = {}, f = {}, n && n(Te({
      dataIndexInside: P,
      dataIndex: e.getRawIndex(P),
      // Can be used for optimization when zoom or roam.
      actionType: L ? L.type : null
    }, l), s);
  };
  function b(P, L) {
    return L == null && (L = u), e.getStore().get(e.getDimensionIndex(P || 0), L);
  }
  function S(P, L) {
    L == null && (L = u), P = P || 0;
    var D = e.getDimensionInfo(P);
    if (!D) {
      var U = e.getDimensionIndex(P);
      return U >= 0 ? e.getStore().get(U, L) : void 0;
    }
    var Q = e.get(D.name, L), V = D && D.ordinalMeta;
    return V ? V.categories[Q] : Q;
  }
  function T(P, L) {
    ({}).NODE_ENV !== "production" && TU("api.style", "Please write literal style directly instead."), L == null && (L = u);
    var D = e.getItemVisual(L, "style"), U = D && D.fill, Q = D && D.opacity, V = m(L, al).getItemStyle();
    U != null && (V.fill = U), Q != null && (V.opacity = Q);
    var F = {
      inheritColor: ne(U) ? U : "#000"
    }, j = E(L, al), ae = Qt(j, null, F, !1, !0);
    ae.text = j.getShallow("show") ? ke(r.getFormattedLabel(L, al), Lf(e, L)) : null;
    var ce = cb(j, F, !1);
    return _(P, V), V = bU(V, ae, ce), P && R(V, P), V.legacy = !0, V;
  }
  function y(P, L) {
    ({}).NODE_ENV !== "production" && TU("api.styleEmphasis", "Please write literal style directly instead."), L == null && (L = u);
    var D = m(L, es).getItemStyle(), U = E(L, es), Q = Qt(U, null, null, !0, !0);
    Q.text = U.getShallow("show") ? Kn(r.getFormattedLabel(L, es), r.getFormattedLabel(L, al), Lf(e, L)) : null;
    var V = cb(U, null, !0);
    return _(P, D), D = bU(D, Q, V), P && R(D, P), D.legacy = !0, D;
  }
  function R(P, L) {
    for (var D in L)
      le(L, D) && (P[D] = L[D]);
  }
  function _(P, L) {
    P && (P.textFill && (L.textFill = P.textFill), P.textPosition && (L.textPosition = P.textPosition));
  }
  function C(P, L) {
    if (L == null && (L = u), le(OU, P)) {
      var D = e.getItemVisual(L, "style");
      return D ? D[OU[P]] : null;
    }
    if (le(JSe, P))
      return e.getItemVisual(L, P);
  }
  function I(P) {
    if (a.type === "cartesian2d") {
      var L = a.getBaseAxis();
      return xhe(Te({
        axis: L
      }, P));
    }
  }
  function w() {
    return t.getCurrentSeriesIndices();
  }
  function x(P) {
    return ZH(P, t);
  }
}
function ITe(r) {
  var e = {};
  return N(r.dimensions, function(t) {
    var i = r.getDimensionInfo(t);
    if (!i.isExtraCoord) {
      var n = i.coordDim, a = e[n] = e[n] || [];
      a[i.coordDimIndex] = r.getDimensionIndex(t);
    }
  }), e;
}
function GR(r, e, t, i, n, a, o) {
  if (!i) {
    a.remove(e);
    return;
  }
  var s = ux(r, e, t, i, n, a);
  return s && o.setItemGraphicEl(t, s), s && qt(s, i.focus, i.blurScope, i.emphasisDisabled), s;
}
function ux(r, e, t, i, n, a) {
  ({}).NODE_ENV !== "production" && Se(i, "should not have an null/undefined element setting");
  var o = -1, s = e;
  e && dZ(e, i, n) && (o = Fe(a.childrenRef(), e), e = null);
  var l = !e, u = e;
  u ? u.clearStates() : (u = sx(i), s && yTe(s, u)), i.morph === !1 ? u.disableMorphing = !0 : u.disableMorphing && (u.disableMorphing = !1), Dn.normal.cfg = Dn.normal.conOpt = Dn.emphasis.cfg = Dn.emphasis.conOpt = Dn.blur.cfg = Dn.blur.conOpt = Dn.select.cfg = Dn.select.conOpt = null, Dn.isLegacy = !1, NTe(u, t, i, n, l, Dn), wTe(u, t, i, n, l), lx(r, u, t, i, Dn, n, l), le(i, "info") && (Jo(u).info = i.info);
  for (var c = 0; c < kl.length; c++) {
    var h = kl[c];
    if (h !== al) {
      var f = Vb(i, h), d = cx(i, f, h);
      fZ(h, u, f, d, Dn);
    }
  }
  return _Te(u, i, n), i.type === "group" && xTe(r, u, t, i, n), o >= 0 ? a.replaceAt(u, o) : a.add(u), u;
}
function dZ(r, e, t) {
  var i = Jo(r), n = e.type, a = e.shape, o = e.style;
  return (
    // Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
    t.isUniversalTransitionEnabled() || n != null && n !== i.customGraphicType || n === "path" && MTe(a) && pZ(a) !== i.customPathData || n === "image" && le(o, "image") && o.image !== i.customImagePath
  );
}
function wTe(r, e, t, i, n) {
  var a = t.clipPath;
  if (a === !1)
    r && r.getClipPath() && r.removeClipPath();
  else if (a) {
    var o = r.getClipPath();
    o && dZ(o, a, i) && (o = null), o || (o = sx(a), {}.NODE_ENV !== "production" && Se($b(o), "Only any type of `path` can be used in `clipPath`, rather than " + o.type + "."), r.setClipPath(o)), lx(null, o, e, a, null, i, n);
  }
}
function NTe(r, e, t, i, n, a) {
  if (!r.isGroup) {
    wU(t, null, a), wU(t, es, a);
    var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, u = a.select.conOpt;
    if (o != null || s != null || u != null || l != null) {
      var c = r.getTextContent();
      if (o === !1)
        c && r.removeTextContent();
      else {
        o = a.normal.conOpt = o || {
          type: "text"
        }, c ? c.clearStates() : (c = sx(o), r.setTextContent(c)), lx(null, c, e, o, null, i, n);
        for (var h = o && o.style, f = 0; f < kl.length; f++) {
          var d = kl[f];
          if (d !== al) {
            var p = a[d].conOpt;
            fZ(d, c, p, cx(o, p, d), null);
          }
        }
        h ? c.dirty() : c.markRedraw();
      }
    }
  }
}
function wU(r, e, t) {
  var i = e ? Vb(r, e) : r, n = e ? cx(r, i, es) : r.style, a = r.type, o = i ? i.textConfig : null, s = r.textContent, l = s ? e ? Vb(s, e) : s : null;
  if (n && // Because emphasis style has little info to detect legacy,
  // if normal is legacy, emphasis is trade as legacy.
  (t.isLegacy || aZ(n, a, !!o, !!l))) {
    t.isLegacy = !0;
    var u = oZ(n, a, !e);
    !o && u.textConfig && (o = u.textConfig), !l && u.textContent && (l = u.textContent);
  }
  if (!e && l) {
    var c = l;
    !c.type && (c.type = "text"), {}.NODE_ENV !== "production" && Se(c.type === "text", 'textContent.type must be "text"');
  }
  var h = e ? t[e] : t.normal;
  h.cfg = o, h.conOpt = l;
}
function Vb(r, e) {
  return e ? r ? r[e] : null : r;
}
function cx(r, e, t) {
  var i = e && e.style;
  return i == null && t === es && r && (i = r.styleEmphasis), i;
}
function xTe(r, e, t, i, n) {
  var a = i.children, o = a ? a.length : 0, s = i.$mergeChildren, l = s === "byName" || i.diffChildrenByName, u = s === !1;
  if (!(!o && !l && !u)) {
    if (l) {
      LTe({
        api: r,
        oldChildren: e.children() || [],
        newChildren: a || [],
        dataIndex: t,
        seriesModel: n,
        group: e
      });
      return;
    }
    u && e.removeAll();
    for (var c = 0; c < o; c++) {
      var h = a[c], f = e.childAt(c);
      h ? (h.ignore == null && (h.ignore = !1), ux(r, f, t, h, n, e)) : ({}.NODE_ENV !== "production" && Se(f, "renderItem should not return a group containing elements as null/undefined/{} if they do not exist before."), f.ignore = !0);
    }
    for (var d = e.childCount() - 1; d >= c; d--) {
      var p = e.childAt(d);
      PTe(e, p, n);
    }
  }
}
function PTe(r, e, t) {
  e && XT(e, Jo(r).option, t);
}
function LTe(r) {
  new cs(r.oldChildren, r.newChildren, NU, NU, r).add(xU).update(xU).remove(DTe).execute();
}
function NU(r, e) {
  var t = r && r.name;
  return t ?? TTe + e;
}
function xU(r, e) {
  var t = this.context, i = r != null ? t.newChildren[r] : null, n = e != null ? t.oldChildren[e] : null;
  ux(t.api, n, t.dataIndex, i, t.seriesModel, t.group);
}
function DTe(r) {
  var e = this.context, t = e.oldChildren[r];
  t && XT(t, Jo(t).option, e.seriesModel);
}
function pZ(r) {
  return r && (r.pathData || r.d);
}
function MTe(r) {
  return r && (le(r, "pathData") || le(r, "d"));
}
function kTe(r) {
  r.registerChartView(ATe), r.registerSeriesModel(tTe);
}
var $u = ft(), PU = ye, BR = ue, QTe = (
  /** @class */
  function() {
    function r() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return r.prototype.render = function(e, t, i, n) {
      var a = t.get("value"), o = t.get("status");
      if (this._axisModel = e, this._axisPointerModel = t, this._api = i, !(!n && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, e, t, i);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(e, t);
        if (!s)
          s = this._group = new Re(), this.createPointerEl(s, u, e, t), this.createLabelEl(s, u, e, t), i.getZr().add(s);
        else {
          var f = Le(LU, t, h);
          this.updatePointerEl(s, u, f), this.updateLabelEl(s, u, f, t);
        }
        MU(s, t, !0), this._renderHandle(a);
      }
    }, r.prototype.remove = function(e) {
      this.clear(e);
    }, r.prototype.dispose = function(e) {
      this.clear(e);
    }, r.prototype.determineAnimation = function(e, t) {
      var i = t.get("animation"), n = e.axis, a = n.type === "category", o = t.get("snap");
      if (!o && !a)
        return !1;
      if (i === "auto" || i == null) {
        var s = this.animationThreshold;
        if (a && n.getBandWidth() > s)
          return !0;
        if (o) {
          var l = DN(e).seriesDataCount, u = n.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return i === !0;
    }, r.prototype.makeElOption = function(e, t, i, n, a) {
    }, r.prototype.createPointerEl = function(e, t, i, n) {
      var a = t.pointer;
      if (a) {
        var o = $u(e).pointerEl = new wv[a.type](PU(t.pointer));
        e.add(o);
      }
    }, r.prototype.createLabelEl = function(e, t, i, n) {
      if (t.label) {
        var a = $u(e).labelEl = new dt(PU(t.label));
        e.add(a), DU(a, n);
      }
    }, r.prototype.updatePointerEl = function(e, t, i) {
      var n = $u(e).pointerEl;
      n && t.pointer && (n.setStyle(t.pointer.style), i(n, {
        shape: t.pointer.shape
      }));
    }, r.prototype.updateLabelEl = function(e, t, i, n) {
      var a = $u(e).labelEl;
      a && (a.setStyle(t.label.style), i(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: t.label.x,
        y: t.label.y
      }), DU(a, n));
    }, r.prototype._renderHandle = function(e) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var t = this._axisPointerModel, i = this._api.getZr(), n = this._handle, a = t.getModel("handle"), o = t.get("status");
        if (!a.get("show") || !o || o === "hide") {
          n && i.remove(n), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, n = this._handle = Iv(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            os(u.event);
          },
          onmousedown: BR(this._onHandleDragMove, this, 0, 0),
          drift: BR(this._onHandleDragMove, this),
          ondragend: BR(this._onHandleDragEnd, this)
        }), i.add(n)), MU(n, t, !1), n.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        X(l) || (l = [l, l]), n.scaleX = l[0] / 2, n.scaleY = l[1] / 2, ud(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s);
      }
    }, r.prototype._moveHandleToValue = function(e, t) {
      LU(this._axisPointerModel, !t && this._moveAnimation, this._handle, FR(this.getHandleTransform(e, this._axisModel, this._axisPointerModel)));
    }, r.prototype._onHandleDragMove = function(e, t) {
      var i = this._handle;
      if (i) {
        this._dragging = !0;
        var n = this.updateHandleTransform(FR(i), [e, t], this._axisModel, this._axisPointerModel);
        this._payloadInfo = n, i.stopAnimation(), i.attr(FR(n)), $u(i).lastProp = null, this._doDispatchAxisPointer();
      }
    }, r.prototype._doDispatchAxisPointer = function() {
      var e = this._handle;
      if (e) {
        var t = this._payloadInfo, i = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: t.cursorPoint[0],
          y: t.cursorPoint[1],
          tooltipOption: t.tooltipOption,
          axesInfo: [{
            axisDim: i.axis.dim,
            axisIndex: i.componentIndex
          }]
        });
      }
    }, r.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var e = this._handle;
      if (e) {
        var t = this._axisPointerModel.get("value");
        this._moveHandleToValue(t), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, r.prototype.clear = function(e) {
      this._lastValue = null, this._lastStatus = null;
      var t = e.getZr(), i = this._group, n = this._handle;
      t && i && (this._lastGraphicKey = null, i && t.remove(i), n && t.remove(n), this._group = null, this._handle = null, this._payloadInfo = null), Qg(this, "_doDispatchAxisPointer");
    }, r.prototype.doClear = function() {
    }, r.prototype.buildLabel = function(e, t, i) {
      return i = i || 0, {
        x: e[i],
        y: e[1 - i],
        width: t[i],
        height: t[1 - i]
      };
    }, r;
  }()
);
function LU(r, e, t, i) {
  gZ($u(t).lastProp, i) || ($u(t).lastProp = i, e ? Ot(t, i, r) : (t.stopAnimation(), t.attr(i)));
}
function gZ(r, e) {
  if (be(r) && be(e)) {
    var t = !0;
    return N(e, function(i, n) {
      t = t && gZ(r[n], i);
    }), !!t;
  } else
    return r === e;
}
function DU(r, e) {
  r[e.get(["label", "show"]) ? "show" : "hide"]();
}
function FR(r) {
  return {
    x: r.x || 0,
    y: r.y || 0,
    rotation: r.rotation || 0
  };
}
function MU(r, e, t) {
  var i = e.get("z"), n = e.get("zlevel");
  r && r.traverse(function(a) {
    a.type !== "group" && (i != null && (a.z = i), n != null && (a.zlevel = n), a.silent = t);
  });
}
const hx = QTe;
function fx(r) {
  var e = r.get("type"), t = r.getModel(e + "Style"), i;
  return e === "line" ? (i = t.getLineStyle(), i.fill = null) : e === "shadow" && (i = t.getAreaStyle(), i.stroke = null), i;
}
function vZ(r, e, t, i, n) {
  var a = t.get("value"), o = OZ(a, e.axis, e.ecModel, t.get("seriesDataIndices"), {
    precision: t.get(["label", "precision"]),
    formatter: t.get(["label", "formatter"])
  }), s = t.getModel("label"), l = id(s.get("padding") || 0), u = s.getFont(), c = yv(o, u), h = n.position, f = c.width + l[1] + l[3], d = c.height + l[0] + l[2], p = n.align;
  p === "right" && (h[0] -= f), p === "center" && (h[0] -= f / 2);
  var g = n.verticalAlign;
  g === "bottom" && (h[1] -= d), g === "middle" && (h[1] -= d / 2), UTe(h, f, d, i);
  var v = s.get("backgroundColor");
  (!v || v === "auto") && (v = e.get(["axisLine", "lineStyle", "color"])), r.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: h[0],
    y: h[1],
    style: Qt(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: v
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function UTe(r, e, t, i) {
  var n = i.getWidth(), a = i.getHeight();
  r[0] = Math.min(r[0] + e, n) - e, r[1] = Math.min(r[1] + t, a) - t, r[0] = Math.max(r[0], 0), r[1] = Math.max(r[1], 0);
}
function OZ(r, e, t, i, n) {
  r = e.scale.parse(r);
  var a = e.scale.getLabel({
    value: r
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: n.precision
  }), o = n.formatter;
  if (o) {
    var s = {
      value: AN(e, {
        value: r
      }),
      axisDimension: e.dim,
      axisIndex: e.index,
      seriesData: []
    };
    N(i, function(l) {
      var u = t.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
      h && s.seriesData.push(h);
    }), ne(o) ? a = o.replace("{value}", a) : ve(o) && (a = o(s));
  }
  return a;
}
function dx(r, e, t) {
  var i = na();
  return zc(i, i, t.rotation), yo(i, i, t.position), Ia([r.dataToCoord(e), (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)], i);
}
function mZ(r, e, t, i, n, a) {
  var o = hs.innerTextLayout(t.rotation, 0, t.labelDirection);
  t.labelMargin = n.get(["label", "margin"]), vZ(e, i, n, a, {
    position: dx(i.axis, r, t),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function px(r, e, t) {
  return t = t || 0, {
    x1: r[t],
    y1: r[1 - t],
    x2: e[t],
    y2: e[1 - t]
  };
}
function EZ(r, e, t) {
  return t = t || 0, {
    x: r[t],
    y: r[1 - t],
    width: e[t],
    height: e[1 - t]
  };
}
function kU(r, e, t, i, n, a) {
  return {
    cx: r,
    cy: e,
    r0: t,
    r: i,
    startAngle: n,
    endAngle: a,
    clockwise: !0
  };
}
var $Te = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, i, n, a, o) {
      var s = n.axis, l = s.grid, u = a.get("type"), c = QU(l, s).getOtherAxis(s).getGlobalExtent(), h = s.toGlobalCoord(s.dataToCoord(i, !0));
      if (u && u !== "none") {
        var f = fx(a), d = VTe[u](s, h, c);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = LC(l.model, n);
      mZ(
        // @ts-ignore
        i,
        t,
        p,
        n,
        a,
        o
      );
    }, e.prototype.getHandleTransform = function(t, i, n) {
      var a = LC(i.axis.grid.model, i, {
        labelInside: !1
      });
      a.labelMargin = n.get(["handle", "margin"]);
      var o = dx(i.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, i, n, a) {
      var o = n.axis, s = o.grid, l = o.getGlobalExtent(!0), u = QU(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, h = [t.x, t.y];
      h[c] += i[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var f = (u[1] + u[0]) / 2, d = [f, f];
      d[c] = h[c];
      var p = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: h[0],
        y: h[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: p[c]
      };
    }, e;
  }(hx)
);
function QU(r, e) {
  var t = {};
  return t[e.dim + "AxisIndex"] = e.index, r.getCartesian(t);
}
var VTe = {
  line: function(r, e, t) {
    var i = px([e, t[0]], [e, t[1]], UU(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: i
    };
  },
  shadow: function(r, e, t) {
    var i = Math.max(1, r.getBandWidth()), n = t[1] - t[0];
    return {
      type: "Rect",
      shape: EZ([e - i / 2, t[0]], [i, n], UU(r))
    };
  }
};
function UU(r) {
  return r.dim === "x" ? 0 : 1;
}
const GTe = $Te;
var BTe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "axisPointer", e.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: "#B9BEC9",
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: "rgba(210,219,238,0.2)"
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: "#fff",
        padding: [5, 7, 5, 7],
        backgroundColor: "auto",
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: "#333",
        shadowBlur: 3,
        shadowColor: "#aaa",
        shadowOffsetX: 0,
        shadowOffsetY: 2,
        // For mobile performance
        throttle: 40
      }
    }, e;
  }(st)
);
const FTe = BTe;
var Wo = ft(), XTe = N;
function bZ(r, e, t) {
  if (!ct.node) {
    var i = e.getZr();
    Wo(i).records || (Wo(i).records = {}), YTe(i, e);
    var n = Wo(i).records[r] || (Wo(i).records[r] = {});
    n.handler = t;
  }
}
function YTe(r, e) {
  if (Wo(r).initialized)
    return;
  Wo(r).initialized = !0, t("click", Le($U, "click")), t("mousemove", Le($U, "mousemove")), t("globalout", WTe);
  function t(i, n) {
    r.on(i, function(a) {
      var o = zTe(e);
      XTe(Wo(r).records, function(s) {
        s && n(s, a, o.dispatchAction);
      }), HTe(o.pendings, e);
    });
  }
}
function HTe(r, e) {
  var t = r.showTip.length, i = r.hideTip.length, n;
  t ? n = r.showTip[t - 1] : i && (n = r.hideTip[i - 1]), n && (n.dispatchAction = null, e.dispatchAction(n));
}
function WTe(r, e, t) {
  r.handler("leave", null, t);
}
function $U(r, e, t, i) {
  e.handler(r, t, i);
}
function zTe(r) {
  var e = {
    showTip: [],
    hideTip: []
  }, t = function(i) {
    var n = e[i.type];
    n ? n.push(i) : (i.dispatchAction = t, r.dispatchAction(i));
  };
  return {
    dispatchAction: t,
    pendings: e
  };
}
function jC(r, e) {
  if (!ct.node) {
    var t = e.getZr(), i = (Wo(t).records || {})[r];
    i && (Wo(t).records[r] = null);
  }
}
var ZTe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = i.getComponent("tooltip"), o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      bZ("axisPointer", n, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, e.prototype.remove = function(t, i) {
      jC("axisPointer", i);
    }, e.prototype.dispose = function(t, i) {
      jC("axisPointer", i);
    }, e.type = "axisPointer", e;
  }(jt)
);
const qTe = ZTe;
function SZ(r, e) {
  var t = [], i = r.seriesIndex, n;
  if (i == null || !(n = e.getSeriesByIndex(i)))
    return {
      point: []
    };
  var a = n.getData(), o = wc(a, r);
  if (o == null || o < 0 || X(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = n.coordinateSystem;
  if (n.getTooltipPosition)
    t = n.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (r.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, f = u.dim, d = h === "x" || h === "radius" ? 1 : 0, p = a.mapDimension(f), g = [];
      g[d] = a.get(p, o), g[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), o), t = l.dataToPoint(g) || [];
    } else
      t = l.dataToPoint(a.getValues(Y(l.dimensions, function(O) {
        return a.mapDimension(O);
      }), o)) || [];
  else if (s) {
    var v = s.getBoundingRect().clone();
    v.applyTransform(s.transform), t = [v.x + v.width / 2, v.y + v.height / 2];
  }
  return {
    point: t,
    el: s
  };
}
var VU = ft();
function jTe(r, e, t) {
  var i = r.currTrigger, n = [r.x, r.y], a = r, o = r.dispatchAction || ue(t.dispatchAction, t), s = e.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    oE(n) && (n = SZ({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, e).point);
    var l = oE(n), u = a.axesInfo, c = s.axesInfo, h = i === "leave" || oE(n), f = {}, d = {}, p = {
      list: [],
      map: {}
    }, g = {
      showPointer: Le(JTe, d),
      showTooltip: Le(eye, p)
    };
    N(s.coordSysMap, function(O, m) {
      var E = l || O.containPoint(n);
      N(s.coordSysAxesInfo[m], function(b, S) {
        var T = b.axis, y = nye(u, b);
        if (!h && E && (!u || y)) {
          var R = y && y.value;
          R == null && !l && (R = T.pointToData(n)), R != null && GU(b, R, g, !1, f);
        }
      });
    });
    var v = {};
    return N(c, function(O, m) {
      var E = O.linkGroup;
      E && !d[m] && N(E.axesInfo, function(b, S) {
        var T = d[S];
        if (b !== O && T) {
          var y = T.value;
          E.mapper && (y = O.axis.scale.parse(E.mapper(y, BU(b), BU(O)))), v[O.key] = y;
        }
      });
    }), N(v, function(O, m) {
      GU(c[m], O, g, !0, f);
    }), tye(d, c, f), rye(p, n, r, o), iye(c, o, t), f;
  }
}
function GU(r, e, t, i, n) {
  var a = r.axis;
  if (!(a.scale.isBlank() || !a.containData(e))) {
    if (!r.involveSeries) {
      t.showPointer(r, e);
      return;
    }
    var o = KTe(e, r), s = o.payloadBatch, l = o.snapToValue;
    s[0] && n.seriesIndex == null && B(n, s[0]), !i && r.snap && a.containData(l) && l != null && (e = l), t.showPointer(r, e, s), t.showTooltip(r, o, l);
  }
}
function KTe(r, e) {
  var t = e.axis, i = t.dim, n = r, a = [], o = Number.MAX_VALUE, s = -1;
  return N(e.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(i), h, f;
    if (l.getAxisTooltipData) {
      var d = l.getAxisTooltipData(c, r, t);
      f = d.dataIndices, h = d.nestestValue;
    } else {
      if (f = l.getData().indicesOfNearest(
        c[0],
        r,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        t.type === "category" ? 0.5 : null
      ), !f.length)
        return;
      h = l.getData().get(c[0], f[0]);
    }
    if (!(h == null || !isFinite(h))) {
      var p = r - h, g = Math.abs(p);
      g <= o && ((g < o || p >= 0 && s < 0) && (o = g, s = p, n = h, a.length = 0), N(f, function(v) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: v,
          dataIndex: l.getData().getRawIndex(v)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: n
  };
}
function JTe(r, e, t, i) {
  r[e.key] = {
    value: t,
    payloadBatch: i
  };
}
function eye(r, e, t, i) {
  var n = t.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel;
  if (!(!e.triggerTooltip || !n.length)) {
    var l = e.coordSys.model, u = Fg(l), c = r.map[u];
    c || (c = r.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, r.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: i,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: n.slice()
    });
  }
}
function tye(r, e, t) {
  var i = t.axesInfo = [];
  N(e, function(n, a) {
    var o = n.axisPointerModel.option, s = r[a];
    s ? (!n.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !n.useHandle && (o.status = "hide"), o.status === "show" && i.push({
      axisDim: n.axis.dim,
      axisIndex: n.axis.model.componentIndex,
      value: o.value
    });
  });
}
function rye(r, e, t, i) {
  if (oE(e) || !r.list.length) {
    i({
      type: "hideTip"
    });
    return;
  }
  var n = ((r.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  i({
    type: "showTip",
    escapeConnect: !0,
    x: e[0],
    y: e[1],
    tooltipOption: t.tooltipOption,
    position: t.position,
    dataIndexInside: n.dataIndexInside,
    dataIndex: n.dataIndex,
    seriesIndex: n.seriesIndex,
    dataByCoordSys: r.list
  });
}
function iye(r, e, t) {
  var i = t.getZr(), n = "axisPointerLastHighlights", a = VU(i)[n] || {}, o = VU(i)[n] = {};
  N(r, function(u, c) {
    var h = u.axisPointerModel.option;
    h.status === "show" && u.triggerEmphasis && N(h.seriesDataIndices, function(f) {
      var d = f.seriesIndex + " | " + f.dataIndex;
      o[d] = f;
    });
  });
  var s = [], l = [];
  N(a, function(u, c) {
    !o[c] && l.push(u);
  }), N(o, function(u, c) {
    !a[c] && s.push(u);
  }), l.length && t.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && t.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function nye(r, e) {
  for (var t = 0; t < (r || []).length; t++) {
    var i = r[t];
    if (e.axis.dim === i.axisDim && e.axis.model.componentIndex === i.axisIndex)
      return i;
  }
}
function BU(r) {
  var e = r.axis.model, t = {}, i = t.axisDim = r.axis.dim;
  return t.axisIndex = t[i + "AxisIndex"] = e.componentIndex, t.axisName = t[i + "AxisName"] = e.name, t.axisId = t[i + "AxisId"] = e.id, t;
}
function oE(r) {
  return !r || r[0] == null || isNaN(r[0]) || r[1] == null || isNaN(r[1]);
}
function Gv(r) {
  Jc.registerAxisPointerClass("CartesianAxisPointer", GTe), r.registerComponentModel(FTe), r.registerComponentView(qTe), r.registerPreprocessor(function(e) {
    if (e) {
      (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {});
      var t = e.axisPointer.link;
      t && !X(t) && (e.axisPointer.link = [t]);
    }
  }), r.registerProcessor(r.PRIORITY.PROCESSOR.STATISTIC, function(e, t) {
    e.getComponent("axisPointer").coordSysAxesInfo = Hpe(e, t);
  }), r.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, jTe);
}
function aye(r) {
  Ye(H3), Ye(Gv);
}
var oye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, i, n, a, o) {
      var s = n.axis;
      s.dim === "angle" && (this.animationThreshold = Math.PI / 18);
      var l = s.polar, u = l.getOtherAxis(s), c = u.getExtent(), h = s.dataToCoord(i), f = a.get("type");
      if (f && f !== "none") {
        var d = fx(a), p = lye[f](s, l, h, c);
        p.style = d, t.graphicKey = p.type, t.pointer = p;
      }
      var g = a.get(["label", "margin"]), v = sye(i, n, a, l, g);
      vZ(t, n, a, o, v);
    }, e;
  }(hx)
);
function sye(r, e, t, i, n) {
  var a = e.axis, o = a.dataToCoord(r), s = i.getAngleAxis().getExtent()[0];
  s = s / 180 * Math.PI;
  var l = i.getRadiusAxis().getExtent(), u, c, h;
  if (a.dim === "radius") {
    var f = na();
    zc(f, f, s), yo(f, f, [i.cx, i.cy]), u = Ia([o, -n], f);
    var d = e.getModel("axisLabel").get("rotate") || 0, p = hs.innerTextLayout(s, d * Math.PI / 180, -1);
    c = p.textAlign, h = p.textVerticalAlign;
  } else {
    var g = l[1];
    u = i.coordToPoint([g + n, o]);
    var v = i.cx, O = i.cy;
    c = Math.abs(u[0] - v) / g < 0.3 ? "center" : u[0] > v ? "left" : "right", h = Math.abs(u[1] - O) / g < 0.3 ? "middle" : u[1] > O ? "top" : "bottom";
  }
  return {
    position: u,
    align: c,
    verticalAlign: h
  };
}
var lye = {
  line: function(r, e, t, i) {
    return r.dim === "angle" ? {
      type: "Line",
      shape: px(e.coordToPoint([i[0], t]), e.coordToPoint([i[1], t]))
    } : {
      type: "Circle",
      shape: {
        cx: e.cx,
        cy: e.cy,
        r: t
      }
    };
  },
  shadow: function(r, e, t, i) {
    var n = Math.max(1, r.getBandWidth()), a = Math.PI / 180;
    return r.dim === "angle" ? {
      type: "Sector",
      shape: kU(
        e.cx,
        e.cy,
        i[0],
        i[1],
        // In ECharts y is negative if angle is positive
        (-t - n / 2) * a,
        (-t + n / 2) * a
      )
    } : {
      type: "Sector",
      shape: kU(e.cx, e.cy, t - n / 2, t + n / 2, 0, Math.PI * 2)
    };
  }
};
const uye = oye;
var cye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.findAxisModel = function(t) {
      var i, n = this.ecModel;
      return n.eachComponent(t, function(a) {
        a.getCoordSysModel() === this && (i = a);
      }, this), i;
    }, e.type = "polar", e.dependencies = ["radiusAxis", "angleAxis"], e.defaultOption = {
      // zlevel: 0,
      z: 0,
      center: ["50%", "50%"],
      radius: "80%"
    }, e;
  }(st)
);
const hye = cye;
var gx = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getCoordSysModel = function() {
      return this.getReferringComponents("polar", Or).models[0];
    }, e.type = "polarAxis", e;
  }(st)
);
br(gx, Lv);
var fye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "angleAxis", e;
  }(gx)
), dye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "radiusAxis", e;
  }(gx)
), vx = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i) {
      return r.call(this, "radius", t, i) || this;
    }
    return e.prototype.pointToData = function(t, i) {
      return this.polar.pointToData(t, i)[this.dim === "radius" ? 0 : 1];
    }, e;
  }(Ma)
);
vx.prototype.dataToRadius = Ma.prototype.dataToCoord;
vx.prototype.radiusToData = Ma.prototype.coordToData;
const pye = vx;
var gye = ft(), Ox = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i) {
      return r.call(this, "angle", t, i || [0, 360]) || this;
    }
    return e.prototype.pointToData = function(t, i) {
      return this.polar.pointToData(t, i)[this.dim === "radius" ? 0 : 1];
    }, e.prototype.calculateCategoryInterval = function() {
      var t = this, i = t.getLabelModel(), n = t.scale, a = n.getExtent(), o = n.count();
      if (a[1] - a[0] < 1)
        return 0;
      var s = a[0], l = t.dataToCoord(s + 1) - t.dataToCoord(s), u = Math.abs(l), c = yv(s == null ? "" : s + "", i.getFont(), "center", "top"), h = Math.max(c.height, 7), f = h / u;
      isNaN(f) && (f = 1 / 0);
      var d = Math.max(0, Math.floor(f)), p = gye(t.model), g = p.lastAutoInterval, v = p.lastTickCount;
      return g != null && v != null && Math.abs(g - d) <= 1 && Math.abs(v - o) <= 1 && g > d ? d = g : (p.lastTickCount = o, p.lastAutoInterval = d), d;
    }, e;
  }(Ma)
);
Ox.prototype.dataToAngle = Ma.prototype.dataToCoord;
Ox.prototype.angleToData = Ma.prototype.coordToData;
const vye = Ox;
var TZ = ["radius", "angle"], Oye = (
  /** @class */
  function() {
    function r(e) {
      this.dimensions = TZ, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new pye(), this._angleAxis = new vye(), this.axisPointerEnabled = !0, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this;
    }
    return r.prototype.containPoint = function(e) {
      var t = this.pointToCoord(e);
      return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1]);
    }, r.prototype.containData = function(e) {
      return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]);
    }, r.prototype.getAxis = function(e) {
      var t = "_" + e + "Axis";
      return this[t];
    }, r.prototype.getAxes = function() {
      return [this._radiusAxis, this._angleAxis];
    }, r.prototype.getAxesByScale = function(e) {
      var t = [], i = this._angleAxis, n = this._radiusAxis;
      return i.scale.type === e && t.push(i), n.scale.type === e && t.push(n), t;
    }, r.prototype.getAngleAxis = function() {
      return this._angleAxis;
    }, r.prototype.getRadiusAxis = function() {
      return this._radiusAxis;
    }, r.prototype.getOtherAxis = function(e) {
      var t = this._angleAxis;
      return e === t ? this._radiusAxis : t;
    }, r.prototype.getBaseAxis = function() {
      return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis();
    }, r.prototype.getTooltipAxes = function(e) {
      var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis();
      return {
        baseAxes: [t],
        otherAxes: [this.getOtherAxis(t)]
      };
    }, r.prototype.dataToPoint = function(e, t) {
      return this.coordToPoint([this._radiusAxis.dataToRadius(e[0], t), this._angleAxis.dataToAngle(e[1], t)]);
    }, r.prototype.pointToData = function(e, t) {
      var i = this.pointToCoord(e);
      return [this._radiusAxis.radiusToData(i[0], t), this._angleAxis.angleToData(i[1], t)];
    }, r.prototype.pointToCoord = function(e) {
      var t = e[0] - this.cx, i = e[1] - this.cy, n = this.getAngleAxis(), a = n.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]);
      n.inverse ? o = s - 360 : s = o + 360;
      var l = Math.sqrt(t * t + i * i);
      t /= l, i /= l;
      for (var u = Math.atan2(-i, t) / Math.PI * 180, c = u < o ? 1 : -1; u < o || u > s; )
        u += c * 360;
      return [l, u];
    }, r.prototype.coordToPoint = function(e) {
      var t = e[0], i = e[1] / 180 * Math.PI, n = Math.cos(i) * t + this.cx, a = -Math.sin(i) * t + this.cy;
      return [n, a];
    }, r.prototype.getArea = function() {
      var e = this.getAngleAxis(), t = this.getRadiusAxis(), i = t.getExtent().slice();
      i[0] > i[1] && i.reverse();
      var n = e.getExtent(), a = Math.PI / 180;
      return {
        cx: this.cx,
        cy: this.cy,
        r0: i[0],
        r: i[1],
        startAngle: -n[0] * a,
        endAngle: -n[1] * a,
        clockwise: e.inverse,
        contain: function(o, s) {
          var l = o - this.cx, u = s - this.cy, c = l * l + u * u - 1e-4, h = this.r, f = this.r0;
          return c <= h * h && c >= f * f;
        }
      };
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = FU(t);
      return n === this ? this.dataToPoint(i) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = FU(t);
      return n === this ? this.pointToData(i) : null;
    }, r;
  }()
);
function FU(r) {
  var e = r.seriesModel, t = r.polarModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
const mye = Oye;
function Eye(r, e, t) {
  var i = e.get("center"), n = t.getWidth(), a = t.getHeight();
  r.cx = K(i[0], n), r.cy = K(i[1], a);
  var o = r.getRadiusAxis(), s = Math.min(n, a) / 2, l = e.get("radius");
  l == null ? l = [0, "100%"] : X(l) || (l = [0, l]);
  var u = [K(l[0], s), K(l[1], s)];
  o.inverse ? o.setExtent(u[1], u[0]) : o.setExtent(u[0], u[1]);
}
function bye(r, e) {
  var t = this, i = t.getAngleAxis(), n = t.getRadiusAxis();
  if (i.scale.setExtent(1 / 0, -1 / 0), n.scale.setExtent(1 / 0, -1 / 0), r.eachSeries(function(s) {
    if (s.coordinateSystem === t) {
      var l = s.getData();
      N(Rb(l, "radius"), function(u) {
        n.scale.unionExtentFromData(l, u);
      }), N(Rb(l, "angle"), function(u) {
        i.scale.unionExtentFromData(l, u);
      });
    }
  }), Pf(i.scale, i.model), Pf(n.scale, n.model), i.type === "category" && !i.onBand) {
    var a = i.getExtent(), o = 360 / i.scale.count();
    i.inverse ? a[1] += o : a[1] -= o, i.setExtent(a[0], a[1]);
  }
}
function Sye(r) {
  return r.mainType === "angleAxis";
}
function XU(r, e) {
  if (r.type = e.get("type"), r.scale = kT(e), r.onBand = e.get("boundaryGap") && r.type === "category", r.inverse = e.get("inverse"), Sye(e)) {
    r.inverse = r.inverse !== e.get("clockwise");
    var t = e.get("startAngle");
    r.setExtent(t, t + (r.inverse ? -360 : 360));
  }
  e.axis = r, r.model = e;
}
var Tye = {
  dimensions: TZ,
  create: function(r, e) {
    var t = [];
    return r.eachComponent("polar", function(i, n) {
      var a = new mye(n + "");
      a.update = bye;
      var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = i.findAxisModel("radiusAxis"), u = i.findAxisModel("angleAxis");
      XU(o, l), XU(s, u), Eye(a, i, e), t.push(a), i.coordinateSystem = a, a.model = i;
    }), r.eachSeries(function(i) {
      if (i.get("coordinateSystem") === "polar") {
        var n = i.getReferringComponents("polar", Or).models[0];
        if ({}.NODE_ENV !== "production" && !n)
          throw new Error('Polar "' + vr(i.get("polarIndex"), i.get("polarId"), 0) + '" not found');
        i.coordinateSystem = n.coordinateSystem;
      }
    }), t;
  }
};
const yye = Tye;
var Rye = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"];
function sm(r, e, t) {
  e[1] > e[0] && (e = e.slice().reverse());
  var i = r.coordToPoint([e[0], t]), n = r.coordToPoint([e[1], t]);
  return {
    x1: i[0],
    y1: i[1],
    x2: n[0],
    y2: n[1]
  };
}
function lm(r) {
  var e = r.getRadiusAxis();
  return e.inverse ? 0 : 1;
}
function YU(r) {
  var e = r[0], t = r[r.length - 1];
  e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && r.pop();
}
var Aye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var n = t.axis, a = n.polar, o = a.getRadiusAxis().getExtent(), s = n.getTicksCoords(), l = n.getMinorTicksCoords(), u = Y(n.getViewLabels(), function(c) {
          c = ye(c);
          var h = n.scale, f = h.type === "ordinal" ? h.getRawOrdinalNumber(c.tickValue) : c.tickValue;
          return c.coord = n.dataToCoord(f), c;
        });
        YU(u), YU(s), N(Rye, function(c) {
          t.get([c, "show"]) && (!n.scale.isBlank() || c === "axisLine") && _ye[c](this.group, t, a, s, l, o, u);
        }, this);
      }
    }, e.type = "angleAxis", e;
  }(Jc)
), _ye = {
  axisLine: function(r, e, t, i, n, a) {
    var o = e.getModel(["axisLine", "lineStyle"]), s = lm(t), l = s ? 0 : 1, u;
    a[l] === 0 ? u = new Co({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: a[s]
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }) : u = new mT({
      shape: {
        cx: t.cx,
        cy: t.cy,
        r: a[s],
        r0: a[l]
      },
      style: o.getLineStyle(),
      z2: 1,
      silent: !0
    }), u.style.fill = null, r.add(u);
  },
  axisTick: function(r, e, t, i, n, a) {
    var o = e.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[lm(t)], u = Y(i, function(c) {
      return new Gr({
        shape: sm(t, [l, l + s], c.coord)
      });
    });
    r.add(Xn(u, {
      style: Te(o.getModel("lineStyle").getLineStyle(), {
        stroke: e.get(["axisLine", "lineStyle", "color"])
      })
    }));
  },
  minorTick: function(r, e, t, i, n, a) {
    if (n.length) {
      for (var o = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), u = a[lm(t)], c = [], h = 0; h < n.length; h++)
        for (var f = 0; f < n[h].length; f++)
          c.push(new Gr({
            shape: sm(t, [u, u + l], n[h][f].coord)
          }));
      r.add(Xn(c, {
        style: Te(s.getModel("lineStyle").getLineStyle(), Te(o.getLineStyle(), {
          stroke: e.get(["axisLine", "lineStyle", "color"])
        }))
      }));
    }
  },
  axisLabel: function(r, e, t, i, n, a, o) {
    var s = e.getCategories(!0), l = e.getModel("axisLabel"), u = l.get("margin"), c = e.get("triggerEvent");
    N(o, function(h, f) {
      var d = l, p = h.tickValue, g = a[lm(t)], v = t.coordToPoint([g + u, h.coord]), O = t.cx, m = t.cy, E = Math.abs(v[0] - O) / g < 0.3 ? "center" : v[0] > O ? "left" : "right", b = Math.abs(v[1] - m) / g < 0.3 ? "middle" : v[1] > m ? "top" : "bottom";
      if (s && s[p]) {
        var S = s[p];
        be(S) && S.textStyle && (d = new Ut(S.textStyle, l, l.ecModel));
      }
      var T = new dt({
        silent: hs.isLabelSilent(e),
        style: Qt(d, {
          x: v[0],
          y: v[1],
          fill: d.getTextColor() || e.get(["axisLine", "lineStyle", "color"]),
          text: h.formattedLabel,
          align: E,
          verticalAlign: b
        })
      });
      if (r.add(T), c) {
        var y = hs.makeAxisEventDataBase(e);
        y.targetType = "axisLabel", y.value = h.rawLabel, Pe(T).eventData = y;
      }
    }, this);
  },
  splitLine: function(r, e, t, i, n, a) {
    var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], h = 0; h < i.length; h++) {
      var f = u++ % l.length;
      c[f] = c[f] || [], c[f].push(new Gr({
        shape: sm(t, a, i[h].coord)
      }));
    }
    for (var h = 0; h < c.length; h++)
      r.add(Xn(c[h], {
        style: Te({
          stroke: l[h % l.length]
        }, s.getLineStyle()),
        silent: !0,
        z: e.get("z")
      }));
  },
  minorSplitLine: function(r, e, t, i, n, a) {
    if (n.length) {
      for (var o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], u = 0; u < n.length; u++)
        for (var c = 0; c < n[u].length; c++)
          l.push(new Gr({
            shape: sm(t, a, n[u][c].coord)
          }));
      r.add(Xn(l, {
        style: s.getLineStyle(),
        silent: !0,
        z: e.get("z")
      }));
    }
  },
  splitArea: function(r, e, t, i, n, a) {
    if (i.length) {
      var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], h = Math.PI / 180, f = -i[0].coord * h, d = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), g = e.get("clockwise"), v = 1, O = i.length; v <= O; v++) {
        var m = v === O ? i[0].coord : i[v].coord, E = u++ % l.length;
        c[E] = c[E] || [], c[E].push(new tn({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: d,
            r: p,
            startAngle: f,
            endAngle: -m * h,
            clockwise: g
          },
          silent: !0
        })), f = -m * h;
      }
      for (var v = 0; v < c.length; v++)
        r.add(Xn(c[v], {
          style: Te({
            fill: l[v % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
const Cye = Aye;
var Iye = ["axisLine", "axisTickLabel", "axisName"], wye = ["splitLine", "splitArea", "minorSplitLine"], Nye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t;
    }
    return e.prototype.render = function(t, i) {
      if (this.group.removeAll(), !!t.get("show")) {
        var n = this._axisGroup, a = this._axisGroup = new Re();
        this.group.add(a);
        var o = t.axis, s = o.polar, l = s.getAngleAxis(), u = o.getTicksCoords(), c = o.getMinorTicksCoords(), h = l.getExtent()[0], f = o.getExtent(), d = Pye(s, t, h), p = new hs(t, d);
        N(Iye, p.add, p), a.add(p.getGroup()), Cv(n, a, t), N(wye, function(g) {
          t.get([g, "show"]) && !o.scale.isBlank() && xye[g](this.group, t, s, h, f, u, c);
        }, this);
      }
    }, e.type = "radiusAxis", e;
  }(Jc)
), xye = {
  splitLine: function(r, e, t, i, n, a) {
    var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), u = 0;
    l = l instanceof Array ? l : [l];
    for (var c = [], h = 0; h < a.length; h++) {
      var f = u++ % l.length;
      c[f] = c[f] || [], c[f].push(new Co({
        shape: {
          cx: t.cx,
          cy: t.cy,
          // ensure circle radius >= 0
          r: Math.max(a[h].coord, 0)
        }
      }));
    }
    for (var h = 0; h < c.length; h++)
      r.add(Xn(c[h], {
        style: Te({
          stroke: l[h % l.length],
          fill: null
        }, s.getLineStyle()),
        silent: !0
      }));
  },
  minorSplitLine: function(r, e, t, i, n, a, o) {
    if (o.length) {
      for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), u = [], c = 0; c < o.length; c++)
        for (var h = 0; h < o[c].length; h++)
          u.push(new Co({
            shape: {
              cx: t.cx,
              cy: t.cy,
              r: o[c][h].coord
            }
          }));
      r.add(Xn(u, {
        style: Te({
          fill: null
        }, l.getLineStyle()),
        silent: !0
      }));
    }
  },
  splitArea: function(r, e, t, i, n, a) {
    if (a.length) {
      var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), u = 0;
      l = l instanceof Array ? l : [l];
      for (var c = [], h = a[0].coord, f = 1; f < a.length; f++) {
        var d = u++ % l.length;
        c[d] = c[d] || [], c[d].push(new tn({
          shape: {
            cx: t.cx,
            cy: t.cy,
            r0: h,
            r: a[f].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: !0
        })), h = a[f].coord;
      }
      for (var f = 0; f < c.length; f++)
        r.add(Xn(c[f], {
          style: Te({
            fill: l[f % l.length]
          }, s.getAreaStyle()),
          silent: !0
        }));
    }
  }
};
function Pye(r, e, t) {
  return {
    position: [r.cx, r.cy],
    rotation: t / 180 * Math.PI,
    labelDirection: -1,
    tickDirection: -1,
    nameDirection: 1,
    labelRotate: e.getModel("axisLabel").get("rotate"),
    // Over splitLine and splitArea
    z2: 1
  };
}
const Lye = Nye;
function yZ(r) {
  return r.get("stack") || "__ec_stack_" + r.seriesIndex;
}
function RZ(r, e) {
  return e.dim + r.model.componentIndex;
}
function Dye(r, e, t) {
  var i = {}, n = Mye(At(e.getSeriesByType(r), function(a) {
    return !e.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar";
  }));
  e.eachSeriesByType(r, function(a) {
    if (a.coordinateSystem.type === "polar") {
      var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), u = RZ(s, l), c = yZ(a), h = n[u][c], f = h.offset, d = h.width, p = s.getOtherAxis(l), g = a.coordinateSystem.cx, v = a.coordinateSystem.cy, O = a.get("barMinHeight") || 0, m = a.get("barMinAngle") || 0;
      i[c] = i[c] || [];
      for (var E = o.mapDimension(p.dim), b = o.mapDimension(l.dim), S = Ll(
        o,
        E
        /* , baseDim */
      ), T = l.dim !== "radius" || !a.get("roundCap", !0), y = p.dataToCoord(0), R = 0, _ = o.count(); R < _; R++) {
        var C = o.get(E, R), I = o.get(b, R), w = C >= 0 ? "p" : "n", x = y;
        S && (i[c][I] || (i[c][I] = {
          p: y,
          n: y
          // Negative stack
        }), x = i[c][I][w]);
        var P = void 0, L = void 0, D = void 0, U = void 0;
        if (p.dim === "radius") {
          var Q = p.dataToCoord(C) - y, V = l.dataToCoord(I);
          Math.abs(Q) < O && (Q = (Q < 0 ? -1 : 1) * O), P = x, L = x + Q, D = V - f, U = D - d, S && (i[c][I][w] = L);
        } else {
          var F = p.dataToCoord(C, T) - y, j = l.dataToCoord(I);
          Math.abs(F) < m && (F = (F < 0 ? -1 : 1) * m), P = j + f, L = P + d, D = x, U = x + F, S && (i[c][I][w] = U);
        }
        o.setItemLayout(R, {
          cx: g,
          cy: v,
          r0: P,
          r: L,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -D * Math.PI / 180,
          endAngle: -U * Math.PI / 180,
          /**
           * Keep the same logic with bar in catesion: use end value to
           * control direction. Notice that if clockwise is true (by
           * default), the sector will always draw clockwisely, no matter
           * whether endAngle is greater or less than startAngle.
           */
          clockwise: D >= U
        });
      }
    }
  });
}
function Mye(r) {
  var e = {};
  N(r, function(i, n) {
    var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = RZ(o, s), u = s.getExtent(), c = s.type === "category" ? s.getBandWidth() : Math.abs(u[1] - u[0]) / a.count(), h = e[l] || {
      bandWidth: c,
      remainedWidth: c,
      autoWidthCount: 0,
      categoryGap: "20%",
      gap: "30%",
      stacks: {}
    }, f = h.stacks;
    e[l] = h;
    var d = yZ(i);
    f[d] || h.autoWidthCount++, f[d] = f[d] || {
      width: 0,
      maxWidth: 0
    };
    var p = K(i.get("barWidth"), c), g = K(i.get("barMaxWidth"), c), v = i.get("barGap"), O = i.get("barCategoryGap");
    p && !f[d].width && (p = Math.min(h.remainedWidth, p), f[d].width = p, h.remainedWidth -= p), g && (f[d].maxWidth = g), v != null && (h.gap = v), O != null && (h.categoryGap = O);
  });
  var t = {};
  return N(e, function(i, n) {
    t[n] = {};
    var a = i.stacks, o = i.bandWidth, s = K(i.categoryGap, o), l = K(i.gap, 1), u = i.remainedWidth, c = i.autoWidthCount, h = (u - s) / (c + (c - 1) * l);
    h = Math.max(h, 0), N(a, function(g, v) {
      var O = g.maxWidth;
      O && O < h && (O = Math.min(O, u), g.width && (O = Math.min(O, g.width)), u -= O, g.width = O, c--);
    }), h = (u - s) / (c + (c - 1) * l), h = Math.max(h, 0);
    var f = 0, d;
    N(a, function(g, v) {
      g.width || (g.width = h), d = g, f += g.width * (1 + l);
    }), d && (f -= d.width * l);
    var p = -f / 2;
    N(a, function(g, v) {
      t[n][v] = t[n][v] || {
        offset: p,
        width: g.width
      }, p += g.width * (1 + l);
    });
  }), t;
}
var kye = {
  startAngle: 90,
  clockwise: !0,
  splitNumber: 12,
  axisLabel: {
    rotate: 0
  }
}, Qye = {
  splitNumber: 5
}, Uye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "polar", e;
  }(jt)
);
function $ye(r) {
  Ye(Gv), Jc.registerAxisPointerClass("PolarAxisPointer", uye), r.registerCoordinateSystem("polar", yye), r.registerComponentModel(hye), r.registerComponentView(Uye), Df(r, "angle", fye, kye), Df(r, "radius", dye, Qye), r.registerComponentView(Cye), r.registerComponentView(Lye), r.registerLayout(Le(Dye, "bar"));
}
function KC(r, e) {
  e = e || {};
  var t = r.coordinateSystem, i = r.axis, n = {}, a = i.position, o = i.orient, s = t.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], u = {
    horizontal: {
      top: l[2],
      bottom: l[3]
    },
    vertical: {
      left: l[0],
      right: l[1]
    }
  };
  n.position = [o === "vertical" ? u.vertical[a] : l[0], o === "horizontal" ? u.horizontal[a] : l[3]];
  var c = {
    horizontal: 0,
    vertical: 1
  };
  n.rotation = Math.PI / 2 * c[o];
  var h = {
    top: -1,
    bottom: 1,
    right: 1,
    left: -1
  };
  n.labelDirection = n.tickDirection = n.nameDirection = h[a], r.get(["axisTick", "inside"]) && (n.tickDirection = -n.tickDirection), vr(e.labelInside, r.get(["axisLabel", "inside"])) && (n.labelDirection = -n.labelDirection);
  var f = e.rotate;
  return f == null && (f = r.get(["axisLabel", "rotate"])), n.labelRotation = a === "top" ? -f : f, n.z2 = 1, n;
}
var Vye = ["axisLine", "axisTickLabel", "axisName"], Gye = ["splitArea", "splitLine"], Bye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = this.group;
      o.removeAll();
      var s = this._axisGroup;
      this._axisGroup = new Re();
      var l = KC(t), u = new hs(t, l);
      N(Vye, u.add, u), o.add(this._axisGroup), o.add(u.getGroup()), N(Gye, function(c) {
        t.get([c, "show"]) && Fye[c](this, this.group, this._axisGroup, t);
      }, this), Cv(s, this._axisGroup, t), r.prototype.render.call(this, t, i, n, a);
    }, e.prototype.remove = function() {
      F3(this);
    }, e.type = "singleAxis", e;
  }(Jc)
), Fye = {
  splitLine: function(r, e, t, i) {
    var n = i.axis;
    if (!n.scale.isBlank()) {
      var a = i.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color");
      s = s instanceof Array ? s : [s];
      for (var l = o.get("width"), u = i.coordinateSystem.getRect(), c = n.isHorizontal(), h = [], f = 0, d = n.getTicksCoords({
        tickModel: a
      }), p = [], g = [], v = 0; v < d.length; ++v) {
        var O = n.toGlobalCoord(d[v].coord);
        c ? (p[0] = O, p[1] = u.y, g[0] = O, g[1] = u.y + u.height) : (p[0] = u.x, p[1] = O, g[0] = u.x + u.width, g[1] = O);
        var m = new Gr({
          shape: {
            x1: p[0],
            y1: p[1],
            x2: g[0],
            y2: g[1]
          },
          silent: !0
        });
        wf(m.shape, l);
        var E = f++ % s.length;
        h[E] = h[E] || [], h[E].push(m);
      }
      for (var b = o.getLineStyle(["color"]), v = 0; v < h.length; ++v)
        e.add(Xn(h[v], {
          style: Te({
            stroke: s[v % s.length]
          }, b),
          silent: !0
        }));
    }
  },
  splitArea: function(r, e, t, i) {
    B3(r, t, i, i);
  }
};
const Xye = Bye;
var AZ = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.getCoordSysModel = function() {
      return this;
    }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = {
      left: "5%",
      top: "5%",
      right: "5%",
      bottom: "5%",
      type: "value",
      position: "bottom",
      orient: "horizontal",
      axisLine: {
        show: !0,
        lineStyle: {
          width: 1,
          type: "solid"
        }
      },
      // Single coordinate system and single axis is the,
      // which is used as the parent tooltip model.
      // same model, so we set default tooltip show as true.
      tooltip: {
        show: !0
      },
      axisTick: {
        show: !0,
        length: 6,
        lineStyle: {
          width: 1
        }
      },
      axisLabel: {
        show: !0,
        interval: "auto"
      },
      splitLine: {
        show: !0,
        lineStyle: {
          type: "dashed",
          opacity: 0.2
        }
      }
    }, e;
  }(st)
);
br(AZ, Lv.prototype);
const XR = AZ;
var Yye = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n, a, o) {
      var s = r.call(this, t, i, n) || this;
      return s.type = a || "value", s.position = o || "bottom", s;
    }
    return e.prototype.isHorizontal = function() {
      var t = this.position;
      return t === "top" || t === "bottom";
    }, e.prototype.pointToData = function(t, i) {
      return this.coordinateSystem.pointToData(t)[0];
    }, e;
  }(Ma)
);
const Hye = Yye;
var _Z = ["single"], Wye = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "single", this.dimension = "single", this.dimensions = _Z, this.axisPointerEnabled = !0, this.model = e, this._init(e, t, i);
    }
    return r.prototype._init = function(e, t, i) {
      var n = this.dimension, a = new Hye(n, kT(e), [0, 0], e.get("type"), e.get("position")), o = a.type === "category";
      a.onBand = o && e.get("boundaryGap"), a.inverse = e.get("inverse"), a.orient = e.get("orient"), e.axis = a, a.model = e, a.coordinateSystem = this, this._axis = a;
    }, r.prototype.update = function(e, t) {
      e.eachSeries(function(i) {
        if (i.coordinateSystem === this) {
          var n = i.getData();
          N(n.mapDimensionsAll(this.dimension), function(a) {
            this._axis.scale.unionExtentFromData(n, a);
          }, this), Pf(this._axis.scale, this._axis.model);
        }
      }, this);
    }, r.prototype.resize = function(e, t) {
      this._rect = Ir({
        left: e.get("left"),
        top: e.get("top"),
        right: e.get("right"),
        bottom: e.get("bottom"),
        width: e.get("width"),
        height: e.get("height")
      }, {
        width: t.getWidth(),
        height: t.getHeight()
      }), this._adjustAxis();
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype._adjustAxis = function() {
      var e = this._rect, t = this._axis, i = t.isHorizontal(), n = i ? [0, e.width] : [0, e.height], a = t.inverse ? 1 : 0;
      t.setExtent(n[a], n[1 - a]), this._updateAxisTransform(t, i ? e.x : e.y);
    }, r.prototype._updateAxisTransform = function(e, t) {
      var i = e.getExtent(), n = i[0] + i[1], a = e.isHorizontal();
      e.toGlobalCoord = a ? function(o) {
        return o + t;
      } : function(o) {
        return n - o + t;
      }, e.toLocalCoord = a ? function(o) {
        return o - t;
      } : function(o) {
        return n - o + t;
      };
    }, r.prototype.getAxis = function() {
      return this._axis;
    }, r.prototype.getBaseAxis = function() {
      return this._axis;
    }, r.prototype.getAxes = function() {
      return [this._axis];
    }, r.prototype.getTooltipAxes = function() {
      return {
        baseAxes: [this.getAxis()],
        // Empty otherAxes
        otherAxes: []
      };
    }, r.prototype.containPoint = function(e) {
      var t = this.getRect(), i = this.getAxis(), n = i.orient;
      return n === "horizontal" ? i.contain(i.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : i.contain(i.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height;
    }, r.prototype.pointToData = function(e) {
      var t = this.getAxis();
      return [t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))];
    }, r.prototype.dataToPoint = function(e) {
      var t = this.getAxis(), i = this.getRect(), n = [], a = t.orient === "horizontal" ? 0 : 1;
      return e instanceof Array && (e = e[0]), n[a] = t.toGlobalCoord(t.dataToCoord(+e)), n[1 - a] = a === 0 ? i.y + i.height / 2 : i.x + i.width / 2, n;
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = HU(t);
      return n === this ? this.dataToPoint(i) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = HU(t);
      return n === this ? this.pointToData(i) : null;
    }, r;
  }()
);
function HU(r) {
  var e = r.seriesModel, t = r.singleAxisModel;
  return t && t.coordinateSystem || e && e.coordinateSystem;
}
function zye(r, e) {
  var t = [];
  return r.eachComponent("singleAxis", function(i, n) {
    var a = new Wye(i, r, e);
    a.name = "single_" + n, a.resize(i, e), i.coordinateSystem = a, t.push(a);
  }), r.eachSeries(function(i) {
    if (i.get("coordinateSystem") === "singleAxis") {
      var n = i.getReferringComponents("singleAxis", Or).models[0];
      i.coordinateSystem = n && n.coordinateSystem;
    }
  }), t;
}
var Zye = {
  create: zye,
  dimensions: _Z
};
const qye = Zye;
var WU = ["x", "y"], jye = ["width", "height"], Kye = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.makeElOption = function(t, i, n, a, o) {
      var s = n.axis, l = s.coordinateSystem, u = YR(l, 1 - Gb(s)), c = l.dataToPoint(i)[0], h = a.get("type");
      if (h && h !== "none") {
        var f = fx(a), d = Jye[h](s, c, u);
        d.style = f, t.graphicKey = d.type, t.pointer = d;
      }
      var p = KC(n);
      mZ(
        // @ts-ignore
        i,
        t,
        p,
        n,
        a,
        o
      );
    }, e.prototype.getHandleTransform = function(t, i, n) {
      var a = KC(i, {
        labelInside: !1
      });
      a.labelMargin = n.get(["handle", "margin"]);
      var o = dx(i.axis, t, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, e.prototype.updateHandleTransform = function(t, i, n, a) {
      var o = n.axis, s = o.coordinateSystem, l = Gb(o), u = YR(s, l), c = [t.x, t.y];
      c[l] += i[l], c[l] = Math.min(u[1], c[l]), c[l] = Math.max(u[0], c[l]);
      var h = YR(s, 1 - l), f = (h[1] + h[0]) / 2, d = [f, f];
      return d[l] = c[l], {
        x: c[0],
        y: c[1],
        rotation: t.rotation,
        cursorPoint: d,
        tooltipOption: {
          verticalAlign: "middle"
        }
      };
    }, e;
  }(hx)
), Jye = {
  line: function(r, e, t) {
    var i = px([e, t[0]], [e, t[1]], Gb(r));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: i
    };
  },
  shadow: function(r, e, t) {
    var i = r.getBandWidth(), n = t[1] - t[0];
    return {
      type: "Rect",
      shape: EZ([e - i / 2, t[0]], [i, n], Gb(r))
    };
  }
};
function Gb(r) {
  return r.isHorizontal() ? 0 : 1;
}
function YR(r, e) {
  var t = r.getRect();
  return [t[WU[e]], t[WU[e]] + t[jye[e]]];
}
const e0e = Kye;
var t0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "single", e;
  }(jt)
);
function r0e(r) {
  Ye(Gv), Jc.registerAxisPointerClass("SingleAxisPointer", e0e), r.registerComponentView(t0e), r.registerComponentView(Xye), r.registerComponentModel(XR), Df(r, "single", XR, XR.defaultOption), r.registerCoordinateSystem("single", qye);
}
var i0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i, n) {
      var a = nd(t);
      r.prototype.init.apply(this, arguments), zU(t, a);
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), zU(this.option, t);
    }, e.prototype.getCellSize = function() {
      return this.option.cellSize;
    }, e.type = "calendar", e.defaultOption = {
      // zlevel: 0,
      z: 2,
      left: 80,
      top: 60,
      cellSize: 20,
      // horizontal vertical
      orient: "horizontal",
      // month separate line style
      splitLine: {
        show: !0,
        lineStyle: {
          color: "#000",
          width: 1,
          type: "solid"
        }
      },
      // rect style  temporarily unused emphasis
      itemStyle: {
        color: "#fff",
        borderWidth: 1,
        borderColor: "#ccc"
      },
      // week text style
      dayLabel: {
        show: !0,
        firstDay: 0,
        // start end
        position: "start",
        margin: "50%",
        color: "#000"
      },
      // month text style
      monthLabel: {
        show: !0,
        // start end
        position: "start",
        margin: 5,
        // center or left
        align: "center",
        formatter: null,
        color: "#000"
      },
      // year text style
      yearLabel: {
        show: !0,
        // top bottom left right
        position: null,
        margin: 30,
        formatter: null,
        color: "#ccc",
        fontFamily: "sans-serif",
        fontWeight: "bolder",
        fontSize: 20
      }
    }, e;
  }(st)
);
function zU(r, e) {
  var t = r.cellSize, i;
  X(t) ? i = t : i = r.cellSize = [t, t], i.length === 1 && (i[1] = i[0]);
  var n = Y([0, 1], function(a) {
    return cle(e, a) && (i[a] = "auto"), i[a] != null && i[a] !== "auto";
  });
  Pl(r, e, {
    type: "box",
    ignoreSize: n
  });
}
const n0e = i0e;
var a0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      var a = this.group;
      a.removeAll();
      var o = t.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), u = i.getLocaleModel();
      this._renderDayRect(t, s, a), this._renderLines(t, s, l, a), this._renderYearText(t, s, l, a), this._renderMonthText(t, u, l, a), this._renderWeekText(t, u, s, l, a);
    }, e.prototype._renderDayRect = function(t, i, n) {
      for (var a = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), u = i.start.time; u <= i.end.time; u = a.getNextNDay(u, 1).time) {
        var c = a.dataToRect([u], !1).tl, h = new ht({
          shape: {
            x: c[0],
            y: c[1],
            width: s,
            height: l
          },
          cursor: "default",
          style: o
        });
        n.add(h);
      }
    }, e.prototype._renderLines = function(t, i, n, a) {
      var o = this, s = t.coordinateSystem, l = t.getModel(["splitLine", "lineStyle"]).getLineStyle(), u = t.get(["splitLine", "show"]), c = l.lineWidth;
      this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = [];
      for (var h = i.start, f = 0; h.time <= i.end.time; f++) {
        p(h.formatedDate), f === 0 && (h = s.getDateInfo(i.start.y + "-" + i.start.m));
        var d = h.date;
        d.setMonth(d.getMonth() + 1), h = s.getDateInfo(d);
      }
      p(s.getNextNDay(i.end.time, 1).formatedDate);
      function p(g) {
        o._firstDayOfMonth.push(s.getDateInfo(g)), o._firstDayPoints.push(s.dataToRect([g], !1).tl);
        var v = o._getLinePointsOfOneWeek(t, g, n);
        o._tlpoints.push(v[0]), o._blpoints.push(v[v.length - 1]), u && o._drawSplitline(v, l, a);
      }
      u && this._drawSplitline(o._getEdgesPoints(o._tlpoints, c, n), l, a), u && this._drawSplitline(o._getEdgesPoints(o._blpoints, c, n), l, a);
    }, e.prototype._getEdgesPoints = function(t, i, n) {
      var a = [t[0].slice(), t[t.length - 1].slice()], o = n === "horizontal" ? 0 : 1;
      return a[0][o] = a[0][o] - i / 2, a[1][o] = a[1][o] + i / 2, a;
    }, e.prototype._drawSplitline = function(t, i, n) {
      var a = new nn({
        z2: 20,
        shape: {
          points: t
        },
        style: i
      });
      n.add(a);
    }, e.prototype._getLinePointsOfOneWeek = function(t, i, n) {
      for (var a = t.coordinateSystem, o = a.getDateInfo(i), s = [], l = 0; l < 7; l++) {
        var u = a.getNextNDay(o.time, l), c = a.dataToRect([u.time], !1);
        s[2 * u.day] = c.tl, s[2 * u.day + 1] = c[n === "horizontal" ? "bl" : "tr"];
      }
      return s;
    }, e.prototype._formatterLabel = function(t, i) {
      return ne(t) && t ? sle(t, i) : ve(t) ? t(i) : i.nameMap;
    }, e.prototype._yearTextPositionControl = function(t, i, n, a, o) {
      var s = i[0], l = i[1], u = ["center", "bottom"];
      a === "bottom" ? (l += o, u = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, u = ["center", "top"]) : l -= o;
      var c = 0;
      return (a === "left" || a === "right") && (c = Math.PI / 2), {
        rotation: c,
        x: s,
        y: l,
        style: {
          align: u[0],
          verticalAlign: u[1]
        }
      };
    }, e.prototype._renderYearText = function(t, i, n, a) {
      var o = t.getModel("yearLabel");
      if (o.get("show")) {
        var s = o.get("margin"), l = o.get("position");
        l || (l = n !== "horizontal" ? "top" : "left");
        var u = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], c = (u[0][0] + u[1][0]) / 2, h = (u[0][1] + u[1][1]) / 2, f = n === "horizontal" ? 0 : 1, d = {
          top: [c, u[f][1]],
          bottom: [c, u[1 - f][1]],
          left: [u[1 - f][0], h],
          right: [u[f][0], h]
        }, p = i.start.y;
        +i.end.y > +i.start.y && (p = p + "-" + i.end.y);
        var g = o.get("formatter"), v = {
          start: i.start.y,
          end: i.end.y,
          nameMap: p
        }, O = this._formatterLabel(g, v), m = new dt({
          z2: 30,
          style: Qt(o, {
            text: O
          })
        });
        m.attr(this._yearTextPositionControl(m, d[l], n, l, s)), a.add(m);
      }
    }, e.prototype._monthTextPositionControl = function(t, i, n, a, o) {
      var s = "left", l = "top", u = t[0], c = t[1];
      return n === "horizontal" ? (c = c + o, i && (s = "center"), a === "start" && (l = "bottom")) : (u = u + o, i && (l = "middle"), a === "start" && (s = "right")), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderMonthText = function(t, i, n, a) {
      var o = t.getModel("monthLabel");
      if (o.get("show")) {
        var s = o.get("nameMap"), l = o.get("margin"), u = o.get("position"), c = o.get("align"), h = [this._tlpoints, this._blpoints];
        (!s || ne(s)) && (s && (i = lC(s) || i), s = i.get(["time", "monthAbbr"]) || []);
        var f = u === "start" ? 0 : 1, d = n === "horizontal" ? 0 : 1;
        l = u === "start" ? -l : l;
        for (var p = c === "center", g = 0; g < h[f].length - 1; g++) {
          var v = h[f][g].slice(), O = this._firstDayOfMonth[g];
          if (p) {
            var m = this._firstDayPoints[g];
            v[d] = (m[d] + h[0][g + 1][d]) / 2;
          }
          var E = o.get("formatter"), b = s[+O.m - 1], S = {
            yyyy: O.y,
            yy: (O.y + "").slice(2),
            MM: O.m,
            M: +O.m,
            nameMap: b
          }, T = this._formatterLabel(E, S), y = new dt({
            z2: 30,
            style: B(Qt(o, {
              text: T
            }), this._monthTextPositionControl(v, p, n, u, l))
          });
          a.add(y);
        }
      }
    }, e.prototype._weekTextPositionControl = function(t, i, n, a, o) {
      var s = "center", l = "middle", u = t[0], c = t[1], h = n === "start";
      return i === "horizontal" ? (u = u + a + (h ? 1 : -1) * o[0] / 2, s = h ? "right" : "left") : (c = c + a + (h ? 1 : -1) * o[1] / 2, l = h ? "bottom" : "top"), {
        x: u,
        y: c,
        align: s,
        verticalAlign: l
      };
    }, e.prototype._renderWeekText = function(t, i, n, a, o) {
      var s = t.getModel("dayLabel");
      if (s.get("show")) {
        var l = t.coordinateSystem, u = s.get("position"), c = s.get("nameMap"), h = s.get("margin"), f = l.getFirstDayOfWeek();
        if (!c || ne(c)) {
          c && (i = lC(c) || i);
          var d = i.get(["time", "dayOfWeekShort"]);
          c = d || Y(i.get(["time", "dayOfWeekAbbr"]), function(S) {
            return S[0];
          });
        }
        var p = l.getNextNDay(n.end.time, 7 - n.lweek).time, g = [l.getCellWidth(), l.getCellHeight()];
        h = K(h, Math.min(g[1], g[0])), u === "start" && (p = l.getNextNDay(n.start.time, -(7 + n.fweek)).time, h = -h);
        for (var v = 0; v < 7; v++) {
          var O = l.getNextNDay(p, v), m = l.dataToRect([O.time], !1).center, E = v;
          E = Math.abs((v + f) % 7);
          var b = new dt({
            z2: 30,
            style: B(Qt(s, {
              text: c[E]
            }), this._weekTextPositionControl(m, a, u, h, g))
          });
          o.add(b);
        }
      }
    }, e.type = "calendar", e;
  }(jt)
);
const o0e = a0e;
var HR = 864e5, s0e = (
  /** @class */
  function() {
    function r(e, t, i) {
      this.type = "calendar", this.dimensions = r.dimensions, this.getDimensionsInfo = r.getDimensionsInfo, this._model = e;
    }
    return r.getDimensionsInfo = function() {
      return [{
        name: "time",
        type: "time"
      }, "value"];
    }, r.prototype.getRangeInfo = function() {
      return this._rangeInfo;
    }, r.prototype.getModel = function() {
      return this._model;
    }, r.prototype.getRect = function() {
      return this._rect;
    }, r.prototype.getCellWidth = function() {
      return this._sw;
    }, r.prototype.getCellHeight = function() {
      return this._sh;
    }, r.prototype.getOrient = function() {
      return this._orient;
    }, r.prototype.getFirstDayOfWeek = function() {
      return this._firstDayOfWeek;
    }, r.prototype.getDateInfo = function(e) {
      e = Ao(e);
      var t = e.getFullYear(), i = e.getMonth() + 1, n = i < 10 ? "0" + i : "" + i, a = e.getDate(), o = a < 10 ? "0" + a : "" + a, s = e.getDay();
      return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), {
        y: t + "",
        m: n,
        d: o,
        day: s,
        time: e.getTime(),
        formatedDate: t + "-" + n + "-" + o,
        date: e
      };
    }, r.prototype.getNextNDay = function(e, t) {
      return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e));
    }, r.prototype.update = function(e, t) {
      this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption());
      var i = this._rangeInfo.weeks || 1, n = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [i, 7] : [7, i];
      N([0, 1], function(h) {
        c(a, h) && (o[n[h]] = a[h] * s[h]);
      });
      var l = {
        width: t.getWidth(),
        height: t.getHeight()
      }, u = this._rect = Ir(o, l);
      N([0, 1], function(h) {
        c(a, h) || (a[h] = u[n[h]] / s[h]);
      });
      function c(h, f) {
        return h[f] != null && h[f] !== "auto";
      }
      this._sw = a[0], this._sh = a[1];
    }, r.prototype.dataToPoint = function(e, t) {
      X(e) && (e = e[0]), t == null && (t = !0);
      var i = this.getDateInfo(e), n = this._rangeInfo, a = i.formatedDate;
      if (t && !(i.time >= n.start.time && i.time < n.end.time + HR))
        return [NaN, NaN];
      var o = i.day, s = this._getRangeInfo([n.start.time, a]).nthWeek;
      return this._orient === "vertical" ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2];
    }, r.prototype.pointToData = function(e) {
      var t = this.pointToDate(e);
      return t && t.time;
    }, r.prototype.dataToRect = function(e, t) {
      var i = this.dataToPoint(e, t);
      return {
        contentShape: {
          x: i[0] - (this._sw - this._lineWidth) / 2,
          y: i[1] - (this._sh - this._lineWidth) / 2,
          width: this._sw - this._lineWidth,
          height: this._sh - this._lineWidth
        },
        center: i,
        tl: [i[0] - this._sw / 2, i[1] - this._sh / 2],
        tr: [i[0] + this._sw / 2, i[1] - this._sh / 2],
        br: [i[0] + this._sw / 2, i[1] + this._sh / 2],
        bl: [i[0] - this._sw / 2, i[1] + this._sh / 2]
      };
    }, r.prototype.pointToDate = function(e) {
      var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1, i = Math.floor((e[1] - this._rect.y) / this._sh) + 1, n = this._rangeInfo.range;
      return this._orient === "vertical" ? this._getDateByWeeksAndDay(i, t - 1, n) : this._getDateByWeeksAndDay(t, i - 1, n);
    }, r.prototype.convertToPixel = function(e, t, i) {
      var n = ZU(t);
      return n === this ? n.dataToPoint(i) : null;
    }, r.prototype.convertFromPixel = function(e, t, i) {
      var n = ZU(t);
      return n === this ? n.pointToData(i) : null;
    }, r.prototype.containPoint = function(e) {
      return console.warn("Not implemented."), !1;
    }, r.prototype._initRangeOption = function() {
      var e = this._model.get("range"), t;
      if (X(e) && e.length === 1 && (e = e[0]), X(e))
        t = e;
      else {
        var i = e.toString();
        if (/^\d{4}$/.test(i) && (t = [i + "-01-01", i + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(i)) {
          var n = this.getDateInfo(i), a = n.date;
          a.setMonth(a.getMonth() + 1);
          var o = this.getNextNDay(a, -1);
          t = [n.formatedDate, o.formatedDate];
        }
        /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(i) && (t = [i, i]);
      }
      if (!t)
        return {}.NODE_ENV !== "production" && _a("Invalid date range."), e;
      var s = this._getRangeInfo(t);
      return s.start.time > s.end.time && t.reverse(), t;
    }, r.prototype._getRangeInfo = function(e) {
      var t = [this.getDateInfo(e[0]), this.getDateInfo(e[1])], i;
      t[0].time > t[1].time && (i = !0, t.reverse());
      var n = Math.floor(t[1].time / HR) - Math.floor(t[0].time / HR) + 1, a = new Date(t[0].time), o = a.getDate(), s = t[1].date.getDate();
      a.setDate(o + n - 1);
      var l = a.getDate();
      if (l !== s)
        for (var u = a.getTime() - t[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - t[1].time) * u > 0; )
          n -= u, a.setDate(l - u);
      var c = Math.floor((n + t[0].day + 6) / 7), h = i ? -c + 1 : c - 1;
      return i && t.reverse(), {
        range: [t[0].formatedDate, t[1].formatedDate],
        start: t[0],
        end: t[1],
        allDay: n,
        weeks: c,
        // From 0.
        nthWeek: h,
        fweek: t[0].day,
        lweek: t[1].day
      };
    }, r.prototype._getDateByWeeksAndDay = function(e, t, i) {
      var n = this._getRangeInfo(i);
      if (e > n.weeks || e === 0 && t < n.fweek || e === n.weeks && t > n.lweek)
        return null;
      var a = (e - 1) * 7 - n.fweek + t, o = new Date(n.start.time);
      return o.setDate(+n.start.d + a), this.getDateInfo(o);
    }, r.create = function(e, t) {
      var i = [];
      return e.eachComponent("calendar", function(n) {
        var a = new r(n);
        i.push(a), n.coordinateSystem = a;
      }), e.eachSeries(function(n) {
        n.get("coordinateSystem") === "calendar" && (n.coordinateSystem = i[n.get("calendarIndex") || 0]);
      }), i;
    }, r.dimensions = ["time", "value"], r;
  }()
);
function ZU(r) {
  var e = r.calendarModel, t = r.seriesModel, i = e ? e.coordinateSystem : t ? t.coordinateSystem : null;
  return i;
}
const l0e = s0e;
function u0e(r) {
  r.registerComponentModel(n0e), r.registerComponentView(o0e), r.registerCoordinateSystem("calendar", l0e);
}
function c0e(r, e) {
  var t = r.existing;
  if (e.id = r.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) {
    var i = e.parentOption;
    i ? e.parentId = i.id : t && (e.parentId = t.parentId);
  }
  e.parentOption = null;
}
function qU(r, e) {
  var t;
  return N(e, function(i) {
    r[i] != null && r[i] !== "auto" && (t = !0);
  }), t;
}
function h0e(r, e, t) {
  var i = B({}, t), n = r[e], a = t.$action || "merge";
  if (a === "merge")
    if (n) {
      if ({}.NODE_ENV !== "production") {
        var o = t.type;
        Se(!o || n.type === o, 'Please set $action: "replace" to change `type`');
      }
      $e(n, i, !0), Pl(n, i, {
        ignoreSize: !0
      }), pW(t, n), um(t, n), um(t, n, "shape"), um(t, n, "style"), um(t, n, "extra"), t.clipPath = n.clipPath;
    } else
      r[e] = i;
  else
    a === "replace" ? r[e] = i : a === "remove" && n && (r[e] = null);
}
var CZ = ["transition", "enterFrom", "leaveTo"], f0e = CZ.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]);
function um(r, e, t) {
  if (t && (!r[t] && e[t] && (r[t] = {}), r = r[t], e = e[t]), !(!r || !e))
    for (var i = t ? CZ : f0e, n = 0; n < i.length; n++) {
      var a = i[n];
      r[a] == null && e[a] != null && (r[a] = e[a]);
    }
}
function d0e(r, e) {
  if (r && (r.hv = e.hv = [
    // Rigid body, don't care about `width`.
    qU(e, ["left", "right"]),
    // Rigid body, don't care about `height`.
    qU(e, ["top", "bottom"])
  ], r.type === "group")) {
    var t = r, i = e;
    t.width == null && (t.width = i.width = 0), t.height == null && (t.height = i.height = 0);
  }
}
var p0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.preventAutoZ = !0, t;
    }
    return e.prototype.mergeOption = function(t, i) {
      var n = this.option.elements;
      this.option.elements = null, r.prototype.mergeOption.call(this, t, i), this.option.elements = n;
    }, e.prototype.optionUpdated = function(t, i) {
      var n = this.option, a = (i ? n : t).elements, o = n.elements = i ? [] : n.elements, s = [];
      this._flatten(a, s, null);
      var l = qY(o, s, "normalMerge"), u = this._elOptionsToUpdate = [];
      N(l, function(c, h) {
        var f = c.newOption;
        ({}).NODE_ENV !== "production" && Se(be(f) || c.existing, "Empty graphic option definition"), f && (u.push(f), c0e(c, f), h0e(o, h, f), d0e(o[h], f));
      }, this), n.elements = At(o, function(c) {
        return c && delete c.$action, c != null;
      });
    }, e.prototype._flatten = function(t, i, n) {
      N(t, function(a) {
        if (a) {
          n && (a.parentOption = n), i.push(a);
          var o = a.children;
          o && o.length && this._flatten(o, i, a), delete a.children;
        }
      }, this);
    }, e.prototype.useElOptionsToUpdate = function() {
      var t = this._elOptionsToUpdate;
      return this._elOptionsToUpdate = null, t;
    }, e.type = "graphic", e.defaultOption = {
      elements: []
      // parentId: null
    }, e;
  }(st)
), jU = {
  // Reserved but not supported in graphic component.
  path: null,
  compoundPath: null,
  // Supported in graphic component.
  group: Re,
  image: ni,
  text: dt
}, $n = ft(), g0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this._elMap = de();
    }, e.prototype.render = function(t, i, n) {
      t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, n);
    }, e.prototype._updateElements = function(t) {
      var i = t.useElOptionsToUpdate();
      if (i) {
        var n = this._elMap, a = this.group, o = t.get("z"), s = t.get("zlevel");
        N(i, function(l) {
          var u = Ar(l.id, null), c = u != null ? n.get(u) : null, h = Ar(l.parentId, null), f = h != null ? n.get(h) : a, d = l.type, p = l.style;
          d === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null);
          var g = l.textContent, v = l.textConfig;
          if (p && aZ(p, d, !!v, !!g)) {
            var O = oZ(p, d, !0);
            !v && O.textConfig && (v = l.textConfig = O.textConfig), !g && O.textContent && (g = O.textContent);
          }
          var m = v0e(l);
          ({}).NODE_ENV !== "production" && c && Se(f === c.parent, "Changing parent is not supported.");
          var E = l.$action || "merge", b = E === "merge", S = E === "replace";
          if (b) {
            var T = !c, y = c;
            T ? y = KU(u, f, l.type, n) : (y && ($n(y).isNew = !1), hZ(y)), y && (aE(y, m, t, {
              isInit: T
            }), JU(y, l, o, s));
          } else if (S) {
            sE(c, l, n, t);
            var R = KU(u, f, l.type, n);
            R && (aE(R, m, t, {
              isInit: !0
            }), JU(R, l, o, s));
          } else
            E === "remove" && (lZ(c, l), sE(c, l, n, t));
          var _ = n.get(u);
          if (_ && g)
            if (b) {
              var C = _.getTextContent();
              C ? C.attr(g) : _.setTextContent(new dt(g));
            } else
              S && _.setTextContent(new dt(g));
          if (_) {
            var I = l.clipPath;
            if (I) {
              var w = I.type, x = void 0, T = !1;
              if (b) {
                var P = _.getClipPath();
                T = !P || $n(P).type !== w, x = T ? JC(w) : P;
              } else
                S && (T = !0, x = JC(w));
              _.setClipPath(x), aE(x, I, t, {
                isInit: T
              }), Ub(x, I.keyframeAnimation, t);
            }
            var L = $n(_);
            _.setTextConfig(v), L.option = l, O0e(_, t, l), ed({
              el: _,
              componentModel: t,
              itemName: _.name,
              itemTooltipOption: l.tooltip
            }), Ub(_, l.keyframeAnimation, t);
          }
        });
      }
    }, e.prototype._relocate = function(t, i) {
      for (var n = t.option.elements, a = this.group, o = this._elMap, s = i.getWidth(), l = i.getHeight(), u = ["x", "y"], c = 0; c < n.length; c++) {
        var h = n[c], f = Ar(h.id, null), d = f != null ? o.get(f) : null;
        if (!(!d || !d.isGroup)) {
          var p = d.parent, g = p === a, v = $n(d), O = $n(p);
          v.width = K(v.option.width, g ? s : O.width) || 0, v.height = K(v.option.height, g ? l : O.height) || 0;
        }
      }
      for (var c = n.length - 1; c >= 0; c--) {
        var h = n[c], f = Ar(h.id, null), d = f != null ? o.get(f) : null;
        if (d) {
          var p = d.parent, O = $n(p), m = p === a ? {
            width: s,
            height: l
          } : {
            width: O.width,
            height: O.height
          }, E = {}, b = IT(d, h, m, null, {
            hv: h.hv,
            boundingMode: h.bounding
          }, E);
          if (!$n(d).isNew && b) {
            for (var S = h.transition, T = {}, y = 0; y < u.length; y++) {
              var R = u[y], _ = E[R];
              S && (Ec(S) || Fe(S, R) >= 0) ? T[R] = _ : d[R] = _;
            }
            Ot(d, T, t, 0);
          } else
            d.attr(E);
        }
      }
    }, e.prototype._clear = function() {
      var t = this, i = this._elMap;
      i.each(function(n) {
        sE(n, $n(n).option, i, t._lastGraphicModel);
      }), this._elMap = de();
    }, e.prototype.dispose = function() {
      this._clear();
    }, e.type = "graphic", e;
  }(jt)
);
function JC(r) {
  ({}).NODE_ENV !== "production" && Se(r, "graphic type MUST be set");
  var e = le(jU, r) ? jU[r] : j1(r);
  ({}).NODE_ENV !== "production" && Se(e, "graphic type " + r + " can not be found");
  var t = new e({});
  return $n(t).type = r, t;
}
function KU(r, e, t, i) {
  var n = JC(t);
  return e.add(n), i.set(r, n), $n(n).id = r, $n(n).isNew = !0, n;
}
function sE(r, e, t, i) {
  var n = r && r.parent;
  n && (r.type === "group" && r.traverse(function(a) {
    sE(a, e, t, i);
  }), XT(r, e, i), t.removeKey($n(r).id));
}
function JU(r, e, t, i) {
  r.isGroup || N([
    ["cursor", aa.prototype.cursor],
    // We should not support configure z and zlevel in the element level.
    // But seems we didn't limit it previously. So here still use it to avoid breaking.
    ["zlevel", i || 0],
    ["z", t || 0],
    // z2 must not be null/undefined, otherwise sort error may occur.
    ["z2", 0]
  ], function(n) {
    var a = n[0];
    le(e, a) ? r[a] = ke(e[a], n[1]) : r[a] == null && (r[a] = n[1]);
  }), N(Ze(e), function(n) {
    if (n.indexOf("on") === 0) {
      var a = e[n];
      r[n] = ve(a) ? a : null;
    }
  }), le(e, "draggable") && (r.draggable = e.draggable), e.name != null && (r.name = e.name), e.id != null && (r.id = e.id);
}
function v0e(r) {
  return r = B({}, r), N(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(dW), function(e) {
    delete r[e];
  }), r;
}
function O0e(r, e, t) {
  var i = Pe(r).eventData;
  !r.silent && !r.ignore && !i && (i = Pe(r).eventData = {
    componentType: "graphic",
    componentIndex: e.componentIndex,
    name: r.name
  }), i && (i.info = t.info);
}
function m0e(r) {
  r.registerComponentModel(p0e), r.registerComponentView(g0e), r.registerPreprocessor(function(e) {
    var t = e.graphic;
    X(t) ? !t[0] || !t[0].elements ? e.graphic = [{
      elements: t
    }] : e.graphic = [e.graphic[0]] : t && !t.elements && (e.graphic = [{
      elements: [t]
    }]);
  });
}
var e$ = ["x", "y", "radius", "angle", "single"], E0e = ["cartesian2d", "polar", "singleAxis"];
function b0e(r) {
  var e = r.get("coordinateSystem");
  return Fe(E0e, e) >= 0;
}
function ol(r) {
  return {}.NODE_ENV !== "production" && Se(r), r + "Axis";
}
function S0e(r, e) {
  var t = de(), i = [], n = de();
  r.eachComponent({
    mainType: "dataZoom",
    query: e
  }, function(c) {
    n.get(c.uid) || s(c);
  });
  var a;
  do
    a = !1, r.eachComponent("dataZoom", o);
  while (a);
  function o(c) {
    !n.get(c.uid) && l(c) && (s(c), a = !0);
  }
  function s(c) {
    n.set(c.uid, !0), i.push(c), u(c);
  }
  function l(c) {
    var h = !1;
    return c.eachTargetAxis(function(f, d) {
      var p = t.get(f);
      p && p[d] && (h = !0);
    }), h;
  }
  function u(c) {
    c.eachTargetAxis(function(h, f) {
      (t.get(h) || t.set(h, []))[f] = !0;
    });
  }
  return i;
}
function IZ(r) {
  var e = r.ecModel, t = {
    infoList: [],
    infoMap: de()
  };
  return r.eachTargetAxis(function(i, n) {
    var a = e.getComponent(ol(i), n);
    if (a) {
      var o = a.getCoordSysModel();
      if (o) {
        var s = o.uid, l = t.infoMap.get(s);
        l || (l = {
          model: o,
          axisModels: []
        }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(a);
      }
    }
  }), t;
}
var WR = (
  /** @class */
  function() {
    function r() {
      this.indexList = [], this.indexMap = [];
    }
    return r.prototype.add = function(e) {
      this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = !0);
    }, r;
  }()
), T0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._autoThrottle = !0, t._noTarget = !0, t._rangePropMode = ["percent", "percent"], t;
    }
    return e.prototype.init = function(t, i, n) {
      var a = t$(t);
      this.settledOption = a, this.mergeDefaultAndTheme(t, n), this._doInit(a);
    }, e.prototype.mergeOption = function(t) {
      var i = t$(t);
      $e(this.option, t, !0), $e(this.settledOption, i, !0), this._doInit(i);
    }, e.prototype._doInit = function(t) {
      var i = this.option;
      this._setDefaultThrottle(t), this._updateRangeUse(t);
      var n = this.settledOption;
      N([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        this._rangePropMode[o] === "value" && (i[a[0]] = n[a[0]] = null);
      }, this), this._resetTarget();
    }, e.prototype._resetTarget = function() {
      var t = this.get("orient", !0), i = this._targetAxisInfoMap = de(), n = this._fillSpecifiedTargetAxis(i);
      n ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(i, this._orient)), this._noTarget = !0, i.each(function(a) {
        a.indexList.length && (this._noTarget = !1);
      }, this);
    }, e.prototype._fillSpecifiedTargetAxis = function(t) {
      var i = !1;
      return N(e$, function(n) {
        var a = this.getReferringComponents(ol(n), Gae);
        if (a.specified) {
          i = !0;
          var o = new WR();
          N(a.models, function(s) {
            o.add(s.componentIndex);
          }), t.set(n, o);
        }
      }, this), i;
    }, e.prototype._fillAutoTargetAxisByOrient = function(t, i) {
      var n = this.ecModel, a = !0;
      if (a) {
        var o = i === "vertical" ? "y" : "x", s = n.findComponents({
          mainType: o + "Axis"
        });
        l(s, o);
      }
      if (a) {
        var s = n.findComponents({
          mainType: "singleAxis",
          filter: function(c) {
            return c.get("orient", !0) === i;
          }
        });
        l(s, "single");
      }
      function l(u, c) {
        var h = u[0];
        if (h) {
          var f = new WR();
          if (f.add(h.componentIndex), t.set(c, f), a = !1, c === "x" || c === "y") {
            var d = h.getReferringComponents("grid", Or).models[0];
            d && N(u, function(p) {
              h.componentIndex !== p.componentIndex && d === p.getReferringComponents("grid", Or).models[0] && f.add(p.componentIndex);
            });
          }
        }
      }
      a && N(e$, function(u) {
        if (a) {
          var c = n.findComponents({
            mainType: ol(u),
            filter: function(f) {
              return f.get("type", !0) === "category";
            }
          });
          if (c[0]) {
            var h = new WR();
            h.add(c[0].componentIndex), t.set(u, h), a = !1;
          }
        }
      }, this);
    }, e.prototype._makeAutoOrientByTargetAxis = function() {
      var t;
      return this.eachTargetAxis(function(i) {
        !t && (t = i);
      }, this), t === "y" ? "vertical" : "horizontal";
    }, e.prototype._setDefaultThrottle = function(t) {
      if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) {
        var i = this.ecModel.option;
        this.option.throttle = i.animation && i.animationDurationUpdate > 0 ? 100 : 20;
      }
    }, e.prototype._updateRangeUse = function(t) {
      var i = this._rangePropMode, n = this.get("rangeMode");
      N([["start", "startValue"], ["end", "endValue"]], function(a, o) {
        var s = t[a[0]] != null, l = t[a[1]] != null;
        s && !l ? i[o] = "percent" : !s && l ? i[o] = "value" : n ? i[o] = n[o] : s && (i[o] = "percent");
      });
    }, e.prototype.noTarget = function() {
      return this._noTarget;
    }, e.prototype.getFirstTargetAxisModel = function() {
      var t;
      return this.eachTargetAxis(function(i, n) {
        t == null && (t = this.ecModel.getComponent(ol(i), n));
      }, this), t;
    }, e.prototype.eachTargetAxis = function(t, i) {
      this._targetAxisInfoMap.each(function(n, a) {
        N(n.indexList, function(o) {
          t.call(i, a, o);
        });
      });
    }, e.prototype.getAxisProxy = function(t, i) {
      var n = this.getAxisModel(t, i);
      if (n)
        return n.__dzAxisProxy;
    }, e.prototype.getAxisModel = function(t, i) {
      ({}).NODE_ENV !== "production" && Se(t && i != null);
      var n = this._targetAxisInfoMap.get(t);
      if (n && n.indexMap[i])
        return this.ecModel.getComponent(ol(t), i);
    }, e.prototype.setRawRange = function(t) {
      var i = this.option, n = this.settledOption;
      N([["start", "startValue"], ["end", "endValue"]], function(a) {
        (t[a[0]] != null || t[a[1]] != null) && (i[a[0]] = n[a[0]] = t[a[0]], i[a[1]] = n[a[1]] = t[a[1]]);
      }, this), this._updateRangeUse(t);
    }, e.prototype.setCalculatedRange = function(t) {
      var i = this.option;
      N(["start", "startValue", "end", "endValue"], function(n) {
        i[n] = t[n];
      });
    }, e.prototype.getPercentRange = function() {
      var t = this.findRepresentativeAxisProxy();
      if (t)
        return t.getDataPercentWindow();
    }, e.prototype.getValueRange = function(t, i) {
      if (t == null && i == null) {
        var n = this.findRepresentativeAxisProxy();
        if (n)
          return n.getDataValueWindow();
      } else
        return this.getAxisProxy(t, i).getDataValueWindow();
    }, e.prototype.findRepresentativeAxisProxy = function(t) {
      if (t)
        return t.__dzAxisProxy;
      for (var i, n = this._targetAxisInfoMap.keys(), a = 0; a < n.length; a++)
        for (var o = n[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) {
          var u = this.getAxisProxy(o, s.indexList[l]);
          if (u.hostedBy(this))
            return u;
          i || (i = u);
        }
      return i;
    }, e.prototype.getRangePropMode = function() {
      return this._rangePropMode.slice();
    }, e.prototype.getOrient = function() {
      return {}.NODE_ENV !== "production" && Se(this._orient), this._orient;
    }, e.type = "dataZoom", e.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      filterMode: "filter",
      start: 0,
      end: 100
    }, e;
  }(st)
);
function t$(r) {
  var e = {};
  return N(["start", "end", "startValue", "endValue", "throttle"], function(t) {
    r.hasOwnProperty(t) && (e[t] = r[t]);
  }), e;
}
const Zg = T0e;
var y0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(Zg)
);
const R0e = y0e;
var A0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n, a) {
      this.dataZoomModel = t, this.ecModel = i, this.api = n;
    }, e.type = "dataZoom", e;
  }(jt)
);
const mx = A0e;
var _0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.select", e;
  }(mx)
);
const C0e = _0e;
var $h = N, r$ = Zn, I0e = (
  /** @class */
  function() {
    function r(e, t, i, n) {
      this._dimName = e, this._axisIndex = t, this.ecModel = n, this._dataZoomModel = i;
    }
    return r.prototype.hostedBy = function(e) {
      return this._dataZoomModel === e;
    }, r.prototype.getDataValueWindow = function() {
      return this._valueWindow.slice();
    }, r.prototype.getDataPercentWindow = function() {
      return this._percentWindow.slice();
    }, r.prototype.getTargetSeriesModels = function() {
      var e = [];
      return this.ecModel.eachSeries(function(t) {
        if (b0e(t)) {
          var i = ol(this._dimName), n = t.getReferringComponents(i, Or).models[0];
          n && this._axisIndex === n.componentIndex && e.push(t);
        }
      }, this), e;
    }, r.prototype.getAxisModel = function() {
      return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex);
    }, r.prototype.getMinMaxSpan = function() {
      return ye(this._minMaxSpan);
    }, r.prototype.calculateDataWindow = function(e) {
      var t = this._dataExtent, i = this.getAxisModel(), n = i.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], u;
      $h(["start", "end"], function(f, d) {
        var p = e[f], g = e[f + "Value"];
        a[d] === "percent" ? (p == null && (p = o[d]), g = n.parse(yt(p, o, t))) : (u = !0, g = g == null ? t[d] : n.parse(g), p = yt(g, t, o)), l[d] = g == null || isNaN(g) ? t[d] : g, s[d] = p == null || isNaN(p) ? o[d] : p;
      }), r$(l), r$(s);
      var c = this._minMaxSpan;
      u ? h(l, s, t, o, !1) : h(s, l, o, t, !0);
      function h(f, d, p, g, v) {
        var O = v ? "Span" : "ValueSpan";
        eh(0, f, p, "all", c["min" + O], c["max" + O]);
        for (var m = 0; m < 2; m++)
          d[m] = yt(f[m], p, g, !0), v && (d[m] = n.parse(d[m]));
      }
      return {
        valueWindow: l,
        percentWindow: s
      };
    }, r.prototype.reset = function(e) {
      if (e === this._dataZoomModel) {
        var t = this.getTargetSeriesModels();
        this._dataExtent = w0e(this, this._dimName, t), this._updateMinMaxSpan();
        var i = this.calculateDataWindow(e.settledOption);
        this._valueWindow = i.valueWindow, this._percentWindow = i.percentWindow, this._setAxisModel();
      }
    }, r.prototype.filterData = function(e, t) {
      if (e !== this._dataZoomModel)
        return;
      var i = this._dimName, n = this.getTargetSeriesModels(), a = e.get("filterMode"), o = this._valueWindow;
      if (a === "none")
        return;
      $h(n, function(l) {
        var u = l.getData(), c = u.mapDimensionsAll(i);
        if (c.length) {
          if (a === "weakFilter") {
            var h = u.getStore(), f = Y(c, function(d) {
              return u.getDimensionIndex(d);
            }, u);
            u.filterSelf(function(d) {
              for (var p, g, v, O = 0; O < c.length; O++) {
                var m = h.get(f[O], d), E = !isNaN(m), b = m < o[0], S = m > o[1];
                if (E && !b && !S)
                  return !0;
                E && (v = !0), b && (p = !0), S && (g = !0);
              }
              return v && p && g;
            });
          } else
            $h(c, function(d) {
              if (a === "empty")
                l.setData(u = u.map(d, function(g) {
                  return s(g) ? g : NaN;
                }));
              else {
                var p = {};
                p[d] = o, u.selectRange(p);
              }
            });
          $h(c, function(d) {
            u.setApproximateExtent(o, d);
          });
        }
      });
      function s(l) {
        return l >= o[0] && l <= o[1];
      }
    }, r.prototype._updateMinMaxSpan = function() {
      var e = this._minMaxSpan = {}, t = this._dataZoomModel, i = this._dataExtent;
      $h(["min", "max"], function(n) {
        var a = t.get(n + "Span"), o = t.get(n + "ValueSpan");
        o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = yt(i[0] + o, i, [0, 100], !0) : a != null && (o = yt(a, [0, 100], i, !0) - i[0]), e[n + "Span"] = a, e[n + "ValueSpan"] = o;
      }, this);
    }, r.prototype._setAxisModel = function() {
      var e = this.getAxisModel(), t = this._percentWindow, i = this._valueWindow;
      if (t) {
        var n = FY(i, [0, 500]);
        n = Math.min(n, 20);
        var a = e.axis.scale.rawExtentInfo;
        t[0] !== 0 && a.setDeterminedMinMax("min", +i[0].toFixed(n)), t[1] !== 100 && a.setDeterminedMinMax("max", +i[1].toFixed(n)), a.freeze();
      }
    }, r;
  }()
);
function w0e(r, e, t) {
  var i = [1 / 0, -1 / 0];
  $h(t, function(o) {
    efe(i, o.getData(), e);
  });
  var n = r.getAxisModel(), a = Xz(n.axis.scale, n, i).calculate();
  return [a.min, a.max];
}
const N0e = I0e;
var x0e = {
  // `dataZoomProcessor` will only be performed in needed series. Consider if
  // there is a line series and a pie series, it is better not to update the
  // line series if only pie series is needed to be updated.
  getTargetSeries: function(r) {
    function e(n) {
      r.eachComponent("dataZoom", function(a) {
        a.eachTargetAxis(function(o, s) {
          var l = r.getComponent(ol(o), s);
          n(o, s, l, a);
        });
      });
    }
    e(function(n, a, o, s) {
      o.__dzAxisProxy = null;
    });
    var t = [];
    e(function(n, a, o, s) {
      o.__dzAxisProxy || (o.__dzAxisProxy = new N0e(n, a, s, r), t.push(o.__dzAxisProxy));
    });
    var i = de();
    return N(t, function(n) {
      N(n.getTargetSeriesModels(), function(a) {
        i.set(a.uid, a);
      });
    }), i;
  },
  // Consider appendData, where filter should be performed. Because data process is
  // in block mode currently, it is not need to worry about that the overallProgress
  // execute every frame.
  overallReset: function(r, e) {
    r.eachComponent("dataZoom", function(t) {
      t.eachTargetAxis(function(i, n) {
        t.getAxisProxy(i, n).reset(t);
      }), t.eachTargetAxis(function(i, n) {
        t.getAxisProxy(i, n).filterData(t, e);
      });
    }), r.eachComponent("dataZoom", function(t) {
      var i = t.findRepresentativeAxisProxy();
      if (i) {
        var n = i.getDataPercentWindow(), a = i.getDataValueWindow();
        t.setCalculatedRange({
          start: n[0],
          end: n[1],
          startValue: a[0],
          endValue: a[1]
        });
      }
    });
  }
};
const P0e = x0e;
function L0e(r) {
  r.registerAction("dataZoom", function(e, t) {
    var i = S0e(t, e);
    N(i, function(n) {
      n.setRawRange({
        start: e.start,
        end: e.end,
        startValue: e.startValue,
        endValue: e.endValue
      });
    });
  });
}
var i$ = !1;
function Ex(r) {
  i$ || (i$ = !0, r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, P0e), L0e(r), r.registerSubTypeDefaulter("dataZoom", function() {
    return "slider";
  }));
}
function D0e(r) {
  r.registerComponentModel(R0e), r.registerComponentView(C0e), Ex(r);
}
var Bn = (
  /** @class */
  function() {
    function r() {
    }
    return r;
  }()
), wZ = {};
function Vh(r, e) {
  wZ[r] = e;
}
function NZ(r) {
  return wZ[r];
}
var M0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function() {
      r.prototype.optionUpdated.apply(this, arguments);
      var t = this.ecModel;
      N(this.option.feature, function(i, n) {
        var a = NZ(n);
        a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(t)), $e(i, a.defaultOption));
      });
    }, e.type = "toolbox", e.layoutMode = {
      type: "box",
      ignoreSize: !0
    }, e.defaultOption = {
      show: !0,
      z: 6,
      // zlevel: 0,
      orient: "horizontal",
      left: "right",
      top: "top",
      // right
      // bottom
      backgroundColor: "transparent",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemSize: 15,
      itemGap: 8,
      showTitle: !0,
      iconStyle: {
        borderColor: "#666",
        color: "none"
      },
      emphasis: {
        iconStyle: {
          borderColor: "#3E98C5"
        }
      },
      // textStyle: {},
      // feature
      tooltip: {
        show: !1,
        position: "bottom"
      }
    }, e;
  }(st)
);
const k0e = M0e;
function Q0e(r, e, t) {
  var i = e.getBoxLayoutParams(), n = e.get("padding"), a = {
    width: t.getWidth(),
    height: t.getHeight()
  }, o = Ir(i, a, n);
  vc(e.get("orient"), r, e.get("itemGap"), o.width, o.height), IT(r, i, a, n);
}
function xZ(r, e) {
  var t = id(e.get("padding")), i = e.getItemStyle(["color", "opacity"]);
  return i.fill = e.get("backgroundColor"), r = new ht({
    shape: {
      x: r.x - t[3],
      y: r.y - t[0],
      width: r.width + t[1] + t[3],
      height: r.height + t[0] + t[2],
      r: e.get("borderRadius")
    },
    style: i,
    silent: !0,
    z2: -1
  }), r;
}
var U0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, i, n, a) {
      var o = this.group;
      if (o.removeAll(), !t.get("show"))
        return;
      var s = +t.get("itemSize"), l = t.get("orient") === "vertical", u = t.get("feature") || {}, c = this._features || (this._features = {}), h = [];
      N(u, function(p, g) {
        h.push(g);
      }), new cs(this._featureNames || [], h).add(f).update(f).remove(Le(f, null)).execute(), this._featureNames = h;
      function f(p, g) {
        var v = h[p], O = h[g], m = u[v], E = new Ut(m, t, t.ecModel), b;
        if (a && a.newTitle != null && a.featureName === v && (m.title = a.newTitle), v && !O) {
          if ($0e(v))
            b = {
              onclick: E.option.onclick,
              featureName: v
            };
          else {
            var S = NZ(v);
            if (!S)
              return;
            b = new S();
          }
          c[v] = b;
        } else if (b = c[O], !b)
          return;
        b.uid = rd("toolbox-feature"), b.model = E, b.ecModel = i, b.api = n;
        var T = b instanceof Bn;
        if (!v && O) {
          T && b.dispose && b.dispose(i, n);
          return;
        }
        if (!E.get("show") || T && b.unusable) {
          T && b.remove && b.remove(i, n);
          return;
        }
        d(E, b, v), E.setIconStatus = function(y, R) {
          var _ = this.option, C = this.iconPaths;
          _.iconStatus = _.iconStatus || {}, _.iconStatus[y] = R, C[y] && (R === "emphasis" ? ls : us)(C[y]);
        }, b instanceof Bn && b.render && b.render(E, i, n, a);
      }
      function d(p, g, v) {
        var O = p.getModel("iconStyle"), m = p.getModel(["emphasis", "iconStyle"]), E = g instanceof Bn && g.getIcons ? g.getIcons() : p.get("icon"), b = p.get("title") || {}, S, T;
        ne(E) ? (S = {}, S[v] = E) : S = E, ne(b) ? (T = {}, T[v] = b) : T = b;
        var y = p.iconPaths = {};
        N(S, function(R, _) {
          var C = Iv(R, {}, {
            x: -s / 2,
            y: -s / 2,
            width: s,
            height: s
          });
          C.setStyle(O.getItemStyle());
          var I = C.ensureState("emphasis");
          I.style = m.getItemStyle();
          var w = new dt({
            style: {
              text: T[_],
              align: m.get("textAlign"),
              borderRadius: m.get("textBorderRadius"),
              padding: m.get("textPadding"),
              fill: null
            },
            ignore: !0
          });
          C.setTextContent(w), ed({
            el: C,
            componentModel: t,
            itemName: _,
            formatterParamsExtra: {
              title: T[_]
            }
          }), C.__title = T[_], C.on("mouseover", function() {
            var x = m.getItemStyle(), P = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top";
            w.setStyle({
              fill: m.get("textFill") || x.fill || x.stroke || "#000",
              backgroundColor: m.get("textBackgroundColor")
            }), C.setTextConfig({
              position: m.get("textPosition") || P
            }), w.ignore = !t.get("showTitle"), n.enterEmphasis(this);
          }).on("mouseout", function() {
            p.get(["iconStatus", _]) !== "emphasis" && n.leaveEmphasis(this), w.hide();
          }), (p.get(["iconStatus", _]) === "emphasis" ? ls : us)(C), o.add(C), C.on("click", ue(g.onclick, g, i, n, _)), y[_] = C;
        });
      }
      Q0e(o, t, n), o.add(xZ(o.getBoundingRect(), t)), l || o.eachChild(function(p) {
        var g = p.__title, v = p.ensureState("emphasis"), O = v.textConfig || (v.textConfig = {}), m = p.getTextContent(), E = m && m.ensureState("emphasis");
        if (E && !ve(E) && g) {
          var b = E.style || (E.style = {}), S = yv(g, dt.makeFont(b)), T = p.x + o.x, y = p.y + o.y + s, R = !1;
          y + S.height > n.getHeight() && (O.position = "top", R = !0);
          var _ = R ? -5 - S.height : s + 10;
          T + S.width / 2 > n.getWidth() ? (O.position = ["100%", _], b.align = "right") : T - S.width / 2 < 0 && (O.position = [0, _], b.align = "left");
        }
      });
    }, e.prototype.updateView = function(t, i, n, a) {
      N(this._features, function(o) {
        o instanceof Bn && o.updateView && o.updateView(o.model, i, n, a);
      });
    }, e.prototype.remove = function(t, i) {
      N(this._features, function(n) {
        n instanceof Bn && n.remove && n.remove(t, i);
      }), this.group.removeAll();
    }, e.prototype.dispose = function(t, i) {
      N(this._features, function(n) {
        n instanceof Bn && n.dispose && n.dispose(t, i);
      });
    }, e.type = "toolbox", e;
  }(jt)
);
function $0e(r) {
  return r.indexOf("my") === 0;
}
const V0e = U0e;
var G0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, i) {
      var n = this.model, a = n.get("name") || t.get("title.0.text") || "echarts", o = i.getZr().painter.getType() === "svg", s = o ? "svg" : n.get("type", !0) || "png", l = i.getConnectedDataURL({
        type: s,
        backgroundColor: n.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff",
        connectedBackgroundColor: n.get("connectedBackgroundColor"),
        excludeComponents: n.get("excludeComponents"),
        pixelRatio: n.get("pixelRatio")
      }), u = ct.browser;
      if (ve(MouseEvent) && (u.newEdge || !u.ie && !u.edge)) {
        var c = document.createElement("a");
        c.download = a + "." + s, c.target = "_blank", c.href = l;
        var h = new MouseEvent("click", {
          // some micro front-end framework window maybe is a Proxy
          view: document.defaultView,
          bubbles: !0,
          cancelable: !1
        });
        c.dispatchEvent(h);
      } else if (window.navigator.msSaveOrOpenBlob || o) {
        var f = l.split(","), d = f[0].indexOf("base64") > -1, p = o ? decodeURIComponent(f[1]) : f[1];
        d && (p = window.atob(p));
        var g = a + "." + s;
        if (window.navigator.msSaveOrOpenBlob) {
          for (var v = p.length, O = new Uint8Array(v); v--; )
            O[v] = p.charCodeAt(v);
          var m = new Blob([O]);
          window.navigator.msSaveOrOpenBlob(m, g);
        } else {
          var E = document.createElement("iframe");
          document.body.appendChild(E);
          var b = E.contentWindow, S = b.document;
          S.open("image/svg+xml", "replace"), S.write(p), S.close(), b.focus(), S.execCommand("SaveAs", !0, g), document.body.removeChild(E);
        }
      } else {
        var T = n.get("lang"), y = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (T && T[0] || "") + '" /></body>', R = window.open();
        R.document.write(y), R.document.title = a;
      }
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0",
        title: t.getLocaleModel().get(["toolbox", "saveAsImage", "title"]),
        type: "png",
        // Default use option.backgroundColor
        // backgroundColor: '#fff',
        connectedBackgroundColor: "#fff",
        name: "",
        excludeComponents: ["toolbox"],
        // use current pixel ratio of device by default
        // pixelRatio: 1,
        lang: t.getLocaleModel().get(["toolbox", "saveAsImage", "lang"])
      };
      return i;
    }, e;
  }(Bn)
);
const B0e = G0e;
var n$ = "__ec_magicType_stack__", F0e = [["line", "bar"], ["stack"]], X0e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.getIcons = function() {
      var t = this.model, i = t.get("icon"), n = {};
      return N(t.get("type"), function(a) {
        i[a] && (n[a] = i[a]);
      }), n;
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        type: [],
        // Icon group
        icon: {
          line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4",
          bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7",
          // eslint-disable-next-line
          stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z"
          // jshint ignore:line
        },
        // `line`, `bar`, `stack`, `tiled`
        title: t.getLocaleModel().get(["toolbox", "magicType", "title"]),
        option: {},
        seriesIndex: {}
      };
      return i;
    }, e.prototype.onclick = function(t, i, n) {
      var a = this.model, o = a.get(["seriesIndex", n]);
      if (a$[n]) {
        var s = {
          series: []
        }, l = function(h) {
          var f = h.subType, d = h.id, p = a$[n](f, d, h, a);
          p && (Te(p, h.option), s.series.push(p));
          var g = h.coordinateSystem;
          if (g && g.type === "cartesian2d" && (n === "line" || n === "bar")) {
            var v = g.getAxesByScale("ordinal")[0];
            if (v) {
              var O = v.dim, m = O + "Axis", E = h.getReferringComponents(m, Or).models[0], b = E.componentIndex;
              s[m] = s[m] || [];
              for (var S = 0; S <= b; S++)
                s[m][b] = s[m][b] || {};
              s[m][b].boundaryGap = n === "bar";
            }
          }
        };
        N(F0e, function(h) {
          Fe(h, n) >= 0 && N(h, function(f) {
            a.setIconStatus(f, "normal");
          });
        }), a.setIconStatus(n, "emphasis"), t.eachComponent({
          mainType: "series",
          query: o == null ? null : {
            seriesIndex: o
          }
        }, l);
        var u, c = n;
        n === "stack" && (u = $e({
          stack: a.option.title.tiled,
          tiled: a.option.title.stack
        }, a.option.title), a.get(["iconStatus", n]) !== "emphasis" && (c = "tiled")), i.dispatchAction({
          type: "changeMagicType",
          currentType: c,
          newOption: s,
          newTitle: u,
          featureName: "magicType"
        });
      }
    }, e;
  }(Bn)
), a$ = {
  line: function(r, e, t, i) {
    if (r === "bar")
      return $e({
        id: e,
        type: "line",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, i.get(["option", "line"]) || {}, !0);
  },
  bar: function(r, e, t, i) {
    if (r === "line")
      return $e({
        id: e,
        type: "bar",
        // Preserve data related option
        data: t.get("data"),
        stack: t.get("stack"),
        markPoint: t.get("markPoint"),
        markLine: t.get("markLine")
      }, i.get(["option", "bar"]) || {}, !0);
  },
  stack: function(r, e, t, i) {
    var n = t.get("stack") === n$;
    if (r === "line" || r === "bar")
      return i.setIconStatus("stack", n ? "normal" : "emphasis"), $e({
        id: e,
        stack: n ? "" : n$
      }, i.get(["option", "stack"]) || {}, !0);
  }
};
Po({
  type: "changeMagicType",
  event: "magicTypeChanged",
  update: "prepareAndUpdate"
}, function(r, e) {
  e.mergeOption(r.newOption);
});
const Y0e = X0e;
var YT = new Array(60).join("-"), Qf = "	";
function H0e(r) {
  var e = {}, t = [], i = [];
  return r.eachRawSeries(function(n) {
    var a = n.coordinateSystem;
    if (a && (a.type === "cartesian2d" || a.type === "polar")) {
      var o = a.getBaseAxis();
      if (o.type === "category") {
        var s = o.dim + "_" + o.index;
        e[s] || (e[s] = {
          categoryAxis: o,
          valueAxis: a.getOtherAxis(o),
          series: []
        }, i.push({
          axisDim: o.dim,
          axisIndex: o.index
        })), e[s].series.push(n);
      } else
        t.push(n);
    } else
      t.push(n);
  }), {
    seriesGroupByCategoryAxis: e,
    other: t,
    meta: i
  };
}
function W0e(r) {
  var e = [];
  return N(r, function(t, i) {
    var n = t.categoryAxis, a = t.valueAxis, o = a.dim, s = [" "].concat(Y(t.series, function(d) {
      return d.name;
    })), l = [n.model.getCategories()];
    N(t.series, function(d) {
      var p = d.getRawData();
      l.push(d.getRawData().mapArray(p.mapDimension(o), function(g) {
        return g;
      }));
    });
    for (var u = [s.join(Qf)], c = 0; c < l[0].length; c++) {
      for (var h = [], f = 0; f < l.length; f++)
        h.push(l[f][c]);
      u.push(h.join(Qf));
    }
    e.push(u.join(`
`));
  }), e.join(`

` + YT + `

`);
}
function z0e(r) {
  return Y(r, function(e) {
    var t = e.getRawData(), i = [e.name], n = [];
    return t.each(t.dimensions, function() {
      for (var a = arguments.length, o = arguments[a - 1], s = t.getName(o), l = 0; l < a - 1; l++)
        n[l] = arguments[l];
      i.push((s ? s + Qf : "") + n.join(Qf));
    }), i.join(`
`);
  }).join(`

` + YT + `

`);
}
function Z0e(r) {
  var e = H0e(r);
  return {
    value: At([W0e(e.seriesGroupByCategoryAxis), z0e(e.other)], function(t) {
      return !!t.replace(/[\n\t\s]/g, "");
    }).join(`

` + YT + `

`),
    meta: e.meta
  };
}
function Bb(r) {
  return r.replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function q0e(r) {
  var e = r.slice(0, r.indexOf(`
`));
  if (e.indexOf(Qf) >= 0)
    return !0;
}
var eI = new RegExp("[" + Qf + "]+", "g");
function j0e(r) {
  for (var e = r.split(/\n+/g), t = Bb(e.shift()).split(eI), i = [], n = Y(t, function(l) {
    return {
      name: l,
      data: []
    };
  }), a = 0; a < e.length; a++) {
    var o = Bb(e[a]).split(eI);
    i.push(o.shift());
    for (var s = 0; s < o.length; s++)
      n[s] && (n[s].data[a] = o[s]);
  }
  return {
    series: n,
    categories: i
  };
}
function K0e(r) {
  for (var e = r.split(/\n+/g), t = Bb(e.shift()), i = [], n = 0; n < e.length; n++) {
    var a = Bb(e[n]);
    if (a) {
      var o = a.split(eI), s = "", l = void 0, u = !1;
      isNaN(o[0]) ? (u = !0, s = o[0], o = o.slice(1), i[n] = {
        name: s,
        value: []
      }, l = i[n].value) : l = i[n] = [];
      for (var c = 0; c < o.length; c++)
        l.push(+o[c]);
      l.length === 1 && (u ? i[n].value = l[0] : i[n] = l[0]);
    }
  }
  return {
    name: t,
    data: i
  };
}
function J0e(r, e) {
  var t = r.split(new RegExp(`
*` + YT + `
*`, "g")), i = {
    series: []
  };
  return N(t, function(n, a) {
    if (q0e(n)) {
      var o = j0e(n), s = e[a], l = s.axisDim + "Axis";
      s && (i[l] = i[l] || [], i[l][s.axisIndex] = {
        data: o.categories
      }, i.series = i.series.concat(o.series));
    } else {
      var o = K0e(n);
      i.series.push(o);
    }
  }), i;
}
var eRe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, i) {
      setTimeout(function() {
        i.dispatchAction({
          type: "hideTip"
        });
      });
      var n = i.getDom(), a = this.model;
      this._dom && n.removeChild(this._dom);
      var o = document.createElement("div");
      o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff";
      var s = document.createElement("h4"), l = a.get("lang") || [];
      s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor");
      var u = document.createElement("div"), c = document.createElement("textarea");
      u.style.cssText = "overflow:auto";
      var h = a.get("optionToContent"), f = a.get("contentToOption"), d = Z0e(t);
      if (ve(h)) {
        var p = h(i.getOption());
        ne(p) ? u.innerHTML = p : _g(p) && u.appendChild(p);
      } else {
        c.readOnly = a.get("readOnly");
        var g = c.style;
        g.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", g.color = a.get("textColor"), g.borderColor = a.get("textareaBorderColor"), g.backgroundColor = a.get("textareaColor"), c.value = d.value, u.appendChild(c);
      }
      var v = d.meta, O = document.createElement("div");
      O.style.cssText = "position:absolute;bottom:5px;left:0;right:0";
      var m = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", E = document.createElement("div"), b = document.createElement("div");
      m += ";background-color:" + a.get("buttonColor"), m += ";color:" + a.get("buttonTextColor");
      var S = this;
      function T() {
        n.removeChild(o), S._dom = null;
      }
      D_(E, "click", T), D_(b, "click", function() {
        if (f == null && h != null || f != null && h == null) {
          ({}).NODE_ENV !== "production" && tr("It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored."), T();
          return;
        }
        var y;
        try {
          ve(f) ? y = f(u, i.getOption()) : y = J0e(c.value, v);
        } catch (R) {
          throw T(), new Error("Data view format error " + R);
        }
        y && i.dispatchAction({
          type: "changeDataView",
          newOption: y
        }), T();
      }), E.innerHTML = l[1], b.innerHTML = l[2], b.style.cssText = E.style.cssText = m, !a.get("readOnly") && O.appendChild(b), O.appendChild(E), o.appendChild(s), o.appendChild(u), o.appendChild(O), u.style.height = n.clientHeight - 80 + "px", n.appendChild(o), this._dom = o;
    }, e.prototype.remove = function(t, i) {
      this._dom && i.getDom().removeChild(this._dom);
    }, e.prototype.dispose = function(t, i) {
      this.remove(t, i);
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        readOnly: !1,
        optionToContent: null,
        contentToOption: null,
        // eslint-disable-next-line
        icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28",
        title: t.getLocaleModel().get(["toolbox", "dataView", "title"]),
        lang: t.getLocaleModel().get(["toolbox", "dataView", "lang"]),
        backgroundColor: "#fff",
        textColor: "#000",
        textareaColor: "#fff",
        textareaBorderColor: "#333",
        buttonColor: "#c23531",
        buttonTextColor: "#fff"
      };
      return i;
    }, e;
  }(Bn)
);
function tRe(r, e) {
  return Y(r, function(t, i) {
    var n = e && e[i];
    if (be(n) && !X(n)) {
      var a = be(t) && !X(t);
      a || (t = {
        value: t
      });
      var o = n.name != null && t.name == null;
      return t = Te(t, n), o && delete t.name, t;
    } else
      return t;
  });
}
Po({
  type: "changeDataView",
  event: "dataViewChanged",
  update: "prepareAndUpdate"
}, function(r, e) {
  var t = [];
  N(r.newOption.series, function(i) {
    var n = e.getSeriesByName(i.name)[0];
    if (!n)
      t.push(B({
        // Default is scatter
        type: "scatter"
      }, i));
    else {
      var a = n.get("data");
      t.push({
        name: i.name,
        data: tRe(i.data, a)
      });
    }
  }), e.mergeOption(Te({
    series: t
  }, r.newOption));
});
const rRe = eRe;
var PZ = N, LZ = ft();
function iRe(r, e) {
  var t = bx(r);
  PZ(e, function(i, n) {
    for (var a = t.length - 1; a >= 0; a--) {
      var o = t[a];
      if (o[n])
        break;
    }
    if (a < 0) {
      var s = r.queryComponents({
        mainType: "dataZoom",
        subType: "select",
        id: n
      })[0];
      if (s) {
        var l = s.getPercentRange();
        t[0][n] = {
          dataZoomId: n,
          start: l[0],
          end: l[1]
        };
      }
    }
  }), t.push(e);
}
function nRe(r) {
  var e = bx(r), t = e[e.length - 1];
  e.length > 1 && e.pop();
  var i = {};
  return PZ(t, function(n, a) {
    for (var o = e.length - 1; o >= 0; o--)
      if (n = e[o][a], n) {
        i[a] = n;
        break;
      }
  }), i;
}
function aRe(r) {
  LZ(r).snapshots = null;
}
function oRe(r) {
  return bx(r).length;
}
function bx(r) {
  var e = LZ(r);
  return e.snapshots || (e.snapshots = [{}]), e.snapshots;
}
var sRe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.onclick = function(t, i) {
      aRe(t), i.dispatchAction({
        type: "restore",
        from: this.uid
      });
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        // eslint-disable-next-line
        icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5",
        title: t.getLocaleModel().get(["toolbox", "restore", "title"])
      };
      return i;
    }, e;
  }(Bn)
);
Po({
  type: "restore",
  event: "restore",
  update: "prepareAndUpdate"
}, function(r, e) {
  e.resetOption("recreate");
});
const lRe = sRe;
var uRe = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], cRe = (
  /** @class */
  function() {
    function r(e, t, i) {
      var n = this;
      this._targetInfoList = [];
      var a = o$(t, e);
      N(hRe, function(o, s) {
        (!i || !i.include || Fe(i.include, s) >= 0) && o(a, n._targetInfoList);
      });
    }
    return r.prototype.setOutputRanges = function(e, t) {
      return this.matchOutputRanges(e, t, function(i, n, a) {
        if ((i.coordRanges || (i.coordRanges = [])).push(n), !i.coordRange) {
          i.coordRange = n;
          var o = zR[i.brushType](0, a, n);
          i.__rangeOffset = {
            offset: c$[i.brushType](o.values, i.range, [1, 1]),
            xyMinMax: o.xyMinMax
          };
        }
      }), e;
    }, r.prototype.matchOutputRanges = function(e, t, i) {
      N(e, function(n) {
        var a = this.findTargetInfo(n, t);
        a && a !== !0 && N(a.coordSyses, function(o) {
          var s = zR[n.brushType](1, o, n.range, !0);
          i(n, s.values, o, t);
        });
      }, this);
    }, r.prototype.setInputRanges = function(e, t) {
      N(e, function(i) {
        var n = this.findTargetInfo(i, t);
        if ({}.NODE_ENV !== "production" && (Se(!n || n === !0 || i.coordRange, "coordRange must be specified when coord index specified."), Se(!n || n !== !0 || i.range, "range must be specified in global brush.")), i.range = i.range || [], n && n !== !0) {
          i.panelId = n.panelId;
          var a = zR[i.brushType](0, n.coordSys, i.coordRange), o = i.__rangeOffset;
          i.range = o ? c$[i.brushType](a.values, o.offset, fRe(a.xyMinMax, o.xyMinMax)) : a.values;
        }
      }, this);
    }, r.prototype.makePanelOpts = function(e, t) {
      return Y(this._targetInfoList, function(i) {
        var n = i.getPanelRect();
        return {
          panelId: i.panelId,
          defaultBrushType: t ? t(i) : null,
          clipPath: $4(n),
          isTargetByCursor: G4(n, e, i.coordSysModel),
          getLinearBrushOtherExtent: V4(n)
        };
      });
    }, r.prototype.controlSeries = function(e, t, i) {
      var n = this.findTargetInfo(e, i);
      return n === !0 || n && Fe(n.coordSyses, t.coordinateSystem) >= 0;
    }, r.prototype.findTargetInfo = function(e, t) {
      for (var i = this._targetInfoList, n = o$(t, e), a = 0; a < i.length; a++) {
        var o = i[a], s = e.panelId;
        if (s) {
          if (o.panelId === s)
            return o;
        } else
          for (var l = 0; l < s$.length; l++)
            if (s$[l](n, o))
              return o;
      }
      return !0;
    }, r;
  }()
);
function tI(r) {
  return r[0] > r[1] && r.reverse(), r;
}
function o$(r, e) {
  return Wp(r, e, {
    includeMainTypes: uRe
  });
}
var hRe = {
  grid: function(r, e) {
    var t = r.xAxisModels, i = r.yAxisModels, n = r.gridModels, a = de(), o = {}, s = {};
    !t && !i && !n || (N(t, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), o[u.id] = !0;
    }), N(i, function(l) {
      var u = l.axis.grid.model;
      a.set(u.id, u), s[u.id] = !0;
    }), N(n, function(l) {
      a.set(l.id, l), o[l.id] = !0, s[l.id] = !0;
    }), a.each(function(l) {
      var u = l.coordinateSystem, c = [];
      N(u.getCartesians(), function(h, f) {
        (Fe(t, h.getAxis("x").model) >= 0 || Fe(i, h.getAxis("y").model) >= 0) && c.push(h);
      }), e.push({
        panelId: "grid--" + l.id,
        gridModel: l,
        coordSysModel: l,
        // Use the first one as the representitive coordSys.
        coordSys: c[0],
        coordSyses: c,
        getPanelRect: l$.grid,
        xAxisDeclared: o[l.id],
        yAxisDeclared: s[l.id]
      });
    }));
  },
  geo: function(r, e) {
    N(r.geoModels, function(t) {
      var i = t.coordinateSystem;
      e.push({
        panelId: "geo--" + t.id,
        geoModel: t,
        coordSysModel: t,
        coordSys: i,
        coordSyses: [i],
        getPanelRect: l$.geo
      });
    });
  }
}, s$ = [
  // grid
  function(r, e) {
    var t = r.xAxisModel, i = r.yAxisModel, n = r.gridModel;
    return !n && t && (n = t.axis.grid.model), !n && i && (n = i.axis.grid.model), n && n === e.gridModel;
  },
  // geo
  function(r, e) {
    var t = r.geoModel;
    return t && t === e.geoModel;
  }
], l$ = {
  grid: function() {
    return this.coordSys.master.getRect().clone();
  },
  geo: function() {
    var r = this.coordSys, e = r.getBoundingRect().clone();
    return e.applyTransform(gc(r)), e;
  }
}, zR = {
  lineX: Le(u$, 0),
  lineY: Le(u$, 1),
  rect: function(r, e, t, i) {
    var n = r ? e.pointToData([t[0][0], t[1][0]], i) : e.dataToPoint([t[0][0], t[1][0]], i), a = r ? e.pointToData([t[0][1], t[1][1]], i) : e.dataToPoint([t[0][1], t[1][1]], i), o = [tI([n[0], a[0]]), tI([n[1], a[1]])];
    return {
      values: o,
      xyMinMax: o
    };
  },
  polygon: function(r, e, t, i) {
    var n = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = Y(t, function(o) {
      var s = r ? e.pointToData(o, i) : e.dataToPoint(o, i);
      return n[0][0] = Math.min(n[0][0], s[0]), n[1][0] = Math.min(n[1][0], s[1]), n[0][1] = Math.max(n[0][1], s[0]), n[1][1] = Math.max(n[1][1], s[1]), s;
    });
    return {
      values: a,
      xyMinMax: n
    };
  }
};
function u$(r, e, t, i) {
  ({}).NODE_ENV !== "production" && Se(t.type === "cartesian2d", "lineX/lineY brush is available only in cartesian2d.");
  var n = t.getAxis(["x", "y"][r]), a = tI(Y([0, 1], function(s) {
    return e ? n.coordToData(n.toLocalCoord(i[s]), !0) : n.toGlobalCoord(n.dataToCoord(i[s]));
  })), o = [];
  return o[r] = a, o[1 - r] = [NaN, NaN], {
    values: a,
    xyMinMax: o
  };
}
var c$ = {
  lineX: Le(h$, 0),
  lineY: Le(h$, 1),
  rect: function(r, e, t) {
    return [[r[0][0] - t[0] * e[0][0], r[0][1] - t[0] * e[0][1]], [r[1][0] - t[1] * e[1][0], r[1][1] - t[1] * e[1][1]]];
  },
  polygon: function(r, e, t) {
    return Y(r, function(i, n) {
      return [i[0] - t[0] * e[n][0], i[1] - t[1] * e[n][1]];
    });
  }
};
function h$(r, e, t, i) {
  return [e[0] - i[r] * t[0], e[1] - i[r] * t[1]];
}
function fRe(r, e) {
  var t = f$(r), i = f$(e), n = [t[0] / i[0], t[1] / i[1]];
  return isNaN(n[0]) && (n[0] = 1), isNaN(n[1]) && (n[1] = 1), n;
}
function f$(r) {
  return r ? [r[0][1] - r[0][0], r[1][1] - r[1][0]] : [NaN, NaN];
}
const Sx = cRe;
var rI = N, dRe = kae("toolbox-dataZoom_"), pRe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, i, n, a) {
      this._brushController || (this._brushController = new tx(n.getZr()), this._brushController.on("brush", ue(this._onBrush, this)).mount()), ORe(t, i, this, a, n), vRe(t, i);
    }, e.prototype.onclick = function(t, i, n) {
      gRe[n].call(this);
    }, e.prototype.remove = function(t, i) {
      this._brushController && this._brushController.unmount();
    }, e.prototype.dispose = function(t, i) {
      this._brushController && this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var i = t.areas;
      if (!t.isEnd || !i.length)
        return;
      var n = {}, a = this.ecModel;
      this._brushController.updateCovers([]);
      var o = new Sx(Tx(this.model), a, {
        include: ["grid"]
      });
      o.matchOutputRanges(i, a, function(u, c, h) {
        if (h.type === "cartesian2d") {
          var f = u.brushType;
          f === "rect" ? (s("x", h, c[0]), s("y", h, c[1])) : s({
            lineX: "x",
            lineY: "y"
          }[f], h, c);
        }
      }), iRe(a, n), this._dispatchZoomAction(n);
      function s(u, c, h) {
        var f = c.getAxis(u), d = f.model, p = l(u, d, a), g = p.findRepresentativeAxisProxy(d).getMinMaxSpan();
        (g.minValueSpan != null || g.maxValueSpan != null) && (h = eh(0, h.slice(), f.scale.getExtent(), 0, g.minValueSpan, g.maxValueSpan)), p && (n[p.id] = {
          dataZoomId: p.id,
          startValue: h[0],
          endValue: h[1]
        });
      }
      function l(u, c, h) {
        var f;
        return h.eachComponent({
          mainType: "dataZoom",
          subType: "select"
        }, function(d) {
          var p = d.getAxisModel(u, c.componentIndex);
          p && (f = d);
        }), f;
      }
    }, e.prototype._dispatchZoomAction = function(t) {
      var i = [];
      rI(t, function(n, a) {
        i.push(ye(n));
      }), i.length && this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        batch: i
      });
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        filterMode: "filter",
        // Icon group
        icon: {
          zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1",
          back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26"
        },
        // `zoom`, `back`
        title: t.getLocaleModel().get(["toolbox", "dataZoom", "title"]),
        brushStyle: {
          borderWidth: 0,
          color: "rgba(210,219,238,0.2)"
        }
      };
      return i;
    }, e;
  }(Bn)
), gRe = {
  zoom: function() {
    var r = !this._isZoomActive;
    this.api.dispatchAction({
      type: "takeGlobalCursor",
      key: "dataZoomSelect",
      dataZoomSelectActive: r
    });
  },
  back: function() {
    this._dispatchZoomAction(nRe(this.ecModel));
  }
};
function Tx(r) {
  var e = {
    xAxisIndex: r.get("xAxisIndex", !0),
    yAxisIndex: r.get("yAxisIndex", !0),
    xAxisId: r.get("xAxisId", !0),
    yAxisId: r.get("yAxisId", !0)
  };
  return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e;
}
function vRe(r, e) {
  r.setIconStatus("back", oRe(e) > 1 ? "emphasis" : "normal");
}
function ORe(r, e, t, i, n) {
  var a = t._isZoomActive;
  i && i.type === "takeGlobalCursor" && (a = i.key === "dataZoomSelect" ? i.dataZoomSelectActive : !1), t._isZoomActive = a, r.setIconStatus("zoom", a ? "emphasis" : "normal");
  var o = new Sx(Tx(r), e, {
    include: ["grid"]
  }), s = o.makePanelOpts(n, function(l) {
    return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect";
  });
  t._brushController.setPanels(s).enableBrush(a && s.length ? {
    brushType: "auto",
    brushStyle: r.getModel("brushStyle").getItemStyle()
  } : !1);
}
vle("dataZoom", function(r) {
  var e = r.getComponent("toolbox", 0), t = ["feature", "dataZoom"];
  if (!e || e.get(t) == null)
    return;
  var i = e.getModel(t), n = [], a = Tx(i), o = Wp(r, a);
  rI(o.xAxisModels, function(l) {
    return s(l, "xAxis", "xAxisIndex");
  }), rI(o.yAxisModels, function(l) {
    return s(l, "yAxis", "yAxisIndex");
  });
  function s(l, u, c) {
    var h = l.componentIndex, f = {
      type: "select",
      $fromToolbox: !0,
      // Default to be filter
      filterMode: i.get("filterMode", !0) || "filter",
      // Id for merge mapping.
      id: dRe + u + h
    };
    f[c] = h, n.push(f);
  }
  return n;
});
const mRe = pRe;
function ERe(r) {
  r.registerComponentModel(k0e), r.registerComponentView(V0e), Vh("saveAsImage", B0e), Vh("magicType", Y0e), Vh("dataView", rRe), Vh("dataZoom", mRe), Vh("restore", lRe), Ye(D0e);
}
var bRe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "tooltip", e.dependencies = ["axisPointer"], e.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      displayMode: "single",
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaut false (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      enterable: !1,
      backgroundColor: "#fff",
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: "#999",
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: "#666",
        fontSize: 14
      }
    }, e;
  }(st)
);
const SRe = bRe;
function DZ(r) {
  var e = r.get("confine");
  return e != null ? !!e : r.get("renderMode") === "richText";
}
function MZ(r) {
  if (ct.domSupported) {
    for (var e = document.documentElement.style, t = 0, i = r.length; t < i; t++)
      if (r[t] in e)
        return r[t];
  }
}
var kZ = MZ(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), TRe = MZ(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function QZ(r, e) {
  if (!r)
    return e;
  e = hW(e, !0);
  var t = r.indexOf(e);
  return r = t === -1 ? e : "-" + r.slice(0, t) + "-" + e, r.toLowerCase();
}
function yRe(r, e) {
  var t = r.currentStyle || document.defaultView && document.defaultView.getComputedStyle(r);
  return t ? e ? t[e] : t : null;
}
var RRe = QZ(TRe, "transition"), yx = QZ(kZ, "transform"), ARe = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (ct.transform3dSupported ? "will-change:transform;" : "");
function _Re(r) {
  return r = r === "left" ? "right" : r === "right" ? "left" : r === "top" ? "bottom" : "top", r;
}
function CRe(r, e, t) {
  if (!ne(t) || t === "inside")
    return "";
  var i = r.get("backgroundColor"), n = r.get("borderWidth");
  e = Pc(e);
  var a = _Re(t), o = Math.max(Math.round(n) * 1.5, 6), s = "", l = yx + ":", u;
  Fe(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, h = o + n, f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), d = Math.round(((f - Math.SQRT2 * n) / 2 + Math.SQRT2 * n - (f - h) / 2) * 100) / 100;
  s += ";" + a + ":-" + d + "px";
  var p = e + " solid " + n + "px;", g = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + i + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function IRe(r, e) {
  var t = "cubic-bezier(0.23,1,0.32,1)", i = " " + r / 2 + "s " + t, n = "opacity" + i + ",visibility" + i;
  return e || (i = " " + r + "s " + t, n += ct.transformSupported ? "," + yx + i : ",left" + i + ",top" + i), RRe + ":" + n;
}
function d$(r, e, t) {
  var i = r.toFixed(0) + "px", n = e.toFixed(0) + "px";
  if (!ct.transformSupported)
    return t ? "top:" + n + ";left:" + i + ";" : [["top", n], ["left", i]];
  var a = ct.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + i + "," + n + (a ? ",0" : "") + ")";
  return t ? "top:0;left:0;" + yx + ":" + o + ";" : [["top", 0], ["left", 0], [kZ, o]];
}
function wRe(r) {
  var e = [], t = r.get("fontSize"), i = r.getTextColor();
  i && e.push("color:" + i), e.push("font:" + r.getFont()), t && e.push("line-height:" + Math.round(t * 3 / 2) + "px");
  var n = r.get("textShadowColor"), a = r.get("textShadowBlur") || 0, o = r.get("textShadowOffsetX") || 0, s = r.get("textShadowOffsetY") || 0;
  return n && a && e.push("text-shadow:" + o + "px " + s + "px " + a + "px " + n), N(["decoration", "align"], function(l) {
    var u = r.get(l);
    u && e.push("text-" + l + ":" + u);
  }), e.join(";");
}
function NRe(r, e, t) {
  var i = [], n = r.get("transitionDuration"), a = r.get("backgroundColor"), o = r.get("shadowBlur"), s = r.get("shadowColor"), l = r.get("shadowOffsetX"), u = r.get("shadowOffsetY"), c = r.getModel("textStyle"), h = HW(r, "html"), f = l + "px " + u + "px " + o + "px " + s;
  return i.push("box-shadow:" + f), e && n && i.push(IRe(n, t)), a && i.push("background-color:" + a), N(["width", "color", "radius"], function(d) {
    var p = "border-" + d, g = hW(p), v = r.get(g);
    v != null && i.push(p + ":" + v + (d === "color" ? "" : "px"));
  }), i.push(wRe(c)), h != null && i.push("padding:" + id(h).join("px ") + "px"), i.join(";") + ";";
}
function p$(r, e, t, i, n) {
  var a = e && e.painter;
  if (t) {
    var o = a && a.getViewportRoot();
    o && ane(r, o, document.body, i, n);
  } else {
    r[0] = i, r[1] = n;
    var s = a && a.getViewportRootOffset();
    s && (r[0] += s.offsetLeft, r[1] += s.offsetTop);
  }
  r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
}
var xRe = (
  /** @class */
  function() {
    function r(e, t, i) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, ct.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var a = this._zr = t.getZr(), o = this._appendToBody = i && i.appendToBody;
      p$(this._styleCoord, a, o, t.getWidth() / 2, t.getHeight() / 2), o ? document.body.appendChild(n) : e.appendChild(n), this._container = e;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = a.handler, c = a.painter.getViewportRoot();
          kn(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return r.prototype.update = function(e) {
      var t = this._container, i = yRe(t, "position"), n = t.style;
      n.position !== "absolute" && i !== "absolute" && (n.position = "relative");
      var a = e.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "";
    }, r.prototype.show = function(e, t) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var i = this.el, n = i.style, a = this._styleCoord;
      i.innerHTML ? n.cssText = ARe + NRe(e, !this._firstShow, this._longHide) + d$(a[0], a[1], !0) + ("border-color:" + Pc(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : n.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, r.prototype.setContent = function(e, t, i, n, a) {
      var o = this.el;
      if (e == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (ne(a) && i.get("trigger") === "item" && !DZ(i) && (s = CRe(i, n, a)), ne(e))
        o.innerHTML = e + s;
      else if (e) {
        o.innerHTML = "", X(e) || (e = [e]);
        for (var l = 0; l < e.length; l++)
          _g(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el;
      return [e.offsetWidth, e.offsetHeight];
    }, r.prototype.moveTo = function(e, t) {
      var i = this._styleCoord;
      if (p$(i, this._zr, this._appendToBody, e, t), i[0] != null && i[1] != null) {
        var n = this.el.style, a = d$(i[0], i[1]);
        N(a, function(o) {
          n[o[0]] = o[1];
        });
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      var e = this, t = this.el.style;
      t.visibility = "hidden", t.opacity = "0", ct.transform3dSupported && (t.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return e._longHide = !0;
      }, 500);
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(ue(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this.el.parentNode.removeChild(this.el);
    }, r;
  }()
);
const PRe = xRe;
var LRe = (
  /** @class */
  function() {
    function r(e) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = e.getZr(), v$(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2);
    }
    return r.prototype.update = function(e) {
      var t = e.get("alwaysShowContent");
      t && this._moveIfResized(), this._alwaysShowContent = t;
    }, r.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, r.prototype.setContent = function(e, t, i, n, a) {
      var o = this;
      be(e) && St({}.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = i.getModel("textStyle");
      this.el = new dt({
        style: {
          rich: t.richTextStyles,
          text: e,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: n,
          textShadowColor: s.get("textShadowColor"),
          fill: i.get(["textStyle", "color"]),
          padding: HW(i, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: i.get("z")
      }), N(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = i.get(u);
      }), N(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, r.prototype.setEnterable = function(e) {
      this._enterable = e;
    }, r.prototype.getSize = function() {
      var e = this.el, t = this.el.getBoundingRect(), i = g$(e.style);
      return [t.width + i.left + i.right, t.height + i.top + i.bottom];
    }, r.prototype.moveTo = function(e, t) {
      var i = this.el;
      if (i) {
        var n = this._styleCoord;
        v$(n, this._zr, e, t), e = n[0], t = n[1];
        var a = i.style, o = Gs(a.borderWidth || 0), s = g$(a);
        i.x = e + o + s.left, i.y = t + o + s.top, i.markRedraw();
      }
    }, r.prototype._moveIfResized = function() {
      var e = this._styleCoord[2], t = this._styleCoord[3];
      this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight());
    }, r.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, r.prototype.hideLater = function(e) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(ue(this.hide, this), e)) : this.hide());
    }, r.prototype.isShow = function() {
      return this._show;
    }, r.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, r;
  }()
);
function Gs(r) {
  return Math.max(0, r);
}
function g$(r) {
  var e = Gs(r.shadowBlur || 0), t = Gs(r.shadowOffsetX || 0), i = Gs(r.shadowOffsetY || 0);
  return {
    left: Gs(e - t),
    right: Gs(e + t),
    top: Gs(e - i),
    bottom: Gs(e + i)
  };
}
function v$(r, e, t, i) {
  r[0] = t, r[1] = i, r[2] = r[0] / e.getWidth(), r[3] = r[1] / e.getHeight();
}
const DRe = LRe;
var MRe = new ht({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), kRe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      if (!(ct.node || !i.getDom())) {
        var n = t.getComponent("tooltip"), a = this._renderMode = Fae(n.get("renderMode"));
        this._tooltipContent = a === "richText" ? new DRe(i) : new PRe(i.getDom(), i, {
          appendToBody: n.get("appendToBody", !0)
        });
      }
    }, e.prototype.render = function(t, i, n) {
      if (!(ct.node || !n.getDom())) {
        this.group.removeAll(), this._tooltipModel = t, this._ecModel = i, this._api = n;
        var a = this._tooltipContent;
        a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? ud(this, "_updatePosition", 50, "fixRate") : Qg(this, "_updatePosition");
      }
    }, e.prototype._initGlobalListener = function() {
      var t = this._tooltipModel, i = t.get("triggerOn");
      bZ("itemTooltip", this._api, ue(function(n, a, o) {
        i !== "none" && (i.indexOf(n) >= 0 ? this._tryShow(a, o) : n === "leave" && this._hide(o));
      }, this));
    }, e.prototype._keepShow = function() {
      var t = this._tooltipModel, i = this._ecModel, n = this._api, a = t.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !n.isDisposed() && o.manuallyShowTip(t, i, n, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, e.prototype.manuallyShowTip = function(t, i, n, a) {
      if (!(a.from === this.uid || ct.node || !n.getDom())) {
        var o = O$(a, n);
        this._ticket = "";
        var s = a.dataByCoordSys, l = VRe(a, i, n);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = MRe;
          c.x = a.x, c.y = a.y, c.update(), Pe(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(t, i, n, a))
            return;
          var h = SZ(a, i), f = h.point[0], d = h.point[1];
          f != null && d != null && this._tryShow({
            offsetX: f,
            offsetY: d,
            target: h.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else
          a.x != null && a.y != null && (n.dispatchAction({
            type: "updateAxisPointer",
            x: a.x,
            y: a.y
          }), this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            target: n.getZr().findHover(a.x, a.y).target
          }, o));
      }
    }, e.prototype.manuallyHideTip = function(t, i, n, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(O$(a, n));
    }, e.prototype._manuallyAxisShowTip = function(t, i, n, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = i.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = i.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), h = Zd([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (h.get("trigger") === "axis")
            return n.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, e.prototype._tryShow = function(t, i) {
      var n = t.target, a = this._tooltipModel;
      if (a) {
        this._lastX = t.offsetX, this._lastY = t.offsetY;
        var o = t.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, t);
        else if (n) {
          this._lastDataByCoordSys = null;
          var s, l;
          ju(n, function(u) {
            if (Pe(u).dataIndex != null)
              return s = u, !0;
            if (Pe(u).tooltipConfig != null)
              return l = u, !0;
          }, !0), s ? this._showSeriesItemTooltip(t, s, i) : l ? this._showComponentItemTooltip(t, l, i) : this._hide(i);
        } else
          this._lastDataByCoordSys = null, this._hide(i);
      }
    }, e.prototype._showOrMove = function(t, i) {
      var n = t.get("showDelay");
      i = ue(i, this), clearTimeout(this._showTimout), n > 0 ? this._showTimout = setTimeout(i, n) : i();
    }, e.prototype._showAxisTooltip = function(t, i) {
      var n = this._ecModel, a = this._tooltipModel, o = [i.offsetX, i.offsetY], s = Zd([i.tooltipOption], a), l = this._renderMode, u = [], c = Qr("section", {
        blocks: [],
        noHeader: !0
      }), h = [], f = new P0();
      N(t, function(m) {
        N(m.dataByAxis, function(E) {
          var b = n.getComponent(E.axisDim + "Axis", E.axisIndex), S = E.value;
          if (!(!b || S == null)) {
            var T = OZ(S, b.axis, n, E.seriesDataIndices, E.valueLabelOpt), y = Qr("section", {
              header: T,
              noHeader: !Ea(T),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(y), N(E.seriesDataIndices, function(R) {
              var _ = n.getSeriesByIndex(R.seriesIndex), C = R.dataIndexInside, I = _.getDataParams(C);
              if (!(I.dataIndex < 0)) {
                I.axisDim = E.axisDim, I.axisIndex = E.axisIndex, I.axisType = E.axisType, I.axisId = E.axisId, I.axisValue = AN(b.axis, {
                  value: S
                }), I.axisValueLabel = T, I.marker = f.makeTooltipMarker("item", Pc(I.color), l);
                var w = ek(_.formatTooltip(C, !0, null)), x = w.frag;
                if (x) {
                  var P = Zd([_], a).get("valueFormatter");
                  y.blocks.push(P ? B({
                    valueFormatter: P
                  }, x) : x);
                }
                w.text && h.push(w.text), u.push(I);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var d = i.position, p = s.get("order"), g = ok(c, f, l, p, n.get("useUTC"), s.get("textStyle"));
      g && h.unshift(g);
      var v = l === "richText" ? `

` : "<br/>", O = h.join(v);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(t, u) ? this._updatePosition(s, d, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, O, u, Math.random() + "", o[0], o[1], d, null, f);
      });
    }, e.prototype._showSeriesItemTooltip = function(t, i, n) {
      var a = this._ecModel, o = Pe(i), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, h = o.dataType, f = u.getData(h), d = this._renderMode, p = t.positionDefault, g = Zd([f.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? {
        position: p
      } : null), v = g.get("trigger");
      if (!(v != null && v !== "item")) {
        var O = u.getDataParams(c, h), m = new P0();
        O.marker = m.makeTooltipMarker("item", Pc(O.color), d);
        var E = ek(u.formatTooltip(c, !1, h)), b = g.get("order"), S = g.get("valueFormatter"), T = E.frag, y = T ? ok(S ? B({
          valueFormatter: S
        }, T) : T, m, d, b, a.get("useUTC"), g.get("textStyle")) : E.text, R = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, y, O, R, t.offsetX, t.offsetY, t.position, t.target, m);
        }), n({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: f.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, e.prototype._showComponentItemTooltip = function(t, i, n) {
      var a = Pe(i), o = a.tooltipConfig, s = o.option || {};
      if (ne(s)) {
        var l = s;
        s = {
          content: l,
          // Fixed formatter
          formatter: l
        };
      }
      var u = [s], c = this._ecModel.getComponent(a.componentMainType, a.componentIndex);
      c && u.push(c), u.push({
        formatter: s.content
      });
      var h = t.positionDefault, f = Zd(u, this._tooltipModel, h ? {
        position: h
      } : null), d = f.get("content"), p = Math.random() + "", g = new P0();
      this._showOrMove(f, function() {
        var v = ye(f.get("formatterParams") || {});
        this._showTooltipContent(f, d, v, p, t.offsetX, t.offsetY, t.position, i, g);
      }), n({
        type: "showTip",
        from: this.uid
      });
    }, e.prototype._showTooltipContent = function(t, i, n, a, o, s, l, u, c) {
      if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(t.get("enterable"));
        var f = t.get("formatter");
        l = l || t.get("position");
        var d = i, p = this._getNearestPoint([o, s], n, t.get("trigger"), t.get("borderColor")), g = p.color;
        if (f)
          if (ne(f)) {
            var v = t.ecModel.get("useUTC"), O = X(n) ? n[0] : n, m = O && O.axisType && O.axisType.indexOf("time") >= 0;
            d = f, m && (d = yT(O.axisValue, d, v)), d = fW(d, n, !0);
          } else if (ve(f)) {
            var E = ue(function(b, S) {
              b === this._ticket && (h.setContent(S, c, t, g, l), this._updatePosition(t, l, o, s, h, n, u));
            }, this);
            this._ticket = a, d = f(n, a, E);
          } else
            d = f;
        h.setContent(d, c, t, g, l), h.show(t, g), this._updatePosition(t, l, o, s, h, n, u);
      }
    }, e.prototype._getNearestPoint = function(t, i, n, a) {
      if (n === "axis" || X(i))
        return {
          color: a || (this._renderMode === "html" ? "#fff" : "none")
        };
      if (!X(i))
        return {
          color: a || i.color || i.borderColor
        };
    }, e.prototype._updatePosition = function(t, i, n, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      i = i || t.get("position");
      var h = o.getSize(), f = t.get("align"), d = t.get("verticalAlign"), p = l && l.getBoundingRect().clone();
      if (l && p.applyTransform(l.transform), ve(i) && (i = i([n, a], s, o.el, p, {
        viewSize: [u, c],
        contentSize: h.slice()
      })), X(i))
        n = K(i[0], u), a = K(i[1], c);
      else if (be(i)) {
        var g = i;
        g.width = h[0], g.height = h[1];
        var v = Ir(g, {
          width: u,
          height: c
        });
        n = v.x, a = v.y, f = null, d = null;
      } else if (ne(i) && l) {
        var O = $Re(i, p, h, t.get("borderWidth"));
        n = O[0], a = O[1];
      } else {
        var O = QRe(n, a, o, u, c, f ? null : 20, d ? null : 20);
        n = O[0], a = O[1];
      }
      if (f && (n -= m$(f) ? h[0] / 2 : f === "right" ? h[0] : 0), d && (a -= m$(d) ? h[1] / 2 : d === "bottom" ? h[1] : 0), DZ(t)) {
        var O = URe(n, a, o, u, c);
        n = O[0], a = O[1];
      }
      o.moveTo(n, a);
    }, e.prototype._updateContentNotChangedOnAxis = function(t, i) {
      var n = this._lastDataByCoordSys, a = this._cbParamsList, o = !!n && n.length === t.length;
      return o && N(n, function(s, l) {
        var u = s.dataByAxis || [], c = t[l] || {}, h = c.dataByAxis || [];
        o = o && u.length === h.length, o && N(u, function(f, d) {
          var p = h[d] || {}, g = f.seriesDataIndices || [], v = p.seriesDataIndices || [];
          o = o && f.value === p.value && f.axisType === p.axisType && f.axisId === p.axisId && g.length === v.length, o && N(g, function(O, m) {
            var E = v[m];
            o = o && O.seriesIndex === E.seriesIndex && O.dataIndex === E.dataIndex;
          }), a && N(f.seriesDataIndices, function(O) {
            var m = O.seriesIndex, E = i[m], b = a[m];
            E && b && b.data !== E.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = t, this._cbParamsList = i, !!o;
    }, e.prototype._hide = function(t) {
      this._lastDataByCoordSys = null, t({
        type: "hideTip",
        from: this.uid
      });
    }, e.prototype.dispose = function(t, i) {
      ct.node || !i.getDom() || (Qg(this, "_updatePosition"), this._tooltipContent.dispose(), jC("itemTooltip", i));
    }, e.type = "tooltip", e;
  }(jt)
);
function Zd(r, e, t) {
  var i = e.ecModel, n;
  t ? (n = new Ut(t, i, i), n = new Ut(e.option, n, i)) : n = e;
  for (var a = r.length - 1; a >= 0; a--) {
    var o = r[a];
    o && (o instanceof Ut && (o = o.get("tooltip", !0)), ne(o) && (o = {
      formatter: o
    }), o && (n = new Ut(o, n, i)));
  }
  return n;
}
function O$(r, e) {
  return r.dispatchAction || ue(e.dispatchAction, e);
}
function QRe(r, e, t, i, n, a, o) {
  var s = t.getSize(), l = s[0], u = s[1];
  return a != null && (r + l + a + 2 > i ? r -= l + a : r += a), o != null && (e + u + o > n ? e -= u + o : e += o), [r, e];
}
function URe(r, e, t, i, n) {
  var a = t.getSize(), o = a[0], s = a[1];
  return r = Math.min(r + o, i) - o, e = Math.min(e + s, n) - s, r = Math.max(r, 0), e = Math.max(e, 0), [r, e];
}
function $Re(r, e, t, i) {
  var n = t[0], a = t[1], o = Math.ceil(Math.SQRT2 * i) + 8, s = 0, l = 0, u = e.width, c = e.height;
  switch (r) {
    case "inside":
      s = e.x + u / 2 - n / 2, l = e.y + c / 2 - a / 2;
      break;
    case "top":
      s = e.x + u / 2 - n / 2, l = e.y - a - o;
      break;
    case "bottom":
      s = e.x + u / 2 - n / 2, l = e.y + c + o;
      break;
    case "left":
      s = e.x - n - o, l = e.y + c / 2 - a / 2;
      break;
    case "right":
      s = e.x + u + o, l = e.y + c / 2 - a / 2;
  }
  return [s, l];
}
function m$(r) {
  return r === "center" || r === "middle";
}
function VRe(r, e, t) {
  var i = U1(r).queryOptionMap, n = i.keys()[0];
  if (!(!n || n === "series")) {
    var a = Rv(e, n, i.get(n), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = t.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var c = Pe(u).tooltipConfig;
        if (c && c.name === r.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: n,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
const GRe = kRe;
function BRe(r) {
  Ye(Gv), r.registerComponentModel(SRe), r.registerComponentView(GRe), r.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, ur), r.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, ur);
}
var FRe = ["rect", "polygon", "keep", "clear"];
function XRe(r, e) {
  var t = It(r ? r.brush : []);
  if (t.length) {
    var i = [];
    N(t, function(l) {
      var u = l.hasOwnProperty("toolbox") ? l.toolbox : [];
      u instanceof Array && (i = i.concat(u));
    });
    var n = r && r.toolbox;
    X(n) && (n = n[0]), n || (n = {
      feature: {}
    }, r.toolbox = [n]);
    var a = n.feature || (n.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []);
    s.push.apply(s, i), YRe(s), e && !s.length && s.push.apply(s, FRe);
  }
}
function YRe(r) {
  var e = {};
  N(r, function(t) {
    e[t] = 1;
  }), r.length = 0, N(e, function(t, i) {
    r.push(i);
  });
}
var E$ = N;
function b$(r) {
  if (r) {
    for (var e in r)
      if (r.hasOwnProperty(e))
        return !0;
  }
}
function iI(r, e, t) {
  var i = {};
  return E$(e, function(a) {
    var o = i[a] = n();
    E$(r[a], function(s, l) {
      if (Jr.isValidType(l)) {
        var u = {
          type: l,
          visual: s
        };
        t && t(u, a), o[l] = new Jr(u), l === "opacity" && (u = ye(u), u.type = "colorAlpha", o.__hidden.__alphaForOpacity = new Jr(u));
      }
    });
  }), i;
  function n() {
    var a = function() {
    };
    a.prototype.__hidden = a.prototype;
    var o = new a();
    return o;
  }
}
function UZ(r, e, t) {
  var i;
  N(t, function(n) {
    e.hasOwnProperty(n) && b$(e[n]) && (i = !0);
  }), i && N(t, function(n) {
    e.hasOwnProperty(n) && b$(e[n]) ? r[n] = ye(e[n]) : delete r[n];
  });
}
function HRe(r, e, t, i, n, a) {
  var o = {};
  N(r, function(h) {
    var f = Jr.prepareVisualTypes(e[h]);
    o[h] = f;
  });
  var s;
  function l(h) {
    return gN(t, s, h);
  }
  function u(h, f) {
    rz(t, s, h, f);
  }
  a == null ? t.each(c) : t.each([a], c);
  function c(h, f) {
    s = a == null ? h : f;
    var d = t.getRawDataItem(s);
    if (!(d && d.visualMap === !1))
      for (var p = i.call(n, h), g = e[p], v = o[p], O = 0, m = v.length; O < m; O++) {
        var E = v[O];
        g[E] && g[E].applyVisual(h, l, u);
      }
  }
}
function WRe(r, e, t, i) {
  var n = {};
  return N(r, function(a) {
    var o = Jr.prepareVisualTypes(e[a]);
    n[a] = o;
  }), {
    progress: function(o, s) {
      var l;
      i != null && (l = s.getDimensionIndex(i));
      function u(S) {
        return gN(s, h, S);
      }
      function c(S, T) {
        rz(s, h, S, T);
      }
      for (var h, f = s.getStore(); (h = o.next()) != null; ) {
        var d = s.getRawDataItem(h);
        if (!(d && d.visualMap === !1))
          for (var p = i != null ? f.get(l, h) : h, g = t(p), v = e[g], O = n[g], m = 0, E = O.length; m < E; m++) {
            var b = O[m];
            v[b] && v[b].applyVisual(p, u, c);
          }
      }
    }
  };
}
function zRe(r) {
  var e = r.brushType, t = {
    point: function(i) {
      return S$[e].point(i, t, r);
    },
    rect: function(i) {
      return S$[e].rect(i, t, r);
    }
  };
  return t;
}
var S$ = {
  lineX: T$(0),
  lineY: T$(1),
  rect: {
    point: function(r, e, t) {
      return r && t.boundingRect.contain(r[0], r[1]);
    },
    rect: function(r, e, t) {
      return r && t.boundingRect.intersect(r);
    }
  },
  polygon: {
    point: function(r, e, t) {
      return r && t.boundingRect.contain(r[0], r[1]) && Qu(t.range, r[0], r[1]);
    },
    rect: function(r, e, t) {
      var i = t.range;
      if (!r || i.length <= 1)
        return !1;
      var n = r.x, a = r.y, o = r.width, s = r.height, l = i[0];
      if (Qu(i, n, a) || Qu(i, n + o, a) || Qu(i, n, a + s) || Qu(i, n + o, a + s) || Ve.create(r).contain(l[0], l[1]) || mp(n, a, n + o, a, i) || mp(n, a, n, a + s, i) || mp(n + o, a, n + o, a + s, i) || mp(n, a + s, n + o, a + s, i))
        return !0;
    }
  }
};
function T$(r) {
  var e = ["x", "y"], t = ["width", "height"];
  return {
    point: function(i, n, a) {
      if (i) {
        var o = a.range, s = i[r];
        return qd(s, o);
      }
    },
    rect: function(i, n, a) {
      if (i) {
        var o = a.range, s = [i[e[r]], i[e[r]] + i[t[r]]];
        return s[1] < s[0] && s.reverse(), qd(s[0], o) || qd(s[1], o) || qd(o[0], s) || qd(o[1], s);
      }
    }
  };
}
function qd(r, e) {
  return e[0] <= r && r <= e[1];
}
var y$ = ["inBrush", "outOfBrush"], ZR = "__ecBrushSelect", nI = "__ecInBrushSelectEvent";
function $Z(r) {
  r.eachComponent({
    mainType: "brush"
  }, function(e) {
    var t = e.brushTargetManager = new Sx(e.option, r);
    t.setInputRanges(e.areas, r);
  });
}
function ZRe(r, e, t) {
  var i = [], n, a;
  r.eachComponent({
    mainType: "brush"
  }, function(o) {
    t && t.type === "takeGlobalCursor" && o.setBrushOption(t.key === "brush" ? t.brushOption : {
      brushType: !1
    });
  }), $Z(r), r.eachComponent({
    mainType: "brush"
  }, function(o, s) {
    var l = {
      brushId: o.id,
      brushIndex: s,
      brushName: o.name,
      areas: ye(o.areas),
      selected: []
    };
    i.push(l);
    var u = o.option, c = u.brushLink, h = [], f = [], d = [], p = !1;
    s || (n = u.throttleType, a = u.throttleDelay);
    var g = Y(o.areas, function(S) {
      var T = JRe[S.brushType], y = Te({
        boundingRect: T ? T(S) : void 0
      }, S);
      return y.selectors = zRe(y), y;
    }), v = iI(o.option, y$, function(S) {
      S.mappingMethod = "fixed";
    });
    X(c) && N(c, function(S) {
      h[S] = 1;
    });
    function O(S) {
      return c === "all" || !!h[S];
    }
    function m(S) {
      return !!S.length;
    }
    r.eachSeries(function(S, T) {
      var y = d[T] = [];
      S.subType === "parallel" ? E(S, T) : b(S, T, y);
    });
    function E(S, T) {
      var y = S.coordinateSystem;
      p = p || y.hasAxisBrushed(), O(T) && y.eachActiveState(S.getData(), function(R, _) {
        R === "active" && (f[_] = 1);
      });
    }
    function b(S, T, y) {
      if (!(!S.brushSelector || KRe(o, T)) && (N(g, function(_) {
        o.brushTargetManager.controlSeries(_, S, r) && y.push(_), p = p || m(y);
      }), O(T) && m(y))) {
        var R = S.getData();
        R.each(function(_) {
          R$(S, y, R, _) && (f[_] = 1);
        });
      }
    }
    r.eachSeries(function(S, T) {
      var y = {
        seriesId: S.id,
        seriesIndex: T,
        seriesName: S.name,
        dataIndex: []
      };
      l.selected.push(y);
      var R = d[T], _ = S.getData(), C = O(T) ? function(I) {
        return f[I] ? (y.dataIndex.push(_.getRawIndex(I)), "inBrush") : "outOfBrush";
      } : function(I) {
        return R$(S, R, _, I) ? (y.dataIndex.push(_.getRawIndex(I)), "inBrush") : "outOfBrush";
      };
      (O(T) ? p : m(R)) && HRe(y$, v, _, C);
    });
  }), qRe(e, n, a, i, t);
}
function qRe(r, e, t, i, n) {
  if (n) {
    var a = r.getZr();
    if (!a[nI]) {
      a[ZR] || (a[ZR] = jRe);
      var o = ud(a, ZR, t, e);
      o(r, i);
    }
  }
}
function jRe(r, e) {
  if (!r.isDisposed()) {
    var t = r.getZr();
    t[nI] = !0, r.dispatchAction({
      type: "brushSelect",
      batch: e
    }), t[nI] = !1;
  }
}
function R$(r, e, t, i) {
  for (var n = 0, a = e.length; n < a; n++) {
    var o = e[n];
    if (r.brushSelector(i, t, o.selectors, o))
      return !0;
  }
}
function KRe(r, e) {
  var t = r.option.seriesIndex;
  return t != null && t !== "all" && (X(t) ? Fe(t, e) < 0 : e !== t);
}
var JRe = {
  rect: function(r) {
    return A$(r.range);
  },
  polygon: function(r) {
    for (var e, t = r.range, i = 0, n = t.length; i < n; i++) {
      e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]];
      var a = t[i];
      a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]);
    }
    return e && A$(e);
  }
};
function A$(r) {
  return new Ve(r[0][0], r[1][0], r[0][1] - r[0][0], r[1][1] - r[1][0]);
}
var eAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      this.ecModel = t, this.api = i, this.model, (this._brushController = new tx(i.getZr())).on("brush", ue(this._onBrush, this)).mount();
    }, e.prototype.render = function(t, i, n, a) {
      this.model = t, this._updateController(t, i, n, a);
    }, e.prototype.updateTransform = function(t, i, n, a) {
      $Z(i), this._updateController(t, i, n, a);
    }, e.prototype.updateVisual = function(t, i, n, a) {
      this.updateTransform(t, i, n, a);
    }, e.prototype.updateView = function(t, i, n, a) {
      this._updateController(t, i, n, a);
    }, e.prototype._updateController = function(t, i, n, a) {
      (!a || a.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(n)).enableBrush(t.brushOption).updateCovers(t.areas.slice());
    }, e.prototype.dispose = function() {
      this._brushController.dispose();
    }, e.prototype._onBrush = function(t) {
      var i = this.model.id, n = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel);
      (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({
        type: "brush",
        brushId: i,
        areas: ye(n),
        $from: i
      }), t.isEnd && this.api.dispatchAction({
        type: "brushEnd",
        brushId: i,
        areas: ye(n),
        $from: i
      });
    }, e.type = "brush", e;
  }(jt)
);
const tAe = eAe;
var rAe = "#ddd", iAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.areas = [], t.brushOption = {}, t;
    }
    return e.prototype.optionUpdated = function(t, i) {
      var n = this.option;
      !i && UZ(n, t, ["inBrush", "outOfBrush"]);
      var a = n.inBrush = n.inBrush || {};
      n.outOfBrush = n.outOfBrush || {
        color: rAe
      }, a.hasOwnProperty("liftZ") || (a.liftZ = 5);
    }, e.prototype.setAreas = function(t) {
      ({}).NODE_ENV !== "production" && (Se(X(t)), N(t, function(i) {
        Se(i.brushType, "Illegal areas");
      })), t && (this.areas = Y(t, function(i) {
        return _$(this.option, i);
      }, this));
    }, e.prototype.setBrushOption = function(t) {
      this.brushOption = _$(this.option, t), this.brushType = this.brushOption.brushType;
    }, e.type = "brush", e.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], e.defaultOption = {
      seriesIndex: "all",
      brushType: "rect",
      brushMode: "single",
      transformable: !0,
      brushStyle: {
        borderWidth: 1,
        color: "rgba(210,219,238,0.3)",
        borderColor: "#D2DBEE"
      },
      throttleType: "fixRate",
      throttleDelay: 0,
      removeOnClick: !0,
      z: 1e4
    }, e;
  }(st)
);
function _$(r, e) {
  return $e({
    brushType: r.brushType,
    brushMode: r.brushMode,
    transformable: r.transformable,
    brushStyle: new Ut(r.brushStyle).getItemStyle(),
    removeOnClick: r.removeOnClick,
    z: r.z
  }, e, !0);
}
const nAe = iAe;
var aAe = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], oAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      return r !== null && r.apply(this, arguments) || this;
    }
    return e.prototype.render = function(t, i, n) {
      var a, o, s;
      i.eachComponent({
        mainType: "brush"
      }, function(l) {
        a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length;
      }), this._brushType = a, this._brushMode = o, N(t.get("type", !0), function(l) {
        t.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal");
      });
    }, e.prototype.updateView = function(t, i, n) {
      this.render(t, i, n);
    }, e.prototype.getIcons = function() {
      var t = this.model, i = t.get("icon", !0), n = {};
      return N(t.get("type", !0), function(a) {
        i[a] && (n[a] = i[a]);
      }), n;
    }, e.prototype.onclick = function(t, i, n) {
      var a = this._brushType, o = this._brushMode;
      n === "clear" ? (i.dispatchAction({
        type: "axisAreaSelect",
        intervals: []
      }), i.dispatchAction({
        type: "brush",
        command: "clear",
        // Clear all areas of all brush components.
        areas: []
      })) : i.dispatchAction({
        type: "takeGlobalCursor",
        key: "brush",
        brushOption: {
          brushType: n === "keep" ? a : a === n ? !1 : n,
          brushMode: n === "keep" ? o === "multiple" ? "single" : "multiple" : o
        }
      });
    }, e.getDefaultOption = function(t) {
      var i = {
        show: !0,
        type: aAe.slice(),
        icon: {
          /* eslint-disable */
          rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13",
          polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2",
          lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4",
          lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4",
          keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z",
          clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2"
          // jshint ignore:line
          /* eslint-enable */
        },
        // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
        title: t.getLocaleModel().get(["toolbox", "brush", "title"])
      };
      return i;
    }, e;
  }(Bn)
);
const sAe = oAe;
function lAe(r) {
  r.registerComponentView(tAe), r.registerComponentModel(nAe), r.registerPreprocessor(XRe), r.registerVisual(r.PRIORITY.VISUAL.BRUSH, ZRe), r.registerAction({
    type: "brush",
    event: "brush",
    update: "updateVisual"
  }, function(e, t) {
    t.eachComponent({
      mainType: "brush",
      query: e
    }, function(i) {
      i.setAreas(e.areas);
    });
  }), r.registerAction({
    type: "brushSelect",
    event: "brushSelected",
    update: "none"
  }, ur), r.registerAction({
    type: "brushEnd",
    event: "brushEnd",
    update: "none"
  }, ur), Vh("brush", sAe);
}
var uAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t;
    }
    return e.type = "title", e.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: 0,
      top: 0,
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: "#464646"
      },
      subtextStyle: {
        fontSize: 12,
        color: "#6E7079"
      }
    }, e;
  }(st)
), cAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.render = function(t, i, n) {
      if (this.group.removeAll(), !!t.get("show")) {
        var a = this.group, o = t.getModel("textStyle"), s = t.getModel("subtextStyle"), l = t.get("textAlign"), u = ke(t.get("textBaseline"), t.get("textVerticalAlign")), c = new dt({
          style: Qt(o, {
            text: t.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = c.getBoundingRect(), f = t.get("subtext"), d = new dt({
          style: Qt(s, {
            text: f,
            fill: s.getTextColor(),
            y: h.height + t.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), p = t.get("link"), g = t.get("sublink"), v = t.get("triggerEvent", !0);
        c.silent = !p && !v, d.silent = !g && !v, p && c.on("click", function() {
          fb(p, "_" + t.get("target"));
        }), g && d.on("click", function() {
          fb(g, "_" + t.get("subtarget"));
        }), Pe(c).eventData = Pe(d).eventData = v ? {
          componentType: "title",
          componentIndex: t.componentIndex
        } : null, a.add(c), f && a.add(d);
        var O = a.getBoundingRect(), m = t.getBoxLayoutParams();
        m.width = O.width, m.height = O.height;
        var E = Ir(m, {
          width: n.getWidth(),
          height: n.getHeight()
        }, t.get("padding"));
        l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? E.x += E.width : l === "center" && (E.x += E.width / 2)), u || (u = t.get("top") || t.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? E.y += E.height : u === "middle" && (E.y += E.height / 2), u = u || "top"), a.x = E.x, a.y = E.y, a.markRedraw();
        var b = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(b), d.setStyle(b), O = a.getBoundingRect();
        var S = E.margin, T = t.getItemStyle(["color", "opacity"]);
        T.fill = t.get("backgroundColor");
        var y = new ht({
          shape: {
            x: O.x - S[3],
            y: O.y - S[0],
            width: O.width + S[1] + S[3],
            height: O.height + S[0] + S[2],
            r: t.get("borderRadius")
          },
          style: T,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(y);
      }
    }, e.type = "title", e;
  }(jt)
);
function hAe(r) {
  r.registerComponentModel(uAe), r.registerComponentView(cAe);
}
var fAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = "box", t;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n), this._initData();
    }, e.prototype.mergeOption = function(t) {
      r.prototype.mergeOption.apply(this, arguments), this._initData();
    }, e.prototype.setCurrentIndex = function(t) {
      t == null && (t = this.option.currentIndex);
      var i = this._data.count();
      this.option.loop ? t = (t % i + i) % i : (t >= i && (t = i - 1), t < 0 && (t = 0)), this.option.currentIndex = t;
    }, e.prototype.getCurrentIndex = function() {
      return this.option.currentIndex;
    }, e.prototype.isIndexMax = function() {
      return this.getCurrentIndex() >= this._data.count() - 1;
    }, e.prototype.setPlayState = function(t) {
      this.option.autoPlay = !!t;
    }, e.prototype.getPlayState = function() {
      return !!this.option.autoPlay;
    }, e.prototype._initData = function() {
      var t = this.option, i = t.data || [], n = t.axisType, a = this._names = [], o;
      n === "category" ? (o = [], N(i, function(u, c) {
        var h = Ar(jf(u), ""), f;
        be(u) ? (f = ye(u), f.value = c) : f = c, o.push(f), a.push(h);
      })) : o = i;
      var s = {
        category: "ordinal",
        time: "time",
        value: "number"
      }[n] || "number", l = this._data = new ki([{
        name: "value",
        type: s
      }], this);
      l.initData(o, a);
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.getCategories = function() {
      if (this.get("axisType") === "category")
        return this._names.slice();
    }, e.type = "timeline", e.defaultOption = {
      // zlevel: 0,                  // 
      z: 4,
      show: !0,
      axisType: "time",
      realtime: !0,
      left: "20%",
      top: null,
      right: "20%",
      bottom: 0,
      width: null,
      height: 40,
      padding: 5,
      controlPosition: "left",
      autoPlay: !1,
      rewind: !1,
      loop: !0,
      playInterval: 2e3,
      currentIndex: 0,
      itemStyle: {},
      label: {
        color: "#000"
      },
      data: []
    }, e;
  }(st)
);
const C$ = fAe;
var VZ = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline.slider", e.defaultOption = Zl(C$.defaultOption, {
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderWidth: 0,
      orient: "horizontal",
      inverse: !1,
      tooltip: {
        trigger: "item"
        // data item may also have tootip attr.
      },
      symbol: "circle",
      symbolSize: 12,
      lineStyle: {
        show: !0,
        width: 2,
        color: "#DAE1F5"
      },
      label: {
        position: "auto",
        // When using number, label position is not
        // restricted by viewRect.
        // positive: right/bottom, negative: left/top
        show: !0,
        interval: "auto",
        rotate: 0,
        // formatter: null,
        // TEXTSTYLE
        color: "#A4B1D7"
      },
      itemStyle: {
        color: "#A4B1D7",
        borderWidth: 1
      },
      checkpointStyle: {
        symbol: "circle",
        symbolSize: 15,
        color: "#316bf3",
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0, 0, 0, 0.3)",
        // borderColor: 'rgba(194,53,49, 0.5)',
        animation: !0,
        animationDuration: 300,
        animationEasing: "quinticInOut"
      },
      controlStyle: {
        show: !0,
        showPlayBtn: !0,
        showPrevBtn: !0,
        showNextBtn: !0,
        itemSize: 24,
        itemGap: 12,
        position: "left",
        playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z",
        stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z",
        // eslint-disable-next-line max-len
        nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z",
        // eslint-disable-next-line max-len
        prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z",
        prevBtnSize: 18,
        nextBtnSize: 18,
        color: "#A4B1D7",
        borderColor: "#A4B1D7",
        borderWidth: 1
      },
      emphasis: {
        label: {
          show: !0,
          // TEXTSTYLE
          color: "#6f778d"
        },
        itemStyle: {
          color: "#316BF3"
        },
        controlStyle: {
          color: "#316BF3",
          borderColor: "#316BF3",
          borderWidth: 2
        }
      },
      progress: {
        lineStyle: {
          color: "#316BF3"
        },
        itemStyle: {
          color: "#316BF3"
        },
        label: {
          color: "#6f778d"
        }
      },
      data: []
    }), e;
  }(C$)
);
br(VZ, cN.prototype);
const dAe = VZ;
var pAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "timeline", e;
  }(jt)
);
const gAe = pAe;
var vAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e(t, i, n, a) {
      var o = r.call(this, t, i, n) || this;
      return o.type = a || "value", o;
    }
    return e.prototype.getLabelModel = function() {
      return this.model.getModel("label");
    }, e.prototype.isHorizontal = function() {
      return this.model.get("orient") === "horizontal";
    }, e;
  }(Ma)
);
const OAe = vAe;
var qR = Math.PI, I$ = ft(), mAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function(t, i) {
      this.api = i;
    }, e.prototype.render = function(t, i, n) {
      if (this.model = t, this.api = n, this.ecModel = i, this.group.removeAll(), t.get("show", !0)) {
        var a = this._layout(t, n), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, t);
        t.formatTooltip = function(u) {
          var c = l.scale.getLabel({
            value: u
          });
          return Qr("nameValue", {
            noName: !0,
            value: c
          });
        }, N(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function(u) {
          this["_render" + u](a, o, l, t);
        }, this), this._renderAxisLabel(a, s, l, t), this._position(a, t);
      }
      this._doPlayStop(), this._updateTicksStatus();
    }, e.prototype.remove = function() {
      this._clearTimer(), this.group.removeAll();
    }, e.prototype.dispose = function() {
      this._clearTimer();
    }, e.prototype._layout = function(t, i) {
      var n = t.get(["label", "position"]), a = t.get("orient"), o = bAe(t, i), s;
      n == null || n === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < i.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < i.getWidth() / 2 ? "+" : "-" : ne(n) ? s = {
        horizontal: {
          top: "-",
          bottom: "+"
        },
        vertical: {
          left: "-",
          right: "+"
        }
      }[a][n] : s = n;
      var l = {
        horizontal: "center",
        vertical: s >= 0 || s === "+" ? "left" : "right"
      }, u = {
        horizontal: s >= 0 || s === "+" ? "top" : "bottom",
        vertical: "middle"
      }, c = {
        horizontal: 0,
        vertical: qR / 2
      }, h = a === "vertical" ? o.height : o.width, f = t.getModel("controlStyle"), d = f.get("show", !0), p = d ? f.get("itemSize") : 0, g = d ? f.get("itemGap") : 0, v = p + g, O = t.get(["label", "rotate"]) || 0;
      O = O * qR / 180;
      var m, E, b, S = f.get("position", !0), T = d && f.get("showPlayBtn", !0), y = d && f.get("showPrevBtn", !0), R = d && f.get("showNextBtn", !0), _ = 0, C = h;
      S === "left" || S === "bottom" ? (T && (m = [0, 0], _ += v), y && (E = [_, 0], _ += v), R && (b = [C - p, 0], C -= v)) : (T && (m = [C - p, 0], C -= v), y && (E = [0, 0], _ += v), R && (b = [C - p, 0], C -= v));
      var I = [_, C];
      return t.get("inverse") && I.reverse(), {
        viewRect: o,
        mainLength: h,
        orient: a,
        rotation: c[a],
        labelRotation: O,
        labelPosOpt: s,
        labelAlign: t.get(["label", "align"]) || l[a],
        labelBaseline: t.get(["label", "verticalAlign"]) || t.get(["label", "baseline"]) || u[a],
        // Based on mainGroup.
        playPosition: m,
        prevBtnPosition: E,
        nextBtnPosition: b,
        axisExtent: I,
        controlSize: p,
        controlGap: g
      };
    }, e.prototype._position = function(t, i) {
      var n = this._mainGroup, a = this._labelGroup, o = t.viewRect;
      if (t.orient === "vertical") {
        var s = na(), l = o.x, u = o.y + o.height;
        yo(s, s, [-l, -u]), zc(s, s, -qR / 2), yo(s, s, [l, u]), o = o.clone(), o.applyTransform(s);
      }
      var c = m(o), h = m(n.getBoundingRect()), f = m(a.getBoundingRect()), d = [n.x, n.y], p = [a.x, a.y];
      p[0] = d[0] = c[0][0];
      var g = t.labelPosOpt;
      if (g == null || ne(g)) {
        var v = g === "+" ? 0 : 1;
        E(d, h, c, 1, v), E(p, f, c, 1, 1 - v);
      } else {
        var v = g >= 0 ? 0 : 1;
        E(d, h, c, 1, v), p[1] = d[1] + g;
      }
      n.setPosition(d), a.setPosition(p), n.rotation = a.rotation = t.rotation, O(n), O(a);
      function O(b) {
        b.originX = c[0][0] - b.x, b.originY = c[1][0] - b.y;
      }
      function m(b) {
        return [[b.x, b.x + b.width], [b.y, b.y + b.height]];
      }
      function E(b, S, T, y, R) {
        b[y] += T[y][R] - S[y][R];
      }
    }, e.prototype._createAxis = function(t, i) {
      var n = i.getData(), a = i.get("axisType"), o = EAe(i, a);
      o.getTicks = function() {
        return n.mapArray(["value"], function(u) {
          return {
            value: u
          };
        });
      };
      var s = n.getDataExtent("value");
      o.setExtent(s[0], s[1]), o.calcNiceTicks();
      var l = new OAe("value", o, t.axisExtent, a);
      return l.model = i, l;
    }, e.prototype._createGroup = function(t) {
      var i = this[t] = new Re();
      return this.group.add(i), i;
    }, e.prototype._renderAxisLine = function(t, i, n, a) {
      var o = n.getExtent();
      if (a.get(["lineStyle", "show"])) {
        var s = new Gr({
          shape: {
            x1: o[0],
            y1: 0,
            x2: o[1],
            y2: 0
          },
          style: B({
            lineCap: "round"
          }, a.getModel("lineStyle").getLineStyle()),
          silent: !0,
          z2: 1
        });
        i.add(s);
        var l = this._progressLine = new Gr({
          shape: {
            x1: o[0],
            x2: this._currentPointer ? this._currentPointer.x : o[0],
            y1: 0,
            y2: 0
          },
          style: Te({
            lineCap: "round",
            lineWidth: s.style.lineWidth
          }, a.getModel(["progress", "lineStyle"]).getLineStyle()),
          silent: !0,
          z2: 1
        });
        i.add(l);
      }
    }, e.prototype._renderAxisTick = function(t, i, n, a) {
      var o = this, s = a.getData(), l = n.scale.getTicks();
      this._tickSymbols = [], N(l, function(u) {
        var c = n.dataToCoord(u.value), h = s.getItemModel(u.value), f = h.getModel("itemStyle"), d = h.getModel(["emphasis", "itemStyle"]), p = h.getModel(["progress", "itemStyle"]), g = {
          x: c,
          y: 0,
          onclick: ue(o._changeTimeline, o, u.value)
        }, v = w$(h, f, i, g);
        v.ensureState("emphasis").style = d.getItemStyle(), v.ensureState("progress").style = p.getItemStyle(), pc(v);
        var O = Pe(v);
        h.get("tooltip") ? (O.dataIndex = u.value, O.dataModel = a) : O.dataIndex = O.dataModel = null, o._tickSymbols.push(v);
      });
    }, e.prototype._renderAxisLabel = function(t, i, n, a) {
      var o = this, s = n.getLabelModel();
      if (s.get("show")) {
        var l = a.getData(), u = n.getViewLabels();
        this._tickLabels = [], N(u, function(c) {
          var h = c.tickValue, f = l.getItemModel(h), d = f.getModel("label"), p = f.getModel(["emphasis", "label"]), g = f.getModel(["progress", "label"]), v = n.dataToCoord(c.tickValue), O = new dt({
            x: v,
            y: 0,
            rotation: t.labelRotation - t.rotation,
            onclick: ue(o._changeTimeline, o, h),
            silent: !1,
            style: Qt(d, {
              text: c.formattedLabel,
              align: t.labelAlign,
              verticalAlign: t.labelBaseline
            })
          });
          O.ensureState("emphasis").style = Qt(p), O.ensureState("progress").style = Qt(g), i.add(O), pc(O), I$(O).dataIndex = h, o._tickLabels.push(O);
        });
      }
    }, e.prototype._renderControl = function(t, i, n, a) {
      var o = t.controlSize, s = t.rotation, l = a.getModel("controlStyle").getItemStyle(), u = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), c = a.getPlayState(), h = a.get("inverse", !0);
      f(t.nextBtnPosition, "next", ue(this._changeTimeline, this, h ? "-" : "+")), f(t.prevBtnPosition, "prev", ue(this._changeTimeline, this, h ? "+" : "-")), f(t.playPosition, c ? "stop" : "play", ue(this._handlePlayClick, this, !c), !0);
      function f(d, p, g, v) {
        if (d) {
          var O = xa(ke(a.get(["controlStyle", p + "BtnSize"]), o), o), m = [0, -O / 2, O, O], E = SAe(a, p + "Icon", m, {
            x: d[0],
            y: d[1],
            originX: o / 2,
            originY: 0,
            rotation: v ? -s : 0,
            rectHover: !0,
            style: l,
            onclick: g
          });
          E.ensureState("emphasis").style = u, i.add(E), pc(E);
        }
      }
    }, e.prototype._renderCurrentPointer = function(t, i, n, a) {
      var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), u = this, c = {
        onCreate: function(h) {
          h.draggable = !0, h.drift = ue(u._handlePointerDrag, u), h.ondragend = ue(u._handlePointerDragend, u), N$(h, u._progressLine, s, n, a, !0);
        },
        onUpdate: function(h) {
          N$(h, u._progressLine, s, n, a);
        }
      };
      this._currentPointer = w$(l, l, this._mainGroup, {}, this._currentPointer, c);
    }, e.prototype._handlePlayClick = function(t) {
      this._clearTimer(), this.api.dispatchAction({
        type: "timelinePlayChange",
        playState: t,
        from: this.uid
      });
    }, e.prototype._handlePointerDrag = function(t, i, n) {
      this._clearTimer(), this._pointerChangeTimeline([n.offsetX, n.offsetY]);
    }, e.prototype._handlePointerDragend = function(t) {
      this._pointerChangeTimeline([t.offsetX, t.offsetY], !0);
    }, e.prototype._pointerChangeTimeline = function(t, i) {
      var n = this._toAxisCoord(t)[0], a = this._axis, o = Zn(a.getExtent().slice());
      n > o[1] && (n = o[1]), n < o[0] && (n = o[0]), this._currentPointer.x = n, this._currentPointer.markRedraw();
      var s = this._progressLine;
      s && (s.shape.x2 = n, s.dirty());
      var l = this._findNearestTick(n), u = this.model;
      (i || l !== u.getCurrentIndex() && u.get("realtime")) && this._changeTimeline(l);
    }, e.prototype._doPlayStop = function() {
      var t = this;
      this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function() {
        var i = t.model;
        t._changeTimeline(i.getCurrentIndex() + (i.get("rewind", !0) ? -1 : 1));
      }, this.model.get("playInterval")));
    }, e.prototype._toAxisCoord = function(t) {
      var i = this._mainGroup.getLocalTransform();
      return Ia(t, i, !0);
    }, e.prototype._findNearestTick = function(t) {
      var i = this.model.getData(), n = 1 / 0, a, o = this._axis;
      return i.each(["value"], function(s, l) {
        var u = o.dataToCoord(s), c = Math.abs(u - t);
        c < n && (n = c, a = l);
      }), a;
    }, e.prototype._clearTimer = function() {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, e.prototype._changeTimeline = function(t) {
      var i = this.model.getCurrentIndex();
      t === "+" ? t = i + 1 : t === "-" && (t = i - 1), this.api.dispatchAction({
        type: "timelineChange",
        currentIndex: t,
        from: this.uid
      });
    }, e.prototype._updateTicksStatus = function() {
      var t = this.model.getCurrentIndex(), i = this._tickSymbols, n = this._tickLabels;
      if (i)
        for (var a = 0; a < i.length; a++)
          i && i[a] && i[a].toggleState("progress", a < t);
      if (n)
        for (var a = 0; a < n.length; a++)
          n && n[a] && n[a].toggleState("progress", I$(n[a]).dataIndex <= t);
    }, e.type = "timeline.slider", e;
  }(gAe)
);
function EAe(r, e) {
  if (e = e || r.get("type"), e)
    switch (e) {
      case "category":
        return new SN({
          ordinalMeta: r.getCategories(),
          extent: [1 / 0, -1 / 0]
        });
      case "time":
        return new Bz({
          locale: r.ecModel.getLocaleModel(),
          useUTC: r.ecModel.get("useUTC")
        });
      default:
        return new Dl();
    }
}
function bAe(r, e) {
  return Ir(r.getBoxLayoutParams(), {
    width: e.getWidth(),
    height: e.getHeight()
  }, r.get("padding"));
}
function SAe(r, e, t, i) {
  var n = i.style, a = Iv(r.get(["controlStyle", e]), i || {}, new Ve(t[0], t[1], t[2], t[3]));
  return n && a.setStyle(n), a;
}
function w$(r, e, t, i, n, a) {
  var o = e.get("color");
  if (n)
    n.setColor(o), t.add(n), a && a.onUpdate(n);
  else {
    var s = r.get("symbol");
    n = Er(s, -1, -1, 2, 2, o), n.setStyle("strokeNoScale", !0), t.add(n), a && a.onCreate(n);
  }
  var l = e.getItemStyle(["color"]);
  n.setStyle(l), i = $e({
    rectHover: !0,
    z2: 100
  }, i, !0);
  var u = cd(r.get("symbolSize"));
  i.scaleX = u[0] / 2, i.scaleY = u[1] / 2;
  var c = qc(r.get("symbolOffset"), u);
  c && (i.x = (i.x || 0) + c[0], i.y = (i.y || 0) + c[1]);
  var h = r.get("symbolRotate");
  return i.rotation = (h || 0) * Math.PI / 180 || 0, n.attr(i), n.updateTransform(), n;
}
function N$(r, e, t, i, n, a) {
  if (!r.dragging) {
    var o = n.getModel("checkpointStyle"), s = i.dataToCoord(n.getData().get("value", t));
    if (a || !o.get("animation", !0))
      r.attr({
        x: s,
        y: 0
      }), e && e.attr({
        shape: {
          x2: s
        }
      });
    else {
      var l = {
        duration: o.get("animationDuration", !0),
        easing: o.get("animationEasing", !0)
      };
      r.stopAnimation(null, !0), r.animateTo({
        x: s,
        y: 0
      }, l), e && e.animateTo({
        shape: {
          x2: s
        }
      }, l);
    }
  }
}
const TAe = mAe;
function yAe(r) {
  r.registerAction({
    type: "timelineChange",
    event: "timelineChanged",
    update: "prepareAndUpdate"
  }, function(e, t, i) {
    var n = t.getComponent("timeline");
    return n && e.currentIndex != null && (n.setCurrentIndex(e.currentIndex), !n.get("loop", !0) && n.isIndexMax() && n.getPlayState() && (n.setPlayState(!1), i.dispatchAction({
      type: "timelinePlayChange",
      playState: !1,
      from: e.from
    }))), t.resetOption("timeline", {
      replaceMerge: n.get("replaceMerge", !0)
    }), Te({
      currentIndex: n.option.currentIndex
    }, e);
  }), r.registerAction({
    type: "timelinePlayChange",
    event: "timelinePlayChanged",
    update: "update"
  }, function(e, t) {
    var i = t.getComponent("timeline");
    i && e.playState != null && i.setPlayState(e.playState);
  });
}
function RAe(r) {
  var e = r && r.timeline;
  X(e) || (e = e ? [e] : []), N(e, function(t) {
    t && AAe(t);
  });
}
function AAe(r) {
  var e = r.type, t = {
    number: "value",
    time: "time"
  };
  if (t[e] && (r.axisType = t[e], delete r.type), x$(r), Vu(r, "controlPosition")) {
    var i = r.controlStyle || (r.controlStyle = {});
    Vu(i, "position") || (i.position = r.controlPosition), i.position === "none" && !Vu(i, "show") && (i.show = !1, delete i.position), delete r.controlPosition;
  }
  N(r.data || [], function(n) {
    be(n) && !X(n) && (!Vu(n, "value") && Vu(n, "name") && (n.value = n.name), x$(n));
  });
}
function x$(r) {
  var e = r.itemStyle || (r.itemStyle = {}), t = e.emphasis || (e.emphasis = {}), i = r.label || r.label || {}, n = i.normal || (i.normal = {}), a = {
    normal: 1,
    emphasis: 1
  };
  N(i, function(o, s) {
    !a[s] && !Vu(n, s) && (n[s] = o);
  }), t.label && !Vu(i, "emphasis") && (i.emphasis = t.label, delete t.label);
}
function Vu(r, e) {
  return r.hasOwnProperty(e);
}
function _Ae(r) {
  r.registerComponentModel(dAe), r.registerComponentView(TAe), r.registerSubTypeDefaulter("timeline", function() {
    return "slider";
  }), yAe(r), r.registerPreprocessor(RAe);
}
function Rx(r, e) {
  if (!r)
    return !1;
  for (var t = X(r) ? r : [r], i = 0; i < t.length; i++)
    if (t[i] && t[i][e])
      return !0;
  return !1;
}
function cm(r) {
  Ic(r, "label", ["show"]);
}
var hm = ft(), GZ = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.createdBySelf = !1, t;
    }
    return e.prototype.init = function(t, i, n) {
      if ({}.NODE_ENV !== "production" && this.type === "marker")
        throw new Error("Marker component is abstract component. Use markLine, markPoint, markArea instead.");
      this.mergeDefaultAndTheme(t, n), this._mergeOption(t, n, !1, !0);
    }, e.prototype.isAnimationEnabled = function() {
      if (ct.node)
        return !1;
      var t = this.__hostSeries;
      return this.getShallow("animation") && t && t.isAnimationEnabled();
    }, e.prototype.mergeOption = function(t, i) {
      this._mergeOption(t, i, !1, !1);
    }, e.prototype._mergeOption = function(t, i, n, a) {
      var o = this.mainType;
      n || i.eachSeries(function(s) {
        var l = s.get(this.mainType, !0), u = hm(s)[o];
        if (!l || !l.data) {
          hm(s)[o] = null;
          return;
        }
        u ? u._mergeOption(l, i, !0) : (a && cm(l), N(l.data, function(c) {
          c instanceof Array ? (cm(c[0]), cm(c[1])) : cm(c);
        }), u = this.createMarkerModelFromSeries(l, this, i), B(u, {
          mainType: this.mainType,
          // Use the same series index and name
          seriesIndex: s.seriesIndex,
          name: s.name,
          createdBySelf: !0
        }), u.__hostSeries = s), hm(s)[o] = u;
      }, this);
    }, e.prototype.formatTooltip = function(t, i, n) {
      var a = this.getData(), o = this.getRawValue(t), s = a.getName(t);
      return Qr("section", {
        header: this.name,
        blocks: [Qr("nameValue", {
          name: s,
          value: o,
          noName: !s,
          noValue: o == null
        })]
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.setData = function(t) {
      this._data = t;
    }, e.getMarkerModelFromSeries = function(t, i) {
      return hm(t)[i];
    }, e.type = "marker", e.dependencies = ["series", "grid", "polar", "geo"], e;
  }(st)
);
br(GZ, cN.prototype);
const Ql = GZ;
var CAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, i, n) {
      return new e(t, i, n);
    }, e.type = "markPoint", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: "pin",
      symbolSize: 50,
      // symbolRotate: 0,
      // symbolOffset: [0, 0]
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "inside"
      },
      itemStyle: {
        borderWidth: 2
      },
      emphasis: {
        label: {
          show: !0
        }
      }
    }, e;
  }(Ql)
);
const IAe = CAe;
function aI(r) {
  return !(isNaN(parseFloat(r.x)) && isNaN(parseFloat(r.y)));
}
function wAe(r) {
  return !isNaN(parseFloat(r.x)) && !isNaN(parseFloat(r.y));
}
function fm(r, e, t, i, n, a) {
  var o = [], s = Ll(
    e,
    i
    /* , otherDataDim */
  ), l = s ? e.getCalculationInfo("stackResultDimension") : i, u = Ax(e, l, r), c = e.indicesOfNearest(l, u)[0];
  o[n] = e.get(t, c), o[a] = e.get(l, c);
  var h = e.get(i, c), f = oo(e.get(i, c));
  return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, h];
}
var jR = {
  min: Le(fm, "min"),
  max: Le(fm, "max"),
  average: Le(fm, "average"),
  median: Le(fm, "median")
};
function qg(r, e) {
  if (e) {
    var t = r.getData(), i = r.coordinateSystem, n = i && i.dimensions;
    if (!wAe(e) && !X(e.coord) && X(n)) {
      var a = BZ(e, t, i, r);
      if (e = ye(e), e.type && jR[e.type] && a.baseAxis && a.valueAxis) {
        var o = Fe(n, a.baseAxis.dim), s = Fe(n, a.valueAxis.dim), l = jR[e.type](t, a.baseDataDim, a.valueDataDim, o, s);
        e.coord = l[0], e.value = l[1];
      } else
        e.coord = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis];
    }
    if (e.coord == null || !X(n))
      e.coord = [];
    else
      for (var u = e.coord, c = 0; c < 2; c++)
        jR[u[c]] && (u[c] = Ax(t, t.mapDimension(n[c]), u[c]));
    return e;
  }
}
function BZ(r, e, t, i) {
  var n = {};
  return r.valueIndex != null || r.valueDim != null ? (n.valueDataDim = r.valueIndex != null ? e.getDimension(r.valueIndex) : r.valueDim, n.valueAxis = t.getAxis(NAe(i, n.valueDataDim)), n.baseAxis = t.getOtherAxis(n.valueAxis), n.baseDataDim = e.mapDimension(n.baseAxis.dim)) : (n.baseAxis = i.getBaseAxis(), n.valueAxis = t.getOtherAxis(n.baseAxis), n.baseDataDim = e.mapDimension(n.baseAxis.dim), n.valueDataDim = e.mapDimension(n.valueAxis.dim)), n;
}
function NAe(r, e) {
  var t = r.getData().getDimensionInfo(e);
  return t && t.coordDim;
}
function jg(r, e) {
  return r && r.containData && e.coord && !aI(e) ? r.containData(e.coord) : !0;
}
function xAe(r, e, t) {
  return r && r.containZone && e.coord && t.coord && !aI(e) && !aI(t) ? r.containZone(e.coord, t.coord) : !0;
}
function FZ(r, e) {
  return r ? function(t, i, n, a) {
    var o = a < 2 ? t.coord && t.coord[a] : t.value;
    return gl(o, e[a]);
  } : function(t, i, n, a) {
    return gl(t.value, e[a]);
  };
}
function Ax(r, e, t) {
  if (t === "average") {
    var i = 0, n = 0;
    return r.each(e, function(a, o) {
      isNaN(a) || (i += a, n++);
    }), i / n;
  } else
    return t === "median" ? r.getMedian(e) : r.getDataExtent(e)[t === "max" ? 1 : 0];
}
var KR = ft(), PAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.init = function() {
      this.markerGroupMap = de();
    }, e.prototype.render = function(t, i, n) {
      var a = this, o = this.markerGroupMap;
      o.each(function(s) {
        KR(s).keep = !1;
      }), i.eachSeries(function(s) {
        var l = Ql.getMarkerModelFromSeries(s, a.type);
        l && a.renderSeries(s, l, i, n);
      }), o.each(function(s) {
        !KR(s).keep && a.group.remove(s.group);
      });
    }, e.prototype.markKeep = function(t) {
      KR(t).keep = !0;
    }, e.prototype.toggleBlurSeries = function(t, i) {
      var n = this;
      N(t, function(a) {
        var o = Ql.getMarkerModelFromSeries(a, n.type);
        if (o) {
          var s = o.getData();
          s.eachItemGraphicEl(function(l) {
            l && (i ? EH(l) : X1(l));
          });
        }
      });
    }, e.type = "marker", e;
  }(jt)
);
const _x = PAe;
function P$(r, e, t) {
  var i = e.coordinateSystem;
  r.each(function(n) {
    var a = r.getItemModel(n), o, s = K(a.get("x"), t.getWidth()), l = K(a.get("y"), t.getHeight());
    if (!isNaN(s) && !isNaN(l))
      o = [s, l];
    else if (e.getMarkerPosition)
      o = e.getMarkerPosition(r.getValues(r.dimensions, n));
    else if (i) {
      var u = r.get(i.dimensions[0], n), c = r.get(i.dimensions[1], n);
      o = i.dataToPoint([u, c]);
    }
    isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), r.setItemLayout(n, o);
  });
}
var LAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, i, n) {
      i.eachSeries(function(a) {
        var o = Ql.getMarkerModelFromSeries(a, "markPoint");
        o && (P$(o.getData(), a, n), this.markerGroupMap.get(a.id).updateLayout());
      }, this);
    }, e.prototype.renderSeries = function(t, i, n, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new Mv()), h = DAe(o, t, i);
      i.setData(h), P$(i.getData(), t, a), h.each(function(f) {
        var d = h.getItemModel(f), p = d.getShallow("symbol"), g = d.getShallow("symbolSize"), v = d.getShallow("symbolRotate"), O = d.getShallow("symbolOffset"), m = d.getShallow("symbolKeepAspect");
        if (ve(p) || ve(g) || ve(v) || ve(O)) {
          var E = i.getRawValue(f), b = i.getDataParams(f);
          ve(p) && (p = p(E, b)), ve(g) && (g = g(E, b)), ve(v) && (v = v(E, b)), ve(O) && (O = O(E, b));
        }
        var S = d.getModel("itemStyle").getItemStyle(), T = Nv(l, "color");
        S.fill || (S.fill = T), h.setItemVisual(f, {
          symbol: p,
          symbolSize: g,
          symbolRotate: v,
          symbolOffset: O,
          symbolKeepAspect: m,
          style: S
        });
      }), c.updateData(h), this.group.add(c.group), h.eachItemGraphicEl(function(f) {
        f.traverse(function(d) {
          Pe(d).dataModel = i;
        });
      }), this.markKeep(c), c.group.silent = i.get("silent") || t.get("silent");
    }, e.type = "markPoint", e;
  }(_x)
);
function DAe(r, e, t) {
  var i;
  r ? i = Y(r && r.dimensions, function(s) {
    var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {};
    return B(B({}, l), {
      name: s,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : i = [{
    name: "value",
    type: "float"
  }];
  var n = new ki(i, t), a = Y(t.get("data"), Le(qg, e));
  r && (a = At(a, Le(jg, r)));
  var o = FZ(!!r, i);
  return n.initData(a, null, o), n;
}
const MAe = LAe;
function kAe(r) {
  r.registerComponentModel(IAe), r.registerComponentView(MAe), r.registerPreprocessor(function(e) {
    Rx(e.series, "markPoint") && (e.markPoint = e.markPoint || {});
  });
}
var QAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, i, n) {
      return new e(t, i, n);
    }, e.type = "markLine", e.defaultOption = {
      // zlevel: 0,
      z: 5,
      symbol: ["circle", "arrow"],
      symbolSize: [8, 16],
      // symbolRotate: 0,
      symbolOffset: 0,
      precision: 2,
      tooltip: {
        trigger: "item"
      },
      label: {
        show: !0,
        position: "end",
        distance: 5
      },
      lineStyle: {
        type: "dashed"
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          width: 3
        }
      },
      animationEasing: "linear"
    }, e;
  }(Ql)
);
const UAe = QAe;
var dm = ft(), $Ae = function(r, e, t, i) {
  var n = r.getData(), a;
  if (X(i))
    a = i;
  else {
    var o = i.type;
    if (o === "min" || o === "max" || o === "average" || o === "median" || i.xAxis != null || i.yAxis != null) {
      var s = void 0, l = void 0;
      if (i.yAxis != null || i.xAxis != null)
        s = e.getAxis(i.yAxis != null ? "y" : "x"), l = vr(i.yAxis, i.xAxis);
      else {
        var u = BZ(i, n, e, r);
        s = u.valueAxis;
        var c = Iz(n, u.valueDataDim);
        l = Ax(n, c, o);
      }
      var h = s.dim === "x" ? 0 : 1, f = 1 - h, d = ye(i), p = {
        coord: []
      };
      d.type = null, d.coord = [], d.coord[f] = -1 / 0, p.coord[f] = 1 / 0;
      var g = t.get("precision");
      g >= 0 && pt(l) && (l = +l.toFixed(Math.min(g, 20))), d.coord[h] = p.coord[h] = l, a = [d, p, {
        type: o,
        valueIndex: i.valueIndex,
        // Force to use the value of calculated value.
        value: l
      }];
    } else
      ({}).NODE_ENV !== "production" && _a("Invalid markLine data."), a = [];
  }
  var v = [qg(r, a[0]), qg(r, a[1]), B({}, a[2])];
  return v[2].type = v[2].type || null, $e(v[2], v[0]), $e(v[2], v[1]), v;
};
function Fb(r) {
  return !isNaN(r) && !isFinite(r);
}
function L$(r, e, t, i) {
  var n = 1 - r, a = i.dimensions[r];
  return Fb(e[n]) && Fb(t[n]) && e[r] === t[r] && i.getAxis(a).containData(e[r]);
}
function VAe(r, e) {
  if (r.type === "cartesian2d") {
    var t = e[0].coord, i = e[1].coord;
    if (t && i && (L$(1, t, i, r) || L$(0, t, i, r)))
      return !0;
  }
  return jg(r, e[0]) && jg(r, e[1]);
}
function JR(r, e, t, i, n) {
  var a = i.coordinateSystem, o = r.getItemModel(e), s, l = K(o.get("x"), n.getWidth()), u = K(o.get("y"), n.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (i.getMarkerPosition)
      s = i.getMarkerPosition(r.getValues(r.dimensions, e));
    else {
      var c = a.dimensions, h = r.get(c[0], e), f = r.get(c[1], e);
      s = a.dataToPoint([h, f]);
    }
    if (Kc(a, "cartesian2d")) {
      var d = a.getAxis("x"), p = a.getAxis("y"), c = a.dimensions;
      Fb(r.get(c[0], e)) ? s[0] = d.toGlobalCoord(d.getExtent()[t ? 0 : 1]) : Fb(r.get(c[1], e)) && (s[1] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  r.setItemLayout(e, s);
}
var GAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, i, n) {
      i.eachSeries(function(a) {
        var o = Ql.getMarkerModelFromSeries(a, "markLine");
        if (o) {
          var s = o.getData(), l = dm(o).from, u = dm(o).to;
          l.each(function(c) {
            JR(l, c, !0, a, n), JR(u, c, !1, a, n);
          }), s.each(function(c) {
            s.setItemLayout(c, [l.getItemLayout(c), u.getItemLayout(c)]);
          }), this.markerGroupMap.get(a.id).updateLayout();
        }
      }, this);
    }, e.prototype.renderSeries = function(t, i, n, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, new ZN());
      this.group.add(c.group);
      var h = BAe(o, t, i), f = h.from, d = h.to, p = h.line;
      dm(i).from = f, dm(i).to = d, i.setData(p);
      var g = i.get("symbol"), v = i.get("symbolSize"), O = i.get("symbolRotate"), m = i.get("symbolOffset");
      X(g) || (g = [g, g]), X(v) || (v = [v, v]), X(O) || (O = [O, O]), X(m) || (m = [m, m]), h.from.each(function(b) {
        E(f, b, !0), E(d, b, !1);
      }), p.each(function(b) {
        var S = p.getItemModel(b).getModel("lineStyle").getLineStyle();
        p.setItemLayout(b, [f.getItemLayout(b), d.getItemLayout(b)]), S.stroke == null && (S.stroke = f.getItemVisual(b, "style").fill), p.setItemVisual(b, {
          fromSymbolKeepAspect: f.getItemVisual(b, "symbolKeepAspect"),
          fromSymbolOffset: f.getItemVisual(b, "symbolOffset"),
          fromSymbolRotate: f.getItemVisual(b, "symbolRotate"),
          fromSymbolSize: f.getItemVisual(b, "symbolSize"),
          fromSymbol: f.getItemVisual(b, "symbol"),
          toSymbolKeepAspect: d.getItemVisual(b, "symbolKeepAspect"),
          toSymbolOffset: d.getItemVisual(b, "symbolOffset"),
          toSymbolRotate: d.getItemVisual(b, "symbolRotate"),
          toSymbolSize: d.getItemVisual(b, "symbolSize"),
          toSymbol: d.getItemVisual(b, "symbol"),
          style: S
        });
      }), c.updateData(p), h.line.eachItemGraphicEl(function(b) {
        Pe(b).dataModel = i, b.traverse(function(S) {
          Pe(S).dataModel = i;
        });
      });
      function E(b, S, T) {
        var y = b.getItemModel(S);
        JR(b, S, T, t, a);
        var R = y.getModel("itemStyle").getItemStyle();
        R.fill == null && (R.fill = Nv(l, "color")), b.setItemVisual(S, {
          symbolKeepAspect: y.get("symbolKeepAspect"),
          // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
          symbolOffset: ke(y.get("symbolOffset", !0), m[T ? 0 : 1]),
          symbolRotate: ke(y.get("symbolRotate", !0), O[T ? 0 : 1]),
          // TODO: when 2d array is supported, it should ignore parent
          symbolSize: ke(y.get("symbolSize"), v[T ? 0 : 1]),
          symbol: ke(y.get("symbol", !0), g[T ? 0 : 1]),
          style: R
        });
      }
      this.markKeep(c), c.group.silent = i.get("silent") || t.get("silent");
    }, e.type = "markLine", e;
  }(_x)
);
function BAe(r, e, t) {
  var i;
  r ? i = Y(r && r.dimensions, function(u) {
    var c = e.getData().getDimensionInfo(e.getData().mapDimension(u)) || {};
    return B(B({}, c), {
      name: u,
      // DON'T use ordinalMeta to parse and collect ordinal.
      ordinalMeta: null
    });
  }) : i = [{
    name: "value",
    type: "float"
  }];
  var n = new ki(i, t), a = new ki(i, t), o = new ki([], t), s = Y(t.get("data"), Le($Ae, e, r, t));
  r && (s = At(s, Le(VAe, r)));
  var l = FZ(!!r, i);
  return n.initData(Y(s, function(u) {
    return u[0];
  }), null, l), a.initData(Y(s, function(u) {
    return u[1];
  }), null, l), o.initData(Y(s, function(u) {
    return u[2];
  })), o.hasItemOption = !0, {
    from: n,
    to: a,
    line: o
  };
}
const FAe = GAe;
function XAe(r) {
  r.registerComponentModel(UAe), r.registerComponentView(FAe), r.registerPreprocessor(function(e) {
    Rx(e.series, "markLine") && (e.markLine = e.markLine || {});
  });
}
var YAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.createMarkerModelFromSeries = function(t, i, n) {
      return new e(t, i, n);
    }, e.type = "markArea", e.defaultOption = {
      // zlevel: 0,
      // PENDING
      z: 1,
      tooltip: {
        trigger: "item"
      },
      // markArea should fixed on the coordinate system
      animation: !1,
      label: {
        show: !0,
        position: "top"
      },
      itemStyle: {
        // color and borderColor default to use color from series
        // color: 'auto'
        // borderColor: 'auto'
        borderWidth: 0
      },
      emphasis: {
        label: {
          show: !0,
          position: "top"
        }
      }
    }, e;
  }(Ql)
);
const HAe = YAe;
var pm = ft(), WAe = function(r, e, t, i) {
  var n = i[0], a = i[1];
  if (!(!n || !a)) {
    var o = qg(r, n), s = qg(r, a), l = o.coord, u = s.coord;
    l[0] = vr(l[0], -1 / 0), l[1] = vr(l[1], -1 / 0), u[0] = vr(u[0], 1 / 0), u[1] = vr(u[1], 1 / 0);
    var c = _1([{}, o, s]);
    return c.coord = [o.coord, s.coord], c.x0 = o.x, c.y0 = o.y, c.x1 = s.x, c.y1 = s.y, c;
  }
};
function Xb(r) {
  return !isNaN(r) && !isFinite(r);
}
function D$(r, e, t, i) {
  var n = 1 - r;
  return Xb(e[n]) && Xb(t[n]);
}
function zAe(r, e) {
  var t = e.coord[0], i = e.coord[1], n = {
    coord: t,
    x: e.x0,
    y: e.y0
  }, a = {
    coord: i,
    x: e.x1,
    y: e.y1
  };
  return Kc(r, "cartesian2d") ? t && i && (D$(1, t, i) || D$(0, t, i)) ? !0 : xAe(r, n, a) : jg(r, n) || jg(r, a);
}
function M$(r, e, t, i, n) {
  var a = i.coordinateSystem, o = r.getItemModel(e), s, l = K(o.get(t[0]), n.getWidth()), u = K(o.get(t[1]), n.getHeight());
  if (!isNaN(l) && !isNaN(u))
    s = [l, u];
  else {
    if (i.getMarkerPosition) {
      var c = r.getValues(["x0", "y0"], e), h = r.getValues(["x1", "y1"], e), f = a.clampData(c), d = a.clampData(h), p = [];
      t[0] === "x0" ? p[0] = f[0] > d[0] ? h[0] : c[0] : p[0] = f[0] > d[0] ? c[0] : h[0], t[1] === "y0" ? p[1] = f[1] > d[1] ? h[1] : c[1] : p[1] = f[1] > d[1] ? c[1] : h[1], s = i.getMarkerPosition(p, t, !0);
    } else {
      var g = r.get(t[0], e), v = r.get(t[1], e), O = [g, v];
      a.clampData && a.clampData(O, O), s = a.dataToPoint(O, !0);
    }
    if (Kc(a, "cartesian2d")) {
      var m = a.getAxis("x"), E = a.getAxis("y"), g = r.get(t[0], e), v = r.get(t[1], e);
      Xb(g) ? s[0] = m.toGlobalCoord(m.getExtent()[t[0] === "x0" ? 0 : 1]) : Xb(v) && (s[1] = E.toGlobalCoord(E.getExtent()[t[1] === "y0" ? 0 : 1]));
    }
    isNaN(l) || (s[0] = l), isNaN(u) || (s[1] = u);
  }
  return s;
}
var k$ = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], ZAe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.updateTransform = function(t, i, n) {
      i.eachSeries(function(a) {
        var o = Ql.getMarkerModelFromSeries(a, "markArea");
        if (o) {
          var s = o.getData();
          s.each(function(l) {
            var u = Y(k$, function(h) {
              return M$(s, l, h, a, n);
            });
            s.setItemLayout(l, u);
            var c = s.getItemGraphicEl(l);
            c.setShape("points", u);
          });
        }
      }, this);
    }, e.prototype.renderSeries = function(t, i, n, a) {
      var o = t.coordinateSystem, s = t.id, l = t.getData(), u = this.markerGroupMap, c = u.get(s) || u.set(s, {
        group: new Re()
      });
      this.group.add(c.group), this.markKeep(c);
      var h = qAe(o, t, i);
      i.setData(h), h.each(function(f) {
        var d = Y(k$, function(R) {
          return M$(h, f, R, t, a);
        }), p = o.getAxis("x").scale, g = o.getAxis("y").scale, v = p.getExtent(), O = g.getExtent(), m = [p.parse(h.get("x0", f)), p.parse(h.get("x1", f))], E = [g.parse(h.get("y0", f)), g.parse(h.get("y1", f))];
        Zn(m), Zn(E);
        var b = !(v[0] > m[1] || v[1] < m[0] || O[0] > E[1] || O[1] < E[0]), S = !b;
        h.setItemLayout(f, {
          points: d,
          allClipped: S
        });
        var T = h.getItemModel(f).getModel("itemStyle").getItemStyle(), y = Nv(l, "color");
        T.fill || (T.fill = y, ne(T.fill) && (T.fill = JE(T.fill, 0.4))), T.stroke || (T.stroke = y), h.setItemVisual(f, "style", T);
      }), h.diff(pm(c).data).add(function(f) {
        var d = h.getItemLayout(f);
        if (!d.allClipped) {
          var p = new rn({
            shape: {
              points: d.points
            }
          });
          h.setItemGraphicEl(f, p), c.group.add(p);
        }
      }).update(function(f, d) {
        var p = pm(c).data.getItemGraphicEl(d), g = h.getItemLayout(f);
        g.allClipped ? p && c.group.remove(p) : (p ? Ot(p, {
          shape: {
            points: g.points
          }
        }, i, f) : p = new rn({
          shape: {
            points: g.points
          }
        }), h.setItemGraphicEl(f, p), c.group.add(p));
      }).remove(function(f) {
        var d = pm(c).data.getItemGraphicEl(f);
        c.group.remove(d);
      }).execute(), h.eachItemGraphicEl(function(f, d) {
        var p = h.getItemModel(d), g = h.getItemVisual(d, "style");
        f.useStyle(h.getItemVisual(d, "style")), ii(f, kr(p), {
          labelFetcher: i,
          labelDataIndex: d,
          defaultText: h.getName(d) || "",
          inheritColor: ne(g.fill) ? JE(g.fill, 1) : "#000"
        }), ri(f, p), qt(f, null, null, p.get(["emphasis", "disabled"])), Pe(f).dataModel = i;
      }), pm(c).data = h, c.group.silent = i.get("silent") || t.get("silent");
    }, e.type = "markArea", e;
  }(_x)
);
function qAe(r, e, t) {
  var i, n, a = ["x0", "y0", "x1", "y1"];
  if (r) {
    var o = Y(r && r.dimensions, function(u) {
      var c = e.getData(), h = c.getDimensionInfo(c.mapDimension(u)) || {};
      return B(B({}, h), {
        name: u,
        // DON'T use ordinalMeta to parse and collect ordinal.
        ordinalMeta: null
      });
    });
    n = Y(a, function(u, c) {
      return {
        name: u,
        type: o[c % 2].type
      };
    }), i = new ki(n, t);
  } else
    n = [{
      name: "value",
      type: "float"
    }], i = new ki(n, t);
  var s = Y(t.get("data"), Le(WAe, e, r, t));
  r && (s = At(s, Le(zAe, r)));
  var l = r ? function(u, c, h, f) {
    var d = u.coord[Math.floor(f / 2)][f % 2];
    return gl(d, n[f]);
  } : function(u, c, h, f) {
    return gl(u.value, n[f]);
  };
  return i.initData(s, null, l), i.hasItemOption = !0, i;
}
const jAe = ZAe;
function KAe(r) {
  r.registerComponentModel(HAe), r.registerComponentView(jAe), r.registerPreprocessor(function(e) {
    Rx(e.series, "markArea") && (e.markArea = e.markArea || {});
  });
}
var JAe = function(r, e) {
  if (e === "all")
    return {
      type: "all",
      title: r.getLocaleModel().get(["legend", "selector", "all"])
    };
  if (e === "inverse")
    return {
      type: "inverse",
      title: r.getLocaleModel().get(["legend", "selector", "inverse"])
    };
}, e_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.layoutMode = {
        type: "box",
        // legend.width/height are maxWidth/maxHeight actually,
        // whereas real width/height is calculated by its content.
        // (Setting {left: 10, right: 10} does not make sense).
        // So consider the case:
        // `setOption({legend: {left: 10});`
        // then `setOption({legend: {right: 10});`
        // The previous `left` should be cleared by setting `ignoreSize`.
        ignoreSize: !0
      }, t;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n), t.selected = t.selected || {}, this._updateSelector(t);
    }, e.prototype.mergeOption = function(t, i) {
      r.prototype.mergeOption.call(this, t, i), this._updateSelector(t);
    }, e.prototype._updateSelector = function(t) {
      var i = t.selector, n = this.ecModel;
      i === !0 && (i = t.selector = ["all", "inverse"]), X(i) && N(i, function(a, o) {
        ne(a) && (a = {
          type: a
        }), i[o] = $e(a, JAe(n, a.type));
      });
    }, e.prototype.optionUpdated = function() {
      this._updateData(this.ecModel);
      var t = this._data;
      if (t[0] && this.get("selectedMode") === "single") {
        for (var i = !1, n = 0; n < t.length; n++) {
          var a = t[n].get("name");
          if (this.isSelected(a)) {
            this.select(a), i = !0;
            break;
          }
        }
        !i && this.select(t[0].get("name"));
      }
    }, e.prototype._updateData = function(t) {
      var i = [], n = [];
      t.eachRawSeries(function(l) {
        var u = l.name;
        n.push(u);
        var c;
        if (l.legendVisualProvider) {
          var h = l.legendVisualProvider, f = h.getAllNames();
          t.isSeriesFiltered(l) || (n = n.concat(f)), f.length ? i = i.concat(f) : c = !0;
        } else
          c = !0;
        c && Q1(l) && i.push(l.name);
      }), this._availableNames = n;
      var a = this.get("data") || i, o = de(), s = Y(a, function(l) {
        return (ne(l) || pt(l)) && (l = {
          name: l
        }), o.get(l.name) ? null : (o.set(l.name, !0), new Ut(l, this, this.ecModel));
      }, this);
      this._data = At(s, function(l) {
        return !!l;
      });
    }, e.prototype.getData = function() {
      return this._data;
    }, e.prototype.select = function(t) {
      var i = this.option.selected, n = this.get("selectedMode");
      if (n === "single") {
        var a = this._data;
        N(a, function(o) {
          i[o.get("name")] = !1;
        });
      }
      i[t] = !0;
    }, e.prototype.unSelect = function(t) {
      this.get("selectedMode") !== "single" && (this.option.selected[t] = !1);
    }, e.prototype.toggleSelected = function(t) {
      var i = this.option.selected;
      i.hasOwnProperty(t) || (i[t] = !0), this[i[t] ? "unSelect" : "select"](t);
    }, e.prototype.allSelect = function() {
      var t = this._data, i = this.option.selected;
      N(t, function(n) {
        i[n.get("name", !0)] = !0;
      });
    }, e.prototype.inverseSelect = function() {
      var t = this._data, i = this.option.selected;
      N(t, function(n) {
        var a = n.get("name", !0);
        i.hasOwnProperty(a) || (i[a] = !0), i[a] = !i[a];
      });
    }, e.prototype.isSelected = function(t) {
      var i = this.option.selected;
      return !(i.hasOwnProperty(t) && !i[t]) && Fe(this._availableNames, t) >= 0;
    }, e.prototype.getOrient = function() {
      return this.get("orient") === "vertical" ? {
        index: 1,
        name: "vertical"
      } : {
        index: 0,
        name: "horizontal"
      };
    }, e.type = "legend.plain", e.dependencies = ["series"], e.defaultOption = {
      // zlevel: 0,
      z: 4,
      show: !0,
      orient: "horizontal",
      left: "center",
      // right: 'center',
      top: 0,
      // bottom: null,
      align: "auto",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      borderRadius: 0,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      itemWidth: 25,
      itemHeight: 14,
      symbolRotate: "inherit",
      symbolKeepAspect: !0,
      inactiveColor: "#ccc",
      inactiveBorderColor: "#ccc",
      inactiveBorderWidth: "auto",
      itemStyle: {
        color: "inherit",
        opacity: "inherit",
        borderColor: "inherit",
        borderWidth: "auto",
        borderCap: "inherit",
        borderJoin: "inherit",
        borderDashOffset: "inherit",
        borderMiterLimit: "inherit"
      },
      lineStyle: {
        width: "auto",
        color: "inherit",
        inactiveColor: "#ccc",
        inactiveWidth: 2,
        opacity: "inherit",
        type: "inherit",
        cap: "inherit",
        join: "inherit",
        dashOffset: "inherit",
        miterLimit: "inherit"
      },
      textStyle: {
        color: "#333"
      },
      selectedMode: !0,
      selector: !1,
      selectorLabel: {
        show: !0,
        borderRadius: 10,
        padding: [3, 5, 3, 5],
        fontSize: 12,
        fontFamily: "sans-serif",
        color: "#666",
        borderWidth: 1,
        borderColor: "#666"
      },
      emphasis: {
        selectorLabel: {
          show: !0,
          color: "#eee",
          backgroundColor: "#666"
        }
      },
      selectorPosition: "auto",
      selectorItemGap: 7,
      selectorButtonGap: 10,
      tooltip: {
        show: !1
      }
    }, e;
  }(st)
);
const oI = e_e;
var Ih = Le, sI = N, gm = Re, t_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !1, t;
    }
    return e.prototype.init = function() {
      this.group.add(this._contentGroup = new gm()), this.group.add(this._selectorGroup = new gm()), this._isFirstRender = !0;
    }, e.prototype.getContentGroup = function() {
      return this._contentGroup;
    }, e.prototype.getSelectorGroup = function() {
      return this._selectorGroup;
    }, e.prototype.render = function(t, i, n) {
      var a = this._isFirstRender;
      if (this._isFirstRender = !1, this.resetInner(), !!t.get("show", !0)) {
        var o = t.get("align"), s = t.get("orient");
        (!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left");
        var l = t.get("selector", !0), u = t.get("selectorPosition", !0);
        l && (!u || u === "auto") && (u = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, i, n, l, s, u);
        var c = t.getBoxLayoutParams(), h = {
          width: n.getWidth(),
          height: n.getHeight()
        }, f = t.get("padding"), d = Ir(c, h, f), p = this.layoutInner(t, o, d, a, l, u), g = Ir(Te({
          width: p.width,
          height: p.height
        }, c), h, f);
        this.group.x = g.x - p.x, this.group.y = g.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = xZ(p, t));
      }
    }, e.prototype.resetInner = function() {
      this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll();
    }, e.prototype.renderInner = function(t, i, n, a, o, s, l) {
      var u = this.getContentGroup(), c = de(), h = i.get("selectedMode"), f = [];
      n.eachRawSeries(function(d) {
        !d.get("legendHoverLink") && f.push(d.id);
      }), sI(i.getData(), function(d, p) {
        var g = d.get("name");
        if (!this.newlineDisabled && (g === "" || g === `
`)) {
          var v = new gm();
          v.newline = !0, u.add(v);
          return;
        }
        var O = n.getSeriesByName(g)[0];
        if (!c.get(g)) {
          if (O) {
            var m = O.getData(), E = m.getVisual("legendLineStyle") || {}, b = m.getVisual("legendIcon"), S = m.getVisual("style"), T = this._createItem(O, g, p, d, i, t, E, S, b, h, a);
            T.on("click", Ih(Q$, g, null, a, f)).on("mouseover", Ih(lI, O.name, null, a, f)).on("mouseout", Ih(uI, O.name, null, a, f)), c.set(g, !0);
          } else
            n.eachRawSeries(function(y) {
              if (!c.get(g) && y.legendVisualProvider) {
                var R = y.legendVisualProvider;
                if (!R.containName(g))
                  return;
                var _ = R.indexOfName(g), C = R.getItemVisual(_, "style"), I = R.getItemVisual(_, "legendIcon"), w = Sn(C.fill);
                w && w[3] === 0 && (w[3] = 0.2, C = B(B({}, C), {
                  fill: jo(w, "rgba")
                }));
                var x = this._createItem(y, g, p, d, i, t, {}, C, I, h, a);
                x.on("click", Ih(Q$, null, g, a, f)).on("mouseover", Ih(lI, null, g, a, f)).on("mouseout", Ih(uI, null, g, a, f)), c.set(g, !0);
              }
            }, this);
          ({}).NODE_ENV !== "production" && (c.get(g) || console.warn(g + " series not exists. Legend data should be same with series name or data name."));
        }
      }, this), o && this._createSelector(o, i, a, s, l);
    }, e.prototype._createSelector = function(t, i, n, a, o) {
      var s = this.getSelectorGroup();
      sI(t, function(u) {
        var c = u.type, h = new dt({
          style: {
            x: 0,
            y: 0,
            align: "center",
            verticalAlign: "middle"
          },
          onclick: function() {
            n.dispatchAction({
              type: c === "all" ? "legendAllSelect" : "legendInverseSelect"
            });
          }
        });
        s.add(h);
        var f = i.getModel("selectorLabel"), d = i.getModel(["emphasis", "selectorLabel"]);
        ii(h, {
          normal: f,
          emphasis: d
        }, {
          defaultText: u.title
        }), pc(h);
      });
    }, e.prototype._createItem = function(t, i, n, a, o, s, l, u, c, h, f) {
      var d = t.visualDrawType, p = o.get("itemWidth"), g = o.get("itemHeight"), v = o.isSelected(i), O = a.get("symbolRotate"), m = a.get("symbolKeepAspect"), E = a.get("icon");
      c = E || c || "roundRect";
      var b = r_e(c, a, l, u, d, v, f), S = new gm(), T = a.getModel("textStyle");
      if (ve(t.getLegendIcon) && (!E || E === "inherit"))
        S.add(t.getLegendIcon({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: O,
          itemStyle: b.itemStyle,
          lineStyle: b.lineStyle,
          symbolKeepAspect: m
        }));
      else {
        var y = E === "inherit" && t.getData().getVisual("symbol") ? O === "inherit" ? t.getData().getVisual("symbolRotate") : O : 0;
        S.add(i_e({
          itemWidth: p,
          itemHeight: g,
          icon: c,
          iconRotate: y,
          itemStyle: b.itemStyle,
          lineStyle: b.lineStyle,
          symbolKeepAspect: m
        }));
      }
      var R = s === "left" ? p + 5 : -5, _ = s, C = o.get("formatter"), I = i;
      ne(C) && C ? I = C.replace("{name}", i ?? "") : ve(C) && (I = C(i));
      var w = v ? T.getTextColor() : a.get("inactiveColor");
      S.add(new dt({
        style: Qt(T, {
          text: I,
          x: R,
          y: g / 2,
          fill: w,
          align: _,
          verticalAlign: "middle"
        }, {
          inheritColor: w
        })
      }));
      var x = new ht({
        shape: S.getBoundingRect(),
        invisible: !0
      }), P = a.getModel("tooltip");
      return P.get("show") && ed({
        el: x,
        componentModel: o,
        itemName: i,
        itemTooltipOption: P.option
      }), S.add(x), S.eachChild(function(L) {
        L.silent = !0;
      }), x.silent = !h, this.getContentGroup().add(S), pc(S), S.__legendDataIndex = n, S;
    }, e.prototype.layoutInner = function(t, i, n, a, o, s) {
      var l = this.getContentGroup(), u = this.getSelectorGroup();
      vc(t.get("orient"), l, t.get("itemGap"), n.width, n.height);
      var c = l.getBoundingRect(), h = [-c.x, -c.y];
      if (u.markRedraw(), l.markRedraw(), o) {
        vc(
          // Buttons in selectorGroup always layout horizontally
          "horizontal",
          u,
          t.get("selectorItemGap", !0)
        );
        var f = u.getBoundingRect(), d = [-f.x, -f.y], p = t.get("selectorButtonGap", !0), g = t.getOrient().index, v = g === 0 ? "width" : "height", O = g === 0 ? "height" : "width", m = g === 0 ? "y" : "x";
        s === "end" ? d[g] += c[v] + p : h[g] += f[v] + p, d[1 - g] += c[O] / 2 - f[O] / 2, u.x = d[0], u.y = d[1], l.x = h[0], l.y = h[1];
        var E = {
          x: 0,
          y: 0
        };
        return E[v] = c[v] + p + f[v], E[O] = Math.max(c[O], f[O]), E[m] = Math.min(0, f[m] + d[1 - g]), E;
      } else
        return l.x = h[0], l.y = h[1], this.group.getBoundingRect();
    }, e.prototype.remove = function() {
      this.getContentGroup().removeAll(), this._isFirstRender = !0;
    }, e.type = "legend.plain", e;
  }(jt)
);
function r_e(r, e, t, i, n, a, o) {
  function s(v, O) {
    v.lineWidth === "auto" && (v.lineWidth = O.lineWidth > 0 ? 2 : 0), sI(v, function(m, E) {
      v[E] === "inherit" && (v[E] = O[E]);
    });
  }
  var l = e.getModel("itemStyle"), u = l.getItemStyle(), c = r.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", h = l.getShallow("decal");
  u.decal = !h || h === "inherit" ? i.decal : xf(h, o), u.fill === "inherit" && (u.fill = i[n]), u.stroke === "inherit" && (u.stroke = i[c]), u.opacity === "inherit" && (u.opacity = (n === "fill" ? i : t).opacity), s(u, i);
  var f = e.getModel("lineStyle"), d = f.getLineStyle();
  if (s(d, t), u.fill === "auto" && (u.fill = i.fill), u.stroke === "auto" && (u.stroke = i.fill), d.stroke === "auto" && (d.stroke = i.fill), !a) {
    var p = e.get("inactiveBorderWidth"), g = u[c];
    u.lineWidth = p === "auto" ? i.lineWidth > 0 && g ? 2 : 0 : u.lineWidth, u.fill = e.get("inactiveColor"), u.stroke = e.get("inactiveBorderColor"), d.stroke = f.get("inactiveColor"), d.lineWidth = f.get("inactiveWidth");
  }
  return {
    itemStyle: u,
    lineStyle: d
  };
}
function i_e(r) {
  var e = r.icon || "roundRect", t = Er(e, 0, 0, r.itemWidth, r.itemHeight, r.itemStyle.fill, r.symbolKeepAspect);
  return t.setStyle(r.itemStyle), t.rotation = (r.iconRotate || 0) * Math.PI / 180, t.setOrigin([r.itemWidth / 2, r.itemHeight / 2]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t;
}
function Q$(r, e, t, i) {
  uI(r, e, t, i), t.dispatchAction({
    type: "legendToggleSelect",
    name: r ?? e
  }), lI(r, e, t, i);
}
function XZ(r) {
  for (var e = r.getZr().storage.getDisplayList(), t, i = 0, n = e.length; i < n && !(t = e[i].states.emphasis); )
    i++;
  return t && t.hoverLayer;
}
function lI(r, e, t, i) {
  XZ(t) || t.dispatchAction({
    type: "highlight",
    seriesName: r,
    name: e,
    excludeSeriesId: i
  });
}
function uI(r, e, t, i) {
  XZ(t) || t.dispatchAction({
    type: "downplay",
    seriesName: r,
    name: e,
    excludeSeriesId: i
  });
}
const YZ = t_e;
function n_e(r) {
  var e = r.findComponents({
    mainType: "legend"
  });
  e && e.length && r.filterSeries(function(t) {
    for (var i = 0; i < e.length; i++)
      if (!e[i].isSelected(t.name))
        return !1;
    return !0;
  });
}
function jd(r, e, t) {
  var i = {}, n = r === "toggleSelected", a;
  return t.eachComponent("legend", function(o) {
    n && a != null ? o[a ? "select" : "unSelect"](e.name) : r === "allSelect" || r === "inverseSelect" ? o[r]() : (o[r](e.name), a = o.isSelected(e.name));
    var s = o.getData();
    N(s, function(l) {
      var u = l.get("name");
      if (!(u === `
` || u === "")) {
        var c = o.isSelected(u);
        i.hasOwnProperty(u) ? i[u] = i[u] && c : i[u] = c;
      }
    });
  }), r === "allSelect" || r === "inverseSelect" ? {
    selected: i
  } : {
    name: e.name,
    selected: i
  };
}
function a_e(r) {
  r.registerAction("legendToggleSelect", "legendselectchanged", Le(jd, "toggleSelected")), r.registerAction("legendAllSelect", "legendselectall", Le(jd, "allSelect")), r.registerAction("legendInverseSelect", "legendinverseselect", Le(jd, "inverseSelect")), r.registerAction("legendSelect", "legendselected", Le(jd, "select")), r.registerAction("legendUnSelect", "legendunselected", Le(jd, "unSelect"));
}
function HZ(r) {
  r.registerComponentModel(oI), r.registerComponentView(YZ), r.registerProcessor(r.PRIORITY.PROCESSOR.SERIES_FILTER, n_e), r.registerSubTypeDefaulter("legend", function() {
    return "plain";
  }), a_e(r);
}
var o_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.setScrollDataIndex = function(t) {
      this.option.scrollDataIndex = t;
    }, e.prototype.init = function(t, i, n) {
      var a = nd(t);
      r.prototype.init.call(this, t, i, n), U$(this, t, a);
    }, e.prototype.mergeOption = function(t, i) {
      r.prototype.mergeOption.call(this, t, i), U$(this, this.option, t);
    }, e.type = "legend.scroll", e.defaultOption = Zl(oI.defaultOption, {
      scrollDataIndex: 0,
      pageButtonItemGap: 5,
      pageButtonGap: null,
      pageButtonPosition: "end",
      pageFormatter: "{current}/{total}",
      pageIcons: {
        horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"],
        vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"]
      },
      pageIconColor: "#2f4554",
      pageIconInactiveColor: "#aaa",
      pageIconSize: 15,
      pageTextStyle: {
        color: "#333"
      },
      animationDurationUpdate: 800
    }), e;
  }(oI)
);
function U$(r, e, t) {
  var i = r.getOrient(), n = [1, 1];
  n[i.index] = 0, Pl(e, t, {
    type: "box",
    ignoreSize: !!n
  });
}
const s_e = o_e;
var $$ = Re, eA = ["width", "height"], tA = ["x", "y"], l_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.newlineDisabled = !0, t._currentIndex = 0, t;
    }
    return e.prototype.init = function() {
      r.prototype.init.call(this), this.group.add(this._containerGroup = new $$()), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new $$());
    }, e.prototype.resetInner = function() {
      r.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null;
    }, e.prototype.renderInner = function(t, i, n, a, o, s, l) {
      var u = this;
      r.prototype.renderInner.call(this, t, i, n, a, o, s, l);
      var c = this._controllerGroup, h = i.get("pageIconSize", !0), f = X(h) ? h : [h, h];
      p("pagePrev", 0);
      var d = i.getModel("pageTextStyle");
      c.add(new dt({
        name: "pageText",
        style: {
          // Placeholder to calculate a proper layout.
          text: "xx/xx",
          fill: d.getTextColor(),
          font: d.getFont(),
          verticalAlign: "middle",
          align: "center"
        },
        silent: !0
      })), p("pageNext", 1);
      function p(g, v) {
        var O = g + "DataIndex", m = Iv(i.get("pageIcons", !0)[i.getOrient().name][v], {
          // Buttons will be created in each render, so we do not need
          // to worry about avoiding using legendModel kept in scope.
          onclick: ue(u._pageGo, u, O, i, a)
        }, {
          x: -f[0] / 2,
          y: -f[1] / 2,
          width: f[0],
          height: f[1]
        });
        m.name = g, c.add(m);
      }
    }, e.prototype.layoutInner = function(t, i, n, a, o, s) {
      var l = this.getSelectorGroup(), u = t.getOrient().index, c = eA[u], h = tA[u], f = eA[1 - u], d = tA[1 - u];
      o && vc(
        // Buttons in selectorGroup always layout horizontally
        "horizontal",
        l,
        t.get("selectorItemGap", !0)
      );
      var p = t.get("selectorButtonGap", !0), g = l.getBoundingRect(), v = [-g.x, -g.y], O = ye(n);
      o && (O[c] = n[c] - g[c] - p);
      var m = this._layoutContentAndController(t, a, O, u, c, f, d, h);
      if (o) {
        if (s === "end")
          v[u] += m[c] + p;
        else {
          var E = g[c] + p;
          v[u] -= E, m[h] -= E;
        }
        m[c] += g[c] + p, v[1 - u] += m[d] + m[f] / 2 - g[f] / 2, m[f] = Math.max(m[f], g[f]), m[d] = Math.min(m[d], g[d] + v[1 - u]), l.x = v[0], l.y = v[1], l.markRedraw();
      }
      return m;
    }, e.prototype._layoutContentAndController = function(t, i, n, a, o, s, l, u) {
      var c = this.getContentGroup(), h = this._containerGroup, f = this._controllerGroup;
      vc(t.get("orient"), c, t.get("itemGap"), a ? n.width : null, a ? null : n.height), vc(
        // Buttons in controller are layout always horizontally.
        "horizontal",
        f,
        t.get("pageButtonItemGap", !0)
      );
      var d = c.getBoundingRect(), p = f.getBoundingRect(), g = this._showController = d[o] > n[o], v = [-d.x, -d.y];
      i || (v[a] = c[u]);
      var O = [0, 0], m = [-p.x, -p.y], E = ke(t.get("pageButtonGap", !0), t.get("itemGap", !0));
      if (g) {
        var b = t.get("pageButtonPosition", !0);
        b === "end" ? m[a] += n[o] - p[o] : O[a] += p[o] + E;
      }
      m[1 - a] += d[s] / 2 - p[s] / 2, c.setPosition(v), h.setPosition(O), f.setPosition(m);
      var S = {
        x: 0,
        y: 0
      };
      if (S[o] = g ? n[o] : d[o], S[s] = Math.max(d[s], p[s]), S[l] = Math.min(0, p[l] + m[1 - a]), h.__rectSize = n[o], g) {
        var T = {
          x: 0,
          y: 0
        };
        T[o] = Math.max(n[o] - p[o] - E, 0), T[s] = S[s], h.setClipPath(new ht({
          shape: T
        })), h.__rectSize = T[o];
      } else
        f.eachChild(function(R) {
          R.attr({
            invisible: !0,
            silent: !0
          });
        });
      var y = this._getPageInfo(t);
      return y.pageIndex != null && Ot(
        c,
        {
          x: y.contentPosition[0],
          y: y.contentPosition[1]
        },
        // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        g ? t : null
      ), this._updatePageInfoView(t, y), S;
    }, e.prototype._pageGo = function(t, i, n) {
      var a = this._getPageInfo(i)[t];
      a != null && n.dispatchAction({
        type: "legendScroll",
        scrollDataIndex: a,
        legendId: i.id
      });
    }, e.prototype._updatePageInfoView = function(t, i) {
      var n = this._controllerGroup;
      N(["pagePrev", "pageNext"], function(c) {
        var h = c + "DataIndex", f = i[h] != null, d = n.childOfName(c);
        d && (d.setStyle("fill", f ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), d.cursor = f ? "pointer" : "default");
      });
      var a = n.childOfName("pageText"), o = t.get("pageFormatter"), s = i.pageIndex, l = s != null ? s + 1 : 0, u = i.pageCount;
      a && o && a.setStyle("text", ne(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", u == null ? "" : u + "") : o({
        current: l,
        total: u
      }));
    }, e.prototype._getPageInfo = function(t) {
      var i = t.get("scrollDataIndex", !0), n = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = eA[o], l = tA[o], u = this._findTargetItemIndex(i), c = n.children(), h = c[u], f = c.length, d = f ? 1 : 0, p = {
        contentPosition: [n.x, n.y],
        pageCount: d,
        pageIndex: d - 1,
        pagePrevDataIndex: null,
        pageNextDataIndex: null
      };
      if (!h)
        return p;
      var g = b(h);
      p.contentPosition[o] = -g.s;
      for (var v = u + 1, O = g, m = g, E = null; v <= f; ++v)
        E = b(c[v]), // Half of the last item is out of the window.
        (!E && m.e > O.s + a || // If the current item does not intersect with the window, the new page
        // can be started at the current item or the last item.
        E && !S(E, O.s)) && (m.i > O.i ? O = m : O = E, O && (p.pageNextDataIndex == null && (p.pageNextDataIndex = O.i), ++p.pageCount)), m = E;
      for (var v = u - 1, O = g, m = g, E = null; v >= -1; --v)
        E = b(c[v]), // If the the end item does not intersect with the window started
        // from the current item, a page can be settled.
        (!E || !S(m, E.s)) && // e.g., when page size is smaller than item size.
        O.i < m.i && (m = O, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = O.i), ++p.pageCount, ++p.pageIndex), O = E;
      return p;
      function b(T) {
        if (T) {
          var y = T.getBoundingRect(), R = y[l] + T[l];
          return {
            s: R,
            e: R + y[s],
            i: T.__legendDataIndex
          };
        }
      }
      function S(T, y) {
        return T.e >= y && T.s <= y + a;
      }
    }, e.prototype._findTargetItemIndex = function(t) {
      if (!this._showController)
        return 0;
      var i, n = this.getContentGroup(), a;
      return n.eachChild(function(o, s) {
        var l = o.__legendDataIndex;
        a == null && l != null && (a = s), l === t && (i = s);
      }), i ?? a;
    }, e.type = "legend.scroll", e;
  }(YZ)
);
const u_e = l_e;
function c_e(r) {
  r.registerAction("legendScroll", "legendscroll", function(e, t) {
    var i = e.scrollDataIndex;
    i != null && t.eachComponent({
      mainType: "legend",
      subType: "scroll",
      query: e
    }, function(n) {
      n.setScrollDataIndex(i);
    });
  });
}
function h_e(r) {
  Ye(HZ), r.registerComponentModel(s_e), r.registerComponentView(u_e), c_e(r);
}
function f_e(r) {
  Ye(HZ), Ye(h_e);
}
var d_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.inside", e.defaultOption = Zl(Zg.defaultOption, {
      disabled: !1,
      zoomLock: !1,
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !1,
      preventDefaultMouseMove: !0
    }), e;
  }(Zg)
);
const p_e = d_e;
var Cx = ft();
function g_e(r, e, t) {
  Cx(r).coordSysRecordMap.each(function(i) {
    var n = i.dataZoomInfoMap.get(e.uid);
    n && (n.getRange = t);
  });
}
function v_e(r, e) {
  for (var t = Cx(r).coordSysRecordMap, i = t.keys(), n = 0; n < i.length; n++) {
    var a = i[n], o = t.get(a), s = o.dataZoomInfoMap;
    if (s) {
      var l = e.uid, u = s.get(l);
      u && (s.removeKey(l), s.keys().length || WZ(t, o));
    }
  }
}
function WZ(r, e) {
  if (e) {
    r.removeKey(e.model.uid);
    var t = e.controller;
    t && t.dispose();
  }
}
function O_e(r, e) {
  var t = {
    model: e,
    containsPoint: Le(E_e, e),
    dispatchAction: Le(m_e, r),
    dataZoomInfoMap: null,
    controller: null
  }, i = t.controller = new $v(r.getZr());
  return N(["pan", "zoom", "scrollMove"], function(n) {
    i.on(n, function(a) {
      var o = [];
      t.dataZoomInfoMap.each(function(s) {
        if (a.isAvailableBehavior(s.model.option)) {
          var l = (s.getRange || {})[n], u = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, a);
          !s.model.get("disabled", !0) && u && o.push({
            dataZoomId: s.model.id,
            start: u[0],
            end: u[1]
          });
        }
      }), o.length && t.dispatchAction(o);
    });
  }), t;
}
function m_e(r, e) {
  r.isDisposed() || r.dispatchAction({
    type: "dataZoom",
    animation: {
      easing: "cubicOut",
      duration: 100
    },
    batch: e
  });
}
function E_e(r, e, t, i) {
  return r.coordinateSystem.containPoint([t, i]);
}
function b_e(r) {
  var e, t = "type_", i = {
    type_true: 2,
    type_move: 1,
    type_false: 0,
    type_undefined: -1
  }, n = !0;
  return r.each(function(a) {
    var o = a.model, s = o.get("disabled", !0) ? !1 : o.get("zoomLock", !0) ? "move" : !0;
    i[t + s] > i[t + e] && (e = s), n = n && o.get("preventDefaultMouseMove", !0);
  }), {
    controlType: e,
    opt: {
      // RoamController will enable all of these functionalities,
      // and the final behavior is determined by its event listener
      // provided by each inside zoom.
      zoomOnMouseWheel: !0,
      moveOnMouseMove: !0,
      moveOnMouseWheel: !0,
      preventDefaultMouseMove: !!n
    }
  };
}
function S_e(r) {
  r.registerProcessor(r.PRIORITY.PROCESSOR.FILTER, function(e, t) {
    var i = Cx(t), n = i.coordSysRecordMap || (i.coordSysRecordMap = de());
    n.each(function(a) {
      a.dataZoomInfoMap = null;
    }), e.eachComponent({
      mainType: "dataZoom",
      subType: "inside"
    }, function(a) {
      var o = IZ(a);
      N(o.infoList, function(s) {
        var l = s.model.uid, u = n.get(l) || n.set(l, O_e(t, s.model)), c = u.dataZoomInfoMap || (u.dataZoomInfoMap = de());
        c.set(a.uid, {
          dzReferCoordSysInfo: s,
          model: a,
          getRange: null
        });
      });
    }), n.each(function(a) {
      var o = a.controller, s, l = a.dataZoomInfoMap;
      if (l) {
        var u = l.keys()[0];
        u != null && (s = l.get(u));
      }
      if (!s) {
        WZ(n, a);
        return;
      }
      var c = b_e(l);
      o.enable(c.controlType, c.opt), o.setPointerChecker(a.containsPoint), ud(a, "dispatchAction", s.model.get("throttle", !0), "fixRate");
    });
  });
}
var T_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataZoom.inside", t;
    }
    return e.prototype.render = function(t, i, n) {
      if (r.prototype.render.apply(this, arguments), t.noTarget()) {
        this._clear();
        return;
      }
      this.range = t.getPercentRange(), g_e(n, t, {
        pan: ue(rA.pan, this),
        zoom: ue(rA.zoom, this),
        scrollMove: ue(rA.scrollMove, this)
      });
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      v_e(this.api, this.dataZoomModel), this.range = null;
    }, e.type = "dataZoom.inside", e;
  }(mx)
), rA = {
  zoom: function(r, e, t, i) {
    var n = this.range, a = n.slice(), o = r.axisModels[0];
    if (o) {
      var s = iA[e](null, [i.originX, i.originY], o, t, r), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], u = Math.max(1 / i.scale, 0);
      a[0] = (a[0] - l) * u + l, a[1] = (a[1] - l) * u + l;
      var c = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan();
      if (eh(0, a, [0, 100], 0, c.minSpan, c.maxSpan), this.range = a, n[0] !== a[0] || n[1] !== a[1])
        return a;
    }
  },
  pan: V$(function(r, e, t, i, n, a) {
    var o = iA[i]([a.oldX, a.oldY], [a.newX, a.newY], e, n, t);
    return o.signal * (r[1] - r[0]) * o.pixel / o.pixelLength;
  }),
  scrollMove: V$(function(r, e, t, i, n, a) {
    var o = iA[i]([0, 0], [a.scrollDelta, a.scrollDelta], e, n, t);
    return o.signal * (r[1] - r[0]) * a.scrollDelta;
  })
};
function V$(r) {
  return function(e, t, i, n) {
    var a = this.range, o = a.slice(), s = e.axisModels[0];
    if (s) {
      var l = r(o, s, e, t, i, n);
      if (eh(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1])
        return o;
    }
  };
}
var iA = {
  grid: function(r, e, t, i, n) {
    var a = t.axis, o = {}, s = n.model.coordinateSystem.getRect();
    return r = r || [0, 0], a.dim === "x" ? (o.pixel = e[0] - r[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o;
  },
  polar: function(r, e, t, i, n) {
    var a = t.axis, o = {}, s = n.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), u = s.getAngleAxis().getExtent();
    return r = r ? s.pointToCoord(r) : [0, 0], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (o.pixel = e[0] - r[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - r[1], o.pixelLength = u[1] - u[0], o.pixelStart = u[0], o.signal = a.inverse ? -1 : 1), o;
  },
  singleAxis: function(r, e, t, i, n) {
    var a = t.axis, o = n.model.coordinateSystem.getRect(), s = {};
    return r = r || [0, 0], a.orient === "horizontal" ? (s.pixel = e[0] - r[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - r[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s;
  }
};
const y_e = T_e;
function zZ(r) {
  Ex(r), r.registerComponentModel(p_e), r.registerComponentView(y_e), S_e(r);
}
var R_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = Zl(Zg.defaultOption, {
      show: !0,
      // deault value can only be drived in view stage.
      right: "ph",
      top: "ph",
      width: "ph",
      height: "ph",
      left: null,
      bottom: null,
      borderColor: "#d2dbee",
      borderRadius: 3,
      backgroundColor: "rgba(47,69,84,0)",
      // dataBackgroundColor: '#ddd',
      dataBackground: {
        lineStyle: {
          color: "#d2dbee",
          width: 0.5
        },
        areaStyle: {
          color: "#d2dbee",
          opacity: 0.2
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: "#8fb0f7",
          width: 0.5
        },
        areaStyle: {
          color: "#8fb0f7",
          opacity: 0.2
        }
      },
      // Color of selected window.
      fillerColor: "rgba(135,175,274,0.2)",
      handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z",
      // Percent of the slider height
      handleSize: "100%",
      handleStyle: {
        color: "#fff",
        borderColor: "#ACB8D1"
      },
      moveHandleSize: 7,
      moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z",
      moveHandleStyle: {
        color: "#D2DBEE",
        opacity: 0.7
      },
      showDetail: !0,
      showDataShadow: "auto",
      realtime: !0,
      zoomLock: !1,
      textStyle: {
        color: "#6E7079"
      },
      brushSelect: !0,
      brushStyle: {
        color: "rgba(135,175,274,0.15)"
      },
      emphasis: {
        handleStyle: {
          borderColor: "#8FB0F7"
        },
        moveHandleStyle: {
          color: "#8FB0F7"
        }
      }
    }), e;
  }(Zg)
);
const A_e = R_e;
var Kd = ht, G$ = 7, __e = 1, nA = 30, C_e = 7, Jd = "horizontal", B$ = "vertical", I_e = 5, w_e = ["line", "bar", "candlestick", "scatter"], N_e = {
  easing: "cubicOut",
  duration: 100,
  delay: 0
}, x_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._displayables = {}, t;
    }
    return e.prototype.init = function(t, i) {
      this.api = i, this._onBrush = ue(this._onBrush, this), this._onBrushEnd = ue(this._onBrushEnd, this);
    }, e.prototype.render = function(t, i, n, a) {
      if (r.prototype.render.apply(this, arguments), ud(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      if (t.noTarget()) {
        this._clear(), this.group.removeAll();
        return;
      }
      (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView();
    }, e.prototype.dispose = function() {
      this._clear(), r.prototype.dispose.apply(this, arguments);
    }, e.prototype._clear = function() {
      Qg(this, "_dispatchZoomAction");
      var t = this.api.getZr();
      t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd);
    }, e.prototype._buildView = function() {
      var t = this.group;
      t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval();
      var i = this._displayables.sliderGroup = new Re();
      this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(i), this._positionGroup();
    }, e.prototype._resetLocation = function() {
      var t = this.dataZoomModel, i = this.api, n = t.get("brushSelect"), a = n ? C_e : 0, o = this._findCoordRect(), s = {
        width: i.getWidth(),
        height: i.getHeight()
      }, l = this._orient === Jd ? {
        // Why using 'right', because right should be used in vertical,
        // and it is better to be consistent for dealing with position param merge.
        right: s.width - o.x - o.width,
        top: s.height - nA - G$ - a,
        width: o.width,
        height: nA
      } : {
        right: G$,
        top: o.y,
        width: nA,
        height: o.height
      }, u = nd(t.option);
      N(["right", "top", "width", "height"], function(h) {
        u[h] === "ph" && (u[h] = l[h]);
      });
      var c = Ir(u, s);
      this._location = {
        x: c.x,
        y: c.y
      }, this._size = [c.width, c.height], this._orient === B$ && this._size.reverse();
    }, e.prototype._positionGroup = function() {
      var t = this.group, i = this._location, n = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse;
      s.attr(n === Jd && !o ? {
        scaleY: l ? 1 : -1,
        scaleX: 1
      } : n === Jd && o ? {
        scaleY: l ? 1 : -1,
        scaleX: -1
      } : n === B$ && !o ? {
        scaleY: l ? -1 : 1,
        scaleX: 1,
        rotation: Math.PI / 2
      } : {
        scaleY: l ? -1 : 1,
        scaleX: -1,
        rotation: Math.PI / 2
      });
      var u = t.getBoundingRect([s]);
      t.x = i.x - u.x, t.y = i.y - u.y, t.markRedraw();
    }, e.prototype._getViewExtent = function() {
      return [0, this._size[0]];
    }, e.prototype._renderBackground = function() {
      var t = this.dataZoomModel, i = this._size, n = this._displayables.sliderGroup, a = t.get("brushSelect");
      n.add(new Kd({
        silent: !0,
        shape: {
          x: 0,
          y: 0,
          width: i[0],
          height: i[1]
        },
        style: {
          fill: t.get("backgroundColor")
        },
        z2: -40
      }));
      var o = new Kd({
        shape: {
          x: 0,
          y: 0,
          width: i[0],
          height: i[1]
        },
        style: {
          fill: "transparent"
        },
        z2: 0,
        onclick: ue(this._onClickPanel, this)
      }), s = this.api.getZr();
      a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), n.add(o);
    }, e.prototype._renderDataShadow = function() {
      var t = this._dataShadowInfo = this._prepareDataShadowInfo();
      if (this._displayables.dataShadowSegs = [], !t)
        return;
      var i = this._size, n = this._shadowSize || [], a = t.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : t.otherDim;
      if (l == null)
        return;
      var u = this._shadowPolygonPts, c = this._shadowPolylinePts;
      if (o !== this._shadowData || l !== this._shadowDim || i[0] !== n[0] || i[1] !== n[1]) {
        var h = o.getDataExtent(l), f = (h[1] - h[0]) * 0.3;
        h = [h[0] - f, h[1] + f];
        var d = [0, i[1]], p = [0, i[0]], g = [[i[0], 0], [0, 0]], v = [], O = p[1] / (o.count() - 1), m = 0, E = Math.round(o.count() / i[0]), b;
        o.each([l], function(_, C) {
          if (E > 0 && C % E) {
            m += O;
            return;
          }
          var I = _ == null || isNaN(_) || _ === "", w = I ? 0 : yt(_, h, d, !0);
          I && !b && C ? (g.push([g[g.length - 1][0], 0]), v.push([v[v.length - 1][0], 0])) : !I && b && (g.push([m, 0]), v.push([m, 0])), g.push([m, w]), v.push([m, w]), m += O, b = I;
        }), u = this._shadowPolygonPts = g, c = this._shadowPolylinePts = v;
      }
      this._shadowData = o, this._shadowDim = l, this._shadowSize = [i[0], i[1]];
      var S = this.dataZoomModel;
      function T(_) {
        var C = S.getModel(_ ? "selectedDataBackground" : "dataBackground"), I = new Re(), w = new rn({
          shape: {
            points: u
          },
          segmentIgnoreThreshold: 1,
          style: C.getModel("areaStyle").getAreaStyle(),
          silent: !0,
          z2: -20
        }), x = new nn({
          shape: {
            points: c
          },
          segmentIgnoreThreshold: 1,
          style: C.getModel("lineStyle").getLineStyle(),
          silent: !0,
          z2: -19
        });
        return I.add(w), I.add(x), I;
      }
      for (var y = 0; y < 3; y++) {
        var R = T(y === 1);
        this._displayables.sliderGroup.add(R), this._displayables.dataShadowSegs.push(R);
      }
    }, e.prototype._prepareDataShadowInfo = function() {
      var t = this.dataZoomModel, i = t.get("showDataShadow");
      if (i !== !1) {
        var n, a = this.ecModel;
        return t.eachTargetAxis(function(o, s) {
          var l = t.getAxisProxy(o, s).getTargetSeriesModels();
          N(l, function(u) {
            if (!n && !(i !== !0 && Fe(w_e, u.get("type")) < 0)) {
              var c = a.getComponent(ol(o), s).axis, h = P_e(o), f, d = u.coordinateSystem;
              h != null && d.getOtherAxis && (f = d.getOtherAxis(c).inverse), h = u.getData().mapDimension(h), n = {
                thisAxis: c,
                series: u,
                thisDim: o,
                otherDim: h,
                otherAxisInverse: f
              };
            }
          }, this);
        }, this), n;
      }
    }, e.prototype._renderHandle = function() {
      var t = this.group, i = this._displayables, n = i.handles = [null, null], a = i.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, u = this.api, c = l.get("borderRadius") || 0, h = l.get("brushSelect"), f = i.filler = new Kd({
        silent: h,
        style: {
          fill: l.get("fillerColor")
        },
        textConfig: {
          position: "inside"
        }
      });
      o.add(f), o.add(new Kd({
        silent: !0,
        subPixelOptimize: !0,
        shape: {
          x: 0,
          y: 0,
          width: s[0],
          height: s[1],
          r: c
        },
        style: {
          // deprecated option
          stroke: l.get("dataBackgroundColor") || l.get("borderColor"),
          lineWidth: __e,
          fill: "rgba(0,0,0,0)"
        }
      })), N([0, 1], function(E) {
        var b = l.get("handleIcon");
        !vb[b] && b.indexOf("path://") < 0 && b.indexOf("image://") < 0 && (b = "path://" + b, {}.NODE_ENV !== "production" && Pa("handleIcon now needs 'path://' prefix when using a path string"));
        var S = Er(b, -1, 0, 2, 2, null, !0);
        S.attr({
          cursor: F$(this._orient),
          draggable: !0,
          drift: ue(this._onDragMove, this, E),
          ondragend: ue(this._onDragEnd, this),
          onmouseover: ue(this._showDataInfo, this, !0),
          onmouseout: ue(this._showDataInfo, this, !1),
          z2: 5
        });
        var T = S.getBoundingRect(), y = l.get("handleSize");
        this._handleHeight = K(y, this._size[1]), this._handleWidth = T.width / T.height * this._handleHeight, S.setStyle(l.getModel("handleStyle").getItemStyle()), S.style.strokeNoScale = !0, S.rectHover = !0, S.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), pc(S);
        var R = l.get("handleColor");
        R != null && (S.style.fill = R), o.add(n[E] = S);
        var _ = l.getModel("textStyle");
        t.add(a[E] = new dt({
          silent: !0,
          invisible: !0,
          style: Qt(_, {
            x: 0,
            y: 0,
            text: "",
            verticalAlign: "middle",
            align: "center",
            fill: _.getTextColor(),
            font: _.getFont()
          }),
          z2: 10
        }));
      }, this);
      var d = f;
      if (h) {
        var p = K(l.get("moveHandleSize"), s[1]), g = i.moveHandle = new ht({
          style: l.getModel("moveHandleStyle").getItemStyle(),
          silent: !0,
          shape: {
            r: [0, 0, 2, 2],
            y: s[1] - 0.5,
            height: p
          }
        }), v = p * 0.8, O = i.moveHandleIcon = Er(l.get("moveHandleIcon"), -v / 2, -v / 2, v, v, "#fff", !0);
        O.silent = !0, O.y = s[1] + p / 2 - 0.5, g.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle();
        var m = Math.min(s[1] / 2, Math.max(p, 10));
        d = i.moveZone = new ht({
          invisible: !0,
          shape: {
            y: s[1] - m,
            height: p + m
          }
        }), d.on("mouseover", function() {
          u.enterEmphasis(g);
        }).on("mouseout", function() {
          u.leaveEmphasis(g);
        }), o.add(g), o.add(O), o.add(d);
      }
      d.attr({
        draggable: !0,
        cursor: F$(this._orient),
        drift: ue(this._onDragMove, this, "all"),
        ondragstart: ue(this._showDataInfo, this, !0),
        ondragend: ue(this._onDragEnd, this),
        onmouseover: ue(this._showDataInfo, this, !0),
        onmouseout: ue(this._showDataInfo, this, !1)
      });
    }, e.prototype._resetInterval = function() {
      var t = this._range = this.dataZoomModel.getPercentRange(), i = this._getViewExtent();
      this._handleEnds = [yt(t[0], [0, 100], i, !0), yt(t[1], [0, 100], i, !0)];
    }, e.prototype._updateInterval = function(t, i) {
      var n = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = n.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100];
      eh(i, a, o, n.get("zoomLock") ? "all" : t, s.minSpan != null ? yt(s.minSpan, l, o, !0) : null, s.maxSpan != null ? yt(s.maxSpan, l, o, !0) : null);
      var u = this._range, c = this._range = Zn([yt(a[0], o, l, !0), yt(a[1], o, l, !0)]);
      return !u || u[0] !== c[0] || u[1] !== c[1];
    }, e.prototype._updateView = function(t) {
      var i = this._displayables, n = this._handleEnds, a = Zn(n.slice()), o = this._size;
      N([0, 1], function(d) {
        var p = i.handles[d], g = this._handleHeight;
        p.attr({
          scaleX: g / 2,
          scaleY: g / 2,
          // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
          // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
          x: n[d] + (d ? -1 : 1),
          y: o[1] / 2 - g / 2
        });
      }, this), i.filler.setShape({
        x: a[0],
        y: 0,
        width: a[1] - a[0],
        height: o[1]
      });
      var s = {
        x: a[0],
        width: a[1] - a[0]
      };
      i.moveHandle && (i.moveHandle.setShape(s), i.moveZone.setShape(s), i.moveZone.getBoundingRect(), i.moveHandleIcon && i.moveHandleIcon.attr("x", s.x + s.width / 2));
      for (var l = i.dataShadowSegs, u = [0, a[0], a[1], o[0]], c = 0; c < l.length; c++) {
        var h = l[c], f = h.getClipPath();
        f || (f = new ht(), h.setClipPath(f)), f.setShape({
          x: u[c],
          y: 0,
          width: u[c + 1] - u[c],
          height: o[1]
        });
      }
      this._updateDataInfo(t);
    }, e.prototype._updateDataInfo = function(t) {
      var i = this.dataZoomModel, n = this._displayables, a = n.handleLabels, o = this._orient, s = ["", ""];
      if (i.get("showDetail")) {
        var l = i.findRepresentativeAxisProxy();
        if (l) {
          var u = l.getAxisModel().axis, c = this._range, h = t ? l.calculateDataWindow({
            start: c[0],
            end: c[1]
          }).valueWindow : l.getDataValueWindow();
          s = [this._formatLabel(h[0], u), this._formatLabel(h[1], u)];
        }
      }
      var f = Zn(this._handleEnds.slice());
      d.call(this, 0), d.call(this, 1);
      function d(p) {
        var g = gc(n.handles[p].parent, this.group), v = ST(p === 0 ? "right" : "left", g), O = this._handleWidth / 2 + I_e, m = Ia([f[p] + (p === 0 ? -O : O), this._size[1] / 2], g);
        a[p].setStyle({
          x: m[0],
          y: m[1],
          verticalAlign: o === Jd ? "middle" : v,
          align: o === Jd ? v : "center",
          text: s[p]
        });
      }
    }, e.prototype._formatLabel = function(t, i) {
      var n = this.dataZoomModel, a = n.get("labelFormatter"), o = n.get("labelPrecision");
      (o == null || o === "auto") && (o = i.getPixelPrecision());
      var s = t == null || isNaN(t) ? "" : i.type === "category" || i.type === "time" ? i.scale.getLabel({
        value: Math.round(t)
      }) : t.toFixed(Math.min(o, 20));
      return ve(a) ? a(t, s) : ne(a) ? a.replace("{value}", s) : s;
    }, e.prototype._showDataInfo = function(t) {
      t = this._dragging || t;
      var i = this._displayables, n = i.handleLabels;
      n[0].attr("invisible", !t), n[1].attr("invisible", !t), i.moveHandle && this.api[t ? "enterEmphasis" : "leaveEmphasis"](i.moveHandle, 1);
    }, e.prototype._onDragMove = function(t, i, n, a) {
      this._dragging = !0, os(a.event);
      var o = this._displayables.sliderGroup.getLocalTransform(), s = Ia([i, n], o, !0), l = this._updateInterval(t, s[0]), u = this.dataZoomModel.get("realtime");
      this._updateView(!u), l && u && this._dispatchZoomAction(!0);
    }, e.prototype._onDragEnd = function() {
      this._dragging = !1, this._showDataInfo(!1);
      var t = this.dataZoomModel.get("realtime");
      !t && this._dispatchZoomAction(!1);
    }, e.prototype._onClickPanel = function(t) {
      var i = this._size, n = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY);
      if (!(n[0] < 0 || n[0] > i[0] || n[1] < 0 || n[1] > i[1])) {
        var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", n[0] - o);
        this._updateView(), s && this._dispatchZoomAction(!1);
      }
    }, e.prototype._onBrushStart = function(t) {
      var i = t.offsetX, n = t.offsetY;
      this._brushStart = new Me(i, n), this._brushing = !0, this._brushStartTime = +/* @__PURE__ */ new Date();
    }, e.prototype._onBrushEnd = function(t) {
      if (this._brushing) {
        var i = this._displayables.brushRect;
        if (this._brushing = !1, !!i) {
          i.attr("ignore", !0);
          var n = i.shape, a = +/* @__PURE__ */ new Date();
          if (!(a - this._brushStartTime < 200 && Math.abs(n.width) < 5)) {
            var o = this._getViewExtent(), s = [0, 100];
            this._range = Zn([yt(n.x, o, s, !0), yt(n.x + n.width, o, s, !0)]), this._handleEnds = [n.x, n.x + n.width], this._updateView(), this._dispatchZoomAction(!1);
          }
        }
      }
    }, e.prototype._onBrush = function(t) {
      this._brushing && (os(t.event), this._updateBrushRect(t.offsetX, t.offsetY));
    }, e.prototype._updateBrushRect = function(t, i) {
      var n = this._displayables, a = this.dataZoomModel, o = n.brushRect;
      o || (o = n.brushRect = new Kd({
        silent: !0,
        style: a.getModel("brushStyle").getItemStyle()
      }), n.sliderGroup.add(o)), o.attr("ignore", !1);
      var s = this._brushStart, l = this._displayables.sliderGroup, u = l.transformCoordToLocal(t, i), c = l.transformCoordToLocal(s.x, s.y), h = this._size;
      u[0] = Math.max(Math.min(h[0], u[0]), 0), o.setShape({
        x: c[0],
        y: 0,
        width: u[0] - c[0],
        height: h[1]
      });
    }, e.prototype._dispatchZoomAction = function(t) {
      var i = this._range;
      this.api.dispatchAction({
        type: "dataZoom",
        from: this.uid,
        dataZoomId: this.dataZoomModel.id,
        animation: t ? N_e : null,
        start: i[0],
        end: i[1]
      });
    }, e.prototype._findCoordRect = function() {
      var t, i = IZ(this.dataZoomModel).infoList;
      if (!t && i.length) {
        var n = i[0].model.coordinateSystem;
        t = n.getRect && n.getRect();
      }
      if (!t) {
        var a = this.api.getWidth(), o = this.api.getHeight();
        t = {
          x: a * 0.2,
          y: o * 0.2,
          width: a * 0.6,
          height: o * 0.6
        };
      }
      return t;
    }, e.type = "dataZoom.slider", e;
  }(mx)
);
function P_e(r) {
  var e = {
    x: "y",
    y: "x",
    radius: "angle",
    angle: "radius"
  };
  return e[r];
}
function F$(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
const L_e = x_e;
function ZZ(r) {
  r.registerComponentModel(A_e), r.registerComponentView(L_e), Ex(r);
}
function D_e(r) {
  Ye(zZ), Ye(ZZ);
}
var M_e = {
  /**
   * @public
   */
  get: function(r, e, t) {
    var i = ye((k_e[r] || {})[e]);
    return t && X(i) ? i[i.length - 1] : i;
  }
}, k_e = {
  color: {
    active: ["#006edd", "#e0ffff"],
    inactive: ["rgba(0,0,0,0)"]
  },
  colorHue: {
    active: [0, 360],
    inactive: [0, 0]
  },
  colorSaturation: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  colorLightness: {
    active: [0.9, 0.5],
    inactive: [0, 0]
  },
  colorAlpha: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  opacity: {
    active: [0.3, 1],
    inactive: [0, 0]
  },
  symbol: {
    active: ["circle", "roundRect", "diamond"],
    inactive: ["none"]
  },
  symbolSize: {
    active: [10, 50],
    inactive: [0, 0]
  }
};
const qZ = M_e;
var X$ = Jr.mapVisual, Q_e = Jr.eachVisual, U_e = X, Y$ = N, $_e = Zn, V_e = yt, G_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.stateList = ["inRange", "outOfRange"], t.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], t.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, t.dataBound = [-1 / 0, 1 / 0], t.targetVisuals = {}, t.controllerVisuals = {}, t;
    }
    return e.prototype.init = function(t, i, n) {
      this.mergeDefaultAndTheme(t, n);
    }, e.prototype.optionUpdated = function(t, i) {
      var n = this.option;
      !i && UZ(n, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption();
    }, e.prototype.resetVisual = function(t) {
      var i = this.stateList;
      t = ue(t, this), this.controllerVisuals = iI(this.option.controller, i, t), this.targetVisuals = iI(this.option.target, i, t);
    }, e.prototype.getItemSymbol = function() {
      return null;
    }, e.prototype.getTargetSeriesIndices = function() {
      var t = this.option.seriesIndex, i = [];
      return t == null || t === "all" ? this.ecModel.eachSeries(function(n, a) {
        i.push(a);
      }) : i = It(t), i;
    }, e.prototype.eachTargetSeries = function(t, i) {
      N(this.getTargetSeriesIndices(), function(n) {
        var a = this.ecModel.getSeriesByIndex(n);
        a && t.call(i, a);
      }, this);
    }, e.prototype.isTargetSeries = function(t) {
      var i = !1;
      return this.eachTargetSeries(function(n) {
        n === t && (i = !0);
      }), i;
    }, e.prototype.formatValueText = function(t, i, n) {
      var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, u;
      n = n || ["<", ">"], X(t) && (t = t.slice(), u = !0);
      var c = i ? t : u ? [h(t[0]), h(t[1])] : h(t);
      if (ne(l))
        return l.replace("{value}", u ? c[0] : c).replace("{value2}", u ? c[1] : c);
      if (ve(l))
        return u ? l(t[0], t[1]) : l(t);
      if (u)
        return t[0] === s[0] ? n[0] + " " + c[1] : t[1] === s[1] ? n[1] + " " + c[0] : c[0] + " - " + c[1];
      return c;
      function h(f) {
        return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20));
      }
    }, e.prototype.resetExtent = function() {
      var t = this.option, i = $_e([t.min, t.max]);
      this._dataExtent = i;
    }, e.prototype.getDataDimensionIndex = function(t) {
      var i = this.option.dimension;
      if (i != null)
        return t.getDimensionIndex(i);
      for (var n = t.dimensions, a = n.length - 1; a >= 0; a--) {
        var o = n[a], s = t.getDimensionInfo(o);
        if (!s.isCalculationCoord)
          return s.storeDimIndex;
      }
    }, e.prototype.getExtent = function() {
      return this._dataExtent.slice();
    }, e.prototype.completeVisualOption = function() {
      var t = this.ecModel, i = this.option, n = {
        inRange: i.inRange,
        outOfRange: i.outOfRange
      }, a = i.target || (i.target = {}), o = i.controller || (i.controller = {});
      $e(a, n), $e(o, n);
      var s = this.isCategory();
      l.call(this, a), l.call(this, o), u.call(this, a, "inRange", "outOfRange"), c.call(this, o);
      function l(h) {
        U_e(i.color) && !h.inRange && (h.inRange = {
          color: i.color.slice().reverse()
        }), h.inRange = h.inRange || {
          color: t.get("gradientColor")
        };
      }
      function u(h, f, d) {
        var p = h[f], g = h[d];
        p && !g && (g = h[d] = {}, Y$(p, function(v, O) {
          if (Jr.isValidType(O)) {
            var m = qZ.get(O, "inactive", s);
            m != null && (g[O] = m, O === "color" && !g.hasOwnProperty("opacity") && !g.hasOwnProperty("colorAlpha") && (g.opacity = [0, 0]));
          }
        }));
      }
      function c(h) {
        var f = (h.inRange || {}).symbol || (h.outOfRange || {}).symbol, d = (h.inRange || {}).symbolSize || (h.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), g = this.getItemSymbol(), v = g || "roundRect";
        Y$(this.stateList, function(O) {
          var m = this.itemSize, E = h[O];
          E || (E = h[O] = {
            color: s ? p : [p]
          }), E.symbol == null && (E.symbol = f && ye(f) || (s ? v : [v])), E.symbolSize == null && (E.symbolSize = d && ye(d) || (s ? m[0] : [m[0], m[0]])), E.symbol = X$(E.symbol, function(T) {
            return T === "none" ? v : T;
          });
          var b = E.symbolSize;
          if (b != null) {
            var S = -1 / 0;
            Q_e(b, function(T) {
              T > S && (S = T);
            }), E.symbolSize = X$(b, function(T) {
              return V_e(T, [0, S], [0, m[0]], !0);
            });
          }
        }, this);
      }
    }, e.prototype.resetItemSize = function() {
      this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))];
    }, e.prototype.isCategory = function() {
      return !!this.option.categories;
    }, e.prototype.setSelected = function(t) {
    }, e.prototype.getSelected = function() {
      return null;
    }, e.prototype.getValueState = function(t) {
      return null;
    }, e.prototype.getVisualMeta = function(t) {
      return null;
    }, e.type = "visualMap", e.dependencies = ["series"], e.defaultOption = {
      show: !0,
      // zlevel: 0,
      z: 4,
      seriesIndex: "all",
      min: 0,
      max: 200,
      left: 0,
      right: null,
      top: null,
      bottom: 0,
      itemWidth: null,
      itemHeight: null,
      inverse: !1,
      orient: "vertical",
      backgroundColor: "rgba(0,0,0,0)",
      borderColor: "#ccc",
      contentColor: "#5793f3",
      inactiveColor: "#aaa",
      borderWidth: 0,
      padding: 5,
      // css
      textGap: 10,
      precision: 0,
      textStyle: {
        color: "#333"
        // 
      }
    }, e;
  }(st)
);
const Yb = G_e;
var H$ = [20, 140], B_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.optionUpdated = function(t, i) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function(n) {
        n.mappingMethod = "linear", n.dataExtent = this.getExtent();
      }), this._resetRange();
    }, e.prototype.resetItemSize = function() {
      r.prototype.resetItemSize.apply(this, arguments);
      var t = this.itemSize;
      (t[0] == null || isNaN(t[0])) && (t[0] = H$[0]), (t[1] == null || isNaN(t[1])) && (t[1] = H$[1]);
    }, e.prototype._resetRange = function() {
      var t = this.getExtent(), i = this.option.range;
      !i || i.auto ? (t.auto = 1, this.option.range = t) : X(i) && (i[0] > i[1] && i.reverse(), i[0] = Math.max(i[0], t[0]), i[1] = Math.min(i[1], t[1]));
    }, e.prototype.completeVisualOption = function() {
      r.prototype.completeVisualOption.apply(this, arguments), N(this.stateList, function(t) {
        var i = this.option.controller[t].symbolSize;
        i && i[0] !== i[1] && (i[0] = i[1] / 3);
      }, this);
    }, e.prototype.setSelected = function(t) {
      this.option.range = t.slice(), this._resetRange();
    }, e.prototype.getSelected = function() {
      var t = this.getExtent(), i = Zn((this.get("range") || []).slice());
      return i[0] > t[1] && (i[0] = t[1]), i[1] > t[1] && (i[1] = t[1]), i[0] < t[0] && (i[0] = t[0]), i[1] < t[0] && (i[1] = t[0]), i;
    }, e.prototype.getValueState = function(t) {
      var i = this.option.range, n = this.getExtent();
      return (i[0] <= n[0] || i[0] <= t) && (i[1] >= n[1] || t <= i[1]) ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var i = [];
      return this.eachTargetSeries(function(n) {
        var a = [], o = n.getData();
        o.each(this.getDataDimensionIndex(o), function(s, l) {
          t[0] <= s && s <= t[1] && a.push(l);
        }, this), i.push({
          seriesId: n.id,
          dataIndex: a
        });
      }, this), i;
    }, e.prototype.getVisualMeta = function(t) {
      var i = W$(this, "outOfRange", this.getExtent()), n = W$(this, "inRange", this.option.range.slice()), a = [];
      function o(d, p) {
        a.push({
          value: d,
          color: t(d, p)
        });
      }
      for (var s = 0, l = 0, u = n.length, c = i.length; l < c && (!n.length || i[l] <= n[0]); l++)
        i[l] < n[s] && o(i[l], "outOfRange");
      for (var h = 1; s < u; s++, h = 0)
        h && a.length && o(n[s], "outOfRange"), o(n[s], "inRange");
      for (var h = 1; l < c; l++)
        (!n.length || n[n.length - 1] < i[l]) && (h && (a.length && o(a[a.length - 1].value, "outOfRange"), h = 0), o(i[l], "outOfRange"));
      var f = a.length;
      return {
        stops: a,
        outerColors: [f ? a[0].color : "transparent", f ? a[f - 1].color : "transparent"]
      };
    }, e.type = "visualMap.continuous", e.defaultOption = Zl(Yb.defaultOption, {
      align: "auto",
      calculable: !1,
      hoverLink: !0,
      realtime: !0,
      handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z",
      handleSize: "120%",
      handleStyle: {
        borderColor: "#fff",
        borderWidth: 1
      },
      indicatorIcon: "circle",
      indicatorSize: "50%",
      indicatorStyle: {
        borderColor: "#fff",
        borderWidth: 2,
        shadowBlur: 2,
        shadowOffsetX: 1,
        shadowOffsetY: 1,
        shadowColor: "rgba(0,0,0,0.2)"
      }
      // emphasis: {
      //     handleStyle: {
      //         shadowBlur: 3,
      //         shadowOffsetX: 1,
      //         shadowOffsetY: 1,
      //         shadowColor: 'rgba(0,0,0,0.2)'
      //     }
      // }
    }), e;
  }(Yb)
);
function W$(r, e, t) {
  if (t[0] === t[1])
    return t.slice();
  for (var i = 200, n = (t[1] - t[0]) / i, a = t[0], o = [], s = 0; s <= i && a < t[1]; s++)
    o.push(a), a += n;
  return o.push(t[1]), o;
}
const F_e = B_e;
var X_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t.autoPositionValues = {
        left: 1,
        right: 1,
        top: 1,
        bottom: 1
      }, t;
    }
    return e.prototype.init = function(t, i) {
      this.ecModel = t, this.api = i;
    }, e.prototype.render = function(t, i, n, a) {
      if (this.visualMapModel = t, t.get("show") === !1) {
        this.group.removeAll();
        return;
      }
      this.doRender(t, i, n, a);
    }, e.prototype.renderBackground = function(t) {
      var i = this.visualMapModel, n = id(i.get("padding") || 0), a = t.getBoundingRect();
      t.add(new ht({
        z2: -1,
        silent: !0,
        shape: {
          x: a.x - n[3],
          y: a.y - n[0],
          width: a.width + n[3] + n[1],
          height: a.height + n[0] + n[2]
        },
        style: {
          fill: i.get("backgroundColor"),
          stroke: i.get("borderColor"),
          lineWidth: i.get("borderWidth")
        }
      }));
    }, e.prototype.getControllerVisual = function(t, i, n) {
      n = n || {};
      var a = n.forceState, o = this.visualMapModel, s = {};
      if (i === "color") {
        var l = o.get("contentColor");
        s.color = l;
      }
      function u(d) {
        return s[d];
      }
      function c(d, p) {
        s[d] = p;
      }
      var h = o.controllerVisuals[a || o.getValueState(t)], f = Jr.prepareVisualTypes(h);
      return N(f, function(d) {
        var p = h[d];
        n.convertOpacityToAlpha && d === "opacity" && (d = "colorAlpha", p = h.__alphaForOpacity), Jr.dependsOn(d, i) && p && p.applyVisual(t, u, c);
      }), s[i];
    }, e.prototype.positionGroup = function(t) {
      var i = this.visualMapModel, n = this.api;
      IT(t, i.getBoxLayoutParams(), {
        width: n.getWidth(),
        height: n.getHeight()
      });
    }, e.prototype.doRender = function(t, i, n, a) {
    }, e.type = "visualMap", e;
  }(jt)
);
const jZ = X_e;
var z$ = [["left", "right", "width"], ["top", "bottom", "height"]];
function KZ(r, e, t) {
  var i = r.option, n = i.align;
  if (n != null && n !== "auto")
    return n;
  for (var a = {
    width: e.getWidth(),
    height: e.getHeight()
  }, o = i.orient === "horizontal" ? 1 : 0, s = z$[o], l = [0, null, 10], u = {}, c = 0; c < 3; c++)
    u[z$[1 - o][c]] = l[c], u[s[c]] = c === 2 ? t[0] : i[s[c]];
  var h = [["x", "width", 3], ["y", "height", 0]][o], f = Ir(u, a, i.padding);
  return s[(f.margin[h[2]] || 0) + f[h[0]] + f[h[1]] * 0.5 < a[h[1]] * 0.5 ? 0 : 1];
}
function lE(r, e) {
  return N(r || [], function(t) {
    t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "");
  }), r;
}
var Wa = yt, Y_e = N, Z$ = Math.min, aA = Math.max, H_e = 12, W_e = 6, z_e = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t;
    }
    return e.prototype.doRender = function(t, i, n, a) {
      this._api = n, (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView();
    }, e.prototype._buildView = function() {
      this.group.removeAll();
      var t = this.visualMapModel, i = this.group;
      this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(i);
      var n = t.get("text");
      this._renderEndsText(i, n, 0), this._renderEndsText(i, n, 1), this._updateView(!0), this.renderBackground(i), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(i);
    }, e.prototype._renderEndsText = function(t, i, n) {
      if (i) {
        var a = i[1 - n];
        a = a != null ? a + "" : "";
        var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, u = this._shapes.mainGroup, c = this._applyTransform([l[0] / 2, n === 0 ? -s : l[1] + s], u), h = this._applyTransform(n === 0 ? "bottom" : "top", u), f = this._orient, d = this.visualMapModel.textStyleModel;
        this.group.add(new dt({
          style: Qt(d, {
            x: c[0],
            y: c[1],
            verticalAlign: f === "horizontal" ? "middle" : h,
            align: f === "horizontal" ? h : "center",
            text: a
          })
        }));
      }
    }, e.prototype._renderBar = function(t) {
      var i = this.visualMapModel, n = this._shapes, a = i.itemSize, o = this._orient, s = this._useHandle, l = KZ(i, this.api, a), u = n.mainGroup = this._createBarGroup(l), c = new Re();
      u.add(c), c.add(n.outOfRange = q$()), c.add(n.inRange = q$(null, s ? K$(this._orient) : null, ue(this._dragHandle, this, "all", !1), ue(this._dragHandle, this, "all", !0))), c.setClipPath(new ht({
        shape: {
          x: 0,
          y: 0,
          width: a[0],
          height: a[1],
          r: 3
        }
      }));
      var h = i.textStyleModel.getTextRect(""), f = aA(h.width, h.height);
      s && (n.handleThumbs = [], n.handleLabels = [], n.handleLabelPoints = [], this._createHandle(i, u, 0, a, f, o), this._createHandle(i, u, 1, a, f, o)), this._createIndicator(i, u, a, f, o), t.add(u);
    }, e.prototype._createHandle = function(t, i, n, a, o, s) {
      var l = ue(this._dragHandle, this, n, !1), u = ue(this._dragHandle, this, n, !0), c = xa(t.get("handleSize"), a[0]), h = Er(t.get("handleIcon"), -c / 2, -c / 2, c, c, null, !0), f = K$(this._orient);
      h.attr({
        cursor: f,
        draggable: !0,
        drift: l,
        ondragend: u,
        onmousemove: function(O) {
          os(O.event);
        }
      }), h.x = a[0] / 2, h.useStyle(t.getModel("handleStyle").getItemStyle()), h.setStyle({
        strokeNoScale: !0,
        strokeFirst: !0
      }), h.style.lineWidth *= 2, h.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), Zu(h, !0), i.add(h);
      var d = this.visualMapModel.textStyleModel, p = new dt({
        cursor: f,
        draggable: !0,
        drift: l,
        onmousemove: function(O) {
          os(O.event);
        },
        ondragend: u,
        style: Qt(d, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      p.ensureState("blur").style = {
        opacity: 0.1
      }, p.stateTransition = {
        duration: 200
      }, this.group.add(p);
      var g = [c, 0], v = this._shapes;
      v.handleThumbs[n] = h, v.handleLabelPoints[n] = g, v.handleLabels[n] = p;
    }, e.prototype._createIndicator = function(t, i, n, a, o) {
      var s = xa(t.get("indicatorSize"), n[0]), l = Er(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0);
      l.attr({
        cursor: "move",
        invisible: !0,
        silent: !0,
        x: n[0] / 2
      });
      var u = t.getModel("indicatorStyle").getItemStyle();
      if (l instanceof ni) {
        var c = l.style;
        l.useStyle(B({
          // TODO other properties like x, y ?
          image: c.image,
          x: c.x,
          y: c.y,
          width: c.width,
          height: c.height
        }, u));
      } else
        l.useStyle(u);
      i.add(l);
      var h = this.visualMapModel.textStyleModel, f = new dt({
        silent: !0,
        invisible: !0,
        style: Qt(h, {
          x: 0,
          y: 0,
          text: ""
        })
      });
      this.group.add(f);
      var d = [(o === "horizontal" ? a / 2 : W_e) + n[0] / 2, 0], p = this._shapes;
      p.indicator = l, p.indicatorLabel = f, p.indicatorLabelPoint = d, this._firstShowIndicator = !0;
    }, e.prototype._dragHandle = function(t, i, n, a) {
      if (this._useHandle) {
        if (this._dragging = !i, !i) {
          var o = this._applyTransform([n, a], this._shapes.mainGroup, !0);
          this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView();
        }
        i === !this.visualMapModel.get("realtime") && this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: this._dataInterval.slice()
        }), i ? !this._hovering && this._clearHoverLinkToSeries() : j$(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1);
      }
    }, e.prototype._resetInterval = function() {
      var t = this.visualMapModel, i = this._dataInterval = t.getSelected(), n = t.getExtent(), a = [0, t.itemSize[1]];
      this._handleEnds = [Wa(i[0], n, a, !0), Wa(i[1], n, a, !0)];
    }, e.prototype._updateInterval = function(t, i) {
      i = i || 0;
      var n = this.visualMapModel, a = this._handleEnds, o = [0, n.itemSize[1]];
      eh(
        i,
        a,
        o,
        t,
        // cross is forbidden
        0
      );
      var s = n.getExtent();
      this._dataInterval = [Wa(a[0], o, s, !0), Wa(a[1], o, s, !0)];
    }, e.prototype._updateView = function(t) {
      var i = this.visualMapModel, n = i.getExtent(), a = this._shapes, o = [0, i.itemSize[1]], s = t ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, n, s, "inRange"), u = this._createBarVisual(n, n, o, "outOfRange");
      a.inRange.setStyle({
        fill: l.barColor
        // opacity: visualInRange.opacity
      }).setShape("points", l.barPoints), a.outOfRange.setStyle({
        fill: u.barColor
        // opacity: visualOutOfRange.opacity
      }).setShape("points", u.barPoints), this._updateHandle(s, l);
    }, e.prototype._createBarVisual = function(t, i, n, a) {
      var o = {
        forceState: a,
        convertOpacityToAlpha: !0
      }, s = this._makeColorGradient(t, o), l = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)], u = this._createBarPoints(n, l);
      return {
        barColor: new _v(0, 0, 0, 1, s),
        barPoints: u,
        handlesColor: [s[0].color, s[s.length - 1].color]
      };
    }, e.prototype._makeColorGradient = function(t, i) {
      var n = 100, a = [], o = (t[1] - t[0]) / n;
      a.push({
        color: this.getControllerVisual(t[0], "color", i),
        offset: 0
      });
      for (var s = 1; s < n; s++) {
        var l = t[0] + o * s;
        if (l > t[1])
          break;
        a.push({
          color: this.getControllerVisual(l, "color", i),
          offset: s / n
        });
      }
      return a.push({
        color: this.getControllerVisual(t[1], "color", i),
        offset: 1
      }), a;
    }, e.prototype._createBarPoints = function(t, i) {
      var n = this.visualMapModel.itemSize;
      return [[n[0] - i[0], t[0]], [n[0], t[0]], [n[0], t[1]], [n[0] - i[1], t[1]]];
    }, e.prototype._createBarGroup = function(t) {
      var i = this._orient, n = this.visualMapModel.get("inverse");
      return new Re(i === "horizontal" && !n ? {
        scaleX: t === "bottom" ? 1 : -1,
        rotation: Math.PI / 2
      } : i === "horizontal" && n ? {
        scaleX: t === "bottom" ? -1 : 1,
        rotation: -Math.PI / 2
      } : i === "vertical" && !n ? {
        scaleX: t === "left" ? 1 : -1,
        scaleY: -1
      } : {
        scaleX: t === "left" ? 1 : -1
      });
    }, e.prototype._updateHandle = function(t, i) {
      if (this._useHandle) {
        var n = this._shapes, a = this.visualMapModel, o = n.handleThumbs, s = n.handleLabels, l = a.itemSize, u = a.getExtent();
        Y_e([0, 1], function(c) {
          var h = o[c];
          h.setStyle("fill", i.handlesColor[c]), h.y = t[c];
          var f = Wa(t[c], [0, l[1]], u, !0), d = this.getControllerVisual(f, "symbolSize");
          h.scaleX = h.scaleY = d / l[0], h.x = l[0] - d / 2;
          var p = Ia(n.handleLabelPoints[c], gc(h, this.group));
          s[c].setStyle({
            x: p[0],
            y: p[1],
            text: a.formatValueText(this._dataInterval[c]),
            verticalAlign: "middle",
            align: this._orient === "vertical" ? this._applyTransform("left", n.mainGroup) : "center"
          });
        }, this);
      }
    }, e.prototype._showIndicator = function(t, i, n, a) {
      var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, u = [0, l[1]], c = this._shapes, h = c.indicator;
      if (h) {
        h.attr("invisible", !1);
        var f = {
          convertOpacityToAlpha: !0
        }, d = this.getControllerVisual(t, "color", f), p = this.getControllerVisual(t, "symbolSize"), g = Wa(t, s, u, !0), v = l[0] - p / 2, O = {
          x: h.x,
          y: h.y
        };
        h.y = g, h.x = v;
        var m = Ia(c.indicatorLabelPoint, gc(h, this.group)), E = c.indicatorLabel;
        E.attr("invisible", !1);
        var b = this._applyTransform("left", c.mainGroup), S = this._orient, T = S === "horizontal";
        E.setStyle({
          text: (n || "") + o.formatValueText(i),
          verticalAlign: T ? b : "middle",
          align: T ? "center" : b
        });
        var y = {
          x: v,
          y: g,
          style: {
            fill: d
          }
        }, R = {
          style: {
            x: m[0],
            y: m[1]
          }
        };
        if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          var _ = {
            duration: 100,
            easing: "cubicInOut",
            additive: !0
          };
          h.x = O.x, h.y = O.y, h.animateTo(y, _), E.animateTo(R, _);
        } else
          h.attr(y), E.attr(R);
        this._firstShowIndicator = !1;
        var C = this._shapes.handleLabels;
        if (C)
          for (var I = 0; I < C.length; I++)
            this._api.enterBlur(C[I]);
      }
    }, e.prototype._enableHoverLinkToSeries = function() {
      var t = this;
      this._shapes.mainGroup.on("mousemove", function(i) {
        if (t._hovering = !0, !t._dragging) {
          var n = t.visualMapModel.itemSize, a = t._applyTransform([i.offsetX, i.offsetY], t._shapes.mainGroup, !0, !0);
          a[1] = Z$(aA(0, a[1]), n[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= n[0]);
        }
      }).on("mouseout", function() {
        t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries();
      });
    }, e.prototype._enableHoverLinkFromSeries = function() {
      var t = this.api.getZr();
      this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries();
    }, e.prototype._doHoverLinkToSeries = function(t, i) {
      var n = this.visualMapModel, a = n.itemSize;
      if (n.option.hoverLink) {
        var o = [0, a[1]], s = n.getExtent();
        t = Z$(aA(o[0], t), o[1]);
        var l = Z_e(n, s, o), u = [t - l, t + l], c = Wa(t, o, s, !0), h = [Wa(u[0], o, s, !0), Wa(u[1], o, s, !0)];
        u[0] < o[0] && (h[0] = -1 / 0), u[1] > o[1] && (h[1] = 1 / 0), i && (h[0] === -1 / 0 ? this._showIndicator(c, h[1], "< ", l) : h[1] === 1 / 0 ? this._showIndicator(c, h[0], "> ", l) : this._showIndicator(c, c, " ", l));
        var f = this._hoverLinkDataIndices, d = [];
        (i || j$(n)) && (d = this._hoverLinkDataIndices = n.findTargetDataIndices(h));
        var p = $ae(f, d);
        this._dispatchHighDown("downplay", lE(p[0], n)), this._dispatchHighDown("highlight", lE(p[1], n));
      }
    }, e.prototype._hoverLinkFromSeriesMouseOver = function(t) {
      var i;
      if (ju(t.target, function(l) {
        var u = Pe(l);
        if (u.dataIndex != null)
          return i = u, !0;
      }, !0), !!i) {
        var n = this.ecModel.getSeriesByIndex(i.seriesIndex), a = this.visualMapModel;
        if (a.isTargetSeries(n)) {
          var o = n.getData(i.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), i.dataIndex);
          isNaN(s) || this._showIndicator(s, s);
        }
      }
    }, e.prototype._hideIndicator = function() {
      var t = this._shapes;
      t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0);
      var i = this._shapes.handleLabels;
      if (i)
        for (var n = 0; n < i.length; n++)
          this._api.leaveBlur(i[n]);
    }, e.prototype._clearHoverLinkToSeries = function() {
      this._hideIndicator();
      var t = this._hoverLinkDataIndices;
      this._dispatchHighDown("downplay", lE(t, this.visualMapModel)), t.length = 0;
    }, e.prototype._clearHoverLinkFromSeries = function() {
      this._hideIndicator();
      var t = this.api.getZr();
      t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator);
    }, e.prototype._applyTransform = function(t, i, n, a) {
      var o = gc(i, a ? null : this.group);
      return X(t) ? Ia(t, o, n) : ST(t, o, n);
    }, e.prototype._dispatchHighDown = function(t, i) {
      i && i.length && this.api.dispatchAction({
        type: t,
        batch: i
      });
    }, e.prototype.dispose = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.prototype.remove = function() {
      this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries();
    }, e.type = "visualMap.continuous", e;
  }(jZ)
);
function q$(r, e, t, i) {
  return new rn({
    shape: {
      points: r
    },
    draggable: !!t,
    cursor: e,
    drift: t,
    onmousemove: function(n) {
      os(n.event);
    },
    ondragend: i
  });
}
function Z_e(r, e, t) {
  var i = H_e / 2, n = r.get("hoverLinkDataSize");
  return n && (i = Wa(n, e, t, !0) / 2), i;
}
function j$(r) {
  var e = r.get("hoverLinkOnHandle");
  return !!(e ?? r.get("realtime"));
}
function K$(r) {
  return r === "vertical" ? "ns-resize" : "ew-resize";
}
const q_e = z_e;
var j_e = {
  type: "selectDataRange",
  event: "dataRangeSelected",
  // FIXME use updateView appears wrong
  update: "update"
}, K_e = function(r, e) {
  e.eachComponent({
    mainType: "visualMap",
    query: r
  }, function(t) {
    t.setSelected(r.selected);
  });
}, J_e = [
  {
    createOnAllSeries: !0,
    reset: function(r, e) {
      var t = [];
      return e.eachComponent("visualMap", function(i) {
        var n = r.pipelineContext;
        !i.isTargetSeries(r) || n && n.large || t.push(WRe(i.stateList, i.targetVisuals, ue(i.getValueState, i), i.getDataDimensionIndex(r.getData())));
      }), t;
    }
  },
  // Only support color.
  {
    createOnAllSeries: !0,
    reset: function(r, e) {
      var t = r.getData(), i = [];
      e.eachComponent("visualMap", function(n) {
        if (n.isTargetSeries(r)) {
          var a = n.getVisualMeta(ue(eCe, null, r, n)) || {
            stops: [],
            outerColors: []
          }, o = n.getDataDimensionIndex(t);
          o >= 0 && (a.dimension = o, i.push(a));
        }
      }), r.getData().setVisual("visualMeta", i);
    }
  }
];
function eCe(r, e, t, i) {
  for (var n = e.targetVisuals[i], a = Jr.prepareVisualTypes(n), o = {
    color: Nv(r.getData(), "color")
    // default color.
  }, s = 0, l = a.length; s < l; s++) {
    var u = a[s], c = n[u === "opacity" ? "__alphaForOpacity" : u];
    c && c.applyVisual(t, h, f);
  }
  return o.color;
  function h(d) {
    return o[d];
  }
  function f(d, p) {
    o[d] = p;
  }
}
var J$ = N;
function tCe(r) {
  var e = r && r.visualMap;
  X(e) || (e = e ? [e] : []), J$(e, function(t) {
    if (t) {
      wh(t, "splitList") && !wh(t, "pieces") && (t.pieces = t.splitList, delete t.splitList);
      var i = t.pieces;
      i && X(i) && J$(i, function(n) {
        be(n) && (wh(n, "start") && !wh(n, "min") && (n.min = n.start), wh(n, "end") && !wh(n, "max") && (n.max = n.end));
      });
    }
  });
}
function wh(r, e) {
  return r && r.hasOwnProperty && r.hasOwnProperty(e);
}
var eV = !1;
function JZ(r) {
  eV || (eV = !0, r.registerSubTypeDefaulter("visualMap", function(e) {
    return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise";
  }), r.registerAction(j_e, K_e), N(J_e, function(e) {
    r.registerVisual(r.PRIORITY.VISUAL.COMPONENT, e);
  }), r.registerPreprocessor(tCe));
}
function e7(r) {
  r.registerComponentModel(F_e), r.registerComponentView(q_e), JZ(r);
}
var rCe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t._pieceList = [], t;
    }
    return e.prototype.optionUpdated = function(t, i) {
      r.prototype.optionUpdated.apply(this, arguments), this.resetExtent();
      var n = this._mode = this._determineMode();
      this._pieceList = [], iCe[this._mode].call(this, this._pieceList), this._resetSelected(t, i);
      var a = this.option.categories;
      this.resetVisual(function(o, s) {
        n === "categories" ? (o.mappingMethod = "category", o.categories = ye(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = Y(this._pieceList, function(l) {
          return l = ye(l), s !== "inRange" && (l.visual = null), l;
        }));
      });
    }, e.prototype.completeVisualOption = function() {
      var t = this.option, i = {}, n = Jr.listVisualTypes(), a = this.isCategory();
      N(t.pieces, function(s) {
        N(n, function(l) {
          s.hasOwnProperty(l) && (i[l] = 1);
        });
      }), N(i, function(s, l) {
        var u = !1;
        N(this.stateList, function(c) {
          u = u || o(t, c, l) || o(t.target, c, l);
        }, this), !u && N(this.stateList, function(c) {
          (t[c] || (t[c] = {}))[l] = qZ.get(l, c === "inRange" ? "active" : "inactive", a);
        });
      }, this);
      function o(s, l, u) {
        return s && s[l] && s[l].hasOwnProperty(u);
      }
      r.prototype.completeVisualOption.apply(this, arguments);
    }, e.prototype._resetSelected = function(t, i) {
      var n = this.option, a = this._pieceList, o = (i ? n : t).selected || {};
      if (n.selected = o, N(a, function(l, u) {
        var c = this.getSelectedMapKey(l);
        o.hasOwnProperty(c) || (o[c] = !0);
      }, this), n.selectedMode === "single") {
        var s = !1;
        N(a, function(l, u) {
          var c = this.getSelectedMapKey(l);
          o[c] && (s ? o[c] = !1 : s = !0);
        }, this);
      }
    }, e.prototype.getItemSymbol = function() {
      return this.get("itemSymbol");
    }, e.prototype.getSelectedMapKey = function(t) {
      return this._mode === "categories" ? t.value + "" : t.index + "";
    }, e.prototype.getPieceList = function() {
      return this._pieceList;
    }, e.prototype._determineMode = function() {
      var t = this.option;
      return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber";
    }, e.prototype.setSelected = function(t) {
      this.option.selected = ye(t);
    }, e.prototype.getValueState = function(t) {
      var i = Jr.findPieceIndex(t, this._pieceList);
      return i != null && this.option.selected[this.getSelectedMapKey(this._pieceList[i])] ? "inRange" : "outOfRange";
    }, e.prototype.findTargetDataIndices = function(t) {
      var i = [], n = this._pieceList;
      return this.eachTargetSeries(function(a) {
        var o = [], s = a.getData();
        s.each(this.getDataDimensionIndex(s), function(l, u) {
          var c = Jr.findPieceIndex(l, n);
          c === t && o.push(u);
        }, this), i.push({
          seriesId: a.id,
          dataIndex: o
        });
      }, this), i;
    }, e.prototype.getRepresentValue = function(t) {
      var i;
      if (this.isCategory())
        i = t.value;
      else if (t.value != null)
        i = t.value;
      else {
        var n = t.interval || [];
        i = n[0] === -1 / 0 && n[1] === 1 / 0 ? 0 : (n[0] + n[1]) / 2;
      }
      return i;
    }, e.prototype.getVisualMeta = function(t) {
      if (this.isCategory())
        return;
      var i = [], n = ["", ""], a = this;
      function o(c, h) {
        var f = a.getRepresentValue({
          interval: c
        });
        h || (h = a.getValueState(f));
        var d = t(f, h);
        c[0] === -1 / 0 ? n[0] = d : c[1] === 1 / 0 ? n[1] = d : i.push({
          value: c[0],
          color: d
        }, {
          value: c[1],
          color: d
        });
      }
      var s = this._pieceList.slice();
      if (!s.length)
        s.push({
          interval: [-1 / 0, 1 / 0]
        });
      else {
        var l = s[0].interval[0];
        l !== -1 / 0 && s.unshift({
          interval: [-1 / 0, l]
        }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({
          interval: [l, 1 / 0]
        });
      }
      var u = -1 / 0;
      return N(s, function(c) {
        var h = c.interval;
        h && (h[0] > u && o([u, h[0]], "outOfRange"), o(h.slice()), u = h[1]);
      }, this), {
        stops: i,
        outerColors: n
      };
    }, e.type = "visualMap.piecewise", e.defaultOption = Zl(Yb.defaultOption, {
      selected: null,
      minOpen: !1,
      maxOpen: !1,
      align: "auto",
      itemWidth: 20,
      itemHeight: 14,
      itemSymbol: "roundRect",
      pieces: null,
      categories: null,
      splitNumber: 5,
      selectedMode: "multiple",
      itemGap: 10,
      hoverLink: !0
      // Enable hover highlight.
    }), e;
  }(Yb)
), iCe = {
  splitNumber: function(r) {
    var e = this.option, t = Math.min(e.precision, 20), i = this.getExtent(), n = e.splitNumber;
    n = Math.max(parseInt(n, 10), 1), e.splitNumber = n;
    for (var a = (i[1] - i[0]) / n; +a.toFixed(t) !== a && t < 5; )
      t++;
    e.precision = t, a = +a.toFixed(t), e.minOpen && r.push({
      interval: [-1 / 0, i[0]],
      close: [0, 0]
    });
    for (var o = 0, s = i[0]; o < n; s += a, o++) {
      var l = o === n - 1 ? i[1] : s + a;
      r.push({
        interval: [s, l],
        close: [1, 1]
      });
    }
    e.maxOpen && r.push({
      interval: [i[1], 1 / 0],
      close: [0, 0]
    }), GD(r), N(r, function(u, c) {
      u.index = c, u.text = this.formatValueText(u.interval);
    }, this);
  },
  categories: function(r) {
    var e = this.option;
    N(e.categories, function(t) {
      r.push({
        text: this.formatValueText(t, !0),
        value: t
      });
    }, this), tV(e, r);
  },
  pieces: function(r) {
    var e = this.option;
    N(e.pieces, function(t, i) {
      be(t) || (t = {
        value: t
      });
      var n = {
        text: "",
        index: i
      };
      if (t.label != null && (n.text = t.label), t.hasOwnProperty("value")) {
        var a = n.value = t.value;
        n.interval = [a, a], n.close = [1, 1];
      } else {
        for (var o = n.interval = [], s = n.close = [0, 0], l = [1, 0, 1], u = [-1 / 0, 1 / 0], c = [], h = 0; h < 2; h++) {
          for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][h], d = 0; d < 3 && o[h] == null; d++)
            o[h] = t[f[d]], s[h] = l[d], c[h] = d === 2;
          o[h] == null && (o[h] = u[h]);
        }
        c[0] && o[1] === 1 / 0 && (s[0] = 0), c[1] && o[0] === -1 / 0 && (s[1] = 0), {}.NODE_ENV !== "production" && o[0] > o[1] && console.warn("Piece " + i + "is illegal: " + o + " lower bound should not greater then uppper bound."), o[0] === o[1] && s[0] && s[1] && (n.value = o[0]);
      }
      n.visual = Jr.retrieveVisuals(t), r.push(n);
    }, this), tV(e, r), GD(r), N(r, function(t) {
      var i = t.close, n = [["<", ""][i[1]], [">", ""][i[0]]];
      t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, n);
    }, this);
  }
};
function tV(r, e) {
  var t = r.inverse;
  (r.orient === "vertical" ? !t : t) && e.reverse();
}
const nCe = rCe;
var aCe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = e.type, t;
    }
    return e.prototype.doRender = function() {
      var t = this.group;
      t.removeAll();
      var i = this.visualMapModel, n = i.get("textGap"), a = i.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), u = i.itemSize, c = this._getViewData(), h = c.endsText, f = vr(i.get("showLabel", !0), !h);
      h && this._renderEndsText(t, h[0], u, f, l), N(c.viewPieceList, function(d) {
        var p = d.piece, g = new Re();
        g.onclick = ue(this._onItemClick, this, p), this._enableHoverLink(g, d.indexInModelPieceList);
        var v = i.getRepresentValue(p);
        if (this._createItemSymbol(g, v, [0, 0, u[0], u[1]]), f) {
          var O = this.visualMapModel.getValueState(v);
          g.add(new dt({
            style: {
              x: l === "right" ? -n : u[0] + n,
              y: u[1] / 2,
              text: p.text,
              verticalAlign: "middle",
              align: l,
              font: o,
              fill: s,
              opacity: O === "outOfRange" ? 0.5 : 1
            }
          }));
        }
        t.add(g);
      }, this), h && this._renderEndsText(t, h[1], u, f, l), vc(i.get("orient"), t, i.get("itemGap")), this.renderBackground(t), this.positionGroup(t);
    }, e.prototype._enableHoverLink = function(t, i) {
      var n = this;
      t.on("mouseover", function() {
        return a("highlight");
      }).on("mouseout", function() {
        return a("downplay");
      });
      var a = function(o) {
        var s = n.visualMapModel;
        s.option.hoverLink && n.api.dispatchAction({
          type: o,
          batch: lE(s.findTargetDataIndices(i), s)
        });
      };
    }, e.prototype._getItemAlign = function() {
      var t = this.visualMapModel, i = t.option;
      if (i.orient === "vertical")
        return KZ(t, this.api, t.itemSize);
      var n = i.align;
      return (!n || n === "auto") && (n = "left"), n;
    }, e.prototype._renderEndsText = function(t, i, n, a, o) {
      if (i) {
        var s = new Re(), l = this.visualMapModel.textStyleModel;
        s.add(new dt({
          style: Qt(l, {
            x: a ? o === "right" ? n[0] : 0 : n[0] / 2,
            y: n[1] / 2,
            verticalAlign: "middle",
            align: a ? o : "center",
            text: i
          })
        })), t.add(s);
      }
    }, e.prototype._getViewData = function() {
      var t = this.visualMapModel, i = Y(t.getPieceList(), function(s, l) {
        return {
          piece: s,
          indexInModelPieceList: l
        };
      }), n = t.get("text"), a = t.get("orient"), o = t.get("inverse");
      return (a === "horizontal" ? o : !o) ? i.reverse() : n && (n = n.slice().reverse()), {
        viewPieceList: i,
        endsText: n
      };
    }, e.prototype._createItemSymbol = function(t, i, n) {
      t.add(Er(
        // symbol will be string
        this.getControllerVisual(i, "symbol"),
        n[0],
        n[1],
        n[2],
        n[3],
        // color will be string
        this.getControllerVisual(i, "color")
      ));
    }, e.prototype._onItemClick = function(t) {
      var i = this.visualMapModel, n = i.option, a = n.selectedMode;
      if (a) {
        var o = ye(n.selected), s = i.getSelectedMapKey(t);
        a === "single" || a === !0 ? (o[s] = !0, N(o, function(l, u) {
          o[u] = u === s;
        })) : o[s] = !o[s], this.api.dispatchAction({
          type: "selectDataRange",
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: o
        });
      }
    }, e.type = "visualMap.piecewise", e;
  }(jZ)
);
const oCe = aCe;
function t7(r) {
  r.registerComponentModel(nCe), r.registerComponentView(oCe), JZ(r);
}
function sCe(r) {
  Ye(e7), Ye(t7);
}
var lCe = {
  label: {
    enabled: !0
  },
  decal: {
    show: !1
  }
}, rV = ft(), uCe = {};
function cCe(r, e) {
  var t = r.getModel("aria");
  if (!t.get("enabled"))
    return;
  var i = ye(lCe);
  $e(i.label, r.getLocaleModel().get("aria"), !1), $e(t.option, i, !1), n(), a();
  function n() {
    var u = t.getModel("decal"), c = u.get("show");
    if (c) {
      var h = de();
      r.eachSeries(function(f) {
        if (!f.isColorBySeries()) {
          var d = h.get(f.type);
          d || (d = {}, h.set(f.type, d)), rV(f).scope = d;
        }
      }), r.eachRawSeries(function(f) {
        if (r.isSeriesFiltered(f))
          return;
        if (ve(f.enableAriaDecal)) {
          f.enableAriaDecal();
          return;
        }
        var d = f.getData();
        if (f.isColorBySeries()) {
          var m = fC(f.ecModel, f.name, uCe, r.getSeriesCount()), E = d.getVisual("decal");
          d.setVisual("decal", b(E, m));
        } else {
          var p = f.getRawData(), g = {}, v = rV(f).scope;
          d.each(function(S) {
            var T = d.getRawIndex(S);
            g[T] = S;
          });
          var O = p.count();
          p.each(function(S) {
            var T = g[S], y = p.getName(S) || S + "", R = fC(f.ecModel, y, v, O), _ = d.getItemVisual(T, "decal");
            d.setItemVisual(T, "decal", b(_, R));
          });
        }
        function b(S, T) {
          var y = S ? B(B({}, T), S) : T;
          return y.dirty = !0, y;
        }
      });
    }
  }
  function a() {
    var u = r.getLocaleModel().get("aria"), c = t.getModel("label");
    if (c.option = Te(c.option, u), !!c.get("enabled")) {
      var h = e.getZr().dom;
      if (c.get("description")) {
        h.setAttribute("aria-label", c.get("description"));
        return;
      }
      var f = r.getSeriesCount(), d = c.get(["data", "maxCount"]) || 10, p = c.get(["series", "maxCount"]) || 10, g = Math.min(f, p), v;
      if (!(f < 1)) {
        var O = s();
        if (O) {
          var m = c.get(["general", "withTitle"]);
          v = o(m, {
            title: O
          });
        } else
          v = c.get(["general", "withoutTitle"]);
        var E = [], b = f > 1 ? c.get(["series", "multiple", "prefix"]) : c.get(["series", "single", "prefix"]);
        v += o(b, {
          seriesCount: f
        }), r.eachSeries(function(R, _) {
          if (_ < g) {
            var C = void 0, I = R.get("name"), w = I ? "withName" : "withoutName";
            C = f > 1 ? c.get(["series", "multiple", w]) : c.get(["series", "single", w]), C = o(C, {
              seriesId: R.seriesIndex,
              seriesName: R.get("name"),
              seriesType: l(R.subType)
            });
            var x = R.getData();
            if (x.count() > d) {
              var P = c.get(["data", "partialData"]);
              C += o(P, {
                displayCnt: d
              });
            } else
              C += c.get(["data", "allData"]);
            for (var L = c.get(["data", "separator", "middle"]), D = c.get(["data", "separator", "end"]), U = [], Q = 0; Q < x.count(); Q++)
              if (Q < d) {
                var V = x.getName(Q), F = x.getValues(Q), j = c.get(["data", V ? "withName" : "withoutName"]);
                U.push(o(j, {
                  name: V,
                  value: F.join(L)
                }));
              }
            C += U.join(L) + D, E.push(C);
          }
        });
        var S = c.getModel(["series", "multiple", "separator"]), T = S.get("middle"), y = S.get("end");
        v += E.join(T) + y, h.setAttribute("aria-label", v);
      }
    }
  }
  function o(u, c) {
    if (!ne(u))
      return u;
    var h = u;
    return N(c, function(f, d) {
      h = h.replace(new RegExp("\\{\\s*" + d + "\\s*\\}", "g"), f);
    }), h;
  }
  function s() {
    var u = r.get("title");
    return u && u.length && (u = u[0]), u && u.text;
  }
  function l(u) {
    return r.getLocaleModel().get(["series", "typeNames"])[u] || "";
  }
}
function hCe(r) {
  if (!(!r || !r.aria)) {
    var e = r.aria;
    e.show != null && (e.enabled = e.show), e.label = e.label || {}, N(["description", "general", "series", "data"], function(t) {
      e[t] != null && (e.label[t] = e[t]);
    });
  }
}
function fCe(r) {
  r.registerPreprocessor(hCe), r.registerVisual(r.PRIORITY.VISUAL.ARIA, cCe);
}
var iV = {
  value: "eq",
  // PENDING: not good for literal semantic?
  "<": "lt",
  "<=": "lte",
  ">": "gt",
  ">=": "gte",
  "=": "eq",
  "!=": "ne",
  "<>": "ne"
  // Might be misleading for sake of the difference between '==' and '===',
  // so don't support them.
  // '==': 'eq',
  // '===': 'seq',
  // '!==': 'sne'
  // PENDING: Whether support some common alias "ge", "le", "neq"?
  // ge: 'gte',
  // le: 'lte',
  // neq: 'ne',
}, dCe = (
  /** @class */
  function() {
    function r(e) {
      var t = this._condVal = ne(e) ? new RegExp(e) : uY(e) ? e : null;
      if (t == null) {
        var i = "";
        ({}).NODE_ENV !== "production" && (i = Ui("Illegal regexp", e, "in")), St(i);
      }
    }
    return r.prototype.evaluate = function(e) {
      var t = typeof e;
      return ne(t) ? this._condVal.test(e) : pt(t) ? this._condVal.test(e + "") : !1;
    }, r;
  }()
), pCe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return this.value;
    }, r;
  }()
), gCe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (!e[t].evaluate())
          return !1;
      return !0;
    }, r;
  }()
), vCe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = this.children, t = 0; t < e.length; t++)
        if (e[t].evaluate())
          return !0;
      return !1;
    }, r;
  }()
), OCe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      return !this.child.evaluate();
    }, r;
  }()
), mCe = (
  /** @class */
  function() {
    function r() {
    }
    return r.prototype.evaluate = function() {
      for (var e = !!this.valueParser, t = this.getValue, i = t(this.valueGetterParam), n = e ? this.valueParser(i) : null, a = 0; a < this.subCondList.length; a++)
        if (!this.subCondList[a].evaluate(e ? n : i))
          return !1;
      return !0;
    }, r;
  }()
);
function Ix(r, e) {
  if (r === !0 || r === !1) {
    var t = new pCe();
    return t.value = r, t;
  }
  var i = "";
  return r7(r) || ({}.NODE_ENV !== "production" && (i = Ui("Illegal config. Expect a plain object but actually", r)), St(i)), r.and ? nV("and", r, e) : r.or ? nV("or", r, e) : r.not ? ECe(r, e) : bCe(r, e);
}
function nV(r, e, t) {
  var i = e[r], n = "";
  ({}).NODE_ENV !== "production" && (n = Ui('"and"/"or" condition should only be `' + r + ": [...]` and must not be empty array.", "Illegal condition:", e)), X(i) || St(n), i.length || St(n);
  var a = r === "and" ? new gCe() : new vCe();
  return a.children = Y(i, function(o) {
    return Ix(o, t);
  }), a.children.length || St(n), a;
}
function ECe(r, e) {
  var t = r.not, i = "";
  ({}).NODE_ENV !== "production" && (i = Ui('"not" condition should only be `not: {}`.', "Illegal condition:", r)), r7(t) || St(i);
  var n = new OCe();
  return n.child = Ix(t, e), n.child || St(i), n;
}
function bCe(r, e) {
  for (var t = "", i = e.prepareGetValue(r), n = [], a = Ze(r), o = r.parser, s = o ? LW(o) : null, l = 0; l < a.length; l++) {
    var u = a[l];
    if (!(u === "parser" || e.valueGetterAttrMap.get(u))) {
      var c = le(iV, u) ? iV[u] : u, h = r[u], f = s ? s(h) : h, d = rue(c, f) || c === "reg" && new dCe(f);
      d || ({}.NODE_ENV !== "production" && (t = Ui('Illegal relational operation: "' + u + '" in condition:', r)), St(t)), n.push(d);
    }
  }
  n.length || ({}.NODE_ENV !== "production" && (t = Ui("Relational condition must have at least one operator.", "Illegal condition:", r)), St(t));
  var p = new mCe();
  return p.valueGetterParam = i, p.valueParser = s, p.getValue = e.getValue, p.subCondList = n, p;
}
function r7(r) {
  return be(r) && !mi(r);
}
var SCe = (
  /** @class */
  function() {
    function r(e, t) {
      this._cond = Ix(e, t);
    }
    return r.prototype.evaluate = function() {
      return this._cond.evaluate();
    }, r;
  }()
);
function TCe(r, e) {
  return new SCe(r, e);
}
var yCe = {
  type: "echarts:filter",
  // PENDING: enhance to filter by index rather than create new data
  transform: function(r) {
    for (var e = r.upstream, t, i = TCe(r.config, {
      valueGetterAttrMap: de({
        dimension: !0
      }),
      prepareGetValue: function(s) {
        var l = "", u = s.dimension;
        le(s, "dimension") || ({}.NODE_ENV !== "production" && (l = Ui('Relation condition must has prop "dimension" specified.', "Illegal condition:", s)), St(l));
        var c = e.getDimensionInfo(u);
        return c || ({}.NODE_ENV !== "production" && (l = Ui("Can not find dimension info via: " + u + `.
`, "Existing dimensions: ", e.cloneAllDimensionInfo(), `.
`, "Illegal condition:", s, `.
`)), St(l)), {
          dimIdx: c.index
        };
      },
      getValue: function(s) {
        return e.retrieveValueFromItem(t, s.dimIdx);
      }
    }), n = [], a = 0, o = e.count(); a < o; a++)
      t = e.getRawDataItem(a), i.evaluate() && n.push(t);
    return {
      data: n
    };
  }
}, cI = "";
({}).NODE_ENV !== "production" && (cI = ["Valid config is like:", '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(" "));
var RCe = {
  type: "echarts:sort",
  transform: function(r) {
    var e = r.upstream, t = r.config, i = "", n = It(t);
    n.length || ({}.NODE_ENV !== "production" && (i = "Empty `config` in sort transform."), St(i));
    var a = [];
    N(n, function(c) {
      var h = c.dimension, f = c.order, d = c.parser, p = c.incomparable;
      if (h == null && ({}.NODE_ENV !== "production" && (i = 'Sort transform config must has "dimension" specified.' + cI), St(i)), f !== "asc" && f !== "desc" && ({}.NODE_ENV !== "production" && (i = 'Sort transform config must has "order" specified.' + cI), St(i)), p && p !== "min" && p !== "max") {
        var g = "";
        ({}).NODE_ENV !== "production" && (g = 'incomparable must be "min" or "max" rather than "' + p + '".'), St(g);
      }
      if (f !== "asc" && f !== "desc") {
        var v = "";
        ({}).NODE_ENV !== "production" && (v = 'order must be "asc" or "desc" rather than "' + f + '".'), St(v);
      }
      var O = e.getDimensionInfo(h);
      O || ({}.NODE_ENV !== "production" && (i = Ui("Can not find dimension info via: " + h + `.
`, "Existing dimensions: ", e.cloneAllDimensionInfo(), `.
`, "Illegal config:", c, `.
`)), St(i));
      var m = d ? LW(d) : null;
      d && !m && ({}.NODE_ENV !== "production" && (i = Ui("Invalid parser name " + d + `.
`, "Illegal config:", c, `.
`)), St(i)), a.push({
        dimIdx: O.index,
        parser: m,
        comparator: new MW(f, p)
      });
    });
    var o = e.sourceFormat;
    o !== Ei && o !== la && ({}.NODE_ENV !== "production" && (i = 'sourceFormat "' + o + '" is not supported yet'), St(i));
    for (var s = [], l = 0, u = e.count(); l < u; l++)
      s.push(e.getRawDataItem(l));
    return s.sort(function(c, h) {
      for (var f = 0; f < a.length; f++) {
        var d = a[f], p = e.retrieveValueFromItem(c, d.dimIdx), g = e.retrieveValueFromItem(h, d.dimIdx);
        d.parser && (p = d.parser(p), g = d.parser(g));
        var v = d.comparator.evaluate(p, g);
        if (v !== 0)
          return v;
      }
      return 0;
    }), {
      data: s
    };
  }
};
function ACe(r) {
  r.registerTransform(yCe), r.registerTransform(RCe);
}
var _Ce = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.prototype.init = function(t, i, n) {
      r.prototype.init.call(this, t, i, n), this._sourceManager = new $W(this), nk(this);
    }, e.prototype.mergeOption = function(t, i) {
      r.prototype.mergeOption.call(this, t, i), nk(this);
    }, e.prototype.optionUpdated = function() {
      this._sourceManager.dirty();
    }, e.prototype.getSourceManager = function() {
      return this._sourceManager;
    }, e.type = "dataset", e.defaultOption = {
      seriesLayoutBy: vo
    }, e;
  }(st)
), CCe = (
  /** @class */
  function(r) {
    $(e, r);
    function e() {
      var t = r !== null && r.apply(this, arguments) || this;
      return t.type = "dataset", t;
    }
    return e.type = "dataset", e;
  }(jt)
);
function ICe(r) {
  r.registerComponentModel(_Ce), r.registerComponentView(CCe);
}
var Ga = _o.CMD;
function Zh(r, e) {
  return Math.abs(r - e) < 1e-5;
}
function hI(r) {
  var e = r.data, t = r.len(), i = [], n, a = 0, o = 0, s = 0, l = 0;
  function u(x, P) {
    n && n.length > 2 && i.push(n), n = [x, P];
  }
  function c(x, P, L, D) {
    Zh(x, L) && Zh(P, D) || n.push(x, P, L, D, L, D);
  }
  function h(x, P, L, D, U, Q) {
    var V = Math.abs(P - x), F = Math.tan(V / 4) * 4 / 3, j = P < x ? -1 : 1, ae = Math.cos(x), ce = Math.sin(x), ge = Math.cos(P), Be = Math.sin(P), We = ae * U + L, Ne = ce * Q + D, Ee = ge * U + L, Ge = Be * Q + D, Ie = U * F * j, he = Q * F * j;
    n.push(We - Ie * ce, Ne + he * ae, Ee + Ie * Be, Ge - he * ge, Ee, Ge);
  }
  for (var f, d, p, g, v = 0; v < t; ) {
    var O = e[v++], m = v === 1;
    switch (m && (a = e[v], o = e[v + 1], s = a, l = o, (O === Ga.L || O === Ga.C || O === Ga.Q) && (n = [s, l])), O) {
      case Ga.M:
        a = s = e[v++], o = l = e[v++], u(s, l);
        break;
      case Ga.L:
        f = e[v++], d = e[v++], c(a, o, f, d), a = f, o = d;
        break;
      case Ga.C:
        n.push(e[v++], e[v++], e[v++], e[v++], a = e[v++], o = e[v++]);
        break;
      case Ga.Q:
        f = e[v++], d = e[v++], p = e[v++], g = e[v++], n.push(a + 2 / 3 * (f - a), o + 2 / 3 * (d - o), p + 2 / 3 * (f - p), g + 2 / 3 * (d - g), p, g), a = p, o = g;
        break;
      case Ga.A:
        var E = e[v++], b = e[v++], S = e[v++], T = e[v++], y = e[v++], R = e[v++] + y;
        v += 1;
        var _ = !e[v++];
        f = Math.cos(y) * S + E, d = Math.sin(y) * T + b, m ? (s = f, l = d, u(s, l)) : c(a, o, f, d), a = Math.cos(R) * S + E, o = Math.sin(R) * T + b;
        for (var C = (_ ? -1 : 1) * Math.PI / 2, I = y; _ ? I > R : I < R; I += C) {
          var w = _ ? Math.max(I + C, R) : Math.min(I + C, R);
          h(I, w, E, b, S, T);
        }
        break;
      case Ga.R:
        s = a = e[v++], l = o = e[v++], f = s + e[v++], d = l + e[v++], u(f, l), c(f, l, f, d), c(f, d, s, d), c(s, d, s, l), c(s, l, f, l);
        break;
      case Ga.Z:
        n && c(a, o, s, l), a = s, o = l;
        break;
    }
  }
  return n && n.length > 2 && i.push(n), i;
}
function fI(r, e, t, i, n, a, o, s, l, u) {
  if (Zh(r, t) && Zh(e, i) && Zh(n, o) && Zh(a, s)) {
    l.push(o, s);
    return;
  }
  var c = 2 / u, h = c * c, f = o - r, d = s - e, p = Math.sqrt(f * f + d * d);
  f /= p, d /= p;
  var g = t - r, v = i - e, O = n - o, m = a - s, E = g * g + v * v, b = O * O + m * m;
  if (E < h && b < h) {
    l.push(o, s);
    return;
  }
  var S = f * g + d * v, T = -f * O - d * m, y = E - S * S, R = b - T * T;
  if (y < h && S >= 0 && R < h && T >= 0) {
    l.push(o, s);
    return;
  }
  var _ = [], C = [];
  wl(r, t, n, o, 0.5, _), wl(e, i, a, s, 0.5, C), fI(_[0], C[0], _[1], C[1], _[2], C[2], _[3], C[3], l, u), fI(_[4], C[4], _[5], C[5], _[6], C[6], _[7], C[7], l, u);
}
function wCe(r, e) {
  var t = hI(r), i = [];
  e = e || 1;
  for (var n = 0; n < t.length; n++) {
    var a = t[n], o = [], s = a[0], l = a[1];
    o.push(s, l);
    for (var u = 2; u < a.length; ) {
      var c = a[u++], h = a[u++], f = a[u++], d = a[u++], p = a[u++], g = a[u++];
      fI(s, l, c, h, f, d, p, g, o, e), s = p, l = g;
    }
    i.push(o);
  }
  return i;
}
function i7(r, e, t) {
  var i = r[e], n = r[1 - e], a = Math.abs(i / n), o = Math.ceil(Math.sqrt(a * t)), s = Math.floor(t / o);
  s === 0 && (s = 1, o = t);
  for (var l = [], u = 0; u < o; u++)
    l.push(s);
  var c = o * s, h = t - c;
  if (h > 0)
    for (var u = 0; u < h; u++)
      l[u % o] += 1;
  return l;
}
function aV(r, e, t) {
  for (var i = r.r0, n = r.r, a = r.startAngle, o = r.endAngle, s = Math.abs(o - a), l = s * n, u = n - i, c = l > Math.abs(u), h = i7([l, u], c ? 0 : 1, e), f = (c ? s : u) / h.length, d = 0; d < h.length; d++)
    for (var p = (c ? u : s) / h[d], g = 0; g < h[d]; g++) {
      var v = {};
      c ? (v.startAngle = a + f * d, v.endAngle = a + f * (d + 1), v.r0 = i + p * g, v.r = i + p * (g + 1)) : (v.startAngle = a + p * g, v.endAngle = a + p * (g + 1), v.r0 = i + f * d, v.r = i + f * (d + 1)), v.clockwise = r.clockwise, v.cx = r.cx, v.cy = r.cy, t.push(v);
    }
}
function NCe(r, e, t) {
  for (var i = r.width, n = r.height, a = i > n, o = i7([i, n], a ? 0 : 1, e), s = a ? "width" : "height", l = a ? "height" : "width", u = a ? "x" : "y", c = a ? "y" : "x", h = r[s] / o.length, f = 0; f < o.length; f++)
    for (var d = r[l] / o[f], p = 0; p < o[f]; p++) {
      var g = {};
      g[u] = f * h, g[c] = p * d, g[s] = h, g[l] = d, g.x += r.x, g.y += r.y, t.push(g);
    }
}
function oV(r, e, t, i) {
  return r * i - t * e;
}
function xCe(r, e, t, i, n, a, o, s) {
  var l = t - r, u = i - e, c = o - n, h = s - a, f = oV(c, h, l, u);
  if (Math.abs(f) < 1e-6)
    return null;
  var d = r - n, p = e - a, g = oV(d, p, c, h) / f;
  return g < 0 || g > 1 ? null : new Me(g * l + r, g * u + e);
}
function PCe(r, e, t) {
  var i = new Me();
  Me.sub(i, t, e), i.normalize();
  var n = new Me();
  Me.sub(n, r, e);
  var a = n.dot(i);
  return a;
}
function Nh(r, e) {
  var t = r[r.length - 1];
  t && t[0] === e[0] && t[1] === e[1] || r.push(e);
}
function LCe(r, e, t) {
  for (var i = r.length, n = [], a = 0; a < i; a++) {
    var o = r[a], s = r[(a + 1) % i], l = xCe(o[0], o[1], s[0], s[1], e.x, e.y, t.x, t.y);
    l && n.push({
      projPt: PCe(l, e, t),
      pt: l,
      idx: a
    });
  }
  if (n.length < 2)
    return [{ points: r }, { points: r }];
  n.sort(function(v, O) {
    return v.projPt - O.projPt;
  });
  var u = n[0], c = n[n.length - 1];
  if (c.idx < u.idx) {
    var h = u;
    u = c, c = h;
  }
  for (var f = [u.pt.x, u.pt.y], d = [c.pt.x, c.pt.y], p = [f], g = [d], a = u.idx + 1; a <= c.idx; a++)
    Nh(p, r[a].slice());
  Nh(p, d), Nh(p, f);
  for (var a = c.idx + 1; a <= u.idx + i; a++)
    Nh(g, r[a % i].slice());
  return Nh(g, f), Nh(g, d), [{
    points: p
  }, {
    points: g
  }];
}
function sV(r) {
  var e = r.points, t = [], i = [];
  gT(e, t, i);
  var n = new Ve(t[0], t[1], i[0] - t[0], i[1] - t[1]), a = n.width, o = n.height, s = n.x, l = n.y, u = new Me(), c = new Me();
  return a > o ? (u.x = c.x = s + a / 2, u.y = l, c.y = l + o) : (u.y = c.y = l + o / 2, u.x = s, c.x = s + a), LCe(e, u, c);
}
function Hb(r, e, t, i) {
  if (t === 1)
    i.push(e);
  else {
    var n = Math.floor(t / 2), a = r(e);
    Hb(r, a[0], n, i), Hb(r, a[1], t - n, i);
  }
  return i;
}
function DCe(r, e) {
  for (var t = [], i = 0; i < e; i++)
    t.push(H1(r));
  return t;
}
function MCe(r, e) {
  e.setStyle(r.style), e.z = r.z, e.z2 = r.z2, e.zlevel = r.zlevel;
}
function kCe(r) {
  for (var e = [], t = 0; t < r.length; )
    e.push([r[t++], r[t++]]);
  return e;
}
function QCe(r, e) {
  var t = [], i = r.shape, n;
  switch (r.type) {
    case "rect":
      NCe(i, e, t), n = ht;
      break;
    case "sector":
      aV(i, e, t), n = tn;
      break;
    case "circle":
      aV({
        r0: 0,
        r: i.r,
        startAngle: 0,
        endAngle: Math.PI * 2,
        cx: i.cx,
        cy: i.cy
      }, e, t), n = tn;
      break;
    default:
      var a = r.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = Y(wCe(r.getUpdatedPathProxy(), o), function(O) {
        return kCe(O);
      }), l = s.length;
      if (l === 0)
        Hb(sV, {
          points: s[0]
        }, e, t);
      else if (l === e)
        for (var u = 0; u < l; u++)
          t.push({
            points: s[u]
          });
      else {
        var c = 0, h = Y(s, function(O) {
          var m = [], E = [];
          gT(O, m, E);
          var b = (E[1] - m[1]) * (E[0] - m[0]);
          return c += b, { poly: O, area: b };
        });
        h.sort(function(O, m) {
          return m.area - O.area;
        });
        for (var f = e, u = 0; u < l; u++) {
          var d = h[u];
          if (f <= 0)
            break;
          var p = u === l - 1 ? f : Math.ceil(d.area / c * e);
          p < 0 || (Hb(sV, {
            points: d.poly
          }, p, t), f -= p);
        }
      }
      n = rn;
      break;
  }
  if (!n)
    return DCe(r, e);
  for (var g = [], u = 0; u < t.length; u++) {
    var v = new n();
    v.setShape(t[u]), MCe(r, v), g.push(v);
  }
  return g;
}
function UCe(r, e) {
  var t = r.length, i = e.length;
  if (t === i)
    return [r, e];
  for (var n = [], a = [], o = t < i ? r : e, s = Math.min(t, i), l = Math.abs(i - t) / 6, u = (s - 2) / 6, c = Math.ceil(l / u) + 1, h = [o[0], o[1]], f = l, d = 2; d < s; ) {
    var p = o[d - 2], g = o[d - 1], v = o[d++], O = o[d++], m = o[d++], E = o[d++], b = o[d++], S = o[d++];
    if (f <= 0) {
      h.push(v, O, m, E, b, S);
      continue;
    }
    for (var T = Math.min(f, c - 1) + 1, y = 1; y <= T; y++) {
      var R = y / T;
      wl(p, v, m, b, R, n), wl(g, O, E, S, R, a), p = n[3], g = a[3], h.push(n[1], a[1], n[2], a[2], p, g), v = n[5], O = a[5], m = n[6], E = a[6];
    }
    f -= T - 1;
  }
  return o === r ? [h, e] : [r, h];
}
function lV(r, e) {
  for (var t = r.length, i = r[t - 2], n = r[t - 1], a = [], o = 0; o < e.length; )
    a[o++] = i, a[o++] = n;
  return a;
}
function $Ce(r, e) {
  for (var t, i, n, a = [], o = [], s = 0; s < Math.max(r.length, e.length); s++) {
    var l = r[s], u = e[s], c = void 0, h = void 0;
    l ? u ? (t = UCe(l, u), c = t[0], h = t[1], i = c, n = h) : (h = lV(n || l, l), c = l) : (c = lV(i || u, u), h = u), a.push(c), o.push(h);
  }
  return [a, o];
}
function uV(r) {
  for (var e = 0, t = 0, i = 0, n = r.length, a = 0, o = n - 2; a < n; o = a, a += 2) {
    var s = r[o], l = r[o + 1], u = r[a], c = r[a + 1], h = s * c - u * l;
    e += h, t += (s + u) * h, i += (l + c) * h;
  }
  return e === 0 ? [r[0] || 0, r[1] || 0] : [t / e / 3, i / e / 3, e];
}
function VCe(r, e, t, i) {
  for (var n = (r.length - 2) / 6, a = 1 / 0, o = 0, s = r.length, l = s - 2, u = 0; u < n; u++) {
    for (var c = u * 6, h = 0, f = 0; f < s; f += 2) {
      var d = f === 0 ? c : (c + f - 2) % l + 2, p = r[d] - t[0], g = r[d + 1] - t[1], v = e[f] - i[0], O = e[f + 1] - i[1], m = v - p, E = O - g;
      h += m * m + E * E;
    }
    h < a && (a = h, o = u);
  }
  return o;
}
function GCe(r) {
  for (var e = [], t = r.length, i = 0; i < t; i += 2)
    e[i] = r[t - i - 2], e[i + 1] = r[t - i - 1];
  return e;
}
function BCe(r, e, t, i) {
  for (var n = [], a, o = 0; o < r.length; o++) {
    var s = r[o], l = e[o], u = uV(s), c = uV(l);
    a == null && (a = u[2] < 0 != c[2] < 0);
    var h = [], f = [], d = 0, p = 1 / 0, g = [], v = s.length;
    a && (s = GCe(s));
    for (var O = VCe(s, l, u, c) * 6, m = v - 2, E = 0; E < m; E += 2) {
      var b = (O + E) % m + 2;
      h[E + 2] = s[b] - u[0], h[E + 3] = s[b + 1] - u[1];
    }
    if (h[0] = s[O] - u[0], h[1] = s[O + 1] - u[1], t > 0)
      for (var S = i / t, T = -i / 2; T <= i / 2; T += S) {
        for (var y = Math.sin(T), R = Math.cos(T), _ = 0, E = 0; E < s.length; E += 2) {
          var C = h[E], I = h[E + 1], w = l[E] - c[0], x = l[E + 1] - c[1], P = w * R - x * y, L = w * y + x * R;
          g[E] = P, g[E + 1] = L;
          var D = P - C, U = L - I;
          _ += D * D + U * U;
        }
        if (_ < p) {
          p = _, d = T;
          for (var Q = 0; Q < g.length; Q++)
            f[Q] = g[Q];
        }
      }
    else
      for (var V = 0; V < v; V += 2)
        f[V] = l[V] - c[0], f[V + 1] = l[V + 1] - c[1];
    n.push({
      from: h,
      to: f,
      fromCp: u,
      toCp: c,
      rotation: -d
    });
  }
  return n;
}
function Wb(r) {
  return r.__isCombineMorphing;
}
var n7 = "__mOriginal_";
function zb(r, e, t) {
  var i = n7 + e, n = r[i] || r[e];
  r[i] || (r[i] = r[e]);
  var a = t.replace, o = t.after, s = t.before;
  r[e] = function() {
    var l = arguments, u;
    return s && s.apply(this, l), a ? u = a.apply(this, l) : u = n.apply(this, l), o && o.apply(this, l), u;
  };
}
function rg(r, e) {
  var t = n7 + e;
  r[t] && (r[e] = r[t], r[t] = null);
}
function cV(r, e) {
  for (var t = 0; t < r.length; t++)
    for (var i = r[t], n = 0; n < i.length; ) {
      var a = i[n], o = i[n + 1];
      i[n++] = e[0] * a + e[2] * o + e[4], i[n++] = e[1] * a + e[3] * o + e[5];
    }
}
function a7(r, e) {
  var t = r.getUpdatedPathProxy(), i = e.getUpdatedPathProxy(), n = $Ce(hI(t), hI(i)), a = n[0], o = n[1], s = r.getComputedTransform(), l = e.getComputedTransform();
  function u() {
    this.transform = null;
  }
  s && cV(a, s), l && cV(o, l), zb(e, "updateTransform", { replace: u }), e.transform = null;
  var c = BCe(a, o, 10, Math.PI), h = [];
  zb(e, "buildPath", { replace: function(f) {
    for (var d = e.__morphT, p = 1 - d, g = [], v = 0; v < c.length; v++) {
      var O = c[v], m = O.from, E = O.to, b = O.rotation * d, S = O.fromCp, T = O.toCp, y = Math.sin(b), R = Math.cos(b);
      Ym(g, S, T, d);
      for (var _ = 0; _ < m.length; _ += 2) {
        var C = m[_], I = m[_ + 1], w = E[_], x = E[_ + 1], P = C * p + w * d, L = I * p + x * d;
        h[_] = P * R - L * y + g[0], h[_ + 1] = P * y + L * R + g[1];
      }
      var D = h[0], U = h[1];
      f.moveTo(D, U);
      for (var _ = 2; _ < m.length; ) {
        var w = h[_++], x = h[_++], Q = h[_++], V = h[_++], F = h[_++], j = h[_++];
        D === w && U === x && Q === F && V === j ? f.lineTo(F, j) : f.bezierCurveTo(w, x, Q, V, F, j), D = F, U = j;
      }
    }
  } });
}
function Nx(r, e, t) {
  if (!r || !e)
    return e;
  var i = t.done, n = t.during;
  a7(r, e), e.__morphT = 0;
  function a() {
    rg(e, "buildPath"), rg(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape();
  }
  return e.animateTo({
    __morphT: 1
  }, Te({
    during: function(o) {
      e.dirtyShape(), n && n(o);
    },
    done: function() {
      a(), i && i();
    }
  }, t)), e;
}
function FCe(r, e, t, i, n, a) {
  var o = 16;
  r = n === t ? 0 : Math.round(32767 * (r - t) / (n - t)), e = a === i ? 0 : Math.round(32767 * (e - i) / (a - i));
  for (var s = 0, l, u = (1 << o) / 2; u > 0; u /= 2) {
    var c = 0, h = 0;
    (r & u) > 0 && (c = 1), (e & u) > 0 && (h = 1), s += u * u * (3 * c ^ h), h === 0 && (c === 1 && (r = u - 1 - r, e = u - 1 - e), l = r, r = e, e = l);
  }
  return s;
}
function Zb(r) {
  var e = 1 / 0, t = 1 / 0, i = -1 / 0, n = -1 / 0, a = Y(r, function(s) {
    var l = s.getBoundingRect(), u = s.getComputedTransform(), c = l.x + l.width / 2 + (u ? u[4] : 0), h = l.y + l.height / 2 + (u ? u[5] : 0);
    return e = Math.min(c, e), t = Math.min(h, t), i = Math.max(c, i), n = Math.max(h, n), [c, h];
  }), o = Y(a, function(s, l) {
    return {
      cp: s,
      z: FCe(s[0], s[1], e, t, i, n),
      path: r[l]
    };
  });
  return o.sort(function(s, l) {
    return s.z - l.z;
  }).map(function(s) {
    return s.path;
  });
}
function o7(r) {
  return QCe(r.path, r.count);
}
function dI() {
  return {
    fromIndividuals: [],
    toIndividuals: [],
    count: 0
  };
}
function XCe(r, e, t) {
  var i = [];
  function n(S) {
    for (var T = 0; T < S.length; T++) {
      var y = S[T];
      Wb(y) ? n(y.childrenRef()) : y instanceof He && i.push(y);
    }
  }
  n(r);
  var a = i.length;
  if (!a)
    return dI();
  var o = t.dividePath || o7, s = o({
    path: e,
    count: a
  });
  if (s.length !== a)
    return console.error("Invalid morphing: unmatched splitted path"), dI();
  i = Zb(i), s = Zb(s);
  for (var l = t.done, u = t.during, c = t.individualDelay, h = new Ho(), f = 0; f < a; f++) {
    var d = i[f], p = s[f];
    p.parent = e, p.copyTransform(h), c || a7(d, p);
  }
  e.__isCombineMorphing = !0, e.childrenRef = function() {
    return s;
  };
  function g(S) {
    for (var T = 0; T < s.length; T++)
      s[T].addSelfToZr(S);
  }
  zb(e, "addSelfToZr", {
    after: function(S) {
      g(S);
    }
  }), zb(e, "removeSelfFromZr", {
    after: function(S) {
      for (var T = 0; T < s.length; T++)
        s[T].removeSelfFromZr(S);
    }
  });
  function v() {
    e.__isCombineMorphing = !1, e.__morphT = -1, e.childrenRef = null, rg(e, "addSelfToZr"), rg(e, "removeSelfFromZr");
  }
  var O = s.length;
  if (c)
    for (var m = O, E = function() {
      m--, m === 0 && (v(), l && l());
    }, f = 0; f < O; f++) {
      var b = c ? Te({
        delay: (t.delay || 0) + c(f, O, i[f], s[f]),
        done: E
      }, t) : t;
      Nx(i[f], s[f], b);
    }
  else
    e.__morphT = 0, e.animateTo({
      __morphT: 1
    }, Te({
      during: function(S) {
        for (var T = 0; T < O; T++) {
          var y = s[T];
          y.__morphT = e.__morphT, y.dirtyShape();
        }
        u && u(S);
      },
      done: function() {
        v();
        for (var S = 0; S < r.length; S++)
          rg(r[S], "updateTransform");
        l && l();
      }
    }, t));
  return e.__zr && g(e.__zr), {
    fromIndividuals: i,
    toIndividuals: s,
    count: O
  };
}
function YCe(r, e, t) {
  var i = e.length, n = [], a = t.dividePath || o7;
  function o(d) {
    for (var p = 0; p < d.length; p++) {
      var g = d[p];
      Wb(g) ? o(g.childrenRef()) : g instanceof He && n.push(g);
    }
  }
  if (Wb(r)) {
    o(r.childrenRef());
    var s = n.length;
    if (s < i)
      for (var l = 0, u = s; u < i; u++)
        n.push(H1(n[l++ % s]));
    n.length = i;
  } else {
    n = a({ path: r, count: i });
    for (var c = r.getComputedTransform(), u = 0; u < n.length; u++)
      n[u].setLocalTransform(c);
    if (n.length !== i)
      return console.error("Invalid morphing: unmatched splitted path"), dI();
  }
  n = Zb(n), e = Zb(e);
  for (var h = t.individualDelay, u = 0; u < i; u++) {
    var f = h ? Te({
      delay: (t.delay || 0) + h(u, i, n[u], e[u])
    }, t) : t;
    Nx(n[u], e[u], f);
  }
  return {
    fromIndividuals: n,
    toIndividuals: e,
    count: e.length
  };
}
function hV(r) {
  return X(r[0]);
}
function fV(r, e) {
  for (var t = [], i = r.length, n = 0; n < i; n++)
    t.push({
      one: r[n],
      many: []
    });
  for (var n = 0; n < e.length; n++) {
    var a = e[n].length, o = void 0;
    for (o = 0; o < a; o++)
      t[o % i].many.push(e[n][o]);
  }
  for (var s = 0, n = i - 1; n >= 0; n--)
    if (!t[n].many.length) {
      var l = t[s].many;
      if (l.length <= 1)
        if (s)
          s = 0;
        else
          return t;
      var a = l.length, u = Math.ceil(a / 2);
      t[n].many = l.slice(u, a), t[s].many = l.slice(0, u), s++;
    }
  return t;
}
var HCe = {
  clone: function(r) {
    for (var e = [], t = 1 - Math.pow(1 - r.path.style.opacity, 1 / r.count), i = 0; i < r.count; i++) {
      var n = H1(r.path);
      n.setStyle("opacity", t), e.push(n);
    }
    return e;
  },
  // Use the default divider
  split: null
};
function oA(r, e, t, i, n, a) {
  if (!r.length || !e.length)
    return;
  var o = Jf("update", i, n);
  if (!(o && o.duration > 0))
    return;
  var s = i.getModel("universalTransition").get("delay"), l = Object.assign({
    // Need to setToFinal so the further calculation based on the style can be correct.
    // Like emphasis color.
    setToFinal: !0
  }, o), u, c;
  hV(r) && (u = r, c = e), hV(e) && (u = e, c = r);
  function h(O, m, E, b, S) {
    var T = O.many, y = O.one;
    if (T.length === 1 && !S) {
      var R = m ? T[0] : y, _ = m ? y : T[0];
      if (Wb(R))
        h({
          many: [R],
          one: _
        }, !0, E, b, !0);
      else {
        var C = s ? Te({
          delay: s(E, b)
        }, l) : l;
        Nx(R, _, C), a(R, _, R, _, C);
      }
    } else
      for (var I = Te({
        dividePath: HCe[t],
        individualDelay: s && function(U, Q, V, F) {
          return s(U + E, b);
        }
      }, l), w = m ? XCe(T, y, I) : YCe(y, T, I), x = w.fromIndividuals, P = w.toIndividuals, L = x.length, D = 0; D < L; D++) {
        var C = s ? Te({
          delay: s(D, L)
        }, l) : l;
        a(x[D], P[D], m ? T[D] : O.one, m ? O.one : T[D], C);
      }
  }
  for (var f = u ? u === r : r.length > e.length, d = u ? fV(c, u) : fV(f ? e : r, [f ? r : e]), p = 0, g = 0; g < d.length; g++)
    p += d[g].many.length;
  for (var v = 0, g = 0; g < d.length; g++)
    h(d[g], f, v, p), v += d[g].many.length;
}
function Du(r) {
  if (!r)
    return [];
  if (X(r)) {
    for (var e = [], t = 0; t < r.length; t++)
      e.push(Du(r[t]));
    return e;
  }
  var i = [];
  return r.traverse(function(n) {
    n instanceof He && !n.disableMorphing && !n.invisible && !n.ignore && i.push(n);
  }), i;
}
var s7 = 1e4, WCe = ft();
function zCe(r) {
  for (var e = r.dimensions, t = 0; t < e.length; t++) {
    var i = r.getDimensionInfo(e[t]);
    if (i && i.otherDims.itemGroupId === 0)
      return e[t];
  }
}
function dV(r) {
  var e = [];
  return N(r, function(t) {
    var i = t.data;
    if (i.count() > s7) {
      ({}).NODE_ENV !== "production" && tr("Universal transition is disabled on large data > 10k.");
      return;
    }
    for (var n = i.getIndices(), a = zCe(i), o = 0; o < n.length; o++)
      e.push({
        dataGroupId: t.dataGroupId,
        data: i,
        dim: t.dim || a,
        divide: t.divide,
        dataIndex: o
      });
  }), e;
}
function sA(r, e, t) {
  r.traverse(function(i) {
    i instanceof He && Bt(i, {
      style: {
        opacity: 0
      }
    }, e, {
      dataIndex: t,
      isFrom: !0
    });
  });
}
function lA(r) {
  if (r.parent) {
    var e = r.getComputedTransform();
    r.setLocalTransform(e), r.parent.remove(r);
  }
}
function xh(r) {
  r.stopAnimation(), r.isGroup && r.traverse(function(e) {
    e.stopAnimation();
  });
}
function ZCe(r, e, t) {
  var i = Jf("update", t, e);
  i && r.traverse(function(n) {
    if (n instanceof aa) {
      var a = Lse(n);
      a && n.animateFrom({
        style: a
      }, i);
    }
  });
}
function qCe(r, e) {
  var t = r.length;
  if (t !== e.length)
    return !1;
  for (var i = 0; i < t; i++) {
    var n = r[i], a = e[i];
    if (n.data.getId(n.dataIndex) !== a.data.getId(a.dataIndex))
      return !1;
  }
  return !0;
}
function l7(r, e, t) {
  var i = dV(r), n = dV(e);
  function a(O, m, E, b, S) {
    (E || O) && m.animateFrom({
      style: E && E !== O ? (
        // dividingMethod like clone may override the style(opacity)
        // So extend it to raw style.
        B(B({}, E.style), O.style)
      ) : O.style
    }, S);
  }
  function o(O) {
    for (var m = 0; m < O.length; m++)
      if (O[m].dim)
        return O[m].dim;
  }
  var s = o(i), l = o(n), u = !1;
  function c(O, m) {
    return function(E) {
      var b = E.data, S = E.dataIndex;
      if (m)
        return b.getId(S);
      var T = E.dataGroupId, y = O ? s || l : l || s, R = y && b.getDimensionInfo(y), _ = R && R.ordinalMeta;
      if (R) {
        var C = b.get(R.name, S);
        return _ && _.categories[C] || C + "";
      }
      var I = b.getRawDataItem(S);
      return I && I.groupId ? I.groupId + "" : T || b.getId(S);
    };
  }
  var h = qCe(i, n), f = {};
  if (!h)
    for (var d = 0; d < n.length; d++) {
      var p = n[d], g = p.data.getItemGraphicEl(p.dataIndex);
      g && (f[g.id] = !0);
    }
  function v(O, m) {
    var E = i[m], b = n[O], S = b.data.hostModel, T = E.data.getItemGraphicEl(E.dataIndex), y = b.data.getItemGraphicEl(b.dataIndex);
    if (T === y) {
      y && ZCe(y, b.dataIndex, S);
      return;
    }
    // We can't use the elements that already being morphed
    T && f[T.id] || y && (xh(y), T ? (xh(T), lA(T), u = !0, oA(Du(T), Du(y), b.divide, S, O, a)) : sA(y, S, O));
  }
  new cs(i, n, c(!0, h), c(!1, h), null, "multiple").update(v).updateManyToOne(function(O, m) {
    var E = n[O], b = E.data, S = b.hostModel, T = b.getItemGraphicEl(E.dataIndex), y = At(Y(m, function(R) {
      return i[R].data.getItemGraphicEl(i[R].dataIndex);
    }), function(R) {
      return R && R !== T && !f[R.id];
    });
    T && (xh(T), y.length ? (N(y, function(R) {
      xh(R), lA(R);
    }), u = !0, oA(Du(y), Du(T), E.divide, S, O, a)) : sA(T, S, E.dataIndex));
  }).updateOneToMany(function(O, m) {
    var E = i[m], b = E.data.getItemGraphicEl(E.dataIndex);
    if (!(b && f[b.id])) {
      var S = At(Y(O, function(y) {
        return n[y].data.getItemGraphicEl(n[y].dataIndex);
      }), function(y) {
        return y && y !== b;
      }), T = n[O[0]].data.hostModel;
      S.length && (N(S, function(y) {
        return xh(y);
      }), b ? (xh(b), lA(b), u = !0, oA(
        Du(b),
        Du(S),
        E.divide,
        // Use divide on old.
        T,
        O[0],
        a
      )) : N(S, function(y) {
        return sA(y, T, O[0]);
      }));
    }
  }).updateManyToMany(function(O, m) {
    new cs(m, O, function(E) {
      return i[E].data.getId(i[E].dataIndex);
    }, function(E) {
      return n[E].data.getId(n[E].dataIndex);
    }).update(function(E, b) {
      v(O[E], m[b]);
    }).execute();
  }).execute(), u && N(e, function(O) {
    var m = O.data, E = m.hostModel, b = E && t.getViewOfSeriesModel(E), S = Jf("update", E, 0);
    b && E.isAnimationEnabled() && S && S.duration > 0 && b.group.traverse(function(T) {
      T instanceof He && !T.animators.length && T.animateFrom({
        style: {
          opacity: 0
        }
      }, S);
    });
  });
}
function pV(r) {
  var e = r.getModel("universalTransition").get("seriesKey");
  return e || r.id;
}
function gV(r) {
  return X(r) ? r.sort().join(",") : r;
}
function Ys(r) {
  if (r.hostModel)
    return r.hostModel.getModel("universalTransition").get("divideShape");
}
function jCe(r, e) {
  var t = de(), i = de(), n = de();
  N(r.oldSeries, function(o, s) {
    var l = r.oldDataGroupIds[s], u = r.oldData[s], c = pV(o), h = gV(c);
    i.set(h, {
      dataGroupId: l,
      data: u
    }), X(c) && N(c, function(f) {
      n.set(f, {
        key: h,
        dataGroupId: l,
        data: u
      });
    });
  });
  function a(o) {
    t.get(o) && tr("Duplicated seriesKey in universalTransition " + o);
  }
  return N(e.updatedSeries, function(o) {
    if (o.isUniversalTransitionEnabled() && o.isAnimationEnabled()) {
      var s = o.get("dataGroupId"), l = o.getData(), u = pV(o), c = gV(u), h = i.get(c);
      if (h)
        ({}).NODE_ENV !== "production" && a(c), t.set(c, {
          oldSeries: [{
            dataGroupId: h.dataGroupId,
            divide: Ys(h.data),
            data: h.data
          }],
          newSeries: [{
            dataGroupId: s,
            divide: Ys(l),
            data: l
          }]
        });
      else if (X(u)) {
        ({}).NODE_ENV !== "production" && a(c);
        var f = [];
        N(u, function(g) {
          var v = i.get(g);
          v.data && f.push({
            dataGroupId: v.dataGroupId,
            divide: Ys(v.data),
            data: v.data
          });
        }), f.length && t.set(c, {
          oldSeries: f,
          newSeries: [{
            dataGroupId: s,
            data: l,
            divide: Ys(l)
          }]
        });
      } else {
        var d = n.get(u);
        if (d) {
          var p = t.get(d.key);
          p || (p = {
            oldSeries: [{
              dataGroupId: d.dataGroupId,
              data: d.data,
              divide: Ys(d.data)
            }],
            newSeries: []
          }, t.set(d.key, p)), p.newSeries.push({
            dataGroupId: s,
            data: l,
            divide: Ys(l)
          });
        }
      }
    }
  }), t;
}
function vV(r, e) {
  for (var t = 0; t < r.length; t++) {
    var i = e.seriesIndex != null && e.seriesIndex === r[t].seriesIndex || e.seriesId != null && e.seriesId === r[t].id;
    if (i)
      return t;
  }
}
function KCe(r, e, t, i) {
  var n = [], a = [];
  N(It(r.from), function(o) {
    var s = vV(e.oldSeries, o);
    s >= 0 && n.push({
      dataGroupId: e.oldDataGroupIds[s],
      data: e.oldData[s],
      // TODO can specify divideShape in transition.
      divide: Ys(e.oldData[s]),
      dim: o.dimension
    });
  }), N(It(r.to), function(o) {
    var s = vV(t.updatedSeries, o);
    if (s >= 0) {
      var l = t.updatedSeries[s].getData();
      a.push({
        dataGroupId: e.oldDataGroupIds[s],
        data: l,
        divide: Ys(l),
        dim: o.dimension
      });
    }
  }), n.length > 0 && a.length > 0 && l7(n, a, i);
}
function JCe(r) {
  r.registerUpdateLifecycle("series:beforeupdate", function(e, t, i) {
    N(It(i.seriesTransition), function(n) {
      N(It(n.to), function(a) {
        for (var o = i.updatedSeries, s = 0; s < o.length; s++)
          (a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][rE] = !0);
      });
    });
  }), r.registerUpdateLifecycle("series:transition", function(e, t, i) {
    var n = WCe(t);
    if (n.oldSeries && i.updatedSeries && i.optionChanged) {
      var a = i.seriesTransition;
      if (a)
        N(It(a), function(d) {
          KCe(d, n, i, t);
        });
      else {
        var o = jCe(n, i);
        N(o.keys(), function(d) {
          var p = o.get(d);
          l7(p.oldSeries, p.newSeries, t);
        });
      }
      N(i.updatedSeries, function(d) {
        d[rE] && (d[rE] = !1);
      });
    }
    for (var s = e.getSeries(), l = n.oldSeries = [], u = n.oldDataGroupIds = [], c = n.oldData = [], h = 0; h < s.length; h++) {
      var f = s[h].getData();
      f.count() < s7 && (l.push(s[h]), u.push(s[h].get("dataGroupId")), c.push(f));
    }
  });
}
Ye([Ode]);
Ye([cde]);
Ye([Gde, ape, mpe, age, Tge, vve, Wve, LOe, sme, vme, Cme, xEe, nbe, Obe, Qbe, Xbe, lSe, mSe, xSe, $Se, KSe, kTe]);
Ye(aye);
Ye($ye);
Ye(r4);
Ye(r0e);
Ye(B4);
Ye(u0e);
Ye(m0e);
Ye(ERe);
Ye(BRe);
Ye(Gv);
Ye(lAe);
Ye(hAe);
Ye(_Ae);
Ye(kAe);
Ye(XAe);
Ye(KAe);
Ye(f_e);
Ye(D_e);
Ye(zZ);
Ye(ZZ);
Ye(sCe);
Ye(e7);
Ye(t7);
Ye(fCe);
Ye(ACe);
Ye(ICe);
Ye(JCe);
Ye(Nfe);
function eIe(r) {
  const [e, t] = Object.prototype.toString.call(r).replace(/[\[|\]]/gi, "").split(" ");
  return t.toLocaleLowerCase();
}
const tIe = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjkxMzg2NDA5MzAwIiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9IjY0NzQiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTY0MCA2NGwwIDE4OS4xMiAxOTIgMEw2NDkuNDcyIDY0IDY0MCA2NHpNNjQwIDY0bDAgMTg5LjEyIDE5MiAwTDY0OS40NzIgNjQgNjQwIDY0ek02OTcuNiA3NjYuNGMtMTQuMDE2IDAtMjcuMTM2LTYuNTkyLTM1LjcxMi0xNy42TDUxNy43NiA1NjcuODcyQzUwMi45MTIgNTQ4LjIyNCA1MDYuNzUyIDUyMC4yNTYgNTI2LjQgNTA1LjM0NGMxOS43NzYtMTQuNzg0IDQ3LjYxNi0xMC45NDQgNjIuNDY0IDguNzA0bDEwNS4xNTIgMTI5LjE1MiAxODkuMjQ4LTMwMy43NDRjMTIuOTkyLTIwLjg2NCA0MC41MTItMjcuMjY0IDYxLjM3Ni0xNC4yNzIgMjAuOTkyIDEyLjk5MiAyNy4yNjQgNDAuNTEyIDE0LjI3MiA2MS40NGwtMjIzLjI5NiAzNTguNzJjLTcuNzQ0IDEyLjQxNi0yMS4yNDggMjAuMjI0LTM1Ljk2OCAyMC45OTJDNjk5LjAwOCA3NjYuNCA2OTguMjQgNzY2LjQgNjk3LjYgNzY2LjR6TTc4OS43NiA3NzkuMjY0Yy0xOC44MTYgMzAuMjcyLTUxLjM5MiA0OS4zNDQtODcuMTA0IDUxLjAwOGwtMS43OTIgMC4xMjhMNjk3LjYgODMwLjRjLTMzLjY2NCAwLTY1Ljk4NC0xNi04NS43Ni00MS43MjhMNDY2Ljc1MiA2MDYuNjU2QzQzMC42NTYgNTU4Ljg0OCA0NDAgNDkwLjYyNCA0ODggNDU0LjE0NGMxOS4wMDgtMTQuMjcyIDQxLjYtMjEuODI0IDY1LjM0NC0yMS44MjQgMzMuNzI4IDAgNjYuMTEyIDE2LjA2NCA4NS4yNDggNDEuMzQ0bDQ4LjM4NCA1OS41ODRMODE5LjkwNCAzMjAgNTc2IDMyMCA1NzYgNjQgOTUuMTY4IDY0Qzc2LjYwOCA2NCA2NCA3Ni42MDggNjQgOTIuMDMybDAgODQwQzY0IDk0Ny4zOTIgNzYuNjA4IDk2MCA5Mi4wMzIgOTYwbDcxMiAwQzgxOS4zOTIgOTYwIDgzMiA5NDcuMzkyIDgzMiA5MzEuOTY4bDAtMjIwLjU0NEw3ODkuNzYgNzc5LjI2NHpNMjI0IDI1NmwxOTIgMEM0MzMuNjY0IDI1NiA0NDggMjcwLjMzNiA0NDggMjg4UzQzMy42NjQgMzIwIDQxNiAzMjBsLTE5MiAwQzIwNi4zMzYgMzIwIDE5MiAzMDUuNjY0IDE5MiAyODhTMjA2LjMzNiAyNTYgMjI0IDI1NnpNMjI0IDM4NGwxOTIgMEM0MzMuNjY0IDM4NCA0NDggMzk4LjMzNiA0NDggNDE2UzQzMy42NjQgNDQ4IDQxNiA0NDhsLTE5MiAwQzIwNi4zMzYgNDQ4IDE5MiA0MzMuNjY0IDE5MiA0MTZTMjA2LjMzNiAzODQgMjI0IDM4NHpNMjI0IDUxMmwxMjggMEMzNjkuNjY0IDUxMiAzODQgNTI2LjMzNiAzODQgNTQ0IDM4NCA1NjEuNiAzNjkuNjY0IDU3NiAzNTIgNTc2bC0xMjggMEMyMDYuMzM2IDU3NiAxOTIgNTYxLjYgMTkyIDU0NCAxOTIgNTI2LjMzNiAyMDYuMzM2IDUxMiAyMjQgNTEyek0yMjQgNjQwbDE5MiAwQzQzMy42NjQgNjQwIDQ0OCA2NTQuNCA0NDggNjcyUzQzMy42NjQgNzA0IDQxNiA3MDRsLTE5MiAwQzIwNi4zMzYgNzA0IDE5MiA2ODkuNiAxOTIgNjcyUzIwNi4zMzYgNjQwIDIyNCA2NDB6TTQ4MCA4MzJsLTI1NiAwQzIwNi4zMzYgODMyIDE5MiA4MTcuNiAxOTIgODAwUzIwNi4zMzYgNzY4IDIyNCA3NjhsMjU2IDBDNDk3LjY2NCA3NjggNTEyIDc4Mi40IDUxMiA4MDBTNDk3LjY2NCA4MzIgNDgwIDgzMnoiIGZpbGw9IiMwMTAxMDEiIHAtaWQ9IjY0NzUiPjwvcGF0aD48L3N2Zz4=", rIe = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBzdGFuZGFsb25lPSJubyI/PjwhRE9DVFlQRSBzdmcgUFVCTElDICItLy9XM0MvL0RURCBTVkcgMS4xLy9FTiIgImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+PHN2ZyB0PSIxNjkxMzg2OTA3NTE5IiBjbGFzcz0iaWNvbiIgdmlld0JveD0iMCAwIDEwMjQgMTAyNCIgdmVyc2lvbj0iMS4xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHAtaWQ9Ijc0NzkiIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB3aWR0aD0iMjAwIiBoZWlnaHQ9IjIwMCI+PHBhdGggZD0iTTYwMS4xNTIgNzA4LjI4OCA0MDAgNTY4IDM0NCA1NjhsMCAxMTItMjI0IDAgMCAxMTIgMjI0IDAgMCAxMTJMNDAwIDkwNGwyMDEuMTUyLTE0MC4yODhDNjI0IDc0OS41MDQgNjI0IDcyMi40OTYgNjAxLjE1MiA3MDguMjg4TDYwMS4xNTIgNzA4LjI4OHpNODkxLjI2NCAzMzEuMiA2MzguNjU2IDc2Ljg2NEM2MzAuNTI4IDY4LjYwOCA2MTkuNDU2IDY0IDYwNy45MzYgNjRMMjMyIDY0QzE5Ni4wMzIgNjQgMTc2IDgzLjcxMiAxNzYgMTIwTDE3NiA1MTIgMjg4IDUxMiAyODggMTc2bDI4MCAwIDAgMTY4YzAgMjQuMTkyIDMyIDU2IDU2IDU2bDE2OCAwIDAuNzY4IDQ0OEw2MjQgODQ4IDYyNCA5NjBsMjI0IDBjMzUuOTY4IDAgNTYtMTkuNzEyIDU2LTU2TDkwNCAzNjIuMTc2QzkwNCAzNTAuNTI4IDg5OS4zOTIgMzM5LjM5MiA4OTEuMjY0IDMzMS4yTDg5MS4yNjQgMzMxLjJ6IiBwLWlkPSI3NDgwIj48L3BhdGg+PC9zdmc+";
class Ct {
  /**
  Get the line description around the given position.
  */
  lineAt(e) {
    if (e < 0 || e > this.length)
      throw new RangeError(`Invalid position ${e} in document of length ${this.length}`);
    return this.lineInner(e, !1, 1, 0);
  }
  /**
  Get the description for the given (1-based) line number.
  */
  line(e) {
    if (e < 1 || e > this.lines)
      throw new RangeError(`Invalid line number ${e} in ${this.lines}-line document`);
    return this.lineInner(e, !0, 1, 0);
  }
  /**
  Replace a range of the text with the given content.
  */
  replace(e, t, i) {
    let n = [];
    return this.decompose(
      0,
      e,
      n,
      2
      /* Open.To */
    ), i.length && i.decompose(
      0,
      i.length,
      n,
      3
      /* Open.To */
    ), this.decompose(
      t,
      this.length,
      n,
      1
      /* Open.From */
    ), io.from(n, this.length - (t - e) + i.length);
  }
  /**
  Append another document to this one.
  */
  append(e) {
    return this.replace(this.length, this.length, e);
  }
  /**
  Retrieve the text between the given points.
  */
  slice(e, t = this.length) {
    let i = [];
    return this.decompose(e, t, i, 0), io.from(i, t - e);
  }
  /**
  Test whether this text is equal to another instance.
  */
  eq(e) {
    if (e == this)
      return !0;
    if (e.length != this.length || e.lines != this.lines)
      return !1;
    let t = this.scanIdentical(e, 1), i = this.length - this.scanIdentical(e, -1), n = new ig(this), a = new ig(e);
    for (let o = t, s = t; ; ) {
      if (n.next(o), a.next(o), o = 0, n.lineBreak != a.lineBreak || n.done != a.done || n.value != a.value)
        return !1;
      if (s += n.value.length, n.done || s >= i)
        return !0;
    }
  }
  /**
  Iterate over the text. When `dir` is `-1`, iteration happens
  from end to start. This will return lines and the breaks between
  them as separate strings.
  */
  iter(e = 1) {
    return new ig(this, e);
  }
  /**
  Iterate over a range of the text. When `from` > `to`, the
  iterator will run in reverse.
  */
  iterRange(e, t = this.length) {
    return new u7(this, e, t);
  }
  /**
  Return a cursor that iterates over the given range of lines,
  _without_ returning the line breaks between, and yielding empty
  strings for empty lines.
  
  When `from` and `to` are given, they should be 1-based line numbers.
  */
  iterLines(e, t) {
    let i;
    if (e == null)
      i = this.iter();
    else {
      t == null && (t = this.lines + 1);
      let n = this.line(e).from;
      i = this.iterRange(n, Math.max(n, t == this.lines + 1 ? this.length : t <= 1 ? 0 : this.line(t - 1).to));
    }
    return new c7(i);
  }
  /**
  Return the document as a string, using newline characters to
  separate lines.
  */
  toString() {
    return this.sliceString(0);
  }
  /**
  Convert the document to an array of lines (which can be
  deserialized again via [`Text.of`](https://codemirror.net/6/docs/ref/#state.Text^of)).
  */
  toJSON() {
    let e = [];
    return this.flatten(e), e;
  }
  /**
  @internal
  */
  constructor() {
  }
  /**
  Create a `Text` instance for the given array of lines.
  */
  static of(e) {
    if (e.length == 0)
      throw new RangeError("A document must have at least one line");
    return e.length == 1 && !e[0] ? Ct.empty : e.length <= 32 ? new hr(e) : io.from(hr.split(e, []));
  }
}
class hr extends Ct {
  constructor(e, t = iIe(e)) {
    super(), this.text = e, this.length = t;
  }
  get lines() {
    return this.text.length;
  }
  get children() {
    return null;
  }
  lineInner(e, t, i, n) {
    for (let a = 0; ; a++) {
      let o = this.text[a], s = n + o.length;
      if ((t ? i : s) >= e)
        return new nIe(n, s, i, o);
      n = s + 1, i++;
    }
  }
  decompose(e, t, i, n) {
    let a = e <= 0 && t >= this.length ? this : new hr(OV(this.text, e, t), Math.min(t, this.length) - Math.max(0, e));
    if (n & 1) {
      let o = i.pop(), s = uE(a.text, o.text.slice(), 0, a.length);
      if (s.length <= 32)
        i.push(new hr(s, o.length + a.length));
      else {
        let l = s.length >> 1;
        i.push(new hr(s.slice(0, l)), new hr(s.slice(l)));
      }
    } else
      i.push(a);
  }
  replace(e, t, i) {
    if (!(i instanceof hr))
      return super.replace(e, t, i);
    let n = uE(this.text, uE(i.text, OV(this.text, 0, e)), t), a = this.length + i.length - (t - e);
    return n.length <= 32 ? new hr(n, a) : io.from(hr.split(n, []), a);
  }
  sliceString(e, t = this.length, i = `
`) {
    let n = "";
    for (let a = 0, o = 0; a <= t && o < this.text.length; o++) {
      let s = this.text[o], l = a + s.length;
      a > e && o && (n += i), e < l && t > a && (n += s.slice(Math.max(0, e - a), t - a)), a = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.text)
      e.push(t);
  }
  scanIdentical() {
    return 0;
  }
  static split(e, t) {
    let i = [], n = -1;
    for (let a of e)
      i.push(a), n += a.length + 1, i.length == 32 && (t.push(new hr(i, n)), i = [], n = -1);
    return n > -1 && t.push(new hr(i, n)), t;
  }
}
class io extends Ct {
  constructor(e, t) {
    super(), this.children = e, this.length = t, this.lines = 0;
    for (let i of e)
      this.lines += i.lines;
  }
  lineInner(e, t, i, n) {
    for (let a = 0; ; a++) {
      let o = this.children[a], s = n + o.length, l = i + o.lines - 1;
      if ((t ? l : s) >= e)
        return o.lineInner(e, t, i, n);
      n = s + 1, i = l + 1;
    }
  }
  decompose(e, t, i, n) {
    for (let a = 0, o = 0; o <= t && a < this.children.length; a++) {
      let s = this.children[a], l = o + s.length;
      if (e <= l && t >= o) {
        let u = n & ((o <= e ? 1 : 0) | (l >= t ? 2 : 0));
        o >= e && l <= t && !u ? i.push(s) : s.decompose(e - o, t - o, i, u);
      }
      o = l + 1;
    }
  }
  replace(e, t, i) {
    if (i.lines < this.lines)
      for (let n = 0, a = 0; n < this.children.length; n++) {
        let o = this.children[n], s = a + o.length;
        if (e >= a && t <= s) {
          let l = o.replace(e - a, t - a, i), u = this.lines - o.lines + l.lines;
          if (l.lines < u >> 5 - 1 && l.lines > u >> 5 + 1) {
            let c = this.children.slice();
            return c[n] = l, new io(c, this.length - (t - e) + i.length);
          }
          return super.replace(a, s, l);
        }
        a = s + 1;
      }
    return super.replace(e, t, i);
  }
  sliceString(e, t = this.length, i = `
`) {
    let n = "";
    for (let a = 0, o = 0; a < this.children.length && o <= t; a++) {
      let s = this.children[a], l = o + s.length;
      o > e && a && (n += i), e < l && t > o && (n += s.sliceString(e - o, t - o, i)), o = l + 1;
    }
    return n;
  }
  flatten(e) {
    for (let t of this.children)
      t.flatten(e);
  }
  scanIdentical(e, t) {
    if (!(e instanceof io))
      return 0;
    let i = 0, [n, a, o, s] = t > 0 ? [0, 0, this.children.length, e.children.length] : [this.children.length - 1, e.children.length - 1, -1, -1];
    for (; ; n += t, a += t) {
      if (n == o || a == s)
        return i;
      let l = this.children[n], u = e.children[a];
      if (l != u)
        return i + l.scanIdentical(u, t);
      i += l.length + 1;
    }
  }
  static from(e, t = e.reduce((i, n) => i + n.length + 1, -1)) {
    let i = 0;
    for (let d of e)
      i += d.lines;
    if (i < 32) {
      let d = [];
      for (let p of e)
        p.flatten(d);
      return new hr(d, t);
    }
    let n = Math.max(
      32,
      i >> 5
      /* Tree.BranchShift */
    ), a = n << 1, o = n >> 1, s = [], l = 0, u = -1, c = [];
    function h(d) {
      let p;
      if (d.lines > a && d instanceof io)
        for (let g of d.children)
          h(g);
      else
        d.lines > o && (l > o || !l) ? (f(), s.push(d)) : d instanceof hr && l && (p = c[c.length - 1]) instanceof hr && d.lines + p.lines <= 32 ? (l += d.lines, u += d.length + 1, c[c.length - 1] = new hr(p.text.concat(d.text), p.length + 1 + d.length)) : (l + d.lines > n && f(), l += d.lines, u += d.length + 1, c.push(d));
    }
    function f() {
      l != 0 && (s.push(c.length == 1 ? c[0] : io.from(c, u)), u = -1, l = c.length = 0);
    }
    for (let d of e)
      h(d);
    return f(), s.length == 1 ? s[0] : new io(s, t);
  }
}
Ct.empty = /* @__PURE__ */ new hr([""], 0);
function iIe(r) {
  let e = -1;
  for (let t of r)
    e += t.length + 1;
  return e;
}
function uE(r, e, t = 0, i = 1e9) {
  for (let n = 0, a = 0, o = !0; a < r.length && n <= i; a++) {
    let s = r[a], l = n + s.length;
    l >= t && (l > i && (s = s.slice(0, i - n)), n < t && (s = s.slice(t - n)), o ? (e[e.length - 1] += s, o = !1) : e.push(s)), n = l + 1;
  }
  return e;
}
function OV(r, e, t) {
  return uE(r, [""], e, t);
}
class ig {
  constructor(e, t = 1) {
    this.dir = t, this.done = !1, this.lineBreak = !1, this.value = "", this.nodes = [e], this.offsets = [t > 0 ? 1 : (e instanceof hr ? e.text.length : e.children.length) << 1];
  }
  nextInner(e, t) {
    for (this.done = this.lineBreak = !1; ; ) {
      let i = this.nodes.length - 1, n = this.nodes[i], a = this.offsets[i], o = a >> 1, s = n instanceof hr ? n.text.length : n.children.length;
      if (o == (t > 0 ? s : 0)) {
        if (i == 0)
          return this.done = !0, this.value = "", this;
        t > 0 && this.offsets[i - 1]++, this.nodes.pop(), this.offsets.pop();
      } else if ((a & 1) == (t > 0 ? 0 : 1)) {
        if (this.offsets[i] += t, e == 0)
          return this.lineBreak = !0, this.value = `
`, this;
        e--;
      } else if (n instanceof hr) {
        let l = n.text[o + (t < 0 ? -1 : 0)];
        if (this.offsets[i] += t, l.length > Math.max(0, e))
          return this.value = e == 0 ? l : t > 0 ? l.slice(e) : l.slice(0, l.length - e), this;
        e -= l.length;
      } else {
        let l = n.children[o + (t < 0 ? -1 : 0)];
        e > l.length ? (e -= l.length, this.offsets[i] += t) : (t < 0 && this.offsets[i]--, this.nodes.push(l), this.offsets.push(t > 0 ? 1 : (l instanceof hr ? l.text.length : l.children.length) << 1));
      }
    }
  }
  next(e = 0) {
    return e < 0 && (this.nextInner(-e, -this.dir), e = this.value.length), this.nextInner(e, this.dir);
  }
}
class u7 {
  constructor(e, t, i) {
    this.value = "", this.done = !1, this.cursor = new ig(e, t > i ? -1 : 1), this.pos = t > i ? e.length : 0, this.from = Math.min(t, i), this.to = Math.max(t, i);
  }
  nextInner(e, t) {
    if (t < 0 ? this.pos <= this.from : this.pos >= this.to)
      return this.value = "", this.done = !0, this;
    e += Math.max(0, t < 0 ? this.pos - this.to : this.from - this.pos);
    let i = t < 0 ? this.pos - this.from : this.to - this.pos;
    e > i && (e = i), i -= e;
    let { value: n } = this.cursor.next(e);
    return this.pos += (n.length + e) * t, this.value = n.length <= i ? n : t < 0 ? n.slice(n.length - i) : n.slice(0, i), this.done = !this.value, this;
  }
  next(e = 0) {
    return e < 0 ? e = Math.max(e, this.from - this.pos) : e > 0 && (e = Math.min(e, this.to - this.pos)), this.nextInner(e, this.cursor.dir);
  }
  get lineBreak() {
    return this.cursor.lineBreak && this.value != "";
  }
}
class c7 {
  constructor(e) {
    this.inner = e, this.afterBreak = !0, this.value = "", this.done = !1;
  }
  next(e = 0) {
    let { done: t, lineBreak: i, value: n } = this.inner.next(e);
    return t ? (this.done = !0, this.value = "") : i ? this.afterBreak ? this.value = "" : (this.afterBreak = !0, this.next()) : (this.value = n, this.afterBreak = !1), this;
  }
  get lineBreak() {
    return !1;
  }
}
typeof Symbol < "u" && (Ct.prototype[Symbol.iterator] = function() {
  return this.iter();
}, ig.prototype[Symbol.iterator] = u7.prototype[Symbol.iterator] = c7.prototype[Symbol.iterator] = function() {
  return this;
});
class nIe {
  /**
  @internal
  */
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.number = i, this.text = n;
  }
  /**
  The length of the line (not including any line break after it).
  */
  get length() {
    return this.to - this.from;
  }
}
let hf = /* @__PURE__ */ "lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o".split(",").map((r) => r ? parseInt(r, 36) : 1);
for (let r = 1; r < hf.length; r++)
  hf[r] += hf[r - 1];
function aIe(r) {
  for (let e = 1; e < hf.length; e += 2)
    if (hf[e] > r)
      return hf[e - 1] <= r;
  return !1;
}
function mV(r) {
  return r >= 127462 && r <= 127487;
}
const EV = 8205;
function vi(r, e, t = !0, i = !0) {
  return (t ? h7 : oIe)(r, e, i);
}
function h7(r, e, t) {
  if (e == r.length)
    return e;
  e && f7(r.charCodeAt(e)) && d7(r.charCodeAt(e - 1)) && e--;
  let i = Zr(r, e);
  for (e += Hn(i); e < r.length; ) {
    let n = Zr(r, e);
    if (i == EV || n == EV || t && aIe(n))
      e += Hn(n), i = n;
    else if (mV(n)) {
      let a = 0, o = e - 2;
      for (; o >= 0 && mV(Zr(r, o)); )
        a++, o -= 2;
      if (a % 2 == 0)
        break;
      e += 2;
    } else
      break;
  }
  return e;
}
function oIe(r, e, t) {
  for (; e > 0; ) {
    let i = h7(r, e - 2, t);
    if (i < e)
      return i;
    e--;
  }
  return 0;
}
function f7(r) {
  return r >= 56320 && r < 57344;
}
function d7(r) {
  return r >= 55296 && r < 56320;
}
function Zr(r, e) {
  let t = r.charCodeAt(e);
  if (!d7(t) || e + 1 == r.length)
    return t;
  let i = r.charCodeAt(e + 1);
  return f7(i) ? (t - 55296 << 10) + (i - 56320) + 65536 : t;
}
function xx(r) {
  return r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode((r >> 10) + 55296, (r & 1023) + 56320));
}
function Hn(r) {
  return r < 65536 ? 1 : 2;
}
const pI = /\r\n?|\n/;
var jr = /* @__PURE__ */ function(r) {
  return r[r.Simple = 0] = "Simple", r[r.TrackDel = 1] = "TrackDel", r[r.TrackBefore = 2] = "TrackBefore", r[r.TrackAfter = 3] = "TrackAfter", r;
}(jr || (jr = {}));
class Oo {
  // Sections are encoded as pairs of integers. The first is the
  // length in the current document, and the second is -1 for
  // unaffected sections, and the length of the replacement content
  // otherwise. So an insertion would be (0, n>0), a deletion (n>0,
  // 0), and a replacement two positive numbers.
  /**
  @internal
  */
  constructor(e) {
    this.sections = e;
  }
  /**
  The length of the document before the change.
  */
  get length() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2)
      e += this.sections[t];
    return e;
  }
  /**
  The length of the document after the change.
  */
  get newLength() {
    let e = 0;
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t + 1];
      e += i < 0 ? this.sections[t] : i;
    }
    return e;
  }
  /**
  False when there are actual changes in this set.
  */
  get empty() {
    return this.sections.length == 0 || this.sections.length == 2 && this.sections[1] < 0;
  }
  /**
  Iterate over the unchanged parts left by these changes. `posA`
  provides the position of the range in the old document, `posB`
  the new position in the changed document.
  */
  iterGaps(e) {
    for (let t = 0, i = 0, n = 0; t < this.sections.length; ) {
      let a = this.sections[t++], o = this.sections[t++];
      o < 0 ? (e(i, n, a), n += a) : n += o, i += a;
    }
  }
  /**
  Iterate over the ranges changed by these changes. (See
  [`ChangeSet.iterChanges`](https://codemirror.net/6/docs/ref/#state.ChangeSet.iterChanges) for a
  variant that also provides you with the inserted text.)
  `fromA`/`toA` provides the extent of the change in the starting
  document, `fromB`/`toB` the extent of the replacement in the
  changed document.
  
  When `individual` is true, adjacent changes (which are kept
  separate for [position mapping](https://codemirror.net/6/docs/ref/#state.ChangeDesc.mapPos)) are
  reported separately.
  */
  iterChangedRanges(e, t = !1) {
    gI(this, e, t);
  }
  /**
  Get a description of the inverted form of these changes.
  */
  get invertedDesc() {
    let e = [];
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      n < 0 ? e.push(i, n) : e.push(n, i);
    }
    return new Oo(e);
  }
  /**
  Compute the combined effect of applying another set of changes
  after this one. The length of the document after this set should
  match the length before `other`.
  */
  composeDesc(e) {
    return this.empty ? e : e.empty ? this : p7(this, e);
  }
  /**
  Map this description, which should start with the same document
  as `other`, over another set of changes, so that it can be
  applied after it. When `before` is true, map as if the changes
  in `other` happened before the ones in `this`.
  */
  mapDesc(e, t = !1) {
    return e.empty ? this : vI(this, e, t);
  }
  mapPos(e, t = -1, i = jr.Simple) {
    let n = 0, a = 0;
    for (let o = 0; o < this.sections.length; ) {
      let s = this.sections[o++], l = this.sections[o++], u = n + s;
      if (l < 0) {
        if (u > e)
          return a + (e - n);
        a += s;
      } else {
        if (i != jr.Simple && u >= e && (i == jr.TrackDel && n < e && u > e || i == jr.TrackBefore && n < e || i == jr.TrackAfter && u > e))
          return null;
        if (u > e || u == e && t < 0 && !s)
          return e == n || t < 0 ? a : a + l;
        a += l;
      }
      n = u;
    }
    if (e > n)
      throw new RangeError(`Position ${e} is out of range for changeset of length ${n}`);
    return a;
  }
  /**
  Check whether these changes touch a given range. When one of the
  changes entirely covers the range, the string `"cover"` is
  returned.
  */
  touchesRange(e, t = e) {
    for (let i = 0, n = 0; i < this.sections.length && n <= t; ) {
      let a = this.sections[i++], o = this.sections[i++], s = n + a;
      if (o >= 0 && n <= t && s >= e)
        return n < e && s > t ? "cover" : !0;
      n = s;
    }
    return !1;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 0; t < this.sections.length; ) {
      let i = this.sections[t++], n = this.sections[t++];
      e += (e ? " " : "") + i + (n >= 0 ? ":" + n : "");
    }
    return e;
  }
  /**
  Serialize this change desc to a JSON-representable value.
  */
  toJSON() {
    return this.sections;
  }
  /**
  Create a change desc from its JSON representation (as produced
  by [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeDesc.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e) || e.length % 2 || e.some((t) => typeof t != "number"))
      throw new RangeError("Invalid JSON representation of ChangeDesc");
    return new Oo(e);
  }
  /**
  @internal
  */
  static create(e) {
    return new Oo(e);
  }
}
class Nr extends Oo {
  constructor(e, t) {
    super(e), this.inserted = t;
  }
  /**
  Apply the changes to a document, returning the modified
  document.
  */
  apply(e) {
    if (this.length != e.length)
      throw new RangeError("Applying change set to a document with the wrong length");
    return gI(this, (t, i, n, a, o) => e = e.replace(n, n + (i - t), o), !1), e;
  }
  mapDesc(e, t = !1) {
    return vI(this, e, t, !0);
  }
  /**
  Given the document as it existed _before_ the changes, return a
  change set that represents the inverse of this set, which could
  be used to go from the document created by the changes back to
  the document as it existed before the changes.
  */
  invert(e) {
    let t = this.sections.slice(), i = [];
    for (let n = 0, a = 0; n < t.length; n += 2) {
      let o = t[n], s = t[n + 1];
      if (s >= 0) {
        t[n] = s, t[n + 1] = o;
        let l = n >> 1;
        for (; i.length < l; )
          i.push(Ct.empty);
        i.push(o ? e.slice(a, a + o) : Ct.empty);
      }
      a += o;
    }
    return new Nr(t, i);
  }
  /**
  Combine two subsequent change sets into a single set. `other`
  must start in the document produced by `this`. If `this` goes
  `docA`  `docB` and `other` represents `docB`  `docC`, the
  returned value will represent the change `docA`  `docC`.
  */
  compose(e) {
    return this.empty ? e : e.empty ? this : p7(this, e, !0);
  }
  /**
  Given another change set starting in the same document, maps this
  change set over the other, producing a new change set that can be
  applied to the document produced by applying `other`. When
  `before` is `true`, order changes as if `this` comes before
  `other`, otherwise (the default) treat `other` as coming first.
  
  Given two changes `A` and `B`, `A.compose(B.map(A))` and
  `B.compose(A.map(B, true))` will produce the same document. This
  provides a basic form of [operational
  transformation](https://en.wikipedia.org/wiki/Operational_transformation),
  and can be used for collaborative editing.
  */
  map(e, t = !1) {
    return e.empty ? this : vI(this, e, t, !0);
  }
  /**
  Iterate over the changed ranges in the document, calling `f` for
  each, with the range in the original document (`fromA`-`toA`)
  and the range that replaces it in the new document
  (`fromB`-`toB`).
  
  When `individual` is true, adjacent changes are reported
  separately.
  */
  iterChanges(e, t = !1) {
    gI(this, e, t);
  }
  /**
  Get a [change description](https://codemirror.net/6/docs/ref/#state.ChangeDesc) for this change
  set.
  */
  get desc() {
    return Oo.create(this.sections);
  }
  /**
  @internal
  */
  filter(e) {
    let t = [], i = [], n = [], a = new Kg(this);
    e:
      for (let o = 0, s = 0; ; ) {
        let l = o == e.length ? 1e9 : e[o++];
        for (; s < l || s == l && a.len == 0; ) {
          if (a.done)
            break e;
          let c = Math.min(a.len, l - s);
          di(n, c, -1);
          let h = a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0;
          di(t, c, h), h > 0 && sl(i, t, a.text), a.forward(c), s += c;
        }
        let u = e[o++];
        for (; s < u; ) {
          if (a.done)
            break e;
          let c = Math.min(a.len, u - s);
          di(t, c, -1), di(n, c, a.ins == -1 ? -1 : a.off == 0 ? a.ins : 0), a.forward(c), s += c;
        }
      }
    return {
      changes: new Nr(t, i),
      filtered: Oo.create(n)
    };
  }
  /**
  Serialize this change set to a JSON-representable value.
  */
  toJSON() {
    let e = [];
    for (let t = 0; t < this.sections.length; t += 2) {
      let i = this.sections[t], n = this.sections[t + 1];
      n < 0 ? e.push(i) : n == 0 ? e.push([i]) : e.push([i].concat(this.inserted[t >> 1].toJSON()));
    }
    return e;
  }
  /**
  Create a change set for the given changes, for a document of the
  given length, using `lineSep` as line separator.
  */
  static of(e, t, i) {
    let n = [], a = [], o = 0, s = null;
    function l(c = !1) {
      if (!c && !n.length)
        return;
      o < t && di(n, t - o, -1);
      let h = new Nr(n, a);
      s = s ? s.compose(h.map(s)) : h, n = [], a = [], o = 0;
    }
    function u(c) {
      if (Array.isArray(c))
        for (let h of c)
          u(h);
      else if (c instanceof Nr) {
        if (c.length != t)
          throw new RangeError(`Mismatched change set length (got ${c.length}, expected ${t})`);
        l(), s = s ? s.compose(c.map(s)) : c;
      } else {
        let { from: h, to: f = h, insert: d } = c;
        if (h > f || h < 0 || f > t)
          throw new RangeError(`Invalid change range ${h} to ${f} (in doc of length ${t})`);
        let p = d ? typeof d == "string" ? Ct.of(d.split(i || pI)) : d : Ct.empty, g = p.length;
        if (h == f && g == 0)
          return;
        h < o && l(), h > o && di(n, h - o, -1), di(n, f - h, g), sl(a, n, p), o = f;
      }
    }
    return u(e), l(!s), s;
  }
  /**
  Create an empty changeset of the given length.
  */
  static empty(e) {
    return new Nr(e ? [e, -1] : [], []);
  }
  /**
  Create a changeset from its JSON representation (as produced by
  [`toJSON`](https://codemirror.net/6/docs/ref/#state.ChangeSet.toJSON).
  */
  static fromJSON(e) {
    if (!Array.isArray(e))
      throw new RangeError("Invalid JSON representation of ChangeSet");
    let t = [], i = [];
    for (let n = 0; n < e.length; n++) {
      let a = e[n];
      if (typeof a == "number")
        t.push(a, -1);
      else {
        if (!Array.isArray(a) || typeof a[0] != "number" || a.some((o, s) => s && typeof o != "string"))
          throw new RangeError("Invalid JSON representation of ChangeSet");
        if (a.length == 1)
          t.push(a[0], 0);
        else {
          for (; i.length < n; )
            i.push(Ct.empty);
          i[n] = Ct.of(a.slice(1)), t.push(a[0], i[n].length);
        }
      }
    }
    return new Nr(t, i);
  }
  /**
  @internal
  */
  static createSet(e, t) {
    return new Nr(e, t);
  }
}
function di(r, e, t, i = !1) {
  if (e == 0 && t <= 0)
    return;
  let n = r.length - 2;
  n >= 0 && t <= 0 && t == r[n + 1] ? r[n] += e : e == 0 && r[n] == 0 ? r[n + 1] += t : i ? (r[n] += e, r[n + 1] += t) : r.push(e, t);
}
function sl(r, e, t) {
  if (t.length == 0)
    return;
  let i = e.length - 2 >> 1;
  if (i < r.length)
    r[r.length - 1] = r[r.length - 1].append(t);
  else {
    for (; r.length < i; )
      r.push(Ct.empty);
    r.push(t);
  }
}
function gI(r, e, t) {
  let i = r.inserted;
  for (let n = 0, a = 0, o = 0; o < r.sections.length; ) {
    let s = r.sections[o++], l = r.sections[o++];
    if (l < 0)
      n += s, a += s;
    else {
      let u = n, c = a, h = Ct.empty;
      for (; u += s, c += l, l && i && (h = h.append(i[o - 2 >> 1])), !(t || o == r.sections.length || r.sections[o + 1] < 0); )
        s = r.sections[o++], l = r.sections[o++];
      e(n, u, a, c, h), n = u, a = c;
    }
  }
}
function vI(r, e, t, i = !1) {
  let n = [], a = i ? [] : null, o = new Kg(r), s = new Kg(e);
  for (let l = -1; ; )
    if (o.ins == -1 && s.ins == -1) {
      let u = Math.min(o.len, s.len);
      di(n, u, -1), o.forward(u), s.forward(u);
    } else if (s.ins >= 0 && (o.ins < 0 || l == o.i || o.off == 0 && (s.len < o.len || s.len == o.len && !t))) {
      let u = s.len;
      for (di(n, s.ins, -1); u; ) {
        let c = Math.min(o.len, u);
        o.ins >= 0 && l < o.i && o.len <= c && (di(n, 0, o.ins), a && sl(a, n, o.text), l = o.i), o.forward(c), u -= c;
      }
      s.next();
    } else if (o.ins >= 0) {
      let u = 0, c = o.len;
      for (; c; )
        if (s.ins == -1) {
          let h = Math.min(c, s.len);
          u += h, c -= h, s.forward(h);
        } else if (s.ins == 0 && s.len < c)
          c -= s.len, s.next();
        else
          break;
      di(n, u, l < o.i ? o.ins : 0), a && l < o.i && sl(a, n, o.text), l = o.i, o.forward(o.len - c);
    } else {
      if (o.done && s.done)
        return a ? Nr.createSet(n, a) : Oo.create(n);
      throw new Error("Mismatched change set lengths");
    }
}
function p7(r, e, t = !1) {
  let i = [], n = t ? [] : null, a = new Kg(r), o = new Kg(e);
  for (let s = !1; ; ) {
    if (a.done && o.done)
      return n ? Nr.createSet(i, n) : Oo.create(i);
    if (a.ins == 0)
      di(i, a.len, 0, s), a.next();
    else if (o.len == 0 && !o.done)
      di(i, 0, o.ins, s), n && sl(n, i, o.text), o.next();
    else {
      if (a.done || o.done)
        throw new Error("Mismatched change set lengths");
      {
        let l = Math.min(a.len2, o.len), u = i.length;
        if (a.ins == -1) {
          let c = o.ins == -1 ? -1 : o.off ? 0 : o.ins;
          di(i, l, c, s), n && c && sl(n, i, o.text);
        } else
          o.ins == -1 ? (di(i, a.off ? 0 : a.len, l, s), n && sl(n, i, a.textBit(l))) : (di(i, a.off ? 0 : a.len, o.off ? 0 : o.ins, s), n && !o.off && sl(n, i, o.text));
        s = (a.ins > l || o.ins >= 0 && o.len > l) && (s || i.length > u), a.forward2(l), o.forward(l);
      }
    }
  }
}
class Kg {
  constructor(e) {
    this.set = e, this.i = 0, this.next();
  }
  next() {
    let { sections: e } = this.set;
    this.i < e.length ? (this.len = e[this.i++], this.ins = e[this.i++]) : (this.len = 0, this.ins = -2), this.off = 0;
  }
  get done() {
    return this.ins == -2;
  }
  get len2() {
    return this.ins < 0 ? this.len : this.ins;
  }
  get text() {
    let { inserted: e } = this.set, t = this.i - 2 >> 1;
    return t >= e.length ? Ct.empty : e[t];
  }
  textBit(e) {
    let { inserted: t } = this.set, i = this.i - 2 >> 1;
    return i >= t.length && !e ? Ct.empty : t[i].slice(this.off, e == null ? void 0 : this.off + e);
  }
  forward(e) {
    e == this.len ? this.next() : (this.len -= e, this.off += e);
  }
  forward2(e) {
    this.ins == -1 ? this.forward(e) : e == this.ins ? this.next() : (this.ins -= e, this.off += e);
  }
}
class tc {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.flags = i;
  }
  /**
  The anchor of the rangethe side that doesn't move when you
  extend it.
  */
  get anchor() {
    return this.flags & 16 ? this.to : this.from;
  }
  /**
  The head of the range, which is moved when the range is
  [extended](https://codemirror.net/6/docs/ref/#state.SelectionRange.extend).
  */
  get head() {
    return this.flags & 16 ? this.from : this.to;
  }
  /**
  True when `anchor` and `head` are at the same position.
  */
  get empty() {
    return this.from == this.to;
  }
  /**
  If this is a cursor that is explicitly associated with the
  character on one of its sides, this returns the side. -1 means
  the character before its position, 1 the character after, and 0
  means no association.
  */
  get assoc() {
    return this.flags & 4 ? -1 : this.flags & 8 ? 1 : 0;
  }
  /**
  The bidirectional text level associated with this cursor, if
  any.
  */
  get bidiLevel() {
    let e = this.flags & 3;
    return e == 3 ? null : e;
  }
  /**
  The goal column (stored vertical offset) associated with a
  cursor. This is used to preserve the vertical position when
  [moving](https://codemirror.net/6/docs/ref/#view.EditorView.moveVertically) across
  lines of different length.
  */
  get goalColumn() {
    let e = this.flags >> 5;
    return e == 33554431 ? void 0 : e;
  }
  /**
  Map this range through a change, producing a valid range in the
  updated document.
  */
  map(e, t = -1) {
    let i, n;
    return this.empty ? i = n = e.mapPos(this.from, t) : (i = e.mapPos(this.from, 1), n = e.mapPos(this.to, -1)), i == this.from && n == this.to ? this : new tc(i, n, this.flags);
  }
  /**
  Extend this range to cover at least `from` to `to`.
  */
  extend(e, t = e) {
    if (e <= this.anchor && t >= this.anchor)
      return Z.range(e, t);
    let i = Math.abs(e - this.anchor) > Math.abs(t - this.anchor) ? e : t;
    return Z.range(this.anchor, i);
  }
  /**
  Compare this range to another range.
  */
  eq(e) {
    return this.anchor == e.anchor && this.head == e.head;
  }
  /**
  Return a JSON-serializable object representing the range.
  */
  toJSON() {
    return { anchor: this.anchor, head: this.head };
  }
  /**
  Convert a JSON representation of a range to a `SelectionRange`
  instance.
  */
  static fromJSON(e) {
    if (!e || typeof e.anchor != "number" || typeof e.head != "number")
      throw new RangeError("Invalid JSON representation for SelectionRange");
    return Z.range(e.anchor, e.head);
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new tc(e, t, i);
  }
}
class Z {
  constructor(e, t) {
    this.ranges = e, this.mainIndex = t;
  }
  /**
  Map a selection through a change. Used to adjust the selection
  position for changes.
  */
  map(e, t = -1) {
    return e.empty ? this : Z.create(this.ranges.map((i) => i.map(e, t)), this.mainIndex);
  }
  /**
  Compare this selection to another selection.
  */
  eq(e) {
    if (this.ranges.length != e.ranges.length || this.mainIndex != e.mainIndex)
      return !1;
    for (let t = 0; t < this.ranges.length; t++)
      if (!this.ranges[t].eq(e.ranges[t]))
        return !1;
    return !0;
  }
  /**
  Get the primary selection range. Usually, you should make sure
  your code applies to _all_ ranges, by using methods like
  [`changeByRange`](https://codemirror.net/6/docs/ref/#state.EditorState.changeByRange).
  */
  get main() {
    return this.ranges[this.mainIndex];
  }
  /**
  Make sure the selection only has one range. Returns a selection
  holding only the main range from this selection.
  */
  asSingle() {
    return this.ranges.length == 1 ? this : new Z([this.main], 0);
  }
  /**
  Extend this selection with an extra range.
  */
  addRange(e, t = !0) {
    return Z.create([e].concat(this.ranges), t ? 0 : this.mainIndex + 1);
  }
  /**
  Replace a given range with another range, and then normalize the
  selection to merge and sort ranges if necessary.
  */
  replaceRange(e, t = this.mainIndex) {
    let i = this.ranges.slice();
    return i[t] = e, Z.create(i, this.mainIndex);
  }
  /**
  Convert this selection to an object that can be serialized to
  JSON.
  */
  toJSON() {
    return { ranges: this.ranges.map((e) => e.toJSON()), main: this.mainIndex };
  }
  /**
  Create a selection from a JSON representation.
  */
  static fromJSON(e) {
    if (!e || !Array.isArray(e.ranges) || typeof e.main != "number" || e.main >= e.ranges.length)
      throw new RangeError("Invalid JSON representation for EditorSelection");
    return new Z(e.ranges.map((t) => tc.fromJSON(t)), e.main);
  }
  /**
  Create a selection holding a single range.
  */
  static single(e, t = e) {
    return new Z([Z.range(e, t)], 0);
  }
  /**
  Sort and merge the given set of ranges, creating a valid
  selection.
  */
  static create(e, t = 0) {
    if (e.length == 0)
      throw new RangeError("A selection needs at least one range");
    for (let i = 0, n = 0; n < e.length; n++) {
      let a = e[n];
      if (a.empty ? a.from <= i : a.from < i)
        return Z.normalized(e.slice(), t);
      i = a.to;
    }
    return new Z(e, t);
  }
  /**
  Create a cursor selection range at the given position. You can
  safely ignore the optional arguments in most situations.
  */
  static cursor(e, t = 0, i, n) {
    return tc.create(e, e, (t == 0 ? 0 : t < 0 ? 4 : 8) | (i == null ? 3 : Math.min(2, i)) | (n ?? 33554431) << 5);
  }
  /**
  Create a selection range.
  */
  static range(e, t, i, n) {
    let a = (i ?? 33554431) << 5 | (n == null ? 3 : Math.min(2, n));
    return t < e ? tc.create(t, e, 24 | a) : tc.create(e, t, (t > e ? 4 : 0) | a);
  }
  /**
  @internal
  */
  static normalized(e, t = 0) {
    let i = e[t];
    e.sort((n, a) => n.from - a.from), t = e.indexOf(i);
    for (let n = 1; n < e.length; n++) {
      let a = e[n], o = e[n - 1];
      if (a.empty ? a.from <= o.to : a.from < o.to) {
        let s = o.from, l = Math.max(a.to, o.to);
        n <= t && t--, e.splice(--n, 2, a.anchor > a.head ? Z.range(l, s) : Z.range(s, l));
      }
    }
    return new Z(e, t);
  }
}
function g7(r, e) {
  for (let t of r.ranges)
    if (t.to > e)
      throw new RangeError("Selection points outside of document");
}
let Px = 0;
class Ce {
  constructor(e, t, i, n, a) {
    this.combine = e, this.compareInput = t, this.compare = i, this.isStatic = n, this.id = Px++, this.default = e([]), this.extensions = typeof a == "function" ? a(this) : a;
  }
  /**
  Define a new facet.
  */
  static define(e = {}) {
    return new Ce(e.combine || ((t) => t), e.compareInput || ((t, i) => t === i), e.compare || (e.combine ? (t, i) => t === i : Lx), !!e.static, e.enables);
  }
  /**
  Returns an extension that adds the given value to this facet.
  */
  of(e) {
    return new cE([], this, 0, e);
  }
  /**
  Create an extension that computes a value for the facet from a
  state. You must take care to declare the parts of the state that
  this value depends on, since your function is only called again
  for a new state when one of those parts changed.
  
  In cases where your value depends only on a single field, you'll
  want to use the [`from`](https://codemirror.net/6/docs/ref/#state.Facet.from) method instead.
  */
  compute(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new cE(e, this, 1, t);
  }
  /**
  Create an extension that computes zero or more values for this
  facet from a state.
  */
  computeN(e, t) {
    if (this.isStatic)
      throw new Error("Can't compute a static facet");
    return new cE(e, this, 2, t);
  }
  from(e, t) {
    return t || (t = (i) => i), this.compute([e], (i) => t(i.field(e)));
  }
}
function Lx(r, e) {
  return r == e || r.length == e.length && r.every((t, i) => t === e[i]);
}
class cE {
  constructor(e, t, i, n) {
    this.dependencies = e, this.facet = t, this.type = i, this.value = n, this.id = Px++;
  }
  dynamicSlot(e) {
    var t;
    let i = this.value, n = this.facet.compareInput, a = this.id, o = e[a] >> 1, s = this.type == 2, l = !1, u = !1, c = [];
    for (let h of this.dependencies)
      h == "doc" ? l = !0 : h == "selection" ? u = !0 : ((t = e[h.id]) !== null && t !== void 0 ? t : 1) & 1 || c.push(e[h.id]);
    return {
      create(h) {
        return h.values[o] = i(h), 1;
      },
      update(h, f) {
        if (l && f.docChanged || u && (f.docChanged || f.selection) || OI(h, c)) {
          let d = i(h);
          if (s ? !bV(d, h.values[o], n) : !n(d, h.values[o]))
            return h.values[o] = d, 1;
        }
        return 0;
      },
      reconfigure: (h, f) => {
        let d, p = f.config.address[a];
        if (p != null) {
          let g = jb(f, p);
          if (this.dependencies.every((v) => v instanceof Ce ? f.facet(v) === h.facet(v) : v instanceof Br ? f.field(v, !1) == h.field(v, !1) : !0) || (s ? bV(d = i(h), g, n) : n(d = i(h), g)))
            return h.values[o] = g, 0;
        } else
          d = i(h);
        return h.values[o] = d, 1;
      }
    };
  }
}
function bV(r, e, t) {
  if (r.length != e.length)
    return !1;
  for (let i = 0; i < r.length; i++)
    if (!t(r[i], e[i]))
      return !1;
  return !0;
}
function OI(r, e) {
  let t = !1;
  for (let i of e)
    ng(r, i) & 1 && (t = !0);
  return t;
}
function sIe(r, e, t) {
  let i = t.map((l) => r[l.id]), n = t.map((l) => l.type), a = i.filter((l) => !(l & 1)), o = r[e.id] >> 1;
  function s(l) {
    let u = [];
    for (let c = 0; c < i.length; c++) {
      let h = jb(l, i[c]);
      if (n[c] == 2)
        for (let f of h)
          u.push(f);
      else
        u.push(h);
    }
    return e.combine(u);
  }
  return {
    create(l) {
      for (let u of i)
        ng(l, u);
      return l.values[o] = s(l), 1;
    },
    update(l, u) {
      if (!OI(l, a))
        return 0;
      let c = s(l);
      return e.compare(c, l.values[o]) ? 0 : (l.values[o] = c, 1);
    },
    reconfigure(l, u) {
      let c = OI(l, i), h = u.config.facets[e.id], f = u.facet(e);
      if (h && !c && Lx(t, h))
        return l.values[o] = f, 0;
      let d = s(l);
      return e.compare(d, f) ? (l.values[o] = f, 0) : (l.values[o] = d, 1);
    }
  };
}
const SV = /* @__PURE__ */ Ce.define({ static: !0 });
class Br {
  constructor(e, t, i, n, a) {
    this.id = e, this.createF = t, this.updateF = i, this.compareF = n, this.spec = a, this.provides = void 0;
  }
  /**
  Define a state field.
  */
  static define(e) {
    let t = new Br(Px++, e.create, e.update, e.compare || ((i, n) => i === n), e);
    return e.provide && (t.provides = e.provide(t)), t;
  }
  create(e) {
    let t = e.facet(SV).find((i) => i.field == this);
    return ((t == null ? void 0 : t.create) || this.createF)(e);
  }
  /**
  @internal
  */
  slot(e) {
    let t = e[this.id] >> 1;
    return {
      create: (i) => (i.values[t] = this.create(i), 1),
      update: (i, n) => {
        let a = i.values[t], o = this.updateF(a, n);
        return this.compareF(a, o) ? 0 : (i.values[t] = o, 1);
      },
      reconfigure: (i, n) => n.config.address[this.id] != null ? (i.values[t] = n.field(this), 0) : (i.values[t] = this.create(i), 1)
    };
  }
  /**
  Returns an extension that enables this field and overrides the
  way it is initialized. Can be useful when you need to provide a
  non-default starting value for the field.
  */
  init(e) {
    return [this, SV.of({ field: this, create: e })];
  }
  /**
  State field instances can be used as
  [`Extension`](https://codemirror.net/6/docs/ref/#state.Extension) values to enable the field in a
  given state.
  */
  get extension() {
    return this;
  }
}
const Gu = { lowest: 4, low: 3, default: 2, high: 1, highest: 0 };
function ep(r) {
  return (e) => new v7(e, r);
}
const th = {
  /**
  The highest precedence level, for extensions that should end up
  near the start of the precedence ordering.
  */
  highest: /* @__PURE__ */ ep(Gu.highest),
  /**
  A higher-than-default precedence, for extensions that should
  come before those with default precedence.
  */
  high: /* @__PURE__ */ ep(Gu.high),
  /**
  The default precedence, which is also used for extensions
  without an explicit precedence.
  */
  default: /* @__PURE__ */ ep(Gu.default),
  /**
  A lower-than-default precedence.
  */
  low: /* @__PURE__ */ ep(Gu.low),
  /**
  The lowest precedence level. Meant for things that should end up
  near the end of the extension order.
  */
  lowest: /* @__PURE__ */ ep(Gu.lowest)
};
class v7 {
  constructor(e, t) {
    this.inner = e, this.prec = t;
  }
}
class HT {
  /**
  Create an instance of this compartment to add to your [state
  configuration](https://codemirror.net/6/docs/ref/#state.EditorStateConfig.extensions).
  */
  of(e) {
    return new mI(this, e);
  }
  /**
  Create an [effect](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) that
  reconfigures this compartment.
  */
  reconfigure(e) {
    return HT.reconfigure.of({ compartment: this, extension: e });
  }
  /**
  Get the current content of the compartment in the state, or
  `undefined` if it isn't present.
  */
  get(e) {
    return e.config.compartments.get(this);
  }
}
class mI {
  constructor(e, t) {
    this.compartment = e, this.inner = t;
  }
}
class qb {
  constructor(e, t, i, n, a, o) {
    for (this.base = e, this.compartments = t, this.dynamicSlots = i, this.address = n, this.staticValues = a, this.facets = o, this.statusTemplate = []; this.statusTemplate.length < i.length; )
      this.statusTemplate.push(
        0
        /* SlotStatus.Unresolved */
      );
  }
  staticFacet(e) {
    let t = this.address[e.id];
    return t == null ? e.default : this.staticValues[t >> 1];
  }
  static resolve(e, t, i) {
    let n = [], a = /* @__PURE__ */ Object.create(null), o = /* @__PURE__ */ new Map();
    for (let f of lIe(e, t, o))
      f instanceof Br ? n.push(f) : (a[f.facet.id] || (a[f.facet.id] = [])).push(f);
    let s = /* @__PURE__ */ Object.create(null), l = [], u = [];
    for (let f of n)
      s[f.id] = u.length << 1, u.push((d) => f.slot(d));
    let c = i == null ? void 0 : i.config.facets;
    for (let f in a) {
      let d = a[f], p = d[0].facet, g = c && c[f] || [];
      if (d.every(
        (v) => v.type == 0
        /* Provider.Static */
      ))
        if (s[p.id] = l.length << 1 | 1, Lx(g, d))
          l.push(i.facet(p));
        else {
          let v = p.combine(d.map((O) => O.value));
          l.push(i && p.compare(v, i.facet(p)) ? i.facet(p) : v);
        }
      else {
        for (let v of d)
          v.type == 0 ? (s[v.id] = l.length << 1 | 1, l.push(v.value)) : (s[v.id] = u.length << 1, u.push((O) => v.dynamicSlot(O)));
        s[p.id] = u.length << 1, u.push((v) => sIe(v, p, d));
      }
    }
    let h = u.map((f) => f(s));
    return new qb(e, o, h, s, l, a);
  }
}
function lIe(r, e, t) {
  let i = [[], [], [], [], []], n = /* @__PURE__ */ new Map();
  function a(o, s) {
    let l = n.get(o);
    if (l != null) {
      if (l <= s)
        return;
      let u = i[l].indexOf(o);
      u > -1 && i[l].splice(u, 1), o instanceof mI && t.delete(o.compartment);
    }
    if (n.set(o, s), Array.isArray(o))
      for (let u of o)
        a(u, s);
    else if (o instanceof mI) {
      if (t.has(o.compartment))
        throw new RangeError("Duplicate use of compartment in extensions");
      let u = e.get(o.compartment) || o.inner;
      t.set(o.compartment, u), a(u, s);
    } else if (o instanceof v7)
      a(o.inner, o.prec);
    else if (o instanceof Br)
      i[s].push(o), o.provides && a(o.provides, s);
    else if (o instanceof cE)
      i[s].push(o), o.facet.extensions && a(o.facet.extensions, Gu.default);
    else {
      let u = o.extension;
      if (!u)
        throw new Error(`Unrecognized extension value in extension set (${o}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);
      a(u, s);
    }
  }
  return a(r, Gu.default), i.reduce((o, s) => o.concat(s));
}
function ng(r, e) {
  if (e & 1)
    return 2;
  let t = e >> 1, i = r.status[t];
  if (i == 4)
    throw new Error("Cyclic dependency between fields and/or facets");
  if (i & 2)
    return i;
  r.status[t] = 4;
  let n = r.computeSlot(r, r.config.dynamicSlots[t]);
  return r.status[t] = 2 | n;
}
function jb(r, e) {
  return e & 1 ? r.config.staticValues[e >> 1] : r.values[e >> 1];
}
const O7 = /* @__PURE__ */ Ce.define(), m7 = /* @__PURE__ */ Ce.define({
  combine: (r) => r.some((e) => e),
  static: !0
}), E7 = /* @__PURE__ */ Ce.define({
  combine: (r) => r.length ? r[0] : void 0,
  static: !0
}), b7 = /* @__PURE__ */ Ce.define(), S7 = /* @__PURE__ */ Ce.define(), T7 = /* @__PURE__ */ Ce.define(), y7 = /* @__PURE__ */ Ce.define({
  combine: (r) => r.length ? r[0] : !1
});
class ys {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Define a new type of annotation.
  */
  static define() {
    return new uIe();
  }
}
class uIe {
  /**
  Create an instance of this annotation.
  */
  of(e) {
    return new ys(this, e);
  }
}
class cIe {
  /**
  @internal
  */
  constructor(e) {
    this.map = e;
  }
  /**
  Create a [state effect](https://codemirror.net/6/docs/ref/#state.StateEffect) instance of this
  type.
  */
  of(e) {
    return new lt(this, e);
  }
}
class lt {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.value = t;
  }
  /**
  Map this effect through a position mapping. Will return
  `undefined` when that ends up deleting the effect.
  */
  map(e) {
    let t = this.type.map(this.value, e);
    return t === void 0 ? void 0 : t == this.value ? this : new lt(this.type, t);
  }
  /**
  Tells you whether this effect object is of a given
  [type](https://codemirror.net/6/docs/ref/#state.StateEffectType).
  */
  is(e) {
    return this.type == e;
  }
  /**
  Define a new effect type. The type parameter indicates the type
  of values that his effect holds. It should be a type that
  doesn't include `undefined`, since that is used in
  [mapping](https://codemirror.net/6/docs/ref/#state.StateEffect.map) to indicate that an effect is
  removed.
  */
  static define(e = {}) {
    return new cIe(e.map || ((t) => t));
  }
  /**
  Map an array of effects through a change set.
  */
  static mapEffects(e, t) {
    if (!e.length)
      return e;
    let i = [];
    for (let n of e) {
      let a = n.map(t);
      a && i.push(a);
    }
    return i;
  }
}
lt.reconfigure = /* @__PURE__ */ lt.define();
lt.appendConfig = /* @__PURE__ */ lt.define();
class Dr {
  constructor(e, t, i, n, a, o) {
    this.startState = e, this.changes = t, this.selection = i, this.effects = n, this.annotations = a, this.scrollIntoView = o, this._doc = null, this._state = null, i && g7(i, t.newLength), a.some((s) => s.type == Dr.time) || (this.annotations = a.concat(Dr.time.of(Date.now())));
  }
  /**
  @internal
  */
  static create(e, t, i, n, a, o) {
    return new Dr(e, t, i, n, a, o);
  }
  /**
  The new document produced by the transaction. Contrary to
  [`.state`](https://codemirror.net/6/docs/ref/#state.Transaction.state)`.doc`, accessing this won't
  force the entire new state to be computed right away, so it is
  recommended that [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) use this getter
  when they need to look at the new document.
  */
  get newDoc() {
    return this._doc || (this._doc = this.changes.apply(this.startState.doc));
  }
  /**
  The new selection produced by the transaction. If
  [`this.selection`](https://codemirror.net/6/docs/ref/#state.Transaction.selection) is undefined,
  this will [map](https://codemirror.net/6/docs/ref/#state.EditorSelection.map) the start state's
  current selection through the changes made by the transaction.
  */
  get newSelection() {
    return this.selection || this.startState.selection.map(this.changes);
  }
  /**
  The new state created by the transaction. Computed on demand
  (but retained for subsequent access), so it is recommended not to
  access it in [transaction
  filters](https://codemirror.net/6/docs/ref/#state.EditorState^transactionFilter) when possible.
  */
  get state() {
    return this._state || this.startState.applyTransaction(this), this._state;
  }
  /**
  Get the value of the given annotation type, if any.
  */
  annotation(e) {
    for (let t of this.annotations)
      if (t.type == e)
        return t.value;
  }
  /**
  Indicates whether the transaction changed the document.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Indicates whether this transaction reconfigures the state
  (through a [configuration compartment](https://codemirror.net/6/docs/ref/#state.Compartment) or
  with a top-level configuration
  [effect](https://codemirror.net/6/docs/ref/#state.StateEffect^reconfigure).
  */
  get reconfigured() {
    return this.startState.config != this.state.config;
  }
  /**
  Returns true if the transaction has a [user
  event](https://codemirror.net/6/docs/ref/#state.Transaction^userEvent) annotation that is equal to
  or more specific than `event`. For example, if the transaction
  has `"select.pointer"` as user event, `"select"` and
  `"select.pointer"` will match it.
  */
  isUserEvent(e) {
    let t = this.annotation(Dr.userEvent);
    return !!(t && (t == e || t.length > e.length && t.slice(0, e.length) == e && t[e.length] == "."));
  }
}
Dr.time = /* @__PURE__ */ ys.define();
Dr.userEvent = /* @__PURE__ */ ys.define();
Dr.addToHistory = /* @__PURE__ */ ys.define();
Dr.remote = /* @__PURE__ */ ys.define();
function hIe(r, e) {
  let t = [];
  for (let i = 0, n = 0; ; ) {
    let a, o;
    if (i < r.length && (n == e.length || e[n] >= r[i]))
      a = r[i++], o = r[i++];
    else if (n < e.length)
      a = e[n++], o = e[n++];
    else
      return t;
    !t.length || t[t.length - 1] < a ? t.push(a, o) : t[t.length - 1] < o && (t[t.length - 1] = o);
  }
}
function R7(r, e, t) {
  var i;
  let n, a, o;
  return t ? (n = e.changes, a = Nr.empty(e.changes.length), o = r.changes.compose(e.changes)) : (n = e.changes.map(r.changes), a = r.changes.mapDesc(e.changes, !0), o = r.changes.compose(n)), {
    changes: o,
    selection: e.selection ? e.selection.map(a) : (i = r.selection) === null || i === void 0 ? void 0 : i.map(n),
    effects: lt.mapEffects(r.effects, n).concat(lt.mapEffects(e.effects, a)),
    annotations: r.annotations.length ? r.annotations.concat(e.annotations) : e.annotations,
    scrollIntoView: r.scrollIntoView || e.scrollIntoView
  };
}
function EI(r, e, t) {
  let i = e.selection, n = ff(e.annotations);
  return e.userEvent && (n = n.concat(Dr.userEvent.of(e.userEvent))), {
    changes: e.changes instanceof Nr ? e.changes : Nr.of(e.changes || [], t, r.facet(E7)),
    selection: i && (i instanceof Z ? i : Z.single(i.anchor, i.head)),
    effects: ff(e.effects),
    annotations: n,
    scrollIntoView: !!e.scrollIntoView
  };
}
function A7(r, e, t) {
  let i = EI(r, e.length ? e[0] : {}, r.doc.length);
  e.length && e[0].filter === !1 && (t = !1);
  for (let a = 1; a < e.length; a++) {
    e[a].filter === !1 && (t = !1);
    let o = !!e[a].sequential;
    i = R7(i, EI(r, e[a], o ? i.changes.newLength : r.doc.length), o);
  }
  let n = Dr.create(r, i.changes, i.selection, i.effects, i.annotations, i.scrollIntoView);
  return dIe(t ? fIe(n) : n);
}
function fIe(r) {
  let e = r.startState, t = !0;
  for (let n of e.facet(b7)) {
    let a = n(r);
    if (a === !1) {
      t = !1;
      break;
    }
    Array.isArray(a) && (t = t === !0 ? a : hIe(t, a));
  }
  if (t !== !0) {
    let n, a;
    if (t === !1)
      a = r.changes.invertedDesc, n = Nr.empty(e.doc.length);
    else {
      let o = r.changes.filter(t);
      n = o.changes, a = o.filtered.mapDesc(o.changes).invertedDesc;
    }
    r = Dr.create(e, n, r.selection && r.selection.map(a), lt.mapEffects(r.effects, a), r.annotations, r.scrollIntoView);
  }
  let i = e.facet(S7);
  for (let n = i.length - 1; n >= 0; n--) {
    let a = i[n](r);
    a instanceof Dr ? r = a : Array.isArray(a) && a.length == 1 && a[0] instanceof Dr ? r = a[0] : r = A7(e, ff(a), !1);
  }
  return r;
}
function dIe(r) {
  let e = r.startState, t = e.facet(T7), i = r;
  for (let n = t.length - 1; n >= 0; n--) {
    let a = t[n](r);
    a && Object.keys(a).length && (i = R7(i, EI(e, a, r.changes.newLength), !0));
  }
  return i == r ? r : Dr.create(e, r.changes, r.selection, i.effects, i.annotations, i.scrollIntoView);
}
const pIe = [];
function ff(r) {
  return r == null ? pIe : Array.isArray(r) ? r : [r];
}
var Mt = /* @__PURE__ */ function(r) {
  return r[r.Word = 0] = "Word", r[r.Space = 1] = "Space", r[r.Other = 2] = "Other", r;
}(Mt || (Mt = {}));
const gIe = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
let bI;
try {
  bI = /* @__PURE__ */ new RegExp("[\\p{Alphabetic}\\p{Number}_]", "u");
} catch {
}
function vIe(r) {
  if (bI)
    return bI.test(r);
  for (let e = 0; e < r.length; e++) {
    let t = r[e];
    if (/\w/.test(t) || t > "" && (t.toUpperCase() != t.toLowerCase() || gIe.test(t)))
      return !0;
  }
  return !1;
}
function OIe(r) {
  return (e) => {
    if (!/\S/.test(e))
      return Mt.Space;
    if (vIe(e))
      return Mt.Word;
    for (let t = 0; t < r.length; t++)
      if (e.indexOf(r[t]) > -1)
        return Mt.Word;
    return Mt.Other;
  };
}
class Rt {
  constructor(e, t, i, n, a, o) {
    this.config = e, this.doc = t, this.selection = i, this.values = n, this.status = e.statusTemplate.slice(), this.computeSlot = a, o && (o._state = this);
    for (let s = 0; s < this.config.dynamicSlots.length; s++)
      ng(this, s << 1);
    this.computeSlot = null;
  }
  field(e, t = !0) {
    let i = this.config.address[e.id];
    if (i == null) {
      if (t)
        throw new RangeError("Field is not present in this state");
      return;
    }
    return ng(this, i), jb(this, i);
  }
  /**
  Create a [transaction](https://codemirror.net/6/docs/ref/#state.Transaction) that updates this
  state. Any number of [transaction specs](https://codemirror.net/6/docs/ref/#state.TransactionSpec)
  can be passed. Unless
  [`sequential`](https://codemirror.net/6/docs/ref/#state.TransactionSpec.sequential) is set, the
  [changes](https://codemirror.net/6/docs/ref/#state.TransactionSpec.changes) (if any) of each spec
  are assumed to start in the _current_ document (not the document
  produced by previous specs), and its
  [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection) and
  [effects](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) are assumed to refer
  to the document created by its _own_ changes. The resulting
  transaction contains the combined effect of all the different
  specs. For [selection](https://codemirror.net/6/docs/ref/#state.TransactionSpec.selection), later
  specs take precedence over earlier ones.
  */
  update(...e) {
    return A7(this, e, !0);
  }
  /**
  @internal
  */
  applyTransaction(e) {
    let t = this.config, { base: i, compartments: n } = t;
    for (let o of e.effects)
      o.is(HT.reconfigure) ? (t && (n = /* @__PURE__ */ new Map(), t.compartments.forEach((s, l) => n.set(l, s)), t = null), n.set(o.value.compartment, o.value.extension)) : o.is(lt.reconfigure) ? (t = null, i = o.value) : o.is(lt.appendConfig) && (t = null, i = ff(i).concat(o.value));
    let a;
    t ? a = e.startState.values.slice() : (t = qb.resolve(i, n, this), a = new Rt(t, this.doc, this.selection, t.dynamicSlots.map(() => null), (s, l) => l.reconfigure(s, this), null).values), new Rt(t, e.newDoc, e.newSelection, a, (o, s) => s.update(o, e), e);
  }
  /**
  Create a [transaction spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec) that
  replaces every selection range with the given content.
  */
  replaceSelection(e) {
    return typeof e == "string" && (e = this.toText(e)), this.changeByRange((t) => ({
      changes: { from: t.from, to: t.to, insert: e },
      range: Z.cursor(t.from + e.length)
    }));
  }
  /**
  Create a set of changes and a new selection by running the given
  function for each range in the active selection. The function
  can return an optional set of changes (in the coordinate space
  of the start document), plus an updated range (in the coordinate
  space of the document produced by the call's own changes). This
  method will merge all the changes and ranges into a single
  changeset and selection, and return it as a [transaction
  spec](https://codemirror.net/6/docs/ref/#state.TransactionSpec), which can be passed to
  [`update`](https://codemirror.net/6/docs/ref/#state.EditorState.update).
  */
  changeByRange(e) {
    let t = this.selection, i = e(t.ranges[0]), n = this.changes(i.changes), a = [i.range], o = ff(i.effects);
    for (let s = 1; s < t.ranges.length; s++) {
      let l = e(t.ranges[s]), u = this.changes(l.changes), c = u.map(n);
      for (let f = 0; f < s; f++)
        a[f] = a[f].map(c);
      let h = n.mapDesc(u, !0);
      a.push(l.range.map(h)), n = n.compose(c), o = lt.mapEffects(o, c).concat(lt.mapEffects(ff(l.effects), h));
    }
    return {
      changes: n,
      selection: Z.create(a, t.mainIndex),
      effects: o
    };
  }
  /**
  Create a [change set](https://codemirror.net/6/docs/ref/#state.ChangeSet) from the given change
  description, taking the state's document length and line
  separator into account.
  */
  changes(e = []) {
    return e instanceof Nr ? e : Nr.of(e, this.doc.length, this.facet(Rt.lineSeparator));
  }
  /**
  Using the state's [line
  separator](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator), create a
  [`Text`](https://codemirror.net/6/docs/ref/#state.Text) instance from the given string.
  */
  toText(e) {
    return Ct.of(e.split(this.facet(Rt.lineSeparator) || pI));
  }
  /**
  Return the given range of the document as a string.
  */
  sliceDoc(e = 0, t = this.doc.length) {
    return this.doc.sliceString(e, t, this.lineBreak);
  }
  /**
  Get the value of a state [facet](https://codemirror.net/6/docs/ref/#state.Facet).
  */
  facet(e) {
    let t = this.config.address[e.id];
    return t == null ? e.default : (ng(this, t), jb(this, t));
  }
  /**
  Convert this state to a JSON-serializable object. When custom
  fields should be serialized, you can pass them in as an object
  mapping property names (in the resulting object, which should
  not use `doc` or `selection`) to fields.
  */
  toJSON(e) {
    let t = {
      doc: this.sliceDoc(),
      selection: this.selection.toJSON()
    };
    if (e)
      for (let i in e) {
        let n = e[i];
        n instanceof Br && this.config.address[n.id] != null && (t[i] = n.spec.toJSON(this.field(e[i]), this));
      }
    return t;
  }
  /**
  Deserialize a state from its JSON representation. When custom
  fields should be deserialized, pass the same object you passed
  to [`toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) when serializing as
  third argument.
  */
  static fromJSON(e, t = {}, i) {
    if (!e || typeof e.doc != "string")
      throw new RangeError("Invalid JSON representation for EditorState");
    let n = [];
    if (i) {
      for (let a in i)
        if (Object.prototype.hasOwnProperty.call(e, a)) {
          let o = i[a], s = e[a];
          n.push(o.init((l) => o.spec.fromJSON(s, l)));
        }
    }
    return Rt.create({
      doc: e.doc,
      selection: Z.fromJSON(e.selection),
      extensions: t.extensions ? n.concat([t.extensions]) : n
    });
  }
  /**
  Create a new state. You'll usually only need this when
  initializing an editorupdated states are created by applying
  transactions.
  */
  static create(e = {}) {
    let t = qb.resolve(e.extensions || [], /* @__PURE__ */ new Map()), i = e.doc instanceof Ct ? e.doc : Ct.of((e.doc || "").split(t.staticFacet(Rt.lineSeparator) || pI)), n = e.selection ? e.selection instanceof Z ? e.selection : Z.single(e.selection.anchor, e.selection.head) : Z.single(0);
    return g7(n, i.length), t.staticFacet(m7) || (n = n.asSingle()), new Rt(t, i, n, t.dynamicSlots.map(() => null), (a, o) => o.create(a), null);
  }
  /**
  The size (in columns) of a tab in the document, determined by
  the [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) facet.
  */
  get tabSize() {
    return this.facet(Rt.tabSize);
  }
  /**
  Get the proper [line-break](https://codemirror.net/6/docs/ref/#state.EditorState^lineSeparator)
  string for this state.
  */
  get lineBreak() {
    return this.facet(Rt.lineSeparator) || `
`;
  }
  /**
  Returns true when the editor is
  [configured](https://codemirror.net/6/docs/ref/#state.EditorState^readOnly) to be read-only.
  */
  get readOnly() {
    return this.facet(y7);
  }
  /**
  Look up a translation for the given phrase (via the
  [`phrases`](https://codemirror.net/6/docs/ref/#state.EditorState^phrases) facet), or return the
  original string if no translation is found.
  
  If additional arguments are passed, they will be inserted in
  place of markers like `$1` (for the first value) and `$2`, etc.
  A single `$` is equivalent to `$1`, and `$$` will produce a
  literal dollar sign.
  */
  phrase(e, ...t) {
    for (let i of this.facet(Rt.phrases))
      if (Object.prototype.hasOwnProperty.call(i, e)) {
        e = i[e];
        break;
      }
    return t.length && (e = e.replace(/\$(\$|\d*)/g, (i, n) => {
      if (n == "$")
        return "$";
      let a = +(n || 1);
      return !a || a > t.length ? i : t[a - 1];
    })), e;
  }
  /**
  Find the values for a given language data field, provided by the
  the [`languageData`](https://codemirror.net/6/docs/ref/#state.EditorState^languageData) facet.
  
  Examples of language data fields are...
  
  - [`"commentTokens"`](https://codemirror.net/6/docs/ref/#commands.CommentTokens) for specifying
    comment syntax.
  - [`"autocomplete"`](https://codemirror.net/6/docs/ref/#autocomplete.autocompletion^config.override)
    for providing language-specific completion sources.
  - [`"wordChars"`](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) for adding
    characters that should be considered part of words in this
    language.
  - [`"closeBrackets"`](https://codemirror.net/6/docs/ref/#autocomplete.CloseBracketConfig) controls
    bracket closing behavior.
  */
  languageDataAt(e, t, i = -1) {
    let n = [];
    for (let a of this.facet(O7))
      for (let o of a(this, t, i))
        Object.prototype.hasOwnProperty.call(o, e) && n.push(o[e]);
    return n;
  }
  /**
  Return a function that can categorize strings (expected to
  represent a single [grapheme cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak))
  into one of:
  
   - Word (contains an alphanumeric character or a character
     explicitly listed in the local language's `"wordChars"`
     language data, which should be a string)
   - Space (contains only whitespace)
   - Other (anything else)
  */
  charCategorizer(e) {
    return OIe(this.languageDataAt("wordChars", e).join(""));
  }
  /**
  Find the word at the given position, meaning the range
  containing all [word](https://codemirror.net/6/docs/ref/#state.CharCategory.Word) characters
  around it. If no word characters are adjacent to the position,
  this returns null.
  */
  wordAt(e) {
    let { text: t, from: i, length: n } = this.doc.lineAt(e), a = this.charCategorizer(e), o = e - i, s = e - i;
    for (; o > 0; ) {
      let l = vi(t, o, !1);
      if (a(t.slice(l, o)) != Mt.Word)
        break;
      o = l;
    }
    for (; s < n; ) {
      let l = vi(t, s);
      if (a(t.slice(s, l)) != Mt.Word)
        break;
      s = l;
    }
    return o == s ? null : Z.range(o + i, s + i);
  }
}
Rt.allowMultipleSelections = m7;
Rt.tabSize = /* @__PURE__ */ Ce.define({
  combine: (r) => r.length ? r[0] : 4
});
Rt.lineSeparator = E7;
Rt.readOnly = y7;
Rt.phrases = /* @__PURE__ */ Ce.define({
  compare(r, e) {
    let t = Object.keys(r), i = Object.keys(e);
    return t.length == i.length && t.every((n) => r[n] == e[n]);
  }
});
Rt.languageData = O7;
Rt.changeFilter = b7;
Rt.transactionFilter = S7;
Rt.transactionExtender = T7;
HT.reconfigure = /* @__PURE__ */ lt.define();
function Lo(r, e, t = {}) {
  let i = {};
  for (let n of r)
    for (let a of Object.keys(n)) {
      let o = n[a], s = i[a];
      if (s === void 0)
        i[a] = o;
      else if (!(s === o || o === void 0))
        if (Object.hasOwnProperty.call(t, a))
          i[a] = t[a](s, o);
        else
          throw new Error("Config merge conflict for field " + a);
    }
  for (let n in e)
    i[n] === void 0 && (i[n] = e[n]);
  return i;
}
class Mc {
  /**
  Compare this value with another value. Used when comparing
  rangesets. The default implementation compares by identity.
  Unless you are only creating a fixed number of unique instances
  of your value type, it is a good idea to implement this
  properly.
  */
  eq(e) {
    return this == e;
  }
  /**
  Create a [range](https://codemirror.net/6/docs/ref/#state.Range) with this value.
  */
  range(e, t = e) {
    return SI.create(e, t, this);
  }
}
Mc.prototype.startSide = Mc.prototype.endSide = 0;
Mc.prototype.point = !1;
Mc.prototype.mapMode = jr.TrackDel;
let SI = class _7 {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.value = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new _7(e, t, i);
  }
};
function TI(r, e) {
  return r.from - e.from || r.value.startSide - e.value.startSide;
}
class Dx {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.value = i, this.maxPoint = n;
  }
  get length() {
    return this.to[this.to.length - 1];
  }
  // Find the index of the given position and side. Use the ranges'
  // `from` pos when `end == false`, `to` when `end == true`.
  findIndex(e, t, i, n = 0) {
    let a = i ? this.to : this.from;
    for (let o = n, s = a.length; ; ) {
      if (o == s)
        return o;
      let l = o + s >> 1, u = a[l] - e || (i ? this.value[l].endSide : this.value[l].startSide) - t;
      if (l == o)
        return u >= 0 ? o : s;
      u >= 0 ? s = l : o = l + 1;
    }
  }
  between(e, t, i, n) {
    for (let a = this.findIndex(t, -1e9, !0), o = this.findIndex(i, 1e9, !1, a); a < o; a++)
      if (n(this.from[a] + e, this.to[a] + e, this.value[a]) === !1)
        return !1;
  }
  map(e, t) {
    let i = [], n = [], a = [], o = -1, s = -1;
    for (let l = 0; l < this.value.length; l++) {
      let u = this.value[l], c = this.from[l] + e, h = this.to[l] + e, f, d;
      if (c == h) {
        let p = t.mapPos(c, u.startSide, u.mapMode);
        if (p == null || (f = d = p, u.startSide != u.endSide && (d = t.mapPos(c, u.endSide), d < f)))
          continue;
      } else if (f = t.mapPos(c, u.startSide), d = t.mapPos(h, u.endSide), f > d || f == d && u.startSide > 0 && u.endSide <= 0)
        continue;
      (d - f || u.endSide - u.startSide) < 0 || (o < 0 && (o = f), u.point && (s = Math.max(s, d - f)), i.push(u), n.push(f - o), a.push(d - o));
    }
    return { mapped: i.length ? new Dx(n, a, i, s) : null, pos: o };
  }
}
class kt {
  constructor(e, t, i, n) {
    this.chunkPos = e, this.chunk = t, this.nextLayer = i, this.maxPoint = n;
  }
  /**
  @internal
  */
  static create(e, t, i, n) {
    return new kt(e, t, i, n);
  }
  /**
  @internal
  */
  get length() {
    let e = this.chunk.length - 1;
    return e < 0 ? 0 : Math.max(this.chunkEnd(e), this.nextLayer.length);
  }
  /**
  The number of ranges in the set.
  */
  get size() {
    if (this.isEmpty)
      return 0;
    let e = this.nextLayer.size;
    for (let t of this.chunk)
      e += t.value.length;
    return e;
  }
  /**
  @internal
  */
  chunkEnd(e) {
    return this.chunkPos[e] + this.chunk[e].length;
  }
  /**
  Update the range set, optionally adding new ranges or filtering
  out existing ones.
  
  (Note: The type parameter is just there as a kludge to work
  around TypeScript variance issues that prevented `RangeSet<X>`
  from being a subtype of `RangeSet<Y>` when `X` is a subtype of
  `Y`.)
  */
  update(e) {
    let { add: t = [], sort: i = !1, filterFrom: n = 0, filterTo: a = this.length } = e, o = e.filter;
    if (t.length == 0 && !o)
      return this;
    if (i && (t = t.slice().sort(TI)), this.isEmpty)
      return t.length ? kt.of(t) : this;
    let s = new C7(this, null, -1).goto(0), l = 0, u = [], c = new Ul();
    for (; s.value || l < t.length; )
      if (l < t.length && (s.from - t[l].from || s.startSide - t[l].value.startSide) >= 0) {
        let h = t[l++];
        c.addInner(h.from, h.to, h.value) || u.push(h);
      } else
        s.rangeIndex == 1 && s.chunkIndex < this.chunk.length && (l == t.length || this.chunkEnd(s.chunkIndex) < t[l].from) && (!o || n > this.chunkEnd(s.chunkIndex) || a < this.chunkPos[s.chunkIndex]) && c.addChunk(this.chunkPos[s.chunkIndex], this.chunk[s.chunkIndex]) ? s.nextChunk() : ((!o || n > s.to || a < s.from || o(s.from, s.to, s.value)) && (c.addInner(s.from, s.to, s.value) || u.push(SI.create(s.from, s.to, s.value))), s.next());
    return c.finishInner(this.nextLayer.isEmpty && !u.length ? kt.empty : this.nextLayer.update({ add: u, filter: o, filterFrom: n, filterTo: a }));
  }
  /**
  Map this range set through a set of changes, return the new set.
  */
  map(e) {
    if (e.empty || this.isEmpty)
      return this;
    let t = [], i = [], n = -1;
    for (let o = 0; o < this.chunk.length; o++) {
      let s = this.chunkPos[o], l = this.chunk[o], u = e.touchesRange(s, s + l.length);
      if (u === !1)
        n = Math.max(n, l.maxPoint), t.push(l), i.push(e.mapPos(s));
      else if (u === !0) {
        let { mapped: c, pos: h } = l.map(s, e);
        c && (n = Math.max(n, c.maxPoint), t.push(c), i.push(h));
      }
    }
    let a = this.nextLayer.map(e);
    return t.length == 0 ? a : new kt(i, t, a || kt.empty, n);
  }
  /**
  Iterate over the ranges that touch the region `from` to `to`,
  calling `f` for each. There is no guarantee that the ranges will
  be reported in any specific order. When the callback returns
  `false`, iteration stops.
  */
  between(e, t, i) {
    if (!this.isEmpty) {
      for (let n = 0; n < this.chunk.length; n++) {
        let a = this.chunkPos[n], o = this.chunk[n];
        if (t >= a && e <= a + o.length && o.between(a, e - a, t - a, i) === !1)
          return;
      }
      this.nextLayer.between(e, t, i);
    }
  }
  /**
  Iterate over the ranges in this set, in order, including all
  ranges that end at or after `from`.
  */
  iter(e = 0) {
    return Jg.from([this]).goto(e);
  }
  /**
  @internal
  */
  get isEmpty() {
    return this.nextLayer == this;
  }
  /**
  Iterate over the ranges in a collection of sets, in order,
  starting from `from`.
  */
  static iter(e, t = 0) {
    return Jg.from(e).goto(t);
  }
  /**
  Iterate over two groups of sets, calling methods on `comparator`
  to notify it of possible differences.
  */
  static compare(e, t, i, n, a = -1) {
    let o = e.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= a), s = t.filter((h) => h.maxPoint > 0 || !h.isEmpty && h.maxPoint >= a), l = TV(o, s, i), u = new tp(o, l, a), c = new tp(s, l, a);
    i.iterGaps((h, f, d) => yV(u, h, c, f, d, n)), i.empty && i.length == 0 && yV(u, 0, c, 0, 0, n);
  }
  /**
  Compare the contents of two groups of range sets, returning true
  if they are equivalent in the given range.
  */
  static eq(e, t, i = 0, n) {
    n == null && (n = 1e9 - 1);
    let a = e.filter((c) => !c.isEmpty && t.indexOf(c) < 0), o = t.filter((c) => !c.isEmpty && e.indexOf(c) < 0);
    if (a.length != o.length)
      return !1;
    if (!a.length)
      return !0;
    let s = TV(a, o), l = new tp(a, s, 0).goto(i), u = new tp(o, s, 0).goto(i);
    for (; ; ) {
      if (l.to != u.to || !yI(l.active, u.active) || l.point && (!u.point || !l.point.eq(u.point)))
        return !1;
      if (l.to > n)
        return !0;
      l.next(), u.next();
    }
  }
  /**
  Iterate over a group of range sets at the same time, notifying
  the iterator about the ranges covering every given piece of
  content. Returns the open count (see
  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#state.SpanIterator.span)) at the end
  of the iteration.
  */
  static spans(e, t, i, n, a = -1) {
    let o = new tp(e, null, a).goto(t), s = t, l = o.openStart;
    for (; ; ) {
      let u = Math.min(o.to, i);
      if (o.point) {
        let c = o.activeForPoint(o.to), h = o.pointFrom < t ? c.length + 1 : Math.min(c.length, l);
        n.point(s, u, o.point, c, h, o.pointRank), l = Math.min(o.openEnd(u), c.length);
      } else
        u > s && (n.span(s, u, o.active, l), l = o.openEnd(u));
      if (o.to > i)
        return l + (o.point && o.to > i ? 1 : 0);
      s = o.to, o.next();
    }
  }
  /**
  Create a range set for the given range or array of ranges. By
  default, this expects the ranges to be _sorted_ (by start
  position and, if two start at the same position,
  `value.startSide`). You can pass `true` as second argument to
  cause the method to sort them.
  */
  static of(e, t = !1) {
    let i = new Ul();
    for (let n of e instanceof SI ? [e] : t ? mIe(e) : e)
      i.add(n.from, n.to, n.value);
    return i.finish();
  }
}
kt.empty = /* @__PURE__ */ new kt([], [], null, -1);
function mIe(r) {
  if (r.length > 1)
    for (let e = r[0], t = 1; t < r.length; t++) {
      let i = r[t];
      if (TI(e, i) > 0)
        return r.slice().sort(TI);
      e = i;
    }
  return r;
}
kt.empty.nextLayer = kt.empty;
class Ul {
  finishChunk(e) {
    this.chunks.push(new Dx(this.from, this.to, this.value, this.maxPoint)), this.chunkPos.push(this.chunkStart), this.chunkStart = -1, this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint), this.maxPoint = -1, e && (this.from = [], this.to = [], this.value = []);
  }
  /**
  Create an empty builder.
  */
  constructor() {
    this.chunks = [], this.chunkPos = [], this.chunkStart = -1, this.last = null, this.lastFrom = -1e9, this.lastTo = -1e9, this.from = [], this.to = [], this.value = [], this.maxPoint = -1, this.setMaxPoint = -1, this.nextLayer = null;
  }
  /**
  Add a range. Ranges should be added in sorted (by `from` and
  `value.startSide`) order.
  */
  add(e, t, i) {
    this.addInner(e, t, i) || (this.nextLayer || (this.nextLayer = new Ul())).add(e, t, i);
  }
  /**
  @internal
  */
  addInner(e, t, i) {
    let n = e - this.lastTo || i.startSide - this.last.endSide;
    if (n <= 0 && (e - this.lastFrom || i.startSide - this.last.startSide) < 0)
      throw new Error("Ranges must be added sorted by `from` position and `startSide`");
    return n < 0 ? !1 : (this.from.length == 250 && this.finishChunk(!0), this.chunkStart < 0 && (this.chunkStart = e), this.from.push(e - this.chunkStart), this.to.push(t - this.chunkStart), this.last = i, this.lastFrom = e, this.lastTo = t, this.value.push(i), i.point && (this.maxPoint = Math.max(this.maxPoint, t - e)), !0);
  }
  /**
  @internal
  */
  addChunk(e, t) {
    if ((e - this.lastTo || t.value[0].startSide - this.last.endSide) < 0)
      return !1;
    this.from.length && this.finishChunk(!0), this.setMaxPoint = Math.max(this.setMaxPoint, t.maxPoint), this.chunks.push(t), this.chunkPos.push(e);
    let i = t.value.length - 1;
    return this.last = t.value[i], this.lastFrom = t.from[i] + e, this.lastTo = t.to[i] + e, !0;
  }
  /**
  Finish the range set. Returns the new set. The builder can't be
  used anymore after this has been called.
  */
  finish() {
    return this.finishInner(kt.empty);
  }
  /**
  @internal
  */
  finishInner(e) {
    if (this.from.length && this.finishChunk(!1), this.chunks.length == 0)
      return e;
    let t = kt.create(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(e) : e, this.setMaxPoint);
    return this.from = null, t;
  }
}
function TV(r, e, t) {
  let i = /* @__PURE__ */ new Map();
  for (let a of r)
    for (let o = 0; o < a.chunk.length; o++)
      a.chunk[o].maxPoint <= 0 && i.set(a.chunk[o], a.chunkPos[o]);
  let n = /* @__PURE__ */ new Set();
  for (let a of e)
    for (let o = 0; o < a.chunk.length; o++) {
      let s = i.get(a.chunk[o]);
      s != null && (t ? t.mapPos(s) : s) == a.chunkPos[o] && !(t != null && t.touchesRange(s, s + a.chunk[o].length)) && n.add(a.chunk[o]);
    }
  return n;
}
class C7 {
  constructor(e, t, i, n = 0) {
    this.layer = e, this.skip = t, this.minPoint = i, this.rank = n;
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  get endSide() {
    return this.value ? this.value.endSide : 0;
  }
  goto(e, t = -1e9) {
    return this.chunkIndex = this.rangeIndex = 0, this.gotoInner(e, t, !1), this;
  }
  gotoInner(e, t, i) {
    for (; this.chunkIndex < this.layer.chunk.length; ) {
      let n = this.layer.chunk[this.chunkIndex];
      if (!(this.skip && this.skip.has(n) || this.layer.chunkEnd(this.chunkIndex) < e || n.maxPoint < this.minPoint))
        break;
      this.chunkIndex++, i = !1;
    }
    if (this.chunkIndex < this.layer.chunk.length) {
      let n = this.layer.chunk[this.chunkIndex].findIndex(e - this.layer.chunkPos[this.chunkIndex], t, !0);
      (!i || this.rangeIndex < n) && this.setRangeIndex(n);
    }
    this.next();
  }
  forward(e, t) {
    (this.to - e || this.endSide - t) < 0 && this.gotoInner(e, t, !0);
  }
  next() {
    for (; ; )
      if (this.chunkIndex == this.layer.chunk.length) {
        this.from = this.to = 1e9, this.value = null;
        break;
      } else {
        let e = this.layer.chunkPos[this.chunkIndex], t = this.layer.chunk[this.chunkIndex], i = e + t.from[this.rangeIndex];
        if (this.from = i, this.to = e + t.to[this.rangeIndex], this.value = t.value[this.rangeIndex], this.setRangeIndex(this.rangeIndex + 1), this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)
          break;
      }
  }
  setRangeIndex(e) {
    if (e == this.layer.chunk[this.chunkIndex].value.length) {
      if (this.chunkIndex++, this.skip)
        for (; this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]); )
          this.chunkIndex++;
      this.rangeIndex = 0;
    } else
      this.rangeIndex = e;
  }
  nextChunk() {
    this.chunkIndex++, this.rangeIndex = 0, this.next();
  }
  compare(e) {
    return this.from - e.from || this.startSide - e.startSide || this.rank - e.rank || this.to - e.to || this.endSide - e.endSide;
  }
}
class Jg {
  constructor(e) {
    this.heap = e;
  }
  static from(e, t = null, i = -1) {
    let n = [];
    for (let a = 0; a < e.length; a++)
      for (let o = e[a]; !o.isEmpty; o = o.nextLayer)
        o.maxPoint >= i && n.push(new C7(o, t, i, a));
    return n.length == 1 ? n[0] : new Jg(n);
  }
  get startSide() {
    return this.value ? this.value.startSide : 0;
  }
  goto(e, t = -1e9) {
    for (let i of this.heap)
      i.goto(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      uA(this.heap, i);
    return this.next(), this;
  }
  forward(e, t) {
    for (let i of this.heap)
      i.forward(e, t);
    for (let i = this.heap.length >> 1; i >= 0; i--)
      uA(this.heap, i);
    (this.to - e || this.value.endSide - t) < 0 && this.next();
  }
  next() {
    if (this.heap.length == 0)
      this.from = this.to = 1e9, this.value = null, this.rank = -1;
    else {
      let e = this.heap[0];
      this.from = e.from, this.to = e.to, this.value = e.value, this.rank = e.rank, e.value && e.next(), uA(this.heap, 0);
    }
  }
}
function uA(r, e) {
  for (let t = r[e]; ; ) {
    let i = (e << 1) + 1;
    if (i >= r.length)
      break;
    let n = r[i];
    if (i + 1 < r.length && n.compare(r[i + 1]) >= 0 && (n = r[i + 1], i++), t.compare(n) < 0)
      break;
    r[i] = t, r[e] = n, e = i;
  }
}
class tp {
  constructor(e, t, i) {
    this.minPoint = i, this.active = [], this.activeTo = [], this.activeRank = [], this.minActive = -1, this.point = null, this.pointFrom = 0, this.pointRank = 0, this.to = -1e9, this.endSide = 0, this.openStart = -1, this.cursor = Jg.from(e, t, i);
  }
  goto(e, t = -1e9) {
    return this.cursor.goto(e, t), this.active.length = this.activeTo.length = this.activeRank.length = 0, this.minActive = -1, this.to = e, this.endSide = t, this.openStart = -1, this.next(), this;
  }
  forward(e, t) {
    for (; this.minActive > -1 && (this.activeTo[this.minActive] - e || this.active[this.minActive].endSide - t) < 0; )
      this.removeActive(this.minActive);
    this.cursor.forward(e, t);
  }
  removeActive(e) {
    vm(this.active, e), vm(this.activeTo, e), vm(this.activeRank, e), this.minActive = RV(this.active, this.activeTo);
  }
  addActive(e) {
    let t = 0, { value: i, to: n, rank: a } = this.cursor;
    for (; t < this.activeRank.length && this.activeRank[t] <= a; )
      t++;
    Om(this.active, t, i), Om(this.activeTo, t, n), Om(this.activeRank, t, a), e && Om(e, t, this.cursor.from), this.minActive = RV(this.active, this.activeTo);
  }
  // After calling this, if `this.point` != null, the next range is a
  // point. Otherwise, it's a regular range, covered by `this.active`.
  next() {
    let e = this.to, t = this.point;
    this.point = null;
    let i = this.openStart < 0 ? [] : null;
    for (; ; ) {
      let n = this.minActive;
      if (n > -1 && (this.activeTo[n] - this.cursor.from || this.active[n].endSide - this.cursor.startSide) < 0) {
        if (this.activeTo[n] > e) {
          this.to = this.activeTo[n], this.endSide = this.active[n].endSide;
          break;
        }
        this.removeActive(n), i && vm(i, n);
      } else if (this.cursor.value)
        if (this.cursor.from > e) {
          this.to = this.cursor.from, this.endSide = this.cursor.startSide;
          break;
        } else {
          let a = this.cursor.value;
          if (!a.point)
            this.addActive(i), this.cursor.next();
          else if (t && this.cursor.to == this.to && this.cursor.from < this.cursor.to)
            this.cursor.next();
          else {
            this.point = a, this.pointFrom = this.cursor.from, this.pointRank = this.cursor.rank, this.to = this.cursor.to, this.endSide = a.endSide, this.cursor.next(), this.forward(this.to, this.endSide);
            break;
          }
        }
      else {
        this.to = this.endSide = 1e9;
        break;
      }
    }
    if (i) {
      this.openStart = 0;
      for (let n = i.length - 1; n >= 0 && i[n] < e; n--)
        this.openStart++;
    }
  }
  activeForPoint(e) {
    if (!this.active.length)
      return this.active;
    let t = [];
    for (let i = this.active.length - 1; i >= 0 && !(this.activeRank[i] < this.pointRank); i--)
      (this.activeTo[i] > e || this.activeTo[i] == e && this.active[i].endSide >= this.point.endSide) && t.push(this.active[i]);
    return t.reverse();
  }
  openEnd(e) {
    let t = 0;
    for (let i = this.activeTo.length - 1; i >= 0 && this.activeTo[i] > e; i--)
      t++;
    return t;
  }
}
function yV(r, e, t, i, n, a) {
  r.goto(e), t.goto(i);
  let o = i + n, s = i, l = i - e;
  for (; ; ) {
    let u = r.to + l - t.to || r.endSide - t.endSide, c = u < 0 ? r.to + l : t.to, h = Math.min(c, o);
    if (r.point || t.point ? r.point && t.point && (r.point == t.point || r.point.eq(t.point)) && yI(r.activeForPoint(r.to), t.activeForPoint(t.to)) || a.comparePoint(s, h, r.point, t.point) : h > s && !yI(r.active, t.active) && a.compareRange(s, h, r.active, t.active), c > o)
      break;
    s = c, u <= 0 && r.next(), u >= 0 && t.next();
  }
}
function yI(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (r[t] != e[t] && !r[t].eq(e[t]))
      return !1;
  return !0;
}
function vm(r, e) {
  for (let t = e, i = r.length - 1; t < i; t++)
    r[t] = r[t + 1];
  r.pop();
}
function Om(r, e, t) {
  for (let i = r.length - 1; i >= e; i--)
    r[i + 1] = r[i];
  r[e] = t;
}
function RV(r, e) {
  let t = -1, i = 1e9;
  for (let n = 0; n < e.length; n++)
    (e[n] - i || r[n].endSide - r[t].endSide) < 0 && (t = n, i = e[n]);
  return t;
}
function Bv(r, e, t = r.length) {
  let i = 0;
  for (let n = 0; n < t; )
    r.charCodeAt(n) == 9 ? (i += e - i % e, n++) : (i++, n = vi(r, n));
  return i;
}
function RI(r, e, t, i) {
  for (let n = 0, a = 0; ; ) {
    if (a >= e)
      return n;
    if (n == r.length)
      break;
    a += r.charCodeAt(n) == 9 ? t - a % t : 1, n = vi(r, n);
  }
  return i === !0 ? -1 : r.length;
}
const AI = "", AV = typeof Symbol > "u" ? "__" + AI : Symbol.for(AI), _I = typeof Symbol > "u" ? "__styleSet" + Math.floor(Math.random() * 1e8) : Symbol("styleSet"), _V = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : {};
class $l {
  // :: (Object<Style>, ?{finish: ?(string)  string})
  // Create a style module from the given spec.
  //
  // When `finish` is given, it is called on regular (non-`@`)
  // selectors (after `&` expansion) to compute the final selector.
  constructor(e, t) {
    this.rules = [];
    let { finish: i } = t || {};
    function n(o) {
      return /^@/.test(o) ? [o] : o.split(/,\s*/);
    }
    function a(o, s, l, u) {
      let c = [], h = /^@(\w+)\b/.exec(o[0]), f = h && h[1] == "keyframes";
      if (h && s == null)
        return l.push(o[0] + ";");
      for (let d in s) {
        let p = s[d];
        if (/&/.test(d))
          a(
            d.split(/,\s*/).map((g) => o.map((v) => g.replace(/&/, v))).reduce((g, v) => g.concat(v)),
            p,
            l
          );
        else if (p && typeof p == "object") {
          if (!h)
            throw new RangeError("The value of a property (" + d + ") should be a primitive value.");
          a(n(d), p, c, f);
        } else
          p != null && c.push(d.replace(/_.*/, "").replace(/[A-Z]/g, (g) => "-" + g.toLowerCase()) + ": " + p + ";");
      }
      (c.length || f) && l.push((i && !h && !u ? o.map(i) : o).join(", ") + " {" + c.join(" ") + "}");
    }
    for (let o in e)
      a(n(o), e[o], this.rules);
  }
  // :: ()  string
  // Returns a string containing the module's CSS rules.
  getRules() {
    return this.rules.join(`
`);
  }
  // :: ()  string
  // Generate a new unique CSS class name.
  static newName() {
    let e = _V[AV] || 1;
    return _V[AV] = e + 1, AI + e.toString(36);
  }
  // :: (union<Document, ShadowRoot>, union<[StyleModule], StyleModule>)
  //
  // Mount the given set of modules in the given DOM root, which ensures
  // that the CSS rules defined by the module are available in that
  // context.
  //
  // Rules are only added to the document once per root.
  //
  // Rule order will follow the order of the modules, so that rules from
  // modules later in the array take precedence of those from earlier
  // modules. If you call this function multiple times for the same root
  // in a way that changes the order of already mounted modules, the old
  // order will be changed.
  static mount(e, t) {
    (e[_I] || new EIe(e)).mount(Array.isArray(t) ? t : [t]);
  }
}
let CV = /* @__PURE__ */ new Map();
class EIe {
  constructor(e) {
    let t = e.ownerDocument || e, i = t.defaultView;
    if (!e.head && e.adoptedStyleSheets && i.CSSStyleSheet) {
      let n = CV.get(t);
      if (n)
        return e.adoptedStyleSheets = [n.sheet, ...e.adoptedStyleSheets], e[_I] = n;
      this.sheet = new i.CSSStyleSheet(), e.adoptedStyleSheets = [this.sheet, ...e.adoptedStyleSheets], CV.set(t, this);
    } else {
      this.styleTag = t.createElement("style");
      let n = e.head || e;
      n.insertBefore(this.styleTag, n.firstChild);
    }
    this.modules = [], e[_I] = this;
  }
  mount(e) {
    let t = this.sheet, i = 0, n = 0;
    for (let a = 0; a < e.length; a++) {
      let o = e[a], s = this.modules.indexOf(o);
      if (s < n && s > -1 && (this.modules.splice(s, 1), n--, s = -1), s == -1) {
        if (this.modules.splice(n++, 0, o), t)
          for (let l = 0; l < o.rules.length; l++)
            t.insertRule(o.rules[l], i++);
      } else {
        for (; n < s; )
          i += this.modules[n++].rules.length;
        i += o.rules.length, n++;
      }
    }
    if (!t) {
      let a = "";
      for (let o = 0; o < this.modules.length; o++)
        a += this.modules[o].getRules() + `
`;
      this.styleTag.textContent = a;
    }
  }
}
var Vl = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, ev = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, bIe = typeof navigator < "u" && /Mac/.test(navigator.platform), SIe = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var qr = 0; qr < 10; qr++)
  Vl[48 + qr] = Vl[96 + qr] = String(qr);
for (var qr = 1; qr <= 24; qr++)
  Vl[qr + 111] = "F" + qr;
for (var qr = 65; qr <= 90; qr++)
  Vl[qr] = String.fromCharCode(qr + 32), ev[qr] = String.fromCharCode(qr);
for (var cA in Vl)
  ev.hasOwnProperty(cA) || (ev[cA] = Vl[cA]);
function TIe(r) {
  var e = bIe && r.metaKey && r.shiftKey && !r.ctrlKey && !r.altKey || SIe && r.shiftKey && r.key && r.key.length == 1 || r.key == "Unidentified", t = !e && r.key || (r.shiftKey ? ev : Vl)[r.keyCode] || r.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
function Kb(r) {
  let e;
  return r.nodeType == 11 ? e = r.getSelection ? r : r.ownerDocument : e = r, e.getSelection();
}
function CI(r, e) {
  return e ? r == e || r.contains(e.nodeType != 1 ? e.parentNode : e) : !1;
}
function yIe(r) {
  let e = r.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function hE(r, e) {
  if (!e.anchorNode)
    return !1;
  try {
    return CI(r, e.anchorNode);
  } catch {
    return !1;
  }
}
function tv(r) {
  return r.nodeType == 3 ? kc(r, 0, r.nodeValue.length).getClientRects() : r.nodeType == 1 ? r.getClientRects() : [];
}
function Jb(r, e, t, i) {
  return t ? IV(r, e, t, i, -1) || IV(r, e, t, i, 1) : !1;
}
function eS(r) {
  for (var e = 0; ; e++)
    if (r = r.previousSibling, !r)
      return e;
}
function IV(r, e, t, i, n) {
  for (; ; ) {
    if (r == t && e == i)
      return !0;
    if (e == (n < 0 ? 0 : Gl(r))) {
      if (r.nodeName == "DIV")
        return !1;
      let a = r.parentNode;
      if (!a || a.nodeType != 1)
        return !1;
      e = eS(r) + (n < 0 ? 0 : 1), r = a;
    } else if (r.nodeType == 1) {
      if (r = r.childNodes[e + (n < 0 ? -1 : 0)], r.nodeType == 1 && r.contentEditable == "false")
        return !1;
      e = n < 0 ? Gl(r) : 0;
    } else
      return !1;
  }
}
function Gl(r) {
  return r.nodeType == 3 ? r.nodeValue.length : r.childNodes.length;
}
function Mx(r, e) {
  let t = e ? r.left : r.right;
  return { left: t, right: t, top: r.top, bottom: r.bottom };
}
function RIe(r) {
  return {
    left: 0,
    right: r.innerWidth,
    top: 0,
    bottom: r.innerHeight
  };
}
function AIe(r, e, t, i, n, a, o, s) {
  let l = r.ownerDocument, u = l.defaultView || window;
  for (let c = r, h = !1; c && !h; )
    if (c.nodeType == 1) {
      let f, d = c == l.body;
      if (d)
        f = RIe(u);
      else {
        if (/^(fixed|sticky)$/.test(getComputedStyle(c).position) && (h = !0), c.scrollHeight <= c.clientHeight && c.scrollWidth <= c.clientWidth) {
          c = c.assignedSlot || c.parentNode;
          continue;
        }
        let v = c.getBoundingClientRect();
        f = {
          left: v.left,
          right: v.left + c.clientWidth,
          top: v.top,
          bottom: v.top + c.clientHeight
        };
      }
      let p = 0, g = 0;
      if (n == "nearest")
        e.top < f.top ? (g = -(f.top - e.top + o), t > 0 && e.bottom > f.bottom + g && (g = e.bottom - f.bottom + g + o)) : e.bottom > f.bottom && (g = e.bottom - f.bottom + o, t < 0 && e.top - g < f.top && (g = -(f.top + g - e.top + o)));
      else {
        let v = e.bottom - e.top, O = f.bottom - f.top;
        g = (n == "center" && v <= O ? e.top + v / 2 - O / 2 : n == "start" || n == "center" && t < 0 ? e.top - o : e.bottom - O + o) - f.top;
      }
      if (i == "nearest" ? e.left < f.left ? (p = -(f.left - e.left + a), t > 0 && e.right > f.right + p && (p = e.right - f.right + p + a)) : e.right > f.right && (p = e.right - f.right + a, t < 0 && e.left < f.left + p && (p = -(f.left + p - e.left + a))) : p = (i == "center" ? e.left + (e.right - e.left) / 2 - (f.right - f.left) / 2 : i == "start" == s ? e.left - a : e.right - (f.right - f.left) + a) - f.left, p || g)
        if (d)
          u.scrollBy(p, g);
        else {
          let v = 0, O = 0;
          if (g) {
            let m = c.scrollTop;
            c.scrollTop += g, O = c.scrollTop - m;
          }
          if (p) {
            let m = c.scrollLeft;
            c.scrollLeft += p, v = c.scrollLeft - m;
          }
          e = {
            left: e.left - v,
            top: e.top - O,
            right: e.right - v,
            bottom: e.bottom - O
          }, v && Math.abs(v - p) < 1 && (i = "nearest"), O && Math.abs(O - g) < 1 && (n = "nearest");
        }
      if (d)
        break;
      c = c.assignedSlot || c.parentNode;
    } else if (c.nodeType == 11)
      c = c.host;
    else
      break;
}
function _Ie(r) {
  let e = r.ownerDocument;
  for (let t = r.parentNode; t && t != e.body; )
    if (t.nodeType == 1) {
      if (t.scrollHeight > t.clientHeight || t.scrollWidth > t.clientWidth)
        return t;
      t = t.assignedSlot || t.parentNode;
    } else if (t.nodeType == 11)
      t = t.host;
    else
      break;
  return null;
}
class CIe {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  eq(e) {
    return this.anchorNode == e.anchorNode && this.anchorOffset == e.anchorOffset && this.focusNode == e.focusNode && this.focusOffset == e.focusOffset;
  }
  setRange(e) {
    let { anchorNode: t, focusNode: i } = e;
    this.set(t, Math.min(e.anchorOffset, t ? Gl(t) : 0), i, Math.min(e.focusOffset, i ? Gl(i) : 0));
  }
  set(e, t, i, n) {
    this.anchorNode = e, this.anchorOffset = t, this.focusNode = i, this.focusOffset = n;
  }
}
let Ph = null;
function I7(r) {
  if (r.setActive)
    return r.setActive();
  if (Ph)
    return r.focus(Ph);
  let e = [];
  for (let t = r; t && (e.push(t, t.scrollTop, t.scrollLeft), t != t.ownerDocument); t = t.parentNode)
    ;
  if (r.focus(Ph == null ? {
    get preventScroll() {
      return Ph = { preventScroll: !0 }, !0;
    }
  } : void 0), !Ph) {
    Ph = !1;
    for (let t = 0; t < e.length; ) {
      let i = e[t++], n = e[t++], a = e[t++];
      i.scrollTop != n && (i.scrollTop = n), i.scrollLeft != a && (i.scrollLeft = a);
    }
  }
}
let wV;
function kc(r, e, t = e) {
  let i = wV || (wV = document.createRange());
  return i.setEnd(r, t), i.setStart(r, e), i;
}
function df(r, e, t) {
  let i = { key: e, code: e, keyCode: t, which: t, cancelable: !0 }, n = new KeyboardEvent("keydown", i);
  n.synthetic = !0, r.dispatchEvent(n);
  let a = new KeyboardEvent("keyup", i);
  return a.synthetic = !0, r.dispatchEvent(a), n.defaultPrevented || a.defaultPrevented;
}
function IIe(r) {
  for (; r; ) {
    if (r && (r.nodeType == 9 || r.nodeType == 11 && r.host))
      return r;
    r = r.assignedSlot || r.parentNode;
  }
  return null;
}
function w7(r) {
  for (; r.attributes.length; )
    r.removeAttributeNode(r.attributes[0]);
}
function wIe(r, e) {
  let t = e.focusNode, i = e.focusOffset;
  if (!t || e.anchorNode != t || e.anchorOffset != i)
    return !1;
  for (i = Math.min(i, Gl(t)); ; )
    if (i) {
      if (t.nodeType != 1)
        return !1;
      let n = t.childNodes[i - 1];
      n.contentEditable == "false" ? i-- : (t = n, i = Gl(t));
    } else {
      if (t == r)
        return !0;
      i = eS(t), t = t.parentNode;
    }
}
function N7(r) {
  return r.scrollTop > Math.max(1, r.scrollHeight - r.clientHeight - 4);
}
class Mi {
  constructor(e, t, i = !0) {
    this.node = e, this.offset = t, this.precise = i;
  }
  static before(e, t) {
    return new Mi(e.parentNode, eS(e), t);
  }
  static after(e, t) {
    return new Mi(e.parentNode, eS(e) + 1, t);
  }
}
const kx = [];
class Ht {
  constructor() {
    this.parent = null, this.dom = null, this.flags = 2;
  }
  get overrideDOMText() {
    return null;
  }
  get posAtStart() {
    return this.parent ? this.parent.posBefore(this) : 0;
  }
  get posAtEnd() {
    return this.posAtStart + this.length;
  }
  posBefore(e) {
    let t = this.posAtStart;
    for (let i of this.children) {
      if (i == e)
        return t;
      t += i.length + i.breakAfter;
    }
    throw new RangeError("Invalid child in posBefore");
  }
  posAfter(e) {
    return this.posBefore(e) + e.length;
  }
  sync(e, t) {
    if (this.flags & 2) {
      let i = this.dom, n = null, a;
      for (let o of this.children) {
        if (o.flags & 7) {
          if (!o.dom && (a = n ? n.nextSibling : i.firstChild)) {
            let s = Ht.get(a);
            (!s || !s.parent && s.canReuseDOM(o)) && o.reuseDOM(a);
          }
          o.sync(e, t), o.flags &= -8;
        }
        if (a = n ? n.nextSibling : i.firstChild, t && !t.written && t.node == i && a != o.dom && (t.written = !0), o.dom.parentNode == i)
          for (; a && a != o.dom; )
            a = NV(a);
        else
          i.insertBefore(o.dom, a);
        n = o.dom;
      }
      for (a = n ? n.nextSibling : i.firstChild, a && t && t.node == i && (t.written = !0); a; )
        a = NV(a);
    } else if (this.flags & 1)
      for (let i of this.children)
        i.flags & 7 && (i.sync(e, t), i.flags &= -8);
  }
  reuseDOM(e) {
  }
  localPosFromDOM(e, t) {
    let i;
    if (e == this.dom)
      i = this.dom.childNodes[t];
    else {
      let n = Gl(e) == 0 ? 0 : t == 0 ? -1 : 1;
      for (; ; ) {
        let a = e.parentNode;
        if (a == this.dom)
          break;
        n == 0 && a.firstChild != a.lastChild && (e == a.firstChild ? n = -1 : n = 1), e = a;
      }
      n < 0 ? i = e : i = e.nextSibling;
    }
    if (i == this.dom.firstChild)
      return 0;
    for (; i && !Ht.get(i); )
      i = i.nextSibling;
    if (!i)
      return this.length;
    for (let n = 0, a = 0; ; n++) {
      let o = this.children[n];
      if (o.dom == i)
        return a;
      a += o.length + o.breakAfter;
    }
  }
  domBoundsAround(e, t, i = 0) {
    let n = -1, a = -1, o = -1, s = -1;
    for (let l = 0, u = i, c = i; l < this.children.length; l++) {
      let h = this.children[l], f = u + h.length;
      if (u < e && f > t)
        return h.domBoundsAround(e, t, u);
      if (f >= e && n == -1 && (n = l, a = u), u > t && h.dom.parentNode == this.dom) {
        o = l, s = c;
        break;
      }
      c = f, u = f + h.breakAfter;
    }
    return {
      from: a,
      to: s < 0 ? i + this.length : s,
      startDOM: (n ? this.children[n - 1].dom.nextSibling : null) || this.dom.firstChild,
      endDOM: o < this.children.length && o >= 0 ? this.children[o].dom : null
    };
  }
  markDirty(e = !1) {
    this.flags |= 2, this.markParentsDirty(e);
  }
  markParentsDirty(e) {
    for (let t = this.parent; t; t = t.parent) {
      if (e && (t.flags |= 2), t.flags & 1)
        return;
      t.flags |= 1, e = !1;
    }
  }
  setParent(e) {
    this.parent != e && (this.parent = e, this.flags & 7 && this.markParentsDirty(!0));
  }
  setDOM(e) {
    this.dom && (this.dom.cmView = null), this.dom = e, e.cmView = this;
  }
  get rootView() {
    for (let e = this; ; ) {
      let t = e.parent;
      if (!t)
        return e;
      e = t;
    }
  }
  replaceChildren(e, t, i = kx) {
    this.markDirty();
    for (let n = e; n < t; n++) {
      let a = this.children[n];
      a.parent == this && a.destroy();
    }
    this.children.splice(e, t - e, ...i);
    for (let n = 0; n < i.length; n++)
      i[n].setParent(this);
  }
  ignoreMutation(e) {
    return !1;
  }
  ignoreEvent(e) {
    return !1;
  }
  childCursor(e = this.length) {
    return new x7(this.children, e, this.children.length);
  }
  childPos(e, t = 1) {
    return this.childCursor().findPos(e, t);
  }
  toString() {
    let e = this.constructor.name.replace("View", "");
    return e + (this.children.length ? "(" + this.children.join() + ")" : this.length ? "[" + (e == "Text" ? this.text : this.length) + "]" : "") + (this.breakAfter ? "#" : "");
  }
  static get(e) {
    return e.cmView;
  }
  get isEditable() {
    return !0;
  }
  get isWidget() {
    return !1;
  }
  get isHidden() {
    return !1;
  }
  merge(e, t, i, n, a, o) {
    return !1;
  }
  become(e) {
    return !1;
  }
  canReuseDOM(e) {
    return e.constructor == this.constructor && !((this.flags | e.flags) & 8);
  }
  // When this is a zero-length view with a side, this should return a
  // number <= 0 to indicate it is before its position, or a
  // number > 0 when after its position.
  getSide() {
    return 0;
  }
  destroy() {
    this.parent = null;
  }
}
Ht.prototype.breakAfter = 0;
function NV(r) {
  let e = r.nextSibling;
  return r.parentNode.removeChild(r), e;
}
class x7 {
  constructor(e, t, i) {
    this.children = e, this.pos = t, this.i = i, this.off = 0;
  }
  findPos(e, t = 1) {
    for (; ; ) {
      if (e > this.pos || e == this.pos && (t > 0 || this.i == 0 || this.children[this.i - 1].breakAfter))
        return this.off = e - this.pos, this;
      let i = this.children[--this.i];
      this.pos -= i.length + i.breakAfter;
    }
  }
}
function P7(r, e, t, i, n, a, o, s, l) {
  let { children: u } = r, c = u.length ? u[e] : null, h = a.length ? a[a.length - 1] : null, f = h ? h.breakAfter : o;
  if (!(e == i && c && !o && !f && a.length < 2 && c.merge(t, n, a.length ? h : null, t == 0, s, l))) {
    if (i < u.length) {
      let d = u[i];
      d && n < d.length ? (e == i && (d = d.split(n), n = 0), !f && h && d.merge(0, n, h, !0, 0, l) ? a[a.length - 1] = d : (n && d.merge(0, n, null, !1, 0, l), a.push(d))) : d != null && d.breakAfter && (h ? h.breakAfter = 1 : o = 1), i++;
    }
    for (c && (c.breakAfter = o, t > 0 && (!o && a.length && c.merge(t, c.length, a[0], !1, s, 0) ? c.breakAfter = a.shift().breakAfter : (t < c.length || c.children.length && c.children[c.children.length - 1].length == 0) && c.merge(t, c.length, null, !1, s, 0), e++)); e < i && a.length; )
      if (u[i - 1].become(a[a.length - 1]))
        i--, a.pop(), l = a.length ? 0 : s;
      else if (u[e].become(a[0]))
        e++, a.shift(), s = a.length ? 0 : l;
      else
        break;
    !a.length && e && i < u.length && !u[e - 1].breakAfter && u[i].merge(0, 0, u[e - 1], !1, s, l) && e--, (e < i || a.length) && r.replaceChildren(e, i, a);
  }
}
function L7(r, e, t, i, n, a) {
  let o = r.childCursor(), { i: s, off: l } = o.findPos(t, 1), { i: u, off: c } = o.findPos(e, -1), h = e - t;
  for (let f of i)
    h += f.length;
  r.length += h, P7(r, u, c, s, l, i, 0, n, a);
}
const qh = "";
class D7 {
  constructor(e, t) {
    this.points = e, this.text = "", this.lineSeparator = t.facet(Rt.lineSeparator);
  }
  append(e) {
    this.text += e;
  }
  lineBreak() {
    this.text += qh;
  }
  readRange(e, t) {
    if (!e)
      return this;
    let i = e.parentNode;
    for (let n = e; ; ) {
      this.findPointBefore(i, n);
      let a = this.text.length;
      this.readNode(n);
      let o = n.nextSibling;
      if (o == t)
        break;
      let s = Ht.get(n), l = Ht.get(o);
      (s && l ? s.breakAfter : (s ? s.breakAfter : xV(n)) || xV(o) && (n.nodeName != "BR" || n.cmIgnore) && this.text.length > a) && this.lineBreak(), n = o;
    }
    return this.findPointBefore(i, t), this;
  }
  readTextNode(e) {
    let t = e.nodeValue;
    for (let i of this.points)
      i.node == e && (i.pos = this.text.length + Math.min(i.offset, t.length));
    for (let i = 0, n = this.lineSeparator ? null : /\r\n?|\n/g; ; ) {
      let a = -1, o = 1, s;
      if (this.lineSeparator ? (a = t.indexOf(this.lineSeparator, i), o = this.lineSeparator.length) : (s = n.exec(t)) && (a = s.index, o = s[0].length), this.append(t.slice(i, a < 0 ? t.length : a)), a < 0)
        break;
      if (this.lineBreak(), o > 1)
        for (let l of this.points)
          l.node == e && l.pos > this.text.length && (l.pos -= o - 1);
      i = a + o;
    }
  }
  readNode(e) {
    if (e.cmIgnore)
      return;
    let t = Ht.get(e), i = t && t.overrideDOMText;
    if (i != null) {
      this.findPointInside(e, i.length);
      for (let n = i.iter(); !n.next().done; )
        n.lineBreak ? this.lineBreak() : this.append(n.value);
    } else
      e.nodeType == 3 ? this.readTextNode(e) : e.nodeName == "BR" ? e.nextSibling && this.lineBreak() : e.nodeType == 1 && this.readRange(e.firstChild, null);
  }
  findPointBefore(e, t) {
    for (let i of this.points)
      i.node == e && e.childNodes[i.offset] == t && (i.pos = this.text.length);
  }
  findPointInside(e, t) {
    for (let i of this.points)
      (e.nodeType == 3 ? i.node == e : e.contains(i.node)) && (i.pos = this.text.length + Math.min(t, i.offset));
  }
}
function xV(r) {
  return r.nodeType == 1 && /^(DIV|P|LI|UL|OL|BLOCKQUOTE|DD|DT|H\d|SECTION|PRE)$/.test(r.nodeName);
}
class PV {
  constructor(e, t) {
    this.node = e, this.offset = t, this.pos = -1;
  }
}
let On = typeof navigator < "u" ? navigator : { userAgent: "", vendor: "", platform: "" }, II = typeof document < "u" ? document : { documentElement: { style: {} } };
const wI = /* @__PURE__ */ /Edge\/(\d+)/.exec(On.userAgent), M7 = /* @__PURE__ */ /MSIE \d/.test(On.userAgent), NI = /* @__PURE__ */ /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(On.userAgent), WT = !!(M7 || NI || wI), LV = !WT && /* @__PURE__ */ /gecko\/(\d+)/i.test(On.userAgent), hA = !WT && /* @__PURE__ */ /Chrome\/(\d+)/.exec(On.userAgent), DV = "webkitFontSmoothing" in II.documentElement.style, k7 = !WT && /* @__PURE__ */ /Apple Computer/.test(On.vendor), MV = k7 && (/* @__PURE__ */ /Mobile\/\w+/.test(On.userAgent) || On.maxTouchPoints > 2);
var we = {
  mac: MV || /* @__PURE__ */ /Mac/.test(On.platform),
  windows: /* @__PURE__ */ /Win/.test(On.platform),
  linux: /* @__PURE__ */ /Linux|X11/.test(On.platform),
  ie: WT,
  ie_version: M7 ? II.documentMode || 6 : NI ? +NI[1] : wI ? +wI[1] : 0,
  gecko: LV,
  gecko_version: LV ? +(/* @__PURE__ */ /Firefox\/(\d+)/.exec(On.userAgent) || [0, 0])[1] : 0,
  chrome: !!hA,
  chrome_version: hA ? +hA[1] : 0,
  ios: MV,
  android: /* @__PURE__ */ /Android\b/.test(On.userAgent),
  webkit: DV,
  safari: k7,
  webkit_version: DV ? +(/* @__PURE__ */ /\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0,
  tabSize: II.documentElement.style.tabSize != null ? "tab-size" : "-moz-tab-size"
};
const NIe = 256;
class Io extends Ht {
  constructor(e) {
    super(), this.text = e;
  }
  get length() {
    return this.text.length;
  }
  createDOM(e) {
    this.setDOM(e || document.createTextNode(this.text));
  }
  sync(e, t) {
    this.dom || this.createDOM(), this.dom.nodeValue != this.text && (t && t.node == this.dom && (t.written = !0), this.dom.nodeValue = this.text);
  }
  reuseDOM(e) {
    e.nodeType == 3 && this.createDOM(e);
  }
  merge(e, t, i) {
    return this.flags & 8 || i && (!(i instanceof Io) || this.length - (t - e) + i.length > NIe || i.flags & 8) ? !1 : (this.text = this.text.slice(0, e) + (i ? i.text : "") + this.text.slice(t), this.markDirty(), !0);
  }
  split(e) {
    let t = new Io(this.text.slice(e));
    return this.text = this.text.slice(0, e), this.markDirty(), t.flags |= this.flags & 8, t;
  }
  localPosFromDOM(e, t) {
    return e == this.dom ? t : t ? this.text.length : 0;
  }
  domAtPos(e) {
    return new Mi(this.dom, e);
  }
  domBoundsAround(e, t, i) {
    return { from: i, to: i + this.length, startDOM: this.dom, endDOM: this.dom.nextSibling };
  }
  coordsAt(e, t) {
    return xIe(this.dom, e, t);
  }
}
class ds extends Ht {
  constructor(e, t = [], i = 0) {
    super(), this.mark = e, this.children = t, this.length = i;
    for (let n of t)
      n.setParent(this);
  }
  setAttrs(e) {
    if (w7(e), this.mark.class && (e.className = this.mark.class), this.mark.attrs)
      for (let t in this.mark.attrs)
        e.setAttribute(t, this.mark.attrs[t]);
    return e;
  }
  canReuseDOM(e) {
    return super.canReuseDOM(e) && !((this.flags | e.flags) & 8);
  }
  reuseDOM(e) {
    e.nodeName == this.mark.tagName.toUpperCase() && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    this.dom ? this.flags & 4 && this.setAttrs(this.dom) : this.setDOM(this.setAttrs(document.createElement(this.mark.tagName))), super.sync(e, t);
  }
  merge(e, t, i, n, a, o) {
    return i && (!(i instanceof ds && i.mark.eq(this.mark)) || e && a <= 0 || t < this.length && o <= 0) ? !1 : (L7(this, e, t, i ? i.children : [], a - 1, o - 1), this.markDirty(), !0);
  }
  split(e) {
    let t = [], i = 0, n = -1, a = 0;
    for (let s of this.children) {
      let l = i + s.length;
      l > e && t.push(i < e ? s.split(e - i) : s), n < 0 && i >= e && (n = a), i = l, a++;
    }
    let o = this.length - e;
    return this.length = e, n > -1 && (this.children.length = n, this.markDirty()), new ds(this.mark, t, o);
  }
  domAtPos(e) {
    return Q7(this, e);
  }
  coordsAt(e, t) {
    return $7(this, e, t);
  }
}
function xIe(r, e, t) {
  let i = r.nodeValue.length;
  e > i && (e = i);
  let n = e, a = e, o = 0;
  e == 0 && t < 0 || e == i && t >= 0 ? we.chrome || we.gecko || (e ? (n--, o = 1) : a < i && (a++, o = -1)) : t < 0 ? n-- : a < i && a++;
  let s = kc(r, n, a).getClientRects();
  if (!s.length)
    return null;
  let l = s[(o ? o < 0 : t >= 0) ? 0 : s.length - 1];
  return we.safari && !o && l.width == 0 && (l = Array.prototype.find.call(s, (u) => u.width) || l), o ? Mx(l, o < 0) : l || null;
}
class rc extends Ht {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.side = i, this.prevWidget = null;
  }
  static create(e, t, i) {
    return new rc(e, t, i);
  }
  split(e) {
    let t = rc.create(this.widget, this.length - e, this.side);
    return this.length -= e, t;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  getSide() {
    return this.side;
  }
  merge(e, t, i, n, a, o) {
    return i && (!(i instanceof rc) || !this.widget.compare(i.widget) || e > 0 && a <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  become(e) {
    return e instanceof rc && e.side == this.side && this.widget.constructor == e.widget.constructor ? (this.widget.compare(e.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get overrideDOMText() {
    if (this.length == 0)
      return Ct.empty;
    let e = this;
    for (; e.parent; )
      e = e.parent;
    let { view: t } = e, i = t && t.state.doc, n = this.posAtStart;
    return i ? i.slice(n, n + this.length) : Ct.empty;
  }
  domAtPos(e) {
    return (this.length ? e == 0 : this.side > 0) ? Mi.before(this.dom) : Mi.after(this.dom, e == this.length);
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e, t) {
    let i = this.widget.coordsAt(this.dom, e, t);
    if (i)
      return i;
    let n = this.dom.getClientRects(), a = null;
    if (!n.length)
      return null;
    let o = this.side ? this.side < 0 : e > 0;
    for (let s = o ? n.length - 1 : 0; a = n[s], !(e > 0 ? s == 0 : s == n.length - 1 || a.top < a.bottom); s += o ? -1 : 1)
      ;
    return Mx(a, !o);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  get isHidden() {
    return this.widget.isHidden;
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class Uf extends Ht {
  constructor(e) {
    super(), this.side = e;
  }
  get length() {
    return 0;
  }
  merge() {
    return !1;
  }
  become(e) {
    return e instanceof Uf && e.side == this.side;
  }
  split() {
    return new Uf(this.side);
  }
  sync() {
    if (!this.dom) {
      let e = document.createElement("img");
      e.className = "cm-widgetBuffer", e.setAttribute("aria-hidden", "true"), this.setDOM(e);
    }
  }
  getSide() {
    return this.side;
  }
  domAtPos(e) {
    return this.side > 0 ? Mi.before(this.dom) : Mi.after(this.dom);
  }
  localPosFromDOM() {
    return 0;
  }
  domBoundsAround() {
    return null;
  }
  coordsAt(e) {
    return this.dom.getBoundingClientRect();
  }
  get overrideDOMText() {
    return Ct.empty;
  }
  get isHidden() {
    return !0;
  }
}
Io.prototype.children = rc.prototype.children = Uf.prototype.children = kx;
function Q7(r, e) {
  let t = r.dom, { children: i } = r, n = 0;
  for (let a = 0; n < i.length; n++) {
    let o = i[n], s = a + o.length;
    if (!(s == a && o.getSide() <= 0)) {
      if (e > a && e < s && o.dom.parentNode == t)
        return o.domAtPos(e - a);
      if (e <= a)
        break;
      a = s;
    }
  }
  for (let a = n; a > 0; a--) {
    let o = i[a - 1];
    if (o.dom.parentNode == t)
      return o.domAtPos(o.length);
  }
  for (let a = n; a < i.length; a++) {
    let o = i[a];
    if (o.dom.parentNode == t)
      return o.domAtPos(0);
  }
  return new Mi(t, 0);
}
function U7(r, e, t) {
  let i, { children: n } = r;
  t > 0 && e instanceof ds && n.length && (i = n[n.length - 1]) instanceof ds && i.mark.eq(e.mark) ? U7(i, e.children[0], t - 1) : (n.push(e), e.setParent(r)), r.length += e.length;
}
function $7(r, e, t) {
  let i = null, n = -1, a = null, o = -1;
  function s(u, c) {
    for (let h = 0, f = 0; h < u.children.length && f <= c; h++) {
      let d = u.children[h], p = f + d.length;
      p >= c && (d.children.length ? s(d, c - f) : (!a || a.isHidden && t > 0) && (p > c || f == p && d.getSide() > 0) ? (a = d, o = c - f) : (f < c || f == p && d.getSide() < 0 && !d.isHidden) && (i = d, n = c - f)), f = p;
    }
  }
  s(r, e);
  let l = (t < 0 ? i : a) || i || a;
  return l ? l.coordsAt(Math.max(0, l == i ? n : o), t) : PIe(r);
}
function PIe(r) {
  let e = r.dom.lastChild;
  if (!e)
    return r.dom.getBoundingClientRect();
  let t = tv(e);
  return t[t.length - 1] || null;
}
function xI(r, e) {
  for (let t in r)
    t == "class" && e.class ? e.class += " " + r.class : t == "style" && e.style ? e.style += ";" + r.style : e[t] = r[t];
  return e;
}
const kV = /* @__PURE__ */ Object.create(null);
function Qx(r, e, t) {
  if (r == e)
    return !0;
  r || (r = kV), e || (e = kV);
  let i = Object.keys(r), n = Object.keys(e);
  if (i.length - (t && i.indexOf(t) > -1 ? 1 : 0) != n.length - (t && n.indexOf(t) > -1 ? 1 : 0))
    return !1;
  for (let a of i)
    if (a != t && (n.indexOf(a) == -1 || r[a] !== e[a]))
      return !1;
  return !0;
}
function PI(r, e, t) {
  let i = null;
  if (e)
    for (let n in e)
      t && n in t || r.removeAttribute(i = n);
  if (t)
    for (let n in t)
      e && e[n] == t[n] || r.setAttribute(i = n, t[n]);
  return !!i;
}
function LIe(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t = 0; t < r.attributes.length; t++) {
    let i = r.attributes[t];
    e[i.name] = i.value;
  }
  return e;
}
class Rs {
  /**
  Compare this instance to another instance of the same type.
  (TypeScript can't express this, but only instances of the same
  specific class will be passed to this method.) This is used to
  avoid redrawing widgets when they are replaced by a new
  decoration of the same type. The default implementation just
  returns `false`, which will cause new instances of the widget to
  always be redrawn.
  */
  eq(e) {
    return !1;
  }
  /**
  Update a DOM element created by a widget of the same type (but
  different, non-`eq` content) to reflect this widget. May return
  true to indicate that it could update, false to indicate it
  couldn't (in which case the widget will be redrawn). The default
  implementation just returns false.
  */
  updateDOM(e, t) {
    return !1;
  }
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  The estimated height this widget will have, to be used when
  estimating the height of content that hasn't been drawn. May
  return -1 to indicate you don't know. The default implementation
  returns -1.
  */
  get estimatedHeight() {
    return -1;
  }
  /**
  For inline widgets that are displayed inline (as opposed to
  `inline-block`) and introduce line breaks (through `<br>` tags
  or textual newlines), this must indicate the amount of line
  breaks they introduce. Defaults to 0.
  */
  get lineBreaks() {
    return 0;
  }
  /**
  Can be used to configure which kinds of events inside the widget
  should be ignored by the editor. The default is to ignore all
  events.
  */
  ignoreEvent(e) {
    return !0;
  }
  /**
  Override the way screen coordinates for positions at/in the
  widget are found. `pos` will be the offset into the widget, and
  `side` the side of the position that is being queriedless than
  zero for before, greater than zero for after, and zero for
  directly at that position.
  */
  coordsAt(e, t, i) {
    return null;
  }
  /**
  @internal
  */
  get isHidden() {
    return !1;
  }
  /**
  This is called when the an instance of the widget is removed
  from the editor view.
  */
  destroy(e) {
  }
}
var ar = /* @__PURE__ */ function(r) {
  return r[r.Text = 0] = "Text", r[r.WidgetBefore = 1] = "WidgetBefore", r[r.WidgetAfter = 2] = "WidgetAfter", r[r.WidgetRange = 3] = "WidgetRange", r;
}(ar || (ar = {}));
class Xe extends Mc {
  constructor(e, t, i, n) {
    super(), this.startSide = e, this.endSide = t, this.widget = i, this.spec = n;
  }
  /**
  @internal
  */
  get heightRelevant() {
    return !1;
  }
  /**
  Create a mark decoration, which influences the styling of the
  content in its range. Nested mark decorations will cause nested
  DOM elements to be created. Nesting order is determined by
  precedence of the [facet](https://codemirror.net/6/docs/ref/#view.EditorView^decorations), with
  the higher-precedence decorations creating the inner DOM nodes.
  Such elements are split on line boundaries and on the boundaries
  of lower-precedence decorations.
  */
  static mark(e) {
    return new Fv(e);
  }
  /**
  Create a widget decoration, which displays a DOM element at the
  given position.
  */
  static widget(e) {
    let t = Math.max(-1e4, Math.min(1e4, e.side || 0)), i = !!e.block;
    return t += i && !e.inlineOrder ? t > 0 ? 3e8 : -4e8 : t > 0 ? 1e8 : -1e8, new Bl(e, t, t, i, e.widget || null, !1);
  }
  /**
  Create a replace decoration which replaces the given range with
  a widget, or simply hides it.
  */
  static replace(e) {
    let t = !!e.block, i, n;
    if (e.isBlockGap)
      i = -5e8, n = 4e8;
    else {
      let { start: a, end: o } = V7(e, t);
      i = (a ? t ? -3e8 : -1 : 5e8) - 1, n = (o ? t ? 2e8 : 1 : -6e8) + 1;
    }
    return new Bl(e, i, n, t, e.widget || null, !0);
  }
  /**
  Create a line decoration, which can add DOM attributes to the
  line starting at the given position.
  */
  static line(e) {
    return new Xv(e);
  }
  /**
  Build a [`DecorationSet`](https://codemirror.net/6/docs/ref/#view.DecorationSet) from the given
  decorated range or ranges. If the ranges aren't already sorted,
  pass `true` for `sort` to make the library sort them for you.
  */
  static set(e, t = !1) {
    return kt.of(e, t);
  }
  /**
  @internal
  */
  hasHeight() {
    return this.widget ? this.widget.estimatedHeight > -1 : !1;
  }
}
Xe.none = kt.empty;
class Fv extends Xe {
  constructor(e) {
    let { start: t, end: i } = V7(e);
    super(t ? -1 : 5e8, i ? 1 : -6e8, null, e), this.tagName = e.tagName || "span", this.class = e.class || "", this.attrs = e.attributes || null;
  }
  eq(e) {
    var t, i;
    return this == e || e instanceof Fv && this.tagName == e.tagName && (this.class || ((t = this.attrs) === null || t === void 0 ? void 0 : t.class)) == (e.class || ((i = e.attrs) === null || i === void 0 ? void 0 : i.class)) && Qx(this.attrs, e.attrs, "class");
  }
  range(e, t = e) {
    if (e >= t)
      throw new RangeError("Mark decorations may not be empty");
    return super.range(e, t);
  }
}
Fv.prototype.point = !1;
class Xv extends Xe {
  constructor(e) {
    super(-2e8, -2e8, null, e);
  }
  eq(e) {
    return e instanceof Xv && this.spec.class == e.spec.class && Qx(this.spec.attributes, e.spec.attributes);
  }
  range(e, t = e) {
    if (t != e)
      throw new RangeError("Line decoration ranges must be zero-length");
    return super.range(e, t);
  }
}
Xv.prototype.mapMode = jr.TrackBefore;
Xv.prototype.point = !0;
class Bl extends Xe {
  constructor(e, t, i, n, a, o) {
    super(t, i, a, e), this.block = n, this.isReplace = o, this.mapMode = n ? t <= 0 ? jr.TrackBefore : jr.TrackAfter : jr.TrackDel;
  }
  // Only relevant when this.block == true
  get type() {
    return this.startSide < this.endSide ? ar.WidgetRange : this.startSide <= 0 ? ar.WidgetBefore : ar.WidgetAfter;
  }
  get heightRelevant() {
    return this.block || !!this.widget && (this.widget.estimatedHeight >= 5 || this.widget.lineBreaks > 0);
  }
  eq(e) {
    return e instanceof Bl && DIe(this.widget, e.widget) && this.block == e.block && this.startSide == e.startSide && this.endSide == e.endSide;
  }
  range(e, t = e) {
    if (this.isReplace && (e > t || e == t && this.startSide > 0 && this.endSide <= 0))
      throw new RangeError("Invalid range for replacement decoration");
    if (!this.isReplace && t != e)
      throw new RangeError("Widget decorations can only have zero-length ranges");
    return super.range(e, t);
  }
}
Bl.prototype.point = !0;
function V7(r, e = !1) {
  let { inclusiveStart: t, inclusiveEnd: i } = r;
  return t == null && (t = r.inclusive), i == null && (i = r.inclusive), { start: t ?? e, end: i ?? e };
}
function DIe(r, e) {
  return r == e || !!(r && e && r.compare(e));
}
function LI(r, e, t, i = 0) {
  let n = t.length - 1;
  n >= 0 && t[n] + i >= r ? t[n] = Math.max(t[n], e) : t.push(r, e);
}
class xi extends Ht {
  constructor() {
    super(...arguments), this.children = [], this.length = 0, this.prevAttrs = void 0, this.attrs = null, this.breakAfter = 0;
  }
  // Consumes source
  merge(e, t, i, n, a, o) {
    if (i) {
      if (!(i instanceof xi))
        return !1;
      this.dom || i.transferDOM(this);
    }
    return n && this.setDeco(i ? i.attrs : null), L7(this, e, t, i ? i.children : [], a, o), !0;
  }
  split(e) {
    let t = new xi();
    if (t.breakAfter = this.breakAfter, this.length == 0)
      return t;
    let { i, off: n } = this.childPos(e);
    n && (t.append(this.children[i].split(n), 0), this.children[i].merge(n, this.children[i].length, null, !1, 0, 0), i++);
    for (let a = i; a < this.children.length; a++)
      t.append(this.children[a], 0);
    for (; i > 0 && this.children[i - 1].length == 0; )
      this.children[--i].destroy();
    return this.children.length = i, this.markDirty(), this.length = e, t;
  }
  transferDOM(e) {
    this.dom && (this.markDirty(), e.setDOM(this.dom), e.prevAttrs = this.prevAttrs === void 0 ? this.attrs : this.prevAttrs, this.prevAttrs = void 0, this.dom = null);
  }
  setDeco(e) {
    Qx(this.attrs, e) || (this.dom && (this.prevAttrs = this.attrs, this.markDirty()), this.attrs = e);
  }
  append(e, t) {
    U7(this, e, t);
  }
  // Only called when building a line view in ContentBuilder
  addLineDeco(e) {
    let t = e.spec.attributes, i = e.spec.class;
    t && (this.attrs = xI(t, this.attrs || {})), i && (this.attrs = xI({ class: i }, this.attrs || {}));
  }
  domAtPos(e) {
    return Q7(this, e);
  }
  reuseDOM(e) {
    e.nodeName == "DIV" && (this.setDOM(e), this.flags |= 6);
  }
  sync(e, t) {
    var i;
    this.dom ? this.flags & 4 && (w7(this.dom), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0) : (this.setDOM(document.createElement("div")), this.dom.className = "cm-line", this.prevAttrs = this.attrs ? null : void 0), this.prevAttrs !== void 0 && (PI(this.dom, this.prevAttrs, this.attrs), this.dom.classList.add("cm-line"), this.prevAttrs = void 0), super.sync(e, t);
    let n = this.dom.lastChild;
    for (; n && Ht.get(n) instanceof ds; )
      n = n.lastChild;
    if (!n || !this.length || n.nodeName != "BR" && ((i = Ht.get(n)) === null || i === void 0 ? void 0 : i.isEditable) == !1 && (!we.ios || !this.children.some((a) => a instanceof Io))) {
      let a = document.createElement("BR");
      a.cmIgnore = !0, this.dom.appendChild(a);
    }
  }
  measureTextSize() {
    if (this.children.length == 0 || this.length > 20)
      return null;
    let e = 0, t;
    for (let i of this.children) {
      if (!(i instanceof Io) || /[^ -~]/.test(i.text))
        return null;
      let n = tv(i.dom);
      if (n.length != 1)
        return null;
      e += n[0].width, t = n[0].height;
    }
    return e ? {
      lineHeight: this.dom.getBoundingClientRect().height,
      charWidth: e / this.length,
      textHeight: t
    } : null;
  }
  coordsAt(e, t) {
    let i = $7(this, e, t);
    if (!this.children.length && i && this.parent) {
      let { heightOracle: n } = this.parent.view.viewState, a = i.bottom - i.top;
      if (Math.abs(a - n.lineHeight) < 2 && n.textHeight < a) {
        let o = (a - n.textHeight) / 2;
        return { top: i.top + o, bottom: i.bottom - o, left: i.left, right: i.left };
      }
    }
    return i;
  }
  become(e) {
    return !1;
  }
  get type() {
    return ar.Text;
  }
  static find(e, t) {
    for (let i = 0, n = 0; i < e.children.length; i++) {
      let a = e.children[i], o = n + a.length;
      if (o >= t) {
        if (a instanceof xi)
          return a;
        if (o > t)
          break;
      }
      n = o + a.breakAfter;
    }
    return null;
  }
}
class bc extends Ht {
  constructor(e, t, i) {
    super(), this.widget = e, this.length = t, this.type = i, this.breakAfter = 0, this.prevWidget = null;
  }
  merge(e, t, i, n, a, o) {
    return i && (!(i instanceof bc) || !this.widget.compare(i.widget) || e > 0 && a <= 0 || t < this.length && o <= 0) ? !1 : (this.length = e + (i ? i.length : 0) + (this.length - t), !0);
  }
  domAtPos(e) {
    return e == 0 ? Mi.before(this.dom) : Mi.after(this.dom, e == this.length);
  }
  split(e) {
    let t = this.length - e;
    this.length = e;
    let i = new bc(this.widget, t, this.type);
    return i.breakAfter = this.breakAfter, i;
  }
  get children() {
    return kx;
  }
  sync(e) {
    (!this.dom || !this.widget.updateDOM(this.dom, e)) && (this.dom && this.prevWidget && this.prevWidget.destroy(this.dom), this.prevWidget = null, this.setDOM(this.widget.toDOM(e)), this.dom.contentEditable = "false");
  }
  get overrideDOMText() {
    return this.parent ? this.parent.view.state.doc.slice(this.posAtStart, this.posAtEnd) : Ct.empty;
  }
  domBoundsAround() {
    return null;
  }
  become(e) {
    return e instanceof bc && e.widget.constructor == this.widget.constructor ? (e.widget.compare(this.widget) || this.markDirty(!0), this.dom && !this.prevWidget && (this.prevWidget = this.widget), this.widget = e.widget, this.length = e.length, this.type = e.type, this.breakAfter = e.breakAfter, !0) : !1;
  }
  ignoreMutation() {
    return !0;
  }
  ignoreEvent(e) {
    return this.widget.ignoreEvent(e);
  }
  get isEditable() {
    return !1;
  }
  get isWidget() {
    return !0;
  }
  coordsAt(e, t) {
    return this.widget.coordsAt(this.dom, e, t);
  }
  destroy() {
    super.destroy(), this.dom && this.widget.destroy(this.dom);
  }
}
class ag {
  constructor(e, t, i, n) {
    this.doc = e, this.pos = t, this.end = i, this.disallowBlockEffectsFor = n, this.content = [], this.curLine = null, this.breakAtStart = 0, this.pendingBuffer = 0, this.bufferMarks = [], this.atCursorPos = !0, this.openStart = -1, this.openEnd = -1, this.text = "", this.textOff = 0, this.cursor = e.iter(), this.skip = t;
  }
  posCovered() {
    if (this.content.length == 0)
      return !this.breakAtStart && this.doc.lineAt(this.pos).from != this.pos;
    let e = this.content[this.content.length - 1];
    return !e.breakAfter && !(e instanceof bc && e.type == ar.WidgetBefore);
  }
  getLine() {
    return this.curLine || (this.content.push(this.curLine = new xi()), this.atCursorPos = !0), this.curLine;
  }
  flushBuffer(e = this.bufferMarks) {
    this.pendingBuffer && (this.curLine.append(mm(new Uf(-1), e), e.length), this.pendingBuffer = 0);
  }
  addBlockWidget(e) {
    this.flushBuffer(), this.curLine = null, this.content.push(e);
  }
  finish(e) {
    this.pendingBuffer && e <= this.bufferMarks.length ? this.flushBuffer() : this.pendingBuffer = 0, this.posCovered() || this.getLine();
  }
  buildText(e, t, i) {
    for (; e > 0; ) {
      if (this.textOff == this.text.length) {
        let { value: a, lineBreak: o, done: s } = this.cursor.next(this.skip);
        if (this.skip = 0, s)
          throw new Error("Ran out of text content when drawing inline views");
        if (o) {
          this.posCovered() || this.getLine(), this.content.length ? this.content[this.content.length - 1].breakAfter = 1 : this.breakAtStart = 1, this.flushBuffer(), this.curLine = null, this.atCursorPos = !0, e--;
          continue;
        } else
          this.text = a, this.textOff = 0;
      }
      let n = Math.min(
        this.text.length - this.textOff,
        e,
        512
        /* Chunk */
      );
      this.flushBuffer(t.slice(t.length - i)), this.getLine().append(mm(new Io(this.text.slice(this.textOff, this.textOff + n)), t), i), this.atCursorPos = !0, this.textOff += n, e -= n, i = 0;
    }
  }
  span(e, t, i, n) {
    this.buildText(t - e, i, n), this.pos = t, this.openStart < 0 && (this.openStart = n);
  }
  point(e, t, i, n, a, o) {
    if (this.disallowBlockEffectsFor[o] && i instanceof Bl) {
      if (i.block)
        throw new RangeError("Block decorations may not be specified via plugins");
      if (t > this.doc.lineAt(this.pos).to)
        throw new RangeError("Decorations that replace line breaks may not be specified via plugins");
    }
    let s = t - e;
    if (i instanceof Bl)
      if (i.block) {
        let { type: l } = i;
        l == ar.WidgetAfter && !this.posCovered() && this.getLine(), this.addBlockWidget(new bc(i.widget || new QV("div"), s, l));
      } else {
        let l = rc.create(i.widget || new QV("span"), s, s ? 0 : i.startSide), u = this.atCursorPos && !l.isEditable && a <= n.length && (e < t || i.startSide > 0), c = !l.isEditable && (e < t || a > n.length || i.startSide <= 0), h = this.getLine();
        this.pendingBuffer == 2 && !u && !l.isEditable && (this.pendingBuffer = 0), this.flushBuffer(n), u && (h.append(mm(new Uf(1), n), a), a = n.length + Math.max(0, a - n.length)), h.append(mm(l, n), a), this.atCursorPos = c, this.pendingBuffer = c ? e < t || a > n.length ? 1 : 2 : 0, this.pendingBuffer && (this.bufferMarks = n.slice());
      }
    else
      this.doc.lineAt(this.pos).from == this.pos && this.getLine().addLineDeco(i);
    s && (this.textOff + s <= this.text.length ? this.textOff += s : (this.skip += s - (this.text.length - this.textOff), this.text = "", this.textOff = 0), this.pos = t), this.openStart < 0 && (this.openStart = a);
  }
  static build(e, t, i, n, a) {
    let o = new ag(e, t, i, a);
    return o.openEnd = kt.spans(n, t, i, o), o.openStart < 0 && (o.openStart = o.openEnd), o.finish(o.openEnd), o;
  }
}
function mm(r, e) {
  for (let t of e)
    r = new ds(t, [r], r.length);
  return r;
}
class QV extends Rs {
  constructor(e) {
    super(), this.tag = e;
  }
  eq(e) {
    return e.tag == this.tag;
  }
  toDOM() {
    return document.createElement(this.tag);
  }
  updateDOM(e) {
    return e.nodeName.toLowerCase() == this.tag;
  }
  get isHidden() {
    return !0;
  }
}
const G7 = /* @__PURE__ */ Ce.define(), B7 = /* @__PURE__ */ Ce.define(), F7 = /* @__PURE__ */ Ce.define(), X7 = /* @__PURE__ */ Ce.define(), DI = /* @__PURE__ */ Ce.define(), Y7 = /* @__PURE__ */ Ce.define(), H7 = /* @__PURE__ */ Ce.define(), W7 = /* @__PURE__ */ Ce.define({
  combine: (r) => r.some((e) => e)
}), z7 = /* @__PURE__ */ Ce.define({
  combine: (r) => r.some((e) => e)
});
class tS {
  constructor(e, t = "nearest", i = "nearest", n = 5, a = 5) {
    this.range = e, this.y = t, this.x = i, this.yMargin = n, this.xMargin = a;
  }
  map(e) {
    return e.empty ? this : new tS(this.range.map(e), this.y, this.x, this.yMargin, this.xMargin);
  }
}
const UV = /* @__PURE__ */ lt.define({ map: (r, e) => r.map(e) });
function ea(r, e, t) {
  let i = r.facet(X7);
  i.length ? i[0](e) : window.onerror ? window.onerror(String(e), t, void 0, void 0, e) : t ? console.error(t + ":", e) : console.error(e);
}
const zT = /* @__PURE__ */ Ce.define({ combine: (r) => r.length ? r[0] : !0 });
let MIe = 0;
const _p = /* @__PURE__ */ Ce.define();
class Ur {
  constructor(e, t, i, n) {
    this.id = e, this.create = t, this.domEventHandlers = i, this.extension = n(this);
  }
  /**
  Define a plugin from a constructor function that creates the
  plugin's value, given an editor view.
  */
  static define(e, t) {
    const { eventHandlers: i, provide: n, decorations: a } = t || {};
    return new Ur(MIe++, e, i, (o) => {
      let s = [_p.of(o)];
      return a && s.push(rv.of((l) => {
        let u = l.plugin(o);
        return u ? a(u) : Xe.none;
      })), n && s.push(n(o)), s;
    });
  }
  /**
  Create a plugin for a class whose constructor takes a single
  editor view as argument.
  */
  static fromClass(e, t) {
    return Ur.define((i) => new e(i), t);
  }
}
class fA {
  constructor(e) {
    this.spec = e, this.mustUpdate = null, this.value = null;
  }
  update(e) {
    if (this.value) {
      if (this.mustUpdate) {
        let t = this.mustUpdate;
        if (this.mustUpdate = null, this.value.update)
          try {
            this.value.update(t);
          } catch (i) {
            if (ea(t.state, i, "CodeMirror plugin crashed"), this.value.destroy)
              try {
                this.value.destroy();
              } catch {
              }
            this.deactivate();
          }
      }
    } else if (this.spec)
      try {
        this.value = this.spec.create(e);
      } catch (t) {
        ea(e.state, t, "CodeMirror plugin crashed"), this.deactivate();
      }
    return this;
  }
  destroy(e) {
    var t;
    if (!((t = this.value) === null || t === void 0) && t.destroy)
      try {
        this.value.destroy();
      } catch (i) {
        ea(e.state, i, "CodeMirror plugin crashed");
      }
  }
  deactivate() {
    this.spec = this.value = null;
  }
}
const Z7 = /* @__PURE__ */ Ce.define(), Ux = /* @__PURE__ */ Ce.define(), rv = /* @__PURE__ */ Ce.define(), $x = /* @__PURE__ */ Ce.define(), q7 = /* @__PURE__ */ Ce.define();
function j7(r) {
  let e = 0, t = 0, i = 0, n = 0;
  for (let a of r.state.facet(q7)) {
    let o = a(r);
    o && (o.left != null && (e = Math.max(e, o.left)), o.right != null && (t = Math.max(t, o.right)), o.top != null && (i = Math.max(i, o.top)), o.bottom != null && (n = Math.max(n, o.bottom)));
  }
  return { left: e, right: t, top: i, bottom: n };
}
const Cp = /* @__PURE__ */ Ce.define();
class ta {
  constructor(e, t, i, n) {
    this.fromA = e, this.toA = t, this.fromB = i, this.toB = n;
  }
  join(e) {
    return new ta(Math.min(this.fromA, e.fromA), Math.max(this.toA, e.toA), Math.min(this.fromB, e.fromB), Math.max(this.toB, e.toB));
  }
  addToSet(e) {
    let t = e.length, i = this;
    for (; t > 0; t--) {
      let n = e[t - 1];
      if (!(n.fromA > i.toA)) {
        if (n.toA < i.fromA)
          break;
        i = i.join(n), e.splice(t - 1, 1);
      }
    }
    return e.splice(t, 0, i), e;
  }
  static extendWithRanges(e, t) {
    if (t.length == 0)
      return e;
    let i = [];
    for (let n = 0, a = 0, o = 0, s = 0; ; n++) {
      let l = n == e.length ? null : e[n], u = o - s, c = l ? l.fromB : 1e9;
      for (; a < t.length && t[a] < c; ) {
        let h = t[a], f = t[a + 1], d = Math.max(s, h), p = Math.min(c, f);
        if (d <= p && new ta(d + u, p + u, d, p).addToSet(i), f > c)
          break;
        a += 2;
      }
      if (!l)
        return i;
      new ta(l.fromA, l.toA, l.fromB, l.toB).addToSet(i), o = l.toA, s = l.toB;
    }
  }
}
class rS {
  constructor(e, t, i) {
    this.view = e, this.state = t, this.transactions = i, this.flags = 0, this.startState = e.state, this.changes = Nr.empty(this.startState.doc.length);
    for (let a of i)
      this.changes = this.changes.compose(a.changes);
    let n = [];
    this.changes.iterChangedRanges((a, o, s, l) => n.push(new ta(a, o, s, l))), this.changedRanges = n;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new rS(e, t, i);
  }
  /**
  Tells you whether the [viewport](https://codemirror.net/6/docs/ref/#view.EditorView.viewport) or
  [visible ranges](https://codemirror.net/6/docs/ref/#view.EditorView.visibleRanges) changed in this
  update.
  */
  get viewportChanged() {
    return (this.flags & 4) > 0;
  }
  /**
  Indicates whether the height of a block element in the editor
  changed in this update.
  */
  get heightChanged() {
    return (this.flags & 2) > 0;
  }
  /**
  Returns true when the document was modified or the size of the
  editor, or elements within the editor, changed.
  */
  get geometryChanged() {
    return this.docChanged || (this.flags & 10) > 0;
  }
  /**
  True when this update indicates a focus change.
  */
  get focusChanged() {
    return (this.flags & 1) > 0;
  }
  /**
  Whether the document changed in this update.
  */
  get docChanged() {
    return !this.changes.empty;
  }
  /**
  Whether the selection was explicitly set in this update.
  */
  get selectionSet() {
    return this.transactions.some((e) => e.selection);
  }
  /**
  @internal
  */
  get empty() {
    return this.flags == 0 && this.transactions.length == 0;
  }
}
var ir = /* @__PURE__ */ function(r) {
  return r[r.LTR = 0] = "LTR", r[r.RTL = 1] = "RTL", r;
}(ir || (ir = {}));
const MI = ir.LTR, kIe = ir.RTL;
function K7(r) {
  let e = [];
  for (let t = 0; t < r.length; t++)
    e.push(1 << +r[t]);
  return e;
}
const QIe = /* @__PURE__ */ K7("88888888888888888888888888888888888666888888787833333333337888888000000000000000000000000008888880000000000000000000000000088888888888888888888888888888888888887866668888088888663380888308888800000000000000000000000800000000000000000000000000000008"), UIe = /* @__PURE__ */ K7("4444448826627288999999999992222222222222222222222222222222222222222222222229999999999999999999994444444444644222822222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222999999949999999229989999223333333333"), kI = /* @__PURE__ */ Object.create(null), Ba = [];
for (let r of ["()", "[]", "{}"]) {
  let e = /* @__PURE__ */ r.charCodeAt(0), t = /* @__PURE__ */ r.charCodeAt(1);
  kI[e] = t, kI[t] = -e;
}
function $Ie(r) {
  return r <= 247 ? QIe[r] : 1424 <= r && r <= 1524 ? 2 : 1536 <= r && r <= 1785 ? UIe[r - 1536] : 1774 <= r && r <= 2220 ? 4 : 8192 <= r && r <= 8203 ? 256 : 64336 <= r && r <= 65023 ? 4 : r == 8204 ? 256 : 1;
}
const VIe = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\ufb50-\ufdff]/;
class pf {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.from = e, this.to = t, this.level = i;
  }
  /**
  The direction of this span.
  */
  get dir() {
    return this.level % 2 ? kIe : MI;
  }
  /**
  @internal
  */
  side(e, t) {
    return this.dir == t == e ? this.to : this.from;
  }
  /**
  @internal
  */
  static find(e, t, i, n) {
    let a = -1;
    for (let o = 0; o < e.length; o++) {
      let s = e[o];
      if (s.from <= t && s.to >= t) {
        if (s.level == i)
          return o;
        (a < 0 || (n != 0 ? n < 0 ? s.from < t : s.to > t : e[a].level > s.level)) && (a = o);
      }
    }
    if (a < 0)
      throw new RangeError("Index out of range");
    return a;
  }
}
const Jt = [];
function GIe(r, e) {
  let t = r.length, i = e == MI ? 1 : 2, n = e == MI ? 2 : 1;
  if (!r || i == 1 && !VIe.test(r))
    return J7(t);
  for (let o = 0, s = i, l = i; o < t; o++) {
    let u = $Ie(r.charCodeAt(o));
    u == 512 ? u = s : u == 8 && l == 4 && (u = 16), Jt[o] = u == 4 ? 2 : u, u & 7 && (l = u), s = u;
  }
  for (let o = 0, s = i, l = i; o < t; o++) {
    let u = Jt[o];
    if (u == 128)
      o < t - 1 && s == Jt[o + 1] && s & 24 ? u = Jt[o] = s : Jt[o] = 256;
    else if (u == 64) {
      let c = o + 1;
      for (; c < t && Jt[c] == 64; )
        c++;
      let h = o && s == 8 || c < t && Jt[c] == 8 ? l == 1 ? 1 : 8 : 256;
      for (let f = o; f < c; f++)
        Jt[f] = h;
      o = c - 1;
    } else
      u == 8 && l == 1 && (Jt[o] = 1);
    s = u, u & 7 && (l = u);
  }
  for (let o = 0, s = 0, l = 0, u, c, h; o < t; o++)
    if (c = kI[u = r.charCodeAt(o)])
      if (c < 0) {
        for (let f = s - 3; f >= 0; f -= 3)
          if (Ba[f + 1] == -c) {
            let d = Ba[f + 2], p = d & 2 ? i : d & 4 ? d & 1 ? n : i : 0;
            p && (Jt[o] = Jt[Ba[f]] = p), s = f;
            break;
          }
      } else {
        if (Ba.length == 189)
          break;
        Ba[s++] = o, Ba[s++] = u, Ba[s++] = l;
      }
    else if ((h = Jt[o]) == 2 || h == 1) {
      let f = h == i;
      l = f ? 0 : 1;
      for (let d = s - 3; d >= 0; d -= 3) {
        let p = Ba[d + 2];
        if (p & 2)
          break;
        if (f)
          Ba[d + 2] |= 2;
        else {
          if (p & 4)
            break;
          Ba[d + 2] |= 4;
        }
      }
    }
  for (let o = 0; o < t; o++)
    if (Jt[o] == 256) {
      let s = o + 1;
      for (; s < t && Jt[s] == 256; )
        s++;
      let l = (o ? Jt[o - 1] : i) == 1, u = (s < t ? Jt[s] : i) == 1, c = l == u ? l ? 1 : 2 : i;
      for (let h = o; h < s; h++)
        Jt[h] = c;
      o = s - 1;
    }
  let a = [];
  if (i == 1)
    for (let o = 0; o < t; ) {
      let s = o, l = Jt[o++] != 1;
      for (; o < t && l == (Jt[o] != 1); )
        o++;
      if (l)
        for (let u = o; u > s; ) {
          let c = u, h = Jt[--u] != 2;
          for (; u > s && h == (Jt[u - 1] != 2); )
            u--;
          a.push(new pf(u, c, h ? 2 : 1));
        }
      else
        a.push(new pf(s, o, 0));
    }
  else
    for (let o = 0; o < t; ) {
      let s = o, l = Jt[o++] == 2;
      for (; o < t && l == (Jt[o] == 2); )
        o++;
      a.push(new pf(s, o, l ? 1 : 2));
    }
  return a;
}
function J7(r) {
  return [new pf(0, r, 0)];
}
let e6 = "";
function BIe(r, e, t, i, n) {
  var a;
  let o = i.head - r.from, s = -1;
  if (o == 0) {
    if (!n || !r.length)
      return null;
    e[0].level != t && (o = e[0].side(!1, t), s = 0);
  } else if (o == r.length) {
    if (n)
      return null;
    let f = e[e.length - 1];
    f.level != t && (o = f.side(!0, t), s = e.length - 1);
  }
  s < 0 && (s = pf.find(e, o, (a = i.bidiLevel) !== null && a !== void 0 ? a : -1, i.assoc));
  let l = e[s];
  o == l.side(n, t) && (l = e[s += n ? 1 : -1], o = l.side(!n, t));
  let u = n == (l.dir == t), c = vi(r.text, o, u);
  if (e6 = r.text.slice(Math.min(o, c), Math.max(o, c)), c != l.side(n, t))
    return Z.cursor(c + r.from, u ? -1 : 1, l.level);
  let h = s == (n ? e.length - 1 : 0) ? null : e[s + (n ? 1 : -1)];
  return !h && l.level != t ? Z.cursor(n ? r.to : r.from, n ? -1 : 1, t) : h && h.level < l.level ? Z.cursor(h.side(!n, t) + r.from, n ? 1 : -1, h.level) : Z.cursor(c + r.from, n ? -1 : 1, l.level);
}
class $V extends Ht {
  constructor(e) {
    super(), this.view = e, this.decorations = [], this.dynamicDecorationMap = [], this.hasComposition = null, this.markedForComposition = /* @__PURE__ */ new Set(), this.minWidth = 0, this.minWidthFrom = 0, this.minWidthTo = 0, this.impreciseAnchor = null, this.impreciseHead = null, this.forceSelection = !1, this.lastUpdate = Date.now(), this.setDOM(e.contentDOM), this.children = [new xi()], this.children[0].setParent(this), this.updateDeco(), this.updateInner([new ta(0, 0, 0, e.state.doc.length)], 0, null);
  }
  get length() {
    return this.view.state.doc.length;
  }
  // Update the document view to a given state.
  update(e) {
    let t = e.changedRanges;
    this.minWidth > 0 && t.length && (t.every(({ fromA: s, toA: l }) => l < this.minWidthFrom || s > this.minWidthTo) ? (this.minWidthFrom = e.changes.mapPos(this.minWidthFrom, 1), this.minWidthTo = e.changes.mapPos(this.minWidthTo, 1)) : this.minWidth = this.minWidthFrom = this.minWidthTo = 0);
    let i = this.view.inputState.composing < 0 ? null : XIe(this.view, e.changes);
    if (this.hasComposition) {
      this.markedForComposition.clear();
      let { from: s, to: l } = this.hasComposition;
      t = new ta(s, l, e.changes.mapPos(s, -1), e.changes.mapPos(l, 1)).addToSet(t.slice());
    }
    this.hasComposition = i ? { from: i.range.fromB, to: i.range.toB } : null, (we.ie || we.chrome) && !i && e && e.state.doc.lines != e.startState.doc.lines && (this.forceSelection = !0);
    let n = this.decorations, a = this.updateDeco(), o = WIe(n, a, e.changes);
    return t = ta.extendWithRanges(t, o), !(this.flags & 7) && t.length == 0 ? !1 : (this.updateInner(t, e.startState.doc.length, i), e.transactions.length && (this.lastUpdate = Date.now()), !0);
  }
  // Used by update and the constructor do perform the actual DOM
  // update
  updateInner(e, t, i) {
    this.view.viewState.mustMeasureContent = !0, this.updateChildren(e, t, i);
    let { observer: n } = this.view;
    n.ignore(() => {
      this.dom.style.height = this.view.viewState.contentHeight + "px", this.dom.style.flexBasis = this.minWidth ? this.minWidth + "px" : "";
      let o = we.chrome || we.ios ? { node: n.selectionRange.focusNode, written: !1 } : void 0;
      this.sync(this.view, o), this.flags &= -8, o && (o.written || n.selectionRange.focusNode != o.node) && (this.forceSelection = !0), this.dom.style.height = "";
    }), this.markedForComposition.forEach(
      (o) => o.flags &= -9
      /* Composition */
    );
    let a = [];
    if (this.view.viewport.from || this.view.viewport.to < this.view.state.doc.length)
      for (let o of this.children)
        o instanceof bc && o.widget instanceof VV && a.push(o.dom);
    n.updateGaps(a);
  }
  updateChildren(e, t, i) {
    let n = i ? i.range.addToSet(e.slice()) : e, a = this.childCursor(t);
    for (let o = n.length - 1; ; o--) {
      let s = o >= 0 ? n[o] : null;
      if (!s)
        break;
      let { fromA: l, toA: u, fromB: c, toB: h } = s, f, d, p, g;
      if (i && i.range.fromB < h && i.range.toB > c) {
        let b = ag.build(this.view.state.doc, c, i.range.fromB, this.decorations, this.dynamicDecorationMap), S = ag.build(this.view.state.doc, i.range.toB, h, this.decorations, this.dynamicDecorationMap);
        d = b.breakAtStart, p = b.openStart, g = S.openEnd;
        let T = this.compositionView(i);
        S.breakAtStart ? T.breakAfter = 1 : S.content.length && T.merge(T.length, T.length, S.content[0], !1, S.openStart, 0) && (T.breakAfter = S.content[0].breakAfter, S.content.shift()), b.content.length && T.merge(0, 0, b.content[b.content.length - 1], !0, 0, b.openEnd) && b.content.pop(), f = b.content.concat(T).concat(S.content);
      } else
        ({ content: f, breakAtStart: d, openStart: p, openEnd: g } = ag.build(this.view.state.doc, c, h, this.decorations, this.dynamicDecorationMap));
      let { i: v, off: O } = a.findPos(u, 1), { i: m, off: E } = a.findPos(l, -1);
      P7(this, m, E, v, O, f, d, p, g);
    }
    i && this.fixCompositionDOM(i);
  }
  compositionView(e) {
    let t = new Io(e.text.nodeValue);
    t.flags |= 8;
    for (let { deco: n } of e.marks)
      t = new ds(n, [t], t.length);
    let i = new xi();
    return i.append(t, 0), i;
  }
  fixCompositionDOM(e) {
    let t = (a, o) => {
      o.flags |= 8, this.markedForComposition.add(o);
      let s = Ht.get(a);
      s != o && (s && (s.dom = null), o.setDOM(a));
    }, i = this.childPos(e.range.fromB, 1), n = this.children[i.i];
    t(e.line, n);
    for (let a = e.marks.length - 1; a >= -1; a--)
      i = n.childPos(i.off, 1), n = n.children[i.i], t(a >= 0 ? e.marks[a].node : e.text, n);
  }
  // Sync the DOM selection to this.state.selection
  updateSelection(e = !1, t = !1) {
    (e || !this.view.observer.selectionRange.focusNode) && this.view.observer.readSelectionRange();
    let i = this.view.root.activeElement, n = i == this.dom, a = !n && hE(this.dom, this.view.observer.selectionRange) && !(i && this.dom.contains(i));
    if (!(n || t || a))
      return;
    let o = this.forceSelection;
    this.forceSelection = !1;
    let s = this.view.state.selection.main, l = this.domAtPos(s.anchor), u = s.empty ? l : this.domAtPos(s.head);
    if (we.gecko && s.empty && !this.hasComposition && FIe(l)) {
      let h = document.createTextNode("");
      this.view.observer.ignore(() => l.node.insertBefore(h, l.node.childNodes[l.offset] || null)), l = u = new Mi(h, 0), o = !0;
    }
    let c = this.view.observer.selectionRange;
    (o || !c.focusNode || !Jb(l.node, l.offset, c.anchorNode, c.anchorOffset) || !Jb(u.node, u.offset, c.focusNode, c.focusOffset)) && (this.view.observer.ignore(() => {
      we.android && we.chrome && this.dom.contains(c.focusNode) && zIe(c.focusNode, this.dom) && (this.dom.blur(), this.dom.focus({ preventScroll: !0 }));
      let h = Kb(this.view.root);
      if (h)
        if (s.empty) {
          if (we.gecko) {
            let f = YIe(l.node, l.offset);
            if (f && f != 3) {
              let d = r6(l.node, l.offset, f == 1 ? 1 : -1);
              d && (l = new Mi(d, f == 1 ? 0 : d.nodeValue.length));
            }
          }
          h.collapse(l.node, l.offset), s.bidiLevel != null && c.cursorBidiLevel != null && (c.cursorBidiLevel = s.bidiLevel);
        } else if (h.extend) {
          h.collapse(l.node, l.offset);
          try {
            h.extend(u.node, u.offset);
          } catch {
          }
        } else {
          let f = document.createRange();
          s.anchor > s.head && ([l, u] = [u, l]), f.setEnd(u.node, u.offset), f.setStart(l.node, l.offset), h.removeAllRanges(), h.addRange(f);
        }
      a && this.view.root.activeElement == this.dom && (this.dom.blur(), i && i.focus());
    }), this.view.observer.setSelectionRange(l, u)), this.impreciseAnchor = l.precise ? null : new Mi(c.anchorNode, c.anchorOffset), this.impreciseHead = u.precise ? null : new Mi(c.focusNode, c.focusOffset);
  }
  enforceCursorAssoc() {
    if (this.hasComposition)
      return;
    let { view: e } = this, t = e.state.selection.main, i = Kb(e.root), { anchorNode: n, anchorOffset: a } = e.observer.selectionRange;
    if (!i || !t.empty || !t.assoc || !i.modify)
      return;
    let o = xi.find(this, t.head);
    if (!o)
      return;
    let s = o.posAtStart;
    if (t.head == s || t.head == s + o.length)
      return;
    let l = this.coordsAt(t.head, -1), u = this.coordsAt(t.head, 1);
    if (!l || !u || l.bottom > u.top)
      return;
    let c = this.domAtPos(t.head + t.assoc);
    i.collapse(c.node, c.offset), i.modify("move", t.assoc < 0 ? "forward" : "backward", "lineboundary"), e.observer.readSelectionRange();
    let h = e.observer.selectionRange;
    e.docView.posFromDOM(h.anchorNode, h.anchorOffset) != t.from && i.collapse(n, a);
  }
  nearest(e) {
    for (let t = e; t; ) {
      let i = Ht.get(t);
      if (i && i.rootView == this)
        return i;
      t = t.parentNode;
    }
    return null;
  }
  posFromDOM(e, t) {
    let i = this.nearest(e);
    if (!i)
      throw new RangeError("Trying to find position for a DOM position outside of the document");
    return i.localPosFromDOM(e, t) + i.posAtStart;
  }
  domAtPos(e) {
    let { i: t, off: i } = this.childCursor().findPos(e, -1);
    for (; t < this.children.length - 1; ) {
      let n = this.children[t];
      if (i < n.length || n instanceof xi)
        break;
      t++, i = 0;
    }
    return this.children[t].domAtPos(i);
  }
  coordsAt(e, t) {
    for (let i = this.length, n = this.children.length - 1; ; n--) {
      let a = this.children[n], o = i - a.breakAfter - a.length;
      if (e > o || e == o && a.type != ar.WidgetBefore && a.type != ar.WidgetAfter && (!n || t == 2 || this.children[n - 1].breakAfter || this.children[n - 1].type == ar.WidgetBefore && t > -2))
        return a.coordsAt(e - o, t);
      i = o;
    }
  }
  coordsForChar(e) {
    let { i: t, off: i } = this.childPos(e, 1), n = this.children[t];
    if (!(n instanceof xi))
      return null;
    for (; n.children.length; ) {
      let { i: s, off: l } = n.childPos(i, 1);
      for (; ; s++) {
        if (s == n.children.length)
          return null;
        if ((n = n.children[s]).length)
          break;
      }
      i = l;
    }
    if (!(n instanceof Io))
      return null;
    let a = vi(n.text, i);
    if (a == i)
      return null;
    let o = kc(n.dom, i, a).getClientRects();
    return !o.length || o[0].top >= o[0].bottom ? null : o[0];
  }
  measureVisibleLineHeights(e) {
    let t = [], { from: i, to: n } = e, a = this.view.contentDOM.clientWidth, o = a > Math.max(this.view.scrollDOM.clientWidth, this.minWidth) + 1, s = -1, l = this.view.textDirection == ir.LTR;
    for (let u = 0, c = 0; c < this.children.length; c++) {
      let h = this.children[c], f = u + h.length;
      if (f > n)
        break;
      if (u >= i) {
        let d = h.dom.getBoundingClientRect();
        if (t.push(d.height), o) {
          let p = h.dom.lastChild, g = p ? tv(p) : [];
          if (g.length) {
            let v = g[g.length - 1], O = l ? v.right - d.left : d.right - v.left;
            O > s && (s = O, this.minWidth = a, this.minWidthFrom = u, this.minWidthTo = f);
          }
        }
      }
      u = f + h.breakAfter;
    }
    return t;
  }
  textDirectionAt(e) {
    let { i: t } = this.childPos(e, 1);
    return getComputedStyle(this.children[t].dom).direction == "rtl" ? ir.RTL : ir.LTR;
  }
  measureTextSize() {
    for (let a of this.children)
      if (a instanceof xi) {
        let o = a.measureTextSize();
        if (o)
          return o;
      }
    let e = document.createElement("div"), t, i, n;
    return e.className = "cm-line", e.style.width = "99999px", e.style.position = "absolute", e.textContent = "abc def ghi jkl mno pqr stu", this.view.observer.ignore(() => {
      this.dom.appendChild(e);
      let a = tv(e.firstChild)[0];
      t = e.getBoundingClientRect().height, i = a ? a.width / 27 : 7, n = a ? a.height : t, e.remove();
    }), { lineHeight: t, charWidth: i, textHeight: n };
  }
  childCursor(e = this.length) {
    let t = this.children.length;
    return t && (e -= this.children[--t].length), new x7(this.children, e, t);
  }
  computeBlockGapDeco() {
    let e = [], t = this.view.viewState;
    for (let i = 0, n = 0; ; n++) {
      let a = n == t.viewports.length ? null : t.viewports[n], o = a ? a.from - 1 : this.length;
      if (o > i) {
        let s = t.lineBlockAt(o).bottom - t.lineBlockAt(i).top;
        e.push(Xe.replace({
          widget: new VV(s),
          block: !0,
          inclusive: !0,
          isBlockGap: !0
        }).range(i, o));
      }
      if (!a)
        break;
      i = a.to + 1;
    }
    return Xe.set(e);
  }
  updateDeco() {
    let e = this.view.state.facet(rv).map((t, i) => (this.dynamicDecorationMap[i] = typeof t == "function") ? t(this.view) : t);
    for (let t = e.length; t < e.length + 3; t++)
      this.dynamicDecorationMap[t] = !1;
    return this.decorations = [
      ...e,
      this.computeBlockGapDeco(),
      this.view.viewState.lineGapDeco
    ];
  }
  scrollIntoView(e) {
    let { range: t } = e, i = this.coordsAt(t.head, t.empty ? t.assoc : t.head > t.anchor ? -1 : 1), n;
    if (!i)
      return;
    !t.empty && (n = this.coordsAt(t.anchor, t.anchor > t.head ? -1 : 1)) && (i = {
      left: Math.min(i.left, n.left),
      top: Math.min(i.top, n.top),
      right: Math.max(i.right, n.right),
      bottom: Math.max(i.bottom, n.bottom)
    });
    let a = j7(this.view), o = {
      left: i.left - a.left,
      top: i.top - a.top,
      right: i.right + a.right,
      bottom: i.bottom + a.bottom
    };
    AIe(this.view.scrollDOM, o, t.head < t.anchor ? -1 : 1, e.x, e.y, e.xMargin, e.yMargin, this.view.textDirection == ir.LTR);
  }
}
function FIe(r) {
  return r.node.nodeType == 1 && r.node.firstChild && (r.offset == 0 || r.node.childNodes[r.offset - 1].contentEditable == "false") && (r.offset == r.node.childNodes.length || r.node.childNodes[r.offset].contentEditable == "false");
}
class VV extends Rs {
  constructor(e) {
    super(), this.height = e;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.updateDOM(e), e;
  }
  eq(e) {
    return e.height == this.height;
  }
  updateDOM(e) {
    return e.style.height = this.height + "px", !0;
  }
  get estimatedHeight() {
    return this.height;
  }
}
function t6(r) {
  let e = r.observer.selectionRange, t = e.focusNode && r6(e.focusNode, e.focusOffset, 0);
  if (!t)
    return null;
  let i = Ht.get(t), n, a;
  if (i instanceof Io)
    n = i.posAtStart, a = n + i.length;
  else
    e:
      for (let o = 0, s = t; ; ) {
        for (let u = s.previousSibling, c; u; u = u.previousSibling) {
          if (c = Ht.get(u)) {
            n = a = c.posAtEnd + o;
            break e;
          }
          let h = new D7([], r.state);
          if (h.readNode(u), h.text.indexOf(qh) > -1)
            return null;
          o += h.text.length;
        }
        if (s = s.parentNode, !s)
          return null;
        let l = Ht.get(s);
        if (l) {
          n = a = l.posAtStart + o;
          break;
        }
      }
  return { from: n, to: a, node: t };
}
function XIe(r, e) {
  let t = t6(r);
  if (!t)
    return null;
  let { from: i, to: n, node: a } = t, o = e.mapPos(i, -1), s = e.mapPos(n, 1), l = a.nodeValue;
  if (/[\n\r]/.test(l))
    return null;
  if (s - o != l.length) {
    let f = e.mapPos(i, 1), d = e.mapPos(n, -1);
    if (d - f == l.length)
      o = f, s = d;
    else if (r.state.doc.sliceString(s - l.length, s) == l)
      o = s - l.length;
    else if (r.state.doc.sliceString(o, o + l.length) == l)
      s = o + l.length;
    else
      return null;
  }
  let { main: u } = r.state.selection;
  if (r.state.doc.sliceString(o, s) != l || o > u.head || s < u.head)
    return null;
  let c = [], h = new ta(i, n, o, s);
  for (let f = a.parentNode; ; f = f.parentNode) {
    let d = Ht.get(f);
    if (d instanceof ds)
      c.push({ node: f, deco: d.mark });
    else {
      if (d instanceof xi || f.nodeName == "DIV" && f.parentNode == r.contentDOM)
        return { range: h, text: a, marks: c, line: f };
      if (f != r.contentDOM)
        c.push({ node: f, deco: new Fv({
          inclusive: !0,
          attributes: LIe(f),
          tagName: f.tagName.toLowerCase()
        }) });
      else
        return null;
    }
  }
}
function r6(r, e, t) {
  if (t <= 0)
    for (let i = r, n = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && n > 0)
        i = i.childNodes[n - 1], n = Gl(i);
      else
        break;
    }
  if (t >= 0)
    for (let i = r, n = e; ; ) {
      if (i.nodeType == 3)
        return i;
      if (i.nodeType == 1 && n < i.childNodes.length && t >= 0)
        i = i.childNodes[n], n = 0;
      else
        break;
    }
  return null;
}
function YIe(r, e) {
  return r.nodeType != 1 ? 0 : (e && r.childNodes[e - 1].contentEditable == "false" ? 1 : 0) | (e < r.childNodes.length && r.childNodes[e].contentEditable == "false" ? 2 : 0);
}
class HIe {
  constructor() {
    this.changes = [];
  }
  compareRange(e, t) {
    LI(e, t, this.changes);
  }
  comparePoint(e, t) {
    LI(e, t, this.changes);
  }
}
function WIe(r, e, t) {
  let i = new HIe();
  return kt.compare(r, e, t, i), i.changes;
}
function zIe(r, e) {
  for (let t = r; t && t != e; t = t.assignedSlot || t.parentNode)
    if (t.nodeType == 1 && t.contentEditable == "false")
      return !0;
  return !1;
}
function ZIe(r, e, t = 1) {
  let i = r.charCategorizer(e), n = r.doc.lineAt(e), a = e - n.from;
  if (n.length == 0)
    return Z.cursor(e);
  a == 0 ? t = 1 : a == n.length && (t = -1);
  let o = a, s = a;
  t < 0 ? o = vi(n.text, a, !1) : s = vi(n.text, a);
  let l = i(n.text.slice(o, s));
  for (; o > 0; ) {
    let u = vi(n.text, o, !1);
    if (i(n.text.slice(u, o)) != l)
      break;
    o = u;
  }
  for (; s < n.length; ) {
    let u = vi(n.text, s);
    if (i(n.text.slice(s, u)) != l)
      break;
    s = u;
  }
  return Z.range(o + n.from, s + n.from);
}
function qIe(r, e) {
  return e.left > r ? e.left - r : Math.max(0, r - e.right);
}
function jIe(r, e) {
  return e.top > r ? e.top - r : Math.max(0, r - e.bottom);
}
function dA(r, e) {
  return r.top < e.bottom - 1 && r.bottom > e.top + 1;
}
function GV(r, e) {
  return e < r.top ? { top: e, left: r.left, right: r.right, bottom: r.bottom } : r;
}
function BV(r, e) {
  return e > r.bottom ? { top: r.top, left: r.left, right: r.right, bottom: e } : r;
}
function QI(r, e, t) {
  let i, n, a, o, s = !1, l, u, c, h;
  for (let p = r.firstChild; p; p = p.nextSibling) {
    let g = tv(p);
    for (let v = 0; v < g.length; v++) {
      let O = g[v];
      n && dA(n, O) && (O = GV(BV(O, n.bottom), n.top));
      let m = qIe(e, O), E = jIe(t, O);
      if (m == 0 && E == 0)
        return p.nodeType == 3 ? FV(p, e, t) : QI(p, e, t);
      if (!i || o > E || o == E && a > m) {
        i = p, n = O, a = m, o = E;
        let b = E ? t < O.top ? -1 : 1 : m ? e < O.left ? -1 : 1 : 0;
        s = !b || (b > 0 ? v < g.length - 1 : v > 0);
      }
      m == 0 ? t > O.bottom && (!c || c.bottom < O.bottom) ? (l = p, c = O) : t < O.top && (!h || h.top > O.top) && (u = p, h = O) : c && dA(c, O) ? c = BV(c, O.bottom) : h && dA(h, O) && (h = GV(h, O.top));
    }
  }
  if (c && c.bottom >= t ? (i = l, n = c) : h && h.top <= t && (i = u, n = h), !i)
    return { node: r, offset: 0 };
  let f = Math.max(n.left, Math.min(n.right, e));
  if (i.nodeType == 3)
    return FV(i, f, t);
  if (s && i.contentEditable != "false")
    return QI(i, f, t);
  let d = Array.prototype.indexOf.call(r.childNodes, i) + (e >= (n.left + n.right) / 2 ? 1 : 0);
  return { node: r, offset: d };
}
function FV(r, e, t) {
  let i = r.nodeValue.length, n = -1, a = 1e9, o = 0;
  for (let s = 0; s < i; s++) {
    let l = kc(r, s, s + 1).getClientRects();
    for (let u = 0; u < l.length; u++) {
      let c = l[u];
      if (c.top == c.bottom)
        continue;
      o || (o = e - c.left);
      let h = (c.top > t ? c.top - t : t - c.bottom) - 1;
      if (c.left - 1 <= e && c.right + 1 >= e && h < a) {
        let f = e >= (c.left + c.right) / 2, d = f;
        if ((we.chrome || we.gecko) && kc(r, s).getBoundingClientRect().left == c.right && (d = !f), h <= 0)
          return { node: r, offset: s + (d ? 1 : 0) };
        n = s + (d ? 1 : 0), a = h;
      }
    }
  }
  return { node: r, offset: n > -1 ? n : o > 0 ? r.nodeValue.length : 0 };
}
function i6(r, e, t, i = -1) {
  var n, a;
  let o = r.contentDOM.getBoundingClientRect(), s = o.top + r.viewState.paddingTop, l, { docHeight: u } = r.viewState, { x: c, y: h } = e, f = h - s;
  if (f < 0)
    return 0;
  if (f > u)
    return r.state.doc.length;
  for (let b = r.viewState.heightOracle.textHeight / 2, S = !1; l = r.elementAtHeight(f), l.type != ar.Text; )
    for (; f = i > 0 ? l.bottom + b : l.top - b, !(f >= 0 && f <= u); ) {
      if (S)
        return t ? null : 0;
      S = !0, i = -i;
    }
  h = s + f;
  let d = l.from;
  if (d < r.viewport.from)
    return r.viewport.from == 0 ? 0 : t ? null : XV(r, o, l, c, h);
  if (d > r.viewport.to)
    return r.viewport.to == r.state.doc.length ? r.state.doc.length : t ? null : XV(r, o, l, c, h);
  let p = r.dom.ownerDocument, g = r.root.elementFromPoint ? r.root : p, v = g.elementFromPoint(c, h);
  v && !r.contentDOM.contains(v) && (v = null), v || (c = Math.max(o.left + 1, Math.min(o.right - 1, c)), v = g.elementFromPoint(c, h), v && !r.contentDOM.contains(v) && (v = null));
  let O, m = -1;
  if (v && ((n = r.docView.nearest(v)) === null || n === void 0 ? void 0 : n.isEditable) != !1) {
    if (p.caretPositionFromPoint) {
      let b = p.caretPositionFromPoint(c, h);
      b && ({ offsetNode: O, offset: m } = b);
    } else if (p.caretRangeFromPoint) {
      let b = p.caretRangeFromPoint(c, h);
      b && ({ startContainer: O, startOffset: m } = b, (!r.contentDOM.contains(O) || we.safari && KIe(O, m, c) || we.chrome && JIe(O, m, c)) && (O = void 0));
    }
  }
  if (!O || !r.docView.dom.contains(O)) {
    let b = xi.find(r.docView, d);
    if (!b)
      return f > l.top + l.height / 2 ? l.to : l.from;
    ({ node: O, offset: m } = QI(b.dom, c, h));
  }
  let E = r.docView.nearest(O);
  if (!E)
    return null;
  if (E.isWidget && ((a = E.dom) === null || a === void 0 ? void 0 : a.nodeType) == 1) {
    let b = E.dom.getBoundingClientRect();
    return e.y < b.top || e.y <= b.bottom && e.x <= (b.left + b.right) / 2 ? E.posAtStart : E.posAtEnd;
  } else
    return E.localPosFromDOM(O, m) + E.posAtStart;
}
function XV(r, e, t, i, n) {
  let a = Math.round((i - e.left) * r.defaultCharacterWidth);
  if (r.lineWrapping && t.height > r.defaultLineHeight * 1.5) {
    let s = r.viewState.heightOracle.textHeight, l = Math.floor((n - t.top - (r.defaultLineHeight - s) * 0.5) / s);
    a += l * r.viewState.heightOracle.lineLength;
  }
  let o = r.state.sliceDoc(t.from, t.to);
  return t.from + RI(o, a, r.state.tabSize);
}
function KIe(r, e, t) {
  let i;
  if (r.nodeType != 3 || e != (i = r.nodeValue.length))
    return !1;
  for (let n = r.nextSibling; n; n = n.nextSibling)
    if (n.nodeType != 1 || n.nodeName != "BR")
      return !1;
  return kc(r, i - 1, i).getBoundingClientRect().left > t;
}
function JIe(r, e, t) {
  if (e != 0)
    return !1;
  for (let n = r; ; ) {
    let a = n.parentNode;
    if (!a || a.nodeType != 1 || a.firstChild != n)
      return !1;
    if (a.classList.contains("cm-line"))
      break;
    n = a;
  }
  let i = r.nodeType == 1 ? r.getBoundingClientRect() : kc(r, 0, Math.max(r.nodeValue.length, 1)).getBoundingClientRect();
  return t - i.left > 5;
}
function UI(r, e) {
  let t = r.lineBlockAt(e);
  if (Array.isArray(t.type)) {
    for (let i of t.type)
      if (i.to > e || i.to == e && (i.to == t.to || i.type == ar.Text))
        return i;
  }
  return t;
}
function ewe(r, e, t, i) {
  let n = UI(r, e.head), a = !i || n.type != ar.Text || !(r.lineWrapping || n.widgetLineBreaks) ? null : r.coordsAtPos(e.assoc < 0 && e.head > n.from ? e.head - 1 : e.head);
  if (a) {
    let o = r.dom.getBoundingClientRect(), s = r.textDirectionAt(n.from), l = r.posAtCoords({
      x: t == (s == ir.LTR) ? o.right - 1 : o.left + 1,
      y: (a.top + a.bottom) / 2
    });
    if (l != null)
      return Z.cursor(l, t ? -1 : 1);
  }
  return Z.cursor(t ? n.to : n.from, t ? -1 : 1);
}
function YV(r, e, t, i) {
  let n = r.state.doc.lineAt(e.head), a = r.bidiSpans(n), o = r.textDirectionAt(n.from);
  for (let s = e, l = null; ; ) {
    let u = BIe(n, a, o, s, t), c = e6;
    if (!u) {
      if (n.number == (t ? r.state.doc.lines : 1))
        return s;
      c = `
`, n = r.state.doc.line(n.number + (t ? 1 : -1)), a = r.bidiSpans(n), u = Z.cursor(t ? n.from : n.to);
    }
    if (l) {
      if (!l(c))
        return s;
    } else {
      if (!i)
        return u;
      l = i(c);
    }
    s = u;
  }
}
function twe(r, e, t) {
  let i = r.state.charCategorizer(e), n = i(t);
  return (a) => {
    let o = i(a);
    return n == Mt.Space && (n = o), n == o;
  };
}
function rwe(r, e, t, i) {
  let n = e.head, a = t ? 1 : -1;
  if (n == (t ? r.state.doc.length : 0))
    return Z.cursor(n, e.assoc);
  let o = e.goalColumn, s, l = r.contentDOM.getBoundingClientRect(), u = r.coordsAtPos(n), c = r.documentTop;
  if (u)
    o == null && (o = u.left - l.left), s = a < 0 ? u.top : u.bottom;
  else {
    let d = r.viewState.lineBlockAt(n);
    o == null && (o = Math.min(l.right - l.left, r.defaultCharacterWidth * (n - d.from))), s = (a < 0 ? d.top : d.bottom) + c;
  }
  let h = l.left + o, f = i ?? r.viewState.heightOracle.textHeight >> 1;
  for (let d = 0; ; d += 10) {
    let p = s + (f + d) * a, g = i6(r, { x: h, y: p }, !1, a);
    if (p < l.top || p > l.bottom || (a < 0 ? g < n : g > n))
      return Z.cursor(g, e.assoc, void 0, o);
  }
}
function fE(r, e, t) {
  for (; ; ) {
    let i = 0;
    for (let n of r)
      n.between(e - 1, e + 1, (a, o, s) => {
        if (e > a && e < o) {
          let l = i || t || (e - a < o - e ? -1 : 1);
          e = l < 0 ? a : o, i = l;
        }
      });
    if (!i)
      return e;
  }
}
function pA(r, e, t) {
  let i = fE(r.state.facet($x).map((n) => n(r)), t.from, e.head > t.from ? -1 : 1);
  return i == t.from ? t : Z.cursor(i, i < t.from ? 1 : -1);
}
class iwe {
  constructor(e) {
    this.lastKeyCode = 0, this.lastKeyTime = 0, this.lastTouchTime = 0, this.lastFocusTime = 0, this.lastScrollTop = 0, this.lastScrollLeft = 0, this.chromeScrollHack = -1, this.pendingIOSKey = void 0, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastEscPress = 0, this.lastContextMenu = 0, this.scrollHandlers = [], this.registeredEvents = [], this.customHandlers = [], this.composing = -1, this.compositionFirstChange = null, this.compositionEndedAt = 0, this.compositionPendingKey = !1, this.compositionPendingChange = !1, this.mouseSelection = null;
    let t = (i, n) => {
      this.ignoreDuringComposition(n) || n.type == "keydown" && this.keydown(e, n) || (this.mustFlushObserver(n) && e.observer.forceFlush(), this.runCustomHandlers(n.type, e, n) ? n.preventDefault() : i(e, n));
    };
    for (let i in _r) {
      let n = _r[i];
      e.contentDOM.addEventListener(i, (a) => {
        HV(e, a) && t(n, a);
      }, $I[i]), this.registeredEvents.push(i);
    }
    e.scrollDOM.addEventListener("mousedown", (i) => {
      if (i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && (t(_r.mousedown, i), !i.defaultPrevented && i.button == 2)) {
        let n = e.contentDOM.style.minHeight;
        e.contentDOM.style.minHeight = "100%", setTimeout(() => e.contentDOM.style.minHeight = n, 200);
      }
    }), e.scrollDOM.addEventListener("drop", (i) => {
      i.target == e.scrollDOM && i.clientY > e.contentDOM.getBoundingClientRect().bottom && t(_r.drop, i);
    }), we.chrome && we.chrome_version == 102 && e.scrollDOM.addEventListener("wheel", () => {
      this.chromeScrollHack < 0 ? e.contentDOM.style.pointerEvents = "none" : window.clearTimeout(this.chromeScrollHack), this.chromeScrollHack = setTimeout(() => {
        this.chromeScrollHack = -1, e.contentDOM.style.pointerEvents = "";
      }, 100);
    }, { passive: !0 }), this.notifiedFocused = e.hasFocus, we.safari && e.contentDOM.addEventListener("input", () => null);
  }
  setSelectionOrigin(e) {
    this.lastSelectionOrigin = e, this.lastSelectionTime = Date.now();
  }
  ensureHandlers(e, t) {
    var i;
    let n;
    this.customHandlers = [];
    for (let a of t)
      if (n = (i = a.update(e).spec) === null || i === void 0 ? void 0 : i.domEventHandlers) {
        this.customHandlers.push({ plugin: a.value, handlers: n });
        for (let o in n)
          this.registeredEvents.indexOf(o) < 0 && o != "scroll" && (this.registeredEvents.push(o), e.contentDOM.addEventListener(o, (s) => {
            HV(e, s) && this.runCustomHandlers(o, e, s) && s.preventDefault();
          }));
      }
  }
  runCustomHandlers(e, t, i) {
    for (let n of this.customHandlers) {
      let a = n.handlers[e];
      if (a)
        try {
          if (a.call(n.plugin, i, t) || i.defaultPrevented)
            return !0;
        } catch (o) {
          ea(t.state, o);
        }
    }
    return !1;
  }
  runScrollHandlers(e, t) {
    this.lastScrollTop = e.scrollDOM.scrollTop, this.lastScrollLeft = e.scrollDOM.scrollLeft;
    for (let i of this.customHandlers) {
      let n = i.handlers.scroll;
      if (n)
        try {
          n.call(i.plugin, t, e);
        } catch (a) {
          ea(e.state, a);
        }
    }
  }
  keydown(e, t) {
    if (this.lastKeyCode = t.keyCode, this.lastKeyTime = Date.now(), t.keyCode == 9 && Date.now() < this.lastEscPress + 2e3)
      return !0;
    if (t.keyCode != 27 && a6.indexOf(t.keyCode) < 0 && (e.inputState.lastEscPress = 0), we.android && we.chrome && !t.synthetic && (t.keyCode == 13 || t.keyCode == 8))
      return e.observer.delayAndroidKey(t.key, t.keyCode), !0;
    let i;
    return we.ios && !t.synthetic && !t.altKey && !t.metaKey && ((i = n6.find((n) => n.keyCode == t.keyCode)) && !t.ctrlKey || nwe.indexOf(t.key) > -1 && t.ctrlKey && !t.shiftKey) ? (this.pendingIOSKey = i || t, setTimeout(() => this.flushIOSKey(e), 250), !0) : !1;
  }
  flushIOSKey(e) {
    let t = this.pendingIOSKey;
    return t ? (this.pendingIOSKey = void 0, df(e.contentDOM, t.key, t.keyCode)) : !1;
  }
  ignoreDuringComposition(e) {
    return /^key/.test(e.type) ? this.composing > 0 ? !0 : we.safari && !we.ios && this.compositionPendingKey && Date.now() - this.compositionEndedAt < 100 ? (this.compositionPendingKey = !1, !0) : !1 : !1;
  }
  mustFlushObserver(e) {
    return e.type == "keydown" && e.keyCode != 229;
  }
  startMouseSelection(e) {
    this.mouseSelection && this.mouseSelection.destroy(), this.mouseSelection = e;
  }
  update(e) {
    this.mouseSelection && this.mouseSelection.update(e), e.transactions.length && (this.lastKeyCode = this.lastSelectionTime = 0);
  }
  destroy() {
    this.mouseSelection && this.mouseSelection.destroy();
  }
}
const n6 = [
  { key: "Backspace", keyCode: 8, inputType: "deleteContentBackward" },
  { key: "Enter", keyCode: 13, inputType: "insertParagraph" },
  { key: "Enter", keyCode: 13, inputType: "insertLineBreak" },
  { key: "Delete", keyCode: 46, inputType: "deleteContentForward" }
], nwe = "dthko", a6 = [16, 17, 18, 20, 91, 92, 224, 225], Em = 6;
function bm(r) {
  return Math.max(0, r) * 0.7 + 8;
}
function awe(r, e) {
  return Math.max(Math.abs(r.clientX - e.clientX), Math.abs(r.clientY - e.clientY));
}
class owe {
  constructor(e, t, i, n) {
    this.view = e, this.startEvent = t, this.style = i, this.mustSelect = n, this.scrollSpeed = { x: 0, y: 0 }, this.scrolling = -1, this.lastEvent = t, this.scrollParent = _Ie(e.contentDOM), this.atoms = e.state.facet($x).map((o) => o(e));
    let a = e.contentDOM.ownerDocument;
    a.addEventListener("mousemove", this.move = this.move.bind(this)), a.addEventListener("mouseup", this.up = this.up.bind(this)), this.extend = t.shiftKey, this.multiple = e.state.facet(Rt.allowMultipleSelections) && swe(e, t), this.dragging = uwe(e, t) && u6(t) == 1 ? null : !1;
  }
  start(e) {
    this.dragging === !1 && (e.preventDefault(), this.select(e));
  }
  move(e) {
    var t;
    if (e.buttons == 0)
      return this.destroy();
    if (this.dragging || this.dragging == null && awe(this.startEvent, e) < 10)
      return;
    this.select(this.lastEvent = e);
    let i = 0, n = 0, a = ((t = this.scrollParent) === null || t === void 0 ? void 0 : t.getBoundingClientRect()) || { left: 0, top: 0, right: this.view.win.innerWidth, bottom: this.view.win.innerHeight }, o = j7(this.view);
    e.clientX - o.left <= a.left + Em ? i = -bm(a.left - e.clientX) : e.clientX + o.right >= a.right - Em && (i = bm(e.clientX - a.right)), e.clientY - o.top <= a.top + Em ? n = -bm(a.top - e.clientY) : e.clientY + o.bottom >= a.bottom - Em && (n = bm(e.clientY - a.bottom)), this.setScrollSpeed(i, n);
  }
  up(e) {
    this.dragging == null && this.select(this.lastEvent), this.dragging || e.preventDefault(), this.destroy();
  }
  destroy() {
    this.setScrollSpeed(0, 0);
    let e = this.view.contentDOM.ownerDocument;
    e.removeEventListener("mousemove", this.move), e.removeEventListener("mouseup", this.up), this.view.inputState.mouseSelection = null;
  }
  setScrollSpeed(e, t) {
    this.scrollSpeed = { x: e, y: t }, e || t ? this.scrolling < 0 && (this.scrolling = setInterval(() => this.scroll(), 50)) : this.scrolling > -1 && (clearInterval(this.scrolling), this.scrolling = -1);
  }
  scroll() {
    this.scrollParent ? (this.scrollParent.scrollLeft += this.scrollSpeed.x, this.scrollParent.scrollTop += this.scrollSpeed.y) : this.view.win.scrollBy(this.scrollSpeed.x, this.scrollSpeed.y), this.dragging === !1 && this.select(this.lastEvent);
  }
  skipAtoms(e) {
    let t = null;
    for (let i = 0; i < e.ranges.length; i++) {
      let n = e.ranges[i], a = null;
      if (n.empty) {
        let o = fE(this.atoms, n.from, 0);
        o != n.from && (a = Z.cursor(o, -1));
      } else {
        let o = fE(this.atoms, n.from, -1), s = fE(this.atoms, n.to, 1);
        (o != n.from || s != n.to) && (a = Z.range(n.from == n.anchor ? o : s, n.from == n.head ? o : s));
      }
      a && (t || (t = e.ranges.slice()), t[i] = a);
    }
    return t ? Z.create(t, e.mainIndex) : e;
  }
  select(e) {
    let { view: t } = this, i = this.skipAtoms(this.style.get(e, this.extend, this.multiple));
    (this.mustSelect || !i.eq(t.state.selection) || i.main.assoc != t.state.selection.main.assoc && this.dragging === !1) && this.view.dispatch({
      selection: i,
      userEvent: "select.pointer"
    }), this.mustSelect = !1;
  }
  update(e) {
    e.docChanged && this.dragging && (this.dragging = this.dragging.map(e.changes)), this.style.update(e) && setTimeout(() => this.select(this.lastEvent), 20);
  }
}
function swe(r, e) {
  let t = r.state.facet(G7);
  return t.length ? t[0](e) : we.mac ? e.metaKey : e.ctrlKey;
}
function lwe(r, e) {
  let t = r.state.facet(B7);
  return t.length ? t[0](e) : we.mac ? !e.altKey : !e.ctrlKey;
}
function uwe(r, e) {
  let { main: t } = r.state.selection;
  if (t.empty)
    return !1;
  let i = Kb(r.root);
  if (!i || i.rangeCount == 0)
    return !0;
  let n = i.getRangeAt(0).getClientRects();
  for (let a = 0; a < n.length; a++) {
    let o = n[a];
    if (o.left <= e.clientX && o.right >= e.clientX && o.top <= e.clientY && o.bottom >= e.clientY)
      return !0;
  }
  return !1;
}
function HV(r, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target, i; t != r.contentDOM; t = t.parentNode)
    if (!t || t.nodeType == 11 || (i = Ht.get(t)) && i.ignoreEvent(e))
      return !1;
  return !0;
}
const _r = /* @__PURE__ */ Object.create(null), $I = /* @__PURE__ */ Object.create(null), o6 = we.ie && we.ie_version < 15 || we.ios && we.webkit_version < 604;
function cwe(r) {
  let e = r.dom.parentNode;
  if (!e)
    return;
  let t = e.appendChild(document.createElement("textarea"));
  t.style.cssText = "position: fixed; left: -10000px; top: 10px", t.focus(), setTimeout(() => {
    r.focus(), t.remove(), s6(r, t.value);
  }, 50);
}
function s6(r, e) {
  let { state: t } = r, i, n = 1, a = t.toText(e), o = a.lines == t.selection.ranges.length;
  if (VI != null && t.selection.ranges.every((l) => l.empty) && VI == a.toString()) {
    let l = -1;
    i = t.changeByRange((u) => {
      let c = t.doc.lineAt(u.from);
      if (c.from == l)
        return { range: u };
      l = c.from;
      let h = t.toText((o ? a.line(n++).text : e) + t.lineBreak);
      return {
        changes: { from: c.from, insert: h },
        range: Z.cursor(u.from + h.length)
      };
    });
  } else
    o ? i = t.changeByRange((l) => {
      let u = a.line(n++);
      return {
        changes: { from: l.from, to: l.to, insert: u.text },
        range: Z.cursor(l.from + u.length)
      };
    }) : i = t.replaceSelection(a);
  r.dispatch(i, {
    userEvent: "input.paste",
    scrollIntoView: !0
  });
}
_r.keydown = (r, e) => {
  r.inputState.setSelectionOrigin("select"), e.keyCode == 27 && (r.inputState.lastEscPress = Date.now());
};
_r.touchstart = (r, e) => {
  r.inputState.lastTouchTime = Date.now(), r.inputState.setSelectionOrigin("select.pointer");
};
_r.touchmove = (r) => {
  r.inputState.setSelectionOrigin("select.pointer");
};
$I.touchstart = $I.touchmove = { passive: !0 };
_r.mousedown = (r, e) => {
  if (r.observer.flush(), r.inputState.lastTouchTime > Date.now() - 2e3)
    return;
  let t = null;
  for (let i of r.state.facet(F7))
    if (t = i(r, e), t)
      break;
  if (!t && e.button == 0 && (t = dwe(r, e)), t) {
    let i = !r.hasFocus;
    r.inputState.startMouseSelection(new owe(r, e, t, i)), i && r.observer.ignore(() => I7(r.contentDOM)), r.inputState.mouseSelection && r.inputState.mouseSelection.start(e);
  }
};
function WV(r, e, t, i) {
  if (i == 1)
    return Z.cursor(e, t);
  if (i == 2)
    return ZIe(r.state, e, t);
  {
    let n = xi.find(r.docView, e), a = r.state.doc.lineAt(n ? n.posAtEnd : e), o = n ? n.posAtStart : a.from, s = n ? n.posAtEnd : a.to;
    return s < r.state.doc.length && s == a.to && s++, Z.range(o, s);
  }
}
let l6 = (r, e) => r >= e.top && r <= e.bottom, zV = (r, e, t) => l6(e, t) && r >= t.left && r <= t.right;
function hwe(r, e, t, i) {
  let n = xi.find(r.docView, e);
  if (!n)
    return 1;
  let a = e - n.posAtStart;
  if (a == 0)
    return 1;
  if (a == n.length)
    return -1;
  let o = n.coordsAt(a, -1);
  if (o && zV(t, i, o))
    return -1;
  let s = n.coordsAt(a, 1);
  return s && zV(t, i, s) ? 1 : o && l6(i, o) ? -1 : 1;
}
function ZV(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  return { pos: t, bias: hwe(r, t, e.clientX, e.clientY) };
}
const fwe = we.ie && we.ie_version <= 11;
let qV = null, jV = 0, KV = 0;
function u6(r) {
  if (!fwe)
    return r.detail;
  let e = qV, t = KV;
  return qV = r, KV = Date.now(), jV = !e || t > Date.now() - 400 && Math.abs(e.clientX - r.clientX) < 2 && Math.abs(e.clientY - r.clientY) < 2 ? (jV + 1) % 3 : 1;
}
function dwe(r, e) {
  let t = ZV(r, e), i = u6(e), n = r.state.selection;
  return {
    update(a) {
      a.docChanged && (t.pos = a.changes.mapPos(t.pos), n = n.map(a.changes));
    },
    get(a, o, s) {
      let l = ZV(r, a), u, c = WV(r, l.pos, l.bias, i);
      if (t.pos != l.pos && !o) {
        let h = WV(r, t.pos, t.bias, i), f = Math.min(h.from, c.from), d = Math.max(h.to, c.to);
        c = f < c.from ? Z.range(f, d) : Z.range(d, f);
      }
      return o ? n.replaceRange(n.main.extend(c.from, c.to)) : s && i == 1 && n.ranges.length > 1 && (u = pwe(n, l.pos)) ? u : s ? n.addRange(c) : Z.create([c]);
    }
  };
}
function pwe(r, e) {
  for (let t = 0; t < r.ranges.length; t++) {
    let { from: i, to: n } = r.ranges[t];
    if (i <= e && n >= e)
      return Z.create(r.ranges.slice(0, t).concat(r.ranges.slice(t + 1)), r.mainIndex == t ? 0 : r.mainIndex - (r.mainIndex > t ? 1 : 0));
  }
  return null;
}
_r.dragstart = (r, e) => {
  let { selection: { main: t } } = r.state, { mouseSelection: i } = r.inputState;
  i && (i.dragging = t), e.dataTransfer && (e.dataTransfer.setData("Text", r.state.sliceDoc(t.from, t.to)), e.dataTransfer.effectAllowed = "copyMove");
};
function JV(r, e, t, i) {
  if (!t)
    return;
  let n = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1);
  e.preventDefault();
  let { mouseSelection: a } = r.inputState, o = i && a && a.dragging && lwe(r, e) ? { from: a.dragging.from, to: a.dragging.to } : null, s = { from: n, insert: t }, l = r.state.changes(o ? [o, s] : s);
  r.focus(), r.dispatch({
    changes: l,
    selection: { anchor: l.mapPos(n, -1), head: l.mapPos(n, 1) },
    userEvent: o ? "move.drop" : "input.drop"
  });
}
_r.drop = (r, e) => {
  if (!e.dataTransfer)
    return;
  if (r.state.readOnly)
    return e.preventDefault();
  let t = e.dataTransfer.files;
  if (t && t.length) {
    e.preventDefault();
    let i = Array(t.length), n = 0, a = () => {
      ++n == t.length && JV(r, e, i.filter((o) => o != null).join(r.state.lineBreak), !1);
    };
    for (let o = 0; o < t.length; o++) {
      let s = new FileReader();
      s.onerror = a, s.onload = () => {
        /[\x00-\x08\x0e-\x1f]{2}/.test(s.result) || (i[o] = s.result), a();
      }, s.readAsText(t[o]);
    }
  } else
    JV(r, e, e.dataTransfer.getData("Text"), !0);
};
_r.paste = (r, e) => {
  if (r.state.readOnly)
    return e.preventDefault();
  r.observer.flush();
  let t = o6 ? null : e.clipboardData;
  t ? (s6(r, t.getData("text/plain") || t.getData("text/uri-text")), e.preventDefault()) : cwe(r);
};
function gwe(r, e) {
  let t = r.dom.parentNode;
  if (!t)
    return;
  let i = t.appendChild(document.createElement("textarea"));
  i.style.cssText = "position: fixed; left: -10000px; top: 10px", i.value = e, i.focus(), i.selectionEnd = e.length, i.selectionStart = 0, setTimeout(() => {
    i.remove(), r.focus();
  }, 50);
}
function vwe(r) {
  let e = [], t = [], i = !1;
  for (let n of r.selection.ranges)
    n.empty || (e.push(r.sliceDoc(n.from, n.to)), t.push(n));
  if (!e.length) {
    let n = -1;
    for (let { from: a } of r.selection.ranges) {
      let o = r.doc.lineAt(a);
      o.number > n && (e.push(o.text), t.push({ from: o.from, to: Math.min(r.doc.length, o.to + 1) })), n = o.number;
    }
    i = !0;
  }
  return { text: e.join(r.lineBreak), ranges: t, linewise: i };
}
let VI = null;
_r.copy = _r.cut = (r, e) => {
  let { text: t, ranges: i, linewise: n } = vwe(r.state);
  if (!t && !n)
    return;
  VI = n ? t : null;
  let a = o6 ? null : e.clipboardData;
  a ? (e.preventDefault(), a.clearData(), a.setData("text/plain", t)) : gwe(r, t), e.type == "cut" && !r.state.readOnly && r.dispatch({
    changes: i,
    scrollIntoView: !0,
    userEvent: "delete.cut"
  });
};
const c6 = /* @__PURE__ */ ys.define();
function h6(r, e) {
  let t = [];
  for (let i of r.facet(H7)) {
    let n = i(r, e);
    n && t.push(n);
  }
  return t ? r.update({ effects: t, annotations: c6.of(!0) }) : null;
}
function f6(r) {
  setTimeout(() => {
    let e = r.hasFocus;
    if (e != r.inputState.notifiedFocused) {
      let t = h6(r.state, e);
      t ? r.dispatch(t) : r.update([]);
    }
  }, 10);
}
_r.focus = (r) => {
  r.inputState.lastFocusTime = Date.now(), !r.scrollDOM.scrollTop && (r.inputState.lastScrollTop || r.inputState.lastScrollLeft) && (r.scrollDOM.scrollTop = r.inputState.lastScrollTop, r.scrollDOM.scrollLeft = r.inputState.lastScrollLeft), f6(r);
};
_r.blur = (r) => {
  r.observer.clearSelectionRange(), f6(r);
};
_r.compositionstart = _r.compositionupdate = (r) => {
  r.inputState.compositionFirstChange == null && (r.inputState.compositionFirstChange = !0), r.inputState.composing < 0 && (r.inputState.composing = 0);
};
_r.compositionend = (r) => {
  r.inputState.composing = -1, r.inputState.compositionEndedAt = Date.now(), r.inputState.compositionPendingKey = !0, r.inputState.compositionPendingChange = r.observer.pendingRecords().length > 0, r.inputState.compositionFirstChange = null, we.chrome && we.android ? r.observer.flushSoon() : r.inputState.compositionPendingChange ? Promise.resolve().then(() => r.observer.flush()) : setTimeout(() => {
    r.inputState.composing < 0 && r.docView.hasComposition && r.update([]);
  }, 50);
};
_r.contextmenu = (r) => {
  r.inputState.lastContextMenu = Date.now();
};
_r.beforeinput = (r, e) => {
  var t;
  let i;
  if (we.chrome && we.android && (i = n6.find((n) => n.inputType == e.inputType)) && (r.observer.delayAndroidKey(i.key, i.keyCode), i.key == "Backspace" || i.key == "Delete")) {
    let n = ((t = window.visualViewport) === null || t === void 0 ? void 0 : t.height) || 0;
    setTimeout(() => {
      var a;
      (((a = window.visualViewport) === null || a === void 0 ? void 0 : a.height) || 0) > n + 10 && r.hasFocus && (r.contentDOM.blur(), r.focus());
    }, 100);
  }
};
const eG = ["pre-wrap", "normal", "pre-line", "break-spaces"];
class Owe {
  constructor(e) {
    this.lineWrapping = e, this.doc = Ct.empty, this.heightSamples = {}, this.lineHeight = 14, this.charWidth = 7, this.textHeight = 14, this.lineLength = 30, this.heightChanged = !1;
  }
  heightForGap(e, t) {
    let i = this.doc.lineAt(t).number - this.doc.lineAt(e).number + 1;
    return this.lineWrapping && (i += Math.max(0, Math.ceil((t - e - i * this.lineLength * 0.5) / this.lineLength))), this.lineHeight * i;
  }
  heightForLine(e) {
    return this.lineWrapping ? (1 + Math.max(0, Math.ceil((e - this.lineLength) / (this.lineLength - 5)))) * this.lineHeight : this.lineHeight;
  }
  setDoc(e) {
    return this.doc = e, this;
  }
  mustRefreshForWrapping(e) {
    return eG.indexOf(e) > -1 != this.lineWrapping;
  }
  mustRefreshForHeights(e) {
    let t = !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i];
      n < 0 ? i++ : this.heightSamples[Math.floor(n * 10)] || (t = !0, this.heightSamples[Math.floor(n * 10)] = !0);
    }
    return t;
  }
  refresh(e, t, i, n, a, o) {
    let s = eG.indexOf(e) > -1, l = Math.round(t) != Math.round(this.lineHeight) || this.lineWrapping != s;
    if (this.lineWrapping = s, this.lineHeight = t, this.charWidth = i, this.textHeight = n, this.lineLength = a, l) {
      this.heightSamples = {};
      for (let u = 0; u < o.length; u++) {
        let c = o[u];
        c < 0 ? u++ : this.heightSamples[Math.floor(c * 10)] = !0;
      }
    }
    return l;
  }
}
class mwe {
  constructor(e, t) {
    this.from = e, this.heights = t, this.index = 0;
  }
  get more() {
    return this.index < this.heights.length;
  }
}
class no {
  /**
  @internal
  */
  constructor(e, t, i, n, a) {
    this.from = e, this.length = t, this.top = i, this.height = n, this._content = a;
  }
  /**
  The type of element this is. When querying lines, this may be
  an array of all the blocks that make up the line.
  */
  get type() {
    return typeof this._content == "number" ? ar.Text : Array.isArray(this._content) ? this._content : this._content.type;
  }
  /**
  The end of the element as a document position.
  */
  get to() {
    return this.from + this.length;
  }
  /**
  The bottom position of the element.
  */
  get bottom() {
    return this.top + this.height;
  }
  /**
  If this is a widget block, this will return the widget
  associated with it.
  */
  get widget() {
    return this._content instanceof Bl ? this._content.widget : null;
  }
  /**
  If this is a textblock, this holds the number of line breaks
  that appear in widgets inside the block.
  */
  get widgetLineBreaks() {
    return typeof this._content == "number" ? this._content : 0;
  }
  /**
  @internal
  */
  join(e) {
    let t = (Array.isArray(this._content) ? this._content : [this]).concat(Array.isArray(e._content) ? e._content : [e]);
    return new no(this.from, this.length + e.length, this.top, this.height + e.height, t);
  }
}
var zt = /* @__PURE__ */ function(r) {
  return r[r.ByPos = 0] = "ByPos", r[r.ByHeight = 1] = "ByHeight", r[r.ByPosNoHeight = 2] = "ByPosNoHeight", r;
}(zt || (zt = {}));
const dE = 1e-3;
class Qi {
  constructor(e, t, i = 2) {
    this.length = e, this.height = t, this.flags = i;
  }
  get outdated() {
    return (this.flags & 2) > 0;
  }
  set outdated(e) {
    this.flags = (e ? 2 : 0) | this.flags & -3;
  }
  setHeight(e, t) {
    this.height != t && (Math.abs(this.height - t) > dE && (e.heightChanged = !0), this.height = t);
  }
  // Base case is to replace a leaf node, which simply builds a tree
  // from the new nodes and returns that (HeightMapBranch and
  // HeightMapGap override this to actually use from/to)
  replace(e, t, i) {
    return Qi.of(i);
  }
  // Again, these are base cases, and are overridden for branch and gap nodes.
  decomposeLeft(e, t) {
    t.push(this);
  }
  decomposeRight(e, t) {
    t.push(this);
  }
  applyChanges(e, t, i, n) {
    let a = this, o = i.doc;
    for (let s = n.length - 1; s >= 0; s--) {
      let { fromA: l, toA: u, fromB: c, toB: h } = n[s], f = a.lineAt(l, zt.ByPosNoHeight, i.setDoc(t), 0, 0), d = f.to >= u ? f : a.lineAt(u, zt.ByPosNoHeight, i, 0, 0);
      for (h += d.to - u, u = d.to; s > 0 && f.from <= n[s - 1].toA; )
        l = n[s - 1].fromA, c = n[s - 1].fromB, s--, l < f.from && (f = a.lineAt(l, zt.ByPosNoHeight, i, 0, 0));
      c += f.from - l, l = f.from;
      let p = Vx.build(i.setDoc(o), e, c, h);
      a = a.replace(l, u, p);
    }
    return a.updateHeight(i, 0);
  }
  static empty() {
    return new fn(0, 0);
  }
  // nodes uses null values to indicate the position of line breaks.
  // There are never line breaks at the start or end of the array, or
  // two line breaks next to each other, and the array isn't allowed
  // to be empty (same restrictions as return value from the builder).
  static of(e) {
    if (e.length == 1)
      return e[0];
    let t = 0, i = e.length, n = 0, a = 0;
    for (; ; )
      if (t == i)
        if (n > a * 2) {
          let s = e[t - 1];
          s.break ? e.splice(--t, 1, s.left, null, s.right) : e.splice(--t, 1, s.left, s.right), i += 1 + s.break, n -= s.size;
        } else if (a > n * 2) {
          let s = e[i];
          s.break ? e.splice(i, 1, s.left, null, s.right) : e.splice(i, 1, s.left, s.right), i += 2 + s.break, a -= s.size;
        } else
          break;
      else if (n < a) {
        let s = e[t++];
        s && (n += s.size);
      } else {
        let s = e[--i];
        s && (a += s.size);
      }
    let o = 0;
    return e[t - 1] == null ? (o = 1, t--) : e[t] == null && (o = 1, i++), new Ewe(Qi.of(e.slice(0, t)), o, Qi.of(e.slice(i)));
  }
}
Qi.prototype.size = 1;
class d6 extends Qi {
  constructor(e, t, i) {
    super(e, t), this.deco = i;
  }
  blockAt(e, t, i, n) {
    return new no(n, this.length, i, this.height, this.deco || 0);
  }
  lineAt(e, t, i, n, a) {
    return this.blockAt(0, i, n, a);
  }
  forEachLine(e, t, i, n, a, o) {
    e <= a + this.length && t >= a && o(this.blockAt(0, i, n, a));
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more && this.setHeight(e, n.heights[n.index++]), this.outdated = !1, this;
  }
  toString() {
    return `block(${this.length})`;
  }
}
class fn extends d6 {
  constructor(e, t) {
    super(e, t, null), this.collapsed = 0, this.widgetHeight = 0, this.breaks = 0;
  }
  blockAt(e, t, i, n) {
    return new no(n, this.length, i, this.height, this.breaks);
  }
  replace(e, t, i) {
    let n = i[0];
    return i.length == 1 && (n instanceof fn || n instanceof zr && n.flags & 4) && Math.abs(this.length - n.length) < 10 ? (n instanceof zr ? n = new fn(n.length, this.height) : n.height = this.height, this.outdated || (n.outdated = !1), n) : Qi.of(i);
  }
  updateHeight(e, t = 0, i = !1, n) {
    return n && n.from <= t && n.more ? this.setHeight(e, n.heights[n.index++]) : (i || this.outdated) && this.setHeight(e, Math.max(this.widgetHeight, e.heightForLine(this.length - this.collapsed)) + this.breaks * e.lineHeight), this.outdated = !1, this;
  }
  toString() {
    return `line(${this.length}${this.collapsed ? -this.collapsed : ""}${this.widgetHeight ? ":" + this.widgetHeight : ""})`;
  }
}
class zr extends Qi {
  constructor(e) {
    super(e, 0);
  }
  heightMetrics(e, t) {
    let i = e.doc.lineAt(t).number, n = e.doc.lineAt(t + this.length).number, a = n - i + 1, o, s = 0;
    if (e.lineWrapping) {
      let l = Math.min(this.height, e.lineHeight * a);
      o = l / a, this.length > a + 1 && (s = (this.height - l) / (this.length - a - 1));
    } else
      o = this.height / a;
    return { firstLine: i, lastLine: n, perLine: o, perChar: s };
  }
  blockAt(e, t, i, n) {
    let { firstLine: a, lastLine: o, perLine: s, perChar: l } = this.heightMetrics(t, n);
    if (t.lineWrapping) {
      let u = n + Math.round(Math.max(0, Math.min(1, (e - i) / this.height)) * this.length), c = t.doc.lineAt(u), h = s + c.length * l, f = Math.max(i, e - h / 2);
      return new no(c.from, c.length, f, h, 0);
    } else {
      let u = Math.max(0, Math.min(o - a, Math.floor((e - i) / s))), { from: c, length: h } = t.doc.line(a + u);
      return new no(c, h, i + s * u, s, 0);
    }
  }
  lineAt(e, t, i, n, a) {
    if (t == zt.ByHeight)
      return this.blockAt(e, i, n, a);
    if (t == zt.ByPosNoHeight) {
      let { from: d, to: p } = i.doc.lineAt(e);
      return new no(d, p - d, 0, 0, 0);
    }
    let { firstLine: o, perLine: s, perChar: l } = this.heightMetrics(i, a), u = i.doc.lineAt(e), c = s + u.length * l, h = u.number - o, f = n + s * h + l * (u.from - a - h);
    return new no(u.from, u.length, Math.max(n, Math.min(f, n + this.height - c)), c, 0);
  }
  forEachLine(e, t, i, n, a, o) {
    e = Math.max(e, a), t = Math.min(t, a + this.length);
    let { firstLine: s, perLine: l, perChar: u } = this.heightMetrics(i, a);
    for (let c = e, h = n; c <= t; ) {
      let f = i.doc.lineAt(c);
      if (c == e) {
        let p = f.number - s;
        h += l * p + u * (e - a - p);
      }
      let d = l + u * f.length;
      o(new no(f.from, f.length, h, d, 0)), h += d, c = f.to + 1;
    }
  }
  replace(e, t, i) {
    let n = this.length - t;
    if (n > 0) {
      let a = i[i.length - 1];
      a instanceof zr ? i[i.length - 1] = new zr(a.length + n) : i.push(null, new zr(n - 1));
    }
    if (e > 0) {
      let a = i[0];
      a instanceof zr ? i[0] = new zr(e + a.length) : i.unshift(new zr(e - 1), null);
    }
    return Qi.of(i);
  }
  decomposeLeft(e, t) {
    t.push(new zr(e - 1), null);
  }
  decomposeRight(e, t) {
    t.push(null, new zr(this.length - e - 1));
  }
  updateHeight(e, t = 0, i = !1, n) {
    let a = t + this.length;
    if (n && n.from <= t + this.length && n.more) {
      let o = [], s = Math.max(t, n.from), l = -1;
      for (n.from > t && o.push(new zr(n.from - t - 1).updateHeight(e, t)); s <= a && n.more; ) {
        let c = e.doc.lineAt(s).length;
        o.length && o.push(null);
        let h = n.heights[n.index++];
        l == -1 ? l = h : Math.abs(h - l) >= dE && (l = -2);
        let f = new fn(c, h);
        f.outdated = !1, o.push(f), s += c + 1;
      }
      s <= a && o.push(null, new zr(a - s).updateHeight(e, s));
      let u = Qi.of(o);
      return (l < 0 || Math.abs(u.height - this.height) >= dE || Math.abs(l - this.heightMetrics(e, t).perLine) >= dE) && (e.heightChanged = !0), u;
    } else
      (i || this.outdated) && (this.setHeight(e, e.heightForGap(t, t + this.length)), this.outdated = !1);
    return this;
  }
  toString() {
    return `gap(${this.length})`;
  }
}
class Ewe extends Qi {
  constructor(e, t, i) {
    super(e.length + t + i.length, e.height + i.height, t | (e.outdated || i.outdated ? 2 : 0)), this.left = e, this.right = i, this.size = e.size + i.size;
  }
  get break() {
    return this.flags & 1;
  }
  blockAt(e, t, i, n) {
    let a = i + this.left.height;
    return e < a ? this.left.blockAt(e, t, i, n) : this.right.blockAt(e, t, a, n + this.left.length + this.break);
  }
  lineAt(e, t, i, n, a) {
    let o = n + this.left.height, s = a + this.left.length + this.break, l = t == zt.ByHeight ? e < o : e < s, u = l ? this.left.lineAt(e, t, i, n, a) : this.right.lineAt(e, t, i, o, s);
    if (this.break || (l ? u.to < s : u.from > s))
      return u;
    let c = t == zt.ByPosNoHeight ? zt.ByPosNoHeight : zt.ByPos;
    return l ? u.join(this.right.lineAt(s, c, i, o, s)) : this.left.lineAt(s, c, i, n, a).join(u);
  }
  forEachLine(e, t, i, n, a, o) {
    let s = n + this.left.height, l = a + this.left.length + this.break;
    if (this.break)
      e < l && this.left.forEachLine(e, t, i, n, a, o), t >= l && this.right.forEachLine(e, t, i, s, l, o);
    else {
      let u = this.lineAt(l, zt.ByPos, i, n, a);
      e < u.from && this.left.forEachLine(e, u.from - 1, i, n, a, o), u.to >= e && u.from <= t && o(u), t > u.to && this.right.forEachLine(u.to + 1, t, i, s, l, o);
    }
  }
  replace(e, t, i) {
    let n = this.left.length + this.break;
    if (t < n)
      return this.balanced(this.left.replace(e, t, i), this.right);
    if (e > this.left.length)
      return this.balanced(this.left, this.right.replace(e - n, t - n, i));
    let a = [];
    e > 0 && this.decomposeLeft(e, a);
    let o = a.length;
    for (let s of i)
      a.push(s);
    if (e > 0 && tG(a, o - 1), t < this.length) {
      let s = a.length;
      this.decomposeRight(t, a), tG(a, s);
    }
    return Qi.of(a);
  }
  decomposeLeft(e, t) {
    let i = this.left.length;
    if (e <= i)
      return this.left.decomposeLeft(e, t);
    t.push(this.left), this.break && (i++, e >= i && t.push(null)), e > i && this.right.decomposeLeft(e - i, t);
  }
  decomposeRight(e, t) {
    let i = this.left.length, n = i + this.break;
    if (e >= n)
      return this.right.decomposeRight(e - n, t);
    e < i && this.left.decomposeRight(e, t), this.break && e < n && t.push(null), t.push(this.right);
  }
  balanced(e, t) {
    return e.size > 2 * t.size || t.size > 2 * e.size ? Qi.of(this.break ? [e, null, t] : [e, t]) : (this.left = e, this.right = t, this.height = e.height + t.height, this.outdated = e.outdated || t.outdated, this.size = e.size + t.size, this.length = e.length + this.break + t.length, this);
  }
  updateHeight(e, t = 0, i = !1, n) {
    let { left: a, right: o } = this, s = t + a.length + this.break, l = null;
    return n && n.from <= t + a.length && n.more ? l = a = a.updateHeight(e, t, i, n) : a.updateHeight(e, t, i), n && n.from <= s + o.length && n.more ? l = o = o.updateHeight(e, s, i, n) : o.updateHeight(e, s, i), l ? this.balanced(a, o) : (this.height = this.left.height + this.right.height, this.outdated = !1, this);
  }
  toString() {
    return this.left + (this.break ? " " : "-") + this.right;
  }
}
function tG(r, e) {
  let t, i;
  r[e] == null && (t = r[e - 1]) instanceof zr && (i = r[e + 1]) instanceof zr && r.splice(e - 1, 3, new zr(t.length + 1 + i.length));
}
const bwe = 5;
class Vx {
  constructor(e, t) {
    this.pos = e, this.oracle = t, this.nodes = [], this.lineStart = -1, this.lineEnd = -1, this.covering = null, this.writtenTo = e;
  }
  get isCovered() {
    return this.covering && this.nodes[this.nodes.length - 1] == this.covering;
  }
  span(e, t) {
    if (this.lineStart > -1) {
      let i = Math.min(t, this.lineEnd), n = this.nodes[this.nodes.length - 1];
      n instanceof fn ? n.length += i - this.pos : (i > this.pos || !this.isCovered) && this.nodes.push(new fn(i - this.pos, -1)), this.writtenTo = i, t > i && (this.nodes.push(null), this.writtenTo++, this.lineStart = -1);
    }
    this.pos = t;
  }
  point(e, t, i) {
    if (e < t || i.heightRelevant) {
      let n = i.widget ? i.widget.estimatedHeight : 0, a = i.widget ? i.widget.lineBreaks : 0;
      n < 0 && (n = this.oracle.lineHeight);
      let o = t - e;
      i.block ? this.addBlock(new d6(o, n, i)) : (o || a || n >= bwe) && this.addLineDeco(n, a, o);
    } else
      t > e && this.span(e, t);
    this.lineEnd > -1 && this.lineEnd < this.pos && (this.lineEnd = this.oracle.doc.lineAt(this.pos).to);
  }
  enterLine() {
    if (this.lineStart > -1)
      return;
    let { from: e, to: t } = this.oracle.doc.lineAt(this.pos);
    this.lineStart = e, this.lineEnd = t, this.writtenTo < e && ((this.writtenTo < e - 1 || this.nodes[this.nodes.length - 1] == null) && this.nodes.push(this.blankContent(this.writtenTo, e - 1)), this.nodes.push(null)), this.pos > e && this.nodes.push(new fn(this.pos - e, -1)), this.writtenTo = this.pos;
  }
  blankContent(e, t) {
    let i = new zr(t - e);
    return this.oracle.doc.lineAt(e).to == t && (i.flags |= 4), i;
  }
  ensureLine() {
    this.enterLine();
    let e = this.nodes.length ? this.nodes[this.nodes.length - 1] : null;
    if (e instanceof fn)
      return e;
    let t = new fn(0, -1);
    return this.nodes.push(t), t;
  }
  addBlock(e) {
    var t;
    this.enterLine();
    let i = (t = e.deco) === null || t === void 0 ? void 0 : t.type;
    i == ar.WidgetAfter && !this.isCovered && this.ensureLine(), this.nodes.push(e), this.writtenTo = this.pos = this.pos + e.length, i != ar.WidgetBefore && (this.covering = e);
  }
  addLineDeco(e, t, i) {
    let n = this.ensureLine();
    n.length += i, n.collapsed += i, n.widgetHeight = Math.max(n.widgetHeight, e), n.breaks += t, this.writtenTo = this.pos = this.pos + i;
  }
  finish(e) {
    let t = this.nodes.length == 0 ? null : this.nodes[this.nodes.length - 1];
    this.lineStart > -1 && !(t instanceof fn) && !this.isCovered ? this.nodes.push(new fn(0, -1)) : (this.writtenTo < this.pos || t == null) && this.nodes.push(this.blankContent(this.writtenTo, this.pos));
    let i = e;
    for (let n of this.nodes)
      n instanceof fn && n.updateHeight(this.oracle, i), i += n ? n.length : 1;
    return this.nodes;
  }
  // Always called with a region that on both sides either stretches
  // to a line break or the end of the document.
  // The returned array uses null to indicate line breaks, but never
  // starts or ends in a line break, or has multiple line breaks next
  // to each other.
  static build(e, t, i, n) {
    let a = new Vx(i, e);
    return kt.spans(t, i, n, a, 0), a.finish(i);
  }
}
function Swe(r, e, t) {
  let i = new Twe();
  return kt.compare(r, e, t, i, 0), i.changes;
}
class Twe {
  constructor() {
    this.changes = [];
  }
  compareRange() {
  }
  comparePoint(e, t, i, n) {
    (e < t || i && i.heightRelevant || n && n.heightRelevant) && LI(e, t, this.changes, 5);
  }
}
function ywe(r, e) {
  let t = r.getBoundingClientRect(), i = r.ownerDocument, n = i.defaultView || window, a = Math.max(0, t.left), o = Math.min(n.innerWidth, t.right), s = Math.max(0, t.top), l = Math.min(n.innerHeight, t.bottom);
  for (let u = r.parentNode; u && u != i.body; )
    if (u.nodeType == 1) {
      let c = u, h = window.getComputedStyle(c);
      if ((c.scrollHeight > c.clientHeight || c.scrollWidth > c.clientWidth) && h.overflow != "visible") {
        let f = c.getBoundingClientRect();
        a = Math.max(a, f.left), o = Math.min(o, f.right), s = Math.max(s, f.top), l = u == r.parentNode ? f.bottom : Math.min(l, f.bottom);
      }
      u = h.position == "absolute" || h.position == "fixed" ? c.offsetParent : c.parentNode;
    } else if (u.nodeType == 11)
      u = u.host;
    else
      break;
  return {
    left: a - t.left,
    right: Math.max(a, o) - t.left,
    top: s - (t.top + e),
    bottom: Math.max(s, l) - (t.top + e)
  };
}
function Rwe(r, e) {
  let t = r.getBoundingClientRect();
  return {
    left: 0,
    right: t.right - t.left,
    top: e,
    bottom: t.bottom - (t.top + e)
  };
}
class gA {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.size = i;
  }
  static same(e, t) {
    if (e.length != t.length)
      return !1;
    for (let i = 0; i < e.length; i++) {
      let n = e[i], a = t[i];
      if (n.from != a.from || n.to != a.to || n.size != a.size)
        return !1;
    }
    return !0;
  }
  draw(e) {
    return Xe.replace({ widget: new Awe(this.size, e) }).range(this.from, this.to);
  }
}
class Awe extends Rs {
  constructor(e, t) {
    super(), this.size = e, this.vertical = t;
  }
  eq(e) {
    return e.size == this.size && e.vertical == this.vertical;
  }
  toDOM() {
    let e = document.createElement("div");
    return this.vertical ? e.style.height = this.size + "px" : (e.style.width = this.size + "px", e.style.height = "2px", e.style.display = "inline-block"), e;
  }
  get estimatedHeight() {
    return this.vertical ? this.size : -1;
  }
}
class rG {
  constructor(e) {
    this.state = e, this.pixelViewport = { left: 0, right: window.innerWidth, top: 0, bottom: 0 }, this.inView = !0, this.paddingTop = 0, this.paddingBottom = 0, this.contentDOMWidth = 0, this.contentDOMHeight = 0, this.editorHeight = 0, this.editorWidth = 0, this.scrollTop = 0, this.scrolledToBottom = !0, this.scrollAnchorPos = 0, this.scrollAnchorHeight = -1, this.scaler = iG, this.scrollTarget = null, this.printing = !1, this.mustMeasureContent = !0, this.defaultTextDirection = ir.LTR, this.visibleRanges = [], this.mustEnforceCursorAssoc = !1;
    let t = e.facet(Ux).some((i) => typeof i != "function" && i.class == "cm-lineWrapping");
    this.heightOracle = new Owe(t), this.stateDeco = e.facet(rv).filter((i) => typeof i != "function"), this.heightMap = Qi.empty().applyChanges(this.stateDeco, Ct.empty, this.heightOracle.setDoc(e.doc), [new ta(0, 0, 0, e.doc.length)]), this.viewport = this.getViewport(0, null), this.updateViewportLines(), this.updateForViewport(), this.lineGaps = this.ensureLineGaps([]), this.lineGapDeco = Xe.set(this.lineGaps.map((i) => i.draw(!1))), this.computeVisibleRanges();
  }
  updateForViewport() {
    let e = [this.viewport], { main: t } = this.state.selection;
    for (let i = 0; i <= 1; i++) {
      let n = i ? t.head : t.anchor;
      if (!e.some(({ from: a, to: o }) => n >= a && n <= o)) {
        let { from: a, to: o } = this.lineBlockAt(n);
        e.push(new Sm(a, o));
      }
    }
    this.viewports = e.sort((i, n) => i.from - n.from), this.scaler = this.heightMap.height <= 7e6 ? iG : new Iwe(this.heightOracle, this.heightMap, this.viewports);
  }
  updateViewportLines() {
    this.viewportLines = [], this.heightMap.forEachLine(this.viewport.from, this.viewport.to, this.heightOracle.setDoc(this.state.doc), 0, 0, (e) => {
      this.viewportLines.push(this.scaler.scale == 1 ? e : Ip(e, this.scaler));
    });
  }
  update(e, t = null) {
    this.state = e.state;
    let i = this.stateDeco;
    this.stateDeco = this.state.facet(rv).filter((c) => typeof c != "function");
    let n = e.changedRanges, a = ta.extendWithRanges(n, Swe(i, this.stateDeco, e ? e.changes : Nr.empty(this.state.doc.length))), o = this.heightMap.height, s = this.scrolledToBottom ? null : this.scrollAnchorAt(this.scrollTop);
    this.heightMap = this.heightMap.applyChanges(this.stateDeco, e.startState.doc, this.heightOracle.setDoc(this.state.doc), a), this.heightMap.height != o && (e.flags |= 2), s ? (this.scrollAnchorPos = e.changes.mapPos(s.from, -1), this.scrollAnchorHeight = s.top) : (this.scrollAnchorPos = -1, this.scrollAnchorHeight = this.heightMap.height);
    let l = a.length ? this.mapViewport(this.viewport, e.changes) : this.viewport;
    (t && (t.range.head < l.from || t.range.head > l.to) || !this.viewportIsAppropriate(l)) && (l = this.getViewport(0, t));
    let u = !e.changes.empty || e.flags & 2 || l.from != this.viewport.from || l.to != this.viewport.to;
    this.viewport = l, this.updateForViewport(), u && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(this.mapLineGaps(this.lineGaps, e.changes))), e.flags |= this.computeVisibleRanges(), t && (this.scrollTarget = t), !this.mustEnforceCursorAssoc && e.selectionSet && e.view.lineWrapping && e.state.selection.main.empty && e.state.selection.main.assoc && !e.state.facet(z7) && (this.mustEnforceCursorAssoc = !0);
  }
  measure(e) {
    let t = e.contentDOM, i = window.getComputedStyle(t), n = this.heightOracle, a = i.whiteSpace;
    this.defaultTextDirection = i.direction == "rtl" ? ir.RTL : ir.LTR;
    let o = this.heightOracle.mustRefreshForWrapping(a), s = t.getBoundingClientRect(), l = o || this.mustMeasureContent || this.contentDOMHeight != s.height;
    this.contentDOMHeight = s.height, this.mustMeasureContent = !1;
    let u = 0, c = 0, h = parseInt(i.paddingTop) || 0, f = parseInt(i.paddingBottom) || 0;
    (this.paddingTop != h || this.paddingBottom != f) && (this.paddingTop = h, this.paddingBottom = f, u |= 10), this.editorWidth != e.scrollDOM.clientWidth && (n.lineWrapping && (l = !0), this.editorWidth = e.scrollDOM.clientWidth, u |= 8), this.scrollTop != e.scrollDOM.scrollTop && (this.scrollAnchorHeight = -1, this.scrollTop = e.scrollDOM.scrollTop), this.scrolledToBottom = N7(e.scrollDOM);
    let d = (this.printing ? Rwe : ywe)(t, this.paddingTop), p = d.top - this.pixelViewport.top, g = d.bottom - this.pixelViewport.bottom;
    this.pixelViewport = d;
    let v = this.pixelViewport.bottom > this.pixelViewport.top && this.pixelViewport.right > this.pixelViewport.left;
    if (v != this.inView && (this.inView = v, v && (l = !0)), !this.inView && !this.scrollTarget)
      return 0;
    let O = s.width;
    if ((this.contentDOMWidth != O || this.editorHeight != e.scrollDOM.clientHeight) && (this.contentDOMWidth = s.width, this.editorHeight = e.scrollDOM.clientHeight, u |= 8), l) {
      let E = e.docView.measureVisibleLineHeights(this.viewport);
      if (n.mustRefreshForHeights(E) && (o = !0), o || n.lineWrapping && Math.abs(O - this.contentDOMWidth) > n.charWidth) {
        let { lineHeight: b, charWidth: S, textHeight: T } = e.docView.measureTextSize();
        o = b > 0 && n.refresh(a, b, S, T, O / S, E), o && (e.docView.minWidth = 0, u |= 8);
      }
      p > 0 && g > 0 ? c = Math.max(p, g) : p < 0 && g < 0 && (c = Math.min(p, g)), n.heightChanged = !1;
      for (let b of this.viewports) {
        let S = b.from == this.viewport.from ? E : e.docView.measureVisibleLineHeights(b);
        this.heightMap = (o ? Qi.empty().applyChanges(this.stateDeco, Ct.empty, this.heightOracle, [new ta(0, 0, 0, e.state.doc.length)]) : this.heightMap).updateHeight(n, 0, o, new mwe(b.from, S));
      }
      n.heightChanged && (u |= 2);
    }
    let m = !this.viewportIsAppropriate(this.viewport, c) || this.scrollTarget && (this.scrollTarget.range.head < this.viewport.from || this.scrollTarget.range.head > this.viewport.to);
    return m && (this.viewport = this.getViewport(c, this.scrollTarget)), this.updateForViewport(), (u & 2 || m) && this.updateViewportLines(), (this.lineGaps.length || this.viewport.to - this.viewport.from > 4e3) && this.updateLineGaps(this.ensureLineGaps(o ? [] : this.lineGaps, e)), u |= this.computeVisibleRanges(), this.mustEnforceCursorAssoc && (this.mustEnforceCursorAssoc = !1, e.docView.enforceCursorAssoc()), u;
  }
  get visibleTop() {
    return this.scaler.fromDOM(this.pixelViewport.top);
  }
  get visibleBottom() {
    return this.scaler.fromDOM(this.pixelViewport.bottom);
  }
  getViewport(e, t) {
    let i = 0.5 - Math.max(-0.5, Math.min(0.5, e / 1e3 / 2)), n = this.heightMap, a = this.heightOracle, { visibleTop: o, visibleBottom: s } = this, l = new Sm(n.lineAt(o - i * 1e3, zt.ByHeight, a, 0, 0).from, n.lineAt(s + (1 - i) * 1e3, zt.ByHeight, a, 0, 0).to);
    if (t) {
      let { head: u } = t.range;
      if (u < l.from || u > l.to) {
        let c = Math.min(this.editorHeight, this.pixelViewport.bottom - this.pixelViewport.top), h = n.lineAt(u, zt.ByPos, a, 0, 0), f;
        t.y == "center" ? f = (h.top + h.bottom) / 2 - c / 2 : t.y == "start" || t.y == "nearest" && u < l.from ? f = h.top : f = h.bottom - c, l = new Sm(n.lineAt(f - 1e3 / 2, zt.ByHeight, a, 0, 0).from, n.lineAt(f + c + 1e3 / 2, zt.ByHeight, a, 0, 0).to);
      }
    }
    return l;
  }
  mapViewport(e, t) {
    let i = t.mapPos(e.from, -1), n = t.mapPos(e.to, 1);
    return new Sm(this.heightMap.lineAt(i, zt.ByPos, this.heightOracle, 0, 0).from, this.heightMap.lineAt(n, zt.ByPos, this.heightOracle, 0, 0).to);
  }
  // Checks if a given viewport covers the visible part of the
  // document and not too much beyond that.
  viewportIsAppropriate({ from: e, to: t }, i = 0) {
    if (!this.inView)
      return !0;
    let { top: n } = this.heightMap.lineAt(e, zt.ByPos, this.heightOracle, 0, 0), { bottom: a } = this.heightMap.lineAt(t, zt.ByPos, this.heightOracle, 0, 0), { visibleTop: o, visibleBottom: s } = this;
    return (e == 0 || n <= o - Math.max(10, Math.min(
      -i,
      250
      /* MaxCoverMargin */
    ))) && (t == this.state.doc.length || a >= s + Math.max(10, Math.min(
      i,
      250
      /* MaxCoverMargin */
    ))) && n > o - 2 * 1e3 && a < s + 2 * 1e3;
  }
  mapLineGaps(e, t) {
    if (!e.length || t.empty)
      return e;
    let i = [];
    for (let n of e)
      t.touchesRange(n.from, n.to) || i.push(new gA(t.mapPos(n.from), t.mapPos(n.to), n.size));
    return i;
  }
  // Computes positions in the viewport where the start or end of a
  // line should be hidden, trying to reuse existing line gaps when
  // appropriate to avoid unneccesary redraws.
  // Uses crude character-counting for the positioning and sizing,
  // since actual DOM coordinates aren't always available and
  // predictable. Relies on generous margins (see LG.Margin) to hide
  // the artifacts this might produce from the user.
  ensureLineGaps(e, t) {
    let i = this.heightOracle.lineWrapping, n = i ? 1e4 : 2e3, a = n >> 1, o = n << 1;
    if (this.defaultTextDirection != ir.LTR && !i)
      return [];
    let s = [], l = (u, c, h, f) => {
      if (c - u < a)
        return;
      let d = this.state.selection.main, p = [d.from];
      d.empty || p.push(d.to);
      for (let v of p)
        if (v > u && v < c) {
          l(u, v - 10, h, f), l(v + 10, c, h, f);
          return;
        }
      let g = Cwe(e, (v) => v.from >= h.from && v.to <= h.to && Math.abs(v.from - u) < a && Math.abs(v.to - c) < a && !p.some((O) => v.from < O && v.to > O));
      if (!g) {
        if (c < h.to && t && i && t.visibleRanges.some((v) => v.from <= c && v.to >= c)) {
          let v = t.moveToLineBoundary(Z.cursor(c), !1, !0).head;
          v > u && (c = v);
        }
        g = new gA(u, c, this.gapSize(h, u, c, f));
      }
      s.push(g);
    };
    for (let u of this.viewportLines) {
      if (u.length < o)
        continue;
      let c = _we(u.from, u.to, this.stateDeco);
      if (c.total < o)
        continue;
      let h = this.scrollTarget ? this.scrollTarget.range.head : null, f, d;
      if (i) {
        let p = n / this.heightOracle.lineLength * this.heightOracle.lineHeight, g, v;
        if (h != null) {
          let O = ym(c, h), m = ((this.visibleBottom - this.visibleTop) / 2 + p) / u.height;
          g = O - m, v = O + m;
        } else
          g = (this.visibleTop - u.top - p) / u.height, v = (this.visibleBottom - u.top + p) / u.height;
        f = Tm(c, g), d = Tm(c, v);
      } else {
        let p = c.total * this.heightOracle.charWidth, g = n * this.heightOracle.charWidth, v, O;
        if (h != null) {
          let m = ym(c, h), E = ((this.pixelViewport.right - this.pixelViewport.left) / 2 + g) / p;
          v = m - E, O = m + E;
        } else
          v = (this.pixelViewport.left - g) / p, O = (this.pixelViewport.right + g) / p;
        f = Tm(c, v), d = Tm(c, O);
      }
      f > u.from && l(u.from, f, u, c), d < u.to && l(d, u.to, u, c);
    }
    return s;
  }
  gapSize(e, t, i, n) {
    let a = ym(n, i) - ym(n, t);
    return this.heightOracle.lineWrapping ? e.height * a : n.total * this.heightOracle.charWidth * a;
  }
  updateLineGaps(e) {
    gA.same(e, this.lineGaps) || (this.lineGaps = e, this.lineGapDeco = Xe.set(e.map((t) => t.draw(this.heightOracle.lineWrapping))));
  }
  computeVisibleRanges() {
    let e = this.stateDeco;
    this.lineGaps.length && (e = e.concat(this.lineGapDeco));
    let t = [];
    kt.spans(e, this.viewport.from, this.viewport.to, {
      span(n, a) {
        t.push({ from: n, to: a });
      },
      point() {
      }
    }, 20);
    let i = t.length != this.visibleRanges.length || this.visibleRanges.some((n, a) => n.from != t[a].from || n.to != t[a].to);
    return this.visibleRanges = t, i ? 4 : 0;
  }
  lineBlockAt(e) {
    return e >= this.viewport.from && e <= this.viewport.to && this.viewportLines.find((t) => t.from <= e && t.to >= e) || Ip(this.heightMap.lineAt(e, zt.ByPos, this.heightOracle, 0, 0), this.scaler);
  }
  lineBlockAtHeight(e) {
    return Ip(this.heightMap.lineAt(this.scaler.fromDOM(e), zt.ByHeight, this.heightOracle, 0, 0), this.scaler);
  }
  scrollAnchorAt(e) {
    let t = this.lineBlockAtHeight(e + 8);
    return t.from >= this.viewport.from || this.viewportLines[0].top - e > 200 ? t : this.viewportLines[0];
  }
  elementAtHeight(e) {
    return Ip(this.heightMap.blockAt(this.scaler.fromDOM(e), this.heightOracle, 0, 0), this.scaler);
  }
  get docHeight() {
    return this.scaler.toDOM(this.heightMap.height);
  }
  get contentHeight() {
    return this.docHeight + this.paddingTop + this.paddingBottom;
  }
}
class Sm {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
function _we(r, e, t) {
  let i = [], n = r, a = 0;
  return kt.spans(t, r, e, {
    span() {
    },
    point(o, s) {
      o > n && (i.push({ from: n, to: o }), a += o - n), n = s;
    }
  }, 20), n < e && (i.push({ from: n, to: e }), a += e - n), { total: a, ranges: i };
}
function Tm({ total: r, ranges: e }, t) {
  if (t <= 0)
    return e[0].from;
  if (t >= 1)
    return e[e.length - 1].to;
  let i = Math.floor(r * t);
  for (let n = 0; ; n++) {
    let { from: a, to: o } = e[n], s = o - a;
    if (i <= s)
      return a + i;
    i -= s;
  }
}
function ym(r, e) {
  let t = 0;
  for (let { from: i, to: n } of r.ranges) {
    if (e <= n) {
      t += e - i;
      break;
    }
    t += n - i;
  }
  return t / r.total;
}
function Cwe(r, e) {
  for (let t of r)
    if (e(t))
      return t;
}
const iG = {
  toDOM(r) {
    return r;
  },
  fromDOM(r) {
    return r;
  },
  scale: 1
};
class Iwe {
  constructor(e, t, i) {
    let n = 0, a = 0, o = 0;
    this.viewports = i.map(({ from: s, to: l }) => {
      let u = t.lineAt(s, zt.ByPos, e, 0, 0).top, c = t.lineAt(l, zt.ByPos, e, 0, 0).bottom;
      return n += c - u, { from: s, to: l, top: u, bottom: c, domTop: 0, domBottom: 0 };
    }), this.scale = (7e6 - n) / (t.height - n);
    for (let s of this.viewports)
      s.domTop = o + (s.top - a) * this.scale, o = s.domBottom = s.domTop + (s.bottom - s.top), a = s.bottom;
  }
  toDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let a = t < this.viewports.length ? this.viewports[t] : null;
      if (!a || e < a.top)
        return n + (e - i) * this.scale;
      if (e <= a.bottom)
        return a.domTop + (e - a.top);
      i = a.bottom, n = a.domBottom;
    }
  }
  fromDOM(e) {
    for (let t = 0, i = 0, n = 0; ; t++) {
      let a = t < this.viewports.length ? this.viewports[t] : null;
      if (!a || e < a.domTop)
        return i + (e - n) / this.scale;
      if (e <= a.domBottom)
        return a.top + (e - a.domTop);
      i = a.bottom, n = a.domBottom;
    }
  }
}
function Ip(r, e) {
  if (e.scale == 1)
    return r;
  let t = e.toDOM(r.top), i = e.toDOM(r.bottom);
  return new no(r.from, r.length, t, i - t, Array.isArray(r._content) ? r._content.map((n) => Ip(n, e)) : r._content);
}
const Rm = /* @__PURE__ */ Ce.define({ combine: (r) => r.join(" ") }), GI = /* @__PURE__ */ Ce.define({ combine: (r) => r.indexOf(!0) > -1 }), BI = /* @__PURE__ */ $l.newName(), p6 = /* @__PURE__ */ $l.newName(), g6 = /* @__PURE__ */ $l.newName(), v6 = { "&light": "." + p6, "&dark": "." + g6 };
function FI(r, e, t) {
  return new $l(e, {
    finish(i) {
      return /&/.test(i) ? i.replace(/&\w*/, (n) => {
        if (n == "&")
          return r;
        if (!t || !t[n])
          throw new RangeError(`Unsupported selector: ${n}`);
        return t[n];
      }) : r + " " + i;
    }
  });
}
const wwe = /* @__PURE__ */ FI("." + BI, {
  "&": {
    position: "relative !important",
    boxSizing: "border-box",
    "&.cm-focused": {
      // Provide a simple default outline to make sure a focused
      // editor is visually distinct. Can't leave the default behavior
      // because that will apply to the content element, which is
      // inside the scrollable container and doesn't include the
      // gutters. We also can't use an 'auto' outline, since those
      // are, for some reason, drawn behind the element content, which
      // will cause things like the active line background to cover
      // the outline (#297).
      outline: "1px dotted #212121"
    },
    display: "flex !important",
    flexDirection: "column"
  },
  ".cm-scroller": {
    display: "flex !important",
    alignItems: "flex-start !important",
    fontFamily: "monospace",
    lineHeight: 1.4,
    height: "100%",
    overflowX: "auto",
    position: "relative",
    zIndex: 0
  },
  ".cm-content": {
    margin: 0,
    flexGrow: 2,
    flexShrink: 0,
    display: "block",
    whiteSpace: "pre",
    wordWrap: "normal",
    boxSizing: "border-box",
    padding: "4px 0",
    outline: "none",
    "&[contenteditable=true]": {
      WebkitUserModify: "read-write-plaintext-only"
    }
  },
  ".cm-lineWrapping": {
    whiteSpace_fallback: "pre-wrap",
    whiteSpace: "break-spaces",
    wordBreak: "break-word",
    overflowWrap: "anywhere",
    flexShrink: 1
  },
  "&light .cm-content": { caretColor: "black" },
  "&dark .cm-content": { caretColor: "white" },
  ".cm-line": {
    display: "block",
    padding: "0 2px 0 6px"
  },
  ".cm-layer": {
    position: "absolute",
    left: 0,
    top: 0,
    contain: "size style",
    "& > *": {
      position: "absolute"
    }
  },
  "&light .cm-selectionBackground": {
    background: "#d9d9d9"
  },
  "&dark .cm-selectionBackground": {
    background: "#222"
  },
  "&light.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#d7d4f0"
  },
  "&dark.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground": {
    background: "#233"
  },
  ".cm-cursorLayer": {
    pointerEvents: "none"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer": {
    animation: "steps(1) cm-blink 1.2s infinite"
  },
  // Two animations defined so that we can switch between them to
  // restart the animation without forcing another style
  // recomputation.
  "@keyframes cm-blink": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  "@keyframes cm-blink2": { "0%": {}, "50%": { opacity: 0 }, "100%": {} },
  ".cm-cursor, .cm-dropCursor": {
    borderLeft: "1.2px solid black",
    marginLeft: "-0.6px",
    pointerEvents: "none"
  },
  ".cm-cursor": {
    display: "none"
  },
  "&dark .cm-cursor": {
    borderLeftColor: "#444"
  },
  ".cm-dropCursor": {
    position: "absolute"
  },
  "&.cm-focused > .cm-scroller > .cm-cursorLayer .cm-cursor": {
    display: "block"
  },
  "&light .cm-activeLine": { backgroundColor: "#cceeff44" },
  "&dark .cm-activeLine": { backgroundColor: "#99eeff33" },
  "&light .cm-specialChar": { color: "red" },
  "&dark .cm-specialChar": { color: "#f78" },
  ".cm-gutters": {
    flexShrink: 0,
    display: "flex",
    height: "100%",
    boxSizing: "border-box",
    insetInlineStart: 0,
    zIndex: 200
  },
  "&light .cm-gutters": {
    backgroundColor: "#f5f5f5",
    color: "#6c6c6c",
    borderRight: "1px solid #ddd"
  },
  "&dark .cm-gutters": {
    backgroundColor: "#333338",
    color: "#ccc"
  },
  ".cm-gutter": {
    display: "flex !important",
    flexDirection: "column",
    flexShrink: 0,
    boxSizing: "border-box",
    minHeight: "100%",
    overflow: "hidden"
  },
  ".cm-gutterElement": {
    boxSizing: "border-box"
  },
  ".cm-lineNumbers .cm-gutterElement": {
    padding: "0 3px 0 5px",
    minWidth: "20px",
    textAlign: "right",
    whiteSpace: "nowrap"
  },
  "&light .cm-activeLineGutter": {
    backgroundColor: "#e2f2ff"
  },
  "&dark .cm-activeLineGutter": {
    backgroundColor: "#222227"
  },
  ".cm-panels": {
    boxSizing: "border-box",
    position: "sticky",
    left: 0,
    right: 0
  },
  "&light .cm-panels": {
    backgroundColor: "#f5f5f5",
    color: "black"
  },
  "&light .cm-panels-top": {
    borderBottom: "1px solid #ddd"
  },
  "&light .cm-panels-bottom": {
    borderTop: "1px solid #ddd"
  },
  "&dark .cm-panels": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tab": {
    display: "inline-block",
    overflow: "hidden",
    verticalAlign: "bottom"
  },
  ".cm-widgetBuffer": {
    verticalAlign: "text-top",
    height: "1em",
    width: 0,
    display: "inline"
  },
  ".cm-placeholder": {
    color: "#888",
    display: "inline-block",
    verticalAlign: "top"
  },
  ".cm-highlightSpace:before": {
    content: "attr(data-display)",
    position: "absolute",
    pointerEvents: "none",
    color: "#888"
  },
  ".cm-highlightTab": {
    backgroundImage: `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" width="200" height="20"><path stroke="%23888" stroke-width="1" fill="none" d="M1 10H196L190 5M190 15L196 10M197 4L197 16"/></svg>')`,
    backgroundSize: "auto 100%",
    backgroundPosition: "right 90%",
    backgroundRepeat: "no-repeat"
  },
  ".cm-trailingSpace": {
    backgroundColor: "#ff332255"
  },
  ".cm-button": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    padding: ".2em 1em",
    borderRadius: "1px"
  },
  "&light .cm-button": {
    backgroundImage: "linear-gradient(#eff1f5, #d9d9df)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#b4b4b4, #d0d3d6)"
    }
  },
  "&dark .cm-button": {
    backgroundImage: "linear-gradient(#393939, #111)",
    border: "1px solid #888",
    "&:active": {
      backgroundImage: "linear-gradient(#111, #333)"
    }
  },
  ".cm-textfield": {
    verticalAlign: "middle",
    color: "inherit",
    fontSize: "70%",
    border: "1px solid silver",
    padding: ".2em .5em"
  },
  "&light .cm-textfield": {
    backgroundColor: "white"
  },
  "&dark .cm-textfield": {
    border: "1px solid #555",
    backgroundColor: "inherit"
  }
}, v6);
class Nwe {
  constructor(e, t, i, n) {
    this.typeOver = n, this.bounds = null, this.text = "";
    let { impreciseHead: a, impreciseAnchor: o } = e.docView;
    if (e.state.readOnly && t > -1)
      this.newSel = null;
    else if (t > -1 && (this.bounds = e.docView.domBoundsAround(t, i, 0))) {
      let s = a || o ? [] : Pwe(e), l = new D7(s, e.state);
      l.readRange(this.bounds.startDOM, this.bounds.endDOM), this.text = l.text, this.newSel = Lwe(s, this.bounds.from);
    } else {
      let s = e.observer.selectionRange, l = a && a.node == s.focusNode && a.offset == s.focusOffset || !CI(e.contentDOM, s.focusNode) ? e.state.selection.main.head : e.docView.posFromDOM(s.focusNode, s.focusOffset), u = o && o.node == s.anchorNode && o.offset == s.anchorOffset || !CI(e.contentDOM, s.anchorNode) ? e.state.selection.main.anchor : e.docView.posFromDOM(s.anchorNode, s.anchorOffset);
      this.newSel = Z.single(u, l);
    }
  }
}
function O6(r, e) {
  let t, { newSel: i } = e, n = r.state.selection.main, a = r.inputState.lastKeyTime > Date.now() - 100 ? r.inputState.lastKeyCode : -1;
  if (e.bounds) {
    let { from: o, to: s } = e.bounds, l = n.from, u = null;
    (a === 8 || we.android && e.text.length < s - o) && (l = n.to, u = "end");
    let c = xwe(r.state.doc.sliceString(o, s, qh), e.text, l - o, u);
    c && (we.chrome && a == 13 && c.toB == c.from + 2 && e.text.slice(c.from, c.toB) == qh + qh && c.toB--, t = {
      from: o + c.from,
      to: o + c.toA,
      insert: Ct.of(e.text.slice(c.from, c.toB).split(qh))
    });
  } else
    i && (!r.hasFocus && r.state.facet(zT) || i.main.eq(n)) && (i = null);
  if (!t && !i)
    return !1;
  if (!t && e.typeOver && !n.empty && i && i.main.empty ? t = { from: n.from, to: n.to, insert: r.state.doc.slice(n.from, n.to) } : t && t.from >= n.from && t.to <= n.to && (t.from != n.from || t.to != n.to) && n.to - n.from - (t.to - t.from) <= 4 ? t = {
    from: n.from,
    to: n.to,
    insert: r.state.doc.slice(n.from, t.from).append(t.insert).append(r.state.doc.slice(t.to, n.to))
  } : (we.mac || we.android) && t && t.from == t.to && t.from == n.head - 1 && /^\. ?$/.test(t.insert.toString()) && r.contentDOM.getAttribute("autocorrect") == "off" ? (i && t.insert.length == 2 && (i = Z.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: Ct.of([" "]) }) : we.chrome && t && t.from == t.to && t.from == n.head && t.insert.toString() == `
 ` && r.lineWrapping && (i && (i = Z.single(i.main.anchor - 1, i.main.head - 1)), t = { from: n.from, to: n.to, insert: Ct.of([" "]) }), t) {
    let o = r.state;
    if (we.ios && r.inputState.flushIOSKey(r) || we.android && (t.from == n.from && t.to == n.to && t.insert.length == 1 && t.insert.lines == 2 && df(r.contentDOM, "Enter", 13) || (t.from == n.from - 1 && t.to == n.to && t.insert.length == 0 || a == 8 && t.insert.length < t.to - t.from) && df(r.contentDOM, "Backspace", 8) || t.from == n.from && t.to == n.to + 1 && t.insert.length == 0 && df(r.contentDOM, "Delete", 46)))
      return !0;
    let s = t.insert.toString();
    if (r.state.facet(Y7).some((c) => c(r, t.from, t.to, s)))
      return !0;
    r.inputState.composing >= 0 && r.inputState.composing++;
    let l;
    if (t.from >= n.from && t.to <= n.to && t.to - t.from >= (n.to - n.from) / 3 && (!i || i.main.empty && i.main.from == t.from + t.insert.length) && r.inputState.composing < 0) {
      let c = n.from < t.from ? o.sliceDoc(n.from, t.from) : "", h = n.to > t.to ? o.sliceDoc(t.to, n.to) : "";
      l = o.replaceSelection(r.state.toText(c + t.insert.sliceString(0, void 0, r.state.lineBreak) + h));
    } else {
      let c = o.changes(t), h = i && i.main.to <= c.newLength ? i.main : void 0;
      if (o.selection.ranges.length > 1 && r.inputState.composing >= 0 && t.to <= n.to && t.to >= n.to - 10) {
        let f = r.state.sliceDoc(t.from, t.to), d = t6(r) || r.state.doc.lineAt(n.head), p = n.to - t.to, g = n.to - n.from;
        l = o.changeByRange((v) => {
          if (v.from == n.from && v.to == n.to)
            return { changes: c, range: h || v.map(c) };
          let O = v.to - p, m = O - f.length;
          if (v.to - v.from != g || r.state.sliceDoc(m, O) != f || // Unfortunately, there's no way to make multiple
          // changes in the same node work without aborting
          // composition, so cursors in the composition range are
          // ignored.
          d && v.to >= d.from && v.from <= d.to)
            return { range: v };
          let E = o.changes({ from: m, to: O, insert: t.insert }), b = v.to - n.to;
          return {
            changes: E,
            range: h ? Z.range(Math.max(0, h.anchor + b), Math.max(0, h.head + b)) : v.map(E)
          };
        });
      } else
        l = {
          changes: c,
          selection: h && o.selection.replaceRange(h)
        };
    }
    let u = "input.type";
    return (r.composing || r.inputState.compositionPendingChange && r.inputState.compositionEndedAt > Date.now() - 50) && (r.inputState.compositionPendingChange = !1, u += ".compose", r.inputState.compositionFirstChange && (u += ".start", r.inputState.compositionFirstChange = !1)), r.dispatch(l, { scrollIntoView: !0, userEvent: u }), !0;
  } else if (i && !i.main.eq(n)) {
    let o = !1, s = "select";
    return r.inputState.lastSelectionTime > Date.now() - 50 && (r.inputState.lastSelectionOrigin == "select" && (o = !0), s = r.inputState.lastSelectionOrigin), r.dispatch({ selection: i, scrollIntoView: o, userEvent: s }), !0;
  } else
    return !1;
}
function xwe(r, e, t, i) {
  let n = Math.min(r.length, e.length), a = 0;
  for (; a < n && r.charCodeAt(a) == e.charCodeAt(a); )
    a++;
  if (a == n && r.length == e.length)
    return null;
  let o = r.length, s = e.length;
  for (; o > 0 && s > 0 && r.charCodeAt(o - 1) == e.charCodeAt(s - 1); )
    o--, s--;
  if (i == "end") {
    let l = Math.max(0, a - Math.min(o, s));
    t -= o + l - a;
  }
  if (o < a && r.length < e.length) {
    let l = t <= a && t >= o ? a - t : 0;
    a -= l, s = a + (s - o), o = a;
  } else if (s < a) {
    let l = t <= a && t >= s ? a - t : 0;
    a -= l, o = a + (o - s), s = a;
  }
  return { from: a, toA: o, toB: s };
}
function Pwe(r) {
  let e = [];
  if (r.root.activeElement != r.contentDOM)
    return e;
  let { anchorNode: t, anchorOffset: i, focusNode: n, focusOffset: a } = r.observer.selectionRange;
  return t && (e.push(new PV(t, i)), (n != t || a != i) && e.push(new PV(n, a))), e;
}
function Lwe(r, e) {
  if (r.length == 0)
    return null;
  let t = r[0].pos, i = r.length == 2 ? r[1].pos : t;
  return t > -1 && i > -1 ? Z.single(t + e, i + e) : null;
}
const Dwe = {
  childList: !0,
  characterData: !0,
  subtree: !0,
  attributes: !0,
  characterDataOldValue: !0
}, vA = we.ie && we.ie_version <= 11;
class Mwe {
  constructor(e) {
    this.view = e, this.active = !1, this.selectionRange = new CIe(), this.selectionChanged = !1, this.delayedFlush = -1, this.resizeTimeout = -1, this.queue = [], this.delayedAndroidKey = null, this.flushingAndroidKey = -1, this.lastChange = 0, this.scrollTargets = [], this.intersection = null, this.resizeScroll = null, this.resizeContent = null, this.intersecting = !1, this.gapIntersection = null, this.gaps = [], this.parentCheck = -1, this.dom = e.contentDOM, this.observer = new MutationObserver((t) => {
      for (let i of t)
        this.queue.push(i);
      (we.ie && we.ie_version <= 11 || we.ios && e.composing) && t.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), vA && (this.onCharData = (t) => {
      this.queue.push({
        target: t.target,
        type: "characterData",
        oldValue: t.prevValue
      }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this), this.onResize = this.onResize.bind(this), this.onPrint = this.onPrint.bind(this), this.onScroll = this.onScroll.bind(this), typeof ResizeObserver == "function" && (this.resizeScroll = new ResizeObserver(() => {
      var t;
      ((t = this.view.docView) === null || t === void 0 ? void 0 : t.lastUpdate) < Date.now() - 75 && this.onResize();
    }), this.resizeScroll.observe(e.scrollDOM), this.resizeContent = new ResizeObserver(() => this.view.requestMeasure()), this.resizeContent.observe(e.contentDOM)), this.addWindowListeners(this.win = e.win), this.start(), typeof IntersectionObserver == "function" && (this.intersection = new IntersectionObserver((t) => {
      this.parentCheck < 0 && (this.parentCheck = setTimeout(this.listenForScroll.bind(this), 1e3)), t.length > 0 && t[t.length - 1].intersectionRatio > 0 != this.intersecting && (this.intersecting = !this.intersecting, this.intersecting != this.view.inView && this.onScrollChanged(document.createEvent("Event")));
    }, { threshold: [0, 1e-3] }), this.intersection.observe(this.dom), this.gapIntersection = new IntersectionObserver((t) => {
      t.length > 0 && t[t.length - 1].intersectionRatio > 0 && this.onScrollChanged(document.createEvent("Event"));
    }, {})), this.listenForScroll(), this.readSelectionRange();
  }
  onScrollChanged(e) {
    this.view.inputState.runScrollHandlers(this.view, e), this.intersecting && this.view.measure();
  }
  onScroll(e) {
    this.intersecting && this.flush(!1), this.onScrollChanged(e);
  }
  onResize() {
    this.resizeTimeout < 0 && (this.resizeTimeout = setTimeout(() => {
      this.resizeTimeout = -1, this.view.requestMeasure();
    }, 50));
  }
  onPrint() {
    this.view.viewState.printing = !0, this.view.measure(), setTimeout(() => {
      this.view.viewState.printing = !1, this.view.requestMeasure();
    }, 500);
  }
  updateGaps(e) {
    if (this.gapIntersection && (e.length != this.gaps.length || this.gaps.some((t, i) => t != e[i]))) {
      this.gapIntersection.disconnect();
      for (let t of e)
        this.gapIntersection.observe(t);
      this.gaps = e;
    }
  }
  onSelectionChange(e) {
    let t = this.selectionChanged;
    if (!this.readSelectionRange() || this.delayedAndroidKey)
      return;
    let { view: i } = this, n = this.selectionRange;
    if (i.state.facet(zT) ? i.root.activeElement != this.dom : !hE(i.dom, n))
      return;
    let a = n.anchorNode && i.docView.nearest(n.anchorNode);
    if (a && a.ignoreEvent(e)) {
      t || (this.selectionChanged = !1);
      return;
    }
    (we.ie && we.ie_version <= 11 || we.android && we.chrome) && !i.state.selection.main.empty && // (Selection.isCollapsed isn't reliable on IE)
    n.focusNode && Jb(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) ? this.flushSoon() : this.flush(!1);
  }
  readSelectionRange() {
    let { view: e } = this, t = we.safari && e.root.nodeType == 11 && yIe(this.dom.ownerDocument) == this.dom && kwe(this.view) || Kb(e.root);
    if (!t || this.selectionRange.eq(t))
      return !1;
    let i = hE(this.dom, t);
    return i && !this.selectionChanged && e.inputState.lastFocusTime > Date.now() - 200 && e.inputState.lastTouchTime < Date.now() - 300 && wIe(this.dom, t) ? (this.view.inputState.lastFocusTime = 0, e.docView.updateSelection(), !1) : (this.selectionRange.setRange(t), i && (this.selectionChanged = !0), !0);
  }
  setSelectionRange(e, t) {
    this.selectionRange.set(e.node, e.offset, t.node, t.offset), this.selectionChanged = !1;
  }
  clearSelectionRange() {
    this.selectionRange.set(null, 0, null, 0);
  }
  listenForScroll() {
    this.parentCheck = -1;
    let e = 0, t = null;
    for (let i = this.dom; i; )
      if (i.nodeType == 1)
        !t && e < this.scrollTargets.length && this.scrollTargets[e] == i ? e++ : t || (t = this.scrollTargets.slice(0, e)), t && t.push(i), i = i.assignedSlot || i.parentNode;
      else if (i.nodeType == 11)
        i = i.host;
      else
        break;
    if (e < this.scrollTargets.length && !t && (t = this.scrollTargets.slice(0, e)), t) {
      for (let i of this.scrollTargets)
        i.removeEventListener("scroll", this.onScroll);
      for (let i of this.scrollTargets = t)
        i.addEventListener("scroll", this.onScroll);
    }
  }
  ignore(e) {
    if (!this.active)
      return e();
    try {
      return this.stop(), e();
    } finally {
      this.start(), this.clear();
    }
  }
  start() {
    this.active || (this.observer.observe(this.dom, Dwe), vA && this.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.active = !0);
  }
  stop() {
    this.active && (this.active = !1, this.observer.disconnect(), vA && this.dom.removeEventListener("DOMCharacterDataModified", this.onCharData));
  }
  // Throw away any pending changes
  clear() {
    this.processRecords(), this.queue.length = 0, this.selectionChanged = !1;
  }
  // Chrome Android, especially in combination with GBoard, not only
  // doesn't reliably fire regular key events, but also often
  // surrounds the effect of enter or backspace with a bunch of
  // composition events that, when interrupted, cause text duplication
  // or other kinds of corruption. This hack makes the editor back off
  // from handling DOM changes for a moment when such a key is
  // detected (via beforeinput or keydown), and then tries to flush
  // them or, if that has no effect, dispatches the given key.
  delayAndroidKey(e, t) {
    var i;
    if (!this.delayedAndroidKey) {
      let n = () => {
        let a = this.delayedAndroidKey;
        a && (this.clearDelayedAndroidKey(), this.view.inputState.lastKeyCode = a.keyCode, this.view.inputState.lastKeyTime = Date.now(), !this.flush() && a.force && df(this.dom, a.key, a.keyCode));
      };
      this.flushingAndroidKey = this.view.win.requestAnimationFrame(n);
    }
    (!this.delayedAndroidKey || e == "Enter") && (this.delayedAndroidKey = {
      key: e,
      keyCode: t,
      // Only run the key handler when no changes are detected if
      // this isn't coming right after another change, in which case
      // it is probably part of a weird chain of updates, and should
      // be ignored if it returns the DOM to its previous state.
      force: this.lastChange < Date.now() - 50 || !!(!((i = this.delayedAndroidKey) === null || i === void 0) && i.force)
    });
  }
  clearDelayedAndroidKey() {
    this.win.cancelAnimationFrame(this.flushingAndroidKey), this.delayedAndroidKey = null, this.flushingAndroidKey = -1;
  }
  flushSoon() {
    this.delayedFlush < 0 && (this.delayedFlush = this.view.win.requestAnimationFrame(() => {
      this.delayedFlush = -1, this.flush();
    }));
  }
  forceFlush() {
    this.delayedFlush >= 0 && (this.view.win.cancelAnimationFrame(this.delayedFlush), this.delayedFlush = -1), this.flush();
  }
  pendingRecords() {
    for (let e of this.observer.takeRecords())
      this.queue.push(e);
    return this.queue;
  }
  processRecords() {
    let e = this.pendingRecords();
    e.length && (this.queue = []);
    let t = -1, i = -1, n = !1;
    for (let a of e) {
      let o = this.readMutation(a);
      o && (o.typeOver && (n = !0), t == -1 ? { from: t, to: i } = o : (t = Math.min(o.from, t), i = Math.max(o.to, i)));
    }
    return { from: t, to: i, typeOver: n };
  }
  readChange() {
    let { from: e, to: t, typeOver: i } = this.processRecords(), n = this.selectionChanged && hE(this.dom, this.selectionRange);
    return e < 0 && !n ? null : (e > -1 && (this.lastChange = Date.now()), this.view.inputState.lastFocusTime = 0, this.selectionChanged = !1, new Nwe(this.view, e, t, i));
  }
  // Apply pending changes, if any
  flush(e = !0) {
    if (this.delayedFlush >= 0 || this.delayedAndroidKey)
      return !1;
    e && this.readSelectionRange();
    let t = this.readChange();
    if (!t)
      return !1;
    let i = this.view.state, n = O6(this.view, t);
    return this.view.state == i && this.view.update([]), n;
  }
  readMutation(e) {
    let t = this.view.docView.nearest(e.target);
    if (!t || t.ignoreMutation(e))
      return null;
    if (t.markDirty(e.type == "attributes"), e.type == "attributes" && (t.flags |= 4), e.type == "childList") {
      let i = nG(t, e.previousSibling || e.target.previousSibling, -1), n = nG(t, e.nextSibling || e.target.nextSibling, 1);
      return {
        from: i ? t.posAfter(i) : t.posAtStart,
        to: n ? t.posBefore(n) : t.posAtEnd,
        typeOver: !1
      };
    } else
      return e.type == "characterData" ? { from: t.posAtStart, to: t.posAtEnd, typeOver: e.target.nodeValue == e.oldValue } : null;
  }
  setWindow(e) {
    e != this.win && (this.removeWindowListeners(this.win), this.win = e, this.addWindowListeners(this.win));
  }
  addWindowListeners(e) {
    e.addEventListener("resize", this.onResize), e.addEventListener("beforeprint", this.onPrint), e.addEventListener("scroll", this.onScroll), e.document.addEventListener("selectionchange", this.onSelectionChange);
  }
  removeWindowListeners(e) {
    e.removeEventListener("scroll", this.onScroll), e.removeEventListener("resize", this.onResize), e.removeEventListener("beforeprint", this.onPrint), e.document.removeEventListener("selectionchange", this.onSelectionChange);
  }
  destroy() {
    var e, t, i, n;
    this.stop(), (e = this.intersection) === null || e === void 0 || e.disconnect(), (t = this.gapIntersection) === null || t === void 0 || t.disconnect(), (i = this.resizeScroll) === null || i === void 0 || i.disconnect(), (n = this.resizeContent) === null || n === void 0 || n.disconnect();
    for (let a of this.scrollTargets)
      a.removeEventListener("scroll", this.onScroll);
    this.removeWindowListeners(this.win), clearTimeout(this.parentCheck), clearTimeout(this.resizeTimeout), this.win.cancelAnimationFrame(this.delayedFlush), this.win.cancelAnimationFrame(this.flushingAndroidKey);
  }
}
function nG(r, e, t) {
  for (; e; ) {
    let i = Ht.get(e);
    if (i && i.parent == r)
      return i;
    let n = e.parentNode;
    e = n != r.dom ? n : t > 0 ? e.nextSibling : e.previousSibling;
  }
  return null;
}
function kwe(r) {
  let e = null;
  function t(l) {
    l.preventDefault(), l.stopImmediatePropagation(), e = l.getTargetRanges()[0];
  }
  if (r.contentDOM.addEventListener("beforeinput", t, !0), r.dom.ownerDocument.execCommand("indent"), r.contentDOM.removeEventListener("beforeinput", t, !0), !e)
    return null;
  let i = e.startContainer, n = e.startOffset, a = e.endContainer, o = e.endOffset, s = r.docView.domAtPos(r.state.selection.main.anchor);
  return Jb(s.node, s.offset, a, o) && ([i, n, a, o] = [a, o, i, n]), { anchorNode: i, anchorOffset: n, focusNode: a, focusOffset: o };
}
class me {
  /**
  Construct a new view. You'll want to either provide a `parent`
  option, or put `view.dom` into your document after creating a
  view, so that the user can see the editor.
  */
  constructor(e = {}) {
    this.plugins = [], this.pluginMap = /* @__PURE__ */ new Map(), this.editorAttrs = {}, this.contentAttrs = {}, this.bidiCache = [], this.destroyed = !1, this.updateState = 2, this.measureScheduled = -1, this.measureRequests = [], this.contentDOM = document.createElement("div"), this.scrollDOM = document.createElement("div"), this.scrollDOM.tabIndex = -1, this.scrollDOM.className = "cm-scroller", this.scrollDOM.appendChild(this.contentDOM), this.announceDOM = document.createElement("div"), this.announceDOM.style.cssText = "position: fixed; top: -10000px", this.announceDOM.setAttribute("aria-live", "polite"), this.dom = document.createElement("div"), this.dom.appendChild(this.announceDOM), this.dom.appendChild(this.scrollDOM), this._dispatch = e.dispatch || ((t) => this.update([t])), this.dispatch = this.dispatch.bind(this), this._root = e.root || IIe(e.parent) || document, this.viewState = new rG(e.state || Rt.create(e)), this.plugins = this.state.facet(_p).map((t) => new fA(t));
    for (let t of this.plugins)
      t.update(this);
    this.observer = new Mwe(this), this.inputState = new iwe(this), this.inputState.ensureHandlers(this, this.plugins), this.docView = new $V(this), this.mountStyles(), this.updateAttrs(), this.updateState = 0, this.requestMeasure(), e.parent && e.parent.appendChild(this.dom);
  }
  /**
  The current editor state.
  */
  get state() {
    return this.viewState.state;
  }
  /**
  To be able to display large documents without consuming too much
  memory or overloading the browser, CodeMirror only draws the
  code that is visible (plus a margin around it) to the DOM. This
  property tells you the extent of the current drawn viewport, in
  document positions.
  */
  get viewport() {
    return this.viewState.viewport;
  }
  /**
  When there are, for example, large collapsed ranges in the
  viewport, its size can be a lot bigger than the actual visible
  content. Thus, if you are doing something like styling the
  content in the viewport, it is preferable to only do so for
  these ranges, which are the subset of the viewport that is
  actually drawn.
  */
  get visibleRanges() {
    return this.viewState.visibleRanges;
  }
  /**
  Returns false when the editor is entirely scrolled out of view
  or otherwise hidden.
  */
  get inView() {
    return this.viewState.inView;
  }
  /**
  Indicates whether the user is currently composing text via
  [IME](https://en.wikipedia.org/wiki/Input_method), and at least
  one change has been made in the current composition.
  */
  get composing() {
    return this.inputState.composing > 0;
  }
  /**
  Indicates whether the user is currently in composing state. Note
  that on some platforms, like Android, this will be the case a
  lot, since just putting the cursor on a word starts a
  composition there.
  */
  get compositionStarted() {
    return this.inputState.composing >= 0;
  }
  /**
  The document or shadow root that the view lives in.
  */
  get root() {
    return this._root;
  }
  /**
  @internal
  */
  get win() {
    return this.dom.ownerDocument.defaultView || window;
  }
  dispatch(...e) {
    let t = e.length == 1 && e[0] instanceof Dr ? e[0] : this.state.update(...e);
    this._dispatch(t, this);
  }
  /**
  Update the view for the given array of transactions. This will
  update the visible document and selection to match the state
  produced by the transactions, and notify view plugins of the
  change. You should usually call
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead, which uses this
  as a primitive.
  */
  update(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.update are not allowed while an update is in progress");
    let t = !1, i = !1, n, a = this.state;
    for (let f of e) {
      if (f.startState != a)
        throw new RangeError("Trying to update state with a transaction that doesn't start from the previous state.");
      a = f.state;
    }
    if (this.destroyed) {
      this.viewState.state = a;
      return;
    }
    let o = this.hasFocus, s = 0, l = null;
    e.some((f) => f.annotation(c6)) ? (this.inputState.notifiedFocused = o, s = 1) : o != this.inputState.notifiedFocused && (this.inputState.notifiedFocused = o, l = h6(a, o), l || (s = 1));
    let u = this.observer.delayedAndroidKey, c = null;
    if (u ? (this.observer.clearDelayedAndroidKey(), c = this.observer.readChange(), (c && !this.state.doc.eq(a.doc) || !this.state.selection.eq(a.selection)) && (c = null)) : this.observer.clear(), a.facet(Rt.phrases) != this.state.facet(Rt.phrases))
      return this.setState(a);
    n = rS.create(this, a, e), n.flags |= s;
    let h = this.viewState.scrollTarget;
    try {
      this.updateState = 2;
      for (let f of e) {
        if (h && (h = h.map(f.changes)), f.scrollIntoView) {
          let { main: d } = f.state.selection;
          h = new tS(d.empty ? d : Z.cursor(d.head, d.head > d.anchor ? -1 : 1));
        }
        for (let d of f.effects)
          d.is(UV) && (h = d.value);
      }
      this.viewState.update(n, h), this.bidiCache = iS.update(this.bidiCache, n.changes), n.empty || (this.updatePlugins(n), this.inputState.update(n)), t = this.docView.update(n), this.state.facet(Cp) != this.styleModules && this.mountStyles(), i = this.updateAttrs(), this.showAnnouncements(e), this.docView.updateSelection(t, e.some((f) => f.isUserEvent("select.pointer")));
    } finally {
      this.updateState = 0;
    }
    if (n.startState.facet(Rm) != n.state.facet(Rm) && (this.viewState.mustMeasureContent = !0), (t || i || h || this.viewState.mustEnforceCursorAssoc || this.viewState.mustMeasureContent) && this.requestMeasure(), !n.empty)
      for (let f of this.state.facet(DI))
        f(n);
    (l || c) && Promise.resolve().then(() => {
      l && this.state == l.startState && this.dispatch(l), c && !O6(this, c) && u.force && df(this.contentDOM, u.key, u.keyCode);
    });
  }
  /**
  Reset the view to the given state. (This will cause the entire
  document to be redrawn and all view plugins to be reinitialized,
  so you should probably only use it when the new state isn't
  derived from the old state. Otherwise, use
  [`dispatch`](https://codemirror.net/6/docs/ref/#view.EditorView.dispatch) instead.)
  */
  setState(e) {
    if (this.updateState != 0)
      throw new Error("Calls to EditorView.setState are not allowed while an update is in progress");
    if (this.destroyed) {
      this.viewState.state = e;
      return;
    }
    this.updateState = 2;
    let t = this.hasFocus;
    try {
      for (let i of this.plugins)
        i.destroy(this);
      this.viewState = new rG(e), this.plugins = e.facet(_p).map((i) => new fA(i)), this.pluginMap.clear();
      for (let i of this.plugins)
        i.update(this);
      this.docView = new $V(this), this.inputState.ensureHandlers(this, this.plugins), this.mountStyles(), this.updateAttrs(), this.bidiCache = [];
    } finally {
      this.updateState = 0;
    }
    t && this.focus(), this.requestMeasure();
  }
  updatePlugins(e) {
    let t = e.startState.facet(_p), i = e.state.facet(_p);
    if (t != i) {
      let n = [];
      for (let a of i) {
        let o = t.indexOf(a);
        if (o < 0)
          n.push(new fA(a));
        else {
          let s = this.plugins[o];
          s.mustUpdate = e, n.push(s);
        }
      }
      for (let a of this.plugins)
        a.mustUpdate != e && a.destroy(this);
      this.plugins = n, this.pluginMap.clear(), this.inputState.ensureHandlers(this, this.plugins);
    } else
      for (let n of this.plugins)
        n.mustUpdate = e;
    for (let n = 0; n < this.plugins.length; n++)
      this.plugins[n].update(this);
  }
  /**
  @internal
  */
  measure(e = !0) {
    if (this.destroyed)
      return;
    this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.measureScheduled = 0, e && this.observer.forceFlush();
    let t = null, i = this.scrollDOM, { scrollTop: n } = i, { scrollAnchorPos: a, scrollAnchorHeight: o } = this.viewState;
    n != this.viewState.scrollTop && (o = -1), this.viewState.scrollAnchorHeight = -1;
    try {
      for (let s = 0; ; s++) {
        if (o < 0)
          if (N7(i))
            a = -1, o = this.viewState.heightMap.height;
          else {
            let d = this.viewState.scrollAnchorAt(n);
            a = d.from, o = d.top;
          }
        this.updateState = 1;
        let l = this.viewState.measure(this);
        if (!l && !this.measureRequests.length && this.viewState.scrollTarget == null)
          break;
        if (s > 5) {
          console.warn(this.measureRequests.length ? "Measure loop restarted more than 5 times" : "Viewport failed to stabilize");
          break;
        }
        let u = [];
        l & 4 || ([this.measureRequests, u] = [u, this.measureRequests]);
        let c = u.map((d) => {
          try {
            return d.read(this);
          } catch (p) {
            return ea(this.state, p), aG;
          }
        }), h = rS.create(this, this.state, []), f = !1;
        h.flags |= l, t ? t.flags |= l : t = h, this.updateState = 2, h.empty || (this.updatePlugins(h), this.inputState.update(h), this.updateAttrs(), f = this.docView.update(h));
        for (let d = 0; d < u.length; d++)
          if (c[d] != aG)
            try {
              let p = u[d];
              p.write && p.write(c[d], this);
            } catch (p) {
              ea(this.state, p);
            }
        if (f && this.docView.updateSelection(!0), !h.viewportChanged && this.measureRequests.length == 0) {
          if (this.viewState.editorHeight)
            if (this.viewState.scrollTarget) {
              this.docView.scrollIntoView(this.viewState.scrollTarget), this.viewState.scrollTarget = null;
              continue;
            } else {
              let p = (a < 0 ? this.viewState.heightMap.height : this.viewState.lineBlockAt(a).top) - o;
              if (p > 1 || p < -1) {
                n = i.scrollTop = n + p, o = -1;
                continue;
              }
            }
          break;
        }
      }
    } finally {
      this.updateState = 0, this.measureScheduled = -1;
    }
    if (t && !t.empty)
      for (let s of this.state.facet(DI))
        s(t);
  }
  /**
  Get the CSS classes for the currently active editor themes.
  */
  get themeClasses() {
    return BI + " " + (this.state.facet(GI) ? g6 : p6) + " " + this.state.facet(Rm);
  }
  updateAttrs() {
    let e = oG(this, Z7, {
      class: "cm-editor" + (this.hasFocus ? " cm-focused " : " ") + this.themeClasses
    }), t = {
      spellcheck: "false",
      autocorrect: "off",
      autocapitalize: "off",
      translate: "no",
      contenteditable: this.state.facet(zT) ? "true" : "false",
      class: "cm-content",
      style: `${we.tabSize}: ${this.state.tabSize}`,
      role: "textbox",
      "aria-multiline": "true"
    };
    this.state.readOnly && (t["aria-readonly"] = "true"), oG(this, Ux, t);
    let i = this.observer.ignore(() => {
      let n = PI(this.contentDOM, this.contentAttrs, t), a = PI(this.dom, this.editorAttrs, e);
      return n || a;
    });
    return this.editorAttrs = e, this.contentAttrs = t, i;
  }
  showAnnouncements(e) {
    let t = !0;
    for (let i of e)
      for (let n of i.effects)
        if (n.is(me.announce)) {
          t && (this.announceDOM.textContent = ""), t = !1;
          let a = this.announceDOM.appendChild(document.createElement("div"));
          a.textContent = n.value;
        }
  }
  mountStyles() {
    this.styleModules = this.state.facet(Cp), $l.mount(this.root, this.styleModules.concat(wwe).reverse());
  }
  readMeasured() {
    if (this.updateState == 2)
      throw new Error("Reading the editor layout isn't allowed during an update");
    this.updateState == 0 && this.measureScheduled > -1 && this.measure(!1);
  }
  /**
  Schedule a layout measurement, optionally providing callbacks to
  do custom DOM measuring followed by a DOM write phase. Using
  this is preferable reading DOM layout directly from, for
  example, an event handler, because it'll make sure measuring and
  drawing done by other components is synchronized, avoiding
  unnecessary DOM layout computations.
  */
  requestMeasure(e) {
    if (this.measureScheduled < 0 && (this.measureScheduled = this.win.requestAnimationFrame(() => this.measure())), e) {
      if (this.measureRequests.indexOf(e) > -1)
        return;
      if (e.key != null) {
        for (let t = 0; t < this.measureRequests.length; t++)
          if (this.measureRequests[t].key === e.key) {
            this.measureRequests[t] = e;
            return;
          }
      }
      this.measureRequests.push(e);
    }
  }
  /**
  Get the value of a specific plugin, if present. Note that
  plugins that crash can be dropped from a view, so even when you
  know you registered a given plugin, it is recommended to check
  the return value of this method.
  */
  plugin(e) {
    let t = this.pluginMap.get(e);
    return (t === void 0 || t && t.spec != e) && this.pluginMap.set(e, t = this.plugins.find((i) => i.spec == e) || null), t && t.update(this).value;
  }
  /**
  The top position of the document, in screen coordinates. This
  may be negative when the editor is scrolled down. Points
  directly to the top of the first line, not above the padding.
  */
  get documentTop() {
    return this.contentDOM.getBoundingClientRect().top + this.viewState.paddingTop;
  }
  /**
  Reports the padding above and below the document.
  */
  get documentPadding() {
    return { top: this.viewState.paddingTop, bottom: this.viewState.paddingBottom };
  }
  /**
  Find the text line or block widget at the given vertical
  position (which is interpreted as relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop)).
  */
  elementAtHeight(e) {
    return this.readMeasured(), this.viewState.elementAtHeight(e);
  }
  /**
  Find the line block (see
  [`lineBlockAt`](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) at the given
  height, again interpreted relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop).
  */
  lineBlockAtHeight(e) {
    return this.readMeasured(), this.viewState.lineBlockAtHeight(e);
  }
  /**
  Get the extent and vertical position of all [line
  blocks](https://codemirror.net/6/docs/ref/#view.EditorView.lineBlockAt) in the viewport. Positions
  are relative to the [top of the
  document](https://codemirror.net/6/docs/ref/#view.EditorView.documentTop);
  */
  get viewportLineBlocks() {
    return this.viewState.viewportLines;
  }
  /**
  Find the line block around the given document position. A line
  block is a range delimited on both sides by either a
  non-[hidden](https://codemirror.net/6/docs/ref/#view.Decoration^replace) line breaks, or the
  start/end of the document. It will usually just hold a line of
  text, but may be broken into multiple textblocks by block
  widgets.
  */
  lineBlockAt(e) {
    return this.viewState.lineBlockAt(e);
  }
  /**
  The editor's total content height.
  */
  get contentHeight() {
    return this.viewState.contentHeight;
  }
  /**
  Move a cursor position by [grapheme
  cluster](https://codemirror.net/6/docs/ref/#state.findClusterBreak). `forward` determines whether
  the motion is away from the line start, or towards it. In
  bidirectional text, the line is traversed in visual order, using
  the editor's [text direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection).
  When the start position was the last one on the line, the
  returned position will be across the line break. If there is no
  further line, the original position is returned.
  
  By default, this method moves over a single cluster. The
  optional `by` argument can be used to move across more. It will
  be called with the first cluster as argument, and should return
  a predicate that determines, for each subsequent cluster,
  whether it should also be moved over.
  */
  moveByChar(e, t, i) {
    return pA(this, e, YV(this, e, t, i));
  }
  /**
  Move a cursor position across the next group of either
  [letters](https://codemirror.net/6/docs/ref/#state.EditorState.charCategorizer) or non-letter
  non-whitespace characters.
  */
  moveByGroup(e, t) {
    return pA(this, e, YV(this, e, t, (i) => twe(this, e.head, i)));
  }
  /**
  Move to the next line boundary in the given direction. If
  `includeWrap` is true, line wrapping is on, and there is a
  further wrap point on the current line, the wrap point will be
  returned. Otherwise this function will return the start or end
  of the line.
  */
  moveToLineBoundary(e, t, i = !0) {
    return ewe(this, e, t, i);
  }
  /**
  Move a cursor position vertically. When `distance` isn't given,
  it defaults to moving to the next line (including wrapped
  lines). Otherwise, `distance` should provide a positive distance
  in pixels.
  
  When `start` has a
  [`goalColumn`](https://codemirror.net/6/docs/ref/#state.SelectionRange.goalColumn), the vertical
  motion will use that as a target horizontal position. Otherwise,
  the cursor's own horizontal position is used. The returned
  cursor will have its goal column set to whichever column was
  used.
  */
  moveVertically(e, t, i) {
    return pA(this, e, rwe(this, e, t, i));
  }
  /**
  Find the DOM parent node and offset (child offset if `node` is
  an element, character offset when it is a text node) at the
  given document position.
  
  Note that for positions that aren't currently in
  `visibleRanges`, the resulting DOM position isn't necessarily
  meaningful (it may just point before or after a placeholder
  element).
  */
  domAtPos(e) {
    return this.docView.domAtPos(e);
  }
  /**
  Find the document position at the given DOM node. Can be useful
  for associating positions with DOM events. Will raise an error
  when `node` isn't part of the editor content.
  */
  posAtDOM(e, t = 0) {
    return this.docView.posFromDOM(e, t);
  }
  posAtCoords(e, t = !0) {
    return this.readMeasured(), i6(this, e, t);
  }
  /**
  Get the screen coordinates at the given document position.
  `side` determines whether the coordinates are based on the
  element before (-1) or after (1) the position (if no element is
  available on the given side, the method will transparently use
  another strategy to get reasonable coordinates).
  */
  coordsAtPos(e, t = 1) {
    this.readMeasured();
    let i = this.docView.coordsAt(e, t);
    if (!i || i.left == i.right)
      return i;
    let n = this.state.doc.lineAt(e), a = this.bidiSpans(n), o = a[pf.find(a, e - n.from, -1, t)];
    return Mx(i, o.dir == ir.LTR == t > 0);
  }
  /**
  Return the rectangle around a given character. If `pos` does not
  point in front of a character that is in the viewport and
  rendered (i.e. not replaced, not a line break), this will return
  null. For space characters that are a line wrap point, this will
  return the position before the line break.
  */
  coordsForChar(e) {
    return this.readMeasured(), this.docView.coordsForChar(e);
  }
  /**
  The default width of a character in the editor. May not
  accurately reflect the width of all characters (given variable
  width fonts or styling of invididual ranges).
  */
  get defaultCharacterWidth() {
    return this.viewState.heightOracle.charWidth;
  }
  /**
  The default height of a line in the editor. May not be accurate
  for all lines.
  */
  get defaultLineHeight() {
    return this.viewState.heightOracle.lineHeight;
  }
  /**
  The text direction
  ([`direction`](https://developer.mozilla.org/en-US/docs/Web/CSS/direction)
  CSS property) of the editor's content element.
  */
  get textDirection() {
    return this.viewState.defaultTextDirection;
  }
  /**
  Find the text direction of the block at the given position, as
  assigned by CSS. If
  [`perLineTextDirection`](https://codemirror.net/6/docs/ref/#view.EditorView^perLineTextDirection)
  isn't enabled, or the given position is outside of the viewport,
  this will always return the same as
  [`textDirection`](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection). Note that
  this may trigger a DOM layout.
  */
  textDirectionAt(e) {
    return !this.state.facet(W7) || e < this.viewport.from || e > this.viewport.to ? this.textDirection : (this.readMeasured(), this.docView.textDirectionAt(e));
  }
  /**
  Whether this editor [wraps lines](https://codemirror.net/6/docs/ref/#view.EditorView.lineWrapping)
  (as determined by the
  [`white-space`](https://developer.mozilla.org/en-US/docs/Web/CSS/white-space)
  CSS property of its content element).
  */
  get lineWrapping() {
    return this.viewState.heightOracle.lineWrapping;
  }
  /**
  Returns the bidirectional text structure of the given line
  (which should be in the current document) as an array of span
  objects. The order of these spans matches the [text
  direction](https://codemirror.net/6/docs/ref/#view.EditorView.textDirection)if that is
  left-to-right, the leftmost spans come first, otherwise the
  rightmost spans come first.
  */
  bidiSpans(e) {
    if (e.length > Qwe)
      return J7(e.length);
    let t = this.textDirectionAt(e.from);
    for (let n of this.bidiCache)
      if (n.from == e.from && n.dir == t)
        return n.order;
    let i = GIe(e.text, t);
    return this.bidiCache.push(new iS(e.from, e.to, t, i)), i;
  }
  /**
  Check whether the editor has focus.
  */
  get hasFocus() {
    var e;
    return (this.dom.ownerDocument.hasFocus() || we.safari && ((e = this.inputState) === null || e === void 0 ? void 0 : e.lastContextMenu) > Date.now() - 3e4) && this.root.activeElement == this.contentDOM;
  }
  /**
  Put focus on the editor.
  */
  focus() {
    this.observer.ignore(() => {
      I7(this.contentDOM), this.docView.updateSelection();
    });
  }
  /**
  Update the [root](https://codemirror.net/6/docs/ref/##view.EditorViewConfig.root) in which the editor lives. This is only
  necessary when moving the editor's existing DOM to a new window or shadow root.
  */
  setRoot(e) {
    this._root != e && (this._root = e, this.observer.setWindow((e.nodeType == 9 ? e : e.ownerDocument).defaultView || window), this.mountStyles());
  }
  /**
  Clean up this editor view, removing its element from the
  document, unregistering event handlers, and notifying
  plugins. The view instance can no longer be used after
  calling this.
  */
  destroy() {
    for (let e of this.plugins)
      e.destroy(this);
    this.plugins = [], this.inputState.destroy(), this.dom.remove(), this.observer.destroy(), this.measureScheduled > -1 && this.win.cancelAnimationFrame(this.measureScheduled), this.destroyed = !0;
  }
  /**
  Returns an effect that can be
  [added](https://codemirror.net/6/docs/ref/#state.TransactionSpec.effects) to a transaction to
  cause it to scroll the given position or range into view.
  */
  static scrollIntoView(e, t = {}) {
    return UV.of(new tS(typeof e == "number" ? Z.cursor(e) : e, t.y, t.x, t.yMargin, t.xMargin));
  }
  /**
  Returns an extension that can be used to add DOM event handlers.
  The value should be an object mapping event names to handler
  functions. For any given event, such functions are ordered by
  extension precedence, and the first handler to return true will
  be assumed to have handled that event, and no other handlers or
  built-in behavior will be activated for it. These are registered
  on the [content element](https://codemirror.net/6/docs/ref/#view.EditorView.contentDOM), except
  for `scroll` handlers, which will be called any time the
  editor's [scroll element](https://codemirror.net/6/docs/ref/#view.EditorView.scrollDOM) or one of
  its parent nodes is scrolled.
  */
  static domEventHandlers(e) {
    return Ur.define(() => ({}), { eventHandlers: e });
  }
  /**
  Create a theme extension. The first argument can be a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)
  style spec providing the styles for the theme. These will be
  prefixed with a generated class for the style.
  
  Because the selectors will be prefixed with a scope class, rule
  that directly match the editor's [wrapper
  element](https://codemirror.net/6/docs/ref/#view.EditorView.dom)to which the scope class will be
  addedneed to be explicitly differentiated by adding an `&` to
  the selector for that elementfor example
  `&.cm-focused`.
  
  When `dark` is set to true, the theme will be marked as dark,
  which will cause the `&dark` rules from [base
  themes](https://codemirror.net/6/docs/ref/#view.EditorView^baseTheme) to be used (as opposed to
  `&light` when a light theme is active).
  */
  static theme(e, t) {
    let i = $l.newName(), n = [Rm.of(i), Cp.of(FI(`.${i}`, e))];
    return t && t.dark && n.push(GI.of(!0)), n;
  }
  /**
  Create an extension that adds styles to the base theme. Like
  with [`theme`](https://codemirror.net/6/docs/ref/#view.EditorView^theme), use `&` to indicate the
  place of the editor wrapper element when directly targeting
  that. You can also use `&dark` or `&light` instead to only
  target editors with a dark or light theme.
  */
  static baseTheme(e) {
    return th.lowest(Cp.of(FI("." + BI, e, v6)));
  }
  /**
  Retrieve an editor view instance from the view's DOM
  representation.
  */
  static findFromDOM(e) {
    var t;
    let i = e.querySelector(".cm-content"), n = i && Ht.get(i) || Ht.get(e);
    return ((t = n == null ? void 0 : n.rootView) === null || t === void 0 ? void 0 : t.view) || null;
  }
}
me.styleModule = Cp;
me.inputHandler = Y7;
me.focusChangeEffect = H7;
me.perLineTextDirection = W7;
me.exceptionSink = X7;
me.updateListener = DI;
me.editable = zT;
me.mouseSelectionStyle = F7;
me.dragMovesSelection = B7;
me.clickAddsSelectionRange = G7;
me.decorations = rv;
me.atomicRanges = $x;
me.scrollMargins = q7;
me.darkTheme = GI;
me.contentAttributes = Ux;
me.editorAttributes = Z7;
me.lineWrapping = /* @__PURE__ */ me.contentAttributes.of({ class: "cm-lineWrapping" });
me.announce = /* @__PURE__ */ lt.define();
const Qwe = 4096, aG = {};
class iS {
  constructor(e, t, i, n) {
    this.from = e, this.to = t, this.dir = i, this.order = n;
  }
  static update(e, t) {
    if (t.empty)
      return e;
    let i = [], n = e.length ? e[e.length - 1].dir : ir.LTR;
    for (let a = Math.max(0, e.length - 10); a < e.length; a++) {
      let o = e[a];
      o.dir == n && !t.touchesRange(o.from, o.to) && i.push(new iS(t.mapPos(o.from, 1), t.mapPos(o.to, -1), o.dir, o.order));
    }
    return i;
  }
}
function oG(r, e, t) {
  for (let i = r.state.facet(e), n = i.length - 1; n >= 0; n--) {
    let a = i[n], o = typeof a == "function" ? a(r) : a;
    o && xI(o, t);
  }
  return t;
}
const Uwe = we.mac ? "mac" : we.windows ? "win" : we.linux ? "linux" : "key";
function $we(r, e) {
  const t = r.split(/-(?!$)/);
  let i = t[t.length - 1];
  i == "Space" && (i = " ");
  let n, a, o, s;
  for (let l = 0; l < t.length - 1; ++l) {
    const u = t[l];
    if (/^(cmd|meta|m)$/i.test(u))
      s = !0;
    else if (/^a(lt)?$/i.test(u))
      n = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      a = !0;
    else if (/^s(hift)?$/i.test(u))
      o = !0;
    else if (/^mod$/i.test(u))
      e == "mac" ? s = !0 : a = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return n && (i = "Alt-" + i), a && (i = "Ctrl-" + i), s && (i = "Meta-" + i), o && (i = "Shift-" + i), i;
}
function Am(r, e, t) {
  return e.altKey && (r = "Alt-" + r), e.ctrlKey && (r = "Ctrl-" + r), e.metaKey && (r = "Meta-" + r), t !== !1 && e.shiftKey && (r = "Shift-" + r), r;
}
const Vwe = /* @__PURE__ */ th.default(/* @__PURE__ */ me.domEventHandlers({
  keydown(r, e) {
    return E6(m6(e.state), r, e, "editor");
  }
})), Yv = /* @__PURE__ */ Ce.define({ enables: Vwe }), sG = /* @__PURE__ */ new WeakMap();
function m6(r) {
  let e = r.facet(Yv), t = sG.get(e);
  return t || sG.set(e, t = Fwe(e.reduce((i, n) => i.concat(n), []))), t;
}
function Gwe(r, e, t) {
  return E6(m6(r.state), e, r, t);
}
let qs = null;
const Bwe = 4e3;
function Fwe(r, e = Uwe) {
  let t = /* @__PURE__ */ Object.create(null), i = /* @__PURE__ */ Object.create(null), n = (o, s) => {
    let l = i[o];
    if (l == null)
      i[o] = s;
    else if (l != s)
      throw new Error("Key binding " + o + " is used both as a regular binding and as a multi-stroke prefix");
  }, a = (o, s, l, u, c) => {
    var h, f;
    let d = t[o] || (t[o] = /* @__PURE__ */ Object.create(null)), p = s.split(/ (?!$)/).map((O) => $we(O, e));
    for (let O = 1; O < p.length; O++) {
      let m = p.slice(0, O).join(" ");
      n(m, !0), d[m] || (d[m] = {
        preventDefault: !0,
        stopPropagation: !1,
        run: [(E) => {
          let b = qs = { view: E, prefix: m, scope: o };
          return setTimeout(() => {
            qs == b && (qs = null);
          }, Bwe), !0;
        }]
      });
    }
    let g = p.join(" ");
    n(g, !1);
    let v = d[g] || (d[g] = {
      preventDefault: !1,
      stopPropagation: !1,
      run: ((f = (h = d._any) === null || h === void 0 ? void 0 : h.run) === null || f === void 0 ? void 0 : f.slice()) || []
    });
    l && v.run.push(l), u && (v.preventDefault = !0), c && (v.stopPropagation = !0);
  };
  for (let o of r) {
    let s = o.scope ? o.scope.split(" ") : ["editor"];
    if (o.any)
      for (let u of s) {
        let c = t[u] || (t[u] = /* @__PURE__ */ Object.create(null));
        c._any || (c._any = { preventDefault: !1, stopPropagation: !1, run: [] });
        for (let h in c)
          c[h].run.push(o.any);
      }
    let l = o[e] || o.key;
    if (l)
      for (let u of s)
        a(u, l, o.run, o.preventDefault, o.stopPropagation), o.shift && a(u, "Shift-" + l, o.shift, o.preventDefault, o.stopPropagation);
  }
  return t;
}
function E6(r, e, t, i) {
  let n = TIe(e), a = Zr(n, 0), o = Hn(a) == n.length && n != " ", s = "", l = !1, u = !1, c = !1;
  qs && qs.view == t && qs.scope == i && (s = qs.prefix + " ", a6.indexOf(e.keyCode) < 0 && (u = !0, qs = null));
  let h = /* @__PURE__ */ new Set(), f = (v) => {
    if (v) {
      for (let O of v.run)
        if (!h.has(O) && (h.add(O), O(t, e)))
          return v.stopPropagation && (c = !0), !0;
      v.preventDefault && (v.stopPropagation && (c = !0), u = !0);
    }
    return !1;
  }, d = r[i], p, g;
  return d && (f(d[s + Am(n, e, !o)]) ? l = !0 : o && (e.altKey || e.metaKey || e.ctrlKey) && // Ctrl-Alt may be used for AltGr on Windows
  !(we.windows && e.ctrlKey && e.altKey) && (p = Vl[e.keyCode]) && p != n ? (f(d[s + Am(p, e, !0)]) || e.shiftKey && (g = ev[e.keyCode]) != n && g != p && f(d[s + Am(g, e, !1)])) && (l = !0) : o && e.shiftKey && f(d[s + Am(n, e, !0)]) && (l = !0), !l && f(d._any) && (l = !0)), u && (l = !0), l && c && e.stopPropagation(), l;
}
class Hv {
  /**
  Create a marker with the given class and dimensions. If `width`
  is null, the DOM element will get no width style.
  */
  constructor(e, t, i, n, a) {
    this.className = e, this.left = t, this.top = i, this.width = n, this.height = a;
  }
  draw() {
    let e = document.createElement("div");
    return e.className = this.className, this.adjust(e), e;
  }
  update(e, t) {
    return t.className != this.className ? !1 : (this.adjust(e), !0);
  }
  adjust(e) {
    e.style.left = this.left + "px", e.style.top = this.top + "px", this.width != null && (e.style.width = this.width + "px"), e.style.height = this.height + "px";
  }
  eq(e) {
    return this.left == e.left && this.top == e.top && this.width == e.width && this.height == e.height && this.className == e.className;
  }
  /**
  Create a set of rectangles for the given selection range,
  assigning them theclass`className`. Will create a single
  rectangle for empty ranges, and a set of selection-style
  rectangles covering the range's content (in a bidi-aware
  way) for non-empty ones.
  */
  static forRange(e, t, i) {
    if (i.empty) {
      let n = e.coordsAtPos(i.head, i.assoc || 1);
      if (!n)
        return [];
      let a = b6(e);
      return [new Hv(t, n.left - a.left, n.top - a.top, null, n.bottom - n.top)];
    } else
      return Xwe(e, t, i);
  }
}
function b6(r) {
  let e = r.scrollDOM.getBoundingClientRect();
  return { left: (r.textDirection == ir.LTR ? e.left : e.right - r.scrollDOM.clientWidth) - r.scrollDOM.scrollLeft, top: e.top - r.scrollDOM.scrollTop };
}
function lG(r, e, t) {
  let i = Z.cursor(e);
  return {
    from: Math.max(t.from, r.moveToLineBoundary(i, !1, !0).from),
    to: Math.min(t.to, r.moveToLineBoundary(i, !0, !0).from),
    type: ar.Text
  };
}
function Xwe(r, e, t) {
  if (t.to <= r.viewport.from || t.from >= r.viewport.to)
    return [];
  let i = Math.max(t.from, r.viewport.from), n = Math.min(t.to, r.viewport.to), a = r.textDirection == ir.LTR, o = r.contentDOM, s = o.getBoundingClientRect(), l = b6(r), u = o.querySelector(".cm-line"), c = u && window.getComputedStyle(u), h = s.left + (c ? parseInt(c.paddingLeft) + Math.min(0, parseInt(c.textIndent)) : 0), f = s.right - (c ? parseInt(c.paddingRight) : 0), d = UI(r, i), p = UI(r, n), g = d.type == ar.Text ? d : null, v = p.type == ar.Text ? p : null;
  if (g && (r.lineWrapping || d.widgetLineBreaks) && (g = lG(r, i, g)), v && (r.lineWrapping || p.widgetLineBreaks) && (v = lG(r, n, v)), g && v && g.from == v.from)
    return m(E(t.from, t.to, g));
  {
    let S = g ? E(t.from, null, g) : b(d, !1), T = v ? E(null, t.to, v) : b(p, !0), y = [];
    return (g || d).to < (v || p).from - (g && v ? 1 : 0) || d.widgetLineBreaks > 1 && S.bottom + r.defaultLineHeight / 2 < T.top ? y.push(O(h, S.bottom, f, T.top)) : S.bottom < T.top && r.elementAtHeight((S.bottom + T.top) / 2).type == ar.Text && (S.bottom = T.top = (S.bottom + T.top) / 2), m(S).concat(y).concat(m(T));
  }
  function O(S, T, y, R) {
    return new Hv(
      e,
      S - l.left,
      T - l.top - 0.01,
      y - S,
      R - T + 0.01
      /* Epsilon */
    );
  }
  function m({ top: S, bottom: T, horizontal: y }) {
    let R = [];
    for (let _ = 0; _ < y.length; _ += 2)
      R.push(O(y[_], S, y[_ + 1], T));
    return R;
  }
  function E(S, T, y) {
    let R = 1e9, _ = -1e9, C = [];
    function I(P, L, D, U, Q) {
      let V = r.coordsAtPos(P, P == y.to ? -2 : 2), F = r.coordsAtPos(D, D == y.from ? 2 : -2);
      !V || !F || (R = Math.min(V.top, F.top, R), _ = Math.max(V.bottom, F.bottom, _), Q == ir.LTR ? C.push(a && L ? h : V.left, a && U ? f : F.right) : C.push(!a && U ? h : F.left, !a && L ? f : V.right));
    }
    let w = S ?? y.from, x = T ?? y.to;
    for (let P of r.visibleRanges)
      if (P.to > w && P.from < x)
        for (let L = Math.max(P.from, w), D = Math.min(P.to, x); ; ) {
          let U = r.state.doc.lineAt(L);
          for (let Q of r.bidiSpans(U)) {
            let V = Q.from + U.from, F = Q.to + U.from;
            if (V >= D)
              break;
            F > L && I(Math.max(V, L), S == null && V <= w, Math.min(F, D), T == null && F >= x, Q.dir);
          }
          if (L = U.to + 1, L >= D)
            break;
        }
    return C.length == 0 && I(w, S == null, x, T == null, r.textDirection), { top: R, bottom: _, horizontal: C };
  }
  function b(S, T) {
    let y = s.top + (T ? S.top : S.bottom);
    return { top: y, bottom: y, horizontal: [] };
  }
}
function Ywe(r, e) {
  return r.constructor == e.constructor && r.eq(e);
}
class Hwe {
  constructor(e, t) {
    this.view = e, this.layer = t, this.drawn = [], this.measureReq = { read: this.measure.bind(this), write: this.draw.bind(this) }, this.dom = e.scrollDOM.appendChild(document.createElement("div")), this.dom.classList.add("cm-layer"), t.above && this.dom.classList.add("cm-layer-above"), t.class && this.dom.classList.add(t.class), this.dom.setAttribute("aria-hidden", "true"), this.setOrder(e.state), e.requestMeasure(this.measureReq), t.mount && t.mount(this.dom, e);
  }
  update(e) {
    e.startState.facet(pE) != e.state.facet(pE) && this.setOrder(e.state), (this.layer.update(e, this.dom) || e.geometryChanged) && e.view.requestMeasure(this.measureReq);
  }
  setOrder(e) {
    let t = 0, i = e.facet(pE);
    for (; t < i.length && i[t] != this.layer; )
      t++;
    this.dom.style.zIndex = String((this.layer.above ? 150 : -1) - t);
  }
  measure() {
    return this.layer.markers(this.view);
  }
  draw(e) {
    if (e.length != this.drawn.length || e.some((t, i) => !Ywe(t, this.drawn[i]))) {
      let t = this.dom.firstChild, i = 0;
      for (let n of e)
        n.update && t && n.constructor && this.drawn[i].constructor && n.update(t, this.drawn[i]) ? (t = t.nextSibling, i++) : this.dom.insertBefore(n.draw(), t);
      for (; t; ) {
        let n = t.nextSibling;
        t.remove(), t = n;
      }
      this.drawn = e;
    }
  }
  destroy() {
    this.layer.destroy && this.layer.destroy(this.dom, this.view), this.dom.remove();
  }
}
const pE = /* @__PURE__ */ Ce.define();
function S6(r) {
  return [
    Ur.define((e) => new Hwe(e, r)),
    pE.of(r)
  ];
}
const T6 = !we.ios, iv = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, {
      cursorBlinkRate: 1200,
      drawRangeCursor: !0
    }, {
      cursorBlinkRate: (e, t) => Math.min(e, t),
      drawRangeCursor: (e, t) => e || t
    });
  }
});
function Wwe(r = {}) {
  return [
    iv.of(r),
    zwe,
    Zwe,
    qwe,
    z7.of(!0)
  ];
}
function y6(r) {
  return r.startState.facet(iv) != r.state.facet(iv);
}
const zwe = /* @__PURE__ */ S6({
  above: !0,
  markers(r) {
    let { state: e } = r, t = e.facet(iv), i = [];
    for (let n of e.selection.ranges) {
      let a = n == e.selection.main;
      if (n.empty ? !a || T6 : t.drawRangeCursor) {
        let o = a ? "cm-cursor cm-cursor-primary" : "cm-cursor cm-cursor-secondary", s = n.empty ? n : Z.cursor(n.head, n.head > n.anchor ? -1 : 1);
        for (let l of Hv.forRange(r, o, s))
          i.push(l);
      }
    }
    return i;
  },
  update(r, e) {
    r.transactions.some((i) => i.selection) && (e.style.animationName = e.style.animationName == "cm-blink" ? "cm-blink2" : "cm-blink");
    let t = y6(r);
    return t && uG(r.state, e), r.docChanged || r.selectionSet || t;
  },
  mount(r, e) {
    uG(e.state, r);
  },
  class: "cm-cursorLayer"
});
function uG(r, e) {
  e.style.animationDuration = r.facet(iv).cursorBlinkRate + "ms";
}
const Zwe = /* @__PURE__ */ S6({
  above: !1,
  markers(r) {
    return r.state.selection.ranges.map((e) => e.empty ? [] : Hv.forRange(r, "cm-selectionBackground", e)).reduce((e, t) => e.concat(t));
  },
  update(r, e) {
    return r.docChanged || r.selectionSet || r.viewportChanged || y6(r);
  },
  class: "cm-selectionLayer"
}), R6 = {
  ".cm-line": {
    "& ::selection": { backgroundColor: "transparent !important" },
    "&::selection": { backgroundColor: "transparent !important" }
  }
};
T6 && (R6[".cm-line"].caretColor = "transparent !important");
const qwe = /* @__PURE__ */ th.highest(/* @__PURE__ */ me.theme(R6)), A6 = /* @__PURE__ */ lt.define({
  map(r, e) {
    return r == null ? null : e.mapPos(r);
  }
}), wp = /* @__PURE__ */ Br.define({
  create() {
    return null;
  },
  update(r, e) {
    return r != null && (r = e.changes.mapPos(r)), e.effects.reduce((t, i) => i.is(A6) ? i.value : t, r);
  }
}), jwe = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.view = r, this.cursor = null, this.measureReq = { read: this.readPos.bind(this), write: this.drawCursor.bind(this) };
  }
  update(r) {
    var e;
    let t = r.state.field(wp);
    t == null ? this.cursor != null && ((e = this.cursor) === null || e === void 0 || e.remove(), this.cursor = null) : (this.cursor || (this.cursor = this.view.scrollDOM.appendChild(document.createElement("div")), this.cursor.className = "cm-dropCursor"), (r.startState.field(wp) != t || r.docChanged || r.geometryChanged) && this.view.requestMeasure(this.measureReq));
  }
  readPos() {
    let r = this.view.state.field(wp), e = r != null && this.view.coordsAtPos(r);
    if (!e)
      return null;
    let t = this.view.scrollDOM.getBoundingClientRect();
    return {
      left: e.left - t.left + this.view.scrollDOM.scrollLeft,
      top: e.top - t.top + this.view.scrollDOM.scrollTop,
      height: e.bottom - e.top
    };
  }
  drawCursor(r) {
    this.cursor && (r ? (this.cursor.style.left = r.left + "px", this.cursor.style.top = r.top + "px", this.cursor.style.height = r.height + "px") : this.cursor.style.left = "-100000px");
  }
  destroy() {
    this.cursor && this.cursor.remove();
  }
  setDropPos(r) {
    this.view.state.field(wp) != r && this.view.dispatch({ effects: A6.of(r) });
  }
}, {
  eventHandlers: {
    dragover(r) {
      this.setDropPos(this.view.posAtCoords({ x: r.clientX, y: r.clientY }));
    },
    dragleave(r) {
      (r.target == this.view.contentDOM || !this.view.contentDOM.contains(r.relatedTarget)) && this.setDropPos(null);
    },
    dragend() {
      this.setDropPos(null);
    },
    drop() {
      this.setDropPos(null);
    }
  }
});
function Kwe() {
  return [wp, jwe];
}
function cG(r, e, t, i, n) {
  e.lastIndex = 0;
  for (let a = r.iterRange(t, i), o = t, s; !a.next().done; o += a.value.length)
    if (!a.lineBreak)
      for (; s = e.exec(a.value); )
        n(o + s.index, s);
}
function Jwe(r, e) {
  let t = r.visibleRanges;
  if (t.length == 1 && t[0].from == r.viewport.from && t[0].to == r.viewport.to)
    return t;
  let i = [];
  for (let { from: n, to: a } of t)
    n = Math.max(r.state.doc.lineAt(n).from, n - e), a = Math.min(r.state.doc.lineAt(a).to, a + e), i.length && i[i.length - 1].to >= n ? i[i.length - 1].to = a : i.push({ from: n, to: a });
  return i;
}
class e1e {
  /**
  Create a decorator.
  */
  constructor(e) {
    const { regexp: t, decoration: i, decorate: n, boundary: a, maxLength: o = 1e3 } = e;
    if (!t.global)
      throw new RangeError("The regular expression given to MatchDecorator should have its 'g' flag set");
    if (this.regexp = t, n)
      this.addMatch = (s, l, u, c) => n(c, u, u + s[0].length, s, l);
    else if (typeof i == "function")
      this.addMatch = (s, l, u, c) => {
        let h = i(s, l, u);
        h && c(u, u + s[0].length, h);
      };
    else if (i)
      this.addMatch = (s, l, u, c) => c(u, u + s[0].length, i);
    else
      throw new RangeError("Either 'decorate' or 'decoration' should be provided to MatchDecorator");
    this.boundary = a, this.maxLength = o;
  }
  /**
  Compute the full set of decorations for matches in the given
  view's viewport. You'll want to call this when initializing your
  plugin.
  */
  createDeco(e) {
    let t = new Ul(), i = t.add.bind(t);
    for (let { from: n, to: a } of Jwe(e, this.maxLength))
      cG(e.state.doc, this.regexp, n, a, (o, s) => this.addMatch(s, e, o, i));
    return t.finish();
  }
  /**
  Update a set of decorations for a view update. `deco` _must_ be
  the set of decorations produced by _this_ `MatchDecorator` for
  the view state before the update.
  */
  updateDeco(e, t) {
    let i = 1e9, n = -1;
    return e.docChanged && e.changes.iterChanges((a, o, s, l) => {
      l > e.view.viewport.from && s < e.view.viewport.to && (i = Math.min(s, i), n = Math.max(l, n));
    }), e.viewportChanged || n - i > 1e3 ? this.createDeco(e.view) : n > -1 ? this.updateRange(e.view, t.map(e.changes), i, n) : t;
  }
  updateRange(e, t, i, n) {
    for (let a of e.visibleRanges) {
      let o = Math.max(a.from, i), s = Math.min(a.to, n);
      if (s > o) {
        let l = e.state.doc.lineAt(o), u = l.to < s ? e.state.doc.lineAt(s) : l, c = Math.max(a.from, l.from), h = Math.min(a.to, u.to);
        if (this.boundary) {
          for (; o > l.from; o--)
            if (this.boundary.test(l.text[o - 1 - l.from])) {
              c = o;
              break;
            }
          for (; s < u.to; s++)
            if (this.boundary.test(u.text[s - u.from])) {
              h = s;
              break;
            }
        }
        let f = [], d, p = (g, v, O) => f.push(O.range(g, v));
        if (l == u)
          for (this.regexp.lastIndex = c - l.from; (d = this.regexp.exec(l.text)) && d.index < h - l.from; )
            this.addMatch(d, e, d.index + l.from, p);
        else
          cG(e.state.doc, this.regexp, c, h, (g, v) => this.addMatch(v, e, g, p));
        t = t.update({ filterFrom: c, filterTo: h, filter: (g, v) => g < c || v > h, add: f });
      }
    }
    return t;
  }
}
const XI = /x/.unicode != null ? "gu" : "g", t1e = /* @__PURE__ */ new RegExp(`[\0-\b
--\u2028\u2029\uFEFF-]`, XI), r1e = {
  0: "null",
  7: "bell",
  8: "backspace",
  10: "newline",
  11: "vertical tab",
  13: "carriage return",
  27: "escape",
  8203: "zero width space",
  8204: "zero width non-joiner",
  8205: "zero width joiner",
  8206: "left-to-right mark",
  8207: "right-to-left mark",
  8232: "line separator",
  8237: "left-to-right override",
  8238: "right-to-left override",
  8294: "left-to-right isolate",
  8295: "right-to-left isolate",
  8297: "pop directional isolate",
  8233: "paragraph separator",
  65279: "zero width no-break space",
  65532: "object replacement"
};
let OA = null;
function i1e() {
  var r;
  if (OA == null && typeof document < "u" && document.body) {
    let e = document.body.style;
    OA = ((r = e.tabSize) !== null && r !== void 0 ? r : e.MozTabSize) != null;
  }
  return OA || !1;
}
const gE = /* @__PURE__ */ Ce.define({
  combine(r) {
    let e = Lo(r, {
      render: null,
      specialChars: t1e,
      addSpecialChars: null
    });
    return (e.replaceTabs = !i1e()) && (e.specialChars = new RegExp("	|" + e.specialChars.source, XI)), e.addSpecialChars && (e.specialChars = new RegExp(e.specialChars.source + "|" + e.addSpecialChars.source, XI)), e;
  }
});
function n1e(r = {}) {
  return [gE.of(r), a1e()];
}
let hG = null;
function a1e() {
  return hG || (hG = Ur.fromClass(class {
    constructor(r) {
      this.view = r, this.decorations = Xe.none, this.decorationCache = /* @__PURE__ */ Object.create(null), this.decorator = this.makeDecorator(r.state.facet(gE)), this.decorations = this.decorator.createDeco(r);
    }
    makeDecorator(r) {
      return new e1e({
        regexp: r.specialChars,
        decoration: (e, t, i) => {
          let { doc: n } = t.state, a = Zr(e[0], 0);
          if (a == 9) {
            let o = n.lineAt(i), s = t.state.tabSize, l = Bv(o.text, s, i - o.from);
            return Xe.replace({ widget: new u1e((s - l % s) * this.view.defaultCharacterWidth) });
          }
          return this.decorationCache[a] || (this.decorationCache[a] = Xe.replace({ widget: new l1e(r, a) }));
        },
        boundary: r.replaceTabs ? void 0 : /[^]/
      });
    }
    update(r) {
      let e = r.state.facet(gE);
      r.startState.facet(gE) != e ? (this.decorator = this.makeDecorator(e), this.decorations = this.decorator.createDeco(r.view)) : this.decorations = this.decorator.updateDeco(r, this.decorations);
    }
  }, {
    decorations: (r) => r.decorations
  }));
}
const o1e = "";
function s1e(r) {
  return r >= 32 ? o1e : r == 10 ? "" : String.fromCharCode(9216 + r);
}
class l1e extends Rs {
  constructor(e, t) {
    super(), this.options = e, this.code = t;
  }
  eq(e) {
    return e.code == this.code;
  }
  toDOM(e) {
    let t = s1e(this.code), i = e.state.phrase("Control character") + " " + (r1e[this.code] || "0x" + this.code.toString(16)), n = this.options.render && this.options.render(this.code, i, t);
    if (n)
      return n;
    let a = document.createElement("span");
    return a.textContent = t, a.title = i, a.setAttribute("aria-label", i), a.className = "cm-specialChar", a;
  }
  ignoreEvent() {
    return !1;
  }
}
class u1e extends Rs {
  constructor(e) {
    super(), this.width = e;
  }
  eq(e) {
    return e.width == this.width;
  }
  toDOM() {
    let e = document.createElement("span");
    return e.textContent = "	", e.className = "cm-tab", e.style.width = this.width + "px", e;
  }
  ignoreEvent() {
    return !1;
  }
}
function c1e() {
  return f1e;
}
const h1e = /* @__PURE__ */ Xe.line({ class: "cm-activeLine" }), f1e = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.docChanged || r.selectionSet) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = -1, t = [];
    for (let i of r.state.selection.ranges) {
      let n = r.lineBlockAt(i.head);
      n.from > e && (t.push(h1e.range(n.from)), e = n.from);
    }
    return Xe.set(t);
  }
}, {
  decorations: (r) => r.decorations
}), YI = 2e3;
function d1e(r, e, t) {
  let i = Math.min(e.line, t.line), n = Math.max(e.line, t.line), a = [];
  if (e.off > YI || t.off > YI || e.col < 0 || t.col < 0) {
    let o = Math.min(e.off, t.off), s = Math.max(e.off, t.off);
    for (let l = i; l <= n; l++) {
      let u = r.doc.line(l);
      u.length <= s && a.push(Z.range(u.from + o, u.to + s));
    }
  } else {
    let o = Math.min(e.col, t.col), s = Math.max(e.col, t.col);
    for (let l = i; l <= n; l++) {
      let u = r.doc.line(l), c = RI(u.text, o, r.tabSize, !0);
      if (c < 0)
        a.push(Z.cursor(u.to));
      else {
        let h = RI(u.text, s, r.tabSize);
        a.push(Z.range(u.from + c, u.from + h));
      }
    }
  }
  return a;
}
function p1e(r, e) {
  let t = r.coordsAtPos(r.viewport.from);
  return t ? Math.round(Math.abs((t.left - e) / r.defaultCharacterWidth)) : -1;
}
function fG(r, e) {
  let t = r.posAtCoords({ x: e.clientX, y: e.clientY }, !1), i = r.state.doc.lineAt(t), n = t - i.from, a = n > YI ? -1 : n == i.length ? p1e(r, e.clientX) : Bv(i.text, r.state.tabSize, t - i.from);
  return { line: i.number, col: a, off: n };
}
function g1e(r, e) {
  let t = fG(r, e), i = r.state.selection;
  return t ? {
    update(n) {
      if (n.docChanged) {
        let a = n.changes.mapPos(n.startState.doc.line(t.line).from), o = n.state.doc.lineAt(a);
        t = { line: o.number, col: t.col, off: Math.min(t.off, o.length) }, i = i.map(n.changes);
      }
    },
    get(n, a, o) {
      let s = fG(r, n);
      if (!s)
        return i;
      let l = d1e(r.state, t, s);
      return l.length ? o ? Z.create(l.concat(i.ranges)) : Z.create(l) : i;
    }
  } : null;
}
function v1e(r) {
  let e = (r == null ? void 0 : r.eventFilter) || ((t) => t.altKey && t.button == 0);
  return me.mouseSelectionStyle.of((t, i) => e(i) ? g1e(t, i) : null);
}
const O1e = {
  Alt: [18, (r) => !!r.altKey],
  Control: [17, (r) => !!r.ctrlKey],
  Shift: [16, (r) => !!r.shiftKey],
  Meta: [91, (r) => !!r.metaKey]
}, m1e = { style: "cursor: crosshair" };
function E1e(r = {}) {
  let [e, t] = O1e[r.key || "Alt"], i = Ur.fromClass(class {
    constructor(n) {
      this.view = n, this.isDown = !1;
    }
    set(n) {
      this.isDown != n && (this.isDown = n, this.view.update([]));
    }
  }, {
    eventHandlers: {
      keydown(n) {
        this.set(n.keyCode == e || t(n));
      },
      keyup(n) {
        (n.keyCode == e || !t(n)) && this.set(!1);
      },
      mousemove(n) {
        this.set(t(n));
      }
    }
  });
  return [
    i,
    me.contentAttributes.of((n) => {
      var a;
      return !((a = n.plugin(i)) === null || a === void 0) && a.isDown ? m1e : null;
    })
  ];
}
const _m = "-10000px";
class _6 {
  constructor(e, t, i) {
    this.facet = t, this.createTooltipView = i, this.input = e.state.facet(t), this.tooltips = this.input.filter((n) => n), this.tooltipViews = this.tooltips.map(i);
  }
  update(e) {
    var t;
    let i = e.state.facet(this.facet), n = i.filter((o) => o);
    if (i === this.input) {
      for (let o of this.tooltipViews)
        o.update && o.update(e);
      return !1;
    }
    let a = [];
    for (let o = 0; o < n.length; o++) {
      let s = n[o], l = -1;
      if (s) {
        for (let u = 0; u < this.tooltips.length; u++) {
          let c = this.tooltips[u];
          c && c.create == s.create && (l = u);
        }
        if (l < 0)
          a[o] = this.createTooltipView(s);
        else {
          let u = a[o] = this.tooltipViews[l];
          u.update && u.update(e);
        }
      }
    }
    for (let o of this.tooltipViews)
      a.indexOf(o) < 0 && (o.dom.remove(), (t = o.destroy) === null || t === void 0 || t.call(o));
    return this.input = i, this.tooltips = n, this.tooltipViews = a, !0;
  }
}
function b1e(r) {
  let { win: e } = r;
  return { top: 0, left: 0, bottom: e.innerHeight, right: e.innerWidth };
}
const mA = /* @__PURE__ */ Ce.define({
  combine: (r) => {
    var e, t, i;
    return {
      position: we.ios ? "absolute" : ((e = r.find((n) => n.position)) === null || e === void 0 ? void 0 : e.position) || "fixed",
      parent: ((t = r.find((n) => n.parent)) === null || t === void 0 ? void 0 : t.parent) || null,
      tooltipSpace: ((i = r.find((n) => n.tooltipSpace)) === null || i === void 0 ? void 0 : i.tooltipSpace) || b1e
    };
  }
}), dG = /* @__PURE__ */ new WeakMap(), C6 = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.view = r, this.inView = !0, this.lastTransaction = 0, this.measureTimeout = -1;
    let e = r.state.facet(mA);
    this.position = e.position, this.parent = e.parent, this.classes = r.themeClasses, this.createContainer(), this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this }, this.manager = new _6(r, Gx, (t) => this.createTooltip(t)), this.intersectionObserver = typeof IntersectionObserver == "function" ? new IntersectionObserver((t) => {
      Date.now() > this.lastTransaction - 50 && t.length > 0 && t[t.length - 1].intersectionRatio < 1 && this.measureSoon();
    }, { threshold: [1] }) : null, this.observeIntersection(), r.win.addEventListener("resize", this.measureSoon = this.measureSoon.bind(this)), this.maybeMeasure();
  }
  createContainer() {
    this.parent ? (this.container = document.createElement("div"), this.container.style.position = "relative", this.container.className = this.view.themeClasses, this.parent.appendChild(this.container)) : this.container = this.view.dom;
  }
  observeIntersection() {
    if (this.intersectionObserver) {
      this.intersectionObserver.disconnect();
      for (let r of this.manager.tooltipViews)
        this.intersectionObserver.observe(r.dom);
    }
  }
  measureSoon() {
    this.measureTimeout < 0 && (this.measureTimeout = setTimeout(() => {
      this.measureTimeout = -1, this.maybeMeasure();
    }, 50));
  }
  update(r) {
    r.transactions.length && (this.lastTransaction = Date.now());
    let e = this.manager.update(r);
    e && this.observeIntersection();
    let t = e || r.geometryChanged, i = r.state.facet(mA);
    if (i.position != this.position) {
      this.position = i.position;
      for (let n of this.manager.tooltipViews)
        n.dom.style.position = this.position;
      t = !0;
    }
    if (i.parent != this.parent) {
      this.parent && this.container.remove(), this.parent = i.parent, this.createContainer();
      for (let n of this.manager.tooltipViews)
        this.container.appendChild(n.dom);
      t = !0;
    } else
      this.parent && this.view.themeClasses != this.classes && (this.classes = this.container.className = this.view.themeClasses);
    t && this.maybeMeasure();
  }
  createTooltip(r) {
    let e = r.create(this.view);
    if (e.dom.classList.add("cm-tooltip"), r.arrow && !e.dom.querySelector(".cm-tooltip > .cm-tooltip-arrow")) {
      let t = document.createElement("div");
      t.className = "cm-tooltip-arrow", e.dom.appendChild(t);
    }
    return e.dom.style.position = this.position, e.dom.style.top = _m, this.container.appendChild(e.dom), e.mount && e.mount(this.view), e;
  }
  destroy() {
    var r, e;
    this.view.win.removeEventListener("resize", this.measureSoon);
    for (let t of this.manager.tooltipViews)
      t.dom.remove(), (r = t.destroy) === null || r === void 0 || r.call(t);
    (e = this.intersectionObserver) === null || e === void 0 || e.disconnect(), clearTimeout(this.measureTimeout);
  }
  readMeasure() {
    let r = this.view.dom.getBoundingClientRect();
    return {
      editor: r,
      parent: this.parent ? this.container.getBoundingClientRect() : r,
      pos: this.manager.tooltips.map((e, t) => {
        let i = this.manager.tooltipViews[t];
        return i.getCoords ? i.getCoords(e.pos) : this.view.coordsAtPos(e.pos);
      }),
      size: this.manager.tooltipViews.map(({ dom: e }) => e.getBoundingClientRect()),
      space: this.view.state.facet(mA).tooltipSpace(this.view)
    };
  }
  writeMeasure(r) {
    var e;
    let { editor: t, space: i } = r, n = [];
    for (let a = 0; a < this.manager.tooltips.length; a++) {
      let o = this.manager.tooltips[a], s = this.manager.tooltipViews[a], { dom: l } = s, u = r.pos[a], c = r.size[a];
      if (!u || u.bottom <= Math.max(t.top, i.top) || u.top >= Math.min(t.bottom, i.bottom) || u.right < Math.max(t.left, i.left) - 0.1 || u.left > Math.min(t.right, i.right) + 0.1) {
        l.style.top = _m;
        continue;
      }
      let h = o.arrow ? s.dom.querySelector(".cm-tooltip-arrow") : null, f = h ? 7 : 0, d = c.right - c.left, p = (e = dG.get(s)) !== null && e !== void 0 ? e : c.bottom - c.top, g = s.offset || T1e, v = this.view.textDirection == ir.LTR, O = c.width > i.right - i.left ? v ? i.left : i.right - c.width : v ? Math.min(u.left - (h ? 14 : 0) + g.x, i.right - d) : Math.max(i.left, u.left - d + (h ? 14 : 0) - g.x), m = !!o.above;
      !o.strictSide && (m ? u.top - (c.bottom - c.top) - g.y < i.top : u.bottom + (c.bottom - c.top) + g.y > i.bottom) && m == i.bottom - u.bottom > u.top - i.top && (m = !m);
      let E = (m ? u.top - i.top : i.bottom - u.bottom) - f;
      if (E < p && s.resize !== !1) {
        if (E < this.view.defaultLineHeight) {
          l.style.top = _m;
          continue;
        }
        dG.set(s, p), l.style.height = (p = E) + "px";
      } else
        l.style.height && (l.style.height = "");
      let b = m ? u.top - p - f - g.y : u.bottom + f + g.y, S = O + d;
      if (s.overlap !== !0)
        for (let T of n)
          T.left < S && T.right > O && T.top < b + p && T.bottom > b && (b = m ? T.top - p - 2 - f : T.bottom + f + 2);
      this.position == "absolute" ? (l.style.top = b - r.parent.top + "px", l.style.left = O - r.parent.left + "px") : (l.style.top = b + "px", l.style.left = O + "px"), h && (h.style.left = `${u.left + (v ? g.x : -g.x) - (O + 14 - 7)}px`), s.overlap !== !0 && n.push({ left: O, top: b, right: S, bottom: b + p }), l.classList.toggle("cm-tooltip-above", m), l.classList.toggle("cm-tooltip-below", !m), s.positioned && s.positioned(r.space);
    }
  }
  maybeMeasure() {
    if (this.manager.tooltips.length && (this.view.inView && this.view.requestMeasure(this.measureReq), this.inView != this.view.inView && (this.inView = this.view.inView, !this.inView)))
      for (let r of this.manager.tooltipViews)
        r.dom.style.top = _m;
  }
}, {
  eventHandlers: {
    scroll() {
      this.maybeMeasure();
    }
  }
}), S1e = /* @__PURE__ */ me.baseTheme({
  ".cm-tooltip": {
    zIndex: 100,
    boxSizing: "border-box"
  },
  "&light .cm-tooltip": {
    border: "1px solid #bbb",
    backgroundColor: "#f5f5f5"
  },
  "&light .cm-tooltip-section:not(:first-child)": {
    borderTop: "1px solid #bbb"
  },
  "&dark .cm-tooltip": {
    backgroundColor: "#333338",
    color: "white"
  },
  ".cm-tooltip-arrow": {
    height: "7px",
    width: `${7 * 2}px`,
    position: "absolute",
    zIndex: -1,
    overflow: "hidden",
    "&:before, &:after": {
      content: "''",
      position: "absolute",
      width: 0,
      height: 0,
      borderLeft: "7px solid transparent",
      borderRight: "7px solid transparent"
    },
    ".cm-tooltip-above &": {
      bottom: "-7px",
      "&:before": {
        borderTop: "7px solid #bbb"
      },
      "&:after": {
        borderTop: "7px solid #f5f5f5",
        bottom: "1px"
      }
    },
    ".cm-tooltip-below &": {
      top: "-7px",
      "&:before": {
        borderBottom: "7px solid #bbb"
      },
      "&:after": {
        borderBottom: "7px solid #f5f5f5",
        top: "1px"
      }
    }
  },
  "&dark .cm-tooltip .cm-tooltip-arrow": {
    "&:before": {
      borderTopColor: "#333338",
      borderBottomColor: "#333338"
    },
    "&:after": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    }
  }
}), T1e = { x: 0, y: 0 }, Gx = /* @__PURE__ */ Ce.define({
  enables: [C6, S1e]
}), nS = /* @__PURE__ */ Ce.define();
class Bx {
  constructor(e) {
    this.view = e, this.mounted = !1, this.dom = document.createElement("div"), this.dom.classList.add("cm-tooltip-hover"), this.manager = new _6(e, nS, (t) => this.createHostedView(t));
  }
  // Needs to be static so that host tooltip instances always match
  static create(e) {
    return new Bx(e);
  }
  createHostedView(e) {
    let t = e.create(this.view);
    return t.dom.classList.add("cm-tooltip-section"), this.dom.appendChild(t.dom), this.mounted && t.mount && t.mount(this.view), t;
  }
  mount(e) {
    for (let t of this.manager.tooltipViews)
      t.mount && t.mount(e);
    this.mounted = !0;
  }
  positioned(e) {
    for (let t of this.manager.tooltipViews)
      t.positioned && t.positioned(e);
  }
  update(e) {
    this.manager.update(e);
  }
  destroy() {
    var e;
    for (let t of this.manager.tooltipViews)
      (e = t.destroy) === null || e === void 0 || e.call(t);
  }
}
const y1e = /* @__PURE__ */ Gx.compute([nS], (r) => {
  let e = r.facet(nS).filter((t) => t);
  return e.length === 0 ? null : {
    pos: Math.min(...e.map((t) => t.pos)),
    end: Math.max(...e.filter((t) => t.end != null).map((t) => t.end)),
    create: Bx.create,
    above: e[0].above,
    arrow: e.some((t) => t.arrow)
  };
});
class R1e {
  constructor(e, t, i, n, a) {
    this.view = e, this.source = t, this.field = i, this.setHover = n, this.hoverTime = a, this.hoverTimeout = -1, this.restartTimeout = -1, this.pending = null, this.lastMove = { x: 0, y: 0, target: e.dom, time: 0 }, this.checkHover = this.checkHover.bind(this), e.dom.addEventListener("mouseleave", this.mouseleave = this.mouseleave.bind(this)), e.dom.addEventListener("mousemove", this.mousemove = this.mousemove.bind(this));
  }
  update() {
    this.pending && (this.pending = null, clearTimeout(this.restartTimeout), this.restartTimeout = setTimeout(() => this.startHover(), 20));
  }
  get active() {
    return this.view.state.field(this.field);
  }
  checkHover() {
    if (this.hoverTimeout = -1, this.active)
      return;
    let e = Date.now() - this.lastMove.time;
    e < this.hoverTime ? this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime - e) : this.startHover();
  }
  startHover() {
    clearTimeout(this.restartTimeout);
    let { lastMove: e } = this, t = this.view.contentDOM.contains(e.target) ? this.view.posAtCoords(e) : null;
    if (t == null)
      return;
    let i = this.view.coordsAtPos(t);
    if (i == null || e.y < i.top || e.y > i.bottom || e.x < i.left - this.view.defaultCharacterWidth || e.x > i.right + this.view.defaultCharacterWidth)
      return;
    let n = this.view.bidiSpans(this.view.state.doc.lineAt(t)).find((s) => s.from <= t && s.to >= t), a = n && n.dir == ir.RTL ? -1 : 1, o = this.source(this.view, t, e.x < i.left ? -a : a);
    if (o != null && o.then) {
      let s = this.pending = { pos: t };
      o.then((l) => {
        this.pending == s && (this.pending = null, l && this.view.dispatch({ effects: this.setHover.of(l) }));
      }, (l) => ea(this.view.state, l, "hover tooltip"));
    } else
      o && this.view.dispatch({ effects: this.setHover.of(o) });
  }
  mousemove(e) {
    var t;
    this.lastMove = { x: e.clientX, y: e.clientY, target: e.target, time: Date.now() }, this.hoverTimeout < 0 && (this.hoverTimeout = setTimeout(this.checkHover, this.hoverTime));
    let i = this.active;
    if (i && !pG(this.lastMove.target) || this.pending) {
      let { pos: n } = i || this.pending, a = (t = i == null ? void 0 : i.end) !== null && t !== void 0 ? t : n;
      (n == a ? this.view.posAtCoords(this.lastMove) != n : !A1e(
        this.view,
        n,
        a,
        e.clientX,
        e.clientY,
        6
        /* MaxDist */
      )) && (this.view.dispatch({ effects: this.setHover.of(null) }), this.pending = null);
    }
  }
  mouseleave(e) {
    clearTimeout(this.hoverTimeout), this.hoverTimeout = -1, this.active && !pG(e.relatedTarget) && this.view.dispatch({ effects: this.setHover.of(null) });
  }
  destroy() {
    clearTimeout(this.hoverTimeout), this.view.dom.removeEventListener("mouseleave", this.mouseleave), this.view.dom.removeEventListener("mousemove", this.mousemove);
  }
}
function pG(r) {
  for (let e = r; e; e = e.parentNode)
    if (e.nodeType == 1 && e.classList.contains("cm-tooltip"))
      return !0;
  return !1;
}
function A1e(r, e, t, i, n, a) {
  let o = document.createRange(), s = r.domAtPos(e), l = r.domAtPos(t);
  o.setEnd(l.node, l.offset), o.setStart(s.node, s.offset);
  let u = o.getClientRects();
  o.detach();
  for (let c = 0; c < u.length; c++) {
    let h = u[c];
    if (Math.max(h.top - n, n - h.bottom, h.left - i, i - h.right) <= a)
      return !0;
  }
  return !1;
}
function _1e(r, e = {}) {
  let t = lt.define(), i = Br.define({
    create() {
      return null;
    },
    update(n, a) {
      if (n && (e.hideOnChange && (a.docChanged || a.selection) || e.hideOn && e.hideOn(a, n)))
        return null;
      if (n && a.docChanged) {
        let o = a.changes.mapPos(n.pos, -1, jr.TrackDel);
        if (o == null)
          return null;
        let s = Object.assign(/* @__PURE__ */ Object.create(null), n);
        s.pos = o, n.end != null && (s.end = a.changes.mapPos(n.end)), n = s;
      }
      for (let o of a.effects)
        o.is(t) && (n = o.value), o.is(C1e) && (n = null);
      return n;
    },
    provide: (n) => nS.from(n)
  });
  return [
    i,
    Ur.define((n) => new R1e(
      n,
      r,
      i,
      t,
      e.hoverTime || 300
      /* Time */
    )),
    y1e
  ];
}
function I6(r, e) {
  let t = r.plugin(C6);
  if (!t)
    return null;
  let i = t.manager.tooltips.indexOf(e);
  return i < 0 ? null : t.manager.tooltipViews[i];
}
const C1e = /* @__PURE__ */ lt.define(), gG = /* @__PURE__ */ Ce.define({
  combine(r) {
    let e, t;
    for (let i of r)
      e = e || i.topContainer, t = t || i.bottomContainer;
    return { topContainer: e, bottomContainer: t };
  }
});
function nv(r, e) {
  let t = r.plugin(w6), i = t ? t.specs.indexOf(e) : -1;
  return i > -1 ? t.panels[i] : null;
}
const w6 = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.input = r.state.facet(av), this.specs = this.input.filter((t) => t), this.panels = this.specs.map((t) => t(r));
    let e = r.state.facet(gG);
    this.top = new Cm(r, !0, e.topContainer), this.bottom = new Cm(r, !1, e.bottomContainer), this.top.sync(this.panels.filter((t) => t.top)), this.bottom.sync(this.panels.filter((t) => !t.top));
    for (let t of this.panels)
      t.dom.classList.add("cm-panel"), t.mount && t.mount();
  }
  update(r) {
    let e = r.state.facet(gG);
    this.top.container != e.topContainer && (this.top.sync([]), this.top = new Cm(r.view, !0, e.topContainer)), this.bottom.container != e.bottomContainer && (this.bottom.sync([]), this.bottom = new Cm(r.view, !1, e.bottomContainer)), this.top.syncClasses(), this.bottom.syncClasses();
    let t = r.state.facet(av);
    if (t != this.input) {
      let i = t.filter((l) => l), n = [], a = [], o = [], s = [];
      for (let l of i) {
        let u = this.specs.indexOf(l), c;
        u < 0 ? (c = l(r.view), s.push(c)) : (c = this.panels[u], c.update && c.update(r)), n.push(c), (c.top ? a : o).push(c);
      }
      this.specs = i, this.panels = n, this.top.sync(a), this.bottom.sync(o);
      for (let l of s)
        l.dom.classList.add("cm-panel"), l.mount && l.mount();
    } else
      for (let i of this.panels)
        i.update && i.update(r);
  }
  destroy() {
    this.top.sync([]), this.bottom.sync([]);
  }
}, {
  provide: (r) => me.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return t && { top: t.top.scrollMargin(), bottom: t.bottom.scrollMargin() };
  })
});
class Cm {
  constructor(e, t, i) {
    this.view = e, this.top = t, this.container = i, this.dom = void 0, this.classes = "", this.panels = [], this.syncClasses();
  }
  sync(e) {
    for (let t of this.panels)
      t.destroy && e.indexOf(t) < 0 && t.destroy();
    this.panels = e, this.syncDOM();
  }
  syncDOM() {
    if (this.panels.length == 0) {
      this.dom && (this.dom.remove(), this.dom = void 0);
      return;
    }
    if (!this.dom) {
      this.dom = document.createElement("div"), this.dom.className = this.top ? "cm-panels cm-panels-top" : "cm-panels cm-panels-bottom", this.dom.style[this.top ? "top" : "bottom"] = "0";
      let t = this.container || this.view.dom;
      t.insertBefore(this.dom, this.top ? t.firstChild : null);
    }
    let e = this.dom.firstChild;
    for (let t of this.panels)
      if (t.dom.parentNode == this.dom) {
        for (; e != t.dom; )
          e = vG(e);
        e = e.nextSibling;
      } else
        this.dom.insertBefore(t.dom, e);
    for (; e; )
      e = vG(e);
  }
  scrollMargin() {
    return !this.dom || this.container ? 0 : Math.max(0, this.top ? this.dom.getBoundingClientRect().bottom - Math.max(0, this.view.scrollDOM.getBoundingClientRect().top) : Math.min(innerHeight, this.view.scrollDOM.getBoundingClientRect().bottom) - this.dom.getBoundingClientRect().top);
  }
  syncClasses() {
    if (!(!this.container || this.classes == this.view.themeClasses)) {
      for (let e of this.classes.split(" "))
        e && this.container.classList.remove(e);
      for (let e of (this.classes = this.view.themeClasses).split(" "))
        e && this.container.classList.add(e);
    }
  }
}
function vG(r) {
  let e = r.nextSibling;
  return r.remove(), e;
}
const av = /* @__PURE__ */ Ce.define({
  enables: w6
});
class ps extends Mc {
  /**
  @internal
  */
  compare(e) {
    return this == e || this.constructor == e.constructor && this.eq(e);
  }
  /**
  Compare this marker to another marker of the same type.
  */
  eq(e) {
    return !1;
  }
  /**
  Called if the marker has a `toDOM` method and its representation
  was removed from a gutter.
  */
  destroy(e) {
  }
}
ps.prototype.elementClass = "";
ps.prototype.toDOM = void 0;
ps.prototype.mapMode = jr.TrackBefore;
ps.prototype.startSide = ps.prototype.endSide = -1;
ps.prototype.point = !0;
const vE = /* @__PURE__ */ Ce.define(), I1e = {
  class: "",
  renderEmptyElements: !1,
  elementStyle: "",
  markers: () => kt.empty,
  lineMarker: () => null,
  widgetMarker: () => null,
  lineMarkerChange: null,
  initialSpacer: null,
  updateSpacer: null,
  domEventHandlers: {}
}, og = /* @__PURE__ */ Ce.define();
function w1e(r) {
  return [N6(), og.of(Object.assign(Object.assign({}, I1e), r))];
}
const HI = /* @__PURE__ */ Ce.define({
  combine: (r) => r.some((e) => e)
});
function N6(r) {
  let e = [
    N1e
  ];
  return r && r.fixed === !1 && e.push(HI.of(!0)), e;
}
const N1e = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.view = r, this.prevViewport = r.viewport, this.dom = document.createElement("div"), this.dom.className = "cm-gutters", this.dom.setAttribute("aria-hidden", "true"), this.dom.style.minHeight = this.view.contentHeight + "px", this.gutters = r.state.facet(og).map((e) => new mG(r, e));
    for (let e of this.gutters)
      this.dom.appendChild(e.dom);
    this.fixed = !r.state.facet(HI), this.fixed && (this.dom.style.position = "sticky"), this.syncGutters(!1), r.scrollDOM.insertBefore(this.dom, r.contentDOM);
  }
  update(r) {
    if (this.updateGutters(r)) {
      let e = this.prevViewport, t = r.view.viewport, i = Math.min(e.to, t.to) - Math.max(e.from, t.from);
      this.syncGutters(i < (t.to - t.from) * 0.8);
    }
    r.geometryChanged && (this.dom.style.minHeight = this.view.contentHeight + "px"), this.view.state.facet(HI) != !this.fixed && (this.fixed = !this.fixed, this.dom.style.position = this.fixed ? "sticky" : ""), this.prevViewport = r.view.viewport;
  }
  syncGutters(r) {
    let e = this.dom.nextSibling;
    r && this.dom.remove();
    let t = kt.iter(this.view.state.facet(vE), this.view.viewport.from), i = [], n = this.gutters.map((a) => new x1e(a, this.view.viewport, -this.view.documentPadding.top));
    for (let a of this.view.viewportLineBlocks)
      if (i.length && (i = []), Array.isArray(a.type)) {
        let o = !0;
        for (let s of a.type)
          if (s.type == ar.Text && o) {
            WI(t, i, s.from);
            for (let l of n)
              l.line(this.view, s, i);
            o = !1;
          } else if (s.widget)
            for (let l of n)
              l.widget(this.view, s);
      } else if (a.type == ar.Text) {
        WI(t, i, a.from);
        for (let o of n)
          o.line(this.view, a, i);
      }
    for (let a of n)
      a.finish();
    r && this.view.scrollDOM.insertBefore(this.dom, e);
  }
  updateGutters(r) {
    let e = r.startState.facet(og), t = r.state.facet(og), i = r.docChanged || r.heightChanged || r.viewportChanged || !kt.eq(r.startState.facet(vE), r.state.facet(vE), r.view.viewport.from, r.view.viewport.to);
    if (e == t)
      for (let n of this.gutters)
        n.update(r) && (i = !0);
    else {
      i = !0;
      let n = [];
      for (let a of t) {
        let o = e.indexOf(a);
        o < 0 ? n.push(new mG(this.view, a)) : (this.gutters[o].update(r), n.push(this.gutters[o]));
      }
      for (let a of this.gutters)
        a.dom.remove(), n.indexOf(a) < 0 && a.destroy();
      for (let a of n)
        this.dom.appendChild(a.dom);
      this.gutters = n;
    }
    return i;
  }
  destroy() {
    for (let r of this.gutters)
      r.destroy();
    this.dom.remove();
  }
}, {
  provide: (r) => me.scrollMargins.of((e) => {
    let t = e.plugin(r);
    return !t || t.gutters.length == 0 || !t.fixed ? null : e.textDirection == ir.LTR ? { left: t.dom.offsetWidth } : { right: t.dom.offsetWidth };
  })
});
function OG(r) {
  return Array.isArray(r) ? r : [r];
}
function WI(r, e, t) {
  for (; r.value && r.from <= t; )
    r.from == t && e.push(r.value), r.next();
}
class x1e {
  constructor(e, t, i) {
    this.gutter = e, this.height = i, this.i = 0, this.cursor = kt.iter(e.markers, t.from);
  }
  addElement(e, t, i) {
    let { gutter: n } = this, a = t.top - this.height;
    if (this.i == n.elements.length) {
      let o = new x6(e, t.height, a, i);
      n.elements.push(o), n.dom.appendChild(o.dom);
    } else
      n.elements[this.i].update(e, t.height, a, i);
    this.height = t.bottom, this.i++;
  }
  line(e, t, i) {
    let n = [];
    WI(this.cursor, n, t.from), i.length && (n = n.concat(i));
    let a = this.gutter.config.lineMarker(e, t, n);
    a && n.unshift(a);
    let o = this.gutter;
    n.length == 0 && !o.config.renderEmptyElements || this.addElement(e, t, n);
  }
  widget(e, t) {
    let i = this.gutter.config.widgetMarker(e, t.widget, t);
    i && this.addElement(e, t, [i]);
  }
  finish() {
    let e = this.gutter;
    for (; e.elements.length > this.i; ) {
      let t = e.elements.pop();
      e.dom.removeChild(t.dom), t.destroy();
    }
  }
}
class mG {
  constructor(e, t) {
    this.view = e, this.config = t, this.elements = [], this.spacer = null, this.dom = document.createElement("div"), this.dom.className = "cm-gutter" + (this.config.class ? " " + this.config.class : "");
    for (let i in t.domEventHandlers)
      this.dom.addEventListener(i, (n) => {
        let a = n.target, o;
        if (a != this.dom && this.dom.contains(a)) {
          for (; a.parentNode != this.dom; )
            a = a.parentNode;
          let l = a.getBoundingClientRect();
          o = (l.top + l.bottom) / 2;
        } else
          o = n.clientY;
        let s = e.lineBlockAtHeight(o - e.documentTop);
        t.domEventHandlers[i](e, s, n) && n.preventDefault();
      });
    this.markers = OG(t.markers(e)), t.initialSpacer && (this.spacer = new x6(e, 0, 0, [t.initialSpacer(e)]), this.dom.appendChild(this.spacer.dom), this.spacer.dom.style.cssText += "visibility: hidden; pointer-events: none");
  }
  update(e) {
    let t = this.markers;
    if (this.markers = OG(this.config.markers(e.view)), this.spacer && this.config.updateSpacer) {
      let n = this.config.updateSpacer(this.spacer.markers[0], e);
      n != this.spacer.markers[0] && this.spacer.update(e.view, 0, 0, [n]);
    }
    let i = e.view.viewport;
    return !kt.eq(this.markers, t, i.from, i.to) || (this.config.lineMarkerChange ? this.config.lineMarkerChange(e) : !1);
  }
  destroy() {
    for (let e of this.elements)
      e.destroy();
  }
}
class x6 {
  constructor(e, t, i, n) {
    this.height = -1, this.above = 0, this.markers = [], this.dom = document.createElement("div"), this.dom.className = "cm-gutterElement", this.update(e, t, i, n);
  }
  update(e, t, i, n) {
    this.height != t && (this.dom.style.height = (this.height = t) + "px"), this.above != i && (this.dom.style.marginTop = (this.above = i) ? i + "px" : ""), P1e(this.markers, n) || this.setMarkers(e, n);
  }
  setMarkers(e, t) {
    let i = "cm-gutterElement", n = this.dom.firstChild;
    for (let a = 0, o = 0; ; ) {
      let s = o, l = a < t.length ? t[a++] : null, u = !1;
      if (l) {
        let c = l.elementClass;
        c && (i += " " + c);
        for (let h = o; h < this.markers.length; h++)
          if (this.markers[h].compare(l)) {
            s = h, u = !0;
            break;
          }
      } else
        s = this.markers.length;
      for (; o < s; ) {
        let c = this.markers[o++];
        if (c.toDOM) {
          c.destroy(n);
          let h = n.nextSibling;
          n.remove(), n = h;
        }
      }
      if (!l)
        break;
      l.toDOM && (u ? n = n.nextSibling : this.dom.insertBefore(l.toDOM(e), n)), u && o++;
    }
    this.dom.className = i, this.markers = t;
  }
  destroy() {
    this.setMarkers(null, []);
  }
}
function P1e(r, e) {
  if (r.length != e.length)
    return !1;
  for (let t = 0; t < r.length; t++)
    if (!r[t].compare(e[t]))
      return !1;
  return !0;
}
const L1e = /* @__PURE__ */ Ce.define(), jh = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, { formatNumber: String, domEventHandlers: {} }, {
      domEventHandlers(e, t) {
        let i = Object.assign({}, e);
        for (let n in t) {
          let a = i[n], o = t[n];
          i[n] = a ? (s, l, u) => a(s, l, u) || o(s, l, u) : o;
        }
        return i;
      }
    });
  }
});
class EA extends ps {
  constructor(e) {
    super(), this.number = e;
  }
  eq(e) {
    return this.number == e.number;
  }
  toDOM() {
    return document.createTextNode(this.number);
  }
}
function bA(r, e) {
  return r.state.facet(jh).formatNumber(e, r.state);
}
const D1e = /* @__PURE__ */ og.compute([jh], (r) => ({
  class: "cm-lineNumbers",
  renderEmptyElements: !1,
  markers(e) {
    return e.state.facet(L1e);
  },
  lineMarker(e, t, i) {
    return i.some((n) => n.toDOM) ? null : new EA(bA(e, e.state.doc.lineAt(t.from).number));
  },
  widgetMarker: () => null,
  lineMarkerChange: (e) => e.startState.facet(jh) != e.state.facet(jh),
  initialSpacer(e) {
    return new EA(bA(e, EG(e.state.doc.lines)));
  },
  updateSpacer(e, t) {
    let i = bA(t.view, EG(t.view.state.doc.lines));
    return i == e.number ? e : new EA(i);
  },
  domEventHandlers: r.facet(jh).domEventHandlers
}));
function M1e(r = {}) {
  return [
    jh.of(r),
    N6(),
    D1e
  ];
}
function EG(r) {
  let e = 9;
  for (; e < r; )
    e = e * 10 + 9;
  return e;
}
const k1e = /* @__PURE__ */ new class extends ps {
  constructor() {
    super(...arguments), this.elementClass = "cm-activeLineGutter";
  }
}(), Q1e = /* @__PURE__ */ vE.compute(["selection"], (r) => {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let n = r.doc.lineAt(i.head).from;
    n > t && (t = n, e.push(k1e.range(n)));
  }
  return kt.of(e);
});
function U1e() {
  return Q1e;
}
const P6 = 1024;
let $1e = 0;
class qn {
  constructor(e, t) {
    this.from = e, this.to = t;
  }
}
class gt {
  /**
  Create a new node prop type.
  */
  constructor(e = {}) {
    this.id = $1e++, this.perNode = !!e.perNode, this.deserialize = e.deserialize || (() => {
      throw new Error("This node type doesn't define a deserialize function");
    });
  }
  /**
  This is meant to be used with
  [`NodeSet.extend`](#common.NodeSet.extend) or
  [`LRParser.configure`](#lr.ParserConfig.props) to compute
  prop values for each node type in the set. Takes a [match
  object](#common.NodeType^match) or function that returns undefined
  if the node type doesn't get this prop, and the prop's value if
  it does.
  */
  add(e) {
    if (this.perNode)
      throw new RangeError("Can't add per-node props to node types");
    return typeof e != "function" && (e = Rn.match(e)), (t) => {
      let i = e(t);
      return i === void 0 ? null : [this, i];
    };
  }
}
gt.closedBy = new gt({ deserialize: (r) => r.split(" ") });
gt.openedBy = new gt({ deserialize: (r) => r.split(" ") });
gt.group = new gt({ deserialize: (r) => r.split(" ") });
gt.contextHash = new gt({ perNode: !0 });
gt.lookAhead = new gt({ perNode: !0 });
gt.mounted = new gt({ perNode: !0 });
class V1e {
  constructor(e, t, i) {
    this.tree = e, this.overlay = t, this.parser = i;
  }
}
const G1e = /* @__PURE__ */ Object.create(null);
let Rn = class L6 {
  /**
  @internal
  */
  constructor(e, t, i, n = 0) {
    this.name = e, this.props = t, this.id = i, this.flags = n;
  }
  /**
  Define a node type.
  */
  static define(e) {
    let t = e.props && e.props.length ? /* @__PURE__ */ Object.create(null) : G1e, i = (e.top ? 1 : 0) | (e.skipped ? 2 : 0) | (e.error ? 4 : 0) | (e.name == null ? 8 : 0), n = new L6(e.name || "", t, e.id, i);
    if (e.props) {
      for (let a of e.props)
        if (Array.isArray(a) || (a = a(n)), a) {
          if (a[0].perNode)
            throw new RangeError("Can't store a per-node prop on a node type");
          t[a[0].id] = a[1];
        }
    }
    return n;
  }
  /**
  Retrieves a node prop for this type. Will return `undefined` if
  the prop isn't present on this node.
  */
  prop(e) {
    return this.props[e.id];
  }
  /**
  True when this is the top node of a grammar.
  */
  get isTop() {
    return (this.flags & 1) > 0;
  }
  /**
  True when this node is produced by a skip rule.
  */
  get isSkipped() {
    return (this.flags & 2) > 0;
  }
  /**
  Indicates whether this is an error node.
  */
  get isError() {
    return (this.flags & 4) > 0;
  }
  /**
  When true, this node type doesn't correspond to a user-declared
  named node, for example because it is used to cache repetition.
  */
  get isAnonymous() {
    return (this.flags & 8) > 0;
  }
  /**
  Returns true when this node's name or one of its
  [groups](#common.NodeProp^group) matches the given string.
  */
  is(e) {
    if (typeof e == "string") {
      if (this.name == e)
        return !0;
      let t = this.prop(gt.group);
      return t ? t.indexOf(e) > -1 : !1;
    }
    return this.id == e;
  }
  /**
  Create a function from node types to arbitrary values by
  specifying an object whose property names are node or
  [group](#common.NodeProp^group) names. Often useful with
  [`NodeProp.add`](#common.NodeProp.add). You can put multiple
  names, separated by spaces, in a single property name to map
  multiple node names to a single value.
  */
  static match(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e)
      for (let n of i.split(" "))
        t[n] = e[i];
    return (i) => {
      for (let n = i.prop(gt.group), a = -1; a < (n ? n.length : 0); a++) {
        let o = t[a < 0 ? i.name : n[a]];
        if (o)
          return o;
      }
    };
  }
};
Rn.none = new Rn(
  "",
  /* @__PURE__ */ Object.create(null),
  0,
  8
  /* NodeFlag.Anonymous */
);
class Fx {
  /**
  Create a set with the given types. The `id` property of each
  type should correspond to its position within the array.
  */
  constructor(e) {
    this.types = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].id != t)
        throw new RangeError("Node type ids should correspond to array positions when creating a node set");
  }
  /**
  Create a copy of this set with some node properties added. The
  arguments to this method can be created with
  [`NodeProp.add`](#common.NodeProp.add).
  */
  extend(...e) {
    let t = [];
    for (let i of this.types) {
      let n = null;
      for (let a of e) {
        let o = a(i);
        o && (n || (n = Object.assign({}, i.props)), n[o[0].id] = o[1]);
      }
      t.push(n ? new Rn(i.name, n, i.id, i.flags) : i);
    }
    return new Fx(t);
  }
}
const Im = /* @__PURE__ */ new WeakMap(), bG = /* @__PURE__ */ new WeakMap();
var Xt;
(function(r) {
  r[r.ExcludeBuffers = 1] = "ExcludeBuffers", r[r.IncludeAnonymous = 2] = "IncludeAnonymous", r[r.IgnoreMounts = 4] = "IgnoreMounts", r[r.IgnoreOverlays = 8] = "IgnoreOverlays";
})(Xt || (Xt = {}));
class nr {
  /**
  Construct a new tree. See also [`Tree.build`](#common.Tree^build).
  */
  constructor(e, t, i, n, a) {
    if (this.type = e, this.children = t, this.positions = i, this.length = n, this.props = null, a && a.length) {
      this.props = /* @__PURE__ */ Object.create(null);
      for (let [o, s] of a)
        this.props[typeof o == "number" ? o : o.id] = s;
    }
  }
  /**
  @internal
  */
  toString() {
    let e = this.prop(gt.mounted);
    if (e && !e.overlay)
      return e.tree.toString();
    let t = "";
    for (let i of this.children) {
      let n = i.toString();
      n && (t && (t += ","), t += n);
    }
    return this.type.name ? (/\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (t.length ? "(" + t + ")" : "") : t;
  }
  /**
  Get a [tree cursor](#common.TreeCursor) positioned at the top of
  the tree. Mode can be used to [control](#common.IterMode) which
  nodes the cursor visits.
  */
  cursor(e = 0) {
    return new ov(this.topNode, e);
  }
  /**
  Get a [tree cursor](#common.TreeCursor) pointing into this tree
  at the given position and side (see
  [`moveTo`](#common.TreeCursor.moveTo).
  */
  cursorAt(e, t = 0, i = 0) {
    let n = Im.get(this) || this.topNode, a = new ov(n);
    return a.moveTo(e, t), Im.set(this, a._tree), a;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) object for the top of the
  tree.
  */
  get topNode() {
    return new ra(this, 0, 0, null);
  }
  /**
  Get the [syntax node](#common.SyntaxNode) at the given position.
  If `side` is -1, this will move into nodes that end at the
  position. If 1, it'll move into nodes that start at the
  position. With 0, it'll only enter nodes that cover the position
  from both sides.
  
  Note that this will not enter
  [overlays](#common.MountedTree.overlay), and you often want
  [`resolveInner`](#common.Tree.resolveInner) instead.
  */
  resolve(e, t = 0) {
    let i = $f(Im.get(this) || this.topNode, e, t, !1);
    return Im.set(this, i), i;
  }
  /**
  Like [`resolve`](#common.Tree.resolve), but will enter
  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node
  pointing into the innermost overlaid tree at the given position
  (with parent links going through all parent structure, including
  the host trees).
  */
  resolveInner(e, t = 0) {
    let i = $f(bG.get(this) || this.topNode, e, t, !0);
    return bG.set(this, i), i;
  }
  /**
  Iterate over the tree and its children, calling `enter` for any
  node that touches the `from`/`to` region (if given) before
  running over such a node's children, and `leave` (if given) when
  leaving the node. When `enter` returns `false`, that node will
  not have its children iterated over (or `leave` called).
  */
  iterate(e) {
    let { enter: t, leave: i, from: n = 0, to: a = this.length } = e, o = e.mode || 0, s = (o & Xt.IncludeAnonymous) > 0;
    for (let l = this.cursor(o | Xt.IncludeAnonymous); ; ) {
      let u = !1;
      if (l.from <= a && l.to >= n && (!s && l.type.isAnonymous || t(l) !== !1)) {
        if (l.firstChild())
          continue;
        u = !0;
      }
      for (; u && i && (s || !l.type.isAnonymous) && i(l), !l.nextSibling(); ) {
        if (!l.parent())
          return;
        u = !0;
      }
    }
  }
  /**
  Get the value of the given [node prop](#common.NodeProp) for this
  node. Works with both per-node and per-type props.
  */
  prop(e) {
    return e.perNode ? this.props ? this.props[e.id] : void 0 : this.type.prop(e);
  }
  /**
  Returns the node's [per-node props](#common.NodeProp.perNode) in a
  format that can be passed to the [`Tree`](#common.Tree)
  constructor.
  */
  get propValues() {
    let e = [];
    if (this.props)
      for (let t in this.props)
        e.push([+t, this.props[t]]);
    return e;
  }
  /**
  Balance the direct children of this tree, producing a copy of
  which may have children grouped into subtrees with type
  [`NodeType.none`](#common.NodeType^none).
  */
  balance(e = {}) {
    return this.children.length <= 8 ? this : Hx(Rn.none, this.children, this.positions, 0, this.children.length, 0, this.length, (t, i, n) => new nr(this.type, t, i, n, this.propValues), e.makeTree || ((t, i, n) => new nr(Rn.none, t, i, n)));
  }
  /**
  Build a tree from a postfix-ordered buffer of node information,
  or a cursor over such a buffer.
  */
  static build(e) {
    return F1e(e);
  }
}
nr.empty = new nr(Rn.none, [], [], 0);
class Xx {
  constructor(e, t) {
    this.buffer = e, this.index = t;
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  get pos() {
    return this.index;
  }
  next() {
    this.index -= 4;
  }
  fork() {
    return new Xx(this.buffer, this.index);
  }
}
class rh {
  /**
  Create a tree buffer.
  */
  constructor(e, t, i) {
    this.buffer = e, this.length = t, this.set = i;
  }
  /**
  @internal
  */
  get type() {
    return Rn.none;
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    for (let t = 0; t < this.buffer.length; )
      e.push(this.childString(t)), t = this.buffer[t + 3];
    return e.join(",");
  }
  /**
  @internal
  */
  childString(e) {
    let t = this.buffer[e], i = this.buffer[e + 3], n = this.set.types[t], a = n.name;
    if (/\W/.test(a) && !n.isError && (a = JSON.stringify(a)), e += 4, i == e)
      return a;
    let o = [];
    for (; e < i; )
      o.push(this.childString(e)), e = this.buffer[e + 3];
    return a + "(" + o.join(",") + ")";
  }
  /**
  @internal
  */
  findChild(e, t, i, n, a) {
    let { buffer: o } = this, s = -1;
    for (let l = e; l != t && !(D6(a, n, o[l + 1], o[l + 2]) && (s = l, i > 0)); l = o[l + 3])
      ;
    return s;
  }
  /**
  @internal
  */
  slice(e, t, i) {
    let n = this.buffer, a = new Uint16Array(t - e), o = 0;
    for (let s = e, l = 0; s < t; ) {
      a[l++] = n[s++], a[l++] = n[s++] - i;
      let u = a[l++] = n[s++] - i;
      a[l++] = n[s++] - e, o = Math.max(o, u);
    }
    return new rh(a, o, this.set);
  }
}
function D6(r, e, t, i) {
  switch (r) {
    case -2:
      return t < e;
    case -1:
      return i >= e && t < e;
    case 0:
      return t < e && i > e;
    case 1:
      return t <= e && i > e;
    case 2:
      return i > e;
    case 4:
      return !0;
  }
}
function M6(r, e) {
  let t = r.childBefore(e);
  for (; t; ) {
    let i = t.lastChild;
    if (!i || i.to != t.to)
      break;
    i.type.isError && i.from == i.to ? (r = t, t = i.prevSibling) : t = i;
  }
  return r;
}
function $f(r, e, t, i) {
  for (var n; r.from == r.to || (t < 1 ? r.from >= e : r.from > e) || (t > -1 ? r.to <= e : r.to < e); ) {
    let o = !i && r instanceof ra && r.index < 0 ? null : r.parent;
    if (!o)
      return r;
    r = o;
  }
  let a = i ? 0 : Xt.IgnoreOverlays;
  if (i)
    for (let o = r, s = o.parent; s; o = s, s = o.parent)
      o instanceof ra && o.index < 0 && ((n = s.enter(e, t, a)) === null || n === void 0 ? void 0 : n.from) != o.from && (r = s);
  for (; ; ) {
    let o = r.enter(e, t, a);
    if (!o)
      return r;
    r = o;
  }
}
class ra {
  constructor(e, t, i, n) {
    this._tree = e, this.from = t, this.index = i, this._parent = n;
  }
  get type() {
    return this._tree.type;
  }
  get name() {
    return this._tree.type.name;
  }
  get to() {
    return this.from + this._tree.length;
  }
  nextChild(e, t, i, n, a = 0) {
    for (let o = this; ; ) {
      for (let { children: s, positions: l } = o._tree, u = t > 0 ? s.length : -1; e != u; e += t) {
        let c = s[e], h = l[e] + o.from;
        if (D6(n, i, h, h + c.length)) {
          if (c instanceof rh) {
            if (a & Xt.ExcludeBuffers)
              continue;
            let f = c.findChild(0, c.buffer.length, t, i - h, n);
            if (f > -1)
              return new co(new B1e(o, c, e, h), null, f);
          } else if (a & Xt.IncludeAnonymous || !c.type.isAnonymous || Yx(c)) {
            let f;
            if (!(a & Xt.IgnoreMounts) && c.props && (f = c.prop(gt.mounted)) && !f.overlay)
              return new ra(f.tree, h, e, o);
            let d = new ra(c, h, e, o);
            return a & Xt.IncludeAnonymous || !d.type.isAnonymous ? d : d.nextChild(t < 0 ? c.children.length - 1 : 0, t, i, n);
          }
        }
      }
      if (a & Xt.IncludeAnonymous || !o.type.isAnonymous || (o.index >= 0 ? e = o.index + t : e = t < 0 ? -1 : o._parent._tree.children.length, o = o._parent, !o))
        return null;
    }
  }
  get firstChild() {
    return this.nextChild(
      0,
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.nextChild(
      0,
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.nextChild(
      this._tree.children.length - 1,
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    let n;
    if (!(i & Xt.IgnoreOverlays) && (n = this._tree.prop(gt.mounted)) && n.overlay) {
      let a = e - this.from;
      for (let { from: o, to: s } of n.overlay)
        if ((t > 0 ? o <= a : o < a) && (t < 0 ? s >= a : s > a))
          return new ra(n.tree, n.overlay[0].from + this.from, -1, this);
    }
    return this.nextChild(0, 1, e, t, i);
  }
  nextSignificantParent() {
    let e = this;
    for (; e.type.isAnonymous && e._parent; )
      e = e._parent;
    return e;
  }
  get parent() {
    return this._parent ? this._parent.nextSignificantParent() : null;
  }
  get nextSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index + 1,
      1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  get prevSibling() {
    return this._parent && this.index >= 0 ? this._parent.nextChild(
      this.index - 1,
      -1,
      0,
      4
      /* Side.DontCare */
    ) : null;
  }
  cursor(e = 0) {
    return new ov(this, e);
  }
  get tree() {
    return this._tree;
  }
  toTree() {
    return this._tree;
  }
  resolve(e, t = 0) {
    return $f(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return $f(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return M6(this, e);
  }
  getChild(e, t = null, i = null) {
    let n = aS(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return aS(this, e, t, i);
  }
  /**
  @internal
  */
  toString() {
    return this._tree.toString();
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return oS(this, e);
  }
}
function aS(r, e, t, i) {
  let n = r.cursor(), a = [];
  if (!n.firstChild())
    return a;
  if (t != null) {
    for (; !n.type.is(t); )
      if (!n.nextSibling())
        return a;
  }
  for (; ; ) {
    if (i != null && n.type.is(i))
      return a;
    if (n.type.is(e) && a.push(n.node), !n.nextSibling())
      return i == null ? a : [];
  }
}
function oS(r, e, t = e.length - 1) {
  for (let i = r.parent; t >= 0; i = i.parent) {
    if (!i)
      return !1;
    if (!i.type.isAnonymous) {
      if (e[t] && e[t] != i.name)
        return !1;
      t--;
    }
  }
  return !0;
}
class B1e {
  constructor(e, t, i, n) {
    this.parent = e, this.buffer = t, this.index = i, this.start = n;
  }
}
class co {
  get name() {
    return this.type.name;
  }
  get from() {
    return this.context.start + this.context.buffer.buffer[this.index + 1];
  }
  get to() {
    return this.context.start + this.context.buffer.buffer[this.index + 2];
  }
  constructor(e, t, i) {
    this.context = e, this._parent = t, this.index = i, this.type = e.buffer.set.types[e.buffer.buffer[i]];
  }
  child(e, t, i) {
    let { buffer: n } = this.context, a = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.context.start, i);
    return a < 0 ? null : new co(this.context, this, a);
  }
  get firstChild() {
    return this.child(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  get lastChild() {
    return this.child(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  childAfter(e) {
    return this.child(
      1,
      e,
      2
      /* Side.After */
    );
  }
  childBefore(e) {
    return this.child(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  enter(e, t, i = 0) {
    if (i & Xt.ExcludeBuffers)
      return null;
    let { buffer: n } = this.context, a = n.findChild(this.index + 4, n.buffer[this.index + 3], t > 0 ? 1 : -1, e - this.context.start, t);
    return a < 0 ? null : new co(this.context, this, a);
  }
  get parent() {
    return this._parent || this.context.parent.nextSignificantParent();
  }
  externalSibling(e) {
    return this._parent ? null : this.context.parent.nextChild(
      this.context.index + e,
      e,
      0,
      4
      /* Side.DontCare */
    );
  }
  get nextSibling() {
    let { buffer: e } = this.context, t = e.buffer[this.index + 3];
    return t < (this._parent ? e.buffer[this._parent.index + 3] : e.buffer.length) ? new co(this.context, this._parent, t) : this.externalSibling(1);
  }
  get prevSibling() {
    let { buffer: e } = this.context, t = this._parent ? this._parent.index + 4 : 0;
    return this.index == t ? this.externalSibling(-1) : new co(this.context, this._parent, e.findChild(
      t,
      this.index,
      -1,
      0,
      4
      /* Side.DontCare */
    ));
  }
  cursor(e = 0) {
    return new ov(this, e);
  }
  get tree() {
    return null;
  }
  toTree() {
    let e = [], t = [], { buffer: i } = this.context, n = this.index + 4, a = i.buffer[this.index + 3];
    if (a > n) {
      let o = i.buffer[this.index + 1];
      e.push(i.slice(n, a, o)), t.push(0);
    }
    return new nr(this.type, e, t, this.to - this.from);
  }
  resolve(e, t = 0) {
    return $f(this, e, t, !1);
  }
  resolveInner(e, t = 0) {
    return $f(this, e, t, !0);
  }
  enterUnfinishedNodesBefore(e) {
    return M6(this, e);
  }
  /**
  @internal
  */
  toString() {
    return this.context.buffer.childString(this.index);
  }
  getChild(e, t = null, i = null) {
    let n = aS(this, e, t, i);
    return n.length ? n[0] : null;
  }
  getChildren(e, t = null, i = null) {
    return aS(this, e, t, i);
  }
  get node() {
    return this;
  }
  matchContext(e) {
    return oS(this, e);
  }
}
class ov {
  /**
  Shorthand for `.type.name`.
  */
  get name() {
    return this.type.name;
  }
  /**
  @internal
  */
  constructor(e, t = 0) {
    if (this.mode = t, this.buffer = null, this.stack = [], this.index = 0, this.bufferNode = null, e instanceof ra)
      this.yieldNode(e);
    else {
      this._tree = e.context.parent, this.buffer = e.context;
      for (let i = e._parent; i; i = i._parent)
        this.stack.unshift(i.index);
      this.bufferNode = e, this.yieldBuf(e.index);
    }
  }
  yieldNode(e) {
    return e ? (this._tree = e, this.type = e.type, this.from = e.from, this.to = e.to, !0) : !1;
  }
  yieldBuf(e, t) {
    this.index = e;
    let { start: i, buffer: n } = this.buffer;
    return this.type = t || n.set.types[n.buffer[e]], this.from = i + n.buffer[e + 1], this.to = i + n.buffer[e + 2], !0;
  }
  yield(e) {
    return e ? e instanceof ra ? (this.buffer = null, this.yieldNode(e)) : (this.buffer = e.context, this.yieldBuf(e.index, e.type)) : !1;
  }
  /**
  @internal
  */
  toString() {
    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();
  }
  /**
  @internal
  */
  enterChild(e, t, i) {
    if (!this.buffer)
      return this.yield(this._tree.nextChild(e < 0 ? this._tree._tree.children.length - 1 : 0, e, t, i, this.mode));
    let { buffer: n } = this.buffer, a = n.findChild(this.index + 4, n.buffer[this.index + 3], e, t - this.buffer.start, i);
    return a < 0 ? !1 : (this.stack.push(this.index), this.yieldBuf(a));
  }
  /**
  Move the cursor to this node's first child. When this returns
  false, the node has no child, and the cursor has not been moved.
  */
  firstChild() {
    return this.enterChild(
      1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to this node's last child.
  */
  lastChild() {
    return this.enterChild(
      -1,
      0,
      4
      /* Side.DontCare */
    );
  }
  /**
  Move the cursor to the first child that ends after `pos`.
  */
  childAfter(e) {
    return this.enterChild(
      1,
      e,
      2
      /* Side.After */
    );
  }
  /**
  Move to the last child that starts before `pos`.
  */
  childBefore(e) {
    return this.enterChild(
      -1,
      e,
      -2
      /* Side.Before */
    );
  }
  /**
  Move the cursor to the child around `pos`. If side is -1 the
  child may end at that position, when 1 it may start there. This
  will also enter [overlaid](#common.MountedTree.overlay)
  [mounted](#common.NodeProp^mounted) trees unless `overlays` is
  set to false.
  */
  enter(e, t, i = this.mode) {
    return this.buffer ? i & Xt.ExcludeBuffers ? !1 : this.enterChild(1, e, t) : this.yield(this._tree.enter(e, t, i));
  }
  /**
  Move to the node's parent node, if this isn't the top node.
  */
  parent() {
    if (!this.buffer)
      return this.yieldNode(this.mode & Xt.IncludeAnonymous ? this._tree._parent : this._tree.parent);
    if (this.stack.length)
      return this.yieldBuf(this.stack.pop());
    let e = this.mode & Xt.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();
    return this.buffer = null, this.yieldNode(e);
  }
  /**
  @internal
  */
  sibling(e) {
    if (!this.buffer)
      return this._tree._parent ? this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + e, e, 0, 4, this.mode)) : !1;
    let { buffer: t } = this.buffer, i = this.stack.length - 1;
    if (e < 0) {
      let n = i < 0 ? 0 : this.stack[i] + 4;
      if (this.index != n)
        return this.yieldBuf(t.findChild(
          n,
          this.index,
          -1,
          0,
          4
          /* Side.DontCare */
        ));
    } else {
      let n = t.buffer[this.index + 3];
      if (n < (i < 0 ? t.buffer.length : t.buffer[this.stack[i] + 3]))
        return this.yieldBuf(n);
    }
    return i < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + e, e, 0, 4, this.mode)) : !1;
  }
  /**
  Move to this node's next sibling, if any.
  */
  nextSibling() {
    return this.sibling(1);
  }
  /**
  Move to this node's previous sibling, if any.
  */
  prevSibling() {
    return this.sibling(-1);
  }
  atLastNode(e) {
    let t, i, { buffer: n } = this;
    if (n) {
      if (e > 0) {
        if (this.index < n.buffer.buffer.length)
          return !1;
      } else
        for (let a = 0; a < this.index; a++)
          if (n.buffer.buffer[a + 3] < this.index)
            return !1;
      ({ index: t, parent: i } = n);
    } else
      ({ index: t, _parent: i } = this._tree);
    for (; i; { index: t, _parent: i } = i)
      if (t > -1)
        for (let a = t + e, o = e < 0 ? -1 : i._tree.children.length; a != o; a += e) {
          let s = i._tree.children[a];
          if (this.mode & Xt.IncludeAnonymous || s instanceof rh || !s.type.isAnonymous || Yx(s))
            return !1;
        }
    return !0;
  }
  move(e, t) {
    if (t && this.enterChild(
      e,
      0,
      4
      /* Side.DontCare */
    ))
      return !0;
    for (; ; ) {
      if (this.sibling(e))
        return !0;
      if (this.atLastNode(e) || !this.parent())
        return !1;
    }
  }
  /**
  Move to the next node in a
  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)
  traversal, going from a node to its first child or, if the
  current node is empty or `enter` is false, its next sibling or
  the next sibling of the first parent node that has one.
  */
  next(e = !0) {
    return this.move(1, e);
  }
  /**
  Move to the next node in a last-to-first pre-order traveral. A
  node is followed by its last child or, if it has none, its
  previous sibling or the previous sibling of the first parent
  node that has one.
  */
  prev(e = !0) {
    return this.move(-1, e);
  }
  /**
  Move the cursor to the innermost node that covers `pos`. If
  `side` is -1, it will enter nodes that end at `pos`. If it is 1,
  it will enter nodes that start at `pos`.
  */
  moveTo(e, t = 0) {
    for (; (this.from == this.to || (t < 1 ? this.from >= e : this.from > e) || (t > -1 ? this.to <= e : this.to < e)) && this.parent(); )
      ;
    for (; this.enterChild(1, e, t); )
      ;
    return this;
  }
  /**
  Get a [syntax node](#common.SyntaxNode) at the cursor's current
  position.
  */
  get node() {
    if (!this.buffer)
      return this._tree;
    let e = this.bufferNode, t = null, i = 0;
    if (e && e.context == this.buffer)
      e:
        for (let n = this.index, a = this.stack.length; a >= 0; ) {
          for (let o = e; o; o = o._parent)
            if (o.index == n) {
              if (n == this.index)
                return o;
              t = o, i = a + 1;
              break e;
            }
          n = this.stack[--a];
        }
    for (let n = i; n < this.stack.length; n++)
      t = new co(this.buffer, t, this.stack[n]);
    return this.bufferNode = new co(this.buffer, t, this.index);
  }
  /**
  Get the [tree](#common.Tree) that represents the current node, if
  any. Will return null when the node is in a [tree
  buffer](#common.TreeBuffer).
  */
  get tree() {
    return this.buffer ? null : this._tree._tree;
  }
  /**
  Iterate over the current node and all its descendants, calling
  `enter` when entering a node and `leave`, if given, when leaving
  one. When `enter` returns `false`, any children of that node are
  skipped, and `leave` isn't called for it.
  */
  iterate(e, t) {
    for (let i = 0; ; ) {
      let n = !1;
      if (this.type.isAnonymous || e(this) !== !1) {
        if (this.firstChild()) {
          i++;
          continue;
        }
        this.type.isAnonymous || (n = !0);
      }
      for (; n && t && t(this), n = this.type.isAnonymous, !this.nextSibling(); ) {
        if (!i)
          return;
        this.parent(), i--, n = !0;
      }
    }
  }
  /**
  Test whether the current node matches a given contexta sequence
  of direct parent node names. Empty strings in the context array
  are treated as wildcards.
  */
  matchContext(e) {
    if (!this.buffer)
      return oS(this.node, e);
    let { buffer: t } = this.buffer, { types: i } = t.set;
    for (let n = e.length - 1, a = this.stack.length - 1; n >= 0; a--) {
      if (a < 0)
        return oS(this.node, e, n);
      let o = i[t.buffer[this.stack[a]]];
      if (!o.isAnonymous) {
        if (e[n] && e[n] != o.name)
          return !1;
        n--;
      }
    }
    return !0;
  }
}
function Yx(r) {
  return r.children.some((e) => e instanceof rh || !e.type.isAnonymous || Yx(e));
}
function F1e(r) {
  var e;
  let { buffer: t, nodeSet: i, maxBufferLength: n = P6, reused: a = [], minRepeatType: o = i.types.length } = r, s = Array.isArray(t) ? new Xx(t, t.length) : t, l = i.types, u = 0, c = 0;
  function h(b, S, T, y, R) {
    let { id: _, start: C, end: I, size: w } = s, x = c;
    for (; w < 0; )
      if (s.next(), w == -1) {
        let Q = a[_];
        T.push(Q), y.push(C - b);
        return;
      } else if (w == -3) {
        u = _;
        return;
      } else if (w == -4) {
        c = _;
        return;
      } else
        throw new RangeError(`Unrecognized record size: ${w}`);
    let P = l[_], L, D, U = C - b;
    if (I - C <= n && (D = g(s.pos - S, R))) {
      let Q = new Uint16Array(D.size - D.skip), V = s.pos - D.size, F = Q.length;
      for (; s.pos > V; )
        F = v(D.start, Q, F);
      L = new rh(Q, I - D.start, i), U = D.start - b;
    } else {
      let Q = s.pos - w;
      s.next();
      let V = [], F = [], j = _ >= o ? _ : -1, ae = 0, ce = I;
      for (; s.pos > Q; )
        j >= 0 && s.id == j && s.size >= 0 ? (s.end <= ce - n && (d(V, F, C, ae, s.end, ce, j, x), ae = V.length, ce = s.end), s.next()) : h(C, Q, V, F, j);
      if (j >= 0 && ae > 0 && ae < V.length && d(V, F, C, ae, C, ce, j, x), V.reverse(), F.reverse(), j > -1 && ae > 0) {
        let ge = f(P);
        L = Hx(P, V, F, 0, V.length, 0, I - C, ge, ge);
      } else
        L = p(P, V, F, I - C, x - I);
    }
    T.push(L), y.push(U);
  }
  function f(b) {
    return (S, T, y) => {
      let R = 0, _ = S.length - 1, C, I;
      if (_ >= 0 && (C = S[_]) instanceof nr) {
        if (!_ && C.type == b && C.length == y)
          return C;
        (I = C.prop(gt.lookAhead)) && (R = T[_] + C.length + I);
      }
      return p(b, S, T, y, R);
    };
  }
  function d(b, S, T, y, R, _, C, I) {
    let w = [], x = [];
    for (; b.length > y; )
      w.push(b.pop()), x.push(S.pop() + T - R);
    b.push(p(i.types[C], w, x, _ - R, I - _)), S.push(R - T);
  }
  function p(b, S, T, y, R = 0, _) {
    if (u) {
      let C = [gt.contextHash, u];
      _ = _ ? [C].concat(_) : [C];
    }
    if (R > 25) {
      let C = [gt.lookAhead, R];
      _ = _ ? [C].concat(_) : [C];
    }
    return new nr(b, S, T, y, _);
  }
  function g(b, S) {
    let T = s.fork(), y = 0, R = 0, _ = 0, C = T.end - n, I = { size: 0, start: 0, skip: 0 };
    e:
      for (let w = T.pos - b; T.pos > w; ) {
        let x = T.size;
        if (T.id == S && x >= 0) {
          I.size = y, I.start = R, I.skip = _, _ += 4, y += 4, T.next();
          continue;
        }
        let P = T.pos - x;
        if (x < 0 || P < w || T.start < C)
          break;
        let L = T.id >= o ? 4 : 0, D = T.start;
        for (T.next(); T.pos > P; ) {
          if (T.size < 0)
            if (T.size == -3)
              L += 4;
            else
              break e;
          else
            T.id >= o && (L += 4);
          T.next();
        }
        R = D, y += x, _ += L;
      }
    return (S < 0 || y == b) && (I.size = y, I.start = R, I.skip = _), I.size > 4 ? I : void 0;
  }
  function v(b, S, T) {
    let { id: y, start: R, end: _, size: C } = s;
    if (s.next(), C >= 0 && y < o) {
      let I = T;
      if (C > 4) {
        let w = s.pos - (C - 4);
        for (; s.pos > w; )
          T = v(b, S, T);
      }
      S[--T] = I, S[--T] = _ - b, S[--T] = R - b, S[--T] = y;
    } else
      C == -3 ? u = y : C == -4 && (c = y);
    return T;
  }
  let O = [], m = [];
  for (; s.pos > 0; )
    h(r.start || 0, r.bufferStart || 0, O, m, -1);
  let E = (e = r.length) !== null && e !== void 0 ? e : O.length ? m[0] + O[0].length : 0;
  return new nr(l[r.topID], O.reverse(), m.reverse(), E);
}
const SG = /* @__PURE__ */ new WeakMap();
function OE(r, e) {
  if (!r.isAnonymous || e instanceof rh || e.type != r)
    return 1;
  let t = SG.get(e);
  if (t == null) {
    t = 1;
    for (let i of e.children) {
      if (i.type != r || !(i instanceof nr)) {
        t = 1;
        break;
      }
      t += OE(r, i);
    }
    SG.set(e, t);
  }
  return t;
}
function Hx(r, e, t, i, n, a, o, s, l) {
  let u = 0;
  for (let p = i; p < n; p++)
    u += OE(r, e[p]);
  let c = Math.ceil(
    u * 1.5 / 8
    /* Balance.BranchFactor */
  ), h = [], f = [];
  function d(p, g, v, O, m) {
    for (let E = v; E < O; ) {
      let b = E, S = g[E], T = OE(r, p[E]);
      for (E++; E < O; E++) {
        let y = OE(r, p[E]);
        if (T + y >= c)
          break;
        T += y;
      }
      if (E == b + 1) {
        if (T > c) {
          let y = p[b];
          d(y.children, y.positions, 0, y.children.length, g[b] + m);
          continue;
        }
        h.push(p[b]);
      } else {
        let y = g[E - 1] + p[E - 1].length - S;
        h.push(Hx(r, p, g, b, E, S, y, null, l));
      }
      f.push(S + m - a);
    }
  }
  return d(e, t, i, n, 0), (s || l)(h, f, o);
}
class k6 {
  constructor() {
    this.map = /* @__PURE__ */ new WeakMap();
  }
  setBuffer(e, t, i) {
    let n = this.map.get(e);
    n || this.map.set(e, n = /* @__PURE__ */ new Map()), n.set(t, i);
  }
  getBuffer(e, t) {
    let i = this.map.get(e);
    return i && i.get(t);
  }
  /**
  Set the value for this syntax node.
  */
  set(e, t) {
    e instanceof co ? this.setBuffer(e.context.buffer, e.index, t) : e instanceof ra && this.map.set(e.tree, t);
  }
  /**
  Retrieve value for this syntax node, if it exists in the map.
  */
  get(e) {
    return e instanceof co ? this.getBuffer(e.context.buffer, e.index) : e instanceof ra ? this.map.get(e.tree) : void 0;
  }
  /**
  Set the value for the node that a cursor currently points to.
  */
  cursorSet(e, t) {
    e.buffer ? this.setBuffer(e.buffer.buffer, e.index, t) : this.map.set(e.tree, t);
  }
  /**
  Retrieve the value for the node that a cursor currently points
  to.
  */
  cursorGet(e) {
    return e.buffer ? this.getBuffer(e.buffer.buffer, e.index) : this.map.get(e.tree);
  }
}
class ts {
  /**
  Construct a tree fragment. You'll usually want to use
  [`addTree`](#common.TreeFragment^addTree) and
  [`applyChanges`](#common.TreeFragment^applyChanges) instead of
  calling this directly.
  */
  constructor(e, t, i, n, a = !1, o = !1) {
    this.from = e, this.to = t, this.tree = i, this.offset = n, this.open = (a ? 1 : 0) | (o ? 2 : 0);
  }
  /**
  Whether the start of the fragment represents the start of a
  parse, or the end of a change. (In the second case, it may not
  be safe to reuse some nodes at the start, depending on the
  parsing algorithm.)
  */
  get openStart() {
    return (this.open & 1) > 0;
  }
  /**
  Whether the end of the fragment represents the end of a
  full-document parse, or the start of a change.
  */
  get openEnd() {
    return (this.open & 2) > 0;
  }
  /**
  Create a set of fragments from a freshly parsed tree, or update
  an existing set of fragments by replacing the ones that overlap
  with a tree with content from the new tree. When `partial` is
  true, the parse is treated as incomplete, and the resulting
  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to
  true.
  */
  static addTree(e, t = [], i = !1) {
    let n = [new ts(0, e.length, e, 0, !1, i)];
    for (let a of t)
      a.to > e.length && n.push(a);
    return n;
  }
  /**
  Apply a set of edits to an array of fragments, removing or
  splitting fragments as necessary to remove edited ranges, and
  adjusting offsets for fragments that moved.
  */
  static applyChanges(e, t, i = 128) {
    if (!t.length)
      return e;
    let n = [], a = 1, o = e.length ? e[0] : null;
    for (let s = 0, l = 0, u = 0; ; s++) {
      let c = s < t.length ? t[s] : null, h = c ? c.fromA : 1e9;
      if (h - l >= i)
        for (; o && o.from < h; ) {
          let f = o;
          if (l >= f.from || h <= f.to || u) {
            let d = Math.max(f.from, l) - u, p = Math.min(f.to, h) - u;
            f = d >= p ? null : new ts(d, p, f.tree, f.offset + u, s > 0, !!c);
          }
          if (f && n.push(f), o.to > h)
            break;
          o = a < e.length ? e[a++] : null;
        }
      if (!c)
        break;
      l = c.toA, u = c.toA - c.toB;
    }
    return n;
  }
}
class Q6 {
  /**
  Start a parse, returning a [partial parse](#common.PartialParse)
  object. [`fragments`](#common.TreeFragment) can be passed in to
  make the parse incremental.
  
  By default, the entire input is parsed. You can pass `ranges`,
  which should be a sorted array of non-empty, non-overlapping
  ranges, to parse only those ranges. The tree returned in that
  case will start at `ranges[0].from`.
  */
  startParse(e, t, i) {
    return typeof e == "string" && (e = new X1e(e)), i = i ? i.length ? i.map((n) => new qn(n.from, n.to)) : [new qn(0, 0)] : [new qn(0, e.length)], this.createParse(e, t || [], i);
  }
  /**
  Run a full parse, returning the resulting tree.
  */
  parse(e, t, i) {
    let n = this.startParse(e, t, i);
    for (; ; ) {
      let a = n.advance();
      if (a)
        return a;
    }
  }
}
class X1e {
  constructor(e) {
    this.string = e;
  }
  get length() {
    return this.string.length;
  }
  chunk(e) {
    return this.string.slice(e);
  }
  get lineChunks() {
    return !1;
  }
  read(e, t) {
    return this.string.slice(e, t);
  }
}
function Y1e(r) {
  return (e, t, i, n) => new W1e(e, r, t, i, n);
}
class TG {
  constructor(e, t, i, n, a) {
    if (this.parser = e, this.parse = t, this.overlay = i, this.target = n, this.ranges = a, !a.length || a.some((o) => o.from >= o.to))
      throw new RangeError("Invalid inner parse ranges given: " + JSON.stringify(a));
  }
}
class H1e {
  constructor(e, t, i, n, a, o, s) {
    this.parser = e, this.predicate = t, this.mounts = i, this.index = n, this.start = a, this.target = o, this.prev = s, this.depth = 0, this.ranges = [];
  }
}
const zI = new gt({ perNode: !0 });
class W1e {
  constructor(e, t, i, n, a) {
    this.nest = t, this.input = i, this.fragments = n, this.ranges = a, this.inner = [], this.innerDone = 0, this.baseTree = null, this.stoppedAt = null, this.baseParse = e;
  }
  advance() {
    if (this.baseParse) {
      let i = this.baseParse.advance();
      if (!i)
        return null;
      if (this.baseParse = null, this.baseTree = i, this.startInner(), this.stoppedAt != null)
        for (let n of this.inner)
          n.parse.stopAt(this.stoppedAt);
    }
    if (this.innerDone == this.inner.length) {
      let i = this.baseTree;
      return this.stoppedAt != null && (i = new nr(i.type, i.children, i.positions, i.length, i.propValues.concat([[zI, this.stoppedAt]]))), i;
    }
    let e = this.inner[this.innerDone], t = e.parse.advance();
    if (t) {
      this.innerDone++;
      let i = Object.assign(/* @__PURE__ */ Object.create(null), e.target.props);
      i[gt.mounted.id] = new V1e(t, e.overlay, e.parser), e.target.props = i;
    }
    return null;
  }
  get parsedPos() {
    if (this.baseParse)
      return 0;
    let e = this.input.length;
    for (let t = this.innerDone; t < this.inner.length; t++)
      this.inner[t].ranges[0].from < e && (e = Math.min(e, this.inner[t].parse.parsedPos));
    return e;
  }
  stopAt(e) {
    if (this.stoppedAt = e, this.baseParse)
      this.baseParse.stopAt(e);
    else
      for (let t = this.innerDone; t < this.inner.length; t++)
        this.inner[t].parse.stopAt(e);
  }
  startInner() {
    let e = new q1e(this.fragments), t = null, i = null, n = new ov(new ra(this.baseTree, this.ranges[0].from, 0, null), Xt.IncludeAnonymous | Xt.IgnoreMounts);
    e:
      for (let a, o; this.stoppedAt == null || n.from < this.stoppedAt; ) {
        let s = !0, l;
        if (e.hasNode(n)) {
          if (t) {
            let u = t.mounts.find((c) => c.frag.from <= n.from && c.frag.to >= n.to && c.mount.overlay);
            if (u)
              for (let c of u.mount.overlay) {
                let h = c.from + u.pos, f = c.to + u.pos;
                h >= n.from && f <= n.to && !t.ranges.some((d) => d.from < f && d.to > h) && t.ranges.push({ from: h, to: f });
              }
          }
          s = !1;
        } else if (i && (o = z1e(i.ranges, n.from, n.to)))
          s = o != 2;
        else if (!n.type.isAnonymous && n.from < n.to && (a = this.nest(n, this.input))) {
          n.tree || Z1e(n);
          let u = e.findMounts(n.from, a.parser);
          if (typeof a.overlay == "function")
            t = new H1e(a.parser, a.overlay, u, this.inner.length, n.from, n.tree, t);
          else {
            let c = AG(this.ranges, a.overlay || [new qn(n.from, n.to)]);
            c.length && this.inner.push(new TG(a.parser, a.parser.startParse(this.input, _G(u, c), c), a.overlay ? a.overlay.map((h) => new qn(h.from - n.from, h.to - n.from)) : null, n.tree, c)), a.overlay ? c.length && (i = { ranges: c, depth: 0, prev: i }) : s = !1;
          }
        } else
          t && (l = t.predicate(n)) && (l === !0 && (l = new qn(n.from, n.to)), l.from < l.to && t.ranges.push(l));
        if (s && n.firstChild())
          t && t.depth++, i && i.depth++;
        else
          for (; !n.nextSibling(); ) {
            if (!n.parent())
              break e;
            if (t && !--t.depth) {
              let u = AG(this.ranges, t.ranges);
              u.length && this.inner.splice(t.index, 0, new TG(t.parser, t.parser.startParse(this.input, _G(t.mounts, u), u), t.ranges.map((c) => new qn(c.from - t.start, c.to - t.start)), t.target, u)), t = t.prev;
            }
            i && !--i.depth && (i = i.prev);
          }
      }
  }
}
function z1e(r, e, t) {
  for (let i of r) {
    if (i.from >= t)
      break;
    if (i.to > e)
      return i.from <= e && i.to >= t ? 2 : 1;
  }
  return 0;
}
function yG(r, e, t, i, n, a) {
  if (e < t) {
    let o = r.buffer[e + 1];
    i.push(r.slice(e, t, o)), n.push(o - a);
  }
}
function Z1e(r) {
  let { node: e } = r, t = 0;
  do
    r.parent(), t++;
  while (!r.tree);
  let i = 0, n = r.tree, a = 0;
  for (; a = n.positions[i] + r.from, !(a <= e.from && a + n.children[i].length >= e.to); i++)
    ;
  let o = n.children[i], s = o.buffer;
  function l(u, c, h, f, d) {
    let p = u;
    for (; s[p + 2] + a <= e.from; )
      p = s[p + 3];
    let g = [], v = [];
    yG(o, u, p, g, v, f);
    let O = s[p + 1], m = s[p + 2], E = O + a == e.from && m + a == e.to && s[p] == e.type.id;
    return g.push(E ? e.toTree() : l(p + 4, s[p + 3], o.set.types[s[p]], O, m - O)), v.push(O - f), yG(o, s[p + 3], c, g, v, f), new nr(h, g, v, d);
  }
  n.children[i] = l(0, s.length, Rn.none, 0, o.length);
  for (let u = 0; u <= t; u++)
    r.childAfter(e.from);
}
class RG {
  constructor(e, t) {
    this.offset = t, this.done = !1, this.cursor = e.cursor(Xt.IncludeAnonymous | Xt.IgnoreMounts);
  }
  // Move to the first node (in pre-order) that starts at or after `pos`.
  moveTo(e) {
    let { cursor: t } = this, i = e - this.offset;
    for (; !this.done && t.from < i; )
      t.to >= e && t.enter(i, 1, Xt.IgnoreOverlays | Xt.ExcludeBuffers) || t.next(!1) || (this.done = !0);
  }
  hasNode(e) {
    if (this.moveTo(e.from), !this.done && this.cursor.from + this.offset == e.from && this.cursor.tree)
      for (let t = this.cursor.tree; ; ) {
        if (t == e.tree)
          return !0;
        if (t.children.length && t.positions[0] == 0 && t.children[0] instanceof nr)
          t = t.children[0];
        else
          break;
      }
    return !1;
  }
}
let q1e = class {
  constructor(e) {
    var t;
    if (this.fragments = e, this.curTo = 0, this.fragI = 0, e.length) {
      let i = this.curFrag = e[0];
      this.curTo = (t = i.tree.prop(zI)) !== null && t !== void 0 ? t : i.to, this.inner = new RG(i.tree, -i.offset);
    } else
      this.curFrag = this.inner = null;
  }
  hasNode(e) {
    for (; this.curFrag && e.from >= this.curTo; )
      this.nextFrag();
    return this.curFrag && this.curFrag.from <= e.from && this.curTo >= e.to && this.inner.hasNode(e);
  }
  nextFrag() {
    var e;
    if (this.fragI++, this.fragI == this.fragments.length)
      this.curFrag = this.inner = null;
    else {
      let t = this.curFrag = this.fragments[this.fragI];
      this.curTo = (e = t.tree.prop(zI)) !== null && e !== void 0 ? e : t.to, this.inner = new RG(t.tree, -t.offset);
    }
  }
  findMounts(e, t) {
    var i;
    let n = [];
    if (this.inner) {
      this.inner.cursor.moveTo(e, 1);
      for (let a = this.inner.cursor.node; a; a = a.parent) {
        let o = (i = a.tree) === null || i === void 0 ? void 0 : i.prop(gt.mounted);
        if (o && o.parser == t)
          for (let s = this.fragI; s < this.fragments.length; s++) {
            let l = this.fragments[s];
            if (l.from >= a.to)
              break;
            l.tree == this.curFrag.tree && n.push({
              frag: l,
              pos: a.from - l.offset,
              mount: o
            });
          }
      }
    }
    return n;
  }
};
function AG(r, e) {
  let t = null, i = e;
  for (let n = 1, a = 0; n < r.length; n++) {
    let o = r[n - 1].to, s = r[n].from;
    for (; a < i.length; a++) {
      let l = i[a];
      if (l.from >= s)
        break;
      l.to <= o || (t || (i = t = e.slice()), l.from < o ? (t[a] = new qn(l.from, o), l.to > s && t.splice(a + 1, 0, new qn(s, l.to))) : l.to > s ? t[a--] = new qn(s, l.to) : t.splice(a--, 1));
    }
  }
  return i;
}
function j1e(r, e, t, i) {
  let n = 0, a = 0, o = !1, s = !1, l = -1e9, u = [];
  for (; ; ) {
    let c = n == r.length ? 1e9 : o ? r[n].to : r[n].from, h = a == e.length ? 1e9 : s ? e[a].to : e[a].from;
    if (o != s) {
      let f = Math.max(l, t), d = Math.min(c, h, i);
      f < d && u.push(new qn(f, d));
    }
    if (l = Math.min(c, h), l == 1e9)
      break;
    c == l && (o ? (o = !1, n++) : o = !0), h == l && (s ? (s = !1, a++) : s = !0);
  }
  return u;
}
function _G(r, e) {
  let t = [];
  for (let { pos: i, mount: n, frag: a } of r) {
    let o = i + (n.overlay ? n.overlay[0].from : 0), s = o + n.tree.length, l = Math.max(a.from, o), u = Math.min(a.to, s);
    if (n.overlay) {
      let c = n.overlay.map((f) => new qn(f.from + i, f.to + i)), h = j1e(e, c, l, u);
      for (let f = 0, d = l; ; f++) {
        let p = f == h.length, g = p ? u : h[f].from;
        if (g > d && t.push(new ts(d, g, n.tree, -o, a.from >= d || a.openStart, a.to <= g || a.openEnd)), p)
          break;
        d = h[f].to;
      }
    } else
      t.push(new ts(l, u, n.tree, -o, a.from >= o || a.openStart, a.to <= s || a.openEnd));
  }
  return t;
}
let K1e = 0;
class Ja {
  /**
  @internal
  */
  constructor(e, t, i) {
    this.set = e, this.base = t, this.modified = i, this.id = K1e++;
  }
  /**
  Define a new tag. If `parent` is given, the tag is treated as a
  sub-tag of that parent, and
  [highlighters](#highlight.tagHighlighter) that don't mention
  this tag will try to fall back to the parent tag (or grandparent
  tag, etc).
  */
  static define(e) {
    if (e != null && e.base)
      throw new Error("Can not derive from a modified tag");
    let t = new Ja([], null, []);
    if (t.set.push(t), e)
      for (let i of e.set)
        t.set.push(i);
    return t;
  }
  /**
  Define a tag _modifier_, which is a function that, given a tag,
  will return a tag that is a subtag of the original. Applying the
  same modifier to a twice tag will return the same value (`m1(t1)
  == m1(t1)`) and applying multiple modifiers will, regardless or
  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).
  
  When multiple modifiers are applied to a given base tag, each
  smaller set of modifiers is registered as a parent, so that for
  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,
  `m1(m3(t1)`, and so on.
  */
  static defineModifier() {
    let e = new sS();
    return (t) => t.modified.indexOf(e) > -1 ? t : sS.get(t.base || t, t.modified.concat(e).sort((i, n) => i.id - n.id));
  }
}
let J1e = 0;
class sS {
  constructor() {
    this.instances = [], this.id = J1e++;
  }
  static get(e, t) {
    if (!t.length)
      return e;
    let i = t[0].instances.find((s) => s.base == e && eNe(t, s.modified));
    if (i)
      return i;
    let n = [], a = new Ja(n, e, t);
    for (let s of t)
      s.instances.push(a);
    let o = tNe(t);
    for (let s of e.set)
      if (!s.modified.length)
        for (let l of o)
          n.push(sS.get(s, l));
    return a;
  }
}
function eNe(r, e) {
  return r.length == e.length && r.every((t, i) => t == e[i]);
}
function tNe(r) {
  let e = [[]];
  for (let t = 0; t < r.length; t++)
    for (let i = 0, n = e.length; i < n; i++)
      e.push(e[i].concat(r[t]));
  return e.sort((t, i) => i.length - t.length);
}
function ql(r) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in r) {
    let i = r[t];
    Array.isArray(i) || (i = [i]);
    for (let n of t.split(" "))
      if (n) {
        let a = [], o = 2, s = n;
        for (let h = 0; ; ) {
          if (s == "..." && h > 0 && h + 3 == n.length) {
            o = 1;
            break;
          }
          let f = /^"(?:[^"\\]|\\.)*?"|[^\/!]+/.exec(s);
          if (!f)
            throw new RangeError("Invalid path: " + n);
          if (a.push(f[0] == "*" ? "" : f[0][0] == '"' ? JSON.parse(f[0]) : f[0]), h += f[0].length, h == n.length)
            break;
          let d = n[h++];
          if (h == n.length && d == "!") {
            o = 0;
            break;
          }
          if (d != "/")
            throw new RangeError("Invalid path: " + n);
          s = n.slice(h);
        }
        let l = a.length - 1, u = a[l];
        if (!u)
          throw new RangeError("Invalid path: " + n);
        let c = new lS(i, o, l > 0 ? a.slice(0, l) : null);
        e[u] = c.sort(e[u]);
      }
  }
  return U6.add(e);
}
const U6 = new gt();
class lS {
  constructor(e, t, i, n) {
    this.tags = e, this.mode = t, this.context = i, this.next = n;
  }
  get opaque() {
    return this.mode == 0;
  }
  get inherit() {
    return this.mode == 1;
  }
  sort(e) {
    return !e || e.depth < this.depth ? (this.next = e, this) : (e.next = this.sort(e.next), e);
  }
  get depth() {
    return this.context ? this.context.length : 0;
  }
}
lS.empty = new lS([], 2, null);
function $6(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let a of r)
    if (!Array.isArray(a.tag))
      t[a.tag.id] = a.class;
    else
      for (let o of a.tag)
        t[o.id] = a.class;
  let { scope: i, all: n = null } = e || {};
  return {
    style: (a) => {
      let o = n;
      for (let s of a)
        for (let l of s.set) {
          let u = t[l.id];
          if (u) {
            o = o ? o + " " + u : u;
            break;
          }
        }
      return o;
    },
    scope: i
  };
}
function rNe(r, e) {
  let t = null;
  for (let i of r) {
    let n = i.style(e);
    n && (t = t ? t + " " + n : n);
  }
  return t;
}
function iNe(r, e, t, i = 0, n = r.length) {
  let a = new nNe(i, Array.isArray(e) ? e : [e], t);
  a.highlightRange(r.cursor(), i, n, "", a.highlighters), a.flush(n);
}
class nNe {
  constructor(e, t, i) {
    this.at = e, this.highlighters = t, this.span = i, this.class = "";
  }
  startSpan(e, t) {
    t != this.class && (this.flush(e), e > this.at && (this.at = e), this.class = t);
  }
  flush(e) {
    e > this.at && this.class && this.span(this.at, e, this.class);
  }
  highlightRange(e, t, i, n, a) {
    let { type: o, from: s, to: l } = e;
    if (s >= i || l <= t)
      return;
    o.isTop && (a = this.highlighters.filter((d) => !d.scope || d.scope(o)));
    let u = n, c = aNe(e) || lS.empty, h = rNe(a, c.tags);
    if (h && (u && (u += " "), u += h, c.mode == 1 && (n += (n ? " " : "") + h)), this.startSpan(Math.max(t, s), u), c.opaque)
      return;
    let f = e.tree && e.tree.prop(gt.mounted);
    if (f && f.overlay) {
      let d = e.node.enter(f.overlay[0].from + s, 1), p = this.highlighters.filter((v) => !v.scope || v.scope(f.tree.type)), g = e.firstChild();
      for (let v = 0, O = s; ; v++) {
        let m = v < f.overlay.length ? f.overlay[v] : null, E = m ? m.from + s : l, b = Math.max(t, O), S = Math.min(i, E);
        if (b < S && g)
          for (; e.from < S && (this.highlightRange(e, b, S, n, a), this.startSpan(Math.min(S, e.to), u), !(e.to >= E || !e.nextSibling())); )
            ;
        if (!m || E > i)
          break;
        O = m.to + s, O > t && (this.highlightRange(d.cursor(), Math.max(t, m.from + s), Math.min(i, O), "", p), this.startSpan(Math.min(i, O), u));
      }
      g && e.parent();
    } else if (e.firstChild()) {
      f && (n = "");
      do
        if (!(e.to <= t)) {
          if (e.from >= i)
            break;
          this.highlightRange(e, t, i, n, a), this.startSpan(Math.min(i, e.to), u);
        }
      while (e.nextSibling());
      e.parent();
    }
  }
}
function aNe(r) {
  let e = r.type.prop(U6);
  for (; e && e.context && !r.matchContext(e.context); )
    e = e.next;
  return e || null;
}
const fe = Ja.define, wm = fe(), Hs = fe(), CG = fe(Hs), IG = fe(Hs), Ws = fe(), Nm = fe(Ws), SA = fe(Ws), za = fe(), _u = fe(za), Fa = fe(), Xa = fe(), ZI = fe(), rp = fe(ZI), xm = fe(), A = {
  /**
  A comment.
  */
  comment: wm,
  /**
  A line [comment](#highlight.tags.comment).
  */
  lineComment: fe(wm),
  /**
  A block [comment](#highlight.tags.comment).
  */
  blockComment: fe(wm),
  /**
  A documentation [comment](#highlight.tags.comment).
  */
  docComment: fe(wm),
  /**
  Any kind of identifier.
  */
  name: Hs,
  /**
  The [name](#highlight.tags.name) of a variable.
  */
  variableName: fe(Hs),
  /**
  A type [name](#highlight.tags.name).
  */
  typeName: CG,
  /**
  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).
  */
  tagName: fe(CG),
  /**
  A property or field [name](#highlight.tags.name).
  */
  propertyName: IG,
  /**
  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).
  */
  attributeName: fe(IG),
  /**
  The [name](#highlight.tags.name) of a class.
  */
  className: fe(Hs),
  /**
  A label [name](#highlight.tags.name).
  */
  labelName: fe(Hs),
  /**
  A namespace [name](#highlight.tags.name).
  */
  namespace: fe(Hs),
  /**
  The [name](#highlight.tags.name) of a macro.
  */
  macroName: fe(Hs),
  /**
  A literal value.
  */
  literal: Ws,
  /**
  A string [literal](#highlight.tags.literal).
  */
  string: Nm,
  /**
  A documentation [string](#highlight.tags.string).
  */
  docString: fe(Nm),
  /**
  A character literal (subtag of [string](#highlight.tags.string)).
  */
  character: fe(Nm),
  /**
  An attribute value (subtag of [string](#highlight.tags.string)).
  */
  attributeValue: fe(Nm),
  /**
  A number [literal](#highlight.tags.literal).
  */
  number: SA,
  /**
  An integer [number](#highlight.tags.number) literal.
  */
  integer: fe(SA),
  /**
  A floating-point [number](#highlight.tags.number) literal.
  */
  float: fe(SA),
  /**
  A boolean [literal](#highlight.tags.literal).
  */
  bool: fe(Ws),
  /**
  Regular expression [literal](#highlight.tags.literal).
  */
  regexp: fe(Ws),
  /**
  An escape [literal](#highlight.tags.literal), for example a
  backslash escape in a string.
  */
  escape: fe(Ws),
  /**
  A color [literal](#highlight.tags.literal).
  */
  color: fe(Ws),
  /**
  A URL [literal](#highlight.tags.literal).
  */
  url: fe(Ws),
  /**
  A language keyword.
  */
  keyword: Fa,
  /**
  The [keyword](#highlight.tags.keyword) for the self or this
  object.
  */
  self: fe(Fa),
  /**
  The [keyword](#highlight.tags.keyword) for null.
  */
  null: fe(Fa),
  /**
  A [keyword](#highlight.tags.keyword) denoting some atomic value.
  */
  atom: fe(Fa),
  /**
  A [keyword](#highlight.tags.keyword) that represents a unit.
  */
  unit: fe(Fa),
  /**
  A modifier [keyword](#highlight.tags.keyword).
  */
  modifier: fe(Fa),
  /**
  A [keyword](#highlight.tags.keyword) that acts as an operator.
  */
  operatorKeyword: fe(Fa),
  /**
  A control-flow related [keyword](#highlight.tags.keyword).
  */
  controlKeyword: fe(Fa),
  /**
  A [keyword](#highlight.tags.keyword) that defines something.
  */
  definitionKeyword: fe(Fa),
  /**
  A [keyword](#highlight.tags.keyword) related to defining or
  interfacing with modules.
  */
  moduleKeyword: fe(Fa),
  /**
  An operator.
  */
  operator: Xa,
  /**
  An [operator](#highlight.tags.operator) that dereferences something.
  */
  derefOperator: fe(Xa),
  /**
  Arithmetic-related [operator](#highlight.tags.operator).
  */
  arithmeticOperator: fe(Xa),
  /**
  Logical [operator](#highlight.tags.operator).
  */
  logicOperator: fe(Xa),
  /**
  Bit [operator](#highlight.tags.operator).
  */
  bitwiseOperator: fe(Xa),
  /**
  Comparison [operator](#highlight.tags.operator).
  */
  compareOperator: fe(Xa),
  /**
  [Operator](#highlight.tags.operator) that updates its operand.
  */
  updateOperator: fe(Xa),
  /**
  [Operator](#highlight.tags.operator) that defines something.
  */
  definitionOperator: fe(Xa),
  /**
  Type-related [operator](#highlight.tags.operator).
  */
  typeOperator: fe(Xa),
  /**
  Control-flow [operator](#highlight.tags.operator).
  */
  controlOperator: fe(Xa),
  /**
  Program or markup punctuation.
  */
  punctuation: ZI,
  /**
  [Punctuation](#highlight.tags.punctuation) that separates
  things.
  */
  separator: fe(ZI),
  /**
  Bracket-style [punctuation](#highlight.tags.punctuation).
  */
  bracket: rp,
  /**
  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`
  tokens).
  */
  angleBracket: fe(rp),
  /**
  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`
  tokens).
  */
  squareBracket: fe(rp),
  /**
  Parentheses (usually `(` and `)` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  paren: fe(rp),
  /**
  Braces (usually `{` and `}` tokens). Subtag of
  [bracket](#highlight.tags.bracket).
  */
  brace: fe(rp),
  /**
  Content, for example plain text in XML or markup documents.
  */
  content: za,
  /**
  [Content](#highlight.tags.content) that represents a heading.
  */
  heading: _u,
  /**
  A level 1 [heading](#highlight.tags.heading).
  */
  heading1: fe(_u),
  /**
  A level 2 [heading](#highlight.tags.heading).
  */
  heading2: fe(_u),
  /**
  A level 3 [heading](#highlight.tags.heading).
  */
  heading3: fe(_u),
  /**
  A level 4 [heading](#highlight.tags.heading).
  */
  heading4: fe(_u),
  /**
  A level 5 [heading](#highlight.tags.heading).
  */
  heading5: fe(_u),
  /**
  A level 6 [heading](#highlight.tags.heading).
  */
  heading6: fe(_u),
  /**
  A prose separator (such as a horizontal rule).
  */
  contentSeparator: fe(za),
  /**
  [Content](#highlight.tags.content) that represents a list.
  */
  list: fe(za),
  /**
  [Content](#highlight.tags.content) that represents a quote.
  */
  quote: fe(za),
  /**
  [Content](#highlight.tags.content) that is emphasized.
  */
  emphasis: fe(za),
  /**
  [Content](#highlight.tags.content) that is styled strong.
  */
  strong: fe(za),
  /**
  [Content](#highlight.tags.content) that is part of a link.
  */
  link: fe(za),
  /**
  [Content](#highlight.tags.content) that is styled as code or
  monospace.
  */
  monospace: fe(za),
  /**
  [Content](#highlight.tags.content) that has a strike-through
  style.
  */
  strikethrough: fe(za),
  /**
  Inserted text in a change-tracking format.
  */
  inserted: fe(),
  /**
  Deleted text.
  */
  deleted: fe(),
  /**
  Changed text.
  */
  changed: fe(),
  /**
  An invalid or unsyntactic element.
  */
  invalid: fe(),
  /**
  Metadata or meta-instruction.
  */
  meta: xm,
  /**
  [Metadata](#highlight.tags.meta) that applies to the entire
  document.
  */
  documentMeta: fe(xm),
  /**
  [Metadata](#highlight.tags.meta) that annotates or adds
  attributes to a given syntactic element.
  */
  annotation: fe(xm),
  /**
  Processing instruction or preprocessor directive. Subtag of
  [meta](#highlight.tags.meta).
  */
  processingInstruction: fe(xm),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that a
  given element is being defined. Expected to be used with the
  various [name](#highlight.tags.name) tags.
  */
  definition: Ja.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates that
  something is constant. Mostly expected to be used with
  [variable names](#highlight.tags.variableName).
  */
  constant: Ja.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) used to indicate that
  a [variable](#highlight.tags.variableName) or [property
  name](#highlight.tags.propertyName) is being called or defined
  as a function.
  */
  function: Ja.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that can be applied to
  [names](#highlight.tags.name) to indicate that they belong to
  the language's standard environment.
  */
  standard: Ja.defineModifier(),
  /**
  [Modifier](#highlight.Tag^defineModifier) that indicates a given
  [names](#highlight.tags.name) is local to some scope.
  */
  local: Ja.defineModifier(),
  /**
  A generic variant [modifier](#highlight.Tag^defineModifier) that
  can be used to tag language-specific alternative variants of
  some common tag. It is recommended for themes to define special
  forms of at least the [string](#highlight.tags.string) and
  [variable name](#highlight.tags.variableName) tags, since those
  come up a lot.
  */
  special: Ja.defineModifier()
};
$6([
  { tag: A.link, class: "tok-link" },
  { tag: A.heading, class: "tok-heading" },
  { tag: A.emphasis, class: "tok-emphasis" },
  { tag: A.strong, class: "tok-strong" },
  { tag: A.keyword, class: "tok-keyword" },
  { tag: A.atom, class: "tok-atom" },
  { tag: A.bool, class: "tok-bool" },
  { tag: A.url, class: "tok-url" },
  { tag: A.labelName, class: "tok-labelName" },
  { tag: A.inserted, class: "tok-inserted" },
  { tag: A.deleted, class: "tok-deleted" },
  { tag: A.literal, class: "tok-literal" },
  { tag: A.string, class: "tok-string" },
  { tag: A.number, class: "tok-number" },
  { tag: [A.regexp, A.escape, A.special(A.string)], class: "tok-string2" },
  { tag: A.variableName, class: "tok-variableName" },
  { tag: A.local(A.variableName), class: "tok-variableName tok-local" },
  { tag: A.definition(A.variableName), class: "tok-variableName tok-definition" },
  { tag: A.special(A.variableName), class: "tok-variableName2" },
  { tag: A.definition(A.propertyName), class: "tok-propertyName tok-definition" },
  { tag: A.typeName, class: "tok-typeName" },
  { tag: A.namespace, class: "tok-namespace" },
  { tag: A.className, class: "tok-className" },
  { tag: A.macroName, class: "tok-macroName" },
  { tag: A.propertyName, class: "tok-propertyName" },
  { tag: A.operator, class: "tok-operator" },
  { tag: A.comment, class: "tok-comment" },
  { tag: A.meta, class: "tok-meta" },
  { tag: A.invalid, class: "tok-invalid" },
  { tag: A.punctuation, class: "tok-punctuation" }
]);
var TA;
const Kh = /* @__PURE__ */ new gt();
function oNe(r) {
  return Ce.define({
    combine: r ? (e) => e.concat(r) : void 0
  });
}
const sNe = /* @__PURE__ */ new gt();
class Ta {
  /**
  Construct a language object. If you need to invoke this
  directly, first define a data facet with
  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then
  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it
  to the language's outer syntax node.
  */
  constructor(e, t, i = [], n = "") {
    this.data = e, this.name = n, Rt.prototype.hasOwnProperty("tree") || Object.defineProperty(Rt.prototype, "tree", { get() {
      return Kt(this);
    } }), this.parser = t, this.extension = [
      Fl.of(this),
      Rt.languageData.of((a, o, s) => {
        let l = wG(a, o, s), u = l.type.prop(Kh);
        if (!u)
          return [];
        let c = a.facet(u), h = l.type.prop(sNe);
        if (h) {
          let f = l.resolve(o - l.from, s);
          for (let d of h)
            if (d.test(f, a)) {
              let p = a.facet(d.facet);
              return d.type == "replace" ? p : p.concat(c);
            }
        }
        return c;
      })
    ].concat(i);
  }
  /**
  Query whether this language is active at the given position.
  */
  isActiveAt(e, t, i = -1) {
    return wG(e, t, i).type.prop(Kh) == this.data;
  }
  /**
  Find the document regions that were parsed using this language.
  The returned regions will _include_ any nested languages rooted
  in this language, when those exist.
  */
  findRegions(e) {
    let t = e.facet(Fl);
    if ((t == null ? void 0 : t.data) == this.data)
      return [{ from: 0, to: e.doc.length }];
    if (!t || !t.allowsNesting)
      return [];
    let i = [], n = (a, o) => {
      if (a.prop(Kh) == this.data) {
        i.push({ from: o, to: o + a.length });
        return;
      }
      let s = a.prop(gt.mounted);
      if (s) {
        if (s.tree.prop(Kh) == this.data) {
          if (s.overlay)
            for (let l of s.overlay)
              i.push({ from: l.from + o, to: l.to + o });
          else
            i.push({ from: o, to: o + a.length });
          return;
        } else if (s.overlay) {
          let l = i.length;
          if (n(s.tree, s.overlay[0].from + o), i.length > l)
            return;
        }
      }
      for (let l = 0; l < a.children.length; l++) {
        let u = a.children[l];
        u instanceof nr && n(u, a.positions[l] + o);
      }
    };
    return n(Kt(e), 0), i;
  }
  /**
  Indicates whether this language allows nested languages. The
  default implementation returns true.
  */
  get allowsNesting() {
    return !0;
  }
}
Ta.setState = /* @__PURE__ */ lt.define();
function wG(r, e, t) {
  let i = r.facet(Fl), n = Kt(r).topNode;
  if (!i || i.allowsNesting)
    for (let a = n; a; a = a.enter(e, t, Xt.ExcludeBuffers))
      a.type.isTop && (n = a);
  return n;
}
class wo extends Ta {
  constructor(e, t, i) {
    super(e, t, [], i), this.parser = t;
  }
  /**
  Define a language from a parser.
  */
  static define(e) {
    let t = oNe(e.languageData);
    return new wo(t, e.parser.configure({
      props: [Kh.add((i) => i.isTop ? t : void 0)]
    }), e.name);
  }
  /**
  Create a new instance of this language with a reconfigured
  version of its parser and optionally a new name.
  */
  configure(e, t) {
    return new wo(this.data, this.parser.configure(e), t || this.name);
  }
  get allowsNesting() {
    return this.parser.hasWrappers();
  }
}
function Kt(r) {
  let e = r.field(Ta.state, !1);
  return e ? e.tree : nr.empty;
}
class lNe {
  /**
  Create an input object for the given document.
  */
  constructor(e) {
    this.doc = e, this.cursorPos = 0, this.string = "", this.cursor = e.iter();
  }
  get length() {
    return this.doc.length;
  }
  syncTo(e) {
    return this.string = this.cursor.next(e - this.cursorPos).value, this.cursorPos = e + this.string.length, this.cursorPos - this.string.length;
  }
  chunk(e) {
    return this.syncTo(e), this.string;
  }
  get lineChunks() {
    return !0;
  }
  read(e, t) {
    let i = this.cursorPos - this.string.length;
    return e < i || t >= this.cursorPos ? this.doc.sliceString(e, t) : this.string.slice(e - i, t - i);
  }
}
let ip = null;
class uS {
  constructor(e, t, i = [], n, a, o, s, l) {
    this.parser = e, this.state = t, this.fragments = i, this.tree = n, this.treeLen = a, this.viewport = o, this.skipped = s, this.scheduleOn = l, this.parse = null, this.tempSkipped = [];
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new uS(e, t, [], nr.empty, 0, i, [], null);
  }
  startParse() {
    return this.parser.startParse(new lNe(this.state.doc), this.fragments);
  }
  /**
  @internal
  */
  work(e, t) {
    return t != null && t >= this.state.doc.length && (t = void 0), this.tree != nr.empty && this.isDone(t ?? this.state.doc.length) ? (this.takeTree(), !0) : this.withContext(() => {
      var i;
      if (typeof e == "number") {
        let n = Date.now() + e;
        e = () => Date.now() > n;
      }
      for (this.parse || (this.parse = this.startParse()), t != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > t) && t < this.state.doc.length && this.parse.stopAt(t); ; ) {
        let n = this.parse.advance();
        if (n)
          if (this.fragments = this.withoutTempSkipped(ts.addTree(n, this.fragments, this.parse.stoppedAt != null)), this.treeLen = (i = this.parse.stoppedAt) !== null && i !== void 0 ? i : this.state.doc.length, this.tree = n, this.parse = null, this.treeLen < (t ?? this.state.doc.length))
            this.parse = this.startParse();
          else
            return !0;
        if (e())
          return !1;
      }
    });
  }
  /**
  @internal
  */
  takeTree() {
    let e, t;
    this.parse && (e = this.parse.parsedPos) >= this.treeLen && ((this.parse.stoppedAt == null || this.parse.stoppedAt > e) && this.parse.stopAt(e), this.withContext(() => {
      for (; !(t = this.parse.advance()); )
        ;
    }), this.treeLen = e, this.tree = t, this.fragments = this.withoutTempSkipped(ts.addTree(this.tree, this.fragments, !0)), this.parse = null);
  }
  withContext(e) {
    let t = ip;
    ip = this;
    try {
      return e();
    } finally {
      ip = t;
    }
  }
  withoutTempSkipped(e) {
    for (let t; t = this.tempSkipped.pop(); )
      e = NG(e, t.from, t.to);
    return e;
  }
  /**
  @internal
  */
  changes(e, t) {
    let { fragments: i, tree: n, treeLen: a, viewport: o, skipped: s } = this;
    if (this.takeTree(), !e.empty) {
      let l = [];
      if (e.iterChangedRanges((u, c, h, f) => l.push({ fromA: u, toA: c, fromB: h, toB: f })), i = ts.applyChanges(i, l), n = nr.empty, a = 0, o = { from: e.mapPos(o.from, -1), to: e.mapPos(o.to, 1) }, this.skipped.length) {
        s = [];
        for (let u of this.skipped) {
          let c = e.mapPos(u.from, 1), h = e.mapPos(u.to, -1);
          c < h && s.push({ from: c, to: h });
        }
      }
    }
    return new uS(this.parser, t, i, n, a, o, s, this.scheduleOn);
  }
  /**
  @internal
  */
  updateViewport(e) {
    if (this.viewport.from == e.from && this.viewport.to == e.to)
      return !1;
    this.viewport = e;
    let t = this.skipped.length;
    for (let i = 0; i < this.skipped.length; i++) {
      let { from: n, to: a } = this.skipped[i];
      n < e.to && a > e.from && (this.fragments = NG(this.fragments, n, a), this.skipped.splice(i--, 1));
    }
    return this.skipped.length >= t ? !1 : (this.reset(), !0);
  }
  /**
  @internal
  */
  reset() {
    this.parse && (this.takeTree(), this.parse = null);
  }
  /**
  Notify the parse scheduler that the given region was skipped
  because it wasn't in view, and the parse should be restarted
  when it comes into view.
  */
  skipUntilInView(e, t) {
    this.skipped.push({ from: e, to: t });
  }
  /**
  Returns a parser intended to be used as placeholder when
  asynchronously loading a nested parser. It'll skip its input and
  mark it as not-really-parsed, so that the next update will parse
  it again.
  
  When `until` is given, a reparse will be scheduled when that
  promise resolves.
  */
  static getSkippingParser(e) {
    return new class extends Q6 {
      createParse(t, i, n) {
        let a = n[0].from, o = n[n.length - 1].to;
        return {
          parsedPos: a,
          advance() {
            let l = ip;
            if (l) {
              for (let u of n)
                l.tempSkipped.push(u);
              e && (l.scheduleOn = l.scheduleOn ? Promise.all([l.scheduleOn, e]) : e);
            }
            return this.parsedPos = o, new nr(Rn.none, [], [], o - a);
          },
          stoppedAt: null,
          stopAt() {
          }
        };
      }
    }();
  }
  /**
  @internal
  */
  isDone(e) {
    e = Math.min(e, this.state.doc.length);
    let t = this.fragments;
    return this.treeLen >= e && t.length && t[0].from == 0 && t[0].to >= e;
  }
  /**
  Get the context for the current parse, or `null` if no editor
  parse is in progress.
  */
  static get() {
    return ip;
  }
}
function NG(r, e, t) {
  return ts.applyChanges(r, [{ fromA: e, toA: t, fromB: e, toB: t }]);
}
class Vf {
  constructor(e) {
    this.context = e, this.tree = e.tree;
  }
  apply(e) {
    if (!e.docChanged && this.tree == this.context.tree)
      return this;
    let t = this.context.changes(e.changes, e.state), i = this.context.treeLen == e.startState.doc.length ? void 0 : Math.max(e.changes.mapPos(this.context.treeLen), t.viewport.to);
    return t.work(20, i) || t.takeTree(), new Vf(t);
  }
  static init(e) {
    let t = Math.min(3e3, e.doc.length), i = uS.create(e.facet(Fl).parser, e, { from: 0, to: t });
    return i.work(20, t) || i.takeTree(), new Vf(i);
  }
}
Ta.state = /* @__PURE__ */ Br.define({
  create: Vf.init,
  update(r, e) {
    for (let t of e.effects)
      if (t.is(Ta.setState))
        return t.value;
    return e.startState.facet(Fl) != e.state.facet(Fl) ? Vf.init(e.state) : r.apply(e);
  }
});
let V6 = (r) => {
  let e = setTimeout(
    () => r(),
    500
    /* MaxPause */
  );
  return () => clearTimeout(e);
};
typeof requestIdleCallback < "u" && (V6 = (r) => {
  let e = -1, t = setTimeout(
    () => {
      e = requestIdleCallback(r, {
        timeout: 500 - 100
        /* MinPause */
      });
    },
    100
    /* MinPause */
  );
  return () => e < 0 ? clearTimeout(t) : cancelIdleCallback(e);
});
const yA = typeof navigator < "u" && (!((TA = navigator.scheduling) === null || TA === void 0) && TA.isInputPending) ? () => navigator.scheduling.isInputPending() : null, uNe = /* @__PURE__ */ Ur.fromClass(class {
  constructor(e) {
    this.view = e, this.working = null, this.workScheduled = 0, this.chunkEnd = -1, this.chunkBudget = -1, this.work = this.work.bind(this), this.scheduleWork();
  }
  update(e) {
    let t = this.view.state.field(Ta.state).context;
    (t.updateViewport(e.view.viewport) || this.view.viewport.to > t.treeLen) && this.scheduleWork(), e.docChanged && (this.view.hasFocus && (this.chunkBudget += 50), this.scheduleWork()), this.checkAsyncSchedule(t);
  }
  scheduleWork() {
    if (this.working)
      return;
    let { state: e } = this.view, t = e.field(Ta.state);
    (t.tree != t.context.tree || !t.context.isDone(e.doc.length)) && (this.working = V6(this.work));
  }
  work(e) {
    this.working = null;
    let t = Date.now();
    if (this.chunkEnd < t && (this.chunkEnd < 0 || this.view.hasFocus) && (this.chunkEnd = t + 3e4, this.chunkBudget = 3e3), this.chunkBudget <= 0)
      return;
    let { state: i, viewport: { to: n } } = this.view, a = i.field(Ta.state);
    if (a.tree == a.context.tree && a.context.isDone(
      n + 1e5
      /* MaxParseAhead */
    ))
      return;
    let o = Date.now() + Math.min(this.chunkBudget, 100, e && !yA ? Math.max(25, e.timeRemaining() - 5) : 1e9), s = a.context.treeLen < n && i.doc.length > n + 1e3, l = a.context.work(() => yA && yA() || Date.now() > o, n + (s ? 0 : 1e5));
    this.chunkBudget -= Date.now() - t, (l || this.chunkBudget <= 0) && (a.context.takeTree(), this.view.dispatch({ effects: Ta.setState.of(new Vf(a.context)) })), this.chunkBudget > 0 && !(l && !s) && this.scheduleWork(), this.checkAsyncSchedule(a.context);
  }
  checkAsyncSchedule(e) {
    e.scheduleOn && (this.workScheduled++, e.scheduleOn.then(() => this.scheduleWork()).catch((t) => ea(this.view.state, t)).then(() => this.workScheduled--), e.scheduleOn = null);
  }
  destroy() {
    this.working && this.working();
  }
  isWorking() {
    return !!(this.working || this.workScheduled > 0);
  }
}, {
  eventHandlers: { focus() {
    this.scheduleWork();
  } }
}), Fl = /* @__PURE__ */ Ce.define({
  combine(r) {
    return r.length ? r[0] : null;
  },
  enables: (r) => [
    Ta.state,
    uNe,
    me.contentAttributes.compute([r], (e) => {
      let t = e.facet(r);
      return t && t.name ? { "data-language": t.name } : {};
    })
  ]
});
class ih {
  /**
  Create a language support object.
  */
  constructor(e, t = []) {
    this.language = e, this.support = t, this.extension = [e, t];
  }
}
const cNe = /* @__PURE__ */ Ce.define(), ZT = /* @__PURE__ */ Ce.define({
  combine: (r) => {
    if (!r.length)
      return "  ";
    let e = r[0];
    if (!e || /\S/.test(e) || Array.from(e).some((t) => t != e[0]))
      throw new Error("Invalid indent unit: " + JSON.stringify(r[0]));
    return e;
  }
});
function cS(r) {
  let e = r.facet(ZT);
  return e.charCodeAt(0) == 9 ? r.tabSize * e.length : e.length;
}
function sv(r, e) {
  let t = "", i = r.tabSize, n = r.facet(ZT)[0];
  if (n == "	") {
    for (; e >= i; )
      t += "	", e -= i;
    n = " ";
  }
  for (let a = 0; a < e; a++)
    t += n;
  return t;
}
function Wx(r, e) {
  r instanceof Rt && (r = new qT(r));
  for (let i of r.state.facet(cNe)) {
    let n = i(r, e);
    if (n !== void 0)
      return n;
  }
  let t = Kt(r.state);
  return t.length >= e ? hNe(r, t, e) : null;
}
class qT {
  /**
  Create an indent context.
  */
  constructor(e, t = {}) {
    this.state = e, this.options = t, this.unit = cS(e);
  }
  /**
  Get a description of the line at the given position, taking
  [simulated line
  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  into account. If there is such a break at `pos`, the `bias`
  argument determines whether the part of the line line before or
  after the break is used.
  */
  lineAt(e, t = 1) {
    let i = this.state.doc.lineAt(e), { simulateBreak: n, simulateDoubleBreak: a } = this.options;
    return n != null && n >= i.from && n <= i.to ? a && n == e ? { text: "", from: e } : (t < 0 ? n < e : n <= e) ? { text: i.text.slice(n - i.from), from: n } : { text: i.text.slice(0, n - i.from), from: i.from } : i;
  }
  /**
  Get the text directly after `pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  textAfterPos(e, t = 1) {
    if (this.options.simulateDoubleBreak && e == this.options.simulateBreak)
      return "";
    let { text: i, from: n } = this.lineAt(e, t);
    return i.slice(e - n, Math.min(i.length, e + 100 - n));
  }
  /**
  Find the column for the given position.
  */
  column(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), a = this.countColumn(i, e - n), o = this.options.overrideIndentation ? this.options.overrideIndentation(n) : -1;
    return o > -1 && (a += o - this.countColumn(i, i.search(/\S|$/))), a;
  }
  /**
  Find the column position (taking tabs into account) of the given
  position in the given string.
  */
  countColumn(e, t = e.length) {
    return Bv(e, this.state.tabSize, t);
  }
  /**
  Find the indentation column of the line at the given point.
  */
  lineIndent(e, t = 1) {
    let { text: i, from: n } = this.lineAt(e, t), a = this.options.overrideIndentation;
    if (a) {
      let o = a(n);
      if (o > -1)
        return o;
    }
    return this.countColumn(i, i.search(/\S|$/));
  }
  /**
  Returns the [simulated line
  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)
  for this context, if any.
  */
  get simulatedBreak() {
    return this.options.simulateBreak || null;
  }
}
const jl = /* @__PURE__ */ new gt();
function hNe(r, e, t) {
  return G6(e.resolveInner(t).enterUnfinishedNodesBefore(t), t, r);
}
function fNe(r) {
  return r.pos == r.options.simulateBreak && r.options.simulateDoubleBreak;
}
function dNe(r) {
  let e = r.type.prop(jl);
  if (e)
    return e;
  let t = r.firstChild, i;
  if (t && (i = t.type.prop(gt.closedBy))) {
    let n = r.lastChild, a = n && i.indexOf(n.name) > -1;
    return (o) => B6(o, !0, 1, void 0, a && !fNe(o) ? n.from : void 0);
  }
  return r.parent == null ? pNe : null;
}
function G6(r, e, t) {
  for (; r; r = r.parent) {
    let i = dNe(r);
    if (i)
      return i(zx.create(t, e, r));
  }
  return null;
}
function pNe() {
  return 0;
}
class zx extends qT {
  constructor(e, t, i) {
    super(e.state, e.options), this.base = e, this.pos = t, this.node = i;
  }
  /**
  @internal
  */
  static create(e, t, i) {
    return new zx(e, t, i);
  }
  /**
  Get the text directly after `this.pos`, either the entire line
  or the next 100 characters, whichever is shorter.
  */
  get textAfter() {
    return this.textAfterPos(this.pos);
  }
  /**
  Get the indentation at the reference line for `this.node`, which
  is the line on which it starts, unless there is a node that is
  _not_ a parent of this node covering the start of that line. If
  so, the line at the start of that node is tried, again skipping
  on if it is covered by another such node.
  */
  get baseIndent() {
    return this.baseIndentFor(this.node);
  }
  /**
  Get the indentation for the reference line of the given node
  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).
  */
  baseIndentFor(e) {
    let t = this.state.doc.lineAt(e.from);
    for (; ; ) {
      let i = e.resolve(t.from);
      for (; i.parent && i.parent.from == i.from; )
        i = i.parent;
      if (gNe(i, e))
        break;
      t = this.state.doc.lineAt(i.from);
    }
    return this.lineIndent(t.from);
  }
  /**
  Continue looking for indentations in the node's parent nodes,
  and return the result of that.
  */
  continue() {
    let e = this.node.parent;
    return e ? G6(e, this.pos, this.base) : 0;
  }
}
function gNe(r, e) {
  for (let t = e; t; t = t.parent)
    if (r == t)
      return !0;
  return !1;
}
function vNe(r) {
  let e = r.node, t = e.childAfter(e.from), i = e.lastChild;
  if (!t)
    return null;
  let n = r.options.simulateBreak, a = r.state.doc.lineAt(t.from), o = n == null || n <= a.from ? a.to : Math.min(a.to, n);
  for (let s = t.to; ; ) {
    let l = e.childAfter(s);
    if (!l || l == i)
      return null;
    if (!l.type.isSkipped)
      return l.from < o ? t : null;
    s = l.to;
  }
}
function sg({ closing: r, align: e = !0, units: t = 1 }) {
  return (i) => B6(i, e, t, r);
}
function B6(r, e, t, i, n) {
  let a = r.textAfter, o = a.match(/^\s*/)[0].length, s = i && a.slice(o, o + i.length) == i || n == r.pos + o, l = e ? vNe(r) : null;
  return l ? s ? r.column(l.from) : r.column(l.to) : r.baseIndent + (s ? 0 : r.unit * t);
}
const F6 = (r) => r.baseIndent;
function mo({ except: r, units: e = 1 } = {}) {
  return (t) => {
    let i = r && r.test(t.textAfter);
    return t.baseIndent + (i ? 0 : e * t.unit);
  };
}
const ONe = 200;
function mNe() {
  return Rt.transactionFilter.of((r) => {
    if (!r.docChanged || !r.isUserEvent("input.type") && !r.isUserEvent("input.complete"))
      return r;
    let e = r.startState.languageDataAt("indentOnInput", r.startState.selection.main.head);
    if (!e.length)
      return r;
    let t = r.newDoc, { head: i } = r.newSelection.main, n = t.lineAt(i);
    if (i > n.from + ONe)
      return r;
    let a = t.sliceString(n.from, i);
    if (!e.some((u) => u.test(a)))
      return r;
    let { state: o } = r, s = -1, l = [];
    for (let { head: u } of o.selection.ranges) {
      let c = o.doc.lineAt(u);
      if (c.from == s)
        continue;
      s = c.from;
      let h = Wx(o, c.from);
      if (h == null)
        continue;
      let f = /^\s*/.exec(c.text)[0], d = sv(o, h);
      f != d && l.push({ from: c.from, to: c.from + f.length, insert: d });
    }
    return l.length ? [r, { changes: l, sequential: !0 }] : r;
  });
}
const ENe = /* @__PURE__ */ Ce.define(), Kl = /* @__PURE__ */ new gt();
function Wv(r) {
  let e = r.firstChild, t = r.lastChild;
  return e && e.to < t.from ? { from: e.to, to: t.type.isError ? r.to : t.from } : null;
}
function bNe(r, e, t) {
  let i = Kt(r);
  if (i.length < t)
    return null;
  let n = i.resolveInner(t, 1), a = null;
  for (let o = n; o; o = o.parent) {
    if (o.to <= t || o.from > t)
      continue;
    if (a && o.from < e)
      break;
    let s = o.type.prop(Kl);
    if (s && (o.to < i.length - 50 || i.length == r.doc.length || !SNe(o))) {
      let l = s(o, r);
      l && l.from <= t && l.from >= e && l.to > t && (a = l);
    }
  }
  return a;
}
function SNe(r) {
  let e = r.lastChild;
  return e && e.to == r.to && e.type.isError;
}
function hS(r, e, t) {
  for (let i of r.facet(ENe)) {
    let n = i(r, e, t);
    if (n)
      return n;
  }
  return bNe(r, e, t);
}
function X6(r, e) {
  let t = e.mapPos(r.from, 1), i = e.mapPos(r.to, -1);
  return t >= i ? void 0 : { from: t, to: i };
}
const jT = /* @__PURE__ */ lt.define({ map: X6 }), zv = /* @__PURE__ */ lt.define({ map: X6 });
function Y6(r) {
  let e = [];
  for (let { head: t } of r.state.selection.ranges)
    e.some((i) => i.from <= t && i.to >= t) || e.push(r.lineBlockAt(t));
  return e;
}
const Qc = /* @__PURE__ */ Br.define({
  create() {
    return Xe.none;
  },
  update(r, e) {
    r = r.map(e.changes);
    for (let t of e.effects)
      if (t.is(jT) && !TNe(r, t.value.from, t.value.to)) {
        let { preparePlaceholder: i } = e.state.facet(Zx), n = i ? Xe.replace({ widget: new wNe(i(e.state, t.value)) }) : xG;
        r = r.update({ add: [n.range(t.value.from, t.value.to)] });
      } else
        t.is(zv) && (r = r.update({
          filter: (i, n) => t.value.from != i || t.value.to != n,
          filterFrom: t.value.from,
          filterTo: t.value.to
        }));
    if (e.selection) {
      let t = !1, { head: i } = e.selection.main;
      r.between(i, i, (n, a) => {
        n < i && a > i && (t = !0);
      }), t && (r = r.update({
        filterFrom: i,
        filterTo: i,
        filter: (n, a) => a <= i || n >= i
      }));
    }
    return r;
  },
  provide: (r) => me.decorations.from(r),
  toJSON(r, e) {
    let t = [];
    return r.between(0, e.doc.length, (i, n) => {
      t.push(i, n);
    }), t;
  },
  fromJSON(r) {
    if (!Array.isArray(r) || r.length % 2)
      throw new RangeError("Invalid JSON for fold state");
    let e = [];
    for (let t = 0; t < r.length; ) {
      let i = r[t++], n = r[t++];
      if (typeof i != "number" || typeof n != "number")
        throw new RangeError("Invalid JSON for fold state");
      e.push(xG.range(i, n));
    }
    return Xe.set(e, !0);
  }
});
function fS(r, e, t) {
  var i;
  let n = null;
  return (i = r.field(Qc, !1)) === null || i === void 0 || i.between(e, t, (a, o) => {
    (!n || n.from > a) && (n = { from: a, to: o });
  }), n;
}
function TNe(r, e, t) {
  let i = !1;
  return r.between(e, e, (n, a) => {
    n == e && a == t && (i = !0);
  }), i;
}
function H6(r, e) {
  return r.field(Qc, !1) ? e : e.concat(lt.appendConfig.of(z6()));
}
const yNe = (r) => {
  for (let e of Y6(r)) {
    let t = hS(r.state, e.from, e.to);
    if (t)
      return r.dispatch({ effects: H6(r.state, [jT.of(t), W6(r, t)]) }), !0;
  }
  return !1;
}, RNe = (r) => {
  if (!r.state.field(Qc, !1))
    return !1;
  let e = [];
  for (let t of Y6(r)) {
    let i = fS(r.state, t.from, t.to);
    i && e.push(zv.of(i), W6(r, i, !1));
  }
  return e.length && r.dispatch({ effects: e }), e.length > 0;
};
function W6(r, e, t = !0) {
  let i = r.state.doc.lineAt(e.from).number, n = r.state.doc.lineAt(e.to).number;
  return me.announce.of(`${r.state.phrase(t ? "Folded lines" : "Unfolded lines")} ${i} ${r.state.phrase("to")} ${n}.`);
}
const ANe = (r) => {
  let { state: e } = r, t = [];
  for (let i = 0; i < e.doc.length; ) {
    let n = r.lineBlockAt(i), a = hS(e, n.from, n.to);
    a && t.push(jT.of(a)), i = (a ? r.lineBlockAt(a.to) : n).to + 1;
  }
  return t.length && r.dispatch({ effects: H6(r.state, t) }), !!t.length;
}, _Ne = (r) => {
  let e = r.state.field(Qc, !1);
  if (!e || !e.size)
    return !1;
  let t = [];
  return e.between(0, r.state.doc.length, (i, n) => {
    t.push(zv.of({ from: i, to: n }));
  }), r.dispatch({ effects: t }), !0;
}, CNe = [
  { key: "Ctrl-Shift-[", mac: "Cmd-Alt-[", run: yNe },
  { key: "Ctrl-Shift-]", mac: "Cmd-Alt-]", run: RNe },
  { key: "Ctrl-Alt-[", run: ANe },
  { key: "Ctrl-Alt-]", run: _Ne }
], INe = {
  placeholderDOM: null,
  preparePlaceholder: null,
  placeholderText: ""
}, Zx = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, INe);
  }
});
function z6(r) {
  let e = [Qc, PNe];
  return r && e.push(Zx.of(r)), e;
}
function Z6(r, e) {
  let { state: t } = r, i = t.facet(Zx), n = (o) => {
    let s = r.lineBlockAt(r.posAtDOM(o.target)), l = fS(r.state, s.from, s.to);
    l && r.dispatch({ effects: zv.of(l) }), o.preventDefault();
  };
  if (i.placeholderDOM)
    return i.placeholderDOM(r, n, e);
  let a = document.createElement("span");
  return a.textContent = i.placeholderText, a.setAttribute("aria-label", t.phrase("folded code")), a.title = t.phrase("unfold"), a.className = "cm-foldPlaceholder", a.onclick = n, a;
}
const xG = /* @__PURE__ */ Xe.replace({ widget: /* @__PURE__ */ new class extends Rs {
  toDOM(r) {
    return Z6(r, null);
  }
}() });
class wNe extends Rs {
  constructor(e) {
    super(), this.value = e;
  }
  eq(e) {
    return this.value == e.value;
  }
  toDOM(e) {
    return Z6(e, this.value);
  }
}
const NNe = {
  openText: "",
  closedText: "",
  markerDOM: null,
  domEventHandlers: {},
  foldingChanged: () => !1
};
class RA extends ps {
  constructor(e, t) {
    super(), this.config = e, this.open = t;
  }
  eq(e) {
    return this.config == e.config && this.open == e.open;
  }
  toDOM(e) {
    if (this.config.markerDOM)
      return this.config.markerDOM(this.open);
    let t = document.createElement("span");
    return t.textContent = this.open ? this.config.openText : this.config.closedText, t.title = e.state.phrase(this.open ? "Fold line" : "Unfold line"), t;
  }
}
function xNe(r = {}) {
  let e = Object.assign(Object.assign({}, NNe), r), t = new RA(e, !0), i = new RA(e, !1), n = Ur.fromClass(class {
    constructor(o) {
      this.from = o.viewport.from, this.markers = this.buildMarkers(o);
    }
    update(o) {
      (o.docChanged || o.viewportChanged || o.startState.facet(Fl) != o.state.facet(Fl) || o.startState.field(Qc, !1) != o.state.field(Qc, !1) || Kt(o.startState) != Kt(o.state) || e.foldingChanged(o)) && (this.markers = this.buildMarkers(o.view));
    }
    buildMarkers(o) {
      let s = new Ul();
      for (let l of o.viewportLineBlocks) {
        let u = fS(o.state, l.from, l.to) ? i : hS(o.state, l.from, l.to) ? t : null;
        u && s.add(l.from, l.from, u);
      }
      return s.finish();
    }
  }), { domEventHandlers: a } = e;
  return [
    n,
    w1e({
      class: "cm-foldGutter",
      markers(o) {
        var s;
        return ((s = o.plugin(n)) === null || s === void 0 ? void 0 : s.markers) || kt.empty;
      },
      initialSpacer() {
        return new RA(e, !1);
      },
      domEventHandlers: Object.assign(Object.assign({}, a), { click: (o, s, l) => {
        if (a.click && a.click(o, s, l))
          return !0;
        let u = fS(o.state, s.from, s.to);
        if (u)
          return o.dispatch({ effects: zv.of(u) }), !0;
        let c = hS(o.state, s.from, s.to);
        return c ? (o.dispatch({ effects: jT.of(c) }), !0) : !1;
      } })
    }),
    z6()
  ];
}
const PNe = /* @__PURE__ */ me.baseTheme({
  ".cm-foldPlaceholder": {
    backgroundColor: "#eee",
    border: "1px solid #ddd",
    color: "#888",
    borderRadius: ".2em",
    margin: "0 1px",
    padding: "0 1px",
    cursor: "pointer"
  },
  ".cm-foldGutter span": {
    padding: "0 1px",
    cursor: "pointer"
  }
});
class Cn {
  constructor(e, t) {
    this.specs = e;
    let i;
    function n(s) {
      let l = $l.newName();
      return (i || (i = /* @__PURE__ */ Object.create(null)))["." + l] = s, l;
    }
    const a = typeof t.all == "string" ? t.all : t.all ? n(t.all) : void 0, o = t.scope;
    this.scope = o instanceof Ta ? (s) => s.prop(Kh) == o.data : o ? (s) => s == o : void 0, this.style = $6(e.map((s) => ({
      tag: s.tag,
      class: s.class || n(Object.assign({}, s, { tag: null }))
    })), {
      all: a
    }).style, this.module = i ? new $l(i) : null, this.themeType = t.themeType;
  }
  /**
  Create a highlighter style that associates the given styles to
  the given tags. The specs must be objects that hold a style tag
  or array of tags in their `tag` property, and either a single
  `class` property providing a static CSS class (for highlighter
  that rely on external styling), or a
  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style
  set of CSS properties (which define the styling for those tags).
  
  The CSS rules created for a highlighter will be emitted in the
  order of the spec's properties. That means that for elements that
  have multiple tags associated with them, styles defined further
  down in the list will have a higher CSS precedence than styles
  defined earlier.
  */
  static define(e, t) {
    return new Cn(e, t || {});
  }
}
const qI = /* @__PURE__ */ Ce.define(), q6 = /* @__PURE__ */ Ce.define({
  combine(r) {
    return r.length ? [r[0]] : null;
  }
});
function AA(r) {
  let e = r.facet(qI);
  return e.length ? e : r.facet(q6);
}
function Do(r, e) {
  let t = [DNe], i;
  return r instanceof Cn && (r.module && t.push(me.styleModule.of(r.module)), i = r.themeType), e != null && e.fallback ? t.push(q6.of(r)) : i ? t.push(qI.computeN([me.darkTheme], (n) => n.facet(me.darkTheme) == (i == "dark") ? [r] : [])) : t.push(qI.of(r)), t;
}
class LNe {
  constructor(e) {
    this.markCache = /* @__PURE__ */ Object.create(null), this.tree = Kt(e.state), this.decorations = this.buildDeco(e, AA(e.state));
  }
  update(e) {
    let t = Kt(e.state), i = AA(e.state), n = i != AA(e.startState);
    t.length < e.view.viewport.to && !n && t.type == this.tree.type ? this.decorations = this.decorations.map(e.changes) : (t != this.tree || e.viewportChanged || n) && (this.tree = t, this.decorations = this.buildDeco(e.view, i));
  }
  buildDeco(e, t) {
    if (!t || !this.tree.length)
      return Xe.none;
    let i = new Ul();
    for (let { from: n, to: a } of e.visibleRanges)
      iNe(this.tree, t, (o, s, l) => {
        i.add(o, s, this.markCache[l] || (this.markCache[l] = Xe.mark({ class: l })));
      }, n, a);
    return i.finish();
  }
}
const DNe = /* @__PURE__ */ th.high(/* @__PURE__ */ Ur.fromClass(LNe, {
  decorations: (r) => r.decorations
})), MNe = /* @__PURE__ */ Cn.define([
  {
    tag: A.meta,
    color: "#404740"
  },
  {
    tag: A.link,
    textDecoration: "underline"
  },
  {
    tag: A.heading,
    textDecoration: "underline",
    fontWeight: "bold"
  },
  {
    tag: A.emphasis,
    fontStyle: "italic"
  },
  {
    tag: A.strong,
    fontWeight: "bold"
  },
  {
    tag: A.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: A.keyword,
    color: "#708"
  },
  {
    tag: [A.atom, A.bool, A.url, A.contentSeparator, A.labelName],
    color: "#219"
  },
  {
    tag: [A.literal, A.inserted],
    color: "#164"
  },
  {
    tag: [A.string, A.deleted],
    color: "#a11"
  },
  {
    tag: [A.regexp, A.escape, /* @__PURE__ */ A.special(A.string)],
    color: "#e40"
  },
  {
    tag: /* @__PURE__ */ A.definition(A.variableName),
    color: "#00f"
  },
  {
    tag: /* @__PURE__ */ A.local(A.variableName),
    color: "#30a"
  },
  {
    tag: [A.typeName, A.namespace],
    color: "#085"
  },
  {
    tag: A.className,
    color: "#167"
  },
  {
    tag: [/* @__PURE__ */ A.special(A.variableName), A.macroName],
    color: "#256"
  },
  {
    tag: /* @__PURE__ */ A.definition(A.propertyName),
    color: "#00c"
  },
  {
    tag: A.comment,
    color: "#940"
  },
  {
    tag: A.invalid,
    color: "#f00"
  }
]), kNe = /* @__PURE__ */ me.baseTheme({
  "&.cm-focused .cm-matchingBracket": { backgroundColor: "#328c8252" },
  "&.cm-focused .cm-nonmatchingBracket": { backgroundColor: "#bb555544" }
}), j6 = 1e4, K6 = "()[]{}", J6 = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, {
      afterCursor: !0,
      brackets: K6,
      maxScanDistance: j6,
      renderMatch: $Ne
    });
  }
}), QNe = /* @__PURE__ */ Xe.mark({ class: "cm-matchingBracket" }), UNe = /* @__PURE__ */ Xe.mark({ class: "cm-nonmatchingBracket" });
function $Ne(r) {
  let e = [], t = r.matched ? QNe : UNe;
  return e.push(t.range(r.start.from, r.start.to)), r.end && e.push(t.range(r.end.from, r.end.to)), e;
}
const VNe = /* @__PURE__ */ Br.define({
  create() {
    return Xe.none;
  },
  update(r, e) {
    if (!e.docChanged && !e.selection)
      return r;
    let t = [], i = e.state.facet(J6);
    for (let n of e.state.selection.ranges) {
      if (!n.empty)
        continue;
      let a = ho(e.state, n.head, -1, i) || n.head > 0 && ho(e.state, n.head - 1, 1, i) || i.afterCursor && (ho(e.state, n.head, 1, i) || n.head < e.state.doc.length && ho(e.state, n.head + 1, -1, i));
      a && (t = t.concat(i.renderMatch(a, e.state)));
    }
    return Xe.set(t, !0);
  },
  provide: (r) => me.decorations.from(r)
}), GNe = [
  VNe,
  kNe
];
function BNe(r = {}) {
  return [J6.of(r), GNe];
}
const FNe = /* @__PURE__ */ new gt();
function jI(r, e, t) {
  let i = r.prop(e < 0 ? gt.openedBy : gt.closedBy);
  if (i)
    return i;
  if (r.name.length == 1) {
    let n = t.indexOf(r.name);
    if (n > -1 && n % 2 == (e < 0 ? 1 : 0))
      return [t[n + e]];
  }
  return null;
}
function KI(r) {
  let e = r.type.prop(FNe);
  return e ? e(r.node) : r;
}
function ho(r, e, t, i = {}) {
  let n = i.maxScanDistance || j6, a = i.brackets || K6, o = Kt(r), s = o.resolveInner(e, t);
  for (let l = s; l; l = l.parent) {
    let u = jI(l.type, t, a);
    if (u && l.from < l.to) {
      let c = KI(l);
      if (c && (t > 0 ? e >= c.from && e < c.to : e > c.from && e <= c.to))
        return XNe(r, e, t, l, c, u, a);
    }
  }
  return YNe(r, e, t, o, s.type, n, a);
}
function XNe(r, e, t, i, n, a, o) {
  let s = i.parent, l = { from: n.from, to: n.to }, u = 0, c = s == null ? void 0 : s.cursor();
  if (c && (t < 0 ? c.childBefore(i.from) : c.childAfter(i.to)))
    do
      if (t < 0 ? c.to <= i.from : c.from >= i.to) {
        if (u == 0 && a.indexOf(c.type.name) > -1 && c.from < c.to) {
          let h = KI(c);
          return { start: l, end: h ? { from: h.from, to: h.to } : void 0, matched: !0 };
        } else if (jI(c.type, t, o))
          u++;
        else if (jI(c.type, -t, o)) {
          if (u == 0) {
            let h = KI(c);
            return {
              start: l,
              end: h && h.from < h.to ? { from: h.from, to: h.to } : void 0,
              matched: !1
            };
          }
          u--;
        }
      }
    while (t < 0 ? c.prevSibling() : c.nextSibling());
  return { start: l, matched: !1 };
}
function YNe(r, e, t, i, n, a, o) {
  let s = t < 0 ? r.sliceDoc(e - 1, e) : r.sliceDoc(e, e + 1), l = o.indexOf(s);
  if (l < 0 || l % 2 == 0 != t > 0)
    return null;
  let u = { from: t < 0 ? e - 1 : e, to: t > 0 ? e + 1 : e }, c = r.doc.iterRange(e, t > 0 ? r.doc.length : 0), h = 0;
  for (let f = 0; !c.next().done && f <= a; ) {
    let d = c.value;
    t < 0 && (f += d.length);
    let p = e + f * t;
    for (let g = t > 0 ? 0 : d.length - 1, v = t > 0 ? d.length : -1; g != v; g += t) {
      let O = o.indexOf(d[g]);
      if (!(O < 0 || i.resolveInner(p + g, 1).type != n))
        if (O % 2 == 0 == t > 0)
          h++;
        else {
          if (h == 1)
            return { start: u, end: { from: p + g, to: p + g + 1 }, matched: O >> 1 == l >> 1 };
          h--;
        }
    }
    t > 0 && (f += d.length);
  }
  return c.done ? { start: u, matched: !1 } : null;
}
const HNe = /* @__PURE__ */ Object.create(null), PG = [Rn.none], LG = [], WNe = /* @__PURE__ */ Object.create(null);
for (let [r, e] of [
  ["variable", "variableName"],
  ["variable-2", "variableName.special"],
  ["string-2", "string.special"],
  ["def", "variableName.definition"],
  ["tag", "tagName"],
  ["attribute", "attributeName"],
  ["type", "typeName"],
  ["builtin", "variableName.standard"],
  ["qualifier", "modifier"],
  ["error", "invalid"],
  ["header", "heading"],
  ["property", "propertyName"]
])
  WNe[r] = /* @__PURE__ */ zNe(HNe, e);
function _A(r, e) {
  LG.indexOf(r) > -1 || (LG.push(r), console.warn(e));
}
function zNe(r, e) {
  let t = null;
  for (let a of e.split(".")) {
    let o = r[a] || A[a];
    o ? typeof o == "function" ? t ? t = o(t) : _A(a, `Modifier ${a} used at start of tag`) : t ? _A(a, `Tag ${a} used as modifier`) : t = o : _A(a, `Unknown highlighting tag ${a}`);
  }
  if (!t)
    return 0;
  let i = e.replace(/ /g, "_"), n = Rn.define({
    id: PG.length,
    name: i,
    props: [ql({ [i]: t })]
  });
  return PG.push(n), n.id;
}
const e9 = (r) => {
  let { state: e } = r, t = e.doc.lineAt(e.selection.main.from), i = qx(r.state, t.from);
  return i.line ? t9(r) : i.block ? i9(r) : !1;
};
function nh(r, e) {
  return ({ state: t, dispatch: i }) => {
    if (t.readOnly)
      return !1;
    let n = r(e, t);
    return n ? (i(t.update(n)), !0) : !1;
  };
}
const t9 = /* @__PURE__ */ nh(
  jx,
  0
  /* CommentOption.Toggle */
), ZNe = /* @__PURE__ */ nh(
  jx,
  1
  /* CommentOption.Comment */
), qNe = /* @__PURE__ */ nh(
  jx,
  2
  /* CommentOption.Uncomment */
), r9 = /* @__PURE__ */ nh(
  KT,
  0
  /* CommentOption.Toggle */
), jNe = /* @__PURE__ */ nh(
  KT,
  1
  /* CommentOption.Comment */
), KNe = /* @__PURE__ */ nh(
  KT,
  2
  /* CommentOption.Uncomment */
), i9 = /* @__PURE__ */ nh(
  (r, e) => KT(r, e, exe(e)),
  0
  /* CommentOption.Toggle */
);
function qx(r, e) {
  let t = r.languageDataAt("commentTokens", e);
  return t.length ? t[0] : {};
}
const np = 50;
function JNe(r, { open: e, close: t }, i, n) {
  let a = r.sliceDoc(i - np, i), o = r.sliceDoc(n, n + np), s = /\s*$/.exec(a)[0].length, l = /^\s*/.exec(o)[0].length, u = a.length - s;
  if (a.slice(u - e.length, u) == e && o.slice(l, l + t.length) == t)
    return {
      open: { pos: i - s, margin: s && 1 },
      close: { pos: n + l, margin: l && 1 }
    };
  let c, h;
  n - i <= 2 * np ? c = h = r.sliceDoc(i, n) : (c = r.sliceDoc(i, i + np), h = r.sliceDoc(n - np, n));
  let f = /^\s*/.exec(c)[0].length, d = /\s*$/.exec(h)[0].length, p = h.length - d - t.length;
  return c.slice(f, f + e.length) == e && h.slice(p, p + t.length) == t ? {
    open: {
      pos: i + f + e.length,
      margin: /\s/.test(c.charAt(f + e.length)) ? 1 : 0
    },
    close: {
      pos: n - d - t.length,
      margin: /\s/.test(h.charAt(p - 1)) ? 1 : 0
    }
  } : null;
}
function exe(r) {
  let e = [];
  for (let t of r.selection.ranges) {
    let i = r.doc.lineAt(t.from), n = t.to <= i.to ? i : r.doc.lineAt(t.to), a = e.length - 1;
    a >= 0 && e[a].to > i.from ? e[a].to = n.to : e.push({ from: i.from + /^\s*/.exec(i.text)[0].length, to: n.to });
  }
  return e;
}
function KT(r, e, t = e.selection.ranges) {
  let i = t.map((a) => qx(e, a.from).block);
  if (!i.every((a) => a))
    return null;
  let n = t.map((a, o) => JNe(e, i[o], a.from, a.to));
  if (r != 2 && !n.every((a) => a))
    return { changes: e.changes(t.map((a, o) => n[o] ? [] : [{ from: a.from, insert: i[o].open + " " }, { from: a.to, insert: " " + i[o].close }])) };
  if (r != 1 && n.some((a) => a)) {
    let a = [];
    for (let o = 0, s; o < n.length; o++)
      if (s = n[o]) {
        let l = i[o], { open: u, close: c } = s;
        a.push({ from: u.pos - l.open.length, to: u.pos + u.margin }, { from: c.pos - c.margin, to: c.pos + l.close.length });
      }
    return { changes: a };
  }
  return null;
}
function jx(r, e, t = e.selection.ranges) {
  let i = [], n = -1;
  for (let { from: a, to: o } of t) {
    let s = i.length, l = 1e9, u = qx(e, a).line;
    if (u) {
      for (let c = a; c <= o; ) {
        let h = e.doc.lineAt(c);
        if (h.from > n && (a == o || o > h.from)) {
          n = h.from;
          let f = /^\s*/.exec(h.text)[0].length, d = f == h.length, p = h.text.slice(f, f + u.length) == u ? f : -1;
          f < h.text.length && f < l && (l = f), i.push({ line: h, comment: p, token: u, indent: f, empty: d, single: !1 });
        }
        c = h.to + 1;
      }
      if (l < 1e9)
        for (let c = s; c < i.length; c++)
          i[c].indent < i[c].line.text.length && (i[c].indent = l);
      i.length == s + 1 && (i[s].single = !0);
    }
  }
  if (r != 2 && i.some((a) => a.comment < 0 && (!a.empty || a.single))) {
    let a = [];
    for (let { line: s, token: l, indent: u, empty: c, single: h } of i)
      (h || !c) && a.push({ from: s.from + u, insert: l + " " });
    let o = e.changes(a);
    return { changes: o, selection: e.selection.map(o, 1) };
  } else if (r != 1 && i.some((a) => a.comment >= 0)) {
    let a = [];
    for (let { line: o, comment: s, token: l } of i)
      if (s >= 0) {
        let u = o.from + s, c = u + l.length;
        o.text[c - o.from] == " " && c++, a.push({ from: u, to: c });
      }
    return { changes: a };
  }
  return null;
}
const JI = /* @__PURE__ */ ys.define(), n9 = /* @__PURE__ */ ys.define(), a9 = /* @__PURE__ */ Ce.define(), o9 = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, {
      minDepth: 100,
      newGroupDelay: 500,
      joinToEvent: (e, t) => t
    }, {
      minDepth: Math.max,
      newGroupDelay: Math.min,
      joinToEvent: (e, t) => (i, n) => e(i, n) || t(i, n)
    });
  }
});
function txe(r) {
  let e = 0;
  return r.iterChangedRanges((t, i) => e = i), e;
}
const JT = /* @__PURE__ */ Br.define({
  create() {
    return fo.empty;
  },
  update(r, e) {
    let t = e.state.facet(o9), i = e.annotation(JI);
    if (i) {
      let l = e.docChanged ? Z.single(txe(e.changes)) : void 0, u = Ki.fromTransaction(e, l), c = i.side, h = c == 0 ? r.undone : r.done;
      return u ? h = pS(h, h.length, t.minDepth, u) : h = f9(h, e.startState.selection), new fo(c == 0 ? i.rest : h, c == 0 ? h : i.rest);
    }
    let n = e.annotation(n9);
    if ((n == "full" || n == "before") && (r = r.isolate()), e.annotation(Dr.addToHistory) === !1)
      return e.changes.empty ? r : r.addMapping(e.changes.desc);
    let a = Ki.fromTransaction(e), o = e.annotation(Dr.time), s = e.annotation(Dr.userEvent);
    return a ? r = r.addChanges(a, o, s, t, e) : e.selection && (r = r.addSelection(e.startState.selection, o, s, t.newGroupDelay)), (n == "full" || n == "after") && (r = r.isolate()), r;
  },
  toJSON(r) {
    return { done: r.done.map((e) => e.toJSON()), undone: r.undone.map((e) => e.toJSON()) };
  },
  fromJSON(r) {
    return new fo(r.done.map(Ki.fromJSON), r.undone.map(Ki.fromJSON));
  }
});
function s9(r = {}) {
  return [
    JT,
    o9.of(r),
    me.domEventHandlers({
      beforeinput(e, t) {
        let i = e.inputType == "historyUndo" ? Kx : e.inputType == "historyRedo" ? dS : null;
        return i ? (e.preventDefault(), i(t)) : !1;
      }
    })
  ];
}
const rxe = JT;
function ey(r, e) {
  return function({ state: t, dispatch: i }) {
    if (!e && t.readOnly)
      return !1;
    let n = t.field(JT, !1);
    if (!n)
      return !1;
    let a = n.pop(r, t, e);
    return a ? (i(a), !0) : !1;
  };
}
const Kx = /* @__PURE__ */ ey(0, !1), dS = /* @__PURE__ */ ey(1, !1), l9 = /* @__PURE__ */ ey(0, !0), u9 = /* @__PURE__ */ ey(1, !0);
function c9(r) {
  return function(e) {
    let t = e.field(JT, !1);
    if (!t)
      return 0;
    let i = r == 0 ? t.done : t.undone;
    return i.length - (i.length && !i[0].changes ? 1 : 0);
  };
}
const ixe = /* @__PURE__ */ c9(
  0
  /* BranchName.Done */
), nxe = /* @__PURE__ */ c9(
  1
  /* BranchName.Undone */
);
class Ki {
  constructor(e, t, i, n, a) {
    this.changes = e, this.effects = t, this.mapped = i, this.startSelection = n, this.selectionsAfter = a;
  }
  setSelAfter(e) {
    return new Ki(this.changes, this.effects, this.mapped, this.startSelection, e);
  }
  toJSON() {
    var e, t, i;
    return {
      changes: (e = this.changes) === null || e === void 0 ? void 0 : e.toJSON(),
      mapped: (t = this.mapped) === null || t === void 0 ? void 0 : t.toJSON(),
      startSelection: (i = this.startSelection) === null || i === void 0 ? void 0 : i.toJSON(),
      selectionsAfter: this.selectionsAfter.map((n) => n.toJSON())
    };
  }
  static fromJSON(e) {
    return new Ki(e.changes && Nr.fromJSON(e.changes), [], e.mapped && Oo.fromJSON(e.mapped), e.startSelection && Z.fromJSON(e.startSelection), e.selectionsAfter.map(Z.fromJSON));
  }
  // This does not check `addToHistory` and such, it assumes the
  // transaction needs to be converted to an item. Returns null when
  // there are no changes or effects in the transaction.
  static fromTransaction(e, t) {
    let i = jn;
    for (let n of e.startState.facet(a9)) {
      let a = n(e);
      a.length && (i = i.concat(a));
    }
    return !i.length && e.changes.empty ? null : new Ki(e.changes.invert(e.startState.doc), i, void 0, t || e.startState.selection, jn);
  }
  static selection(e) {
    return new Ki(void 0, jn, void 0, void 0, e);
  }
}
function pS(r, e, t, i) {
  let n = e + 1 > t + 20 ? e - t - 1 : 0, a = r.slice(n, e);
  return a.push(i), a;
}
function axe(r, e) {
  let t = [], i = !1;
  return r.iterChangedRanges((n, a) => t.push(n, a)), e.iterChangedRanges((n, a, o, s) => {
    for (let l = 0; l < t.length; ) {
      let u = t[l++], c = t[l++];
      s >= u && o <= c && (i = !0);
    }
  }), i;
}
function oxe(r, e) {
  return r.ranges.length == e.ranges.length && r.ranges.filter((t, i) => t.empty != e.ranges[i].empty).length === 0;
}
function h9(r, e) {
  return r.length ? e.length ? r.concat(e) : r : e;
}
const jn = [], sxe = 200;
function f9(r, e) {
  if (r.length) {
    let t = r[r.length - 1], i = t.selectionsAfter.slice(Math.max(0, t.selectionsAfter.length - sxe));
    return i.length && i[i.length - 1].eq(e) ? r : (i.push(e), pS(r, r.length - 1, 1e9, t.setSelAfter(i)));
  } else
    return [Ki.selection([e])];
}
function lxe(r) {
  let e = r[r.length - 1], t = r.slice();
  return t[r.length - 1] = e.setSelAfter(e.selectionsAfter.slice(0, e.selectionsAfter.length - 1)), t;
}
function CA(r, e) {
  if (!r.length)
    return r;
  let t = r.length, i = jn;
  for (; t; ) {
    let n = uxe(r[t - 1], e, i);
    if (n.changes && !n.changes.empty || n.effects.length) {
      let a = r.slice(0, t);
      return a[t - 1] = n, a;
    } else
      e = n.mapped, t--, i = n.selectionsAfter;
  }
  return i.length ? [Ki.selection(i)] : jn;
}
function uxe(r, e, t) {
  let i = h9(r.selectionsAfter.length ? r.selectionsAfter.map((s) => s.map(e)) : jn, t);
  if (!r.changes)
    return Ki.selection(i);
  let n = r.changes.map(e), a = e.mapDesc(r.changes, !0), o = r.mapped ? r.mapped.composeDesc(a) : a;
  return new Ki(n, lt.mapEffects(r.effects, e), o, r.startSelection.map(a), i);
}
const cxe = /^(input\.type|delete)($|\.)/;
class fo {
  constructor(e, t, i = 0, n = void 0) {
    this.done = e, this.undone = t, this.prevTime = i, this.prevUserEvent = n;
  }
  isolate() {
    return this.prevTime ? new fo(this.done, this.undone) : this;
  }
  addChanges(e, t, i, n, a) {
    let o = this.done, s = o[o.length - 1];
    return s && s.changes && !s.changes.empty && e.changes && (!i || cxe.test(i)) && (!s.selectionsAfter.length && t - this.prevTime < n.newGroupDelay && n.joinToEvent(a, axe(s.changes, e.changes)) || // For compose (but not compose.start) events, always join with previous event
    i == "input.type.compose") ? o = pS(o, o.length - 1, n.minDepth, new Ki(e.changes.compose(s.changes), h9(e.effects, s.effects), s.mapped, s.startSelection, jn)) : o = pS(o, o.length, n.minDepth, e), new fo(o, jn, t, i);
  }
  addSelection(e, t, i, n) {
    let a = this.done.length ? this.done[this.done.length - 1].selectionsAfter : jn;
    return a.length > 0 && t - this.prevTime < n && i == this.prevUserEvent && i && /^select($|\.)/.test(i) && oxe(a[a.length - 1], e) ? this : new fo(f9(this.done, e), this.undone, t, i);
  }
  addMapping(e) {
    return new fo(CA(this.done, e), CA(this.undone, e), this.prevTime, this.prevUserEvent);
  }
  pop(e, t, i) {
    let n = e == 0 ? this.done : this.undone;
    if (n.length == 0)
      return null;
    let a = n[n.length - 1];
    if (i && a.selectionsAfter.length)
      return t.update({
        selection: a.selectionsAfter[a.selectionsAfter.length - 1],
        annotations: JI.of({ side: e, rest: lxe(n) }),
        userEvent: e == 0 ? "select.undo" : "select.redo",
        scrollIntoView: !0
      });
    if (a.changes) {
      let o = n.length == 1 ? jn : n.slice(0, n.length - 1);
      return a.mapped && (o = CA(o, a.mapped)), t.update({
        changes: a.changes,
        selection: a.startSelection,
        effects: a.effects,
        annotations: JI.of({ side: e, rest: o }),
        filter: !1,
        userEvent: e == 0 ? "undo" : "redo",
        scrollIntoView: !0
      });
    } else
      return null;
  }
}
fo.empty = /* @__PURE__ */ new fo(jn, jn);
const d9 = [
  { key: "Mod-z", run: Kx, preventDefault: !0 },
  { key: "Mod-y", mac: "Mod-Shift-z", run: dS, preventDefault: !0 },
  { linux: "Ctrl-Shift-z", run: dS, preventDefault: !0 },
  { key: "Mod-u", run: l9, preventDefault: !0 },
  { key: "Alt-u", mac: "Mod-Shift-u", run: u9, preventDefault: !0 }
];
function fd(r, e) {
  return Z.create(r.ranges.map(e), r.mainIndex);
}
function Mo(r, e) {
  return r.update({ selection: e, scrollIntoView: !0, userEvent: "select" });
}
function ua({ state: r, dispatch: e }, t) {
  let i = fd(r.selection, t);
  return i.eq(r.selection) ? !1 : (e(Mo(r, i)), !0);
}
function Zv(r, e) {
  return Z.cursor(e ? r.to : r.from);
}
function ty(r, e) {
  return ua(r, (t) => t.empty ? r.moveByChar(t, e) : Zv(t, e));
}
function Si(r) {
  return r.textDirectionAt(r.state.selection.main.head) == ir.LTR;
}
const Jx = (r) => ty(r, !Si(r)), eP = (r) => ty(r, Si(r)), hxe = (r) => ty(r, !0), fxe = (r) => ty(r, !1);
function ry(r, e) {
  return ua(r, (t) => t.empty ? r.moveByGroup(t, e) : Zv(t, e));
}
const p9 = (r) => ry(r, !Si(r)), g9 = (r) => ry(r, Si(r)), dxe = (r) => ry(r, !0), pxe = (r) => ry(r, !1);
function v9(r, e, t) {
  let i = r.state.charCategorizer(e.from);
  return r.moveByChar(e, t, (n) => {
    let a = Mt.Space, o = e.from, s = !1, l = !1, u = !1, c = (h) => {
      if (s)
        return !1;
      o += t ? h.length : -h.length;
      let f = i(h), d;
      if (f == Mt.Word && h.charCodeAt(0) < 128 && /[\W_]/.test(h) && (f = -1), a == Mt.Space && (a = f), a != f)
        return !1;
      if (a == Mt.Word)
        if (h.toLowerCase() == h) {
          if (!t && l)
            return !1;
          u = !0;
        } else if (u) {
          if (t)
            return !1;
          s = !0;
        } else {
          if (l && t && i(d = r.state.sliceDoc(o, o + 1)) == Mt.Word && d.toLowerCase() == d)
            return !1;
          l = !0;
        }
      return !0;
    };
    return c(n), c;
  });
}
function O9(r, e) {
  return ua(r, (t) => t.empty ? v9(r, t, e) : Zv(t, e));
}
const gxe = (r) => O9(r, !0), vxe = (r) => O9(r, !1);
function Oxe(r, e, t) {
  if (e.type.prop(t))
    return !0;
  let i = e.to - e.from;
  return i && (i > 2 || /[^\s,.;:]/.test(r.sliceDoc(e.from, e.to))) || e.firstChild;
}
function iy(r, e, t) {
  let i = Kt(r).resolveInner(e.head), n = t ? gt.closedBy : gt.openedBy;
  for (let l = e.head; ; ) {
    let u = t ? i.childAfter(l) : i.childBefore(l);
    if (!u)
      break;
    Oxe(r, u, n) ? i = u : l = t ? u.to : u.from;
  }
  let a = i.type.prop(n), o, s;
  return a && (o = t ? ho(r, i.from, 1) : ho(r, i.to, -1)) && o.matched ? s = t ? o.end.to : o.end.from : s = t ? i.to : i.from, Z.cursor(s, t ? -1 : 1);
}
const m9 = (r) => ua(r, (e) => iy(r.state, e, !Si(r))), E9 = (r) => ua(r, (e) => iy(r.state, e, Si(r)));
function b9(r, e) {
  return ua(r, (t) => {
    if (!t.empty)
      return Zv(t, e);
    let i = r.moveVertically(t, e);
    return i.head != t.head ? i : r.moveToLineBoundary(t, e);
  });
}
const tP = (r) => b9(r, !1), rP = (r) => b9(r, !0);
function S9(r) {
  let e = r.scrollDOM.clientHeight < r.scrollDOM.scrollHeight - 2, t = 0, i = 0, n;
  if (e) {
    for (let a of r.state.facet(me.scrollMargins)) {
      let o = a(r);
      o != null && o.top && (t = Math.max(o == null ? void 0 : o.top, t)), o != null && o.bottom && (i = Math.max(o == null ? void 0 : o.bottom, i));
    }
    n = r.scrollDOM.clientHeight - t - i;
  } else
    n = (r.dom.ownerDocument.defaultView || window).innerHeight;
  return {
    marginTop: t,
    marginBottom: i,
    selfScroll: e,
    height: Math.max(r.defaultLineHeight, n - 5)
  };
}
function T9(r, e) {
  let t = S9(r), { state: i } = r, n = fd(i.selection, (o) => o.empty ? r.moveVertically(o, e, t.height) : Zv(o, e));
  if (n.eq(i.selection))
    return !1;
  let a;
  if (t.selfScroll) {
    let o = r.coordsAtPos(i.selection.main.head), s = r.scrollDOM.getBoundingClientRect(), l = s.top + t.marginTop, u = s.bottom - t.marginBottom;
    o && o.top > l && o.bottom < u && (a = me.scrollIntoView(n.main.head, { y: "start", yMargin: o.top - l }));
  }
  return r.dispatch(Mo(i, n), { effects: a }), !0;
}
const ew = (r) => T9(r, !1), gS = (r) => T9(r, !0);
function Jl(r, e, t) {
  let i = r.lineBlockAt(e.head), n = r.moveToLineBoundary(e, t);
  if (n.head == e.head && n.head != (t ? i.to : i.from) && (n = r.moveToLineBoundary(e, t, !1)), !t && n.head == i.from && i.length) {
    let a = /^\s*/.exec(r.state.sliceDoc(i.from, Math.min(i.from + 100, i.to)))[0].length;
    a && e.head != i.from + a && (n = Z.cursor(i.from + a));
  }
  return n;
}
const y9 = (r) => ua(r, (e) => Jl(r, e, !0)), R9 = (r) => ua(r, (e) => Jl(r, e, !1)), A9 = (r) => ua(r, (e) => Jl(r, e, !Si(r))), _9 = (r) => ua(r, (e) => Jl(r, e, Si(r))), C9 = (r) => ua(r, (e) => Z.cursor(r.lineBlockAt(e.head).from, 1)), I9 = (r) => ua(r, (e) => Z.cursor(r.lineBlockAt(e.head).to, -1));
function w9(r, e, t) {
  let i = !1, n = fd(r.selection, (a) => {
    let o = ho(r, a.head, -1) || ho(r, a.head, 1) || a.head > 0 && ho(r, a.head - 1, 1) || a.head < r.doc.length && ho(r, a.head + 1, -1);
    if (!o || !o.end)
      return a;
    i = !0;
    let s = o.start.from == a.head ? o.end.to : o.end.from;
    return t ? Z.range(a.anchor, s) : Z.cursor(s);
  });
  return i ? (e(Mo(r, n)), !0) : !1;
}
const N9 = ({ state: r, dispatch: e }) => w9(r, e, !1), mxe = ({ state: r, dispatch: e }) => w9(r, e, !0);
function In(r, e) {
  let t = fd(r.state.selection, (i) => {
    let n = e(i);
    return Z.range(i.anchor, n.head, n.goalColumn, n.bidiLevel || void 0);
  });
  return t.eq(r.state.selection) ? !1 : (r.dispatch(Mo(r.state, t)), !0);
}
function ny(r, e) {
  return In(r, (t) => r.moveByChar(t, e));
}
const iP = (r) => ny(r, !Si(r)), nP = (r) => ny(r, Si(r)), Exe = (r) => ny(r, !0), bxe = (r) => ny(r, !1);
function ay(r, e) {
  return In(r, (t) => r.moveByGroup(t, e));
}
const x9 = (r) => ay(r, !Si(r)), P9 = (r) => ay(r, Si(r)), Sxe = (r) => ay(r, !0), Txe = (r) => ay(r, !1);
function L9(r, e) {
  return In(r, (t) => v9(r, t, e));
}
const yxe = (r) => L9(r, !0), Rxe = (r) => L9(r, !1), D9 = (r) => In(r, (e) => iy(r.state, e, !Si(r))), M9 = (r) => In(r, (e) => iy(r.state, e, Si(r)));
function k9(r, e) {
  return In(r, (t) => r.moveVertically(t, e));
}
const aP = (r) => k9(r, !1), oP = (r) => k9(r, !0);
function Q9(r, e) {
  return In(r, (t) => r.moveVertically(t, e, S9(r).height));
}
const tw = (r) => Q9(r, !1), rw = (r) => Q9(r, !0), U9 = (r) => In(r, (e) => Jl(r, e, !0)), $9 = (r) => In(r, (e) => Jl(r, e, !1)), V9 = (r) => In(r, (e) => Jl(r, e, !Si(r))), G9 = (r) => In(r, (e) => Jl(r, e, Si(r))), B9 = (r) => In(r, (e) => Z.cursor(r.lineBlockAt(e.head).from)), F9 = (r) => In(r, (e) => Z.cursor(r.lineBlockAt(e.head).to)), iw = ({ state: r, dispatch: e }) => (e(Mo(r, { anchor: 0 })), !0), nw = ({ state: r, dispatch: e }) => (e(Mo(r, { anchor: r.doc.length })), !0), aw = ({ state: r, dispatch: e }) => (e(Mo(r, { anchor: r.selection.main.anchor, head: 0 })), !0), ow = ({ state: r, dispatch: e }) => (e(Mo(r, { anchor: r.selection.main.anchor, head: r.doc.length })), !0), X9 = ({ state: r, dispatch: e }) => (e(r.update({ selection: { anchor: 0, head: r.doc.length }, userEvent: "select" })), !0), Y9 = ({ state: r, dispatch: e }) => {
  let t = sy(r).map(({ from: i, to: n }) => Z.range(i, Math.min(n + 1, r.doc.length)));
  return e(r.update({ selection: Z.create(t), userEvent: "select" })), !0;
}, H9 = ({ state: r, dispatch: e }) => {
  let t = fd(r.selection, (i) => {
    var n;
    let a = Kt(r).resolveInner(i.head, 1);
    for (; !(a.from < i.from && a.to >= i.to || a.to > i.to && a.from <= i.from || !(!((n = a.parent) === null || n === void 0) && n.parent)); )
      a = a.parent;
    return Z.range(a.to, a.from);
  });
  return e(Mo(r, t)), !0;
}, W9 = ({ state: r, dispatch: e }) => {
  let t = r.selection, i = null;
  return t.ranges.length > 1 ? i = Z.create([t.main]) : t.main.empty || (i = Z.create([Z.cursor(t.main.head)])), i ? (e(Mo(r, i)), !0) : !1;
};
function oy(r, e) {
  if (r.state.readOnly)
    return !1;
  let t = "delete.selection", { state: i } = r, n = i.changeByRange((a) => {
    let { from: o, to: s } = a;
    if (o == s) {
      let l = e(o);
      l < o ? (t = "delete.backward", l = Pm(r, l, !1)) : l > o && (t = "delete.forward", l = Pm(r, l, !0)), o = Math.min(o, l), s = Math.max(s, l);
    } else
      o = Pm(r, o, !1), s = Pm(r, s, !0);
    return o == s ? { range: a } : { changes: { from: o, to: s }, range: Z.cursor(o) };
  });
  return n.changes.empty ? !1 : (r.dispatch(i.update(n, {
    scrollIntoView: !0,
    userEvent: t,
    effects: t == "delete.selection" ? me.announce.of(i.phrase("Selection deleted")) : void 0
  })), !0);
}
function Pm(r, e, t) {
  if (r instanceof me)
    for (let i of r.state.facet(me.atomicRanges).map((n) => n(r)))
      i.between(e, e, (n, a) => {
        n < e && a > e && (e = t ? a : n);
      });
  return e;
}
const z9 = (r, e) => oy(r, (t) => {
  let { state: i } = r, n = i.doc.lineAt(t), a, o;
  if (!e && t > n.from && t < n.from + 200 && !/[^ \t]/.test(a = n.text.slice(0, t - n.from))) {
    if (a[a.length - 1] == "	")
      return t - 1;
    let s = Bv(a, i.tabSize), l = s % cS(i) || cS(i);
    for (let u = 0; u < l && a[a.length - 1 - u] == " "; u++)
      t--;
    o = t;
  } else
    o = vi(n.text, t - n.from, e, e) + n.from, o == t && n.number != (e ? i.doc.lines : 1) && (o += e ? 1 : -1);
  return o;
}), vS = (r) => z9(r, !1), sP = (r) => z9(r, !0), Z9 = (r, e) => oy(r, (t) => {
  let i = t, { state: n } = r, a = n.doc.lineAt(i), o = n.charCategorizer(i);
  for (let s = null; ; ) {
    if (i == (e ? a.to : a.from)) {
      i == t && a.number != (e ? n.doc.lines : 1) && (i += e ? 1 : -1);
      break;
    }
    let l = vi(a.text, i - a.from, e) + a.from, u = a.text.slice(Math.min(i, l) - a.from, Math.max(i, l) - a.from), c = o(u);
    if (s != null && c != s)
      break;
    (u != " " || i != t) && (s = c), i = l;
  }
  return i;
}), lP = (r) => Z9(r, !1), q9 = (r) => Z9(r, !0), uP = (r) => oy(r, (e) => {
  let t = r.lineBlockAt(e).to;
  return e < t ? t : Math.min(r.state.doc.length, e + 1);
}), j9 = (r) => oy(r, (e) => {
  let t = r.lineBlockAt(e).from;
  return e > t ? t : Math.max(0, e - 1);
}), Axe = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = [];
  for (let i = 0, n = "", a = r.doc.iter(); ; ) {
    if (a.next(), a.lineBreak || a.done) {
      let o = n.search(/\s+$/);
      if (o > -1 && t.push({ from: i - (n.length - o), to: i }), a.done)
        break;
      n = "";
    } else
      n = a.value;
    i += a.value.length;
  }
  return t.length ? (e(r.update({ changes: t, userEvent: "delete" })), !0) : !1;
}, K9 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => ({
    changes: { from: i.from, to: i.to, insert: Ct.of(["", ""]) },
    range: Z.cursor(i.from)
  }));
  return e(r.update(t, { scrollIntoView: !0, userEvent: "input" })), !0;
}, J9 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = r.changeByRange((i) => {
    if (!i.empty || i.from == 0 || i.from == r.doc.length)
      return { range: i };
    let n = i.from, a = r.doc.lineAt(n), o = n == a.from ? n - 1 : vi(a.text, n - a.from, !1) + a.from, s = n == a.to ? n + 1 : vi(a.text, n - a.from, !0) + a.from;
    return {
      changes: { from: o, to: s, insert: r.doc.slice(n, s).append(r.doc.slice(o, n)) },
      range: Z.cursor(s)
    };
  });
  return t.changes.empty ? !1 : (e(r.update(t, { scrollIntoView: !0, userEvent: "move.character" })), !0);
};
function sy(r) {
  let e = [], t = -1;
  for (let i of r.selection.ranges) {
    let n = r.doc.lineAt(i.from), a = r.doc.lineAt(i.to);
    if (!i.empty && i.to == a.from && (a = r.doc.lineAt(i.to - 1)), t >= n.number) {
      let o = e[e.length - 1];
      o.to = a.to, o.ranges.push(i);
    } else
      e.push({ from: n.from, to: a.to, ranges: [i] });
    t = a.number + 1;
  }
  return e;
}
function e8(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [], n = [];
  for (let a of sy(r)) {
    if (t ? a.to == r.doc.length : a.from == 0)
      continue;
    let o = r.doc.lineAt(t ? a.to + 1 : a.from - 1), s = o.length + 1;
    if (t) {
      i.push({ from: a.to, to: o.to }, { from: a.from, insert: o.text + r.lineBreak });
      for (let l of a.ranges)
        n.push(Z.range(Math.min(r.doc.length, l.anchor + s), Math.min(r.doc.length, l.head + s)));
    } else {
      i.push({ from: o.from, to: a.from }, { from: a.to, insert: r.lineBreak + o.text });
      for (let l of a.ranges)
        n.push(Z.range(l.anchor - s, l.head - s));
    }
  }
  return i.length ? (e(r.update({
    changes: i,
    scrollIntoView: !0,
    selection: Z.create(n, r.selection.mainIndex),
    userEvent: "move.line"
  })), !0) : !1;
}
const t8 = ({ state: r, dispatch: e }) => e8(r, e, !1), r8 = ({ state: r, dispatch: e }) => e8(r, e, !0);
function i8(r, e, t) {
  if (r.readOnly)
    return !1;
  let i = [];
  for (let n of sy(r))
    t ? i.push({ from: n.from, insert: r.doc.slice(n.from, n.to) + r.lineBreak }) : i.push({ from: n.to, insert: r.lineBreak + r.doc.slice(n.from, n.to) });
  return e(r.update({ changes: i, scrollIntoView: !0, userEvent: "input.copyline" })), !0;
}
const n8 = ({ state: r, dispatch: e }) => i8(r, e, !1), a8 = ({ state: r, dispatch: e }) => i8(r, e, !0), o8 = (r) => {
  if (r.state.readOnly)
    return !1;
  let { state: e } = r, t = e.changes(sy(e).map(({ from: n, to: a }) => (n > 0 ? n-- : a < e.doc.length && a++, { from: n, to: a }))), i = fd(e.selection, (n) => r.moveVertically(n, !0)).map(t);
  return r.dispatch({ changes: t, selection: i, scrollIntoView: !0, userEvent: "delete.line" }), !0;
}, _xe = ({ state: r, dispatch: e }) => (e(r.update(r.replaceSelection(r.lineBreak), { scrollIntoView: !0, userEvent: "input" })), !0);
function Cxe(r, e) {
  if (/\(\)|\[\]|\{\}/.test(r.sliceDoc(e - 1, e + 1)))
    return { from: e, to: e };
  let t = Kt(r).resolveInner(e), i = t.childBefore(e), n = t.childAfter(e), a;
  return i && n && i.to <= e && n.from >= e && (a = i.type.prop(gt.closedBy)) && a.indexOf(n.name) > -1 && r.doc.lineAt(i.to).from == r.doc.lineAt(n.from).from ? { from: i.to, to: n.from } : null;
}
const s8 = /* @__PURE__ */ u8(!1), l8 = /* @__PURE__ */ u8(!0);
function u8(r) {
  return ({ state: e, dispatch: t }) => {
    if (e.readOnly)
      return !1;
    let i = e.changeByRange((n) => {
      let { from: a, to: o } = n, s = e.doc.lineAt(a), l = !r && a == o && Cxe(e, a);
      r && (a = o = (o <= s.to ? s : e.doc.lineAt(o)).to);
      let u = new qT(e, { simulateBreak: a, simulateDoubleBreak: !!l }), c = Wx(u, a);
      for (c == null && (c = /^\s*/.exec(e.doc.lineAt(a).text)[0].length); o < s.to && /\s/.test(s.text[o - s.from]); )
        o++;
      l ? { from: a, to: o } = l : a > s.from && a < s.from + 100 && !/\S/.test(s.text.slice(0, a)) && (a = s.from);
      let h = ["", sv(e, c)];
      return l && h.push(sv(e, u.lineIndent(s.from, -1))), {
        changes: { from: a, to: o, insert: Ct.of(h) },
        range: Z.cursor(a + 1 + h[1].length)
      };
    });
    return t(e.update(i, { scrollIntoView: !0, userEvent: "input" })), !0;
  };
}
function cP(r, e) {
  let t = -1;
  return r.changeByRange((i) => {
    let n = [];
    for (let o = i.from; o <= i.to; ) {
      let s = r.doc.lineAt(o);
      s.number > t && (i.empty || i.to > s.from) && (e(s, n, i), t = s.number), o = s.to + 1;
    }
    let a = r.changes(n);
    return {
      changes: n,
      range: Z.range(a.mapPos(i.anchor, 1), a.mapPos(i.head, 1))
    };
  });
}
const c8 = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let t = /* @__PURE__ */ Object.create(null), i = new qT(r, { overrideIndentation: (a) => {
    let o = t[a];
    return o ?? -1;
  } }), n = cP(r, (a, o, s) => {
    let l = Wx(i, a.from);
    if (l == null)
      return;
    /\S/.test(a.text) || (l = 0);
    let u = /^\s*/.exec(a.text)[0], c = sv(r, l);
    (u != c || s.from < a.from + u.length) && (t[a.from] = l, o.push({ from: a.from, to: a.from + u.length, insert: c }));
  });
  return n.changes.empty || e(r.update(n, { userEvent: "indent" })), !0;
}, ly = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(cP(r, (t, i) => {
  i.push({ from: t.from, insert: r.facet(ZT) });
}), { userEvent: "input.indent" })), !0), hP = ({ state: r, dispatch: e }) => r.readOnly ? !1 : (e(r.update(cP(r, (t, i) => {
  let n = /^\s*/.exec(t.text)[0];
  if (!n)
    return;
  let a = Bv(n, r.tabSize), o = 0, s = sv(r, Math.max(0, a - cS(r)));
  for (; o < n.length && o < s.length && n.charCodeAt(o) == s.charCodeAt(o); )
    o++;
  i.push({ from: t.from + o, to: t.from + n.length, insert: s.slice(o) });
}), { userEvent: "delete.dedent" })), !0), Ixe = ({ state: r, dispatch: e }) => r.selection.ranges.some((t) => !t.empty) ? ly({ state: r, dispatch: e }) : (e(r.update(r.replaceSelection("	"), { scrollIntoView: !0, userEvent: "input" })), !0), h8 = [
  { key: "Ctrl-b", run: Jx, shift: iP, preventDefault: !0 },
  { key: "Ctrl-f", run: eP, shift: nP },
  { key: "Ctrl-p", run: tP, shift: aP },
  { key: "Ctrl-n", run: rP, shift: oP },
  { key: "Ctrl-a", run: C9, shift: B9 },
  { key: "Ctrl-e", run: I9, shift: F9 },
  { key: "Ctrl-d", run: sP },
  { key: "Ctrl-h", run: vS },
  { key: "Ctrl-k", run: uP },
  { key: "Ctrl-Alt-h", run: lP },
  { key: "Ctrl-o", run: K9 },
  { key: "Ctrl-t", run: J9 },
  { key: "Ctrl-v", run: gS }
], f8 = /* @__PURE__ */ [
  { key: "ArrowLeft", run: Jx, shift: iP, preventDefault: !0 },
  { key: "Mod-ArrowLeft", mac: "Alt-ArrowLeft", run: p9, shift: x9, preventDefault: !0 },
  { mac: "Cmd-ArrowLeft", run: A9, shift: V9, preventDefault: !0 },
  { key: "ArrowRight", run: eP, shift: nP, preventDefault: !0 },
  { key: "Mod-ArrowRight", mac: "Alt-ArrowRight", run: g9, shift: P9, preventDefault: !0 },
  { mac: "Cmd-ArrowRight", run: _9, shift: G9, preventDefault: !0 },
  { key: "ArrowUp", run: tP, shift: aP, preventDefault: !0 },
  { mac: "Cmd-ArrowUp", run: iw, shift: aw },
  { mac: "Ctrl-ArrowUp", run: ew, shift: tw },
  { key: "ArrowDown", run: rP, shift: oP, preventDefault: !0 },
  { mac: "Cmd-ArrowDown", run: nw, shift: ow },
  { mac: "Ctrl-ArrowDown", run: gS, shift: rw },
  { key: "PageUp", run: ew, shift: tw },
  { key: "PageDown", run: gS, shift: rw },
  { key: "Home", run: R9, shift: $9, preventDefault: !0 },
  { key: "Mod-Home", run: iw, shift: aw },
  { key: "End", run: y9, shift: U9, preventDefault: !0 },
  { key: "Mod-End", run: nw, shift: ow },
  { key: "Enter", run: s8 },
  { key: "Mod-a", run: X9 },
  { key: "Backspace", run: vS, shift: vS },
  { key: "Delete", run: sP },
  { key: "Mod-Backspace", mac: "Alt-Backspace", run: lP },
  { key: "Mod-Delete", mac: "Alt-Delete", run: q9 },
  { mac: "Mod-Backspace", run: j9 },
  { mac: "Mod-Delete", run: uP }
].concat(/* @__PURE__ */ h8.map((r) => ({ mac: r.key, run: r.run, shift: r.shift }))), d8 = /* @__PURE__ */ [
  { key: "Alt-ArrowLeft", mac: "Ctrl-ArrowLeft", run: m9, shift: D9 },
  { key: "Alt-ArrowRight", mac: "Ctrl-ArrowRight", run: E9, shift: M9 },
  { key: "Alt-ArrowUp", run: t8 },
  { key: "Shift-Alt-ArrowUp", run: n8 },
  { key: "Alt-ArrowDown", run: r8 },
  { key: "Shift-Alt-ArrowDown", run: a8 },
  { key: "Escape", run: W9 },
  { key: "Mod-Enter", run: l8 },
  { key: "Alt-l", mac: "Ctrl-l", run: Y9 },
  { key: "Mod-i", run: H9, preventDefault: !0 },
  { key: "Mod-[", run: hP },
  { key: "Mod-]", run: ly },
  { key: "Mod-Alt-\\", run: c8 },
  { key: "Shift-Mod-k", run: o8 },
  { key: "Shift-Mod-\\", run: N9 },
  { key: "Mod-/", run: e9 },
  { key: "Alt-A", run: r9 }
].concat(f8), wxe = { key: "Tab", run: ly, shift: hP }, DG = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  blockComment: jNe,
  blockUncomment: KNe,
  copyLineDown: a8,
  copyLineUp: n8,
  cursorCharBackward: fxe,
  cursorCharForward: hxe,
  cursorCharLeft: Jx,
  cursorCharRight: eP,
  cursorDocEnd: nw,
  cursorDocStart: iw,
  cursorGroupBackward: pxe,
  cursorGroupForward: dxe,
  cursorGroupLeft: p9,
  cursorGroupRight: g9,
  cursorLineBoundaryBackward: R9,
  cursorLineBoundaryForward: y9,
  cursorLineBoundaryLeft: A9,
  cursorLineBoundaryRight: _9,
  cursorLineDown: rP,
  cursorLineEnd: I9,
  cursorLineStart: C9,
  cursorLineUp: tP,
  cursorMatchingBracket: N9,
  cursorPageDown: gS,
  cursorPageUp: ew,
  cursorSubwordBackward: vxe,
  cursorSubwordForward: gxe,
  cursorSyntaxLeft: m9,
  cursorSyntaxRight: E9,
  defaultKeymap: d8,
  deleteCharBackward: vS,
  deleteCharForward: sP,
  deleteGroupBackward: lP,
  deleteGroupForward: q9,
  deleteLine: o8,
  deleteToLineEnd: uP,
  deleteToLineStart: j9,
  deleteTrailingWhitespace: Axe,
  emacsStyleKeymap: h8,
  history: s9,
  historyField: rxe,
  historyKeymap: d9,
  indentLess: hP,
  indentMore: ly,
  indentSelection: c8,
  indentWithTab: wxe,
  insertBlankLine: l8,
  insertNewline: _xe,
  insertNewlineAndIndent: s8,
  insertTab: Ixe,
  invertedEffects: a9,
  isolateHistory: n9,
  lineComment: ZNe,
  lineUncomment: qNe,
  moveLineDown: r8,
  moveLineUp: t8,
  redo: dS,
  redoDepth: nxe,
  redoSelection: u9,
  selectAll: X9,
  selectCharBackward: bxe,
  selectCharForward: Exe,
  selectCharLeft: iP,
  selectCharRight: nP,
  selectDocEnd: ow,
  selectDocStart: aw,
  selectGroupBackward: Txe,
  selectGroupForward: Sxe,
  selectGroupLeft: x9,
  selectGroupRight: P9,
  selectLine: Y9,
  selectLineBoundaryBackward: $9,
  selectLineBoundaryForward: U9,
  selectLineBoundaryLeft: V9,
  selectLineBoundaryRight: G9,
  selectLineDown: oP,
  selectLineEnd: F9,
  selectLineStart: B9,
  selectLineUp: aP,
  selectMatchingBracket: mxe,
  selectPageDown: rw,
  selectPageUp: tw,
  selectParentSyntax: H9,
  selectSubwordBackward: Rxe,
  selectSubwordForward: yxe,
  selectSyntaxLeft: D9,
  selectSyntaxRight: M9,
  simplifySelection: W9,
  splitLine: K9,
  standardKeymap: f8,
  toggleBlockComment: r9,
  toggleBlockCommentByLine: i9,
  toggleComment: e9,
  toggleLineComment: t9,
  transposeChars: J9,
  undo: Kx,
  undoDepth: ixe,
  undoSelection: l9
}, Symbol.toStringTag, { value: "Module" }));
function Ft() {
  var r = arguments[0];
  typeof r == "string" && (r = document.createElement(r));
  var e = 1, t = arguments[1];
  if (t && typeof t == "object" && t.nodeType == null && !Array.isArray(t)) {
    for (var i in t)
      if (Object.prototype.hasOwnProperty.call(t, i)) {
        var n = t[i];
        typeof n == "string" ? r.setAttribute(i, n) : n != null && (r[i] = n);
      }
    e++;
  }
  for (; e < arguments.length; e++)
    p8(r, arguments[e]);
  return r;
}
function p8(r, e) {
  if (typeof e == "string")
    r.appendChild(document.createTextNode(e));
  else if (e != null)
    if (e.nodeType != null)
      r.appendChild(e);
    else if (Array.isArray(e))
      for (var t = 0; t < e.length; t++)
        p8(r, e[t]);
    else
      throw new RangeError("Unsupported child node: " + e);
}
const MG = typeof String.prototype.normalize == "function" ? (r) => r.normalize("NFKD") : (r) => r;
class Gf {
  /**
  Create a text cursor. The query is the search string, `from` to
  `to` provides the region to search.
  
  When `normalize` is given, it will be called, on both the query
  string and the content it is matched against, before comparing.
  You can, for example, create a case-insensitive search by
  passing `s => s.toLowerCase()`.
  
  Text is always normalized with
  [`.normalize("NFKD")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)
  (when supported).
  */
  constructor(e, t, i = 0, n = e.length, a, o) {
    this.test = o, this.value = { from: 0, to: 0 }, this.done = !1, this.matches = [], this.buffer = "", this.bufferPos = 0, this.iter = e.iterRange(i, n), this.bufferStart = i, this.normalize = a ? (s) => a(MG(s)) : MG, this.query = this.normalize(t);
  }
  peek() {
    if (this.bufferPos == this.buffer.length) {
      if (this.bufferStart += this.buffer.length, this.iter.next(), this.iter.done)
        return -1;
      this.bufferPos = 0, this.buffer = this.iter.value;
    }
    return Zr(this.buffer, this.bufferPos);
  }
  /**
  Look for the next match. Updates the iterator's
  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and
  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called
  at least once before using the cursor.
  */
  next() {
    for (; this.matches.length; )
      this.matches.pop();
    return this.nextOverlapping();
  }
  /**
  The `next` method will ignore matches that partially overlap a
  previous match. This method behaves like `next`, but includes
  such matches.
  */
  nextOverlapping() {
    for (; ; ) {
      let e = this.peek();
      if (e < 0)
        return this.done = !0, this;
      let t = xx(e), i = this.bufferStart + this.bufferPos;
      this.bufferPos += Hn(e);
      let n = this.normalize(t);
      for (let a = 0, o = i; ; a++) {
        let s = n.charCodeAt(a), l = this.match(s, o);
        if (a == n.length - 1) {
          if (l)
            return this.value = l, this;
          break;
        }
        o == i && a < t.length && t.charCodeAt(a) == s && o++;
      }
    }
  }
  match(e, t) {
    let i = null;
    for (let n = 0; n < this.matches.length; n += 2) {
      let a = this.matches[n], o = !1;
      this.query.charCodeAt(a) == e && (a == this.query.length - 1 ? i = { from: this.matches[n + 1], to: t + 1 } : (this.matches[n]++, o = !0)), o || (this.matches.splice(n, 2), n -= 2);
    }
    return this.query.charCodeAt(0) == e && (this.query.length == 1 ? i = { from: t, to: t + 1 } : this.matches.push(1, t)), i && this.test && !this.test(i.from, i.to, this.buffer, this.bufferPos) && (i = null), i;
  }
}
typeof Symbol < "u" && (Gf.prototype[Symbol.iterator] = function() {
  return this;
});
const g8 = { from: -1, to: -1, match: /* @__PURE__ */ /.*/.exec("") }, fP = "gm" + (/x/.unicode == null ? "" : "u");
class v8 {
  /**
  Create a cursor that will search the given range in the given
  document. `query` should be the raw pattern (as you'd pass it to
  `new RegExp`).
  */
  constructor(e, t, i, n = 0, a = e.length) {
    if (this.text = e, this.to = a, this.curLine = "", this.done = !1, this.value = g8, /\\[sWDnr]|\n|\r|\[\^/.test(t))
      return new O8(e, t, i, n, a);
    this.re = new RegExp(t, fP + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.iter = e.iter();
    let o = e.lineAt(n);
    this.curLineStart = o.from, this.matchPos = OS(e, n), this.getLine(this.curLineStart);
  }
  getLine(e) {
    this.iter.next(e), this.iter.lineBreak ? this.curLine = "" : (this.curLine = this.iter.value, this.curLineStart + this.curLine.length > this.to && (this.curLine = this.curLine.slice(0, this.to - this.curLineStart)), this.iter.next());
  }
  nextLine() {
    this.curLineStart = this.curLineStart + this.curLine.length + 1, this.curLineStart > this.to ? this.curLine = "" : this.getLine(0);
  }
  /**
  Move to the next match, if there is one.
  */
  next() {
    for (let e = this.matchPos - this.curLineStart; ; ) {
      this.re.lastIndex = e;
      let t = this.matchPos <= this.to && this.re.exec(this.curLine);
      if (t) {
        let i = this.curLineStart + t.index, n = i + t[0].length;
        if (this.matchPos = OS(this.text, n + (i == n ? 1 : 0)), i == this.curLineStart + this.curLine.length && this.nextLine(), (i < n || i > this.value.to) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this;
        e = this.matchPos - this.curLineStart;
      } else if (this.curLineStart + this.curLine.length < this.to)
        this.nextLine(), e = 0;
      else
        return this.done = !0, this;
    }
  }
}
const IA = /* @__PURE__ */ new WeakMap();
class gf {
  constructor(e, t) {
    this.from = e, this.text = t;
  }
  get to() {
    return this.from + this.text.length;
  }
  static get(e, t, i) {
    let n = IA.get(e);
    if (!n || n.from >= i || n.to <= t) {
      let s = new gf(t, e.sliceString(t, i));
      return IA.set(e, s), s;
    }
    if (n.from == t && n.to == i)
      return n;
    let { text: a, from: o } = n;
    return o > t && (a = e.sliceString(t, o) + a, o = t), n.to < i && (a += e.sliceString(n.to, i)), IA.set(e, new gf(o, a)), new gf(t, a.slice(t - o, i - o));
  }
}
class O8 {
  constructor(e, t, i, n, a) {
    this.text = e, this.to = a, this.done = !1, this.value = g8, this.matchPos = OS(e, n), this.re = new RegExp(t, fP + (i != null && i.ignoreCase ? "i" : "")), this.test = i == null ? void 0 : i.test, this.flat = gf.get(e, n, this.chunkEnd(
      n + 5e3
      /* Base */
    ));
  }
  chunkEnd(e) {
    return e >= this.to ? this.to : this.text.lineAt(e).to;
  }
  next() {
    for (; ; ) {
      let e = this.re.lastIndex = this.matchPos - this.flat.from, t = this.re.exec(this.flat.text);
      if (t && !t[0] && t.index == e && (this.re.lastIndex = e + 1, t = this.re.exec(this.flat.text)), t) {
        let i = this.flat.from + t.index, n = i + t[0].length;
        if ((this.flat.to >= this.to || t.index + t[0].length <= this.flat.text.length - 10) && (!this.test || this.test(i, n, t)))
          return this.value = { from: i, to: n, match: t }, this.matchPos = OS(this.text, n + (i == n ? 1 : 0)), this;
      }
      if (this.flat.to == this.to)
        return this.done = !0, this;
      this.flat = gf.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));
    }
  }
}
typeof Symbol < "u" && (v8.prototype[Symbol.iterator] = O8.prototype[Symbol.iterator] = function() {
  return this;
});
function Nxe(r) {
  try {
    return new RegExp(r, fP), !0;
  } catch {
    return !1;
  }
}
function OS(r, e) {
  if (e >= r.length)
    return e;
  let t = r.lineAt(e), i;
  for (; e < t.to && (i = t.text.charCodeAt(e - t.from)) >= 56320 && i < 57344; )
    e++;
  return e;
}
function sw(r) {
  let e = Ft("input", { class: "cm-textfield", name: "line" }), t = Ft("form", {
    class: "cm-gotoLine",
    onkeydown: (n) => {
      n.keyCode == 27 ? (n.preventDefault(), r.dispatch({ effects: mS.of(!1) }), r.focus()) : n.keyCode == 13 && (n.preventDefault(), i());
    },
    onsubmit: (n) => {
      n.preventDefault(), i();
    }
  }, Ft("label", r.state.phrase("Go to line"), ": ", e), " ", Ft("button", { class: "cm-button", type: "submit" }, r.state.phrase("go")));
  function i() {
    let n = /^([+-])?(\d+)?(:\d+)?(%)?$/.exec(e.value);
    if (!n)
      return;
    let { state: a } = r, o = a.doc.lineAt(a.selection.main.head), [, s, l, u, c] = n, h = u ? +u.slice(1) : 0, f = l ? +l : o.number;
    if (l && c) {
      let g = f / 100;
      s && (g = g * (s == "-" ? -1 : 1) + o.number / a.doc.lines), f = Math.round(a.doc.lines * g);
    } else
      l && s && (f = f * (s == "-" ? -1 : 1) + o.number);
    let d = a.doc.line(Math.max(1, Math.min(a.doc.lines, f))), p = Z.cursor(d.from + Math.max(0, Math.min(h, d.length)));
    r.dispatch({
      effects: [mS.of(!1), me.scrollIntoView(p.from, { y: "center" })],
      selection: p
    }), r.focus();
  }
  return { dom: t };
}
const mS = /* @__PURE__ */ lt.define(), kG = /* @__PURE__ */ Br.define({
  create() {
    return !0;
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(mS) && (r = t.value);
    return r;
  },
  provide: (r) => av.from(r, (e) => e ? sw : null)
}), xxe = (r) => {
  let e = nv(r, sw);
  if (!e) {
    let t = [mS.of(!0)];
    r.state.field(kG, !1) == null && t.push(lt.appendConfig.of([kG, Pxe])), r.dispatch({ effects: t }), e = nv(r, sw);
  }
  return e && e.dom.querySelector("input").focus(), !0;
}, Pxe = /* @__PURE__ */ me.baseTheme({
  ".cm-panel.cm-gotoLine": {
    padding: "2px 6px 4px",
    "& label": { fontSize: "80%" }
  }
}), Lxe = {
  highlightWordAroundCursor: !1,
  minSelectionLength: 1,
  maxMatches: 100,
  wholeWords: !1
}, m8 = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, Lxe, {
      highlightWordAroundCursor: (e, t) => e || t,
      minSelectionLength: Math.min,
      maxMatches: Math.min
    });
  }
});
function Dxe(r) {
  let e = [$xe, Uxe];
  return r && e.push(m8.of(r)), e;
}
const Mxe = /* @__PURE__ */ Xe.mark({ class: "cm-selectionMatch" }), kxe = /* @__PURE__ */ Xe.mark({ class: "cm-selectionMatch cm-selectionMatch-main" });
function QG(r, e, t, i) {
  return (t == 0 || r(e.sliceDoc(t - 1, t)) != Mt.Word) && (i == e.doc.length || r(e.sliceDoc(i, i + 1)) != Mt.Word);
}
function Qxe(r, e, t, i) {
  return r(e.sliceDoc(t, t + 1)) == Mt.Word && r(e.sliceDoc(i - 1, i)) == Mt.Word;
}
const Uxe = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.decorations = this.getDeco(r);
  }
  update(r) {
    (r.selectionSet || r.docChanged || r.viewportChanged) && (this.decorations = this.getDeco(r.view));
  }
  getDeco(r) {
    let e = r.state.facet(m8), { state: t } = r, i = t.selection;
    if (i.ranges.length > 1)
      return Xe.none;
    let n = i.main, a, o = null;
    if (n.empty) {
      if (!e.highlightWordAroundCursor)
        return Xe.none;
      let l = t.wordAt(n.head);
      if (!l)
        return Xe.none;
      o = t.charCategorizer(n.head), a = t.sliceDoc(l.from, l.to);
    } else {
      let l = n.to - n.from;
      if (l < e.minSelectionLength || l > 200)
        return Xe.none;
      if (e.wholeWords) {
        if (a = t.sliceDoc(n.from, n.to), o = t.charCategorizer(n.head), !(QG(o, t, n.from, n.to) && Qxe(o, t, n.from, n.to)))
          return Xe.none;
      } else if (a = t.sliceDoc(n.from, n.to).trim(), !a)
        return Xe.none;
    }
    let s = [];
    for (let l of r.visibleRanges) {
      let u = new Gf(t.doc, a, l.from, l.to);
      for (; !u.next().done; ) {
        let { from: c, to: h } = u.value;
        if ((!o || QG(o, t, c, h)) && (n.empty && c <= n.from && h >= n.to ? s.push(kxe.range(c, h)) : (c >= n.to || h <= n.from) && s.push(Mxe.range(c, h)), s.length > e.maxMatches))
          return Xe.none;
      }
    }
    return Xe.set(s);
  }
}, {
  decorations: (r) => r.decorations
}), $xe = /* @__PURE__ */ me.baseTheme({
  ".cm-selectionMatch": { backgroundColor: "#99ff7780" },
  ".cm-searchMatch .cm-selectionMatch": { backgroundColor: "transparent" }
}), Vxe = ({ state: r, dispatch: e }) => {
  let { selection: t } = r, i = Z.create(t.ranges.map((n) => r.wordAt(n.head) || Z.cursor(n.head)), t.mainIndex);
  return i.eq(t) ? !1 : (e(r.update({ selection: i })), !0);
};
function Gxe(r, e) {
  let { main: t, ranges: i } = r.selection, n = r.wordAt(t.head), a = n && n.from == t.from && n.to == t.to;
  for (let o = !1, s = new Gf(r.doc, e, i[i.length - 1].to); ; )
    if (s.next(), s.done) {
      if (o)
        return null;
      s = new Gf(r.doc, e, 0, Math.max(0, i[i.length - 1].from - 1)), o = !0;
    } else {
      if (o && i.some((l) => l.from == s.value.from))
        continue;
      if (a) {
        let l = r.wordAt(s.value.from);
        if (!l || l.from != s.value.from || l.to != s.value.to)
          continue;
      }
      return s.value;
    }
}
const Bxe = ({ state: r, dispatch: e }) => {
  let { ranges: t } = r.selection;
  if (t.some((a) => a.from === a.to))
    return Vxe({ state: r, dispatch: e });
  let i = r.sliceDoc(t[0].from, t[0].to);
  if (r.selection.ranges.some((a) => r.sliceDoc(a.from, a.to) != i))
    return !1;
  let n = Gxe(r, i);
  return n ? (e(r.update({
    selection: r.selection.addRange(Z.range(n.from, n.to), !1),
    effects: me.scrollIntoView(n.to)
  })), !0) : !1;
}, dd = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, {
      top: !1,
      caseSensitive: !1,
      literal: !1,
      regexp: !1,
      wholeWord: !1,
      createPanel: (e) => new ePe(e),
      scrollToMatch: (e) => me.scrollIntoView(e)
    });
  }
});
class E8 {
  /**
  Create a query object.
  */
  constructor(e) {
    this.search = e.search, this.caseSensitive = !!e.caseSensitive, this.literal = !!e.literal, this.regexp = !!e.regexp, this.replace = e.replace || "", this.valid = !!this.search && (!this.regexp || Nxe(this.search)), this.unquoted = this.unquote(this.search), this.wholeWord = !!e.wholeWord;
  }
  /**
  @internal
  */
  unquote(e) {
    return this.literal ? e : e.replace(/\\([nrt\\])/g, (t, i) => i == "n" ? `
` : i == "r" ? "\r" : i == "t" ? "	" : "\\");
  }
  /**
  Compare this query to another query.
  */
  eq(e) {
    return this.search == e.search && this.replace == e.replace && this.caseSensitive == e.caseSensitive && this.regexp == e.regexp && this.wholeWord == e.wholeWord;
  }
  /**
  @internal
  */
  create() {
    return this.regexp ? new Hxe(this) : new Xxe(this);
  }
  /**
  Get a search cursor for this query, searching through the given
  range in the given state.
  */
  getCursor(e, t = 0, i) {
    let n = e.doc ? e : Rt.create({ doc: e });
    return i == null && (i = n.doc.length), this.regexp ? Bh(this, n, t, i) : Gh(this, n, t, i);
  }
}
class b8 {
  constructor(e) {
    this.spec = e;
  }
}
function Gh(r, e, t, i) {
  return new Gf(e.doc, r.unquoted, t, i, r.caseSensitive ? void 0 : (n) => n.toLowerCase(), r.wholeWord ? Fxe(e.doc, e.charCategorizer(e.selection.main.head)) : void 0);
}
function Fxe(r, e) {
  return (t, i, n, a) => ((a > t || a + n.length < i) && (a = Math.max(0, t - 2), n = r.sliceString(a, Math.min(r.length, i + 2))), (e(ES(n, t - a)) != Mt.Word || e(bS(n, t - a)) != Mt.Word) && (e(bS(n, i - a)) != Mt.Word || e(ES(n, i - a)) != Mt.Word));
}
class Xxe extends b8 {
  constructor(e) {
    super(e);
  }
  nextMatch(e, t, i) {
    let n = Gh(this.spec, e, i, e.doc.length).nextOverlapping();
    return n.done && (n = Gh(this.spec, e, 0, t).nextOverlapping()), n.done ? null : n.value;
  }
  // Searching in reverse is, rather than implementing an inverted search
  // cursor, done by scanning chunk after chunk forward.
  prevMatchInRange(e, t, i) {
    for (let n = i; ; ) {
      let a = Math.max(t, n - 1e4 - this.spec.unquoted.length), o = Gh(this.spec, e, a, n), s = null;
      for (; !o.nextOverlapping().done; )
        s = o.value;
      if (s)
        return s;
      if (a == t)
        return null;
      n -= 1e4;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace);
  }
  matchAll(e, t) {
    let i = Gh(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let a = Gh(this.spec, e, Math.max(0, t - this.spec.unquoted.length), Math.min(i + this.spec.unquoted.length, e.doc.length));
    for (; !a.next().done; )
      n(a.value.from, a.value.to);
  }
}
function Bh(r, e, t, i) {
  return new v8(e.doc, r.search, {
    ignoreCase: !r.caseSensitive,
    test: r.wholeWord ? Yxe(e.charCategorizer(e.selection.main.head)) : void 0
  }, t, i);
}
function ES(r, e) {
  return r.slice(vi(r, e, !1), e);
}
function bS(r, e) {
  return r.slice(e, vi(r, e));
}
function Yxe(r) {
  return (e, t, i) => !i[0].length || (r(ES(i.input, i.index)) != Mt.Word || r(bS(i.input, i.index)) != Mt.Word) && (r(bS(i.input, i.index + i[0].length)) != Mt.Word || r(ES(i.input, i.index + i[0].length)) != Mt.Word);
}
class Hxe extends b8 {
  nextMatch(e, t, i) {
    let n = Bh(this.spec, e, i, e.doc.length).next();
    return n.done && (n = Bh(this.spec, e, 0, t).next()), n.done ? null : n.value;
  }
  prevMatchInRange(e, t, i) {
    for (let n = 1; ; n++) {
      let a = Math.max(
        t,
        i - n * 1e4
        /* ChunkSize */
      ), o = Bh(this.spec, e, a, i), s = null;
      for (; !o.next().done; )
        s = o.value;
      if (s && (a == t || s.from > a + 10))
        return s;
      if (a == t)
        return null;
    }
  }
  prevMatch(e, t, i) {
    return this.prevMatchInRange(e, 0, t) || this.prevMatchInRange(e, i, e.doc.length);
  }
  getReplacement(e) {
    return this.spec.unquote(this.spec.replace.replace(/\$([$&\d+])/g, (t, i) => i == "$" ? "$" : i == "&" ? e.match[0] : i != "0" && +i < e.match.length ? e.match[i] : t));
  }
  matchAll(e, t) {
    let i = Bh(this.spec, e, 0, e.doc.length), n = [];
    for (; !i.next().done; ) {
      if (n.length >= t)
        return null;
      n.push(i.value);
    }
    return n;
  }
  highlight(e, t, i, n) {
    let a = Bh(this.spec, e, Math.max(
      0,
      t - 250
      /* HighlightMargin */
    ), Math.min(i + 250, e.doc.length));
    for (; !a.next().done; )
      n(a.value.from, a.value.to);
  }
}
const lv = /* @__PURE__ */ lt.define(), dP = /* @__PURE__ */ lt.define(), Ol = /* @__PURE__ */ Br.define({
  create(r) {
    return new wA(lw(r).create(), null);
  },
  update(r, e) {
    for (let t of e.effects)
      t.is(lv) ? r = new wA(t.value.create(), r.panel) : t.is(dP) && (r = new wA(r.query, t.value ? pP : null));
    return r;
  },
  provide: (r) => av.from(r, (e) => e.panel)
});
class wA {
  constructor(e, t) {
    this.query = e, this.panel = t;
  }
}
const Wxe = /* @__PURE__ */ Xe.mark({ class: "cm-searchMatch" }), zxe = /* @__PURE__ */ Xe.mark({ class: "cm-searchMatch cm-searchMatch-selected" }), Zxe = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.view = r, this.decorations = this.highlight(r.state.field(Ol));
  }
  update(r) {
    let e = r.state.field(Ol);
    (e != r.startState.field(Ol) || r.docChanged || r.selectionSet || r.viewportChanged) && (this.decorations = this.highlight(e));
  }
  highlight({ query: r, panel: e }) {
    if (!e || !r.spec.valid)
      return Xe.none;
    let { view: t } = this, i = new Ul();
    for (let n = 0, a = t.visibleRanges, o = a.length; n < o; n++) {
      let { from: s, to: l } = a[n];
      for (; n < o - 1 && l > a[n + 1].from - 2 * 250; )
        l = a[++n].to;
      r.highlight(t.state, s, l, (u, c) => {
        let h = t.state.selection.ranges.some((f) => f.from == u && f.to == c);
        i.add(u, c, h ? zxe : Wxe);
      });
    }
    return i.finish();
  }
}, {
  decorations: (r) => r.decorations
});
function qv(r) {
  return (e) => {
    let t = e.state.field(Ol, !1);
    return t && t.query.spec.valid ? r(e, t) : y8(e);
  };
}
const SS = /* @__PURE__ */ qv((r, { query: e }) => {
  let { to: t } = r.state.selection.main, i = e.nextMatch(r.state, t, t);
  if (!i)
    return !1;
  let n = Z.single(i.from, i.to), a = r.state.facet(dd);
  return r.dispatch({
    selection: n,
    effects: [gP(r, i), a.scrollToMatch(n.main, r)],
    userEvent: "select.search"
  }), T8(r), !0;
}), TS = /* @__PURE__ */ qv((r, { query: e }) => {
  let { state: t } = r, { from: i } = t.selection.main, n = e.prevMatch(t, i, i);
  if (!n)
    return !1;
  let a = Z.single(n.from, n.to), o = r.state.facet(dd);
  return r.dispatch({
    selection: a,
    effects: [gP(r, n), o.scrollToMatch(a.main, r)],
    userEvent: "select.search"
  }), T8(r), !0;
}), qxe = /* @__PURE__ */ qv((r, { query: e }) => {
  let t = e.matchAll(r.state, 1e3);
  return !t || !t.length ? !1 : (r.dispatch({
    selection: Z.create(t.map((i) => Z.range(i.from, i.to))),
    userEvent: "select.search.matches"
  }), !0);
}), jxe = ({ state: r, dispatch: e }) => {
  let t = r.selection;
  if (t.ranges.length > 1 || t.main.empty)
    return !1;
  let { from: i, to: n } = t.main, a = [], o = 0;
  for (let s = new Gf(r.doc, r.sliceDoc(i, n)); !s.next().done; ) {
    if (a.length > 1e3)
      return !1;
    s.value.from == i && (o = a.length), a.push(Z.range(s.value.from, s.value.to));
  }
  return e(r.update({
    selection: Z.create(a, o),
    userEvent: "select.search.matches"
  })), !0;
}, UG = /* @__PURE__ */ qv((r, { query: e }) => {
  let { state: t } = r, { from: i, to: n } = t.selection.main;
  if (t.readOnly)
    return !1;
  let a = e.nextMatch(t, i, i);
  if (!a)
    return !1;
  let o = [], s, l, u = [];
  if (a.from == i && a.to == n && (l = t.toText(e.getReplacement(a)), o.push({ from: a.from, to: a.to, insert: l }), a = e.nextMatch(t, a.from, a.to), u.push(me.announce.of(t.phrase("replaced match on line $", t.doc.lineAt(i).number) + "."))), a) {
    let c = o.length == 0 || o[0].from >= a.to ? 0 : a.to - a.from - l.length;
    s = Z.single(a.from - c, a.to - c), u.push(gP(r, a)), u.push(t.facet(dd).scrollToMatch(s.main, r));
  }
  return r.dispatch({
    changes: o,
    selection: s,
    effects: u,
    userEvent: "input.replace"
  }), !0;
}), Kxe = /* @__PURE__ */ qv((r, { query: e }) => {
  if (r.state.readOnly)
    return !1;
  let t = e.matchAll(r.state, 1e9).map((n) => {
    let { from: a, to: o } = n;
    return { from: a, to: o, insert: e.getReplacement(n) };
  });
  if (!t.length)
    return !1;
  let i = r.state.phrase("replaced $ matches", t.length) + ".";
  return r.dispatch({
    changes: t,
    effects: me.announce.of(i),
    userEvent: "input.replace.all"
  }), !0;
});
function pP(r) {
  return r.state.facet(dd).createPanel(r);
}
function lw(r, e) {
  var t, i, n, a, o;
  let s = r.selection.main, l = s.empty || s.to > s.from + 100 ? "" : r.sliceDoc(s.from, s.to);
  if (e && !l)
    return e;
  let u = r.facet(dd);
  return new E8({
    search: ((t = e == null ? void 0 : e.literal) !== null && t !== void 0 ? t : u.literal) ? l : l.replace(/\n/g, "\\n"),
    caseSensitive: (i = e == null ? void 0 : e.caseSensitive) !== null && i !== void 0 ? i : u.caseSensitive,
    literal: (n = e == null ? void 0 : e.literal) !== null && n !== void 0 ? n : u.literal,
    regexp: (a = e == null ? void 0 : e.regexp) !== null && a !== void 0 ? a : u.regexp,
    wholeWord: (o = e == null ? void 0 : e.wholeWord) !== null && o !== void 0 ? o : u.wholeWord
  });
}
function S8(r) {
  let e = nv(r, pP);
  return e && e.dom.querySelector("[main-field]");
}
function T8(r) {
  let e = S8(r);
  e && e == r.root.activeElement && e.select();
}
const y8 = (r) => {
  let e = r.state.field(Ol, !1);
  if (e && e.panel) {
    let t = S8(r);
    if (t && t != r.root.activeElement) {
      let i = lw(r.state, e.query.spec);
      i.valid && r.dispatch({ effects: lv.of(i) }), t.focus(), t.select();
    }
  } else
    r.dispatch({ effects: [
      dP.of(!0),
      e ? lv.of(lw(r.state, e.query.spec)) : lt.appendConfig.of(rPe)
    ] });
  return !0;
}, R8 = (r) => {
  let e = r.state.field(Ol, !1);
  if (!e || !e.panel)
    return !1;
  let t = nv(r, pP);
  return t && t.dom.contains(r.root.activeElement) && r.focus(), r.dispatch({ effects: dP.of(!1) }), !0;
}, Jxe = [
  { key: "Mod-f", run: y8, scope: "editor search-panel" },
  { key: "F3", run: SS, shift: TS, scope: "editor search-panel", preventDefault: !0 },
  { key: "Mod-g", run: SS, shift: TS, scope: "editor search-panel", preventDefault: !0 },
  { key: "Escape", run: R8, scope: "editor search-panel" },
  { key: "Mod-Shift-l", run: jxe },
  { key: "Alt-g", run: xxe },
  { key: "Mod-d", run: Bxe, preventDefault: !0 }
];
class ePe {
  constructor(e) {
    this.view = e;
    let t = this.query = e.state.field(Ol).query.spec;
    this.commit = this.commit.bind(this), this.searchField = Ft("input", {
      value: t.search,
      placeholder: sn(e, "Find"),
      "aria-label": sn(e, "Find"),
      class: "cm-textfield",
      name: "search",
      form: "",
      "main-field": "true",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.replaceField = Ft("input", {
      value: t.replace,
      placeholder: sn(e, "Replace"),
      "aria-label": sn(e, "Replace"),
      class: "cm-textfield",
      name: "replace",
      form: "",
      onchange: this.commit,
      onkeyup: this.commit
    }), this.caseField = Ft("input", {
      type: "checkbox",
      name: "case",
      form: "",
      checked: t.caseSensitive,
      onchange: this.commit
    }), this.reField = Ft("input", {
      type: "checkbox",
      name: "re",
      form: "",
      checked: t.regexp,
      onchange: this.commit
    }), this.wordField = Ft("input", {
      type: "checkbox",
      name: "word",
      form: "",
      checked: t.wholeWord,
      onchange: this.commit
    });
    function i(n, a, o) {
      return Ft("button", { class: "cm-button", name: n, onclick: a, type: "button" }, o);
    }
    this.dom = Ft("div", { onkeydown: (n) => this.keydown(n), class: "cm-search" }, [
      this.searchField,
      i("next", () => SS(e), [sn(e, "next")]),
      i("prev", () => TS(e), [sn(e, "previous")]),
      i("select", () => qxe(e), [sn(e, "all")]),
      Ft("label", null, [this.caseField, sn(e, "match case")]),
      Ft("label", null, [this.reField, sn(e, "regexp")]),
      Ft("label", null, [this.wordField, sn(e, "by word")]),
      ...e.state.readOnly ? [] : [
        Ft("br"),
        this.replaceField,
        i("replace", () => UG(e), [sn(e, "replace")]),
        i("replaceAll", () => Kxe(e), [sn(e, "replace all")])
      ],
      Ft("button", {
        name: "close",
        onclick: () => R8(e),
        "aria-label": sn(e, "close"),
        type: "button"
      }, [""])
    ]);
  }
  commit() {
    let e = new E8({
      search: this.searchField.value,
      caseSensitive: this.caseField.checked,
      regexp: this.reField.checked,
      wholeWord: this.wordField.checked,
      replace: this.replaceField.value
    });
    e.eq(this.query) || (this.query = e, this.view.dispatch({ effects: lv.of(e) }));
  }
  keydown(e) {
    Gwe(this.view, e, "search-panel") ? e.preventDefault() : e.keyCode == 13 && e.target == this.searchField ? (e.preventDefault(), (e.shiftKey ? TS : SS)(this.view)) : e.keyCode == 13 && e.target == this.replaceField && (e.preventDefault(), UG(this.view));
  }
  update(e) {
    for (let t of e.transactions)
      for (let i of t.effects)
        i.is(lv) && !i.value.eq(this.query) && this.setQuery(i.value);
  }
  setQuery(e) {
    this.query = e, this.searchField.value = e.search, this.replaceField.value = e.replace, this.caseField.checked = e.caseSensitive, this.reField.checked = e.regexp, this.wordField.checked = e.wholeWord;
  }
  mount() {
    this.searchField.select();
  }
  get pos() {
    return 80;
  }
  get top() {
    return this.view.state.facet(dd).top;
  }
}
function sn(r, e) {
  return r.state.phrase(e);
}
const Lm = 30, Dm = /[\s\.,:;?!]/;
function gP(r, { from: e, to: t }) {
  let i = r.state.doc.lineAt(e), n = r.state.doc.lineAt(t).to, a = Math.max(i.from, e - Lm), o = Math.min(n, t + Lm), s = r.state.sliceDoc(a, o);
  if (a != i.from) {
    for (let l = 0; l < Lm; l++)
      if (!Dm.test(s[l + 1]) && Dm.test(s[l])) {
        s = s.slice(l);
        break;
      }
  }
  if (o != n) {
    for (let l = s.length - 1; l > s.length - Lm; l--)
      if (!Dm.test(s[l - 1]) && Dm.test(s[l])) {
        s = s.slice(0, l);
        break;
      }
  }
  return me.announce.of(`${r.state.phrase("current match")}. ${s} ${r.state.phrase("on line")} ${i.number}.`);
}
const tPe = /* @__PURE__ */ me.baseTheme({
  ".cm-panel.cm-search": {
    padding: "2px 6px 4px",
    position: "relative",
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "4px",
      backgroundColor: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    },
    "& input, & button, & label": {
      margin: ".2em .6em .2em 0"
    },
    "& input[type=checkbox]": {
      marginRight: ".2em"
    },
    "& label": {
      fontSize: "80%",
      whiteSpace: "pre"
    }
  },
  "&light .cm-searchMatch": { backgroundColor: "#ffff0054" },
  "&dark .cm-searchMatch": { backgroundColor: "#00ffff8a" },
  "&light .cm-searchMatch-selected": { backgroundColor: "#ff6a0054" },
  "&dark .cm-searchMatch-selected": { backgroundColor: "#ff00ff8a" }
}), rPe = [
  Ol,
  /* @__PURE__ */ th.lowest(Zxe),
  tPe
];
class A8 {
  /**
  Create a new completion context. (Mostly useful for testing
  completion sourcesin the editor, the extension will create
  these for you.)
  */
  constructor(e, t, i) {
    this.state = e, this.pos = t, this.explicit = i, this.abortListeners = [];
  }
  /**
  Get the extent, content, and (if there is a token) type of the
  token before `this.pos`.
  */
  tokenBefore(e) {
    let t = Kt(this.state).resolveInner(this.pos, -1);
    for (; t && e.indexOf(t.name) < 0; )
      t = t.parent;
    return t ? {
      from: t.from,
      to: this.pos,
      text: this.state.sliceDoc(t.from, this.pos),
      type: t.type
    } : null;
  }
  /**
  Get the match of the given expression directly before the
  cursor.
  */
  matchBefore(e) {
    let t = this.state.doc.lineAt(this.pos), i = Math.max(t.from, this.pos - 250), n = t.text.slice(i - t.from, this.pos - t.from), a = n.search(_8(e, !1));
    return a < 0 ? null : { from: i + a, to: this.pos, text: n.slice(a) };
  }
  /**
  Yields true when the query has been aborted. Can be useful in
  asynchronous queries to avoid doing work that will be ignored.
  */
  get aborted() {
    return this.abortListeners == null;
  }
  /**
  Allows you to register abort handlers, which will be called when
  the query is
  [aborted](https://codemirror.net/6/docs/ref/#autocomplete.CompletionContext.aborted).
  */
  addEventListener(e, t) {
    e == "abort" && this.abortListeners && this.abortListeners.push(t);
  }
}
function $G(r) {
  let e = Object.keys(r).join(""), t = /\w/.test(e);
  return t && (e = e.replace(/\w/g, "")), `[${t ? "\\w" : ""}${e.replace(/[^\w\s]/g, "\\$&")}]`;
}
function iPe(r) {
  let e = /* @__PURE__ */ Object.create(null), t = /* @__PURE__ */ Object.create(null);
  for (let { label: n } of r) {
    e[n[0]] = !0;
    for (let a = 1; a < n.length; a++)
      t[n[a]] = !0;
  }
  let i = $G(e) + $G(t) + "*$";
  return [new RegExp("^" + i), new RegExp(i)];
}
function uy(r) {
  let e = r.map((n) => typeof n == "string" ? { label: n } : n), [t, i] = e.every((n) => /^\w+$/.test(n.label)) ? [/\w*$/, /\w+$/] : iPe(e);
  return (n) => {
    let a = n.matchBefore(i);
    return a || n.explicit ? { from: a ? a.from : n.pos, options: e, validFor: t } : null;
  };
}
function vP(r, e) {
  return (t) => {
    for (let i = Kt(t.state).resolveInner(t.pos, -1); i; i = i.parent) {
      if (r.indexOf(i.name) > -1)
        return null;
      if (i.type.isTop)
        break;
    }
    return e(t);
  };
}
class VG {
  constructor(e, t, i, n) {
    this.completion = e, this.source = t, this.match = i, this.score = n;
  }
}
function ml(r) {
  return r.selection.main.from;
}
function _8(r, e) {
  var t;
  let { source: i } = r, n = e && i[0] != "^", a = i[i.length - 1] != "$";
  return !n && !a ? r : new RegExp(`${n ? "^" : ""}(?:${i})${a ? "$" : ""}`, (t = r.flags) !== null && t !== void 0 ? t : r.ignoreCase ? "i" : "");
}
const C8 = /* @__PURE__ */ ys.define();
function nPe(r, e, t, i) {
  let { main: n } = r.selection, a = t - n.from, o = i - n.from;
  return Object.assign(Object.assign({}, r.changeByRange((s) => s != n && t != i && r.sliceDoc(s.from + a, s.from + o) != r.sliceDoc(t, i) ? { range: s } : {
    changes: { from: s.from + a, to: i == n.from ? s.to : s.from + o, insert: e },
    range: Z.cursor(s.from + a + e.length)
  })), { userEvent: "input.complete" });
}
const GG = /* @__PURE__ */ new WeakMap();
function aPe(r) {
  if (!Array.isArray(r))
    return r;
  let e = GG.get(r);
  return e || GG.set(r, e = uy(r)), e;
}
const OP = /* @__PURE__ */ lt.define(), uv = /* @__PURE__ */ lt.define();
class oPe {
  constructor(e) {
    this.pattern = e, this.chars = [], this.folded = [], this.any = [], this.precise = [], this.byWord = [], this.score = 0, this.matched = [];
    for (let t = 0; t < e.length; ) {
      let i = Zr(e, t), n = Hn(i);
      this.chars.push(i);
      let a = e.slice(t, t + n), o = a.toUpperCase();
      this.folded.push(Zr(o == a ? a.toLowerCase() : o, 0)), t += n;
    }
    this.astral = e.length != this.chars.length;
  }
  ret(e, t) {
    return this.score = e, this.matched = t, !0;
  }
  // Matches a given word (completion) against the pattern (input).
  // Will return a boolean indicating whether there was a match and,
  // on success, set `this.score` to the score, `this.matched` to an
  // array of `from, to` pairs indicating the matched parts of `word`.
  //
  // The score is a number that is more negative the worse the match
  // is. See `Penalty` above.
  match(e) {
    if (this.pattern.length == 0)
      return this.ret(-100, []);
    if (e.length < this.pattern.length)
      return !1;
    let { chars: t, folded: i, any: n, precise: a, byWord: o } = this;
    if (t.length == 1) {
      let m = Zr(e, 0), E = Hn(m), b = E == e.length ? 0 : -100;
      if (m != t[0])
        if (m == i[0])
          b += -200;
        else
          return !1;
      return this.ret(b, [0, E]);
    }
    let s = e.indexOf(this.pattern);
    if (s == 0)
      return this.ret(e.length == this.pattern.length ? 0 : -100, [0, this.pattern.length]);
    let l = t.length, u = 0;
    if (s < 0) {
      for (let m = 0, E = Math.min(e.length, 200); m < E && u < l; ) {
        let b = Zr(e, m);
        (b == t[u] || b == i[u]) && (n[u++] = m), m += Hn(b);
      }
      if (u < l)
        return !1;
    }
    let c = 0, h = 0, f = !1, d = 0, p = -1, g = -1, v = /[a-z]/.test(e), O = !0;
    for (let m = 0, E = Math.min(e.length, 200), b = 0; m < E && h < l; ) {
      let S = Zr(e, m);
      s < 0 && (c < l && S == t[c] && (a[c++] = m), d < l && (S == t[d] || S == i[d] ? (d == 0 && (p = m), g = m + 1, d++) : d = 0));
      let T, y = S < 255 ? S >= 48 && S <= 57 || S >= 97 && S <= 122 ? 2 : S >= 65 && S <= 90 ? 1 : 0 : (T = xx(S)) != T.toLowerCase() ? 1 : T != T.toUpperCase() ? 2 : 0;
      (!m || y == 1 && v || b == 0 && y != 0) && (t[h] == S || i[h] == S && (f = !0) ? o[h++] = m : o.length && (O = !1)), b = y, m += Hn(S);
    }
    return h == l && o[0] == 0 && O ? this.result(-100 + (f ? -200 : 0), o, e) : d == l && p == 0 ? this.ret(-200 - e.length + (g == e.length ? 0 : -100), [0, g]) : s > -1 ? this.ret(-700 - e.length, [s, s + this.pattern.length]) : d == l ? this.ret(-200 + -700 - e.length, [p, g]) : h == l ? this.result(-100 + (f ? -200 : 0) + -700 + (O ? 0 : -1100), o, e) : t.length == 2 ? !1 : this.result((n[0] ? -700 : 0) + -200 + -1100, n, e);
  }
  result(e, t, i) {
    let n = [], a = 0;
    for (let o of t) {
      let s = o + (this.astral ? Hn(Zr(i, o)) : 1);
      a && n[a - 1] == o ? n[a - 1] = s : (n[a++] = o, n[a++] = s);
    }
    return this.ret(e - i.length, n);
  }
}
const Ji = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Lo(r, {
      activateOnTyping: !0,
      selectOnOpen: !0,
      override: null,
      closeOnBlur: !0,
      maxRenderedOptions: 100,
      defaultKeymap: !0,
      tooltipClass: () => "",
      optionClass: () => "",
      aboveCursor: !1,
      icons: !0,
      addToOptions: [],
      positionInfo: sPe,
      compareCompletions: (e, t) => e.label.localeCompare(t.label),
      interactionDelay: 75
    }, {
      defaultKeymap: (e, t) => e && t,
      closeOnBlur: (e, t) => e && t,
      icons: (e, t) => e && t,
      tooltipClass: (e, t) => (i) => BG(e(i), t(i)),
      optionClass: (e, t) => (i) => BG(e(i), t(i)),
      addToOptions: (e, t) => e.concat(t)
    });
  }
});
function BG(r, e) {
  return r ? e ? r + " " + e : r : e;
}
function sPe(r, e, t, i, n) {
  let a = r.textDirection == ir.RTL, o = a, s = !1, l = "top", u, c, h = e.left - n.left, f = n.right - e.right, d = i.right - i.left, p = i.bottom - i.top;
  if (o && h < Math.min(d, f) ? o = !1 : !o && f < Math.min(d, h) && (o = !0), d <= (o ? h : f))
    u = Math.max(n.top, Math.min(t.top, n.bottom - p)) - e.top, c = Math.min(400, o ? h : f);
  else {
    s = !0, c = Math.min(
      400,
      (a ? e.right : n.right - e.left) - 30
      /* Margin */
    );
    let g = n.bottom - e.bottom;
    g >= p || g > e.top ? u = t.bottom - e.top : (l = "bottom", u = e.bottom - t.top);
  }
  return {
    style: `${l}: ${u}px; max-width: ${c}px`,
    class: "cm-completionInfo-" + (s ? a ? "left-narrow" : "right-narrow" : o ? "left" : "right")
  };
}
function lPe(r) {
  let e = r.addToOptions.slice();
  return r.icons && e.push({
    render(t) {
      let i = document.createElement("div");
      return i.classList.add("cm-completionIcon"), t.type && i.classList.add(...t.type.split(/\s+/g).map((n) => "cm-completionIcon-" + n)), i.setAttribute("aria-hidden", "true"), i;
    },
    position: 20
  }), e.push({
    render(t, i, n) {
      let a = document.createElement("span");
      a.className = "cm-completionLabel";
      let o = t.displayLabel || t.label, s = 0;
      for (let l = 0; l < n.length; ) {
        let u = n[l++], c = n[l++];
        u > s && a.appendChild(document.createTextNode(o.slice(s, u)));
        let h = a.appendChild(document.createElement("span"));
        h.appendChild(document.createTextNode(o.slice(u, c))), h.className = "cm-completionMatchedText", s = c;
      }
      return s < o.length && a.appendChild(document.createTextNode(o.slice(s))), a;
    },
    position: 50
  }, {
    render(t) {
      if (!t.detail)
        return null;
      let i = document.createElement("span");
      return i.className = "cm-completionDetail", i.textContent = t.detail, i;
    },
    position: 80
  }), e.sort((t, i) => t.position - i.position).map((t) => t.render);
}
function FG(r, e, t) {
  if (r <= t)
    return { from: 0, to: r };
  if (e < 0 && (e = 0), e <= r >> 1) {
    let n = Math.floor(e / t);
    return { from: n * t, to: (n + 1) * t };
  }
  let i = Math.floor((r - e) / t);
  return { from: r - (i + 1) * t, to: r - i * t };
}
class uPe {
  constructor(e, t, i) {
    this.view = e, this.stateField = t, this.applyCompletion = i, this.info = null, this.infoDestroy = null, this.placeInfoReq = {
      read: () => this.measureInfo(),
      write: (l) => this.placeInfo(l),
      key: this
    }, this.space = null, this.currentClass = "";
    let n = e.state.field(t), { options: a, selected: o } = n.open, s = e.state.facet(Ji);
    this.optionContent = lPe(s), this.optionClass = s.optionClass, this.tooltipClass = s.tooltipClass, this.range = FG(a.length, o, s.maxRenderedOptions), this.dom = document.createElement("div"), this.dom.className = "cm-tooltip-autocomplete", this.updateTooltipClass(e.state), this.dom.addEventListener("mousedown", (l) => {
      for (let u = l.target, c; u && u != this.dom; u = u.parentNode)
        if (u.nodeName == "LI" && (c = /-(\d+)$/.exec(u.id)) && +c[1] < a.length) {
          this.applyCompletion(e, a[+c[1]]), l.preventDefault();
          return;
        }
    }), this.dom.addEventListener("focusout", (l) => {
      let u = e.state.field(this.stateField, !1);
      u && u.tooltip && e.state.facet(Ji).closeOnBlur && l.relatedTarget != e.contentDOM && e.dispatch({ effects: uv.of(null) });
    }), this.list = this.dom.appendChild(this.createListBox(a, n.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    });
  }
  mount() {
    this.updateSel();
  }
  update(e) {
    var t, i, n;
    let a = e.state.field(this.stateField), o = e.startState.field(this.stateField);
    this.updateTooltipClass(e.state), a != o && (this.updateSel(), ((t = a.open) === null || t === void 0 ? void 0 : t.disabled) != ((i = o.open) === null || i === void 0 ? void 0 : i.disabled) && this.dom.classList.toggle("cm-tooltip-autocomplete-disabled", !!(!((n = a.open) === null || n === void 0) && n.disabled)));
  }
  updateTooltipClass(e) {
    let t = this.tooltipClass(e);
    if (t != this.currentClass) {
      for (let i of this.currentClass.split(" "))
        i && this.dom.classList.remove(i);
      for (let i of t.split(" "))
        i && this.dom.classList.add(i);
      this.currentClass = t;
    }
  }
  positioned(e) {
    this.space = e, this.info && this.view.requestMeasure(this.placeInfoReq);
  }
  updateSel() {
    let e = this.view.state.field(this.stateField), t = e.open;
    if ((t.selected > -1 && t.selected < this.range.from || t.selected >= this.range.to) && (this.range = FG(t.options.length, t.selected, this.view.state.facet(Ji).maxRenderedOptions), this.list.remove(), this.list = this.dom.appendChild(this.createListBox(t.options, e.id, this.range)), this.list.addEventListener("scroll", () => {
      this.info && this.view.requestMeasure(this.placeInfoReq);
    })), this.updateSelectedOption(t.selected)) {
      this.destroyInfo();
      let { completion: i } = t.options[t.selected], { info: n } = i;
      if (!n)
        return;
      let a = typeof n == "string" ? document.createTextNode(n) : n(i);
      if (!a)
        return;
      "then" in a ? a.then((o) => {
        o && this.view.state.field(this.stateField, !1) == e && this.addInfoPane(o, i);
      }).catch((o) => ea(this.view.state, o, "completion info")) : this.addInfoPane(a, i);
    }
  }
  addInfoPane(e, t) {
    this.destroyInfo();
    let i = this.info = document.createElement("div");
    if (i.className = "cm-tooltip cm-completionInfo", e.nodeType != null)
      i.appendChild(e), this.infoDestroy = null;
    else {
      let { dom: n, destroy: a } = e;
      i.appendChild(n), this.infoDestroy = a || null;
    }
    this.dom.appendChild(i), this.view.requestMeasure(this.placeInfoReq);
  }
  updateSelectedOption(e) {
    let t = null;
    for (let i = this.list.firstChild, n = this.range.from; i; i = i.nextSibling, n++)
      i.nodeName != "LI" || !i.id ? n-- : n == e ? i.hasAttribute("aria-selected") || (i.setAttribute("aria-selected", "true"), t = i) : i.hasAttribute("aria-selected") && i.removeAttribute("aria-selected");
    return t && hPe(this.list, t), t;
  }
  measureInfo() {
    let e = this.dom.querySelector("[aria-selected]");
    if (!e || !this.info)
      return null;
    let t = this.dom.getBoundingClientRect(), i = this.info.getBoundingClientRect(), n = e.getBoundingClientRect(), a = this.space;
    if (!a) {
      let o = this.dom.ownerDocument.defaultView || window;
      a = { left: 0, top: 0, right: o.innerWidth, bottom: o.innerHeight };
    }
    return n.top > Math.min(a.bottom, t.bottom) - 10 || n.bottom < Math.max(a.top, t.top) + 10 ? null : this.view.state.facet(Ji).positionInfo(this.view, t, n, i, a);
  }
  placeInfo(e) {
    this.info && (e ? (e.style && (this.info.style.cssText = e.style), this.info.className = "cm-tooltip cm-completionInfo " + (e.class || "")) : this.info.style.cssText = "top: -1e6px");
  }
  createListBox(e, t, i) {
    const n = document.createElement("ul");
    n.id = t, n.setAttribute("role", "listbox"), n.setAttribute("aria-expanded", "true"), n.setAttribute("aria-label", this.view.state.phrase("Completions"));
    let a = null;
    for (let o = i.from; o < i.to; o++) {
      let { completion: s, match: l } = e[o], { section: u } = s;
      if (u) {
        let f = typeof u == "string" ? u : u.name;
        if (f != a && (o > i.from || i.from == 0))
          if (a = f, typeof u != "string" && u.header)
            n.appendChild(u.header(u));
          else {
            let d = n.appendChild(document.createElement("completion-section"));
            d.textContent = f;
          }
      }
      const c = n.appendChild(document.createElement("li"));
      c.id = t + "-" + o, c.setAttribute("role", "option");
      let h = this.optionClass(s);
      h && (c.className = h);
      for (let f of this.optionContent) {
        let d = f(s, this.view.state, l);
        d && c.appendChild(d);
      }
    }
    return i.from && n.classList.add("cm-completionListIncompleteTop"), i.to < e.length && n.classList.add("cm-completionListIncompleteBottom"), n;
  }
  destroyInfo() {
    this.info && (this.infoDestroy && this.infoDestroy(), this.info.remove(), this.info = null);
  }
  destroy() {
    this.destroyInfo();
  }
}
function cPe(r, e) {
  return (t) => new uPe(t, r, e);
}
function hPe(r, e) {
  let t = r.getBoundingClientRect(), i = e.getBoundingClientRect();
  i.top < t.top ? r.scrollTop -= t.top - i.top : i.bottom > t.bottom && (r.scrollTop += i.bottom - t.bottom);
}
function XG(r) {
  return (r.boost || 0) * 100 + (r.apply ? 10 : 0) + (r.info ? 5 : 0) + (r.type ? 1 : 0);
}
function fPe(r, e) {
  let t = [], i = null, n = (l) => {
    t.push(l);
    let { section: u } = l.completion;
    if (u) {
      i || (i = []);
      let c = typeof u == "string" ? u : u.name;
      i.some((h) => h.name == c) || i.push(typeof u == "string" ? { name: c } : u);
    }
  };
  for (let l of r)
    if (l.hasResult()) {
      let u = l.result.getMatch;
      if (l.result.filter === !1)
        for (let c of l.result.options)
          n(new VG(c, l.source, u ? u(c) : [], 1e9 - t.length));
      else {
        let c = new oPe(e.sliceDoc(l.from, l.to));
        for (let h of l.result.options)
          if (c.match(h.label)) {
            let f = h.displayLabel ? u ? u(h, c.matched) : [] : c.matched;
            n(new VG(h, l.source, f, c.score + (h.boost || 0)));
          }
      }
    }
  if (i) {
    let l = /* @__PURE__ */ Object.create(null), u = 0, c = (h, f) => {
      var d, p;
      return ((d = h.rank) !== null && d !== void 0 ? d : 1e9) - ((p = f.rank) !== null && p !== void 0 ? p : 1e9) || (h.name < f.name ? -1 : 1);
    };
    for (let h of i.sort(c))
      u -= 1e5, l[h.name] = u;
    for (let h of t) {
      let { section: f } = h.completion;
      f && (h.score += l[typeof f == "string" ? f : f.name]);
    }
  }
  let a = [], o = null, s = e.facet(Ji).compareCompletions;
  for (let l of t.sort((u, c) => c.score - u.score || s(u.completion, c.completion))) {
    let u = l.completion;
    !o || o.label != u.label || o.detail != u.detail || o.type != null && u.type != null && o.type != u.type || o.apply != u.apply || o.boost != u.boost ? a.push(l) : XG(l.completion) > XG(o) && (a[a.length - 1] = l), o = l.completion;
  }
  return a;
}
class Jh {
  constructor(e, t, i, n, a, o) {
    this.options = e, this.attrs = t, this.tooltip = i, this.timestamp = n, this.selected = a, this.disabled = o;
  }
  setSelected(e, t) {
    return e == this.selected || e >= this.options.length ? this : new Jh(this.options, YG(t, e), this.tooltip, this.timestamp, e, this.disabled);
  }
  static build(e, t, i, n, a) {
    let o = fPe(e, t);
    if (!o.length)
      return n && e.some(
        (l) => l.state == 1
        /* Pending */
      ) ? new Jh(n.options, n.attrs, n.tooltip, n.timestamp, n.selected, !0) : null;
    let s = t.facet(Ji).selectOnOpen ? 0 : -1;
    if (n && n.selected != s && n.selected != -1) {
      let l = n.options[n.selected].completion;
      for (let u = 0; u < o.length; u++)
        if (o[u].completion == l) {
          s = u;
          break;
        }
    }
    return new Jh(o, YG(i, s), {
      pos: e.reduce((l, u) => u.hasResult() ? Math.min(l, u.from) : l, 1e8),
      create: cPe(gn, N8),
      above: a.aboveCursor
    }, n ? n.timestamp : Date.now(), s, !1);
  }
  map(e) {
    return new Jh(this.options, this.attrs, Object.assign(Object.assign({}, this.tooltip), { pos: e.mapPos(this.tooltip.pos) }), this.timestamp, this.selected, this.disabled);
  }
}
class yS {
  constructor(e, t, i) {
    this.active = e, this.id = t, this.open = i;
  }
  static start() {
    return new yS(gPe, "cm-ac-" + Math.floor(Math.random() * 2e6).toString(36), null);
  }
  update(e) {
    let { state: t } = e, i = t.facet(Ji), a = (i.override || t.languageDataAt("autocomplete", ml(t)).map(aPe)).map((s) => (this.active.find((u) => u.source == s) || new zi(
      s,
      this.active.some(
        (u) => u.state != 0
        /* Inactive */
      ) ? 1 : 0
      /* Inactive */
    )).update(e, i));
    a.length == this.active.length && a.every((s, l) => s == this.active[l]) && (a = this.active);
    let o = this.open;
    o && e.docChanged && (o = o.map(e.changes)), e.selection || a.some((s) => s.hasResult() && e.changes.touchesRange(s.from, s.to)) || !dPe(a, this.active) ? o = Jh.build(a, t, this.id, o, i) : o && o.disabled && !a.some(
      (s) => s.state == 1
      /* Pending */
    ) && (o = null), !o && a.every(
      (s) => s.state != 1
      /* Pending */
    ) && a.some((s) => s.hasResult()) && (a = a.map((s) => s.hasResult() ? new zi(
      s.source,
      0
      /* Inactive */
    ) : s));
    for (let s of e.effects)
      s.is(w8) && (o = o && o.setSelected(s.value, this.id));
    return a == this.active && o == this.open ? this : new yS(a, this.id, o);
  }
  get tooltip() {
    return this.open ? this.open.tooltip : null;
  }
  get attrs() {
    return this.open ? this.open.attrs : pPe;
  }
}
function dPe(r, e) {
  if (r == e)
    return !0;
  for (let t = 0, i = 0; ; ) {
    for (; t < r.length && !r[t].hasResult; )
      t++;
    for (; i < e.length && !e[i].hasResult; )
      i++;
    let n = t == r.length, a = i == e.length;
    if (n || a)
      return n == a;
    if (r[t++].result != e[i++].result)
      return !1;
  }
}
const pPe = {
  "aria-autocomplete": "list"
};
function YG(r, e) {
  let t = {
    "aria-autocomplete": "list",
    "aria-haspopup": "listbox",
    "aria-controls": r
  };
  return e > -1 && (t["aria-activedescendant"] = r + "-" + e), t;
}
const gPe = [];
function uw(r) {
  return r.isUserEvent("input.type") ? "input" : r.isUserEvent("delete.backward") ? "delete" : null;
}
class zi {
  constructor(e, t, i = -1) {
    this.source = e, this.state = t, this.explicitPos = i;
  }
  hasResult() {
    return !1;
  }
  update(e, t) {
    let i = uw(e), n = this;
    i ? n = n.handleUserEvent(e, i, t) : e.docChanged ? n = n.handleChange(e) : e.selection && n.state != 0 && (n = new zi(
      n.source,
      0
      /* Inactive */
    ));
    for (let a of e.effects)
      if (a.is(OP))
        n = new zi(n.source, 1, a.value ? ml(e.state) : -1);
      else if (a.is(uv))
        n = new zi(
          n.source,
          0
          /* Inactive */
        );
      else if (a.is(I8))
        for (let o of a.value)
          o.source == n.source && (n = o);
    return n;
  }
  handleUserEvent(e, t, i) {
    return t == "delete" || !i.activateOnTyping ? this.map(e.changes) : new zi(
      this.source,
      1
      /* Pending */
    );
  }
  handleChange(e) {
    return e.changes.touchesRange(ml(e.startState)) ? new zi(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty || this.explicitPos < 0 ? this : new zi(this.source, this.state, e.mapPos(this.explicitPos));
  }
}
class vf extends zi {
  constructor(e, t, i, n, a) {
    super(e, 2, t), this.result = i, this.from = n, this.to = a;
  }
  hasResult() {
    return !0;
  }
  handleUserEvent(e, t, i) {
    var n;
    let a = e.changes.mapPos(this.from), o = e.changes.mapPos(this.to, 1), s = ml(e.state);
    if ((this.explicitPos < 0 ? s <= a : s < this.from) || s > o || t == "delete" && ml(e.startState) == this.from)
      return new zi(
        this.source,
        t == "input" && i.activateOnTyping ? 1 : 0
        /* Inactive */
      );
    let l = this.explicitPos < 0 ? -1 : e.changes.mapPos(this.explicitPos), u;
    return vPe(this.result.validFor, e.state, a, o) ? new vf(this.source, l, this.result, a, o) : this.result.update && (u = this.result.update(this.result, a, o, new A8(e.state, s, l >= 0))) ? new vf(this.source, l, u, u.from, (n = u.to) !== null && n !== void 0 ? n : ml(e.state)) : new zi(this.source, 1, l);
  }
  handleChange(e) {
    return e.changes.touchesRange(this.from, this.to) ? new zi(
      this.source,
      0
      /* Inactive */
    ) : this.map(e.changes);
  }
  map(e) {
    return e.empty ? this : new vf(this.source, this.explicitPos < 0 ? -1 : e.mapPos(this.explicitPos), this.result, e.mapPos(this.from), e.mapPos(this.to, 1));
  }
}
function vPe(r, e, t, i) {
  if (!r)
    return !1;
  let n = e.sliceDoc(t, i);
  return typeof r == "function" ? r(n, t, i, e) : _8(r, !0).test(n);
}
const I8 = /* @__PURE__ */ lt.define({
  map(r, e) {
    return r.map((t) => t.map(e));
  }
}), w8 = /* @__PURE__ */ lt.define(), gn = /* @__PURE__ */ Br.define({
  create() {
    return yS.start();
  },
  update(r, e) {
    return r.update(e);
  },
  provide: (r) => [
    Gx.from(r, (e) => e.tooltip),
    me.contentAttributes.from(r, (e) => e.attrs)
  ]
});
function N8(r, e) {
  const t = e.completion.apply || e.completion.label;
  let i = r.state.field(gn).active.find((n) => n.source == e.source);
  return i instanceof vf ? (typeof t == "string" ? r.dispatch(Object.assign(Object.assign({}, nPe(r.state, t, i.from, i.to)), { annotations: C8.of(e.completion) })) : t(r, e.completion, i.from, i.to), !0) : !1;
}
function Mm(r, e = "option") {
  return (t) => {
    let i = t.state.field(gn, !1);
    if (!i || !i.open || i.open.disabled || Date.now() - i.open.timestamp < t.state.facet(Ji).interactionDelay)
      return !1;
    let n = 1, a;
    e == "page" && (a = I6(t, i.open.tooltip)) && (n = Math.max(2, Math.floor(a.dom.offsetHeight / a.dom.querySelector("li").offsetHeight) - 1));
    let { length: o } = i.open.options, s = i.open.selected > -1 ? i.open.selected + n * (r ? 1 : -1) : r ? 0 : o - 1;
    return s < 0 ? s = e == "page" ? 0 : o - 1 : s >= o && (s = e == "page" ? o - 1 : 0), t.dispatch({ effects: w8.of(s) }), !0;
  };
}
const OPe = (r) => {
  let e = r.state.field(gn, !1);
  return r.state.readOnly || !e || !e.open || e.open.selected < 0 || e.open.disabled || Date.now() - e.open.timestamp < r.state.facet(Ji).interactionDelay ? !1 : N8(r, e.open.options[e.open.selected]);
}, mPe = (r) => r.state.field(gn, !1) ? (r.dispatch({ effects: OP.of(!0) }), !0) : !1, EPe = (r) => {
  let e = r.state.field(gn, !1);
  return !e || !e.active.some(
    (t) => t.state != 0
    /* Inactive */
  ) ? !1 : (r.dispatch({ effects: uv.of(null) }), !0);
};
class bPe {
  constructor(e, t) {
    this.active = e, this.context = t, this.time = Date.now(), this.updates = [], this.done = void 0;
  }
}
const HG = 50, SPe = 50, TPe = 1e3, yPe = /* @__PURE__ */ Ur.fromClass(class {
  constructor(r) {
    this.view = r, this.debounceUpdate = -1, this.running = [], this.debounceAccept = -1, this.composing = 0;
    for (let e of r.state.field(gn).active)
      e.state == 1 && this.startQuery(e);
  }
  update(r) {
    let e = r.state.field(gn);
    if (!r.selectionSet && !r.docChanged && r.startState.field(gn) == e)
      return;
    let t = r.transactions.some((i) => (i.selection || i.docChanged) && !uw(i));
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (t || n.updates.length + r.transactions.length > SPe && Date.now() - n.time > TPe) {
        for (let a of n.context.abortListeners)
          try {
            a();
          } catch (o) {
            ea(this.view.state, o);
          }
        n.context.abortListeners = null, this.running.splice(i--, 1);
      } else
        n.updates.push(...r.transactions);
    }
    if (this.debounceUpdate > -1 && clearTimeout(this.debounceUpdate), this.debounceUpdate = e.active.some((i) => i.state == 1 && !this.running.some((n) => n.active.source == i.source)) ? setTimeout(() => this.startUpdate(), HG) : -1, this.composing != 0)
      for (let i of r.transactions)
        uw(i) == "input" ? this.composing = 2 : this.composing == 2 && i.selection && (this.composing = 3);
  }
  startUpdate() {
    this.debounceUpdate = -1;
    let { state: r } = this.view, e = r.field(gn);
    for (let t of e.active)
      t.state == 1 && !this.running.some((i) => i.active.source == t.source) && this.startQuery(t);
  }
  startQuery(r) {
    let { state: e } = this.view, t = ml(e), i = new A8(e, t, r.explicitPos == t), n = new bPe(r, i);
    this.running.push(n), Promise.resolve(r.source(i)).then((a) => {
      n.context.aborted || (n.done = a || null, this.scheduleAccept());
    }, (a) => {
      this.view.dispatch({ effects: uv.of(null) }), ea(this.view.state, a);
    });
  }
  scheduleAccept() {
    this.running.every((r) => r.done !== void 0) ? this.accept() : this.debounceAccept < 0 && (this.debounceAccept = setTimeout(() => this.accept(), HG));
  }
  // For each finished query in this.running, try to create a result
  // or, if appropriate, restart the query.
  accept() {
    var r;
    this.debounceAccept > -1 && clearTimeout(this.debounceAccept), this.debounceAccept = -1;
    let e = [], t = this.view.state.facet(Ji);
    for (let i = 0; i < this.running.length; i++) {
      let n = this.running[i];
      if (n.done === void 0)
        continue;
      if (this.running.splice(i--, 1), n.done) {
        let o = new vf(n.active.source, n.active.explicitPos, n.done, n.done.from, (r = n.done.to) !== null && r !== void 0 ? r : ml(n.updates.length ? n.updates[0].startState : this.view.state));
        for (let s of n.updates)
          o = o.update(s, t);
        if (o.hasResult()) {
          e.push(o);
          continue;
        }
      }
      let a = this.view.state.field(gn).active.find((o) => o.source == n.active.source);
      if (a && a.state == 1)
        if (n.done == null) {
          let o = new zi(
            n.active.source,
            0
            /* Inactive */
          );
          for (let s of n.updates)
            o = o.update(s, t);
          o.state != 1 && e.push(o);
        } else
          this.startQuery(a);
    }
    e.length && this.view.dispatch({ effects: I8.of(e) });
  }
}, {
  eventHandlers: {
    blur(r) {
      let e = this.view.state.field(gn, !1);
      if (e && e.tooltip && this.view.state.facet(Ji).closeOnBlur) {
        let t = e.open && I6(this.view, e.open.tooltip);
        (!t || !t.dom.contains(r.relatedTarget)) && this.view.dispatch({ effects: uv.of(null) });
      }
    },
    compositionstart() {
      this.composing = 1;
    },
    compositionend() {
      this.composing == 3 && setTimeout(() => this.view.dispatch({ effects: OP.of(!1) }), 20), this.composing = 0;
    }
  }
}), x8 = /* @__PURE__ */ me.baseTheme({
  ".cm-tooltip.cm-tooltip-autocomplete": {
    "& > ul": {
      fontFamily: "monospace",
      whiteSpace: "nowrap",
      overflow: "hidden auto",
      maxWidth_fallback: "700px",
      maxWidth: "min(700px, 95vw)",
      minWidth: "250px",
      maxHeight: "10em",
      height: "100%",
      listStyle: "none",
      margin: 0,
      padding: 0,
      "& > li, & > completion-section": {
        padding: "1px 3px",
        lineHeight: 1.2
      },
      "& > li": {
        overflowX: "hidden",
        textOverflow: "ellipsis",
        cursor: "pointer"
      },
      "& > completion-section": {
        display: "list-item",
        borderBottom: "1px solid silver",
        paddingLeft: "0.5em",
        opacity: 0.7
      }
    }
  },
  "&light .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#17c",
    color: "white"
  },
  "&light .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#777"
  },
  "&dark .cm-tooltip-autocomplete ul li[aria-selected]": {
    background: "#347",
    color: "white"
  },
  "&dark .cm-tooltip-autocomplete-disabled ul li[aria-selected]": {
    background: "#444"
  },
  ".cm-completionListIncompleteTop:before, .cm-completionListIncompleteBottom:after": {
    content: '""',
    opacity: 0.5,
    display: "block",
    textAlign: "center"
  },
  ".cm-tooltip.cm-completionInfo": {
    position: "absolute",
    padding: "3px 9px",
    width: "max-content",
    maxWidth: "400px",
    boxSizing: "border-box"
  },
  ".cm-completionInfo.cm-completionInfo-left": { right: "100%" },
  ".cm-completionInfo.cm-completionInfo-right": { left: "100%" },
  ".cm-completionInfo.cm-completionInfo-left-narrow": { right: "30px" },
  ".cm-completionInfo.cm-completionInfo-right-narrow": { left: "30px" },
  "&light .cm-snippetField": { backgroundColor: "#00000022" },
  "&dark .cm-snippetField": { backgroundColor: "#ffffff22" },
  ".cm-snippetFieldPosition": {
    verticalAlign: "text-top",
    width: 0,
    height: "1.15em",
    display: "inline-block",
    margin: "0 -0.7px -.7em",
    borderLeft: "1.4px dotted #888"
  },
  ".cm-completionMatchedText": {
    textDecoration: "underline"
  },
  ".cm-completionDetail": {
    marginLeft: "0.5em",
    fontStyle: "italic"
  },
  ".cm-completionIcon": {
    fontSize: "90%",
    width: ".8em",
    display: "inline-block",
    textAlign: "center",
    paddingRight: ".6em",
    opacity: "0.6",
    boxSizing: "content-box"
  },
  ".cm-completionIcon-function, .cm-completionIcon-method": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-class": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-interface": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-variable": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-constant": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-type": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-enum": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-property": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-keyword": {
    "&:after": { content: "''" }
    // Disable emoji rendering
  },
  ".cm-completionIcon-namespace": {
    "&:after": { content: "''" }
  },
  ".cm-completionIcon-text": {
    "&:after": { content: "'abc'", fontSize: "50%", verticalAlign: "middle" }
  }
});
class RPe {
  constructor(e, t, i, n) {
    this.field = e, this.line = t, this.from = i, this.to = n;
  }
}
class mP {
  constructor(e, t, i) {
    this.field = e, this.from = t, this.to = i;
  }
  map(e) {
    let t = e.mapPos(this.from, -1, jr.TrackDel), i = e.mapPos(this.to, 1, jr.TrackDel);
    return t == null || i == null ? null : new mP(this.field, t, i);
  }
}
class EP {
  constructor(e, t) {
    this.lines = e, this.fieldPositions = t;
  }
  instantiate(e, t) {
    let i = [], n = [t], a = e.doc.lineAt(t), o = /^\s*/.exec(a.text)[0];
    for (let l of this.lines) {
      if (i.length) {
        let u = o, c = /^\t*/.exec(l)[0].length;
        for (let h = 0; h < c; h++)
          u += e.facet(ZT);
        n.push(t + u.length - c), l = u + l.slice(c);
      }
      i.push(l), t += l.length + 1;
    }
    let s = this.fieldPositions.map((l) => new mP(l.field, n[l.line] + l.from, n[l.line] + l.to));
    return { text: i, ranges: s };
  }
  static parse(e) {
    let t = [], i = [], n = [], a;
    for (let o of e.split(/\r\n?|\n/)) {
      for (; a = /[#$]\{(?:(\d+)(?::([^}]*))?|([^}]*))\}/.exec(o); ) {
        let s = a[1] ? +a[1] : null, l = a[2] || a[3] || "", u = -1;
        for (let c = 0; c < t.length; c++)
          (s != null ? t[c].seq == s : l && t[c].name == l) && (u = c);
        if (u < 0) {
          let c = 0;
          for (; c < t.length && (s == null || t[c].seq != null && t[c].seq < s); )
            c++;
          t.splice(c, 0, { seq: s, name: l }), u = c;
          for (let h of n)
            h.field >= u && h.field++;
        }
        n.push(new RPe(u, i.length, a.index, a.index + l.length)), o = o.slice(0, a.index) + l + o.slice(a.index + a[0].length);
      }
      for (let s; s = /\\([{}])/.exec(o); ) {
        o = o.slice(0, s.index) + s[1] + o.slice(s.index + s[0].length);
        for (let l of n)
          l.line == i.length && l.from > s.index && (l.from--, l.to--);
      }
      i.push(o);
    }
    return new EP(i, n);
  }
}
let APe = /* @__PURE__ */ Xe.widget({ widget: /* @__PURE__ */ new class extends Rs {
  toDOM() {
    let r = document.createElement("span");
    return r.className = "cm-snippetFieldPosition", r;
  }
  ignoreEvent() {
    return !1;
  }
}() }), _Pe = /* @__PURE__ */ Xe.mark({ class: "cm-snippetField" });
class pd {
  constructor(e, t) {
    this.ranges = e, this.active = t, this.deco = Xe.set(e.map((i) => (i.from == i.to ? APe : _Pe).range(i.from, i.to)));
  }
  map(e) {
    let t = [];
    for (let i of this.ranges) {
      let n = i.map(e);
      if (!n)
        return null;
      t.push(n);
    }
    return new pd(t, this.active);
  }
  selectionInsideField(e) {
    return e.ranges.every((t) => this.ranges.some((i) => i.field == this.active && i.from <= t.from && i.to >= t.to));
  }
}
const jv = /* @__PURE__ */ lt.define({
  map(r, e) {
    return r && r.map(e);
  }
}), CPe = /* @__PURE__ */ lt.define(), cv = /* @__PURE__ */ Br.define({
  create() {
    return null;
  },
  update(r, e) {
    for (let t of e.effects) {
      if (t.is(jv))
        return t.value;
      if (t.is(CPe) && r)
        return new pd(r.ranges, t.value);
    }
    return r && e.docChanged && (r = r.map(e.changes)), r && e.selection && !r.selectionInsideField(e.selection) && (r = null), r;
  },
  provide: (r) => me.decorations.from(r, (e) => e ? e.deco : Xe.none)
});
function bP(r, e) {
  return Z.create(r.filter((t) => t.field == e).map((t) => Z.range(t.from, t.to)));
}
function IPe(r) {
  let e = EP.parse(r);
  return (t, i, n, a) => {
    let { text: o, ranges: s } = e.instantiate(t.state, n), l = {
      changes: { from: n, to: a, insert: Ct.of(o) },
      scrollIntoView: !0,
      annotations: i ? C8.of(i) : void 0
    };
    if (s.length && (l.selection = bP(s, 0)), s.length > 1) {
      let u = new pd(s, 0), c = l.effects = [jv.of(u)];
      t.state.field(cv, !1) === void 0 && c.push(lt.appendConfig.of([cv, LPe, DPe, x8]));
    }
    t.dispatch(t.state.update(l));
  };
}
function P8(r) {
  return ({ state: e, dispatch: t }) => {
    let i = e.field(cv, !1);
    if (!i || r < 0 && i.active == 0)
      return !1;
    let n = i.active + r, a = r > 0 && !i.ranges.some((o) => o.field == n + r);
    return t(e.update({
      selection: bP(i.ranges, n),
      effects: jv.of(a ? null : new pd(i.ranges, n))
    })), !0;
  };
}
const wPe = ({ state: r, dispatch: e }) => r.field(cv, !1) ? (e(r.update({ effects: jv.of(null) })), !0) : !1, NPe = /* @__PURE__ */ P8(1), xPe = /* @__PURE__ */ P8(-1), PPe = [
  { key: "Tab", run: NPe, shift: xPe },
  { key: "Escape", run: wPe }
], WG = /* @__PURE__ */ Ce.define({
  combine(r) {
    return r.length ? r[0] : PPe;
  }
}), LPe = /* @__PURE__ */ th.highest(/* @__PURE__ */ Yv.compute([WG], (r) => r.facet(WG)));
function Tr(r, e) {
  return Object.assign(Object.assign({}, e), { apply: IPe(r) });
}
const DPe = /* @__PURE__ */ me.domEventHandlers({
  mousedown(r, e) {
    let t = e.state.field(cv, !1), i;
    if (!t || (i = e.posAtCoords({ x: r.clientX, y: r.clientY })) == null)
      return !1;
    let n = t.ranges.find((a) => a.from <= i && a.to >= i);
    return !n || n.field == t.active ? !1 : (e.dispatch({
      selection: bP(t.ranges, n.field),
      effects: jv.of(t.ranges.some((a) => a.field > n.field) ? new pd(t.ranges, n.field) : null)
    }), !0);
  }
}), hv = {
  brackets: ["(", "[", "{", "'", '"'],
  before: ")]}:;>",
  stringPrefixes: []
}, ic = /* @__PURE__ */ lt.define({
  map(r, e) {
    let t = e.mapPos(r, -1, jr.TrackAfter);
    return t ?? void 0;
  }
}), SP = /* @__PURE__ */ new class extends Mc {
}();
SP.startSide = 1;
SP.endSide = -1;
const L8 = /* @__PURE__ */ Br.define({
  create() {
    return kt.empty;
  },
  update(r, e) {
    if (e.selection) {
      let t = e.state.doc.lineAt(e.selection.main.head).from, i = e.startState.doc.lineAt(e.startState.selection.main.head).from;
      t != e.changes.mapPos(i, -1) && (r = kt.empty);
    }
    r = r.map(e.changes);
    for (let t of e.effects)
      t.is(ic) && (r = r.update({ add: [SP.range(t.value, t.value + 1)] }));
    return r;
  }
});
function MPe() {
  return [QPe, L8];
}
const NA = "()[]{}<>";
function D8(r) {
  for (let e = 0; e < NA.length; e += 2)
    if (NA.charCodeAt(e) == r)
      return NA.charAt(e + 1);
  return xx(r < 128 ? r : r + 1);
}
function M8(r, e) {
  return r.languageDataAt("closeBrackets", e)[0] || hv;
}
const kPe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), QPe = /* @__PURE__ */ me.inputHandler.of((r, e, t, i) => {
  if ((kPe ? r.composing : r.compositionStarted) || r.state.readOnly)
    return !1;
  let n = r.state.selection.main;
  if (i.length > 2 || i.length == 2 && Hn(Zr(i, 0)) == 1 || e != n.from || t != n.to)
    return !1;
  let a = VPe(r.state, i);
  return a ? (r.dispatch(a), !0) : !1;
}), UPe = ({ state: r, dispatch: e }) => {
  if (r.readOnly)
    return !1;
  let i = M8(r, r.selection.main.head).brackets || hv.brackets, n = null, a = r.changeByRange((o) => {
    if (o.empty) {
      let s = GPe(r.doc, o.head);
      for (let l of i)
        if (l == s && cy(r.doc, o.head) == D8(Zr(l, 0)))
          return {
            changes: { from: o.head - l.length, to: o.head + l.length },
            range: Z.cursor(o.head - l.length)
          };
    }
    return { range: n = o };
  });
  return n || e(r.update(a, { scrollIntoView: !0, userEvent: "delete.backward" })), !n;
}, $Pe = [
  { key: "Backspace", run: UPe }
];
function VPe(r, e) {
  let t = M8(r, r.selection.main.head), i = t.brackets || hv.brackets;
  for (let n of i) {
    let a = D8(Zr(n, 0));
    if (e == n)
      return a == n ? XPe(r, n, i.indexOf(n + n + n) > -1, t) : BPe(r, n, a, t.before || hv.before);
    if (e == a && k8(r, r.selection.main.from))
      return FPe(r, n, a);
  }
  return null;
}
function k8(r, e) {
  let t = !1;
  return r.field(L8).between(0, r.doc.length, (i) => {
    i == e && (t = !0);
  }), t;
}
function cy(r, e) {
  let t = r.sliceString(e, e + 2);
  return t.slice(0, Hn(Zr(t, 0)));
}
function GPe(r, e) {
  let t = r.sliceString(e - 2, e);
  return Hn(Zr(t, 0)) == t.length ? t : t.slice(1);
}
function BPe(r, e, t, i) {
  let n = null, a = r.changeByRange((o) => {
    if (!o.empty)
      return {
        changes: [{ insert: e, from: o.from }, { insert: t, from: o.to }],
        effects: ic.of(o.to + e.length),
        range: Z.range(o.anchor + e.length, o.head + e.length)
      };
    let s = cy(r.doc, o.head);
    return !s || /\s/.test(s) || i.indexOf(s) > -1 ? {
      changes: { insert: e + t, from: o.head },
      effects: ic.of(o.head + e.length),
      range: Z.cursor(o.head + e.length)
    } : { range: n = o };
  });
  return n ? null : r.update(a, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function FPe(r, e, t) {
  let i = null, n = r.changeByRange((a) => a.empty && cy(r.doc, a.head) == t ? {
    changes: { from: a.head, to: a.head + t.length, insert: t },
    range: Z.cursor(a.head + t.length)
  } : i = { range: a });
  return i ? null : r.update(n, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function XPe(r, e, t, i) {
  let n = i.stringPrefixes || hv.stringPrefixes, a = null, o = r.changeByRange((s) => {
    if (!s.empty)
      return {
        changes: [{ insert: e, from: s.from }, { insert: e, from: s.to }],
        effects: ic.of(s.to + e.length),
        range: Z.range(s.anchor + e.length, s.head + e.length)
      };
    let l = s.head, u = cy(r.doc, l), c;
    if (u == e) {
      if (zG(r, l))
        return {
          changes: { insert: e + e, from: l },
          effects: ic.of(l + e.length),
          range: Z.cursor(l + e.length)
        };
      if (k8(r, l)) {
        let f = t && r.sliceDoc(l, l + e.length * 3) == e + e + e ? e + e + e : e;
        return {
          changes: { from: l, to: l + f.length, insert: f },
          range: Z.cursor(l + f.length)
        };
      }
    } else {
      if (t && r.sliceDoc(l - 2 * e.length, l) == e + e && (c = ZG(r, l - 2 * e.length, n)) > -1 && zG(r, c))
        return {
          changes: { insert: e + e + e + e, from: l },
          effects: ic.of(l + e.length),
          range: Z.cursor(l + e.length)
        };
      if (r.charCategorizer(l)(u) != Mt.Word && ZG(r, l, n) > -1 && !YPe(r, l, e, n))
        return {
          changes: { insert: e + e, from: l },
          effects: ic.of(l + e.length),
          range: Z.cursor(l + e.length)
        };
    }
    return { range: a = s };
  });
  return a ? null : r.update(o, {
    scrollIntoView: !0,
    userEvent: "input.type"
  });
}
function zG(r, e) {
  let t = Kt(r).resolveInner(e + 1);
  return t.parent && t.from == e;
}
function YPe(r, e, t, i) {
  let n = Kt(r).resolveInner(e, -1), a = i.reduce((o, s) => Math.max(o, s.length), 0);
  for (let o = 0; o < 5; o++) {
    let s = r.sliceDoc(n.from, Math.min(n.to, n.from + t.length + a)), l = s.indexOf(t);
    if (!l || l > -1 && i.indexOf(s.slice(0, l)) > -1) {
      let c = n.firstChild;
      for (; c && c.from == n.from && c.to - c.from > t.length + l; ) {
        if (r.sliceDoc(c.to - t.length, c.to) == t)
          return !1;
        c = c.firstChild;
      }
      return !0;
    }
    let u = n.to == e && n.parent;
    if (!u)
      break;
    n = u;
  }
  return !1;
}
function ZG(r, e, t) {
  let i = r.charCategorizer(e);
  if (i(r.sliceDoc(e - 1, e)) != Mt.Word)
    return e;
  for (let n of t) {
    let a = e - n.length;
    if (r.sliceDoc(a, e) == n && i(r.sliceDoc(a - 1, a)) != Mt.Word)
      return a;
  }
  return -1;
}
function Q8(r = {}) {
  return [
    gn,
    Ji.of(r),
    yPe,
    HPe,
    x8
  ];
}
const U8 = [
  { key: "Ctrl-Space", run: mPe },
  { key: "Escape", run: EPe },
  { key: "ArrowDown", run: /* @__PURE__ */ Mm(!0) },
  { key: "ArrowUp", run: /* @__PURE__ */ Mm(!1) },
  { key: "PageDown", run: /* @__PURE__ */ Mm(!0, "page") },
  { key: "PageUp", run: /* @__PURE__ */ Mm(!1, "page") },
  { key: "Enter", run: OPe }
], HPe = /* @__PURE__ */ th.highest(/* @__PURE__ */ Yv.computeN([Ji], (r) => r.facet(Ji).defaultKeymap ? [U8] : []));
class WPe {
  constructor(e, t, i) {
    this.from = e, this.to = t, this.diagnostic = i;
  }
}
class Bu {
  constructor(e, t, i) {
    this.diagnostics = e, this.panel = t, this.selected = i;
  }
  static init(e, t, i) {
    let n = e, a = i.facet(G8).markerFilter;
    a && (n = a(n));
    let o = Xe.set(n.map((s) => s.from == s.to || s.from == s.to - 1 && i.doc.lineAt(s.from).to == s.from ? Xe.widget({
      widget: new rLe(s),
      diagnostic: s
    }).range(s.from) : Xe.mark({
      attributes: { class: "cm-lintRange cm-lintRange-" + s.severity + (s.markClass ? " " + s.markClass : "") },
      diagnostic: s
    }).range(s.from, s.to)), !0);
    return new Bu(o, t, Bf(o));
  }
}
function Bf(r, e = null, t = 0) {
  let i = null;
  return r.between(t, 1e9, (n, a, { spec: o }) => {
    if (!(e && o.diagnostic != e))
      return i = new WPe(n, a, o.diagnostic), !1;
  }), i;
}
function zPe(r, e) {
  let t = r.startState.doc.lineAt(e.pos);
  return !!(r.effects.some((i) => i.is($8)) || r.changes.touchesRange(t.from, t.to));
}
function ZPe(r, e) {
  return r.field(mn, !1) ? e : e.concat(lt.appendConfig.of(aLe));
}
const $8 = /* @__PURE__ */ lt.define(), TP = /* @__PURE__ */ lt.define(), V8 = /* @__PURE__ */ lt.define(), mn = /* @__PURE__ */ Br.define({
  create() {
    return new Bu(Xe.none, null, null);
  },
  update(r, e) {
    if (e.docChanged) {
      let t = r.diagnostics.map(e.changes), i = null;
      if (r.selected) {
        let n = e.changes.mapPos(r.selected.from, 1);
        i = Bf(t, r.selected.diagnostic, n) || Bf(t, null, n);
      }
      r = new Bu(t, r.panel, i);
    }
    for (let t of e.effects)
      t.is($8) ? r = Bu.init(t.value, r.panel, e.state) : t.is(TP) ? r = new Bu(r.diagnostics, t.value ? hy.open : null, r.selected) : t.is(V8) && (r = new Bu(r.diagnostics, r.panel, t.value));
    return r;
  },
  provide: (r) => [
    av.from(r, (e) => e.panel),
    me.decorations.from(r, (e) => e.diagnostics)
  ]
}), qPe = /* @__PURE__ */ Xe.mark({ class: "cm-lintRange cm-lintRange-active" });
function jPe(r, e, t) {
  let { diagnostics: i } = r.state.field(mn), n = [], a = 2e8, o = 0;
  i.between(e - (t < 0 ? 1 : 0), e + (t > 0 ? 1 : 0), (l, u, { spec: c }) => {
    e >= l && e <= u && (l == u || (e > l || t > 0) && (e < u || t < 0)) && (n.push(c.diagnostic), a = Math.min(l, a), o = Math.max(u, o));
  });
  let s = r.state.facet(G8).tooltipFilter;
  return s && (n = s(n)), n.length ? {
    pos: a,
    end: o,
    above: r.state.doc.lineAt(a).to < o,
    create() {
      return { dom: KPe(r, n) };
    }
  } : null;
}
function KPe(r, e) {
  return Ft("ul", { class: "cm-tooltip-lint" }, e.map((t) => F8(r, t, !1)));
}
const JPe = (r) => {
  let e = r.state.field(mn, !1);
  (!e || !e.panel) && r.dispatch({ effects: ZPe(r.state, [TP.of(!0)]) });
  let t = nv(r, hy.open);
  return t && t.dom.querySelector(".cm-panel-lint ul").focus(), !0;
}, qG = (r) => {
  let e = r.state.field(mn, !1);
  return !e || !e.panel ? !1 : (r.dispatch({ effects: TP.of(!1) }), !0);
}, eLe = (r) => {
  let e = r.state.field(mn, !1);
  if (!e)
    return !1;
  let t = r.state.selection.main, i = e.diagnostics.iter(t.to + 1);
  return !i.value && (i = e.diagnostics.iter(0), !i.value || i.from == t.from && i.to == t.to) ? !1 : (r.dispatch({ selection: { anchor: i.from, head: i.to }, scrollIntoView: !0 }), !0);
}, tLe = [
  { key: "Mod-Shift-m", run: JPe, preventDefault: !0 },
  { key: "F8", run: eLe }
], G8 = /* @__PURE__ */ Ce.define({
  combine(r) {
    return Object.assign({ sources: r.map((e) => e.source) }, Lo(r.map((e) => e.config), {
      delay: 750,
      markerFilter: null,
      tooltipFilter: null,
      needsRefresh: null
    }, {
      needsRefresh: (e, t) => e ? t ? (i) => e(i) || t(i) : e : t
    }));
  }
});
function B8(r) {
  let e = [];
  if (r)
    e:
      for (let { name: t } of r) {
        for (let i = 0; i < t.length; i++) {
          let n = t[i];
          if (/[a-zA-Z]/.test(n) && !e.some((a) => a.toLowerCase() == n.toLowerCase())) {
            e.push(n);
            continue e;
          }
        }
        e.push("");
      }
  return e;
}
function F8(r, e, t) {
  var i;
  let n = t ? B8(e.actions) : [];
  return Ft("li", { class: "cm-diagnostic cm-diagnostic-" + e.severity }, Ft("span", { class: "cm-diagnosticText" }, e.renderMessage ? e.renderMessage() : e.message), (i = e.actions) === null || i === void 0 ? void 0 : i.map((a, o) => {
    let s = !1, l = (f) => {
      if (f.preventDefault(), s)
        return;
      s = !0;
      let d = Bf(r.state.field(mn).diagnostics, e);
      d && a.apply(r, d.from, d.to);
    }, { name: u } = a, c = n[o] ? u.indexOf(n[o]) : -1, h = c < 0 ? u : [
      u.slice(0, c),
      Ft("u", u.slice(c, c + 1)),
      u.slice(c + 1)
    ];
    return Ft("button", {
      type: "button",
      class: "cm-diagnosticAction",
      onclick: l,
      onmousedown: l,
      "aria-label": ` Action: ${u}${c < 0 ? "" : ` (access key "${n[o]})"`}.`
    }, h);
  }), e.source && Ft("div", { class: "cm-diagnosticSource" }, e.source));
}
class rLe extends Rs {
  constructor(e) {
    super(), this.diagnostic = e;
  }
  eq(e) {
    return e.diagnostic == this.diagnostic;
  }
  toDOM() {
    return Ft("span", { class: "cm-lintPoint cm-lintPoint-" + this.diagnostic.severity });
  }
}
class jG {
  constructor(e, t) {
    this.diagnostic = t, this.id = "item_" + Math.floor(Math.random() * 4294967295).toString(16), this.dom = F8(e, t, !0), this.dom.id = this.id, this.dom.setAttribute("role", "option");
  }
}
class hy {
  constructor(e) {
    this.view = e, this.items = [];
    let t = (n) => {
      if (n.keyCode == 27)
        qG(this.view), this.view.focus();
      else if (n.keyCode == 38 || n.keyCode == 33)
        this.moveSelection((this.selectedIndex - 1 + this.items.length) % this.items.length);
      else if (n.keyCode == 40 || n.keyCode == 34)
        this.moveSelection((this.selectedIndex + 1) % this.items.length);
      else if (n.keyCode == 36)
        this.moveSelection(0);
      else if (n.keyCode == 35)
        this.moveSelection(this.items.length - 1);
      else if (n.keyCode == 13)
        this.view.focus();
      else if (n.keyCode >= 65 && n.keyCode <= 90 && this.selectedIndex >= 0) {
        let { diagnostic: a } = this.items[this.selectedIndex], o = B8(a.actions);
        for (let s = 0; s < o.length; s++)
          if (o[s].toUpperCase().charCodeAt(0) == n.keyCode) {
            let l = Bf(this.view.state.field(mn).diagnostics, a);
            l && a.actions[s].apply(e, l.from, l.to);
          }
      } else
        return;
      n.preventDefault();
    }, i = (n) => {
      for (let a = 0; a < this.items.length; a++)
        this.items[a].dom.contains(n.target) && this.moveSelection(a);
    };
    this.list = Ft("ul", {
      tabIndex: 0,
      role: "listbox",
      "aria-label": this.view.state.phrase("Diagnostics"),
      onkeydown: t,
      onclick: i
    }), this.dom = Ft("div", { class: "cm-panel-lint" }, this.list, Ft("button", {
      type: "button",
      name: "close",
      "aria-label": this.view.state.phrase("close"),
      onclick: () => qG(this.view)
    }, "")), this.update();
  }
  get selectedIndex() {
    let e = this.view.state.field(mn).selected;
    if (!e)
      return -1;
    for (let t = 0; t < this.items.length; t++)
      if (this.items[t].diagnostic == e.diagnostic)
        return t;
    return -1;
  }
  update() {
    let { diagnostics: e, selected: t } = this.view.state.field(mn), i = 0, n = !1, a = null;
    for (e.between(0, this.view.state.doc.length, (o, s, { spec: l }) => {
      let u = -1, c;
      for (let h = i; h < this.items.length; h++)
        if (this.items[h].diagnostic == l.diagnostic) {
          u = h;
          break;
        }
      u < 0 ? (c = new jG(this.view, l.diagnostic), this.items.splice(i, 0, c), n = !0) : (c = this.items[u], u > i && (this.items.splice(i, u - i), n = !0)), t && c.diagnostic == t.diagnostic ? c.dom.hasAttribute("aria-selected") || (c.dom.setAttribute("aria-selected", "true"), a = c) : c.dom.hasAttribute("aria-selected") && c.dom.removeAttribute("aria-selected"), i++;
    }); i < this.items.length && !(this.items.length == 1 && this.items[0].diagnostic.from < 0); )
      n = !0, this.items.pop();
    this.items.length == 0 && (this.items.push(new jG(this.view, {
      from: -1,
      to: -1,
      severity: "info",
      message: this.view.state.phrase("No diagnostics")
    })), n = !0), a ? (this.list.setAttribute("aria-activedescendant", a.id), this.view.requestMeasure({
      key: this,
      read: () => ({ sel: a.dom.getBoundingClientRect(), panel: this.list.getBoundingClientRect() }),
      write: ({ sel: o, panel: s }) => {
        o.top < s.top ? this.list.scrollTop -= s.top - o.top : o.bottom > s.bottom && (this.list.scrollTop += o.bottom - s.bottom);
      }
    })) : this.selectedIndex < 0 && this.list.removeAttribute("aria-activedescendant"), n && this.sync();
  }
  sync() {
    let e = this.list.firstChild;
    function t() {
      let i = e;
      e = i.nextSibling, i.remove();
    }
    for (let i of this.items)
      if (i.dom.parentNode == this.list) {
        for (; e != i.dom; )
          t();
        e = i.dom.nextSibling;
      } else
        this.list.insertBefore(i.dom, e);
    for (; e; )
      t();
  }
  moveSelection(e) {
    if (this.selectedIndex < 0)
      return;
    let t = this.view.state.field(mn), i = Bf(t.diagnostics, this.items[e].diagnostic);
    i && this.view.dispatch({
      selection: { anchor: i.from, head: i.to },
      scrollIntoView: !0,
      effects: V8.of(i)
    });
  }
  static open(e) {
    return new hy(e);
  }
}
function iLe(r, e = 'viewBox="0 0 40 40"') {
  return `url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" ${e}>${encodeURIComponent(r)}</svg>')`;
}
function km(r) {
  return iLe(`<path d="m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0" stroke="${r}" fill="none" stroke-width=".7"/>`, 'width="6" height="3"');
}
const nLe = /* @__PURE__ */ me.baseTheme({
  ".cm-diagnostic": {
    padding: "3px 6px 3px 8px",
    marginLeft: "-1px",
    display: "block",
    whiteSpace: "pre-wrap"
  },
  ".cm-diagnostic-error": { borderLeft: "5px solid #d11" },
  ".cm-diagnostic-warning": { borderLeft: "5px solid orange" },
  ".cm-diagnostic-info": { borderLeft: "5px solid #999" },
  ".cm-diagnostic-hint": { borderLeft: "5px solid #66d" },
  ".cm-diagnosticAction": {
    font: "inherit",
    border: "none",
    padding: "2px 4px",
    backgroundColor: "#444",
    color: "white",
    borderRadius: "3px",
    marginLeft: "8px",
    cursor: "pointer"
  },
  ".cm-diagnosticSource": {
    fontSize: "70%",
    opacity: 0.7
  },
  ".cm-lintRange": {
    backgroundPosition: "left bottom",
    backgroundRepeat: "repeat-x",
    paddingBottom: "0.7px"
  },
  ".cm-lintRange-error": { backgroundImage: /* @__PURE__ */ km("#d11") },
  ".cm-lintRange-warning": { backgroundImage: /* @__PURE__ */ km("orange") },
  ".cm-lintRange-info": { backgroundImage: /* @__PURE__ */ km("#999") },
  ".cm-lintRange-hint": { backgroundImage: /* @__PURE__ */ km("#66d") },
  ".cm-lintRange-active": { backgroundColor: "#ffdd9980" },
  ".cm-tooltip-lint": {
    padding: 0,
    margin: 0
  },
  ".cm-lintPoint": {
    position: "relative",
    "&:after": {
      content: '""',
      position: "absolute",
      bottom: 0,
      left: "-2px",
      borderLeft: "3px solid transparent",
      borderRight: "3px solid transparent",
      borderBottom: "4px solid #d11"
    }
  },
  ".cm-lintPoint-warning": {
    "&:after": { borderBottomColor: "orange" }
  },
  ".cm-lintPoint-info": {
    "&:after": { borderBottomColor: "#999" }
  },
  ".cm-lintPoint-hint": {
    "&:after": { borderBottomColor: "#66d" }
  },
  ".cm-panel.cm-panel-lint": {
    position: "relative",
    "& ul": {
      maxHeight: "100px",
      overflowY: "auto",
      "& [aria-selected]": {
        backgroundColor: "#ddd",
        "& u": { textDecoration: "underline" }
      },
      "&:focus [aria-selected]": {
        background_fallback: "#bdf",
        backgroundColor: "Highlight",
        color_fallback: "white",
        color: "HighlightText"
      },
      "& u": { textDecoration: "none" },
      padding: 0,
      margin: 0
    },
    "& [name=close]": {
      position: "absolute",
      top: "0",
      right: "2px",
      background: "inherit",
      border: "none",
      font: "inherit",
      padding: 0,
      margin: 0
    }
  }
}), aLe = [
  mn,
  /* @__PURE__ */ me.decorations.compute([mn], (r) => {
    let { selected: e, panel: t } = r.field(mn);
    return !e || !t || e.from == e.to ? Xe.none : Xe.set([
      qPe.range(e.from, e.to)
    ]);
  }),
  /* @__PURE__ */ _1e(jPe, { hideOn: zPe }),
  nLe
], oLe = /* @__PURE__ */ (() => [
  M1e(),
  U1e(),
  n1e(),
  s9(),
  xNe(),
  Wwe(),
  Kwe(),
  Rt.allowMultipleSelections.of(!0),
  mNe(),
  Do(MNe, { fallback: !0 }),
  BNe(),
  MPe(),
  Q8(),
  v1e(),
  E1e(),
  c1e(),
  Dxe(),
  Yv.of([
    ...$Pe,
    ...d8,
    ...Jxe,
    ...d9,
    ...CNe,
    ...U8,
    ...tLe
  ])
])(), sLe = "#e5c07b", KG = "#e06c75", lLe = "#56b6c2", uLe = "#ffffff", mE = "#abb2bf", cw = "#7d8799", cLe = "#61afef", hLe = "#98c379", JG = "#d19a66", fLe = "#c678dd", dLe = "#21252b", eB = "#2c313a", tB = "#282c34", xA = "#353a42", pLe = "#3E4451", rB = "#528bff", gLe = /* @__PURE__ */ me.theme({
  "&": {
    color: mE,
    backgroundColor: tB
  },
  ".cm-content": {
    caretColor: rB
  },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: rB },
  "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: pLe },
  ".cm-panels": { backgroundColor: dLe, color: mE },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: "#72a1ff59",
    outline: "1px solid #457dff"
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: "#6199ff2f"
  },
  ".cm-activeLine": { backgroundColor: "#6699ff0b" },
  ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: "#bad0f847",
    outline: "1px solid #515a6b"
  },
  ".cm-gutters": {
    backgroundColor: tB,
    color: cw,
    border: "none"
  },
  ".cm-activeLineGutter": {
    backgroundColor: eB
  },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: "#ddd"
  },
  ".cm-tooltip": {
    border: "none",
    backgroundColor: xA
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: xA,
    borderBottomColor: xA
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      backgroundColor: eB,
      color: mE
    }
  }
}, { dark: !0 }), vLe = /* @__PURE__ */ Cn.define([
  {
    tag: A.keyword,
    color: fLe
  },
  {
    tag: [A.name, A.deleted, A.character, A.propertyName, A.macroName],
    color: KG
  },
  {
    tag: [/* @__PURE__ */ A.function(A.variableName), A.labelName],
    color: cLe
  },
  {
    tag: [A.color, /* @__PURE__ */ A.constant(A.name), /* @__PURE__ */ A.standard(A.name)],
    color: JG
  },
  {
    tag: [/* @__PURE__ */ A.definition(A.name), A.separator],
    color: mE
  },
  {
    tag: [A.typeName, A.className, A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace],
    color: sLe
  },
  {
    tag: [A.operator, A.operatorKeyword, A.url, A.escape, A.regexp, A.link, /* @__PURE__ */ A.special(A.string)],
    color: lLe
  },
  {
    tag: [A.meta, A.comment],
    color: cw
  },
  {
    tag: A.strong,
    fontWeight: "bold"
  },
  {
    tag: A.emphasis,
    fontStyle: "italic"
  },
  {
    tag: A.strikethrough,
    textDecoration: "line-through"
  },
  {
    tag: A.link,
    color: cw,
    textDecoration: "underline"
  },
  {
    tag: A.heading,
    fontWeight: "bold",
    color: KG
  },
  {
    tag: [A.atom, A.bool, /* @__PURE__ */ A.special(A.variableName)],
    color: JG
  },
  {
    tag: [A.processingInstruction, A.string, A.inserted],
    color: hLe
  },
  {
    tag: A.invalid,
    color: uLe
  }
]), iB = [gLe, /* @__PURE__ */ Do(vLe)], Je = {
  name: "materialLight",
  dark: !1,
  background: "#FAFAFA",
  foreground: "#90A4AE",
  selection: "#80CBC440",
  cursor: "#272727",
  dropdownBackground: "#FAFAFA",
  dropdownBorder: "#00000010",
  activeLine: "#c2c2c222",
  matchingBracket: "#FAFAFA",
  keyword: "#39ADB5",
  storage: "#39ADB5",
  variable: "#90A4AE",
  parameter: "#90A4AE",
  function: "#6182B8",
  string: "#91B859",
  constant: "#39ADB5",
  type: "#E2931D",
  class: "#E2931D",
  number: "#F76D47",
  comment: "#90A4AE",
  heading: "#39ADB5",
  invalid: "#E5393570",
  regexp: "#91B859"
}, OLe = me.theme({
  "&": {
    color: Je.foreground,
    backgroundColor: Je.background
  },
  ".cm-content": { caretColor: Je.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: Je.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: Je.selection },
  ".cm-panels": { backgroundColor: Je.dropdownBackground, color: Je.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: Je.dropdownBackground,
    outline: `1px solid ${Je.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: Je.selection
  },
  ".cm-activeLine": { backgroundColor: Je.activeLine },
  ".cm-selectionMatch": { backgroundColor: Je.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: Je.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: Je.background,
    color: Je.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: Je.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: Je.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${Je.dropdownBorder}`,
    backgroundColor: Je.dropdownBackground,
    color: Je.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: Je.foreground,
    borderBottomColor: Je.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: Je.selection,
      color: Je.foreground
    }
  }
}, { dark: Je.dark }), mLe = Cn.define([
  { tag: A.keyword, color: Je.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: Je.variable },
  { tag: [A.propertyName], color: Je.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: Je.string },
  { tag: [A.function(A.variableName), A.labelName], color: Je.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: Je.constant },
  { tag: [A.definition(A.name), A.separator], color: Je.variable },
  { tag: [A.className], color: Je.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: Je.number },
  { tag: [A.typeName], color: Je.type, fontStyle: Je.type },
  { tag: [A.operator, A.operatorKeyword], color: Je.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: Je.regexp },
  { tag: [A.meta, A.comment], color: Je.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: Je.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: Je.variable },
  { tag: A.invalid, color: Je.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), ELe = [
  OLe,
  Do(mLe)
], et = {
  name: "materialDark",
  dark: !0,
  background: "#263238",
  foreground: "#EEFFFF",
  selection: "#80CBC420",
  cursor: "#FFCC00",
  dropdownBackground: "#263238",
  dropdownBorder: "#FFFFFF10",
  activeLine: "#4c616c22",
  matchingBracket: "#263238",
  keyword: "#89DDFF",
  storage: "#89DDFF",
  variable: "#EEFFFF",
  parameter: "#EEFFFF",
  function: "#82AAFF",
  string: "#C3E88D",
  constant: "#89DDFF",
  type: "#FFCB6B",
  class: "#FFCB6B",
  number: "#F78C6C",
  comment: "#546E7A",
  heading: "#89DDFF",
  invalid: "#f0717870",
  regexp: "#C3E88D"
}, bLe = me.theme({
  "&": {
    color: et.foreground,
    backgroundColor: et.background
  },
  ".cm-content": { caretColor: et.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: et.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: et.selection },
  ".cm-panels": { backgroundColor: et.dropdownBackground, color: et.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: et.dropdownBackground,
    outline: `1px solid ${et.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: et.selection
  },
  ".cm-activeLine": { backgroundColor: et.activeLine },
  ".cm-selectionMatch": { backgroundColor: et.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: et.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: et.background,
    color: et.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: et.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: et.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${et.dropdownBorder}`,
    backgroundColor: et.dropdownBackground,
    color: et.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: et.foreground,
    borderBottomColor: et.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: et.selection,
      color: et.foreground
    }
  }
}, { dark: et.dark }), SLe = Cn.define([
  { tag: A.keyword, color: et.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: et.variable },
  { tag: [A.propertyName], color: et.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: et.string },
  { tag: [A.function(A.variableName), A.labelName], color: et.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: et.constant },
  { tag: [A.definition(A.name), A.separator], color: et.variable },
  { tag: [A.className], color: et.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: et.number },
  { tag: [A.typeName], color: et.type, fontStyle: et.type },
  { tag: [A.operator, A.operatorKeyword], color: et.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: et.regexp },
  { tag: [A.meta, A.comment], color: et.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: et.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: et.variable },
  { tag: A.invalid, color: et.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), TLe = [
  bLe,
  Do(SLe)
], tt = {
  name: "solarizedLight",
  dark: !1,
  background: "#FDF6E3",
  foreground: "#586E75",
  selection: "#EEE8D5",
  cursor: "#657B83",
  dropdownBackground: "#FDF6E3",
  dropdownBorder: "#D3AF86",
  activeLine: "#d5bd5c22",
  matchingBracket: "#EEE8D5",
  keyword: "#859900",
  storage: "#586E75",
  variable: "#268BD2",
  parameter: "#268BD2",
  function: "#268BD2",
  string: "#2AA198",
  constant: "#CB4B16",
  type: "#CB4B16",
  class: "#CB4B16",
  number: "#D33682",
  comment: "#93A1A1",
  heading: "#268BD2",
  invalid: "#DC322F",
  regexp: "#DC322F"
}, yLe = me.theme({
  "&": {
    color: tt.foreground,
    backgroundColor: tt.background
  },
  ".cm-content": { caretColor: tt.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: tt.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: tt.selection },
  ".cm-panels": { backgroundColor: tt.dropdownBackground, color: tt.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: tt.dropdownBackground,
    outline: `1px solid ${tt.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: tt.selection
  },
  ".cm-activeLine": { backgroundColor: tt.activeLine },
  ".cm-selectionMatch": { backgroundColor: tt.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: tt.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: tt.background,
    color: tt.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: tt.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: tt.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${tt.dropdownBorder}`,
    backgroundColor: tt.dropdownBackground,
    color: tt.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: tt.foreground,
    borderBottomColor: tt.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: tt.selection,
      color: tt.foreground
    }
  }
}, { dark: tt.dark }), RLe = Cn.define([
  { tag: A.keyword, color: tt.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: tt.variable },
  { tag: [A.propertyName], color: tt.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: tt.string },
  { tag: [A.function(A.variableName), A.labelName], color: tt.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: tt.constant },
  { tag: [A.definition(A.name), A.separator], color: tt.variable },
  { tag: [A.className], color: tt.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: tt.number },
  { tag: [A.typeName], color: tt.type, fontStyle: tt.type },
  { tag: [A.operator, A.operatorKeyword], color: tt.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: tt.regexp },
  { tag: [A.meta, A.comment], color: tt.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: tt.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: tt.variable },
  { tag: A.invalid, color: tt.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), ALe = [
  yLe,
  Do(RLe)
], rt = {
  name: "solarizedDark",
  dark: !0,
  background: "#002B36",
  foreground: "#93A1A1",
  selection: "#274642",
  cursor: "#D30102",
  dropdownBackground: "#002B36",
  dropdownBorder: "#2AA19899",
  activeLine: "#005b7022",
  matchingBracket: "#073642",
  keyword: "#859900",
  storage: "#93A1A1",
  variable: "#268BD2",
  parameter: "#268BD2",
  function: "#268BD2",
  string: "#2AA198",
  constant: "#CB4B16",
  type: "#CB4B16",
  class: "#CB4B16",
  number: "#D33682",
  comment: "#586E75",
  heading: "#268BD2",
  invalid: "#DC322F",
  regexp: "#DC322F"
}, _Le = me.theme({
  "&": {
    color: rt.foreground,
    backgroundColor: rt.background
  },
  ".cm-content": { caretColor: rt.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: rt.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: rt.selection },
  ".cm-panels": { backgroundColor: rt.dropdownBackground, color: rt.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: rt.dropdownBackground,
    outline: `1px solid ${rt.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: rt.selection
  },
  ".cm-activeLine": { backgroundColor: rt.activeLine },
  ".cm-selectionMatch": { backgroundColor: rt.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: rt.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: rt.background,
    color: rt.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: rt.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: rt.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${rt.dropdownBorder}`,
    backgroundColor: rt.dropdownBackground,
    color: rt.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: rt.foreground,
    borderBottomColor: rt.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: rt.selection,
      color: rt.foreground
    }
  }
}, { dark: rt.dark }), CLe = Cn.define([
  { tag: A.keyword, color: rt.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: rt.variable },
  { tag: [A.propertyName], color: rt.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: rt.string },
  { tag: [A.function(A.variableName), A.labelName], color: rt.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: rt.constant },
  { tag: [A.definition(A.name), A.separator], color: rt.variable },
  { tag: [A.className], color: rt.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: rt.number },
  { tag: [A.typeName], color: rt.type, fontStyle: rt.type },
  { tag: [A.operator, A.operatorKeyword], color: rt.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: rt.regexp },
  { tag: [A.meta, A.comment], color: rt.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: rt.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: rt.variable },
  { tag: A.invalid, color: rt.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), ILe = [
  _Le,
  Do(CLe)
], it = {
  name: "dracula",
  dark: !0,
  background: "#282A36",
  foreground: "#F8F8F2",
  selection: "#44475A",
  cursor: "#F8F8F2",
  dropdownBackground: "#282A36",
  dropdownBorder: "#191A21",
  activeLine: "#53576c22",
  matchingBracket: "#44475A",
  keyword: "#FF79C6",
  storage: "#FF79C6",
  variable: "#F8F8F2",
  parameter: "#F8F8F2",
  function: "#50FA7B",
  string: "#F1FA8C",
  constant: "#BD93F9",
  type: "#8BE9FD",
  class: "#8BE9FD",
  number: "#BD93F9",
  comment: "#6272A4",
  heading: "#BD93F9",
  invalid: "#FF5555",
  regexp: "#F1FA8C"
}, wLe = me.theme({
  "&": {
    color: it.foreground,
    backgroundColor: it.background
  },
  ".cm-content": { caretColor: it.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: it.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: it.selection },
  ".cm-panels": { backgroundColor: it.dropdownBackground, color: it.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: it.dropdownBackground,
    outline: `1px solid ${it.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: it.selection
  },
  ".cm-activeLine": { backgroundColor: it.activeLine },
  ".cm-selectionMatch": { backgroundColor: it.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: it.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: it.background,
    color: it.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: it.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: it.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${it.dropdownBorder}`,
    backgroundColor: it.dropdownBackground,
    color: it.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: it.foreground,
    borderBottomColor: it.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: it.selection,
      color: it.foreground
    }
  }
}, { dark: it.dark }), NLe = Cn.define([
  { tag: A.keyword, color: it.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: it.variable },
  { tag: [A.propertyName], color: it.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: it.string },
  { tag: [A.function(A.variableName), A.labelName], color: it.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: it.constant },
  { tag: [A.definition(A.name), A.separator], color: it.variable },
  { tag: [A.className], color: it.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: it.number },
  { tag: [A.typeName], color: it.type, fontStyle: it.type },
  { tag: [A.operator, A.operatorKeyword], color: it.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: it.regexp },
  { tag: [A.meta, A.comment], color: it.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: it.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: it.variable },
  { tag: A.invalid, color: it.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), xLe = [
  wLe,
  Do(NLe)
], nt = {
  name: "githubLight",
  dark: !1,
  background: "#fff",
  foreground: "#444d56",
  selection: "#0366d625",
  cursor: "#044289",
  dropdownBackground: "#fff",
  dropdownBorder: "#e1e4e8",
  activeLine: "#c6c6c622",
  matchingBracket: "#34d05840",
  keyword: "#d73a49",
  storage: "#d73a49",
  variable: "#e36209",
  parameter: "#24292e",
  function: "#005cc5",
  string: "#032f62",
  constant: "#005cc5",
  type: "#005cc5",
  class: "#6f42c1",
  number: "#005cc5",
  comment: "#6a737d",
  heading: "#005cc5",
  invalid: "#cb2431",
  regexp: "#032f62"
}, PLe = me.theme({
  "&": {
    color: nt.foreground,
    backgroundColor: nt.background
  },
  ".cm-content": { caretColor: nt.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: nt.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: nt.selection },
  ".cm-panels": { backgroundColor: nt.dropdownBackground, color: nt.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: nt.dropdownBackground,
    outline: `1px solid ${nt.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: nt.selection
  },
  ".cm-activeLine": { backgroundColor: nt.activeLine },
  ".cm-selectionMatch": { backgroundColor: nt.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: nt.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: nt.background,
    color: nt.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: nt.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: nt.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${nt.dropdownBorder}`,
    backgroundColor: nt.dropdownBackground,
    color: nt.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: nt.foreground,
    borderBottomColor: nt.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: nt.selection,
      color: nt.foreground
    }
  }
}, { dark: nt.dark }), LLe = Cn.define([
  { tag: A.keyword, color: nt.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: nt.variable },
  { tag: [A.propertyName], color: nt.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: nt.string },
  { tag: [A.function(A.variableName), A.labelName], color: nt.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: nt.constant },
  { tag: [A.definition(A.name), A.separator], color: nt.variable },
  { tag: [A.className], color: nt.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: nt.number },
  { tag: [A.typeName], color: nt.type, fontStyle: nt.type },
  { tag: [A.operator, A.operatorKeyword], color: nt.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: nt.regexp },
  { tag: [A.meta, A.comment], color: nt.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: nt.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: nt.variable },
  { tag: A.invalid, color: nt.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), DLe = [
  PLe,
  Do(LLe)
], at = {
  name: "tokyoNight",
  dark: !0,
  background: "#1a1b26",
  foreground: "#787c99",
  selection: "#515c7e40",
  cursor: "#c0caf5",
  dropdownBackground: "#1a1b26",
  dropdownBorder: "#787c99",
  activeLine: "#43455c22",
  matchingBracket: "#16161e",
  keyword: "#bb9af7",
  storage: "#bb9af7",
  variable: "#c0caf5",
  parameter: "#c0caf5",
  function: "#7aa2f7",
  string: "#9ece6a",
  constant: "#bb9af7",
  type: "#0db9d7",
  class: "#c0caf5",
  number: "#ff9e64",
  comment: "#444b6a",
  heading: "#89ddff",
  invalid: "#ff5370",
  regexp: "#b4f9f8"
}, MLe = me.theme({
  "&": {
    color: at.foreground,
    backgroundColor: at.background
  },
  ".cm-content": { caretColor: at.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: at.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: at.selection },
  ".cm-panels": { backgroundColor: at.dropdownBackground, color: at.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: at.dropdownBackground,
    outline: `1px solid ${at.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: at.selection
  },
  ".cm-activeLine": { backgroundColor: at.activeLine },
  ".cm-selectionMatch": { backgroundColor: at.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: at.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: at.background,
    color: at.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: at.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: at.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${at.dropdownBorder}`,
    backgroundColor: at.dropdownBackground,
    color: at.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: at.foreground,
    borderBottomColor: at.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: at.selection,
      color: at.foreground
    }
  }
}, { dark: at.dark }), kLe = Cn.define([
  { tag: A.keyword, color: at.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: at.variable },
  { tag: [A.propertyName], color: at.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: at.string },
  { tag: [A.function(A.variableName), A.labelName], color: at.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: at.constant },
  { tag: [A.definition(A.name), A.separator], color: at.variable },
  { tag: [A.className], color: at.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: at.number },
  { tag: [A.typeName], color: at.type, fontStyle: at.type },
  { tag: [A.operator, A.operatorKeyword], color: at.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: at.regexp },
  { tag: [A.meta, A.comment], color: at.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: at.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: at.variable },
  { tag: A.invalid, color: at.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), QLe = [
  MLe,
  Do(kLe)
], ot = {
  name: "tokyoNightStorm",
  dark: !0,
  background: "#24283b",
  foreground: "#7982a9",
  selection: "#6f7bb630",
  cursor: "#c0caf5",
  dropdownBackground: "#24283b",
  dropdownBorder: "#7982a9",
  activeLine: "#4d547722",
  matchingBracket: "#1f2335",
  keyword: "#bb9af7",
  storage: "#bb9af7",
  variable: "#c0caf5",
  parameter: "#c0caf5",
  function: "#7aa2f7",
  string: "#9ece6a",
  constant: "#bb9af7",
  type: "#2ac3de",
  class: "#c0caf5",
  number: "#ff9e64",
  comment: "#565f89",
  heading: "#89ddff",
  invalid: "#ff5370",
  regexp: "#b4f9f8"
}, ULe = me.theme({
  "&": {
    color: ot.foreground,
    backgroundColor: ot.background
  },
  ".cm-content": { caretColor: ot.cursor },
  ".cm-cursor, .cm-dropCursor": { borderLeftColor: ot.cursor },
  "&.cm-focused > .cm-scroller > .cm-selectionLayer .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: ot.selection },
  ".cm-panels": { backgroundColor: ot.dropdownBackground, color: ot.foreground },
  ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
  ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
  ".cm-searchMatch": {
    backgroundColor: ot.dropdownBackground,
    outline: `1px solid ${ot.dropdownBorder}`
  },
  ".cm-searchMatch.cm-searchMatch-selected": {
    backgroundColor: ot.selection
  },
  ".cm-activeLine": { backgroundColor: ot.activeLine },
  ".cm-selectionMatch": { backgroundColor: ot.selection },
  "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
    backgroundColor: ot.matchingBracket,
    outline: "none"
  },
  ".cm-gutters": {
    backgroundColor: ot.background,
    color: ot.foreground,
    border: "none"
  },
  ".cm-activeLineGutter": { backgroundColor: ot.background },
  ".cm-foldPlaceholder": {
    backgroundColor: "transparent",
    border: "none",
    color: ot.foreground
  },
  ".cm-tooltip": {
    border: `1px solid ${ot.dropdownBorder}`,
    backgroundColor: ot.dropdownBackground,
    color: ot.foreground
  },
  ".cm-tooltip .cm-tooltip-arrow:before": {
    borderTopColor: "transparent",
    borderBottomColor: "transparent"
  },
  ".cm-tooltip .cm-tooltip-arrow:after": {
    borderTopColor: ot.foreground,
    borderBottomColor: ot.foreground
  },
  ".cm-tooltip-autocomplete": {
    "& > ul > li[aria-selected]": {
      background: ot.selection,
      color: ot.foreground
    }
  }
}, { dark: ot.dark }), $Le = Cn.define([
  { tag: A.keyword, color: ot.keyword },
  { tag: [A.name, A.deleted, A.character, A.macroName], color: ot.variable },
  { tag: [A.propertyName], color: ot.function },
  { tag: [A.processingInstruction, A.string, A.inserted, A.special(A.string)], color: ot.string },
  { tag: [A.function(A.variableName), A.labelName], color: ot.function },
  { tag: [A.color, A.constant(A.name), A.standard(A.name)], color: ot.constant },
  { tag: [A.definition(A.name), A.separator], color: ot.variable },
  { tag: [A.className], color: ot.class },
  { tag: [A.number, A.changed, A.annotation, A.modifier, A.self, A.namespace], color: ot.number },
  { tag: [A.typeName], color: ot.type, fontStyle: ot.type },
  { tag: [A.operator, A.operatorKeyword], color: ot.keyword },
  { tag: [A.url, A.escape, A.regexp, A.link], color: ot.regexp },
  { tag: [A.meta, A.comment], color: ot.comment },
  { tag: A.strong, fontWeight: "bold" },
  { tag: A.emphasis, fontStyle: "italic" },
  { tag: A.link, textDecoration: "underline" },
  { tag: A.heading, fontWeight: "bold", color: ot.heading },
  { tag: [A.atom, A.bool, A.special(A.variableName)], color: ot.variable },
  { tag: A.invalid, color: ot.invalid },
  { tag: A.strikethrough, textDecoration: "line-through" }
]), VLe = [
  ULe,
  Do($Le)
];
class RS {
  /**
  @internal
  */
  constructor(e, t, i, n, a, o, s, l, u, c = 0, h) {
    this.p = e, this.stack = t, this.state = i, this.reducePos = n, this.pos = a, this.score = o, this.buffer = s, this.bufferBase = l, this.curContext = u, this.lookAhead = c, this.parent = h;
  }
  /**
  @internal
  */
  toString() {
    return `[${this.stack.filter((e, t) => t % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? "!" + this.score : ""}`;
  }
  // Start an empty stack
  /**
  @internal
  */
  static start(e, t, i = 0) {
    let n = e.parser.context;
    return new RS(e, [], t, i, i, 0, [], 0, n ? new nB(n, n.start) : null, 0, null);
  }
  /**
  The stack's current [context](#lr.ContextTracker) value, if
  any. Its type will depend on the context tracker's type
  parameter, or it will be `null` if there is no context
  tracker.
  */
  get context() {
    return this.curContext ? this.curContext.context : null;
  }
  // Push a state onto the stack, tracking its start position as well
  // as the buffer base at that point.
  /**
  @internal
  */
  pushState(e, t) {
    this.stack.push(this.state, t, this.bufferBase + this.buffer.length), this.state = e;
  }
  // Apply a reduce action
  /**
  @internal
  */
  reduce(e) {
    var t;
    let i = e >> 19, n = e & 65535, { parser: a } = this.p, o = a.dynamicPrecedence(n);
    if (o && (this.score += o), i == 0) {
      this.pushState(a.getGoto(this.state, n, !0), this.reducePos), n < a.minRepeatTerm && this.storeNode(n, this.reducePos, this.reducePos, 4, !0), this.reduceContext(n, this.reducePos);
      return;
    }
    let s = this.stack.length - (i - 1) * 3 - (e & 262144 ? 6 : 0), l = s ? this.stack[s - 2] : this.p.ranges[0].from, u = this.reducePos - l;
    u >= 2e3 && !(!((t = this.p.parser.nodeSet.types[n]) === null || t === void 0) && t.isAnonymous) && (l == this.p.lastBigReductionStart ? (this.p.bigReductionCount++, this.p.lastBigReductionSize = u) : this.p.lastBigReductionSize < u && (this.p.bigReductionCount = 1, this.p.lastBigReductionStart = l, this.p.lastBigReductionSize = u));
    let c = s ? this.stack[s - 1] : 0, h = this.bufferBase + this.buffer.length - c;
    if (n < a.minRepeatTerm || e & 131072) {
      let f = a.stateFlag(
        this.state,
        1
        /* StateFlag.Skipped */
      ) ? this.pos : this.reducePos;
      this.storeNode(n, l, f, h + 4, !0);
    }
    if (e & 262144)
      this.state = this.stack[s];
    else {
      let f = this.stack[s - 3];
      this.state = a.getGoto(f, n, !0);
    }
    for (; this.stack.length > s; )
      this.stack.pop();
    this.reduceContext(n, l);
  }
  // Shift a value into the buffer
  /**
  @internal
  */
  storeNode(e, t, i, n = 4, a = !1) {
    if (e == 0 && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {
      let o = this, s = this.buffer.length;
      if (s == 0 && o.parent && (s = o.bufferBase - o.parent.bufferBase, o = o.parent), s > 0 && o.buffer[s - 4] == 0 && o.buffer[s - 1] > -1) {
        if (t == i)
          return;
        if (o.buffer[s - 2] >= t) {
          o.buffer[s - 2] = i;
          return;
        }
      }
    }
    if (!a || this.pos == i)
      this.buffer.push(e, t, i, n);
    else {
      let o = this.buffer.length;
      if (o > 0 && this.buffer[o - 4] != 0)
        for (; o > 0 && this.buffer[o - 2] > i; )
          this.buffer[o] = this.buffer[o - 4], this.buffer[o + 1] = this.buffer[o - 3], this.buffer[o + 2] = this.buffer[o - 2], this.buffer[o + 3] = this.buffer[o - 1], o -= 4, n > 4 && (n -= 4);
      this.buffer[o] = e, this.buffer[o + 1] = t, this.buffer[o + 2] = i, this.buffer[o + 3] = n;
    }
  }
  // Apply a shift action
  /**
  @internal
  */
  shift(e, t, i) {
    let n = this.pos;
    if (e & 131072)
      this.pushState(e & 65535, this.pos);
    else if (e & 262144)
      this.pos = i, this.shiftContext(t, n), t <= this.p.parser.maxNode && this.buffer.push(t, n, i, 4);
    else {
      let a = e, { parser: o } = this.p;
      (i > this.pos || t <= o.maxNode) && (this.pos = i, o.stateFlag(
        a,
        1
        /* StateFlag.Skipped */
      ) || (this.reducePos = i)), this.pushState(a, n), this.shiftContext(t, n), t <= o.maxNode && this.buffer.push(t, n, i, 4);
    }
  }
  // Apply an action
  /**
  @internal
  */
  apply(e, t, i) {
    e & 65536 ? this.reduce(e) : this.shift(e, t, i);
  }
  // Add a prebuilt (reused) node into the buffer.
  /**
  @internal
  */
  useNode(e, t) {
    let i = this.p.reused.length - 1;
    (i < 0 || this.p.reused[i] != e) && (this.p.reused.push(e), i++);
    let n = this.pos;
    this.reducePos = this.pos = n + e.length, this.pushState(t, n), this.buffer.push(
      i,
      n,
      this.reducePos,
      -1
      /* size == -1 means this is a reused value */
    ), this.curContext && this.updateContext(this.curContext.tracker.reuse(this.curContext.context, e, this, this.p.stream.reset(this.pos - e.length)));
  }
  // Split the stack. Due to the buffer sharing and the fact
  // that `this.stack` tends to stay quite shallow, this isn't very
  // expensive.
  /**
  @internal
  */
  split() {
    let e = this, t = e.buffer.length;
    for (; t > 0 && e.buffer[t - 2] > e.reducePos; )
      t -= 4;
    let i = e.buffer.slice(t), n = e.bufferBase + t;
    for (; e && n == e.bufferBase; )
      e = e.parent;
    return new RS(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, i, n, this.curContext, this.lookAhead, e);
  }
  // Try to recover from an error by 'deleting' (ignoring) one token.
  /**
  @internal
  */
  recoverByDelete(e, t) {
    let i = e <= this.p.parser.maxNode;
    i && this.storeNode(e, this.pos, t, 4), this.storeNode(0, this.pos, t, i ? 8 : 4), this.pos = this.reducePos = t, this.score -= 190;
  }
  /**
  Check if the given term would be able to be shifted (optionally
  after some reductions) on this stack. This can be useful for
  external tokenizers that want to make sure they only provide a
  given token when it applies.
  */
  canShift(e) {
    for (let t = new GLe(this); ; ) {
      let i = this.p.parser.stateSlot(
        t.state,
        4
        /* ParseState.DefaultReduce */
      ) || this.p.parser.hasAction(t.state, e);
      if (i == 0)
        return !1;
      if (!(i & 65536))
        return !0;
      t.reduce(i);
    }
  }
  // Apply up to Recover.MaxNext recovery actions that conceptually
  // inserts some missing token or rule.
  /**
  @internal
  */
  recoverByInsert(e) {
    if (this.stack.length >= 300)
      return [];
    let t = this.p.parser.nextStates(this.state);
    if (t.length > 8 || this.stack.length >= 120) {
      let n = [];
      for (let a = 0, o; a < t.length; a += 2)
        (o = t[a + 1]) != this.state && this.p.parser.hasAction(o, e) && n.push(t[a], o);
      if (this.stack.length < 120)
        for (let a = 0; n.length < 8 && a < t.length; a += 2) {
          let o = t[a + 1];
          n.some((s, l) => l & 1 && s == o) || n.push(t[a], o);
        }
      t = n;
    }
    let i = [];
    for (let n = 0; n < t.length && i.length < 4; n += 2) {
      let a = t[n + 1];
      if (a == this.state)
        continue;
      let o = this.split();
      o.pushState(a, this.pos), o.storeNode(0, o.pos, o.pos, 4, !0), o.shiftContext(t[n], this.pos), o.score -= 200, i.push(o);
    }
    return i;
  }
  // Force a reduce, if possible. Return false if that can't
  // be done.
  /**
  @internal
  */
  forceReduce() {
    let { parser: e } = this.p, t = e.stateSlot(
      this.state,
      5
      /* ParseState.ForcedReduce */
    );
    if (!(t & 65536))
      return !1;
    if (!e.validAction(this.state, t)) {
      let i = t >> 19, n = t & 65535, a = this.stack.length - i * 3;
      if (a < 0 || e.getGoto(this.stack[a], n, !1) < 0) {
        let o = this.findForcedReduction();
        if (o == null)
          return !1;
        t = o;
      }
      this.storeNode(0, this.pos, this.pos, 4, !0), this.score -= 100;
    }
    return this.reducePos = this.pos, this.reduce(t), !0;
  }
  /**
  Try to scan through the automaton to find some kind of reduction
  that can be applied. Used when the regular ForcedReduce field
  isn't a valid action. @internal
  */
  findForcedReduction() {
    let { parser: e } = this.p, t = [], i = (n, a) => {
      if (!t.includes(n))
        return t.push(n), e.allActions(n, (o) => {
          if (!(o & 393216))
            if (o & 65536) {
              let s = (o >> 19) - a;
              if (s > 1) {
                let l = o & 65535, u = this.stack.length - s * 3;
                if (u >= 0 && e.getGoto(this.stack[u], l, !1) >= 0)
                  return s << 19 | 65536 | l;
              }
            } else {
              let s = i(o, a + 1);
              if (s != null)
                return s;
            }
        });
    };
    return i(this.state, 0);
  }
  /**
  @internal
  */
  forceAll() {
    for (; !this.p.parser.stateFlag(
      this.state,
      2
      /* StateFlag.Accepting */
    ); )
      if (!this.forceReduce()) {
        this.storeNode(0, this.pos, this.pos, 4, !0);
        break;
      }
    return this;
  }
  /**
  Check whether this state has no further actions (assumed to be a direct descendant of the
  top state, since any other states must be able to continue
  somehow). @internal
  */
  get deadEnd() {
    if (this.stack.length != 3)
      return !1;
    let { parser: e } = this.p;
    return e.data[e.stateSlot(
      this.state,
      1
      /* ParseState.Actions */
    )] == 65535 && !e.stateSlot(
      this.state,
      4
      /* ParseState.DefaultReduce */
    );
  }
  /**
  Restart the stack (put it back in its start state). Only safe
  when this.stack.length == 3 (state is directly below the top
  state). @internal
  */
  restart() {
    this.state = this.stack[0], this.stack.length = 0;
  }
  /**
  @internal
  */
  sameState(e) {
    if (this.state != e.state || this.stack.length != e.stack.length)
      return !1;
    for (let t = 0; t < this.stack.length; t += 3)
      if (this.stack[t] != e.stack[t])
        return !1;
    return !0;
  }
  /**
  Get the parser used by this stack.
  */
  get parser() {
    return this.p.parser;
  }
  /**
  Test whether a given dialect (by numeric ID, as exported from
  the terms file) is enabled.
  */
  dialectEnabled(e) {
    return this.p.parser.dialect.flags[e];
  }
  shiftContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.shift(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  reduceContext(e, t) {
    this.curContext && this.updateContext(this.curContext.tracker.reduce(this.curContext.context, e, this, this.p.stream.reset(t)));
  }
  /**
  @internal
  */
  emitContext() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -3) && this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);
  }
  /**
  @internal
  */
  emitLookAhead() {
    let e = this.buffer.length - 1;
    (e < 0 || this.buffer[e] != -4) && this.buffer.push(this.lookAhead, this.pos, this.pos, -4);
  }
  updateContext(e) {
    if (e != this.curContext.context) {
      let t = new nB(this.curContext.tracker, e);
      t.hash != this.curContext.hash && this.emitContext(), this.curContext = t;
    }
  }
  /**
  @internal
  */
  setLookAhead(e) {
    e > this.lookAhead && (this.emitLookAhead(), this.lookAhead = e);
  }
  /**
  @internal
  */
  close() {
    this.curContext && this.curContext.tracker.strict && this.emitContext(), this.lookAhead > 0 && this.emitLookAhead();
  }
}
class nB {
  constructor(e, t) {
    this.tracker = e, this.context = t, this.hash = e.strict ? e.hash(t) : 0;
  }
}
class GLe {
  constructor(e) {
    this.start = e, this.state = e.state, this.stack = e.stack, this.base = this.stack.length;
  }
  reduce(e) {
    let t = e & 65535, i = e >> 19;
    i == 0 ? (this.stack == this.start.stack && (this.stack = this.stack.slice()), this.stack.push(this.state, 0, 0), this.base += 3) : this.base -= (i - 1) * 3;
    let n = this.start.p.parser.getGoto(this.stack[this.base - 3], t, !0);
    this.state = n;
  }
}
class AS {
  constructor(e, t, i) {
    this.stack = e, this.pos = t, this.index = i, this.buffer = e.buffer, this.index == 0 && this.maybeNext();
  }
  static create(e, t = e.bufferBase + e.buffer.length) {
    return new AS(e, t, t - e.bufferBase);
  }
  maybeNext() {
    let e = this.stack.parent;
    e != null && (this.index = this.stack.bufferBase - e.bufferBase, this.stack = e, this.buffer = e.buffer);
  }
  get id() {
    return this.buffer[this.index - 4];
  }
  get start() {
    return this.buffer[this.index - 3];
  }
  get end() {
    return this.buffer[this.index - 2];
  }
  get size() {
    return this.buffer[this.index - 1];
  }
  next() {
    this.index -= 4, this.pos -= 4, this.index == 0 && this.maybeNext();
  }
  fork() {
    return new AS(this.stack, this.pos, this.index);
  }
}
function Np(r, e = Uint16Array) {
  if (typeof r != "string")
    return r;
  let t = null;
  for (let i = 0, n = 0; i < r.length; ) {
    let a = 0;
    for (; ; ) {
      let o = r.charCodeAt(i++), s = !1;
      if (o == 126) {
        a = 65535;
        break;
      }
      o >= 92 && o--, o >= 34 && o--;
      let l = o - 32;
      if (l >= 46 && (l -= 46, s = !0), a += l, s)
        break;
      a *= 46;
    }
    t ? t[n++] = a : t = new e(a);
  }
  return t;
}
class EE {
  constructor() {
    this.start = -1, this.value = -1, this.end = -1, this.extended = -1, this.lookAhead = 0, this.mask = 0, this.context = 0;
  }
}
const aB = new EE();
class BLe {
  /**
  @internal
  */
  constructor(e, t) {
    this.input = e, this.ranges = t, this.chunk = "", this.chunkOff = 0, this.chunk2 = "", this.chunk2Pos = 0, this.next = -1, this.token = aB, this.rangeIndex = 0, this.pos = this.chunkPos = t[0].from, this.range = t[0], this.end = t[t.length - 1].to, this.readNext();
  }
  /**
  @internal
  */
  resolveOffset(e, t) {
    let i = this.range, n = this.rangeIndex, a = this.pos + e;
    for (; a < i.from; ) {
      if (!n)
        return null;
      let o = this.ranges[--n];
      a -= i.from - o.to, i = o;
    }
    for (; t < 0 ? a > i.to : a >= i.to; ) {
      if (n == this.ranges.length - 1)
        return null;
      let o = this.ranges[++n];
      a += o.from - i.to, i = o;
    }
    return a;
  }
  /**
  @internal
  */
  clipPos(e) {
    if (e >= this.range.from && e < this.range.to)
      return e;
    for (let t of this.ranges)
      if (t.to > e)
        return Math.max(e, t.from);
    return this.end;
  }
  /**
  Look at a code unit near the stream position. `.peek(0)` equals
  `.next`, `.peek(-1)` gives you the previous character, and so
  on.
  
  Note that looking around during tokenizing creates dependencies
  on potentially far-away content, which may reduce the
  effectiveness incremental parsingwhen looking forwardor even
  cause invalid reparses when looking backward more than 25 code
  units, since the library does not track lookbehind.
  */
  peek(e) {
    let t = this.chunkOff + e, i, n;
    if (t >= 0 && t < this.chunk.length)
      i = this.pos + e, n = this.chunk.charCodeAt(t);
    else {
      let a = this.resolveOffset(e, 1);
      if (a == null)
        return -1;
      if (i = a, i >= this.chunk2Pos && i < this.chunk2Pos + this.chunk2.length)
        n = this.chunk2.charCodeAt(i - this.chunk2Pos);
      else {
        let o = this.rangeIndex, s = this.range;
        for (; s.to <= i; )
          s = this.ranges[++o];
        this.chunk2 = this.input.chunk(this.chunk2Pos = i), i + this.chunk2.length > s.to && (this.chunk2 = this.chunk2.slice(0, s.to - i)), n = this.chunk2.charCodeAt(0);
      }
    }
    return i >= this.token.lookAhead && (this.token.lookAhead = i + 1), n;
  }
  /**
  Accept a token. By default, the end of the token is set to the
  current stream position, but you can pass an offset (relative to
  the stream position) to change that.
  */
  acceptToken(e, t = 0) {
    let i = t ? this.resolveOffset(t, -1) : this.pos;
    if (i == null || i < this.token.start)
      throw new RangeError("Token end out of bounds");
    this.token.value = e, this.token.end = i;
  }
  getChunk() {
    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {
      let { chunk: e, chunkPos: t } = this;
      this.chunk = this.chunk2, this.chunkPos = this.chunk2Pos, this.chunk2 = e, this.chunk2Pos = t, this.chunkOff = this.pos - this.chunkPos;
    } else {
      this.chunk2 = this.chunk, this.chunk2Pos = this.chunkPos;
      let e = this.input.chunk(this.pos), t = this.pos + e.length;
      this.chunk = t > this.range.to ? e.slice(0, this.range.to - this.pos) : e, this.chunkPos = this.pos, this.chunkOff = 0;
    }
  }
  readNext() {
    return this.chunkOff >= this.chunk.length && (this.getChunk(), this.chunkOff == this.chunk.length) ? this.next = -1 : this.next = this.chunk.charCodeAt(this.chunkOff);
  }
  /**
  Move the stream forward N (defaults to 1) code units. Returns
  the new value of [`next`](#lr.InputStream.next).
  */
  advance(e = 1) {
    for (this.chunkOff += e; this.pos + e >= this.range.to; ) {
      if (this.rangeIndex == this.ranges.length - 1)
        return this.setDone();
      e -= this.range.to - this.pos, this.range = this.ranges[++this.rangeIndex], this.pos = this.range.from;
    }
    return this.pos += e, this.pos >= this.token.lookAhead && (this.token.lookAhead = this.pos + 1), this.readNext();
  }
  setDone() {
    return this.pos = this.chunkPos = this.end, this.range = this.ranges[this.rangeIndex = this.ranges.length - 1], this.chunk = "", this.next = -1;
  }
  /**
  @internal
  */
  reset(e, t) {
    if (t ? (this.token = t, t.start = e, t.lookAhead = e + 1, t.value = t.extended = -1) : this.token = aB, this.pos != e) {
      if (this.pos = e, e == this.end)
        return this.setDone(), this;
      for (; e < this.range.from; )
        this.range = this.ranges[--this.rangeIndex];
      for (; e >= this.range.to; )
        this.range = this.ranges[++this.rangeIndex];
      e >= this.chunkPos && e < this.chunkPos + this.chunk.length ? this.chunkOff = e - this.chunkPos : (this.chunk = "", this.chunkOff = 0), this.readNext();
    }
    return this;
  }
  /**
  @internal
  */
  read(e, t) {
    if (e >= this.chunkPos && t <= this.chunkPos + this.chunk.length)
      return this.chunk.slice(e - this.chunkPos, t - this.chunkPos);
    if (e >= this.chunk2Pos && t <= this.chunk2Pos + this.chunk2.length)
      return this.chunk2.slice(e - this.chunk2Pos, t - this.chunk2Pos);
    if (e >= this.range.from && t <= this.range.to)
      return this.input.read(e, t);
    let i = "";
    for (let n of this.ranges) {
      if (n.from >= t)
        break;
      n.to > e && (i += this.input.read(Math.max(n.from, e), Math.min(n.to, t)));
    }
    return i;
  }
}
class Of {
  constructor(e, t) {
    this.data = e, this.id = t;
  }
  token(e, t) {
    let { parser: i } = t.p;
    X8(this.data, e, t, this.id, i.data, i.tokenPrecTable);
  }
}
Of.prototype.contextual = Of.prototype.fallback = Of.prototype.extend = !1;
class _S {
  constructor(e, t, i) {
    this.precTable = t, this.elseToken = i, this.data = typeof e == "string" ? Np(e) : e;
  }
  token(e, t) {
    let i = e.pos, n = 0;
    for (; ; ) {
      let a = e.next < 0, o = e.resolveOffset(1, 1);
      if (X8(this.data, e, t, 0, this.data, this.precTable), e.token.value > -1)
        break;
      if (this.elseToken == null)
        return;
      if (a || n++, o == null)
        break;
      e.reset(o, e.token);
    }
    n && (e.reset(i, e.token), e.acceptToken(this.elseToken, n));
  }
}
_S.prototype.contextual = Of.prototype.fallback = Of.prototype.extend = !1;
class Vi {
  /**
  Create a tokenizer. The first argument is the function that,
  given an input stream, scans for the types of tokens it
  recognizes at the stream's position, and calls
  [`acceptToken`](#lr.InputStream.acceptToken) when it finds
  one.
  */
  constructor(e, t = {}) {
    this.token = e, this.contextual = !!t.contextual, this.fallback = !!t.fallback, this.extend = !!t.extend;
  }
}
function X8(r, e, t, i, n, a) {
  let o = 0, s = 1 << i, { dialect: l } = t.p.parser;
  e:
    for (; s & r[o]; ) {
      let u = r[o + 1];
      for (let d = o + 3; d < u; d += 2)
        if ((r[d + 1] & s) > 0) {
          let p = r[d];
          if (l.allows(p) && (e.token.value == -1 || e.token.value == p || FLe(p, e.token.value, n, a))) {
            e.acceptToken(p);
            break;
          }
        }
      let c = e.next, h = 0, f = r[o + 2];
      if (e.next < 0 && f > h && r[u + f * 3 - 3] == 65535 && r[u + f * 3 - 3] == 65535) {
        o = r[u + f * 3 - 1];
        continue e;
      }
      for (; h < f; ) {
        let d = h + f >> 1, p = u + d + (d << 1), g = r[p], v = r[p + 1] || 65536;
        if (c < g)
          f = d;
        else if (c >= v)
          h = d + 1;
        else {
          o = r[p + 2], e.advance();
          continue e;
        }
      }
      break;
    }
}
function oB(r, e, t) {
  for (let i = e, n; (n = r[i]) != 65535; i++)
    if (n == t)
      return i - e;
  return -1;
}
function FLe(r, e, t, i) {
  let n = oB(t, i, e);
  return n < 0 || oB(t, i, r) < n;
}
const ln = typeof process < "u" && {} && /\bparse\b/.test({}.LOG);
let PA = null;
function sB(r, e, t) {
  let i = r.cursor(Xt.IncludeAnonymous);
  for (i.moveTo(e); ; )
    if (!(t < 0 ? i.childBefore(e) : i.childAfter(e)))
      for (; ; ) {
        if ((t < 0 ? i.to < e : i.from > e) && !i.type.isError)
          return t < 0 ? Math.max(0, Math.min(
            i.to - 1,
            e - 25
            /* Safety.Margin */
          )) : Math.min(r.length, Math.max(
            i.from + 1,
            e + 25
            /* Safety.Margin */
          ));
        if (t < 0 ? i.prevSibling() : i.nextSibling())
          break;
        if (!i.parent())
          return t < 0 ? 0 : r.length;
      }
}
class XLe {
  constructor(e, t) {
    this.fragments = e, this.nodeSet = t, this.i = 0, this.fragment = null, this.safeFrom = -1, this.safeTo = -1, this.trees = [], this.start = [], this.index = [], this.nextFragment();
  }
  nextFragment() {
    let e = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];
    if (e) {
      for (this.safeFrom = e.openStart ? sB(e.tree, e.from + e.offset, 1) - e.offset : e.from, this.safeTo = e.openEnd ? sB(e.tree, e.to + e.offset, -1) - e.offset : e.to; this.trees.length; )
        this.trees.pop(), this.start.pop(), this.index.pop();
      this.trees.push(e.tree), this.start.push(-e.offset), this.index.push(0), this.nextStart = this.safeFrom;
    } else
      this.nextStart = 1e9;
  }
  // `pos` must be >= any previously given `pos` for this cursor
  nodeAt(e) {
    if (e < this.nextStart)
      return null;
    for (; this.fragment && this.safeTo <= e; )
      this.nextFragment();
    if (!this.fragment)
      return null;
    for (; ; ) {
      let t = this.trees.length - 1;
      if (t < 0)
        return this.nextFragment(), null;
      let i = this.trees[t], n = this.index[t];
      if (n == i.children.length) {
        this.trees.pop(), this.start.pop(), this.index.pop();
        continue;
      }
      let a = i.children[n], o = this.start[t] + i.positions[n];
      if (o > e)
        return this.nextStart = o, null;
      if (a instanceof nr) {
        if (o == e) {
          if (o < this.safeFrom)
            return null;
          let s = o + a.length;
          if (s <= this.safeTo) {
            let l = a.prop(gt.lookAhead);
            if (!l || s + l < this.fragment.to)
              return a;
          }
        }
        this.index[t]++, o + a.length >= Math.max(this.safeFrom, e) && (this.trees.push(a), this.start.push(o), this.index.push(0));
      } else
        this.index[t]++, this.nextStart = o + a.length;
    }
  }
}
class YLe {
  constructor(e, t) {
    this.stream = t, this.tokens = [], this.mainToken = null, this.actions = [], this.tokens = e.tokenizers.map((i) => new EE());
  }
  getActions(e) {
    let t = 0, i = null, { parser: n } = e.p, { tokenizers: a } = n, o = n.stateSlot(
      e.state,
      3
      /* ParseState.TokenizerMask */
    ), s = e.curContext ? e.curContext.hash : 0, l = 0;
    for (let u = 0; u < a.length; u++) {
      if (!(1 << u & o))
        continue;
      let c = a[u], h = this.tokens[u];
      if (!(i && !c.fallback) && ((c.contextual || h.start != e.pos || h.mask != o || h.context != s) && (this.updateCachedToken(h, c, e), h.mask = o, h.context = s), h.lookAhead > h.end + 25 && (l = Math.max(h.lookAhead, l)), h.value != 0)) {
        let f = t;
        if (h.extended > -1 && (t = this.addActions(e, h.extended, h.end, t)), t = this.addActions(e, h.value, h.end, t), !c.extend && (i = h, t > f))
          break;
      }
    }
    for (; this.actions.length > t; )
      this.actions.pop();
    return l && e.setLookAhead(l), !i && e.pos == this.stream.end && (i = new EE(), i.value = e.p.parser.eofTerm, i.start = i.end = e.pos, t = this.addActions(e, i.value, i.end, t)), this.mainToken = i, this.actions;
  }
  getMainToken(e) {
    if (this.mainToken)
      return this.mainToken;
    let t = new EE(), { pos: i, p: n } = e;
    return t.start = i, t.end = Math.min(i + 1, n.stream.end), t.value = i == n.stream.end ? n.parser.eofTerm : 0, t;
  }
  updateCachedToken(e, t, i) {
    let n = this.stream.clipPos(i.pos);
    if (t.token(this.stream.reset(n, e), i), e.value > -1) {
      let { parser: a } = i.p;
      for (let o = 0; o < a.specialized.length; o++)
        if (a.specialized[o] == e.value) {
          let s = a.specializers[o](this.stream.read(e.start, e.end), i);
          if (s >= 0 && i.p.parser.dialect.allows(s >> 1)) {
            s & 1 ? e.extended = s >> 1 : e.value = s >> 1;
            break;
          }
        }
    } else
      e.value = 0, e.end = this.stream.clipPos(n + 1);
  }
  putAction(e, t, i, n) {
    for (let a = 0; a < n; a += 3)
      if (this.actions[a] == e)
        return n;
    return this.actions[n++] = e, this.actions[n++] = t, this.actions[n++] = i, n;
  }
  addActions(e, t, i, n) {
    let { state: a } = e, { parser: o } = e.p, { data: s } = o;
    for (let l = 0; l < 2; l++)
      for (let u = o.stateSlot(
        a,
        l ? 2 : 1
        /* ParseState.Actions */
      ); ; u += 3) {
        if (s[u] == 65535)
          if (s[u + 1] == 1)
            u = Xo(s, u + 2);
          else {
            n == 0 && s[u + 1] == 2 && (n = this.putAction(Xo(s, u + 2), t, i, n));
            break;
          }
        s[u] == t && (n = this.putAction(Xo(s, u + 1), t, i, n));
      }
    return n;
  }
}
class HLe {
  constructor(e, t, i, n) {
    this.parser = e, this.input = t, this.ranges = n, this.recovering = 0, this.nextStackID = 9812, this.minStackPos = 0, this.reused = [], this.stoppedAt = null, this.lastBigReductionStart = -1, this.lastBigReductionSize = 0, this.bigReductionCount = 0, this.stream = new BLe(t, n), this.tokens = new YLe(e, this.stream), this.topTerm = e.top[1];
    let { from: a } = n[0];
    this.stacks = [RS.start(this, e.top[0], a)], this.fragments = i.length && this.stream.end - a > e.bufferLength * 4 ? new XLe(i, e.nodeSet) : null;
  }
  get parsedPos() {
    return this.minStackPos;
  }
  // Move the parser forward. This will process all parse stacks at
  // `this.pos` and try to advance them to a further position. If no
  // stack for such a position is found, it'll start error-recovery.
  //
  // When the parse is finished, this will return a syntax tree. When
  // not, it returns `null`.
  advance() {
    let e = this.stacks, t = this.minStackPos, i = this.stacks = [], n, a;
    if (this.bigReductionCount > 300 && e.length == 1) {
      let [o] = e;
      for (; o.forceReduce() && o.stack.length && o.stack[o.stack.length - 2] >= this.lastBigReductionStart; )
        ;
      this.bigReductionCount = this.lastBigReductionSize = 0;
    }
    for (let o = 0; o < e.length; o++) {
      let s = e[o];
      for (; ; ) {
        if (this.tokens.mainToken = null, s.pos > t)
          i.push(s);
        else {
          if (this.advanceStack(s, i, e))
            continue;
          {
            n || (n = [], a = []), n.push(s);
            let l = this.tokens.getMainToken(s);
            a.push(l.value, l.end);
          }
        }
        break;
      }
    }
    if (!i.length) {
      let o = n && zLe(n);
      if (o)
        return ln && console.log("Finish with " + this.stackID(o)), this.stackToTree(o);
      if (this.parser.strict)
        throw ln && n && console.log("Stuck with token " + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : "none")), new SyntaxError("No parse at " + t);
      this.recovering || (this.recovering = 5);
    }
    if (this.recovering && n) {
      let o = this.stoppedAt != null && n[0].pos > this.stoppedAt ? n[0] : this.runRecovery(n, a, i);
      if (o)
        return ln && console.log("Force-finish " + this.stackID(o)), this.stackToTree(o.forceAll());
    }
    if (this.recovering) {
      let o = this.recovering == 1 ? 1 : this.recovering * 3;
      if (i.length > o)
        for (i.sort((s, l) => l.score - s.score); i.length > o; )
          i.pop();
      i.some((s) => s.reducePos > t) && this.recovering--;
    } else if (i.length > 1) {
      e:
        for (let o = 0; o < i.length - 1; o++) {
          let s = i[o];
          for (let l = o + 1; l < i.length; l++) {
            let u = i[l];
            if (s.sameState(u) || s.buffer.length > 500 && u.buffer.length > 500)
              if ((s.score - u.score || s.buffer.length - u.buffer.length) > 0)
                i.splice(l--, 1);
              else {
                i.splice(o--, 1);
                continue e;
              }
          }
        }
      i.length > 12 && i.splice(
        12,
        i.length - 12
        /* Rec.MaxStackCount */
      );
    }
    this.minStackPos = i[0].pos;
    for (let o = 1; o < i.length; o++)
      i[o].pos < this.minStackPos && (this.minStackPos = i[o].pos);
    return null;
  }
  stopAt(e) {
    if (this.stoppedAt != null && this.stoppedAt < e)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = e;
  }
  // Returns an updated version of the given stack, or null if the
  // stack can't advance normally. When `split` and `stacks` are
  // given, stacks split off by ambiguous operations will be pushed to
  // `split`, or added to `stacks` if they move `pos` forward.
  advanceStack(e, t, i) {
    let n = e.pos, { parser: a } = this, o = ln ? this.stackID(e) + " -> " : "";
    if (this.stoppedAt != null && n > this.stoppedAt)
      return e.forceReduce() ? e : null;
    if (this.fragments) {
      let u = e.curContext && e.curContext.tracker.strict, c = u ? e.curContext.hash : 0;
      for (let h = this.fragments.nodeAt(n); h; ) {
        let f = this.parser.nodeSet.types[h.type.id] == h.type ? a.getGoto(e.state, h.type.id) : -1;
        if (f > -1 && h.length && (!u || (h.prop(gt.contextHash) || 0) == c))
          return e.useNode(h, f), ln && console.log(o + this.stackID(e) + ` (via reuse of ${a.getName(h.type.id)})`), !0;
        if (!(h instanceof nr) || h.children.length == 0 || h.positions[0] > 0)
          break;
        let d = h.children[0];
        if (d instanceof nr && h.positions[0] == 0)
          h = d;
        else
          break;
      }
    }
    let s = a.stateSlot(
      e.state,
      4
      /* ParseState.DefaultReduce */
    );
    if (s > 0)
      return e.reduce(s), ln && console.log(o + this.stackID(e) + ` (via always-reduce ${a.getName(
        s & 65535
        /* Action.ValueMask */
      )})`), !0;
    if (e.stack.length >= 15e3)
      for (; e.stack.length > 9e3 && e.forceReduce(); )
        ;
    let l = this.tokens.getActions(e);
    for (let u = 0; u < l.length; ) {
      let c = l[u++], h = l[u++], f = l[u++], d = u == l.length || !i, p = d ? e : e.split();
      if (p.apply(c, h, f), ln && console.log(o + this.stackID(p) + ` (via ${c & 65536 ? `reduce of ${a.getName(
        c & 65535
        /* Action.ValueMask */
      )}` : "shift"} for ${a.getName(h)} @ ${n}${p == e ? "" : ", split"})`), d)
        return !0;
      p.pos > n ? t.push(p) : i.push(p);
    }
    return !1;
  }
  // Advance a given stack forward as far as it will go. Returns the
  // (possibly updated) stack if it got stuck, or null if it moved
  // forward and was given to `pushStackDedup`.
  advanceFully(e, t) {
    let i = e.pos;
    for (; ; ) {
      if (!this.advanceStack(e, null, null))
        return !1;
      if (e.pos > i)
        return lB(e, t), !0;
    }
  }
  runRecovery(e, t, i) {
    let n = null, a = !1;
    for (let o = 0; o < e.length; o++) {
      let s = e[o], l = t[o << 1], u = t[(o << 1) + 1], c = ln ? this.stackID(s) + " -> " : "";
      if (s.deadEnd && (a || (a = !0, s.restart(), ln && console.log(c + this.stackID(s) + " (restarted)"), this.advanceFully(s, i))))
        continue;
      let h = s.split(), f = c;
      for (let d = 0; h.forceReduce() && d < 10 && (ln && console.log(f + this.stackID(h) + " (via force-reduce)"), !this.advanceFully(h, i)); d++)
        ln && (f = this.stackID(h) + " -> ");
      for (let d of s.recoverByInsert(l))
        ln && console.log(c + this.stackID(d) + " (via recover-insert)"), this.advanceFully(d, i);
      this.stream.end > s.pos ? (u == s.pos && (u++, l = 0), s.recoverByDelete(l, u), ln && console.log(c + this.stackID(s) + ` (via recover-delete ${this.parser.getName(l)})`), lB(s, i)) : (!n || n.score < s.score) && (n = s);
    }
    return n;
  }
  // Convert the stack's buffer to a syntax tree.
  stackToTree(e) {
    return e.close(), nr.build({
      buffer: AS.create(e),
      nodeSet: this.parser.nodeSet,
      topID: this.topTerm,
      maxBufferLength: this.parser.bufferLength,
      reused: this.reused,
      start: this.ranges[0].from,
      length: e.pos - this.ranges[0].from,
      minRepeatType: this.parser.minRepeatTerm
    });
  }
  stackID(e) {
    let t = (PA || (PA = /* @__PURE__ */ new WeakMap())).get(e);
    return t || PA.set(e, t = String.fromCodePoint(this.nextStackID++)), t + e;
  }
}
function lB(r, e) {
  for (let t = 0; t < e.length; t++) {
    let i = e[t];
    if (i.pos == r.pos && i.sameState(r)) {
      e[t].score < r.score && (e[t] = r);
      return;
    }
  }
  e.push(r);
}
class WLe {
  constructor(e, t, i) {
    this.source = e, this.flags = t, this.disabled = i;
  }
  allows(e) {
    return !this.disabled || this.disabled[e] == 0;
  }
}
const LA = (r) => r;
class yP {
  /**
  Define a context tracker.
  */
  constructor(e) {
    this.start = e.start, this.shift = e.shift || LA, this.reduce = e.reduce || LA, this.reuse = e.reuse || LA, this.hash = e.hash || (() => 0), this.strict = e.strict !== !1;
  }
}
class No extends Q6 {
  /**
  @internal
  */
  constructor(e) {
    if (super(), this.wrappers = [], e.version != 14)
      throw new RangeError(`Parser version (${e.version}) doesn't match runtime version (14)`);
    let t = e.nodeNames.split(" ");
    this.minRepeatTerm = t.length;
    for (let s = 0; s < e.repeatNodeCount; s++)
      t.push("");
    let i = Object.keys(e.topRules).map((s) => e.topRules[s][1]), n = [];
    for (let s = 0; s < t.length; s++)
      n.push([]);
    function a(s, l, u) {
      n[s].push([l, l.deserialize(String(u))]);
    }
    if (e.nodeProps)
      for (let s of e.nodeProps) {
        let l = s[0];
        typeof l == "string" && (l = gt[l]);
        for (let u = 1; u < s.length; ) {
          let c = s[u++];
          if (c >= 0)
            a(c, l, s[u++]);
          else {
            let h = s[u + -c];
            for (let f = -c; f > 0; f--)
              a(s[u++], l, h);
            u++;
          }
        }
      }
    this.nodeSet = new Fx(t.map((s, l) => Rn.define({
      name: l >= this.minRepeatTerm ? void 0 : s,
      id: l,
      props: n[l],
      top: i.indexOf(l) > -1,
      error: l == 0,
      skipped: e.skippedNodes && e.skippedNodes.indexOf(l) > -1
    }))), e.propSources && (this.nodeSet = this.nodeSet.extend(...e.propSources)), this.strict = !1, this.bufferLength = P6;
    let o = Np(e.tokenData);
    this.context = e.context, this.specializerSpecs = e.specialized || [], this.specialized = new Uint16Array(this.specializerSpecs.length);
    for (let s = 0; s < this.specializerSpecs.length; s++)
      this.specialized[s] = this.specializerSpecs[s].term;
    this.specializers = this.specializerSpecs.map(uB), this.states = Np(e.states, Uint32Array), this.data = Np(e.stateData), this.goto = Np(e.goto), this.maxTerm = e.maxTerm, this.tokenizers = e.tokenizers.map((s) => typeof s == "number" ? new Of(o, s) : s), this.topRules = e.topRules, this.dialects = e.dialects || {}, this.dynamicPrecedences = e.dynamicPrecedences || null, this.tokenPrecTable = e.tokenPrec, this.termNames = e.termNames || null, this.maxNode = this.nodeSet.types.length - 1, this.dialect = this.parseDialect(), this.top = this.topRules[Object.keys(this.topRules)[0]];
  }
  createParse(e, t, i) {
    let n = new HLe(this, e, t, i);
    for (let a of this.wrappers)
      n = a(n, e, t, i);
    return n;
  }
  /**
  Get a goto table entry @internal
  */
  getGoto(e, t, i = !1) {
    let n = this.goto;
    if (t >= n[0])
      return -1;
    for (let a = n[t + 1]; ; ) {
      let o = n[a++], s = o & 1, l = n[a++];
      if (s && i)
        return l;
      for (let u = a + (o >> 1); a < u; a++)
        if (n[a] == e)
          return l;
      if (s)
        return -1;
    }
  }
  /**
  Check if this state has an action for a given terminal @internal
  */
  hasAction(e, t) {
    let i = this.data;
    for (let n = 0; n < 2; n++)
      for (let a = this.stateSlot(
        e,
        n ? 2 : 1
        /* ParseState.Actions */
      ), o; ; a += 3) {
        if ((o = i[a]) == 65535)
          if (i[a + 1] == 1)
            o = i[a = Xo(i, a + 2)];
          else {
            if (i[a + 1] == 2)
              return Xo(i, a + 2);
            break;
          }
        if (o == t || o == 0)
          return Xo(i, a + 1);
      }
    return 0;
  }
  /**
  @internal
  */
  stateSlot(e, t) {
    return this.states[e * 6 + t];
  }
  /**
  @internal
  */
  stateFlag(e, t) {
    return (this.stateSlot(
      e,
      0
      /* ParseState.Flags */
    ) & t) > 0;
  }
  /**
  @internal
  */
  validAction(e, t) {
    return !!this.allActions(e, (i) => i == t ? !0 : null);
  }
  /**
  @internal
  */
  allActions(e, t) {
    let i = this.stateSlot(
      e,
      4
      /* ParseState.DefaultReduce */
    ), n = i ? t(i) : void 0;
    for (let a = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); n == null; a += 3) {
      if (this.data[a] == 65535)
        if (this.data[a + 1] == 1)
          a = Xo(this.data, a + 2);
        else
          break;
      n = t(Xo(this.data, a + 1));
    }
    return n;
  }
  /**
  Get the states that can follow this one through shift actions or
  goto jumps. @internal
  */
  nextStates(e) {
    let t = [];
    for (let i = this.stateSlot(
      e,
      1
      /* ParseState.Actions */
    ); ; i += 3) {
      if (this.data[i] == 65535)
        if (this.data[i + 1] == 1)
          i = Xo(this.data, i + 2);
        else
          break;
      if (!(this.data[i + 2] & 1)) {
        let n = this.data[i + 1];
        t.some((a, o) => o & 1 && a == n) || t.push(this.data[i], n);
      }
    }
    return t;
  }
  /**
  Configure the parser. Returns a new parser instance that has the
  given settings modified. Settings not provided in `config` are
  kept from the original parser.
  */
  configure(e) {
    let t = Object.assign(Object.create(No.prototype), this);
    if (e.props && (t.nodeSet = this.nodeSet.extend(...e.props)), e.top) {
      let i = this.topRules[e.top];
      if (!i)
        throw new RangeError(`Invalid top rule name ${e.top}`);
      t.top = i;
    }
    return e.tokenizers && (t.tokenizers = this.tokenizers.map((i) => {
      let n = e.tokenizers.find((a) => a.from == i);
      return n ? n.to : i;
    })), e.specializers && (t.specializers = this.specializers.slice(), t.specializerSpecs = this.specializerSpecs.map((i, n) => {
      let a = e.specializers.find((s) => s.from == i.external);
      if (!a)
        return i;
      let o = Object.assign(Object.assign({}, i), { external: a.to });
      return t.specializers[n] = uB(o), o;
    })), e.contextTracker && (t.context = e.contextTracker), e.dialect && (t.dialect = this.parseDialect(e.dialect)), e.strict != null && (t.strict = e.strict), e.wrap && (t.wrappers = t.wrappers.concat(e.wrap)), e.bufferLength != null && (t.bufferLength = e.bufferLength), t;
  }
  /**
  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)
  are registered for this parser.
  */
  hasWrappers() {
    return this.wrappers.length > 0;
  }
  /**
  Returns the name associated with a given term. This will only
  work for all terms when the parser was generated with the
  `--names` option. By default, only the names of tagged terms are
  stored.
  */
  getName(e) {
    return this.termNames ? this.termNames[e] : String(e <= this.maxNode && this.nodeSet.types[e].name || e);
  }
  /**
  The eof term id is always allocated directly after the node
  types. @internal
  */
  get eofTerm() {
    return this.maxNode + 1;
  }
  /**
  The type of top node produced by the parser.
  */
  get topNode() {
    return this.nodeSet.types[this.top[1]];
  }
  /**
  @internal
  */
  dynamicPrecedence(e) {
    let t = this.dynamicPrecedences;
    return t == null ? 0 : t[e] || 0;
  }
  /**
  @internal
  */
  parseDialect(e) {
    let t = Object.keys(this.dialects), i = t.map(() => !1);
    if (e)
      for (let a of e.split(" ")) {
        let o = t.indexOf(a);
        o >= 0 && (i[o] = !0);
      }
    let n = null;
    for (let a = 0; a < t.length; a++)
      if (!i[a])
        for (let o = this.dialects[t[a]], s; (s = this.data[o++]) != 65535; )
          (n || (n = new Uint8Array(this.maxTerm + 1)))[s] = 1;
    return new WLe(e, i, n);
  }
  /**
  Used by the output of the parser generator. Not available to
  user code. @hide
  */
  static deserialize(e) {
    return new No(e);
  }
}
function Xo(r, e) {
  return r[e] | r[e + 1] << 16;
}
function zLe(r) {
  let e = null;
  for (let t of r) {
    let i = t.p.stoppedAt;
    (t.pos == t.p.stream.end || i != null && t.pos > i) && t.p.parser.stateFlag(
      t.state,
      2
      /* StateFlag.Accepting */
    ) && (!e || e.score < t.score) && (e = t);
  }
  return e;
}
function uB(r) {
  if (r.external) {
    let e = r.extend ? 1 : 0;
    return (t, i) => r.external(t, i) << 1 | e;
  }
  return r.get;
}
const ZLe = 54, qLe = 1, jLe = 55, KLe = 2, JLe = 56, eDe = 3, cB = 4, tDe = 5, CS = 6, Y8 = 7, H8 = 8, W8 = 9, z8 = 10, rDe = 11, iDe = 12, nDe = 13, DA = 57, aDe = 14, hB = 58, Z8 = 20, oDe = 22, q8 = 23, sDe = 24, hw = 26, j8 = 27, lDe = 28, uDe = 31, cDe = 34, hDe = 36, fDe = 37, dDe = 0, pDe = 1, gDe = {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  command: !0,
  embed: !0,
  frame: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0,
  menuitem: !0
}, vDe = {
  dd: !0,
  li: !0,
  optgroup: !0,
  option: !0,
  p: !0,
  rp: !0,
  rt: !0,
  tbody: !0,
  td: !0,
  tfoot: !0,
  th: !0,
  tr: !0
}, fB = {
  dd: { dd: !0, dt: !0 },
  dt: { dd: !0, dt: !0 },
  li: { li: !0 },
  option: { option: !0, optgroup: !0 },
  optgroup: { optgroup: !0 },
  p: {
    address: !0,
    article: !0,
    aside: !0,
    blockquote: !0,
    dir: !0,
    div: !0,
    dl: !0,
    fieldset: !0,
    footer: !0,
    form: !0,
    h1: !0,
    h2: !0,
    h3: !0,
    h4: !0,
    h5: !0,
    h6: !0,
    header: !0,
    hgroup: !0,
    hr: !0,
    menu: !0,
    nav: !0,
    ol: !0,
    p: !0,
    pre: !0,
    section: !0,
    table: !0,
    ul: !0
  },
  rp: { rp: !0, rt: !0 },
  rt: { rp: !0, rt: !0 },
  tbody: { tbody: !0, tfoot: !0 },
  td: { td: !0, th: !0 },
  tfoot: { tbody: !0 },
  th: { td: !0, th: !0 },
  thead: { tbody: !0, tfoot: !0 },
  tr: { tr: !0 }
};
function ODe(r) {
  return r == 45 || r == 46 || r == 58 || r >= 65 && r <= 90 || r == 95 || r >= 97 && r <= 122 || r >= 161;
}
function K8(r) {
  return r == 9 || r == 10 || r == 13 || r == 32;
}
let dB = null, pB = null, gB = 0;
function fw(r, e) {
  let t = r.pos + e;
  if (gB == t && pB == r)
    return dB;
  let i = r.peek(e);
  for (; K8(i); )
    i = r.peek(++e);
  let n = "";
  for (; ODe(i); )
    n += String.fromCharCode(i), i = r.peek(++e);
  return pB = r, gB = t, dB = n ? n.toLowerCase() : i == mDe || i == EDe ? void 0 : null;
}
const J8 = 60, IS = 62, RP = 47, mDe = 63, EDe = 33, bDe = 45;
function vB(r, e) {
  this.name = r, this.parent = e, this.hash = e ? e.hash : 0;
  for (let t = 0; t < r.length; t++)
    this.hash += (this.hash << 4) + r.charCodeAt(t) + (r.charCodeAt(t) << 8);
}
const SDe = [CS, z8, Y8, H8, W8], TDe = new yP({
  start: null,
  shift(r, e, t, i) {
    return SDe.indexOf(e) > -1 ? new vB(fw(i, 1) || "", r) : r;
  },
  reduce(r, e) {
    return e == Z8 && r ? r.parent : r;
  },
  reuse(r, e, t, i) {
    let n = e.type.id;
    return n == CS || n == hDe ? new vB(fw(i, 1) || "", r) : r;
  },
  hash(r) {
    return r ? r.hash : 0;
  },
  strict: !1
}), yDe = new Vi((r, e) => {
  if (r.next != J8) {
    r.next < 0 && e.context && r.acceptToken(DA);
    return;
  }
  r.advance();
  let t = r.next == RP;
  t && r.advance();
  let i = fw(r, 0);
  if (i === void 0)
    return;
  if (!i)
    return r.acceptToken(t ? aDe : CS);
  let n = e.context ? e.context.name : null;
  if (t) {
    if (i == n)
      return r.acceptToken(rDe);
    if (n && vDe[n])
      return r.acceptToken(DA, -2);
    if (e.dialectEnabled(dDe))
      return r.acceptToken(iDe);
    for (let a = e.context; a; a = a.parent)
      if (a.name == i)
        return;
    r.acceptToken(nDe);
  } else {
    if (i == "script")
      return r.acceptToken(Y8);
    if (i == "style")
      return r.acceptToken(H8);
    if (i == "textarea")
      return r.acceptToken(W8);
    if (gDe.hasOwnProperty(i))
      return r.acceptToken(z8);
    n && fB[n] && fB[n][i] ? r.acceptToken(DA, -1) : r.acceptToken(CS);
  }
}, { contextual: !0 }), RDe = new Vi((r) => {
  for (let e = 0, t = 0; ; t++) {
    if (r.next < 0) {
      t && r.acceptToken(hB);
      break;
    }
    if (r.next == bDe)
      e++;
    else if (r.next == IS && e >= 2) {
      t > 3 && r.acceptToken(hB, -2);
      break;
    } else
      e = 0;
    r.advance();
  }
});
function ADe(r) {
  for (; r; r = r.parent)
    if (r.name == "svg" || r.name == "math")
      return !0;
  return !1;
}
const _De = new Vi((r, e) => {
  if (r.next == RP && r.peek(1) == IS) {
    let t = e.dialectEnabled(pDe) || ADe(e.context);
    r.acceptToken(t ? tDe : cB, 2);
  } else
    r.next == IS && r.acceptToken(cB, 1);
});
function AP(r, e, t) {
  let i = 2 + r.length;
  return new Vi((n) => {
    for (let a = 0, o = 0, s = 0; ; s++) {
      if (n.next < 0) {
        s && n.acceptToken(e);
        break;
      }
      if (a == 0 && n.next == J8 || a == 1 && n.next == RP || a >= 2 && a < i && n.next == r.charCodeAt(a - 2))
        a++, o++;
      else if ((a == 2 || a == i) && K8(n.next))
        o++;
      else if (a == i && n.next == IS) {
        s > o ? n.acceptToken(e, -o) : n.acceptToken(t, -(o - 2));
        break;
      } else if ((n.next == 10 || n.next == 13) && s) {
        n.acceptToken(e, 1);
        break;
      } else
        a = o = 0;
      n.advance();
    }
  });
}
const CDe = AP("script", ZLe, qLe), IDe = AP("style", jLe, KLe), wDe = AP("textarea", JLe, eDe), NDe = ql({
  "Text RawText": A.content,
  "StartTag StartCloseTag SelfClosingEndTag EndTag": A.angleBracket,
  TagName: A.tagName,
  "MismatchedCloseTag/TagName": [A.tagName, A.invalid],
  AttributeName: A.attributeName,
  "AttributeValue UnquotedAttributeValue": A.attributeValue,
  Is: A.definitionOperator,
  "EntityReference CharacterReference": A.character,
  Comment: A.blockComment,
  ProcessingInst: A.processingInstruction,
  DoctypeDecl: A.documentMeta
}), xDe = No.deserialize({
  version: 14,
  states: ",xOVO!rOOO!WQ#tO'#CqO!]Q#tO'#CzO!bQ#tO'#C}O!gQ#tO'#DQO!lQ#tO'#DSO!qOaO'#CpO!|ObO'#CpO#XOdO'#CpO$eO!rO'#CpOOO`'#Cp'#CpO$lO$fO'#DTO$tQ#tO'#DVO$yQ#tO'#DWOOO`'#Dk'#DkOOO`'#DY'#DYQVO!rOOO%OQ&rO,59]O%WQ&rO,59fO%`Q&rO,59iO%hQ&rO,59lO%sQ&rO,59nOOOa'#D^'#D^O%{OaO'#CxO&WOaO,59[OOOb'#D_'#D_O&`ObO'#C{O&kObO,59[OOOd'#D`'#D`O&sOdO'#DOO'OOdO,59[OOO`'#Da'#DaO'WO!rO,59[O'_Q#tO'#DROOO`,59[,59[OOOp'#Db'#DbO'dO$fO,59oOOO`,59o,59oO'lQ#|O,59qO'qQ#|O,59rOOO`-E7W-E7WO'vQ&rO'#CsOOQW'#DZ'#DZO(UQ&rO1G.wOOOa1G.w1G.wO(^Q&rO1G/QOOOb1G/Q1G/QO(fQ&rO1G/TOOOd1G/T1G/TO(nQ&rO1G/WOOO`1G/W1G/WOOO`1G/Y1G/YO(yQ&rO1G/YOOOa-E7[-E7[O)RQ#tO'#CyOOO`1G.v1G.vOOOb-E7]-E7]O)WQ#tO'#C|OOOd-E7^-E7^O)]Q#tO'#DPOOO`-E7_-E7_O)bQ#|O,59mOOOp-E7`-E7`OOO`1G/Z1G/ZOOO`1G/]1G/]OOO`1G/^1G/^O)gQ,UO,59_OOQW-E7X-E7XOOOa7+$c7+$cOOOb7+$l7+$lOOOd7+$o7+$oOOO`7+$r7+$rOOO`7+$t7+$tO)rQ#|O,59eO)wQ#|O,59hO)|Q#|O,59kOOO`1G/X1G/XO*RO7[O'#CvO*dOMhO'#CvOOQW1G.y1G.yOOO`1G/P1G/POOO`1G/S1G/SOOO`1G/V1G/VOOOO'#D['#D[O*uO7[O,59bOOQW,59b,59bOOOO'#D]'#D]O+WOMhO,59bOOOO-E7Y-E7YOOQW1G.|1G.|OOOO-E7Z-E7Z",
  stateData: "+s~O!^OS~OUSOVPOWQOXROYTO[]O][O^^O`^Oa^Ob^Oc^Ox^O{_O!dZO~OfaO~OfbO~OfcO~OfdO~OfeO~O!WfOPlP!ZlP~O!XiOQoP!ZoP~O!YlORrP!ZrP~OUSOVPOWQOXROYTOZqO[]O][O^^O`^Oa^Ob^Oc^Ox^O!dZO~O!ZrO~P#dO![sO!euO~OfvO~OfwO~OS|OhyO~OS!OOhyO~OS!QOhyO~OS!SOT!TOhyO~OS!TOhyO~O!WfOPlX!ZlX~OP!WO!Z!XO~O!XiOQoX!ZoX~OQ!ZO!Z!XO~O!YlORrX!ZrX~OR!]O!Z!XO~O!Z!XO~P#dOf!_O~O![sO!e!aO~OS!bO~OS!cO~Oi!dOSgXhgXTgX~OS!fOhyO~OS!gOhyO~OS!hOhyO~OS!iOT!jOhyO~OS!jOhyO~Of!kO~Of!lO~Of!mO~OS!nO~Ok!qO!`!oO!b!pO~OS!rO~OS!sO~OS!tO~Oa!uOb!uOc!uO!`!wO!a!uO~Oa!xOb!xOc!xO!b!wO!c!xO~Oa!uOb!uOc!uO!`!{O!a!uO~Oa!xOb!xOc!xO!b!{O!c!xO~OT~bac!dx{!d~",
  goto: "%p!`PPPPPPPPPPPPPPPPPPPP!a!gP!mPP!yP!|#P#S#Y#]#`#f#i#l#r#x!aP!a!aP$O$U$l$r$x%O%U%[%bPPPPPPPP%hX^OX`pXUOX`pezabcde{}!P!R!UR!q!dRhUR!XhXVOX`pRkVR!XkXWOX`pRnWR!XnXXOX`pQrXR!XpXYOX`pQ`ORx`Q{aQ}bQ!PcQ!RdQ!UeZ!e{}!P!R!UQ!v!oR!z!vQ!y!pR!|!yQgUR!VgQjVR!YjQmWR![mQpXR!^pQtZR!`tS_O`ToXp",
  nodeNames: " StartCloseTag StartCloseTag StartCloseTag EndTag SelfClosingEndTag StartTag StartTag StartTag StartTag StartTag StartCloseTag StartCloseTag StartCloseTag IncompleteCloseTag Document Text EntityReference CharacterReference InvalidEntity Element OpenTag TagName Attribute AttributeName Is AttributeValue UnquotedAttributeValue ScriptText CloseTag OpenTag StyleText CloseTag OpenTag TextareaText CloseTag OpenTag CloseTag SelfClosingTag Comment ProcessingInst MismatchedCloseTag CloseTag DoctypeDecl",
  maxTerm: 67,
  context: TDe,
  nodeProps: [
    ["closedBy", -10, 1, 2, 3, 7, 8, 9, 10, 11, 12, 13, "EndTag", 6, "EndTag SelfClosingEndTag", -4, 21, 30, 33, 36, "CloseTag"],
    ["openedBy", 4, "StartTag StartCloseTag", 5, "StartTag", -4, 29, 32, 35, 37, "OpenTag"],
    ["group", -9, 14, 17, 18, 19, 20, 39, 40, 41, 42, "Entity", 16, "Entity TextContent", -3, 28, 31, 34, "TextContent Entity"]
  ],
  propSources: [NDe],
  skippedNodes: [0],
  repeatNodeCount: 9,
  tokenData: "!<p!aR!YOX$qXY,QYZ,QZ[$q[]&X]^,Q^p$qpq,Qqr-_rs3_sv-_vw3}wxHYx}-_}!OH{!O!P-_!P!Q$q!Q![-_![!]Mz!]!^-_!^!_!$S!_!`!;x!`!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4U-_4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!Z$|c`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr$qrs&}sv$qvw+Pwx(tx!^$q!^!_*V!_!a&X!a#S$q#S#T&X#T;'S$q;'S;=`+z<%lO$q!R&bX`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&Xq'UV`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}P'pT`POv'kw!^'k!_;'S'k;'S;=`(P<%lO'kP(SP;=`<%l'kp([S!cpOv(Vx;'S(V;'S;=`(h<%lO(Vp(kP;=`<%l(Vq(qP;=`<%l&}a({W`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t`)jT!a`Or)esv)ew;'S)e;'S;=`)y<%lO)e`)|P;=`<%l)ea*SP;=`<%l(t!Q*^V!a`!cpOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!Q*vP;=`<%l*V!R*|P;=`<%l&XW+UYkWOX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+PW+wP;=`<%l+P!Z+}P;=`<%l$q!a,]``P!a`!cp!^^OX&XXY,QYZ,QZ]&X]^,Q^p&Xpq,Qqr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!_-ljhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q[/ebhSkWOX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+PS0rXhSqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0mS1bP;=`<%l0m[1hP;=`<%l/^!V1vchS`P!a`!cpOq&Xqr1krs&}sv1kvw0mwx(tx!P1k!P!Q&X!Q!^1k!^!_*V!_!a&X!a#s1k#s$f&X$f;'S1k;'S;=`3R<%l?Ah1k?Ah?BY&X?BY?Mn1k?MnO&X!V3UP;=`<%l1k!_3[P;=`<%l-_!Z3hV!`h`P!cpOv&}wx'kx!^&}!^!_(V!_;'S&};'S;=`(n<%lO&}!_4WihSkWc!ROX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst>]tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^/^!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!Z5zbkWOX5uXZ7SZ[5u[^7S^p5uqr5urs7Sst+Ptw5uwx7Sx!]5u!]!^7w!^!a7S!a#S5u#S#T7S#T;'S5u;'S;=`8n<%lO5u!R7VVOp7Sqs7St!]7S!]!^7l!^;'S7S;'S;=`7q<%lO7S!R7qOa!R!R7tP;=`<%l7S!Z8OYkWa!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!Z8qP;=`<%l5u!_8{ihSkWOX5uXZ7SZ[5u[^7S^p5uqr8trs7Sst/^tw8twx7Sx!P8t!P!Q5u!Q!]8t!]!^:j!^!a7S!a#S8t#S#T;{#T#s8t#s$f5u$f;'S8t;'S;=`>V<%l?Ah8t?Ah?BY5u?BY?Mn8t?MnO5u!_:sbhSkWa!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!V<QchSOp7Sqr;{rs7Sst0mtw;{wx7Sx!P;{!P!Q7S!Q!];{!]!^=]!^!a7S!a#s;{#s$f7S$f;'S;{;'S;=`>P<%l?Ah;{?Ah?BY7S?BY?Mn;{?MnO7S!V=dXhSa!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!V>SP;=`<%l;{!_>YP;=`<%l8t!_>dhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^/^!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!Z@TakWOX@OXZAYZ[@O[^AY^p@Oqr@OrsAYsw@OwxAYx!]@O!]!^Az!^!aAY!a#S@O#S#TAY#T;'S@O;'S;=`Bq<%lO@O!RA]UOpAYq!]AY!]!^Ao!^;'SAY;'S;=`At<%lOAY!RAtOb!R!RAwP;=`<%lAY!ZBRYkWb!ROX+PZ[+P^p+Pqr+Psw+Px!^+P!a#S+P#T;'S+P;'S;=`+t<%lO+P!ZBtP;=`<%l@O!_COhhSkWOX@OXZAYZ[@O[^AY^p@OqrBwrsAYswBwwxAYx!PBw!P!Q@O!Q!]Bw!]!^Dj!^!aAY!a#SBw#S#TE{#T#sBw#s$f@O$f;'SBw;'S;=`HS<%l?AhBw?Ah?BY@O?BY?MnBw?MnO@O!_DsbhSkWb!ROX+PZ[+P^p+Pqr/^sw/^x!P/^!P!Q+P!Q!^/^!a#S/^#S#T0m#T#s/^#s$f+P$f;'S/^;'S;=`1e<%l?Ah/^?Ah?BY+P?BY?Mn/^?MnO+P!VFQbhSOpAYqrE{rsAYswE{wxAYx!PE{!P!QAY!Q!]E{!]!^GY!^!aAY!a#sE{#s$fAY$f;'SE{;'S;=`G|<%l?AhE{?Ah?BYAY?BY?MnE{?MnOAY!VGaXhSb!Rqr0msw0mx!P0m!Q!^0m!a#s0m$f;'S0m;'S;=`1_<%l?Ah0m?BY?Mn0m!VHPP;=`<%lE{!_HVP;=`<%lBw!ZHcW!bx`P!a`Or(trs'ksv(tw!^(t!^!_)e!_;'S(t;'S;=`*P<%lO(t!aIYlhS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OKQ!O!P-_!P!Q$q!Q!^-_!^!_*V!_!a&X!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!aK_khS`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx!P-_!P!Q$q!Q!^-_!^!_*V!_!`&X!`!aMS!a#S-_#S#T1k#T#s-_#s$f$q$f;'S-_;'S;=`3X<%l?Ah-_?Ah?BY$q?BY?Mn-_?MnO$q!TM_X`P!a`!cp!eQOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X!aNZ!ZhSfQ`PkW!a`!cpOX$qXZ&XZ[$q[^&X^p$qpq&Xqr-_rs&}sv-_vw/^wx(tx}-_}!OMz!O!PMz!P!Q$q!Q![Mz![!]Mz!]!^-_!^!_*V!_!a&X!a!c-_!c!}Mz!}#R-_#R#SMz#S#T1k#T#oMz#o#s-_#s$f$q$f$}-_$}%OMz%O%W-_%W%oMz%o%p-_%p&aMz&a&b-_&b1pMz1p4UMz4U4dMz4d4e-_4e$ISMz$IS$I`-_$I`$IbMz$Ib$Je-_$Je$JgMz$Jg$Kh-_$Kh%#tMz%#t&/x-_&/x&EtMz&Et&FV-_&FV;'SMz;'S;:j!#|;:j;=`3X<%l?&r-_?&r?AhMz?Ah?BY$q?BY?MnMz?MnO$q!a!$PP;=`<%lMz!R!$ZY!a`!cpOq*Vqr!$yrs(Vsv*Vwx)ex!a*V!a!b!4t!b;'S*V;'S;=`*s<%lO*V!R!%Q]!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!%y!O!f*V!f!g!']!g#W*V#W#X!0`#X;'S*V;'S;=`*s<%lO*V!R!&QX!a`!cpOr*Vrs(Vsv*Vwx)ex}*V}!O!&m!O;'S*V;'S;=`*s<%lO*V!R!&vV!a`!cp!dPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!'dX!a`!cpOr*Vrs(Vsv*Vwx)ex!q*V!q!r!(P!r;'S*V;'S;=`*s<%lO*V!R!(WX!a`!cpOr*Vrs(Vsv*Vwx)ex!e*V!e!f!(s!f;'S*V;'S;=`*s<%lO*V!R!(zX!a`!cpOr*Vrs(Vsv*Vwx)ex!v*V!v!w!)g!w;'S*V;'S;=`*s<%lO*V!R!)nX!a`!cpOr*Vrs(Vsv*Vwx)ex!{*V!{!|!*Z!|;'S*V;'S;=`*s<%lO*V!R!*bX!a`!cpOr*Vrs(Vsv*Vwx)ex!r*V!r!s!*}!s;'S*V;'S;=`*s<%lO*V!R!+UX!a`!cpOr*Vrs(Vsv*Vwx)ex!g*V!g!h!+q!h;'S*V;'S;=`*s<%lO*V!R!+xY!a`!cpOr!+qrs!,hsv!+qvw!-Swx!.[x!`!+q!`!a!/j!a;'S!+q;'S;=`!0Y<%lO!+qq!,mV!cpOv!,hvx!-Sx!`!,h!`!a!-q!a;'S!,h;'S;=`!.U<%lO!,hP!-VTO!`!-S!`!a!-f!a;'S!-S;'S;=`!-k<%lO!-SP!-kO{PP!-nP;=`<%l!-Sq!-xS!cp{POv(Vx;'S(V;'S;=`(h<%lO(Vq!.XP;=`<%l!,ha!.aX!a`Or!.[rs!-Ssv!.[vw!-Sw!`!.[!`!a!.|!a;'S!.[;'S;=`!/d<%lO!.[a!/TT!a`{POr)esv)ew;'S)e;'S;=`)y<%lO)ea!/gP;=`<%l!.[!R!/sV!a`!cp{POr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!0]P;=`<%l!+q!R!0gX!a`!cpOr*Vrs(Vsv*Vwx)ex#c*V#c#d!1S#d;'S*V;'S;=`*s<%lO*V!R!1ZX!a`!cpOr*Vrs(Vsv*Vwx)ex#V*V#V#W!1v#W;'S*V;'S;=`*s<%lO*V!R!1}X!a`!cpOr*Vrs(Vsv*Vwx)ex#h*V#h#i!2j#i;'S*V;'S;=`*s<%lO*V!R!2qX!a`!cpOr*Vrs(Vsv*Vwx)ex#m*V#m#n!3^#n;'S*V;'S;=`*s<%lO*V!R!3eX!a`!cpOr*Vrs(Vsv*Vwx)ex#d*V#d#e!4Q#e;'S*V;'S;=`*s<%lO*V!R!4XX!a`!cpOr*Vrs(Vsv*Vwx)ex#X*V#X#Y!+q#Y;'S*V;'S;=`*s<%lO*V!R!4{Y!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!a!4t!a!b!:]!b;'S!4t;'S;=`!;r<%lO!4tq!5pV!cpOv!5kvx!6Vx!a!5k!a!b!7W!b;'S!5k;'S;=`!8V<%lO!5kP!6YTO!a!6V!a!b!6i!b;'S!6V;'S;=`!7Q<%lO!6VP!6lTO!`!6V!`!a!6{!a;'S!6V;'S;=`!7Q<%lO!6VP!7QOxPP!7TP;=`<%l!6Vq!7]V!cpOv!5kvx!6Vx!`!5k!`!a!7r!a;'S!5k;'S;=`!8V<%lO!5kq!7yS!cpxPOv(Vx;'S(V;'S;=`(h<%lO(Vq!8YP;=`<%l!5ka!8bX!a`Or!8]rs!6Vsv!8]vw!6Vw!a!8]!a!b!8}!b;'S!8];'S;=`!:V<%lO!8]a!9SX!a`Or!8]rs!6Vsv!8]vw!6Vw!`!8]!`!a!9o!a;'S!8];'S;=`!:V<%lO!8]a!9vT!a`xPOr)esv)ew;'S)e;'S;=`)y<%lO)ea!:YP;=`<%l!8]!R!:dY!a`!cpOr!4trs!5ksv!4tvw!6Vwx!8]x!`!4t!`!a!;S!a;'S!4t;'S;=`!;r<%lO!4t!R!;]V!a`!cpxPOr*Vrs(Vsv*Vwx)ex;'S*V;'S;=`*s<%lO*V!R!;uP;=`<%l!4t!V!<TXiS`P!a`!cpOr&Xrs&}sv&Xwx(tx!^&X!^!_*V!_;'S&X;'S;=`*y<%lO&X",
  tokenizers: [CDe, IDe, wDe, _De, yDe, RDe, 0, 1, 2, 3, 4, 5],
  topRules: { Document: [0, 15] },
  dialects: { noMatch: 0, selfClosing: 485 },
  tokenPrec: 487
});
function eq(r, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let i of r.getChildren(q8)) {
    let n = i.getChild(sDe), a = i.getChild(hw) || i.getChild(j8);
    n && (t[e.read(n.from, n.to)] = a ? a.type.id == hw ? e.read(a.from + 1, a.to - 1) : e.read(a.from, a.to) : "");
  }
  return t;
}
function OB(r, e) {
  let t = r.getChild(oDe);
  return t ? e.read(t.from, t.to) : " ";
}
function MA(r, e, t) {
  let i;
  for (let n of t)
    if (!n.attrs || n.attrs(i || (i = eq(r.node.parent.firstChild, e))))
      return { parser: n.parser };
  return null;
}
function PDe(r = [], e = []) {
  let t = [], i = [], n = [], a = [];
  for (let s of r)
    (s.tag == "script" ? t : s.tag == "style" ? i : s.tag == "textarea" ? n : a).push(s);
  let o = e.length ? /* @__PURE__ */ Object.create(null) : null;
  for (let s of e)
    (o[s.name] || (o[s.name] = [])).push(s);
  return Y1e((s, l) => {
    let u = s.type.id;
    if (u == lDe)
      return MA(s, l, t);
    if (u == uDe)
      return MA(s, l, i);
    if (u == cDe)
      return MA(s, l, n);
    if (u == Z8 && a.length) {
      let c = s.node, h = c.firstChild, f = h && OB(h, l), d;
      if (f) {
        for (let p of a)
          if (p.tag == f && (!p.attrs || p.attrs(d || (d = eq(c, l))))) {
            let g = c.lastChild;
            return { parser: p.parser, overlay: [{ from: h.to, to: g.type.id == fDe ? g.from : c.to }] };
          }
      }
    }
    if (o && u == q8) {
      let c = s.node, h;
      if (h = c.firstChild) {
        let f = o[l.read(h.from, h.to)];
        if (f)
          for (let d of f) {
            if (d.tagName && d.tagName != OB(c.parent, l))
              continue;
            let p = c.lastChild;
            if (p.type.id == hw) {
              let g = p.from + 1, v = p.lastChild, O = p.to - (v && v.isError ? 0 : 1);
              if (O > g)
                return { parser: d.parser, overlay: [{ from: g, to: O }] };
            } else if (p.type.id == j8)
              return { parser: d.parser, overlay: [{ from: p.from, to: p.to }] };
          }
      }
    }
    return null;
  });
}
const LDe = 96, mB = 1, DDe = 97, MDe = 98, EB = 2, tq = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], kDe = 58, QDe = 40, rq = 95, UDe = 91, bE = 45, $De = 46, VDe = 35, GDe = 37;
function wS(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 161;
}
function BDe(r) {
  return r >= 48 && r <= 57;
}
const FDe = new Vi((r, e) => {
  for (let t = !1, i = 0, n = 0; ; n++) {
    let { next: a } = r;
    if (wS(a) || a == bE || a == rq || t && BDe(a))
      !t && (a != bE || n > 0) && (t = !0), i === n && a == bE && i++, r.advance();
    else {
      t && r.acceptToken(a == QDe ? DDe : i == 2 && e.canShift(EB) ? EB : MDe);
      break;
    }
  }
}), XDe = new Vi((r) => {
  if (tq.includes(r.peek(-1))) {
    let { next: e } = r;
    (wS(e) || e == rq || e == VDe || e == $De || e == UDe || e == kDe || e == bE) && r.acceptToken(LDe);
  }
}), YDe = new Vi((r) => {
  if (!tq.includes(r.peek(-1))) {
    let { next: e } = r;
    if (e == GDe && (r.advance(), r.acceptToken(mB)), wS(e)) {
      do
        r.advance();
      while (wS(r.next));
      r.acceptToken(mB);
    }
  }
}), HDe = ql({
  "AtKeyword import charset namespace keyframes media supports": A.definitionKeyword,
  "from to selector": A.keyword,
  NamespaceName: A.namespace,
  KeyframeName: A.labelName,
  KeyframeRangeName: A.operatorKeyword,
  TagName: A.tagName,
  ClassName: A.className,
  PseudoClassName: A.constant(A.className),
  IdName: A.labelName,
  "FeatureName PropertyName": A.propertyName,
  AttributeName: A.attributeName,
  NumberLiteral: A.number,
  KeywordQuery: A.keyword,
  UnaryQueryOp: A.operatorKeyword,
  "CallTag ValueName": A.atom,
  VariableName: A.variableName,
  Callee: A.operatorKeyword,
  Unit: A.unit,
  "UniversalSelector NestingSelector": A.definitionOperator,
  MatchOp: A.compareOperator,
  "ChildOp SiblingOp, LogicOp": A.logicOperator,
  BinOp: A.arithmeticOperator,
  Important: A.modifier,
  Comment: A.blockComment,
  ColorLiteral: A.color,
  "ParenthesizedContent StringLiteral": A.string,
  ":": A.punctuation,
  "PseudoOp #": A.derefOperator,
  "; ,": A.separator,
  "( )": A.paren,
  "[ ]": A.squareBracket,
  "{ }": A.brace
}), WDe = { __proto__: null, lang: 32, "nth-child": 32, "nth-last-child": 32, "nth-of-type": 32, "nth-last-of-type": 32, dir: 32, "host-context": 32, url: 60, "url-prefix": 60, domain: 60, regexp: 60, selector: 134 }, zDe = { __proto__: null, "@import": 114, "@media": 138, "@charset": 142, "@namespace": 146, "@keyframes": 152, "@supports": 164 }, ZDe = { __proto__: null, not: 128, only: 128 }, qDe = No.deserialize({
  version: 14,
  states: "9bQYQ[OOO#_Q[OOP#fOWOOOOQP'#Cd'#CdOOQP'#Cc'#CcO#kQ[O'#CfO$_QXO'#CaO$fQ[O'#ChO$qQ[O'#DPO$vQ[O'#DTOOQP'#Ej'#EjO${QdO'#DeO%gQ[O'#DrO${QdO'#DtO%xQ[O'#DvO&TQ[O'#DyO&]Q[O'#EPO&kQ[O'#EROOQS'#Ei'#EiOOQS'#EU'#EUQYQ[OOO&rQXO'#CdO'gQWO'#DaO'lQWO'#EpO'wQ[O'#EpQOQWOOP(RO#tO'#C_POOO)C@X)C@XOOQP'#Cg'#CgOOQP,59Q,59QO#kQ[O,59QO(^Q[O'#EXO(xQWO,58{O)QQ[O,59SO$qQ[O,59kO$vQ[O,59oO(^Q[O,59sO(^Q[O,59uO(^Q[O,59vO)]Q[O'#D`OOQS,58{,58{OOQP'#Ck'#CkOOQO'#C}'#C}OOQP,59S,59SO)dQWO,59SO)iQWO,59SOOQP'#DR'#DROOQP,59k,59kOOQO'#DV'#DVO)nQ`O,59oOOQS'#Cp'#CpO${QdO'#CqO)vQvO'#CsO+TQtO,5:POOQO'#Cx'#CxO)iQWO'#CwO+iQWO'#CyOOQS'#Em'#EmOOQO'#Dh'#DhO+nQ[O'#DoO+|QWO'#EqO&]Q[O'#DmO,[QWO'#DpOOQO'#Er'#ErO({QWO,5:^O,aQpO,5:`OOQS'#Dx'#DxO,iQWO,5:bO,nQ[O,5:bOOQO'#D{'#D{O,vQWO,5:eO,{QWO,5:kO-TQWO,5:mOOQS-E8S-E8SO${QdO,59{O-]Q[O'#EZO-jQWO,5;[O-jQWO,5;[POOO'#ET'#ETP-uO#tO,58yPOOO,58y,58yOOQP1G.l1G.lO.lQXO,5:sOOQO-E8V-E8VOOQS1G.g1G.gOOQP1G.n1G.nO)dQWO1G.nO)iQWO1G.nOOQP1G/V1G/VO.yQ`O1G/ZO/dQXO1G/_O/zQXO1G/aO0bQXO1G/bO0xQWO,59zO0}Q[O'#DOO1UQdO'#CoOOQP1G/Z1G/ZO${QdO1G/ZO1]QpO,59]OOQS,59_,59_O${QdO,59aO1eQWO1G/kOOQS,59c,59cO1jQ!bO,59eO1rQWO'#DhO1}QWO,5:TO2SQWO,5:ZO&]Q[O,5:VO&]Q[O'#E[O2[QWO,5;]O2gQWO,5:XO(^Q[O,5:[OOQS1G/x1G/xOOQS1G/z1G/zOOQS1G/|1G/|O2xQWO1G/|O2}QdO'#D|OOQS1G0P1G0POOQS1G0V1G0VOOQS1G0X1G0XO3YQtO1G/gOOQO,5:u,5:uO3pQ[O,5:uOOQO-E8X-E8XO3}QWO1G0vPOOO-E8R-E8RPOOO1G.e1G.eOOQP7+$Y7+$YOOQP7+$u7+$uO${QdO7+$uOOQS1G/f1G/fO4YQXO'#EoO4aQWO,59jO4fQtO'#EVO5ZQdO'#ElO5eQWO,59ZO5jQpO7+$uOOQS1G.w1G.wOOQS1G.{1G.{OOQS7+%V7+%VO5rQWO1G/PO${QdO1G/oOOQO1G/u1G/uOOQO1G/q1G/qO5wQWO,5:vOOQO-E8Y-E8YO6VQXO1G/vOOQS7+%h7+%hO6^QYO'#CsOOQO'#EO'#EOO6iQ`O'#D}OOQO'#D}'#D}O6tQWO'#E]O6|QdO,5:hOOQS,5:h,5:hO7XQtO'#EYO${QdO'#EYO8VQdO7+%ROOQO7+%R7+%ROOQO1G0a1G0aO8jQpO<<HaO8rQWO,5;ZOOQP1G/U1G/UOOQS-E8T-E8TO${QdO'#EWO8zQWO,5;WOOQT1G.u1G.uOOQP<<Ha<<HaOOQS7+$k7+$kO9SQdO7+%ZOOQO7+%b7+%bOOQO,5:i,5:iO3QQdO'#E^O6tQWO,5:wOOQS,5:w,5:wOOQS-E8Z-E8ZOOQS1G0S1G0SO9ZQtO,5:tOOQS-E8W-E8WOOQO<<Hm<<HmOOQPAN={AN={O:XQdO,5:rOOQO-E8U-E8UOOQO<<Hu<<HuOOQO,5:x,5:xOOQO-E8[-E8[OOQS1G0c1G0c",
  stateData: ":k~O#WOS#XQQ~OUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#URO#_TO~OQfOUYOXYO]VO^VOtWOxXO!YaO!ZZO!g[O!i]O!k^O!n_O!t`O#UeO#_TO~O#R#dP~P!ZO#XjO~O#UlO~O]qO^qOpoOtrOxsO|tO!PvO#SuO#_nO~O!RwO~P#pO`}O#TzO#UyO~O#U!OO~O#U!QO~OQ!ZOb!TOf!ZOh!ZOn!YO#T!WO#U!SO#b!UO~Ob!]O!b!_O!e!`O#U![O!R#eP~Oh!eOn!YO#U!dO~Oh!gO#U!gO~Ob!]O!b!_O!e!`O#U![O~O!W#eP~P%gO]WX]!UX^WXpWXtWXxWX|WX!PWX!RWX#SWX#_WX~O]!lO~O!W!mO#R#dX!Q#dX~O#R#dX!Q#dX~P!ZO#Y!pO#Z!pO#[!rO~OUYOXYO]VO^VOtWOxXO#URO#_TO~OpoO!RwO~O`!yO#TzO#UyO~O!Q#dP~P!ZOb#QO~Ob#RO~Ov#SOz#TO~OP#VObgXjgX!WgX!bgX!egX#UgXagXQgXfgXhgXngXpgX!VgX#RgX#TgX#bgXvgX!QgX~Ob!]Oj#WO!b!_O!e!`O#U![O!W#eP~Ob#ZO~Ob!]O!b!_O!e!`O#U#[O~Op#`O!`#_O!R#eX!W#eX~Ob#cO~Oj#WO!W#eO~O!W#fO~Oh#gOn!YO~O!R#hO~O!RwO!`#_O~O!RwO!W#kO~O!W!}X#R!}X!Q!}X~P!ZO!W!mO#R#da!Q#da~O#Y!pO#Z!pO#[#rO~O]qO^qOtrOxsO|tO!PvO#SuO#_nO~Op!{a!R!{aa!{a~P.QOv#tOz#uO~O]qO^qOtrOxsO#_nO~Op{i|{i!P{i!R{i#S{ia{i~P/ROp}i|}i!P}i!R}i#S}ia}i~P/ROp!Oi|!Oi!P!Oi!R!Oi#S!Oia!Oi~P/RO!Q#vO~Oa#cP~P(^Oa#`P~P${Oa#}Oj#WO~O!W$PO~Oh$QOo$QO~O]!^Xa![X!`![X~O]$RO~Oa$SO!`#_O~Op#`O!R#ea!W#ea~O!`#_Op!aa!R!aa!W!aaa!aa~O!W$XO~O!Q$`O#U$ZO#b$YO~Oj#WOp$bO!V$dO!W!Ti#R!Ti!Q!Ti~P${O!W!}a#R!}a!Q!}a~P!ZO!W!mO#R#di!Q#di~Oa#cX~P#pOa$hO~Oj#WOQ!yXa!yXb!yXf!yXh!yXn!yXp!yX#T!yX#U!yX#b!yX~Op$jOa#`X~P${Oa$lO~Oj#WOv$mO~Oa$nO~O!`#_Op#Oa!R#Oa!W#Oa~Oa$pO~P.QOP#VOpgX!RgX~O#b$YOp!qX!R!qX~Op$rO!RwO~O!Q$vO#U$ZO#b$YO~Oj#WOQ!|Xb!|Xf!|Xh!|Xn!|Xp!|X!V!|X!W!|X#R!|X#T!|X#U!|X#b!|X!Q!|X~Op$bO!V$yO!W!Tq#R!Tq!Q!Tq~P${Oj#WOv$zO~OpoOa#ca~Op$jOa#`a~Oa$}O~P${Oj#WOQ!|ab!|af!|ah!|an!|ap!|a!V!|a!W!|a#R!|a#T!|a#U!|a#b!|a!Q!|a~Oa!zap!za~P${O#Wo#X#bj!P#b~",
  goto: "-Y#gPPP#hP#kP#t$TP#t$d#tPP$jPPP$p$y$yP%]P$yP$y%w&ZPPP&s&y#tP'PP#tP'VP#tP#t#tPPP']'r(PPP#kPP(W(W(b(WP(WP(W(WP#kP#kP#kP(e#kP(h(k(n(u#kP#kP(z)Q)a)o)u*P*V*a*g*mPPPPPPPPPP*s*|P+i+lP,b,e,k,tRkQ_bOPdhw!m#nkYOPdhotuvw!m#Q#c#nkSOPdhotuvw!m#Q#c#nQmTR!snQ{VR!wqQ!w}Q#Y!XR#s!yq!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${U$]#h$_$rR$q$[q!XZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${p!ZZ]!T!l#R#T#W#l#u#z$R$b$c$j$o${Q!e^R#g!fQ|VR!xqQ!w|R#s!xQ!PWR!zrQ!RXR!{sQxUQ!vpQ#d!bQ#j!iQ#k!jQ$t$^R%Q$sSgPwQ!ohQ#m!mR$e#nZfPhw!m#na!a[`a!V!]!_#_#`R#]!]R!f^R!h_R#i!hS$^#h$_R%O$rV$[#h$_$rQ!qjR#q!qQdOShPwU!kdh#nR#n!mQ#z#RU$i#z$o${Q$o$RR${$jQ$k#zR$|$kQpUS!up$gR$g#wQ$c#lR$x$cQ!ngS#o!n#pR#p!oQ#a!^R$V#aQ$_#hR$u$_Q$s$^R%P$s_cOPdhw!m#n^UOPdhw!m#nQ!toQ!|tQ!}uQ#OvQ#w#QR$W#cR#{#RQ!VZQ!c]Q#U!TQ#l!l[#y#R#z$R$j$o${Q#|#TQ$O#WS$a#l$cQ$f#uR$w$bR#x#QQiPR#PwQ!b[Q!jaR#X!VU!^[a!VQ!i`Q#^!]Q#b!_Q$T#_R$U#`",
  nodeNames: " Unit VariableName Comment StyleSheet RuleSet UniversalSelector TagSelector TagName NestingSelector ClassSelector ClassName PseudoClassSelector : :: PseudoClassName PseudoClassName ) ( ArgList ValueName ParenthesizedValue ColorLiteral NumberLiteral StringLiteral BinaryExpression BinOp CallExpression Callee CallLiteral CallTag ParenthesizedContent , PseudoClassName ArgList IdSelector # IdName ] AttributeSelector [ AttributeName MatchOp ChildSelector ChildOp DescendantSelector SiblingSelector SiblingOp } { Block Declaration PropertyName Important ; ImportStatement AtKeyword import KeywordQuery FeatureQuery FeatureName BinaryQuery LogicOp UnaryQuery UnaryQueryOp ParenthesizedQuery SelectorQuery selector MediaStatement media CharsetStatement charset NamespaceStatement namespace NamespaceName KeyframesStatement keyframes KeyframeName KeyframeList KeyframeSelector KeyframeRangeName SupportsStatement supports AtRule Styles",
  maxTerm: 114,
  nodeProps: [
    ["openedBy", 17, "(", 48, "{"],
    ["closedBy", 18, ")", 49, "}"]
  ],
  propSources: [HDe],
  skippedNodes: [0, 3, 85],
  repeatNodeCount: 10,
  tokenData: "J^~R!^OX$}X^%u^p$}pq%uqr)Xrs.Rst/utu6duv$}vw7^wx7oxy9^yz9oz{9t{|:_|}?Q}!O?c!O!P@Q!P!Q@i!Q![Ab![!]B]!]!^CX!^!_$}!_!`Cj!`!aC{!a!b$}!b!cDw!c!}$}!}#OFa#O#P$}#P#QFr#Q#R6d#R#T$}#T#UGT#U#c$}#c#dHf#d#o$}#o#pH{#p#q6d#q#rI^#r#sIo#s#y$}#y#z%u#z$f$}$f$g%u$g#BY$}#BY#BZ%u#BZ$IS$}$IS$I_%u$I_$I|$}$I|$JO%u$JO$JT$}$JT$JU%u$JU$KV$}$KV$KW%u$KW&FU$}&FU&FV%u&FV;'S$};'S;=`JW<%lO$}`%QSOy%^z;'S%^;'S;=`%o<%lO%^`%cSo`Oy%^z;'S%^;'S;=`%o<%lO%^`%rP;=`<%l%^~%zh#W~OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^~'mh#W~o`OX%^X^'f^p%^pq'fqy%^z#y%^#y#z'f#z$f%^$f$g'f$g#BY%^#BY#BZ'f#BZ$IS%^$IS$I_'f$I_$I|%^$I|$JO'f$JO$JT%^$JT$JU'f$JU$KV%^$KV$KW'f$KW&FU%^&FU&FV'f&FV;'S%^;'S;=`%o<%lO%^l)[UOy%^z#]%^#]#^)n#^;'S%^;'S;=`%o<%lO%^l)sUo`Oy%^z#a%^#a#b*V#b;'S%^;'S;=`%o<%lO%^l*[Uo`Oy%^z#d%^#d#e*n#e;'S%^;'S;=`%o<%lO%^l*sUo`Oy%^z#c%^#c#d+V#d;'S%^;'S;=`%o<%lO%^l+[Uo`Oy%^z#f%^#f#g+n#g;'S%^;'S;=`%o<%lO%^l+sUo`Oy%^z#h%^#h#i,V#i;'S%^;'S;=`%o<%lO%^l,[Uo`Oy%^z#T%^#T#U,n#U;'S%^;'S;=`%o<%lO%^l,sUo`Oy%^z#b%^#b#c-V#c;'S%^;'S;=`%o<%lO%^l-[Uo`Oy%^z#h%^#h#i-n#i;'S%^;'S;=`%o<%lO%^l-uS!V[o`Oy%^z;'S%^;'S;=`%o<%lO%^~.UWOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o<%lO.R~.sOh~~.vRO;'S.R;'S;=`/P;=`O.R~/SXOY.RZr.Rrs.ns#O.R#O#P.s#P;'S.R;'S;=`/o;=`<%l.R<%lO.R~/rP;=`<%l.Rn/zYtQOy%^z!Q%^!Q![0j![!c%^!c!i0j!i#T%^#T#Z0j#Z;'S%^;'S;=`%o<%lO%^l0oYo`Oy%^z!Q%^!Q![1_![!c%^!c!i1_!i#T%^#T#Z1_#Z;'S%^;'S;=`%o<%lO%^l1dYo`Oy%^z!Q%^!Q![2S![!c%^!c!i2S!i#T%^#T#Z2S#Z;'S%^;'S;=`%o<%lO%^l2ZYf[o`Oy%^z!Q%^!Q![2y![!c%^!c!i2y!i#T%^#T#Z2y#Z;'S%^;'S;=`%o<%lO%^l3QYf[o`Oy%^z!Q%^!Q![3p![!c%^!c!i3p!i#T%^#T#Z3p#Z;'S%^;'S;=`%o<%lO%^l3uYo`Oy%^z!Q%^!Q![4e![!c%^!c!i4e!i#T%^#T#Z4e#Z;'S%^;'S;=`%o<%lO%^l4lYf[o`Oy%^z!Q%^!Q![5[![!c%^!c!i5[!i#T%^#T#Z5[#Z;'S%^;'S;=`%o<%lO%^l5aYo`Oy%^z!Q%^!Q![6P![!c%^!c!i6P!i#T%^#T#Z6P#Z;'S%^;'S;=`%o<%lO%^l6WSf[o`Oy%^z;'S%^;'S;=`%o<%lO%^d6gUOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^d7QSzSo`Oy%^z;'S%^;'S;=`%o<%lO%^b7cSXQOy%^z;'S%^;'S;=`%o<%lO%^~7rWOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W<%lO7o~8_RO;'S7o;'S;=`8h;=`O7o~8kXOY7oZw7owx.nx#O7o#O#P8[#P;'S7o;'S;=`9W;=`<%l7o<%lO7o~9ZP;=`<%l7on9cSb^Oy%^z;'S%^;'S;=`%o<%lO%^~9tOa~n9{UUQjWOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^n:fWjW!PQOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^l;TUo`Oy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^l;nYo`#b[Oy%^z!Q%^!Q![;g![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^l<cYo`Oy%^z{%^{|=R|}%^}!O=R!O!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=WUo`Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l=qUo`#b[Oy%^z!Q%^!Q![=j![;'S%^;'S;=`%o<%lO%^l>[[o`#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^n?VSp^Oy%^z;'S%^;'S;=`%o<%lO%^l?hWjWOy%^z!O%^!O!P;O!P!Q%^!Q![>T![;'S%^;'S;=`%o<%lO%^n@VU#_QOy%^z!Q%^!Q![;g![;'S%^;'S;=`%o<%lO%^~@nTjWOy%^z{@}{;'S%^;'S;=`%o<%lO%^~AUSo`#X~Oy%^z;'S%^;'S;=`%o<%lO%^lAg[#b[Oy%^z!O%^!O!P;g!P!Q%^!Q![>T![!g%^!g!h<^!h#X%^#X#Y<^#Y;'S%^;'S;=`%o<%lO%^bBbU]QOy%^z![%^![!]Bt!];'S%^;'S;=`%o<%lO%^bB{S^Qo`Oy%^z;'S%^;'S;=`%o<%lO%^nC^S!W^Oy%^z;'S%^;'S;=`%o<%lO%^dCoSzSOy%^z;'S%^;'S;=`%o<%lO%^bDQU|QOy%^z!`%^!`!aDd!a;'S%^;'S;=`%o<%lO%^bDkS|Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bDzWOy%^z!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bEk[!YQo`Oy%^z}%^}!OEd!O!Q%^!Q![Ed![!c%^!c!}Ed!}#T%^#T#oEd#o;'S%^;'S;=`%o<%lO%^bFfSxQOy%^z;'S%^;'S;=`%o<%lO%^lFwSv[Oy%^z;'S%^;'S;=`%o<%lO%^bGWUOy%^z#b%^#b#cGj#c;'S%^;'S;=`%o<%lO%^bGoUo`Oy%^z#W%^#W#XHR#X;'S%^;'S;=`%o<%lO%^bHYS!`Qo`Oy%^z;'S%^;'S;=`%o<%lO%^bHiUOy%^z#f%^#f#gHR#g;'S%^;'S;=`%o<%lO%^fIQS!RUOy%^z;'S%^;'S;=`%o<%lO%^nIcS!Q^Oy%^z;'S%^;'S;=`%o<%lO%^fItU!PQOy%^z!_%^!_!`6y!`;'S%^;'S;=`%o<%lO%^`JZP;=`<%l$}",
  tokenizers: [XDe, YDe, FDe, 1, 2, 3, 4, new _S("m~RRYZ[z{a~~g~aO#Z~~dP!P!Qg~lO#[~~", 28, 102)],
  topRules: { StyleSheet: [0, 4], Styles: [1, 84] },
  specialized: [{ term: 97, get: (r) => WDe[r] || -1 }, { term: 56, get: (r) => zDe[r] || -1 }, { term: 98, get: (r) => ZDe[r] || -1 }],
  tokenPrec: 1169
});
let kA = null;
function QA() {
  if (!kA && typeof document == "object" && document.body) {
    let r = [];
    for (let e in document.body.style)
      /[A-Z]|^-|^(item|length)$/.test(e) || r.push(e);
    kA = r.sort().map((e) => ({ type: "property", label: e }));
  }
  return kA || [];
}
const bB = /* @__PURE__ */ [
  "active",
  "after",
  "before",
  "checked",
  "default",
  "disabled",
  "empty",
  "enabled",
  "first-child",
  "first-letter",
  "first-line",
  "first-of-type",
  "focus",
  "hover",
  "in-range",
  "indeterminate",
  "invalid",
  "lang",
  "last-child",
  "last-of-type",
  "link",
  "not",
  "nth-child",
  "nth-last-child",
  "nth-last-of-type",
  "nth-of-type",
  "only-of-type",
  "only-child",
  "optional",
  "out-of-range",
  "placeholder",
  "read-only",
  "read-write",
  "required",
  "root",
  "selection",
  "target",
  "valid",
  "visited"
].map((r) => ({ type: "class", label: r })), SB = /* @__PURE__ */ [
  "above",
  "absolute",
  "activeborder",
  "additive",
  "activecaption",
  "after-white-space",
  "ahead",
  "alias",
  "all",
  "all-scroll",
  "alphabetic",
  "alternate",
  "always",
  "antialiased",
  "appworkspace",
  "asterisks",
  "attr",
  "auto",
  "auto-flow",
  "avoid",
  "avoid-column",
  "avoid-page",
  "avoid-region",
  "axis-pan",
  "background",
  "backwards",
  "baseline",
  "below",
  "bidi-override",
  "blink",
  "block",
  "block-axis",
  "bold",
  "bolder",
  "border",
  "border-box",
  "both",
  "bottom",
  "break",
  "break-all",
  "break-word",
  "bullets",
  "button",
  "button-bevel",
  "buttonface",
  "buttonhighlight",
  "buttonshadow",
  "buttontext",
  "calc",
  "capitalize",
  "caps-lock-indicator",
  "caption",
  "captiontext",
  "caret",
  "cell",
  "center",
  "checkbox",
  "circle",
  "cjk-decimal",
  "clear",
  "clip",
  "close-quote",
  "col-resize",
  "collapse",
  "color",
  "color-burn",
  "color-dodge",
  "column",
  "column-reverse",
  "compact",
  "condensed",
  "contain",
  "content",
  "contents",
  "content-box",
  "context-menu",
  "continuous",
  "copy",
  "counter",
  "counters",
  "cover",
  "crop",
  "cross",
  "crosshair",
  "currentcolor",
  "cursive",
  "cyclic",
  "darken",
  "dashed",
  "decimal",
  "decimal-leading-zero",
  "default",
  "default-button",
  "dense",
  "destination-atop",
  "destination-in",
  "destination-out",
  "destination-over",
  "difference",
  "disc",
  "discard",
  "disclosure-closed",
  "disclosure-open",
  "document",
  "dot-dash",
  "dot-dot-dash",
  "dotted",
  "double",
  "down",
  "e-resize",
  "ease",
  "ease-in",
  "ease-in-out",
  "ease-out",
  "element",
  "ellipse",
  "ellipsis",
  "embed",
  "end",
  "ethiopic-abegede-gez",
  "ethiopic-halehame-aa-er",
  "ethiopic-halehame-gez",
  "ew-resize",
  "exclusion",
  "expanded",
  "extends",
  "extra-condensed",
  "extra-expanded",
  "fantasy",
  "fast",
  "fill",
  "fill-box",
  "fixed",
  "flat",
  "flex",
  "flex-end",
  "flex-start",
  "footnotes",
  "forwards",
  "from",
  "geometricPrecision",
  "graytext",
  "grid",
  "groove",
  "hand",
  "hard-light",
  "help",
  "hidden",
  "hide",
  "higher",
  "highlight",
  "highlighttext",
  "horizontal",
  "hsl",
  "hsla",
  "hue",
  "icon",
  "ignore",
  "inactiveborder",
  "inactivecaption",
  "inactivecaptiontext",
  "infinite",
  "infobackground",
  "infotext",
  "inherit",
  "initial",
  "inline",
  "inline-axis",
  "inline-block",
  "inline-flex",
  "inline-grid",
  "inline-table",
  "inset",
  "inside",
  "intrinsic",
  "invert",
  "italic",
  "justify",
  "keep-all",
  "landscape",
  "large",
  "larger",
  "left",
  "level",
  "lighter",
  "lighten",
  "line-through",
  "linear",
  "linear-gradient",
  "lines",
  "list-item",
  "listbox",
  "listitem",
  "local",
  "logical",
  "loud",
  "lower",
  "lower-hexadecimal",
  "lower-latin",
  "lower-norwegian",
  "lowercase",
  "ltr",
  "luminosity",
  "manipulation",
  "match",
  "matrix",
  "matrix3d",
  "medium",
  "menu",
  "menutext",
  "message-box",
  "middle",
  "min-intrinsic",
  "mix",
  "monospace",
  "move",
  "multiple",
  "multiple_mask_images",
  "multiply",
  "n-resize",
  "narrower",
  "ne-resize",
  "nesw-resize",
  "no-close-quote",
  "no-drop",
  "no-open-quote",
  "no-repeat",
  "none",
  "normal",
  "not-allowed",
  "nowrap",
  "ns-resize",
  "numbers",
  "numeric",
  "nw-resize",
  "nwse-resize",
  "oblique",
  "opacity",
  "open-quote",
  "optimizeLegibility",
  "optimizeSpeed",
  "outset",
  "outside",
  "outside-shape",
  "overlay",
  "overline",
  "padding",
  "padding-box",
  "painted",
  "page",
  "paused",
  "perspective",
  "pinch-zoom",
  "plus-darker",
  "plus-lighter",
  "pointer",
  "polygon",
  "portrait",
  "pre",
  "pre-line",
  "pre-wrap",
  "preserve-3d",
  "progress",
  "push-button",
  "radial-gradient",
  "radio",
  "read-only",
  "read-write",
  "read-write-plaintext-only",
  "rectangle",
  "region",
  "relative",
  "repeat",
  "repeating-linear-gradient",
  "repeating-radial-gradient",
  "repeat-x",
  "repeat-y",
  "reset",
  "reverse",
  "rgb",
  "rgba",
  "ridge",
  "right",
  "rotate",
  "rotate3d",
  "rotateX",
  "rotateY",
  "rotateZ",
  "round",
  "row",
  "row-resize",
  "row-reverse",
  "rtl",
  "run-in",
  "running",
  "s-resize",
  "sans-serif",
  "saturation",
  "scale",
  "scale3d",
  "scaleX",
  "scaleY",
  "scaleZ",
  "screen",
  "scroll",
  "scrollbar",
  "scroll-position",
  "se-resize",
  "self-start",
  "self-end",
  "semi-condensed",
  "semi-expanded",
  "separate",
  "serif",
  "show",
  "single",
  "skew",
  "skewX",
  "skewY",
  "skip-white-space",
  "slide",
  "slider-horizontal",
  "slider-vertical",
  "sliderthumb-horizontal",
  "sliderthumb-vertical",
  "slow",
  "small",
  "small-caps",
  "small-caption",
  "smaller",
  "soft-light",
  "solid",
  "source-atop",
  "source-in",
  "source-out",
  "source-over",
  "space",
  "space-around",
  "space-between",
  "space-evenly",
  "spell-out",
  "square",
  "start",
  "static",
  "status-bar",
  "stretch",
  "stroke",
  "stroke-box",
  "sub",
  "subpixel-antialiased",
  "svg_masks",
  "super",
  "sw-resize",
  "symbolic",
  "symbols",
  "system-ui",
  "table",
  "table-caption",
  "table-cell",
  "table-column",
  "table-column-group",
  "table-footer-group",
  "table-header-group",
  "table-row",
  "table-row-group",
  "text",
  "text-bottom",
  "text-top",
  "textarea",
  "textfield",
  "thick",
  "thin",
  "threeddarkshadow",
  "threedface",
  "threedhighlight",
  "threedlightshadow",
  "threedshadow",
  "to",
  "top",
  "transform",
  "translate",
  "translate3d",
  "translateX",
  "translateY",
  "translateZ",
  "transparent",
  "ultra-condensed",
  "ultra-expanded",
  "underline",
  "unidirectional-pan",
  "unset",
  "up",
  "upper-latin",
  "uppercase",
  "url",
  "var",
  "vertical",
  "vertical-text",
  "view-box",
  "visible",
  "visibleFill",
  "visiblePainted",
  "visibleStroke",
  "visual",
  "w-resize",
  "wait",
  "wave",
  "wider",
  "window",
  "windowframe",
  "windowtext",
  "words",
  "wrap",
  "wrap-reverse",
  "x-large",
  "x-small",
  "xor",
  "xx-large",
  "xx-small"
].map((r) => ({ type: "keyword", label: r })).concat(/* @__PURE__ */ [
  "aliceblue",
  "antiquewhite",
  "aqua",
  "aquamarine",
  "azure",
  "beige",
  "bisque",
  "black",
  "blanchedalmond",
  "blue",
  "blueviolet",
  "brown",
  "burlywood",
  "cadetblue",
  "chartreuse",
  "chocolate",
  "coral",
  "cornflowerblue",
  "cornsilk",
  "crimson",
  "cyan",
  "darkblue",
  "darkcyan",
  "darkgoldenrod",
  "darkgray",
  "darkgreen",
  "darkkhaki",
  "darkmagenta",
  "darkolivegreen",
  "darkorange",
  "darkorchid",
  "darkred",
  "darksalmon",
  "darkseagreen",
  "darkslateblue",
  "darkslategray",
  "darkturquoise",
  "darkviolet",
  "deeppink",
  "deepskyblue",
  "dimgray",
  "dodgerblue",
  "firebrick",
  "floralwhite",
  "forestgreen",
  "fuchsia",
  "gainsboro",
  "ghostwhite",
  "gold",
  "goldenrod",
  "gray",
  "grey",
  "green",
  "greenyellow",
  "honeydew",
  "hotpink",
  "indianred",
  "indigo",
  "ivory",
  "khaki",
  "lavender",
  "lavenderblush",
  "lawngreen",
  "lemonchiffon",
  "lightblue",
  "lightcoral",
  "lightcyan",
  "lightgoldenrodyellow",
  "lightgray",
  "lightgreen",
  "lightpink",
  "lightsalmon",
  "lightseagreen",
  "lightskyblue",
  "lightslategray",
  "lightsteelblue",
  "lightyellow",
  "lime",
  "limegreen",
  "linen",
  "magenta",
  "maroon",
  "mediumaquamarine",
  "mediumblue",
  "mediumorchid",
  "mediumpurple",
  "mediumseagreen",
  "mediumslateblue",
  "mediumspringgreen",
  "mediumturquoise",
  "mediumvioletred",
  "midnightblue",
  "mintcream",
  "mistyrose",
  "moccasin",
  "navajowhite",
  "navy",
  "oldlace",
  "olive",
  "olivedrab",
  "orange",
  "orangered",
  "orchid",
  "palegoldenrod",
  "palegreen",
  "paleturquoise",
  "palevioletred",
  "papayawhip",
  "peachpuff",
  "peru",
  "pink",
  "plum",
  "powderblue",
  "purple",
  "rebeccapurple",
  "red",
  "rosybrown",
  "royalblue",
  "saddlebrown",
  "salmon",
  "sandybrown",
  "seagreen",
  "seashell",
  "sienna",
  "silver",
  "skyblue",
  "slateblue",
  "slategray",
  "snow",
  "springgreen",
  "steelblue",
  "tan",
  "teal",
  "thistle",
  "tomato",
  "turquoise",
  "violet",
  "wheat",
  "white",
  "whitesmoke",
  "yellow",
  "yellowgreen"
].map((r) => ({ type: "constant", label: r }))), jDe = /* @__PURE__ */ [
  "a",
  "abbr",
  "address",
  "article",
  "aside",
  "b",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "figcaption",
  "figure",
  "footer",
  "form",
  "header",
  "hgroup",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "main",
  "meter",
  "nav",
  "ol",
  "output",
  "p",
  "pre",
  "ruby",
  "section",
  "select",
  "small",
  "source",
  "span",
  "strong",
  "sub",
  "summary",
  "sup",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "tr",
  "u",
  "ul"
].map((r) => ({ type: "type", label: r })), Us = /^[\w-]*/, KDe = (r) => {
  let { state: e, pos: t } = r, i = Kt(e).resolveInner(t, -1);
  if (i.name == "PropertyName")
    return { from: i.from, options: QA(), validFor: Us };
  if (i.name == "ValueName")
    return { from: i.from, options: SB, validFor: Us };
  if (i.name == "PseudoClassName")
    return { from: i.from, options: bB, validFor: Us };
  if (i.name == "TagName") {
    for (let { parent: o } = i; o; o = o.parent)
      if (o.name == "Block")
        return { from: i.from, options: QA(), validFor: Us };
    return { from: i.from, options: jDe, validFor: Us };
  }
  if (!r.explicit)
    return null;
  let n = i.resolve(t), a = n.childBefore(t);
  return a && a.name == ":" && n.name == "PseudoClassSelector" ? { from: t, options: bB, validFor: Us } : a && a.name == ":" && n.name == "Declaration" || n.name == "ArgList" ? { from: t, options: SB, validFor: Us } : n.name == "Block" ? { from: t, options: QA(), validFor: Us } : null;
}, dw = /* @__PURE__ */ wo.define({
  parser: /* @__PURE__ */ qDe.configure({
    props: [
      /* @__PURE__ */ jl.add({
        Declaration: /* @__PURE__ */ mo()
      }),
      /* @__PURE__ */ Kl.add({
        Block: Wv
      })
    ]
  }),
  languageData: {
    commentTokens: { block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*\}$/,
    wordChars: "-"
  }
});
function pw() {
  return new ih(dw, dw.data.of({ autocomplete: KDe }));
}
const JDe = 303, TB = 1, eMe = 2, tMe = 304, rMe = 306, iMe = 307, nMe = 3, aMe = 4, oMe = [
  9,
  10,
  11,
  12,
  13,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
], iq = 125, sMe = 59, yB = 47, lMe = 42, uMe = 43, cMe = 45, hMe = new yP({
  start: !1,
  shift(r, e) {
    return e == nMe || e == aMe || e == rMe ? r : e == iMe;
  },
  strict: !1
}), fMe = new Vi((r, e) => {
  let { next: t } = r;
  (t == iq || t == -1 || e.context) && r.acceptToken(tMe);
}, { contextual: !0, fallback: !0 }), dMe = new Vi((r, e) => {
  let { next: t } = r, i;
  oMe.indexOf(t) > -1 || t == yB && ((i = r.peek(1)) == yB || i == lMe) || t != iq && t != sMe && t != -1 && !e.context && r.acceptToken(JDe);
}, { contextual: !0 }), pMe = new Vi((r, e) => {
  let { next: t } = r;
  if ((t == uMe || t == cMe) && (r.advance(), t == r.next)) {
    r.advance();
    let i = !e.context && e.canShift(TB);
    r.acceptToken(i ? TB : eMe);
  }
}, { contextual: !0 }), gMe = ql({
  "get set async static": A.modifier,
  "for while do if else switch try catch finally return throw break continue default case": A.controlKeyword,
  "in of await yield void typeof delete instanceof": A.operatorKeyword,
  "let var const function class extends": A.definitionKeyword,
  "import export from": A.moduleKeyword,
  "with debugger as new": A.keyword,
  TemplateString: A.special(A.string),
  super: A.atom,
  BooleanLiteral: A.bool,
  this: A.self,
  null: A.null,
  Star: A.modifier,
  VariableName: A.variableName,
  "CallExpression/VariableName TaggedTemplateExpression/VariableName": A.function(A.variableName),
  VariableDefinition: A.definition(A.variableName),
  Label: A.labelName,
  PropertyName: A.propertyName,
  PrivatePropertyName: A.special(A.propertyName),
  "CallExpression/MemberExpression/PropertyName": A.function(A.propertyName),
  "FunctionDeclaration/VariableDefinition": A.function(A.definition(A.variableName)),
  "ClassDeclaration/VariableDefinition": A.definition(A.className),
  PropertyDefinition: A.definition(A.propertyName),
  PrivatePropertyDefinition: A.definition(A.special(A.propertyName)),
  UpdateOp: A.updateOperator,
  LineComment: A.lineComment,
  BlockComment: A.blockComment,
  Number: A.number,
  String: A.string,
  Escape: A.escape,
  ArithOp: A.arithmeticOperator,
  LogicOp: A.logicOperator,
  BitOp: A.bitwiseOperator,
  CompareOp: A.compareOperator,
  RegExp: A.regexp,
  Equals: A.definitionOperator,
  Arrow: A.function(A.punctuation),
  ": Spread": A.punctuation,
  "( )": A.paren,
  "[ ]": A.squareBracket,
  "{ }": A.brace,
  "InterpolationStart InterpolationEnd": A.special(A.brace),
  ".": A.derefOperator,
  ", ;": A.separator,
  "@": A.meta,
  TypeName: A.typeName,
  TypeDefinition: A.definition(A.typeName),
  "type enum interface implements namespace module declare": A.definitionKeyword,
  "abstract global Privacy readonly override": A.modifier,
  "is keyof unique infer": A.operatorKeyword,
  JSXAttributeValue: A.attributeValue,
  JSXText: A.content,
  "JSXStartTag JSXStartCloseTag JSXSelfCloseEndTag JSXEndTag": A.angleBracket,
  "JSXIdentifier JSXNameSpacedName": A.tagName,
  "JSXAttribute/JSXIdentifier JSXAttribute/JSXNameSpacedName": A.attributeName,
  "JSXBuiltin/JSXIdentifier": A.standard(A.tagName)
}), vMe = { __proto__: null, export: 14, as: 19, from: 27, default: 30, async: 35, function: 36, extends: 46, this: 50, true: 58, false: 58, null: 70, void: 74, typeof: 78, super: 96, new: 130, delete: 146, yield: 155, await: 159, class: 164, public: 221, private: 221, protected: 221, readonly: 223, instanceof: 242, satisfies: 245, in: 246, const: 248, import: 280, keyof: 335, unique: 339, infer: 345, is: 381, abstract: 401, implements: 403, type: 405, let: 408, var: 410, using: 413, interface: 419, enum: 423, namespace: 429, module: 431, declare: 435, global: 439, for: 458, of: 467, while: 470, with: 474, do: 478, if: 482, else: 484, switch: 488, case: 494, try: 500, catch: 504, finally: 508, return: 512, throw: 516, break: 520, continue: 524, debugger: 528 }, OMe = { __proto__: null, async: 117, get: 119, set: 121, declare: 181, public: 183, private: 183, protected: 183, static: 185, abstract: 187, override: 189, readonly: 195, accessor: 197, new: 385 }, mMe = { __proto__: null, "<": 137 }, EMe = No.deserialize({
  version: 14,
  states: "$6tO`QUOOO%TQUOOO'WQWOOP(eOSOOO*sQ(CjO'#CfO*zOpO'#CgO+YO!bO'#CgO+hO07`O'#DZO-yQUO'#DaO.ZQUO'#DlO%TQUO'#DvO0_QUO'#EOOOQ(CY'#EW'#EWO0xQSO'#ETOOQO'#Ei'#EiOOQO'#Ic'#IcO1QQSO'#GkO1]QSO'#EhO1bQSO'#EhO3dQ(CjO'#JdO6TQ(CjO'#JeO6qQSO'#FWO6vQ#tO'#FoOOQ(CY'#F`'#F`O7RO&jO'#F`O7aQ,UO'#FvO8wQSO'#FuOOQ(CY'#Je'#JeOOQ(CW'#Jd'#JdO8|QSO'#GoOOQQ'#KP'#KPO9XQSO'#IPO9^Q(C[O'#IQOOQQ'#JQ'#JQOOQQ'#IU'#IUQ`QUOOO%TQUO'#DnO9fQUO'#DzO9mQUO'#D|O9SQSO'#GkO9tQ,UO'#ClO:SQSO'#EgO:_QSO'#ErO:dQ,UO'#F_O;RQSO'#GkOOQO'#KQ'#KQO;WQSO'#KQO;fQSO'#GsO;fQSO'#GtO;fQSO'#GvO9SQSO'#GyO<]QSO'#G|O=tQSO'#CbO>UQSO'#HYO>^QSO'#H`O>^QSO'#HbO`QUO'#HdO>^QSO'#HfO>^QSO'#HiO>cQSO'#HoO>hQ(C]O'#HuO%TQUO'#HwO>sQ(C]O'#HyO?OQ(C]O'#H{O9^Q(C[O'#H}O?ZQ(CjO'#CfO@]QWO'#DfQOQSOOO%TQUO'#D|O@sQSO'#EPO9tQ,UO'#EgOAOQSO'#EgOAZQ`O'#F_OOQQ'#Cd'#CdOOQ(CW'#Dk'#DkOOQ(CW'#Jh'#JhO%TQUO'#JhOOQO'#Jl'#JlOOQO'#I`'#I`OBZQWO'#E`OOQ(CW'#E_'#E_OCVQ(C`O'#E`OCaQWO'#ESOOQO'#Jk'#JkOCuQWO'#JlOESQWO'#ESOCaQWO'#E`PEaO?MpO'#C`POOO)CDo)CDoOOOO'#IV'#IVOElOpO,59ROOQ(CY,59R,59ROOOO'#IW'#IWOEzO!bO,59RO%TQUO'#D]OOOO'#IY'#IYOFYO07`O,59uOOQ(CY,59u,59uOFhQUO'#IZOF{QSO'#JfOH}QbO'#JfO+vQUO'#JfOIUQSO,59{OIlQSO'#EiOIyQSO'#JtOJUQSO'#JsOJUQSO'#JsOJ^QSO,5;VOJcQSO'#JrOOQ(CY,5:W,5:WOJjQUO,5:WOLkQ(CjO,5:bOM[QSO,5:jOMuQ(C[O'#JqOM|QSO'#JpO8|QSO'#JpONbQSO'#JpONjQSO,5;UONoQSO'#JpO!!wQbO'#JeOOQ(CY'#Cf'#CfO%TQUO'#EOO!#gQ`O,5:oOOQO'#Jm'#JmOOQO-E<a-E<aO9SQSO,5=VO!#}QSO,5=VO!$SQUO,5;SO!&VQ,UO'#EdO!'jQSO,5;SO!)SQ,UO'#DpO!)ZQUO'#DuO!)eQWO,5;]O!)mQWO,5;]O%TQUO,5;]OOQQ'#FO'#FOOOQQ'#FQ'#FQO%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^O%TQUO,5;^OOQQ'#FU'#FUO!){QUO,5;oOOQ(CY,5;t,5;tOOQ(CY,5;u,5;uO!,OQSO,5;uOOQ(CY,5;v,5;vO%TQUO'#IgO!,WQ(C[O,5<cO!&VQ,UO,5;^O!,uQ,UO,5;^O%TQUO,5;rO!,|Q#tO'#FeO!-yQ#tO'#JxO!-eQ#tO'#JxO!.QQ#tO'#JxOOQO'#Jx'#JxO!.fQ#tO,5;}OOOO,5<Z,5<ZO!.wQUO'#FqOOOO'#If'#IfO7RO&jO,5;zO!/OQ#tO'#FsOOQ(CY,5;z,5;zO!/oQ7[O'#CrOOQ(CY'#Cv'#CvO!0SQSO'#CvO!0XO07`O'#CzO!0uQ,UO,5<`O!0|QSO,5<bO!2cQMhO'#GQO!2pQSO'#GRO!2uQSO'#GRO!2zQMhO'#GVO!3yQWO'#GZO!4lQ7[O'#J_OOQ(CY'#J_'#J_O!4vQSO'#J^O!5UQSO'#J]O!5^QSO'#CqOOQ(CY'#Ct'#CtOOQ(CY'#DO'#DOOOQ(CY'#DQ'#DQO0{QSO'#DSO!'oQ,UO'#FxO!'oQ,UO'#FzO!5fQSO'#F|O!5kQSO'#F}O!2uQSO'#GTO!'oQ,UO'#GYO!5pQSO'#EjO!6_QSO,5<aOOQ(CW'#Co'#CoO!6gQSO'#EkO!7aQWO'#ElOOQ(CW'#Jr'#JrO!7hQ(C[O'#KRO9^Q(C[O,5=ZO`QUO,5>kOOQQ'#JY'#JYOOQQ,5>l,5>lOOQQ-E<S-E<SO!9jQ(CjO,5:YO!<WQ(CjO,5:fO%TQUO,5:fO!>qQ(CjO,5:hOOQO,5@l,5@lO!?bQ,UO,5=VO!?pQ(C[O'#JZO8wQSO'#JZO!@RQ(C[O,59WO!@^QWO,59WO!@fQ,UO,59WO9tQ,UO,59WO!@qQSO,5;SO!@yQSO'#HXO!A[QSO'#KUO%TQUO,5;wO!7[QWO,5;yO!AdQSO,5=rO!AiQSO,5=rO!AnQSO,5=rO9^Q(C[O,5=rO;fQSO,5=bOOQO'#Cr'#CrO!A|QWO,5=_O!BUQ,UO,5=`O!BaQSO,5=bO!BfQ`O,5=eO!BnQSO'#KQO>cQSO'#HOO9SQSO'#HQO!BsQSO'#HQO9tQ,UO'#HSO!BxQSO'#HSOOQQ,5=h,5=hO!B}QSO'#HTO!CVQSO'#ClO!C[QSO,58|O!CfQSO,58|O!EkQUO,58|OOQQ,58|,58|O!E{Q(C[O,58|O%TQUO,58|O!HWQUO'#H[OOQQ'#H]'#H]OOQQ'#H^'#H^O`QUO,5=tO!HnQSO,5=tO`QUO,5=zO`QUO,5=|O!HsQSO,5>OO`QUO,5>QO!HxQSO,5>TO!H}QUO,5>ZOOQQ,5>a,5>aO%TQUO,5>aO9^Q(C[O,5>cOOQQ,5>e,5>eO!MXQSO,5>eOOQQ,5>g,5>gO!MXQSO,5>gOOQQ,5>i,5>iO!M^QWO'#DXO%TQUO'#JhO!M{QWO'#JhO!NjQWO'#DgO!N{QWO'#DgO##^QUO'#DgO##eQSO'#JgO##mQSO,5:QO##rQSO'#EmO#$QQSO'#JuO#$YQSO,5;WO#$_QWO'#DgO#$lQWO'#EROOQ(CY,5:k,5:kO%TQUO,5:kO#$sQSO,5:kO>cQSO,5;RO!@^QWO,5;RO!@fQ,UO,5;RO9tQ,UO,5;RO#${QSO,5@SO#%QQ!LQO,5:oOOQO-E<^-E<^O#&WQ(C`O,5:zOCaQWO,5:nO#&bQWO,5:nOCaQWO,5:zO!@RQ(C[O,5:nOOQ(CW'#Ec'#EcOOQO,5:z,5:zO%TQUO,5:zO#&oQ(C[O,5:zO#&zQ(C[O,5:zO!@^QWO,5:nOOQO,5;Q,5;QO#'YQ(C[O,5:zPOOO'#IT'#ITP#'nO?MpO,58zPOOO,58z,58zOOOO-E<T-E<TOOQ(CY1G.m1G.mOOOO-E<U-E<UO#'yQ`O,59wOOOO-E<W-E<WOOQ(CY1G/a1G/aO#(OQbO,5>uO+vQUO,5>uOOQO,5>{,5>{O#(YQUO'#IZOOQO-E<X-E<XO#(gQSO,5@QO#(oQbO,5@QO#(vQSO,5@_OOQ(CY1G/g1G/gO%TQUO,5@`O#)OQSO'#IaOOQO-E<_-E<_O#(vQSO,5@_OOQ(CW1G0q1G0qOOQ(CY1G/r1G/rOOQ(CY1G0U1G0UO%TQUO,5@]O#)dQ(C[O,5@]O#)uQ(C[O,5@]O#)|QSO,5@[O8|QSO,5@[O#*UQSO,5@[O#*dQSO'#IdO#)|QSO,5@[OOQ(CW1G0p1G0pO!)eQWO,5:qO!)pQWO,5:qOOQO,5:s,5:sO#+UQSO,5:sO#+^Q,UO1G2qO9SQSO1G2qOOQ(CY1G0n1G0nO#+lQ(CjO1G0nO#,qQ(ChO,5;OOOQ(CY'#GP'#GPO#-_Q(CjO'#J_O!$SQUO1G0nO#/gQ,UO'#JiO#/qQSO,5:[O#/vQbO'#JjO%TQUO'#JjO#0QQSO,5:aOOQ(CY'#DX'#DXOOQ(CY1G0w1G0wO%TQUO1G0wOOQ(CY1G1a1G1aO#0VQSO1G0wO#2nQ(CjO1G0xO#2uQ(CjO1G0xO#5`Q(CjO1G0xO#5gQ(CjO1G0xO#7qQ(CjO1G0xO#8XQ(CjO1G0xO#;RQ(CjO1G0xO#;YQ(CjO1G0xO#=sQ(CjO1G0xO#=zQ(CjO1G0xO#?rQ(CjO1G0xO#BrQ$IUO'#CfO#DpQ$IUO1G1ZO#DwQ$IUO'#JeO!,RQSO1G1aO#EXQ(CjO,5?ROOQ(CW-E<e-E<eO#E{Q(CjO1G0xOOQ(CY1G0x1G0xO#HWQ(CjO1G1^O#HzQ#tO,5<RO#ISQ#tO,5<SO#I[Q#tO'#FjO#IsQSO'#FiOOQO'#Jy'#JyOOQO'#Ie'#IeO#IxQ#tO1G1iOOQ(CY1G1i1G1iOOOO1G1t1G1tO#JZQ$IUO'#JdO#JeQSO,5<]O!){QUO,5<]OOOO-E<d-E<dOOQ(CY1G1f1G1fO#JjQWO'#JxOOQ(CY,5<_,5<_O#JrQWO,5<_OOQ(CY,59b,59bO!&VQ,UO'#C|OOOO'#IX'#IXO#JwO07`O,59fOOQ(CY,59f,59fO%TQUO1G1zO!5kQSO'#IiO#KSQ,UO,5<sOOQ(CY,5<p,5<pOOQO'#Gf'#GfO!'oQ,UO,5=POOQO'#Gh'#GhO!'oQ,UO,5=RO!&VQ,UO,5=TOOQO1G1|1G1|O#KZQ`O'#CoO#KnQ`O,5<lO#KuQSO'#J|O9SQSO'#J|O#LTQSO,5<nO!'oQ,UO,5<mO#LYQSO'#GSO#LeQSO,5<mO#LjQ`O'#GPO#LwQ`O'#J}O#MRQSO'#J}O!&VQ,UO'#J}O#MWQSO,5<qO#M]QWO'#G[O!3tQWO'#G[O#MnQSO'#G^O#MsQSO'#G`O!2uQSO'#GcO#MxQ(C[O'#IkO#NTQWO,5<uOOQ(CY,5<u,5<uO#N[QWO'#G[O#NjQWO'#G]O#NrQWO'#G]OOQ(CY,5=U,5=UO!'oQ,UO,5?xO!'oQ,UO,5?xO#NwQSO'#IlO$ SQSO,5?wO$ [QSO,59]O$ {Q,UO,59nOOQ(CY,59n,59nO$!nQ,UO,5<dO$#aQ,UO,5<fO@TQSO,5<hOOQ(CY,5<i,5<iO$#kQSO,5<oO$#pQ,UO,5<tO$$QQSO'#JpO!$SQUO1G1{O$$VQSO1G1{O8|QSO'#JsO8|QSO'#EmO%TQUO'#EmO8|QSO'#InO$$[Q(C[O,5@mOOQQ1G2u1G2uOOQQ1G4V1G4VOOQ(CY1G/t1G/tO!,OQSO1G/tO$&aQ(CjO1G0QOOQQ1G2q1G2qO!&VQ,UO1G2qO%TQUO1G2qO$'QQSO1G2qO$']Q,UO'#EdOOQ(CW,5?u,5?uO$'gQ(C[O,5?uOOQQ1G.r1G.rO!@RQ(C[O1G.rO!@^QWO1G.rO!@fQ,UO1G.rO$'xQSO1G0nO$'}QSO'#CfO$(YQSO'#KVO$(bQSO,5=sO$(gQSO'#KVO$(lQSO'#KVO$(wQSO'#ItO$)VQSO,5@pO$)_QbO1G1cOOQ(CY1G1e1G1eO9SQSO1G3^O@TQSO1G3^O$)fQSO1G3^O$)kQSO1G3^OOQQ1G3^1G3^O!BaQSO1G2|O!&VQ,UO1G2yO$)pQSO1G2yOOQQ1G2z1G2zO!&VQ,UO1G2zO$)uQSO1G2zO$)}QWO'#GxOOQQ1G2|1G2|O!3tQWO'#IpO!BfQ`O1G3POOQQ1G3P1G3POOQQ,5=j,5=jO$*VQ,UO,5=lO9SQSO,5=lO#MsQSO,5=nO8wQSO,5=nO!@^QWO,5=nO!@fQ,UO,5=nO9tQ,UO,5=nO$*eQSO'#KTO$*pQSO,5=oOOQQ1G.h1G.hO$*uQ(C[O1G.hO@TQSO1G.hO$+QQSO1G.hO9^Q(C[O1G.hO$-VQbO,5@rO$-gQSO,5@rO8|QSO,5@rO$-rQUO,5=vO$-yQSO,5=vOOQQ1G3`1G3`O`QUO1G3`OOQQ1G3f1G3fOOQQ1G3h1G3hO>^QSO1G3jO$.OQUO1G3lO$2SQUO'#HkOOQQ1G3o1G3oO$2aQSO'#HqO>cQSO'#HsOOQQ1G3u1G3uO$2iQUO1G3uO9^Q(C[O1G3{OOQQ1G3}1G3}OOQ(CW'#GW'#GWO9^Q(C[O1G4PO9^Q(C[O1G4RO$6pQSO,5@SO!){QUO,5;XO8|QSO,5;XO>cQSO,5:RO!){QUO,5:RO!@^QWO,5:RO$6uQ$IUO,5:ROOQO,5;X,5;XO$7PQWO'#I[O$7gQSO,5@ROOQ(CY1G/l1G/lO$7oQWO'#IbO$7yQSO,5@aOOQ(CW1G0r1G0rO!N{QWO,5:ROOQO'#I_'#I_O$8RQWO,5:mOOQ(CY,5:m,5:mO#$vQSO1G0VOOQ(CY1G0V1G0VO%TQUO1G0VOOQ(CY1G0m1G0mO>cQSO1G0mO!@^QWO1G0mO!@fQ,UO1G0mOOQ(CW1G5n1G5nO!@RQ(C[O1G0YOOQO1G0f1G0fO%TQUO1G0fO$8YQ(C[O1G0fO$8eQ(C[O1G0fO!@^QWO1G0YOCaQWO1G0YO$8sQ(C[O1G0fOOQO1G0Y1G0YO$9XQ(CjO1G0fPOOO-E<R-E<RPOOO1G.f1G.fOOOO1G/c1G/cO$9cQ`O,5<cO$9kQbO1G4aOOQO1G4g1G4gO%TQUO,5>uO$9uQSO1G5lO$9}QSO1G5yO$:VQbO1G5zO8|QSO,5>{O$:aQ(CjO1G5wO%TQUO1G5wO$:qQ(C[O1G5wO$;SQSO1G5vO$;SQSO1G5vO8|QSO1G5vO$;[QSO,5?OO8|QSO,5?OOOQO,5?O,5?OO$;pQSO,5?OO$$QQSO,5?OOOQO-E<b-E<bOOQO1G0]1G0]OOQO1G0_1G0_O!,RQSO1G0_OOQQ7+(]7+(]O!&VQ,UO7+(]O%TQUO7+(]O$<OQSO7+(]O$<ZQ,UO7+(]O$<iQ(CjO,59nO$>qQ(CjO,5<dO$@|Q(CjO,5<fO$CXQ(CjO,5<tOOQ(CY7+&Y7+&YO$EjQ(CjO7+&YO$F^Q,UO'#I]O$FhQSO,5@TOOQ(CY1G/v1G/vO$FpQUO'#I^O$F}QSO,5@UO$GVQbO,5@UOOQ(CY1G/{1G/{O$GaQSO7+&cOOQ(CY7+&c7+&cO$GfQ$IUO,5:bO%TQUO7+&uO$GpQ$IUO,5:YO$G}Q$IUO,5:fO$HXQ$IUO,5:hOOQ(CY7+&{7+&{OOQO1G1m1G1mOOQO1G1n1G1nO$HcQ#tO,5<UO!){QUO,5<TOOQO-E<c-E<cOOQ(CY7+'T7+'TOOOO7+'`7+'`OOOO1G1w1G1wO$HnQSO1G1wOOQ(CY1G1y1G1yO$HsQ`O,59hOOOO-E<V-E<VOOQ(CY1G/Q1G/QO$HzQ(CjO7+'fOOQ(CY,5?T,5?TO$InQ`O,5?TOOQ(CY1G2_1G2_P!&VQ,UO'#IiPOQ(CY-E<g-E<gO$J^Q,UO1G2kO$KPQ,UO1G2mO$KZQ`O1G2oOOQ(CY1G2W1G2WO$KbQSO'#IhO$KpQSO,5@hO$KpQSO,5@hO$KxQSO,5@hO$LTQSO,5@hOOQO1G2Y1G2YO$LcQ,UO1G2XO!'oQ,UO1G2XO$LsQMhO'#IjO$MTQSO,5@iO!&VQ,UO,5@iO$M]Q`O,5@iOOQ(CY1G2]1G2]OOQ(CW,5<v,5<vOOQ(CW,5<w,5<wO$$QQSO,5<wOCQQSO,5<wO!@^QWO,5<vOOQO'#G_'#G_O$MgQSO,5<xOOQ(CW,5<z,5<zO$$QQSO,5<}OOQO,5?V,5?VOOQO-E<i-E<iOOQ(CY1G2a1G2aO!3tQWO,5<vO$MoQSO,5<wO#MnQSO,5<xO!3tQWO,5<wO$MzQ,UO1G5dO$NUQ,UO1G5dOOQO,5?W,5?WOOQO-E<j-E<jOOQO1G.w1G.wO!7[QWO,59pO%TQUO,59pO$NcQSO1G2SO!'oQ,UO1G2ZO$NhQ(CjO7+'gOOQ(CY7+'g7+'gO!$SQUO7+'gO% [QSO,5;XOOQ(CW,5?Y,5?YOOQ(CW-E<l-E<lOOQ(CY7+%`7+%`O% aQ`O'#KOO#$vQSO7+(]O% kQbO7+(]O$<RQSO7+(]O% rQ(ChO'#CfO%!VQ(ChO,5<{O%!wQSO,5<{OOQ(CW1G5a1G5aOOQQ7+$^7+$^O!@RQ(C[O7+$^O!@^QWO7+$^O!$SQUO7+&YO%!|QSO'#IsO%#bQSO,5@qOOQO1G3_1G3_O9SQSO,5@qO%#bQSO,5@qO%#jQSO,5@qOOQO,5?`,5?`OOQO-E<r-E<rOOQ(CY7+&}7+&}O%#oQSO7+(xO9^Q(C[O7+(xO9SQSO7+(xO@TQSO7+(xOOQQ7+(h7+(hO%#tQ(ChO7+(eO!&VQ,UO7+(eO%$OQ`O7+(fOOQQ7+(f7+(fO!&VQ,UO7+(fO%$VQSO'#KSO%$bQSO,5=dOOQO,5?[,5?[OOQO-E<n-E<nOOQQ7+(k7+(kO%%qQWO'#HROOQQ1G3W1G3WO!&VQ,UO1G3WO%TQUO1G3WO%%xQSO1G3WO%&TQ,UO1G3WO9^Q(C[O1G3YO#MsQSO1G3YO8wQSO1G3YO!@^QWO1G3YO!@fQ,UO1G3YO%&cQSO'#IrO%&nQSO,5@oO%&vQWO,5@oOOQ(CW1G3Z1G3ZOOQQ7+$S7+$SO@TQSO7+$SO9^Q(C[O7+$SO%'RQSO7+$SO%TQUO1G6^O%TQUO1G6_O%'WQ(C[O1G6^O%'bQUO1G3bO%'iQSO1G3bO%'nQUO1G3bOOQQ7+(z7+(zO9^Q(C[O7+)UO`QUO7+)WOOQQ'#KY'#KYOOQQ'#Iu'#IuO%'uQUO,5>VOOQQ,5>V,5>VO%TQUO'#HlO%(SQSO'#HnOOQQ,5>],5>]O8|QSO,5>]OOQQ,5>_,5>_OOQQ7+)a7+)aOOQQ7+)g7+)gOOQQ7+)k7+)kOOQQ7+)m7+)mO%(XQWO1G5nO%(mQ$IUO1G0sO%(wQSO1G0sOOQO1G/m1G/mO%)SQ$IUO1G/mO>cQSO1G/mO!){QUO'#DgOOQO,5>v,5>vOOQO-E<Y-E<YOOQO,5>|,5>|OOQO-E<`-E<`O!@^QWO1G/mOOQO-E<]-E<]OOQ(CY1G0X1G0XOOQ(CY7+%q7+%qO#$vQSO7+%qOOQ(CY7+&X7+&XO>cQSO7+&XO!@^QWO7+&XOOQO7+%t7+%tO$9XQ(CjO7+&QOOQO7+&Q7+&QO%TQUO7+&QO%)^Q(C[O7+&QO!@RQ(C[O7+%tO!@^QWO7+%tO%)iQ(C[O7+&QO%)wQ(CjO7++cO%TQUO7++cO%*XQSO7++bO%*XQSO7++bOOQO1G4j1G4jO8|QSO1G4jO%*aQSO1G4jOOQO7+%y7+%yO#$vQSO<<KwO% kQbO<<KwO%*oQSO<<KwOOQQ<<Kw<<KwO!&VQ,UO<<KwO%TQUO<<KwO%*wQSO<<KwO%+SQ(CjO1G2kO%-_Q(CjO1G2mO%/jQ(CjO1G2XO%1{Q,UO,5>wOOQO-E<Z-E<ZO%2VQbO,5>xO%TQUO,5>xOOQO-E<[-E<[O%2aQSO1G5pOOQ(CY<<I}<<I}O%2iQ$IUO1G0nO%4sQ$IUO1G0xO%4zQ$IUO1G0xO%7OQ$IUO1G0xO%7VQ$IUO1G0xO%8zQ$IUO1G0xO%9bQ$IUO1G0xO%;uQ$IUO1G0xO%;|Q$IUO1G0xO%>QQ$IUO1G0xO%>XQ$IUO1G0xO%@PQ$IUO1G0xO%@dQ(CjO<<JaO%AiQ$IUO1G0xO%C_Q$IUO'#J_O%EbQ$IUO1G1^O%EoQ$IUO1G0QO!){QUO'#FlOOQO'#Jz'#JzOOQO1G1p1G1pO%EyQSO1G1oO%FOQ$IUO,5?ROOOO7+'c7+'cOOOO1G/S1G/SOOQ(CY1G4o1G4oO!'oQ,UO7+(ZO%FYQSO,5?SO9SQSO,5?SOOQO-E<f-E<fO%FhQSO1G6SO%FhQSO1G6SO%FpQSO1G6SO%F{Q,UO7+'sO%G]Q`O,5?UO%GgQSO,5?UO!&VQ,UO,5?UOOQO-E<h-E<hO%GlQ`O1G6TO%GvQSO1G6TOOQ(CW1G2c1G2cO$$QQSO1G2cOOQ(CW1G2b1G2bO%HOQSO1G2dO!&VQ,UO1G2dOOQ(CW1G2i1G2iO!@^QWO1G2bOCQQSO1G2cO%HTQSO1G2dO%H]QSO1G2cO!'oQ,UO7++OOOQ(CY1G/[1G/[O%HhQSO1G/[OOQ(CY7+'n7+'nO%HmQ,UO7+'uO%H}Q(CjO<<KROOQ(CY<<KR<<KRO%IqQSO1G0sO!&VQ,UO'#ImO%IvQSO,5@jO!&VQ,UO1G2gOOQQ<<Gx<<GxO!@RQ(C[O<<GxO%JOQ(CjO<<ItOOQ(CY<<It<<ItOOQO,5?_,5?_O%JrQSO,5?_O$(lQSO,5?_OOQO-E<q-E<qO%JwQSO1G6]O%JwQSO1G6]O9SQSO1G6]O@TQSO<<LdOOQQ<<Ld<<LdO%KPQSO<<LdO9^Q(C[O<<LdOOQQ<<LP<<LPO%#tQ(ChO<<LPOOQQ<<LQ<<LQO%$OQ`O<<LQO%KUQWO'#IoO%KaQSO,5@nO!){QUO,5@nOOQQ1G3O1G3OO%KiQUO'#JhOOQO'#Iq'#IqO9^Q(C[O'#IqO%KsQWO,5=mOOQQ,5=m,5=mO%KzQWO'#E`O%L`QSO7+(rO%LeQSO7+(rOOQQ7+(r7+(rO!&VQ,UO7+(rO%TQUO7+(rO%LmQSO7+(rOOQQ7+(t7+(tO9^Q(C[O7+(tO#MsQSO7+(tO8wQSO7+(tO!@^QWO7+(tO%LxQSO,5?^OOQO-E<p-E<pOOQO'#HU'#HUO%MTQSO1G6ZO9^Q(C[O<<GnOOQQ<<Gn<<GnO@TQSO<<GnO%M]QSO7++xO%MbQSO7++yO%TQUO7++xO%TQUO7++yOOQQ7+(|7+(|O%MgQSO7+(|O%MlQUO7+(|O%MsQSO7+(|OOQQ<<Lp<<LpOOQQ<<Lr<<LrOOQQ-E<s-E<sOOQQ1G3q1G3qO%MxQSO,5>WOOQQ,5>Y,5>YO%M}QSO1G3wO8|QSO7+&_O!){QUO7+&_OOQO7+%X7+%XO%NSQ$IUO1G5zO>cQSO7+%XOOQ(CY<<I]<<I]OOQ(CY<<Is<<IsO>cQSO<<IsOOQO<<Il<<IlO$9XQ(CjO<<IlO%TQUO<<IlOOQO<<I`<<I`O!@RQ(C[O<<I`O%N^Q(C[O<<IlO%NiQ(CjO<<N}O%NyQSO<<N|OOQO7+*U7+*UO8|QSO7+*UOOQQANAcANAcO& RQSOANAcO!&VQ,UOANAcO#$vQSOANAcO% kQbOANAcO%TQUOANAcO& ZQ(CjO7+'sO&#lQ(CjO7+'uO&%}QbO1G4dO&&XQ$IUO7+&YO&&fQ$IUO,59nO&(iQ$IUO,5<dO&*lQ$IUO,5<fO&,oQ$IUO,5<tO&.eQ$IUO7+'fO&.rQ$IUO7+'gO&/PQSO,5<WOOQO7+'Z7+'ZO&/UQ,UO<<KuOOQO1G4n1G4nO&/]QSO1G4nO&/hQSO1G4nO&/vQSO7++nO&/vQSO7++nO!&VQ,UO1G4pO&0OQ`O1G4pO&0YQSO7++oOOQ(CW7+'}7+'}O$$QQSO7+(OO&0bQ`O7+(OOOQ(CW7+'|7+'|O$$QQSO7+'}O&0iQSO7+(OO!&VQ,UO7+(OOCQQSO7+'}O&0nQ,UO<<NjOOQ(CY7+$v7+$vO&0xQ`O,5?XOOQO-E<k-E<kO&1SQ(ChO7+(ROOQQAN=dAN=dO9SQSO1G4yOOQO1G4y1G4yO&1dQSO1G4yO&1iQSO7++wO&1iQSO7++wO9^Q(C[OANBOO@TQSOANBOOOQQANBOANBOOOQQANAkANAkOOQQANAlANAlO&1qQSO,5?ZOOQO-E<m-E<mO&1|Q$IUO1G6YO&4^QbO'#CfOOQO,5?],5?]OOQO-E<o-E<oOOQQ1G3X1G3XO%KiQUO,5<xOOQQ<<L^<<L^O!&VQ,UO<<L^O%L`QSO<<L^O&4hQSO<<L^O%TQUO<<L^OOQQ<<L`<<L`O9^Q(C[O<<L`O#MsQSO<<L`O8wQSO<<L`O&4pQWO1G4xO&4{QSO7++uOOQQAN=YAN=YO9^Q(C[OAN=YOOQQ<= d<= dOOQQ<= e<= eO&5TQSO<= dO&5YQSO<= eOOQQ<<Lh<<LhO&5_QSO<<LhO&5dQUO<<LhOOQQ1G3r1G3rO>cQSO7+)cO&5kQSO<<IyO&5vQ$IUO<<IyOOQO<<Hs<<HsOOQ(CYAN?_AN?_OOQOAN?WAN?WO$9XQ(CjOAN?WOOQOAN>zAN>zO%TQUOAN?WOOQO<<Mp<<MpOOQQG26}G26}O!&VQ,UOG26}O#$vQSOG26}O&6QQSOG26}O% kQbOG26}O&6YQ$IUO<<JaO&6gQ$IUO1G2XO&8]Q$IUO1G2kO&:`Q$IUO1G2mO&<cQ$IUO<<KRO&<pQ$IUO<<ItOOQO1G1r1G1rO!'oQ,UOANAaOOQO7+*Y7+*YO&<}QSO7+*YO&=YQSO<= YO&=bQ`O7+*[OOQ(CW<<Kj<<KjO$$QQSO<<KjOOQ(CW<<Ki<<KiO&=lQ`O<<KjO$$QQSO<<KiOOQO7+*e7+*eO9SQSO7+*eO&=sQSO<= cOOQQG27jG27jO9^Q(C[OG27jO!){QUO1G4uO&={QSO7++tO%L`QSOANAxOOQQANAxANAxO!&VQ,UOANAxO&>TQSOANAxOOQQANAzANAzO9^Q(C[OANAzO#MsQSOANAzOOQO'#HV'#HVOOQO7+*d7+*dOOQQG22tG22tOOQQANEOANEOOOQQANEPANEPOOQQANBSANBSO&>]QSOANBSOOQQ<<L}<<L}O!){QUOAN?eOOQOG24rG24rO$9XQ(CjOG24rO#$vQSOLD,iOOQQLD,iLD,iO!&VQ,UOLD,iO&>bQSOLD,iO&>jQ$IUO7+'sO&@`Q$IUO7+'uO&BUQ,UOG26{OOQO<<Mt<<MtOOQ(CWANAUANAUO$$QQSOANAUOOQ(CWANATANATOOQO<<NP<<NPOOQQLD-ULD-UO&BfQ$IUO7+*aOOQQG27dG27dO%L`QSOG27dO!&VQ,UOG27dOOQQG27fG27fO9^Q(C[OG27fOOQQG27nG27nO&BpQ$IUOG25POOQOLD*^LD*^OOQQ!$(!T!$(!TO#$vQSO!$(!TO!&VQ,UO!$(!TO&BzQ(CjOG26{OOQ(CWG26pG26pOOQQLD-OLD-OO%L`QSOLD-OOOQQLD-QLD-QOOQQ!)9Eo!)9EoO#$vQSO!)9EoOOQQ!$(!j!$(!jOOQQ!.K;Z!.K;ZO&E]Q$IUOG26{O!){QUO'#DvO0xQSO'#ETO&GRQbO'#JdO!){QUO'#DnO&GYQUO'#DzO&GaQbO'#CfO&IwQbO'#CfO!){QUO'#D|O&JXQUO,5;SO!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO,5;^O!){QUO'#IgO&L[QSO,5<cO&LdQ,UO,5;^O&MwQ,UO,5;^O!){QUO,5;rO0{QSO'#DSO0{QSO'#DSO!&VQ,UO'#FxO&LdQ,UO'#FxO!&VQ,UO'#FzO&LdQ,UO'#FzO!&VQ,UO'#GYO&LdQ,UO'#GYO!){QUO,5:fO!){QUO,5@`O&JXQUO1G0nO&NOQ$IUO'#CfO!){QUO1G1zO!&VQ,UO,5=PO&LdQ,UO,5=PO!&VQ,UO,5=RO&LdQ,UO,5=RO!&VQ,UO,5<mO&LdQ,UO,5<mO&JXQUO1G1{O!){QUO7+&uO!&VQ,UO1G2XO&LdQ,UO1G2XO!&VQ,UO1G2ZO&LdQ,UO1G2ZO&JXQUO7+'gO&JXQUO7+&YO!&VQ,UOANAaO&LdQ,UOANAaO&NYQSO'#EhO&N_QSO'#EhO&NgQSO'#FWO&NlQSO'#ErO&NqQSO'#JtO&N|QSO'#JrO' XQSO,5;SO' ^Q,UO,5<`O' eQSO'#GRO' jQSO'#GRO' oQSO,5<aO' wQSO,5;SO'!PQ$IUO1G1ZO'!WQSO,5<mO'!]QSO,5<mO'!bQSO,5<oO'!gQSO,5<oO'!lQSO1G1{O'!qQSO1G0nO'!vQ,UO<<KuO'!}Q,UO<<KuO7aQ,UO'#FvO8wQSO'#FuOAOQSO'#EgO!){QUO,5;oO!2uQSO'#GRO!2uQSO'#GRO!2uQSO'#GTO!2uQSO'#GTO!'oQ,UO7+(ZO!'oQ,UO7+(ZO$KZQ`O1G2oO$KZQ`O1G2oO!&VQ,UO,5=TO!&VQ,UO,5=T",
  stateData: "'$W~O'nOS'oOSROS'pRQ~OPYOQYOV!UO^qOayObxOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!ctO!hZO!kYO!lYO!mYO!ouO!qvO!twO!x]O#p!OO$Q{O$UfO%`|O%b!PO%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO%q!TO%}!VO&T!WO&V!XO&X!YO&Z!ZO&^![O&d!]O&j!^O&l!_O&n!`O&p!aO&r!bO'uSO'wTO'zUO(SVO(b[O(oiO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~O^!uOl!mO|!nO![!wO!]!tO!^!tO!x9qO!|!oO!}!oO#O!vO#P!oO#Q!oO#T!xO#U!xO'v!kO'wTO'zUO(V!lO(b!rO~O'p!yO~OPYXXYX^YXkYXyYXzYX|YX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX'lYX(SYX(cYX(jYX(kYX~O!a$zX~P(jO[!{O'w!}O'x!{O'y!}O~O[#OO'y!}O'z!}O'{#OO~Oq#QO!O#RO(T#RO(U#TO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u9uO'wTO'zUO(SVO(b[O(oiO~O!U#XO!V#UO!S(YP!S(gP~P+vO!W#aO~P`OPYOQYOa!iOb!hOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'wTO'zUO(SVO(b[O(oiO~Oi#kO!U#gO!x]O#b#jO#c#gO'u9vO!g(dP~P.bO!h#mO'u#lO~O!t#qO!x]O%`#rO~O#d#sO~O!a#tO#d#sO~OP$[OX$cOk$POy#xOz#yO|#zO!V$`O!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O^(WX'l(WX'j(WX!g(WX!S(WX!X(WX%a(WX!a(WX~P1jO#X$dO#{$dOP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#o(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX!X(XX%a(XX~O^(XX!f(XX'l(XX'j(XX!S(XX!g(XXo(XX!a(XX~P4QO#X$dO~O$W$fO$Y$eO$a$kO~O!X$lO$UfO$d$mO$f$oO~Oi%ROk$sOl$rOm$rOs%SOu%TOw%UO|$zO!X${O!c%ZO!h$wO#c%[O$Q%XO$m%VO$o%WO$r%YO'u$qO'wTO'zUO(O%QO(S$tOd(PP~O!h%]O~O|%`O!X%aO'u%_O~O!a%eO~O^%fO'l%fO~O'v!kO~P%TO%f%mO~P%TO!h%]O'u%_O'v!kO(O%QO~Ob%tO!h%]O'u%_O~O#o$RO~Oy%yO!X%vO!h%xO%b%|O'u%_O'v!kO'wTO'zUO](xP~O!t#qO~O%k&OO|(tX!X(tX'u(tX~O'u&PO~O!q&UO#p!OO%b!PO%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO~Oa&ZOb&YO!t&WO%`&XO%s&VO~P;kOa&^ObxO!X&]O!q&UO!twO!x]O#p!OO%`|O%d}O%e}O%f}O%i!QO%k!RO%n!SO%o!SO%q!TO~O_&aO#X&dO%b&_O'v!kO~P<pO!h&eO!q&iO~O!h#mO~O!XXO~O^%fO'k&qO'l%fO~O^%fO'k&tO'l%fO~O^%fO'k&vO'l%fO~O'jYX!SYXoYX!gYX&RYX!XYX%aYX!aYX~P(jO!['TO!]&|O!^&|O'v!kO'wTO'zUO~Ol&zO|&yO!U&}O(V&xO!W(ZP!W(iP~P?wOg'WO!X'UO'u%_O~Ob']O!h%]O'u%_O~Oy%yO!h%xO~Ol!mO|!nO!x9qO!|!oO!}!oO#P!oO#Q!oO'v!kO'wTO'zUO(V!lO(b!rO~O!['cO!]'bO!^'bO#O!oO#T'dO#U'dO~PAcO^%fO!a#tO!h%]O'l%fO(O%QO(c'fO~O!l'jO#X'hO~PBqOl!mO|!nO'wTO'zUO(V!lO(b!rO~O!XXOl(`X|(`X![(`X!](`X!^(`X!x(`X!|(`X!}(`X#O(`X#P(`X#Q(`X#T(`X#U(`X'v(`X'w(`X'z(`X(V(`X(b(`X~O!]'bO!^'bO'v!kO~PCaO'q'nO'r'nO's'pO~O[!{O'w'rO'x!{O'y'rO~O[#OO'y'rO'z'rO'{#OO~Oq#QO!O#RO(T#RO(U'vO~O!U'xO!S&}X!S'TX!V&}X!V'TX~P+vO!V'zO!S(YX~OP$[OX$cOk$POy#xOz#yO|#zO!V'zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O!S(YX~PGTO!S(PO~O!S(fX!V(fX!a(fX!g(fX(c(fX~O#X(fX#d#]X!W(fX~PIZO#X(QO!S(hX!V(hX~O!V(RO!S(gX~O!S(UO~O#X$dO~PIZO!W(VO~P`Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!jaX!jak!ja!V!ja!e!ja!l!ja#g!ja#h!ja#i!ja#j!ja#k!ja#l!ja#m!ja#n!ja#o!ja#q!ja#s!ja#u!ja#v!ja(c!ja(j!ja(k!ja~O^!ja'l!ja'j!ja!S!ja!g!jao!ja!X!ja%a!ja!a!ja~PJqO!g(WO~O!a#tO#X(XO(c'fO!V(eX^(eX'l(eX~O!g(eX~PMaO|%`O!X%aO!x]O#b(^O#c(]O'u%_O~O!V(_O!g(dX~O!g(aO~O|%`O!X%aO#c(]O'u%_O~OP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!f(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#o(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX~O!a#tO!g(XX~PN}Oy(bOz(cO!f#vO!h#wO!x!wa|!wa~O!t!wa%`!wa!X!wa#b!wa#c!wa'u!wa~P!#RO!t(gO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!XXO!ctO!hZO!kYO!lYO!mYO!ouO!q!fO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~Oi%ROk$sOl$rOm$rOs%SOu%TOw:ZO|$zO!X${O!c;eO!h$wO#c:aO$Q%XO$m:]O$o:_O$r%YO'u(kO'wTO'zUO(O%QO(S$tO~O#d(mO~Oi%ROk$sOl$rOm$rOs%SOu%TOw%UO|$zO!X${O!c%ZO!h$wO#c%[O$Q%XO$m%VO$o%WO$r%YO'u(kO'wTO'zUO(O%QO(S$tO~Od(]P~P!'oO!U(qO!g(^P~P%TO(V(sO(b[O~O|(uO!h#wO(V(sO(b[O~OP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!X!dO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'u)TO'wTO'zUO(SVO(b[O(o;_O~Oz)WO!h#wO~O!V$`O^$ka'l$ka'j$ka!g$ka!S$ka!X$ka%a$ka!a$ka~O#p)[O~P!&VOy)_O!a)^O!X$XX$T$XX$W$XX$Y$XX$a$XX~O!a)^O!X(lX$T(lX$W(lX$Y(lX$a(lX~Oy)_O~P!-eOy)_O!X(lX$T(lX$W(lX$Y(lX$a(lX~O!X)aO$T)eO$W)`O$Y)`O$a)fO~O!U)iO~P!){O$W$fO$Y$eO$a)mO~Og$sXy$sX|$sX!f$sX(j$sX(k$sX~OdfXd$sXgfX!VfX#XfX~P!/ZOl)oO~Oq)pO(T)qO(U)sO~Og)|Oy)uO|)vO(j)xO(k)zO~Od)tO~P!0dOd)}O~Oi%ROk$sOl$rOm$rOs%SOu%TOw:ZO|$zO!X${O!c;eO!h$wO#c:aO$Q%XO$m:]O$o:_O$r%YO'wTO'zUO(O%QO(S$tO~O!U*RO'u*OO!g(pP~P!1RO#d*TO~O!h*UO~O!U*ZO'u*WO!S(qP~P!1ROk*gO|*_O![*eO!]*^O!^*^O!h*UO#T*fO%W*aO'v!kO(V!lO~O!W*dO~P!3XO!f#vOg(RXy(RX|(RX(j(RX(k(RX!V(RX#X(RX~Od(RX#y(RX~P!4QOg*jO#X*iOd(QX!V(QX~O!V*kOd(PX~O'u&POd(PP~O!h*rO~O'u(kO~Oi*vO|%`O!U#gO!X%aO!x]O#b#jO#c#gO'u%_O!g(dP~O!a#tO#d*wO~O|%`O!U*yO!V(RO!X%aO'u%_O!S(gP~Ol'QO|*{O!U*zO'wTO'zUO(V(sO~O!W(iP~P!6{O!V*|O^(uX'l(uX~OP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO#v$XO(SVO(c$YO(j#{O(k#|O~O^!ba!V!ba'l!ba'j!ba!S!ba!g!bao!ba!X!ba%a!ba!a!ba~P!7sOy#xOz#yO|#zO!f#vO!h#wO(SVOP!naX!nak!na!V!na!e!na!l!na#g!na#h!na#i!na#j!na#k!na#l!na#m!na#n!na#o!na#q!na#s!na#u!na#v!na(c!na(j!na(k!na~O^!na'l!na'j!na!S!na!g!nao!na!X!na%a!na!a!na~P!:^Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!paX!pak!pa!V!pa!e!pa!l!pa#g!pa#h!pa#i!pa#j!pa#k!pa#l!pa#m!pa#n!pa#o!pa#q!pa#s!pa#u!pa#v!pa(c!pa(j!pa(k!pa~O^!pa'l!pa'j!pa!S!pa!g!pao!pa!X!pa%a!pa!a!pa~P!<wOg+VO!X'UO%a+UO(O%QO~O!a+XO^'}X!X'}X'l'}X!V'}X~O^%fO!XXO'l%fO~O!h%]O(O%QO~O!h%]O'u%_O(O%QO~O!a#tO#d(mO~O%b+eO'u+aO'wTO'zUO!W(yP~O!V+fO](xX~OX+jO~O]+kO~O!X%vO'u%_O'v!kO](xP~O#X+pO(O%QO~Og+sO!X${O(O%QO~O!X+uO~Oy+wO!XXO~O%f%mO~O!t+|O~Ob,RO~O'u#lO!W(wP~Ob%tO~O%b!PO'u&PO~P<pOX,XO],WO~OPYOQYOayObxOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!ctO!hZO!kYO!lYO!mYO!ouO!twO!x]O$UfO%`|O'wTO'zUO(SVO(b[O(oiO~O!X!dO!q!fO$Q!jO'u!cO~P!CnO],WO^%fO'l%fO~OPYOQYOa!iOb!hOikOkYOlkOmkOskOuYOwYO|WO!QkO!RkO!X!dO!ctO!hZO!kYO!lYO!mYO!ouO!t!gO$Q!jO$UfO'u!cO'wTO'zUO(SVO(b[O(oiO~O^,^O!qvO#p}O%d}O%e}O%f}O~P!FWO!h&eO~O&T,dO~O!X,fO~O&f,hO&h,iOP&caQ&caV&ca^&caa&cab&cai&cak&cal&cam&cas&cau&caw&ca|&ca!Q&ca!R&ca!X&ca!c&ca!h&ca!k&ca!l&ca!m&ca!o&ca!q&ca!t&ca!x&ca#p&ca$Q&ca$U&ca%`&ca%b&ca%d&ca%e&ca%f&ca%i&ca%k&ca%n&ca%o&ca%q&ca%}&ca&T&ca&V&ca&X&ca&Z&ca&^&ca&d&ca&j&ca&l&ca&n&ca&p&ca&r&ca'j&ca'u&ca'w&ca'z&ca(S&ca(b&ca(o&ca!W&ca&[&ca_&ca&a&ca~O'u,nO~O!V{X!V!_X!W{X!W!_X!a{X!a!_X!h!_X#X{X(O!_X~O!a,sO#X,rO!V#aX!V([X!W#aX!W([X!a([X!h([X(O([X~O!a,uO!h%]O(O%QO!V!ZX!W!ZX~Ol!mO|!nO'wTO'zUO(V!lO~OP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!X!dO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'wTO'zUO(SVO(b[O(o;_O~O'u:fO~P# ^O!V,yO!W(ZX~O!W,{O~O!a,sO#X,rO!V#aX!W#aX~O!V,|O!W(iX~O!W-OO~O!]-PO!^-PO'v!kO~P!N{O!W-SO~P'WOg-VO!X'UO~O!S-[O~Ol!wa![!wa!]!wa!^!wa!|!wa!}!wa#O!wa#P!wa#Q!wa#T!wa#U!wa'v!wa'w!wa'z!wa(V!wa(b!wa~P!#RO!l-aO#X-_O~PBqO!]-cO!^-cO'v!kO~PCaO^%fO#X-_O'l%fO~O^%fO!a#tO#X-_O'l%fO~O^%fO!a#tO!l-aO#X-_O'l%fO(c'fO~O'q'nO'r'nO's-hO~Oo-iO~O!S&}a!V&}a~P!7sO!U-mO!S&}X!V&}X~P%TO!V'zO!S(Ya~O!S(Ya~PGTO!V(RO!S(ga~O|%`O!U-qO!X%aO'u%_O!S'TX!V'TX~O#X-sO!V(ea!g(ea^(ea'l(ea~O!a#tO~P#)dO!V(_O!g(da~O|%`O!X%aO#c-wO'u%_O~Oi-|O|%`O!U-yO!X%aO!x]O#b-{O#c-yO'u%_O!V'WX!g'WX~Oz.QO!h#wO~Og.TO!X'UO%a.SO(O%QO~O^#[i!V#[i'l#[i'j#[i!S#[i!g#[io#[i!X#[i%a#[i!a#[i~P!7sOg;kOy)uO|)vO(j)xO(k)zO~O#d#Wa^#Wa#X#Wa'l#Wa!V#Wa!g#Wa!X#Wa!S#Wa~P#,`O#d(RXP(RXX(RX^(RXk(RXz(RX!e(RX!h(RX!l(RX#g(RX#h(RX#i(RX#j(RX#k(RX#l(RX#m(RX#n(RX#o(RX#q(RX#s(RX#u(RX#v(RX'l(RX(S(RX(c(RX!g(RX!S(RX'j(RXo(RX!X(RX%a(RX!a(RX~P!4QO!V.^Od(]X~P!0dOd.`O~O!V.aO!g(^X~P!7sO!g.dO~O!S.fO~OP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O(SVOX#fi^#fik#fi!V#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O#g#fi~P#0[O#g#}O~P#0[OP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO(SVOX#fi^#fi!V#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~Ok#fi~P#2|Ok$PO~P#2|OP$[Ok$POy#xOz#yO|#zO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO(SVO^#fi!V#fi#q#fi#s#fi#u#fi#v#fi'l#fi(c#fi(j#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P#5nOX$cO!e$RO#l$RO#m$RO#n$bO#o$RO~P#5nOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO(SVO^#fi!V#fi#s#fi#u#fi#v#fi'l#fi(c#fi(k#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(j#fi~P#8oO(j#{O~P#8oOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO(SVO(j#{O^#fi!V#fi#u#fi#v#fi'l#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~O(k#fi~P#;aO(k#|O~P#;aOP$[OX$cOk$POy#xOz#yO|#zO!e$RO!f#vO!h#wO!l$[O#g#}O#h$OO#i$OO#j$OO#k$QO#l$RO#m$RO#n$bO#o$RO#q$SO#s$UO#u$WO(SVO(j#{O(k#|O~O^#fi!V#fi#v#fi'l#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#>ROPYXXYXkYXyYXzYX|YX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX!VYX!WYX~O#yYX~P#@lOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO#u:SO#v:TO(SVO(c$YO(j#{O(k#|O~O#y.hO~P#ByO#X:YO#{:YO#y(XX!W(XX~PN}O^'Za!V'Za'l'Za'j'Za!g'Za!S'Zao'Za!X'Za%a'Za!a'Za~P!7sOP#fiX#fi^#fik#fiz#fi!V#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi'l#fi(S#fi(c#fi'j#fi!S#fi!g#fio#fi!X#fi%a#fi!a#fi~P#,`O^#zi!V#zi'l#zi'j#zi!S#zi!g#zio#zi!X#zi%a#zi!a#zi~P!7sO$W.mO$Y.mO~O$W.nO$Y.nO~O!a)^O#X.oO!X$^X$T$^X$W$^X$Y$^X$a$^X~O!U.pO~O!X)aO$T.rO$W)`O$Y)`O$a.sO~O!V:UO!W(WX~P#ByO!W.tO~O!a)^O$a(lX~O$a.vO~Oq)pO(T)qO(U.yO~O!S.}O~P!&VO!VcX!acX!gcX!g$sX(ccX~P!/ZO!g/TO~P#,`O!V/UO!a#tO(c'fO!g(pX~O!g/ZO~O!U*RO'u%_O!g(pP~O#d/]O~O!S$sX!V$sX!a$zX~P!/ZO!V/^O!S(qX~P#,`O!a/`O~O!S/bO~Ok/fO!a#tO!h%]O(O%QO(c'fO~O'u/hO~O!a+XO~O^%fO!V/lO'l%fO~O!W/nO~P!3XO!]/oO!^/oO'v!kO(V!lO~O|/qO(V!lO~O#T/rO~O'u&POd'`X!V'`X~O!V*kOd(Pa~Od/wO~Oy/xOz/xO|/yOgva(jva(kva!Vva#Xva~Odva#yva~P$ aOy)uO|)vOg$la(j$la(k$la!V$la#X$la~Od$la#y$la~P$!VOy)uO|)vOg$na(j$na(k$na!V$na#X$na~Od$na#y$na~P$!xO#d/{O~Od$|a!V$|a#X$|a#y$|a~P!0dO!a#tO~O#d0OO~O!V*|O^(ua'l(ua~Oy#xOz#yO|#zO!f#vO!h#wO(SVOP!niX!nik!ni!V!ni!e!ni!l!ni#g!ni#h!ni#i!ni#j!ni#k!ni#l!ni#m!ni#n!ni#o!ni#q!ni#s!ni#u!ni#v!ni(c!ni(j!ni(k!ni~O^!ni'l!ni'j!ni!S!ni!g!nio!ni!X!ni%a!ni!a!ni~P$$gOg.TO!X'UO%a.SO~Oi0YO'u0XO~P!1UO!a+XO^'}a!X'}a'l'}a!V'}a~O#d0`O~OXYX!VcX!WcX~O!V0aO!W(yX~O!W0cO~OX0dO~O'u+aO'wTO'zUO~O!X%vO'u%_O]'hX!V'hX~O!V+fO](xa~O!g0iO~P!7sOX0lO~O]0mO~O#X0pO~Og0sO!X${O~O(V(sO!W(vP~Og0|O!X0yO%a0{O(O%QO~OX1WO!V1UO!W(wX~O!W1XO~O]1ZO^%fO'l%fO~O'u#lO'wTO'zUO~O#X$dO#{$dOP(XXX(XXk(XXy(XXz(XX|(XX!V(XX!e(XX!h(XX!l(XX#g(XX#h(XX#i(XX#j(XX#k(XX#l(XX#m(XX#n(XX#q(XX#s(XX#u(XX#v(XX(S(XX(c(XX(j(XX(k(XX~O#o1^O&R1_O^(XX!f(XX~P$+]O#X$dO#o1^O&R1_O~O^1aO~P%TO^1cO~O&[1fOP&YiQ&YiV&Yi^&Yia&Yib&Yii&Yik&Yil&Yim&Yis&Yiu&Yiw&Yi|&Yi!Q&Yi!R&Yi!X&Yi!c&Yi!h&Yi!k&Yi!l&Yi!m&Yi!o&Yi!q&Yi!t&Yi!x&Yi#p&Yi$Q&Yi$U&Yi%`&Yi%b&Yi%d&Yi%e&Yi%f&Yi%i&Yi%k&Yi%n&Yi%o&Yi%q&Yi%}&Yi&T&Yi&V&Yi&X&Yi&Z&Yi&^&Yi&d&Yi&j&Yi&l&Yi&n&Yi&p&Yi&r&Yi'j&Yi'u&Yi'w&Yi'z&Yi(S&Yi(b&Yi(o&Yi!W&Yi_&Yi&a&Yi~O_1lO!W1jO&a1kO~P`O!XXO!h1nO~O&h,iOP&ciQ&ciV&ci^&cia&cib&cii&cik&cil&cim&cis&ciu&ciw&ci|&ci!Q&ci!R&ci!X&ci!c&ci!h&ci!k&ci!l&ci!m&ci!o&ci!q&ci!t&ci!x&ci#p&ci$Q&ci$U&ci%`&ci%b&ci%d&ci%e&ci%f&ci%i&ci%k&ci%n&ci%o&ci%q&ci%}&ci&T&ci&V&ci&X&ci&Z&ci&^&ci&d&ci&j&ci&l&ci&n&ci&p&ci&r&ci'j&ci'u&ci'w&ci'z&ci(S&ci(b&ci(o&ci!W&ci&[&ci_&ci&a&ci~O!S1tO~O!V!Za!W!Za~P#ByOl!mO|!nO!U1zO(V!lO!V'OX!W'OX~P?wO!V,yO!W(Za~O!V'UX!W'UX~P!6{O!V,|O!W(ia~O!W2RO~P'WO^%fO#X2[O'l%fO~O^%fO!a#tO#X2[O'l%fO~O^%fO!a#tO!l2`O#X2[O'l%fO(c'fO~O^%fO'l%fO~P!7sO!V$`Oo$ka~O!S&}i!V&}i~P!7sO!V'zO!S(Yi~O!V(RO!S(gi~O!S(hi!V(hi~P!7sO!V(ei!g(ei^(ei'l(ei~P!7sO#X2bO!V(ei!g(ei^(ei'l(ei~O!V(_O!g(di~O|%`O!X%aO!x]O#b2gO#c2fO'u%_O~O|%`O!X%aO#c2fO'u%_O~Og2nO!X'UO%a2mO~Og2nO!X'UO%a2mO(O%QO~O#dvaPvaXva^vakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva'lva(Sva(cva!gva!Sva'jvaova!Xva%ava!ava~P$ aO#d$laP$laX$la^$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la'l$la(S$la(c$la!g$la!S$la'j$lao$la!X$la%a$la!a$la~P$!VO#d$naP$naX$na^$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na'l$na(S$na(c$na!g$na!S$na'j$nao$na!X$na%a$na!a$na~P$!xO#d$|aP$|aX$|a^$|ak$|az$|a!V$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a'l$|a(S$|a(c$|a!g$|a!S$|a'j$|a#X$|ao$|a!X$|a%a$|a!a$|a~P#,`O^#[q!V#[q'l#[q'j#[q!S#[q!g#[qo#[q!X#[q%a#[q!a#[q~P!7sOd'PX!V'PX~P!'oO!V.^Od(]a~O!U2vO!V'QX!g'QX~P%TO!V.aO!g(^a~O!V.aO!g(^a~P!7sO!S2yO~O#y!ja!W!ja~PJqO#y!ba!V!ba!W!ba~P#ByO#y!na!W!na~P!:^O#y!pa!W!pa~P!<wO!X3]O$UfO$_3^O~O!W3bO~Oo3cO~P#,`O^$hq!V$hq'l$hq'j$hq!S$hq!g$hqo$hq!X$hq%a$hq!a$hq~P!7sO!S3dO~P#,`Oy)uO|)vO(k)zOg%Xi(j%Xi!V%Xi#X%Xi~Od%Xi#y%Xi~P$IuOy)uO|)vOg%Zi(j%Zi(k%Zi!V%Zi#X%Zi~Od%Zi#y%Zi~P$JhO(c$YO~P#,`O!U3gO'u%_O!V'[X!g'[X~O!V/UO!g(pa~O!V/UO!a#tO!g(pa~O!V/UO!a#tO(c'fO!g(pa~Od$ui!V$ui#X$ui#y$ui~P!0dO!U3oO'u*WO!S'^X!V'^X~P!1RO!V/^O!S(qa~O!V/^O!S(qa~P#,`O!a#tO#o3wO~Ok3zO!a#tO(c'fO~Od(Qi!V(Qi~P!0dO#X3}Od(Qi!V(Qi~P!0dO!g4QO~O^$iq!V$iq'l$iq'j$iq!S$iq!g$iqo$iq!X$iq%a$iq!a$iq~P!7sO!S4UO~O!V4VO!X(rX~P#,`O!f#vO~P4QO^$sX!X$sX%UYX'l$sX!V$sX~P!/ZO%U4XO^hXghXyhX|hX!XhX'lhX(jhX(khX!VhX~O%U4XO~O%b4`O'u+aO'wTO'zUO!V'gX!W'gX~O!V0aO!W(ya~OX4dO~O]4eO~O^%fO'l%fO~P#,`O!X${O~P#,`O!V4mO#X4oO!W(vX~O!W4pO~Ol!mO|4qO![!wO!]!tO!^!tO!x9qO!|!oO!}!oO#O!oO#P!oO#Q!oO#T4vO#U!xO'v!kO'wTO'zUO(V!lO(b!rO~O!W4uO~P%$gOg4{O!X0yO%a4zO~Og4{O!X0yO%a4zO(O%QO~O'u#lO!V'fX!W'fX~O!V1UO!W(wa~O'wTO'zUO(V5UO~O]5YO~O#o5]O&R5^O~PMaO!g5_O~P%TO^5aO~O^5aO~P%TO_1lO!W5fO&a1kO~P`O!a5hO~O!a5jO!V([i!W([i!a([i!h([i(O([i~O!V#ai!W#ai~P#ByO#X5kO!V#ai!W#ai~O!V!Zi!W!Zi~P#ByO^%fO#X5tO'l%fO~O^%fO!a#tO#X5tO'l%fO~O!V(eq!g(eq^(eq'l(eq~P!7sO!V(_O!g(dq~O|%`O!X%aO#c5{O'u%_O~O!X'UO%a6OO~Og6RO!X'UO%a6OO~O#d%XiP%XiX%Xi^%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi'l%Xi(S%Xi(c%Xi!g%Xi!S%Xi'j%Xio%Xi!X%Xi%a%Xi!a%Xi~P$IuO#d%ZiP%ZiX%Zi^%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi'l%Zi(S%Zi(c%Zi!g%Zi!S%Zi'j%Zio%Zi!X%Zi%a%Zi!a%Zi~P$JhO#d$uiP$uiX$ui^$uik$uiz$ui!V$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui'l$ui(S$ui(c$ui!g$ui!S$ui'j$ui#X$uio$ui!X$ui%a$ui!a$ui~P#,`Od'Pa!V'Pa~P!0dO!V'Qa!g'Qa~P!7sO!V.aO!g(^i~O#y#[i!V#[i!W#[i~P#ByOP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O(SVOX#fik#fi!e#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~O#g#fi~P%2vO#g9yO~P%2vOP$[Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO(SVOX#fi!e#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~Ok#fi~P%5ROk9{O~P%5ROP$[Ok9{Oy#xOz#yO|#zO!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O(SVO#q#fi#s#fi#u#fi#v#fi#y#fi(c#fi(j#fi(k#fi!V#fi!W#fi~OX#fi!e#fi#l#fi#m#fi#n#fi#o#fi~P%7^OX:XO!e9}O#l9}O#m9}O#n:WO#o9}O~P%7^OP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO(SVO#s#fi#u#fi#v#fi#y#fi(c#fi(k#fi!V#fi!W#fi~O(j#fi~P%9xO(j#{O~P%9xOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO(SVO(j#{O#u#fi#v#fi#y#fi(c#fi!V#fi!W#fi~O(k#fi~P%<TO(k#|O~P%<TOP$[OX:XOk9{Oy#xOz#yO|#zO!e9}O!f#vO!h#wO!l$[O#g9yO#h9zO#i9zO#j9zO#k9|O#l9}O#m9}O#n:WO#o9}O#q:OO#s:QO#u:SO(SVO(j#{O(k#|O~O#v#fi#y#fi(c#fi!V#fi!W#fi~P%>`O^#wy!V#wy'l#wy'j#wy!S#wy!g#wyo#wy!X#wy%a#wy!a#wy~P!7sOg;lOy)uO|)vO(j)xO(k)zO~OP#fiX#fik#fiz#fi!e#fi!f#fi!h#fi!l#fi#g#fi#h#fi#i#fi#j#fi#k#fi#l#fi#m#fi#n#fi#o#fi#q#fi#s#fi#u#fi#v#fi#y#fi(S#fi(c#fi!V#fi!W#fi~P%AWO!f#vOP(RXX(RXg(RXk(RXy(RXz(RX|(RX!e(RX!h(RX!l(RX#g(RX#h(RX#i(RX#j(RX#k(RX#l(RX#m(RX#n(RX#o(RX#q(RX#s(RX#u(RX#v(RX#y(RX(S(RX(c(RX(j(RX(k(RX!V(RX!W(RX~O#y#zi!V#zi!W#zi~P#ByO#y!ni!W!ni~P$$gO!W6_O~O!V'Za!W'Za~P#ByO!a#tO(c'fO!V'[a!g'[a~O!V/UO!g(pi~O!V/UO!a#tO!g(pi~Od$uq!V$uq#X$uq#y$uq~P!0dO!S'^a!V'^a~P#,`O!a6fO~O!V/^O!S(qi~P#,`O!V/^O!S(qi~O!S6jO~O!a#tO#o6oO~Ok6pO!a#tO(c'fO~O!S6rO~Od$wq!V$wq#X$wq#y$wq~P!0dO^$iy!V$iy'l$iy'j$iy!S$iy!g$iyo$iy!X$iy%a$iy!a$iy~P!7sO!a5jO~O!V4VO!X(ra~O^#[y!V#[y'l#[y'j#[y!S#[y!g#[yo#[y!X#[y%a#[y!a#[y~P!7sOX6wO~O!V0aO!W(yi~O]6}O~O(V(sO!V'cX!W'cX~O!V4mO!W(va~OikO'u7UO~P.bO!W7XO~P%$gOl!mO|7YO'wTO'zUO(V!lO(b!rO~O!X0yO~O!X0yO%a7[O~Og7_O!X0yO%a7[O~OX7dO!V'fa!W'fa~O!V1UO!W(wi~O!g7hO~O!g7iO~O!g7lO~O!g7lO~P%TO^7nO~O!a7oO~O!g7pO~O!V(hi!W(hi~P#ByO^%fO#X7xO'l%fO~O!V(ey!g(ey^(ey'l(ey~P!7sO!V(_O!g(dy~O!X'UO%a7{O~O#d$uqP$uqX$uq^$uqk$uqz$uq!V$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq'l$uq(S$uq(c$uq!g$uq!S$uq'j$uq#X$uqo$uq!X$uq%a$uq!a$uq~P#,`O#d$wqP$wqX$wq^$wqk$wqz$wq!V$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq'l$wq(S$wq(c$wq!g$wq!S$wq'j$wq#X$wqo$wq!X$wq%a$wq!a$wq~P#,`O!V'Qi!g'Qi~P!7sO#y#[q!V#[q!W#[q~P#ByOy/xOz/xO|/yOPvaXvagvakva!eva!fva!hva!lva#gva#hva#iva#jva#kva#lva#mva#nva#ova#qva#sva#uva#vva#yva(Sva(cva(jva(kva!Vva!Wva~Oy)uO|)vOP$laX$lag$lak$laz$la!e$la!f$la!h$la!l$la#g$la#h$la#i$la#j$la#k$la#l$la#m$la#n$la#o$la#q$la#s$la#u$la#v$la#y$la(S$la(c$la(j$la(k$la!V$la!W$la~Oy)uO|)vOP$naX$nag$nak$naz$na!e$na!f$na!h$na!l$na#g$na#h$na#i$na#j$na#k$na#l$na#m$na#n$na#o$na#q$na#s$na#u$na#v$na#y$na(S$na(c$na(j$na(k$na!V$na!W$na~OP$|aX$|ak$|az$|a!e$|a!f$|a!h$|a!l$|a#g$|a#h$|a#i$|a#j$|a#k$|a#l$|a#m$|a#n$|a#o$|a#q$|a#s$|a#u$|a#v$|a#y$|a(S$|a(c$|a!V$|a!W$|a~P%AWO#y$hq!V$hq!W$hq~P#ByO#y$iq!V$iq!W$iq~P#ByO!W8VO~O#y8WO~P!0dO!a#tO!V'[i!g'[i~O!a#tO(c'fO!V'[i!g'[i~O!V/UO!g(pq~O!S'^i!V'^i~P#,`O!V/^O!S(qq~O!S8^O~P#,`O!S8^O~Od(Qy!V(Qy~P!0dO!V'aa!X'aa~P#,`O^%Tq!X%Tq'l%Tq!V%Tq~P#,`OX8cO~O!V0aO!W(yq~O#X8gO!V'ca!W'ca~O!V4mO!W(vi~P#ByOPYXXYXkYXyYXzYX|YX!SYX!VYX!eYX!fYX!hYX!lYX#XYX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX~O!a%RX#o%RX~P&2WO!X0yO%a8kO~O'wTO'zUO(V8pO~O!V1UO!W(wq~O!g8sO~O!g8tO~O!g8uO~O!g8uO~P%TO#X8xO!V#ay!W#ay~O!V#ay!W#ay~P#ByO!X'UO%a8}O~O#y#wy!V#wy!W#wy~P#ByOP$uiX$uik$uiz$ui!e$ui!f$ui!h$ui!l$ui#g$ui#h$ui#i$ui#j$ui#k$ui#l$ui#m$ui#n$ui#o$ui#q$ui#s$ui#u$ui#v$ui#y$ui(S$ui(c$ui!V$ui!W$ui~P%AWOy)uO|)vO(k)zOP%XiX%Xig%Xik%Xiz%Xi!e%Xi!f%Xi!h%Xi!l%Xi#g%Xi#h%Xi#i%Xi#j%Xi#k%Xi#l%Xi#m%Xi#n%Xi#o%Xi#q%Xi#s%Xi#u%Xi#v%Xi#y%Xi(S%Xi(c%Xi(j%Xi!V%Xi!W%Xi~Oy)uO|)vOP%ZiX%Zig%Zik%Ziz%Zi!e%Zi!f%Zi!h%Zi!l%Zi#g%Zi#h%Zi#i%Zi#j%Zi#k%Zi#l%Zi#m%Zi#n%Zi#o%Zi#q%Zi#s%Zi#u%Zi#v%Zi#y%Zi(S%Zi(c%Zi(j%Zi(k%Zi!V%Zi!W%Zi~O#y$iy!V$iy!W$iy~P#ByO#y#[y!V#[y!W#[y~P#ByO!a#tO!V'[q!g'[q~O!V/UO!g(py~O!S'^q!V'^q~P#,`O!S9UO~P#,`O!V0aO!W(yy~O!V4mO!W(vq~O!X0yO%a9]O~O!g9`O~O!X'UO%a9eO~OP$uqX$uqk$uqz$uq!e$uq!f$uq!h$uq!l$uq#g$uq#h$uq#i$uq#j$uq#k$uq#l$uq#m$uq#n$uq#o$uq#q$uq#s$uq#u$uq#v$uq#y$uq(S$uq(c$uq!V$uq!W$uq~P%AWOP$wqX$wqk$wqz$wq!e$wq!f$wq!h$wq!l$wq#g$wq#h$wq#i$wq#j$wq#k$wq#l$wq#m$wq#n$wq#o$wq#q$wq#s$wq#u$wq#v$wq#y$wq(S$wq(c$wq!V$wq!W$wq~P%AWOd%]!Z!V%]!Z#X%]!Z#y%]!Z~P!0dO!V'cq!W'cq~P#ByO!V#a!Z!W#a!Z~P#ByO#d%]!ZP%]!ZX%]!Z^%]!Zk%]!Zz%]!Z!V%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z'l%]!Z(S%]!Z(c%]!Z!g%]!Z!S%]!Z'j%]!Z#X%]!Zo%]!Z!X%]!Z%a%]!Z!a%]!Z~P#,`OP%]!ZX%]!Zk%]!Zz%]!Z!e%]!Z!f%]!Z!h%]!Z!l%]!Z#g%]!Z#h%]!Z#i%]!Z#j%]!Z#k%]!Z#l%]!Z#m%]!Z#n%]!Z#o%]!Z#q%]!Z#s%]!Z#u%]!Z#v%]!Z#y%]!Z(S%]!Z(c%]!Z!V%]!Z!W%]!Z~P%AWOo(WX~P1jO'v!kO~P!){O!ScX!VcX#XcX~P&2WOPYXXYXkYXyYXzYX|YX!VYX!VcX!eYX!fYX!hYX!lYX#XYX#XcX#dcX#gYX#hYX#iYX#jYX#kYX#lYX#mYX#nYX#oYX#qYX#sYX#uYX#vYX#{YX(SYX(cYX(jYX(kYX~O!acX!gYX!gcX(ccX~P&GnOP9pOQ9pOa;aOb!hOikOk9pOlkOmkOskOu9pOw9pO|WO!QkO!RkO!XXO!c9sO!hZO!k9pO!l9pO!m9pO!o9tO!q9wO!t!gO$Q!jO$UfO'u)TO'wTO'zUO(SVO(b[O(o;_O~O!V:UO!W$ka~Oi%ROk$sOl$rOm$rOs%SOu%TOw:[O|$zO!X${O!c;fO!h$wO#c:bO$Q%XO$m:^O$o:`O$r%YO'u(kO'wTO'zUO(O%QO(S$tO~O#p)[O~P&LdO!WYX!WcX~P&GnO#d9xO~O!a#tO#d9xO~O#X:YO~O#o9}O~O#X:dO!V(hX!W(hX~O#X:YO!V(fX!W(fX~O#d:eO~Od:gO~P!0dO#d:lO~O#d:mO~O!a#tO#d:nO~O!a#tO#d:eO~O#y:oO~P#ByO#d:pO~O#d:qO~O#d:rO~O#d:sO~O#d:tO~O#d:uO~O#y:vO~P!0dO#y:wO~P!0dO$U~!f!|!}#P#Q#T#b#c#n(o$m$o$r%U%`%a%b%i%k%n%o%q%s~'pR$U(o#h!R'n'v#il#g#jky'o(V'o'u$W$Y$W~",
  goto: "$&a(}PPPP)OP)RP)cP*r.uPPPP5UPP5kP;f>mP?QP?QPPP?QP@rP?QP?QP?QP@vPP@{PAfPF]PPPFaPPPPFaIaPPPIgJbPFaPLoPPPPN}FaPPPFaPFaP!#]FaP!&p!'r!'{P!(n!(r!(nPPPPP!+|!'rPP!,j!-dP!0WFaFa!0]!3f!7z!7z!;oPPP!;vFaPPPPPPPPPPP!?SP!@ePPFa!ArPFaPFaFaFaFaPFa!CUPP!F]P!I`P!Id!In!Ir!IrP!FYP!Iv!IvP!LyP!L}FaFa!MT#!V?QP?QP?Q?QP##a?Q?Q#%]?Q#'l?Q#)b?Q?Q#*O#+|#+|#,Q#,Y#+|#,bP#+|P?Q#,z?Q#.T?Q?Q5UPPP#/aPPP#/y#/yP#/yP#0`#/yPP#0fP#0]P#0]#0x#0]#1d#1j5R)R#1m)RP#1t#1t#1tP)RP)RP)RP)RPP)RP#1z#1}P#1})RP#2RP#2UP)RP)RP)RP)RP)RP)R)RPP#2[#2b#2l#2r#2x#3O#3U#3d#3j#3p#3z#4Q#4[#4k#4q#5b#5t#5z#6Q#6`#6u#8W#8f#8l#8r#8x#9O#9Y#9`#9f#9p#:S#:YPPPPPPPPPP#:`PPPPPPP#;S#>ZP#?j#?q#?yPPPP#DX#F}#Me#Mh#Mk#Nd#Ng#Nj#Nq#NyPP$ P$ T$ {$!z$#O$#dPP$#h$#n$#rP$#u$#y$#|$$r$%Y$%p$%t$%w$%z$&Q$&T$&X$&]R!zRmqOXs!Y#b%e&h&j&k&m,a,f1f1iY!tQ'U-R0y4tQ%kuQ%sxQ%z{Q&`!US&|!d,yQ'[!hS'b!q!wS*^${*cQ+_%tQ+l%|Q,Q&YQ-P'TQ-Z']Q-c'cQ/o*eQ1T,RR:c9t$|dOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{,^,a,f-V-_-m-s.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2v4q4{5]5^5a5t7Y7_7n7xS#o]9q!r)V$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ*n%UQ+d%vQ,S&]Q,Z&eQ.W:ZQ0V+VQ0Z+XQ0f+eQ1],XQ2j.TQ4_0aQ5S1UQ6Q2nQ6W:[Q6y4`R8O6R&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bt!mQ!q!t!w!x&|'T'U'b'c'd,y-P-R-c0y4t4v$^$ri#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lQ%}{Q&z!dS'Q%a,|Q+d%vQ/z*rQ0f+eQ0k+kQ1[,WQ1],XQ4_0aQ4h0mQ5V1WQ5W1ZQ6y4`Q6|4eQ7g5YQ8f6}R8q7dpnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iR,U&a&t^OPXYstuvy!Y!_!f!i!n#Q#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y'W'h'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;a;b[#ZWZ#U#X&}'x!S%bm#f#g#j%]%`(R(](^(_*y*z*|,],s-q-w-x-y-{1n2f2g5j5{Q%nwQ%rxS%w{%|Q&T!SQ'X!gQ'Z!hQ(f#qS*Q$w*US+^%s%tQ+b%vQ+{&WQ,P&YS-Y'[']Q.V(gQ/Y*RQ0_+_Q0e+eQ0g+fQ0j+jQ1O+|S1S,Q,RQ2W-ZQ3f/UQ4^0aQ4b0dQ4g0lQ5R1TQ6c3gQ6x4`Q6{4dQ8b6wR9W8cv$yi#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h!S%px!h!s%r%s%t&{'Z'[']'a'k*]+^+_,v-Y-Z-b/g0_2P2W2_3yQ+W%nQ+q&QQ+t&RQ,O&YQ.U(fQ0}+{U1R,P,Q,RQ2o.VQ4|1OS5Q1S1TQ7c5R#O;c#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lg;d:W:X:^:`:b:i:k:m:q:s:wW%Oi%Q*k;_S&Q!P&_Q&R!QQ&S!RR+o&O$_$}i#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lT)q$t)rV*o%U:Z:[U'Q!d%a,|S(t#x#yQ+i%yS.O(b(cQ0t+uQ4O/xR7R4m&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;b$i$_c#W#c%i%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.i.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;UT#RV#S&{kOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ'O!dR1{,yv!mQ!d!q!t!w!x&|'T'U'b'c'd,y-P-R-c0y4t4vS*]${*cS/g*^*eQ/p*fQ0v+wQ3y/oR3|/rlqOXs!Y#b%e&h&j&k&m,a,f1f1iQ&o!]Q'l!vS(h#s9xQ+[%qQ+y&TQ+z&VQ-W'YQ-e'eS.[(m:eS/}*w:nQ0]+]Q0x+xQ1m,hQ1o,iQ1w,tQ2U-XQ2X-]S4T0O:tQ4Y0^S4]0`:uQ5l1yQ5p2VQ5u2^Q6v4ZQ7s5nQ7t5qQ7w5vR8w7p$d$^c#W#c%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;US(e#n'_U*h$|(l3YS+R%i.iQ2k0VQ5}2jQ7}6QR9O8O$d$]c#W#c%j%l'w'}(i(p(x(y(z({(|(})O)P)Q)R)S)U)X)])g+S+h,w-f-k-p-r.].c.g.j.k.z/|1u1x2Y2a2u2z2{2|2}3O3P3Q3R3S3T3U3V3W3Z3[3a4S4[5m5s5x6U6V6[6]7T7r7v8P8T8U8z9Y9a9r;US(d#n'_S(v#y$^S+Q%i.iS.P(c(eQ.l)WQ0S+RR2h.Q&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bS#o]9qQ&j!WQ&k!XQ&m!ZQ&n![R1e,dQ'V!gQ+T%nQ-U'XS.R(f+WQ2S-TW2l.U.V0U0WQ5o2TU5|2i2k2oS7z5}6PS8|7|7}S9c8{9OQ9k9dR9n9lU!uQ'U-RT4r0y4t!O_OXZ`s!U!Y#b#f%]%e&_&a&h&j&k&m(_,a,f-x1f1i]!oQ!q'U-R0y4tT#o]9q%WzOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xS(t#x#yS.O(b(c!s:{$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bY!sQ'U-R0y4tQ'a!qS'k!t!wS'm!x4vS-b'b'cQ-d'dR2_-cQ'j!sS(Z#e1`S-a'a'mQ/X*QQ/e*]Q2`-dQ3k/YS3t/f/pQ6b3fS6m3z3|Q8Y6cR8a6pQ#ubQ'i!sS(Y#e1`S([#k*vQ*x%^Q+Y%oQ+`%uU-`'a'j'mQ-t(ZQ/W*QQ/d*]Q/j*`Q0[+ZQ1P+}S2]-a-dQ2e-|S3j/X/YS3s/e/pQ3v/iQ3x/kQ5O1QQ5w2`Q6a3fQ6e3kS6i3t3|Q6n3{Q7a5PS8X6b6cQ8]6jQ8_6mQ8n7bQ9S8YQ9T8^Q9V8aQ9_8oQ9g9UQ;O:yQ;Z;SR;[;TV!uQ'U-R%WaOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xS#uy!i!r:x$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bR;O;a%WbOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xQ%^j!S%ox!h!s%r%s%t&{'Z'[']'a'k*]+^+_,v-Y-Z-b/g0_2P2W2_3yS%uy!iQ+Z%pQ+}&YW1Q,O,P,Q,RU5P1R1S1TS7b5Q5RQ8o7c!r:y$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ;S;`R;T;a$zeOPXYstuv!Y!_!f!n#Q#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7xY#`WZ#U#X'x!S%bm#f#g#j%]%`(R(](^(_*y*z*|,],s-q-w-x-y-{1n2f2g5j5{Q,[&e!p:z$Z$l)i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bR:}&}S'R!d%aR1},|$|dOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{,^,a,f-V-_-m-s.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2v4q4{5]5^5a5t7Y7_7n7x!r)V$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bQ,Z&eQ0V+VQ2j.TQ6Q2nR8O6R!f$Tc#W%i'w'}(i(p)P)Q)R)S)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9r!T:P)U)g,w.i1u1x2z3S3T3U3V3Z3a5m6V6[6]7T7r8P8T8U9Y9a;U!b$Vc#W%i'w'}(i(p)R)S)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9r!P:R)U)g,w.i1u1x2z3U3V3Z3a5m6V6[6]7T7r8P8T8U9Y9a;U!^$Zc#W%i'w'}(i(p)X)]+h-f-k-p-r.].c.z/|2Y2a2u3W4S4[5s5x6U7v8z9rQ3e/Sz;b)U)g,w.i1u1x2z3Z3a5m6V6[6]7T7r8P8T8U9Y9a;UQ;g;iR;h;j&zkOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bS$mh$nR3^.o'RgOPWXYZhstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l$n%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.o.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bT$if$oQ$gfS)`$j)dR)l$oT$hf$oT)b$j)d'RhOPWXYZhstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$Z$`$d$l$n%e%k%x&a&d&e&h&j&k&m&q&y&}'W'h'x'z(Q(X(m(q(u)i)t*w*{+V,^,a,f,r,u-V-_-m-s.T.a.h.o.p/y0O0`0|1^1_1a1c1f1i1k1z2[2b2n2v3]4o4q4{5]5^5a5k5t6R7Y7_7n7x8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;bT$mh$nQ$phR)k$n%WjOPWXYZstuv!Y!_!f!n#Q#U#X#b#m#s#w#z#}$O$P$Q$R$S$T$U$V$W$X$`$d%e%k%x&a&d&e&h&j&k&m&q&y'W'h'x'z(Q(X(m(q(u)t*w*{+V,^,a,f-V-_-m-s.T.a.h/y0O0`0|1^1_1a1c1f1i1k2[2b2n2v4q4{5]5^5a5t6R7Y7_7n7x!s;`$Z$l&})i,r,u.p1z3]4o5k8g8x9p9s9t9w9x9y9z9{9|9}:O:P:Q:R:S:T:U:Y:c:d:e:g:n:o:t:u;b#alOPXZs!Y!_!n#Q#b#m#z$l%e&a&d&e&h&j&k&m&q&y'W(u)i*{+V,^,a,f-V.T.p/y0|1^1_1a1c1f1i1k2n3]4q4{5]5^5a6R7Y7_7nv$|i#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h#O(l#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lQ*s%YQ.{)ug3Y:W:X:^:`:b:i:k:m:q:s:wv$xi#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;hQ*V$yS*`${*cQ*t%ZQ/k*a#O;Q#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lf;R:W:X:^:`:b:i:k:m:q:s:wQ;V;cQ;W;dQ;X;eR;Y;fv$|i#v%V%W%[)y){*T*i*j.^/]/{3e3}8W;_;g;h#O(l#t$b$c$w$z)p)v)|*Z+U+X+p+s.S/O/^/`0p0s0{2m3o3w4V4X4z6O6f6o7[7{8k8}9]9e:]:_:a:h:j:l:p:r:v;k;lg3Y:W:X:^:`:b:i:k:m:q:s:wloOXs!Y#b%e&h&j&k&m,a,f1f1iQ*Y$zQ,o&tQ,p&vR3n/^$^$}i#t#v$b$c$w$z%V%W%[)p)v)y){)|*T*Z*i*j+U+X+p+s.S.^/O/]/^/`/{0p0s0{2m3e3o3w3}4V4X4z6O6f6o7[7{8W8k8}9]9e:W:X:]:^:_:`:a:b:h:i:j:k:l:m:p:q:r:s:v:w;_;g;h;k;lQ+r&RQ0r+tQ4k0qR7Q4lT*b${*cS*b${*cT4s0y4tS/i*_4qT3{/q7YQ+Y%oQ/j*`Q0[+ZQ1P+}Q5O1QQ7a5PQ8n7bR9_8on)y$u(n*u/[/s/t2s3l4R6`6q9R;P;];^!Y:h(j)Z*P*X.Z.w.|/S/a0T0o0q2r3m3q4j4l6S6T6g6k6s6u8[8`9f;i;j]:i3X6Z8Q9P9Q9op){$u(n*u/Q/[/s/t2s3l4R6`6q9R;P;];^![:j(j)Z*P*X.Z.w.|/S/a0T0o0q2p2r3m3q4j4l6S6T6g6k6s6u8[8`9f;i;j_:k3X6Z8Q8R9P9Q9opnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iQ&[!TR,^&epnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iR&[!TQ+v&SR0n+oqnOXs!U!Y#b%e&_&h&j&k&m,a,f1f1iQ0z+{S4y0}1OU7Z4w4x4|S8j7]7^S9Z8i8lQ9h9[R9m9iQ&c!UR,V&_R5V1WS%w{%|R0g+fQ&h!VR,a&iR,g&nT1g,f1iR,k&oQ,j&oR1p,kQ'o!yR-g'oQsOQ#bXT%hs#bQ!|TR'q!|Q#PUR's#PQ)r$tR.x)rQ#SVR'u#SQ#VWU'{#V'|-nQ'|#WR-n'}Q,z'OR1|,zQ._(nR2t._Q.b(pS2w.b2xR2x.cQ-R'UR2Q-RY!qQ'U-R0y4tR'`!qS#]W%`U(S#](T-oQ(T#^R-o(OQ,}'RR2O,}r`OXs!U!Y#b%e&_&a&h&j&k&m,a,f1f1iS#fZ%]U#p`#f-xR-x(_Q(`#hQ-u([W-}(`-u2c5yQ2c-vR5y2dQ)d$jR.q)dQ$nhR)j$nQ$acU)Y$a-j:VQ-j9rR:V)gQ/V*QW3h/V3i6d8ZU3i/W/X/YS6d3j3kR8Z6e#o)w$u(j(n)Z*P*X*p*q*u.X.Y.Z.w.|/Q/R/S/[/a/s/t0T0o0q2p2q2r2s3X3l3m3q4R4j4l6S6T6X6Y6Z6`6g6k6q6s6u8Q8R8S8[8`9P9Q9R9f9o;P;];^;i;jQ/_*XU3p/_3r6hQ3r/aR6h3qQ*c${R/m*cQ*l%PR/v*lQ4W0TR6t4WQ*}%cR0R*}Q4n0tS7S4n8hR8h7TQ+x&TR0w+xQ4t0yR7W4tQ1V,SS5T1V7eR7e5VQ0b+bW4a0b4c6z8dQ4c0eQ6z4bR8d6{Q+g%wR0h+gQ1i,fR5e1iWrOXs#bQ&l!YQ+P%eQ,`&hQ,b&jQ,c&kQ,e&mQ1d,aS1g,f1iR5d1fQ%gpQ&p!^Q&s!`Q&u!aQ&w!bQ'g!sQ+O%dQ+[%qQ+n%}Q,U&cQ,m&rW-^'a'i'j'mQ-e'eQ/l*bQ0]+]S1Y,V,YQ1q,lQ1r,oQ1s,pQ2X-]W2Z-`-a-d-fQ4Y0^Q4f0kQ4i0oQ4}1PQ5X1[Q5c1eU5r2Y2]2`Q5u2^Q6v4ZQ7O4hQ7P4jQ7V4sQ7`5OQ7f5WS7u5s5wQ7w5vQ8e6|Q8m7aQ8r7gQ8y7vQ9X8fQ9^8nQ9b8zR9j9_Q%qxQ'Y!hQ'e!sU+]%r%s%tQ,t&{U-X'Z'[']S-]'a'kQ/c*]S0^+^+_Q1y,vS2V-Y-ZQ2^-bQ3u/gQ4Z0_Q5n2PQ5q2WQ5v2_R6l3yS$vi;_R*m%QU%Pi%Q;_R/u*kQ$uiS(j#t+XQ(n#vS)Z$b$cQ*P$wQ*X$zQ*p%VQ*q%WQ*u%[Q.X:]Q.Y:_Q.Z:aQ.w)pS.|)v/OQ/Q)yQ/R){Q/S)|Q/[*TQ/a*ZQ/s*iQ/t*jh0T+U.S0{2m4z6O7[7{8k8}9]9eQ0o+pQ0q+sQ2p:hQ2q:jQ2r:lQ2s.^S3X:W:XQ3l/]Q3m/^Q3q/`Q4R/{Q4j0pQ4l0sQ6S:pQ6T:rQ6X:^Q6Y:`Q6Z:bQ6`3eQ6g3oQ6k3wQ6q3}Q6s4VQ6u4XQ8Q:mQ8R:iQ8S:kQ8[6fQ8`6oQ9P:qQ9Q:sQ9R8WQ9f:vQ9o:wQ;P;_Q;];gQ;^;hQ;i;kR;j;llpOXs!Y#b%e&h&j&k&m,a,f1f1iQ!ePS#dZ#mQ&r!_U'^!n4q7YQ't#QQ(w#zQ)h$lS,Y&a&dQ,_&eQ,l&qQ,q&yQ-T'WQ.e(uQ.u)iQ0P*{Q0W+VQ1b,^Q2T-VQ2k.TQ3`.pQ4P/yQ4x0|Q5Z1^Q5[1_Q5`1aQ5b1cQ5g1kQ5}2nQ6^3]Q7^4{Q7j5]Q7k5^Q7m5aQ7}6RQ8l7_R8v7n#UcOPXZs!Y!_!n#b#m#z%e&a&d&e&h&j&k&m&q&y'W(u*{+V,^,a,f-V.T/y0|1^1_1a1c1f1i1k2n4q4{5]5^5a6R7Y7_7nQ#WWQ#cYQ%itQ%juS%lv!fS'w#U'zQ'}#XQ(i#sQ(p#wQ(x#}Q(y$OQ(z$PQ({$QQ(|$RQ(}$SQ)O$TQ)P$UQ)Q$VQ)R$WQ)S$XQ)U$ZQ)X$`Q)]$dW)g$l)i.p3]Q+S%kQ+h%xS,w&}1zQ-f'hS-k'x-mQ-p(QQ-r(XQ.](mQ.c(qQ.g9pQ.i9sQ.j9tQ.k9wQ.z)tQ/|*wQ1u,rQ1x,uQ2Y-_Q2a-sQ2u.aQ2z9xQ2{9yQ2|9zQ2}9{Q3O9|Q3P9}Q3Q:OQ3R:PQ3S:QQ3T:RQ3U:SQ3V:TQ3W.hQ3Z:YQ3[:cQ3a:UQ4S0OQ4[0`Q5m:dQ5s2[Q5x2bQ6U2vQ6V:eQ6[:gQ6]:nQ7T4oQ7r5kQ7v5tQ8P:oQ8T:tQ8U:uQ8z7xQ9Y8gQ9a8xQ9r#QR;U;bR#YWR'P!dY!sQ'U-R0y4tS&{!d,yQ'a!qS'k!t!wS'm!x4vS,v&|'TS-b'b'cQ-d'dQ2P-PR2_-cR(o#vR(r#wQ!eQT-Q'U-R]!pQ!q'U-R0y4tQ#n]R'_9qT#iZ%]S#hZ%]S%cm,]U([#f#g#jS-v(](^Q-z(_Q0Q*|Q2d-wU2e-x-y-{S5z2f2gR7y5{`#[W#U#X%`'x(R*y-qr#eZm#f#g#j%](](^(_*|-w-x-y-{2f2g5{Q1`,]Q1v,sQ5i1nQ7q5jT:|&}*zT#_W%`S#^W%`S'y#U(RS(O#X*yS,x&}*zT-l'x-qT'S!d%aQ$jfR)n$oT)c$j)dR3_.oT*S$w*UR*[$zQ0U+UQ2i.SQ4w0{Q6P2mQ7]4zQ7|6OQ8i7[Q8{7{Q9[8kQ9d8}Q9i9]R9l9elqOXs!Y#b%e&h&j&k&m,a,f1f1iQ&b!UR,U&_rmOXs!T!U!Y#b%e&_&h&j&k&m,a,f1f1iR,]&eT%dm,]R0u+uR,T&]Q%{{R+m%|R+c%vT&f!V&iT&g!V&iT1h,f1i",
  nodeNames: " ArithOp ArithOp LineComment BlockComment Script ExportDeclaration export Star as VariableName String Escape from ; default FunctionDeclaration async function VariableDefinition > TypeParamList TypeDefinition extends ThisType this LiteralType ArithOp Number BooleanLiteral TemplateType InterpolationEnd Interpolation InterpolationStart NullType null VoidType void TypeofType typeof MemberExpression . ?. PropertyName [ TemplateString Escape Interpolation super RegExp ] ArrayExpression Spread , } { ObjectExpression Property async get set PropertyDefinition Block : NewExpression new TypeArgList CompareOp < ) ( ArgList UnaryExpression delete LogicOp BitOp YieldExpression yield AwaitExpression await ParenthesizedExpression ClassExpression class ClassBody MethodDeclaration Decorator @ MemberExpression PrivatePropertyName CallExpression declare Privacy static abstract override PrivatePropertyDefinition PropertyDeclaration readonly accessor Optional TypeAnnotation Equals StaticBlock FunctionExpression ArrowFunction ParamList ParamList ArrayPattern ObjectPattern PatternProperty Privacy readonly Arrow MemberExpression BinaryExpression ArithOp ArithOp ArithOp ArithOp BitOp CompareOp instanceof satisfies in const CompareOp BitOp BitOp BitOp LogicOp LogicOp ConditionalExpression LogicOp LogicOp AssignmentExpression UpdateOp PostfixExpression CallExpression TaggedTemplateExpression DynamicImport import ImportMeta JSXElement JSXSelfCloseEndTag JSXStartTag JSXSelfClosingTag JSXIdentifier JSXBuiltin JSXIdentifier JSXNamespacedName JSXMemberExpression JSXSpreadAttribute JSXAttribute JSXAttributeValue JSXEscape JSXEndTag JSXOpenTag JSXFragmentTag JSXText JSXEscape JSXStartCloseTag JSXCloseTag PrefixCast ArrowFunction TypeParamList SequenceExpression KeyofType keyof UniqueType unique ImportType InferredType infer TypeName ParenthesizedType FunctionSignature ParamList NewSignature IndexedType TupleType Label ArrayType ReadonlyType ObjectType MethodType PropertyType IndexSignature PropertyDefinition CallSignature TypePredicate is NewSignature new UnionType LogicOp IntersectionType LogicOp ConditionalType ParameterizedType ClassDeclaration abstract implements type VariableDeclaration let var using TypeAliasDeclaration InterfaceDeclaration interface EnumDeclaration enum EnumBody NamespaceDeclaration namespace module AmbientDeclaration declare GlobalDeclaration global ClassDeclaration ClassBody AmbientFunctionDeclaration ExportGroup VariableName VariableName ImportDeclaration ImportGroup ForStatement for ForSpec ForInSpec ForOfSpec of WhileStatement while WithStatement with DoStatement do IfStatement if else SwitchStatement switch SwitchBody CaseLabel case DefaultLabel TryStatement try CatchClause catch FinallyClause finally ReturnStatement return ThrowStatement throw BreakStatement break ContinueStatement continue DebuggerStatement debugger LabeledStatement ExpressionStatement SingleExpression SingleClassItem",
  maxTerm: 366,
  context: hMe,
  nodeProps: [
    ["group", -26, 6, 14, 16, 62, 199, 203, 207, 208, 210, 213, 216, 226, 228, 234, 236, 238, 240, 243, 249, 255, 257, 259, 261, 263, 265, 266, "Statement", -32, 10, 11, 25, 28, 29, 35, 45, 48, 49, 51, 56, 64, 72, 76, 78, 80, 81, 103, 104, 113, 114, 131, 134, 136, 137, 138, 139, 141, 142, 162, 163, 165, "Expression", -23, 24, 26, 30, 34, 36, 38, 166, 168, 170, 171, 173, 174, 175, 177, 178, 179, 181, 182, 183, 193, 195, 197, 198, "Type", -3, 84, 96, 102, "ClassItem"],
    ["openedBy", 31, "InterpolationStart", 50, "[", 54, "{", 69, "(", 143, "JSXStartTag", 155, "JSXStartTag JSXStartCloseTag"],
    ["closedBy", 33, "InterpolationEnd", 44, "]", 55, "}", 70, ")", 144, "JSXSelfCloseEndTag JSXEndTag", 160, "JSXEndTag"]
  ],
  propSources: [gMe],
  skippedNodes: [0, 3, 4, 269],
  repeatNodeCount: 33,
  tokenData: "$>y(CSR!bOX%ZXY+gYZ-yZ[+g[]%Z]^.c^p%Zpq+gqr/mrs3cst:_tu>PuvBavwDxwxGgxyMvyz! Qz{!![{|!%O|}!&]}!O!%O!O!P!'g!P!Q!1w!Q!R#0t!R![#3T![!]#@T!]!^#Aa!^!_#Bk!_!`#GS!`!a#In!a!b#N{!b!c$$z!c!}>P!}#O$&U#O#P$'`#P#Q$,w#Q#R$.R#R#S>P#S#T$/`#T#o$0j#o#p$4z#p#q$5p#q#r$7Q#r#s$8^#s$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$I|>P$I|$I}$<s$I}$JO$<s$JO$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(n%d_$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&j&hT$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c&j&zP;=`<%l&c'|'U]$d&j'{!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!b(SU'{!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}!b(iP;=`<%l'}'|(oP;=`<%l&}'[(y]$d&j'xpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rp)wU'xpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)rp*^P;=`<%l)r'[*dP;=`<%l(r#S*nX'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g#S+^P;=`<%l*g(n+dP;=`<%l%Z(CS+rq$d&j'xp'{!b'n(;dOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p$f%Z$f$g+g$g#BY%Z#BY#BZ+g#BZ$IS%Z$IS$I_+g$I_$JT%Z$JT$JU+g$JU$KV%Z$KV$KW+g$KW&FU%Z&FU&FV+g&FV;'S%Z;'S;=`+a<%l?HT%Z?HT?HU+g?HUO%Z(CS.ST'y#S$d&j'o(;dO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c(CS.n_$d&j'xp'{!b'o(;dOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#`/x`$d&j!l$Ip'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S1V`#q$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`2X!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S2d_#q$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2b3l_'w$(n$d&j'{!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k*r4r_$d&j'{!bOY4kYZ5qZr4krs7nsw4kwx5qx!^4k!^!_8p!_#O4k#O#P5q#P#o4k#o#p8p#p;'S4k;'S;=`:X<%lO4k)`5vX$d&jOr5qrs6cs!^5q!^!_6y!_#o5q#o#p6y#p;'S5q;'S;=`7h<%lO5q)`6jT$_#t$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#t6|TOr6yrs7]s;'S6y;'S;=`7b<%lO6y#t7bO$_#t#t7eP;=`<%l6y)`7kP;=`<%l5q*r7w]$_#t$d&j'{!bOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}%W8uZ'{!bOY8pYZ6yZr8prs9hsw8pwx6yx#O8p#O#P6y#P;'S8p;'S;=`:R<%lO8p%W9oU$_#t'{!bOY'}Zw'}x#O'}#P;'S'};'S;=`(f<%lO'}%W:UP;=`<%l8p*r:[P;=`<%l4k#%|:hg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|<[i$d&j(b!L^'xp'{!bOY%ZYZ&cZr%Zrs&}st%Ztu<Puw%Zwx(rx!Q%Z!Q![<P![!^%Z!^!_*g!_!c%Z!c!}<P!}#O%Z#O#P&c#P#R%Z#R#S<P#S#T%Z#T#o<P#o#p*g#p$g%Z$g;'S<P;'S;=`=y<%lO<P#%|=|P;=`<%l<P(CS>`k$d&j'xp'{!b(V!LY'u&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P+d@`k$d&j'xp'{!b$W#tOY%ZYZ&cZr%Zrs&}st%Ztu@Tuw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![@T![!^%Z!^!_*g!_!c%Z!c!}@T!}#O%Z#O#P&c#P#R%Z#R#S@T#S#T%Z#T#o@T#o#p*g#p$g%Z$g;'S@T;'S;=`BT<%lO@T+dBWP;=`<%l@T(CSB^P;=`<%l>P%#SBl`$d&j'xp'{!b#i$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SCy_$d&j#{$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%DfETa(k%<v$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sv%ZvwFYwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#SFe`$d&j#u$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$2bGp_'z$)`$d&j'xpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo*QHv_$d&j'xpOYHoYZIuZrHorsIuswHowxKVx!^Ho!^!_LX!_#OHo#O#PIu#P#oHo#o#pLX#p;'SHo;'S;=`Mp<%lOHo)`IzX$d&jOwIuwx6cx!^Iu!^!_Jg!_#oIu#o#pJg#p;'SIu;'S;=`KP<%lOIu#tJjTOwJgwx7]x;'SJg;'S;=`Jy<%lOJg#tJ|P;=`<%lJg)`KSP;=`<%lIu*QK`]$_#t$d&j'xpOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(r$fL^Z'xpOYLXYZJgZrLXrsJgswLXwxMPx#OLX#O#PJg#P;'SLX;'S;=`Mj<%lOLX$fMWU$_#t'xpOY)rZr)rs#O)r#P;'S)r;'S;=`*Z<%lO)r$fMmP;=`<%lLX*QMsP;=`<%lHo(*QNR_!h(!b$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'l! ]_!gM|$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h!!ib$d&j'xp'{!b'v#)d#j$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rxz%Zz{!#q{!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S!#|`$d&j'xp'{!b#g$IdOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&-O!%Z`$d&j'xp'{!bk&%`OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&C[!&h_!V&;l$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!'rc$d&j'xp'{!by'<nOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!(}!P!Q%Z!Q![!+g![!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!)Wa$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!*]!P!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z!'d!*h_!UMt$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!+rg$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!+g![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S!+g#S#X%Z#X#Y!-Z#Y#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!-dg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx{%Z{|!.{|}%Z}!O!.{!O!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!/Uc$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l!0lc$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![!0a![!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S!0a#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS!2Sf$d&j'xp'{!b#h$IdOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}xz!3hz{#$s{!P!3h!P!Q#&Y!Q!^!3h!^!_!Mh!_!`#-x!`!a#/_!a!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(r!3sb$d&j'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(Q!5U`$d&j'{!b!RSOY!4{YZ&cZw!4{wx!6Wx!P!4{!P!Q!=o!Q!^!4{!^!_!?g!_!}!4{!}#O!Bn#O#P!<w#P#o!4{#o#p!?g#p;'S!4{;'S;=`!Cw<%lO!4{&n!6_^$d&j!RSOY!6WYZ&cZ!P!6W!P!Q!7Z!Q!^!6W!^!_!8g!_!}!6W!}#O!;U#O#P!<w#P#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!7ba$d&j!RSO!^&c!_#Z&c#Z#[!7Z#[#]&c#]#^!7Z#^#a&c#a#b!7Z#b#g&c#g#h!7Z#h#i&c#i#j!7Z#j#m&c#m#n!7Z#n#o&c#p;'S&c;'S;=`&w<%lO&cS!8lX!RSOY!8gZ!P!8g!P!Q!9X!Q!}!8g!}#O!9p#O#P!:o#P;'S!8g;'S;=`!;O<%lO!8gS!9^U!RS#Z#[!9X#]#^!9X#a#b!9X#g#h!9X#i#j!9X#m#n!9XS!9sVOY!9pZ#O!9p#O#P!:Y#P#Q!8g#Q;'S!9p;'S;=`!:i<%lO!9pS!:]SOY!9pZ;'S!9p;'S;=`!:i<%lO!9pS!:lP;=`<%l!9pS!:rSOY!8gZ;'S!8g;'S;=`!;O<%lO!8gS!;RP;=`<%l!8g&n!;Z[$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#O!;U#O#P!<P#P#Q!6W#Q#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<UX$d&jOY!;UYZ&cZ!^!;U!^!_!9p!_#o!;U#o#p!9p#p;'S!;U;'S;=`!<q<%lO!;U&n!<tP;=`<%l!;U&n!<|X$d&jOY!6WYZ&cZ!^!6W!^!_!8g!_#o!6W#o#p!8g#p;'S!6W;'S;=`!=i<%lO!6W&n!=lP;=`<%l!6W(Q!=xi$d&j'{!b!RSOY&}YZ&cZw&}wx&cx!^&}!^!_'}!_#O&}#O#P&c#P#Z&}#Z#[!=o#[#]&}#]#^!=o#^#a&}#a#b!=o#b#g&}#g#h!=o#h#i&}#i#j!=o#j#m&}#m#n!=o#n#o&}#o#p'}#p;'S&};'S;=`(l<%lO&}!f!?nZ'{!b!RSOY!?gZw!?gwx!8gx!P!?g!P!Q!@a!Q!}!?g!}#O!Ap#O#P!:o#P;'S!?g;'S;=`!Bh<%lO!?g!f!@hb'{!b!RSOY'}Zw'}x#O'}#P#Z'}#Z#[!@a#[#]'}#]#^!@a#^#a'}#a#b!@a#b#g'}#g#h!@a#h#i'}#i#j!@a#j#m'}#m#n!@a#n;'S'};'S;=`(f<%lO'}!f!AuX'{!bOY!ApZw!Apwx!9px#O!Ap#O#P!:Y#P#Q!?g#Q;'S!Ap;'S;=`!Bb<%lO!Ap!f!BeP;=`<%l!Ap!f!BkP;=`<%l!?g(Q!Bu^$d&j'{!bOY!BnYZ&cZw!Bnwx!;Ux!^!Bn!^!_!Ap!_#O!Bn#O#P!<P#P#Q!4{#Q#o!Bn#o#p!Ap#p;'S!Bn;'S;=`!Cq<%lO!Bn(Q!CtP;=`<%l!Bn(Q!CzP;=`<%l!4{'`!DW`$d&j'xp!RSOY!C}YZ&cZr!C}rs!6Ws!P!C}!P!Q!EY!Q!^!C}!^!_!GQ!_!}!C}!}#O!JX#O#P!<w#P#o!C}#o#p!GQ#p;'S!C};'S;=`!Kb<%lO!C}'`!Eci$d&j'xp!RSOY(rYZ&cZr(rrs&cs!^(r!^!_)r!_#O(r#O#P&c#P#Z(r#Z#[!EY#[#](r#]#^!EY#^#a(r#a#b!EY#b#g(r#g#h!EY#h#i(r#i#j!EY#j#m(r#m#n!EY#n#o(r#o#p)r#p;'S(r;'S;=`*a<%lO(rt!GXZ'xp!RSOY!GQZr!GQrs!8gs!P!GQ!P!Q!Gz!Q!}!GQ!}#O!IZ#O#P!:o#P;'S!GQ;'S;=`!JR<%lO!GQt!HRb'xp!RSOY)rZr)rs#O)r#P#Z)r#Z#[!Gz#[#])r#]#^!Gz#^#a)r#a#b!Gz#b#g)r#g#h!Gz#h#i)r#i#j!Gz#j#m)r#m#n!Gz#n;'S)r;'S;=`*Z<%lO)rt!I`X'xpOY!IZZr!IZrs!9ps#O!IZ#O#P!:Y#P#Q!GQ#Q;'S!IZ;'S;=`!I{<%lO!IZt!JOP;=`<%l!IZt!JUP;=`<%l!GQ'`!J`^$d&j'xpOY!JXYZ&cZr!JXrs!;Us!^!JX!^!_!IZ!_#O!JX#O#P!<P#P#Q!C}#Q#o!JX#o#p!IZ#p;'S!JX;'S;=`!K[<%lO!JX'`!K_P;=`<%l!JX'`!KeP;=`<%l!C}(r!Ksk$d&j'xp'{!b!RSOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#Z%Z#Z#[!Kh#[#]%Z#]#^!Kh#^#a%Z#a#b!Kh#b#g%Z#g#h!Kh#h#i%Z#i#j!Kh#j#m%Z#m#n!Kh#n#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#W!Mq]'xp'{!b!RSOY!MhZr!Mhrs!?gsw!Mhwx!GQx!P!Mh!P!Q!Nj!Q!}!Mh!}#O#!U#O#P!:o#P;'S!Mh;'S;=`##U<%lO!Mh#W!Nse'xp'{!b!RSOY*gZr*grs'}sw*gwx)rx#O*g#P#Z*g#Z#[!Nj#[#]*g#]#^!Nj#^#a*g#a#b!Nj#b#g*g#g#h!Nj#h#i*g#i#j!Nj#j#m*g#m#n!Nj#n;'S*g;'S;=`+Z<%lO*g#W#!]Z'xp'{!bOY#!UZr#!Urs!Apsw#!Uwx!IZx#O#!U#O#P!:Y#P#Q!Mh#Q;'S#!U;'S;=`##O<%lO#!U#W##RP;=`<%l#!U#W##XP;=`<%l!Mh(r##e`$d&j'xp'{!bOY##[YZ&cZr##[rs!Bnsw##[wx!JXx!^##[!^!_#!U!_#O##[#O#P!<P#P#Q!3h#Q#o##[#o#p#!U#p;'S##[;'S;=`#$g<%lO##[(r#$jP;=`<%l##[(r#$pP;=`<%l!3h(CS#%Qb$d&j'xp'{!b'p(;d!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h(CS#&e_$d&j'xp'{!bR(;dOY#&YYZ&cZr#&Yrs#'dsw#&Ywx#*tx!^#&Y!^!_#,s!_#O#&Y#O#P#(f#P#o#&Y#o#p#,s#p;'S#&Y;'S;=`#-r<%lO#&Y(Bb#'m]$d&j'{!bR(;dOY#'dYZ&cZw#'dwx#(fx!^#'d!^!_#)w!_#O#'d#O#P#(f#P#o#'d#o#p#)w#p;'S#'d;'S;=`#*n<%lO#'d(AO#(mX$d&jR(;dOY#(fYZ&cZ!^#(f!^!_#)Y!_#o#(f#o#p#)Y#p;'S#(f;'S;=`#)q<%lO#(f(;d#)_SR(;dOY#)YZ;'S#)Y;'S;=`#)k<%lO#)Y(;d#)nP;=`<%l#)Y(AO#)tP;=`<%l#(f(<v#*OW'{!bR(;dOY#)wZw#)wwx#)Yx#O#)w#O#P#)Y#P;'S#)w;'S;=`#*h<%lO#)w(<v#*kP;=`<%l#)w(Bb#*qP;=`<%l#'d(Ap#*}]$d&j'xpR(;dOY#*tYZ&cZr#*trs#(fs!^#*t!^!_#+v!_#O#*t#O#P#(f#P#o#*t#o#p#+v#p;'S#*t;'S;=`#,m<%lO#*t(<U#+}W'xpR(;dOY#+vZr#+vrs#)Ys#O#+v#O#P#)Y#P;'S#+v;'S;=`#,g<%lO#+v(<U#,jP;=`<%l#+v(Ap#,pP;=`<%l#*t(=h#,|Y'xp'{!bR(;dOY#,sZr#,srs#)wsw#,swx#+vx#O#,s#O#P#)Y#P;'S#,s;'S;=`#-l<%lO#,s(=h#-oP;=`<%l#,s(CS#-uP;=`<%l#&Y%#W#.Vb$d&j#{$Id'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h+h#/lb$T#t$d&j'xp'{!b!RSOY!3hYZ&cZr!3hrs!4{sw!3hwx!C}x!P!3h!P!Q!Kh!Q!^!3h!^!_!Mh!_!}!3h!}#O##[#O#P!<w#P#o!3h#o#p!Mh#p;'S!3h;'S;=`#$m<%lO!3h$/l#1Pp$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#U%Z#U#V#6_#V#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#d#9g#d#l%Z#l#m#<i#m#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#3`k$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P!+g!P!Q%Z!Q![#3T![!^%Z!^!_*g!_!g%Z!g!h!-Z!h#O%Z#O#P&c#P#R%Z#R#S#3T#S#X%Z#X#Y!-Z#Y#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#5`_$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#6hd$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#8Rf$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!R#7v!R!S#7v!S!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#7v#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#9pc$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#;We$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q!Y#:{!Y!^%Z!^!_*g!_#O%Z#O#P&c#P#R%Z#R#S#:{#S#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#<rg$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z$/l#>fi$d&j'xp'{!bl$'|OY%ZYZ&cZr%Zrs&}sw%Zwx(rx!Q%Z!Q![#>Z![!^%Z!^!_*g!_!c%Z!c!i#>Z!i#O%Z#O#P&c#P#R%Z#R#S#>Z#S#T%Z#T#Z#>Z#Z#b%Z#b#c#5T#c#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#@b_!a$b$d&j#y%<f'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z)[#Al_^l$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS#Bz^(O!*v!e'.r'xp'{!b$U)d(oSOY*gZr*grs'}sw*gwx)rx!P*g!P!Q#Cv!Q!^*g!^!_#Dl!_!`#F^!`#O*g#P;'S*g;'S;=`+Z<%lO*g(n#DPX$f&j'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#DuZ#k$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx!_*g!_!`#Eh!`#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#EqX#{$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g$Kh#FgX#l$Id'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Gh#G_a#X%?x$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`0z!`!a#Hd!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#W#Ho_#d$Ih$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%Gh#I}adBf#l$Id$a#|$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`#KS!`!a#L^!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#K__#l$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#Lia#k$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`!a#Mn!a#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S#My`#k$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+h$ Wc(c$Ip$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!O%Z!O!P$!c!P!^%Z!^!_*g!_!a%Z!a!b$#m!b#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z'+`$!n_z'#p$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$#x`$d&j#v$Id'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z#&^$%V_!x!Ln$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(@^$&a_|(8n$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(n$'eZ$d&jO!^$(W!^!_$(n!_#i$(W#i#j$(s#j#l$(W#l#m$*f#m#o$(W#o#p$(n#p;'S$(W;'S;=`$,q<%lO$(W(n$(_T[#S$d&jO!^&c!_#o&c#p;'S&c;'S;=`&w<%lO&c#S$(sO[#S(n$(x[$d&jO!Q&c!Q![$)n![!^&c!_!c&c!c!i$)n!i#T&c#T#Z$)n#Z#o&c#o#p$,U#p;'S&c;'S;=`&w<%lO&c(n$)sZ$d&jO!Q&c!Q![$*f![!^&c!_!c&c!c!i$*f!i#T&c#T#Z$*f#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$*kZ$d&jO!Q&c!Q![$+^![!^&c!_!c&c!c!i$+^!i#T&c#T#Z$+^#Z#o&c#p;'S&c;'S;=`&w<%lO&c(n$+cZ$d&jO!Q&c!Q![$(W![!^&c!_!c&c!c!i$(W!i#T&c#T#Z$(W#Z#o&c#p;'S&c;'S;=`&w<%lO&c#S$,XR!Q![$,b!c!i$,b#T#Z$,b#S$,eS!Q![$,b!c!i$,b#T#Z$,b#q#r$(n(n$,tP;=`<%l$(W!2r$-S_!S!+S$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z%#S$.^`#s$Id$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z&,v$/k_$d&j'xp'{!b(S&%WOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$0yk$d&j'xp'{!b(V!LY'u&;d$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$0juw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$0j![!^%Z!^!_*g!_!c%Z!c!}$0j!}#O%Z#O#P&c#P#R%Z#R#S$0j#S#T%Z#T#o$0j#o#p*g#p$g%Z$g;'S$0j;'S;=`$4t<%lO$0j+d$2yk$d&j'xp'{!b$Y#tOY%ZYZ&cZr%Zrs&}st%Ztu$2nuw%Zwx(rx}%Z}!O$2n!O!Q%Z!Q![$2n![!^%Z!^!_*g!_!c%Z!c!}$2n!}#O%Z#O#P&c#P#R%Z#R#S$2n#S#T%Z#T#o$2n#o#p*g#p$g%Z$g;'S$2n;'S;=`$4n<%lO$2n+d$4qP;=`<%l$2n(CS$4wP;=`<%l$0j!5p$5TX!X!3l'xp'{!bOY*gZr*grs'}sw*gwx)rx#O*g#P;'S*g;'S;=`+Z<%lO*g%Df$5{a(j%<v$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_!`Cn!`#O%Z#O#P&c#P#o%Z#o#p*g#p#q$#m#q;'S%Z;'S;=`+a<%lO%Z%#`$7__!W$I`o`$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(r$8i_!mS$d&j'xp'{!bOY%ZYZ&cZr%Zrs&}sw%Zwx(rx!^%Z!^!_*g!_#O%Z#O#P&c#P#o%Z#o#p*g#p;'S%Z;'S;=`+a<%lO%Z(CS$9y|$d&j'xp'{!b'n(;d(V!LY'u&;d$W#tOX%ZXY+gYZ&cZ[+g[p%Zpq+gqr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$f%Z$f$g+g$g#BY>P#BY#BZ$9h#BZ$IS>P$IS$I_$9h$I_$JT>P$JT$JU$9h$JU$KV>P$KV$KW$9h$KW&FU>P&FU&FV$9h&FV;'S>P;'S;=`BZ<%l?HT>P?HT?HU$9h?HUO>P(CS$=Uk$d&j'xp'{!b'o(;d(V!LY'u&;d$W#tOY%ZYZ&cZr%Zrs&}st%Ztu>Puw%Zwx(rx}%Z}!O@T!O!Q%Z!Q![>P![!^%Z!^!_*g!_!c%Z!c!}>P!}#O%Z#O#P&c#P#R%Z#R#S>P#S#T%Z#T#o>P#o#p*g#p$g%Z$g;'S>P;'S;=`BZ<%lO>P",
  tokenizers: [dMe, pMe, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, fMe, new _S("$S~RRtu[#O#Pg#S#T#|~_P#o#pb~gOq~~jVO#i!P#i#j!U#j#l!P#l#m!q#m;'S!P;'S;=`#v<%lO!P~!UO!O~~!XS!Q![!e!c!i!e#T#Z!e#o#p#Z~!hR!Q![!q!c!i!q#T#Z!q~!tR!Q![!}!c!i!}#T#Z!}~#QR!Q![!P!c!i!P#T#Z!P~#^R!Q![#g!c!i#g#T#Z#g~#jS!Q![#g!c!i#g#T#Z#g#q#r!P~#yP;=`<%l!P~$RO(U~~", 141, 327), new _S("j~RQYZXz{^~^O'r~~aP!P!Qd~iO's~~", 25, 309)],
  topRules: { Script: [0, 5], SingleExpression: [1, 267], SingleClassItem: [2, 268] },
  dialects: { jsx: 12794, ts: 12796 },
  dynamicPrecedences: { 76: 1, 78: 1, 163: 1, 191: 1 },
  specialized: [{ term: 313, get: (r) => vMe[r] || -1 }, { term: 329, get: (r) => OMe[r] || -1 }, { term: 67, get: (r) => mMe[r] || -1 }],
  tokenPrec: 12820
}), bMe = [
  /* @__PURE__ */ Tr("function ${name}(${params}) {\n	${}\n}", {
    label: "function",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("for (let ${index} = 0; ${index} < ${bound}; ${index}++) {\n	${}\n}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("for (let ${name} of ${collection}) {\n	${}\n}", {
    label: "for",
    detail: "of loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("do {\n	${}\n} while (${})", {
    label: "do",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("while (${}) {\n	${}\n}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr(`try {
	\${}
} catch (\${error}) {
	\${}
}`, {
    label: "try",
    detail: "/ catch block",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("if (${}) {\n	${}\n}", {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr(`if (\${}) {
	\${}
} else {
	\${}
}`, {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr(`class \${name} {
	constructor(\${params}) {
		\${}
	}
}`, {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr('import {${names}} from "${module}"\n${}', {
    label: "import",
    detail: "named",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr('import ${name} from "${module}"\n${}', {
    label: "import",
    detail: "default",
    type: "keyword"
  })
], RB = /* @__PURE__ */ new k6(), nq = /* @__PURE__ */ new Set([
  "Script",
  "Block",
  "FunctionExpression",
  "FunctionDeclaration",
  "ArrowFunction",
  "MethodDeclaration",
  "ForStatement"
]);
function ap(r) {
  return (e, t) => {
    let i = e.node.getChild("VariableDefinition");
    return i && t(i, r), !0;
  };
}
const SMe = ["FunctionDeclaration"], TMe = {
  FunctionDeclaration: /* @__PURE__ */ ap("function"),
  ClassDeclaration: /* @__PURE__ */ ap("class"),
  ClassExpression: () => !0,
  EnumDeclaration: /* @__PURE__ */ ap("constant"),
  TypeAliasDeclaration: /* @__PURE__ */ ap("type"),
  NamespaceDeclaration: /* @__PURE__ */ ap("namespace"),
  VariableDefinition(r, e) {
    r.matchContext(SMe) || e(r, "variable");
  },
  TypeDefinition(r, e) {
    e(r, "type");
  },
  __proto__: null
};
function aq(r, e) {
  let t = RB.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function a(o, s) {
    let l = r.sliceString(o.from, o.to);
    i.push({ label: l, type: s });
  }
  return e.cursor(Xt.IncludeAnonymous).iterate((o) => {
    if (n)
      n = !1;
    else if (o.name) {
      let s = TMe[o.name];
      if (s && s(o, a) || nq.has(o.name))
        return !1;
    } else if (o.to - o.from > 8192) {
      for (let s of aq(r, o.node))
        i.push(s);
      return !1;
    }
  }), RB.set(e, i), i;
}
const AB = /^[\w$\xa1-\uffff][\w$\d\xa1-\uffff]*$/, oq = [
  "TemplateString",
  "String",
  "RegExp",
  "LineComment",
  "BlockComment",
  "VariableDefinition",
  "TypeDefinition",
  "Label",
  "PropertyDefinition",
  "PropertyName",
  "PrivatePropertyDefinition",
  "PrivatePropertyName"
];
function yMe(r) {
  let e = Kt(r.state).resolveInner(r.pos, -1);
  if (oq.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && AB.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    nq.has(n.name) && (i = i.concat(aq(r.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : r.pos,
    validFor: AB
  };
}
const El = /* @__PURE__ */ wo.define({
  name: "javascript",
  parser: /* @__PURE__ */ EMe.configure({
    props: [
      /* @__PURE__ */ jl.add({
        IfStatement: /* @__PURE__ */ mo({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ mo({ except: /^\s*({|catch\b|finally\b)/ }),
        LabeledStatement: F6,
        SwitchBody: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : i ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ sg({ closing: "}" }),
        ArrowFunction: (r) => r.baseIndent + r.unit,
        "TemplateString BlockComment": () => null,
        "Statement Property": /* @__PURE__ */ mo({ except: /^{/ }),
        JSXElement(r) {
          let e = /^\s*<\//.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        JSXEscape(r) {
          let e = /\s*\}/.test(r.textAfter);
          return r.lineIndent(r.node.from) + (e ? 0 : r.unit);
        },
        "JSXOpenTag JSXSelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        }
      }),
      /* @__PURE__ */ Kl.add({
        "Block ClassBody SwitchBody EnumBody ObjectExpression ArrayExpression": Wv,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] },
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\}|<\/)$/,
    wordChars: "$"
  }
}), RMe = /* @__PURE__ */ El.configure({ dialect: "ts" }, "typescript"), AMe = /* @__PURE__ */ El.configure({ dialect: "jsx" }), _Me = /* @__PURE__ */ El.configure({ dialect: "jsx ts" }, "typescript"), CMe = /* @__PURE__ */ "break case const continue default delete export extends false finally in instanceof let new return static super switch this throw true typeof var yield".split(" ").map((r) => ({ label: r, type: "keyword" }));
function SE(r = {}) {
  let e = r.jsx ? r.typescript ? _Me : AMe : r.typescript ? RMe : El;
  return new ih(e, [
    El.data.of({
      autocomplete: vP(oq, uy(bMe.concat(CMe)))
    }),
    El.data.of({
      autocomplete: yMe
    }),
    r.jsx ? wMe : []
  ]);
}
function _B(r, e, t = r.length) {
  if (!e)
    return "";
  let i = e.getChild("JSXIdentifier");
  return i ? r.sliceString(i.from, Math.min(i.to, t)) : "";
}
const IMe = typeof navigator == "object" && /* @__PURE__ */ /Android\b/.test(navigator.userAgent), wMe = /* @__PURE__ */ me.inputHandler.of((r, e, t, i) => {
  if ((IMe ? r.composing : r.compositionStarted) || r.state.readOnly || e != t || i != ">" && i != "/" || !El.isActiveAt(r.state, e, -1))
    return !1;
  let { state: n } = r, a = n.changeByRange((o) => {
    var s, l, u;
    let { head: c } = o, h = Kt(n).resolveInner(c, -1), f;
    if (h.name == "JSXStartTag" && (h = h.parent), i == ">" && h.name == "JSXFragmentTag")
      return { range: Z.cursor(c + 1), changes: { from: c, insert: "><>" } };
    if (i == ">" && h.name == "JSXIdentifier") {
      if (((l = (s = h.parent) === null || s === void 0 ? void 0 : s.lastChild) === null || l === void 0 ? void 0 : l.name) != "JSXEndTag" && (f = _B(n.doc, h.parent, c)))
        return { range: Z.cursor(c + 1), changes: { from: c, insert: `></${f}>` } };
    } else if (i == "/" && h.name == "JSXFragmentTag") {
      let d = h.parent, p = d == null ? void 0 : d.parent;
      if (d.from == c - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "JSXEndTag" && (f = _B(n.doc, p == null ? void 0 : p.firstChild, c))) {
        let g = `/${f}>`;
        return { range: Z.cursor(c + g.length), changes: { from: c, insert: g } };
      }
    }
    return { range: o };
  });
  return a.changes.empty ? !1 : (r.dispatch(a, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), op = ["_blank", "_self", "_top", "_parent"], UA = ["ascii", "utf-8", "utf-16", "latin1", "latin1"], $A = ["get", "post", "put", "delete"], VA = ["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"], un = ["true", "false"], Oe = {}, fy = {
  a: {
    attrs: {
      href: null,
      ping: null,
      type: null,
      media: null,
      target: op,
      hreflang: null
    }
  },
  abbr: Oe,
  acronym: Oe,
  address: Oe,
  applet: Oe,
  area: {
    attrs: {
      alt: null,
      coords: null,
      href: null,
      target: null,
      ping: null,
      media: null,
      hreflang: null,
      type: null,
      shape: ["default", "rect", "circle", "poly"]
    }
  },
  article: Oe,
  aside: Oe,
  audio: {
    attrs: {
      src: null,
      mediagroup: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["none", "metadata", "auto"],
      autoplay: ["autoplay"],
      loop: ["loop"],
      controls: ["controls"]
    }
  },
  b: Oe,
  base: { attrs: { href: null, target: op } },
  basefont: Oe,
  bdi: Oe,
  bdo: Oe,
  big: Oe,
  blockquote: { attrs: { cite: null } },
  body: Oe,
  br: Oe,
  button: {
    attrs: {
      form: null,
      formaction: null,
      name: null,
      value: null,
      autofocus: ["autofocus"],
      disabled: ["autofocus"],
      formenctype: VA,
      formmethod: $A,
      formnovalidate: ["novalidate"],
      formtarget: op,
      type: ["submit", "reset", "button"]
    }
  },
  canvas: { attrs: { width: null, height: null } },
  caption: Oe,
  center: Oe,
  cite: Oe,
  code: Oe,
  col: { attrs: { span: null } },
  colgroup: { attrs: { span: null } },
  command: {
    attrs: {
      type: ["command", "checkbox", "radio"],
      label: null,
      icon: null,
      radiogroup: null,
      command: null,
      title: null,
      disabled: ["disabled"],
      checked: ["checked"]
    }
  },
  data: { attrs: { value: null } },
  datagrid: { attrs: { disabled: ["disabled"], multiple: ["multiple"] } },
  datalist: { attrs: { data: null } },
  dd: Oe,
  del: { attrs: { cite: null, datetime: null } },
  details: { attrs: { open: ["open"] } },
  dfn: Oe,
  dir: Oe,
  div: Oe,
  dl: Oe,
  dt: Oe,
  em: Oe,
  embed: { attrs: { src: null, type: null, width: null, height: null } },
  eventsource: { attrs: { src: null } },
  fieldset: { attrs: { disabled: ["disabled"], form: null, name: null } },
  figcaption: Oe,
  figure: Oe,
  font: Oe,
  footer: Oe,
  form: {
    attrs: {
      action: null,
      name: null,
      "accept-charset": UA,
      autocomplete: ["on", "off"],
      enctype: VA,
      method: $A,
      novalidate: ["novalidate"],
      target: op
    }
  },
  frame: Oe,
  frameset: Oe,
  h1: Oe,
  h2: Oe,
  h3: Oe,
  h4: Oe,
  h5: Oe,
  h6: Oe,
  head: {
    children: ["title", "base", "link", "style", "meta", "script", "noscript", "command"]
  },
  header: Oe,
  hgroup: Oe,
  hr: Oe,
  html: {
    attrs: { manifest: null }
  },
  i: Oe,
  iframe: {
    attrs: {
      src: null,
      srcdoc: null,
      name: null,
      width: null,
      height: null,
      sandbox: ["allow-top-navigation", "allow-same-origin", "allow-forms", "allow-scripts"],
      seamless: ["seamless"]
    }
  },
  img: {
    attrs: {
      alt: null,
      src: null,
      ismap: null,
      usemap: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"]
    }
  },
  input: {
    attrs: {
      alt: null,
      dirname: null,
      form: null,
      formaction: null,
      height: null,
      list: null,
      max: null,
      maxlength: null,
      min: null,
      name: null,
      pattern: null,
      placeholder: null,
      size: null,
      src: null,
      step: null,
      value: null,
      width: null,
      accept: ["audio/*", "video/*", "image/*"],
      autocomplete: ["on", "off"],
      autofocus: ["autofocus"],
      checked: ["checked"],
      disabled: ["disabled"],
      formenctype: VA,
      formmethod: $A,
      formnovalidate: ["novalidate"],
      formtarget: op,
      multiple: ["multiple"],
      readonly: ["readonly"],
      required: ["required"],
      type: [
        "hidden",
        "text",
        "search",
        "tel",
        "url",
        "email",
        "password",
        "datetime",
        "date",
        "month",
        "week",
        "time",
        "datetime-local",
        "number",
        "range",
        "color",
        "checkbox",
        "radio",
        "file",
        "submit",
        "image",
        "reset",
        "button"
      ]
    }
  },
  ins: { attrs: { cite: null, datetime: null } },
  kbd: Oe,
  keygen: {
    attrs: {
      challenge: null,
      form: null,
      name: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      keytype: ["RSA"]
    }
  },
  label: { attrs: { for: null, form: null } },
  legend: Oe,
  li: { attrs: { value: null } },
  link: {
    attrs: {
      href: null,
      type: null,
      hreflang: null,
      media: null,
      sizes: ["all", "16x16", "16x16 32x32", "16x16 32x32 64x64"]
    }
  },
  map: { attrs: { name: null } },
  mark: Oe,
  menu: { attrs: { label: null, type: ["list", "context", "toolbar"] } },
  meta: {
    attrs: {
      content: null,
      charset: UA,
      name: ["viewport", "application-name", "author", "description", "generator", "keywords"],
      "http-equiv": ["content-language", "content-type", "default-style", "refresh"]
    }
  },
  meter: { attrs: { value: null, min: null, low: null, high: null, max: null, optimum: null } },
  nav: Oe,
  noframes: Oe,
  noscript: Oe,
  object: {
    attrs: {
      data: null,
      type: null,
      name: null,
      usemap: null,
      form: null,
      width: null,
      height: null,
      typemustmatch: ["typemustmatch"]
    }
  },
  ol: {
    attrs: { reversed: ["reversed"], start: null, type: ["1", "a", "A", "i", "I"] },
    children: ["li", "script", "template", "ul", "ol"]
  },
  optgroup: { attrs: { disabled: ["disabled"], label: null } },
  option: { attrs: { disabled: ["disabled"], label: null, selected: ["selected"], value: null } },
  output: { attrs: { for: null, form: null, name: null } },
  p: Oe,
  param: { attrs: { name: null, value: null } },
  pre: Oe,
  progress: { attrs: { value: null, max: null } },
  q: { attrs: { cite: null } },
  rp: Oe,
  rt: Oe,
  ruby: Oe,
  s: Oe,
  samp: Oe,
  script: {
    attrs: {
      type: ["text/javascript"],
      src: null,
      async: ["async"],
      defer: ["defer"],
      charset: UA
    }
  },
  section: Oe,
  select: {
    attrs: {
      form: null,
      name: null,
      size: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      multiple: ["multiple"]
    }
  },
  slot: { attrs: { name: null } },
  small: Oe,
  source: { attrs: { src: null, type: null, media: null } },
  span: Oe,
  strike: Oe,
  strong: Oe,
  style: {
    attrs: {
      type: ["text/css"],
      media: null,
      scoped: null
    }
  },
  sub: Oe,
  summary: Oe,
  sup: Oe,
  table: Oe,
  tbody: Oe,
  td: { attrs: { colspan: null, rowspan: null, headers: null } },
  template: Oe,
  textarea: {
    attrs: {
      dirname: null,
      form: null,
      maxlength: null,
      name: null,
      placeholder: null,
      rows: null,
      cols: null,
      autofocus: ["autofocus"],
      disabled: ["disabled"],
      readonly: ["readonly"],
      required: ["required"],
      wrap: ["soft", "hard"]
    }
  },
  tfoot: Oe,
  th: { attrs: { colspan: null, rowspan: null, headers: null, scope: ["row", "col", "rowgroup", "colgroup"] } },
  thead: Oe,
  time: { attrs: { datetime: null } },
  title: Oe,
  tr: Oe,
  track: {
    attrs: {
      src: null,
      label: null,
      default: null,
      kind: ["subtitles", "captions", "descriptions", "chapters", "metadata"],
      srclang: null
    }
  },
  tt: Oe,
  u: Oe,
  ul: { children: ["li", "script", "template", "ul", "ol"] },
  var: Oe,
  video: {
    attrs: {
      src: null,
      poster: null,
      width: null,
      height: null,
      crossorigin: ["anonymous", "use-credentials"],
      preload: ["auto", "metadata", "none"],
      autoplay: ["autoplay"],
      mediagroup: ["movie"],
      muted: ["muted"],
      controls: ["controls"]
    }
  },
  wbr: Oe
}, sq = {
  accesskey: null,
  class: null,
  contenteditable: un,
  contextmenu: null,
  dir: ["ltr", "rtl", "auto"],
  draggable: ["true", "false", "auto"],
  dropzone: ["copy", "move", "link", "string:", "file:"],
  hidden: ["hidden"],
  id: null,
  inert: ["inert"],
  itemid: null,
  itemprop: null,
  itemref: null,
  itemscope: ["itemscope"],
  itemtype: null,
  lang: ["ar", "bn", "de", "en-GB", "en-US", "es", "fr", "hi", "id", "ja", "pa", "pt", "ru", "tr", "zh"],
  spellcheck: un,
  autocorrect: un,
  autocapitalize: un,
  style: null,
  tabindex: null,
  title: null,
  translate: ["yes", "no"],
  onclick: null,
  rel: ["stylesheet", "alternate", "author", "bookmark", "help", "license", "next", "nofollow", "noreferrer", "prefetch", "prev", "search", "tag"],
  role: /* @__PURE__ */ "alert application article banner button cell checkbox complementary contentinfo dialog document feed figure form grid gridcell heading img list listbox listitem main navigation region row rowgroup search switch tab table tabpanel textbox timer".split(" "),
  "aria-activedescendant": null,
  "aria-atomic": un,
  "aria-autocomplete": ["inline", "list", "both", "none"],
  "aria-busy": un,
  "aria-checked": ["true", "false", "mixed", "undefined"],
  "aria-controls": null,
  "aria-describedby": null,
  "aria-disabled": un,
  "aria-dropeffect": null,
  "aria-expanded": ["true", "false", "undefined"],
  "aria-flowto": null,
  "aria-grabbed": ["true", "false", "undefined"],
  "aria-haspopup": un,
  "aria-hidden": un,
  "aria-invalid": ["true", "false", "grammar", "spelling"],
  "aria-label": null,
  "aria-labelledby": null,
  "aria-level": null,
  "aria-live": ["off", "polite", "assertive"],
  "aria-multiline": un,
  "aria-multiselectable": un,
  "aria-owns": null,
  "aria-posinset": null,
  "aria-pressed": ["true", "false", "mixed", "undefined"],
  "aria-readonly": un,
  "aria-relevant": null,
  "aria-required": un,
  "aria-selected": ["true", "false", "undefined"],
  "aria-setsize": null,
  "aria-sort": ["ascending", "descending", "none", "other"],
  "aria-valuemax": null,
  "aria-valuemin": null,
  "aria-valuenow": null,
  "aria-valuetext": null
}, NMe = /* @__PURE__ */ Object.keys(fy), CB = /* @__PURE__ */ Object.keys(sq);
function Ff(r, e, t = r.length) {
  if (!e)
    return "";
  let i = e.firstChild, n = i && i.getChild("TagName");
  return n ? r.sliceString(n.from, Math.min(n.to, t)) : "";
}
function dy(r, e = !1) {
  for (let t = r.parent; t; t = t.parent)
    if (t.name == "Element")
      if (e)
        e = !1;
      else
        return t;
  return null;
}
function lq(r, e) {
  let t = fy[Ff(r, dy(e, !0))];
  return (t == null ? void 0 : t.children) || NMe;
}
function _P(r, e) {
  let t = [];
  for (let i = e; i = dy(i); ) {
    let n = Ff(r, i);
    if (n && i.lastChild.name == "CloseTag")
      break;
    n && t.indexOf(n) < 0 && (e.name == "EndTag" || e.from >= i.firstChild.to) && t.push(n);
  }
  return t;
}
const uq = /^[:\-\.\w\u00b7-\uffff]*$/;
function IB(r, e, t, i) {
  let n = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: lq(r.doc, e).map((a) => ({ label: a, type: "type" })).concat(_P(r.doc, e).map((a, o) => ({ label: "/" + a, apply: "/" + a + n, type: "type", boost: 99 - o }))),
    validFor: /^\/?[:\-\.\w\u00b7-\uffff]*$/
  };
}
function wB(r, e, t, i) {
  let n = /\s*>/.test(r.sliceDoc(i, i + 5)) ? "" : ">";
  return {
    from: t,
    to: i,
    options: _P(r.doc, e).map((a, o) => ({ label: a, apply: a + n, type: "type", boost: 99 - o })),
    validFor: uq
  };
}
function xMe(r, e, t) {
  let i = [], n = 0;
  for (let a of lq(r.doc, e))
    i.push({ label: "<" + a, type: "type" });
  for (let a of _P(r.doc, e))
    i.push({ label: "</" + a + ">", type: "type", boost: 99 - n++ });
  return { from: t, to: t, options: i, validFor: /^<\/?[:\-\.\w\u00b7-\uffff]*$/ };
}
function PMe(r, e, t, i) {
  let n = dy(e), a = n ? fy[Ff(r.doc, n)] : null, o = a && a.attrs ? Object.keys(a.attrs).concat(CB) : CB;
  return {
    from: t,
    to: i,
    options: o.map((s) => ({ label: s, type: "property" })),
    validFor: uq
  };
}
function LMe(r, e, t, i) {
  var n;
  let a = (n = e.parent) === null || n === void 0 ? void 0 : n.getChild("AttributeName"), o = [], s;
  if (a) {
    let l = r.sliceDoc(a.from, a.to), u = sq[l];
    if (!u) {
      let c = dy(e), h = c ? fy[Ff(r.doc, c)] : null;
      u = (h == null ? void 0 : h.attrs) && h.attrs[l];
    }
    if (u) {
      let c = r.sliceDoc(t, i).toLowerCase(), h = '"', f = '"';
      /^['"]/.test(c) ? (s = c[0] == '"' ? /^[^"]*$/ : /^[^']*$/, h = "", f = r.sliceDoc(i, i + 1) == c[0] ? "" : c[0], c = c.slice(1), t++) : s = /^[^\s<>='"]*$/;
      for (let d of u)
        o.push({ label: d, apply: h + d + f, type: "constant" });
    }
  }
  return { from: t, to: i, options: o, validFor: s };
}
function DMe(r) {
  let { state: e, pos: t } = r, i = Kt(e).resolveInner(t), n = i.resolve(t, -1);
  for (let a = t, o; i == n && (o = n.childBefore(a)); ) {
    let s = o.lastChild;
    if (!s || !s.type.isError || s.from < s.to)
      break;
    i = n = o, a = s.from;
  }
  return n.name == "TagName" ? n.parent && /CloseTag$/.test(n.parent.name) ? wB(e, n, n.from, t) : IB(e, n, n.from, t) : n.name == "StartTag" ? IB(e, n, t, t) : n.name == "StartCloseTag" || n.name == "IncompleteCloseTag" ? wB(e, n, t, t) : r.explicit && (n.name == "OpenTag" || n.name == "SelfClosingTag") || n.name == "AttributeName" ? PMe(e, n, n.name == "AttributeName" ? n.from : t, t) : n.name == "Is" || n.name == "AttributeValue" || n.name == "UnquotedAttributeValue" ? LMe(e, n, n.name == "Is" ? t : n.from, t) : r.explicit && (i.name == "Element" || i.name == "Text" || i.name == "Document") ? xMe(e, n, t) : null;
}
const gw = /* @__PURE__ */ wo.define({
  parser: /* @__PURE__ */ xDe.configure({
    props: [
      /* @__PURE__ */ jl.add({
        Element(r) {
          let e = /^(\s*)(<\/)?/.exec(r.textAfter);
          return r.node.to <= r.pos + e[0].length ? r.continue() : r.lineIndent(r.node.from) + (e[2] ? 0 : r.unit);
        },
        "OpenTag CloseTag SelfClosingTag"(r) {
          return r.column(r.node.from) + r.unit;
        },
        Document(r) {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length < r.node.to)
            return r.continue();
          let e = null, t;
          for (let i = r.node; ; ) {
            let n = i.lastChild;
            if (!n || n.name != "Element" || n.to != i.to)
              break;
            e = i = n;
          }
          return e && !((t = e.lastChild) && (t.name == "CloseTag" || t.name == "SelfClosingTag")) ? r.lineIndent(e.from) + r.unit : null;
        }
      }),
      /* @__PURE__ */ Kl.add({
        Element(r) {
          let e = r.firstChild, t = r.lastChild;
          return !e || e.name != "OpenTag" ? null : { from: e.to, to: t.name == "CloseTag" ? t.from : r.to };
        }
      })
    ],
    wrap: /* @__PURE__ */ PDe([
      {
        tag: "script",
        attrs(r) {
          return !r.type || /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i.test(r.type);
        },
        parser: El.parser
      },
      {
        tag: "style",
        attrs(r) {
          return (!r.lang || r.lang == "css") && (!r.type || /^(text\/)?(x-)?(stylesheet|css)$/i.test(r.type));
        },
        parser: dw.parser
      }
    ])
  }),
  languageData: {
    commentTokens: { block: { open: "<!--", close: "-->" } },
    indentOnInput: /^\s*<\/\w+\W$/,
    wordChars: "-._"
  }
});
function MMe(r = {}) {
  let e = gw;
  return r.matchClosingTags === !1 && (e = e.configure({ dialect: "noMatch" })), new ih(e, [
    gw.data.of({ autocomplete: DMe }),
    r.autoCloseTags !== !1 ? kMe : [],
    SE().support,
    pw().support
  ]);
}
const kMe = /* @__PURE__ */ me.inputHandler.of((r, e, t, i) => {
  if (r.composing || r.state.readOnly || e != t || i != ">" && i != "/" || !gw.isActiveAt(r.state, e, -1))
    return !1;
  let { state: n } = r, a = n.changeByRange((o) => {
    var s, l, u;
    let { head: c } = o, h = Kt(n).resolveInner(c, -1), f;
    if ((h.name == "TagName" || h.name == "StartTag") && (h = h.parent), i == ">" && h.name == "OpenTag") {
      if (((l = (s = h.parent) === null || s === void 0 ? void 0 : s.lastChild) === null || l === void 0 ? void 0 : l.name) != "CloseTag" && (f = Ff(n.doc, h.parent, c)))
        return { range: Z.cursor(c + 1), changes: { from: c, insert: `></${f}>` } };
    } else if (i == "/" && h.name == "OpenTag") {
      let d = h.parent, p = d == null ? void 0 : d.parent;
      if (d.from == c - 1 && ((u = p.lastChild) === null || u === void 0 ? void 0 : u.name) != "CloseTag" && (f = Ff(n.doc, p, c))) {
        let g = `/${f}>`;
        return { range: Z.cursor(c + g.length), changes: { from: c, insert: g } };
      }
    }
    return { range: o };
  });
  return a.changes.empty ? !1 : (r.dispatch(a, { userEvent: "input.type", scrollIntoView: !0 }), !0);
}), QMe = ql({
  String: A.string,
  Number: A.number,
  "True False": A.bool,
  PropertyName: A.propertyName,
  Null: A.null,
  ",": A.separator,
  "[ ]": A.squareBracket,
  "{ }": A.brace
}), UMe = No.deserialize({
  version: 14,
  states: "$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j",
  stateData: "#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O",
  goto: "!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R",
  nodeNames: " JsonText True False Null Number String } { Object Property PropertyName ] [ Array",
  maxTerm: 25,
  nodeProps: [
    ["openedBy", 7, "{", 12, "["],
    ["closedBy", 8, "}", 13, "]"]
  ],
  propSources: [QMe],
  skippedNodes: [0],
  repeatNodeCount: 2,
  tokenData: "(|~RaXY!WYZ!W]^!Wpq!Wrs!]|}$u}!O$z!Q!R%T!R![&c![!]&t!}#O&y#P#Q'O#Y#Z'T#b#c'r#h#i(Z#o#p(r#q#r(w~!]Oc~~!`Wpq!]qr!]rs!xs#O!]#O#P!}#P;'S!];'S;=`$o<%lO!]~!}Oe~~#QXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#m~#pR!Q![#y!c!i#y#T#Z#y~#|R!Q![$V!c!i$V#T#Z$V~$YR!Q![$c!c!i$c#T#Z$c~$fR!Q![!]!c!i!]#T#Z!]~$rP;=`<%l!]~$zOh~~$}Q!Q!R%T!R![&c~%YRT~!O!P%c!g!h%w#X#Y%w~%fP!Q![%i~%nRT~!Q![%i!g!h%w#X#Y%w~%zR{|&T}!O&T!Q![&Z~&WP!Q![&Z~&`PT~!Q![&Z~&hST~!O!P%c!Q![&c!g!h%w#X#Y%w~&yOg~~'OO]~~'TO[~~'WP#T#U'Z~'^P#`#a'a~'dP#g#h'g~'jP#X#Y'm~'rOR~~'uP#i#j'x~'{P#`#a(O~(RP#`#a(U~(ZOS~~(^P#f#g(a~(dP#i#j(g~(jP#X#Y(m~(rOQ~~(wOW~~(|OV~",
  tokenizers: [0],
  topRules: { JsonText: [0, 1] },
  tokenPrec: 0
}), $Me = /* @__PURE__ */ wo.define({
  parser: /* @__PURE__ */ UMe.configure({
    props: [
      /* @__PURE__ */ jl.add({
        Object: /* @__PURE__ */ mo({ except: /^\s*\}/ }),
        Array: /* @__PURE__ */ mo({ except: /^\s*\]/ })
      }),
      /* @__PURE__ */ Kl.add({
        "Object Array": Wv
      })
    ]
  }),
  languageData: {
    closeBrackets: { brackets: ["[", "{", '"'] },
    indentOnInput: /^\s*[\}\]]$/
  }
});
function VMe() {
  return new ih($Me);
}
const GMe = 34, NB = 1, BMe = 2, GA = 3, Qm = 4, FMe = 5, XMe = 6, YMe = 7, HMe = 8, WMe = 9, zMe = 10, ZMe = 11, qMe = 12, jMe = 13, KMe = 14, JMe = 15, eke = 16, tke = 17, rke = 18, ike = 19, cq = 20, hq = 21, nke = 22;
function vw(r) {
  return r >= 65 && r <= 90 || r >= 97 && r <= 122 || r >= 48 && r <= 57;
}
function ake(r) {
  return r >= 48 && r <= 57 || r >= 97 && r <= 102 || r >= 65 && r <= 70;
}
function Fh(r, e, t) {
  for (let i = !1; ; ) {
    if (r.next < 0)
      return;
    if (r.next == e && !i) {
      r.advance();
      return;
    }
    i = t && !i && r.next == 92, r.advance();
  }
}
function fq(r, e) {
  for (; !(r.next != 95 && !vw(r.next)); )
    e != null && (e += String.fromCharCode(r.next)), r.advance();
  return e;
}
function oke(r) {
  if (r.next == 39 || r.next == 34 || r.next == 96) {
    let e = r.next;
    r.advance(), Fh(r, e, !1);
  } else
    fq(r);
}
function xB(r, e) {
  for (; ; ) {
    if (r.next == 46) {
      if (e)
        break;
      e = !0;
    } else if (r.next < 48 || r.next > 57)
      break;
    r.advance();
  }
  if (r.next == 69 || r.next == 101)
    for (r.advance(), (r.next == 43 || r.next == 45) && r.advance(); r.next >= 48 && r.next <= 57; )
      r.advance();
}
function PB(r) {
  for (; !(r.next < 0 || r.next == 10); )
    r.advance();
}
function Lh(r, e) {
  for (let t = 0; t < e.length; t++)
    if (e.charCodeAt(t) == r)
      return !0;
  return !1;
}
const LB = ` 	\r
`;
function dq(r, e, t) {
  let i = /* @__PURE__ */ Object.create(null);
  i.true = i.false = FMe, i.null = i.unknown = XMe;
  for (let n of r.split(" "))
    n && (i[n] = cq);
  for (let n of e.split(" "))
    n && (i[n] = hq);
  for (let n of (t || "").split(" "))
    n && (i[n] = nke);
  return i;
}
const ske = "array binary bit boolean char character clob date decimal double float int integer interval large national nchar nclob numeric object precision real smallint time timestamp varchar varying ", lke = "absolute action add after all allocate alter and any are as asc assertion at authorization before begin between both breadth by call cascade cascaded case cast catalog check close collate collation column commit condition connect connection constraint constraints constructor continue corresponding count create cross cube current current_date current_default_transform_group current_transform_group_for_type current_path current_role current_time current_timestamp current_user cursor cycle data day deallocate declare default deferrable deferred delete depth deref desc describe descriptor deterministic diagnostics disconnect distinct do domain drop dynamic each else elseif end end-exec equals escape except exception exec execute exists exit external fetch first for foreign found from free full function general get global go goto grant group grouping handle having hold hour identity if immediate in indicator initially inner inout input insert intersect into is isolation join key language last lateral leading leave left level like limit local localtime localtimestamp locator loop map match method minute modifies module month names natural nesting new next no none not of old on only open option or order ordinality out outer output overlaps pad parameter partial path prepare preserve primary prior privileges procedure public read reads recursive redo ref references referencing relative release repeat resignal restrict result return returns revoke right role rollback rollup routine row rows savepoint schema scroll search second section select session session_user set sets signal similar size some space specific specifictype sql sqlexception sqlstate sqlwarning start state static system_user table temporary then timezone_hour timezone_minute to trailing transaction translation treat trigger under undo union unique unnest until update usage user using value values view when whenever where while with without work write year zone ", Ow = {
  backslashEscapes: !1,
  hashComments: !1,
  spaceAfterDashes: !1,
  slashComments: !1,
  doubleQuotedStrings: !1,
  charSetCasts: !1,
  operatorChars: "*+-%<>!=&|~^/",
  specialVar: "?",
  identifierQuotes: '"',
  words: /* @__PURE__ */ dq(lke, ske)
};
function uke(r, e, t, i) {
  let n = {};
  for (let a in Ow)
    n[a] = (r.hasOwnProperty(a) ? r : Ow)[a];
  return e && (n.words = dq(e, t || "", i)), n;
}
function pq(r) {
  return new Vi((e) => {
    var t;
    let { next: i } = e;
    if (e.advance(), Lh(i, LB)) {
      for (; Lh(e.next, LB); )
        e.advance();
      e.acceptToken(GMe);
    } else if (i == 39 || i == 34 && r.doubleQuotedStrings)
      Fh(e, i, r.backslashEscapes), e.acceptToken(GA);
    else if (i == 35 && r.hashComments || i == 47 && e.next == 47 && r.slashComments)
      PB(e), e.acceptToken(NB);
    else if (i == 45 && e.next == 45 && (!r.spaceAfterDashes || e.peek(2) == 32))
      PB(e), e.acceptToken(NB);
    else if (i == 47 && e.next == 42) {
      e.advance();
      for (let n = -1, a = 1; !(e.next < 0); )
        if (e.advance(), n == 42 && e.next == 47) {
          if (a--, !a) {
            e.advance();
            break;
          }
          n = -1;
        } else
          n == 47 && e.next == 42 ? (a++, n = -1) : n = e.next;
      e.acceptToken(BMe);
    } else if ((i == 101 || i == 69) && e.next == 39)
      e.advance(), Fh(e, 39, !0);
    else if ((i == 110 || i == 78) && e.next == 39 && r.charSetCasts)
      e.advance(), Fh(e, 39, r.backslashEscapes), e.acceptToken(GA);
    else if (i == 95 && r.charSetCasts)
      for (let n = 0; ; n++) {
        if (e.next == 39 && n > 1) {
          e.advance(), Fh(e, 39, r.backslashEscapes), e.acceptToken(GA);
          break;
        }
        if (!vw(e.next))
          break;
        e.advance();
      }
    else if (i == 40)
      e.acceptToken(YMe);
    else if (i == 41)
      e.acceptToken(HMe);
    else if (i == 123)
      e.acceptToken(WMe);
    else if (i == 125)
      e.acceptToken(zMe);
    else if (i == 91)
      e.acceptToken(ZMe);
    else if (i == 93)
      e.acceptToken(qMe);
    else if (i == 59)
      e.acceptToken(jMe);
    else if (i == 48 && (e.next == 98 || e.next == 66) || (i == 98 || i == 66) && e.next == 39) {
      let n = e.next == 39;
      for (e.advance(); e.next == 48 || e.next == 49; )
        e.advance();
      n && e.next == 39 && e.advance(), e.acceptToken(Qm);
    } else if (i == 48 && (e.next == 120 || e.next == 88) || (i == 120 || i == 88) && e.next == 39) {
      let n = e.next == 39;
      for (e.advance(); ake(e.next); )
        e.advance();
      n && e.next == 39 && e.advance(), e.acceptToken(Qm);
    } else if (i == 46 && e.next >= 48 && e.next <= 57)
      xB(e, !0), e.acceptToken(Qm);
    else if (i == 46)
      e.acceptToken(KMe);
    else if (i >= 48 && i <= 57)
      xB(e, !1), e.acceptToken(Qm);
    else if (Lh(i, r.operatorChars)) {
      for (; Lh(e.next, r.operatorChars); )
        e.advance();
      e.acceptToken(JMe);
    } else if (Lh(i, r.specialVar))
      e.next == i && e.advance(), oke(e), e.acceptToken(tke);
    else if (Lh(i, r.identifierQuotes))
      Fh(e, i, !1), e.acceptToken(ike);
    else if (i == 58 || i == 44)
      e.acceptToken(eke);
    else if (vw(i)) {
      let n = fq(e, String.fromCharCode(i));
      e.acceptToken((t = r.words[n.toLowerCase()]) !== null && t !== void 0 ? t : rke);
    }
  });
}
const gq = /* @__PURE__ */ pq(Ow), cke = /* @__PURE__ */ No.deserialize({
  version: 14,
  states: "%dQ]QQOOO#kQRO'#DQO#rQQO'#CuO%RQQO'#CvO%YQQO'#CwO%aQQO'#CxOOQQ'#DQ'#DQOOQQ'#C{'#C{O&lQRO'#CyOOQQ'#Ct'#CtOOQQ'#Cz'#CzQ]QQOOQOQQOOO&vQQO,59aO'RQQO,59aO'WQQO'#DQOOQQ,59b,59bO'eQQO,59bOOQQ,59c,59cO'lQQO,59cOOQQ,59d,59dO'sQQO,59dOOQQ-E6y-E6yOOQQ,59`,59`OOQQ-E6x-E6xOOQQ'#C|'#C|OOQQ1G.{1G.{O&vQQO1G.{OOQQ1G.|1G.|OOQQ1G.}1G.}OOQQ1G/O1G/OP'zQQO'#C{POQQ-E6z-E6zOOQQ7+$g7+$g",
  stateData: "(R~OrOSPOSQOS~ORUOSUOTUOUUOVROXSOZTO]XO^QO_UO`UOaPObPOcPOdUOeUOfUO~O^]ORtXStXTtXUtXVtXXtXZtX]tX_tX`tXatXbtXctXdtXetXftX~OqtX~P!dOa^Ob^Oc^O~ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOa_Ob_Oc_OdUOeUOfUO~OW`O~P#}OYbO~P#}O[dO~P#}ORUOSUOTUOUUOVROXSOZTO^QO_UO`UOaPObPOcPOdUOeUOfUO~O]gOqmX~P%hOaiObiOciO~O^kO~OWtXYtX[tX~P!dOWlO~P#}OYmO~P#}O[nO~P#}O]gO~P#}O",
  goto: "#YuPPPPPPPPPPPPPPPPPPPPPPPPvzzzz!W![!b!vPPP!|TYOZeUORSTWZaceoT[OZQZORhZSWOZQaRQcSQeTZfWaceoQj]RqkeVORSTWZaceo",
  nodeNames: " LineComment BlockComment String Number Bool Null ( ) [ ] { } ; . Operator Punctuation SpecialVar Identifier QuotedIdentifier Keyword Type Builtin Script Statement CompositeIdentifier Parens Braces Brackets Statement",
  maxTerm: 36,
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 3,
  tokenData: "RORO",
  tokenizers: [0, gq],
  topRules: { Script: [0, 23] },
  tokenPrec: 0
});
function mw(r) {
  let e = r.cursor().moveTo(r.from, -1);
  for (; /Comment/.test(e.name); )
    e.moveTo(e.from, -1);
  return e.node;
}
function hke(r) {
  let e = /^[`'"](.*)[`'"]$/.exec(r);
  return e ? e[1] : r;
}
function fke(r, e) {
  return e.name == "Identifier" || e.name == "QuotedIdentifier" || e.name == "Keyword" && /^public$/i.test(r.sliceDoc(e.from, e.to));
}
function DB(r, e) {
  for (let t = []; ; ) {
    if (!e || e.name != ".")
      return t;
    let i = mw(e);
    if (!i || !fke(r, i))
      return t;
    t.unshift(hke(r.sliceDoc(i.from, i.to))), e = mw(i);
  }
}
function dke(r, e) {
  let t = Kt(r).resolveInner(e, -1);
  return t.name == "Identifier" || t.name == "QuotedIdentifier" ? {
    from: t.from,
    quoted: t.name == "QuotedIdentifier" ? r.sliceDoc(t.from, t.from + 1) : null,
    parents: DB(r, mw(t))
  } : t.name == "." ? {
    from: e,
    quoted: null,
    parents: DB(r, t)
  } : { from: e, quoted: null, parents: [], empty: !0 };
}
function pke(r, e) {
  return r ? e.map((t) => Object.assign(Object.assign({}, t), { label: r + t.label + r, apply: void 0 })) : e;
}
const gke = /^\w*$/, vke = /^[`'"]?\w*[`'"]?$/;
class CP {
  constructor() {
    this.list = [], this.children = void 0;
  }
  child(e) {
    let t = this.children || (this.children = /* @__PURE__ */ Object.create(null));
    return t[e] || (t[e] = new CP());
  }
  childCompletions(e) {
    return this.children ? Object.keys(this.children).filter((t) => t).map((t) => ({ label: t, type: e })) : [];
  }
}
function Oke(r, e, t, i) {
  let n = new CP(), a = n.child(i || "");
  for (let o in r) {
    let s = o.indexOf("."), u = (s > -1 ? n.child(o.slice(0, s)) : a).child(s > -1 ? o.slice(s + 1) : o);
    u.list = r[o].map((c) => typeof c == "string" ? { label: c, type: "property" } : c);
  }
  a.list = (e || a.childCompletions("type")).concat(t ? a.child(t).list : []);
  for (let o in n.children) {
    let s = n.child(o);
    s.list.length || (s.list = s.childCompletions("type"));
  }
  return n.list = a.list.concat(n.childCompletions("type")), (o) => {
    let { parents: s, from: l, quoted: u, empty: c } = dke(o.state, o.pos);
    if (c && !o.explicit)
      return null;
    let h = n;
    for (let d of s) {
      for (; !h.children || !h.children[d]; )
        if (h == n)
          h = a;
        else if (h == a && t)
          h = h.child(t);
        else
          return null;
      h = h.child(d);
    }
    let f = u && o.state.sliceDoc(o.pos, o.pos + 1) == u;
    return {
      from: l,
      to: f ? o.pos + 1 : void 0,
      options: pke(u, h.list),
      validFor: u ? vke : gke
    };
  };
}
function mke(r, e) {
  let t = Object.keys(r).map((i) => ({
    label: e ? i.toUpperCase() : i,
    type: r[i] == hq ? "type" : r[i] == cq ? "keyword" : "variable",
    boost: -1
  }));
  return vP(["QuotedIdentifier", "SpecialVar", "String", "LineComment", "BlockComment", "."], uy(t));
}
let Eke = /* @__PURE__ */ cke.configure({
  props: [
    /* @__PURE__ */ jl.add({
      Statement: /* @__PURE__ */ mo()
    }),
    /* @__PURE__ */ Kl.add({
      Statement(r) {
        return { from: r.firstChild.to, to: r.to };
      },
      BlockComment(r) {
        return { from: r.from + 2, to: r.to - 2 };
      }
    }),
    /* @__PURE__ */ ql({
      Keyword: A.keyword,
      Type: A.typeName,
      Builtin: /* @__PURE__ */ A.standard(A.name),
      Bool: A.bool,
      Null: A.null,
      Number: A.number,
      String: A.string,
      Identifier: A.name,
      QuotedIdentifier: /* @__PURE__ */ A.special(A.string),
      SpecialVar: /* @__PURE__ */ A.special(A.name),
      LineComment: A.lineComment,
      BlockComment: A.blockComment,
      Operator: A.operator,
      "Semi Punctuation": A.punctuation,
      "( )": A.paren,
      "{ }": A.brace,
      "[ ]": A.squareBracket
    })
  ]
});
class IP {
  constructor(e, t) {
    this.dialect = e, this.language = t;
  }
  /**
  Returns the language for this dialect as an extension.
  */
  get extension() {
    return this.language.extension;
  }
  /**
  Define a new dialect.
  */
  static define(e) {
    let t = uke(e, e.keywords, e.types, e.builtin), i = wo.define({
      parser: Eke.configure({
        tokenizers: [{ from: gq, to: pq(t) }]
      }),
      languageData: {
        commentTokens: { line: "--", block: { open: "/*", close: "*/" } },
        closeBrackets: { brackets: ["(", "[", "{", "'", '"', "`"] }
      }
    });
    return new IP(t, i);
  }
}
function bke(r, e = !1) {
  return mke(r.dialect.words, e);
}
function Ske(r, e = !1) {
  return r.language.data.of({
    autocomplete: bke(r, e)
  });
}
function Tke(r) {
  return r.schema ? Oke(r.schema, r.tables, r.defaultTable, r.defaultSchema) : () => null;
}
function yke(r) {
  return r.schema ? (r.dialect || vq).language.data.of({
    autocomplete: Tke(r)
  }) : [];
}
function Rke(r = {}) {
  let e = r.dialect || vq;
  return new ih(e.language, [yke(r), Ske(e, !!r.upperCaseKeywords)]);
}
const vq = /* @__PURE__ */ IP.define({}), Ake = 1, Oq = 196, mq = 197, _ke = 198, MB = 199, Cke = 200, Ike = 201, wke = 202, Nke = 2, xke = 203, Pke = 204, Lke = 3, Dke = 205, Mke = 206, kke = 4, Qke = 207, Uke = 208, $ke = 5, Vke = 209, Gke = 26, Bke = 27, Fke = 51, Xke = 52, Yke = 57, Hke = 58, Wke = 59, zke = 61, Zke = 62, qke = 63, jke = 64, Kke = 65, Jke = 67, eQe = 246, tQe = 74, rQe = 265, iQe = 129, nQe = 150, aQe = 151, oQe = 154, fv = 10, dv = 13, wP = 32, py = 9, NP = 35, sQe = 40, lQe = 46, kB = 123, Eq = 39, bq = 34, uQe = 92, cQe = /* @__PURE__ */ new Set([
  Bke,
  Fke,
  Xke,
  rQe,
  Jke,
  iQe,
  Hke,
  Wke,
  eQe,
  jke,
  Kke,
  tQe,
  Zke,
  qke,
  nQe,
  aQe,
  oQe
]);
function BA(r) {
  return r == fv || r == dv;
}
const hQe = new Vi((r, e) => {
  let t;
  if (r.next < 0)
    r.acceptToken(Ike);
  else if (e.context.depth < 0)
    BA(r.next) && r.acceptToken(Cke, 1);
  else if (((t = r.peek(-1)) < 0 || BA(t)) && e.canShift(MB)) {
    let i = 0;
    for (; r.next == wP || r.next == py; )
      r.advance(), i++;
    (r.next == fv || r.next == dv || r.next == NP) && r.acceptToken(MB, -i);
  } else
    BA(r.next) && r.acceptToken(_ke, 1);
}, { contextual: !0 }), fQe = new Vi((r, e) => {
  let t = e.context.depth;
  if (t < 0)
    return;
  let i = r.peek(-1);
  if (i == fv || i == dv) {
    let n = 0, a = 0;
    for (; ; ) {
      if (r.next == wP)
        n++;
      else if (r.next == py)
        n += 8 - n % 8;
      else
        break;
      r.advance(), a++;
    }
    n != t && r.next != fv && r.next != dv && r.next != NP && (n < t ? r.acceptToken(mq, -a) : r.acceptToken(Oq));
  }
});
function Ew(r, e) {
  this.parent = r, this.depth = e, this.hash = (r ? r.hash + r.hash << 8 : 0) + e + (e << 4);
}
const dQe = new Ew(null, 0);
function pQe(r) {
  let e = 0;
  for (let t = 0; t < r.length; t++)
    e += r.charCodeAt(t) == py ? 8 - e % 8 : 1;
  return e;
}
const gQe = new yP({
  start: dQe,
  reduce(r, e) {
    return r.depth < 0 && cQe.has(e) ? r.parent : r;
  },
  shift(r, e, t, i) {
    return e == Oq ? new Ew(r, pQe(i.read(i.pos, t.pos))) : e == mq ? r.parent : e == Gke || e == Yke || e == zke ? new Ew(r, -1) : r;
  },
  hash(r) {
    return r.hash;
  }
}), vQe = new Vi((r) => {
  for (let e = 0; e < 5; e++) {
    if (r.next != "print".charCodeAt(e))
      return;
    r.advance();
  }
  if (!/\w/.test(String.fromCharCode(r.next)))
    for (let e = 0; ; e++) {
      let t = r.peek(e);
      if (!(t == wP || t == py)) {
        t != sQe && t != lQe && t != fv && t != dv && t != NP && r.acceptToken(Ake);
        return;
      }
    }
});
function gy(r, e, t, i, n) {
  return new Vi((a) => {
    let o = a.pos;
    for (; !(a.next < 0); )
      if (a.next == kB)
        if (a.peek(1) == kB)
          a.advance(2);
        else {
          if (a.pos == o) {
            a.acceptToken(i, 1);
            return;
          }
          break;
        }
      else if (a.next == uQe)
        a.advance(), a.next >= 0 && a.advance();
      else if (a.next == r && (e == 1 || a.peek(1) == r && a.peek(2) == r)) {
        if (a.pos == o) {
          a.acceptToken(n, e);
          return;
        }
        break;
      } else
        a.advance();
    a.pos > o && a.acceptToken(t);
  });
}
const OQe = gy(Eq, 1, wke, Nke, xke), mQe = gy(bq, 1, Pke, Lke, Dke), EQe = gy(Eq, 3, Mke, kke, Qke), bQe = gy(bq, 3, Uke, $ke, Vke), SQe = ql({
  'async "*" "**" FormatConversion FormatSpec': A.modifier,
  "for while if elif else try except finally return raise break continue with pass assert await yield match case": A.controlKeyword,
  "in not and or is del": A.operatorKeyword,
  "from def class global nonlocal lambda": A.definitionKeyword,
  import: A.moduleKeyword,
  "with as print": A.keyword,
  Boolean: A.bool,
  None: A.null,
  VariableName: A.variableName,
  "CallExpression/VariableName": A.function(A.variableName),
  "FunctionDefinition/VariableName": A.function(A.definition(A.variableName)),
  "ClassDefinition/VariableName": A.definition(A.className),
  PropertyName: A.propertyName,
  "CallExpression/MemberExpression/PropertyName": A.function(A.propertyName),
  Comment: A.lineComment,
  Number: A.number,
  String: A.string,
  FormatString: A.special(A.string),
  UpdateOp: A.updateOperator,
  "ArithOp!": A.arithmeticOperator,
  BitOp: A.bitwiseOperator,
  CompareOp: A.compareOperator,
  AssignOp: A.definitionOperator,
  Ellipsis: A.punctuation,
  At: A.meta,
  "( )": A.paren,
  "[ ]": A.squareBracket,
  "{ }": A.brace,
  ".": A.derefOperator,
  ", ;": A.separator
}), TQe = { __proto__: null, await: 48, or: 58, and: 60, in: 64, not: 66, is: 68, if: 74, else: 76, lambda: 80, yield: 98, from: 100, async: 106, for: 108, None: 168, True: 170, False: 170, del: 184, pass: 188, break: 192, continue: 196, return: 200, raise: 208, import: 212, as: 214, global: 218, nonlocal: 220, assert: 224, elif: 234, while: 238, try: 244, except: 246, finally: 248, with: 252, def: 256, class: 266, match: 277, case: 283 }, yQe = No.deserialize({
  version: 14,
  states: "#!OO`Q#yOOP$_OSOOO%hQ&nO'#H^OOQS'#Cq'#CqOOQS'#Cr'#CrO'WQ#xO'#CpO(yQ&nO'#H]OOQS'#H^'#H^OOQS'#DW'#DWOOQS'#H]'#H]O)gQ#xO'#DaO)zQ#xO'#DhO*[Q#xO'#DlOOQS'#Dw'#DwO*oO,UO'#DwO*wO7[O'#DwO+POWO'#DxO+[O`O'#DxO+gOpO'#DxO+rO!bO'#DxO-tQ&nO'#G}OOQS'#G}'#G}O'WQ#xO'#G|O/WQ&nO'#G|OOQS'#Ee'#EeO/oQ#xO'#EfOOQS'#G{'#G{O/yQ#xO'#GzOOQV'#Gz'#GzO0UQ#xO'#FXOOQS'#G`'#G`O0ZQ#xO'#FWOOQV'#IS'#ISOOQV'#Gy'#GyOOQV'#Fp'#FpQ`Q#yOOO'WQ#xO'#CsO0iQ#xO'#DPO0pQ#xO'#DTO1OQ#xO'#HbO1`Q&nO'#EYO'WQ#xO'#EZOOQS'#E]'#E]OOQS'#E_'#E_OOQS'#Ea'#EaO1tQ#xO'#EcO2[Q#xO'#EgO0UQ#xO'#EiO2oQ&nO'#EiO0UQ#xO'#ElO/oQ#xO'#EoO/oQ#xO'#EsO/oQ#xO'#EvO2zQ#xO'#ExO3RQ#xO'#E}O3^Q#xO'#EyO/oQ#xO'#E}O0UQ#xO'#FPO0UQ#xO'#FUO3cQ#xO'#FZP3jO#xO'#GxPOOO)CBl)CBlOOQS'#Cg'#CgOOQS'#Ch'#ChOOQS'#Ci'#CiOOQS'#Cj'#CjOOQS'#Ck'#CkOOQS'#Cl'#ClOOQS'#Cn'#CnO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO'WQ#xO,59QO3uQ#xO'#DqOOQS,5:[,5:[O4YQ#xO'#HlOOQS,5:_,5:_O4gQMlO,5:_O4lQ&nO,59[O0iQ#xO,59dO0iQ#xO,59dO0iQ#xO,59dO7[Q#xO,59dO7aQ#xO,59dO7hQ#xO,59lO7oQ#xO'#H]O8uQ#xO'#H[OOQS'#H['#H[OOQS'#D^'#D^O9^Q#xO,59cO'WQ#xO,59cO9lQ#xO,59cOOQS,59{,59{O9qQ#xO,5:TO'WQ#xO,5:TOOQS,5:S,5:SO:PQ#xO,5:SO:UQ#xO,5:ZO'WQ#xO,5:ZO'WQ#xO,5:XOOQS,5:W,5:WO:gQ#xO,5:WO:lQ#xO,5:YOOOO'#Fx'#FxO:qO,UO,5:cOOQS,5:c,5:cOOOO'#Fy'#FyO:yO7[O,5:cO;RQ#xO'#DyOOOW'#Fz'#FzO;cOWO,5:dOOQS,5:d,5:dO;RQ#xO'#D}OOO`'#F}'#F}O;nO`O,5:dO;RQ#xO'#EOOOOp'#GO'#GOO;yOpO,5:dO;RQ#xO'#EPOOO!b'#GP'#GPO<UO!bO,5:dOOQS'#GQ'#GQO<aQ&nO,5:lO?RQ&nO,5=hO?lQ!LUO,5=hO@]Q&nO,5=hOOQS,5;Q,5;QO@tQ#yO'#GYOBTQ#xO,5;]OOQV,5=f,5=fOB`Q&nO'#IOOBwQ#xO,5;sOOQS-E:^-E:^OOQV,5;r,5;rO3XQ#xO'#FPOOQV-E9n-E9nOCPQ&nO,59_OEWQ&nO,59kOEqQ#xO'#H_OE|Q#xO'#H_O0UQ#xO'#H_OFXQ#xO'#DVOFaQ#xO,59oOFfQ#xO'#HcO'WQ#xO'#HcO/oQ#xO,5=|OOQS,5=|,5=|O/oQ#xO'#EUOOQS'#EV'#EVOGTQ#xO'#GSOGeQ#xO,59OOGeQ#xO,59OO)mQ#xO,5:rOGsQ&nO'#HeOOQS,5:u,5:uOOQS,5:},5:}OHWQ#xO,5;ROHiQ#xO,5;TOOQS'#GV'#GVOHwQ&nO,5;TOIVQ#xO,5;TOI[Q#xO'#IROOQS,5;W,5;WOIjQ#xO'#H}OOQS,5;Z,5;ZO3^Q#xO,5;_O3^Q#xO,5;bOI{Q&nO'#ITO'WQ#xO'#ITOJVQ#xO,5;dO2zQ#xO,5;dO/oQ#xO,5;iO0UQ#xO,5;kOJ[Q#yO'#EtOKeQ#{O,5;eONvQ#xO'#IUO3^Q#xO,5;iO! RQ#xO,5;kO! WQ#xO,5;pO! `Q&nO,5;uO'WQ#xO,5;uPOOO,5=d,5=dP! gOSO,5=dP! lO#xO,5=dO!$aQ&nO1G.lO!$hQ&nO1G.lO!'XQ&nO1G.lO!'cQ&nO1G.lO!)|Q&nO1G.lO!*aQ&nO1G.lO!*tQ#xO'#HkO!+SQ&nO'#G}O/oQ#xO'#HkO!+^Q#xO'#HjOOQS,5:],5:]O!+fQ#xO,5:]O!+kQ#xO'#HmO!+vQ#xO'#HmO!,ZQ#xO,5>WOOQS'#Du'#DuOOQS1G/y1G/yOOQS1G/O1G/OO!-ZQ&nO1G/OO!-bQ&nO1G/OO0iQ#xO1G/OO!-}Q#xO1G/WOOQS'#D]'#D]O/oQ#xO,59vOOQS1G.}1G.}O!.UQ#xO1G/gO!.fQ#xO1G/gO!.nQ#xO1G/hO'WQ#xO'#HdO!.sQ#xO'#HdO!.xQ&nO1G.}O!/YQ#xO,59kO!0`Q#xO,5>SO!0pQ#xO,5>SO!0xQ#xO1G/oO!0}Q&nO1G/oOOQS1G/n1G/nO!1_Q#xO,5=}O!2UQ#xO,5=}O/oQ#xO1G/sO!2sQ#xO1G/uO!2xQ&nO1G/uO!3YQ&nO1G/sOOQS1G/r1G/rOOQS1G/t1G/tOOOO-E9v-E9vOOQS1G/}1G/}OOOO-E9w-E9wO!3jQ#xO'#HwO/oQ#xO'#HwO!3xQ#xO,5:eOOOW-E9x-E9xOOQS1G0O1G0OO!4TQ#xO,5:iOOO`-E9{-E9{O!4`Q#xO,5:jOOOp-E9|-E9|O!4kQ#xO,5:kOOO!b-E9}-E9}OOQS-E:O-E:OO!4vQ!LUO1G3SO!5gQ&nO1G3SO'WQ#xO,5<mOOQS,5<m,5<mOOQS-E:P-E:POOQS,5<t,5<tOOQS-E:W-E:WOOQV1G0w1G0wO0UQ#xO'#GUO!6OQ&nO,5>jOOQS1G1_1G1_O!6gQ#xO1G1_OOQS'#DX'#DXO/oQ#xO,5=yOOQS,5=y,5=yO!6lQ#xO'#FqO!6wQ#xO,59qO!7PQ#xO1G/ZO!7ZQ&nO,5=}OOQS1G3h1G3hOOQS,5:p,5:pO!7zQ#xO'#G|OOQS,5<n,5<nOOQS-E:Q-E:QO!8]Q#xO1G.jOOQS1G0^1G0^O!8kQ#xO,5>PO!8{Q#xO,5>PO/oQ#xO1G0mO/oQ#xO1G0mO0UQ#xO1G0oOOQS-E:T-E:TO!9^Q#xO1G0oO!9iQ#xO1G0oO!9nQ#xO,5>mO!9|Q#xO,5>mO!:[Q#xO,5>iO!:rQ#xO,5>iO!;TQ#{O1G0yO!>cQ#{O1G0|O!AnQ#xO,5>oO!AxQ#xO,5>oO!BQQ&nO,5>oO/oQ#xO1G1OO!B[Q#xO1G1OO3^Q#xO1G1TO! RQ#xO1G1VOOQV,5;`,5;`O!BaQ#zO,5;`O!BfQ#{O1G1PO!EwQ#xO'#G]O3^Q#xO1G1PO3^Q#xO1G1PO!FUQ#xO,5>pO!FcQ#xO,5>pO0UQ#xO,5>pOOQV1G1T1G1TO!FkQ#xO'#FRO!F|QMlO1G1VOOQV1G1[1G1[O3^Q#xO1G1[O!GUQ#xO'#F]OOQV1G1a1G1aO! `Q&nO1G1aPOOO1G3O1G3OP!GZOSO1G3OOOQS,5>V,5>VOOQS'#Dr'#DrO/oQ#xO,5>VO!G`Q#xO,5>UO!GsQ#xO,5>UOOQS1G/w1G/wO!G{Q#xO,5>XO!H]Q#xO,5>XO!HeQ#xO,5>XO!HxQ#xO,5>XO!IYQ#xO,5>XOOQS1G3r1G3rOOQS7+$j7+$jO!7PQ#xO7+$rO!J{Q#xO1G/OO!KSQ#xO1G/OOOQS1G/b1G/bOOQS,5<_,5<_O'WQ#xO,5<_OOQS7+%R7+%RO!KZQ#xO7+%ROOQS-E9q-E9qOOQS7+%S7+%SO!KkQ#xO,5>OO'WQ#xO,5>OOOQS7+$i7+$iO!KpQ#xO7+%RO!KxQ#xO7+%SO!K}Q#xO1G3nOOQS7+%Z7+%ZO!L_Q#xO1G3nO!LgQ#xO7+%ZOOQS,5<^,5<^O'WQ#xO,5<^O!LlQ#xO1G3iOOQS-E9p-E9pO!McQ#xO7+%_OOQS7+%a7+%aO!MqQ#xO1G3iO!N`Q#xO7+%aO!NeQ#xO1G3oO!NuQ#xO1G3oO!N}Q#xO7+%_O# SQ#xO,5>cO# jQ#xO,5>cO# jQ#xO,5>cO# xO$ISO'#D{O#!TO#tO'#HxOOOW1G0P1G0PO#!YQ#xO1G0POOO`1G0T1G0TO#!bQ#xO1G0TOOOp1G0U1G0UO#!jQ#xO1G0UOOO!b1G0V1G0VO#!rQ#xO1G0VO#!zQ!LUO7+(nO##kQ&nO1G2XP#$UQ#xO'#GROOQS,5<p,5<pOOQS-E:S-E:SOOQS7+&y7+&yOOQS1G3e1G3eOOQS,5<],5<]OOQS-E9o-E9oOOQS7+$u7+$uO#$cQ#xO,5=hO#$|Q#xO,5=hO#%_Q&nO,5<`O#%rQ#xO1G3kOOQS-E9r-E9rOOQS7+&X7+&XO#&SQ#xO7+&XOOQS7+&Z7+&ZO#&bQ#xO'#IQO0UQ#xO'#IPO#&vQ#xO7+&ZOOQS,5<s,5<sO#'RQ#xO1G4XOOQS-E:V-E:VOOQS,5<o,5<oO#'aQ#xO1G4TOOQS-E:R-E:RO#'wQ#{O7+&eO!EwQ#xO'#GZO3^Q#xO7+&eO3^Q#xO7+&hO#+VQ&nO,5<vO'WQ#xO,5<vO#+aQ#xO1G4ZOOQS-E:Y-E:YO#+kQ#xO1G4ZO3^Q#xO7+&jO/oQ#xO7+&jOOQV7+&o7+&oO!F|QMlO7+&qO`Q#yO1G0zOOQV-E:Z-E:ZO3^Q#xO7+&kO3^Q#xO7+&kOOQV,5<w,5<wO#+sQ#xO,5<wOOQV7+&k7+&kO#,OQ#{O7+&kO#/ZQ#xO,5<xO#/fQ#xO1G4[OOQS-E:[-E:[O#/sQ#xO1G4[O#/{Q#xO'#IWO#0ZQ#xO'#IWO0UQ#xO'#IWOOQS'#IW'#IWO#0fQ#xO'#IVOOQS,5;m,5;mO#0nQ#xO,5;mO/oQ#xO'#FTOOQV7+&q7+&qO3^Q#xO7+&qOOQV7+&v7+&vO#0sQ#zO,5;wOOQV7+&{7+&{POOO7+(j7+(jOOQS1G3q1G3qOOQS,5<b,5<bO#0xQ#xO1G3pOOQS-E9t-E9tO#1]Q#xO,5<cO#1hQ#xO,5<cO#1{Q#xO1G3sOOQS-E9u-E9uO#2]Q#xO1G3sO#2eQ#xO1G3sO#2uQ#xO1G3sO#2]Q#xO1G3sOOQS<<H^<<H^O#3QQ&nO1G1yOOQS<<Hm<<HmP#3_Q#xO'#FsO7hQ#xO1G3jO#3lQ#xO1G3jO#3qQ#xO<<HmOOQS<<Hn<<HnO#4RQ#xO7+)YOOQS<<Hu<<HuO#4cQ&nO1G1xP#5SQ#xO'#FrO#5aQ#xO7+)ZO#5qQ#xO7+)ZO#5yQ#xO<<HyO#6OQ#xO7+)TOOQS<<H{<<H{O#6uQ#xO,5<aO'WQ#xO,5<aOOQS-E9s-E9sOOQS<<Hy<<HyOOQS,5<g,5<gO/oQ#xO,5<gO#6zQ#xO1G3}OOQS-E9y-E9yO#7bQ#xO1G3}O;RQ#xO'#D|OOOO'#F|'#F|O#7pO$ISO,5:gOOO#l,5>d,5>dOOOW7+%k7+%kOOO`7+%o7+%oOOOp7+%p7+%pOOO!b7+%q7+%qO#7{Q#xO1G3SO#8fQ#xO1G3SP'WQ#xO'#FtO/oQ#xO<<IsO#8wQ#xO,5>lO#9YQ#xO,5>lO0UQ#xO,5>lO#9kQ#xO,5>kOOQS<<Iu<<IuP0UQ#xO'#GXP/oQ#xO'#GTOOQV-E:X-E:XO3^Q#xO<<JPOOQV,5<u,5<uO3^Q#xO,5<uOOQV<<JP<<JPOOQV<<JS<<JSO#9pQ&nO1G2bP#9zQ#xO'#G[O#:RQ#xO7+)uO#:]Q#{O<<JUO3^Q#xO<<JUOOQV<<J]<<J]O3^Q#xO<<J]O#=hQ#{O7+&fOOQV<<JV<<JVO#=rQ#{O<<JVOOQV1G2c1G2cO0UQ#xO1G2cO3^Q#xO<<JVO0UQ#xO1G2dP/oQ#xO'#G^O#@}Q#xO7+)vO#A[Q#xO7+)vOOQS'#FS'#FSO/oQ#xO,5>rO#AdQ#xO,5>rOOQS,5>r,5>rO#AoQ#xO,5>qO#BQQ#xO,5>qOOQS1G1X1G1XOOQS,5;o,5;oO#BYQ#xO1G1cP#B_Q#xO'#FvO#BoQ#xO1G1}O#CSQ#xO1G1}O#CdQ#xO1G1}P#CoQ#xO'#FwO#C|Q#xO7+)_O#D^Q#xO7+)_O#D^Q#xO7+)_O#DfQ#xO7+)_O#DvQ#xO7+)UO7hQ#xO7+)UOOQSAN>XAN>XO#EaQ#xO<<LuOOQSAN>eAN>eO/oQ#xO1G1{O#EqQ&nO1G1{P#E{Q#xO'#FuOOQS1G2R1G2RP#FYQ#xO'#F{O#FgQ#xO7+)iO#F}Q#xO,5:hOOOO-E9z-E9zO#GYQ#xO7+(nOOQSAN?_AN?_O#GsQ#xO,5<rO#HXQ#xO1G4WOOQS-E:U-E:UO#HjQ#xO1G4WOOQS1G4V1G4VOOQVAN?kAN?kOOQV1G2a1G2aO3^Q#xOAN?pO#H{Q#{OAN?pOOQVAN?wAN?wOOQV<<JQ<<JQO3^Q#xOAN?qO3^Q#xO7+'}OOQVAN?qAN?qOOQS7+(O7+(OO#LWQ#xO<<MbOOQS1G4^1G4^O/oQ#xO1G4^OOQS,5<y,5<yO#LeQ#xO1G4]OOQS-E:]-E:]OOQU'#Ga'#GaO#LvQ#zO7+&}O#MRQ#xO'#F^O#MyQ#xO7+'iO#NZQ#xO7+'iOOQS7+'i7+'iO#NfQ#xO<<LyO#NvQ#xO<<LyO#NvQ#xO<<LyO$ OQ#xO'#HfOOQS<<Lp<<LpO$ YQ#xO<<LpOOQS7+'g7+'gOOOO1G0S1G0SO$ sQ#xO1G0SO0UQ#xO1G2^P0UQ#xO'#GWO$ {Q#xO7+)rO$!^Q#xO7+)rOOQVG25[G25[O3^Q#xOG25[OOQVG25]G25]OOQV<<Ki<<KiOOQS7+)x7+)xP$!oQ#xO'#G_OOQU-E:_-E:_OOQV<<Ji<<JiO$#cQ&nO'#F`OOQS'#Fb'#FbO$#sQ#xO'#FaO$$eQ#xO'#FaOOQS'#Fa'#FaO$$jQ#xO'#IYO#MRQ#xO'#FhO#MRQ#xO'#FhO$%RQ#xO'#FiO#MRQ#xO'#FjO$%YQ#xO'#IZOOQS'#IZ'#IZO$%wQ#xO,5;xOOQS<<KT<<KTO$&PQ#xO<<KTO$&aQ#xOANBeO$&qQ#xOANBeO$&yQ#xO'#HgOOQS'#Hg'#HgO0pQ#xO'#DeO$'dQ#xO,5>QOOQSANB[ANB[OOOO7+%n7+%nOOQS7+'x7+'xO$'{Q#xO<<M^OOQVLD*vLD*vO4gQMlO'#GcO$(^Q&nO,5<RO#MRQ#xO'#FlOOQS,5<V,5<VOOQS'#Fc'#FcO$)OQ#xO,5;{O$)TQ#xO,5;{OOQS'#Ff'#FfO#MRQ#xO'#GbO$)uQ#xO,5<PO$*aQ#xO,5>tO$*qQ#xO,5>tO0UQ#xO,5<OO$+SQ#xO,5<SO$+XQ#xO,5<SO#MRQ#xO'#I[O$+^Q#xO'#I[O$+cQ#xO,5<TOOQS,5<U,5<UO'WQ#xO'#FoOOQU1G1d1G1dO3^Q#xO1G1dOOQSAN@oAN@oO$+hQ#xOG28PO$+xQ#xO,5:POOQS1G3l1G3lOOQS,5<},5<}OOQS-E:a-E:aO$+}Q&nO'#F`O$,UQ#xO'#I]O$,dQ#xO'#I]O$,lQ#xO,5<WOOQS1G1g1G1gO$,qQ#xO1G1gO$,vQ#xO,5<|OOQS-E:`-E:`O$-bQ#xO,5=QO$-yQ#xO1G4`OOQS-E:d-E:dOOQS1G1j1G1jOOQS1G1n1G1nO$.ZQ#xO,5>vO#MRQ#xO,5>vOOQS1G1o1G1oO$.iQ&nO,5<ZOOQU7+'O7+'OO$ OQ#xO1G/kO#MRQ#xO,5<XO$.pQ#xO,5>wO$.wQ#xO,5>wOOQS1G1r1G1rOOQS7+'R7+'RP#MRQ#xO'#GfO$/PQ#xO1G4bO$/ZQ#xO1G4bO$/cQ#xO1G4bOOQS7+%V7+%VO$/qQ#xO1G1sO$0PQ&nO'#F`O$0WQ#xO,5=POOQS,5=P,5=PO$0fQ#xO1G4cOOQS-E:c-E:cO#MRQ#xO,5=OO$0mQ#xO,5=OO$0rQ#xO7+)|OOQS-E:b-E:bO$0|Q#xO7+)|O#MRQ#xO,5<YP#MRQ#xO'#GeO$1UQ#xO1G2jO#MRQ#xO1G2jP$1dQ#xO'#GdO$1kQ#xO<<MhO$1uQ#xO1G1tO$2TQ#xO7+(UO7hQ#xO'#DPO7hQ#xO,59dO7hQ#xO,59dO7hQ#xO,59dO$2cQ&nO,5=hO7hQ#xO1G/OO/oQ#xO1G/ZO/oQ#xO7+$rP$2vQ#xO'#GRO'WQ#xO'#G|O$3TQ#xO,59dO$3YQ#xO,59dO$3aQ#xO,59oO$3fQ#xO1G/WO0pQ#xO'#DTO7hQ#xO,59l",
  stateData: "$3w~O%kOS%`OSUOS%_PQ~OPiOXfOhtOjYOquOu!TOxvO!RwO!S!QO!V!WO!W!VO!ZZO!_[O!jeO!ueO!veO!weO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#k!UO#n!XO#r!YO#t!ZO#y![O#|mO$O!]O%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O%_!^O~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%r!`O%s!aO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eO~Om&QXn&QXo&QXp&QXq&QXr&QXu&QX|&QX}&QX!{&QX#f&QX%^&QX%a&QX&S&QXi&QX!V&QX!W&QX&T&QX!Y&QX!^&QX!S&QX#_&QXv&QX!n&QX~P$dOhtOjYO!ZZO!_[O!jeO!ueO!veO!weO%wRO%xRO%|SO%}WO&c]O&d^O&g_O&j`O&naO&obO&pcO~O|&PX}&PX#f&PX%^&PX%a&PX&S&PX~Om!tOn!uOo!sOp!sOq!vOr!wOu!xO!{&PX~P(eOX#OOi#QOq0VOx0eO!RwO~P'WOX#SOq0VOx0eO!Y#TO~P'WOX#WOc#XOq0VOx0eO!^#YO~P'WO&e#]O&f#_O~O&h#`O&i#_O~OQ#bO%b#cO%c#eO~OR#fO%d#gO%e#eO~OS#iO%f#jO%g#eO~OT#lO%h#mO%i#eO~OX%qXa%qXc%qXj%qXm%qXn%qXo%qXp%qXq%qXr%qXu%qX|%qX!Z%qX!h%qX%r%qX%s%qX%t%qX%u%qX%v%qX%w%qX%x%qX%y%qX%z%qX%{%qXi%qX!V%qX!W%qX~O&c]O&d^O&g_O&j`O&naO&obO&pcO}%qX!{%qX#f%qX%^%qX%a%qX&S%qX&T%qX!Y%qX!^%qX!S%qX#_%qXv%qX!n%qX~P+}O|#rO}%pX!{%pX#f%pX%^%pX%a%pX&S%pX~Oq0VOx0eO~P'WO#f#uO%^#wO%a#wO~O%}WO~O!V#|O#t!ZO#y![O#|mO~OquO~P'WOX$ROc$SO%}WO}yP~OX$WOq0VOx0eO!S$XO~P'WO}$ZO!{$`O&S$[O#f!|X%^!|X%a!|X~OX$WOq0VOx0eO#f#VX%^#VX%a#VX~P'WOq0VOx0eO#f#ZX%^#ZX%a#ZX~P'WO!h$fO!u$fO%}WO~OX$pO~P'WO!W$rO#r$sO#t$tO~O}$uO~OX$|O~P'WOU%OO%^$}O%k%PO~OX%YOc%YOi%[Oq0VOx0eO~P'WOq0VOx0eO}%_O~P'WO&b%aO~Oc!fOj!mO!Z!oO!h!qOXdaadamdandaodapdaqdardauda|da}da!{da#fda%^da%ada%rda%sda%tda%uda%vda%wda%xda%yda%zda%{da&Sdaida!Vda!Wda&Tda!Yda!^da!Sda#_davda!nda~Op%fO~Oq%fO~P'WOq0VO~P'WOm0XOn0YOo0WOp0WOq0aOr0bOu0fOi&PX!V&PX!W&PX&T&PX!Y&PX!^&PX!S&PX#_&PX!n&PX~P(eO&T%hOi&OX|&OX!V&OX!W&OX!Y&OX}&OX~Oi%jO|%kO!V%oO!W%nO~Oi%jO~O|%rO!V%oO!W%nO!Y&[X~O!Y%vO~O|%wO}%yO!V%oO!W%nO!^&VX~O!^%}O~O!^&OO~O&e#]O&f&QO~O&h#`O&i&QO~OX&TOq0VOx0eO!RwO~P'WOQ#bO%b#cO%c&WO~OR#fO%d#gO%e&WO~OS#iO%f#jO%g&WO~OT#lO%h#mO%i&WO~OX!taa!tac!taj!tam!tan!tao!tap!taq!tar!tau!ta|!ta}!ta!Z!ta!h!ta!{!ta#f!ta%^!ta%a!ta%r!ta%s!ta%t!ta%u!ta%v!ta%w!ta%x!ta%y!ta%z!ta%{!ta&S!tai!ta!V!ta!W!ta&T!ta!Y!ta!^!ta!S!ta#_!tav!ta!n!ta~P#vO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P$dOX&bOquOxvO}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~P'WO|&`O}%pa!{%pa#f%pa%^%pa%a%pa&S%pa~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO#f$|X%^$|X%a$|X~P'WO#f#uO%^&gO%a&gO~O!h&hOj&rX%^&rX#_&rX#f&rX%a&rX#^&rX~Oj!mO%^&jO~Omgangaogapgaqgargauga|ga}ga!{ga#fga%^ga%aga&Sgaiga!Vga!Wga&Tga!Yga!^ga!Sga#_gavga!nga~P$dOusa|sa}sa#fsa%^sa%asa&Ssa~Om!tOn!uOo!sOp!sOq!vOr!wO!{sa~PDoO&S&lO|&RX}&RX~O%}WO|&RX}&RX~O|&oO}yX~O}&qO~O|%wO#f&VX%^&VX%a&VXi&VX}&VX!^&VX!n&VX&S&VX~OX0`Oq0VOx0eO!RwO~P'WO&S$[O#fWa%^Wa%aWa~O|&zO#f&XX%^&XX%a&XXp&XX~P$dO|&}O!S&|O#f#Za%^#Za%a#Za~O#_'OO#f#]a%^#]a%a#]a~O!h$fO!u$fO#^'QO%}WO~O#^'QO~O|'SO#f&uX%^&uX%a&uX~O|'UO#f&qX%^&qX%a&qX}&qX~O|'YOp&wX~P$dOp']O~OPiOXfOquOxvO!RwO!S!QO#OyO#QzO#S{O#U|O#W}O#[!OO#^!PO#a!RO#b!RO#d!SO%^'bO~P'WOv'fO#o'dO#p'eOP#maX#mah#maj#maq#mau#max#ma!R#ma!S#ma!V#ma!W#ma!Z#ma!_#ma!j#ma!u#ma!v#ma!w#ma#O#ma#Q#ma#S#ma#U#ma#W#ma#[#ma#^#ma#a#ma#b#ma#d#ma#k#ma#n#ma#r#ma#t#ma#y#ma#|#ma$O#ma%Z#ma%w#ma%x#ma%|#ma%}#ma&c#ma&d#ma&g#ma&j#ma&n#ma&o#ma&p#ma%]#ma%a#ma~O|'gO#_'iO}&xX~Oj'kO~Oj!mO}$uO~O}'oO~P$dO%^'rO~OU'sO%^'rO~OX!eOa!eOc!fOj!mO!Z!oO!h!qO%t!bO%u!cO%v!cO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%s!aO~P! tO%sYi~P! tOX!eOa!eOc!fOj!mO!Z!oO!h!qO%w!dO%x!dO%y!eO%z!eO%{!eOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~O%u!cO%v!cO~P!$oO%uYi%vYi~P!$oOc!fOj!mO!Z!oO!h!qOmYinYioYipYiqYirYiuYi|Yi}Yi!{Yi#fYi%^Yi%aYi%rYi%sYi%tYi%uYi%vYi%wYi%xYi&SYiiYi!VYi!WYi&TYi!YYi!^Yi!SYi#_YivYi!nYi~OX!eOa!eO%y!eO%z!eO%{!eO~P!'mOXYiaYi%yYi%zYi%{Yi~P!'mO!V%oO!W%nOi&_X|&_X~O&S'uO&T'uO~P+}O|'wOi&^X~Oi'yO~O|'zO}'|O!Y&aX~Oq0VOx0eO|'zO}'}O!Y&aX~P'WO!Y(PO~Oo!sOp!sOq!vOr!wOmliuli|li}li!{li#fli%^li%ali&Sli~On!uO~P!,`Onli~P!,`Om0XOn0YOo0WOp0WOq0aOr0bO~Ov(RO~P!-iOX(WOi(XOq0VOx0eO~P'WOi(XO|(YO~Oi([O~O!W(^O~Oi(_O|(YO!V%oO!W%nO~P$dOm0XOn0YOo0WOp0WOq0aOr0bOisa!Vsa!Wsa&Tsa!Ysa!^sa!Ssa#_savsa!nsa~PDoOX(WOq0VOx0eO!Y&[a~P'WO|(bO!Y&[a~O!Y(cO~O|(bO!V%oO!W%nO!Y&[a~P$dOX(gOq0VOx0eO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~P'WO|(hO!^&Va#f&Va%^&Va%a&Vai&Va}&Va!n&Va&S&Va~O!^(kO~O|(hO!V%oO!W%nO!^&Va~P$dO|(nO!V%oO!W%nO!^&]a~P$dO|(qO}&kX!^&kX!n&kX~O}(tO!^(vO!n(wO~O}(tO!^(xO!n(yO~O}(tO!^(zO!n({O~O}(tO!^(|O!n(}O~OX&bOquOxvO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~P'WO|)OO}%pi!{%pi#f%pi%^%pi%a%pi&S%pi~O!h&hOj&ra%^&ra#_&ra#f&ra%a&ra#^&ra~O%^)TO~OX$ROc$SO%}WO~O|&oO}ya~OquOxvO~P'WO|(hO#f&Va%^&Va%a&Vai&Va}&Va!^&Va!n&Va&S&Va~P$dO|)YO#f%pX%^%pX%a%pX&S%pX~O&S$[O#fWi%^Wi%aWi~O#f&Xa%^&Xa%a&Xap&Xa~P'WO|)]O#f&Xa%^&Xa%a&Xap&Xa~OX)aOj)cO%}WO~O#^)dO~O%}WO#f&ua%^&ua%a&ua~O|)fO#f&ua%^&ua%a&ua~Oq0VOx0eO#f&qa%^&qa%a&qa}&qa~P'WO|)iO#f&qa%^&qa%a&qa}&qa~Ov)mO#i)lOP#giX#gih#gij#giq#giu#gix#gi!R#gi!S#gi!V#gi!W#gi!Z#gi!_#gi!j#gi!u#gi!v#gi!w#gi#O#gi#Q#gi#S#gi#U#gi#W#gi#[#gi#^#gi#a#gi#b#gi#d#gi#k#gi#n#gi#r#gi#t#gi#y#gi#|#gi$O#gi%Z#gi%w#gi%x#gi%|#gi%}#gi&c#gi&d#gi&g#gi&j#gi&n#gi&o#gi&p#gi%]#gi%a#gi~Ov)nOP#jiX#jih#jij#jiq#jiu#jix#ji!R#ji!S#ji!V#ji!W#ji!Z#ji!_#ji!j#ji!u#ji!v#ji!w#ji#O#ji#Q#ji#S#ji#U#ji#W#ji#[#ji#^#ji#a#ji#b#ji#d#ji#k#ji#n#ji#r#ji#t#ji#y#ji#|#ji$O#ji%Z#ji%w#ji%x#ji%|#ji%}#ji&c#ji&d#ji&g#ji&j#ji&n#ji&o#ji&p#ji%]#ji%a#ji~OX)pOp&wa~P'WO|)qOp&wa~O|)qOp&wa~P$dOp)uO~O%[)xO~Ov){O#o'dO#p)zOP#miX#mih#mij#miq#miu#mix#mi!R#mi!S#mi!V#mi!W#mi!Z#mi!_#mi!j#mi!u#mi!v#mi!w#mi#O#mi#Q#mi#S#mi#U#mi#W#mi#[#mi#^#mi#a#mi#b#mi#d#mi#k#mi#n#mi#r#mi#t#mi#y#mi#|#mi$O#mi%Z#mi%w#mi%x#mi%|#mi%}#mi&c#mi&d#mi&g#mi&j#mi&n#mi&o#mi&p#mi%]#mi%a#mi~Oq0VOx0eO}$uO~P'WOq0VOx0eO}&xa~P'WO|*RO}&xa~OX*VOc*WOi*ZO%y*XO%}WO~O}$uO&{*]O~O%^*aO~O%^*cO~OX%YOc%YOq0VOx0eOi&^a~P'WO|*fOi&^a~Oq0VOx0eO}*iO!Y&aa~P'WO|*jO!Y&aa~Oq0VOx0eO|*jO}*mO!Y&aa~P'WOq0VOx0eO|*jO!Y&aa~P'WO|*jO}*mO!Y&aa~Oo0WOp0WOq0aOr0bOilimliuli|li!Vli!Wli&Tli!Yli}li!^li#fli%^li%ali!Sli#_livli!nli&Sli~On0YO~P!IeOnli~P!IeOX(WOi*rOq0VOx0eO~P'WOp*tO~Oi*rO|*vO~Oi*wO~OX(WOq0VOx0eO!Y&[i~P'WO|*xO!Y&[i~O!Y*yO~OX(gOq0VOx0eO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~P'WO|*|O!V%oO!W%nO!^&]i~O|+PO!^&Vi#f&Vi%^&Vi%a&Vii&Vi}&Vi!n&Vi&S&Vi~O!^+QO~Oc+SOq0VOx0eO!^&]i~P'WO|*|O!^&]i~O!^+UO~OX+WOq0VOx0eO}&ka!^&ka!n&ka~P'WO|+XO}&ka!^&ka!n&ka~O!_+[O&m+]O!^!oX~O!^+_O~O}(tO!^+`O~O}(tO!^+aO~O}(tO!^+bO~O}(tO!^+cO~OX&bOquOxvO}%pq!{%pq#f%pq%^%pq%a%pq&S%pq~P'WO|$ui}$ui!{$ui#f$ui%^$ui%a$ui&S$ui~P$dOX&bOquOxvO~P'WOX&bOq0VOx0eO#f%pa%^%pa%a%pa&S%pa~P'WO|+dO#f%pa%^%pa%a%pa&S%pa~O|$ha#f$ha%^$ha%a$hap$ha~P$dO#f&Xi%^&Xi%a&Xip&Xi~P'WO|+gO#f#Zq%^#Zq%a#Zq~O|+hO#_+jO#f&tX%^&tX%a&tXi&tX~OX+lOj)cO%}WO~O%}WO#f&ui%^&ui%a&ui~Oq0VOx0eO#f&qi%^&qi%a&qi}&qi~P'WOv+pO#i)lOP#gqX#gqh#gqj#gqq#gqu#gqx#gq!R#gq!S#gq!V#gq!W#gq!Z#gq!_#gq!j#gq!u#gq!v#gq!w#gq#O#gq#Q#gq#S#gq#U#gq#W#gq#[#gq#^#gq#a#gq#b#gq#d#gq#k#gq#n#gq#r#gq#t#gq#y#gq#|#gq$O#gq%Z#gq%w#gq%x#gq%|#gq%}#gq&c#gq&d#gq&g#gq&j#gq&n#gq&o#gq&p#gq%]#gq%a#gq~Op%Oa|%Oa~P$dOX)pOp&wi~P'WO|+wOp&wi~O|,QO}$uO#_,QO~O#p,ROP#mqX#mqh#mqj#mqq#mqu#mqx#mq!R#mq!S#mq!V#mq!W#mq!Z#mq!_#mq!j#mq!u#mq!v#mq!w#mq#O#mq#Q#mq#S#mq#U#mq#W#mq#[#mq#^#mq#a#mq#b#mq#d#mq#k#mq#n#mq#r#mq#t#mq#y#mq#|#mq$O#mq%Z#mq%w#mq%x#mq%|#mq%}#mq&c#mq&d#mq&g#mq&j#mq&n#mq&o#mq&p#mq%]#mq%a#mq~O#_,SO|%Qa}%Qa~Oq0VOx0eO}&xi~P'WO|,UO}&xi~O}$ZO&S,WOi&zX|&zX~O%}WOi&zX|&zX~O|,[Oi&yX~Oi,^O~O%[,`O~OX%YOc%YOq0VOx0eOi&^i~P'WO},bO|$ka!Y$ka~Oq0VOx0eO},cO|$ka!Y$ka~P'WOq0VOx0eO}*iO!Y&ai~P'WO|,fO!Y&ai~Oq0VOx0eO|,fO!Y&ai~P'WO|,fO},iO!Y&ai~Oi$gi|$gi!Y$gi~P$dOX(WOq0VOx0eO~P'WOp,kO~OX(WOi,lOq0VOx0eO~P'WOX(WOq0VOx0eO!Y&[q~P'WO|$fi!^$fi#f$fi%^$fi%a$fii$fi}$fi!n$fi&S$fi~P$dOX(gOq0VOx0eO~P'WOc+SOq0VOx0eO!^&]q~P'WO|,mO!^&]q~O!^,nO~OX(gOq0VOx0eO!^&Vq#f&Vq%^&Vq%a&Vqi&Vq}&Vq!n&Vq&S&Vq~P'WO},oO~OX+WOq0VOx0eO}&ki!^&ki!n&ki~P'WO|,tO}&ki!^&ki!n&ki~O!_+[O&m+]O!^!oa~OX&bOq0VOx0eO#f%pi%^%pi%a%pi&S%pi~P'WO|,wO#f%pi%^%pi%a%pi&S%pi~O%}WO#f&ta%^&ta%a&tai&ta~O|,zO#f&ta%^&ta%a&tai&ta~Oi,}O~Op%Oi|%Oi~P$dOX)pO~P'WOX)pOp&wq~P'WOv-QOP#lyX#lyh#lyj#lyq#lyu#lyx#ly!R#ly!S#ly!V#ly!W#ly!Z#ly!_#ly!j#ly!u#ly!v#ly!w#ly#O#ly#Q#ly#S#ly#U#ly#W#ly#[#ly#^#ly#a#ly#b#ly#d#ly#k#ly#n#ly#r#ly#t#ly#y#ly#|#ly$O#ly%Z#ly%w#ly%x#ly%|#ly%}#ly&c#ly&d#ly&g#ly&j#ly&n#ly&o#ly&p#ly%]#ly%a#ly~O%]-TO%a-TO~P`O#p-UOP#myX#myh#myj#myq#myu#myx#my!R#my!S#my!V#my!W#my!Z#my!_#my!j#my!u#my!v#my!w#my#O#my#Q#my#S#my#U#my#W#my#[#my#^#my#a#my#b#my#d#my#k#my#n#my#r#my#t#my#y#my#|#my$O#my%Z#my%w#my%x#my%|#my%}#my&c#my&d#my&g#my&j#my&n#my&o#my&p#my%]#my%a#my~Oq0VOx0eO}&xq~P'WO|-YO}&xq~O&S,WOi&za|&za~OX*VOc*WO%y*XO%}WOi&ya~O|-^Oi&ya~O$R-bO~OX%YOc%YOq0VOx0eO~P'WOq0VOx0eO}-cO|$ki!Y$ki~P'WOq0VOx0eO|$ki!Y$ki~P'WO}-cO|$ki!Y$ki~Oq0VOx0eO}*iO~P'WOq0VOx0eO}*iO!Y&aq~P'WO|-fO!Y&aq~Oq0VOx0eO|-fO!Y&aq~P'WOu-iO!V%oO!W%nOi&Wq!Y&Wq!^&Wq|&Wq~P!-iOc+SOq0VOx0eO!^&]y~P'WO|$ii!^$ii~P$dOc+SOq0VOx0eO~P'WOX+WOq0VOx0eO~P'WOX+WOq0VOx0eO}&kq!^&kq!n&kq~P'WO}(tO!^-mO!n-nO~OX&bOq0VOx0eO#f%pq%^%pq%a%pq&S%pq~P'WO#_-oO|$za#f$za%^$za%a$zai$za~O%}WO#f&ti%^&ti%a&tii&ti~O|-qO#f&ti%^&ti%a&tii&ti~Ov-tOP#l!RX#l!Rh#l!Rj#l!Rq#l!Ru#l!Rx#l!R!R#l!R!S#l!R!V#l!R!W#l!R!Z#l!R!_#l!R!j#l!R!u#l!R!v#l!R!w#l!R#O#l!R#Q#l!R#S#l!R#U#l!R#W#l!R#[#l!R#^#l!R#a#l!R#b#l!R#d#l!R#k#l!R#n#l!R#r#l!R#t#l!R#y#l!R#|#l!R$O#l!R%Z#l!R%w#l!R%x#l!R%|#l!R%}#l!R&c#l!R&d#l!R&g#l!R&j#l!R&n#l!R&o#l!R&p#l!R%]#l!R%a#l!R~Oq0VOx0eO}&xy~P'WOX*VOc*WO%y*XO%}WOi&yi~O$R-bO%]-zO%a-zO~OX.UOj.SO!Z.RO!_.TO!j-}O!v.PO!w.PO%x-|O%}WO&c]O&d^O&g_O~Oq0VOx0eO|$kq!Y$kq~P'WO}.ZO|$kq!Y$kq~Oq0VOx0eO}*iO!Y&ay~P'WO|.[O!Y&ay~Oq0VOx.`O~P'WOu-iO!V%oO!W%nOi&Wy!Y&Wy!^&Wy|&Wy~P!-iO}(tO!^.cO~O%}WO#f&tq%^&tq%a&tqi&tq~O|.eO#f&tq%^&tq%a&tqi&tq~OX*VOc*WO%y*XO%}WO~Oj.iO!h.gO|$SX#_$SX%r$SXi$SX~Ou$SX}$SX!Y$SX!^$SX~P$!}O%w.kO%x.kOu$TX|$TX}$TX#_$TX%r$TX!Y$TXi$TX!^$TX~O!j.mO~O|.qO#_.sO%r.nOu&|X}&|X!Y&|Xi&|X~Oc.vO~P#M_Oj.iOu&}X|&}X}&}X#_&}X%r&}X!Y&}Xi&}X!^&}X~Ou.zO}$uO~Oq0VOx0eO|$ky!Y$ky~P'WOq0VOx0eO}*iO!Y&a!R~P'WO|/OO!Y&a!R~Oi&ZXu&ZX!V&ZX!W&ZX!Y&ZX!^&ZX|&ZX~P!-iOu-iO!V%oO!W%nOi&Ya!Y&Ya!^&Ya|&Ya~O%}WO#f&ty%^&ty%a&tyi&ty~O!h.gOj$Zau$Za|$Za}$Za#_$Za%r$Za!Y$Zai$Za!^$Za~O!j/XO~O%w.kO%x.kOu$Ta|$Ta}$Ta#_$Ta%r$Ta!Y$Tai$Ta!^$Ta~O%r.nOu$Xa|$Xa}$Xa#_$Xa!Y$Xai$Xa!^$Xa~Ou&|a}&|a!Y&|ai&|a~P#MRO|/^Ou&|a}&|a!Y&|ai&|a~O!Y/aO~Oi/aO~O}/cO~O!^/dO~Oq0VOx0eO}*iO!Y&a!Z~P'WO}/gO~O&S/hO~P$!}O|/iO#_.sO%r.nOi'PX~O|/iOi'PX~Oi/kO~O!j/lO~O#_.sOu%Ua|%Ua}%Ua%r%Ua!Y%Uai%Ua!^%Ua~O#_.sO%r.nOu%Ya|%Ya}%Ya!Y%Yai%Ya~Ou&|i}&|i!Y&|ii&|i~P#MRO|/nO#_.sO%r.nO!^'Oa~O}$ca~P$dOi'Pa~P#MRO|/vOi'Pa~Oc/xO!^'Oi~P#M_O|/zO!^'Oi~O|/zO#_.sO%r.nO!^'Oi~O#_.sO%r.nOi$ai|$ai~O&S/}O~P$!}O#_.sO%r.nOi%Xa|%Xa~Oi'Pi~P#MRO}0QO~Oc/xO!^'Oq~P#M_O|0SO!^'Oq~O#_.sO%r.nO|%Wi!^%Wi~Oc/xO~P#M_Oc/xO!^'Oy~P#M_O#_.sO%r.nOi$bi|$bi~O#_.sO%r.nO|%Wq!^%Wq~O|+dO#f%pa%^%pa%a%pa&S%pa~P$dOX&bOq0VOx0eO~P'WOp0[O~Oq0[O~P'WO}0]O~Ov0^O~P!-iO&d&g&o&p&c&j&n%}&c~",
  goto: "!<w'QPPPPPPPP'RP'Z*s+]+v,b,}-kP.YP'Z.y.y'ZPPP'Z2cPPPPPP2c5VPP5VP7g7p=pPP=s>e>hPP'Z'ZPP?QPP'Z'ZPP'Z'Z'Z'Z'Z?U?{'ZP@OP@UD]GyPG}HZH_HcHg'ZPPPHkHq'RP'R'RP'RP'RP'RP'RP'R'R'RP'RPP'RPP'RPHwPIOIUPIOPIOIOPPPIOPKTPK^KdKjKTPIOKpPIOPKwK}PLRLgMUMoLRLRMuNSLRLRLRLRNhNnNqNvNy! T! Z! g! y!!P!!Z!!a!!}!#T!#Z!#a!#k!#q!#w!#}!$T!$Z!$m!$w!$}!%T!%Z!%e!%k!%q!%w!&R!&X!&c!&i!&r!&x!'X!'a!'k!'rPPPPPPPPPPPPPPPPP!'x!'{!(R!([!(f!(qPPPPPPPPPPPP!-e!.y!2s!6TPP!6]!6o!6x!7n!7e!7w!7}!8Q!8T!8W!8`!9PPPPPPPPPP!9S!9cPPPP!:R!:_!:k!:q!:z!:}!;T!;Z!;a!;dP!;l!;u!<q!<t]jOs#u$u)x+|'}eOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f}!gQ#q$O$a$o${%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!P!hQ#q$O$a$o${%Q%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!R!iQ#q$O$a$o${%Q%R%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!T!jQ#q$O$a$o${%Q%R%S%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!V!kQ#q$O$a$o${%Q%R%S%T%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!X!lQ#q$O$a$o${%Q%R%S%T%U%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z!]!lQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0Z'}TOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0f&cVOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0f%mXOYZ[isw}!O!S!T!U!Y!m!o#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$UvQ/P.`R0c0e'teOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fW#xm!P!Q$gW$Qv&o.`0eQ$i!RQ$y!ZQ$z![W%X!m'w*f,aS&n$R$SQ'`$tQ)R&hQ)a'OU)b'Q)c)dU)e'S)f+mQ*T'iW*U'k,[-^-xS,Z*V*WY,y+h,z-p-q.eQ,|+jQ-V,QQ-X,Sl-{-b.R.S.U.o.q.v/^/c/h/m/x/}0QQ.d-oQ.w.TQ/T.iQ/`.sU/s/i/v0OX/y/n/z0R0SR&m$Q!_!{YZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OR%i!zQ#PYQ&U#bQ&X#fQ&Z#iQ&]#lQ&v$]Q&y$`R,u+[T._-i/g![!nQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZQ&k#yR'n$zR'v%XQ%b!qR/R.g'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fS#od#p!P.P-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0S'|dOTYZ[fistuwy}!O!S!T!U!V!Y!]!g!h!i!j!k!l!m!o!s!t!u!w!x#O#S#W#X#b#f#i#l#r#u$W$X$Z$]$`$p$r$s$u$|%Y%_%f%i%k%n%r%w%y&T&`&b&m&q&z&|&}'U'Y']'d'g'v'w'z'|'}(R(W(Y(^(b(g(h(n(q)O)Q)Y)])i)l)p)q)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+S+W+X+[+d+f+g+n+v+w+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[.z/O/g0V0W0X0Y0[0]0^0_0`0b0fT#od#pT#c`#de(u&U&X&Z&](w(y({(},u-nT+](t+^T#ga#hT#jb#kT#mc#nQ$_xR,Y*UX$]x$^$_&xZlOs$u)x+|XpOs)x+|Q$v!XQ'W$mQ'X$nQ'j$xQ'm$zQ)v'_Q)|'dQ*O'eQ*P'fQ*^'lQ*`'nQ+q)lQ+s)mQ+t)nQ+x)tS+z)w*_Q+})zQ,O){Q,P)}Q-O+pQ-P+rQ-R+yQ-S+{Q-W,RQ-s-QQ-u-UQ-v-VQ.f-tQ.{.XR/f.|WpOs)x+|R#{oQ'l$yR)w'`Q,X*UR-[,YQ*_'lR+{)wZnOos)x+|Q'p${R*b'qT-`,`-au.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0Qt.W-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QQ.w.TX/y/n/z0R0S!P.O-b.R.S.T.U.i.o.q.v/^/c/h/i/m/n/v/x/z/}0O0Q0R0SQ.l-}R/Y.mg.o.Q.p/U/]/b/p/r/t0P0T0Uu.V-b.R.S.U.i.o.q.v/^/c/h/i/m/v/x/}0O0QX.j-{.V/T/sR/V.iV/u/i/v0OR.|.XQsOS#}s+|R+|)xQ&p$TR)W&pS%x#V$VS(i%x(lT(l%{&rQ%l!}Q%s#RW(Z%l%s(`(dQ(`%pR(d%uQ&{$aR)^&{Q(o%|Q*}(jT+T(o*}Q'x%ZR*g'xS'{%^%_Y*k'{*l,g-g.]U*l'|'}(OU,g*m*n*oS-g,h,iR.]-hQ#^^R&P#^Q#a_R&R#aQ#d`R&V#dQ(r&SS+Y(r+ZR+Z(sQ+^(tR,v+^Q#haR&Y#hQ#kbR&[#kQ#ncR&^#nQ#pdR&_#pQ#sgQ&a#qW&d#s&a)Z+eQ)Z&uR+e0ZQ$^xS&w$^&xR&x$_Q'V$kR)j'VQ&i#xR)S&iQ$g!QR'P$gQ+i)bS,{+i-rR-r,|Q'T$iR)g'TQ#vkR&f#vQ)k'WR+o)kQ'Z$oS)r'Z)sR)s'[Q'c$vR)y'cQ'h$wS*S'h,VR,V*TQ,]*YR-_,]WoOs)x+|R#zoQ-a,`R-y-ad.p.Q/U/]/b/p/r/t0P0T0UR/[.pU.h-{/T/sR/S.hQ/o/bS/{/o/|R/|/pS/j/U/VR/w/jQ.r.QR/_.rR!_PXrOs)x+|WqOs)x+|R'a$uYkOs$u)x+|R&e#u[xOs#u$u)x+|R&v$]&bQOYZ[isuw}!O!S!T!U!Y!m!o!s!t!u!w!x#b#f#i#l#r#u$X$Z$]$`$s$u%Y%_%f%i%k%r%w%y&T&`&m&q&|&}'U']'d'g'v'w'z'|'}(R(Y(b(h(n(q)O)Q)Y)i)l)u)x*R*]*f*i*j*m*s*t*v*x*{*|+P+W+X+[+d+g+n+|,T,U,X,a,b,c,e,f,i,k,m,o,q,s,t,w-Y-[-c-f-i.Z.[/O/g0V0W0X0Y0[0]0^0_0b0fQ!rTQ#qfQ$OtU$ay%n(^S$o!V$rQ${!]Q%Q!gQ%R!hQ%S!iQ%T!jQ%U!kQ%V!lQ%p#OQ%u#SQ%{#WQ%|#XQ&r$WQ'[$pQ'q$|Q)P&bU)[&z)]+fW)o'Y)q+v+wQ*q(WQ*z(gQ+u)pQ,p+SQ/e.zR0Z0`Q!}YQ#RZQ$m!TQ$n!UQ%^!oQ(O%_^(V%k%r(Y(b*s*v*x^*h'z*j,e,f-f.[/OQ*n'|Q*o'}Q+r)lQ,d*iQ,h*mQ-d,bQ-e,cQ-h,iQ.Y-cR.}.Z[gOs#u$u)x+|!^!zYZ!T!U!o%_%k%r'z'|'}(Y(b)l*i*j*m*s*v*x,b,c,e,f,i-c-f.Z.[/OQ#V[Q#tiS$Vw}Q$d!OW$k!S$`'])uS$w!Y$sW%W!m'w*f,aY&S#b#f#i#l+[`&c#r&`)O)Q)Y+d,w0_Q&s$XQ&t$ZQ&u$]Q't%YQ(U%iW(f%w(h*{+PQ(j%yQ(s&TQ)U&mS)X&q0]Q)_&|Q)`&}U)h'U)i+nQ)}'dY*Q'g*R,T,U-YQ*d'vS*p(R0^W+R(n*|,m,qW+V(q+X,s,tQ,_*]Q,r+WQ,x+gQ-Z,XQ-l,oR-w-[hUOs#r#u$u&`&q(R)O)Q)x+|%S!yYZ[iw}!O!S!T!U!Y!m!o#b#f#i#l$X$Z$]$`$s%Y%_%i%k%r%w%y&T&m&|&}'U']'d'g'v'w'z'|'}(Y(b(h(n(q)Y)i)l)u*R*]*f*i*j*m*s*v*x*{*|+P+W+X+[+d+g+n,T,U,X,a,b,c,e,f,i,m,o,q,s,t,w-Y-[-c-f.Z.[/O0]0^0_Q$PuW%c!s!w0W0bQ%d!tQ%e!uQ%g!xQ%q0VS(Q%f0[Q(S0XQ(T0YQ,j*tQ-k,kS.^-i/gR0d0fU$Tv.`0eR)V&o[hOs#u$u)x+|a!|Y#b#f#i#l$]$`+[Q#[[Q$YwR$c}Q%m!}Q%t#RQ%z#VQ't%WQ(a%pQ(e%uQ(m%{Q(p%|Q+O(jQ-j,jQ.b-kR/Q.aQ$byQ(]%nR*u(^Q.a-iR/q/gR#UZR#Z[R%]!mQ%Z!mV*e'w*f,a!]!pQ!r#q$O$a$o${%Q%R%S%T%U%V%p%u%{%|&r'['q)P)[)o*q*z+u,p/e0ZR%`!oQ&U#bQ&X#fQ&Z#iQ&]#lR,u+[Q(v&UQ(x&XQ(z&ZQ(|&]Q+`(wQ+a(yQ+b({Q+c(}Q-m,uR.c-nQ$l!SQ&y$`Q)t']R+y)uQ#ymQ$e!PQ$h!QR'R$gQ)a'QR+l)dQ)a'QQ+k)cR+l)dR$j!RXqOs)x+|Q$q!VR'^$rQ$x!YR'_$sR*['kQ*Y'kV-],[-^-xQ.X-bQ.t.RR.u.SU.Q-b.R.SQ.y.UQ/U.iQ/Z.oU/].q/^/mQ/b.vQ/p/cQ/r/hU/t/i/v0OQ0P/xQ0T/}R0U0QR.x.TR/W.i",
  nodeNames: " print { { { { Comment Script AssignStatement * BinaryExpression BitOp BitOp BitOp BitOp ArithOp ArithOp @ ArithOp ** UnaryExpression ArithOp BitOp AwaitExpression await ) ( ParenthesizedExpression BinaryExpression or and CompareOp in not is UnaryExpression ConditionalExpression if else LambdaExpression lambda ParamList VariableName AssignOp , : NamedExpression AssignOp YieldExpression yield from TupleExpression ComprehensionExpression async for LambdaExpression ] [ ArrayExpression ArrayComprehensionExpression } { DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression CallExpression ArgList AssignOp MemberExpression . PropertyName Number String FormatString FormatReplacement FormatConversion FormatSpec FormatReplacement FormatReplacement FormatReplacement FormatReplacement ContinuedString Ellipsis None Boolean TypeDef AssignOp UpdateStatement UpdateOp ExpressionStatement DeleteStatement del PassStatement pass BreakStatement break ContinueStatement continue ReturnStatement return YieldStatement PrintStatement RaiseStatement raise ImportStatement import as ScopeStatement global nonlocal AssertStatement assert StatementGroup ; IfStatement Body elif WhileStatement while ForStatement TryStatement try except finally WithStatement with FunctionDefinition def ParamList AssignOp TypeDef ClassDefinition class DecoratedStatement Decorator At MatchStatement match MatchBody MatchClause case CapturePattern LiteralPattern ArithOp ArithOp AsPattern OrPattern LogicOp AttributePattern SequencePattern MappingPattern StarPattern ClassPattern PatternArgList KeywordPattern KeywordPattern Guard",
  maxTerm: 277,
  context: gQe,
  nodeProps: [
    ["group", -14, 8, 88, 90, 91, 93, 95, 97, 99, 101, 102, 103, 105, 108, 111, "Statement Statement", -22, 10, 20, 23, 27, 42, 51, 52, 58, 59, 62, 63, 64, 65, 66, 69, 72, 73, 74, 82, 83, 84, 85, "Expression", -10, 113, 115, 118, 120, 121, 125, 127, 132, 134, 137, "Statement", -9, 142, 143, 146, 147, 149, 150, 151, 152, 153, "Pattern"],
    ["openedBy", 25, "(", 56, "[", 60, "{"],
    ["closedBy", 26, ")", 57, "]", 61, "}"]
  ],
  propSources: [SQe],
  skippedNodes: [0, 6],
  repeatNodeCount: 37,
  tokenData: "%-W#sR!`OX%TXY=|Y[%T[]=|]p%Tpq=|qr@_rsDOst!+|tu%Tuv!Nnvw#!|wx#$Wxy#:Uyz#;Yz{#<^{|#>x|}#@S}!O#AW!O!P#Ci!P!Q#N_!Q!R$!y!R![$&w![!]$1e!]!^$3s!^!_$4w!_!`$7c!`!a$8m!a!b%T!b!c$;U!c!d$<b!d!e$>W!e!h$<b!h!i$H[!i!t$<b!t!u%#r!u!w$<b!w!x$Fl!x!}$<b!}#O%%z#O#P?d#P#Q%'O#Q#R%(S#R#S$<b#S#T%T#T#U$<b#U#V$>W#V#Y$<b#Y#Z$H[#Z#f$<b#f#g%#r#g#i$<b#i#j$Fl#j#o$<b#o#p%)^#p#q%*S#q#r%+^#r#s%,S#s$g%T$g;'S$<b;'S;=`$>Q<%lO$<b!n%^]&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n&^]&m!b&eSOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n'^]&m!b&eSOr%Trs(Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!f(^Z&m!b&eSOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)UZ&m!bOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!f)|Z&m!bOw(Vwx*ox#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V!b*tT&m!bO#o*o#p#q*o#r;'S*o;'S;=`+T<%lO*o!b+WP;=`<%l*o!f+`W&m!bO#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`.d;=`<%l+x<%lO(VS+}V&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS,gVOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-PUOw+xx#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xS-fRO;'S+x;'S;=`-o;=`O+xS-tW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l+x<%lO+xS.aP;=`<%l+x!f.iW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l(V<%lO+x!f/UP;=`<%l(V!n/`]&m!b&hWOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!n0`]&m!b&hWOr%Trs&Vsw%Twx1Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!j1`Z&m!b&hWOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j2WZ&m!bOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3OZ&m!bOr1Xrs*os#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X!j3vW&m!bO#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`6z;=`<%l4`<%lO1XW4eV&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W4}VOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5gUOr4`s#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`W5|RO;'S4`;'S;=`6V;=`O4`W6[W&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l4`<%lO4`W6wP;=`<%l4`!j7PW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l1X<%lO4`!j7lP;=`<%l1X!n7tW&m!bO#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T[8eX&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9VX&eSOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[9wX&eSOr8^rs+xsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[:iX&hWOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;ZX&hWOr8^rs9Qsw8^wx4`x#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^[;yRO;'S8^;'S;=`<S;=`O8^[<ZY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l8^<%lO8^[<|P;=`<%l8^!n=WY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l%T<%lO8^!n=yP;=`<%l%T#s>Xc&m!b&eS&hW%k!TOX%TXY=|Y[%T[]=|]p%Tpq=|qr%Trs&Vsw%Twx/Xx#O%T#O#P?d#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s?i[&m!bOY%TYZ=|Z]%T]^=|^#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=P;=`<%l8^<%lO%T!q@hd&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#T%T#T#UBz#U#f%T#f#gBz#g#hBz#h#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qBR]oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!qCV]!nR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cDXa&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs!)|swE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cEia&m!b&eS&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cFw]&m!b&eS&csOr%Trs'Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#cGya&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxIOx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#cIXa&m!b&hW&csOYE^YZ%TZ]E^]^%T^rE^rsFnswE^wxJ^x#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#_Jg_&m!b&hW&csOYJ^YZ1XZ]J^]^1X^rJ^rsKfs#OJ^#O#PL`#P#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`!!o<%lOJ^#_KmZ&m!b&csOr1Xrs2ys#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#_LeW&m!bO#oJ^#o#pL}#p#qJ^#q#rL}#r;'SJ^;'S;=`! r;=`<%lL}<%lOJ^{MUZ&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l<%lOL}{M|V&csOr4`rs5ds#O4`#O#P5y#P;'S4`;'S;=`6t<%lO4`{NfRO;'SL};'S;=`No;=`OL}{Nv[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lL}<%lOL}{! oP;=`<%lL}#_! y[&hW&csOYL}YZ4`Z]L}]^4`^rL}rsMws#OL}#O#PNc#P;'SL};'S;=`! l;=`<%lJ^<%lOL}#_!!rP;=`<%lJ^#c!!zW&m!bO#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!(q;=`<%l!#d<%lOE^!P!#m]&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!$mX&eS&csOr8^rs9rsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P!%a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!&Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!&a]&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwxL}x#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k<%lO!#d!P!']RO;'S!#d;'S;=`!'f;=`O!#d!P!'o^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%l!#d<%lO!#d!P!(nP;=`<%l!#d#c!(z^&eS&hW&csOY!#dYZ8^Z]!#d]^8^^r!#drs!$fsw!#dwx!%Yx#O!#d#O#P!'Y#P;'S!#d;'S;=`!(k;=`<%lE^<%lO!#d#c!)yP;=`<%lE^#c!*V]&m!b&eS&csOr%Trs!+Osw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c!+ZZ&iW&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#s!,XaU!T&m!b&eS&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!-gaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!.lsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!.uaU!T&m!b&eSOY!+|YZ%TZ]!+|]^%T^r!+|rs!/zsw!+|wx!:hx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#k!0T_U!T&m!b&eSOY!/zYZ(VZ]!/z]^(V^w!/zwx!1Sx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!1Z_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!2Yx#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#k!2a_U!T&m!bOY!/zYZ(VZ]!/z]^(V^w!/zwx!3`x#O!/z#O#P!4z#P#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!:b<%lO!/z#g!3gZU!T&m!bOY!3`YZ*oZ]!3`]^*o^#o!3`#o#p!4Y#p#q!3`#q#r!4Y#r;'S!3`;'S;=`!4t<%lO!3`!T!4_TU!TOY!4YZ]!4Y^;'S!4Y;'S;=`!4n<%lO!4Y!T!4qP;=`<%l!4Y#g!4wP;=`<%l!3`#k!5R[U!T&m!bOY!/zYZ(VZ]!/z]^(V^#o!/z#o#p!5w#p#q!/z#q#r!5w#r;'S!/z;'S;=`!9s;=`<%l+x<%lO!/z!X!6OZU!T&eSOY!5wYZ+xZ]!5w]^+x^w!5wwx!6qx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!6vZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!7ix#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!7nZU!TOY!5wYZ+xZ]!5w]^+x^w!5wwx!4Yx#O!5w#O#P!8a#P;'S!5w;'S;=`!9m<%lO!5w!X!8fWU!TOY!5wYZ+xZ]!5w]^+x^;'S!5w;'S;=`!9O;=`<%l+x<%lO!5w!X!9TW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!5w<%lO+x!X!9pP;=`<%l!5w#k!9xW&eSOw+xwx,dx#O+x#O#P-c#P;'S+x;'S;=`.^;=`<%l!/z<%lO+x#k!:eP;=`<%l!/z#s!:qaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!;vx#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#s!<PaU!T&m!b&hWOY!+|YZ%TZ]!+|]^%T^r!+|rs!-^sw!+|wx!=Ux#O!+|#O#P!FW#P#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Nh<%lO!+|#o!=__U!T&m!b&hWOY!=UYZ1XZ]!=U]^1X^r!=Urs!>^s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!>e_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!?ds#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!?k_U!T&m!bOY!=UYZ1XZ]!=U]^1X^r!=Urs!3`s#O!=U#O#P!@j#P#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!FQ<%lO!=U#o!@q[U!T&m!bOY!=UYZ1XZ]!=U]^1X^#o!=U#o#p!Ag#p#q!=U#q#r!Ag#r;'S!=U;'S;=`!Ec;=`<%l4`<%lO!=U!]!AnZU!T&hWOY!AgYZ4`Z]!Ag]^4`^r!Agrs!Bas#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!BfZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!CXs#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!C^ZU!TOY!AgYZ4`Z]!Ag]^4`^r!Agrs!4Ys#O!Ag#O#P!DP#P;'S!Ag;'S;=`!E]<%lO!Ag!]!DUWU!TOY!AgYZ4`Z]!Ag]^4`^;'S!Ag;'S;=`!Dn;=`<%l4`<%lO!Ag!]!DsW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!Ag<%lO4`!]!E`P;=`<%l!Ag#o!EhW&hWOr4`rs4zs#O4`#O#P5y#P;'S4`;'S;=`6t;=`<%l!=U<%lO4`#o!FTP;=`<%l!=U#s!F_[U!T&m!bOY!+|YZ%TZ]!+|]^%T^#o!+|#o#p!GT#p#q!+|#q#r!GT#r;'S!+|;'S;=`!Mq;=`<%l8^<%lO!+|!a!G^]U!T&eS&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!H^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!IVsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!I^]U!T&eSOY!GTYZ8^Z]!GT]^8^^r!GTrs!5wsw!GTwx!JVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!J^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!KVx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!K^]U!T&hWOY!GTYZ8^Z]!GT]^8^^r!GTrs!HVsw!GTwx!Agx#O!GT#O#P!LV#P;'S!GT;'S;=`!Mk<%lO!GT!a!L[WU!TOY!GTYZ8^Z]!GT]^8^^;'S!GT;'S;=`!Lt;=`<%l8^<%lO!GT!a!L{Y&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!GT<%lO8^!a!MnP;=`<%l!GT#s!MxY&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y;=`<%l!+|<%lO8^#s!NkP;=`<%l!+|#b!Ny_%zQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b#!T]!{r&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b##X_%tQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#$aa&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#8Ux#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#%qa&m!b&eS&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#'Pa&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#(Usw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c#(_a&m!b&eS&csOY#%fYZ%TZ]#%f]^%T^r#%frs#)dsw#%fwx#/{x#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#Z#)m_&m!b&eS&csOY#)dYZ(VZ]#)d]^(V^w#)dwx#*lx#O#)d#O#P#+f#P#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#/u<%lO#)d#Z#*sZ&m!b&csOw(Vwx)wx#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#Z#+kW&m!bO#o#)d#o#p#,T#p#q#)d#q#r#,T#r;'S#)d;'S;=`#.x;=`<%l#,T<%lO#)dw#,[Z&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r<%lO#,Tw#-SV&csOw+xwx,|x#O+x#O#P-c#P;'S+x;'S;=`.^<%lO+xw#-lRO;'S#,T;'S;=`#-u;=`O#,Tw#-|[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#,T<%lO#,Tw#.uP;=`<%l#,T#Z#/P[&eS&csOY#,TYZ+xZ]#,T]^+x^w#,Twx#,}x#O#,T#O#P#-i#P;'S#,T;'S;=`#.r;=`<%l#)d<%lO#,T#Z#/xP;=`<%l#)d#c#0U]&m!b&hW&csOr%Trs&Vsw%Twx0Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#1SW&m!bO#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#6y;=`<%l#1l<%lO#%f!P#1u]&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#2u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#3nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#3u]&eS&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#,Tsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s<%lO#1l!P#4uX&hW&csOr8^rs9Qsw8^wx;Ux#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^!P#5eRO;'S#1l;'S;=`#5n;=`O#1l!P#5w^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#1l<%lO#1l!P#6vP;=`<%l#1l#c#7S^&eS&hW&csOY#1lYZ8^Z]#1l]^8^^r#1lrs#2nsw#1lwx#4nx#O#1l#O#P#5b#P;'S#1l;'S;=`#6s;=`<%l#%f<%lO#1l#c#8RP;=`<%l#%f#c#8_]&m!b&hW&csOr%Trs&Vsw%Twx#9Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#9cZ&fS&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#c#:a]js&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#;e]iR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#<iaXs&m!b&eS&hWOr%Trs&Vsw%Twx/Xxz%Tz{#=n{!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#=y_cR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#?T_%ws&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q#@_]|R&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s#Ac`%xs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`!a#Be!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#O#Bp]&{`&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Cta!hQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#Dy!P!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#ES_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P#FR!P#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#F^]!us&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Gbi!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#GV#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#IYc&m!b&eS&hWOr%Trs&Vsw%Twx/Xx{%T{|#Je|}%T}!O#Je!O!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Jn_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Kxe!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#Km![!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S#Km#S#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a#Mf]!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c#Nja%yR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!P%T!P!Q$ o!Q!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$ z_%{Q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$#Uw!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!d%T!d!e$(w!e!g%T!g!h#IP!h!l%T!l!m#MZ!m!q%T!q!r$+m!r!z%T!z!{$.]!{#O%T#O#P7o#P#R%T#R#S$&w#S#U%T#U#V$(w#V#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#c%T#c#d$+m#d#l%T#l#m$.]#m#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$%x_&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![#GV![#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$'Sk!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!O%T!O!P$%o!P!Q%T!Q![$&w![!g%T!g!h#IP!h!l%T!l!m#MZ!m#O%T#O#P7o#P#R%T#R#S$&w#S#X%T#X#Y#IP#Y#^%T#^#_#MZ#_#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$)Qb&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$*eb!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!R$*Y!R!S$*Y!S#O%T#O#P7o#P#R%T#R#S$*Y#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$+va&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$-Wa!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q!Y$,{!Y#O%T#O#P7o#P#R%T#R#S$,{#S#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$.fe&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a$0Se!jq&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!Q%T!Q![$/w![!c%T!c!i$/w!i#O%T#O#P7o#P#R%T#R#S$/w#S#T%T#T#Z$/w#Z#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$1p_}!T&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`$2o!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q$2z]&TR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$4O]#fs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$5SaoR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!^%T!^!_$6X!_!`Av!`!aAv!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$6d_%uQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$7n_&Ss&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$8x`oR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`Av!`!a$9z!a#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b$:V_%vQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$;c_aQ#|P&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#s$<oe&m!b&eS&hW&b`%}sOr%Trs&Vsw%Twx/Xx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$>TP;=`<%l$<b#s$>ei&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g$Fl#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$@]a&m!b&eS&csOYE^YZ%TZ]E^]^%T^rE^rs$AbswE^wxGpx#OE^#O#P!!u#P#oE^#o#p!#d#p#qE^#q#r!#d#r;'SE^;'S;=`!)v<%lOE^#c$Ak]&m!b&eS&csOr%Trs$Bdsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$BmZ&m!b&eS&gsOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$Cia&m!b&hW&csOY#%fYZ%TZ]#%f]^%T^r#%frs#&vsw#%fwx$Dnx#O#%f#O#P#0}#P#o#%f#o#p#1l#p#q#%f#q#r#1l#r;'S#%f;'S;=`#8O<%lO#%f#c$Dw]&m!b&hW&csOr%Trs&Vsw%Twx$Epx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_$EyZ&m!b&hW&dsOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s$Fye&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s$Hii&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!t$<b!t!u%!S!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#f$<b#f#g%!S#g#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c$Ja]&m!b&eS&nsOr%Trs$KYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$Ka]&m!b&eSOr%Trs$LYsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#Z$LcZ&m!b&eS&psOw(Vwx)Px#O(V#O#P+Z#P#o(V#o#p+x#p#q(V#q#r+x#r;'S(V;'S;=`/R<%lO(V#c$M_]&m!b&hW&jsOr%Trs&Vsw%Twx$NWx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#c$N_]&m!b&hWOr%Trs&Vsw%Twx% Wx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#_% aZ&m!b&hW&osOr1Xrs2Rs#O1X#O#P3q#P#o1X#o#p4`#p#q1X#q#r4`#r;'S1X;'S;=`7i<%lO1X#s%!ae&m!b&eS&hW&b`%}sOr%Trs$JWsw%Twx$MUx!Q%T!Q![$<b![!c%T!c!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#s%$Pm&m!b&eS&hW&b`%}sOr%Trs$@Ssw%Twx$C`x!Q%T!Q![$<b![!c%T!c!h$<b!h!i%!S!i!t$<b!t!u$Fl!u!}$<b!}#O%T#O#P7o#P#R%T#R#S$<b#S#T%T#T#U$<b#U#V$Fl#V#Y$<b#Y#Z%!S#Z#o$<b#o#p8^#p#q%T#q#r8^#r$g%T$g;'S$<b;'S;=`$>Q<%lO$<b#c%&V]!Zs&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%'Z]!YR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#b%(__%sQ&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T#a%)gX!_#T&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#c%*__%rR&m!b&eS&hWOr%Trs&Vsw%Twx/Xx!_%T!_!`# x!`#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T!q%+gX!^!e&eS&hWOr8^rs9Qsw8^wx:dx#O8^#O#P;v#P;'S8^;'S;=`<y<%lO8^#a%,_]%|q&m!b&eS&hWOr%Trs&Vsw%Twx/Xx#O%T#O#P7o#P#o%T#o#p8^#p#q%T#q#r8^#r;'S%T;'S;=`=v<%lO%T",
  tokenizers: [vQe, fQe, hQe, OQe, mQe, EQe, bQe, 0, 1, 2, 3, 4, 5, 6],
  topRules: { Script: [0, 7] },
  specialized: [{ term: 229, get: (r) => TQe[r] || -1 }],
  tokenPrec: 7205
}), QB = /* @__PURE__ */ new k6(), Sq = /* @__PURE__ */ new Set([
  "Script",
  "Body",
  "FunctionDefinition",
  "ClassDefinition",
  "LambdaExpression",
  "ForStatement",
  "MatchClause"
]);
function Um(r) {
  return (e, t, i) => {
    if (i)
      return !1;
    let n = e.node.getChild("VariableName");
    return n && t(n, r), !0;
  };
}
const RQe = {
  FunctionDefinition: /* @__PURE__ */ Um("function"),
  ClassDefinition: /* @__PURE__ */ Um("class"),
  ForStatement(r, e, t) {
    if (t) {
      for (let i = r.node.firstChild; i; i = i.nextSibling)
        if (i.name == "VariableName")
          e(i, "variable");
        else if (i.name == "in")
          break;
    }
  },
  ImportStatement(r, e) {
    var t, i;
    let { node: n } = r, a = ((t = n.firstChild) === null || t === void 0 ? void 0 : t.name) == "from";
    for (let o = n.getChild("import"); o; o = o.nextSibling)
      o.name == "VariableName" && ((i = o.nextSibling) === null || i === void 0 ? void 0 : i.name) != "as" && e(o, a ? "variable" : "namespace");
  },
  AssignStatement(r, e) {
    for (let t = r.node.firstChild; t; t = t.nextSibling)
      if (t.name == "VariableName")
        e(t, "variable");
      else if (t.name == ":" || t.name == "AssignOp")
        break;
  },
  ParamList(r, e) {
    for (let t = null, i = r.node.firstChild; i; i = i.nextSibling)
      i.name == "VariableName" && (!t || !/\*|AssignOp/.test(t.name)) && e(i, "variable"), t = i;
  },
  CapturePattern: /* @__PURE__ */ Um("variable"),
  AsPattern: /* @__PURE__ */ Um("variable"),
  __proto__: null
};
function Tq(r, e) {
  let t = QB.get(e);
  if (t)
    return t;
  let i = [], n = !0;
  function a(o, s) {
    let l = r.sliceString(o.from, o.to);
    i.push({ label: l, type: s });
  }
  return e.cursor(Xt.IncludeAnonymous).iterate((o) => {
    if (o.name) {
      let s = RQe[o.name];
      if (s && s(o, a, n) || !n && Sq.has(o.name))
        return !1;
      n = !1;
    } else if (o.to - o.from > 8192) {
      for (let s of Tq(r, o.node))
        i.push(s);
      return !1;
    }
  }), QB.set(e, i), i;
}
const UB = /^[\w\xa1-\uffff][\w\d\xa1-\uffff]*$/, yq = ["String", "FormatString", "Comment", "PropertyName"];
function AQe(r) {
  let e = Kt(r.state).resolveInner(r.pos, -1);
  if (yq.indexOf(e.name) > -1)
    return null;
  let t = e.name == "VariableName" || e.to - e.from < 20 && UB.test(r.state.sliceDoc(e.from, e.to));
  if (!t && !r.explicit)
    return null;
  let i = [];
  for (let n = e; n; n = n.parent)
    Sq.has(n.name) && (i = i.concat(Tq(r.state.doc, n)));
  return {
    options: i,
    from: t ? e.from : r.pos,
    validFor: UB
  };
}
const _Qe = /* @__PURE__ */ [
  "__annotations__",
  "__builtins__",
  "__debug__",
  "__doc__",
  "__import__",
  "__name__",
  "__loader__",
  "__package__",
  "__spec__",
  "False",
  "None",
  "True"
].map((r) => ({ label: r, type: "constant" })).concat(/* @__PURE__ */ [
  "ArithmeticError",
  "AssertionError",
  "AttributeError",
  "BaseException",
  "BlockingIOError",
  "BrokenPipeError",
  "BufferError",
  "BytesWarning",
  "ChildProcessError",
  "ConnectionAbortedError",
  "ConnectionError",
  "ConnectionRefusedError",
  "ConnectionResetError",
  "DeprecationWarning",
  "EOFError",
  "Ellipsis",
  "EncodingWarning",
  "EnvironmentError",
  "Exception",
  "FileExistsError",
  "FileNotFoundError",
  "FloatingPointError",
  "FutureWarning",
  "GeneratorExit",
  "IOError",
  "ImportError",
  "ImportWarning",
  "IndentationError",
  "IndexError",
  "InterruptedError",
  "IsADirectoryError",
  "KeyError",
  "KeyboardInterrupt",
  "LookupError",
  "MemoryError",
  "ModuleNotFoundError",
  "NameError",
  "NotADirectoryError",
  "NotImplemented",
  "NotImplementedError",
  "OSError",
  "OverflowError",
  "PendingDeprecationWarning",
  "PermissionError",
  "ProcessLookupError",
  "RecursionError",
  "ReferenceError",
  "ResourceWarning",
  "RuntimeError",
  "RuntimeWarning",
  "StopAsyncIteration",
  "StopIteration",
  "SyntaxError",
  "SyntaxWarning",
  "SystemError",
  "SystemExit",
  "TabError",
  "TimeoutError",
  "TypeError",
  "UnboundLocalError",
  "UnicodeDecodeError",
  "UnicodeEncodeError",
  "UnicodeError",
  "UnicodeTranslateError",
  "UnicodeWarning",
  "UserWarning",
  "ValueError",
  "Warning",
  "ZeroDivisionError"
].map((r) => ({ label: r, type: "type" }))).concat(/* @__PURE__ */ [
  "bool",
  "bytearray",
  "bytes",
  "classmethod",
  "complex",
  "float",
  "frozenset",
  "int",
  "list",
  "map",
  "memoryview",
  "object",
  "range",
  "set",
  "staticmethod",
  "str",
  "super",
  "tuple",
  "type"
].map((r) => ({ label: r, type: "class" }))).concat(/* @__PURE__ */ [
  "abs",
  "aiter",
  "all",
  "anext",
  "any",
  "ascii",
  "bin",
  "breakpoint",
  "callable",
  "chr",
  "compile",
  "delattr",
  "dict",
  "dir",
  "divmod",
  "enumerate",
  "eval",
  "exec",
  "exit",
  "filter",
  "format",
  "getattr",
  "globals",
  "hasattr",
  "hash",
  "help",
  "hex",
  "id",
  "input",
  "isinstance",
  "issubclass",
  "iter",
  "len",
  "license",
  "locals",
  "max",
  "min",
  "next",
  "oct",
  "open",
  "ord",
  "pow",
  "print",
  "property",
  "quit",
  "repr",
  "reversed",
  "round",
  "setattr",
  "slice",
  "sorted",
  "sum",
  "vars",
  "zip"
].map((r) => ({ label: r, type: "function" }))), CQe = [
  /* @__PURE__ */ Tr("def ${name}(${params}):\n	${}", {
    label: "def",
    detail: "function",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("for ${name} in ${collection}:\n	${}", {
    label: "for",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("while ${}:\n	${}", {
    label: "while",
    detail: "loop",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("try:\n	${}\nexcept ${error}:\n	${}", {
    label: "try",
    detail: "/ except block",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr(`if \${}:
	
`, {
    label: "if",
    detail: "block",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("if ${}:\n	${}\nelse:\n	${}", {
    label: "if",
    detail: "/ else block",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("class ${name}:\n	def __init__(self, ${params}):\n			${}", {
    label: "class",
    detail: "definition",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("import ${module}", {
    label: "import",
    detail: "statement",
    type: "keyword"
  }),
  /* @__PURE__ */ Tr("from ${module} import ${names}", {
    label: "from",
    detail: "import",
    type: "keyword"
  })
], IQe = /* @__PURE__ */ vP(yq, /* @__PURE__ */ uy(/* @__PURE__ */ _Qe.concat(CQe)));
function $B(r, e) {
  let t = r.baseIndentFor(e), i = r.lineAt(r.pos, -1), n = i.from + i.text.length;
  return /^\s*($|#)/.test(i.text) && r.node.to < n + 100 && !/\S/.test(r.state.sliceDoc(n, r.node.to)) && r.lineIndent(r.pos, -1) <= t || /^\s*(else:|elif |except |finally:)/.test(r.textAfter) && r.lineIndent(r.pos, -1) > t ? null : t + r.unit;
}
const FA = /* @__PURE__ */ wo.define({
  name: "python",
  parser: /* @__PURE__ */ yQe.configure({
    props: [
      /* @__PURE__ */ jl.add({
        Body: (r) => {
          var e;
          return (e = $B(r, r.node)) !== null && e !== void 0 ? e : r.continue();
        },
        IfStatement: (r) => /^\s*(else:|elif )/.test(r.textAfter) ? r.baseIndent : r.continue(),
        TryStatement: (r) => /^\s*(except |finally:|else:)/.test(r.textAfter) ? r.baseIndent : r.continue(),
        "TupleExpression ComprehensionExpression ParamList ArgList ParenthesizedExpression": /* @__PURE__ */ sg({ closing: ")" }),
        "DictionaryExpression DictionaryComprehensionExpression SetExpression SetComprehensionExpression": /* @__PURE__ */ sg({ closing: "}" }),
        "ArrayExpression ArrayComprehensionExpression": /* @__PURE__ */ sg({ closing: "]" }),
        "String FormatString": () => null,
        Script: (r) => {
          if (r.pos + /\s*/.exec(r.textAfter)[0].length >= r.node.to) {
            let e = null;
            for (let t = r.node, i = t.to; t = t.lastChild, !(!t || t.to != i); )
              t.type.name == "Body" && (e = t);
            if (e) {
              let t = $B(r, e);
              if (t != null)
                return t;
            }
          }
          return r.continue();
        }
      }),
      /* @__PURE__ */ Kl.add({
        "ArrayExpression DictionaryExpression SetExpression TupleExpression": Wv,
        Body: (r, e) => ({ from: r.from + 1, to: r.to - (r.to == e.doc.length ? 0 : 1) })
      })
    ]
  }),
  languageData: {
    closeBrackets: {
      brackets: ["(", "[", "{", "'", '"', "'''", '"""'],
      stringPrefixes: [
        "f",
        "fr",
        "rf",
        "r",
        "u",
        "b",
        "br",
        "rb",
        "F",
        "FR",
        "RF",
        "R",
        "U",
        "B",
        "BR",
        "RB"
      ]
    },
    commentTokens: { line: "#" },
    indentOnInput: /^\s*([\}\]\)]|else:|elif |except |finally:)$/
  }
});
function wQe() {
  return new ih(FA, [
    FA.data.of({ autocomplete: AQe }),
    FA.data.of({ autocomplete: IQe })
  ]);
}
const NQe = ql({
  null: A.null,
  instanceof: A.operatorKeyword,
  this: A.self,
  "new super assert open to with void": A.keyword,
  "class interface extends implements enum var": A.definitionKeyword,
  "module package import": A.moduleKeyword,
  "switch while for if else case default do break continue return try catch finally throw": A.controlKeyword,
  "requires exports opens uses provides public private protected static transitive abstract final strictfp synchronized native transient volatile throws": A.modifier,
  IntegerLiteral: A.integer,
  FloatingPointLiteral: A.float,
  "StringLiteral TextBlock": A.string,
  CharacterLiteral: A.character,
  LineComment: A.lineComment,
  BlockComment: A.blockComment,
  BooleanLiteral: A.bool,
  PrimitiveType: A.standard(A.typeName),
  TypeName: A.typeName,
  Identifier: A.variableName,
  "MethodName/Identifier": A.function(A.variableName),
  Definition: A.definition(A.variableName),
  ArithOp: A.arithmeticOperator,
  LogicOp: A.logicOperator,
  BitOp: A.bitwiseOperator,
  CompareOp: A.compareOperator,
  AssignOp: A.definitionOperator,
  UpdateOp: A.updateOperator,
  Asterisk: A.punctuation,
  Label: A.labelName,
  "( )": A.paren,
  "[ ]": A.squareBracket,
  "{ }": A.brace,
  ".": A.derefOperator,
  ", ;": A.separator
}), xQe = { __proto__: null, true: 34, false: 34, null: 42, void: 46, byte: 48, short: 48, int: 48, long: 48, char: 48, float: 48, double: 48, boolean: 48, extends: 62, super: 64, class: 76, this: 78, new: 84, public: 100, protected: 102, private: 104, abstract: 106, static: 108, final: 110, strictfp: 112, default: 114, synchronized: 116, native: 118, transient: 120, volatile: 122, throws: 150, implements: 160, interface: 166, enum: 176, instanceof: 236, open: 265, module: 267, requires: 272, transitive: 274, exports: 276, to: 278, opens: 280, uses: 282, provides: 284, with: 286, package: 290, import: 294, if: 306, else: 308, while: 312, for: 316, var: 323, assert: 330, switch: 334, case: 340, do: 344, break: 348, continue: 352, return: 356, throw: 362, try: 366, catch: 370, finally: 378 }, PQe = No.deserialize({
  version: 14,
  states: "#!hQ]QPOOO&tQQO'#H[O(xQQO'#CbOOQO'#Cb'#CbO)PQPO'#CaO)XOSO'#CpOOQO'#Ha'#HaOOQO'#Cu'#CuO*tQPO'#D_O+_QQO'#HkOOQO'#Hk'#HkO-sQQO'#HfO-zQQO'#HfOOQO'#Hf'#HfOOQO'#He'#HeO0OQPO'#DUO0]QPO'#GlO3TQPO'#D_O3[QPO'#DzO)PQPO'#E[O3}QPO'#E[OOQO'#DV'#DVO5]QQO'#H_O7dQQO'#EeO7kQPO'#EdO7pQPO'#EfOOQO'#H`'#H`O5sQQO'#H`O8sQQO'#FgO8zQPO'#EwO9PQPO'#E|O9PQPO'#FOOOQO'#H_'#H_OOQO'#HW'#HWOOQO'#Gf'#GfOOQO'#HV'#HVO:aQPO'#FhOOQO'#HU'#HUOOQO'#Ge'#GeQ]QPOOOOQO'#Hq'#HqO:fQPO'#HqO:kQPO'#D{O:kQPO'#EVO:kQPO'#EQO:sQPO'#HnO;UQQO'#EfO)PQPO'#C`O;^QPO'#C`O)PQPO'#FbO;cQPO'#FdO;nQPO'#FjO;nQPO'#FmO:kQPO'#FrO;sQPO'#FoO9PQPO'#FvO;nQPO'#FxO]QPO'#F}O;xQPO'#GPO<TQPO'#GRO<`QPO'#GTO;nQPO'#GVO9PQPO'#GWO<gQPO'#GYOOQO'#H['#H[O=WQQO,58{OOQO'#HY'#HYOOOO'#Gg'#GgO>yOSO,59[OOQO,59[,59[OOQO'#Hg'#HgO?jQPO,59eO@lQPO,59yOOQO-E:d-E:dO)PQPO,58zOA`QPO,58zO)PQPO,5;|OAeQPO'#DQOAjQPO'#DQOOQO'#Gi'#GiOBjQQO,59jOOQO'#Dm'#DmODRQPO'#HsOD]QPO'#DlODkQPO'#HrODsQPO,5<^ODxQPO,59^OEcQPO'#CxOOQO,59c,59cOEjQPO,59bOGrQQO'#H[OJVQQO'#CbOJmQPO'#D_OKrQQO'#HkOLSQQO,59pOLZQPO'#DvOLiQPO'#HzOLqQPO,5:`OLvQPO,5:`OM^QPO,5;mOMiQPO'#IROMtQPO,5;dOMyQPO,5=WOOQO-E:j-E:jOOQO,5:f,5:fO! aQPO,5:fO! hQPO,5:vO! mQPO,5<^O)PQPO,5:vO:kQPO,5:gO:kQPO,5:qO:kQPO,5:lO:kQPO,5<^O!!^QPO,59qO9PQPO,5:}O!!eQPO,5;QO9PQPO,59TO!!sQPO'#DXOOQO,5;O,5;OOOQO'#El'#ElOOQO'#En'#EnO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;UO9PQPO,5;eOOQO,5;h,5;hOOQO,5<R,5<RO!!zQPO,5;aO!#]QPO,5;cO!!zQPO'#CyO!#dQQO'#HkO!#rQQO,5;jO]QPO,5<SOOQO-E:c-E:cOOQO,5>],5>]O!%SQPO,5:gO!%bQPO,5:qO!%jQPO,5:lO!%uQPO,5>YOLZQPO,5>YO! {QPO,59UO!&QQQO,58zO!&YQQO,5;|O!&bQQO,5<OO)PQPO,5<OO9PQPO'#DUO]QPO,5<UO]QPO,5<XO!&jQPO'#FqO]QPO,5<ZO]QPO,5<`O!&zQQO,5<bO!'UQPO,5<dO!'ZQPO,5<iOOQO'#Fi'#FiOOQO,5<k,5<kO!'`QPO,5<kOOQO,5<m,5<mO!'eQPO,5<mO!'jQQO,5<oOOQO,5<o,5<oO<jQPO,5<qO!'qQQO,5<rO!'xQPO'#GcO!)OQPO,5<tO<jQPO,5<|O)PQPO,58}O!,|QPO'#ChOOQO1G.k1G.kOOOO-E:e-E:eOOQO1G.v1G.vO!-WQPO,59jO!&QQQO1G.fO)PQPO1G.fO!-eQQO1G1hOOQO,59l,59lO!-mQPO,59lOOQO-E:g-E:gO!-rQPO,5>_O!.ZQPO,5:WO:kQPO'#GnO!.bQPO,5>^OOQO1G1x1G1xOOQO1G.x1G.xO!.{QPO'#CyO!/kQPO'#HkO!/uQPO'#CzO!0TQPO'#HjO!0]QPO,59dOOQO1G.|1G.|OEjQPO1G.|O!0sQPO,59eO!1QQQO'#H[O!1cQQO'#CbOOQO,5:b,5:bO:kQPO,5:cOOQO,5:a,5:aO!1tQQO,5:aOOQO1G/[1G/[O!1yQPO,5:bO!2[QPO'#GqO!2oQPO,5>fOOQO1G/z1G/zO!2wQPO'#DvO!3YQPO'#D_O!3aQPO1G/zO!!zQPO'#GoO!3fQPO1G1XO9PQPO1G1XO:kQPO'#GwO!3nQPO,5>mOOQO1G1O1G1OOOQO1G0Q1G0QO!3vQPO'#E]OOQO1G0b1G0bO!4gQPO1G1xO! hQPO1G0bO!%SQPO1G0RO!%bQPO1G0]O!%jQPO1G0WOOQO1G/]1G/]O!4lQQO1G.pO7kQPO1G0jO)PQPO1G0jO:sQPO'#HnO!6`QQO1G.pOOQO1G.p1G.pO!6eQQO1G0iOOQO1G0l1G0lO!6lQPO1G0lO!6wQQO1G.oO!7_QQO'#HoO!7lQPO,59sO!8{QQO1G0pO!:dQQO1G0pO!;rQQO1G0pO!<PQQO1G0pO!=UQQO1G0pO!=lQQO1G0pO!=vQQO1G1PO!=}QQO'#HkOOQO1G0{1G0{O!?QQQO1G0}OOQO1G0}1G0}OOQO1G1n1G1nO! pQPO'#DqO!ARQPO'#D[O!!zQPO'#D|O!!zQPO'#D}OOQO1G0R1G0RO!AYQPO1G0RO!A_QPO1G0RO!AgQPO1G0RO!ArQPO'#EXOOQO1G0]1G0]O!BVQPO1G0]O!B[QPO'#ETO!!zQPO'#ESOOQO1G0W1G0WO!CUQPO1G0WO!CZQPO1G0WO!CcQPO'#EhO!CjQPO'#EhOOQO'#Gv'#GvO!CrQQO1G0mO!EcQQO1G3tO7kQPO1G3tO!GbQPO'#FWOOQO1G.f1G.fOOQO1G1h1G1hO!GiQPO1G1jOOQO1G1j1G1jO!GtQQO1G1jO!G|QPO1G1pOOQO1G1s1G1sO)aQPO'#D_O+_QQO,5<aO!KtQPO,5<aO!LVQPO,5<]O!L^QPO,5<]OOQO1G1u1G1uOOQO1G1z1G1zOOQO1G1|1G1|O9PQPO1G1|O#!QQPO'#FzOOQO1G2O1G2OO;nQPO1G2TOOQO1G2V1G2VOOQO1G2X1G2XOOQO1G2Z1G2ZOOQO1G2]1G2]OOQO1G2^1G2^O#!XQQO'#H[O##SQQO'#CbO+_QQO'#HkO##}QQOOO#$kQQO'#EeO#$YQQO'#H`OLZQPO'#GdO#$rQPO,5<}OOQO'#HO'#HOO#$zQPO1G2`O#(xQPO'#G[O<jQPO'#G`OOQO1G2`1G2`O#(}QPO1G2hOOQO1G.i1G.iO#.SQQO'#EeO#.dQQO'#H^O#.tQPO'#FSOOQO'#H^'#H^O#/OQPO'#H^O#/mQPO'#IUO#/uQPO,59SOOQO7+$Q7+$QO!&QQQO7+$QOOQO7+'S7+'SOOQO1G/W1G/WO#/zQPO'#DoO#0UQQO'#HtOOQO'#Ht'#HtOOQO1G/r1G/rOOQO,5=Y,5=YOOQO-E:l-E:lO#0fQWO,58{O#0mQPO,59fOOQO,59f,59fO!!zQPO'#HmOD}QPO'#GhO#0{QPO,5>UOOQO1G/O1G/OOOQO7+$h7+$hOOQO1G/{1G/{O#1TQQO1G/{OOQO1G/}1G/}O#1YQPO1G/{OOQO1G/|1G/|O:kQPO1G/}OOQO,5=],5=]OOQO-E:o-E:oOOQO7+%f7+%fOOQO,5=Z,5=ZOOQO-E:m-E:mO9PQPO7+&sOOQO7+&s7+&sOOQO,5=c,5=cOOQO-E:u-E:uO#1_QPO'#EUO#1mQPO'#EUOOQO'#Gu'#GuO#2UQPO,5:wOOQO,5:w,5:wOOQO7+'d7+'dOOQO7+%|7+%|OOQO7+%m7+%mO!AYQPO7+%mO!A_QPO7+%mO!AgQPO7+%mOOQO7+%w7+%wO!BVQPO7+%wOOQO7+%r7+%rO!CUQPO7+%rO!CZQPO7+%rOOQO7+&U7+&UOOQO'#Ee'#EeO7kQPO7+&UO7kQPO,5>YO#2uQPO7+$[OOQO7+&T7+&TOOQO7+&W7+&WO9PQPO'#GjO#3TQPO,5>ZOOQO1G/_1G/_O9PQPO7+&kO#3`QQO,59eO#4cQPO'#DrO! pQPO'#DrO#4nQPO'#HwO#4vQPO,5:]O#5aQQO'#HgO#5|QQO'#CuO! mQPO'#HvO#6lQPO'#DpO#6vQPO'#HvO#7XQPO'#DpO#7aQPO'#IPO#7fQPO'#E`OOQO'#Hp'#HpOOQO'#Gk'#GkO#7nQPO,59vOOQO,59v,59vO#7uQPO'#HqOOQO,5:h,5:hO#9]QPO'#H|OOQO'#EP'#EPOOQO,5:i,5:iO#9hQPO'#EYO:kQPO'#EYO#9yQPO'#H}O#:UQPO,5:sO! mQPO'#HvO!!zQPO'#HvO#:^QPO'#DpOOQO'#Gs'#GsO#:eQPO,5:oOOQO,5:o,5:oOOQO,5:n,5:nOOQO,5;S,5;SO#;_QQO,5;SO#;fQPO,5;SOOQO-E:t-E:tOOQO7+&X7+&XOOQO7+)`7+)`O#;mQQO7+)`OOQO'#Gz'#GzO#=ZQPO,5;rOOQO,5;r,5;rO#=bQPO'#FXO)PQPO'#FXO)PQPO'#FXO)PQPO'#FXO#=pQPO7+'UO#=uQPO7+'UOOQO7+'U7+'UO]QPO7+'[O#>QQPO1G1{O! mQPO1G1{O#>`QQO1G1wO!!sQPO1G1wO#>gQPO1G1wO#>nQQO7+'hOOQO'#G}'#G}O#>uQPO,5<fOOQO,5<f,5<fO#>|QPO'#HqO9PQPO'#F{O#?UQPO7+'oO#?ZQPO,5=OO! mQPO,5=OO#?`QPO1G2iO#@iQPO1G2iOOQO1G2i1G2iOOQO-E:|-E:|OOQO7+'z7+'zO!2[QPO'#G^O<jQPO,5<vOOQO,5<z,5<zO#@qQPO7+(SOOQO7+(S7+(SO#DoQPO,59TO#DvQPO'#ITO#EOQPO,5;nO)PQPO'#GyO#ETQPO,5>pOOQO1G.n1G.nOOQO<<Gl<<GlO#E]QPO'#HuO#EeQPO,5:ZOOQO1G/Q1G/QOOQO,5>X,5>XOOQO,5=S,5=SOOQO-E:f-E:fO#EjQPO7+%gOOQO7+%g7+%gOOQO7+%i7+%iOOQO<<J_<<J_O#FQQPO'#H[O#FXQPO'#CbO#F`QPO,5:pO#FeQPO,5:xO#1_QPO,5:pOOQO-E:s-E:sOOQO1G0c1G0cOOQO<<IX<<IXO!AYQPO<<IXO!A_QPO<<IXOOQO<<Ic<<IcOOQO<<I^<<I^O!CUQPO<<I^OOQO<<Ip<<IpO#FjQQO<<GvO7kQPO<<IpO)PQPO<<IpOOQO<<Gv<<GvO#H^QQO,5=UOOQO-E:h-E:hO#HkQQO<<JVOOQO,5:^,5:^O!!zQPO'#DsO#IRQPO,5:^O! pQPO'#GpO#I^QPO,5>cOOQO1G/w1G/wO#IfQPO'#HsO#ImQPO,59xO#IrQPO,5>bO! mQPO,59xO#I}QPO,5:[O#7fQPO,5:zO! mQPO,5>bO!!zQPO,5>bO#7aQPO,5>kOOQO,5:[,5:[OLvQPO'#DtOOQO,5>k,5>kO#JVQPO'#EaOOQO,5:z,5:zO#MWQPO,5:zO!!zQPO'#DxOOQO-E:i-E:iOOQO1G/b1G/bOOQO,5:y,5:yO!!zQPO'#GrO#M]QPO,5>hOOQO,5:t,5:tO#MhQPO,5:tO#MvQPO,5:tO#NXQPO'#GtO#NoQPO,5>iO#NzQPO'#EZOOQO1G0_1G0_O$ RQPO1G0_O! mQPO,5:pOOQO-E:q-E:qOOQO1G0Z1G0ZOOQO1G0n1G0nO$ WQQO1G0nOOQO<<Lz<<LzOOQO-E:x-E:xOOQO1G1^1G1^O$ _QQO,5;sOOQO'#G{'#G{O#=bQPO,5;sOOQO'#IV'#IVO$ gQQO,5;sO$ xQQO,5;sOOQO<<Jp<<JpO$!QQPO<<JpOOQO<<Jv<<JvO9PQPO7+'gO$!VQPO7+'gO!!sQPO7+'cO$!eQPO7+'cO$!jQQO7+'cOOQO<<KS<<KSOOQO-E:{-E:{OOQO1G2Q1G2QOOQO,5<g,5<gO$!qQQO,5<gOOQO<<KZ<<KZO9PQPO1G2jO$!xQPO1G2jOOQO,5=l,5=lOOQO7+(T7+(TO$!}QPO7+(TOOQO-E;O-E;OO$$lQWO'#HfO$$WQWO'#HfO$$sQPO'#G_O:kQPO,5<xOLZQPO,5<xOOQO1G2b1G2bOOQO<<Kn<<KnO$%UQQO1G.oOOQO1G1Z1G1ZO$%`QPO'#GxO$%mQPO,5>oOOQO1G1Y1G1YO$%uQPO'#FTOOQO,5=e,5=eOOQO-E:w-E:wO$%zQPO'#GmO$&XQPO,5>aOOQO1G/u1G/uOOQO<<IR<<IROOQO1G0[1G0[O$&aQPO1G0dO$&fQPO1G0[O$&kQPO1G0dOOQOAN>sAN>sO!AYQPOAN>sOOQOAN>xAN>xOOQOAN?[AN?[O7kQPOAN?[O$&pQPO,5:_OOQO1G/x1G/xOOQO,5=[,5=[OOQO-E:n-E:nO$&{QPO,5>eOOQO1G/d1G/dOOQO1G3|1G3|O$'^QPO1G/dOOQO1G/v1G/vOOQO1G0f1G0fO#MWQPO1G0fO#7aQPO'#HyO$'cQPO1G3|O! mQPO1G3|OOQO1G4V1G4VOK^QPO'#DvOJmQPO'#D_OOQO,5:{,5:{O$'nQPO,5:{O$'nQPO,5:{O$'uQQO'#H_O$'|QQO'#H`O$(WQQO'#EbO$(cQPO'#EbOOQO,5:d,5:dOOQO,5=^,5=^OOQO-E:p-E:pOOQO1G0`1G0`O$(kQPO1G0`OOQO,5=`,5=`OOQO-E:r-E:rO$(yQPO,5:uOOQO7+%y7+%yOOQO7+&Y7+&YOOQO1G1_1G1_O$)QQQO1G1_OOQO-E:y-E:yO$)YQQO'#IWO$)TQPO1G1_O$ mQPO1G1_O)PQPO1G1_OOQOAN@[AN@[O$)eQQO<<KRO9PQPO<<KRO$)lQPO<<J}OOQO<<J}<<J}O!!sQPO<<J}OOQO1G2R1G2RO$)qQQO7+(UO9PQPO7+(UOOQO<<Ko<<KoP!'xQPO'#HQOLZQPO'#HPO$){QPO,5<yO$*WQPO1G2dO:kQPO1G2dOOQO,5=d,5=dOOQO-E:v-E:vO#DoQPO,5;oOOQO,5=X,5=XOOQO-E:k-E:kO$*]QPO7+&OOOQO7+%v7+%vO$*kQPO7+&OOOQOG24_G24_OOQOG24vG24vO$*pQPO1G/yO$*{QPO1G4POOQO7+%O7+%OOOQO7+&Q7+&QOOQO7+)h7+)hO$+^QPO7+)hO!0bQPO,5:aOOQO1G0g1G0gO$+iQPO1G0gO$+pQPO,59qO$,UQPO,5:|O7kQPO,5:|OOQO7+%z7+%zOOQO7+&y7+&yO)PQPO'#G|O$,ZQPO,5>rO$,cQPO7+&yO$,hQQO'#IXOOQOAN@mAN@mO$,sQQOAN@mOOQOAN@iAN@iO$,zQPOAN@iO$-PQQO<<KpO$-ZQPO,5=kOOQO-E:}-E:}OOQO7+(O7+(OO$-lQPO7+(OO$-qQPO<<IjOOQO<<Ij<<IjO#DoQPO<<IjO$-qQPO<<IjOOQO<<MS<<MSOOQO7+&R7+&RO$.PQPO1G0jO$.[QQO1G0hOOQO1G0h1G0hO$.dQPO1G0hO$.iQQO,5=hOOQO-E:z-E:zOOQO<<Je<<JeO$.tQPO,5>sOOQOG26XG26XOOQOG26TG26TOOQO<<Kj<<KjOOQOAN?UAN?UO#DoQPOAN?UO$.|QPOAN?UO$/RQPOAN?UO7kQPO7+&SO$/aQPO7+&SOOQO7+&S7+&SO$/fQPOG24pOOQOG24pG24pO#DoQPOG24pO$/kQPO<<InOOQO<<In<<InOOQOLD*[LD*[O$/pQPOLD*[OOQOAN?YAN?YOOQO!$'Mv!$'MvO)PQPO'#CaO$/uQQO'#H[O$0YQQO'#CbO!!zQPO'#Cy",
  stateData: "$0u~OPOSQOS%wOS~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~OWiXW&OXZ&OXuiXu&OX!P&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~O#o$]X~P$wOWUXW&ZXZUXuUXu&ZX!PUX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~O#o$]X~P&{O%}RO&P!bO~O&U!gO&W!eO~Og]Oh]O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO%{SO%}!hO&PVOg!RXh!RX$g!RX%}!RX&P!RX~O#x!mO#y!lO$V!nOv!RX!u!RX!z!RX&r!RX~P)aOW!xOu!oO%{SO%}!sO&P!sO&t&_X~OW!{Ou&YX%{&YX%}&YX&P&YX&t&YXY&YXw&YX&l&YX&o&YXZ&YXq&YX&[&YX!P&YX#_&YX#a&YX#c&YX#d&YX#e&YX#f&YX#g&YX#h&YX#j&YX#n&YX#q&YX}&YX!r&YX#o&YXs&YX|&YX~O&]!yO~P+sO&]&YX~P+sOZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO#eoO#qnO#soO#toO%{SO&VTO~O%}!}O&P!|OY&nP~P.RO%{SOg%`Xh%`Xv%`X!S%`X!T%`X!U%`X!V%`X!W%`X!X%`X!Y%`X!Z%`X!]%`X!^%`X!_%`X!u%`X!z%`X$g%`X%}%`X&P%`X&r%`X&]%`X~O!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xOg!RXh!RXv!RX!u!RX!z!RX%}!RX&P!RX&r!RX&]!RX~O$g!RX~P1sO|#[O~P]Og]Oh]Ov#aO!u#cO!z#bO%}!hO&PVO&r#`O~O$g#dO~P3cOu#fO&t#gO!P&RX#_&RX#a&RX#c&RX#d&RX#e&RX#f&RX#g&RX#h&RX#j&RX#n&RX#q&RX&[&RX&]&RX&l&RX~OW#eOY&RX#o&RXs&RXq&RX|&RX~P4UO!b#hO#]#hOW&SXu&SX!P&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SXY&SX#o&SXs&SXq&SX|&SX~OZ#XX~P5sOZ#iO~O&t#gO~O#_#mO#a#nO#c#oO#d#oO#e#pO#f#qO#g#rO#h#rO#j#vO#n#sO#q#tO&[#kO&]#kO&l#lO~O!P#uO~P7uO&v#wO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O#eoO#qnO#soO#toO%{SO%}0iO&P0hO&VTO~O#o#{O~O![#}O~O%}!sO&P!sO~Og]Oh]O%}!hO&PVO&]!yO~OW$TO&t#gO~O#y!lO~O!W$XO%}RO&P!bO~OZ$YO~OZ$]O~O!P$dO%}$cO&P$cO~O!P$fO%}$cO&P$cO~O!P$iO~P9POZ$lO}bO~OW$oOZ$pOgTahTa%{Ta%}Ta&PTa~OvTa!STa!TTa!UTa!VTa!WTa!XTa!YTa!ZTa!]Ta!^Ta!_Ta!uTa!zTa#xTa#yTa$VTa$gTa&rTauTaYTa&]TaqTa|Ta!PTa~P<oO&U$sO&W!eO~Ou!oO%{SOqma&[maYma&lma!Pma~O&tma}ma!rma~P?RO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!ZyO!]xO!^xO!_xO~Og!Rah!Rav!Ra!u!Ra!z!Ra$g!Ra%}!Ra&P!Ra&r!Ra&]!Ra~P?wO#y$vO~Os$xO~Ou$yO%{SO~Ou!oO%{ra%}ra&Pra&traYrawra&lra&ora!Pra&[raqra~OWra#_ra#ara#cra#dra#era#fra#gra#hra#jra#nra#qra&]ra#orasra|ra~PArOu!oO%{SOq&gX!P&gX!b&gX~OY&gX#o&gX~PCpO!b$|Oq!`X!P!`XY!`X~Oq$}O!P&fX~O!P%PO~Ov%QO~Og]Oh]O%{0gO%}!hO&PVO&`%TO~O&[&^P~PD}O%{SO%}!hO&PVO~OWiXW&OXY&OXZ&OXuiXu&OX!b&OX#]&OX#_&OX#a&OX#c&OX#d&OX#e&OX#f&OX#g&OX#h&OX#j&OX#n&OX#q&OX%{iX%}iX&PiX&[&OX&]iX&]&OX&l&OX&tiX&t&OX&v!aX~OYiXY!aXq!aXwiX&liX&oiX~PEuOWUXW&ZXYUXZUXuUXu&ZX!bUX#]UX#_UX#aUX#cUX#dUX#eUX#fUX#gUX#hUX#jUX#nUX#qUX%{&ZX%}&ZX&P&ZX&[UX&]UX&]&ZX&lUX&tUX&t&ZX&v!aX~OY!aXY&ZXq!aXw&ZX&l&ZX&o&ZX~PHYOg]Oh]O%{SO%}!hO&PVOg!RXh!RX%}!RX&P!RX~P?wOu!oOw%_O%{SO%}%[O&P%ZO&o%^O~OW!xOY&_X&l&_X&t&_X~PK^OY%aO~P7uOg]Oh]O%}!hO&PVO~Oq%cOY&nX~OY%eO~Og]Oh]O%{SO%}!hO&PVOY&nP~P?wOY%kO&l%iO&t#gO~Oq%lO&v#wOY&uX~OY%nO~O%{SOg%`ah%`av%`a!S%`a!T%`a!U%`a!V%`a!W%`a!X%`a!Y%`a!Z%`a!]%`a!^%`a!_%`a!u%`a!z%`a$g%`a%}%`a&P%`a&r%`a&]%`a~O|%oO~P]O}%pO~Ou!oO%{SO%}!sO&P!sO~Op%|Ow%}O%}RO&P!bO&]!yO~Oz%{O~P! {Oz&PO%}RO&P!bO&]!yO~OY&cP~P9POg]Oh]O%{SO%}!hO&PVO~O}bO~P9POW!xOu!oO%{SO&t&_X~O#q#tO!P#ra#_#ra#a#ra#c#ra#d#ra#e#ra#f#ra#g#ra#h#ra#j#ra#n#ra&[#ra&]#ra&l#raY#ra#o#ras#raq#ra|#ra~Oo&dO}&cO!r&eO&]&bO~O}&jO!r&eO~Oo&nO}&mO&]&bO~OZ#iOu&rO%{SO~OW$oO}&xO~OW$oO!P&zO~OW&{O!P&|O~O$g!VO%}0iO&P0hO!P&cP~P.RO!P'XO#o'YO~P7uO}'ZO~O$b']O~O!P'^O~O!P'_O~O!P'`O~P7uO!P'bO~P7uOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wO%P'mO%T'nOZ$|a_$|a`$|aa$|ab$|ac$|ae$|ag$|ah$|ap$|av$|aw$|az$|a}$|a!P$|a!S$|a!T$|a!U$|a!V$|a!W$|a!X$|a!Y$|a!Z$|a![$|a!]$|a!^$|a!_$|a!u$|a!z$|a#e$|a#q$|a#s$|a#t$|a#x$|a#y$|a$V$|a$X$|a$_$|a$b$|a$d$|a$g$|a$k$|a$m$|a$r$|a$t$|a$v$|a$x$|a${$|a$}$|a%u$|a%{$|a%}$|a&P$|a&V$|a&r$|a|$|a$`$|a$p$|a~O}'tOY&xP~P9PO}ra!rra&|ra~PArOW$oO!P'{O~Os'|O~Ou!oO%{SOq&ga!P&ga!b&gaY&ga#o&ga~O}'}O~P9POq$}O!P&fa~Og]Oh]O%{0gO%}!hO&PVO~O&`(UO~P!.jOu!oO%{SOq&_X&[&_XY&_X&l&_X!P&_X~O}&_X!r&_X~P!/SOo(WOp(WOqnX&[nX~Oq(XO&[&^X~O&[(ZO~Ou!oOw(]O%{SO%}RO&P!bO~OYma&lma&tma~P!0bOW&OXY!aXq!aXu!aX%{!aX~OWUXY!aXq!aXu!aX%{!aX~OW(`O~Ou!oO%{SO%}!sO&P!sO&o(bO~Og]Oh]O%{SO%}!hO&PVO~P?wOq%cOY&na~Ou!oO%{SO%}!sO&P!sO&o%^O~O%{SO~P1sOY(eO~OY(hO&l%iO~Oq%lOY&ua~Og]Oh]OvzO|(pO!u|O%{SO%}!hO&PVO&rcO~P?wO!P(qO~OW^iZ#XXu^i!P^i!b^i#]^i#_^i#a^i#c^i#d^i#e^i#f^i#g^i#h^i#j^i#n^i#q^i&[^i&]^i&l^i&t^iY^i#o^is^iq^i|^i~OW)QO~Os)RO~P7uOz)SO%}RO&P!bO~O!P]iY]i#o]is]iq]i|]i~P7uOq)TOY&cX!P&cX~P7uOY)VO~O#q#tO!P#^i#_#^i#a#^i#c#^i#d#^i#e#^i#f#^i#j#^i#n#^i&[#^i&]#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#g#rO#h#rO~P!7qO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#a#^i#c#^i#d#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#e#pO~P!9VO#_#mO#f#qO#g#rO#h#rO#j#vO#q#tO&[#kO&]#kO!P#^i#c#^i#d#^i#n#^iY#^i#o#^is#^iq#^i|#^i~O#a#nO#e#pO&l#lO~P!:kO#e#^i~P!9VO#q#tO!P#^i#a#^i#c#^i#d#^i#e#^i#f#^i#n#^i&l#^iY#^i#o#^is#^iq#^i|#^i~O#_#mO#g#rO#h#rO#j#vO&[#kO&]#kO~P!<WO#g#^i#h#^i~P!7qO#o)WO~P7uO#_&_X#a&_X#c&_X#d&_X#e&_X#f&_X#g&_X#h&_X#j&_X#n&_X#q&_X&]&_X#o&_Xs&_X|&_X~P!/SO!P#kiY#ki#o#kis#kiq#ki|#ki~P7uOg]Oh]OvzO}bO!P)fO!SxO!TxO!UxO!VxO!W)jO!XxO!YxO!ZyO!]xO!^xO!_xO!u|O!z{O%{SO%})^O&P)_O&]&bO&rcO~O|)iO~P!?hO}&cO~O}&cO!r&eO~Oo&dO}&cO!r&eO~O%{SO%}!sO&P!sO|&qP!P&qP~P?wO}&jO~Og]Oh]OvzO|)xO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wO}&mO~Oo&nO}&mO~Os)zO~P9POu)|O%{SO~Ou&rO}'}O%{SOW#Zi!P#Zi#_#Zi#a#Zi#c#Zi#d#Zi#e#Zi#f#Zi#g#Zi#h#Zi#j#Zi#n#Zi#q#Zi&[#Zi&]#Zi&l#Zi&t#ZiY#Zi#o#Zis#Ziq#Zi|#Zi~O}&cOW&biu&bi!P&bi#_&bi#a&bi#c&bi#d&bi#e&bi#f&bi#g&bi#h&bi#j&bi#n&bi#q&bi&[&bi&]&bi&l&bi&t&biY&bi#o&bis&biq&bi|&bi~O#|*UO$O*VO$Q*VO$R*WO$S*XO~O|*TO~P!GPO$Y*YO%}RO&P!bO~OW*ZO!P*[O~O$`*]OZ$^i_$^i`$^ia$^ib$^ic$^ie$^ig$^ih$^ip$^iv$^iw$^iz$^i}$^i!P$^i!S$^i!T$^i!U$^i!V$^i!W$^i!X$^i!Y$^i!Z$^i![$^i!]$^i!^$^i!_$^i!u$^i!z$^i#e$^i#q$^i#s$^i#t$^i#x$^i#y$^i$V$^i$X$^i$_$^i$b$^i$d$^i$g$^i$k$^i$m$^i$r$^i$t$^i$v$^i$x$^i${$^i$}$^i%u$^i%{$^i%}$^i&P$^i&V$^i&r$^i|$^i$p$^i~Og]Oh]O$g#dO%}!hO&PVO~O!P*aO~P9PO!P*bO~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op!OOvzOwjOz}O}bO!PuO!SxO!TxO!UxO!VxO!WxO!XxO!YxO!Z*gO![!_O!]xO!^xO!_xO!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$p*hO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&rcO~O|*fO~P!LcOWiXW&OXY&OXZ&OXuiXu&OX!P&OX%{iX%}iX&PiX&]iX&tiX&t&OX~OWUXW&ZXYUXZUXuUXu&ZX!PUX%{&ZX%}&ZX&P&ZX&]&ZX&tUX&t&ZX~OW#eOu#fO&t#gO~OW&SXY%WXu&SX!P%WX&t&SX~OZ#XX~P#$YOY*nO!P*lO~O%P'mO%T'nOZ$|i_$|i`$|ia$|ib$|ic$|ie$|ig$|ih$|ip$|iv$|iw$|iz$|i}$|i!P$|i!S$|i!T$|i!U$|i!V$|i!W$|i!X$|i!Y$|i!Z$|i![$|i!]$|i!^$|i!_$|i!u$|i!z$|i#e$|i#q$|i#s$|i#t$|i#x$|i#y$|i$V$|i$X$|i$_$|i$b$|i$d$|i$g$|i$k$|i$m$|i$r$|i$t$|i$v$|i$x$|i${$|i$}$|i%u$|i%{$|i%}$|i&P$|i&V$|i&r$|i|$|i$`$|i$p$|i~OZ*qO~O%P'mO%T'nOZ%Ui_%Ui`%Uia%Uib%Uic%Uie%Uig%Uih%Uip%Uiv%Uiw%Uiz%Ui}%Ui!P%Ui!S%Ui!T%Ui!U%Ui!V%Ui!W%Ui!X%Ui!Y%Ui!Z%Ui![%Ui!]%Ui!^%Ui!_%Ui!u%Ui!z%Ui#e%Ui#q%Ui#s%Ui#t%Ui#x%Ui#y%Ui$V%Ui$X%Ui$_%Ui$b%Ui$d%Ui$g%Ui$k%Ui$m%Ui$r%Ui$t%Ui$v%Ui$x%Ui${%Ui$}%Ui%u%Ui%{%Ui%}%Ui&P%Ui&V%Ui&r%Ui|%Ui$`%Ui$p%Ui~OW&SXu&SX#_&SX#a&SX#c&SX#d&SX#e&SX#f&SX#g&SX#h&SX#j&SX#n&SX#q&SX&[&SX&]&SX&l&SX&t&SX~O!b*vO#]#hOY&SXZ#XX~P#,{OY&QXq&QX|&QX!P&QX~P7uO}'tO|&wP~P9POY&QXg%YXh%YX%{%YX%}%YX&P%YXq&QX|&QX!P&QX~Oq*yOY&xX~OY*{O~O}'}O|&iP~P9POq&hX!P&hX|&hXY&hX~P7uO&`Ta~P<oOo(WOp(WOqna&[na~Oq(XO&[&^a~OW+TO~Ow+UO~Ou!oO%{SO%}+YO&P+XO~Og]Oh]Ov#aO!u#cO%}!hO&PVO&r#`O~Og]Oh]OvzO|+_O!u|O%{SO%}!hO&PVO&rcO~P?wOw+jO%}RO&P!bO&]!yO~Oq)TOY&ca!P&ca~O#_ma#ama#cma#dma#ema#fma#gma#hma#jma#nma#qma&]ma#omasma|ma~P?ROo+oOq!fX&[!fX~Oq+qO&[&kX~O&[+sO~OW&ZXu&ZX%{&ZX%}&ZX&P&ZX&]&ZX~OZ!aX~P#4{OWiXuiX%{iX%}iX&PiX&]iX~OZ!aX~P#5hOg]Oh]Ov#aO!u#cO!z#bO&]&bO&r#`O~O%})^O&P)_O~P#6TOg]Oh]O%{SO%})^O&P)_O~O}bO!P+}O~OZ,OO~O},QO!m,TO~O|,VO~P!?hO}bOg&eXh&eXv&eX!S&eX!T&eX!U&eX!V&eX!W&eX!X&eX!Y&eX!Z&eX!]&eX!^&eX!_&eX!u&eX!z&eX%{&eX%}&eX&P&eX&]&eX&r&eX~Oq,XO}&pX!P&pX~OZ#iO}&cOq!|X|!|X!P!|X~Oq,^O|&qX!P&qX~O|,aO!P,`O~O&]&bO~P3cOg]Oh]OvzO|,eO!P)vO!u|O!z{O%{SO%}!hO&PVO&]&bO&rcO~P?wOs,fO~P7uOs,fO~P9PO}&cOW&bqu&bq!P&bq#_&bq#a&bq#c&bq#d&bq#e&bq#f&bq#g&bq#h&bq#j&bq#n&bq#q&bq&[&bq&]&bq&l&bq&t&bqY&bq#o&bqs&bqq&bq|&bq~O|,jO~P!GPO!W,nO#},nO%}RO&P!bO~O!P,qO~O$Y,rO%}RO&P!bO~O!b$|O#o,tOq!`X!P!`X~O!P,vO~P7uO!P,vO~P9PO!P,yO~P7uO|,{O~P!LcO![#}O#o,|O~O!P-OO~O!b-PO~OY-SOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOY-SO!P-TO~O%P'mO%T'nOZ%Uq_%Uq`%Uqa%Uqb%Uqc%Uqe%Uqg%Uqh%Uqp%Uqv%Uqw%Uqz%Uq}%Uq!P%Uq!S%Uq!T%Uq!U%Uq!V%Uq!W%Uq!X%Uq!Y%Uq!Z%Uq![%Uq!]%Uq!^%Uq!_%Uq!u%Uq!z%Uq#e%Uq#q%Uq#s%Uq#t%Uq#x%Uq#y%Uq$V%Uq$X%Uq$_%Uq$b%Uq$d%Uq$g%Uq$k%Uq$m%Uq$r%Uq$t%Uq$v%Uq$x%Uq${%Uq$}%Uq%u%Uq%{%Uq%}%Uq&P%Uq&V%Uq&r%Uq|%Uq$`%Uq$p%Uq~O}'tO~P9POq-`O|&wX~O|-bO~Oq*yOY&xa~Oq-fO|&iX~O|-hO~Ow-iO~Oq!aXu!aX!P!aX!b!aX%{!aX~OZ&OX~P#EoOZUX~P#EoO!P-jO~OZ-kO~OW^yZ#XXu^y!P^y!b^y#]^y#_^y#a^y#c^y#d^y#e^y#f^y#g^y#h^y#j^y#n^y#q^y&[^y&]^y&l^y&t^yY^y#o^ys^yq^y|^y~OY%^aq%^a!P%^a~P7uO!P#myY#my#o#mys#myq#my|#my~P7uOo+oOq!fa&[!fa~Oq+qO&[&ka~OZ,OO~PCpO!P-xO~O!m,TO}&ja!P&ja~O}bO!P-{O~OZ_O_UO`UOaUObUOcUOeUOg]Oh]Op.ZOvzOw.YOz}O|.UO}bO!PuO![!_O!u|O!z{O#eoO#qnO#soO#toO#x!QO#y!PO$V!RO$X!SO$_!TO$b!UO$d!WO$g!VO$k!XO$m!YO$r!ZO$t![O$v!]O$x!^O${!`O$}!aO%{SO%}QO&PPO&VTO&]!yO&rcO~P?wO},QO~Oq,XO}&pa!P&pa~O}&cOq!|a|!|a!P!|a~OZ#iO}&cOq!|a|!|a!P!|a~O%{SO%}!sO&P!sOq%hX|%hX!P%hX~P?wOq,^O|&qa!P&qa~O|!}X~P!?hO|.eO~Os.fO~P7uOW$oO!P.gO~OW$oO$P.lO%}RO&P!bO!P&zP~OW$oO$T.mO~O!P.nO~O!b$|O#o.pOq!`X!P!`X~OY.rO~O!P.sO~P7uO#o.tO~P7uO!b.vO~OY.wOZ$YO_UO`UOaUObUOcUOeUOg]Oh]Op!OOwjOz}O%{SO%}'dO&P'cO&VTO~P?wOW!{Ou&YX%{&YX%}&YX&P&YX&|&YX~O&]!yO~P$$WOu!oO%{SO&|.yO%}%RX&P%RX~OY&QXq&QX~P7uO}'tOq%lX|%lX~P9POq-`O|&wa~O!b/PO~O}'}Oq%aX|%aX~P9POq-fO|&ia~OY/SO~O!P/TO~OZ/UO~O&l%iOq!ga&[!ga~Ou!oO%{SO}&ma!P&ma!m&ma~O!P/ZO~O!m,TO}&ji!P&ji~O|/`O~P]OW/bO~P4UOZ#iO!P&SX~P#,{OW$TOZ#iO&t#gO~Op/dOw/dO~O}&cOq!|i|!|i!P!|i~O|!}a~P!?hOW$oO!P/fO~OW$oOq/gO!P&zX~OY/kO~P7uOY/mO~OY%Wq!P%Wq~P7uO&|.yO%}%Ra&P%Ra~OY/rO~Ou!oO!P/uO!Z/vO%{SO~OY/wO~O&l%iOq!gi&[!gi~Ou!oO%{SO}&mi!P&mi!m&mi~O!m,TO}&jq!P&jq~O|/yO~P]Op/{Ow%}Oz%{O%}RO&P!bO&]!yO~O!P/|O~Oq/gO!P&za~O!P0QO~OW$oOq/gO!P&{X~OY0SO~P7uOY0TO~OY%Wy!P%Wy~P7uOu!oO%{SO%}%sa&P%sa&|%sa~OY0UO~Ou!oO!P0VO!Z0WO%{SO~Op0ZO%}RO&P!bO~OW)QOZ#iO~O!P0]O~OW$oOq%pa!P%pa~Oq/gO!P&{a~O!P0_O~Ou!oO!P0_O!Z0`O%{SO~O!P0bO~O!P0cO~O!P0eO~O!P0fO~O#o&OXY&OXs&OXq&OX|&OX~P$wO#oUXYUXsUXqUX|UX~P&{O`Q_P#f&Vc~",
  goto: "#(V&|PPPP&}'b*q-tP'bPP.Y.^/rPPPPP1^P2vPP4`7P9j<T<m>bPPP>hP@|PPPAv2vPCoPPDjPEaEgPPPPPPPPPPPPFpGXPJ_JgJqKZKaKgMVMZMZMcPMrNx! k! uP!![NxP!!b!!l!!{!#TP!#r!#|!$SNx!$V!$]EaEa!$a!$k!$n2v!&Y2v2v!(RP.^P!(VP!(vPPPPPP.^P.^!)d.^PP.^P.^PP.^!*x!+SPP!+Y!+cPPPPPPPP&}P&}PP!+g!+g!+z!+gPP!+gP!+gP!,e!,hP!+g!-O!+gP!+gP!-R!-UP!+gP!+gP!+gP!+gP!+g!+gP!+gP!-YP!-`!-c!-iP!+g!-u!-x!.Q!.d!2a!2g!2m!3s!3y!4T!5X!5_!5e!5o!5u!5{!6R!6X!6_!6e!6k!6q!6w!6}!7T!7Z!7e!7k!7u!7{PPP!8R!+g!8vP!<XP!=]P!?n!@U!CQ2vPPP!Dn!HY!JwPP!Mb!MeP# n# t##b##q##w#$w#%a#&[#&e#&h#&tP#&w#'TP#'[#'cP#'fP#'oP#'r#'u#'x#'|#(SssObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/a'kqOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l$p${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e't'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q*v+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-`-f-w.Q.S.T.V.W.d.p.s.v.x/P/S/Y/_/a/p/t/v/w0W0Y0`0j#rgO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`t!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gQ#^cS%`#P.SQ%s#`U%x#e$T/bQ&P#gW'g$l*l-T.xU'q$o&{*ZQ'r$pS(^%Y/_U(}%z+i/zQ)S&QQ+[(lQ+g)QQ-c*yR-m+]u!dS!P!R!S!l!n$X$v*U*V*W*X,m,o.l.m/g0gT$q!c(T#upO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#tkO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`X'h$l*l-T.x#}UO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`#}jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jQ%W!{Q([%XV-V*q-Z.y%tZOW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-V*q-Z.y%t[OW_bdnow}!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*v+o+{,O,Q,T,X,`,t,v-P-T-`-f.T.V.W.d.p.s.v.x/P/a/v0W0`0jV-W*q-Z.yS!zZ-VS$S}%{S%z#e$TQ&Q#gQ+i)QQ.[,QR/z/b$eYO_bnow!X!Z!^!`!y#]#f#h#i#m#n#o#p#q#r#s#v#w#{$Y$Z$[$]$^$_$l$p$|%i%k&d&e&n&r'T'Y'Z't'}(W(X(h)T)W)|*]*a*b*e*h*l*v+o,Q,T,X,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q%U!yR+R(X%u^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0j!o!qX!i!r!t#P#_#y$t${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0Y#|jO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q$Z!TQ$[!UQ$a!YQ$j!_R*i']Q#jhS&v$R)PQ(|%yQ*Q&wQ+f)OQ,[)oQ-q+hQ.a,]Q/W-rS/c.Y.ZQ/}/dQ0[/{R0a0ZQ&f$OW(s%t&g&h&iQ*P&vU+`(t(u(vQ,Z)oQ,h*QS-n+a+bS.`,[,]Q/V-oR/e.aX)f&c)h,`.drdObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW#R_#U%c,OQ'S$]W'i$l*l-T.xS(m%p(oW)a&c)h,`.dS)p&j,^S)u&m)wR-Z*qh!vX!V#_#d'R(l)`)s*_+]+w,cQ(R$}Q(_%^R+V(b#rmObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`v!tX!V#P#_#d$}%^%b%f'R'e(b(l*_*k+]-Y.S.|Q#W_Q$OzQ$P{Q$Q|Q%t#aQ%u#bQ%v#cQ(j%lS)Y&b+qY)d&c)a)h,`.dS)o&j,^Q+p)ZW+t)`)s+w,cQ+|)bQ,])pT.O+z.QU(P$|'}-fR*O&uW)f&c)h,`.dT)v&m)wQ&i$OQ&q$QQ(v%tQ({%vY)b&c)a)h,`.dV)t&m)u)wQ)[&bR-u+qQ+n)YR-t+p#tmO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`Q,P)dS-w+t.OR.R+|T#U_,OU#S_#U,OR(c%cQ,S)eQ-y+vQ-}+yQ/].PR/x/^ruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$m!aQ&`#wQ'a$jQ'p$nW)f&c)h,`.dQ*s'nQ+})cQ,W)jQ-[*rR-{+xrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS(n%p(oW)f&c)h,`.dT)v&m)wQ&h$OS(u%t&iR+b(vQ&g$OQ&l$PU(t%t&h&iQ(x%uS+a(u(vR-o+bQ)n&eR)y&nQ&p$QS(z%v&qR+e({Q&o$QU(y%v&p&qS+d(z({R-p+eS(n%p(oT)v&m)wrsObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW)f&c)h,`.dT)v&m)wQ&k$PS(w%u&lR+c(xQ)q&jR.b,^R,b)rQ%q#^R(r%sT(n%p(oQ,R)eS-|+y,SR/[-}R.W,QWj$l*l-T.x#ukO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`#|hO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`U%y#e$T/bS)O%z/zQ+h)QR-r+iT&t$R&u!]#ml#Q$`$h$k&O&R&S&V&W&X&Y&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o!V#nl#Q$`$h$k&O&R&S&W&[&_'s(O){*`*c+k+m,g,x,}-^.o.u/l/o#umO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,Q,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`a'u$p't*v-`/P/v0W0`Q'w$pR-d*yQ&y$UQ'y$uR*|'zT*R&x*SsuObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/artObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aQ$e![R$g!]R$^!WruObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aR'T$]R$_!WR'[$aT*d'Z*eX'k$m'l'p*tR*r'mQ-Y*qR.|-ZQ'o$mQ*p'lQ*u'pR-]*tR$n!aQ'j$lV-R*l-T.xQwOQ#]bW#|w#].V/aQ.V,QR/a.WrWObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/al!kW!p#O#Y#x%R%X%g&s'Q)Z+{.T0j!j!pX!i!t#P#_#y${%S%Y%b%f&]'R'e(l)X)`)s*_*k+]+t+w+z,c-X-w.Q.S/S/Y/_/p/t/w0YQ#O_Q#Y`#^#xno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%i%k&d&e&n&r'T'Y't'}(W(h)T)W)|*a*b*h*v+o,T,X,t,v-P-`-f.p.s.v/P/v0W0`S%R!y(XQ%X!{j%g#U%c%p&c&j&m(o)h)w*q,^,`.dS&s$R&uY'Q$]$l*l-T.xS)Z&b+qS+{)b)tQ.T,OR0j#vQ!fTR$r!fQ(Y%UR+S(Y^!rX#P#y&]'R'e)Xx$t!i#_%S%Y%b%f(l)`)s*_*k+]+w+z,c-X.Q.S/_/p[$z!r$t${/Y/t0YS${!t+tQ/Y-wQ/t/SR0Y/wQ)U&SR+l)UQ)h&cS,U)h.dR.d,`!laO_bw!Z#U#]#{$Z$[$]$^$_$l%c%p&c&j&m'Z(o)h)w*]*e*l*q,O,Q,^,`-T.V.W.d.x/aY!jW#O%g'Q.TT#Za!jQ-g*}R/R-gQ%O!vR(S%OQ%j#VS(g%j/XR/X-sQ+r)[R-v+rQ%d#SR(d%dQ,Y)lR._,YQ)w&mR,d)wQ,_)qR.c,_Q(o%pR+^(oQ&u$RR)}&uQ%m#WR(k%mQ-a*wR/O-aQ*z'wR-e*zQ*S&xR,i*SQ,m*UR.i,mQ/h.jS0P/h0RR0R/jQ*e'ZR,z*eQ'l$mS*o'l*tR*t'pQ.z-XR/q.zQ*m'jR-U*m`vObw#],Q.V.W/aQ$b!ZQ&a#{Q'O$ZQ'P$[Q'V$^Q'W$_S*d'Z*eR,s*]'YrOWX_`bnow!X!Z!^!`!i!p!t!y!{#O#P#U#Y#]#_#f#h#i#m#n#o#p#q#r#s#v#w#x#y#{$R$Y$Z$[$]$^$_$l${$|%R%S%X%Y%b%c%f%g%i%k%p&]&b&c&d&e&j&m&n&r&s&u'Q'R'T'Y'Z'e'}(W(X(h(l(o)T)W)X)Z)`)b)h)s)t)w)|*]*_*a*b*e*h*k*l*q+]+o+q+t+w+z+{,O,Q,T,X,^,`,c,t,v-P-T-X-f-w.Q.S.T.V.W.d.p.s.v.x/S/Y/_/a/p/t/w0Y0ja'v$p't*v-`/P/v0W0`Q!cSQ$U!PQ$V!RQ$W!SQ$u!lQ$w!nQ&}$XQ'z$vQ(T0gS,k*U*WQ,o*VQ,p*XQ.h,mS.j,o.lQ/j.mR0O/g%oROS_bcnow!P!R!S!X!Z!^!`!l!n#P#]#`#e#f#g#h#i#m#n#o#p#q#r#s#w#{$T$X$Y$Z$[$]$^$_$l$o$p$v$|%Y%k%z&Q&r&{'T'Y'Z't'}(h(l)Q)T)W)|*U*V*W*X*Z*]*a*b*e*h*l*v*y+]+i,Q,m,o,t,v-P-T-`-f.S.V.W.l.m.p.s.v.x/P/_/a/b/g/v/z0W0`0gQ'x$pQ*w'tS-_*v/PQ.}-`Q0X/vQ0^0WR0d0`rlObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aS#Q_$YQ#tnQ#zoQ$`!XQ$h!^Q$k!`Q&O#fQ&R#hY&S#i$]*a,v.sQ&U#mQ&V#nQ&W#oQ&X#pQ&Y#qQ&Z#rQ&[#sQ&_#w^'s$p't-`/P/v0W0`U(O$|'}-fQ(i%kQ){&rQ*`'TQ*c'YQ+W(hQ+k)TQ+m)WQ,g)|Q,x*bQ,}*hQ-^*vQ.o,tQ.u-PQ/l.pR/o.v#rfO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*v,t,v-P-`-f.V.W.p.s.v/P/a/v0W0`W'f$l*l-T.xR.X,QrXObw!Z#]#{$Z$[$^$_'Z*]*e,Q.V.W/aW!iW#x%R'QQ#P_Q#_d!|#yno!X!^!`#f#h#i#m#n#o#p#q#r#s#w$Y$p$|%k&r'T'Y't'}(h)T)W)|*a*b*h*v,t,v-P-`-f.p.s.v/P/v0W0`d%S!y%i&d&e&n(W(X+o,T,XQ%Y#OQ%b#RS%f#U%cQ&]#vQ'R$]W'e$l*l-T.xS(l%p(oQ)X0jW)`&c)h,`.dS)s&m)wQ*_'SQ*k'iQ+](mQ+w)aS+z)b)tQ,c)uS-X*q-ZQ.Q+{Q.S,OQ/_.TR/p.y%t^OW_bdnow!X!Z!^!`!y#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$Y$Z$[$]$^$_$l$p$|%R%c%i%k%p&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jQ$R}Q&w$SR)P%{&PVOW_bdnow}!X!Z!^!`!y!{#O#R#U#]#f#h#i#m#n#o#p#q#r#s#v#w#x#{$S$Y$Z$[$]$^$_$l$p$|%R%X%c%i%k%p%{&c&d&e&m&n&r'Q'S'T'Y'Z'i't'}(W(X(h(m(o)T)W)a)b)h)t)u)w)|*]*a*b*e*h*l*q*v+o+{,O,Q,T,X,`,t,v-P-T-Z-`-f.T.V.W.d.p.s.v.x.y/P/a/v0W0`0jR%V!y#ziObnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`Q#V_Q%U!yQ&^#vQ(f%iQ)k&dU)l&e&n,TQ+Q(WQ+R(XQ-s+oR.^,XQ(V%TR+P(U#|eO_bnow!X!Z!^!`#]#f#h#i#m#n#o#p#q#r#s#w#{$Y$Z$[$]$^$_$l$p$|%k&r'T'Y'Z't'}(h)T)W)|*]*a*b*e*h*l*v,Q,t,v-P-T-`-f.V.W.p.s.v.x/P/a/v0W0`T%w#e/bQ&T#iQ'U$]Q,w*aQ.q,vR/n.sX)g&c)h,`.d!{`OW_abw!Z!j#O#U#]#{$Z$[$]$^$_$l%c%g%p&c&j&m'Q'Z(o)h)w*]*e*l*q,O,Q,^,`-T.T.V.W.d.x/aU!wX!V'RU%r#_#d*_S+Z(l)sQ+u)`S-l+],cR-z+wj!uX!V#_#d$}%^(b(l)`)s+]+w,cU%]#P%f.SQ(a%bQ*^'RQ*j'eQ,u*_Q-Q*kQ.{-YR/s.|Q(Q$|Q*}'}R/Q-fR+O'}[)c&c&m)h)w,`.dT+x)a)uR)]&bW+v)`)s+w,cQ.P+zR/^.QS#T_,OR%h#US)m&e&nR.],TR)r&jW)e&c)h,`.dR+y)aR#X_R*x'tR'x$pT,l*U,mQ.k,oR/i.lR/i.m",
  nodeNames: " LineComment BlockComment Program ModuleDeclaration MarkerAnnotation Identifier ScopedIdentifier . Annotation ) ( AnnotationArgumentList AssignmentExpression FieldAccess IntegerLiteral FloatingPointLiteral BooleanLiteral CharacterLiteral StringLiteral TextBlock null ClassLiteral void PrimitiveType TypeName ScopedTypeName GenericType TypeArguments AnnotatedType Wildcard extends super , ArrayType ] Dimension [ class this ParenthesizedExpression ObjectCreationExpression new ArgumentList } { ClassBody ; FieldDeclaration Modifiers public protected private abstract static final strictfp default synchronized native transient volatile VariableDeclarator Definition AssignOp ArrayInitializer MethodDeclaration TypeParameters TypeParameter TypeBound FormalParameters ReceiverParameter FormalParameter SpreadParameter Throws throws Block ClassDeclaration Superclass SuperInterfaces implements InterfaceTypeList InterfaceDeclaration interface ExtendsInterfaces InterfaceBody ConstantDeclaration EnumDeclaration enum EnumBody EnumConstant EnumBodyDeclarations AnnotationTypeDeclaration AnnotationTypeBody AnnotationTypeElementDeclaration StaticInitializer ConstructorDeclaration ConstructorBody ExplicitConstructorInvocation ArrayAccess MethodInvocation MethodName MethodReference ArrayCreationExpression Dimension AssignOp BinaryExpression CompareOp CompareOp LogicOp BitOp BitOp LogicOp ArithOp ArithOp ArithOp BitOp InstanceofExpression instanceof LambdaExpression InferredParameters TernaryExpression LogicOp : UpdateExpression UpdateOp UnaryExpression LogicOp BitOp CastExpression ElementValueArrayInitializer ElementValuePair open module ModuleBody ModuleDirective requires transitive exports to opens uses provides with PackageDeclaration package ImportDeclaration import Asterisk ExpressionStatement LabeledStatement Label IfStatement if else WhileStatement while ForStatement for ForSpec LocalVariableDeclaration var EnhancedForStatement ForSpec AssertStatement assert SwitchStatement switch SwitchBlock SwitchLabel case DoStatement do BreakStatement break ContinueStatement continue ReturnStatement return SynchronizedStatement ThrowStatement throw TryStatement try CatchClause catch CatchFormalParameter CatchType FinallyClause finally TryWithResourcesStatement ResourceSpecification Resource",
  maxTerm: 274,
  nodeProps: [
    ["group", -26, 4, 47, 76, 77, 82, 87, 92, 144, 146, 149, 150, 152, 155, 157, 160, 162, 164, 166, 171, 173, 175, 177, 179, 180, 182, 190, "Statement", -25, 6, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 39, 40, 41, 99, 100, 102, 103, 106, 117, 119, 121, 124, 126, 129, "Expression", -7, 23, 24, 25, 26, 27, 29, 34, "Type"],
    ["openedBy", 10, "(", 44, "{"],
    ["closedBy", 11, ")", 45, "}"]
  ],
  propSources: [NQe],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 28,
  tokenData: "#$f_R!_OX%QXY'fYZ)bZ^'f^p%Qpq'fqr*|rs,^st%Qtu4euv5qvw7Rwx8ixyAQyzAnz{B[{|CQ|}Dh}!OEU!O!PFo!P!Q! i!Q!R!,_!R![!0V![!]!>g!]!^!?w!^!_!@e!_!`!BO!`!a!Br!a!b!D`!b!c!EO!c!}!Kz!}#O!MW#O#P%Q#P#Q!Mt#Q#R!Nb#R#S4e#S#T%Q#T#o4e#o#p# U#p#q# r#q#r##[#r#s##x#s#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%QS%VV&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS%qO&WSS%tVOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZS&^VOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QS&vP;=`<%l%QS&|UOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZS'cP;=`<%l&Z_'mk&WS%wZOX%QXY'fYZ)bZ^'f^p%Qpq'fqr%Qrs%qs#y%Q#y#z'f#z$f%Q$f$g'f$g#BY%Q#BY#BZ'f#BZ$IS%Q$IS$I_'f$I_$I|%Q$I|$JO'f$JO$JT%Q$JT$JU'f$JU$KV%Q$KV$KW'f$KW&FU%Q&FU&FV'f&FV;'S%Q;'S;=`&s<%lO%Q_)iY&WS%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XZ*^Y%wZX^*Xpq*X#y#z*X$f$g*X#BY#BZ*X$IS$I_*X$I|$JO*X$JT$JU*X$KV$KW*X&FU&FV*XV+TX#sP&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QU+wV#_Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT,aXOY,|YZ%lZr,|rs3Ys#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T-PXOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT-qX&WSOY-lYZ%lZr-lrs.^s#O-l#O#P.x#P;'S-l;'S;=`2|<%lO-lT.cVcPOY&ZYZ%lZr&Zrs&ys;'S&Z;'S;=`'`<%lO&ZT.}V&WSOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT/iW&WSOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0UWOY0RZr0Rrs0ns#O0R#O#P0s#P;'S0R;'S;=`1V<%lO0RP0sOcPP0vTOY0RYZ0RZ;'S0R;'S;=`1V<%lO0RP1YP;=`<%l0RT1`XOY,|YZ%lZr,|rs1{s#O,|#O#P2d#P;'S,|;'S;=`3S<%lO,|T2QUcPOY&ZYZ%lZr&Zs;'S&Z;'S;=`'`<%lO&ZT2gVOY-lYZ/dZr-lrs1]s;'S-l;'S;=`2|<%lO-lT3PP;=`<%l-lT3VP;=`<%l,|T3_VcPOY&ZYZ%lZr&Zrs3ts;'S&Z;'S;=`'`<%lO&ZT3yR&USXY4SYZ4`pq4SP4VRXY4SYZ4`pq4SP4eO&VP_4la%}Z&WSOY%QYZ%lZr%Qrs%qst%Qtu4eu!Q%Q!Q![4e![!c%Q!c!}4e!}#R%Q#R#S4e#S#T%Q#T#o4e#o;'S%Q;'S;=`&s<%lO%QU5xX#gQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU6lV#]Q&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV7YZ&lR&WSOY%QYZ%lZr%Qrs%qsv%Qvw7{w!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QU8SV#aQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT8nZ&WSOY9aYZ%lZr9ars:osw9awx%Qx#O9a#O#P;y#P;'S9a;'S;=`@z<%lO9aT9fX&WSOY%QYZ%lZr%Qrs%qsw%Qwx:Rx;'S%Q;'S;=`&s<%lO%QT:YVbP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT:rXOY&ZYZ%lZr&Zrs&ysw&Zwx;_x;'S&Z;'S;=`'`<%lO&ZT;dVbPOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT<OZ&WSOY<qYZ%lZr<qrs=isw<qwx9ax#O<q#O#P9a#P;'S<q;'S;=`?T<%lO<qT<vZ&WSOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT=lZOY>_YZ%lZr>_rs?Zsw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_T>bZOY<qYZ%lZr<qrs=isw<qwx:Rx#O<q#O#P%Q#P;'S<q;'S;=`?T<%lO<qT?WP;=`<%l<qT?^ZOY>_YZ%lZr>_rs@Psw>_wx;_x#O>_#O#P&Z#P;'S>_;'S;=`@t<%lO>_P@SVOY@PZw@Pwx@ix#O@P#P;'S@P;'S;=`@n<%lO@PP@nObPP@qP;=`<%l@PT@wP;=`<%l>_T@}P;=`<%l9a_AXVZZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVAuVYR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVBeX$YP&WS#fQOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVCXZ#eR&WSOY%QYZ%lZr%Qrs%qs{%Q{|Cz|!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QVDRV#qR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVDoVqR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QVE][#eR&WSOY%QYZ%lZr%Qrs%qs}%Q}!OCz!O!_%Q!_!`6e!`!aFR!a;'S%Q;'S;=`&s<%lO%QVFYV&vR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_FvZWY&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PGi!P!Q%Q!Q![Hw![;'S%Q;'S;=`&s<%lO%QVGnX&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!PHZ!P;'S%Q;'S;=`&s<%lO%QVHbV&oR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTIOc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#R%Q#R#SNq#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTJbV&WS`POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QTJ|]&WSOY%QYZ%lZr%Qrs%qs{%Q{|Ku|}%Q}!OKu!O!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTKzX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![;'S%Q;'S;=`&s<%lO%QTLnc&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![!f%Q!f!gJZ!g!h%Q!h!iJZ!i#R%Q#R#SMy#S#W%Q#W#XJZ#X#Y%Q#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QTNOZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Lg![#R%Q#R#SMy#S;'S%Q;'S;=`&s<%lO%QTNvZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![#R%Q#R#SNq#S;'S%Q;'S;=`&s<%lO%Q_! p]&WS#fQOY%QYZ%lZr%Qrs%qsz%Qz{!!i{!P%Q!P!Q!)[!Q!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%Q_!!nX&WSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!#`T&WSOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!#rTOz!#oz{!$R{;'S!#o;'S;=`!$p<%lO!#oZ!$UVOz!#oz{!$R{!P!#o!P!Q!$k!Q;'S!#o;'S;=`!$p<%lO!#oZ!$pOQZZ!$sP;=`<%l!#o_!$yXOY!%fYZ!#ZZr!%frs!'psz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!%iXOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{;'S!!i;'S;=`!'j<%lO!!i_!&ZZ&WSOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!'TV&WSQZOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!'mP;=`<%l!!i_!'sXOY!%fYZ!#ZZr!%frs!#osz!%fz{!(`{;'S!%f;'S;=`!)U<%lO!%f_!(cZOY!!iYZ!#ZZr!!irs!$vsz!!iz{!&U{!P!!i!P!Q!&|!Q;'S!!i;'S;=`!'j<%lO!!i_!)XP;=`<%l!%f_!)cV&WSPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!)}VPZOY!*dYZ%lZr!*drs!+Us;'S!*d;'S;=`!,X<%lO!*d_!*iVPZOY!)[YZ%lZr!)[rs!)xs;'S!)[;'S;=`!+O<%lO!)[_!+RP;=`<%l!)[_!+ZVPZOY!*dYZ%lZr!*drs!+ps;'S!*d;'S;=`!,X<%lO!*dZ!+uSPZOY!+pZ;'S!+p;'S;=`!,R<%lO!+pZ!,UP;=`<%l!+p_!,[P;=`<%l!*dT!,fu&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!d%Q!d!e!3a!e!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o!q%Q!q!r!5_!r!z%Q!z!{!7V!{#R%Q#R#S!2i#S#U%Q#U#V!3a#V#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a#c%Q#c#d!5_#d#l%Q#l#m!7V#m;'S%Q;'S;=`&s<%lO%QT!/Qa&WS`POY%QYZ%lZr%Qrs%qs!Q%Q!Q![Hw![!f%Q!f!gJZ!g!hJw!h!iJZ!i#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z;'S%Q;'S;=`&s<%lO%QT!0^i&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!.y!P!Q%Q!Q![!0V![!f%Q!f!gJZ!g!hJw!h!iJZ!i!n%Q!n!o!1{!o#R%Q#R#S!2i#S#W%Q#W#XJZ#X#YJw#Y#ZJZ#Z#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!2SV&WS_POY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT!2nZ&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!0V![#R%Q#R#S!2i#S;'S%Q;'S;=`&s<%lO%QT!3fY&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S;'S%Q;'S;=`&s<%lO%QT!4]`&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!R!4U!R!S!4U!S!n%Q!n!o!1{!o#R%Q#R#S!3a#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!5dX&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y;'S%Q;'S;=`&s<%lO%QT!6W_&WS_POY%QYZ%lZr%Qrs%qs!Q%Q!Q!Y!6P!Y!n%Q!n!o!1{!o#R%Q#R#S!5_#S#`%Q#`#a!1{#a;'S%Q;'S;=`&s<%lO%QT!7[_&WSOY%QYZ%lZr%Qrs%qs!O%Q!O!P!8Z!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QT!8`]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i#T%Q#T#Z!9X#Z;'S%Q;'S;=`&s<%lO%QT!9^c&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#R%Q#R#S!8Z#S#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!:pi&WS_POY%QYZ%lZr%Qrs%qs!O%Q!O!P!<_!P!Q%Q!Q![!:i![!c%Q!c!i!:i!i!n%Q!n!o!1{!o!r%Q!r!sJw!s#R%Q#R#S!=i#S#T%Q#T#Z!:i#Z#`%Q#`#a!1{#a#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!<da&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!9X![!c%Q!c!i!9X!i!r%Q!r!sJw!s#T%Q#T#Z!9X#Z#d%Q#d#eJw#e;'S%Q;'S;=`&s<%lO%QT!=n]&WSOY%QYZ%lZr%Qrs%qs!Q%Q!Q![!:i![!c%Q!c!i!:i!i#T%Q#T#Z!:i#Z;'S%Q;'S;=`&s<%lO%QV!>nX#oR&WSOY%QYZ%lZr%Qrs%qs![%Q![!]!?Z!];'S%Q;'S;=`&s<%lO%QV!?bV&tR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!@OV!PR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!@lY&]Z&WSOY%QYZ%lZr%Qrs%qs!^%Q!^!_!A[!_!`+p!`;'S%Q;'S;=`&s<%lO%QU!AcX#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV!BVX!bR&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`;'S%Q;'S;=`&s<%lO%QV!ByY&[R&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`+p!`!a!Ci!a;'S%Q;'S;=`&s<%lO%QU!CpY#hQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`!a!A[!a;'S%Q;'S;=`&s<%lO%Q_!DiV&`X#nQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!EVX%{Z&WSOY%QYZ%lZr%Qrs%qs#]%Q#]#^!Er#^;'S%Q;'S;=`&s<%lO%QV!EwX&WSOY%QYZ%lZr%Qrs%qs#b%Q#b#c!Fd#c;'S%Q;'S;=`&s<%lO%QV!FiX&WSOY%QYZ%lZr%Qrs%qs#h%Q#h#i!GU#i;'S%Q;'S;=`&s<%lO%QV!GZX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!Gv#Y;'S%Q;'S;=`&s<%lO%QV!G{X&WSOY%QYZ%lZr%Qrs%qs#f%Q#f#g!Hh#g;'S%Q;'S;=`&s<%lO%QV!HmX&WSOY%QYZ%lZr%Qrs%qs#Y%Q#Y#Z!IY#Z;'S%Q;'S;=`&s<%lO%QV!I_X&WSOY%QYZ%lZr%Qrs%qs#T%Q#T#U!Iz#U;'S%Q;'S;=`&s<%lO%QV!JPX&WSOY%QYZ%lZr%Qrs%qs#V%Q#V#W!Jl#W;'S%Q;'S;=`&s<%lO%QV!JqX&WSOY%QYZ%lZr%Qrs%qs#X%Q#X#Y!K^#Y;'S%Q;'S;=`&s<%lO%QV!KeV&rR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_!LRa&PZ&WSOY%QYZ%lZr%Qrs%qst%Qtu!Kzu!Q%Q!Q![!Kz![!c%Q!c!}!Kz!}#R%Q#R#S!Kz#S#T%Q#T#o!Kz#o;'S%Q;'S;=`&s<%lO%Q_!M_VuZ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV!M{VsR&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QU!NiX#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`;'S%Q;'S;=`&s<%lO%QV# ]V}R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q_# {Z&|X#cQ&WSOY%QYZ%lZr%Qrs%qs!_%Q!_!`6e!`#p%Q#p#q#!n#q;'S%Q;'S;=`&s<%lO%QU#!uV#dQ&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QV##cV|R&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%QT#$PV#tP&WSOY%QYZ%lZr%Qrs%qs;'S%Q;'S;=`&s<%lO%Q",
  tokenizers: [0, 1, 2, 3],
  topRules: { Program: [0, 3] },
  dynamicPrecedences: { 27: 1, 230: -1, 241: -1 },
  specialized: [{ term: 229, get: (r) => xQe[r] || -1 }],
  tokenPrec: 7067
}), LQe = /* @__PURE__ */ wo.define({
  parser: /* @__PURE__ */ PQe.configure({
    props: [
      /* @__PURE__ */ jl.add({
        IfStatement: /* @__PURE__ */ mo({ except: /^\s*({|else\b)/ }),
        TryStatement: /* @__PURE__ */ mo({ except: /^\s*({|catch|finally)\b/ }),
        LabeledStatement: F6,
        SwitchBlock: (r) => {
          let e = r.textAfter, t = /^\s*\}/.test(e), i = /^\s*(case|default)\b/.test(e);
          return r.baseIndent + (t ? 0 : i ? 1 : 2) * r.unit;
        },
        Block: /* @__PURE__ */ sg({ closing: "}" }),
        BlockComment: () => -1,
        Statement: /* @__PURE__ */ mo({ except: /^{/ })
      }),
      /* @__PURE__ */ Kl.add({
        "Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody ConstructorBody InterfaceBody ArrayInitializer": Wv,
        BlockComment(r) {
          return { from: r.from + 2, to: r.to - 2 };
        }
      })
    ]
  }),
  languageData: {
    commentTokens: { line: "//", block: { open: "/*", close: "*/" } },
    indentOnInput: /^\s*(?:case |default:|\{|\})$/
  }
});
function DQe() {
  return new ih(LQe);
}
let ee;
(function(r) {
  r.QUOTED_IDENTIFIER = "QUOTED_IDENTIFIER", r.IDENTIFIER = "IDENTIFIER", r.STRING = "STRING", r.VARIABLE = "VARIABLE", r.RESERVED_KEYWORD = "RESERVED_KEYWORD", r.RESERVED_FUNCTION_NAME = "RESERVED_FUNCTION_NAME", r.RESERVED_PHRASE = "RESERVED_PHRASE", r.RESERVED_SET_OPERATION = "RESERVED_SET_OPERATION", r.RESERVED_CLAUSE = "RESERVED_CLAUSE", r.RESERVED_SELECT = "RESERVED_SELECT", r.RESERVED_JOIN = "RESERVED_JOIN", r.ARRAY_IDENTIFIER = "ARRAY_IDENTIFIER", r.ARRAY_KEYWORD = "ARRAY_KEYWORD", r.CASE = "CASE", r.END = "END", r.WHEN = "WHEN", r.ELSE = "ELSE", r.THEN = "THEN", r.LIMIT = "LIMIT", r.BETWEEN = "BETWEEN", r.AND = "AND", r.OR = "OR", r.XOR = "XOR", r.OPERATOR = "OPERATOR", r.COMMA = "COMMA", r.ASTERISK = "ASTERISK", r.DOT = "DOT", r.OPEN_PAREN = "OPEN_PAREN", r.CLOSE_PAREN = "CLOSE_PAREN", r.LINE_COMMENT = "LINE_COMMENT", r.BLOCK_COMMENT = "BLOCK_COMMENT", r.NUMBER = "NUMBER", r.NAMED_PARAMETER = "NAMED_PARAMETER", r.QUOTED_PARAMETER = "QUOTED_PARAMETER", r.NUMBERED_PARAMETER = "NUMBERED_PARAMETER", r.POSITIONAL_PARAMETER = "POSITIONAL_PARAMETER", r.CUSTOM_PARAMETER = "CUSTOM_PARAMETER", r.DELIMITER = "DELIMITER", r.EOF = "EOF";
})(ee || (ee = {}));
const Rq = (r) => ({
  type: ee.EOF,
  raw: "EOF",
  text: "EOF",
  start: r
}), Uc = Rq(1 / 0), sp = (r) => (e) => e.type === r.type && e.text === r.text, Xl = {
  ARRAY: sp({
    text: "ARRAY",
    type: ee.RESERVED_KEYWORD
  }),
  BY: sp({
    text: "BY",
    type: ee.RESERVED_KEYWORD
  }),
  SET: sp({
    text: "SET",
    type: ee.RESERVED_CLAUSE
  }),
  STRUCT: sp({
    text: "STRUCT",
    type: ee.RESERVED_KEYWORD
  }),
  WINDOW: sp({
    text: "WINDOW",
    type: ee.RESERVED_CLAUSE
  })
}, Aq = (r) => r === ee.RESERVED_KEYWORD || r === ee.RESERVED_FUNCTION_NAME || r === ee.RESERVED_PHRASE || r === ee.RESERVED_CLAUSE || r === ee.RESERVED_SELECT || r === ee.RESERVED_SET_OPERATION || r === ee.RESERVED_JOIN || r === ee.ARRAY_KEYWORD || r === ee.CASE || r === ee.END || r === ee.WHEN || r === ee.ELSE || r === ee.THEN || r === ee.LIMIT || r === ee.BETWEEN || r === ee.AND || r === ee.OR || r === ee.XOR, MQe = (r) => r === ee.AND || r === ee.OR || r === ee.XOR, re = (r) => r.flatMap(kQe), kQe = (r) => _q(QQe(r)).map((e) => e.trim()), VB = /[^[\]{}]+/y, GB = /\{.*?\}/y, BB = /\[.*?\]/y, QQe = (r) => {
  let e = 0;
  const t = [];
  for (; e < r.length; ) {
    VB.lastIndex = e;
    const i = VB.exec(r);
    i && (t.push([i[0].trim()]), e += i[0].length), BB.lastIndex = e;
    const n = BB.exec(r);
    if (n) {
      const o = n[0].slice(1, -1).split("|").map((s) => s.trim());
      t.push(["", ...o]), e += n[0].length;
    }
    GB.lastIndex = e;
    const a = GB.exec(r);
    if (a) {
      const o = a[0].slice(1, -1).split("|").map((s) => s.trim());
      t.push(o), e += a[0].length;
    }
    if (!i && !n && !a)
      throw new Error(`Unbalanced parenthesis in: ${r}`);
  }
  return t;
}, _q = ([r, ...e]) => r === void 0 ? [""] : _q(e).flatMap((t) => r.map((i) => i.trim() + " " + t.trim())), UQe = (r) => [...new Set(r)], lg = (r) => r[r.length - 1], Cq = (r) => r.sort((e, t) => t.length - e.length || e.localeCompare(t)), Iq = (r) => r.reduce((e, t) => Math.max(e, t.length), 0), wq = (r) => r.replace(/\s+/gu, " "), wt = (r) => UQe(Object.values(r).flat()), XA = (r) => /\n/.test(r), $Qe = wt({
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#reserved_keywords
  keywords: ["ALL", "AND", "ANY", "ARRAY", "AS", "ASC", "ASSERT_ROWS_MODIFIED", "AT", "BETWEEN", "BY", "CASE", "CAST", "COLLATE", "CONTAINS", "CREATE", "CROSS", "CUBE", "CURRENT", "DEFAULT", "DEFINE", "DESC", "DISTINCT", "ELSE", "END", "ENUM", "ESCAPE", "EXCEPT", "EXCLUDE", "EXISTS", "EXTRACT", "FALSE", "FETCH", "FOLLOWING", "FOR", "FROM", "FULL", "GROUP", "GROUPING", "GROUPS", "HASH", "HAVING", "IF", "IGNORE", "IN", "INNER", "INTERSECT", "INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LIKE", "LIMIT", "LOOKUP", "MERGE", "NATURAL", "NEW", "NO", "NOT", "NULL", "NULLS", "OF", "ON", "OR", "ORDER", "OUTER", "OVER", "PARTITION", "PRECEDING", "PROTO", "RANGE", "RECURSIVE", "RESPECT", "RIGHT", "ROLLUP", "ROWS", "SELECT", "SET", "SOME", "STRUCT", "TABLE", "TABLESAMPLE", "THEN", "TO", "TREAT", "TRUE", "UNBOUNDED", "UNION", "UNNEST", "USING", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN"],
  datatypes: [
    "ARRAY",
    // parametric, ARRAY<T>
    "BOOL",
    "BYTES",
    // parameterised, BYTES(Length)
    "DATE",
    "DATETIME",
    "GEOGRAPHY",
    "INTERVAL",
    "INT64",
    "INT",
    "SMALLINT",
    "INTEGER",
    "BIGINT",
    "TINYINT",
    "BYTEINT",
    "NUMERIC",
    // parameterised, NUMERIC(Precision[, Scale])
    "DECIMAL",
    // parameterised, DECIMAL(Precision[, Scale])
    "BIGNUMERIC",
    // parameterised, BIGNUMERIC(Precision[, Scale])
    "BIGDECIMAL",
    // parameterised, BIGDECIMAL(Precision[, Scale])
    "FLOAT64",
    "STRING",
    // parameterised, STRING(Length)
    "STRUCT",
    // parametric, STRUCT<T>
    "TIME",
    "TIMEZONE"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions#formatting_syntax
  stringFormat: ["HEX", "BASEX", "BASE64M", "ASCII", "UTF-8", "UTF8"],
  misc: ["SAFE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  ddl: [
    "LIKE",
    // CREATE TABLE LIKE
    "COPY",
    // CREATE TABLE COPY
    "CLONE",
    // CREATE TABLE CLONE
    "IN",
    "OUT",
    "INOUT",
    "RETURNS",
    "LANGUAGE",
    "CASCADE",
    "RESTRICT",
    "DETERMINISTIC"
  ]
}), VQe = wt({
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aead_encryption_functions
  aead: ["KEYS.NEW_KEYSET", "KEYS.ADD_KEY_FROM_RAW_BYTES", "AEAD.DECRYPT_BYTES", "AEAD.DECRYPT_STRING", "AEAD.ENCRYPT", "KEYS.KEYSET_CHAIN", "KEYS.KEYSET_FROM_JSON", "KEYS.KEYSET_TO_JSON", "KEYS.ROTATE_KEYSET", "KEYS.KEYSET_LENGTH"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_analytic_functions
  aggregateAnalytic: ["ANY_VALUE", "ARRAY_AGG", "AVG", "CORR", "COUNT", "COUNTIF", "COVAR_POP", "COVAR_SAMP", "MAX", "MIN", "ST_CLUSTERDBSCAN", "STDDEV_POP", "STDDEV_SAMP", "STRING_AGG", "SUM", "VAR_POP", "VAR_SAMP"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/aggregate_functions
  aggregate: ["ANY_VALUE", "ARRAY_AGG", "ARRAY_CONCAT_AGG", "AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "COUNT", "COUNTIF", "LOGICAL_AND", "LOGICAL_OR", "MAX", "MIN", "STRING_AGG", "SUM"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/approximate_aggregate_functions
  approximateAggregate: ["APPROX_COUNT_DISTINCT", "APPROX_QUANTILES", "APPROX_TOP_COUNT", "APPROX_TOP_SUM"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/array_functions
  array: [
    // 'ARRAY',
    "ARRAY_CONCAT",
    "ARRAY_LENGTH",
    "ARRAY_TO_STRING",
    "GENERATE_ARRAY",
    "GENERATE_DATE_ARRAY",
    "GENERATE_TIMESTAMP_ARRAY",
    "ARRAY_REVERSE",
    "OFFSET",
    "SAFE_OFFSET",
    "ORDINAL",
    "SAFE_ORDINAL"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/bit_functions
  bitwise: ["BIT_COUNT"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conversion_functions
  conversion: [
    // 'CASE',
    "PARSE_BIGNUMERIC",
    "PARSE_NUMERIC",
    "SAFE_CAST"
  ],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/date_functions
  date: ["CURRENT_DATE", "EXTRACT", "DATE", "DATE_ADD", "DATE_SUB", "DATE_DIFF", "DATE_TRUNC", "DATE_FROM_UNIX_DATE", "FORMAT_DATE", "LAST_DAY", "PARSE_DATE", "UNIX_DATE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/datetime_functions
  datetime: ["CURRENT_DATETIME", "DATETIME", "EXTRACT", "DATETIME_ADD", "DATETIME_SUB", "DATETIME_DIFF", "DATETIME_TRUNC", "FORMAT_DATETIME", "LAST_DAY", "PARSE_DATETIME"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging_functions
  debugging: ["ERROR"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/federated_query_functions
  federatedQuery: ["EXTERNAL_QUERY"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions
  geography: ["S2_CELLIDFROMPOINT", "S2_COVERINGCELLIDS", "ST_ANGLE", "ST_AREA", "ST_ASBINARY", "ST_ASGEOJSON", "ST_ASTEXT", "ST_AZIMUTH", "ST_BOUNDARY", "ST_BOUNDINGBOX", "ST_BUFFER", "ST_BUFFERWITHTOLERANCE", "ST_CENTROID", "ST_CENTROID_AGG", "ST_CLOSESTPOINT", "ST_CLUSTERDBSCAN", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DUMP", "ST_DWITHIN", "ST_ENDPOINT", "ST_EQUALS", "ST_EXTENT", "ST_EXTERIORRING", "ST_GEOGFROM", "ST_GEOGFROMGEOJSON", "ST_GEOGFROMTEXT", "ST_GEOGFROMWKB", "ST_GEOGPOINT", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOHASH", "ST_GEOMETRYTYPE", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_INTERSECTSBOX", "ST_ISCOLLECTION", "ST_ISEMPTY", "ST_LENGTH", "ST_MAKELINE", "ST_MAKEPOLYGON", "ST_MAKEPOLYGONORIENTED", "ST_MAXDISTANCE", "ST_NPOINTS", "ST_NUMGEOMETRIES", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SIMPLIFY", "ST_SNAPTOGRID", "ST_STARTPOINT", "ST_TOUCHES", "ST_UNION", "ST_UNION_AGG", "ST_WITHIN", "ST_X", "ST_Y"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hash_functions
  hash: ["FARM_FINGERPRINT", "MD5", "SHA1", "SHA256", "SHA512"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/hll_functions
  hll: ["HLL_COUNT.INIT", "HLL_COUNT.MERGE", "HLL_COUNT.MERGE_PARTIAL", "HLL_COUNT.EXTRACT"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/interval_functions
  interval: ["MAKE_INTERVAL", "EXTRACT", "JUSTIFY_DAYS", "JUSTIFY_HOURS", "JUSTIFY_INTERVAL"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/json_functions
  json: ["JSON_EXTRACT", "JSON_QUERY", "JSON_EXTRACT_SCALAR", "JSON_VALUE", "JSON_EXTRACT_ARRAY", "JSON_QUERY_ARRAY", "JSON_EXTRACT_STRING_ARRAY", "JSON_VALUE_ARRAY", "TO_JSON_STRING"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/mathematical_functions
  math: ["ABS", "SIGN", "IS_INF", "IS_NAN", "IEEE_DIVIDE", "RAND", "SQRT", "POW", "POWER", "EXP", "LN", "LOG", "LOG10", "GREATEST", "LEAST", "DIV", "SAFE_DIVIDE", "SAFE_MULTIPLY", "SAFE_NEGATE", "SAFE_ADD", "SAFE_SUBTRACT", "MOD", "ROUND", "TRUNC", "CEIL", "CEILING", "FLOOR", "COS", "COSH", "ACOS", "ACOSH", "SIN", "SINH", "ASIN", "ASINH", "TAN", "TANH", "ATAN", "ATANH", "ATAN2", "RANGE_BUCKET"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions
  navigation: ["FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "LEAD", "LAG", "PERCENTILE_CONT", "PERCENTILE_DISC"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/net_functions
  net: ["NET.IP_FROM_STRING", "NET.SAFE_IP_FROM_STRING", "NET.IP_TO_STRING", "NET.IP_NET_MASK", "NET.IP_TRUNC", "NET.IPV4_FROM_INT64", "NET.IPV4_TO_INT64", "NET.HOST", "NET.PUBLIC_SUFFIX", "NET.REG_DOMAIN"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/numbering_functions
  numbering: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "NTILE", "ROW_NUMBER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/security_functions
  security: ["SESSION_USER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/statistical_aggregate_functions
  statisticalAggregate: ["CORR", "COVAR_POP", "COVAR_SAMP", "STDDEV_POP", "STDDEV_SAMP", "STDDEV", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/string_functions
  string: ["ASCII", "BYTE_LENGTH", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHR", "CODE_POINTS_TO_BYTES", "CODE_POINTS_TO_STRING", "CONCAT", "CONTAINS_SUBSTR", "ENDS_WITH", "FORMAT", "FROM_BASE32", "FROM_BASE64", "FROM_HEX", "INITCAP", "INSTR", "LEFT", "LENGTH", "LPAD", "LOWER", "LTRIM", "NORMALIZE", "NORMALIZE_AND_CASEFOLD", "OCTET_LENGTH", "REGEXP_CONTAINS", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "REPEAT", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SAFE_CONVERT_BYTES_TO_STRING", "SOUNDEX", "SPLIT", "STARTS_WITH", "STRPOS", "SUBSTR", "SUBSTRING", "TO_BASE32", "TO_BASE64", "TO_CODE_POINTS", "TO_HEX", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/time_functions
  time: ["CURRENT_TIME", "TIME", "EXTRACT", "TIME_ADD", "TIME_SUB", "TIME_DIFF", "TIME_TRUNC", "FORMAT_TIME", "PARSE_TIME"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/timestamp_functions
  timestamp: ["CURRENT_TIMESTAMP", "EXTRACT", "STRING", "TIMESTAMP", "TIMESTAMP_ADD", "TIMESTAMP_SUB", "TIMESTAMP_DIFF", "TIMESTAMP_TRUNC", "FORMAT_TIMESTAMP", "PARSE_TIMESTAMP", "TIMESTAMP_SECONDS", "TIMESTAMP_MILLIS", "TIMESTAMP_MICROS", "UNIX_SECONDS", "UNIX_MILLIS", "UNIX_MICROS"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/uuid_functions
  uuid: ["GENERATE_UUID"],
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/conditional_expressions
  conditional: ["COALESCE", "IF", "IFNULL", "NULLIF"],
  // https://cloud.google.com/bigquery/docs/reference/legacy-sql
  legacyAggregate: ["AVG", "BIT_AND", "BIT_OR", "BIT_XOR", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "EXACT_COUNT_DISTINCT", "FIRST", "GROUP_CONCAT", "GROUP_CONCAT_UNQUOTED", "LAST", "MAX", "MIN", "NEST", "NTH", "QUANTILES", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "TOP", "UNIQUE", "VARIANCE", "VAR_POP", "VAR_SAMP"],
  legacyBitwise: ["BIT_COUNT"],
  legacyCasting: ["BOOLEAN", "BYTES", "CAST", "FLOAT", "HEX_STRING", "INTEGER", "STRING"],
  legacyComparison: [
    // expr 'IN',
    "COALESCE",
    "GREATEST",
    "IFNULL",
    "IS_INF",
    "IS_NAN",
    "IS_EXPLICITLY_DEFINED",
    "LEAST",
    "NVL"
  ],
  legacyDatetime: ["CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE", "DATE_ADD", "DATEDIFF", "DAY", "DAYOFWEEK", "DAYOFYEAR", "FORMAT_UTC_USEC", "HOUR", "MINUTE", "MONTH", "MSEC_TO_TIMESTAMP", "NOW", "PARSE_UTC_USEC", "QUARTER", "SEC_TO_TIMESTAMP", "SECOND", "STRFTIME_UTC_USEC", "TIME", "TIMESTAMP", "TIMESTAMP_TO_MSEC", "TIMESTAMP_TO_SEC", "TIMESTAMP_TO_USEC", "USEC_TO_TIMESTAMP", "UTC_USEC_TO_DAY", "UTC_USEC_TO_HOUR", "UTC_USEC_TO_MONTH", "UTC_USEC_TO_WEEK", "UTC_USEC_TO_YEAR", "WEEK", "YEAR"],
  legacyIp: ["FORMAT_IP", "PARSE_IP", "FORMAT_PACKED_IP", "PARSE_PACKED_IP"],
  legacyJson: ["JSON_EXTRACT", "JSON_EXTRACT_SCALAR"],
  legacyMath: ["ABS", "ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATANH", "ATAN2", "CEIL", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG2", "LOG10", "PI", "POW", "RADIANS", "RAND", "ROUND", "SIN", "SINH", "SQRT", "TAN", "TANH"],
  legacyRegex: ["REGEXP_MATCH", "REGEXP_EXTRACT", "REGEXP_REPLACE"],
  legacyString: [
    "CONCAT",
    // expr CONTAINS 'str'
    "INSTR",
    "LEFT",
    "LENGTH",
    "LOWER",
    "LPAD",
    "LTRIM",
    "REPLACE",
    "RIGHT",
    "RPAD",
    "RTRIM",
    "SPLIT",
    "SUBSTR",
    "UPPER"
  ],
  legacyTableWildcard: ["TABLE_DATE_RANGE", "TABLE_DATE_RANGE_STRICT", "TABLE_QUERY"],
  legacyUrl: ["HOST", "DOMAIN", "TLD"],
  legacyWindow: ["AVG", "COUNT", "MAX", "MIN", "STDDEV", "SUM", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER"],
  legacyMisc: ["CURRENT_USER", "EVERY", "FROM_BASE64", "HASH", "FARM_FINGERPRINT", "IF", "POSITION", "SHA1", "SOME", "TO_BASE64"],
  other: ["BQ.JOBS.CANCEL", "BQ.REFRESH_MATERIALIZED_VIEW"],
  ddl: ["OPTIONS"],
  pivot: ["PIVOT", "UNPIVOT"],
  // Data types with parameters like VARCHAR(100)
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#parameterized_data_types
  dataTypes: ["BYTES", "NUMERIC", "DECIMAL", "BIGNUMERIC", "BIGDECIMAL", "STRING"]
}), GQe = re(["SELECT [ALL | DISTINCT] [AS STRUCT | AS VALUE]"]), BQe = re([
  // Queries: https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "QUALIFY",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "OMIT RECORD IF",
  // legacy
  // Data modification: https://cloud.google.com/bigquery/docs/reference/standard-sql/dml-syntax
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY SOURCE | BY TARGET] [THEN]",
  "UPDATE SET",
  // Data definition, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|SNAPSHOT|EXTERNAL] TABLE [IF NOT EXISTS]",
  "CLUSTER BY",
  "FOR SYSTEM_TIME AS OF",
  // CREATE SNAPSHOT TABLE
  "WITH CONNECTION",
  "WITH PARTITION COLUMNS",
  "REMOTE WITH CONNECTION"
]), FB = re([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [SNAPSHOT | EXTERNAL] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME TO",
  "ALTER COLUMN [IF EXISTS]",
  "SET DEFAULT COLLATE",
  // for alter column
  "SET OPTIONS",
  // for alter column
  "DROP NOT NULL",
  // for alter column
  "SET DATA TYPE",
  // for alter column
  // - alter schema
  "ALTER SCHEMA [IF EXISTS]",
  // - alter view
  "ALTER [MATERIALIZED] VIEW [IF EXISTS]",
  // - alter bi_capacity
  "ALTER BI_CAPACITY",
  // - truncate:
  "TRUNCATE TABLE",
  // - create schema
  "CREATE SCHEMA [IF NOT EXISTS]",
  "DEFAULT COLLATE",
  // stored procedures
  "CREATE [OR REPLACE] [TEMP|TEMPORARY|TABLE] FUNCTION [IF NOT EXISTS]",
  "CREATE [OR REPLACE] PROCEDURE [IF NOT EXISTS]",
  // row access policy
  "CREATE [OR REPLACE] ROW ACCESS POLICY [IF NOT EXISTS]",
  "GRANT TO",
  "FILTER USING",
  // capacity
  "CREATE CAPACITY",
  "AS JSON",
  // reservation
  "CREATE RESERVATION",
  // assignment
  "CREATE ASSIGNMENT",
  // search index
  "CREATE SEARCH INDEX [IF NOT EXISTS]",
  // drop
  "DROP SCHEMA [IF EXISTS]",
  "DROP [MATERIALIZED] VIEW [IF EXISTS]",
  "DROP [TABLE] FUNCTION [IF EXISTS]",
  "DROP PROCEDURE [IF EXISTS]",
  "DROP ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "DROP CAPACITY [IF EXISTS]",
  "DROP RESERVATION [IF EXISTS]",
  "DROP ASSIGNMENT [IF EXISTS]",
  "DROP SEARCH INDEX [IF EXISTS]",
  "DROP [IF EXISTS]",
  // DCL, https://cloud.google.com/bigquery/docs/reference/standard-sql/data-control-language
  "GRANT",
  "REVOKE",
  // Script, https://cloud.google.com/bigquery/docs/reference/standard-sql/scripting
  "DECLARE",
  "EXECUTE IMMEDIATE",
  "LOOP",
  "END LOOP",
  "REPEAT",
  "END REPEAT",
  "WHILE",
  "END WHILE",
  "BREAK",
  "LEAVE",
  "CONTINUE",
  "ITERATE",
  "FOR",
  "END FOR",
  "BEGIN",
  "BEGIN TRANSACTION",
  "COMMIT TRANSACTION",
  "ROLLBACK TRANSACTION",
  "RAISE",
  "RETURN",
  "CALL",
  // Debug, https://cloud.google.com/bigquery/docs/reference/standard-sql/debugging-statements
  "ASSERT",
  // Other, https://cloud.google.com/bigquery/docs/reference/standard-sql/other-statements
  "EXPORT DATA"
]), FQe = re(["UNION {ALL | DISTINCT}", "EXCEPT DISTINCT", "INTERSECT DISTINCT"]), XQe = re(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]), YQe = re([
  // https://cloud.google.com/bigquery/docs/reference/standard-sql/query-syntax#tablesample_operator
  "TABLESAMPLE SYSTEM",
  // From DDL: https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language
  "ANY TYPE",
  "ALL COLUMNS",
  "NOT DETERMINISTIC",
  // inside window definitions
  "{ROWS | RANGE} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), HQe = {
  tokenizerOptions: {
    reservedSelect: GQe,
    reservedClauses: [...BQe, ...FB],
    reservedSetOperations: FQe,
    reservedJoins: XQe,
    reservedPhrases: YQe,
    reservedKeywords: $Qe,
    reservedFunctionNames: VQe,
    extraParens: ["[]"],
    stringTypes: [
      // The triple-quoted strings are listed first, so they get matched first.
      // Otherwise the first two quotes of """ will get matched as an empty "" string.
      {
        quote: '""".."""',
        prefixes: ["R", "B", "RB", "BR"]
      },
      {
        quote: "'''..'''",
        prefixes: ["R", "B", "RB", "BR"]
      },
      '""-bs',
      "''-bs",
      {
        quote: '""-raw',
        prefixes: ["R", "B", "RB", "BR"],
        requirePrefix: !0
      },
      {
        quote: "''-raw",
        prefixes: ["R", "B", "RB", "BR"],
        requirePrefix: !0
      }
    ],
    identTypes: ["``"],
    identChars: {
      dashes: !0
    },
    paramTypes: {
      positional: !0,
      named: ["@"],
      quoted: ["@"]
    },
    variableTypes: [{
      regex: String.raw`@@\w+`
    }],
    lineCommentTypes: ["--", "#"],
    operators: ["&", "|", "^", "~", ">>", "<<", "||", "=>"],
    postProcess: WQe
  },
  formatOptions: {
    onelineClauses: FB
  }
};
function WQe(r) {
  return zQe(ZQe(r));
}
function zQe(r) {
  let e = Uc;
  return r.map((t) => t.text === "OFFSET" && e.text === "[" ? (e = t, {
    ...t,
    type: ee.RESERVED_FUNCTION_NAME
  }) : (e = t, t));
}
function ZQe(r) {
  const e = [];
  for (let i = 0; i < r.length; i++) {
    var t;
    const n = r[i];
    if ((Xl.ARRAY(n) || Xl.STRUCT(n)) && ((t = r[i + 1]) === null || t === void 0 ? void 0 : t.text) === "<") {
      const a = qQe(r, i + 1), o = r.slice(i, a + 1);
      e.push({
        type: ee.IDENTIFIER,
        raw: o.map(XB("raw")).join(""),
        text: o.map(XB("text")).join(""),
        start: n.start
      }), i = a;
    } else
      e.push(n);
  }
  return e;
}
const XB = (r) => (e) => e.type === ee.IDENTIFIER || e.type === ee.COMMA ? e[r] + " " : e[r];
function qQe(r, e) {
  let t = 0;
  for (let i = e; i < r.length; i++) {
    const n = r[i];
    if (n.text === "<" ? t++ : n.text === ">" ? t-- : n.text === ">>" && (t -= 2), t === 0)
      return i;
  }
  return r.length - 1;
}
const jQe = wt({
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-aggregate
  aggregate: ["ARRAY_AGG", "AVG", "CORR", "CORRELATION", "COUNT", "COUNT_BIG", "COVAR_POP", "COVARIANCE", "COVAR", "COVAR_SAMP", "COVARIANCE_SAMP", "CUME_DIST", "GROUPING", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_ICPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV", "STDDEV_SAMP", "SUM", "VAR_POP", "VARIANCE", "VAR", "VAR_SAMP", "VARIANCE_SAMP", "XMLAGG"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-scalar
  scalar: ["ABS", "ABSVAL", "ACOS", "ADD_DAYS", "ADD_MONTHS", "ARRAY_DELETE", "ARRAY_FIRST", "ARRAY_LAST", "ARRAY_NEXT", "ARRAY_PRIOR", "ARRAY_TRIM", "ASCII", "ASCII_CHR", "ASCII_STR", "ASCIISTR", "ASIN", "ATAN", "ATANH", "ATAN2", "BIGINT", "BINARY", "BITAND", "BITANDNOT", "BITOR", "BITXOR", "BITNOT", "BLOB", "BTRIM", "CARDINALITY", "CCSID_ENCODING", "CEILING", "CEIL", "CHAR", "CHAR9", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CLOB", "COALESCE", "COLLATION_KEY", "COMPARE_DECFLOAT", "CONCAT", "CONTAINS", "COS", "COSH", "DATE", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEK_ISO", "DAYOFYEAR", "DAYS", "DAYS_BETWEEN", "DBCLOB", "DECFLOAT", "DECFLOAT_FORMAT", "DECFLOAT_SORTKEY", "DECIMAL", "DEC", "DECODE", "DECRYPT_BINARY", "DECRYPT_BIT", "DECRYPT_CHAR", "DECRYPT_DB", "DECRYPT_DATAKEY_BIGINT", "DECRYPT_DATAKEY_BIT", "DECRYPT_DATAKEY_CLOB", "DECRYPT_DATAKEY_DBCLOB", "DECRYPT_DATAKEY_DECIMAL", "DECRYPT_DATAKEY_INTEGER", "DECRYPT_DATAKEY_VARCHAR", "DECRYPT_DATAKEY_VARGRAPHIC", "DEGREES", "DIFFERENCE", "DIGITS", "DOUBLE_PRECISION", "DOUBLE", "DSN_XMLVALIDATE", "EBCDIC_CHR", "EBCDIC_STR", "ENCRYPT_DATAKEY", "ENCRYPT_TDES", "EXP", "EXTRACT", "FLOAT", "FLOOR", "GENERATE_UNIQUE", "GENERATE_UNIQUE_BINARY", "GETHINT", "GETVARIABLE", "GRAPHIC", "GREATEST", "HASH", "HASH_CRC32", "HASH_MD5", "HASH_SHA1", "HASH_SHA256", "HEX", "HOUR", "IDENTITY_VAL_LOCAL", "IFNULL", "INSERT", "INSTR", "INTEGER", "INT", "JULIAN_DAY", "LAST_DAY", "LCASE", "LEAST", "LEFT", "LENGTH", "LN", "LOCATE", "LOCATE_IN_STRING", "LOG10", "LOWER", "LPAD", "LTRIM", "MAX", "MAX_CARDINALITY", "MICROSECOND", "MIDNIGHT_SECONDS", "MIN", "MINUTE", "MOD", "MONTH", "MONTHS_BETWEEN", "MQREAD", "MQREADCLOB", "MQRECEIVE", "MQRECEIVECLOB", "MQSEND", "MULTIPLY_ALT", "NEXT_DAY", "NEXT_MONTH", "NORMALIZE_DECFLOAT", "NORMALIZE_STRING", "NULLIF", "NVL", "OVERLAY", "PACK", "POSITION", "POSSTR", "POWER", "POW", "QUANTIZE", "QUARTER", "RADIANS", "RAISE_ERROR", "RANDOM", "RAND", "REAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "RID", "RIGHT", "ROUND", "ROUND_TIMESTAMP", "ROWID", "RPAD", "RTRIM", "SCORE", "SECOND", "SIGN", "SIN", "SINH", "SMALLINT", "SOUNDEX", "SOAPHTTPC", "SOAPHTTPV", "SOAPHTTPNC", "SOAPHTTPNV", "SPACE", "SQRT", "STRIP", "STRLEFT", "STRPOS", "STRRIGHT", "SUBSTR", "SUBSTRING", "TAN", "TANH", "TIME", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIMESTAMP_FORMAT", "TIMESTAMP_ISO", "TIMESTAMP_TZ", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_NUMBER", "TOTALORDER", "TO_TIMESTAMP", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRUNC", "TRUNC_TIMESTAMP", "UCASE", "UNICODE", "UNICODE_STR", "UNISTR", "UPPER", "VALUE", "VARBINARY", "VARCHAR", "VARCHAR9", "VARCHAR_BIT_FORMAT", "VARCHAR_FORMAT", "VARGRAPHIC", "VERIFY_GROUP_FOR_USER", "VERIFY_ROLE_FOR_USER", "VERIFY_TRUSTED_CONTEXT_ROLE_FOR_USER", "WEEK", "WEEK_ISO", "WRAP", "XMLATTRIBUTES", "XMLCOMMENT", "XMLCONCAT", "XMLDOCUMENT", "XMLELEMENT", "XMLFOREST", "XMLMODIFY", "XMLNAMESPACES", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLSERIALIZE", "XMLTEXT", "XMLXSROBJECTID", "XSLTRANSFORM", "YEAR"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-table
  table: ["ADMIN_TASK_LIST", "ADMIN_TASK_OUTPUT", "ADMIN_TASK_STATUS", "BLOCKING_THREADS", "MQREADALL", "MQREADALLCLOB", "MQRECEIVEALL", "MQRECEIVEALLCLOB", "XMLTABLE"],
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=functions-row
  row: ["UNPACK"],
  // https://www.ibm.com/docs/en/db2-for-zos/12?topic=expressions-olap-specification
  olap: ["CUME_DIST", "PERCENT_RANK", "RANK", "DENSE_RANK", "NTILE", "LAG", "LEAD", "ROW_NUMBER", "FIRST_VALUE", "LAST_VALUE", "NTH_VALUE", "RATIO_TO_REPORT"],
  // Type casting
  cast: ["CAST"]
}), KQe = wt({
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=words-reserved#db2z_reservedwords__newresword
  standard: ["ALL", "ALLOCATE", "ALLOW", "ALTERAND", "ANY", "AS", "ARRAY", "ARRAY_EXISTS", "ASENSITIVE", "ASSOCIATE", "ASUTIME", "AT", "AUDIT", "AUX", "AUXILIARY", "BEFORE", "BEGIN", "BETWEEN", "BUFFERPOOL", "BY", "CAPTURE", "CASCADED", "CAST", "CCSID", "CHARACTER", "CHECK", "CLONE", "CLUSTER", "COLLECTION", "COLLID", "COLUMN", "CONDITION", "CONNECTION", "CONSTRAINT", "CONTENT", "CONTINUE", "CREATE", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_LC_CTYPE", "CURRENT_PATH", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRVAL", "CURSOR", "DATA", "DATABASE", "DBINFO", "DECLARE", "DEFAULT", "DESCRIPTOR", "DETERMINISTIC", "DISABLE", "DISALLOW", "DISTINCT", "DO", "DOCUMENT", "DSSIZE", "DYNAMIC", "EDITPROC", "ELSE", "ELSEIF", "ENCODING", "ENCRYPTION", "ENDING", "END-EXEC", "ERASE", "ESCAPE", "EXCEPTION", "EXISTS", "EXIT", "EXTERNAL", "FENCED", "FIELDPROC", "FINAL", "FIRST", "FOR", "FREE", "FULL", "FUNCTION", "GENERATED", "GET", "GLOBAL", "GOTO", "GROUP", "HANDLER", "HOLD", "HOURS", "IF", "IMMEDIATE", "IN", "INCLUSIVE", "INDEX", "INHERIT", "INNER", "INOUT", "INSENSITIVE", "INTO", "IS", "ISOBID", "ITERATE", "JAR", "KEEP", "KEY", "LANGUAGE", "LAST", "LC_CTYPE", "LEAVE", "LIKE", "LOCAL", "LOCALE", "LOCATOR", "LOCATORS", "LOCK", "LOCKMAX", "LOCKSIZE", "LONG", "LOOP", "MAINTAINED", "MATERIALIZED", "MICROSECONDS", "MINUTEMINUTES", "MODIFIES", "MONTHS", "NEXT", "NEXTVAL", "NO", "NONE", "NOT", "NULL", "NULLS", "NUMPARTS", "OBID", "OF", "OLD", "ON", "OPTIMIZATION", "OPTIMIZE", "ORDER", "ORGANIZATION", "OUT", "OUTER", "PACKAGE", "PARAMETER", "PART", "PADDED", "PARTITION", "PARTITIONED", "PARTITIONING", "PATH", "PIECESIZE", "PERIOD", "PLAN", "PRECISION", "PREVVAL", "PRIOR", "PRIQTY", "PRIVILEGES", "PROCEDURE", "PROGRAM", "PSID", "PUBLIC", "QUERY", "QUERYNO", "READS", "REFERENCES", "RESIGNAL", "RESTRICT", "RESULT", "RESULT_SET_LOCATOR", "RETURN", "RETURNS", "ROLE", "ROLLUP", "ROUND_CEILING", "ROUND_DOWN", "ROUND_FLOOR", "ROUND_HALF_DOWN", "ROUND_HALF_EVEN", "ROUND_HALF_UP", "ROUND_UP", "ROW", "ROWSET", "SCHEMA", "SCRATCHPAD", "SECONDS", "SECQTY", "SECURITY", "SEQUENCE", "SENSITIVE", "SESSION_USER", "SIMPLE", "SOME", "SOURCE", "SPECIFIC", "STANDARD", "STATIC", "STATEMENT", "STAY", "STOGROUP", "STORES", "STYLE", "SUMMARY", "SYNONYM", "SYSDATE", "SYSTEM", "SYSTIMESTAMP", "TABLE", "TABLESPACE", "THEN", "TO", "TRIGGER", "TYPE", "UNDO", "UNIQUE", "UNTIL", "USER", "USING", "VALIDPROC", "VARIABLE", "VARIANT", "VCAT", "VERSIONING", "VIEW", "VOLATILE", "VOLUMES", "WHILE", "WLM", "XMLEXISTS", "XMLCAST", "YEARS", "ZONE"]
}), JQe = re(["SELECT [ALL | DISTINCT]"]), e2e = re([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY [INPUT SEQUENCE]",
  "FETCH FIRST",
  // Data modification
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT",
  // Data definition
  "CREATE [OR REPLACE] VIEW",
  "CREATE [GLOBAL TEMPORARY] TABLE"
]), YB = re([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  "WITH {RR | RS | CS | UR}",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [HIERARCHY]",
  // alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [COLUMN]",
  "ALTER [COLUMN]",
  "SET DATA TYPE",
  // for alter column
  "SET NOT NULL",
  // for alter column
  "DROP {IDENTITY | EXPRESSION | DEFAULT | NOT NULL}",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "SET [CURRENT] SCHEMA",
  "AFTER",
  "GO",
  // https://www.ibm.com/docs/en/db2-for-zos/11?topic=statements-list-supported
  "ALLOCATE CURSOR",
  "ALTER DATABASE",
  "ALTER FUNCTION",
  "ALTER INDEX",
  "ALTER MASK",
  "ALTER PERMISSION",
  "ALTER PROCEDURE",
  "ALTER SEQUENCE",
  "ALTER STOGROUP",
  "ALTER TABLESPACE",
  "ALTER TRIGGER",
  "ALTER TRUSTED CONTEXT",
  "ALTER VIEW",
  "ASSOCIATE LOCATORS",
  "BEGIN DECLARE SECTION",
  "CALL",
  "CLOSE",
  "COMMENT",
  "COMMIT",
  "CONNECT",
  "CREATE ALIAS",
  "CREATE AUXILIARY TABLE",
  "CREATE DATABASE",
  "CREATE FUNCTION",
  "CREATE GLOBAL TEMPORARY TABLE",
  "CREATE INDEX",
  "CREATE LOB TABLESPACE",
  "CREATE MASK",
  "CREATE PERMISSION",
  "CREATE PROCEDURE",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE STOGROUP",
  "CREATE SYNONYM",
  "CREATE TABLESPACE",
  "CREATE TRIGGER",
  "CREATE TRUSTED CONTEXT",
  "CREATE TYPE",
  "CREATE VARIABLE",
  "DECLARE CURSOR",
  "DECLARE GLOBAL TEMPORARY TABLE",
  "DECLARE STATEMENT",
  "DECLARE TABLE",
  "DECLARE VARIABLE",
  "DESCRIBE CURSOR",
  "DESCRIBE INPUT",
  "DESCRIBE OUTPUT",
  "DESCRIBE PROCEDURE",
  "DESCRIBE TABLE",
  "DROP",
  "END DECLARE SECTION",
  "EXCHANGE",
  "EXECUTE",
  "EXECUTE IMMEDIATE",
  "EXPLAIN",
  "FETCH",
  "FREE LOCATOR",
  "GET DIAGNOSTICS",
  "GRANT",
  "HOLD LOCATOR",
  "INCLUDE",
  "LABEL",
  "LOCK TABLE",
  "OPEN",
  "PREPARE",
  "REFRESH",
  "RELEASE",
  "RELEASE SAVEPOINT",
  "RENAME",
  "REVOKE",
  "ROLLBACK",
  "SAVEPOINT",
  "SELECT INTO",
  "SET CONNECTION",
  "SET CURRENT ACCELERATOR",
  "SET CURRENT APPLICATION COMPATIBILITY",
  "SET CURRENT APPLICATION ENCODING SCHEME",
  "SET CURRENT DEBUG MODE",
  "SET CURRENT DECFLOAT ROUNDING MODE",
  "SET CURRENT DEGREE",
  "SET CURRENT EXPLAIN MODE",
  "SET CURRENT GET_ACCEL_ARCHIVE",
  "SET CURRENT LOCALE LC_CTYPE",
  "SET CURRENT MAINTAINED TABLE TYPES FOR OPTIMIZATION",
  "SET CURRENT OPTIMIZATION HINT",
  "SET CURRENT PACKAGE PATH",
  "SET CURRENT PACKAGESET",
  "SET CURRENT PRECISION",
  "SET CURRENT QUERY ACCELERATION",
  "SET CURRENT QUERY ACCELERATION WAITFORDATA",
  "SET CURRENT REFRESH AGE",
  "SET CURRENT ROUTINE VERSION",
  "SET CURRENT RULES",
  "SET CURRENT SQLID",
  "SET CURRENT TEMPORAL BUSINESS_TIME",
  "SET CURRENT TEMPORAL SYSTEM_TIME",
  "SET ENCRYPTION PASSWORD",
  "SET PATH",
  "SET SESSION TIME ZONE",
  "SIGNAL",
  "VALUES INTO",
  "WHENEVER"
]), t2e = re(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]), r2e = re(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN"]), i2e = re(["ON DELETE", "ON UPDATE", "SET NULL", "{ROWS | RANGE} BETWEEN"]), n2e = {
  tokenizerOptions: {
    reservedSelect: JQe,
    reservedClauses: [...e2e, ...YB],
    reservedSetOperations: t2e,
    reservedJoins: r2e,
    reservedPhrases: i2e,
    reservedKeywords: KQe,
    reservedFunctionNames: jQe,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["G", "N", "U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X", "BX", "GX", "UX"],
      requirePrefix: !0
    }],
    identTypes: ['""-qq'],
    identChars: {
      first: "@#$"
    },
    paramTypes: {
      positional: !0,
      named: [":"]
    },
    paramChars: {
      first: "@#$",
      rest: "@#$"
    },
    operators: ["**", "=", ">", "<", "!>", "!<", "||"]
  },
  formatOptions: {
    onelineClauses: YB
  }
}, a2e = wt({
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+UDF
  math: [
    "ABS",
    "ACOS",
    "ASIN",
    "ATAN",
    "BIN",
    "BROUND",
    "CBRT",
    "CEIL",
    "CEILING",
    "CONV",
    "COS",
    "DEGREES",
    // 'E',
    "EXP",
    "FACTORIAL",
    "FLOOR",
    "GREATEST",
    "HEX",
    "LEAST",
    "LN",
    "LOG",
    "LOG10",
    "LOG2",
    "NEGATIVE",
    "PI",
    "PMOD",
    "POSITIVE",
    "POW",
    "POWER",
    "RADIANS",
    "RAND",
    "ROUND",
    "SHIFTLEFT",
    "SHIFTRIGHT",
    "SHIFTRIGHTUNSIGNED",
    "SIGN",
    "SIN",
    "SQRT",
    "TAN",
    "UNHEX",
    "WIDTH_BUCKET"
  ],
  array: ["ARRAY_CONTAINS", "MAP_KEYS", "MAP_VALUES", "SIZE", "SORT_ARRAY"],
  conversion: ["BINARY", "CAST"],
  date: ["ADD_MONTHS", "DATE", "DATE_ADD", "DATE_FORMAT", "DATE_SUB", "DATEDIFF", "DAY", "DAYNAME", "DAYOFMONTH", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "QUARTER", "SECOND", "TIMESTAMP", "TO_DATE", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_TIMESTAMP", "WEEKOFYEAR", "YEAR"],
  conditional: ["ASSERT_TRUE", "COALESCE", "IF", "ISNOTNULL", "ISNULL", "NULLIF", "NVL"],
  string: ["ASCII", "BASE64", "CHARACTER_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "CONTEXT_NGRAMS", "DECODE", "ELT", "ENCODE", "FIELD", "FIND_IN_SET", "FORMAT_NUMBER", "GET_JSON_OBJECT", "IN_FILE", "INITCAP", "INSTR", "LCASE", "LENGTH", "LEVENSHTEIN", "LOCATE", "LOWER", "LPAD", "LTRIM", "NGRAMS", "OCTET_LENGTH", "PARSE_URL", "PRINTF", "QUOTE", "REGEXP_EXTRACT", "REGEXP_REPLACE", "REPEAT", "REVERSE", "RPAD", "RTRIM", "SENTENCES", "SOUNDEX", "SPACE", "SPLIT", "STR_TO_MAP", "SUBSTR", "SUBSTRING", "TRANSLATE", "TRIM", "UCASE", "UNBASE64", "UPPER"],
  masking: ["MASK", "MASK_FIRST_N", "MASK_HASH", "MASK_LAST_N", "MASK_SHOW_FIRST_N", "MASK_SHOW_LAST_N"],
  misc: ["AES_DECRYPT", "AES_ENCRYPT", "CRC32", "CURRENT_DATABASE", "CURRENT_USER", "HASH", "JAVA_METHOD", "LOGGED_IN_USER", "MD5", "REFLECT", "SHA", "SHA1", "SHA2", "SURROGATE_KEY", "VERSION"],
  aggregate: ["AVG", "COLLECT_LIST", "COLLECT_SET", "CORR", "COUNT", "COVAR_POP", "COVAR_SAMP", "HISTOGRAM_NUMERIC", "MAX", "MIN", "NTILE", "PERCENTILE", "PERCENTILE_APPROX", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  table: ["EXPLODE", "INLINE", "JSON_TUPLE", "PARSE_URL_TUPLE", "POSEXPLODE", "STACK"],
  // https://cwiki.apache.org/confluence/display/Hive/LanguageManual+WindowingAndAnalytics
  window: ["LEAD", "LAG", "FIRST_VALUE", "LAST_VALUE", "RANK", "ROW_NUMBER", "DENSE_RANK", "CUME_DIST", "PERCENT_RANK", "NTILE"],
  // Parameterized data types
  // https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=82706456
  // Though in reality Hive only supports parameters for DECIMAL(),
  // it doesn't hurt to allow others in here as well.
  dataTypes: ["DECIMAL", "NUMERIC", "VARCHAR", "CHAR"]
}), o2e = wt({
  // https://cwiki.apache.org/confluence/display/hive/languagemanual+ddl
  // Non-reserved keywords have proscribed meanings in. HiveQL, but can still be used as table or column names
  nonReserved: ["ADD", "ADMIN", "AFTER", "ANALYZE", "ARCHIVE", "ASC", "BEFORE", "BUCKET", "BUCKETS", "CASCADE", "CHANGE", "CLUSTER", "CLUSTERED", "CLUSTERSTATUS", "COLLECTION", "COLUMNS", "COMMENT", "COMPACT", "COMPACTIONS", "COMPUTE", "CONCATENATE", "CONTINUE", "DATA", "DATABASES", "DATETIME", "DAY", "DBPROPERTIES", "DEFERRED", "DEFINED", "DELIMITED", "DEPENDENCY", "DESC", "DIRECTORIES", "DIRECTORY", "DISABLE", "DISTRIBUTE", "ELEM_TYPE", "ENABLE", "ESCAPED", "EXCLUSIVE", "EXPLAIN", "EXPORT", "FIELDS", "FILE", "FILEFORMAT", "FIRST", "FORMAT", "FORMATTED", "FUNCTIONS", "HOLD_DDLTIME", "HOUR", "IDXPROPERTIES", "IGNORE", "INDEX", "INDEXES", "INPATH", "INPUTDRIVER", "INPUTFORMAT", "ITEMS", "JAR", "KEYS", "KEY_TYPE", "LIMIT", "LINES", "LOAD", "LOCATION", "LOCK", "LOCKS", "LOGICAL", "LONG", "MAPJOIN", "MATERIALIZED", "METADATA", "MINUS", "MINUTE", "MONTH", "MSCK", "NOSCAN", "NO_DROP", "OFFLINE", "OPTION", "OUTPUTDRIVER", "OUTPUTFORMAT", "OVERWRITE", "OWNER", "PARTITIONED", "PARTITIONS", "PLUS", "PRETTY", "PRINCIPALS", "PROTECTION", "PURGE", "READ", "READONLY", "REBUILD", "RECORDREADER", "RECORDWRITER", "RELOAD", "RENAME", "REPAIR", "REPLACE", "REPLICATION", "RESTRICT", "REWRITE", "ROLE", "ROLES", "SCHEMA", "SCHEMAS", "SECOND", "SEMI", "SERDE", "SERDEPROPERTIES", "SERVER", "SETS", "SHARED", "SHOW", "SHOW_DATABASE", "SKEWED", "SORT", "SORTED", "SSL", "STATISTICS", "STORED", "STREAMTABLE", "STRING", "STRUCT", "TABLES", "TBLPROPERTIES", "TEMPORARY", "TERMINATED", "TINYINT", "TOUCH", "TRANSACTIONS", "UNARCHIVE", "UNDO", "UNIONTYPE", "UNLOCK", "UNSET", "UNSIGNED", "URI", "USE", "UTC", "UTCTIMESTAMP", "VALUE_TYPE", "VIEW", "WHILE", "YEAR", "AUTOCOMMIT", "ISOLATION", "LEVEL", "OFFSET", "SNAPSHOT", "TRANSACTION", "WORK", "WRITE", "ABORT", "KEY", "LAST", "NORELY", "NOVALIDATE", "NULLS", "RELY", "VALIDATE", "DETAIL", "DOW", "EXPRESSION", "OPERATOR", "QUARTER", "SUMMARY", "VECTORIZATION", "WEEK", "YEARS", "MONTHS", "WEEKS", "DAYS", "HOURS", "MINUTES", "SECONDS", "TIMESTAMPTZ", "ZONE"],
  reserved: ["ALL", "ALTER", "AND", "ARRAY", "AS", "AUTHORIZATION", "BETWEEN", "BIGINT", "BINARY", "BOOLEAN", "BOTH", "BY", "CASE", "CAST", "CHAR", "COLUMN", "CONF", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURSOR", "DATABASE", "DATE", "DECIMAL", "DELETE", "DESCRIBE", "DISTINCT", "DOUBLE", "DROP", "ELSE", "END", "EXCHANGE", "EXISTS", "EXTENDED", "EXTERNAL", "FALSE", "FETCH", "FLOAT", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTION", "GRANT", "GROUP", "GROUPING", "HAVING", "IF", "IMPORT", "IN", "INNER", "INSERT", "INT", "INTERSECT", "INTERVAL", "INTO", "IS", "JOIN", "LATERAL", "LEFT", "LESS", "LIKE", "LOCAL", "MACRO", "MAP", "MORE", "NONE", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "OUT", "OUTER", "OVER", "PARTIALSCAN", "PARTITION", "PERCENT", "PRECEDING", "PRESERVE", "PROCEDURE", "RANGE", "READS", "REDUCE", "REVOKE", "RIGHT", "ROLLUP", "ROW", "ROWS", "SELECT", "SET", "SMALLINT", "TABLE", "TABLESAMPLE", "THEN", "TIMESTAMP", "TO", "TRANSFORM", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNION", "UNIQUEJOIN", "UPDATE", "USER", "USING", "UTC_TMESTAMP", "VALUES", "VARCHAR", "WHEN", "WHERE", "WINDOW", "WITH", "COMMIT", "ONLY", "REGEXP", "RLIKE", "ROLLBACK", "START", "CACHE", "CONSTRAINT", "FOREIGN", "PRIMARY", "REFERENCES", "DAYOFWEEK", "EXTRACT", "FLOOR", "INTEGER", "PRECISION", "VIEWS", "TIME", "NUMERIC", "SYNC"],
  fileTypes: ["TEXTFILE", "SEQUENCEFILE", "ORC", "CSV", "TSV", "PARQUET", "AVRO", "RCFILE", "JSONFILE", "INPUTFORMAT", "OUTPUTFORMAT"]
}), s2e = re(["SELECT [ALL | DISTINCT]"]), l2e = re([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  //   Hive does not actually support plain INSERT INTO, only INSERT INTO TABLE
  //   but it's a nuisance to not support it, as all other dialects do.
  "INSERT INTO [TABLE]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  "INSERT [VALUES]",
  // - insert overwrite directory:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Writingdataintothefilesystemfromqueries
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://cwiki.apache.org/confluence/display/Hive/LanguageManual+DML#LanguageManualDML-Loadingfilesintotables
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE",
  // Data definition
  "CREATE [MATERIALIZED] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY] [EXTERNAL] TABLE [IF NOT EXISTS]"
]), HB = re([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "RENAME TO",
  // - truncate:
  "TRUNCATE [TABLE]",
  // other
  "ALTER",
  "CREATE",
  "USE",
  "DESCRIBE",
  "DROP",
  "FETCH",
  "SHOW",
  "STORED AS",
  "STORED BY",
  "ROW FORMAT"
]), u2e = re(["UNION [ALL | DISTINCT]"]), c2e = re([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "LEFT SEMI JOIN"
]), h2e = re(["{ROWS | RANGE} BETWEEN"]), f2e = {
  tokenizerOptions: {
    reservedSelect: s2e,
    reservedClauses: [...l2e, ...HB],
    reservedSetOperations: u2e,
    reservedJoins: c2e,
    reservedPhrases: h2e,
    reservedKeywords: o2e,
    reservedFunctionNames: a2e,
    extraParens: ["[]"],
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    variableTypes: [{
      quote: "{}",
      prefixes: ["$"],
      requirePrefix: !0
    }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||"]
  },
  formatOptions: {
    onelineClauses: HB
  }
}, d2e = wt({
  // https://mariadb.com/kb/en/information-schema-keywords-table/
  all: [
    "ACCESSIBLE",
    "ACCOUNT",
    "ACTION",
    "ADD",
    "ADMIN",
    "AFTER",
    "AGAINST",
    "AGGREGATE",
    "ALL",
    "ALGORITHM",
    "ALTER",
    "ALWAYS",
    "ANALYZE",
    "AND",
    "ANY",
    "AS",
    "ASC",
    "ASCII",
    "ASENSITIVE",
    "AT",
    "ATOMIC",
    "AUTHORS",
    "AUTO_INCREMENT",
    "AUTOEXTEND_SIZE",
    "AUTO",
    "AVG",
    "AVG_ROW_LENGTH",
    "BACKUP",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BINLOG",
    "BIT",
    "BLOB",
    "BLOCK",
    "BODY",
    "BOOL",
    "BOOLEAN",
    "BOTH",
    "BTREE",
    "BY",
    "BYTE",
    "CACHE",
    "CALL",
    "CASCADE",
    "CASCADED",
    "CASE",
    "CATALOG_NAME",
    "CHAIN",
    "CHANGE",
    "CHANGED",
    "CHAR",
    "CHARACTER",
    "CHARSET",
    "CHECK",
    "CHECKPOINT",
    "CHECKSUM",
    "CIPHER",
    "CLASS_ORIGIN",
    "CLIENT",
    "CLOB",
    "CLOSE",
    "COALESCE",
    "CODE",
    "COLLATE",
    "COLLATION",
    "COLUMN",
    "COLUMN_NAME",
    "COLUMNS",
    "COLUMN_ADD",
    "COLUMN_CHECK",
    "COLUMN_CREATE",
    "COLUMN_DELETE",
    "COLUMN_GET",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPACT",
    "COMPLETION",
    "COMPRESSED",
    "CONCURRENT",
    "CONDITION",
    "CONNECTION",
    "CONSISTENT",
    "CONSTRAINT",
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONTAINS",
    "CONTEXT",
    "CONTINUE",
    "CONTRIBUTORS",
    "CONVERT",
    "CPU",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_POS",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURSOR",
    "CURSOR_NAME",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DATAFILE",
    "DATE",
    "DATETIME",
    "DAY",
    "DAY_HOUR",
    "DAY_MICROSECOND",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFINER",
    "DELAYED",
    "DELAY_KEY_WRITE",
    "DELETE",
    "DELETE_DOMAIN_ID",
    "DESC",
    "DESCRIBE",
    "DES_KEY_FILE",
    "DETERMINISTIC",
    "DIAGNOSTICS",
    "DIRECTORY",
    "DISABLE",
    "DISCARD",
    "DISK",
    "DISTINCT",
    "DISTINCTROW",
    "DIV",
    "DO",
    "DOUBLE",
    "DO_DOMAIN_IDS",
    "DROP",
    "DUAL",
    "DUMPFILE",
    "DUPLICATE",
    "DYNAMIC",
    "EACH",
    "ELSE",
    "ELSEIF",
    "ELSIF",
    "EMPTY",
    "ENABLE",
    "ENCLOSED",
    "END",
    "ENDS",
    "ENGINE",
    "ENGINES",
    "ENUM",
    "ERROR",
    "ERRORS",
    "ESCAPE",
    "ESCAPED",
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXAMINED",
    "EXCEPT",
    "EXCHANGE",
    "EXCLUDE",
    "EXECUTE",
    "EXCEPTION",
    "EXISTS",
    "EXIT",
    "EXPANSION",
    "EXPIRE",
    "EXPORT",
    "EXPLAIN",
    "EXTENDED",
    "EXTENT_SIZE",
    "FALSE",
    "FAST",
    "FAULTS",
    "FEDERATED",
    "FETCH",
    "FIELDS",
    "FILE",
    "FIRST",
    "FIXED",
    "FLOAT",
    "FLOAT4",
    "FLOAT8",
    "FLUSH",
    "FOLLOWING",
    "FOLLOWS",
    "FOR",
    "FORCE",
    "FOREIGN",
    "FORMAT",
    "FOUND",
    "FROM",
    "FULL",
    "FULLTEXT",
    "FUNCTION",
    "GENERAL",
    "GENERATED",
    "GET_FORMAT",
    "GET",
    "GLOBAL",
    "GOTO",
    "GRANT",
    "GRANTS",
    "GROUP",
    "HANDLER",
    "HARD",
    "HASH",
    "HAVING",
    "HELP",
    "HIGH_PRIORITY",
    "HISTORY",
    "HOST",
    "HOSTS",
    "HOUR",
    "HOUR_MICROSECOND",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    // 'ID', // conflicts with common column name
    "IDENTIFIED",
    "IF",
    "IGNORE",
    "IGNORED",
    "IGNORE_DOMAIN_IDS",
    "IGNORE_SERVER_IDS",
    "IMMEDIATE",
    "IMPORT",
    "INTERSECT",
    "IN",
    "INCREMENT",
    "INDEX",
    "INDEXES",
    "INFILE",
    "INITIAL_SIZE",
    "INNER",
    "INOUT",
    "INSENSITIVE",
    "INSERT",
    "INSERT_METHOD",
    "INSTALL",
    "INT",
    "INT1",
    "INT2",
    "INT3",
    "INT4",
    "INT8",
    "INTEGER",
    "INTERVAL",
    "INVISIBLE",
    "INTO",
    "IO",
    "IO_THREAD",
    "IPC",
    "IS",
    "ISOLATION",
    "ISOPEN",
    "ISSUER",
    "ITERATE",
    "INVOKER",
    "JOIN",
    "JSON",
    "JSON_TABLE",
    "KEY",
    "KEYS",
    "KEY_BLOCK_SIZE",
    "KILL",
    "LANGUAGE",
    "LAST",
    "LAST_VALUE",
    "LASTVAL",
    "LEADING",
    "LEAVE",
    "LEAVES",
    "LEFT",
    "LESS",
    "LEVEL",
    "LIKE",
    "LIMIT",
    "LINEAR",
    "LINES",
    "LIST",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCK",
    "LOCKED",
    "LOCKS",
    "LOGFILE",
    "LOGS",
    "LONG",
    "LONGBLOB",
    "LONGTEXT",
    "LOOP",
    "LOW_PRIORITY",
    "MASTER",
    "MASTER_CONNECT_RETRY",
    "MASTER_DELAY",
    "MASTER_GTID_POS",
    "MASTER_HOST",
    "MASTER_LOG_FILE",
    "MASTER_LOG_POS",
    "MASTER_PASSWORD",
    "MASTER_PORT",
    "MASTER_SERVER_ID",
    "MASTER_SSL",
    "MASTER_SSL_CA",
    "MASTER_SSL_CAPATH",
    "MASTER_SSL_CERT",
    "MASTER_SSL_CIPHER",
    "MASTER_SSL_CRL",
    "MASTER_SSL_CRLPATH",
    "MASTER_SSL_KEY",
    "MASTER_SSL_VERIFY_SERVER_CERT",
    "MASTER_USER",
    "MASTER_USE_GTID",
    "MASTER_HEARTBEAT_PERIOD",
    "MATCH",
    "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR",
    "MAX_ROWS",
    "MAX_SIZE",
    "MAX_STATEMENT_TIME",
    "MAX_UPDATES_PER_HOUR",
    "MAX_USER_CONNECTIONS",
    "MAXVALUE",
    "MEDIUM",
    "MEDIUMBLOB",
    "MEDIUMINT",
    "MEDIUMTEXT",
    "MEMORY",
    "MERGE",
    "MESSAGE_TEXT",
    "MICROSECOND",
    "MIDDLEINT",
    "MIGRATE",
    "MINUS",
    "MINUTE",
    "MINUTE_MICROSECOND",
    "MINUTE_SECOND",
    "MINVALUE",
    "MIN_ROWS",
    "MOD",
    "MODE",
    "MODIFIES",
    "MODIFY",
    "MONITOR",
    "MONTH",
    "MUTEX",
    "MYSQL",
    "MYSQL_ERRNO",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NESTED",
    "NEVER",
    "NEW",
    "NEXT",
    "NEXTVAL",
    "NO",
    "NOMAXVALUE",
    "NOMINVALUE",
    "NOCACHE",
    "NOCYCLE",
    "NO_WAIT",
    "NOWAIT",
    "NODEGROUP",
    "NONE",
    "NOT",
    "NOTFOUND",
    "NO_WRITE_TO_BINLOG",
    "NULL",
    "NUMBER",
    "NUMERIC",
    "NVARCHAR",
    "OF",
    "OFFSET",
    "OLD_PASSWORD",
    "ON",
    "ONE",
    "ONLINE",
    "ONLY",
    "OPEN",
    "OPTIMIZE",
    "OPTIONS",
    "OPTION",
    "OPTIONALLY",
    "OR",
    "ORDER",
    "ORDINALITY",
    "OTHERS",
    "OUT",
    "OUTER",
    "OUTFILE",
    "OVER",
    "OVERLAPS",
    "OWNER",
    "PACKAGE",
    "PACK_KEYS",
    "PAGE",
    "PAGE_CHECKSUM",
    "PARSER",
    "PARSE_VCOL_EXPR",
    "PATH",
    "PERIOD",
    "PARTIAL",
    "PARTITION",
    "PARTITIONING",
    "PARTITIONS",
    "PASSWORD",
    "PERSISTENT",
    "PHASE",
    "PLUGIN",
    "PLUGINS",
    "PORT",
    "PORTION",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    "PREPARE",
    "PRESERVE",
    "PREV",
    "PREVIOUS",
    "PRIMARY",
    "PRIVILEGES",
    "PROCEDURE",
    "PROCESS",
    "PROCESSLIST",
    "PROFILE",
    "PROFILES",
    "PROXY",
    "PURGE",
    "QUARTER",
    "QUERY",
    "QUICK",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "READ_ONLY",
    "READ_WRITE",
    "READS",
    "REAL",
    "REBUILD",
    "RECOVER",
    "RECURSIVE",
    "REDO_BUFFER_SIZE",
    "REDOFILE",
    "REDUNDANT",
    "REFERENCES",
    "REGEXP",
    "RELAY",
    "RELAYLOG",
    "RELAY_LOG_FILE",
    "RELAY_LOG_POS",
    "RELAY_THREAD",
    "RELEASE",
    "RELOAD",
    "REMOVE",
    "RENAME",
    "REORGANIZE",
    "REPAIR",
    "REPEATABLE",
    "REPLACE",
    "REPLAY",
    "REPLICA",
    "REPLICAS",
    "REPLICA_POS",
    "REPLICATION",
    "REPEAT",
    "REQUIRE",
    "RESET",
    "RESIGNAL",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    "RESUME",
    "RETURNED_SQLSTATE",
    "RETURN",
    "RETURNING",
    "RETURNS",
    "REUSE",
    "REVERSE",
    "REVOKE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROUTINE",
    "ROW",
    "ROWCOUNT",
    "ROWNUM",
    "ROWS",
    "ROWTYPE",
    "ROW_COUNT",
    "ROW_FORMAT",
    "RTREE",
    "SAVEPOINT",
    "SCHEDULE",
    "SCHEMA",
    "SCHEMA_NAME",
    "SCHEMAS",
    "SECOND",
    "SECOND_MICROSECOND",
    "SECURITY",
    "SELECT",
    "SENSITIVE",
    "SEPARATOR",
    "SEQUENCE",
    "SERIAL",
    "SERIALIZABLE",
    "SESSION",
    "SERVER",
    "SET",
    "SETVAL",
    "SHARE",
    "SHOW",
    "SHUTDOWN",
    "SIGNAL",
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SLAVE",
    "SLAVES",
    "SLAVE_POS",
    "SLOW",
    "SNAPSHOT",
    "SMALLINT",
    "SOCKET",
    "SOFT",
    "SOME",
    "SONAME",
    "SOUNDS",
    "SOURCE",
    "STAGE",
    "STORED",
    "SPATIAL",
    "SPECIFIC",
    "REF_SYSTEM_ID",
    "SQL",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "SQL_BIG_RESULT",
    "SQL_BUFFER_RESULT",
    "SQL_CACHE",
    "SQL_CALC_FOUND_ROWS",
    "SQL_NO_CACHE",
    "SQL_SMALL_RESULT",
    "SQL_THREAD",
    "SQL_TSI_SECOND",
    "SQL_TSI_MINUTE",
    "SQL_TSI_HOUR",
    "SQL_TSI_DAY",
    "SQL_TSI_WEEK",
    "SQL_TSI_MONTH",
    "SQL_TSI_QUARTER",
    "SQL_TSI_YEAR",
    "SSL",
    "START",
    "STARTING",
    "STARTS",
    "STATEMENT",
    "STATS_AUTO_RECALC",
    "STATS_PERSISTENT",
    "STATS_SAMPLE_PAGES",
    "STATUS",
    "STOP",
    "STORAGE",
    "STRAIGHT_JOIN",
    "STRING",
    "SUBCLASS_ORIGIN",
    "SUBJECT",
    "SUBPARTITION",
    "SUBPARTITIONS",
    "SUPER",
    "SUSPEND",
    "SWAPS",
    "SWITCHES",
    "SYSDATE",
    "SYSTEM",
    "SYSTEM_TIME",
    "TABLE",
    "TABLE_NAME",
    "TABLES",
    "TABLESPACE",
    "TABLE_CHECKSUM",
    "TEMPORARY",
    "TEMPTABLE",
    "TERMINATED",
    "TEXT",
    "THAN",
    "THEN",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TINYBLOB",
    "TINYINT",
    "TINYTEXT",
    "TO",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONAL",
    "THREADS",
    "TRIGGER",
    "TRIGGERS",
    "TRUE",
    "TRUNCATE",
    "TYPE",
    "TYPES",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNDEFINED",
    "UNDO_BUFFER_SIZE",
    "UNDOFILE",
    "UNDO",
    "UNICODE",
    "UNION",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNINSTALL",
    "UNSIGNED",
    "UNTIL",
    "UPDATE",
    "UPGRADE",
    "USAGE",
    "USE",
    "USER",
    "USER_RESOURCES",
    "USE_FRM",
    "USING",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "VALUE",
    "VALUES",
    "VARBINARY",
    "VARCHAR",
    "VARCHARACTER",
    "VARCHAR2",
    "VARIABLES",
    "VARYING",
    "VIA",
    "VIEW",
    "VIRTUAL",
    "VISIBLE",
    "VERSIONING",
    "WAIT",
    "WARNINGS",
    "WEEK",
    "WEIGHT_STRING",
    "WHEN",
    "WHERE",
    "WHILE",
    "WINDOW",
    "WITH",
    "WITHIN",
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    "X509",
    "XOR",
    "XA",
    "XML",
    "YEAR",
    "YEAR_MONTH",
    "ZEROFILL"
  ]
}), p2e = wt({
  // https://mariadb.com/kb/en/information-schema-sql_functions-table/
  all: [
    "ADDDATE",
    "ADD_MONTHS",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "CAST",
    "COUNT",
    "CUME_DIST",
    "CURDATE",
    "CURTIME",
    "DATE_ADD",
    "DATE_SUB",
    "DATE_FORMAT",
    "DECODE",
    "DENSE_RANK",
    "EXTRACT",
    "FIRST_VALUE",
    "GROUP_CONCAT",
    "JSON_ARRAYAGG",
    "JSON_OBJECTAGG",
    "LAG",
    "LEAD",
    "MAX",
    "MEDIAN",
    "MID",
    "MIN",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "POSITION",
    "PERCENT_RANK",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "RANK",
    "ROW_NUMBER",
    "SESSION_USER",
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUM",
    "SYSTEM_USER",
    "TRIM",
    "TRIM_ORACLE",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "ABS",
    "ACOS",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    "ASIN",
    "ATAN",
    "ATAN2",
    "BENCHMARK",
    "BIN",
    "BINLOG_GTID_POS",
    "BIT_COUNT",
    "BIT_LENGTH",
    "CEIL",
    "CEILING",
    "CHARACTER_LENGTH",
    "CHAR_LENGTH",
    "CHR",
    "COERCIBILITY",
    "COLUMN_CHECK",
    "COLUMN_EXISTS",
    "COLUMN_LIST",
    "COLUMN_JSON",
    "COMPRESS",
    "CONCAT",
    "CONCAT_OPERATOR_ORACLE",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT_TZ",
    "COS",
    "COT",
    "CRC32",
    "DATEDIFF",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DEGREES",
    "DECODE_HISTOGRAM",
    "DECODE_ORACLE",
    "DES_DECRYPT",
    "DES_ENCRYPT",
    "ELT",
    "ENCODE",
    "ENCRYPT",
    "EXP",
    "EXPORT_SET",
    "EXTRACTVALUE",
    "FIELD",
    "FIND_IN_SET",
    "FLOOR",
    "FORMAT",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GET_LOCK",
    "GREATEST",
    "HEX",
    "IFNULL",
    "INSTR",
    "ISNULL",
    "IS_FREE_LOCK",
    "IS_USED_LOCK",
    "JSON_ARRAY",
    "JSON_ARRAY_APPEND",
    "JSON_ARRAY_INSERT",
    "JSON_COMPACT",
    "JSON_CONTAINS",
    "JSON_CONTAINS_PATH",
    "JSON_DEPTH",
    "JSON_DETAILED",
    "JSON_EXISTS",
    "JSON_EXTRACT",
    "JSON_INSERT",
    "JSON_KEYS",
    "JSON_LENGTH",
    "JSON_LOOSE",
    "JSON_MERGE",
    "JSON_MERGE_PATCH",
    "JSON_MERGE_PRESERVE",
    "JSON_QUERY",
    "JSON_QUOTE",
    "JSON_OBJECT",
    "JSON_REMOVE",
    "JSON_REPLACE",
    "JSON_SET",
    "JSON_SEARCH",
    "JSON_TYPE",
    "JSON_UNQUOTE",
    "JSON_VALID",
    "JSON_VALUE",
    "LAST_DAY",
    "LAST_INSERT_ID",
    "LCASE",
    "LEAST",
    "LENGTH",
    "LENGTHB",
    "LN",
    "LOAD_FILE",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LOWER",
    "LPAD",
    "LPAD_ORACLE",
    "LTRIM",
    "LTRIM_ORACLE",
    "MAKEDATE",
    "MAKETIME",
    "MAKE_SET",
    "MASTER_GTID_WAIT",
    "MASTER_POS_WAIT",
    "MD5",
    "MONTHNAME",
    "NAME_CONST",
    "NVL",
    "NVL2",
    "OCT",
    "OCTET_LENGTH",
    "ORD",
    "PERIOD_ADD",
    "PERIOD_DIFF",
    "PI",
    "POW",
    "POWER",
    "QUOTE",
    "REGEXP_INSTR",
    "REGEXP_REPLACE",
    "REGEXP_SUBSTR",
    "RADIANS",
    "RAND",
    "RELEASE_ALL_LOCKS",
    "RELEASE_LOCK",
    "REPLACE_ORACLE",
    "REVERSE",
    "ROUND",
    "RPAD",
    "RPAD_ORACLE",
    "RTRIM",
    "RTRIM_ORACLE",
    "SEC_TO_TIME",
    "SHA",
    "SHA1",
    "SHA2",
    "SIGN",
    "SIN",
    "SLEEP",
    "SOUNDEX",
    "SPACE",
    "SQRT",
    "STRCMP",
    "STR_TO_DATE",
    "SUBSTR_ORACLE",
    "SUBSTRING_INDEX",
    "SUBTIME",
    "SYS_GUID",
    "TAN",
    "TIMEDIFF",
    "TIME_FORMAT",
    "TIME_TO_SEC",
    "TO_BASE64",
    "TO_CHAR",
    "TO_DAYS",
    "TO_SECONDS",
    "UCASE",
    "UNCOMPRESS",
    "UNCOMPRESSED_LENGTH",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "UUID",
    "UUID_SHORT",
    "VERSION",
    "WEEKDAY",
    "WEEKOFYEAR",
    "WSREP_LAST_WRITTEN_GTID",
    "WSREP_LAST_SEEN_GTID",
    "WSREP_SYNC_WAIT_UPTO_GTID",
    "YEARWEEK",
    // CASE expression shorthands
    "COALESCE",
    "NULLIF",
    // Data types with parameters
    // https://mariadb.com/kb/en/data-types/
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    // 'NUMBER', // ?? In oracle mode only
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "BIT",
    "BINARY",
    "BLOB",
    "CHAR",
    "NATIONAL CHAR",
    "CHAR BYTE",
    "ENUM",
    "VARBINARY",
    "VARCHAR",
    "NATIONAL VARCHAR",
    // 'SET' // handled as special-case in postProcess
    "TIME",
    "DATETIME",
    "TIMESTAMP",
    "YEAR"
  ]
}), g2e = re(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), v2e = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMPORARY] TABLE [IF NOT EXISTS]",
  // other
  "RETURNING"
]), WB = re([
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] [IGNORE] TABLE [IF EXISTS]",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "{CHANGE | MODIFY} [COLUMN] [IF EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "RENAME [TO]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  "SET {VISIBLE | INVISIBLE}",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://mariadb.com/docs/reference/mdb/sql-statements/
  "ALTER DATABASE",
  "ALTER DATABASE COMMENT",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER SCHEMA COMMENT",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE",
  "ANALYZE TABLE",
  "BACKUP LOCK",
  "BACKUP STAGE",
  "BACKUP UNLOCK",
  "BEGIN",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHECK TABLE",
  "CHECK VIEW",
  "CHECKSUM TABLE",
  "COMMIT",
  "CREATE AGGREGATE FUNCTION",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PROCEDURE",
  "CREATE ROLE",
  "CREATE SEQUENCE",
  "CREATE SERVER",
  "CREATE SPATIAL INDEX",
  "CREATE TRIGGER",
  "CREATE UNIQUE INDEX",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PREPARE",
  "DROP PROCEDURE",
  "DROP ROLE",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GET DIAGNOSTICS",
  "GET DIAGNOSTICS CONDITION",
  "GRANT",
  "HANDLER",
  "HELP",
  "INSTALL PLUGIN",
  "INSTALL SONAME",
  "KILL",
  "LOAD DATA INFILE",
  "LOAD INDEX INTO CACHE",
  "LOAD XML INFILE",
  "LOCK TABLE",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "PURGE MASTER LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "REPAIR VIEW",
  "RESET MASTER",
  "RESET QUERY CACHE",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESIGNAL",
  "REVOKE",
  "ROLLBACK",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET GLOBAL TRANSACTION",
  "SET NAMES",
  "SET PASSWORD",
  "SET ROLE",
  "SET STATEMENT",
  "SET TRANSACTION",
  "SHOW",
  "SHOW ALL REPLICAS STATUS",
  "SHOW ALL SLAVES STATUS",
  "SHOW AUTHORS",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW BINLOG STATUS",
  "SHOW CHARACTER SET",
  "SHOW CLIENT_STATISTICS",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CONTRIBUTORS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PACKAGE",
  "SHOW CREATE PACKAGE BODY",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE SEQUENCE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINE INNODB STATUS",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW EXPLAIN",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW INDEXES",
  "SHOW INDEX_STATISTICS",
  "SHOW KEYS",
  "SHOW LOCALES",
  "SHOW MASTER LOGS",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PACKAGE BODY CODE",
  "SHOW PACKAGE BODY STATUS",
  "SHOW PACKAGE STATUS",
  "SHOW PLUGINS",
  "SHOW PLUGINS SONAME",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW QUERY_RESPONSE_TIME",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA",
  "SHOW REPLICA HOSTS",
  "SHOW REPLICA STATUS",
  "SHOW SCHEMAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW SLAVE STATUS",
  "SHOW STATUS",
  "SHOW STORAGE ENGINES",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW USER_STATISTICS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHOW WSREP_MEMBERSHIP",
  "SHOW WSREP_STATUS",
  "SHUTDOWN",
  "SIGNAL",
  "START ALL REPLICAS",
  "START ALL SLAVES",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP ALL REPLICAS",
  "STOP ALL SLAVES",
  "STOP REPLICA",
  "STOP SLAVE",
  "UNINSTALL PLUGIN",
  "UNINSTALL SONAME",
  "UNLOCK TABLE",
  "USE",
  "XA BEGIN",
  "XA COMMIT",
  "XA END",
  "XA PREPARE",
  "XA RECOVER",
  "XA ROLLBACK",
  "XA START"
]), O2e = re(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]", "MINUS [ALL | DISTINCT]"]), m2e = re([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), E2e = re(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), b2e = {
  tokenizerOptions: {
    reservedSelect: g2e,
    reservedClauses: [...v2e, ...WB],
    reservedSetOperations: O2e,
    reservedJoins: m2e,
    reservedPhrases: E2e,
    supportsXor: !0,
    reservedKeywords: d2e,
    reservedFunctionNames: p2e,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: ['""-qq-bs', "''-qq-bs", {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_.$]+"
    }, {
      quote: '""-qq-bs',
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "''-qq-bs",
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    paramTypes: {
      positional: !0
    },
    lineCommentTypes: ["--", "#"],
    operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "!"],
    postProcess: S2e
  },
  formatOptions: {
    onelineClauses: WB
  }
};
function S2e(r) {
  return r.map((e, t) => {
    const i = r[t + 1] || Uc;
    return Xl.SET(e) && i.text === "(" ? {
      ...e,
      type: ee.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const T2e = wt({
  // https://dev.mysql.com/doc/refman/8.0/en/keywords.html
  all: [
    "ACCESSIBLE",
    // (R)
    "ACCOUNT",
    "ACTION",
    "ACTIVE",
    "ADD",
    // (R)
    "ADMIN",
    "AFTER",
    "AGAINST",
    "AGGREGATE",
    "ALGORITHM",
    "ALL",
    // (R)
    "ALTER",
    // (R)
    "ALWAYS",
    "ANALYZE",
    // (R)
    "AND",
    // (R)
    "ANY",
    "ARRAY",
    "AS",
    // (R)
    "ASC",
    // (R)
    "ASCII",
    "ASENSITIVE",
    // (R)
    "AT",
    "ATTRIBUTE",
    "AUTHENTICATION",
    "AUTOEXTEND_SIZE",
    "AUTO_INCREMENT",
    "AVG",
    "AVG_ROW_LENGTH",
    "BACKUP",
    "BEFORE",
    // (R)
    "BEGIN",
    "BETWEEN",
    // (R)
    "BIGINT",
    // (R)
    "BINARY",
    // (R)
    "BINLOG",
    "BIT",
    "BLOB",
    // (R)
    "BLOCK",
    "BOOL",
    "BOOLEAN",
    "BOTH",
    // (R)
    "BTREE",
    "BUCKETS",
    "BY",
    // (R)
    "BYTE",
    "CACHE",
    "CALL",
    // (R)
    "CASCADE",
    // (R)
    "CASCADED",
    "CASE",
    // (R)
    "CATALOG_NAME",
    "CHAIN",
    "CHALLENGE_RESPONSE",
    "CHANGE",
    // (R)
    "CHANGED",
    "CHANNEL",
    "CHAR",
    // (R)
    "CHARACTER",
    // (R)
    "CHARSET",
    "CHECK",
    // (R)
    "CHECKSUM",
    "CIPHER",
    "CLASS_ORIGIN",
    "CLIENT",
    "CLONE",
    "CLOSE",
    "COALESCE",
    "CODE",
    "COLLATE",
    // (R)
    "COLLATION",
    "COLUMN",
    // (R)
    "COLUMNS",
    "COLUMN_FORMAT",
    "COLUMN_NAME",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPACT",
    "COMPLETION",
    "COMPONENT",
    "COMPRESSED",
    "COMPRESSION",
    "CONCURRENT",
    "CONDITION",
    // (R)
    "CONNECTION",
    "CONSISTENT",
    "CONSTRAINT",
    // (R)
    "CONSTRAINT_CATALOG",
    "CONSTRAINT_NAME",
    "CONSTRAINT_SCHEMA",
    "CONTAINS",
    "CONTEXT",
    "CONTINUE",
    // (R)
    "CONVERT",
    // (R)
    "CPU",
    "CREATE",
    // (R)
    "CROSS",
    // (R)
    "CUBE",
    // (R)
    "CUME_DIST",
    // (R)
    "CURRENT",
    "CURRENT_DATE",
    // (R)
    "CURRENT_TIME",
    // (R)
    "CURRENT_TIMESTAMP",
    // (R)
    "CURRENT_USER",
    // (R)
    "CURSOR",
    // (R)
    "CURSOR_NAME",
    "DATA",
    "DATABASE",
    // (R)
    "DATABASES",
    // (R)
    "DATAFILE",
    "DATE",
    "DATETIME",
    "DAY",
    "DAY_HOUR",
    // (R)
    "DAY_MICROSECOND",
    // (R)
    "DAY_MINUTE",
    // (R)
    "DAY_SECOND",
    // (R)
    "DEALLOCATE",
    "DEC",
    // (R)
    "DECIMAL",
    // (R)
    "DECLARE",
    // (R)
    "DEFAULT",
    // (R)
    "DEFAULT_AUTH",
    "DEFINER",
    "DEFINITION",
    "DELAYED",
    // (R)
    "DELAY_KEY_WRITE",
    "DELETE",
    // (R)
    "DENSE_RANK",
    // (R)
    "DESC",
    // (R)
    "DESCRIBE",
    // (R)
    "DESCRIPTION",
    "DETERMINISTIC",
    // (R)
    "DIAGNOSTICS",
    "DIRECTORY",
    "DISABLE",
    "DISCARD",
    "DISK",
    "DISTINCT",
    // (R)
    "DISTINCTROW",
    // (R)
    "DIV",
    // (R)
    "DO",
    "DOUBLE",
    // (R)
    "DROP",
    // (R)
    "DUAL",
    // (R)
    "DUMPFILE",
    "DUPLICATE",
    "DYNAMIC",
    "EACH",
    // (R)
    "ELSE",
    // (R)
    "ELSEIF",
    // (R)
    "EMPTY",
    // (R)
    "ENABLE",
    "ENCLOSED",
    // (R)
    "ENCRYPTION",
    "END",
    "ENDS",
    "ENFORCED",
    "ENGINE",
    "ENGINES",
    "ENGINE_ATTRIBUTE",
    "ENUM",
    "ERROR",
    "ERRORS",
    "ESCAPE",
    "ESCAPED",
    // (R)
    "EVENT",
    "EVENTS",
    "EVERY",
    "EXCEPT",
    // (R)
    "EXCHANGE",
    "EXCLUDE",
    "EXECUTE",
    "EXISTS",
    // (R)
    "EXIT",
    // (R)
    "EXPANSION",
    "EXPIRE",
    "EXPLAIN",
    // (R)
    "EXPORT",
    "EXTENDED",
    "EXTENT_SIZE",
    "FACTOR",
    "FAILED_LOGIN_ATTEMPTS",
    "FALSE",
    // (R)
    "FAST",
    "FAULTS",
    "FETCH",
    // (R)
    "FIELDS",
    "FILE",
    "FILE_BLOCK_SIZE",
    "FILTER",
    "FINISH",
    "FIRST",
    "FIRST_VALUE",
    // (R)
    "FIXED",
    "FLOAT",
    // (R)
    "FLOAT4",
    // (R)
    "FLOAT8",
    // (R)
    "FLUSH",
    "FOLLOWING",
    "FOLLOWS",
    "FOR",
    // (R)
    "FORCE",
    // (R)
    "FOREIGN",
    // (R)
    "FORMAT",
    "FOUND",
    "FROM",
    // (R)
    "FULL",
    "FULLTEXT",
    // (R)
    "FUNCTION",
    // (R)
    "GENERAL",
    "GENERATED",
    // (R)
    "GEOMCOLLECTION",
    "GEOMETRY",
    "GEOMETRYCOLLECTION",
    "GET",
    // (R)
    "GET_FORMAT",
    "GET_MASTER_PUBLIC_KEY",
    "GET_SOURCE_PUBLIC_KEY",
    "GLOBAL",
    "GRANT",
    // (R)
    "GRANTS",
    "GROUP",
    // (R)
    "GROUPING",
    // (R)
    "GROUPS",
    // (R)
    "GROUP_REPLICATION",
    "GTID_ONLY",
    "HANDLER",
    "HASH",
    "HAVING",
    // (R)
    "HELP",
    "HIGH_PRIORITY",
    // (R)
    "HISTOGRAM",
    "HISTORY",
    "HOST",
    "HOSTS",
    "HOUR",
    "HOUR_MICROSECOND",
    // (R)
    "HOUR_MINUTE",
    // (R)
    "HOUR_SECOND",
    // (R)
    "IDENTIFIED",
    "IF",
    // (R)
    "IGNORE",
    // (R)
    "IGNORE_SERVER_IDS",
    "IMPORT",
    "IN",
    // (R)
    "INACTIVE",
    "INDEX",
    // (R)
    "INDEXES",
    "INFILE",
    // (R)
    "INITIAL",
    "INITIAL_SIZE",
    "INITIATE",
    "INNER",
    // (R)
    "INOUT",
    // (R)
    "INSENSITIVE",
    // (R)
    "INSERT",
    // (R)
    "INSERT_METHOD",
    "INSTALL",
    "INSTANCE",
    "IN",
    // <-- moved over from functions
    "INT",
    // (R)
    "INT1",
    // (R)
    "INT2",
    // (R)
    "INT3",
    // (R)
    "INT4",
    // (R)
    "INT8",
    // (R)
    "INTEGER",
    // (R)
    "INTERSECT",
    // (R)
    "INTERVAL",
    // (R)
    "INTO",
    // (R)
    "INVISIBLE",
    "INVOKER",
    "IO",
    "IO_AFTER_GTIDS",
    // (R)
    "IO_BEFORE_GTIDS",
    // (R)
    "IO_THREAD",
    "IPC",
    "IS",
    // (R)
    "ISOLATION",
    "ISSUER",
    "ITERATE",
    // (R)
    "JOIN",
    // (R)
    "JSON",
    "JSON_TABLE",
    // (R)
    "JSON_VALUE",
    "KEY",
    // (R)
    "KEYRING",
    "KEYS",
    // (R)
    "KEY_BLOCK_SIZE",
    "KILL",
    // (R)
    "LAG",
    // (R)
    "LANGUAGE",
    "LAST",
    "LAST_VALUE",
    // (R)
    "LATERAL",
    // (R)
    "LEAD",
    // (R)
    "LEADING",
    // (R)
    "LEAVE",
    // (R)
    "LEAVES",
    "LEFT",
    // (R)
    "LESS",
    "LEVEL",
    "LIKE",
    // (R)
    "LIMIT",
    // (R)
    "LINEAR",
    // (R)
    "LINES",
    // (R)
    "LINESTRING",
    "LIST",
    "LOAD",
    // (R)
    "LOCAL",
    "LOCALTIME",
    // (R)
    "LOCALTIMESTAMP",
    // (R)
    "LOCK",
    // (R)
    "LOCKED",
    "LOCKS",
    "LOGFILE",
    "LOGS",
    "LONG",
    // (R)
    "LONGBLOB",
    // (R)
    "LONGTEXT",
    // (R)
    "LOOP",
    // (R)
    "LOW_PRIORITY",
    // (R)
    "MASTER",
    "MASTER_AUTO_POSITION",
    "MASTER_BIND",
    // (R)
    "MASTER_COMPRESSION_ALGORITHMS",
    "MASTER_CONNECT_RETRY",
    "MASTER_DELAY",
    "MASTER_HEARTBEAT_PERIOD",
    "MASTER_HOST",
    "MASTER_LOG_FILE",
    "MASTER_LOG_POS",
    "MASTER_PASSWORD",
    "MASTER_PORT",
    "MASTER_PUBLIC_KEY_PATH",
    "MASTER_RETRY_COUNT",
    "MASTER_SSL",
    "MASTER_SSL_CA",
    "MASTER_SSL_CAPATH",
    "MASTER_SSL_CERT",
    "MASTER_SSL_CIPHER",
    "MASTER_SSL_CRL",
    "MASTER_SSL_CRLPATH",
    "MASTER_SSL_KEY",
    "MASTER_SSL_VERIFY_SERVER_CERT",
    // (R)
    "MASTER_TLS_CIPHERSUITES",
    "MASTER_TLS_VERSION",
    "MASTER_USER",
    "MASTER_ZSTD_COMPRESSION_LEVEL",
    "MATCH",
    // (R)
    "MAXVALUE",
    // (R)
    "MAX_CONNECTIONS_PER_HOUR",
    "MAX_QUERIES_PER_HOUR",
    "MAX_ROWS",
    "MAX_SIZE",
    "MAX_UPDATES_PER_HOUR",
    "MAX_USER_CONNECTIONS",
    "MEDIUM",
    "MEDIUMBLOB",
    // (R)
    "MEDIUMINT",
    // (R)
    "MEDIUMTEXT",
    // (R)
    "MEMBER",
    "MEMORY",
    "MERGE",
    "MESSAGE_TEXT",
    "MICROSECOND",
    "MIDDLEINT",
    // (R)
    "MIGRATE",
    "MINUTE",
    "MINUTE_MICROSECOND",
    // (R)
    "MINUTE_SECOND",
    // (R)
    "MIN_ROWS",
    "MOD",
    // (R)
    "MODE",
    "MODIFIES",
    // (R)
    "MODIFY",
    "MONTH",
    "MULTILINESTRING",
    "MULTIPOINT",
    "MULTIPOLYGON",
    "MUTEX",
    "MYSQL_ERRNO",
    "NAME",
    "NAMES",
    "NATIONAL",
    "NATURAL",
    // (R)
    "NCHAR",
    "NDB",
    "NDBCLUSTER",
    "NESTED",
    "NETWORK_NAMESPACE",
    "NEVER",
    "NEW",
    "NEXT",
    "NO",
    "NODEGROUP",
    "NONE",
    "NOT",
    // (R)
    "NOWAIT",
    "NO_WAIT",
    "NO_WRITE_TO_BINLOG",
    // (R)
    "NTH_VALUE",
    // (R)
    "NTILE",
    // (R)
    "NULL",
    // (R)
    "NULLS",
    "NUMBER",
    "NUMERIC",
    // (R)
    "NVARCHAR",
    "OF",
    // (R)
    "OFF",
    "OFFSET",
    "OJ",
    "OLD",
    "ON",
    // (R)
    "ONE",
    "ONLY",
    "OPEN",
    "OPTIMIZE",
    // (R)
    "OPTIMIZER_COSTS",
    // (R)
    "OPTION",
    // (R)
    "OPTIONAL",
    "OPTIONALLY",
    // (R)
    "OPTIONS",
    "OR",
    // (R)
    "ORDER",
    // (R)
    "ORDINALITY",
    "ORGANIZATION",
    "OTHERS",
    "OUT",
    // (R)
    "OUTER",
    // (R)
    "OUTFILE",
    // (R)
    "OVER",
    // (R)
    "OWNER",
    "PACK_KEYS",
    "PAGE",
    "PARSER",
    "PARTIAL",
    "PARTITION",
    // (R)
    "PARTITIONING",
    "PARTITIONS",
    "PASSWORD",
    "PASSWORD_LOCK_TIME",
    "PATH",
    "PERCENT_RANK",
    // (R)
    "PERSIST",
    "PERSIST_ONLY",
    "PHASE",
    "PLUGIN",
    "PLUGINS",
    "PLUGIN_DIR",
    "POINT",
    "POLYGON",
    "PORT",
    "PRECEDES",
    "PRECEDING",
    "PRECISION",
    // (R)
    "PREPARE",
    "PRESERVE",
    "PREV",
    "PRIMARY",
    // (R)
    "PRIVILEGES",
    "PRIVILEGE_CHECKS_USER",
    "PROCEDURE",
    // (R)
    "PROCESS",
    "PROCESSLIST",
    "PROFILE",
    "PROFILES",
    "PROXY",
    "PURGE",
    // (R)
    "QUARTER",
    "QUERY",
    "QUICK",
    "RANDOM",
    "RANGE",
    // (R)
    "RANK",
    // (R)
    "READ",
    // (R)
    "READS",
    // (R)
    "READ_ONLY",
    "READ_WRITE",
    // (R)
    "REAL",
    // (R)
    "REBUILD",
    "RECOVER",
    "RECURSIVE",
    // (R)
    "REDO_BUFFER_SIZE",
    "REDUNDANT",
    "REFERENCE",
    "REFERENCES",
    // (R)
    "REGEXP",
    // (R)
    "REGISTRATION",
    "RELAY",
    "RELAYLOG",
    "RELAY_LOG_FILE",
    "RELAY_LOG_POS",
    "RELAY_THREAD",
    "RELEASE",
    // (R)
    "RELOAD",
    "REMOVE",
    "RENAME",
    // (R)
    "REORGANIZE",
    "REPAIR",
    "REPEAT",
    // (R)
    "REPEATABLE",
    "REPLACE",
    // (R)
    "REPLICA",
    "REPLICAS",
    "REPLICATE_DO_DB",
    "REPLICATE_DO_TABLE",
    "REPLICATE_IGNORE_DB",
    "REPLICATE_IGNORE_TABLE",
    "REPLICATE_REWRITE_DB",
    "REPLICATE_WILD_DO_TABLE",
    "REPLICATE_WILD_IGNORE_TABLE",
    "REPLICATION",
    "REQUIRE",
    // (R)
    "REQUIRE_ROW_FORMAT",
    "RESET",
    "RESIGNAL",
    // (R)
    "RESOURCE",
    "RESPECT",
    "RESTART",
    "RESTORE",
    "RESTRICT",
    // (R)
    "RESUME",
    "RETAIN",
    "RETURN",
    // (R)
    "RETURNED_SQLSTATE",
    "RETURNING",
    "RETURNS",
    "REUSE",
    "REVERSE",
    "REVOKE",
    // (R)
    "RIGHT",
    // (R)
    "RLIKE",
    // (R)
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROTATE",
    "ROUTINE",
    "ROW",
    // (R)
    "ROWS",
    // (R)
    "ROW_COUNT",
    "ROW_FORMAT",
    "ROW_NUMBER",
    // (R)
    "RTREE",
    "SAVEPOINT",
    "SCHEDULE",
    "SCHEMA",
    // (R)
    "SCHEMAS",
    // (R)
    "SCHEMA_NAME",
    "SECOND",
    "SECONDARY",
    "SECONDARY_ENGINE",
    "SECONDARY_ENGINE_ATTRIBUTE",
    "SECONDARY_LOAD",
    "SECONDARY_UNLOAD",
    "SECOND_MICROSECOND",
    // (R)
    "SECURITY",
    "SELECT",
    // (R)
    "SENSITIVE",
    // (R)
    "SEPARATOR",
    // (R)
    "SERIAL",
    "SERIALIZABLE",
    "SERVER",
    "SESSION",
    "SET",
    // (R)
    "SHARE",
    "SHOW",
    // (R)
    "SHUTDOWN",
    "SIGNAL",
    // (R)
    "SIGNED",
    "SIMPLE",
    "SKIP",
    "SLAVE",
    "SLOW",
    "SMALLINT",
    // (R)
    "SNAPSHOT",
    "SOCKET",
    "SOME",
    "SONAME",
    "SOUNDS",
    "SOURCE",
    "SOURCE_AUTO_POSITION",
    "SOURCE_BIND",
    "SOURCE_COMPRESSION_ALGORITHMS",
    "SOURCE_CONNECT_RETRY",
    "SOURCE_DELAY",
    "SOURCE_HEARTBEAT_PERIOD",
    "SOURCE_HOST",
    "SOURCE_LOG_FILE",
    "SOURCE_LOG_POS",
    "SOURCE_PASSWORD",
    "SOURCE_PORT",
    "SOURCE_PUBLIC_KEY_PATH",
    "SOURCE_RETRY_COUNT",
    "SOURCE_SSL",
    "SOURCE_SSL_CA",
    "SOURCE_SSL_CAPATH",
    "SOURCE_SSL_CERT",
    "SOURCE_SSL_CIPHER",
    "SOURCE_SSL_CRL",
    "SOURCE_SSL_CRLPATH",
    "SOURCE_SSL_KEY",
    "SOURCE_SSL_VERIFY_SERVER_CERT",
    "SOURCE_TLS_CIPHERSUITES",
    "SOURCE_TLS_VERSION",
    "SOURCE_USER",
    "SOURCE_ZSTD_COMPRESSION_LEVEL",
    "SPATIAL",
    // (R)
    "SPECIFIC",
    // (R)
    "SQL",
    // (R)
    "SQLEXCEPTION",
    // (R)
    "SQLSTATE",
    // (R)
    "SQLWARNING",
    // (R)
    "SQL_AFTER_GTIDS",
    "SQL_AFTER_MTS_GAPS",
    "SQL_BEFORE_GTIDS",
    "SQL_BIG_RESULT",
    // (R)
    "SQL_BUFFER_RESULT",
    "SQL_CALC_FOUND_ROWS",
    // (R)
    "SQL_NO_CACHE",
    "SQL_SMALL_RESULT",
    // (R)
    "SQL_THREAD",
    "SQL_TSI_DAY",
    "SQL_TSI_HOUR",
    "SQL_TSI_MINUTE",
    "SQL_TSI_MONTH",
    "SQL_TSI_QUARTER",
    "SQL_TSI_SECOND",
    "SQL_TSI_WEEK",
    "SQL_TSI_YEAR",
    "SRID",
    "SSL",
    // (R)
    "STACKED",
    "START",
    "STARTING",
    // (R)
    "STARTS",
    "STATS_AUTO_RECALC",
    "STATS_PERSISTENT",
    "STATS_SAMPLE_PAGES",
    "STATUS",
    "STOP",
    "STORAGE",
    "STORED",
    // (R)
    "STRAIGHT_JOIN",
    // (R)
    "STREAM",
    "STRING",
    "SUBCLASS_ORIGIN",
    "SUBJECT",
    "SUBPARTITION",
    "SUBPARTITIONS",
    "SUPER",
    "SUSPEND",
    "SWAPS",
    "SWITCHES",
    "SYSTEM",
    // (R)
    "TABLE",
    // (R)
    "TABLES",
    "TABLESPACE",
    "TABLE_CHECKSUM",
    "TABLE_NAME",
    "TEMPORARY",
    "TEMPTABLE",
    "TERMINATED",
    // (R)
    "TEXT",
    "THAN",
    "THEN",
    // (R)
    "THREAD_PRIORITY",
    "TIES",
    "TIME",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TINYBLOB",
    // (R)
    "TINYINT",
    // (R)
    "TINYTEXT",
    // (R)
    "TLS",
    "TO",
    // (R)
    "TRAILING",
    // (R)
    "TRANSACTION",
    "TRIGGER",
    // (R)
    "TRIGGERS",
    "TRUE",
    // (R)
    "TRUNCATE",
    "TYPE",
    "TYPES",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNDEFINED",
    "UNDO",
    // (R)
    "UNDOFILE",
    "UNDO_BUFFER_SIZE",
    "UNICODE",
    "UNINSTALL",
    "UNION",
    // (R)
    "UNIQUE",
    // (R)
    "UNKNOWN",
    "UNLOCK",
    // (R)
    "UNREGISTER",
    "UNSIGNED",
    // (R)
    "UNTIL",
    "UPDATE",
    // (R)
    "UPGRADE",
    "USAGE",
    // (R)
    "USE",
    // (R)
    "USER",
    "USER_RESOURCES",
    "USE_FRM",
    "USING",
    // (R)
    "UTC_DATE",
    // (R)
    "UTC_TIME",
    // (R)
    "UTC_TIMESTAMP",
    // (R)
    "VALIDATION",
    "VALUE",
    "VALUES",
    // (R)
    "VARBINARY",
    // (R)
    "VARCHAR",
    // (R)
    "VARCHARACTER",
    // (R)
    "VARIABLES",
    "VARYING",
    // (R)
    "VCPU",
    "VIEW",
    "VIRTUAL",
    // (R)
    "VISIBLE",
    "WAIT",
    "WARNINGS",
    "WEEK",
    "WEIGHT_STRING",
    "WHEN",
    // (R)
    "WHERE",
    // (R)
    "WHILE",
    // (R)
    "WINDOW",
    // (R)
    "WITH",
    // (R)
    "WITHOUT",
    "WORK",
    "WRAPPER",
    "WRITE",
    // (R)
    "X509",
    "XA",
    "XID",
    "XML",
    "XOR",
    // (R)
    "YEAR",
    "YEAR_MONTH",
    // (R)
    "ZEROFILL",
    // (R)
    "ZONE"
  ]
}), y2e = wt({
  // https://dev.mysql.com/doc/refman/8.0/en/built-in-function-reference.html
  all: [
    "ABS",
    "ACOS",
    "ADDDATE",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    // 'AND',
    "ANY_VALUE",
    "ASCII",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BENCHMARK",
    "BIN",
    "BIN_TO_UUID",
    "BINARY",
    "BIT_AND",
    "BIT_COUNT",
    "BIT_LENGTH",
    "BIT_OR",
    "BIT_XOR",
    "CAN_ACCESS_COLUMN",
    "CAN_ACCESS_DATABASE",
    "CAN_ACCESS_TABLE",
    "CAN_ACCESS_USER",
    "CAN_ACCESS_VIEW",
    "CAST",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHAR_LENGTH",
    "CHARACTER_LENGTH",
    "CHARSET",
    "COALESCE",
    "COERCIBILITY",
    "COLLATION",
    "COMPRESS",
    "CONCAT",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT",
    "CONVERT_TZ",
    "COS",
    "COT",
    "COUNT",
    "CRC32",
    "CUME_DIST",
    "CURDATE",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURTIME",
    "DATABASE",
    "DATE",
    "DATE_ADD",
    "DATE_FORMAT",
    "DATE_SUB",
    "DATEDIFF",
    "DAY",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DEFAULT",
    "DEGREES",
    "DENSE_RANK",
    "DIV",
    "ELT",
    "EXP",
    "EXPORT_SET",
    "EXTRACT",
    "EXTRACTVALUE",
    "FIELD",
    "FIND_IN_SET",
    "FIRST_VALUE",
    "FLOOR",
    "FORMAT",
    "FORMAT_BYTES",
    "FORMAT_PICO_TIME",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GEOMCOLLECTION",
    "GEOMETRYCOLLECTION",
    "GET_DD_COLUMN_PRIVILEGES",
    "GET_DD_CREATE_OPTIONS",
    "GET_DD_INDEX_SUB_PART_LENGTH",
    "GET_FORMAT",
    "GET_LOCK",
    "GREATEST",
    "GROUP_CONCAT",
    "GROUPING",
    "GTID_SUBSET",
    "GTID_SUBTRACT",
    "HEX",
    "HOUR",
    "ICU_VERSION",
    "IF",
    "IFNULL",
    // 'IN',
    "INET_ATON",
    "INET_NTOA",
    "INET6_ATON",
    "INET6_NTOA",
    "INSERT",
    "INSTR",
    "INTERNAL_AUTO_INCREMENT",
    "INTERNAL_AVG_ROW_LENGTH",
    "INTERNAL_CHECK_TIME",
    "INTERNAL_CHECKSUM",
    "INTERNAL_DATA_FREE",
    "INTERNAL_DATA_LENGTH",
    "INTERNAL_DD_CHAR_LENGTH",
    "INTERNAL_GET_COMMENT_OR_ERROR",
    "INTERNAL_GET_ENABLED_ROLE_JSON",
    "INTERNAL_GET_HOSTNAME",
    "INTERNAL_GET_USERNAME",
    "INTERNAL_GET_VIEW_WARNING_OR_ERROR",
    "INTERNAL_INDEX_COLUMN_CARDINALITY",
    "INTERNAL_INDEX_LENGTH",
    "INTERNAL_IS_ENABLED_ROLE",
    "INTERNAL_IS_MANDATORY_ROLE",
    "INTERNAL_KEYS_DISABLED",
    "INTERNAL_MAX_DATA_LENGTH",
    "INTERNAL_TABLE_ROWS",
    "INTERNAL_UPDATE_TIME",
    "INTERVAL",
    "IS",
    "IS_FREE_LOCK",
    "IS_IPV4",
    "IS_IPV4_COMPAT",
    "IS_IPV4_MAPPED",
    "IS_IPV6",
    "IS NOT",
    "IS NOT NULL",
    "IS NULL",
    "IS_USED_LOCK",
    "IS_UUID",
    "ISNULL",
    "JSON_ARRAY",
    "JSON_ARRAY_APPEND",
    "JSON_ARRAY_INSERT",
    "JSON_ARRAYAGG",
    "JSON_CONTAINS",
    "JSON_CONTAINS_PATH",
    "JSON_DEPTH",
    "JSON_EXTRACT",
    "JSON_INSERT",
    "JSON_KEYS",
    "JSON_LENGTH",
    "JSON_MERGE",
    "JSON_MERGE_PATCH",
    "JSON_MERGE_PRESERVE",
    "JSON_OBJECT",
    "JSON_OBJECTAGG",
    "JSON_OVERLAPS",
    "JSON_PRETTY",
    "JSON_QUOTE",
    "JSON_REMOVE",
    "JSON_REPLACE",
    "JSON_SCHEMA_VALID",
    "JSON_SCHEMA_VALIDATION_REPORT",
    "JSON_SEARCH",
    "JSON_SET",
    "JSON_STORAGE_FREE",
    "JSON_STORAGE_SIZE",
    "JSON_TABLE",
    "JSON_TYPE",
    "JSON_UNQUOTE",
    "JSON_VALID",
    "JSON_VALUE",
    "LAG",
    "LAST_DAY",
    "LAST_INSERT_ID",
    "LAST_VALUE",
    "LCASE",
    "LEAD",
    "LEAST",
    "LEFT",
    "LENGTH",
    "LIKE",
    "LINESTRING",
    "LN",
    "LOAD_FILE",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LOWER",
    "LPAD",
    "LTRIM",
    "MAKE_SET",
    "MAKEDATE",
    "MAKETIME",
    "MASTER_POS_WAIT",
    "MATCH",
    "MAX",
    "MBRCONTAINS",
    "MBRCOVEREDBY",
    "MBRCOVERS",
    "MBRDISJOINT",
    "MBREQUALS",
    "MBRINTERSECTS",
    "MBROVERLAPS",
    "MBRTOUCHES",
    "MBRWITHIN",
    "MD5",
    "MEMBER OF",
    "MICROSECOND",
    "MID",
    "MIN",
    "MINUTE",
    "MOD",
    "MONTH",
    "MONTHNAME",
    "MULTILINESTRING",
    "MULTIPOINT",
    "MULTIPOLYGON",
    "NAME_CONST",
    "NOT",
    "NOT IN",
    "NOT LIKE",
    "NOT REGEXP",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "OCT",
    "OCTET_LENGTH",
    // 'OR',
    "ORD",
    "PERCENT_RANK",
    "PERIOD_ADD",
    "PERIOD_DIFF",
    "PI",
    "POINT",
    "POLYGON",
    "POSITION",
    "POW",
    "POWER",
    "PS_CURRENT_THREAD_ID",
    "PS_THREAD_ID",
    "QUARTER",
    "QUOTE",
    "RADIANS",
    "RAND",
    "RANDOM_BYTES",
    "RANK",
    "REGEXP",
    "REGEXP_INSTR",
    "REGEXP_LIKE",
    "REGEXP_REPLACE",
    "REGEXP_SUBSTR",
    "RELEASE_ALL_LOCKS",
    "RELEASE_LOCK",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RLIKE",
    "ROLES_GRAPHML",
    "ROUND",
    "ROW_COUNT",
    "ROW_NUMBER",
    "RPAD",
    "RTRIM",
    "SCHEMA",
    "SEC_TO_TIME",
    "SECOND",
    "SESSION_USER",
    "SHA1",
    "SHA2",
    "SIGN",
    "SIN",
    "SLEEP",
    "SOUNDEX",
    "SOUNDS LIKE",
    "SOURCE_POS_WAIT",
    "SPACE",
    "SQRT",
    "ST_AREA",
    "ST_ASBINARY",
    "ST_ASGEOJSON",
    "ST_ASTEXT",
    "ST_BUFFER",
    "ST_BUFFER_STRATEGY",
    "ST_CENTROID",
    "ST_COLLECT",
    "ST_CONTAINS",
    "ST_CONVEXHULL",
    "ST_CROSSES",
    "ST_DIFFERENCE",
    "ST_DIMENSION",
    "ST_DISJOINT",
    "ST_DISTANCE",
    "ST_DISTANCE_SPHERE",
    "ST_ENDPOINT",
    "ST_ENVELOPE",
    "ST_EQUALS",
    "ST_EXTERIORRING",
    "ST_FRECHETDISTANCE",
    "ST_GEOHASH",
    "ST_GEOMCOLLFROMTEXT",
    "ST_GEOMCOLLFROMWKB",
    "ST_GEOMETRYN",
    "ST_GEOMETRYTYPE",
    "ST_GEOMFROMGEOJSON",
    "ST_GEOMFROMTEXT",
    "ST_GEOMFROMWKB",
    "ST_HAUSDORFFDISTANCE",
    "ST_INTERIORRINGN",
    "ST_INTERSECTION",
    "ST_INTERSECTS",
    "ST_ISCLOSED",
    "ST_ISEMPTY",
    "ST_ISSIMPLE",
    "ST_ISVALID",
    "ST_LATFROMGEOHASH",
    "ST_LATITUDE",
    "ST_LENGTH",
    "ST_LINEFROMTEXT",
    "ST_LINEFROMWKB",
    "ST_LINEINTERPOLATEPOINT",
    "ST_LINEINTERPOLATEPOINTS",
    "ST_LONGFROMGEOHASH",
    "ST_LONGITUDE",
    "ST_MAKEENVELOPE",
    "ST_MLINEFROMTEXT",
    "ST_MLINEFROMWKB",
    "ST_MPOINTFROMTEXT",
    "ST_MPOINTFROMWKB",
    "ST_MPOLYFROMTEXT",
    "ST_MPOLYFROMWKB",
    "ST_NUMGEOMETRIES",
    "ST_NUMINTERIORRING",
    "ST_NUMPOINTS",
    "ST_OVERLAPS",
    "ST_POINTATDISTANCE",
    "ST_POINTFROMGEOHASH",
    "ST_POINTFROMTEXT",
    "ST_POINTFROMWKB",
    "ST_POINTN",
    "ST_POLYFROMTEXT",
    "ST_POLYFROMWKB",
    "ST_SIMPLIFY",
    "ST_SRID",
    "ST_STARTPOINT",
    "ST_SWAPXY",
    "ST_SYMDIFFERENCE",
    "ST_TOUCHES",
    "ST_TRANSFORM",
    "ST_UNION",
    "ST_VALIDATE",
    "ST_WITHIN",
    "ST_X",
    "ST_Y",
    "STATEMENT_DIGEST",
    "STATEMENT_DIGEST_TEXT",
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DATE",
    "STRCMP",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "SUBTIME",
    "SUM",
    "SYSDATE",
    "SYSTEM_USER",
    "TAN",
    "TIME",
    "TIME_FORMAT",
    "TIME_TO_SEC",
    "TIMEDIFF",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TO_BASE64",
    "TO_DAYS",
    "TO_SECONDS",
    "TRIM",
    "TRUNCATE",
    "UCASE",
    "UNCOMPRESS",
    "UNCOMPRESSED_LENGTH",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "USER",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "UUID",
    "UUID_SHORT",
    "UUID_TO_BIN",
    "VALIDATE_PASSWORD_STRENGTH",
    "VALUES",
    "VAR_POP",
    "VAR_SAMP",
    "VARIANCE",
    "VERSION",
    "WAIT_FOR_EXECUTED_GTID_SET",
    "WAIT_UNTIL_SQL_THREAD_AFTER_GTIDS",
    "WEEK",
    "WEEKDAY",
    "WEEKOFYEAR",
    "WEIGHT_STRING",
    // 'XOR',
    "YEAR",
    "YEARWEEK",
    // Data types with parameters
    // https://dev.mysql.com/doc/refman/8.0/en/data-types.html
    "BIT",
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "DATETIME",
    "TIMESTAMP",
    "TIME",
    "YEAR",
    "CHAR",
    "NATIONAL CHAR",
    "VARCHAR",
    "NATIONAL VARCHAR",
    "BINARY",
    "VARBINARY",
    "BLOB",
    "TEXT",
    "ENUM"
    // 'SET' // handled as special-case in postProcess
  ]
}), R2e = re(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), A2e = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [LOW_PRIORITY | DELAYED | HIGH_PRIORITY] [IGNORE] [INTO]",
  "REPLACE [LOW_PRIORITY | DELAYED] [INTO]",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [SQL SECURITY DEFINER | SQL SECURITY INVOKER] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY] TABLE [IF NOT EXISTS]"
]), zB = re([
  // - update:
  "UPDATE [LOW_PRIORITY] [IGNORE]",
  // - delete:
  "DELETE [LOW_PRIORITY] [QUICK] [IGNORE] FROM",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "{CHANGE | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [TO | AS]",
  "RENAME COLUMN",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://dev.mysql.com/doc/refman/8.0/en/sql-statements.html
  "ALTER DATABASE",
  "ALTER EVENT",
  "ALTER FUNCTION",
  "ALTER INSTANCE",
  "ALTER LOGFILE GROUP",
  "ALTER PROCEDURE",
  "ALTER RESOURCE GROUP",
  "ALTER SERVER",
  "ALTER TABLESPACE",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "BINLOG",
  "CACHE INDEX",
  "CALL",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE EVENT",
  "CREATE FUNCTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE LOGFILE GROUP",
  "CREATE PROCEDURE",
  "CREATE RESOURCE GROUP",
  "CREATE ROLE",
  "CREATE SERVER",
  "CREATE SPATIAL REFERENCE SYSTEM",
  "CREATE TABLESPACE",
  "CREATE TRIGGER",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DROP DATABASE",
  "DROP EVENT",
  "DROP FUNCTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LOGFILE GROUP",
  "DROP PROCEDURE",
  "DROP RESOURCE GROUP",
  "DROP ROLE",
  "DROP SERVER",
  "DROP SPATIAL REFERENCE SYSTEM",
  "DROP TABLESPACE",
  "DROP TRIGGER",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "GRANT",
  "HANDLER",
  "HELP",
  "IMPORT TABLE",
  "INSTALL COMPONENT",
  "INSTALL PLUGIN",
  "KILL",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "RELEASE SAVEPOINT",
  "RENAME TABLE",
  "RENAME USER",
  "REPAIR TABLE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW BINARY LOGS",
  "SHOW BINLOG EVENTS",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE EVENT",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE TRIGGER",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW EVENTS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW TRIGGERS",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP REPLICA",
  "STOP SLAVE",
  "TABLE",
  "UNINSTALL COMPONENT",
  "UNINSTALL PLUGIN",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  // 'IF',
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]), _2e = re(["UNION [ALL | DISTINCT]"]), C2e = re([
  "JOIN",
  "{LEFT | RIGHT} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), I2e = re(["ON {UPDATE | DELETE} [SET NULL]", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), w2e = {
  tokenizerOptions: {
    reservedSelect: R2e,
    reservedClauses: [...A2e, ...zB],
    reservedSetOperations: _2e,
    reservedJoins: C2e,
    reservedPhrases: I2e,
    supportsXor: !0,
    reservedKeywords: T2e,
    reservedFunctionNames: y2e,
    // TODO: support _ char set prefixes such as _utf8, _latin1, _binary, _utf8mb4, etc.
    stringTypes: ['""-qq-bs', {
      quote: "''-qq-bs",
      prefixes: ["N"]
    }, {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_.$]+"
    }, {
      quote: '""-qq-bs',
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "''-qq-bs",
      prefixes: ["@"],
      requirePrefix: !0
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    paramTypes: {
      positional: !0
    },
    lineCommentTypes: ["--", "#"],
    operators: ["%", ":=", "&", "|", "^", "~", "<<", ">>", "<=>", "->", "->>", "&&", "||", "!"],
    postProcess: N2e
  },
  formatOptions: {
    onelineClauses: zB
  }
};
function N2e(r) {
  return r.map((e, t) => {
    const i = r[t + 1] || Uc;
    return Xl.SET(e) && i.text === "(" ? {
      ...e,
      type: ee.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const x2e = wt({
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/functions.html
  all: [
    "ABORT",
    "ABS",
    "ACOS",
    "ADVISOR",
    "ARRAY_AGG",
    "ARRAY_AGG",
    "ARRAY_APPEND",
    "ARRAY_AVG",
    "ARRAY_BINARY_SEARCH",
    "ARRAY_CONCAT",
    "ARRAY_CONTAINS",
    "ARRAY_COUNT",
    "ARRAY_DISTINCT",
    "ARRAY_EXCEPT",
    "ARRAY_FLATTEN",
    "ARRAY_IFNULL",
    "ARRAY_INSERT",
    "ARRAY_INTERSECT",
    "ARRAY_LENGTH",
    "ARRAY_MAX",
    "ARRAY_MIN",
    "ARRAY_MOVE",
    "ARRAY_POSITION",
    "ARRAY_PREPEND",
    "ARRAY_PUT",
    "ARRAY_RANGE",
    "ARRAY_REMOVE",
    "ARRAY_REPEAT",
    "ARRAY_REPLACE",
    "ARRAY_REVERSE",
    "ARRAY_SORT",
    "ARRAY_STAR",
    "ARRAY_SUM",
    "ARRAY_SYMDIFF",
    "ARRAY_SYMDIFF1",
    "ARRAY_SYMDIFFN",
    "ARRAY_UNION",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BASE64",
    "BASE64_DECODE",
    "BASE64_ENCODE",
    "BITAND ",
    "BITCLEAR ",
    "BITNOT ",
    "BITOR ",
    "BITSET ",
    "BITSHIFT ",
    "BITTEST ",
    "BITXOR ",
    "CEIL",
    "CLOCK_LOCAL",
    "CLOCK_MILLIS",
    "CLOCK_STR",
    "CLOCK_TZ",
    "CLOCK_UTC",
    "COALESCE",
    "CONCAT",
    "CONCAT2",
    "CONTAINS",
    "CONTAINS_TOKEN",
    "CONTAINS_TOKEN_LIKE",
    "CONTAINS_TOKEN_REGEXP",
    "COS",
    "COUNT",
    "COUNT",
    "COUNTN",
    "CUME_DIST",
    "CURL",
    "DATE_ADD_MILLIS",
    "DATE_ADD_STR",
    "DATE_DIFF_MILLIS",
    "DATE_DIFF_STR",
    "DATE_FORMAT_STR",
    "DATE_PART_MILLIS",
    "DATE_PART_STR",
    "DATE_RANGE_MILLIS",
    "DATE_RANGE_STR",
    "DATE_TRUNC_MILLIS",
    "DATE_TRUNC_STR",
    "DECODE",
    "DECODE_JSON",
    "DEGREES",
    "DENSE_RANK",
    "DURATION_TO_STR",
    // 'E',
    "ENCODED_SIZE",
    "ENCODE_JSON",
    "EXP",
    "FIRST_VALUE",
    "FLOOR",
    "GREATEST",
    "HAS_TOKEN",
    "IFINF",
    "IFMISSING",
    "IFMISSINGORNULL",
    "IFNAN",
    "IFNANORINF",
    "IFNULL",
    "INITCAP",
    "ISARRAY",
    "ISATOM",
    "ISBITSET",
    "ISBOOLEAN",
    "ISNUMBER",
    "ISOBJECT",
    "ISSTRING",
    "LAG",
    "LAST_VALUE",
    "LEAD",
    "LEAST",
    "LENGTH",
    "LN",
    "LOG",
    "LOWER",
    "LTRIM",
    "MAX",
    "MEAN",
    "MEDIAN",
    "META",
    "MILLIS",
    "MILLIS_TO_LOCAL",
    "MILLIS_TO_STR",
    "MILLIS_TO_TZ",
    "MILLIS_TO_UTC",
    "MILLIS_TO_ZONE_NAME",
    "MIN",
    "MISSINGIF",
    "NANIF",
    "NEGINFIF",
    "NOW_LOCAL",
    "NOW_MILLIS",
    "NOW_STR",
    "NOW_TZ",
    "NOW_UTC",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "NVL",
    "NVL2",
    "OBJECT_ADD",
    "OBJECT_CONCAT",
    "OBJECT_INNER_PAIRS",
    "OBJECT_INNER_VALUES",
    "OBJECT_LENGTH",
    "OBJECT_NAMES",
    "OBJECT_PAIRS",
    "OBJECT_PUT",
    "OBJECT_REMOVE",
    "OBJECT_RENAME",
    "OBJECT_REPLACE",
    "OBJECT_UNWRAP",
    "OBJECT_VALUES",
    "PAIRS",
    "PERCENT_RANK",
    "PI",
    "POLY_LENGTH",
    "POSINFIF",
    "POSITION",
    "POWER",
    "RADIANS",
    "RANDOM",
    "RANK",
    "RATIO_TO_REPORT",
    "REGEXP_CONTAINS",
    "REGEXP_LIKE",
    "REGEXP_MATCHES",
    "REGEXP_POSITION",
    "REGEXP_REPLACE",
    "REGEXP_SPLIT",
    "REGEX_CONTAINS",
    "REGEX_LIKE",
    "REGEX_MATCHES",
    "REGEX_POSITION",
    "REGEX_REPLACE",
    "REGEX_SPLIT",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "ROUND",
    "ROW_NUMBER",
    "RTRIM",
    "SEARCH",
    "SEARCH_META",
    "SEARCH_SCORE",
    "SIGN",
    "SIN",
    "SPLIT",
    "SQRT",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DURATION",
    "STR_TO_MILLIS",
    "STR_TO_TZ",
    "STR_TO_UTC",
    "STR_TO_ZONE_NAME",
    "SUBSTR",
    "SUFFIXES",
    "SUM",
    "TAN",
    "TITLE",
    "TOARRAY",
    "TOATOM",
    "TOBOOLEAN",
    "TOKENS",
    "TOKENS",
    "TONUMBER",
    "TOOBJECT",
    "TOSTRING",
    "TRIM",
    "TRUNC",
    // 'TYPE', // disabled
    "UPPER",
    "UUID",
    "VARIANCE",
    "VARIANCE_POP",
    "VARIANCE_SAMP",
    "VAR_POP",
    "VAR_SAMP",
    "WEEKDAY_MILLIS",
    "WEEKDAY_STR",
    // type casting
    // not implemented in N1QL, but added here now for the sake of tests
    // https://docs.couchbase.com/server/current/analytics/3_query.html#Vs_SQL-92
    "CAST"
  ]
}), P2e = wt({
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  all: ["ADVISE", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "BEGIN", "BETWEEN", "BINARY", "BOOLEAN", "BREAK", "BUCKET", "BUILD", "BY", "CALL", "CASE", "CAST", "CLUSTER", "COLLATE", "COLLECTION", "COMMIT", "COMMITTED", "CONNECT", "CONTINUE", "CORRELATED", "COVER", "CREATE", "CURRENT", "DATABASE", "DATASET", "DATASTORE", "DECLARE", "DECREMENT", "DELETE", "DERIVED", "DESC", "DESCRIBE", "DISTINCT", "DO", "DROP", "EACH", "ELEMENT", "ELSE", "END", "EVERY", "EXCEPT", "EXCLUDE", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FILTER", "FIRST", "FLATTEN", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FROM", "FTS", "FUNCTION", "GOLANG", "GRANT", "GROUP", "GROUPS", "GSI", "HASH", "HAVING", "IF", "ISOLATION", "IGNORE", "ILIKE", "IN", "INCLUDE", "INCREMENT", "INDEX", "INFER", "INLINE", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JAVASCRIPT", "JOIN", "KEY", "KEYS", "KEYSPACE", "KNOWN", "LANGUAGE", "LAST", "LEFT", "LET", "LETTING", "LEVEL", "LIKE", "LIMIT", "LSM", "MAP", "MAPPING", "MATCHED", "MATERIALIZED", "MERGE", "MINUS", "MISSING", "NAMESPACE", "NEST", "NL", "NO", "NOT", "NTH_VALUE", "NULL", "NULLS", "NUMBER", "OBJECT", "OFFSET", "ON", "OPTION", "OPTIONS", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARSE", "PARTITION", "PASSWORD", "PATH", "POOL", "PRECEDING", "PREPARE", "PRIMARY", "PRIVATE", "PRIVILEGE", "PROBE", "PROCEDURE", "PUBLIC", "RANGE", "RAW", "REALM", "REDUCE", "RENAME", "RESPECT", "RETURN", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLLBACK", "ROW", "ROWS", "SATISFIES", "SAVEPOINT", "SCHEMA", "SCOPE", "SELECT", "SELF", "SEMI", "SET", "SHOW", "SOME", "START", "STATISTICS", "STRING", "SYSTEM", "THEN", "TIES", "TO", "TRAN", "TRANSACTION", "TRIGGER", "TRUE", "TRUNCATE", "UNBOUNDED", "UNDER", "UNION", "UNIQUE", "UNKNOWN", "UNNEST", "UNSET", "UPDATE", "UPSERT", "USE", "USER", "USING", "VALIDATE", "VALUE", "VALUED", "VALUES", "VIA", "VIEW", "WHEN", "WHERE", "WHILE", "WINDOW", "WITH", "WITHIN", "WORK", "XOR"]
}), L2e = re(["SELECT [ALL | DISTINCT]"]), D2e = re([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE INTO",
  "WHEN [NOT] MATCHED THEN",
  "UPDATE SET",
  "INSERT",
  // other
  "NEST",
  "UNNEST",
  "RETURNING"
]), ZB = re([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - set schema:
  "SET SCHEMA",
  // https://docs.couchbase.com/server/current/n1ql/n1ql-language-reference/reservedwords.html
  "ADVISE",
  "ALTER INDEX",
  "BEGIN TRANSACTION",
  "BUILD INDEX",
  "COMMIT TRANSACTION",
  "CREATE COLLECTION",
  "CREATE FUNCTION",
  "CREATE INDEX",
  "CREATE PRIMARY INDEX",
  "CREATE SCOPE",
  "DROP COLLECTION",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP PRIMARY INDEX",
  "DROP SCOPE",
  "EXECUTE",
  "EXECUTE FUNCTION",
  "EXPLAIN",
  "GRANT",
  "INFER",
  "PREPARE",
  "REVOKE",
  "ROLLBACK TRANSACTION",
  "SAVEPOINT",
  "SET TRANSACTION",
  "UPDATE STATISTICS",
  "UPSERT",
  // other
  "LET",
  "SET CURRENT SCHEMA",
  "SHOW",
  "USE [PRIMARY] KEYS"
]), M2e = re(["UNION [ALL]", "EXCEPT [ALL]", "INTERSECT [ALL]"]), k2e = re(["JOIN", "{LEFT | RIGHT} [OUTER] JOIN", "INNER JOIN"]), Q2e = re(["{ROWS | RANGE | GROUPS} BETWEEN"]), U2e = {
  tokenizerOptions: {
    reservedSelect: L2e,
    reservedClauses: [...D2e, ...ZB],
    reservedSetOperations: M2e,
    reservedJoins: k2e,
    reservedPhrases: Q2e,
    supportsXor: !0,
    reservedKeywords: P2e,
    reservedFunctionNames: x2e,
    // NOTE: single quotes are actually not supported in N1QL,
    // but we support them anyway as all other SQL dialects do,
    // which simplifies writing tests that are shared between all dialects.
    stringTypes: ['""-bs', "''-bs"],
    identTypes: ["``"],
    extraParens: ["[]", "{}"],
    paramTypes: {
      positional: !0,
      numbered: ["$"],
      named: ["$"]
    },
    lineCommentTypes: ["#", "--"],
    operators: ["%", "==", ":", "||"]
  },
  formatOptions: {
    onelineClauses: ZB
  }
}, $2e = wt({
  // https://docs.oracle.com/cd/B19306_01/appdev.102/b14261/reservewords.htm
  all: [
    // 'A',
    "ADD",
    "AGENT",
    "AGGREGATE",
    "ALL",
    "ALTER",
    "AND",
    "ANY",
    "ARRAY",
    "ARROW",
    "AS",
    "ASC",
    "AT",
    "ATTRIBUTE",
    "AUTHID",
    "AVG",
    "BEGIN",
    "BETWEEN",
    "BFILE_BASE",
    "BINARY",
    "BLOB_BASE",
    "BLOCK",
    "BODY",
    "BOTH",
    "BOUND",
    "BULK",
    "BY",
    "BYTE",
    // 'C',
    "CALL",
    "CALLING",
    "CASCADE",
    "CASE",
    "CHAR",
    "CHAR_BASE",
    "CHARACTER",
    "CHARSET",
    "CHARSETFORM",
    "CHARSETID",
    "CHECK",
    "CLOB_BASE",
    "CLOSE",
    "CLUSTER",
    "CLUSTERS",
    "COLAUTH",
    "COLLECT",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMMITTED",
    "COMPILED",
    "COMPRESS",
    "CONNECT",
    "CONSTANT",
    "CONSTRUCTOR",
    "CONTEXT",
    "CONVERT",
    "COUNT",
    "CRASH",
    "CREATE",
    "CURRENT",
    "CURSOR",
    "CUSTOMDATUM",
    "DANGLING",
    "DATA",
    "DATE",
    "DATE_BASE",
    "DAY",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DEFINE",
    "DELETE",
    "DESC",
    "DETERMINISTIC",
    "DISTINCT",
    "DOUBLE",
    "DROP",
    "DURATION",
    "ELEMENT",
    "ELSE",
    "ELSIF",
    "EMPTY",
    "END",
    "ESCAPE",
    "EXCEPT",
    "EXCEPTION",
    "EXCEPTIONS",
    "EXCLUSIVE",
    "EXECUTE",
    "EXISTS",
    "EXIT",
    "EXTERNAL",
    "FETCH",
    "FINAL",
    "FIXED",
    "FLOAT",
    "FOR",
    "FORALL",
    "FORCE",
    "FORM",
    "FROM",
    "FUNCTION",
    "GENERAL",
    "GOTO",
    "GRANT",
    "GROUP",
    "HASH",
    "HAVING",
    "HEAP",
    "HIDDEN",
    "HOUR",
    "IDENTIFIED",
    "IF",
    "IMMEDIATE",
    "IN",
    "INCLUDING",
    "INDEX",
    "INDEXES",
    "INDICATOR",
    "INDICES",
    "INFINITE",
    "INSERT",
    "INSTANTIABLE",
    "INT",
    "INTERFACE",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "INVALIDATE",
    "IS",
    "ISOLATION",
    "JAVA",
    "LANGUAGE",
    "LARGE",
    "LEADING",
    "LENGTH",
    "LEVEL",
    "LIBRARY",
    "LIKE",
    "LIKE2",
    "LIKE4",
    "LIKEC",
    "LIMIT",
    "LIMITED",
    "LOCAL",
    "LOCK",
    "LONG",
    "LOOP",
    "MAP",
    "MAX",
    "MAXLEN",
    "MEMBER",
    "MERGE",
    "MIN",
    "MINUS",
    "MINUTE",
    "MOD",
    "MODE",
    "MODIFY",
    "MONTH",
    "MULTISET",
    "NAME",
    "NAN",
    "NATIONAL",
    "NATIVE",
    "NCHAR",
    "NEW",
    "NOCOMPRESS",
    "NOCOPY",
    "NOT",
    "NOWAIT",
    "NULL",
    "NUMBER_BASE",
    "OBJECT",
    "OCICOLL",
    "OCIDATE",
    "OCIDATETIME",
    "OCIDURATION",
    "OCIINTERVAL",
    "OCILOBLOCATOR",
    "OCINUMBER",
    "OCIRAW",
    "OCIREF",
    "OCIREFCURSOR",
    "OCIROWID",
    "OCISTRING",
    "OCITYPE",
    "OF",
    "ON",
    "ONLY",
    "OPAQUE",
    "OPEN",
    "OPERATOR",
    "OPTION",
    "OR",
    "ORACLE",
    "ORADATA",
    "ORDER",
    "OVERLAPS",
    "ORGANIZATION",
    "ORLANY",
    "ORLVARY",
    "OTHERS",
    "OUT",
    "OVERRIDING",
    "PACKAGE",
    "PARALLEL_ENABLE",
    "PARAMETER",
    "PARAMETERS",
    "PARTITION",
    "PASCAL",
    "PIPE",
    "PIPELINED",
    "PRAGMA",
    "PRECISION",
    "PRIOR",
    "PRIVATE",
    "PROCEDURE",
    "PUBLIC",
    "RAISE",
    "RANGE",
    "RAW",
    "READ",
    "RECORD",
    "REF",
    "REFERENCE",
    "REM",
    "REMAINDER",
    "RENAME",
    "RESOURCE",
    "RESULT",
    "RETURN",
    "RETURNING",
    "REVERSE",
    "REVOKE",
    "ROLLBACK",
    "ROW",
    "SAMPLE",
    "SAVE",
    "SAVEPOINT",
    "SB1",
    "SB2",
    "SB4",
    "SECOND",
    "SEGMENT",
    "SELECT",
    "SELF",
    "SEPARATE",
    "SEQUENCE",
    "SERIALIZABLE",
    "SET",
    "SHARE",
    "SHORT",
    "SIZE",
    "SIZE_T",
    "SOME",
    "SPARSE",
    "SQL",
    "SQLCODE",
    "SQLDATA",
    "SQLNAME",
    "SQLSTATE",
    "STANDARD",
    "START",
    "STATIC",
    "STDDEV",
    "STORED",
    "STRING",
    "STRUCT",
    "STYLE",
    "SUBMULTISET",
    "SUBPARTITION",
    "SUBSTITUTABLE",
    "SUBTYPE",
    "SUM",
    "SYNONYM",
    "TABAUTH",
    "TABLE",
    "TDO",
    "THE",
    "THEN",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_ABBR",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TIMEZONE_REGION",
    "TO",
    "TRAILING",
    "TRANSAC",
    "TRANSACTIONAL",
    "TRUSTED",
    "TYPE",
    "UB1",
    "UB2",
    "UB4",
    "UNDER",
    "UNION",
    "UNIQUE",
    "UNSIGNED",
    "UNTRUSTED",
    "UPDATE",
    "USE",
    "USING",
    "VALIST",
    "VALUE",
    "VALUES",
    "VARIABLE",
    "VARIANCE",
    "VARRAY",
    "VARYING",
    "VIEW",
    "VIEWS",
    "VOID",
    "WHEN",
    "WHERE",
    "WHILE",
    "WITH",
    "WORK",
    "WRAPPED",
    "WRITE",
    "YEAR",
    "ZONE"
  ]
}), V2e = wt({
  // https://docs.oracle.com/cd/B19306_01/server.102/b14200/functions001.htm
  numeric: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "BITAND", "CEIL", "COS", "COSH", "EXP", "FLOOR", "LN", "LOG", "MOD", "NANVL", "POWER", "REMAINDER", "ROUND", "SIGN", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC", "WIDTH_BUCKET"],
  character: ["CHR", "CONCAT", "INITCAP", "LOWER", "LPAD", "LTRIM", "NLS_INITCAP", "NLS_LOWER", "NLSSORT", "NLS_UPPER", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPLACE", "RPAD", "RTRIM", "SOUNDEX", "SUBSTR", "TRANSLATE", "TREAT", "TRIM", "UPPER", "NLS_CHARSET_DECL_LEN", "NLS_CHARSET_ID", "NLS_CHARSET_NAME", "ASCII", "INSTR", "LENGTH", "REGEXP_INSTR"],
  datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_TIMESTAMP", "DBTIMEZONE", "EXTRACT", "FROM_TZ", "LAST_DAY", "LOCALTIMESTAMP", "MONTHS_BETWEEN", "NEW_TIME", "NEXT_DAY", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "ROUND", "SESSIONTIMEZONE", "SYS_EXTRACT_UTC", "SYSDATE", "SYSTIMESTAMP", "TO_CHAR", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_DSINTERVAL", "TO_YMINTERVAL", "TRUNC", "TZ_OFFSET"],
  comparison: ["GREATEST", "LEAST"],
  conversion: ["ASCIISTR", "BIN_TO_NUM", "CAST", "CHARTOROWID", "COMPOSE", "CONVERT", "DECOMPOSE", "HEXTORAW", "NUMTODSINTERVAL", "NUMTOYMINTERVAL", "RAWTOHEX", "RAWTONHEX", "ROWIDTOCHAR", "ROWIDTONCHAR", "SCN_TO_TIMESTAMP", "TIMESTAMP_TO_SCN", "TO_BINARY_DOUBLE", "TO_BINARY_FLOAT", "TO_CHAR", "TO_CLOB", "TO_DATE", "TO_DSINTERVAL", "TO_LOB", "TO_MULTI_BYTE", "TO_NCHAR", "TO_NCLOB", "TO_NUMBER", "TO_DSINTERVAL", "TO_SINGLE_BYTE", "TO_TIMESTAMP", "TO_TIMESTAMP_TZ", "TO_YMINTERVAL", "TO_YMINTERVAL", "TRANSLATE", "UNISTR"],
  largeObject: ["BFILENAME", "EMPTY_BLOB,", "EMPTY_CLOB"],
  collection: ["CARDINALITY", "COLLECT", "POWERMULTISET", "POWERMULTISET_BY_CARDINALITY", "SET"],
  hierarchical: ["SYS_CONNECT_BY_PATH"],
  dataMining: ["CLUSTER_ID", "CLUSTER_PROBABILITY", "CLUSTER_SET", "FEATURE_ID", "FEATURE_SET", "FEATURE_VALUE", "PREDICTION", "PREDICTION_COST", "PREDICTION_DETAILS", "PREDICTION_PROBABILITY", "PREDICTION_SET"],
  xml: ["APPENDCHILDXML", "DELETEXML", "DEPTH", "EXTRACT", "EXISTSNODE", "EXTRACTVALUE", "INSERTCHILDXML", "INSERTXMLBEFORE", "PATH", "SYS_DBURIGEN", "SYS_XMLAGG", "SYS_XMLGEN", "UPDATEXML", "XMLAGG", "XMLCDATA", "XMLCOLATTVAL", "XMLCOMMENT", "XMLCONCAT", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLQUERY", "XMLROOT", "XMLSEQUENCE", "XMLSERIALIZE", "XMLTABLE", "XMLTRANSFORM"],
  encoding: ["DECODE", "DUMP", "ORA_HASH", "VSIZE"],
  nullRelated: ["COALESCE", "LNNVL", "NULLIF", "NVL", "NVL2"],
  env: ["SYS_CONTEXT", "SYS_GUID", "SYS_TYPEID", "UID", "USER", "USERENV"],
  aggregate: ["AVG", "COLLECT", "CORR", "CORR_S", "CORR_K", "COUNT", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "DENSE_RANK", "FIRST", "GROUP_ID", "GROUPING", "GROUPING_ID", "LAST", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "RANK", "REGR_SLOPE", "REGR_INTERCEPT", "REGR_COUNT", "REGR_R2", "REGR_AVGX", "REGR_AVGY", "REGR_SXX", "REGR_SYY", "REGR_SXY", "STATS_BINOMIAL_TEST", "STATS_CROSSTAB", "STATS_F_TEST", "STATS_KS_TEST", "STATS_MODE", "STATS_MW_TEST", "STATS_ONE_WAY_ANOVA", "STATS_T_TEST_ONE", "STATS_T_TEST_PAIRED", "STATS_T_TEST_INDEP", "STATS_T_TEST_INDEPU", "STATS_WSR_TEST", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "SUM", "VAR_POP", "VAR_SAMP", "VARIANCE"],
  // Windowing functions (minus the ones already listed in aggregates)
  window: ["FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTILE", "RATIO_TO_REPORT", "ROW_NUMBER"],
  objectReference: ["DEREF", "MAKE_REF", "REF", "REFTOHEX", "VALUE"],
  model: ["CV", "ITERATION_NUMBER", "PRESENTNNV", "PRESENTV", "PREVIOUS"],
  // Parameterized data types
  // https://docs.oracle.com/en/database/oracle/oracle-database/19/sqlrf/Data-Types.html
  dataTypes: [
    // Oracle builtin data types
    "VARCHAR2",
    "NVARCHAR2",
    "NUMBER",
    "FLOAT",
    "TIMESTAMP",
    "INTERVAL YEAR",
    "INTERVAL DAY",
    "RAW",
    "UROWID",
    "NCHAR",
    // ANSI Data Types
    "CHARACTER",
    "CHAR",
    "CHARACTER VARYING",
    "CHAR VARYING",
    "NATIONAL CHARACTER",
    "NATIONAL CHAR",
    "NATIONAL CHARACTER VARYING",
    "NATIONAL CHAR VARYING",
    "NCHAR VARYING",
    "NUMERIC",
    "DECIMAL",
    "FLOAT",
    // SQL/DS and DB2 Data Types
    "VARCHAR"
  ]
}), G2e = re(["SELECT [ALL | DISTINCT | UNIQUE]"]), B2e = re([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER [SIBLINGS] BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR UPDATE [OF]",
  // Data manipulation
  // - insert:
  "INSERT [INTO | ALL INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [THEN]",
  "UPDATE SET",
  // Data definition
  "CREATE [OR REPLACE] [NO FORCE | FORCE] [EDITIONING | EDITIONABLE | EDITIONABLE EDITIONING | NONEDITIONABLE] VIEW",
  "CREATE MATERIALIZED VIEW",
  "CREATE [GLOBAL TEMPORARY | PRIVATE TEMPORARY | SHARDED | DUPLICATED | IMMUTABLE BLOCKCHAIN | BLOCKCHAIN | IMMUTABLE] TABLE",
  // other
  "RETURNING"
]), qB = re([
  // - update:
  "UPDATE [ONLY]",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP {COLUMN | UNUSED COLUMNS | COLUMNS CONTINUE}",
  "MODIFY",
  "RENAME TO",
  "RENAME COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA",
  "BEGIN",
  "CONNECT BY",
  "DECLARE",
  "EXCEPT",
  "EXCEPTION",
  "LOOP",
  "START WITH"
]), F2e = re(["UNION [ALL]", "EXCEPT", "INTERSECT"]), X2e = re([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]), Y2e = re(["ON {UPDATE | DELETE} [SET NULL]", "ON COMMIT", "{ROWS | RANGE} BETWEEN"]), H2e = {
  tokenizerOptions: {
    reservedSelect: G2e,
    reservedClauses: [...B2e, ...qB],
    reservedSetOperations: F2e,
    reservedJoins: X2e,
    reservedPhrases: Y2e,
    supportsXor: !0,
    reservedKeywords: $2e,
    reservedFunctionNames: V2e,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["N"]
    }, {
      quote: "q''",
      prefixes: ["N"]
    }],
    // PL/SQL doesn't actually support escaping of quotes in identifiers,
    // but for the sake of simpler testing we'll support this anyway
    // as all other SQL dialects with "identifiers" do.
    identTypes: ['""-qq'],
    identChars: {
      rest: "$#"
    },
    variableTypes: [{
      regex: "&{1,2}[A-Za-z][A-Za-z0-9_$#]*"
    }],
    paramTypes: {
      numbered: [":"],
      named: [":"]
    },
    paramChars: {},
    // Empty object used on purpose to not allow $ and # chars as specified in identChars
    operators: [
      "**",
      ":=",
      "%",
      "~=",
      "^=",
      // '..', // Conflicts with float followed by dot (so "2..3" gets parsed as ["2.", ".", "3"])
      ">>",
      "<<",
      "=>",
      "@",
      "||"
    ],
    postProcess: W2e
  },
  formatOptions: {
    alwaysDenseOperators: ["@"],
    onelineClauses: qB
  }
};
function W2e(r) {
  let e = Uc;
  return r.map((t) => Xl.SET(t) && Xl.BY(e) ? {
    ...t,
    type: ee.RESERVED_KEYWORD
  } : (Aq(t.type) && (e = t), t));
}
const z2e = wt({
  // https://www.postgresql.org/docs/14/functions.html
  //
  // https://www.postgresql.org/docs/14/functions-math.html
  math: ["ABS", "ACOS", "ACOSD", "ACOSH", "ASIN", "ASIND", "ASINH", "ATAN", "ATAN2", "ATAN2D", "ATAND", "ATANH", "CBRT", "CEIL", "CEILING", "COS", "COSD", "COSH", "COT", "COTD", "DEGREES", "DIV", "EXP", "FACTORIAL", "FLOOR", "GCD", "LCM", "LN", "LOG", "LOG10", "MIN_SCALE", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SCALE", "SETSEED", "SIGN", "SIN", "SIND", "SINH", "SQRT", "TAN", "TAND", "TANH", "TRIM_SCALE", "TRUNC", "WIDTH_BUCKET"],
  // https://www.postgresql.org/docs/14/functions-string.html
  string: ["ABS", "ASCII", "BIT_LENGTH", "BTRIM", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHR", "CONCAT", "CONCAT_WS", "FORMAT", "INITCAP", "LEFT", "LENGTH", "LOWER", "LPAD", "LTRIM", "MD5", "NORMALIZE", "OCTET_LENGTH", "OVERLAY", "PARSE_IDENT", "PG_CLIENT_ENCODING", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "QUOTE_NULLABLE", "REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE", "REPEAT", "REPLACE", "REVERSE", "RIGHT", "RPAD", "RTRIM", "SPLIT_PART", "SPRINTF", "STARTS_WITH", "STRING_AGG", "STRING_TO_ARRAY", "STRING_TO_TABLE", "STRPOS", "SUBSTR", "SUBSTRING", "TO_ASCII", "TO_HEX", "TRANSLATE", "TRIM", "UNISTR", "UPPER"],
  // https://www.postgresql.org/docs/14/functions-binarystring.html
  binary: ["BIT_COUNT", "BIT_LENGTH", "BTRIM", "CONVERT", "CONVERT_FROM", "CONVERT_TO", "DECODE", "ENCODE", "GET_BIT", "GET_BYTE", "LENGTH", "LTRIM", "MD5", "OCTET_LENGTH", "OVERLAY", "POSITION", "RTRIM", "SET_BIT", "SET_BYTE", "SHA224", "SHA256", "SHA384", "SHA512", "STRING_AGG", "SUBSTR", "SUBSTRING", "TRIM"],
  // https://www.postgresql.org/docs/14/functions-bitstring.html
  bitstring: ["BIT_COUNT", "BIT_LENGTH", "GET_BIT", "LENGTH", "OCTET_LENGTH", "OVERLAY", "POSITION", "SET_BIT", "SUBSTRING"],
  // https://www.postgresql.org/docs/14/functions-matching.html
  pattern: ["REGEXP_MATCH", "REGEXP_MATCHES", "REGEXP_REPLACE", "REGEXP_SPLIT_TO_ARRAY", "REGEXP_SPLIT_TO_TABLE"],
  // https://www.postgresql.org/docs/14/functions-formatting.html
  datatype: ["TO_CHAR", "TO_DATE", "TO_NUMBER", "TO_TIMESTAMP"],
  // https://www.postgresql.org/docs/14/functions-datetime.html
  datetime: [
    // 'AGE',
    "CLOCK_TIMESTAMP",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "DATE_BIN",
    "DATE_PART",
    "DATE_TRUNC",
    "EXTRACT",
    "ISFINITE",
    "JUSTIFY_DAYS",
    "JUSTIFY_HOURS",
    "JUSTIFY_INTERVAL",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "MAKE_DATE",
    "MAKE_INTERVAL",
    "MAKE_TIME",
    "MAKE_TIMESTAMP",
    "MAKE_TIMESTAMPTZ",
    "NOW",
    "PG_SLEEP",
    "PG_SLEEP_FOR",
    "PG_SLEEP_UNTIL",
    "STATEMENT_TIMESTAMP",
    "TIMEOFDAY",
    "TO_TIMESTAMP",
    "TRANSACTION_TIMESTAMP"
  ],
  // https://www.postgresql.org/docs/14/functions-enum.html
  enum: ["ENUM_FIRST", "ENUM_LAST", "ENUM_RANGE"],
  // https://www.postgresql.org/docs/14/functions-geometry.html
  geometry: ["AREA", "BOUND_BOX", "BOX", "CENTER", "CIRCLE", "DIAGONAL", "DIAMETER", "HEIGHT", "ISCLOSED", "ISOPEN", "LENGTH", "LINE", "LSEG", "NPOINTS", "PATH", "PCLOSE", "POINT", "POLYGON", "POPEN", "RADIUS", "SLOPE", "WIDTH"],
  // https://www.postgresql.org/docs/14/functions-net.html
  network: ["ABBREV", "BROADCAST", "FAMILY", "HOST", "HOSTMASK", "INET_MERGE", "INET_SAME_FAMILY", "MACADDR8_SET7BIT", "MASKLEN", "NETMASK", "NETWORK", "SET_MASKLEN", "TEXT", "TRUNC"],
  // https://www.postgresql.org/docs/14/functions-textsearch.html
  textsearch: ["ARRAY_TO_TSVECTOR", "GET_CURRENT_TS_CONFIG", "JSONB_TO_TSVECTOR", "JSON_TO_TSVECTOR", "LENGTH", "NUMNODE", "PHRASETO_TSQUERY", "PLAINTO_TSQUERY", "QUERYTREE", "SETWEIGHT", "STRIP", "TO_TSQUERY", "TO_TSVECTOR", "TSQUERY_PHRASE", "TSVECTOR_TO_ARRAY", "TS_DEBUG", "TS_DELETE", "TS_FILTER", "TS_HEADLINE", "TS_LEXIZE", "TS_PARSE", "TS_RANK", "TS_RANK_CD", "TS_REWRITE", "TS_STAT", "TS_TOKEN_TYPE", "WEBSEARCH_TO_TSQUERY"],
  // https://www.postgresql.org/docs/14/functions-uuid.html
  uuid: ["UUID"],
  // https://www.postgresql.org/docs/14/functions-xml.html
  xml: ["CURSOR_TO_XML", "CURSOR_TO_XMLSCHEMA", "DATABASE_TO_XML", "DATABASE_TO_XMLSCHEMA", "DATABASE_TO_XML_AND_XMLSCHEMA", "NEXTVAL", "QUERY_TO_XML", "QUERY_TO_XMLSCHEMA", "QUERY_TO_XML_AND_XMLSCHEMA", "SCHEMA_TO_XML", "SCHEMA_TO_XMLSCHEMA", "SCHEMA_TO_XML_AND_XMLSCHEMA", "STRING", "TABLE_TO_XML", "TABLE_TO_XMLSCHEMA", "TABLE_TO_XML_AND_XMLSCHEMA", "XMLAGG", "XMLCOMMENT", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", "XMLFOREST", "XMLPARSE", "XMLPI", "XMLROOT", "XMLSERIALIZE", "XMLTABLE", "XML_IS_WELL_FORMED", "XML_IS_WELL_FORMED_CONTENT", "XML_IS_WELL_FORMED_DOCUMENT", "XPATH", "XPATH_EXISTS"],
  // https://www.postgresql.org/docs/14/functions-json.html
  json: ["ARRAY_TO_JSON", "JSONB_AGG", "JSONB_ARRAY_ELEMENTS", "JSONB_ARRAY_ELEMENTS_TEXT", "JSONB_ARRAY_LENGTH", "JSONB_BUILD_ARRAY", "JSONB_BUILD_OBJECT", "JSONB_EACH", "JSONB_EACH_TEXT", "JSONB_EXTRACT_PATH", "JSONB_EXTRACT_PATH_TEXT", "JSONB_INSERT", "JSONB_OBJECT", "JSONB_OBJECT_AGG", "JSONB_OBJECT_KEYS", "JSONB_PATH_EXISTS", "JSONB_PATH_EXISTS_TZ", "JSONB_PATH_MATCH", "JSONB_PATH_MATCH_TZ", "JSONB_PATH_QUERY", "JSONB_PATH_QUERY_ARRAY", "JSONB_PATH_QUERY_ARRAY_TZ", "JSONB_PATH_QUERY_FIRST", "JSONB_PATH_QUERY_FIRST_TZ", "JSONB_PATH_QUERY_TZ", "JSONB_POPULATE_RECORD", "JSONB_POPULATE_RECORDSET", "JSONB_PRETTY", "JSONB_SET", "JSONB_SET_LAX", "JSONB_STRIP_NULLS", "JSONB_TO_RECORD", "JSONB_TO_RECORDSET", "JSONB_TYPEOF", "JSON_AGG", "JSON_ARRAY_ELEMENTS", "JSON_ARRAY_ELEMENTS_TEXT", "JSON_ARRAY_LENGTH", "JSON_BUILD_ARRAY", "JSON_BUILD_OBJECT", "JSON_EACH", "JSON_EACH_TEXT", "JSON_EXTRACT_PATH", "JSON_EXTRACT_PATH_TEXT", "JSON_OBJECT", "JSON_OBJECT_AGG", "JSON_OBJECT_KEYS", "JSON_POPULATE_RECORD", "JSON_POPULATE_RECORDSET", "JSON_STRIP_NULLS", "JSON_TO_RECORD", "JSON_TO_RECORDSET", "JSON_TYPEOF", "ROW_TO_JSON", "TO_JSON", "TO_JSONB", "TO_TIMESTAMP"],
  // https://www.postgresql.org/docs/14/functions-sequence.html
  sequence: ["CURRVAL", "LASTVAL", "NEXTVAL", "SETVAL"],
  // https://www.postgresql.org/docs/14/functions-conditional.html
  conditional: [
    // 'CASE',
    "COALESCE",
    "GREATEST",
    "LEAST",
    "NULLIF"
  ],
  // https://www.postgresql.org/docs/14/functions-array.html
  array: ["ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_DIMS", "ARRAY_FILL", "ARRAY_LENGTH", "ARRAY_LOWER", "ARRAY_NDIMS", "ARRAY_POSITION", "ARRAY_POSITIONS", "ARRAY_PREPEND", "ARRAY_REMOVE", "ARRAY_REPLACE", "ARRAY_TO_STRING", "ARRAY_UPPER", "CARDINALITY", "STRING_TO_ARRAY", "TRIM_ARRAY", "UNNEST"],
  // https://www.postgresql.org/docs/14/functions-range.html
  range: ["ISEMPTY", "LOWER", "LOWER_INC", "LOWER_INF", "MULTIRANGE", "RANGE_MERGE", "UPPER", "UPPER_INC", "UPPER_INF"],
  // https://www.postgresql.org/docs/14/functions-aggregate.html
  aggregate: [
    // 'ANY',
    "ARRAY_AGG",
    "AVG",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "BOOL_AND",
    "BOOL_OR",
    "COALESCE",
    "CORR",
    "COUNT",
    "COVAR_POP",
    "COVAR_SAMP",
    "CUME_DIST",
    "DENSE_RANK",
    "EVERY",
    "GROUPING",
    "JSONB_AGG",
    "JSONB_OBJECT_AGG",
    "JSON_AGG",
    "JSON_OBJECT_AGG",
    "MAX",
    "MIN",
    "MODE",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "PERCENT_RANK",
    "RANGE_AGG",
    "RANGE_INTERSECT_AGG",
    "RANK",
    "REGR_AVGX",
    "REGR_AVGY",
    "REGR_COUNT",
    "REGR_INTERCEPT",
    "REGR_R2",
    "REGR_SLOPE",
    "REGR_SXX",
    "REGR_SXY",
    "REGR_SYY",
    // 'SOME',
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STRING_AGG",
    "SUM",
    "TO_JSON",
    "TO_JSONB",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "XMLAGG"
  ],
  // https://www.postgresql.org/docs/14/functions-window.html
  window: ["CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
  // https://www.postgresql.org/docs/14/functions-srf.html
  set: ["GENERATE_SERIES", "GENERATE_SUBSCRIPTS"],
  // https://www.postgresql.org/docs/14/functions-info.html
  sysInfo: ["ACLDEFAULT", "ACLEXPLODE", "COL_DESCRIPTION", "CURRENT_CATALOG", "CURRENT_DATABASE", "CURRENT_QUERY", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "FORMAT_TYPE", "HAS_ANY_COLUMN_PRIVILEGE", "HAS_COLUMN_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_FOREIGN_DATA_WRAPPER_PRIVILEGE", "HAS_FUNCTION_PRIVILEGE", "HAS_LANGUAGE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_SEQUENCE_PRIVILEGE", "HAS_SERVER_PRIVILEGE", "HAS_TABLESPACE_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "HAS_TYPE_PRIVILEGE", "INET_CLIENT_ADDR", "INET_CLIENT_PORT", "INET_SERVER_ADDR", "INET_SERVER_PORT", "MAKEACLITEM", "OBJ_DESCRIPTION", "PG_BACKEND_PID", "PG_BLOCKING_PIDS", "PG_COLLATION_IS_VISIBLE", "PG_CONF_LOAD_TIME", "PG_CONTROL_CHECKPOINT", "PG_CONTROL_INIT", "PG_CONTROL_SYSTEM", "PG_CONVERSION_IS_VISIBLE", "PG_CURRENT_LOGFILE", "PG_CURRENT_SNAPSHOT", "PG_CURRENT_XACT_ID", "PG_CURRENT_XACT_ID_IF_ASSIGNED", "PG_DESCRIBE_OBJECT", "PG_FUNCTION_IS_VISIBLE", "PG_GET_CATALOG_FOREIGN_KEYS", "PG_GET_CONSTRAINTDEF", "PG_GET_EXPR", "PG_GET_FUNCTIONDEF", "PG_GET_FUNCTION_ARGUMENTS", "PG_GET_FUNCTION_IDENTITY_ARGUMENTS", "PG_GET_FUNCTION_RESULT", "PG_GET_INDEXDEF", "PG_GET_KEYWORDS", "PG_GET_OBJECT_ADDRESS", "PG_GET_OWNED_SEQUENCE", "PG_GET_RULEDEF", "PG_GET_SERIAL_SEQUENCE", "PG_GET_STATISTICSOBJDEF", "PG_GET_TRIGGERDEF", "PG_GET_USERBYID", "PG_GET_VIEWDEF", "PG_HAS_ROLE", "PG_IDENTIFY_OBJECT", "PG_IDENTIFY_OBJECT_AS_ADDRESS", "PG_INDEXAM_HAS_PROPERTY", "PG_INDEX_COLUMN_HAS_PROPERTY", "PG_INDEX_HAS_PROPERTY", "PG_IS_OTHER_TEMP_SCHEMA", "PG_JIT_AVAILABLE", "PG_LAST_COMMITTED_XACT", "PG_LISTENING_CHANNELS", "PG_MY_TEMP_SCHEMA", "PG_NOTIFICATION_QUEUE_USAGE", "PG_OPCLASS_IS_VISIBLE", "PG_OPERATOR_IS_VISIBLE", "PG_OPFAMILY_IS_VISIBLE", "PG_OPTIONS_TO_TABLE", "PG_POSTMASTER_START_TIME", "PG_SAFE_SNAPSHOT_BLOCKING_PIDS", "PG_SNAPSHOT_XIP", "PG_SNAPSHOT_XMAX", "PG_SNAPSHOT_XMIN", "PG_STATISTICS_OBJ_IS_VISIBLE", "PG_TABLESPACE_DATABASES", "PG_TABLESPACE_LOCATION", "PG_TABLE_IS_VISIBLE", "PG_TRIGGER_DEPTH", "PG_TS_CONFIG_IS_VISIBLE", "PG_TS_DICT_IS_VISIBLE", "PG_TS_PARSER_IS_VISIBLE", "PG_TS_TEMPLATE_IS_VISIBLE", "PG_TYPEOF", "PG_TYPE_IS_VISIBLE", "PG_VISIBLE_IN_SNAPSHOT", "PG_XACT_COMMIT_TIMESTAMP", "PG_XACT_COMMIT_TIMESTAMP_ORIGIN", "PG_XACT_STATUS", "PQSERVERVERSION", "ROW_SECURITY_ACTIVE", "SESSION_USER", "SHOBJ_DESCRIPTION", "TO_REGCLASS", "TO_REGCOLLATION", "TO_REGNAMESPACE", "TO_REGOPER", "TO_REGOPERATOR", "TO_REGPROC", "TO_REGPROCEDURE", "TO_REGROLE", "TO_REGTYPE", "TXID_CURRENT", "TXID_CURRENT_IF_ASSIGNED", "TXID_CURRENT_SNAPSHOT", "TXID_SNAPSHOT_XIP", "TXID_SNAPSHOT_XMAX", "TXID_SNAPSHOT_XMIN", "TXID_STATUS", "TXID_VISIBLE_IN_SNAPSHOT", "USER", "VERSION"],
  // https://www.postgresql.org/docs/14/functions-admin.html
  sysAdmin: ["BRIN_DESUMMARIZE_RANGE", "BRIN_SUMMARIZE_NEW_VALUES", "BRIN_SUMMARIZE_RANGE", "CONVERT_FROM", "CURRENT_SETTING", "GIN_CLEAN_PENDING_LIST", "PG_ADVISORY_LOCK", "PG_ADVISORY_LOCK_SHARED", "PG_ADVISORY_UNLOCK", "PG_ADVISORY_UNLOCK_ALL", "PG_ADVISORY_UNLOCK_SHARED", "PG_ADVISORY_XACT_LOCK", "PG_ADVISORY_XACT_LOCK_SHARED", "PG_BACKUP_START_TIME", "PG_CANCEL_BACKEND", "PG_COLLATION_ACTUAL_VERSION", "PG_COLUMN_COMPRESSION", "PG_COLUMN_SIZE", "PG_COPY_LOGICAL_REPLICATION_SLOT", "PG_COPY_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_LOGICAL_REPLICATION_SLOT", "PG_CREATE_PHYSICAL_REPLICATION_SLOT", "PG_CREATE_RESTORE_POINT", "PG_CURRENT_WAL_FLUSH_LSN", "PG_CURRENT_WAL_INSERT_LSN", "PG_CURRENT_WAL_LSN", "PG_DATABASE_SIZE", "PG_DROP_REPLICATION_SLOT", "PG_EXPORT_SNAPSHOT", "PG_FILENODE_RELATION", "PG_GET_WAL_REPLAY_PAUSE_STATE", "PG_IMPORT_SYSTEM_COLLATIONS", "PG_INDEXES_SIZE", "PG_IS_IN_BACKUP", "PG_IS_IN_RECOVERY", "PG_IS_WAL_REPLAY_PAUSED", "PG_LAST_WAL_RECEIVE_LSN", "PG_LAST_WAL_REPLAY_LSN", "PG_LAST_XACT_REPLAY_TIMESTAMP", "PG_LOGICAL_EMIT_MESSAGE", "PG_LOGICAL_SLOT_GET_BINARY_CHANGES", "PG_LOGICAL_SLOT_GET_CHANGES", "PG_LOGICAL_SLOT_PEEK_BINARY_CHANGES", "PG_LOGICAL_SLOT_PEEK_CHANGES", "PG_LOG_BACKEND_MEMORY_CONTEXTS", "PG_LS_ARCHIVE_STATUSDIR", "PG_LS_DIR", "PG_LS_LOGDIR", "PG_LS_TMPDIR", "PG_LS_WALDIR", "PG_PARTITION_ANCESTORS", "PG_PARTITION_ROOT", "PG_PARTITION_TREE", "PG_PROMOTE", "PG_READ_BINARY_FILE", "PG_READ_FILE", "PG_RELATION_FILENODE", "PG_RELATION_FILEPATH", "PG_RELATION_SIZE", "PG_RELOAD_CONF", "PG_REPLICATION_ORIGIN_ADVANCE", "PG_REPLICATION_ORIGIN_CREATE", "PG_REPLICATION_ORIGIN_DROP", "PG_REPLICATION_ORIGIN_OID", "PG_REPLICATION_ORIGIN_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_IS_SETUP", "PG_REPLICATION_ORIGIN_SESSION_PROGRESS", "PG_REPLICATION_ORIGIN_SESSION_RESET", "PG_REPLICATION_ORIGIN_SESSION_SETUP", "PG_REPLICATION_ORIGIN_XACT_RESET", "PG_REPLICATION_ORIGIN_XACT_SETUP", "PG_REPLICATION_SLOT_ADVANCE", "PG_ROTATE_LOGFILE", "PG_SIZE_BYTES", "PG_SIZE_PRETTY", "PG_START_BACKUP", "PG_STAT_FILE", "PG_STOP_BACKUP", "PG_SWITCH_WAL", "PG_TABLESPACE_SIZE", "PG_TABLE_SIZE", "PG_TERMINATE_BACKEND", "PG_TOTAL_RELATION_SIZE", "PG_TRY_ADVISORY_LOCK", "PG_TRY_ADVISORY_LOCK_SHARED", "PG_TRY_ADVISORY_XACT_LOCK", "PG_TRY_ADVISORY_XACT_LOCK_SHARED", "PG_WALFILE_NAME", "PG_WALFILE_NAME_OFFSET", "PG_WAL_LSN_DIFF", "PG_WAL_REPLAY_PAUSE", "PG_WAL_REPLAY_RESUME", "SET_CONFIG"],
  // https://www.postgresql.org/docs/14/functions-trigger.html
  trigger: ["SUPPRESS_REDUNDANT_UPDATES_TRIGGER", "TSVECTOR_UPDATE_TRIGGER", "TSVECTOR_UPDATE_TRIGGER_COLUMN"],
  // https://www.postgresql.org/docs/14/functions-event-triggers.html
  eventTrigger: ["PG_EVENT_TRIGGER_DDL_COMMANDS", "PG_EVENT_TRIGGER_DROPPED_OBJECTS", "PG_EVENT_TRIGGER_TABLE_REWRITE_OID", "PG_EVENT_TRIGGER_TABLE_REWRITE_REASON", "PG_GET_OBJECT_ADDRESS"],
  // https://www.postgresql.org/docs/14/functions-statistics.html
  stats: ["PG_MCV_LIST_ITEMS"],
  cast: ["CAST"],
  // Parameterized data types
  // https://www.postgresql.org/docs/current/datatype.html
  dataTypes: ["BIT", "BIT VARYING", "CHARACTER", "CHARACTER VARYING", "VARCHAR", "CHAR", "DECIMAL", "NUMERIC", "TIME", "TIMESTAMP", "ENUM"]
}), Z2e = wt({
  // https://www.postgresql.org/docs/14/sql-keywords-appendix.html
  all: [
    "ABORT",
    "ABSOLUTE",
    "ACCESS",
    "ACTION",
    "ADD",
    "ADMIN",
    "AFTER",
    "AGGREGATE",
    "ALL",
    // reserved
    "ALSO",
    "ALTER",
    "ALWAYS",
    "ANALYSE",
    // reserved
    "ANALYZE",
    // reserved
    "AND",
    // reserved
    "ANY",
    // reserved
    "ARRAY",
    // reserved, requires AS
    "AS",
    // reserved, requires AS
    "ASC",
    // reserved
    "ASENSITIVE",
    "ASSERTION",
    "ASSIGNMENT",
    "ASYMMETRIC",
    // reserved
    "AT",
    "ATOMIC",
    "ATTACH",
    "ATTRIBUTE",
    "AUTHORIZATION",
    // reserved (can be function or type)
    "BACKWARD",
    "BEFORE",
    "BEGIN",
    "BETWEEN",
    // (cannot be function or type)
    "BIGINT",
    // (cannot be function or type)
    "BINARY",
    // reserved (can be function or type)
    "BIT",
    // (cannot be function or type)
    "BOOLEAN",
    // (cannot be function or type)
    "BOTH",
    // reserved
    "BREADTH",
    "BY",
    "CACHE",
    "CALL",
    "CALLED",
    "CASCADE",
    "CASCADED",
    "CASE",
    // reserved
    "CAST",
    // reserved
    "CATALOG",
    "CHAIN",
    "CHAR",
    // (cannot be function or type), requires AS
    "CHARACTER",
    // (cannot be function or type), requires AS
    "CHARACTERISTICS",
    "CHECK",
    // reserved
    "CHECKPOINT",
    "CLASS",
    "CLOSE",
    "CLUSTER",
    "COALESCE",
    // (cannot be function or type)
    "COLLATE",
    // reserved
    "COLLATION",
    // reserved (can be function or type)
    "COLUMN",
    // reserved
    "COLUMNS",
    "COMMENT",
    "COMMENTS",
    "COMMIT",
    "COMMITTED",
    "COMPRESSION",
    "CONCURRENTLY",
    // reserved (can be function or type)
    "CONFIGURATION",
    "CONFLICT",
    "CONNECTION",
    "CONSTRAINT",
    // reserved
    "CONSTRAINTS",
    "CONTENT",
    "CONTINUE",
    "CONVERSION",
    "COPY",
    "COST",
    "CREATE",
    // reserved, requires AS
    "CROSS",
    // reserved (can be function or type)
    "CSV",
    "CUBE",
    "CURRENT",
    "CURRENT_CATALOG",
    // reserved
    "CURRENT_DATE",
    // reserved
    "CURRENT_ROLE",
    // reserved
    "CURRENT_SCHEMA",
    // reserved (can be function or type)
    "CURRENT_TIME",
    // reserved
    "CURRENT_TIMESTAMP",
    // reserved
    "CURRENT_USER",
    // reserved
    "CURSOR",
    "CYCLE",
    "DATA",
    "DATABASE",
    "DAY",
    // requires AS
    "DEALLOCATE",
    "DEC",
    // (cannot be function or type)
    "DECIMAL",
    // (cannot be function or type)
    "DECLARE",
    "DEFAULT",
    // reserved
    "DEFAULTS",
    "DEFERRABLE",
    // reserved
    "DEFERRED",
    "DEFINER",
    "DELETE",
    "DELIMITER",
    "DELIMITERS",
    "DEPENDS",
    "DEPTH",
    "DESC",
    // reserved
    "DETACH",
    "DICTIONARY",
    "DISABLE",
    "DISCARD",
    "DISTINCT",
    // reserved
    "DO",
    // reserved
    "DOCUMENT",
    "DOMAIN",
    "DOUBLE",
    "DROP",
    "EACH",
    "ELSE",
    // reserved
    "ENABLE",
    "ENCODING",
    "ENCRYPTED",
    "END",
    // reserved
    "ENUM",
    "ESCAPE",
    "EVENT",
    "EXCEPT",
    // reserved, requires AS
    "EXCLUDE",
    "EXCLUDING",
    "EXCLUSIVE",
    "EXECUTE",
    "EXISTS",
    // (cannot be function or type)
    "EXPLAIN",
    "EXPRESSION",
    "EXTENSION",
    "EXTERNAL",
    "EXTRACT",
    // (cannot be function or type)
    "FALSE",
    // reserved
    "FAMILY",
    "FETCH",
    // reserved, requires AS
    "FILTER",
    // requires AS
    "FINALIZE",
    "FIRST",
    "FLOAT",
    // (cannot be function or type)
    "FOLLOWING",
    "FOR",
    // reserved, requires AS
    "FORCE",
    "FOREIGN",
    // reserved
    "FORWARD",
    "FREEZE",
    // reserved (can be function or type)
    "FROM",
    // reserved, requires AS
    "FULL",
    // reserved (can be function or type)
    "FUNCTION",
    "FUNCTIONS",
    "GENERATED",
    "GLOBAL",
    "GRANT",
    // reserved, requires AS
    "GRANTED",
    "GREATEST",
    // (cannot be function or type)
    "GROUP",
    // reserved, requires AS
    "GROUPING",
    // (cannot be function or type)
    "GROUPS",
    "HANDLER",
    "HAVING",
    // reserved, requires AS
    "HEADER",
    "HOLD",
    "HOUR",
    // requires AS
    "IDENTITY",
    "IF",
    "ILIKE",
    // reserved (can be function or type)
    "IMMEDIATE",
    "IMMUTABLE",
    "IMPLICIT",
    "IMPORT",
    "IN",
    // reserved
    "INCLUDE",
    "INCLUDING",
    "INCREMENT",
    "INDEX",
    "INDEXES",
    "INHERIT",
    "INHERITS",
    "INITIALLY",
    // reserved
    "INLINE",
    "INNER",
    // reserved (can be function or type)
    "INOUT",
    // (cannot be function or type)
    "INPUT",
    "INSENSITIVE",
    "INSERT",
    "INSTEAD",
    "INT",
    // (cannot be function or type)
    "INTEGER",
    // (cannot be function or type)
    "INTERSECT",
    // reserved, requires AS
    "INTERVAL",
    // (cannot be function or type)
    "INTO",
    // reserved, requires AS
    "INVOKER",
    "IS",
    // reserved (can be function or type)
    "ISNULL",
    // reserved (can be function or type), requires AS
    "ISOLATION",
    "JOIN",
    // reserved (can be function or type)
    "KEY",
    "LABEL",
    "LANGUAGE",
    "LARGE",
    "LAST",
    "LATERAL",
    // reserved
    "LEADING",
    // reserved
    "LEAKPROOF",
    "LEAST",
    // (cannot be function or type)
    "LEFT",
    // reserved (can be function or type)
    "LEVEL",
    "LIKE",
    // reserved (can be function or type)
    "LIMIT",
    // reserved, requires AS
    "LISTEN",
    "LOAD",
    "LOCAL",
    "LOCALTIME",
    // reserved
    "LOCALTIMESTAMP",
    // reserved
    "LOCATION",
    "LOCK",
    "LOCKED",
    "LOGGED",
    "MAPPING",
    "MATCH",
    "MATERIALIZED",
    "MAXVALUE",
    "METHOD",
    "MINUTE",
    // requires AS
    "MINVALUE",
    "MODE",
    "MONTH",
    // requires AS
    "MOVE",
    "NAME",
    "NAMES",
    "NATIONAL",
    // (cannot be function or type)
    "NATURAL",
    // reserved (can be function or type)
    "NCHAR",
    // (cannot be function or type)
    "NEW",
    "NEXT",
    "NFC",
    "NFD",
    "NFKC",
    "NFKD",
    "NO",
    "NONE",
    // (cannot be function or type)
    "NORMALIZE",
    // (cannot be function or type)
    "NORMALIZED",
    "NOT",
    // reserved
    "NOTHING",
    "NOTIFY",
    "NOTNULL",
    // reserved (can be function or type), requires AS
    "NOWAIT",
    "NULL",
    // reserved
    "NULLIF",
    // (cannot be function or type)
    "NULLS",
    "NUMERIC",
    // (cannot be function or type)
    "OBJECT",
    "OF",
    "OFF",
    "OFFSET",
    // reserved, requires AS
    "OIDS",
    "OLD",
    "ON",
    // reserved, requires AS
    "ONLY",
    // reserved
    "OPERATOR",
    "OPTION",
    "OPTIONS",
    "OR",
    // reserved
    "ORDER",
    // reserved, requires AS
    "ORDINALITY",
    "OTHERS",
    "OUT",
    // (cannot be function or type)
    "OUTER",
    // reserved (can be function or type)
    "OVER",
    // requires AS
    "OVERLAPS",
    // reserved (can be function or type), requires AS
    "OVERLAY",
    // (cannot be function or type)
    "OVERRIDING",
    "OWNED",
    "OWNER",
    "PARALLEL",
    "PARSER",
    "PARTIAL",
    "PARTITION",
    "PASSING",
    "PASSWORD",
    "PLACING",
    // reserved
    "PLANS",
    "POLICY",
    "POSITION",
    // (cannot be function or type)
    "PRECEDING",
    "PRECISION",
    // (cannot be function or type), requires AS
    "PREPARE",
    "PREPARED",
    "PRESERVE",
    "PRIMARY",
    // reserved
    "PRIOR",
    "PRIVILEGES",
    "PROCEDURAL",
    "PROCEDURE",
    "PROCEDURES",
    "PROGRAM",
    "PUBLICATION",
    "QUOTE",
    "RANGE",
    "READ",
    "REAL",
    // (cannot be function or type)
    "REASSIGN",
    "RECHECK",
    "RECURSIVE",
    "REF",
    "REFERENCES",
    // reserved
    "REFERENCING",
    "REFRESH",
    "REINDEX",
    "RELATIVE",
    "RELEASE",
    "RENAME",
    "REPEATABLE",
    "REPLACE",
    "REPLICA",
    "RESET",
    "RESTART",
    "RESTRICT",
    "RETURN",
    "RETURNING",
    // reserved, requires AS
    "RETURNS",
    "REVOKE",
    "RIGHT",
    // reserved (can be function or type)
    "ROLE",
    "ROLLBACK",
    "ROLLUP",
    "ROUTINE",
    "ROUTINES",
    "ROW",
    // (cannot be function or type)
    "ROWS",
    "RULE",
    "SAVEPOINT",
    "SCHEMA",
    "SCHEMAS",
    "SCROLL",
    "SEARCH",
    "SECOND",
    // requires AS
    "SECURITY",
    "SELECT",
    // reserved
    "SEQUENCE",
    "SEQUENCES",
    "SERIALIZABLE",
    "SERVER",
    "SESSION",
    "SESSION_USER",
    // reserved
    "SET",
    "SETOF",
    // (cannot be function or type)
    "SETS",
    "SHARE",
    "SHOW",
    "SIMILAR",
    // reserved (can be function or type)
    "SIMPLE",
    "SKIP",
    "SMALLINT",
    // (cannot be function or type)
    "SNAPSHOT",
    "SOME",
    // reserved
    "SQL",
    "STABLE",
    "STANDALONE",
    "START",
    "STATEMENT",
    "STATISTICS",
    "STDIN",
    "STDOUT",
    "STORAGE",
    "STORED",
    "STRICT",
    "STRIP",
    "SUBSCRIPTION",
    "SUBSTRING",
    // (cannot be function or type)
    "SUPPORT",
    "SYMMETRIC",
    // reserved
    "SYSID",
    "SYSTEM",
    "TABLE",
    // reserved
    "TABLES",
    "TABLESAMPLE",
    // reserved (can be function or type)
    "TABLESPACE",
    "TEMP",
    "TEMPLATE",
    "TEMPORARY",
    "TEXT",
    "THEN",
    // reserved
    "TIES",
    "TIME",
    // (cannot be function or type)
    "TIMESTAMP",
    // (cannot be function or type)
    "TO",
    // reserved, requires AS
    "TRAILING",
    // reserved
    "TRANSACTION",
    "TRANSFORM",
    "TREAT",
    // (cannot be function or type)
    "TRIGGER",
    "TRIM",
    // (cannot be function or type)
    "TRUE",
    // reserved
    "TRUNCATE",
    "TRUSTED",
    "TYPE",
    "TYPES",
    "UESCAPE",
    "UNBOUNDED",
    "UNCOMMITTED",
    "UNENCRYPTED",
    "UNION",
    // reserved, requires AS
    "UNIQUE",
    // reserved
    "UNKNOWN",
    "UNLISTEN",
    "UNLOGGED",
    "UNTIL",
    "UPDATE",
    "USER",
    // reserved
    "USING",
    // reserved
    "VACUUM",
    "VALID",
    "VALIDATE",
    "VALIDATOR",
    "VALUE",
    "VALUES",
    // (cannot be function or type)
    "VARCHAR",
    // (cannot be function or type)
    "VARIADIC",
    // reserved
    "VARYING",
    // requires AS
    "VERBOSE",
    // reserved (can be function or type)
    "VERSION",
    "VIEW",
    "VIEWS",
    "VOLATILE",
    "WHEN",
    // reserved
    "WHERE",
    // reserved, requires AS
    "WHITESPACE",
    "WINDOW",
    // reserved, requires AS
    "WITH",
    // reserved, requires AS
    "WITHIN",
    // requires AS
    "WITHOUT",
    // requires AS
    "WORK",
    "WRAPPER",
    "WRITE",
    "XML",
    "XMLATTRIBUTES",
    // (cannot be function or type)
    "XMLCONCAT",
    // (cannot be function or type)
    "XMLELEMENT",
    // (cannot be function or type)
    "XMLEXISTS",
    // (cannot be function or type)
    "XMLFOREST",
    // (cannot be function or type)
    "XMLNAMESPACES",
    // (cannot be function or type)
    "XMLPARSE",
    // (cannot be function or type)
    "XMLPI",
    // (cannot be function or type)
    "XMLROOT",
    // (cannot be function or type)
    "XMLSERIALIZE",
    // (cannot be function or type)
    "XMLTABLE",
    // (cannot be function or type)
    "YEAR",
    // requires AS
    "YES",
    "ZONE"
  ]
}), q2e = re(["SELECT [ALL | DISTINCT]"]), j2e = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  "FOR {UPDATE | NO KEY UPDATE | SHARE | KEY SHARE} [OF]",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [TEMP | TEMPORARY] [RECURSIVE] VIEW",
  "CREATE MATERIALIZED VIEW [IF NOT EXISTS]",
  "CREATE [GLOBAL | LOCAL] [TEMPORARY | TEMP | UNLOGGED] TABLE [IF NOT EXISTS]",
  // other
  "RETURNING"
]), jB = re([
  // - update:
  "UPDATE [ONLY]",
  "WHERE CURRENT OF",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM [ONLY]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS] [ONLY]",
  "ALTER TABLE ALL IN TABLESPACE",
  "RENAME [COLUMN]",
  "RENAME TO",
  "ADD [COLUMN] [IF NOT EXISTS]",
  "DROP [COLUMN] [IF EXISTS]",
  "ALTER [COLUMN]",
  "[SET DATA] TYPE",
  // for alter column
  "{SET | DROP} DEFAULT",
  // for alter column
  "{SET | DROP} NOT NULL",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE] [ONLY]",
  // other
  "SET SCHEMA",
  "AFTER",
  // https://www.postgresql.org/docs/14/sql-commands.html
  "ABORT",
  "ALTER AGGREGATE",
  "ALTER COLLATION",
  "ALTER CONVERSION",
  "ALTER DATABASE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER DOMAIN",
  "ALTER EVENT TRIGGER",
  "ALTER EXTENSION",
  "ALTER FOREIGN DATA WRAPPER",
  "ALTER FOREIGN TABLE",
  "ALTER FUNCTION",
  "ALTER GROUP",
  "ALTER INDEX",
  "ALTER LANGUAGE",
  "ALTER LARGE OBJECT",
  "ALTER MATERIALIZED VIEW",
  "ALTER OPERATOR",
  "ALTER OPERATOR CLASS",
  "ALTER OPERATOR FAMILY",
  "ALTER POLICY",
  "ALTER PROCEDURE",
  "ALTER PUBLICATION",
  "ALTER ROLE",
  "ALTER ROUTINE",
  "ALTER RULE",
  "ALTER SCHEMA",
  "ALTER SEQUENCE",
  "ALTER SERVER",
  "ALTER STATISTICS",
  "ALTER SUBSCRIPTION",
  "ALTER SYSTEM",
  "ALTER TABLESPACE",
  "ALTER TEXT SEARCH CONFIGURATION",
  "ALTER TEXT SEARCH DICTIONARY",
  "ALTER TEXT SEARCH PARSER",
  "ALTER TEXT SEARCH TEMPLATE",
  "ALTER TRIGGER",
  "ALTER TYPE",
  "ALTER USER",
  "ALTER USER MAPPING",
  "ALTER VIEW",
  "ANALYZE",
  "BEGIN",
  "CALL",
  "CHECKPOINT",
  "CLOSE",
  "CLUSTER",
  "COMMENT",
  "COMMIT",
  "COMMIT PREPARED",
  "COPY",
  "CREATE ACCESS METHOD",
  "CREATE AGGREGATE",
  "CREATE CAST",
  "CREATE COLLATION",
  "CREATE CONVERSION",
  "CREATE DATABASE",
  "CREATE DOMAIN",
  "CREATE EVENT TRIGGER",
  "CREATE EXTENSION",
  "CREATE FOREIGN DATA WRAPPER",
  "CREATE FOREIGN TABLE",
  "CREATE FUNCTION",
  "CREATE GROUP",
  "CREATE INDEX",
  "CREATE LANGUAGE",
  "CREATE OPERATOR",
  "CREATE OPERATOR CLASS",
  "CREATE OPERATOR FAMILY",
  "CREATE POLICY",
  "CREATE PROCEDURE",
  "CREATE PUBLICATION",
  "CREATE ROLE",
  "CREATE RULE",
  "CREATE SCHEMA",
  "CREATE SEQUENCE",
  "CREATE SERVER",
  "CREATE STATISTICS",
  "CREATE SUBSCRIPTION",
  "CREATE TABLESPACE",
  "CREATE TEXT SEARCH CONFIGURATION",
  "CREATE TEXT SEARCH DICTIONARY",
  "CREATE TEXT SEARCH PARSER",
  "CREATE TEXT SEARCH TEMPLATE",
  "CREATE TRANSFORM",
  "CREATE TRIGGER",
  "CREATE TYPE",
  "CREATE USER",
  "CREATE USER MAPPING",
  "DEALLOCATE",
  "DECLARE",
  "DISCARD",
  "DROP ACCESS METHOD",
  "DROP AGGREGATE",
  "DROP CAST",
  "DROP COLLATION",
  "DROP CONVERSION",
  "DROP DATABASE",
  "DROP DOMAIN",
  "DROP EVENT TRIGGER",
  "DROP EXTENSION",
  "DROP FOREIGN DATA WRAPPER",
  "DROP FOREIGN TABLE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP INDEX",
  "DROP LANGUAGE",
  "DROP MATERIALIZED VIEW",
  "DROP OPERATOR",
  "DROP OPERATOR CLASS",
  "DROP OPERATOR FAMILY",
  "DROP OWNED",
  "DROP POLICY",
  "DROP PROCEDURE",
  "DROP PUBLICATION",
  "DROP ROLE",
  "DROP ROUTINE",
  "DROP RULE",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SERVER",
  "DROP STATISTICS",
  "DROP SUBSCRIPTION",
  "DROP TABLESPACE",
  "DROP TEXT SEARCH CONFIGURATION",
  "DROP TEXT SEARCH DICTIONARY",
  "DROP TEXT SEARCH PARSER",
  "DROP TEXT SEARCH TEMPLATE",
  "DROP TRANSFORM",
  "DROP TRIGGER",
  "DROP TYPE",
  "DROP USER",
  "DROP USER MAPPING",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "IMPORT FOREIGN SCHEMA",
  "LISTEN",
  "LOAD",
  "LOCK",
  "MOVE",
  "NOTIFY",
  "PREPARE",
  "PREPARE TRANSACTION",
  "REASSIGN OWNED",
  "REFRESH MATERIALIZED VIEW",
  "REINDEX",
  "RELEASE SAVEPOINT",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK PREPARED",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SECURITY LABEL",
  "SELECT INTO",
  "SET CONSTRAINTS",
  "SET ROLE",
  "SET SESSION AUTHORIZATION",
  "SET TRANSACTION",
  "SHOW",
  "START TRANSACTION",
  "UNLISTEN",
  "VACUUM"
]), K2e = re(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), J2e = re(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), eUe = re([
  "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]",
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // https://www.postgresql.org/docs/current/datatype-datetime.html
  "{TIMESTAMP | TIME} {WITH | WITHOUT} TIME ZONE",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), tUe = {
  tokenizerOptions: {
    reservedSelect: q2e,
    reservedClauses: [...j2e, ...jB],
    reservedSetOperations: K2e,
    reservedJoins: J2e,
    reservedPhrases: eUe,
    reservedKeywords: Z2e,
    reservedFunctionNames: z2e,
    nestedBlockComments: !0,
    extraParens: ["[]"],
    stringTypes: ["$$", {
      quote: "''-qq",
      prefixes: ["U&"]
    }, {
      quote: "''-bs",
      prefixes: ["E"],
      requirePrefix: !0
    }, {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: [{
      quote: '""-qq',
      prefixes: ["U&"]
    }],
    identChars: {
      rest: "$"
    },
    paramTypes: {
      numbered: ["$"]
    },
    operators: [
      // Arithmetic
      "%",
      "^",
      "|/",
      "||/",
      "@",
      // Assignment
      ":=",
      // Bitwise
      "&",
      "|",
      "#",
      "~",
      "<<",
      ">>",
      // Byte comparison
      "~>~",
      "~<~",
      "~>=~",
      "~<=~",
      // Geometric
      "@-@",
      "@@",
      "##",
      "<->",
      "&&",
      "&<",
      "&>",
      "<<|",
      "&<|",
      "|>>",
      "|&>",
      "<^",
      "^>",
      "?#",
      "?-",
      "?|",
      "?-|",
      "?||",
      "@>",
      "<@",
      "~=",
      // JSON
      "?",
      "@?",
      "?&",
      "->",
      "->>",
      "#>",
      "#>>",
      "#-",
      // Named function params
      "=>",
      // Network address
      ">>=",
      "<<=",
      // Pattern matching
      "~~",
      "~~*",
      "!~~",
      "!~~*",
      // POSIX RegExp
      "~",
      "~*",
      "!~",
      "!~*",
      // Range/multirange
      "-|-",
      // String concatenation
      "||",
      // Text search
      "@@@",
      "!!",
      // Trigram/trigraph
      "<%",
      "%>",
      "<<%",
      "%>>",
      "<<->",
      "<->>",
      "<<<->",
      "<->>>",
      // Type cast
      "::"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: jB
  }
}, rUe = wt({
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Aggregate_Functions.html
  aggregate: ["ANY_VALUE", "APPROXIMATE PERCENTILE_DISC", "AVG", "COUNT", "LISTAGG", "MAX", "MEDIAN", "MIN", "PERCENTILE_CONT", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Array_Functions.html
  array: ["array", "array_concat", "array_flatten", "get_array_length", "split_to_array", "subarray"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_bitwise_aggregate_functions.html
  bitwise: ["BIT_AND", "BIT_OR", "BOOL_AND", "BOOL_OR"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_conditional_expressions.html
  conditional: ["COALESCE", "DECODE", "GREATEST", "LEAST", "NVL", "NVL2", "NULLIF"],
  // https://docs.aws.amazon.com/redshift/latest/dg/Date_functions_header.html
  dateTime: ["ADD_MONTHS", "AT TIME ZONE", "CONVERT_TIMEZONE", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATE_CMP", "DATE_CMP_TIMESTAMP", "DATE_CMP_TIMESTAMPTZ", "DATE_PART_YEAR", "DATEADD", "DATEDIFF", "DATE_PART", "DATE_TRUNC", "EXTRACT", "GETDATE", "INTERVAL_CMP", "LAST_DAY", "MONTHS_BETWEEN", "NEXT_DAY", "SYSDATE", "TIMEOFDAY", "TIMESTAMP_CMP", "TIMESTAMP_CMP_DATE", "TIMESTAMP_CMP_TIMESTAMPTZ", "TIMESTAMPTZ_CMP", "TIMESTAMPTZ_CMP_DATE", "TIMESTAMPTZ_CMP_TIMESTAMP", "TIMEZONE", "TO_TIMESTAMP", "TRUNC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/geospatial-functions.html
  spatial: ["AddBBox", "DropBBox", "GeometryType", "ST_AddPoint", "ST_Angle", "ST_Area", "ST_AsBinary", "ST_AsEWKB", "ST_AsEWKT", "ST_AsGeoJSON", "ST_AsText", "ST_Azimuth", "ST_Boundary", "ST_Collect", "ST_Contains", "ST_ContainsProperly", "ST_ConvexHull", "ST_CoveredBy", "ST_Covers", "ST_Crosses", "ST_Dimension", "ST_Disjoint", "ST_Distance", "ST_DistanceSphere", "ST_DWithin", "ST_EndPoint", "ST_Envelope", "ST_Equals", "ST_ExteriorRing", "ST_Force2D", "ST_Force3D", "ST_Force3DM", "ST_Force3DZ", "ST_Force4D", "ST_GeometryN", "ST_GeometryType", "ST_GeomFromEWKB", "ST_GeomFromEWKT", "ST_GeomFromText", "ST_GeomFromWKB", "ST_InteriorRingN", "ST_Intersects", "ST_IsPolygonCCW", "ST_IsPolygonCW", "ST_IsClosed", "ST_IsCollection", "ST_IsEmpty", "ST_IsSimple", "ST_IsValid", "ST_Length", "ST_LengthSphere", "ST_Length2D", "ST_LineFromMultiPoint", "ST_LineInterpolatePoint", "ST_M", "ST_MakeEnvelope", "ST_MakeLine", "ST_MakePoint", "ST_MakePolygon", "ST_MemSize", "ST_MMax", "ST_MMin", "ST_Multi", "ST_NDims", "ST_NPoints", "ST_NRings", "ST_NumGeometries", "ST_NumInteriorRings", "ST_NumPoints", "ST_Perimeter", "ST_Perimeter2D", "ST_Point", "ST_PointN", "ST_Points", "ST_Polygon", "ST_RemovePoint", "ST_Reverse", "ST_SetPoint", "ST_SetSRID", "ST_Simplify", "ST_SRID", "ST_StartPoint", "ST_Touches", "ST_Within", "ST_X", "ST_XMax", "ST_XMin", "ST_Y", "ST_YMax", "ST_YMin", "ST_Z", "ST_ZMax", "ST_ZMin", "SupportsBBox"],
  // https://docs.aws.amazon.com/redshift/latest/dg/hash-functions.html
  hash: ["CHECKSUM", "FUNC_SHA1", "FNV_HASH", "MD5", "SHA", "SHA1", "SHA2"],
  // https://docs.aws.amazon.com/redshift/latest/dg/hyperloglog-functions.html
  hyperLogLog: ["HLL", "HLL_CREATE_SKETCH", "HLL_CARDINALITY", "HLL_COMBINE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/json-functions.html
  json: ["IS_VALID_JSON", "IS_VALID_JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_EXTRACT_ARRAY_ELEMENT_TEXT", "JSON_EXTRACT_PATH_TEXT", "JSON_PARSE", "JSON_SERIALIZE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/Math_functions.html
  math: ["ABS", "ACOS", "ASIN", "ATAN", "ATAN2", "CBRT", "CEILING", "CEIL", "COS", "COT", "DEGREES", "DEXP", "DLOG1", "DLOG10", "EXP", "FLOOR", "LN", "LOG", "MOD", "PI", "POWER", "RADIANS", "RANDOM", "ROUND", "SIN", "SIGN", "SQRT", "TAN", "TO_HEX", "TRUNC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/ml-function.html
  machineLearning: ["EXPLAIN_MODEL"],
  // https://docs.aws.amazon.com/redshift/latest/dg/String_functions_header.html
  string: ["ASCII", "BPCHARCMP", "BTRIM", "BTTEXT_PATTERN_CMP", "CHAR_LENGTH", "CHARACTER_LENGTH", "CHARINDEX", "CHR", "COLLATE", "CONCAT", "CRC32", "DIFFERENCE", "INITCAP", "LEFT", "RIGHT", "LEN", "LENGTH", "LOWER", "LPAD", "RPAD", "LTRIM", "OCTETINDEX", "OCTET_LENGTH", "POSITION", "QUOTE_IDENT", "QUOTE_LITERAL", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REPEAT", "REPLACE", "REPLICATE", "REVERSE", "RTRIM", "SOUNDEX", "SPLIT_PART", "STRPOS", "STRTOL", "SUBSTRING", "TEXTLEN", "TRANSLATE", "TRIM", "UPPER"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Type_Info_Functions.html
  superType: ["decimal_precision", "decimal_scale", "is_array", "is_bigint", "is_boolean", "is_char", "is_decimal", "is_float", "is_integer", "is_object", "is_scalar", "is_smallint", "is_varchar", "json_typeof"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Window_functions.html
  window: ["AVG", "COUNT", "CUME_DIST", "DENSE_RANK", "FIRST_VALUE", "LAST_VALUE", "LAG", "LEAD", "LISTAGG", "MAX", "MEDIAN", "MIN", "NTH_VALUE", "NTILE", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "RANK", "RATIO_TO_REPORT", "ROW_NUMBER", "STDDEV_SAMP", "STDDEV_POP", "SUM", "VAR_SAMP", "VAR_POP"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Data_type_formatting.html
  dataType: ["CAST", "CONVERT", "TO_CHAR", "TO_DATE", "TO_NUMBER", "TEXT_TO_INT_ALT", "TEXT_TO_NUMERIC_ALT"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_administration_functions.html
  sysAdmin: ["CHANGE_QUERY_PRIORITY", "CHANGE_SESSION_PRIORITY", "CHANGE_USER_PRIORITY", "CURRENT_SETTING", "PG_CANCEL_BACKEND", "PG_TERMINATE_BACKEND", "REBOOT_CLUSTER", "SET_CONFIG"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_System_information_functions.html
  sysInfo: ["CURRENT_AWS_ACCOUNT", "CURRENT_DATABASE", "CURRENT_NAMESPACE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_USER", "CURRENT_USER_ID", "HAS_ASSUMEROLE_PRIVILEGE", "HAS_DATABASE_PRIVILEGE", "HAS_SCHEMA_PRIVILEGE", "HAS_TABLE_PRIVILEGE", "PG_BACKEND_PID", "PG_GET_COLS", "PG_GET_GRANTEE_BY_IAM_ROLE", "PG_GET_IAM_ROLE_BY_USER", "PG_GET_LATE_BINDING_VIEW_COLS", "PG_LAST_COPY_COUNT", "PG_LAST_COPY_ID", "PG_LAST_UNLOAD_ID", "PG_LAST_QUERY_ID", "PG_LAST_UNLOAD_COUNT", "SESSION_USER", "SLICE_NUM", "USER", "VERSION"],
  dataTypes: ["DECIMAL", "NUMERIC", "CHAR", "CHARACTER", "VARCHAR", "CHARACTER VARYING", "NCHAR", "NVARCHAR", "VARBYTE"]
}), iUe = wt({
  // https://docs.aws.amazon.com/redshift/latest/dg/r_pg_keywords.html
  standard: ["AES128", "AES256", "ALL", "ALLOWOVERWRITE", "ANY", "ARRAY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BETWEEN", "BINARY", "BOTH", "CHECK", "COLUMN", "CONSTRAINT", "CREATE", "CROSS", "DEFAULT", "DEFERRABLE", "DEFLATE", "DEFRAG", "DESC", "DISABLE", "DISTINCT", "DO", "ENABLE", "ENCODE", "ENCRYPT", "ENCRYPTION", "EXPLICIT", "FALSE", "FOR", "FOREIGN", "FREEZE", "FROM", "FULL", "GLOBALDICT256", "GLOBALDICT64K", "GROUP", "IDENTITY", "IGNORE", "ILIKE", "IN", "INITIALLY", "INNER", "INTO", "IS", "ISNULL", "LANGUAGE", "LEADING", "LIKE", "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "LUN", "LUNS", "MINUS", "NATURAL", "NEW", "NOT", "NOTNULL", "NULL", "NULLS", "OFF", "OFFLINE", "OFFSET", "OID", "OLD", "ON", "ONLY", "OPEN", "ORDER", "OUTER", "OVERLAPS", "PARALLEL", "PARTITION", "PERCENT", "PERMISSIONS", "PLACING", "PRIMARY", "RECOVER", "REFERENCES", "REJECTLOG", "RESORT", "RESPECT", "RESTORE", "SIMILAR", "SNAPSHOT", "SOME", "SYSTEM", "TABLE", "TAG", "TDES", "THEN", "TIMESTAMP", "TO", "TOP", "TRAILING", "TRUE", "UNIQUE", "USING", "VERBOSE", "WALLET", "WITHOUT"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  dataConversionParams: ["ACCEPTANYDATE", "ACCEPTINVCHARS", "BLANKSASNULL", "DATEFORMAT", "EMPTYASNULL", "ENCODING", "ESCAPE", "EXPLICIT_IDS", "FILLRECORD", "IGNOREBLANKLINES", "IGNOREHEADER", "REMOVEQUOTES", "ROUNDEC", "TIMEFORMAT", "TRIMBLANKS", "TRUNCATECOLUMNS"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-load.html
  dataLoadParams: ["COMPROWS", "COMPUPDATE", "MAXERROR", "NOLOAD", "STATUPDATE"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-format.html
  dataFormatParams: ["FORMAT", "CSV", "DELIMITER", "FIXEDWIDTH", "SHAPEFILE", "AVRO", "JSON", "PARQUET", "ORC"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-authorization.html
  copyAuthParams: ["ACCESS_KEY_ID", "CREDENTIALS", "ENCRYPTED", "IAM_ROLE", "MASTER_SYMMETRIC_KEY", "SECRET_ACCESS_KEY", "SESSION_TOKEN"],
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-file-compression.html
  copyCompressionParams: ["BZIP2", "GZIP", "LZOP", "ZSTD"],
  // https://docs.aws.amazon.com/redshift/latest/dg/r_COPY-alphabetical-parm-list.html
  copyMiscParams: ["MANIFEST", "READRATIO", "REGION", "SSH"],
  // https://docs.aws.amazon.com/redshift/latest/dg/c_Compression_encodings.html
  compressionEncodings: ["RAW", "AZ64", "BYTEDICT", "DELTA", "DELTA32K", "LZO", "MOSTLY8", "MOSTLY16", "MOSTLY32", "RUNLENGTH", "TEXT255", "TEXT32K"],
  misc: [
    // CREATE EXTERNAL SCHEMA (https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html)
    "CATALOG_ROLE",
    "SECRET_ARN",
    "EXTERNAL",
    // https://docs.aws.amazon.com/redshift/latest/dg/c_choosing_dist_sort.html
    "AUTO",
    "EVEN",
    "KEY",
    "PREDICATE",
    // ANALYZE | ANALYSE (https://docs.aws.amazon.com/redshift/latest/dg/r_ANALYZE.html)
    // unknown
    "COMPRESSION"
  ],
  /**
   * Other keywords not included:
   * STL: https://docs.aws.amazon.com/redshift/latest/dg/c_intro_STL_tables.html
   * SVCS: https://docs.aws.amazon.com/redshift/latest/dg/svcs_views.html
   * SVL: https://docs.aws.amazon.com/redshift/latest/dg/svl_views.html
   * SVV: https://docs.aws.amazon.com/redshift/latest/dg/svv_views.html
   */
  // https://docs.aws.amazon.com/redshift/latest/dg/r_Character_types.html#r_Character_types-text-and-bpchar-types
  dataTypes: ["BPCHAR", "TEXT"]
}), nUe = re(["SELECT [ALL | DISTINCT]"]), aUe = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE | MATERIALIZED] VIEW",
  "CREATE [TEMPORARY | TEMP | LOCAL TEMPORARY | LOCAL TEMP] TABLE [IF NOT EXISTS]"
]), KB = re([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ALTER TABLE APPEND",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  "TYPE",
  // for alter column
  "ENCODE",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.aws.amazon.com/redshift/latest/dg/c_SQL_commands.html
  "ABORT",
  "ALTER DATABASE",
  "ALTER DATASHARE",
  "ALTER DEFAULT PRIVILEGES",
  "ALTER GROUP",
  "ALTER MATERIALIZED VIEW",
  "ALTER PROCEDURE",
  "ALTER SCHEMA",
  "ALTER USER",
  "ANALYSE",
  "ANALYZE",
  "ANALYSE COMPRESSION",
  "ANALYZE COMPRESSION",
  "BEGIN",
  "CALL",
  "CANCEL",
  "CLOSE",
  "COMMENT",
  "COMMIT",
  "COPY",
  "CREATE DATABASE",
  "CREATE DATASHARE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL SCHEMA",
  "CREATE EXTERNAL TABLE",
  "CREATE FUNCTION",
  "CREATE GROUP",
  "CREATE LIBRARY",
  "CREATE MODEL",
  "CREATE PROCEDURE",
  "CREATE SCHEMA",
  "CREATE USER",
  "DEALLOCATE",
  "DECLARE",
  "DESC DATASHARE",
  "DROP DATABASE",
  "DROP DATASHARE",
  "DROP FUNCTION",
  "DROP GROUP",
  "DROP LIBRARY",
  "DROP MODEL",
  "DROP MATERIALIZED VIEW",
  "DROP PROCEDURE",
  "DROP SCHEMA",
  "DROP USER",
  "DROP VIEW",
  "DROP",
  "EXECUTE",
  "EXPLAIN",
  "FETCH",
  "GRANT",
  "LOCK",
  "PREPARE",
  "REFRESH MATERIALIZED VIEW",
  "RESET",
  "REVOKE",
  "ROLLBACK",
  "SELECT INTO",
  "SET SESSION AUTHORIZATION",
  "SET SESSION CHARACTERISTICS",
  "SHOW",
  "SHOW EXTERNAL TABLE",
  "SHOW MODEL",
  "SHOW DATASHARES",
  "SHOW PROCEDURE",
  "SHOW TABLE",
  "SHOW VIEW",
  "START TRANSACTION",
  "UNLOAD",
  "VACUUM"
]), oUe = re(["UNION [ALL]", "EXCEPT", "INTERSECT", "MINUS"]), sUe = re(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), lUe = re([
  // https://docs.aws.amazon.com/redshift/latest/dg/copy-parameters-data-conversion.html
  "NULL AS",
  // https://docs.aws.amazon.com/redshift/latest/dg/r_CREATE_EXTERNAL_SCHEMA.html
  "DATA CATALOG",
  "HIVE METASTORE",
  // in window specifications
  "{ROWS | RANGE} BETWEEN"
]), uUe = {
  tokenizerOptions: {
    reservedSelect: nUe,
    reservedClauses: [...aUe, ...KB],
    reservedSetOperations: oUe,
    reservedJoins: sUe,
    reservedPhrases: lUe,
    reservedKeywords: iUe,
    reservedFunctionNames: rUe,
    stringTypes: ["''-qq"],
    identTypes: ['""-qq'],
    identChars: {
      first: "#"
    },
    paramTypes: {
      numbered: ["$"]
    },
    operators: [
      "^",
      "%",
      "@",
      "|/",
      "||/",
      "&",
      "|",
      // '#', conflicts with first char of identifier
      "~",
      "<<",
      ">>",
      "||",
      "::"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: KB
  }
}, cUe = wt({
  // https://deepkb.com/CO_000013/en/kb/IMPORT-fbfa59f0-2bf1-31fe-bb7b-0f9efe9932c6/spark-sql-keywords
  all: [
    "ADD",
    "AFTER",
    "ALL",
    "ALTER",
    "ANALYZE",
    "AND",
    "ANTI",
    "ANY",
    "ARCHIVE",
    "ARRAY",
    "AS",
    "ASC",
    "AT",
    "AUTHORIZATION",
    "BETWEEN",
    "BOTH",
    "BUCKET",
    "BUCKETS",
    "BY",
    "CACHE",
    "CASCADE",
    "CAST",
    "CHANGE",
    "CHECK",
    "CLEAR",
    "CLUSTER",
    "CLUSTERED",
    "CODEGEN",
    "COLLATE",
    "COLLECTION",
    "COLUMN",
    "COLUMNS",
    "COMMENT",
    "COMMIT",
    "COMPACT",
    "COMPACTIONS",
    "COMPUTE",
    "CONCATENATE",
    "CONSTRAINT",
    "COST",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_DATE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "DATA",
    "DATABASE",
    "DATABASES",
    "DAY",
    "DBPROPERTIES",
    "DEFINED",
    "DELETE",
    "DELIMITED",
    "DESC",
    "DESCRIBE",
    "DFS",
    "DIRECTORIES",
    "DIRECTORY",
    "DISTINCT",
    "DISTRIBUTE",
    "DIV",
    "DROP",
    "ESCAPE",
    "ESCAPED",
    "EXCEPT",
    "EXCHANGE",
    "EXISTS",
    "EXPORT",
    "EXTENDED",
    "EXTERNAL",
    "EXTRACT",
    "FALSE",
    "FETCH",
    "FIELDS",
    "FILTER",
    "FILEFORMAT",
    "FIRST",
    "FIRST_VALUE",
    "FOLLOWING",
    "FOR",
    "FOREIGN",
    "FORMAT",
    "FORMATTED",
    "FULL",
    "FUNCTION",
    "FUNCTIONS",
    "GLOBAL",
    "GRANT",
    "GROUP",
    "GROUPING",
    "HOUR",
    "IF",
    "IGNORE",
    "IMPORT",
    "IN",
    "INDEX",
    "INDEXES",
    "INNER",
    "INPATH",
    "INPUTFORMAT",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "ITEMS",
    "KEYS",
    "LAST",
    "LAST_VALUE",
    "LATERAL",
    "LAZY",
    "LEADING",
    "LEFT",
    "LIKE",
    "LINES",
    "LIST",
    "LOCAL",
    "LOCATION",
    "LOCK",
    "LOCKS",
    "LOGICAL",
    "MACRO",
    "MAP",
    "MATCHED",
    "MERGE",
    "MINUTE",
    "MONTH",
    "MSCK",
    "NAMESPACE",
    "NAMESPACES",
    "NATURAL",
    "NO",
    "NOT",
    "NULL",
    "NULLS",
    "OF",
    "ONLY",
    "OPTION",
    "OPTIONS",
    "OR",
    "ORDER",
    "OUT",
    "OUTER",
    "OUTPUTFORMAT",
    "OVER",
    "OVERLAPS",
    "OVERLAY",
    "OVERWRITE",
    "OWNER",
    "PARTITION",
    "PARTITIONED",
    "PARTITIONS",
    "PERCENT",
    "PLACING",
    "POSITION",
    "PRECEDING",
    "PRIMARY",
    "PRINCIPALS",
    "PROPERTIES",
    "PURGE",
    "QUERY",
    "RANGE",
    "RECORDREADER",
    "RECORDWRITER",
    "RECOVER",
    "REDUCE",
    "REFERENCES",
    "RENAME",
    "REPAIR",
    "REPLACE",
    "RESPECT",
    "RESTRICT",
    "REVOKE",
    "RIGHT",
    "RLIKE",
    "ROLE",
    "ROLES",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SCHEMA",
    "SECOND",
    "SELECT",
    "SEMI",
    "SEPARATED",
    "SERDE",
    "SERDEPROPERTIES",
    "SESSION_USER",
    "SETS",
    "SHOW",
    "SKEWED",
    "SOME",
    "SORT",
    "SORTED",
    "START",
    "STATISTICS",
    "STORED",
    "STRATIFY",
    "STRUCT",
    "SUBSTR",
    "SUBSTRING",
    "TABLE",
    "TABLES",
    "TBLPROPERTIES",
    "TEMPORARY",
    "TERMINATED",
    "THEN",
    "TO",
    "TOUCH",
    "TRAILING",
    "TRANSACTION",
    "TRANSACTIONS",
    "TRIM",
    "TRUE",
    "TRUNCATE",
    "UNARCHIVE",
    "UNBOUNDED",
    "UNCACHE",
    "UNIQUE",
    "UNKNOWN",
    "UNLOCK",
    "UNSET",
    "USE",
    "USER",
    "USING",
    "VIEW",
    "WINDOW",
    "YEAR",
    // other
    "ANALYSE",
    "ARRAY_ZIP",
    "COALESCE",
    "CONTAINS",
    "CONVERT",
    "DAYS",
    "DAY_HOUR",
    "DAY_MINUTE",
    "DAY_SECOND",
    "DECODE",
    "DEFAULT",
    "DISTINCTROW",
    "ENCODE",
    "EXPLODE",
    "EXPLODE_OUTER",
    "FIXED",
    "GREATEST",
    "GROUP_CONCAT",
    "HOURS",
    "HOUR_MINUTE",
    "HOUR_SECOND",
    "IFNULL",
    "LEAST",
    "LEVEL",
    "MINUTE_SECOND",
    "NULLIF",
    "OFFSET",
    "ON",
    "OPTIMIZE",
    "REGEXP",
    "SEPARATOR",
    "SIZE",
    "STRING",
    "TYPE",
    "TYPES",
    "UNSIGNED",
    "VARIABLES",
    "YEAR_MONTH"
  ]
}), hUe = wt({
  // http://spark.apache.org/docs/latest/sql-ref-functions.html
  //
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#aggregate-functions
  aggregate: [
    // 'ANY',
    "APPROX_COUNT_DISTINCT",
    "APPROX_PERCENTILE",
    "AVG",
    "BIT_AND",
    "BIT_OR",
    "BIT_XOR",
    "BOOL_AND",
    "BOOL_OR",
    "COLLECT_LIST",
    "COLLECT_SET",
    "CORR",
    "COUNT",
    "COUNT",
    "COUNT",
    "COUNT_IF",
    "COUNT_MIN_SKETCH",
    "COVAR_POP",
    "COVAR_SAMP",
    "EVERY",
    "FIRST",
    "FIRST_VALUE",
    "GROUPING",
    "GROUPING_ID",
    "KURTOSIS",
    "LAST",
    "LAST_VALUE",
    "MAX",
    "MAX_BY",
    "MEAN",
    "MIN",
    "MIN_BY",
    "PERCENTILE",
    "PERCENTILE",
    "PERCENTILE_APPROX",
    "SKEWNESS",
    // 'SOME',
    "STD",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "SUM",
    "VAR_POP",
    "VAR_SAMP",
    "VARIANCE"
  ],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#window-functions
  window: ["CUME_DIST", "DENSE_RANK", "LAG", "LEAD", "NTH_VALUE", "NTILE", "PERCENT_RANK", "RANK", "ROW_NUMBER"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#array-functions
  array: ["ARRAY", "ARRAY_CONTAINS", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_REPEAT", "ARRAY_UNION", "ARRAYS_OVERLAP", "ARRAYS_ZIP", "FLATTEN", "SEQUENCE", "SHUFFLE", "SLICE", "SORT_ARRAY"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#map-functions
  map: ["ELEMENT_AT", "ELEMENT_AT", "MAP", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FROM_ARRAYS", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_VALUES", "STR_TO_MAP"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#date-and-timestamp-functions
  datetime: ["ADD_MONTHS", "CURRENT_DATE", "CURRENT_DATE", "CURRENT_TIMESTAMP", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "DATE_ADD", "DATE_FORMAT", "DATE_FROM_UNIX_DATE", "DATE_PART", "DATE_SUB", "DATE_TRUNC", "DATEDIFF", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFYEAR", "EXTRACT", "FROM_UNIXTIME", "FROM_UTC_TIMESTAMP", "HOUR", "LAST_DAY", "MAKE_DATE", "MAKE_DT_INTERVAL", "MAKE_INTERVAL", "MAKE_TIMESTAMP", "MAKE_YM_INTERVAL", "MINUTE", "MONTH", "MONTHS_BETWEEN", "NEXT_DAY", "NOW", "QUARTER", "SECOND", "SESSION_WINDOW", "TIMESTAMP_MICROS", "TIMESTAMP_MILLIS", "TIMESTAMP_SECONDS", "TO_DATE", "TO_TIMESTAMP", "TO_UNIX_TIMESTAMP", "TO_UTC_TIMESTAMP", "TRUNC", "UNIX_DATE", "UNIX_MICROS", "UNIX_MILLIS", "UNIX_SECONDS", "UNIX_TIMESTAMP", "WEEKDAY", "WEEKOFYEAR", "WINDOW", "YEAR"],
  // http://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#json-functions
  json: ["FROM_JSON", "GET_JSON_OBJECT", "JSON_ARRAY_LENGTH", "JSON_OBJECT_KEYS", "JSON_TUPLE", "SCHEMA_OF_JSON", "TO_JSON"],
  // http://spark.apache.org/docs/latest/api/sql/index.html
  misc: [
    "ABS",
    "ACOS",
    "ACOSH",
    "AGGREGATE",
    "ARRAY_SORT",
    "ASCII",
    "ASIN",
    "ASINH",
    "ASSERT_TRUE",
    "ATAN",
    "ATAN2",
    "ATANH",
    "BASE64",
    "BIGINT",
    "BIN",
    "BINARY",
    "BIT_COUNT",
    "BIT_GET",
    "BIT_LENGTH",
    "BOOLEAN",
    "BROUND",
    "BTRIM",
    "CARDINALITY",
    "CBRT",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHAR_LENGTH",
    "CHARACTER_LENGTH",
    "CHR",
    "CONCAT",
    "CONCAT_WS",
    "CONV",
    "COS",
    "COSH",
    "COT",
    "CRC32",
    "CURRENT_CATALOG",
    "CURRENT_DATABASE",
    "CURRENT_USER",
    "DATE",
    "DECIMAL",
    "DEGREES",
    "DOUBLE",
    // 'E',
    "ELT",
    "EXP",
    "EXPM1",
    "FACTORIAL",
    "FIND_IN_SET",
    "FLOAT",
    "FLOOR",
    "FORALL",
    "FORMAT_NUMBER",
    "FORMAT_STRING",
    "FROM_CSV",
    "GETBIT",
    "HASH",
    "HEX",
    "HYPOT",
    "INITCAP",
    "INLINE",
    "INLINE_OUTER",
    "INPUT_FILE_BLOCK_LENGTH",
    "INPUT_FILE_BLOCK_START",
    "INPUT_FILE_NAME",
    "INSTR",
    "INT",
    "ISNAN",
    "ISNOTNULL",
    "ISNULL",
    "JAVA_METHOD",
    "LCASE",
    "LEFT",
    "LENGTH",
    "LEVENSHTEIN",
    "LN",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG1P",
    "LOG2",
    "LOWER",
    "LPAD",
    "LTRIM",
    "MAP_FILTER",
    "MAP_ZIP_WITH",
    "MD5",
    "MOD",
    "MONOTONICALLY_INCREASING_ID",
    "NAMED_STRUCT",
    "NANVL",
    "NEGATIVE",
    "NVL",
    "NVL2",
    "OCTET_LENGTH",
    "OVERLAY",
    "PARSE_URL",
    "PI",
    "PMOD",
    "POSEXPLODE",
    "POSEXPLODE_OUTER",
    "POSITION",
    "POSITIVE",
    "POW",
    "POWER",
    "PRINTF",
    "RADIANS",
    "RAISE_ERROR",
    "RAND",
    "RANDN",
    "RANDOM",
    "REFLECT",
    "REGEXP_EXTRACT",
    "REGEXP_EXTRACT_ALL",
    "REGEXP_LIKE",
    "REGEXP_REPLACE",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RINT",
    "ROUND",
    "RPAD",
    "RTRIM",
    "SCHEMA_OF_CSV",
    "SENTENCES",
    "SHA",
    "SHA1",
    "SHA2",
    "SHIFTLEFT",
    "SHIFTRIGHT",
    "SHIFTRIGHTUNSIGNED",
    "SIGN",
    "SIGNUM",
    "SIN",
    "SINH",
    "SMALLINT",
    "SOUNDEX",
    "SPACE",
    "SPARK_PARTITION_ID",
    "SPLIT",
    "SQRT",
    "STACK",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "TAN",
    "TANH",
    "TIMESTAMP",
    "TINYINT",
    "TO_CSV",
    "TRANSFORM_KEYS",
    "TRANSFORM_VALUES",
    "TRANSLATE",
    "TRIM",
    "TRY_ADD",
    "TRY_DIVIDE",
    "TYPEOF",
    "UCASE",
    "UNBASE64",
    "UNHEX",
    "UPPER",
    "UUID",
    "VERSION",
    "WIDTH_BUCKET",
    "XPATH",
    "XPATH_BOOLEAN",
    "XPATH_DOUBLE",
    "XPATH_FLOAT",
    "XPATH_INT",
    "XPATH_LONG",
    "XPATH_NUMBER",
    "XPATH_SHORT",
    "XPATH_STRING",
    "XXHASH64",
    "ZIP_WITH"
  ],
  cast: ["CAST"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Parameterized data types
  // https://spark.apache.org/docs/latest/sql-ref-datatypes.html
  dataTypes: [
    "DECIMAL",
    "DEC",
    "NUMERIC",
    // No varchar type in Spark, only STRING. Added for the sake of tests
    "VARCHAR"
  ]
}), fUe = re(["SELECT [ALL | DISTINCT]"]), dUe = re([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "SORT BY",
  "CLUSTER BY",
  "DISTRIBUTE BY",
  "LIMIT",
  // Data manipulation
  // - insert:
  "INSERT [INTO | OVERWRITE] [TABLE]",
  "VALUES",
  // - insert overwrite directory:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-insert-overwrite-directory.html
  "INSERT OVERWRITE [LOCAL] DIRECTORY",
  // - load:
  //   https://spark.apache.org/docs/latest/sql-ref-syntax-dml-load.html
  "LOAD DATA [LOCAL] INPATH",
  "[OVERWRITE] INTO TABLE",
  // Data definition
  "CREATE [OR REPLACE] [GLOBAL TEMPORARY | TEMPORARY] VIEW [IF NOT EXISTS]",
  "CREATE [EXTERNAL] TABLE [IF NOT EXISTS]"
]), JB = re([
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMNS",
  "DROP {COLUMN | COLUMNS}",
  "RENAME TO",
  "RENAME COLUMN",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "LATERAL VIEW",
  "ALTER DATABASE",
  "ALTER VIEW",
  "CREATE DATABASE",
  "CREATE FUNCTION",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP VIEW",
  "REPAIR TABLE",
  "USE DATABASE",
  // Data Retrieval
  "TABLESAMPLE",
  "PIVOT",
  "TRANSFORM",
  "EXPLAIN",
  // Auxiliary
  "ADD FILE",
  "ADD JAR",
  "ANALYZE TABLE",
  "CACHE TABLE",
  "CLEAR CACHE",
  "DESCRIBE DATABASE",
  "DESCRIBE FUNCTION",
  "DESCRIBE QUERY",
  "DESCRIBE TABLE",
  "LIST FILE",
  "LIST JAR",
  "REFRESH",
  "REFRESH TABLE",
  "REFRESH FUNCTION",
  "RESET",
  "SHOW COLUMNS",
  "SHOW CREATE TABLE",
  "SHOW DATABASES",
  "SHOW FUNCTIONS",
  "SHOW PARTITIONS",
  "SHOW TABLE EXTENDED",
  "SHOW TABLES",
  "SHOW TBLPROPERTIES",
  "SHOW VIEWS",
  "UNCACHE TABLE"
]), pUe = re(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), gUe = re([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL [INNER] JOIN",
  "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN",
  // non-standard-joins
  "[LEFT] {ANTI | SEMI} JOIN",
  "NATURAL [LEFT] {ANTI | SEMI} JOIN"
]), vUe = re(["ON DELETE", "ON UPDATE", "CURRENT ROW", "{ROWS | RANGE} BETWEEN"]), OUe = {
  tokenizerOptions: {
    reservedSelect: fUe,
    reservedClauses: [...dUe, ...JB],
    reservedSetOperations: pUe,
    reservedJoins: gUe,
    reservedPhrases: vUe,
    supportsXor: !0,
    reservedKeywords: cUe,
    reservedFunctionNames: hUe,
    extraParens: ["[]"],
    stringTypes: ["''-bs", '""-bs', {
      quote: "''-raw",
      prefixes: ["R", "X"],
      requirePrefix: !0
    }, {
      quote: '""-raw',
      prefixes: ["R", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    variableTypes: [{
      quote: "{}",
      prefixes: ["$"],
      requirePrefix: !0
    }],
    operators: ["%", "~", "^", "|", "&", "<=>", "==", "!", "||", "->"],
    postProcess: mUe
  },
  formatOptions: {
    onelineClauses: JB
  }
};
function mUe(r) {
  return r.map((e, t) => {
    const i = r[t - 1] || Uc, n = r[t + 1] || Uc;
    return Xl.WINDOW(e) && n.type === ee.OPEN_PAREN ? {
      ...e,
      type: ee.RESERVED_FUNCTION_NAME
    } : e.text === "ITEMS" && e.type === ee.RESERVED_KEYWORD && !(i.text === "COLLECTION" && n.text === "TERMINATED") ? {
      ...e,
      type: ee.IDENTIFIER,
      text: e.raw
    } : e;
  });
}
const EUe = wt({
  // https://www.sqlite.org/lang_corefunc.html
  scalar: ["ABS", "CHANGES", "CHAR", "COALESCE", "FORMAT", "GLOB", "HEX", "IFNULL", "IIF", "INSTR", "LAST_INSERT_ROWID", "LENGTH", "LIKE", "LIKELIHOOD", "LIKELY", "LOAD_EXTENSION", "LOWER", "LTRIM", "NULLIF", "PRINTF", "QUOTE", "RANDOM", "RANDOMBLOB", "REPLACE", "ROUND", "RTRIM", "SIGN", "SOUNDEX", "SQLITE_COMPILEOPTION_GET", "SQLITE_COMPILEOPTION_USED", "SQLITE_OFFSET", "SQLITE_SOURCE_ID", "SQLITE_VERSION", "SUBSTR", "SUBSTRING", "TOTAL_CHANGES", "TRIM", "TYPEOF", "UNICODE", "UNLIKELY", "UPPER", "ZEROBLOB"],
  // https://www.sqlite.org/lang_aggfunc.html
  aggregate: ["AVG", "COUNT", "GROUP_CONCAT", "MAX", "MIN", "SUM", "TOTAL"],
  // https://www.sqlite.org/lang_datefunc.html
  datetime: ["DATE", "TIME", "DATETIME", "JULIANDAY", "UNIXEPOCH", "STRFTIME"],
  // https://www.sqlite.org/windowfunctions.html#biwinfunc
  window: ["row_number", "rank", "dense_rank", "percent_rank", "cume_dist", "ntile", "lag", "lead", "first_value", "last_value", "nth_value"],
  // https://www.sqlite.org/lang_mathfunc.html
  math: ["ACOS", "ACOSH", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "CEIL", "CEILING", "COS", "COSH", "DEGREES", "EXP", "FLOOR", "LN", "LOG", "LOG", "LOG10", "LOG2", "MOD", "PI", "POW", "POWER", "RADIANS", "SIN", "SINH", "SQRT", "TAN", "TANH", "TRUNC"],
  // https://www.sqlite.org/json1.html
  json: ["JSON", "JSON_ARRAY", "JSON_ARRAY_LENGTH", "JSON_ARRAY_LENGTH", "JSON_EXTRACT", "JSON_INSERT", "JSON_OBJECT", "JSON_PATCH", "JSON_REMOVE", "JSON_REPLACE", "JSON_SET", "JSON_TYPE", "JSON_TYPE", "JSON_VALID", "JSON_QUOTE", "JSON_GROUP_ARRAY", "JSON_GROUP_OBJECT", "JSON_EACH", "JSON_TREE"],
  cast: ["CAST"],
  // SQLite allows parameters for all data types
  // Well, in fact it allows any word as a data type, e.g. CREATE TABLE foo (col1 madeupname(123));
  // https://www.sqlite.org/datatype3.html
  dataTypes: ["CHARACTER", "VARCHAR", "VARYING CHARACTER", "NCHAR", "NATIVE CHARACTER", "NVARCHAR", "NUMERIC", "DECIMAL"]
}), bUe = wt({
  // https://www.sqlite.org/lang_keywords.html
  all: ["ABORT", "ACTION", "ADD", "AFTER", "ALL", "ALTER", "AND", "ANY", "ARE", "ARRAY", "ALWAYS", "ANALYZE", "AS", "ASC", "ATTACH", "AUTOINCREMENT", "BEFORE", "BEGIN", "BETWEEN", "BY", "CASCADE", "CASE", "CAST", "CHECK", "COLLATE", "COLUMN", "COMMIT", "CONFLICT", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "DATABASE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DETACH", "DISTINCT", "DO", "DROP", "EACH", "ELSE", "END", "ESCAPE", "EXCEPT", "EXCLUDE", "EXCLUSIVE", "EXISTS", "EXPLAIN", "FAIL", "FILTER", "FIRST", "FOLLOWING", "FOR", "FOREIGN", "FROM", "FULL", "GENERATED", "GLOB", "GROUP", "GROUPS", "HAVING", "IF", "IGNORE", "IMMEDIATE", "IN", "INDEX", "INDEXED", "INITIALLY", "INNER", "INSERT", "INSTEAD", "INTERSECT", "INTO", "IS", "ISNULL", "JOIN", "KEY", "LAST", "LEFT", "LIKE", "LIMIT", "MATCH", "MATERIALIZED", "NATURAL", "NO", "NOT", "NOTHING", "NOTNULL", "NULL", "NULLS", "OF", "OFFSET", "ON", "ONLY", "OPEN", "OR", "ORDER", "OTHERS", "OUTER", "OVER", "PARTITION", "PLAN", "PRAGMA", "PRECEDING", "PRIMARY", "QUERY", "RAISE", "RANGE", "RECURSIVE", "REFERENCES", "REGEXP", "REINDEX", "RELEASE", "RENAME", "REPLACE", "RESTRICT", "RETURNING", "RIGHT", "ROLLBACK", "ROW", "ROWS", "SAVEPOINT", "SELECT", "SET", "TABLE", "TEMP", "TEMPORARY", "THEN", "TIES", "TO", "TRANSACTION", "TRIGGER", "UNBOUNDED", "UNION", "UNIQUE", "UPDATE", "USING", "VACUUM", "VALUES", "VIEW", "VIRTUAL", "WHEN", "WHERE", "WINDOW", "WITH", "WITHOUT"]
}), SUe = re(["SELECT [ALL | DISTINCT]"]), TUe = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK] INTO",
  "REPLACE INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [TEMPORARY | TEMP] VIEW [IF NOT EXISTS]",
  "CREATE [TEMPORARY | TEMP] TABLE [IF NOT EXISTS]"
]), e5 = re([
  // - update:
  "UPDATE [OR ABORT | OR FAIL | OR IGNORE | OR REPLACE | OR ROLLBACK]",
  // - insert:
  "ON CONFLICT",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD [COLUMN]",
  "DROP [COLUMN]",
  "RENAME [COLUMN]",
  "RENAME TO",
  // - set schema
  "SET SCHEMA"
]), yUe = re(["UNION [ALL]", "EXCEPT", "INTERSECT"]), RUe = re(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), AUe = re(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE | GROUPS} BETWEEN"]), _Ue = {
  tokenizerOptions: {
    reservedSelect: SUe,
    reservedClauses: [...TUe, ...e5],
    reservedSetOperations: yUe,
    reservedJoins: RUe,
    reservedPhrases: AUe,
    reservedKeywords: bUe,
    reservedFunctionNames: EUe,
    stringTypes: [
      "''-qq",
      {
        quote: "''-raw",
        prefixes: ["X"],
        requirePrefix: !0
      }
      // Depending on context SQLite also supports double-quotes for strings,
      // and single-quotes for identifiers.
    ],
    identTypes: ['""-qq', "``", "[]"],
    // https://www.sqlite.org/lang_expr.html#parameters
    paramTypes: {
      positional: !0,
      numbered: ["?"],
      named: [":", "@", "$"]
    },
    operators: ["%", "~", "&", "|", "<<", ">>", "==", "->", "->>", "||"]
  },
  formatOptions: {
    onelineClauses: e5
  }
}, CUe = wt({
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_9_set_function_specification
  set: ["GROUPING"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_10_window_function
  window: ["RANK", "DENSE_RANK", "PERCENT_RANK", "CUME_DIST", "ROW_NUMBER"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_27_numeric_value_function
  numeric: ["POSITION", "OCCURRENCES_REGEX", "POSITION_REGEX", "EXTRACT", "CHAR_LENGTH", "CHARACTER_LENGTH", "OCTET_LENGTH", "CARDINALITY", "ABS", "MOD", "LN", "EXP", "POWER", "SQRT", "FLOOR", "CEIL", "CEILING", "WIDTH_BUCKET"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_29_string_value_function
  string: ["SUBSTRING", "SUBSTRING_REGEX", "UPPER", "LOWER", "CONVERT", "TRANSLATE", "TRANSLATE_REGEX", "TRIM", "OVERLAY", "NORMALIZE", "SPECIFICTYPE"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_31_datetime_value_function
  datetime: ["CURRENT_DATE", "CURRENT_TIME", "LOCALTIME", "CURRENT_TIMESTAMP", "LOCALTIMESTAMP"],
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_6_38_multiset_value_function
  // SET serves multiple roles: a SET() function and a SET keyword e.g. in UPDATE table SET ...
  // multiset: ['SET'], (disabled for now)
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#_10_9_aggregate_function
  aggregate: [
    "COUNT",
    "AVG",
    "MAX",
    "MIN",
    "SUM",
    // 'EVERY',
    // 'ANY',
    // 'SOME',
    "STDDEV_POP",
    "STDDEV_SAMP",
    "VAR_SAMP",
    "VAR_POP",
    "COLLECT",
    "FUSION",
    "INTERSECTION",
    "COVAR_POP",
    "COVAR_SAMP",
    "CORR",
    "REGR_SLOPE",
    "REGR_INTERCEPT",
    "REGR_COUNT",
    "REGR_R2",
    "REGR_AVGX",
    "REGR_AVGY",
    "REGR_SXX",
    "REGR_SYY",
    "REGR_SXY",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC"
  ],
  // CAST is a pretty complex case, involving multiple forms:
  // - CAST(col AS int)
  // - CAST(...) WITH ...
  // - CAST FROM int
  // - CREATE CAST(mycol AS int) WITH ...
  cast: ["CAST"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Non-standard functions that have widespread support
  nonStandard: ["ROUND", "SIN", "COS", "TAN", "ASIN", "ACOS", "ATAN"],
  // Data types with parameters like VARCHAR(100)
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#predefined-type
  dataTypes: ["CHARACTER", "CHAR", "CHARACTER VARYING", "CHAR VARYING", "VARCHAR", "CHARACTER LARGE OBJECT", "CHAR LARGE OBJECT", "CLOB", "NATIONAL CHARACTER", "NATIONAL CHAR", "NCHAR", "NATIONAL CHARACTER VARYING", "NATIONAL CHAR VARYING", "NCHAR VARYING", "NATIONAL CHARACTER LARGE OBJECT", "NCHAR LARGE OBJECT", "NCLOB", "BINARY", "BINARY VARYING", "VARBINARY", "BINARY LARGE OBJECT", "BLOB", "NUMERIC", "DECIMAL", "DEC", "TIME", "TIMESTAMP"]
}), IUe = wt({
  // https://jakewheat.github.io/sql-overview/sql-2008-foundation-grammar.html#reserved-word
  all: [
    "ALL",
    "ALLOCATE",
    "ALTER",
    "ANY",
    // <- moved over from functions
    "ARE",
    "ARRAY",
    "AS",
    "ASENSITIVE",
    "ASYMMETRIC",
    "AT",
    "ATOMIC",
    "AUTHORIZATION",
    "BEGIN",
    "BETWEEN",
    "BIGINT",
    "BINARY",
    "BLOB",
    "BOOLEAN",
    "BOTH",
    "BY",
    "CALL",
    "CALLED",
    "CASCADED",
    "CAST",
    "CHAR",
    "CHARACTER",
    "CHECK",
    "CLOB",
    "CLOSE",
    "COALESCE",
    "COLLATE",
    "COLUMN",
    "COMMIT",
    "CONDITION",
    "CONNECT",
    "CONSTRAINT",
    "CORRESPONDING",
    "CREATE",
    "CROSS",
    "CUBE",
    "CURRENT",
    "CURRENT_CATALOG",
    "CURRENT_DEFAULT_TRANSFORM_GROUP",
    "CURRENT_PATH",
    "CURRENT_ROLE",
    "CURRENT_SCHEMA",
    "CURRENT_TRANSFORM_GROUP_FOR_TYPE",
    "CURRENT_USER",
    "CURSOR",
    "CYCLE",
    "DATE",
    "DAY",
    "DEALLOCATE",
    "DEC",
    "DECIMAL",
    "DECLARE",
    "DEFAULT",
    "DELETE",
    "DEREF",
    "DESCRIBE",
    "DETERMINISTIC",
    "DISCONNECT",
    "DISTINCT",
    "DOUBLE",
    "DROP",
    "DYNAMIC",
    "EACH",
    "ELEMENT",
    "END-EXEC",
    "ESCAPE",
    "EVERY",
    // <- moved over from functions
    "EXCEPT",
    "EXEC",
    "EXECUTE",
    "EXISTS",
    "EXTERNAL",
    "FALSE",
    "FETCH",
    "FILTER",
    "FLOAT",
    "FOR",
    "FOREIGN",
    "FREE",
    "FROM",
    "FULL",
    "FUNCTION",
    "GET",
    "GLOBAL",
    "GRANT",
    "GROUP",
    "HAVING",
    "HOLD",
    "HOUR",
    "IDENTITY",
    "IN",
    "INDICATOR",
    "INNER",
    "INOUT",
    "INSENSITIVE",
    "INSERT",
    "INT",
    "INTEGER",
    "INTERSECT",
    "INTERVAL",
    "INTO",
    "IS",
    "LANGUAGE",
    "LARGE",
    "LATERAL",
    "LEADING",
    "LEFT",
    "LIKE",
    "LIKE_REGEX",
    "LOCAL",
    "MATCH",
    "MEMBER",
    "MERGE",
    "METHOD",
    "MINUTE",
    "MODIFIES",
    "MODULE",
    "MONTH",
    "MULTISET",
    "NATIONAL",
    "NATURAL",
    "NCHAR",
    "NCLOB",
    "NEW",
    "NO",
    "NONE",
    "NOT",
    "NULL",
    "NULLIF",
    "NUMERIC",
    "OF",
    "OLD",
    "ON",
    "ONLY",
    "OPEN",
    "ORDER",
    "OUT",
    "OUTER",
    "OVER",
    "OVERLAPS",
    "PARAMETER",
    "PARTITION",
    "PRECISION",
    "PREPARE",
    "PRIMARY",
    "PROCEDURE",
    "RANGE",
    "READS",
    "REAL",
    "RECURSIVE",
    "REF",
    "REFERENCES",
    "REFERENCING",
    "RELEASE",
    "RESULT",
    "RETURN",
    "RETURNS",
    "REVOKE",
    "RIGHT",
    "ROLLBACK",
    "ROLLUP",
    "ROW",
    "ROWS",
    "SAVEPOINT",
    "SCOPE",
    "SCROLL",
    "SEARCH",
    "SECOND",
    "SELECT",
    "SENSITIVE",
    "SESSION_USER",
    "SET",
    "SIMILAR",
    "SMALLINT",
    "SOME",
    // <- moved over from functions
    "SPECIFIC",
    "SQL",
    "SQLEXCEPTION",
    "SQLSTATE",
    "SQLWARNING",
    "START",
    "STATIC",
    "SUBMULTISET",
    "SYMMETRIC",
    "SYSTEM",
    "SYSTEM_USER",
    "TABLE",
    "TABLESAMPLE",
    "THEN",
    "TIME",
    "TIMESTAMP",
    "TIMEZONE_HOUR",
    "TIMEZONE_MINUTE",
    "TO",
    "TRAILING",
    "TRANSLATION",
    "TREAT",
    "TRIGGER",
    "TRUE",
    "UESCAPE",
    "UNION",
    "UNIQUE",
    "UNKNOWN",
    "UNNEST",
    "UPDATE",
    "USER",
    "USING",
    "VALUE",
    "VALUES",
    "VARBINARY",
    "VARCHAR",
    "VARYING",
    "WHENEVER",
    "WINDOW",
    "WITHIN",
    "WITHOUT",
    "YEAR"
  ]
}), wUe = re(["SELECT [ALL | DISTINCT]"]), NUe = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [RECURSIVE] VIEW",
  "CREATE [GLOBAL TEMPORARY | LOCAL TEMPORARY] TABLE"
]), t5 = re([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE",
  // - alter table:
  "ALTER TABLE",
  "ADD COLUMN",
  "DROP [COLUMN]",
  "RENAME COLUMN",
  "RENAME TO",
  "ALTER [COLUMN]",
  "{SET | DROP} DEFAULT",
  // for alter column
  "ADD SCOPE",
  // for alter column
  "DROP SCOPE {CASCADE | RESTRICT}",
  // for alter column
  "RESTART WITH",
  // for alter column
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "SET SCHEMA"
]), xUe = re(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), PUe = re(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), LUe = re(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]), DUe = {
  tokenizerOptions: {
    reservedSelect: wUe,
    reservedClauses: [...NUe, ...t5],
    reservedSetOperations: xUe,
    reservedJoins: PUe,
    reservedPhrases: LUe,
    reservedKeywords: IUe,
    reservedFunctionNames: CUe,
    stringTypes: [{
      quote: "''-qq-bs",
      prefixes: ["N", "U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X"],
      requirePrefix: !0
    }],
    identTypes: ['""-qq', "``"],
    paramTypes: {
      positional: !0
    },
    operators: ["||"]
  },
  formatOptions: {
    onelineClauses: t5
  }
}, MUe = wt({
  // https://github.com/trinodb/trino/tree/432d2897bdef99388c1a47188743a061c4ac1f34/docs/src/main/sphinx/functions
  // rg '^\.\. function::' ./docs/src/main/sphinx/functions | cut -d' ' -f 3 | cut -d '(' -f 1 | sort | uniq
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep    '\* :func:' | cut -d'`' -f 2
  // rg '\* ' ./docs/src/main/sphinx/functions/list-by-topic.rst | grep -v '\* :func:'
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep  -e '^- :func:' | cut -d'`' -f2
  // grep -e '^- ' ./docs/src/main/sphinx/functions/list.rst | grep -ve '^- :func:'
  all: ["ABS", "ACOS", "ALL_MATCH", "ANY_MATCH", "APPROX_DISTINCT", "APPROX_MOST_FREQUENT", "APPROX_PERCENTILE", "APPROX_SET", "ARBITRARY", "ARRAYS_OVERLAP", "ARRAY_AGG", "ARRAY_DISTINCT", "ARRAY_EXCEPT", "ARRAY_INTERSECT", "ARRAY_JOIN", "ARRAY_MAX", "ARRAY_MIN", "ARRAY_POSITION", "ARRAY_REMOVE", "ARRAY_SORT", "ARRAY_UNION", "ASIN", "ATAN", "ATAN2", "AT_TIMEZONE", "AVG", "BAR", "BETA_CDF", "BING_TILE", "BING_TILES_AROUND", "BING_TILE_AT", "BING_TILE_COORDINATES", "BING_TILE_POLYGON", "BING_TILE_QUADKEY", "BING_TILE_ZOOM_LEVEL", "BITWISE_AND", "BITWISE_AND_AGG", "BITWISE_LEFT_SHIFT", "BITWISE_NOT", "BITWISE_OR", "BITWISE_OR_AGG", "BITWISE_RIGHT_SHIFT", "BITWISE_RIGHT_SHIFT_ARITHMETIC", "BITWISE_XOR", "BIT_COUNT", "BOOL_AND", "BOOL_OR", "CARDINALITY", "CAST", "CBRT", "CEIL", "CEILING", "CHAR2HEXINT", "CHECKSUM", "CHR", "CLASSIFY", "COALESCE", "CODEPOINT", "COLOR", "COMBINATIONS", "CONCAT", "CONCAT_WS", "CONTAINS", "CONTAINS_SEQUENCE", "CONVEX_HULL_AGG", "CORR", "COS", "COSH", "COSINE_SIMILARITY", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CRC32", "CUME_DIST", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_GROUPS", "CURRENT_SCHEMA", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_USER", "DATE", "DATE_ADD", "DATE_DIFF", "DATE_FORMAT", "DATE_PARSE", "DATE_TRUNC", "DAY", "DAY_OF_MONTH", "DAY_OF_WEEK", "DAY_OF_YEAR", "DEGREES", "DENSE_RANK", "DOW", "DOY", "E", "ELEMENT_AT", "EMPTY_APPROX_SET", "EVALUATE_CLASSIFIER_PREDICTIONS", "EVERY", "EXP", "EXTRACT", "FEATURES", "FILTER", "FIRST_VALUE", "FLATTEN", "FLOOR", "FORMAT", "FORMAT_DATETIME", "FORMAT_NUMBER", "FROM_BASE", "FROM_BASE32", "FROM_BASE64", "FROM_BASE64URL", "FROM_BIG_ENDIAN_32", "FROM_BIG_ENDIAN_64", "FROM_ENCODED_POLYLINE", "FROM_GEOJSON_GEOMETRY", "FROM_HEX", "FROM_IEEE754_32", "FROM_IEEE754_64", "FROM_ISO8601_DATE", "FROM_ISO8601_TIMESTAMP", "FROM_ISO8601_TIMESTAMP_NANOS", "FROM_UNIXTIME", "FROM_UNIXTIME_NANOS", "FROM_UTF8", "GEOMETRIC_MEAN", "GEOMETRY_FROM_HADOOP_SHAPE", "GEOMETRY_INVALID_REASON", "GEOMETRY_NEAREST_POINTS", "GEOMETRY_TO_BING_TILES", "GEOMETRY_UNION", "GEOMETRY_UNION_AGG", "GREATEST", "GREAT_CIRCLE_DISTANCE", "HAMMING_DISTANCE", "HASH_COUNTS", "HISTOGRAM", "HMAC_MD5", "HMAC_SHA1", "HMAC_SHA256", "HMAC_SHA512", "HOUR", "HUMAN_READABLE_SECONDS", "IF", "INDEX", "INFINITY", "INTERSECTION_CARDINALITY", "INVERSE_BETA_CDF", "INVERSE_NORMAL_CDF", "IS_FINITE", "IS_INFINITE", "IS_JSON_SCALAR", "IS_NAN", "JACCARD_INDEX", "JSON_ARRAY_CONTAINS", "JSON_ARRAY_GET", "JSON_ARRAY_LENGTH", "JSON_EXISTS", "JSON_EXTRACT", "JSON_EXTRACT_SCALAR", "JSON_FORMAT", "JSON_PARSE", "JSON_QUERY", "JSON_SIZE", "JSON_VALUE", "KURTOSIS", "LAG", "LAST_DAY_OF_MONTH", "LAST_VALUE", "LEAD", "LEARN_CLASSIFIER", "LEARN_LIBSVM_CLASSIFIER", "LEARN_LIBSVM_REGRESSOR", "LEARN_REGRESSOR", "LEAST", "LENGTH", "LEVENSHTEIN_DISTANCE", "LINE_INTERPOLATE_POINT", "LINE_INTERPOLATE_POINTS", "LINE_LOCATE_POINT", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOG10", "LOG2", "LOWER", "LPAD", "LTRIM", "LUHN_CHECK", "MAKE_SET_DIGEST", "MAP", "MAP_AGG", "MAP_CONCAT", "MAP_ENTRIES", "MAP_FILTER", "MAP_FROM_ENTRIES", "MAP_KEYS", "MAP_UNION", "MAP_VALUES", "MAP_ZIP_WITH", "MAX", "MAX_BY", "MD5", "MERGE", "MERGE_SET_DIGEST", "MILLISECOND", "MIN", "MINUTE", "MIN_BY", "MOD", "MONTH", "MULTIMAP_AGG", "MULTIMAP_FROM_ENTRIES", "MURMUR3", "NAN", "NGRAMS", "NONE_MATCH", "NORMALIZE", "NORMAL_CDF", "NOW", "NTH_VALUE", "NTILE", "NULLIF", "NUMERIC_HISTOGRAM", "OBJECTID", "OBJECTID_TIMESTAMP", "PARSE_DATA_SIZE", "PARSE_DATETIME", "PARSE_DURATION", "PERCENT_RANK", "PI", "POSITION", "POW", "POWER", "QDIGEST_AGG", "QUARTER", "RADIANS", "RAND", "RANDOM", "RANK", "REDUCE", "REDUCE_AGG", "REGEXP_COUNT", "REGEXP_EXTRACT", "REGEXP_EXTRACT_ALL", "REGEXP_LIKE", "REGEXP_POSITION", "REGEXP_REPLACE", "REGEXP_SPLIT", "REGRESS", "REGR_INTERCEPT", "REGR_SLOPE", "RENDER", "REPEAT", "REPLACE", "REVERSE", "RGB", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "SECOND", "SEQUENCE", "SHA1", "SHA256", "SHA512", "SHUFFLE", "SIGN", "SIMPLIFY_GEOMETRY", "SIN", "SKEWNESS", "SLICE", "SOUNDEX", "SPATIAL_PARTITIONING", "SPATIAL_PARTITIONS", "SPLIT", "SPLIT_PART", "SPLIT_TO_MAP", "SPLIT_TO_MULTIMAP", "SPOOKY_HASH_V2_32", "SPOOKY_HASH_V2_64", "SQRT", "STARTS_WITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRPOS", "ST_AREA", "ST_ASBINARY", "ST_ASTEXT", "ST_BOUNDARY", "ST_BUFFER", "ST_CENTROID", "ST_CONTAINS", "ST_CONVEXHULL", "ST_COORDDIM", "ST_CROSSES", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_ENDPOINT", "ST_ENVELOPE", "ST_ENVELOPEASPTS", "ST_EQUALS", "ST_EXTERIORRING", "ST_GEOMETRIES", "ST_GEOMETRYFROMTEXT", "ST_GEOMETRYN", "ST_GEOMETRYTYPE", "ST_GEOMFROMBINARY", "ST_INTERIORRINGN", "ST_INTERIORRINGS", "ST_INTERSECTION", "ST_INTERSECTS", "ST_ISCLOSED", "ST_ISEMPTY", "ST_ISRING", "ST_ISSIMPLE", "ST_ISVALID", "ST_LENGTH", "ST_LINEFROMTEXT", "ST_LINESTRING", "ST_MULTIPOINT", "ST_NUMGEOMETRIES", "ST_NUMINTERIORRING", "ST_NUMPOINTS", "ST_OVERLAPS", "ST_POINT", "ST_POINTN", "ST_POINTS", "ST_POLYGON", "ST_RELATE", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_TOUCHES", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "SUBSTR", "SUBSTRING", "SUM", "TAN", "TANH", "TDIGEST_AGG", "TIMESTAMP_OBJECTID", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO_BASE", "TO_BASE32", "TO_BASE64", "TO_BASE64URL", "TO_BIG_ENDIAN_32", "TO_BIG_ENDIAN_64", "TO_CHAR", "TO_DATE", "TO_ENCODED_POLYLINE", "TO_GEOJSON_GEOMETRY", "TO_GEOMETRY", "TO_HEX", "TO_IEEE754_32", "TO_IEEE754_64", "TO_ISO8601", "TO_MILLISECONDS", "TO_SPHERICAL_GEOGRAPHY", "TO_TIMESTAMP", "TO_UNIXTIME", "TO_UTF8", "TRANSFORM", "TRANSFORM_KEYS", "TRANSFORM_VALUES", "TRANSLATE", "TRIM", "TRIM_ARRAY", "TRUNCATE", "TRY", "TRY_CAST", "TYPEOF", "UPPER", "URL_DECODE", "URL_ENCODE", "URL_EXTRACT_FRAGMENT", "URL_EXTRACT_HOST", "URL_EXTRACT_PARAMETER", "URL_EXTRACT_PATH", "URL_EXTRACT_PORT", "URL_EXTRACT_PROTOCOL", "URL_EXTRACT_QUERY", "UUID", "VALUES_AT_QUANTILES", "VALUE_AT_QUANTILE", "VARIANCE", "VAR_POP", "VAR_SAMP", "VERSION", "WEEK", "WEEK_OF_YEAR", "WIDTH_BUCKET", "WILSON_INTERVAL_LOWER", "WILSON_INTERVAL_UPPER", "WITH_TIMEZONE", "WORD_STEM", "XXHASH64", "YEAR", "YEAR_OF_WEEK", "YOW", "ZIP", "ZIP_WITH"],
  // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-recognition-expressions
  rowPattern: ["CLASSIFIER", "FIRST", "LAST", "MATCH_NUMBER", "NEXT", "PERMUTE", "PREV"]
}), kUe = wt({
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-parser/src/main/antlr4/io/trino/sql/parser/SqlBase.g4#L858-L1128
  all: ["ABSENT", "ADD", "ADMIN", "AFTER", "ALL", "ALTER", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", "AT", "AUTHORIZATION", "BERNOULLI", "BETWEEN", "BOTH", "BY", "CALL", "CASCADE", "CASE", "CATALOGS", "COLUMN", "COLUMNS", "COMMENT", "COMMIT", "COMMITTED", "CONDITIONAL", "CONSTRAINT", "COPARTITION", "CREATE", "CROSS", "CUBE", "CURRENT", "CURRENT_PATH", "CURRENT_ROLE", "DATA", "DEALLOCATE", "DEFAULT", "DEFINE", "DEFINER", "DELETE", "DENY", "DESC", "DESCRIBE", "DESCRIPTOR", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DROP", "ELSE", "EMPTY", "ENCODING", "END", "ERROR", "ESCAPE", "EXCEPT", "EXCLUDING", "EXECUTE", "EXISTS", "EXPLAIN", "FALSE", "FETCH", "FINAL", "FIRST", "FOLLOWING", "FOR", "FROM", "FULL", "FUNCTIONS", "GRANT", "GRANTED", "GRANTS", "GRAPHVIZ", "GROUP", "GROUPING", "GROUPS", "HAVING", "IGNORE", "IN", "INCLUDING", "INITIAL", "INNER", "INPUT", "INSERT", "INTERSECT", "INTERVAL", "INTO", "INVOKER", "IO", "IS", "ISOLATION", "JOIN", "JSON", "JSON_ARRAY", "JSON_OBJECT", "KEEP", "KEY", "KEYS", "LAST", "LATERAL", "LEADING", "LEFT", "LEVEL", "LIKE", "LIMIT", "LOCAL", "LOGICAL", "MATCH", "MATCHED", "MATCHES", "MATCH_RECOGNIZE", "MATERIALIZED", "MEASURES", "NATURAL", "NEXT", "NFC", "NFD", "NFKC", "NFKD", "NO", "NONE", "NOT", "NULL", "NULLS", "OBJECT", "OF", "OFFSET", "OMIT", "ON", "ONE", "ONLY", "OPTION", "OR", "ORDER", "ORDINALITY", "OUTER", "OUTPUT", "OVER", "OVERFLOW", "PARTITION", "PARTITIONS", "PASSING", "PAST", "PATH", "PATTERN", "PER", "PERMUTE", "PRECEDING", "PRECISION", "PREPARE", "PRIVILEGES", "PROPERTIES", "PRUNE", "QUOTES", "RANGE", "READ", "RECURSIVE", "REFRESH", "RENAME", "REPEATABLE", "RESET", "RESPECT", "RESTRICT", "RETURNING", "REVOKE", "RIGHT", "ROLE", "ROLES", "ROLLBACK", "ROLLUP", "ROW", "ROWS", "RUNNING", "SCALAR", "SCHEMA", "SCHEMAS", "SECURITY", "SEEK", "SELECT", "SERIALIZABLE", "SESSION", "SET", "SETS", "SHOW", "SKIP", "SOME", "START", "STATS", "STRING", "SUBSET", "SYSTEM", "TABLE", "TABLES", "TABLESAMPLE", "TEXT", "THEN", "TIES", "TIME", "TIMESTAMP", "TO", "TRAILING", "TRANSACTION", "TRUE", "TYPE", "UESCAPE", "UNBOUNDED", "UNCOMMITTED", "UNCONDITIONAL", "UNION", "UNIQUE", "UNKNOWN", "UNMATCHED", "UNNEST", "UPDATE", "USE", "USER", "USING", "UTF16", "UTF32", "UTF8", "VALIDATE", "VALUE", "VALUES", "VERBOSE", "VIEW", "WHEN", "WHERE", "WINDOW", "WITH", "WITHIN", "WITHOUT", "WORK", "WRAPPER", "WRITE", "ZONE"],
  // https://github.com/trinodb/trino/blob/432d2897bdef99388c1a47188743a061c4ac1f34/core/trino-main/src/main/java/io/trino/metadata/TypeRegistry.java#L131-L168
  // or https://trino.io/docs/current/language/types.html
  types: ["BIGINT", "INT", "INTEGER", "SMALLINT", "TINYINT", "BOOLEAN", "DATE", "DECIMAL", "REAL", "DOUBLE", "HYPERLOGLOG", "QDIGEST", "TDIGEST", "P4HYPERLOGLOG", "INTERVAL", "TIMESTAMP", "TIME", "VARBINARY", "VARCHAR", "CHAR", "ROW", "ARRAY", "MAP", "JSON", "JSON2016", "IPADDRESS", "GEOMETRY", "UUID", "SETDIGEST", "JONIREGEXP", "RE2JREGEXP", "LIKEPATTERN", "COLOR", "CODEPOINTS", "FUNCTION", "JSONPATH"]
}), QUe = re(["SELECT [ALL | DISTINCT]"]), UUe = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY [ALL | DISTINCT]",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  "CREATE [OR REPLACE] [MATERIALIZED] VIEW",
  "CREATE TABLE [IF NOT EXISTS]",
  // MATCH_RECOGNIZE
  "MATCH_RECOGNIZE",
  "MEASURES",
  "ONE ROW PER MATCH",
  "ALL ROWS PER MATCH",
  "AFTER MATCH",
  "PATTERN",
  "SUBSET",
  "DEFINE"
]), r5 = re([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "ADD COLUMN [IF NOT EXISTS]",
  "DROP COLUMN [IF EXISTS]",
  "RENAME COLUMN [IF EXISTS]",
  "RENAME TO",
  "SET AUTHORIZATION [USER | ROLE]",
  "SET PROPERTIES",
  "EXECUTE",
  // - truncate:
  "TRUNCATE TABLE",
  // other
  "ALTER SCHEMA",
  "ALTER MATERIALIZED VIEW",
  "ALTER VIEW",
  "CREATE SCHEMA",
  "CREATE ROLE",
  "DROP SCHEMA",
  "DROP MATERIALIZED VIEW",
  "DROP VIEW",
  "DROP ROLE",
  // Auxiliary
  "EXPLAIN",
  "ANALYZE",
  "EXPLAIN ANALYZE",
  "EXPLAIN ANALYZE VERBOSE",
  "USE",
  "COMMENT ON TABLE",
  "COMMENT ON COLUMN",
  "DESCRIBE INPUT",
  "DESCRIBE OUTPUT",
  "REFRESH MATERIALIZED VIEW",
  "RESET SESSION",
  "SET SESSION",
  "SET PATH",
  "SET TIME ZONE",
  "SHOW GRANTS",
  "SHOW CREATE TABLE",
  "SHOW CREATE SCHEMA",
  "SHOW CREATE VIEW",
  "SHOW CREATE MATERIALIZED VIEW",
  "SHOW TABLES",
  "SHOW SCHEMAS",
  "SHOW CATALOGS",
  "SHOW COLUMNS",
  "SHOW STATS FOR",
  "SHOW ROLES",
  "SHOW CURRENT ROLES",
  "SHOW ROLE GRANTS",
  "SHOW FUNCTIONS",
  "SHOW SESSION"
]), $Ue = re(["UNION [ALL | DISTINCT]", "EXCEPT [ALL | DISTINCT]", "INTERSECT [ALL | DISTINCT]"]), VUe = re(["JOIN", "{LEFT | RIGHT | FULL} [OUTER] JOIN", "{INNER | CROSS} JOIN", "NATURAL [INNER] JOIN", "NATURAL {LEFT | RIGHT | FULL} [OUTER] JOIN"]), GUe = re([
  "{ROWS | RANGE | GROUPS} BETWEEN",
  // comparison operator
  "IS [NOT] DISTINCT FROM"
]), BUe = {
  tokenizerOptions: {
    reservedSelect: QUe,
    reservedClauses: [...UUe, ...r5],
    reservedSetOperations: $Ue,
    reservedJoins: VUe,
    reservedPhrases: GUe,
    reservedKeywords: kUe,
    reservedFunctionNames: MUe,
    // Trino also supports {- ... -} parenthesis.
    // The formatting of these currently works out as a result of { and -
    // not getting a space added in-between.
    // https://trino.io/docs/current/sql/match-recognize.html#row-pattern-syntax
    extraParens: ["[]", "{}"],
    // https://trino.io/docs/current/language/types.html#string
    // https://trino.io/docs/current/language/types.html#varbinary
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["U&"]
    }, {
      quote: "''-raw",
      prefixes: ["X"],
      requirePrefix: !0
    }],
    // https://trino.io/docs/current/language/reserved.html
    identTypes: ['""-qq'],
    paramTypes: {
      positional: !0
    },
    operators: [
      "%",
      "->",
      "=>",
      ":",
      "||",
      // Row pattern syntax
      "|",
      "^",
      "$"
      // '?', conflicts with positional placeholders
    ]
  },
  formatOptions: {
    onelineClauses: r5
  }
}, FUe = wt({
  // https://docs.microsoft.com/en-us/sql/t-sql/functions/functions?view=sql-server-ver15
  aggregate: ["APPROX_COUNT_DISTINCT", "AVG", "CHECKSUM_AGG", "COUNT", "COUNT_BIG", "GROUPING", "GROUPING_ID", "MAX", "MIN", "STDEV", "STDEVP", "SUM", "VAR", "VARP"],
  analytic: ["CUME_DIST", "FIRST_VALUE", "LAG", "LAST_VALUE", "LEAD", "PERCENTILE_CONT", "PERCENTILE_DISC", "PERCENT_RANK", "Collation - COLLATIONPROPERTY", "Collation - TERTIARY_WEIGHTS"],
  configuration: ["@@DBTS", "@@LANGID", "@@LANGUAGE", "@@LOCK_TIMEOUT", "@@MAX_CONNECTIONS", "@@MAX_PRECISION", "@@NESTLEVEL", "@@OPTIONS", "@@REMSERVER", "@@SERVERNAME", "@@SERVICENAME", "@@SPID", "@@TEXTSIZE", "@@VERSION"],
  conversion: ["CAST", "CONVERT", "PARSE", "TRY_CAST", "TRY_CONVERT", "TRY_PARSE"],
  cryptographic: ["ASYMKEY_ID", "ASYMKEYPROPERTY", "CERTPROPERTY", "CERT_ID", "CRYPT_GEN_RANDOM", "DECRYPTBYASYMKEY", "DECRYPTBYCERT", "DECRYPTBYKEY", "DECRYPTBYKEYAUTOASYMKEY", "DECRYPTBYKEYAUTOCERT", "DECRYPTBYPASSPHRASE", "ENCRYPTBYASYMKEY", "ENCRYPTBYCERT", "ENCRYPTBYKEY", "ENCRYPTBYPASSPHRASE", "HASHBYTES", "IS_OBJECTSIGNED", "KEY_GUID", "KEY_ID", "KEY_NAME", "SIGNBYASYMKEY", "SIGNBYCERT", "SYMKEYPROPERTY", "VERIFYSIGNEDBYCERT", "VERIFYSIGNEDBYASYMKEY"],
  cursor: ["@@CURSOR_ROWS", "@@FETCH_STATUS", "CURSOR_STATUS"],
  dataType: ["DATALENGTH", "IDENT_CURRENT", "IDENT_INCR", "IDENT_SEED", "IDENTITY", "SQL_VARIANT_PROPERTY"],
  datetime: ["@@DATEFIRST", "CURRENT_TIMESTAMP", "CURRENT_TIMEZONE", "CURRENT_TIMEZONE_ID", "DATEADD", "DATEDIFF", "DATEDIFF_BIG", "DATEFROMPARTS", "DATENAME", "DATEPART", "DATETIME2FROMPARTS", "DATETIMEFROMPARTS", "DATETIMEOFFSETFROMPARTS", "DAY", "EOMONTH", "GETDATE", "GETUTCDATE", "ISDATE", "MONTH", "SMALLDATETIMEFROMPARTS", "SWITCHOFFSET", "SYSDATETIME", "SYSDATETIMEOFFSET", "SYSUTCDATETIME", "TIMEFROMPARTS", "TODATETIMEOFFSET", "YEAR", "JSON", "ISJSON", "JSON_VALUE", "JSON_QUERY", "JSON_MODIFY"],
  mathematical: ["ABS", "ACOS", "ASIN", "ATAN", "ATN2", "CEILING", "COS", "COT", "DEGREES", "EXP", "FLOOR", "LOG", "LOG10", "PI", "POWER", "RADIANS", "RAND", "ROUND", "SIGN", "SIN", "SQRT", "SQUARE", "TAN", "CHOOSE", "GREATEST", "IIF", "LEAST"],
  metadata: ["@@PROCID", "APP_NAME", "APPLOCK_MODE", "APPLOCK_TEST", "ASSEMBLYPROPERTY", "COL_LENGTH", "COL_NAME", "COLUMNPROPERTY", "DATABASEPROPERTYEX", "DB_ID", "DB_NAME", "FILE_ID", "FILE_IDEX", "FILE_NAME", "FILEGROUP_ID", "FILEGROUP_NAME", "FILEGROUPPROPERTY", "FILEPROPERTY", "FILEPROPERTYEX", "FULLTEXTCATALOGPROPERTY", "FULLTEXTSERVICEPROPERTY", "INDEX_COL", "INDEXKEY_PROPERTY", "INDEXPROPERTY", "NEXT VALUE FOR", "OBJECT_DEFINITION", "OBJECT_ID", "OBJECT_NAME", "OBJECT_SCHEMA_NAME", "OBJECTPROPERTY", "OBJECTPROPERTYEX", "ORIGINAL_DB_NAME", "PARSENAME", "SCHEMA_ID", "SCHEMA_NAME", "SCOPE_IDENTITY", "SERVERPROPERTY", "STATS_DATE", "TYPE_ID", "TYPE_NAME", "TYPEPROPERTY"],
  ranking: ["DENSE_RANK", "NTILE", "RANK", "ROW_NUMBER", "PUBLISHINGSERVERNAME"],
  security: ["CERTENCODED", "CERTPRIVATEKEY", "CURRENT_USER", "DATABASE_PRINCIPAL_ID", "HAS_DBACCESS", "HAS_PERMS_BY_NAME", "IS_MEMBER", "IS_ROLEMEMBER", "IS_SRVROLEMEMBER", "LOGINPROPERTY", "ORIGINAL_LOGIN", "PERMISSIONS", "PWDENCRYPT", "PWDCOMPARE", "SESSION_USER", "SESSIONPROPERTY", "SUSER_ID", "SUSER_NAME", "SUSER_SID", "SUSER_SNAME", "SYSTEM_USER", "USER", "USER_ID", "USER_NAME"],
  string: ["ASCII", "CHAR", "CHARINDEX", "CONCAT", "CONCAT_WS", "DIFFERENCE", "FORMAT", "LEFT", "LEN", "LOWER", "LTRIM", "NCHAR", "PATINDEX", "QUOTENAME", "REPLACE", "REPLICATE", "REVERSE", "RIGHT", "RTRIM", "SOUNDEX", "SPACE", "STR", "STRING_AGG", "STRING_ESCAPE", "STUFF", "SUBSTRING", "TRANSLATE", "TRIM", "UNICODE", "UPPER"],
  system: ["$PARTITION", "@@ERROR", "@@IDENTITY", "@@PACK_RECEIVED", "@@ROWCOUNT", "@@TRANCOUNT", "BINARY_CHECKSUM", "CHECKSUM", "COMPRESS", "CONNECTIONPROPERTY", "CONTEXT_INFO", "CURRENT_REQUEST_ID", "CURRENT_TRANSACTION_ID", "DECOMPRESS", "ERROR_LINE", "ERROR_MESSAGE", "ERROR_NUMBER", "ERROR_PROCEDURE", "ERROR_SEVERITY", "ERROR_STATE", "FORMATMESSAGE", "GET_FILESTREAM_TRANSACTION_CONTEXT", "GETANSINULL", "HOST_ID", "HOST_NAME", "ISNULL", "ISNUMERIC", "MIN_ACTIVE_ROWVERSION", "NEWID", "NEWSEQUENTIALID", "ROWCOUNT_BIG", "SESSION_CONTEXT", "XACT_STATE"],
  statistical: ["@@CONNECTIONS", "@@CPU_BUSY", "@@IDLE", "@@IO_BUSY", "@@PACK_SENT", "@@PACKET_ERRORS", "@@TIMETICKS", "@@TOTAL_ERRORS", "@@TOTAL_READ", "@@TOTAL_WRITE", "TEXTPTR", "TEXTVALID"],
  trigger: ["COLUMNS_UPDATED", "EVENTDATA", "TRIGGER_NESTLEVEL", "UPDATE"],
  // Shorthand functions to use in place of CASE expression
  caseAbbrev: ["COALESCE", "NULLIF"],
  // Parameterized types
  // https://docs.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver15
  dataTypes: ["DECIMAL", "NUMERIC", "FLOAT", "REAL", "DATETIME2", "DATETIMEOFFSET", "TIME", "CHAR", "VARCHAR", "NCHAR", "NVARCHAR", "BINARY", "VARBINARY"]
}), XUe = wt({
  // https://docs.microsoft.com/en-us/sql/t-sql/language-elements/reserved-keywords-transact-sql?view=sql-server-ver15
  standard: ["ADD", "ALL", "ALTER", "AND", "ANY", "AS", "ASC", "AUTHORIZATION", "BACKUP", "BEGIN", "BETWEEN", "BREAK", "BROWSE", "BULK", "BY", "CASCADE", "CHECK", "CHECKPOINT", "CLOSE", "CLUSTERED", "COALESCE", "COLLATE", "COLUMN", "COMMIT", "COMPUTE", "CONSTRAINT", "CONTAINS", "CONTAINSTABLE", "CONTINUE", "CONVERT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATABASE", "DBCC", "DEALLOCATE", "DECLARE", "DEFAULT", "DELETE", "DENY", "DESC", "DISK", "DISTINCT", "DISTRIBUTED", "DOUBLE", "DROP", "DUMP", "ERRLVL", "ESCAPE", "EXEC", "EXECUTE", "EXISTS", "EXIT", "EXTERNAL", "FETCH", "FILE", "FILLFACTOR", "FOR", "FOREIGN", "FREETEXT", "FREETEXTTABLE", "FROM", "FULL", "FUNCTION", "GOTO", "GRANT", "GROUP", "HAVING", "HOLDLOCK", "IDENTITY", "IDENTITYCOL", "IDENTITY_INSERT", "IF", "IN", "INDEX", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "JOIN", "KEY", "KILL", "LEFT", "LIKE", "LINENO", "LOAD", "MERGE", "NATIONAL", "NOCHECK", "NONCLUSTERED", "NOT", "NULL", "NULLIF", "OF", "OFF", "OFFSETS", "ON", "OPEN", "OPENDATASOURCE", "OPENQUERY", "OPENROWSET", "OPENXML", "OPTION", "OR", "ORDER", "OUTER", "OVER", "PERCENT", "PIVOT", "PLAN", "PRECISION", "PRIMARY", "PRINT", "PROC", "PROCEDURE", "PUBLIC", "RAISERROR", "READ", "READTEXT", "RECONFIGURE", "REFERENCES", "REPLICATION", "RESTORE", "RESTRICT", "RETURN", "REVERT", "REVOKE", "RIGHT", "ROLLBACK", "ROWCOUNT", "ROWGUIDCOL", "RULE", "SAVE", "SCHEMA", "SECURITYAUDIT", "SELECT", "SEMANTICKEYPHRASETABLE", "SEMANTICSIMILARITYDETAILSTABLE", "SEMANTICSIMILARITYTABLE", "SESSION_USER", "SET", "SETUSER", "SHUTDOWN", "SOME", "STATISTICS", "SYSTEM_USER", "TABLE", "TABLESAMPLE", "TEXTSIZE", "THEN", "TO", "TOP", "TRAN", "TRANSACTION", "TRIGGER", "TRUNCATE", "TRY_CONVERT", "TSEQUAL", "UNION", "UNIQUE", "UNPIVOT", "UPDATE", "UPDATETEXT", "USE", "USER", "VALUES", "VARYING", "VIEW", "WAITFOR", "WHERE", "WHILE", "WITH", "WITHIN GROUP", "WRITETEXT"],
  odbc: ["ABSOLUTE", "ACTION", "ADA", "ADD", "ALL", "ALLOCATE", "ALTER", "AND", "ANY", "ARE", "AS", "ASC", "ASSERTION", "AT", "AUTHORIZATION", "AVG", "BEGIN", "BETWEEN", "BIT", "BIT_LENGTH", "BOTH", "BY", "CASCADE", "CASCADED", "CAST", "CATALOG", "CHAR", "CHARACTER", "CHARACTER_LENGTH", "CHAR_LENGTH", "CHECK", "CLOSE", "COALESCE", "COLLATE", "COLLATION", "COLUMN", "COMMIT", "CONNECT", "CONNECTION", "CONSTRAINT", "CONSTRAINTS", "CONTINUE", "CONVERT", "CORRESPONDING", "COUNT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "DATE", "DAY", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFERRABLE", "DEFERRED", "DELETE", "DESC", "DESCRIBE", "DESCRIPTOR", "DIAGNOSTICS", "DISCONNECT", "DISTINCT", "DOMAIN", "DOUBLE", "DROP", "END-EXEC", "ESCAPE", "EXCEPTION", "EXEC", "EXECUTE", "EXISTS", "EXTERNAL", "EXTRACT", "FALSE", "FETCH", "FIRST", "FLOAT", "FOR", "FOREIGN", "FORTRAN", "FOUND", "FROM", "FULL", "GET", "GLOBAL", "GO", "GOTO", "GRANT", "GROUP", "HAVING", "HOUR", "IDENTITY", "IMMEDIATE", "IN", "INCLUDE", "INDEX", "INDICATOR", "INITIALLY", "INNER", "INPUT", "INSENSITIVE", "INSERT", "INT", "INTEGER", "INTERSECT", "INTERVAL", "INTO", "IS", "ISOLATION", "JOIN", "KEY", "LANGUAGE", "LAST", "LEADING", "LEFT", "LEVEL", "LIKE", "LOCAL", "LOWER", "MATCH", "MAX", "MIN", "MINUTE", "MODULE", "MONTH", "NAMES", "NATIONAL", "NATURAL", "NCHAR", "NEXT", "NO", "NONE", "NOT", "NULL", "NULLIF", "NUMERIC", "OCTET_LENGTH", "OF", "ONLY", "OPEN", "OPTION", "OR", "ORDER", "OUTER", "OUTPUT", "OVERLAPS", "PAD", "PARTIAL", "PASCAL", "POSITION", "PRECISION", "PREPARE", "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURE", "PUBLIC", "READ", "REAL", "REFERENCES", "RELATIVE", "RESTRICT", "REVOKE", "RIGHT", "ROLLBACK", "ROWS", "SCHEMA", "SCROLL", "SECOND", "SECTION", "SELECT", "SESSION", "SESSION_USER", "SET", "SIZE", "SMALLINT", "SOME", "SPACE", "SQL", "SQLCA", "SQLCODE", "SQLERROR", "SQLSTATE", "SQLWARNING", "SUBSTRING", "SUM", "SYSTEM_USER", "TABLE", "TEMPORARY", "TIME", "TIMESTAMP", "TIMEZONE_HOUR", "TIMEZONE_MINUTE", "TO", "TRAILING", "TRANSACTION", "TRANSLATE", "TRANSLATION", "TRIM", "TRUE", "UNION", "UNIQUE", "UNKNOWN", "UPDATE", "UPPER", "USAGE", "USER", "VALUE", "VALUES", "VARCHAR", "VARYING", "VIEW", "WHENEVER", "WHERE", "WITH", "WORK", "WRITE", "YEAR", "ZONE"]
}), YUe = re(["SELECT [ALL | DISTINCT]"]), HUe = re([
  // queries
  "WITH",
  "INTO",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "WINDOW",
  "PARTITION BY",
  "ORDER BY",
  "OFFSET",
  "FETCH {FIRST | NEXT}",
  // Data manipulation
  // - insert:
  "INSERT [INTO]",
  "VALUES",
  // - update:
  "SET",
  // - merge:
  "MERGE [INTO]",
  "WHEN [NOT] MATCHED [BY TARGET | BY SOURCE] [THEN]",
  "UPDATE SET",
  // Data definition
  "CREATE [OR ALTER] [MATERIALIZED] VIEW",
  "CREATE TABLE",
  "CREATE [OR ALTER] {PROC | PROCEDURE}"
]), i5 = re([
  // - update:
  "UPDATE",
  "WHERE CURRENT OF",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE",
  "ADD",
  "DROP COLUMN [IF EXISTS]",
  "ALTER COLUMN",
  // - truncate:
  "TRUNCATE TABLE",
  // https://docs.microsoft.com/en-us/sql/t-sql/statements/statements?view=sql-server-ver15
  "ADD SENSITIVITY CLASSIFICATION",
  "ADD SIGNATURE",
  "AGGREGATE",
  "ANSI_DEFAULTS",
  "ANSI_NULLS",
  "ANSI_NULL_DFLT_OFF",
  "ANSI_NULL_DFLT_ON",
  "ANSI_PADDING",
  "ANSI_WARNINGS",
  "APPLICATION ROLE",
  "ARITHABORT",
  "ARITHIGNORE",
  "ASSEMBLY",
  "ASYMMETRIC KEY",
  "AUTHORIZATION",
  "AVAILABILITY GROUP",
  "BACKUP",
  "BACKUP CERTIFICATE",
  "BACKUP MASTER KEY",
  "BACKUP SERVICE MASTER KEY",
  "BEGIN CONVERSATION TIMER",
  "BEGIN DIALOG CONVERSATION",
  "BROKER PRIORITY",
  "BULK INSERT",
  "CERTIFICATE",
  "CLOSE MASTER KEY",
  "CLOSE SYMMETRIC KEY",
  "COLLATE",
  "COLUMN ENCRYPTION KEY",
  "COLUMN MASTER KEY",
  "COLUMNSTORE INDEX",
  "CONCAT_NULL_YIELDS_NULL",
  "CONTEXT_INFO",
  "CONTRACT",
  "CREDENTIAL",
  "CRYPTOGRAPHIC PROVIDER",
  "CURSOR_CLOSE_ON_COMMIT",
  "DATABASE",
  "DATABASE AUDIT SPECIFICATION",
  "DATABASE ENCRYPTION KEY",
  "DATABASE HADR",
  "DATABASE SCOPED CONFIGURATION",
  "DATABASE SCOPED CREDENTIAL",
  "DATABASE SET",
  "DATEFIRST",
  "DATEFORMAT",
  "DEADLOCK_PRIORITY",
  "DENY",
  "DENY XML",
  "DISABLE TRIGGER",
  "ENABLE TRIGGER",
  "END CONVERSATION",
  "ENDPOINT",
  "EVENT NOTIFICATION",
  "EVENT SESSION",
  "EXECUTE AS",
  "EXTERNAL DATA SOURCE",
  "EXTERNAL FILE FORMAT",
  "EXTERNAL LANGUAGE",
  "EXTERNAL LIBRARY",
  "EXTERNAL RESOURCE POOL",
  "EXTERNAL TABLE",
  "FIPS_FLAGGER",
  "FMTONLY",
  "FORCEPLAN",
  "FULLTEXT CATALOG",
  "FULLTEXT INDEX",
  "FULLTEXT STOPLIST",
  "FUNCTION",
  "GET CONVERSATION GROUP",
  "GET_TRANSMISSION_STATUS",
  "GRANT",
  "GRANT XML",
  "IDENTITY_INSERT",
  "IMPLICIT_TRANSACTIONS",
  "INDEX",
  "LANGUAGE",
  "LOCK_TIMEOUT",
  "LOGIN",
  "MASTER KEY",
  "MESSAGE TYPE",
  "MOVE CONVERSATION",
  "NOCOUNT",
  "NOEXEC",
  "NUMERIC_ROUNDABORT",
  "OFFSETS",
  "OPEN MASTER KEY",
  "OPEN SYMMETRIC KEY",
  "PARSEONLY",
  "PARTITION FUNCTION",
  "PARTITION SCHEME",
  "PROCEDURE",
  "QUERY_GOVERNOR_COST_LIMIT",
  "QUEUE",
  "QUOTED_IDENTIFIER",
  "RECEIVE",
  "REMOTE SERVICE BINDING",
  "REMOTE_PROC_TRANSACTIONS",
  "RESOURCE GOVERNOR",
  "RESOURCE POOL",
  "RESTORE",
  "RESTORE FILELISTONLY",
  "RESTORE HEADERONLY",
  "RESTORE LABELONLY",
  "RESTORE MASTER KEY",
  "RESTORE REWINDONLY",
  "RESTORE SERVICE MASTER KEY",
  "RESTORE VERIFYONLY",
  "REVERT",
  "REVOKE",
  "REVOKE XML",
  "ROLE",
  "ROUTE",
  "ROWCOUNT",
  "RULE",
  "SCHEMA",
  "SEARCH PROPERTY LIST",
  "SECURITY POLICY",
  "SELECTIVE XML INDEX",
  "SEND",
  "SENSITIVITY CLASSIFICATION",
  "SEQUENCE",
  "SERVER AUDIT",
  "SERVER AUDIT SPECIFICATION",
  "SERVER CONFIGURATION",
  "SERVER ROLE",
  "SERVICE",
  "SERVICE MASTER KEY",
  "SETUSER",
  "SHOWPLAN_ALL",
  "SHOWPLAN_TEXT",
  "SHOWPLAN_XML",
  "SIGNATURE",
  "SPATIAL INDEX",
  "STATISTICS",
  "STATISTICS IO",
  "STATISTICS PROFILE",
  "STATISTICS TIME",
  "STATISTICS XML",
  "SYMMETRIC KEY",
  "SYNONYM",
  "TABLE",
  "TABLE IDENTITY",
  "TEXTSIZE",
  "TRANSACTION ISOLATION LEVEL",
  "TRIGGER",
  "TYPE",
  "UPDATE STATISTICS",
  "USER",
  "WORKLOAD GROUP",
  "XACT_ABORT",
  "XML INDEX",
  "XML SCHEMA COLLECTION"
]), WUe = re(["UNION [ALL]", "EXCEPT", "INTERSECT"]), zUe = re([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  // non-standard joins
  "{CROSS | OUTER} APPLY"
]), ZUe = re(["ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]", "{ROWS | RANGE} BETWEEN"]), qUe = {
  tokenizerOptions: {
    reservedSelect: YUe,
    reservedClauses: [...HUe, ...i5],
    reservedSetOperations: WUe,
    reservedJoins: zUe,
    reservedPhrases: ZUe,
    reservedKeywords: XUe,
    reservedFunctionNames: FUe,
    nestedBlockComments: !0,
    stringTypes: [{
      quote: "''-qq",
      prefixes: ["N"]
    }],
    identTypes: ['""-qq', "[]"],
    identChars: {
      first: "#@",
      rest: "#@$"
    },
    paramTypes: {
      named: ["@"],
      quoted: ["@"]
    },
    operators: ["%", "&", "|", "^", "~", "!<", "!>", "+=", "-=", "*=", "/=", "%=", "|=", "&=", "^=", "::"]
    // TODO: Support for money constants
  },
  formatOptions: {
    alwaysDenseOperators: ["::"],
    onelineClauses: i5
  }
}, jUe = wt({
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/restricted-keywords/list-of-restricted-keywords.html
  all: ["ABORT", "ABSOLUTE", "ACCESS", "ACCESSIBLE", "ACCOUNT", "ACTION", "ACTIVE", "ADD", "ADMIN", "AFTER", "AGAINST", "AGGREGATE", "AGGREGATES", "AGGREGATOR", "AGGREGATOR_ID", "AGGREGATOR_PLAN_HASH", "AGGREGATORS", "ALGORITHM", "ALL", "ALSO", "ALTER", "ALWAYS", "ANALYZE", "AND", "ANY", "ARGHISTORY", "ARRANGE", "ARRANGEMENT", "ARRAY", "AS", "ASC", "ASCII", "ASENSITIVE", "ASM", "ASSERTION", "ASSIGNMENT", "AST", "ASYMMETRIC", "ASYNC", "AT", "ATTACH", "ATTRIBUTE", "AUTHORIZATION", "AUTO", "AUTO_INCREMENT", "AUTO_REPROVISION", "AUTOSTATS", "AUTOSTATS_CARDINALITY_MODE", "AUTOSTATS_ENABLED", "AUTOSTATS_HISTOGRAM_MODE", "AUTOSTATS_SAMPLING", "AVAILABILITY", "AVG", "AVG_ROW_LENGTH", "AVRO", "AZURE", "BACKGROUND", "_BACKGROUND_THREADS_FOR_CLEANUP", "BACKUP", "BACKUP_HISTORY", "BACKUP_ID", "BACKWARD", "BATCH", "BATCHES", "BATCH_INTERVAL", "_BATCH_SIZE_LIMIT", "BEFORE", "BEGIN", "BETWEEN", "BIGINT", "BINARY", "_BINARY", "BIT", "BLOB", "BOOL", "BOOLEAN", "BOOTSTRAP", "BOTH", "_BT", "BTREE", "BUCKET_COUNT", "BUCKETS", "BY", "BYTE", "BYTE_LENGTH", "CACHE", "CALL", "CALL_FOR_PIPELINE", "CALLED", "CAPTURE", "CASCADE", "CASCADED", "CASE", "CATALOG", "CHAIN", "CHANGE", "CHAR", "CHARACTER", "CHARACTERISTICS", "CHARSET", "CHECK", "CHECKPOINT", "_CHECK_CAN_CONNECT", "_CHECK_CONSISTENCY", "CHECKSUM", "_CHECKSUM", "CLASS", "CLEAR", "CLIENT", "CLIENT_FOUND_ROWS", "CLOSE", "CLUSTER", "CLUSTERED", "CNF", "COALESCE", "COLLATE", "COLLATION", "COLUMN", "COLUMNAR", "COLUMNS", "COLUMNSTORE", "COLUMNSTORE_SEGMENT_ROWS", "COMMENT", "COMMENTS", "COMMIT", "COMMITTED", "_COMMIT_LOG_TAIL", "COMPACT", "COMPILE", "COMPRESSED", "COMPRESSION", "CONCURRENT", "CONCURRENTLY", "CONDITION", "CONFIGURATION", "CONNECTION", "CONNECTIONS", "CONFIG", "CONSTRAINT", "CONTAINS", "CONTENT", "CONTINUE", "_CONTINUE_REPLAY", "CONVERSION", "CONVERT", "COPY", "_CORE", "COST", "CREATE", "CREDENTIALS", "CROSS", "CUBE", "CSV", "CUME_DIST", "CURRENT", "CURRENT_CATALOG", "CURRENT_DATE", "CURRENT_SCHEMA", "CURRENT_SECURITY_GROUPS", "CURRENT_SECURITY_ROLES", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "CURSOR", "CYCLE", "DATA", "DATABASE", "DATABASES", "DATE", "DATETIME", "DAY", "DAY_HOUR", "DAY_MICROSECOND", "DAY_MINUTE", "DAY_SECOND", "DEALLOCATE", "DEC", "DECIMAL", "DECLARE", "DEFAULT", "DEFAULTS", "DEFERRABLE", "DEFERRED", "DEFINED", "DEFINER", "DELAYED", "DELAY_KEY_WRITE", "DELETE", "DELIMITER", "DELIMITERS", "DENSE_RANK", "DESC", "DESCRIBE", "DETACH", "DETERMINISTIC", "DICTIONARY", "DIFFERENTIAL", "DIRECTORY", "DISABLE", "DISCARD", "_DISCONNECT", "DISK", "DISTINCT", "DISTINCTROW", "DISTRIBUTED_JOINS", "DIV", "DO", "DOCUMENT", "DOMAIN", "DOUBLE", "DROP", "_DROP_PROFILE", "DUAL", "DUMP", "DUPLICATE", "DURABILITY", "DYNAMIC", "EARLIEST", "EACH", "ECHO", "ELECTION", "ELSE", "ELSEIF", "ENABLE", "ENCLOSED", "ENCODING", "ENCRYPTED", "END", "ENGINE", "ENGINES", "ENUM", "ERRORS", "ESCAPE", "ESCAPED", "ESTIMATE", "EVENT", "EVENTS", "EXCEPT", "EXCLUDE", "EXCLUDING", "EXCLUSIVE", "EXECUTE", "EXISTS", "EXIT", "EXPLAIN", "EXTENDED", "EXTENSION", "EXTERNAL", "EXTERNAL_HOST", "EXTERNAL_PORT", "EXTRACTOR", "EXTRACTORS", "EXTRA_JOIN", "_FAILOVER", "FAILED_LOGIN_ATTEMPTS", "FAILURE", "FALSE", "FAMILY", "FAULT", "FETCH", "FIELDS", "FILE", "FILES", "FILL", "FIX_ALTER", "FIXED", "FLOAT", "FLOAT4", "FLOAT8", "FLUSH", "FOLLOWING", "FOR", "FORCE", "FORCE_COMPILED_MODE", "FORCE_INTERPRETER_MODE", "FOREGROUND", "FOREIGN", "FORMAT", "FORWARD", "FREEZE", "FROM", "FS", "_FSYNC", "FULL", "FULLTEXT", "FUNCTION", "FUNCTIONS", "GC", "GCS", "GET_FORMAT", "_GC", "_GCX", "GENERATE", "GEOGRAPHY", "GEOGRAPHYPOINT", "GEOMETRY", "GEOMETRYPOINT", "GLOBAL", "_GLOBAL_VERSION_TIMESTAMP", "GRANT", "GRANTED", "GRANTS", "GROUP", "GROUPING", "GROUPS", "GZIP", "HANDLE", "HANDLER", "HARD_CPU_LIMIT_PERCENTAGE", "HASH", "HAS_TEMP_TABLES", "HAVING", "HDFS", "HEADER", "HEARTBEAT_NO_LOGGING", "HIGH_PRIORITY", "HISTOGRAM", "HOLD", "HOLDING", "HOST", "HOSTS", "HOUR", "HOUR_MICROSECOND", "HOUR_MINUTE", "HOUR_SECOND", "IDENTIFIED", "IDENTITY", "IF", "IGNORE", "ILIKE", "IMMEDIATE", "IMMUTABLE", "IMPLICIT", "IMPORT", "IN", "INCLUDING", "INCREMENT", "INCREMENTAL", "INDEX", "INDEXES", "INFILE", "INHERIT", "INHERITS", "_INIT_PROFILE", "INIT", "INITIALIZE", "INITIALLY", "INJECT", "INLINE", "INNER", "INOUT", "INPUT", "INSENSITIVE", "INSERT", "INSERT_METHOD", "INSTANCE", "INSTEAD", "IN", "INT", "INT1", "INT2", "INT3", "INT4", "INT8", "INTEGER", "_INTERNAL_DYNAMIC_TYPECAST", "INTERPRETER_MODE", "INTERSECT", "INTERVAL", "INTO", "INVOKER", "ISOLATION", "ITERATE", "JOIN", "JSON", "KAFKA", "KEY", "KEY_BLOCK_SIZE", "KEYS", "KILL", "KILLALL", "LABEL", "LAG", "LANGUAGE", "LARGE", "LAST", "LAST_VALUE", "LATERAL", "LATEST", "LC_COLLATE", "LC_CTYPE", "LEAD", "LEADING", "LEAF", "LEAKPROOF", "LEAVE", "LEAVES", "LEFT", "LEVEL", "LICENSE", "LIKE", "LIMIT", "LINES", "LISTEN", "LLVM", "LOADDATA_WHERE", "LOAD", "LOCAL", "LOCALTIME", "LOCALTIMESTAMP", "LOCATION", "LOCK", "LONG", "LONGBLOB", "LONGTEXT", "LOOP", "LOW_PRIORITY", "_LS", "LZ4", "MANAGEMENT", "_MANAGEMENT_THREAD", "MAPPING", "MASTER", "MATCH", "MATERIALIZED", "MAXVALUE", "MAX_CONCURRENCY", "MAX_ERRORS", "MAX_PARTITIONS_PER_BATCH", "MAX_QUEUE_DEPTH", "MAX_RETRIES_PER_BATCH_PARTITION", "MAX_ROWS", "MBC", "MPL", "MEDIUMBLOB", "MEDIUMINT", "MEDIUMTEXT", "MEMBER", "MEMORY", "MEMORY_PERCENTAGE", "_MEMSQL_TABLE_ID_LOOKUP", "MEMSQL", "MEMSQL_DESERIALIZE", "MEMSQL_IMITATING_KAFKA", "MEMSQL_SERIALIZE", "MERGE", "METADATA", "MICROSECOND", "MIDDLEINT", "MIN_ROWS", "MINUS", "MINUTE_MICROSECOND", "MINUTE_SECOND", "MINVALUE", "MOD", "MODE", "MODEL", "MODIFIES", "MODIFY", "MONTH", "MOVE", "MPL", "NAMES", "NAMED", "NAMESPACE", "NATIONAL", "NATURAL", "NCHAR", "NEXT", "NO", "NODE", "NONE", "NO_QUERY_REWRITE", "NOPARAM", "NOT", "NOTHING", "NOTIFY", "NOWAIT", "NO_WRITE_TO_BINLOG", "NO_QUERY_REWRITE", "NORELY", "NTH_VALUE", "NTILE", "NULL", "NULLCOLS", "NULLS", "NUMERIC", "NVARCHAR", "OBJECT", "OF", "OFF", "OFFLINE", "OFFSET", "OFFSETS", "OIDS", "ON", "ONLINE", "ONLY", "OPEN", "OPERATOR", "OPTIMIZATION", "OPTIMIZE", "OPTIMIZER", "OPTIMIZER_STATE", "OPTION", "OPTIONS", "OPTIONALLY", "OR", "ORDER", "ORDERED_SERIALIZE", "ORPHAN", "OUT", "OUT_OF_ORDER", "OUTER", "OUTFILE", "OVER", "OVERLAPS", "OVERLAY", "OWNED", "OWNER", "PACK_KEYS", "PAIRED", "PARSER", "PARQUET", "PARTIAL", "PARTITION", "PARTITION_ID", "PARTITIONING", "PARTITIONS", "PASSING", "PASSWORD", "PASSWORD_LOCK_TIME", "PAUSE", "_PAUSE_REPLAY", "PERIODIC", "PERSISTED", "PIPELINE", "PIPELINES", "PLACING", "PLAN", "PLANS", "PLANCACHE", "PLUGINS", "POOL", "POOLS", "PORT", "PRECEDING", "PRECISION", "PREPARE", "PRESERVE", "PRIMARY", "PRIOR", "PRIVILEGES", "PROCEDURAL", "PROCEDURE", "PROCEDURES", "PROCESS", "PROCESSLIST", "PROFILE", "PROFILES", "PROGRAM", "PROMOTE", "PROXY", "PURGE", "QUARTER", "QUERIES", "QUERY", "QUERY_TIMEOUT", "QUEUE", "RANGE", "RANK", "READ", "_READ", "READS", "REAL", "REASSIGN", "REBALANCE", "RECHECK", "RECORD", "RECURSIVE", "REDUNDANCY", "REDUNDANT", "REF", "REFERENCE", "REFERENCES", "REFRESH", "REGEXP", "REINDEX", "RELATIVE", "RELEASE", "RELOAD", "RELY", "REMOTE", "REMOVE", "RENAME", "REPAIR", "_REPAIR_TABLE", "REPEAT", "REPEATABLE", "_REPL", "_REPROVISIONING", "REPLACE", "REPLICA", "REPLICATE", "REPLICATING", "REPLICATION", "REQUIRE", "RESOURCE", "RESOURCE_POOL", "RESET", "RESTART", "RESTORE", "RESTRICT", "RESULT", "_RESURRECT", "RETRY", "RETURN", "RETURNING", "RETURNS", "REVERSE", "RG_POOL", "REVOKE", "RIGHT", "RIGHT_ANTI_JOIN", "RIGHT_SEMI_JOIN", "RIGHT_STRAIGHT_JOIN", "RLIKE", "ROLES", "ROLLBACK", "ROLLUP", "ROUTINE", "ROW", "ROW_COUNT", "ROW_FORMAT", "ROW_NUMBER", "ROWS", "ROWSTORE", "RULE", "_RPC", "RUNNING", "S3", "SAFE", "SAVE", "SAVEPOINT", "SCALAR", "SCHEMA", "SCHEMAS", "SCHEMA_BINDING", "SCROLL", "SEARCH", "SECOND", "SECOND_MICROSECOND", "SECURITY", "SELECT", "SEMI_JOIN", "_SEND_THREADS", "SENSITIVE", "SEPARATOR", "SEQUENCE", "SEQUENCES", "SERIAL", "SERIALIZABLE", "SERIES", "SERVICE_USER", "SERVER", "SESSION", "SESSION_USER", "SET", "SETOF", "SECURITY_LISTS_INTERSECT", "SHA", "SHARD", "SHARDED", "SHARDED_ID", "SHARE", "SHOW", "SHUTDOWN", "SIGNAL", "SIGNED", "SIMILAR", "SIMPLE", "SITE", "SKIP", "SKIPPED_BATCHES", "__SLEEP", "SMALLINT", "SNAPSHOT", "_SNAPSHOT", "_SNAPSHOTS", "SOFT_CPU_LIMIT_PERCENTAGE", "SOME", "SONAME", "SPARSE", "SPATIAL", "SPATIAL_CHECK_INDEX", "SPECIFIC", "SQL", "SQL_BIG_RESULT", "SQL_BUFFER_RESULT", "SQL_CACHE", "SQL_CALC_FOUND_ROWS", "SQLEXCEPTION", "SQL_MODE", "SQL_NO_CACHE", "SQL_NO_LOGGING", "SQL_SMALL_RESULT", "SQLSTATE", "SQLWARNING", "STDIN", "STDOUT", "STOP", "STORAGE", "STRAIGHT_JOIN", "STRICT", "STRING", "STRIP", "SUCCESS", "SUPER", "SYMMETRIC", "SYNC_SNAPSHOT", "SYNC", "_SYNC", "_SYNC2", "_SYNC_PARTITIONS", "_SYNC_SNAPSHOT", "SYNCHRONIZE", "SYSID", "SYSTEM", "TABLE", "TABLE_CHECKSUM", "TABLES", "TABLESPACE", "TAGS", "TARGET_SIZE", "TASK", "TEMP", "TEMPLATE", "TEMPORARY", "TEMPTABLE", "_TERM_BUMP", "TERMINATE", "TERMINATED", "TEXT", "THEN", "TIME", "TIMEOUT", "TIMESTAMP", "TIMESTAMPADD", "TIMESTAMPDIFF", "TIMEZONE", "TINYBLOB", "TINYINT", "TINYTEXT", "TO", "TRACELOGS", "TRADITIONAL", "TRAILING", "TRANSFORM", "TRANSACTION", "_TRANSACTIONS_EXPERIMENTAL", "TREAT", "TRIGGER", "TRIGGERS", "TRUE", "TRUNC", "TRUNCATE", "TRUSTED", "TWO_PHASE", "_TWOPCID", "TYPE", "TYPES", "UNBOUNDED", "UNCOMMITTED", "UNDEFINED", "UNDO", "UNENCRYPTED", "UNENFORCED", "UNHOLD", "UNICODE", "UNION", "UNIQUE", "_UNITTEST", "UNKNOWN", "UNLISTEN", "_UNLOAD", "UNLOCK", "UNLOGGED", "UNPIVOT", "UNSIGNED", "UNTIL", "UPDATE", "UPGRADE", "USAGE", "USE", "USER", "USERS", "USING", "UTC_DATE", "UTC_TIME", "UTC_TIMESTAMP", "_UTF8", "VACUUM", "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VALUES", "VARBINARY", "VARCHAR", "VARCHARACTER", "VARIABLES", "VARIADIC", "VARYING", "VERBOSE", "VIEW", "VOID", "VOLATILE", "VOTING", "WAIT", "_WAKE", "WARNINGS", "WEEK", "WHEN", "WHERE", "WHILE", "WHITESPACE", "WINDOW", "WITH", "WITHOUT", "WITHIN", "_WM_HEARTBEAT", "WORK", "WORKLOAD", "WRAPPER", "WRITE", "XACT_ID", "XOR", "YEAR", "YEAR_MONTH", "YES", "ZEROFILL", "ZONE"]
}), KUe = wt({
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/vector-functions/vector-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/window-functions/window-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/string-functions/string-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/conditional-functions/conditional-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/numeric-functions/numeric-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/geospatial-functions/geospatial-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/json-functions/json-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/information-functions/information-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/aggregate-functions/aggregate-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/time-series-functions/time-series-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/identifier-generation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/date-and-time-functions/date-and-time-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/distinct-count-estimation-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/full-text-search-functions/full-text-search-functions.html
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference/regular-expression-functions.html
  all: [
    "ABS",
    "ACOS",
    "ADDDATE",
    "ADDTIME",
    "AES_DECRYPT",
    "AES_ENCRYPT",
    "ANY_VALUE",
    "APPROX_COUNT_DISTINCT",
    "APPROX_COUNT_DISTINCT_ACCUMULATE",
    "APPROX_COUNT_DISTINCT_COMBINE",
    "APPROX_COUNT_DISTINCT_ESTIMATE",
    "APPROX_GEOGRAPHY_INTERSECTS",
    "APPROX_PERCENTILE",
    "ASCII",
    "ASIN",
    "ATAN",
    "ATAN2",
    "AVG",
    "BIN",
    "BINARY",
    "BIT_AND",
    "BIT_COUNT",
    "BIT_OR",
    "BIT_XOR",
    "CAST",
    "CEIL",
    "CEILING",
    "CHAR",
    "CHARACTER_LENGTH",
    "CHAR_LENGTH",
    "CHARSET",
    "COALESCE",
    "COERCIBILITY",
    "COLLATION",
    "COLLECT",
    "CONCAT",
    "CONCAT_WS",
    "CONNECTION_ID",
    "CONV",
    "CONVERT",
    "CONVERT_TZ",
    "COS",
    "COT",
    "COUNT",
    "CUME_DIST",
    "CURDATE",
    "CURRENT_DATE",
    "CURRENT_ROLE",
    "CURRENT_TIME",
    "CURRENT_TIMESTAMP",
    "CURRENT_USER",
    "CURTIME",
    "DATABASE",
    "DATE",
    "DATE_ADD",
    "DATEDIFF",
    "DATE_FORMAT",
    "DATE_SUB",
    "DATE_TRUNC",
    "DAY",
    "DAYNAME",
    "DAYOFMONTH",
    "DAYOFWEEK",
    "DAYOFYEAR",
    "DECODE",
    "DEFAULT",
    "DEGREES",
    "DENSE_RANK",
    "DIV",
    "DOT_PRODUCT",
    "ELT",
    "EUCLIDEAN_DISTANCE",
    "EXP",
    "EXTRACT",
    "FIELD",
    "FIRST",
    "FIRST_VALUE",
    "FLOOR",
    "FORMAT",
    "FOUND_ROWS",
    "FROM_BASE64",
    "FROM_DAYS",
    "FROM_UNIXTIME",
    "GEOGRAPHY_AREA",
    "GEOGRAPHY_CONTAINS",
    "GEOGRAPHY_DISTANCE",
    "GEOGRAPHY_INTERSECTS",
    "GEOGRAPHY_LATITUDE",
    "GEOGRAPHY_LENGTH",
    "GEOGRAPHY_LONGITUDE",
    "GEOGRAPHY_POINT",
    "GEOGRAPHY_WITHIN_DISTANCE",
    "GEOMETRY_AREA",
    "GEOMETRY_CONTAINS",
    "GEOMETRY_DISTANCE",
    "GEOMETRY_FILTER",
    "GEOMETRY_INTERSECTS",
    "GEOMETRY_LENGTH",
    "GEOMETRY_POINT",
    "GEOMETRY_WITHIN_DISTANCE",
    "GEOMETRY_X",
    "GEOMETRY_Y",
    "GREATEST",
    "GROUPING",
    "GROUP_CONCAT",
    "HEX",
    "HIGHLIGHT",
    "HOUR",
    "ICU_VERSION",
    "IF",
    "IFNULL",
    "INET_ATON",
    "INET_NTOA",
    "INET6_ATON",
    "INET6_NTOA",
    "INITCAP",
    "INSERT",
    "INSTR",
    "INTERVAL",
    "IS",
    "IS NULL",
    "JSON_AGG",
    "JSON_ARRAY_CONTAINS_DOUBLE",
    "JSON_ARRAY_CONTAINS_JSON",
    "JSON_ARRAY_CONTAINS_STRING",
    "JSON_ARRAY_PUSH_DOUBLE",
    "JSON_ARRAY_PUSH_JSON",
    "JSON_ARRAY_PUSH_STRING",
    "JSON_DELETE_KEY",
    "JSON_EXTRACT_DOUBLE",
    "JSON_EXTRACT_JSON",
    "JSON_EXTRACT_STRING",
    "JSON_EXTRACT_BIGINT",
    "JSON_GET_TYPE",
    "JSON_LENGTH",
    "JSON_SET_DOUBLE",
    "JSON_SET_JSON",
    "JSON_SET_STRING",
    "JSON_SPLICE_DOUBLE",
    "JSON_SPLICE_JSON",
    "JSON_SPLICE_STRING",
    "LAG",
    "LAST_DAY",
    "LAST_VALUE",
    "LCASE",
    "LEAD",
    "LEAST",
    "LEFT",
    "LENGTH",
    "LIKE",
    "LN",
    "LOCALTIME",
    "LOCALTIMESTAMP",
    "LOCATE",
    "LOG",
    "LOG10",
    "LOG2",
    "LPAD",
    "LTRIM",
    "MATCH",
    "MAX",
    "MD5",
    "MEDIAN",
    "MICROSECOND",
    "MIN",
    "MINUTE",
    "MOD",
    "MONTH",
    "MONTHNAME",
    "MONTHS_BETWEEN",
    "NOT",
    "NOW",
    "NTH_VALUE",
    "NTILE",
    "NULLIF",
    "OCTET_LENGTH",
    "PERCENT_RANK",
    "PERCENTILE_CONT",
    "PERCENTILE_DISC",
    "PI",
    "PIVOT",
    "POSITION",
    "POW",
    "POWER",
    "QUARTER",
    "QUOTE",
    "RADIANS",
    "RAND",
    "RANK",
    "REGEXP",
    "REPEAT",
    "REPLACE",
    "REVERSE",
    "RIGHT",
    "RLIKE",
    "ROUND",
    "ROW_COUNT",
    "ROW_NUMBER",
    "RPAD",
    "RTRIM",
    "SCALAR",
    "SCHEMA",
    "SEC_TO_TIME",
    "SHA1",
    "SHA2",
    "SIGMOID",
    "SIGN",
    "SIN",
    "SLEEP",
    "SPLIT",
    "SOUNDEX",
    "SOUNDS LIKE",
    "SOURCE_POS_WAIT",
    "SPACE",
    "SQRT",
    "STDDEV",
    "STDDEV_POP",
    "STDDEV_SAMP",
    "STR_TO_DATE",
    "SUBDATE",
    "SUBSTR",
    "SUBSTRING",
    "SUBSTRING_INDEX",
    "SUM",
    "SYS_GUID",
    "TAN",
    "TIME",
    "TIMEDIFF",
    "TIME_BUCKET",
    "TIME_FORMAT",
    "TIMESTAMP",
    "TIMESTAMPADD",
    "TIMESTAMPDIFF",
    "TIME_TO_SEC",
    "TO_BASE64",
    "TO_CHAR",
    "TO_DAYS",
    "TO_JSON",
    "TO_NUMBER",
    "TO_SECONDS",
    "TO_TIMESTAMP",
    "TRIM",
    "TRUNC",
    "TRUNCATE",
    "UCASE",
    "UNHEX",
    "UNIX_TIMESTAMP",
    "UPDATEXML",
    "UPPER",
    "USER",
    "UTC_DATE",
    "UTC_TIME",
    "UTC_TIMESTAMP",
    "UUID",
    "VALUES",
    "VARIANCE",
    "VAR_POP",
    "VAR_SAMP",
    "VECTOR_SUB",
    "VERSION",
    "WEEK",
    "WEEKDAY",
    "WEEKOFYEAR",
    "YEAR",
    // Data types with parameters
    // https://docs.singlestore.com/managed-service/en/reference/sql-reference/data-types.html
    "BIT",
    "TINYINT",
    "SMALLINT",
    "MEDIUMINT",
    "INT",
    "INTEGER",
    "BIGINT",
    "DECIMAL",
    "DEC",
    "NUMERIC",
    "FIXED",
    "FLOAT",
    "DOUBLE",
    "DOUBLE PRECISION",
    "REAL",
    "DATETIME",
    "TIMESTAMP",
    "TIME",
    "YEAR",
    "CHAR",
    "NATIONAL CHAR",
    "VARCHAR",
    "NATIONAL VARCHAR",
    "BINARY",
    "VARBINARY",
    "BLOB",
    "TEXT",
    "ENUM"
  ]
}), JUe = re(["SELECT [ALL | DISTINCT | DISTINCTROW]"]), e$e = re([
  // queries
  "WITH",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "LIMIT",
  "OFFSET",
  // Data manipulation
  // - insert:
  "INSERT [IGNORE] [INTO]",
  "VALUES",
  "REPLACE [INTO]",
  // - update:
  "SET",
  // Data definition
  "CREATE VIEW",
  "CREATE [ROWSTORE] [REFERENCE | TEMPORARY | GLOBAL TEMPORARY] TABLE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [TEMPORARY] PROCEDURE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [EXTERNAL] FUNCTION"
]), n5 = re([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE [FROM]",
  // - drop table:
  "DROP [TEMPORARY] TABLE [IF EXISTS]",
  // - alter table:
  "ALTER [ONLINE] TABLE",
  "ADD [COLUMN]",
  "ADD [UNIQUE] {INDEX | KEY}",
  "DROP [COLUMN]",
  "MODIFY [COLUMN]",
  "CHANGE",
  "RENAME [TO | AS]",
  // - truncate:
  "TRUNCATE [TABLE]",
  // https://docs.singlestore.com/managed-service/en/reference/sql-reference.html
  "ADD AGGREGATOR",
  "ADD LEAF",
  "AGGREGATOR SET AS MASTER",
  "ALTER DATABASE",
  "ALTER PIPELINE",
  "ALTER RESOURCE POOL",
  "ALTER USER",
  "ALTER VIEW",
  "ANALYZE TABLE",
  "ATTACH DATABASE",
  "ATTACH LEAF",
  "ATTACH LEAF ALL",
  "BACKUP DATABASE",
  "BINLOG",
  "BOOTSTRAP AGGREGATOR",
  "CACHE INDEX",
  "CALL",
  "CHANGE",
  "CHANGE MASTER TO",
  "CHANGE REPLICATION FILTER",
  "CHANGE REPLICATION SOURCE TO",
  "CHECK BLOB CHECKSUM",
  "CHECK TABLE",
  "CHECKSUM TABLE",
  "CLEAR ORPHAN DATABASES",
  "CLONE",
  "COMMIT",
  "CREATE DATABASE",
  "CREATE GROUP",
  "CREATE INDEX",
  "CREATE LINK",
  "CREATE MILESTONE",
  "CREATE PIPELINE",
  "CREATE RESOURCE POOL",
  "CREATE ROLE",
  "CREATE USER",
  "DEALLOCATE PREPARE",
  "DESCRIBE",
  "DETACH DATABASE",
  "DETACH PIPELINE",
  "DROP DATABASE",
  "DROP FUNCTION",
  "DROP INDEX",
  "DROP LINK",
  "DROP PIPELINE",
  "DROP PROCEDURE",
  "DROP RESOURCE POOL",
  "DROP ROLE",
  "DROP USER",
  "DROP VIEW",
  "EXECUTE",
  "EXPLAIN",
  "FLUSH",
  "FORCE",
  "GRANT",
  "HANDLER",
  "HELP",
  "KILL CONNECTION",
  "KILLALL QUERIES",
  "LOAD DATA",
  "LOAD INDEX INTO CACHE",
  "LOAD XML",
  "LOCK INSTANCE FOR BACKUP",
  "LOCK TABLES",
  "MASTER_POS_WAIT",
  "OPTIMIZE TABLE",
  "PREPARE",
  "PURGE BINARY LOGS",
  "REBALANCE PARTITIONS",
  "RELEASE SAVEPOINT",
  "REMOVE AGGREGATOR",
  "REMOVE LEAF",
  "REPAIR TABLE",
  "REPLACE",
  "REPLICATE DATABASE",
  "RESET",
  "RESET MASTER",
  "RESET PERSIST",
  "RESET REPLICA",
  "RESET SLAVE",
  "RESTART",
  "RESTORE DATABASE",
  "RESTORE REDUNDANCY",
  "REVOKE",
  "ROLLBACK",
  "ROLLBACK TO SAVEPOINT",
  "SAVEPOINT",
  "SET CHARACTER SET",
  "SET DEFAULT ROLE",
  "SET NAMES",
  "SET PASSWORD",
  "SET RESOURCE GROUP",
  "SET ROLE",
  "SET TRANSACTION",
  "SHOW",
  "SHOW CHARACTER SET",
  "SHOW COLLATION",
  "SHOW COLUMNS",
  "SHOW CREATE DATABASE",
  "SHOW CREATE FUNCTION",
  "SHOW CREATE PIPELINE",
  "SHOW CREATE PROCEDURE",
  "SHOW CREATE TABLE",
  "SHOW CREATE USER",
  "SHOW CREATE VIEW",
  "SHOW DATABASES",
  "SHOW ENGINE",
  "SHOW ENGINES",
  "SHOW ERRORS",
  "SHOW FUNCTION CODE",
  "SHOW FUNCTION STATUS",
  "SHOW GRANTS",
  "SHOW INDEX",
  "SHOW MASTER STATUS",
  "SHOW OPEN TABLES",
  "SHOW PLUGINS",
  "SHOW PRIVILEGES",
  "SHOW PROCEDURE CODE",
  "SHOW PROCEDURE STATUS",
  "SHOW PROCESSLIST",
  "SHOW PROFILE",
  "SHOW PROFILES",
  "SHOW RELAYLOG EVENTS",
  "SHOW REPLICA STATUS",
  "SHOW REPLICAS",
  "SHOW SLAVE",
  "SHOW SLAVE HOSTS",
  "SHOW STATUS",
  "SHOW TABLE STATUS",
  "SHOW TABLES",
  "SHOW VARIABLES",
  "SHOW WARNINGS",
  "SHUTDOWN",
  "SNAPSHOT DATABASE",
  "SOURCE_POS_WAIT",
  "START GROUP_REPLICATION",
  "START PIPELINE",
  "START REPLICA",
  "START SLAVE",
  "START TRANSACTION",
  "STOP GROUP_REPLICATION",
  "STOP PIPELINE",
  "STOP REPLICA",
  "STOP REPLICATING",
  "STOP SLAVE",
  "TEST PIPELINE",
  "UNLOCK INSTANCE",
  "UNLOCK TABLES",
  "USE",
  "XA",
  // flow control
  "ITERATE",
  "LEAVE",
  "LOOP",
  "REPEAT",
  "RETURN",
  "WHILE"
]), t$e = re(["UNION [ALL | DISTINCT]", "EXCEPT", "INTERSECT", "MINUS"]), r$e = re([
  "JOIN",
  "{LEFT | RIGHT | FULL} [OUTER] JOIN",
  "{INNER | CROSS} JOIN",
  "NATURAL {LEFT | RIGHT} [OUTER] JOIN",
  // non-standard joins
  "STRAIGHT_JOIN"
]), i$e = re(["ON DELETE", "ON UPDATE", "CHARACTER SET", "{ROWS | RANGE} BETWEEN"]), n$e = {
  tokenizerOptions: {
    reservedSelect: JUe,
    reservedClauses: [...e$e, ...n5],
    reservedSetOperations: t$e,
    reservedJoins: r$e,
    reservedPhrases: i$e,
    reservedKeywords: jUe,
    reservedFunctionNames: KUe,
    // TODO: support _binary"some string" prefix
    stringTypes: ['""-qq-bs', "''-qq-bs", {
      quote: "''-raw",
      prefixes: ["B", "X"],
      requirePrefix: !0
    }],
    identTypes: ["``"],
    identChars: {
      first: "$",
      rest: "$",
      allowFirstCharNumber: !0
    },
    variableTypes: [{
      regex: "@@?[A-Za-z0-9_$]+"
    }, {
      quote: "``",
      prefixes: ["@"],
      requirePrefix: !0
    }],
    lineCommentTypes: ["--", "#"],
    operators: [":=", "&", "|", "^", "~", "<<", ">>", "<=>", "&&", "||", "::", "::$", "::%", ":>", "!:>"],
    postProcess: a$e
  },
  formatOptions: {
    alwaysDenseOperators: ["::", "::$", "::%"],
    onelineClauses: n5
  }
};
function a$e(r) {
  return r.map((e, t) => {
    const i = r[t + 1] || Uc;
    return Xl.SET(e) && i.text === "(" ? {
      ...e,
      type: ee.RESERVED_FUNCTION_NAME
    } : e;
  });
}
const o$e = wt({
  // https://docs.snowflake.com/en/sql-reference-functions.html
  //
  // https://docs.snowflake.com/en/sql-reference/functions-all.html
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. split all lines that contain ',' or '/' into multiple lines
  // 3. remove all ' Deprecated' parts from the strings
  // 4. delete all strings that end with '<object_type>', they are already covered in the list
  // 5. remove all strings that contain '[', they are operators not functions
  // 6. fix all values that contain '*'
  // 7. delete operatos ':', '::', '||'
  //
  // Steps 1-5 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   .map(x => x.split(x.includes(',') ? ',' : '/')).flat().map(x => x.trim()) // Step 2
  //   .map(x => x.replace(' Deprecated', '')) // Step 3
  //   .filter(x => !x.endsWith('<object_type>')) // Step 4
  //   .filter(x => !x.includes('[')) // Step 5
  all: ["ABS", "ACOS", "ACOSH", "ADD_MONTHS", "ALL_USER_NAMES", "ANY_VALUE", "APPROX_COUNT_DISTINCT", "APPROX_PERCENTILE", "APPROX_PERCENTILE_ACCUMULATE", "APPROX_PERCENTILE_COMBINE", "APPROX_PERCENTILE_ESTIMATE", "APPROX_TOP_K", "APPROX_TOP_K_ACCUMULATE", "APPROX_TOP_K_COMBINE", "APPROX_TOP_K_ESTIMATE", "APPROXIMATE_JACCARD_INDEX", "APPROXIMATE_SIMILARITY", "ARRAY_AGG", "ARRAY_APPEND", "ARRAY_CAT", "ARRAY_COMPACT", "ARRAY_CONSTRUCT", "ARRAY_CONSTRUCT_COMPACT", "ARRAY_CONTAINS", "ARRAY_INSERT", "ARRAY_INTERSECTION", "ARRAY_POSITION", "ARRAY_PREPEND", "ARRAY_SIZE", "ARRAY_SLICE", "ARRAY_TO_STRING", "ARRAY_UNION_AGG", "ARRAY_UNIQUE_AGG", "ARRAYS_OVERLAP", "AS_ARRAY", "AS_BINARY", "AS_BOOLEAN", "AS_CHAR", "AS_VARCHAR", "AS_DATE", "AS_DECIMAL", "AS_NUMBER", "AS_DOUBLE", "AS_REAL", "AS_INTEGER", "AS_OBJECT", "AS_TIME", "AS_TIMESTAMP_LTZ", "AS_TIMESTAMP_NTZ", "AS_TIMESTAMP_TZ", "ASCII", "ASIN", "ASINH", "ATAN", "ATAN2", "ATANH", "AUTO_REFRESH_REGISTRATION_HISTORY", "AUTOMATIC_CLUSTERING_HISTORY", "AVG", "BASE64_DECODE_BINARY", "BASE64_DECODE_STRING", "BASE64_ENCODE", "BIT_LENGTH", "BITAND", "BITAND_AGG", "BITMAP_BIT_POSITION", "BITMAP_BUCKET_NUMBER", "BITMAP_CONSTRUCT_AGG", "BITMAP_COUNT", "BITMAP_OR_AGG", "BITNOT", "BITOR", "BITOR_AGG", "BITSHIFTLEFT", "BITSHIFTRIGHT", "BITXOR", "BITXOR_AGG", "BOOLAND", "BOOLAND_AGG", "BOOLNOT", "BOOLOR", "BOOLOR_AGG", "BOOLXOR", "BOOLXOR_AGG", "BUILD_SCOPED_FILE_URL", "BUILD_STAGE_FILE_URL", "CASE", "CAST", "CBRT", "CEIL", "CHARINDEX", "CHECK_JSON", "CHECK_XML", "CHR", "CHAR", "COALESCE", "COLLATE", "COLLATION", "COMPLETE_TASK_GRAPHS", "COMPRESS", "CONCAT", "CONCAT_WS", "CONDITIONAL_CHANGE_EVENT", "CONDITIONAL_TRUE_EVENT", "CONTAINS", "CONVERT_TIMEZONE", "COPY_HISTORY", "CORR", "COS", "COSH", "COT", "COUNT", "COUNT_IF", "COVAR_POP", "COVAR_SAMP", "CUME_DIST", "CURRENT_ACCOUNT", "CURRENT_AVAILABLE_ROLES", "CURRENT_CLIENT", "CURRENT_DATABASE", "CURRENT_DATE", "CURRENT_IP_ADDRESS", "CURRENT_REGION", "CURRENT_ROLE", "CURRENT_SCHEMA", "CURRENT_SCHEMAS", "CURRENT_SECONDARY_ROLES", "CURRENT_SESSION", "CURRENT_STATEMENT", "CURRENT_TASK_GRAPHS", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_TRANSACTION", "CURRENT_USER", "CURRENT_VERSION", "CURRENT_WAREHOUSE", "DATA_TRANSFER_HISTORY", "DATABASE_REFRESH_HISTORY", "DATABASE_REFRESH_PROGRESS", "DATABASE_REFRESH_PROGRESS_BY_JOB", "DATABASE_STORAGE_USAGE_HISTORY", "DATE_FROM_PARTS", "DATE_PART", "DATE_TRUNC", "DATEADD", "DATEDIFF", "DAYNAME", "DECODE", "DECOMPRESS_BINARY", "DECOMPRESS_STRING", "DECRYPT", "DECRYPT_RAW", "DEGREES", "DENSE_RANK", "DIV0", "EDITDISTANCE", "ENCRYPT", "ENCRYPT_RAW", "ENDSWITH", "EQUAL_NULL", "EXP", "EXPLAIN_JSON", "EXTERNAL_FUNCTIONS_HISTORY", "EXTERNAL_TABLE_FILES", "EXTERNAL_TABLE_FILE_REGISTRATION_HISTORY", "EXTRACT", "EXTRACT_SEMANTIC_CATEGORIES", "FACTORIAL", "FIRST_VALUE", "FLATTEN", "FLOOR", "GENERATE_COLUMN_DESCRIPTION", "GENERATOR", "GET", "GET_ABSOLUTE_PATH", "GET_DDL", "GET_IGNORE_CASE", "GET_OBJECT_REFERENCES", "GET_PATH", "GET_PRESIGNED_URL", "GET_RELATIVE_PATH", "GET_STAGE_LOCATION", "GETBIT", "GREATEST", "GROUPING", "GROUPING_ID", "HASH", "HASH_AGG", "HAVERSINE", "HEX_DECODE_BINARY", "HEX_DECODE_STRING", "HEX_ENCODE", "HLL", "HLL_ACCUMULATE", "HLL_COMBINE", "HLL_ESTIMATE", "HLL_EXPORT", "HLL_IMPORT", "HOUR", "MINUTE", "SECOND", "IFF", "IFNULL", "ILIKE", "ILIKE ANY", "INFER_SCHEMA", "INITCAP", "INSERT", "INVOKER_ROLE", "INVOKER_SHARE", "IS_ARRAY", "IS_BINARY", "IS_BOOLEAN", "IS_CHAR", "IS_VARCHAR", "IS_DATE", "IS_DATE_VALUE", "IS_DECIMAL", "IS_DOUBLE", "IS_REAL", "IS_GRANTED_TO_INVOKER_ROLE", "IS_INTEGER", "IS_NULL_VALUE", "IS_OBJECT", "IS_ROLE_IN_SESSION", "IS_TIME", "IS_TIMESTAMP_LTZ", "IS_TIMESTAMP_NTZ", "IS_TIMESTAMP_TZ", "JAROWINKLER_SIMILARITY", "JSON_EXTRACT_PATH_TEXT", "KURTOSIS", "LAG", "LAST_DAY", "LAST_QUERY_ID", "LAST_TRANSACTION", "LAST_VALUE", "LEAD", "LEAST", "LEFT", "LENGTH", "LEN", "LIKE", "LIKE ALL", "LIKE ANY", "LISTAGG", "LN", "LOCALTIME", "LOCALTIMESTAMP", "LOG", "LOGIN_HISTORY", "LOGIN_HISTORY_BY_USER", "LOWER", "LPAD", "LTRIM", "MATERIALIZED_VIEW_REFRESH_HISTORY", "MD5", "MD5_HEX", "MD5_BINARY", "MD5_NUMBER  Obsoleted", "MD5_NUMBER_LOWER64", "MD5_NUMBER_UPPER64", "MEDIAN", "MIN", "MAX", "MINHASH", "MINHASH_COMBINE", "MOD", "MODE", "MONTHNAME", "MONTHS_BETWEEN", "NEXT_DAY", "NORMAL", "NTH_VALUE", "NTILE", "NULLIF", "NULLIFZERO", "NVL", "NVL2", "OBJECT_AGG", "OBJECT_CONSTRUCT", "OBJECT_CONSTRUCT_KEEP_NULL", "OBJECT_DELETE", "OBJECT_INSERT", "OBJECT_KEYS", "OBJECT_PICK", "OCTET_LENGTH", "PARSE_IP", "PARSE_JSON", "PARSE_URL", "PARSE_XML", "PERCENT_RANK", "PERCENTILE_CONT", "PERCENTILE_DISC", "PI", "PIPE_USAGE_HISTORY", "POLICY_CONTEXT", "POLICY_REFERENCES", "POSITION", "POW", "POWER", "PREVIOUS_DAY", "QUERY_ACCELERATION_HISTORY", "QUERY_HISTORY", "QUERY_HISTORY_BY_SESSION", "QUERY_HISTORY_BY_USER", "QUERY_HISTORY_BY_WAREHOUSE", "RADIANS", "RANDOM", "RANDSTR", "RANK", "RATIO_TO_REPORT", "REGEXP", "REGEXP_COUNT", "REGEXP_INSTR", "REGEXP_LIKE", "REGEXP_REPLACE", "REGEXP_SUBSTR", "REGEXP_SUBSTR_ALL", "REGR_AVGX", "REGR_AVGY", "REGR_COUNT", "REGR_INTERCEPT", "REGR_R2", "REGR_SLOPE", "REGR_SXX", "REGR_SXY", "REGR_SYY", "REGR_VALX", "REGR_VALY", "REPEAT", "REPLACE", "REPLICATION_GROUP_REFRESH_HISTORY", "REPLICATION_GROUP_REFRESH_PROGRESS", "REPLICATION_GROUP_REFRESH_PROGRESS_BY_JOB", "REPLICATION_GROUP_USAGE_HISTORY", "REPLICATION_USAGE_HISTORY", "REST_EVENT_HISTORY", "RESULT_SCAN", "REVERSE", "RIGHT", "RLIKE", "ROUND", "ROW_NUMBER", "RPAD", "RTRIM", "RTRIMMED_LENGTH", "SEARCH_OPTIMIZATION_HISTORY", "SEQ1", "SEQ2", "SEQ4", "SEQ8", "SERVERLESS_TASK_HISTORY", "SHA1", "SHA1_HEX", "SHA1_BINARY", "SHA2", "SHA2_HEX", "SHA2_BINARY", "SIGN", "SIN", "SINH", "SKEW", "SOUNDEX", "SPACE", "SPLIT", "SPLIT_PART", "SPLIT_TO_TABLE", "SQRT", "SQUARE", "ST_AREA", "ST_ASEWKB", "ST_ASEWKT", "ST_ASGEOJSON", "ST_ASWKB", "ST_ASBINARY", "ST_ASWKT", "ST_ASTEXT", "ST_AZIMUTH", "ST_CENTROID", "ST_COLLECT", "ST_CONTAINS", "ST_COVEREDBY", "ST_COVERS", "ST_DIFFERENCE", "ST_DIMENSION", "ST_DISJOINT", "ST_DISTANCE", "ST_DWITHIN", "ST_ENDPOINT", "ST_ENVELOPE", "ST_GEOGFROMGEOHASH", "ST_GEOGPOINTFROMGEOHASH", "ST_GEOGRAPHYFROMWKB", "ST_GEOGRAPHYFROMWKT", "ST_GEOHASH", "ST_GEOMETRYFROMWKB", "ST_GEOMETRYFROMWKT", "ST_HAUSDORFFDISTANCE", "ST_INTERSECTION", "ST_INTERSECTS", "ST_LENGTH", "ST_MAKEGEOMPOINT", "ST_GEOM_POINT", "ST_MAKELINE", "ST_MAKEPOINT", "ST_POINT", "ST_MAKEPOLYGON", "ST_POLYGON", "ST_NPOINTS", "ST_NUMPOINTS", "ST_PERIMETER", "ST_POINTN", "ST_SETSRID", "ST_SIMPLIFY", "ST_SRID", "ST_STARTPOINT", "ST_SYMDIFFERENCE", "ST_UNION", "ST_WITHIN", "ST_X", "ST_XMAX", "ST_XMIN", "ST_Y", "ST_YMAX", "ST_YMIN", "STAGE_DIRECTORY_FILE_REGISTRATION_HISTORY", "STAGE_STORAGE_USAGE_HISTORY", "STARTSWITH", "STDDEV", "STDDEV_POP", "STDDEV_SAMP", "STRIP_NULL_VALUE", "STRTOK", "STRTOK_SPLIT_TO_TABLE", "STRTOK_TO_ARRAY", "SUBSTR", "SUBSTRING", "SUM", "SYSDATE", "SYSTEM$ABORT_SESSION", "SYSTEM$ABORT_TRANSACTION", "SYSTEM$AUTHORIZE_PRIVATELINK", "SYSTEM$AUTHORIZE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$BEHAVIOR_CHANGE_BUNDLE_STATUS", "SYSTEM$CANCEL_ALL_QUERIES", "SYSTEM$CANCEL_QUERY", "SYSTEM$CLUSTERING_DEPTH", "SYSTEM$CLUSTERING_INFORMATION", "SYSTEM$CLUSTERING_RATIO ", "SYSTEM$CURRENT_USER_TASK_NAME", "SYSTEM$DATABASE_REFRESH_HISTORY ", "SYSTEM$DATABASE_REFRESH_PROGRESS", "SYSTEM$DATABASE_REFRESH_PROGRESS_BY_JOB ", "SYSTEM$DISABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$DISABLE_DATABASE_REPLICATION", "SYSTEM$ENABLE_BEHAVIOR_CHANGE_BUNDLE", "SYSTEM$ESTIMATE_QUERY_ACCELERATION", "SYSTEM$ESTIMATE_SEARCH_OPTIMIZATION_COSTS", "SYSTEM$EXPLAIN_JSON_TO_TEXT", "SYSTEM$EXPLAIN_PLAN_JSON", "SYSTEM$EXTERNAL_TABLE_PIPE_STATUS", "SYSTEM$GENERATE_SAML_CSR", "SYSTEM$GENERATE_SCIM_ACCESS_TOKEN", "SYSTEM$GET_AWS_SNS_IAM_POLICY", "SYSTEM$GET_PREDECESSOR_RETURN_VALUE", "SYSTEM$GET_PRIVATELINK", "SYSTEM$GET_PRIVATELINK_AUTHORIZED_ENDPOINTS", "SYSTEM$GET_PRIVATELINK_CONFIG", "SYSTEM$GET_SNOWFLAKE_PLATFORM_INFO", "SYSTEM$GET_TAG", "SYSTEM$GET_TAG_ALLOWED_VALUES", "SYSTEM$GET_TAG_ON_CURRENT_COLUMN", "SYSTEM$GET_TAG_ON_CURRENT_TABLE", "SYSTEM$GLOBAL_ACCOUNT_SET_PARAMETER", "SYSTEM$LAST_CHANGE_COMMIT_TIME", "SYSTEM$LINK_ACCOUNT_OBJECTS_BY_NAME", "SYSTEM$MIGRATE_SAML_IDP_REGISTRATION", "SYSTEM$PIPE_FORCE_RESUME", "SYSTEM$PIPE_STATUS", "SYSTEM$REVOKE_PRIVATELINK", "SYSTEM$REVOKE_STAGE_PRIVATELINK_ACCESS", "SYSTEM$SET_RETURN_VALUE", "SYSTEM$SHOW_OAUTH_CLIENT_SECRETS", "SYSTEM$STREAM_GET_TABLE_TIMESTAMP", "SYSTEM$STREAM_HAS_DATA", "SYSTEM$TASK_DEPENDENTS_ENABLE", "SYSTEM$TYPEOF", "SYSTEM$USER_TASK_CANCEL_ONGOING_EXECUTIONS", "SYSTEM$VERIFY_EXTERNAL_OAUTH_TOKEN", "SYSTEM$WAIT", "SYSTEM$WHITELIST", "SYSTEM$WHITELIST_PRIVATELINK", "TAG_REFERENCES", "TAG_REFERENCES_ALL_COLUMNS", "TAG_REFERENCES_WITH_LINEAGE", "TAN", "TANH", "TASK_DEPENDENTS", "TASK_HISTORY", "TIME_FROM_PARTS", "TIME_SLICE", "TIMEADD", "TIMEDIFF", "TIMESTAMP_FROM_PARTS", "TIMESTAMPADD", "TIMESTAMPDIFF", "TO_ARRAY", "TO_BINARY", "TO_BOOLEAN", "TO_CHAR", "TO_VARCHAR", "TO_DATE", "DATE", "TO_DECIMAL", "TO_NUMBER", "TO_NUMERIC", "TO_DOUBLE", "TO_GEOGRAPHY", "TO_GEOMETRY", "TO_JSON", "TO_OBJECT", "TO_TIME", "TIME", "TO_TIMESTAMP", "TO_TIMESTAMP_LTZ", "TO_TIMESTAMP_NTZ", "TO_TIMESTAMP_TZ", "TO_VARIANT", "TO_XML", "TRANSLATE", "TRIM", "TRUNCATE", "TRUNC", "TRUNC", "TRY_BASE64_DECODE_BINARY", "TRY_BASE64_DECODE_STRING", "TRY_CAST", "TRY_HEX_DECODE_BINARY", "TRY_HEX_DECODE_STRING", "TRY_PARSE_JSON", "TRY_TO_BINARY", "TRY_TO_BOOLEAN", "TRY_TO_DATE", "TRY_TO_DECIMAL", "TRY_TO_NUMBER", "TRY_TO_NUMERIC", "TRY_TO_DOUBLE", "TRY_TO_GEOGRAPHY", "TRY_TO_GEOMETRY", "TRY_TO_TIME", "TRY_TO_TIMESTAMP", "TRY_TO_TIMESTAMP_LTZ", "TRY_TO_TIMESTAMP_NTZ", "TRY_TO_TIMESTAMP_TZ", "TYPEOF", "UNICODE", "UNIFORM", "UPPER", "UUID_STRING", "VALIDATE", "VALIDATE_PIPE_LOAD", "VAR_POP", "VAR_SAMP", "VARIANCE", "VARIANCE_SAMP", "VARIANCE_POP", "WAREHOUSE_LOAD_HISTORY", "WAREHOUSE_METERING_HISTORY", "WIDTH_BUCKET", "XMLGET", "YEAR", "YEAROFWEEK", "YEAROFWEEKISO", "DAY", "DAYOFMONTH", "DAYOFWEEK", "DAYOFWEEKISO", "DAYOFYEAR", "WEEK", "WEEK", "WEEKOFYEAR", "WEEKISO", "MONTH", "QUARTER", "ZEROIFNULL", "ZIPF"]
}), s$e = wt({
  // https://docs.snowflake.com/en/sql-reference/reserved-keywords.html
  //
  // run in console on this page: $x('//tbody/tr/*[1]/p/text()').map(x => x.nodeValue)
  all: ["ACCOUNT", "ALL", "ALTER", "AND", "ANY", "AS", "BETWEEN", "BY", "CASE", "CAST", "CHECK", "COLUMN", "CONNECT", "CONNECTION", "CONSTRAINT", "CREATE", "CROSS", "CURRENT", "CURRENT_DATE", "CURRENT_TIME", "CURRENT_TIMESTAMP", "CURRENT_USER", "DATABASE", "DELETE", "DISTINCT", "DROP", "ELSE", "EXISTS", "FALSE", "FOLLOWING", "FOR", "FROM", "FULL", "GRANT", "GROUP", "GSCLUSTER", "HAVING", "ILIKE", "IN", "INCREMENT", "INNER", "INSERT", "INTERSECT", "INTO", "IS", "ISSUE", "JOIN", "LATERAL", "LEFT", "LIKE", "LOCALTIME", "LOCALTIMESTAMP", "MINUS", "NATURAL", "NOT", "NULL", "OF", "ON", "OR", "ORDER", "ORGANIZATION", "QUALIFY", "REGEXP", "REVOKE", "RIGHT", "RLIKE", "ROW", "ROWS", "SAMPLE", "SCHEMA", "SELECT", "SET", "SOME", "START", "TABLE", "TABLESAMPLE", "THEN", "TO", "TRIGGER", "TRUE", "TRY_CAST", "UNION", "UNIQUE", "UPDATE", "USING", "VALUES", "VIEW", "WHEN", "WHENEVER", "WHERE", "WITH"]
}), l$e = re(["SELECT [ALL | DISTINCT]"]), u$e = re([
  // queries
  "WITH [RECURSIVE]",
  "FROM",
  "WHERE",
  "GROUP BY",
  "HAVING",
  "PARTITION BY",
  "ORDER BY",
  "QUALIFY",
  "LIMIT",
  "OFFSET",
  "FETCH [FIRST | NEXT]",
  // Data manipulation
  // - insert:
  "INSERT [OVERWRITE] [ALL INTO | INTO | ALL | FIRST]",
  "{THEN | ELSE} INTO",
  "VALUES",
  // - update:
  "SET",
  // Data definition
  // - view
  "CREATE [OR REPLACE] [SECURE] [RECURSIVE] VIEW [IF NOT EXISTS]",
  // - create/drop/merge table
  "CREATE [OR REPLACE] [VOLATILE] TABLE [IF NOT EXISTS]",
  "CREATE [OR REPLACE] [LOCAL | GLOBAL] {TEMP|TEMPORARY} TABLE [IF NOT EXISTS]",
  "CLUSTER BY",
  "[WITH] {MASKING POLICY | TAG | ROW ACCESS POLICY}",
  "COPY GRANTS",
  "USING TEMPLATE",
  "MERGE INTO",
  "WHEN MATCHED [AND]",
  "THEN {UPDATE SET | DELETE}",
  "WHEN NOT MATCHED THEN INSERT"
]), a5 = re([
  // - update:
  "UPDATE",
  // - delete:
  "DELETE FROM",
  // - drop table:
  "DROP TABLE [IF EXISTS]",
  // - alter table:
  "ALTER TABLE [IF EXISTS]",
  "RENAME TO",
  "SWAP WITH",
  "[SUSPEND | RESUME] RECLUSTER",
  "DROP CLUSTERING KEY",
  "ADD [COLUMN]",
  "RENAME COLUMN",
  "{ALTER | MODIFY} [COLUMN]",
  "DROP [COLUMN]",
  "{ADD | ALTER | MODIFY | DROP} [CONSTRAINT]",
  "RENAME CONSTRAINT",
  "{ADD | DROP} SEARCH OPTIMIZATION",
  "{SET | UNSET} TAG",
  // Actually TAG is optional, but that conflicts with UPDATE..SET statement
  "{ADD | DROP} ROW ACCESS POLICY",
  "DROP ALL ROW ACCESS POLICIES",
  "{SET | DROP} DEFAULT",
  // for alter column
  "{SET | DROP} NOT NULL",
  // for alter column
  "[SET DATA] TYPE",
  // for alter column
  "[UNSET] COMMENT",
  // for alter column
  "{SET | UNSET} MASKING POLICY",
  // for alter column
  // - truncate:
  "TRUNCATE [TABLE] [IF EXISTS]",
  // other
  // https://docs.snowflake.com/en/sql-reference/sql-all.html
  //
  // 1. run in console on this page: $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue)
  // 2. delete all lines that contain a sting like '(.*)', they are already covered in the list
  // 3. delete all lines that contain a sting like '<.*>', they are already covered in the list
  // 4. delete all lines that contain '', they are part of a regex statement that can't be covered here
  // 5. Manually add 'COPY INTO'
  // 6. Remove all lines that are already in `reservedClauses`
  //
  // Steps 1-4 can be combined by the following script in the developer console:
  // $x('//tbody/tr/*[1]//a/span/text()').map(x => x.nodeValue) // Step 1
  //   filter(x => !x.match(/\(.*\)/) && !x.match(//) && !x.match(/<.*>/)) // Step 2-4
  "ALTER ACCOUNT",
  "ALTER API INTEGRATION",
  "ALTER CONNECTION",
  "ALTER DATABASE",
  "ALTER EXTERNAL TABLE",
  "ALTER FAILOVER GROUP",
  "ALTER FILE FORMAT",
  "ALTER FUNCTION",
  "ALTER INTEGRATION",
  "ALTER MASKING POLICY",
  "ALTER MATERIALIZED VIEW",
  "ALTER NETWORK POLICY",
  "ALTER NOTIFICATION INTEGRATION",
  "ALTER PIPE",
  "ALTER PROCEDURE",
  "ALTER REPLICATION GROUP",
  "ALTER RESOURCE MONITOR",
  "ALTER ROLE",
  "ALTER ROW ACCESS POLICY",
  "ALTER SCHEMA",
  "ALTER SECURITY INTEGRATION",
  "ALTER SEQUENCE",
  "ALTER SESSION",
  "ALTER SESSION POLICY",
  "ALTER SHARE",
  "ALTER STAGE",
  "ALTER STORAGE INTEGRATION",
  "ALTER STREAM",
  "ALTER TAG",
  "ALTER TASK",
  "ALTER USER",
  "ALTER VIEW",
  "ALTER WAREHOUSE",
  "BEGIN",
  "CALL",
  "COMMIT",
  "COPY INTO",
  "CREATE ACCOUNT",
  "CREATE API INTEGRATION",
  "CREATE CONNECTION",
  "CREATE DATABASE",
  "CREATE EXTERNAL FUNCTION",
  "CREATE EXTERNAL TABLE",
  "CREATE FAILOVER GROUP",
  "CREATE FILE FORMAT",
  "CREATE FUNCTION",
  "CREATE INTEGRATION",
  "CREATE MANAGED ACCOUNT",
  "CREATE MASKING POLICY",
  "CREATE MATERIALIZED VIEW",
  "CREATE NETWORK POLICY",
  "CREATE NOTIFICATION INTEGRATION",
  "CREATE PIPE",
  "CREATE PROCEDURE",
  "CREATE REPLICATION GROUP",
  "CREATE RESOURCE MONITOR",
  "CREATE ROLE",
  "CREATE ROW ACCESS POLICY",
  "CREATE SCHEMA",
  "CREATE SECURITY INTEGRATION",
  "CREATE SEQUENCE",
  "CREATE SESSION POLICY",
  "CREATE SHARE",
  "CREATE STAGE",
  "CREATE STORAGE INTEGRATION",
  "CREATE STREAM",
  "CREATE TAG",
  "CREATE TASK",
  "CREATE USER",
  "CREATE WAREHOUSE",
  "DELETE",
  "DESCRIBE DATABASE",
  "DESCRIBE EXTERNAL TABLE",
  "DESCRIBE FILE FORMAT",
  "DESCRIBE FUNCTION",
  "DESCRIBE INTEGRATION",
  "DESCRIBE MASKING POLICY",
  "DESCRIBE MATERIALIZED VIEW",
  "DESCRIBE NETWORK POLICY",
  "DESCRIBE PIPE",
  "DESCRIBE PROCEDURE",
  "DESCRIBE RESULT",
  "DESCRIBE ROW ACCESS POLICY",
  "DESCRIBE SCHEMA",
  "DESCRIBE SEQUENCE",
  "DESCRIBE SESSION POLICY",
  "DESCRIBE SHARE",
  "DESCRIBE STAGE",
  "DESCRIBE STREAM",
  "DESCRIBE TABLE",
  "DESCRIBE TASK",
  "DESCRIBE TRANSACTION",
  "DESCRIBE USER",
  "DESCRIBE VIEW",
  "DESCRIBE WAREHOUSE",
  "DROP CONNECTION",
  "DROP DATABASE",
  "DROP EXTERNAL TABLE",
  "DROP FAILOVER GROUP",
  "DROP FILE FORMAT",
  "DROP FUNCTION",
  "DROP INTEGRATION",
  "DROP MANAGED ACCOUNT",
  "DROP MASKING POLICY",
  "DROP MATERIALIZED VIEW",
  "DROP NETWORK POLICY",
  "DROP PIPE",
  "DROP PROCEDURE",
  "DROP REPLICATION GROUP",
  "DROP RESOURCE MONITOR",
  "DROP ROLE",
  "DROP ROW ACCESS POLICY",
  "DROP SCHEMA",
  "DROP SEQUENCE",
  "DROP SESSION POLICY",
  "DROP SHARE",
  "DROP STAGE",
  "DROP STREAM",
  "DROP TAG",
  "DROP TASK",
  "DROP USER",
  "DROP VIEW",
  "DROP WAREHOUSE",
  "EXECUTE IMMEDIATE",
  "EXECUTE TASK",
  "EXPLAIN",
  "GET",
  "GRANT OWNERSHIP",
  "GRANT ROLE",
  "INSERT",
  "LIST",
  "MERGE",
  "PUT",
  "REMOVE",
  "REVOKE ROLE",
  "ROLLBACK",
  "SHOW COLUMNS",
  "SHOW CONNECTIONS",
  "SHOW DATABASES",
  "SHOW DATABASES IN FAILOVER GROUP",
  "SHOW DATABASES IN REPLICATION GROUP",
  "SHOW DELEGATED AUTHORIZATIONS",
  "SHOW EXTERNAL FUNCTIONS",
  "SHOW EXTERNAL TABLES",
  "SHOW FAILOVER GROUPS",
  "SHOW FILE FORMATS",
  "SHOW FUNCTIONS",
  "SHOW GLOBAL ACCOUNTS",
  "SHOW GRANTS",
  "SHOW INTEGRATIONS",
  "SHOW LOCKS",
  "SHOW MANAGED ACCOUNTS",
  "SHOW MASKING POLICIES",
  "SHOW MATERIALIZED VIEWS",
  "SHOW NETWORK POLICIES",
  "SHOW OBJECTS",
  "SHOW ORGANIZATION ACCOUNTS",
  "SHOW PARAMETERS",
  "SHOW PIPES",
  "SHOW PRIMARY KEYS",
  "SHOW PROCEDURES",
  "SHOW REGIONS",
  "SHOW REPLICATION ACCOUNTS",
  "SHOW REPLICATION DATABASES",
  "SHOW REPLICATION GROUPS",
  "SHOW RESOURCE MONITORS",
  "SHOW ROLES",
  "SHOW ROW ACCESS POLICIES",
  "SHOW SCHEMAS",
  "SHOW SEQUENCES",
  "SHOW SESSION POLICIES",
  "SHOW SHARES",
  "SHOW SHARES IN FAILOVER GROUP",
  "SHOW SHARES IN REPLICATION GROUP",
  "SHOW STAGES",
  "SHOW STREAMS",
  "SHOW TABLES",
  "SHOW TAGS",
  "SHOW TASKS",
  "SHOW TRANSACTIONS",
  "SHOW USER FUNCTIONS",
  "SHOW USERS",
  "SHOW VARIABLES",
  "SHOW VIEWS",
  "SHOW WAREHOUSES",
  "TRUNCATE MATERIALIZED VIEW",
  "UNDROP DATABASE",
  "UNDROP SCHEMA",
  "UNDROP TABLE",
  "UNDROP TAG",
  "UNSET",
  "USE DATABASE",
  "USE ROLE",
  "USE SCHEMA",
  "USE SECONDARY ROLES",
  "USE WAREHOUSE"
]), c$e = re(["UNION [ALL]", "MINUS", "EXCEPT", "INTERSECT"]), h$e = re(["[INNER] JOIN", "[NATURAL] {LEFT | RIGHT | FULL} [OUTER] JOIN", "{CROSS | NATURAL} JOIN"]), f$e = re(["{ROWS | RANGE} BETWEEN", "ON {UPDATE | DELETE} [SET NULL | SET DEFAULT]"]), d$e = {
  tokenizerOptions: {
    reservedSelect: l$e,
    reservedClauses: [...u$e, ...a5],
    reservedSetOperations: c$e,
    reservedJoins: h$e,
    reservedPhrases: f$e,
    reservedKeywords: s$e,
    reservedFunctionNames: o$e,
    stringTypes: ["$$", "''-qq-bs"],
    identTypes: ['""-qq'],
    variableTypes: [
      // for accessing columns at certain positons in the table
      {
        regex: "[$][1-9]\\d*"
      },
      // identifier style syntax
      {
        regex: "[$][_a-zA-Z][_a-zA-Z0-9$]*"
      }
    ],
    extraParens: ["[]"],
    identChars: {
      rest: "$"
    },
    lineCommentTypes: ["--", "//"],
    operators: [
      // Modulo
      "%",
      // Type cast
      "::",
      // String concat
      "||",
      // Get Path
      ":",
      // Generators: https://docs.snowflake.com/en/sql-reference/functions/generator.html#generator
      "=>"
    ]
  },
  formatOptions: {
    alwaysDenseOperators: [":", "::"],
    onelineClauses: a5
  }
}, p$e = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bigquery: HQe,
  db2: n2e,
  hive: f2e,
  mariadb: b2e,
  mysql: w2e,
  n1ql: U2e,
  plsql: H2e,
  postgresql: tUe,
  redshift: uUe,
  singlestoredb: n$e,
  snowflake: d$e,
  spark: OUe,
  sql: DUe,
  sqlite: _Ue,
  transactsql: qUe,
  trino: BUe
}, Symbol.toStringTag, { value: "Module" })), wa = (r) => r.replace(/[.*+?^${}()|[\]\\]/gu, "\\$&"), o5 = /\s+/uy, ah = (r) => new RegExp(`(?:${r})`, "uy"), g$e = (r) => r.split("").map((e) => / /gu.test(e) ? "\\s+" : `[${e.toUpperCase()}${e.toLowerCase()}]`).join(""), v$e = (r) => r + "(?:-" + r + ")*", O$e = ({
  prefixes: r,
  requirePrefix: e
}) => `(?:${r.map(g$e).join("|")}${e ? "" : "|"})`, m$e = (r) => new RegExp(`(?:${r.map(wa).join("|")}).*?(?=\r
|\r|
|$)`, "uy"), s5 = (r, e = []) => {
  const t = r === "open" ? 0 : 1, i = ["()", ...e].map((n) => n[t]);
  return ah(i.map(wa).join("|"));
}, E$e = (r) => ah(`${Cq(r).map(wa).join("|")}`), b$e = ({
  rest: r,
  dashes: e
}) => r || e ? `(?![${r || ""}${e ? "-" : ""}])` : "", Cu = (r, e = {}) => {
  if (r.length === 0)
    return /^\b$/u;
  const t = b$e(e), i = Cq(r).map(wa).join("|").replace(/ /gu, "\\s+");
  return new RegExp(`(?:${i})${t}\\b`, "iuy");
}, YA = (r, e) => {
  if (!r.length)
    return;
  const t = r.map(wa).join("|");
  return ah(`(?:${t})(?:${e})`);
}, S$e = () => {
  const r = {
    "<": ">",
    "[": "]",
    "(": ")",
    "{": "}"
  }, e = "{left}(?:(?!{right}').)*?{right}", t = Object.entries(r).map(([o, s]) => e.replace(/{left}/g, wa(o)).replace(/{right}/g, wa(s))), i = wa(Object.keys(r).join(""));
  return `[Qq]'(?:${String.raw`(?<tag>[^\s${i}])(?:(?!\k<tag>').)*?\k<tag>`}|${t.join("|")})'`;
}, l5 = {
  // - backtick quoted (using `` to escape)
  "``": "(?:`[^`]*`)+",
  // - Transact-SQL square bracket quoted (using ]] to escape)
  "[]": String.raw`(?:\[[^\]]*\])(?:\][^\]]*\])*`,
  // double-quoted
  '""-qq': String.raw`(?:"[^"]*")+`,
  // with repeated quote escapes
  '""-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")`,
  // with backslash escapes
  '""-qq-bs': String.raw`(?:"[^"\\]*(?:\\.[^"\\]*)*")+`,
  // with repeated quote or backslash escapes
  '""-raw': String.raw`(?:"[^"]*")`,
  // no escaping
  // single-quoted
  "''-qq": String.raw`(?:'[^']*')+`,
  // with repeated quote escapes
  "''-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')`,
  // with backslash escapes
  "''-qq-bs": String.raw`(?:'[^'\\]*(?:\\.[^'\\]*)*')+`,
  // with repeated quote or backslash escapes
  "''-raw": String.raw`(?:'[^']*')`,
  // no escaping
  // PostgreSQL dollar-quoted
  $$: String.raw`(?<tag>\$\w*\$)[\s\S]*?\k<tag>`,
  // BigQuery '''triple-quoted''' (using \' to escape)
  "'''..'''": String.raw`'''[^\\]*?(?:\\.[^\\]*?)*?'''`,
  // BigQuery """triple-quoted""" (using \" to escape)
  '""".."""': String.raw`"""[^\\]*?(?:\\.[^\\]*?)*?"""`,
  // Hive and Spark variables: ${name}
  "{}": String.raw`(?:\{[^\}]*\})`,
  // Oracle q'' strings: q'<text>' q'|text|' ...
  "q''": S$e()
}, Nq = (r) => typeof r == "string" ? l5[r] : "regex" in r ? r.regex : O$e(r) + l5[r.quote], T$e = (r) => ah(r.map((e) => "regex" in e ? e.regex : Nq(e)).join("|")), xq = (r) => r.map(Nq).join("|"), u5 = (r) => ah(xq(r)), y$e = (r = {}) => ah(Pq(r)), Pq = ({
  first: r,
  rest: e,
  dashes: t,
  allowFirstCharNumber: i
} = {}) => {
  const n = "\\p{Alphabetic}\\p{Mark}_", a = "\\p{Decimal_Number}", o = wa(r ?? ""), s = wa(e ?? ""), l = i ? `[${n}${a}${o}][${n}${a}${s}]*` : `[${n}${o}][${n}${a}${s}]*`;
  return t ? v$e(l) : l;
};
function Lq(r, e) {
  const t = r.slice(0, e).split(/\n/);
  return {
    line: t.length,
    col: t[t.length - 1].length + 1
  };
}
class R$e {
  // Current position in string
  constructor(e) {
    ai(this, "input", "");
    // The input SQL string to process
    ai(this, "index", 0);
    this.rules = e;
  }
  /**
   * Takes a SQL string and breaks it into tokens.
   * Each token is an object with type and value.
   *
   * @param {string} input - The SQL string
   * @returns {Token[]} output token stream
   */
  tokenize(e) {
    this.input = e, this.index = 0;
    const t = [];
    let i;
    for (; this.index < this.input.length; ) {
      const n = this.getWhitespace();
      if (this.index < this.input.length) {
        if (i = this.getNextToken(), !i)
          throw this.createParseError();
        t.push({
          ...i,
          precedingWhitespace: n
        });
      }
    }
    return t;
  }
  createParseError() {
    const e = this.input.slice(this.index, this.index + 10), {
      line: t,
      col: i
    } = Lq(this.input, this.index);
    return new Error(`Parse error: Unexpected "${e}" at line ${t} column ${i}`);
  }
  getWhitespace() {
    o5.lastIndex = this.index;
    const e = o5.exec(this.input);
    if (e)
      return this.index += e[0].length, e[0];
  }
  getNextToken() {
    for (const e of this.rules) {
      const t = this.match(e);
      if (t)
        return t;
    }
  }
  // Attempts to match token rule regex at current position in input
  match(e) {
    e.regex.lastIndex = this.index;
    const t = e.regex.exec(this.input);
    if (t) {
      const i = t[0], n = {
        type: e.type,
        raw: i,
        text: e.text ? e.text(i) : i,
        start: this.index
      };
      return e.key && (n.key = e.key(i)), this.index += i.length, n;
    }
  }
}
const c5 = /\/\*/uy, A$e = /([^/*]|\*[^/]|\/[^*])+/uy, _$e = /\*\//uy;
class C$e {
  constructor() {
    ai(this, "lastIndex", 0);
  }
  exec(e) {
    let t = "", i, n = 0;
    if (i = this.matchSection(c5, e))
      t += i, n++;
    else
      return null;
    for (; n > 0; )
      if (i = this.matchSection(c5, e))
        t += i, n++;
      else if (i = this.matchSection(_$e, e))
        t += i, n--;
      else if (i = this.matchSection(A$e, e))
        t += i;
      else
        return null;
    return [t];
  }
  matchSection(e, t) {
    e.lastIndex = this.lastIndex;
    const i = e.exec(t);
    return i && (this.lastIndex += i[0].length), i ? i[0] : null;
  }
}
class I$e {
  constructor(e) {
    this.cfg = e, this.rulesBeforeParams = this.buildRulesBeforeParams(e), this.rulesAfterParams = this.buildRulesAfterParams(e);
  }
  tokenize(e, t) {
    const i = [...this.rulesBeforeParams, ...this.buildParamRules(this.cfg, t), ...this.rulesAfterParams], n = new R$e(i).tokenize(e);
    return this.cfg.postProcess ? this.cfg.postProcess(n) : n;
  }
  // These rules can be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesBeforeParams(e) {
    return this.validRules([
      {
        type: ee.BLOCK_COMMENT,
        regex: e.nestedBlockComments ? new C$e() : /(\/\*[^]*?\*\/)/uy
      },
      {
        type: ee.LINE_COMMENT,
        regex: m$e(e.lineCommentTypes ?? ["--"])
      },
      {
        type: ee.QUOTED_IDENTIFIER,
        regex: u5(e.identTypes)
      },
      {
        type: ee.NUMBER,
        regex: /(?:0x[0-9a-fA-F]+|0b[01]+|(?:-\s*)?[0-9]+(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+(?:\.[0-9]+)?)?)(?!\w)/uy
      },
      // RESERVED_PHRASE is matched before all other keyword tokens
      // to e.g. prioritize matching "TIMESTAMP WITH TIME ZONE" phrase over "WITH" clause.
      {
        type: ee.RESERVED_PHRASE,
        regex: Cu(e.reservedPhrases ?? [], e.identChars),
        text: Fr
      },
      {
        type: ee.CASE,
        regex: /CASE\b/iuy,
        text: Fr
      },
      {
        type: ee.END,
        regex: /END\b/iuy,
        text: Fr
      },
      {
        type: ee.BETWEEN,
        regex: /BETWEEN\b/iuy,
        text: Fr
      },
      {
        type: ee.LIMIT,
        regex: e.reservedClauses.includes("LIMIT") ? /LIMIT\b/iuy : void 0,
        text: Fr
      },
      {
        type: ee.RESERVED_CLAUSE,
        regex: Cu(e.reservedClauses, e.identChars),
        text: Fr
      },
      {
        type: ee.RESERVED_SELECT,
        regex: Cu(e.reservedSelect, e.identChars),
        text: Fr
      },
      {
        type: ee.RESERVED_SET_OPERATION,
        regex: Cu(e.reservedSetOperations, e.identChars),
        text: Fr
      },
      {
        type: ee.WHEN,
        regex: /WHEN\b/iuy,
        text: Fr
      },
      {
        type: ee.ELSE,
        regex: /ELSE\b/iuy,
        text: Fr
      },
      {
        type: ee.THEN,
        regex: /THEN\b/iuy,
        text: Fr
      },
      {
        type: ee.RESERVED_JOIN,
        regex: Cu(e.reservedJoins, e.identChars),
        text: Fr
      },
      {
        type: ee.AND,
        regex: /AND\b/iuy,
        text: Fr
      },
      {
        type: ee.OR,
        regex: /OR\b/iuy,
        text: Fr
      },
      {
        type: ee.XOR,
        regex: e.supportsXor ? /XOR\b/iuy : void 0,
        text: Fr
      },
      {
        type: ee.RESERVED_FUNCTION_NAME,
        regex: Cu(e.reservedFunctionNames, e.identChars),
        text: Fr
      },
      {
        type: ee.RESERVED_KEYWORD,
        regex: Cu(e.reservedKeywords, e.identChars),
        text: Fr
      }
    ]);
  }
  // These rules can also be cached as they only depend on
  // the Tokenizer config options specified for each SQL dialect
  buildRulesAfterParams(e) {
    return this.validRules([{
      type: ee.VARIABLE,
      regex: e.variableTypes ? T$e(e.variableTypes) : void 0
    }, {
      type: ee.STRING,
      regex: u5(e.stringTypes)
    }, {
      type: ee.IDENTIFIER,
      regex: y$e(e.identChars)
    }, {
      type: ee.DELIMITER,
      regex: /[;]/uy
    }, {
      type: ee.COMMA,
      regex: /[,]/y
    }, {
      type: ee.OPEN_PAREN,
      regex: s5("open", e.extraParens)
    }, {
      type: ee.CLOSE_PAREN,
      regex: s5("close", e.extraParens)
    }, {
      type: ee.OPERATOR,
      regex: E$e([
        // standard operators
        "+",
        "-",
        "/",
        ">",
        "<",
        "=",
        "<>",
        "<=",
        ">=",
        "!=",
        ...e.operators ?? []
      ])
    }, {
      type: ee.ASTERISK,
      regex: /[*]/uy
    }, {
      type: ee.DOT,
      regex: /[.]/uy
    }]);
  }
  // These rules can't be blindly cached as the paramTypesOverrides object
  // can differ on each invocation of the format() function.
  buildParamRules(e, t) {
    var i, n, a, o, s;
    const l = {
      named: (t == null ? void 0 : t.named) || ((i = e.paramTypes) === null || i === void 0 ? void 0 : i.named) || [],
      quoted: (t == null ? void 0 : t.quoted) || ((n = e.paramTypes) === null || n === void 0 ? void 0 : n.quoted) || [],
      numbered: (t == null ? void 0 : t.numbered) || ((a = e.paramTypes) === null || a === void 0 ? void 0 : a.numbered) || [],
      positional: typeof (t == null ? void 0 : t.positional) == "boolean" ? t.positional : (o = e.paramTypes) === null || o === void 0 ? void 0 : o.positional,
      custom: (t == null ? void 0 : t.custom) || ((s = e.paramTypes) === null || s === void 0 ? void 0 : s.custom) || []
    };
    return this.validRules([{
      type: ee.NAMED_PARAMETER,
      regex: YA(l.named, Pq(e.paramChars || e.identChars)),
      key: (u) => u.slice(1)
    }, {
      type: ee.QUOTED_PARAMETER,
      regex: YA(l.quoted, xq(e.identTypes)),
      key: (u) => (({
        tokenKey: c,
        quoteChar: h
      }) => c.replace(new RegExp(wa("\\" + h), "gu"), h))({
        tokenKey: u.slice(2, -1),
        quoteChar: u.slice(-1)
      })
    }, {
      type: ee.NUMBERED_PARAMETER,
      regex: YA(l.numbered, "[0-9]+"),
      key: (u) => u.slice(1)
    }, {
      type: ee.POSITIONAL_PARAMETER,
      regex: l.positional ? /[?]/y : void 0
    }, ...l.custom.map((u) => ({
      type: ee.CUSTOM_PARAMETER,
      regex: ah(u.regex),
      key: u.key ?? ((c) => c)
    }))]);
  }
  // filters out rules for token types whose regex is undefined
  validRules(e) {
    return e.filter((t) => !!t.regex);
  }
}
const Fr = (r) => wq(r.toUpperCase()), h5 = /* @__PURE__ */ new Map(), w$e = (r) => {
  let e = h5.get(r);
  return e || (e = N$e(r), h5.set(r, e)), e;
}, N$e = (r) => ({
  tokenizer: new I$e(r.tokenizerOptions),
  formatOptions: x$e(r.formatOptions)
}), x$e = (r) => ({
  alwaysDenseOperators: r.alwaysDenseOperators || [],
  onelineClauses: Object.fromEntries(r.onelineClauses.map((e) => [e, !0]))
});
function f5(r) {
  return r.indentStyle === "tabularLeft" || r.indentStyle === "tabularRight" ? " ".repeat(10) : r.useTabs ? "	" : " ".repeat(r.tabWidth);
}
function lp(r) {
  return r.indentStyle === "tabularLeft" || r.indentStyle === "tabularRight";
}
class P$e {
  constructor(e) {
    this.params = e, this.index = 0;
  }
  /**
   * Returns param value that matches given placeholder with param key.
   */
  get({
    key: e,
    text: t
  }) {
    return this.params ? e ? this.params[e] : this.params[this.index++] : t;
  }
  /**
   * Returns index of current positional parameter.
   */
  getPositionalParameterIndex() {
    return this.index;
  }
  /**
   * Sets index of current positional parameter.
   */
  setPositionalParameterIndex(e) {
    this.index = e;
  }
}
var L$e = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function D$e(r) {
  return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r;
}
var Dq = { exports: {} };
(function(r) {
  (function(e, t) {
    r.exports ? r.exports = t() : e.nearley = t();
  })(L$e, function() {
    function e(u, c, h) {
      return this.id = ++e.highestId, this.name = u, this.symbols = c, this.postprocess = h, this;
    }
    e.highestId = 0, e.prototype.toString = function(u) {
      var c = typeof u > "u" ? this.symbols.map(l).join(" ") : this.symbols.slice(0, u).map(l).join(" ") + "  " + this.symbols.slice(u).map(l).join(" ");
      return this.name + "  " + c;
    };
    function t(u, c, h, f) {
      this.rule = u, this.dot = c, this.reference = h, this.data = [], this.wantedBy = f, this.isComplete = this.dot === u.symbols.length;
    }
    t.prototype.toString = function() {
      return "{" + this.rule.toString(this.dot) + "}, from: " + (this.reference || 0);
    }, t.prototype.nextState = function(u) {
      var c = new t(this.rule, this.dot + 1, this.reference, this.wantedBy);
      return c.left = this, c.right = u, c.isComplete && (c.data = c.build(), c.right = void 0), c;
    }, t.prototype.build = function() {
      var u = [], c = this;
      do
        u.push(c.right.data), c = c.left;
      while (c.left);
      return u.reverse(), u;
    }, t.prototype.finish = function() {
      this.rule.postprocess && (this.data = this.rule.postprocess(this.data, this.reference, o.fail));
    };
    function i(u, c) {
      this.grammar = u, this.index = c, this.states = [], this.wants = {}, this.scannable = [], this.completed = {};
    }
    i.prototype.process = function(u) {
      for (var c = this.states, h = this.wants, f = this.completed, d = 0; d < c.length; d++) {
        var p = c[d];
        if (p.isComplete) {
          if (p.finish(), p.data !== o.fail) {
            for (var g = p.wantedBy, v = g.length; v--; ) {
              var O = g[v];
              this.complete(O, p);
            }
            if (p.reference === this.index) {
              var m = p.rule.name;
              (this.completed[m] = this.completed[m] || []).push(p);
            }
          }
        } else {
          var m = p.rule.symbols[p.dot];
          if (typeof m != "string") {
            this.scannable.push(p);
            continue;
          }
          if (h[m]) {
            if (h[m].push(p), f.hasOwnProperty(m))
              for (var E = f[m], v = 0; v < E.length; v++) {
                var b = E[v];
                this.complete(p, b);
              }
          } else
            h[m] = [p], this.predict(m);
        }
      }
    }, i.prototype.predict = function(u) {
      for (var c = this.grammar.byName[u] || [], h = 0; h < c.length; h++) {
        var f = c[h], d = this.wants[u], p = new t(f, 0, this.index, d);
        this.states.push(p);
      }
    }, i.prototype.complete = function(u, c) {
      var h = u.nextState(c);
      this.states.push(h);
    };
    function n(u, c) {
      this.rules = u, this.start = c || this.rules[0].name;
      var h = this.byName = {};
      this.rules.forEach(function(f) {
        h.hasOwnProperty(f.name) || (h[f.name] = []), h[f.name].push(f);
      });
    }
    n.fromCompiled = function(f, c) {
      var h = f.Lexer;
      f.ParserStart && (c = f.ParserStart, f = f.ParserRules);
      var f = f.map(function(p) {
        return new e(p.name, p.symbols, p.postprocess);
      }), d = new n(f, c);
      return d.lexer = h, d;
    };
    function a() {
      this.reset("");
    }
    a.prototype.reset = function(u, c) {
      this.buffer = u, this.index = 0, this.line = c ? c.line : 1, this.lastLineBreak = c ? -c.col : 0;
    }, a.prototype.next = function() {
      if (this.index < this.buffer.length) {
        var u = this.buffer[this.index++];
        return u === `
` && (this.line += 1, this.lastLineBreak = this.index), { value: u };
      }
    }, a.prototype.save = function() {
      return {
        line: this.line,
        col: this.index - this.lastLineBreak
      };
    }, a.prototype.formatError = function(u, c) {
      var h = this.buffer;
      if (typeof h == "string") {
        var f = h.split(`
`).slice(
          Math.max(0, this.line - 5),
          this.line
        ), d = h.indexOf(`
`, this.index);
        d === -1 && (d = h.length);
        var p = this.index - this.lastLineBreak, g = String(this.line).length;
        return c += " at line " + this.line + " col " + p + `:

`, c += f.map(function(O, m) {
          return v(this.line - f.length + m + 1, g) + " " + O;
        }, this).join(`
`), c += `
` + v("", g + p) + `^
`, c;
      } else
        return c + " at index " + (this.index - 1);
      function v(O, m) {
        var E = String(O);
        return Array(m - E.length + 1).join(" ") + E;
      }
    };
    function o(u, c, h) {
      if (u instanceof n)
        var f = u, h = c;
      else
        var f = n.fromCompiled(u, c);
      this.grammar = f, this.options = {
        keepHistory: !1,
        lexer: f.lexer || new a()
      };
      for (var d in h || {})
        this.options[d] = h[d];
      this.lexer = this.options.lexer, this.lexerState = void 0;
      var p = new i(f, 0);
      this.table = [p], p.wants[f.start] = [], p.predict(f.start), p.process(), this.current = 0;
    }
    o.fail = {}, o.prototype.feed = function(u) {
      var c = this.lexer;
      c.reset(u, this.lexerState);
      for (var h; ; ) {
        try {
          if (h = c.next(), !h)
            break;
        } catch (y) {
          var g = new i(this.grammar, this.current + 1);
          this.table.push(g);
          var f = new Error(this.reportLexerError(y));
          throw f.offset = this.current, f.token = y.token, f;
        }
        var d = this.table[this.current];
        this.options.keepHistory || delete this.table[this.current - 1];
        var p = this.current + 1, g = new i(this.grammar, p);
        this.table.push(g);
        for (var v = h.text !== void 0 ? h.text : h.value, O = c.constructor === a ? h.value : h, m = d.scannable, E = m.length; E--; ) {
          var b = m[E], S = b.rule.symbols[b.dot];
          if (S.test ? S.test(O) : S.type ? S.type === h.type : S.literal === v) {
            var T = b.nextState({ data: O, token: h, isToken: !0, reference: p - 1 });
            g.states.push(T);
          }
        }
        if (g.process(), g.states.length === 0) {
          var f = new Error(this.reportError(h));
          throw f.offset = this.current, f.token = h, f;
        }
        this.options.keepHistory && (d.lexerState = c.save()), this.current++;
      }
      return d && (this.lexerState = c.save()), this.results = this.finish(), this;
    }, o.prototype.reportLexerError = function(u) {
      var c, h, f = u.token;
      return f ? (c = "input " + JSON.stringify(f.text[0]) + " (lexer error)", h = this.lexer.formatError(f, "Syntax error")) : (c = "input (lexer error)", h = u.message), this.reportErrorCommon(h, c);
    }, o.prototype.reportError = function(u) {
      var c = (u.type ? u.type + " token: " : "") + JSON.stringify(u.value !== void 0 ? u.value : u), h = this.lexer.formatError(u, "Syntax error");
      return this.reportErrorCommon(h, c);
    }, o.prototype.reportErrorCommon = function(u, c) {
      var h = [];
      h.push(u);
      var f = this.table.length - 2, d = this.table[f], p = d.states.filter(function(v) {
        var O = v.rule.symbols[v.dot];
        return O && typeof O != "string";
      });
      if (p.length === 0)
        h.push("Unexpected " + c + `. I did not expect any more input. Here is the state of my parse table:
`), this.displayStateStack(d.states, h);
      else {
        h.push("Unexpected " + c + `. Instead, I was expecting to see one of the following:
`);
        var g = p.map(function(v) {
          return this.buildFirstStateStack(v, []) || [v];
        }, this);
        g.forEach(function(v) {
          var O = v[0], m = O.rule.symbols[O.dot], E = this.getSymbolDisplay(m);
          h.push("A " + E + " based on:"), this.displayStateStack(v, h);
        }, this);
      }
      return h.push(""), h.join(`
`);
    }, o.prototype.displayStateStack = function(u, c) {
      for (var h, f = 0, d = 0; d < u.length; d++) {
        var p = u[d], g = p.rule.toString(p.dot);
        g === h ? f++ : (f > 0 && c.push("    ^ " + f + " more lines identical to this"), f = 0, c.push("    " + g)), h = g;
      }
    }, o.prototype.getSymbolDisplay = function(u) {
      return s(u);
    }, o.prototype.buildFirstStateStack = function(u, c) {
      if (c.indexOf(u) !== -1)
        return null;
      if (u.wantedBy.length === 0)
        return [u];
      var h = u.wantedBy[0], f = [u].concat(c), d = this.buildFirstStateStack(h, f);
      return d === null ? null : [u].concat(d);
    }, o.prototype.save = function() {
      var u = this.table[this.current];
      return u.lexerState = this.lexerState, u;
    }, o.prototype.restore = function(u) {
      var c = u.index;
      this.current = c, this.table[c] = u, this.table.splice(c + 1), this.lexerState = u.lexerState, this.results = this.finish();
    }, o.prototype.rewind = function(u) {
      if (!this.options.keepHistory)
        throw new Error("set option `keepHistory` to enable rewinding");
      this.restore(this.table[u]);
    }, o.prototype.finish = function() {
      var u = [], c = this.grammar.start, h = this.table[this.table.length - 1];
      return h.states.forEach(function(f) {
        f.rule.name === c && f.dot === f.rule.symbols.length && f.reference === 0 && f.data !== o.fail && u.push(f);
      }), u.map(function(f) {
        return f.data;
      });
    };
    function s(u) {
      var c = typeof u;
      if (c === "string")
        return u;
      if (c === "object") {
        if (u.literal)
          return JSON.stringify(u.literal);
        if (u instanceof RegExp)
          return "character matching " + u;
        if (u.type)
          return u.type + " token";
        if (u.test)
          return "token matching " + String(u.test);
        throw new Error("Unknown symbol type: " + u);
      }
    }
    function l(u) {
      var c = typeof u;
      if (c === "string")
        return u;
      if (c === "object") {
        if (u.literal)
          return JSON.stringify(u.literal);
        if (u instanceof RegExp)
          return u.toString();
        if (u.type)
          return "%" + u.type;
        if (u.test)
          return "<" + String(u.test) + ">";
        throw new Error("Unknown symbol type: " + u);
      }
    }
    return {
      Parser: o,
      Grammar: n,
      Rule: e
    };
  });
})(Dq);
var M$e = Dq.exports;
const k$e = /* @__PURE__ */ D$e(M$e);
function Q$e(r) {
  return r.map(U$e).map($$e).map(V$e).map(G$e);
}
const U$e = (r, e, t) => {
  if (Aq(r.type)) {
    const i = B$e(t, e);
    if (i && i.text === ".")
      return {
        ...r,
        type: ee.IDENTIFIER,
        text: r.raw
      };
  }
  return r;
}, $$e = (r, e, t) => {
  if (r.type === ee.RESERVED_FUNCTION_NAME) {
    const i = vy(t, e);
    if (!i || !F$e(i))
      return {
        ...r,
        type: ee.RESERVED_KEYWORD
      };
  }
  return r;
}, V$e = (r, e, t) => {
  if (r.type === ee.IDENTIFIER) {
    const i = vy(t, e);
    if (i && Mq(i))
      return {
        ...r,
        type: ee.ARRAY_IDENTIFIER
      };
  }
  return r;
}, G$e = (r, e, t) => {
  if (r.type === ee.RESERVED_KEYWORD) {
    const i = vy(t, e);
    if (i && Mq(i))
      return {
        ...r,
        type: ee.ARRAY_KEYWORD
      };
  }
  return r;
}, B$e = (r, e) => vy(r, e, -1), vy = (r, e, t = 1) => {
  let i = 1;
  for (; r[e + i * t] && X$e(r[e + i * t]); )
    i++;
  return r[e + i * t];
}, F$e = (r) => r.type === ee.OPEN_PAREN && r.text === "(", Mq = (r) => r.type === ee.OPEN_PAREN && r.text === "[", X$e = (r) => r.type === ee.BLOCK_COMMENT || r.type === ee.LINE_COMMENT;
class kq {
  constructor(e) {
    ai(this, "index", 0);
    ai(this, "tokens", []);
    ai(this, "input", "");
    this.tokenize = e;
  }
  reset(e, t) {
    this.input = e, this.index = 0, this.tokens = this.tokenize(e);
  }
  next() {
    return this.tokens[this.index++];
  }
  save() {
  }
  formatError(e) {
    const {
      line: t,
      col: i
    } = Lq(this.input, e.start);
    return `Parse error at token: ${e.text} at line ${t} column ${i}`;
  }
  has(e) {
    return e in ee;
  }
}
let Qe;
(function(r) {
  r.statement = "statement", r.clause = "clause", r.set_operation = "set_operation", r.function_call = "function_call", r.array_subscript = "array_subscript", r.property_access = "property_access", r.parenthesis = "parenthesis", r.between_predicate = "between_predicate", r.case_expression = "case_expression", r.case_when = "case_when", r.case_else = "case_else", r.limit_clause = "limit_clause", r.all_columns_asterisk = "all_columns_asterisk", r.literal = "literal", r.identifier = "identifier", r.keyword = "keyword", r.parameter = "parameter", r.operator = "operator", r.comma = "comma", r.line_comment = "line_comment", r.block_comment = "block_comment";
})(Qe || (Qe = {}));
function HA(r) {
  return r[0];
}
const ze = new kq((r) => []), Dh = ([[r]]) => r, $r = (r) => ({
  type: Qe.keyword,
  tokenType: r.type,
  text: r.text,
  raw: r.raw
}), Yr = (r, {
  leading: e,
  trailing: t
}) => (e != null && e.length && (r = {
  ...r,
  leadingComments: e
}), t != null && t.length && (r = {
  ...r,
  trailingComments: t
}), r), Y$e = (r, {
  leading: e,
  trailing: t
}) => {
  if (e != null && e.length) {
    const [i, ...n] = r;
    r = [Yr(i, {
      leading: e
    }), ...n];
  }
  if (t != null && t.length) {
    const i = r.slice(0, -1), n = r[r.length - 1];
    r = [...i, Yr(n, {
      trailing: t
    })];
  }
  return r;
}, H$e = {
  Lexer: ze,
  ParserRules: [{
    name: "main$ebnf$1",
    symbols: []
  }, {
    name: "main$ebnf$1",
    symbols: ["main$ebnf$1", "statement"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "main",
    symbols: ["main$ebnf$1"],
    postprocess: ([r]) => {
      const e = r[r.length - 1];
      return e && !e.hasSemicolon ? e.children.length > 0 ? r : r.slice(0, -1) : r;
    }
  }, {
    name: "statement$subexpression$1",
    symbols: [ze.has("DELIMITER") ? {
      type: "DELIMITER"
    } : DELIMITER]
  }, {
    name: "statement$subexpression$1",
    symbols: [ze.has("EOF") ? {
      type: "EOF"
    } : EOF]
  }, {
    name: "statement",
    symbols: ["expressions_or_clauses", "statement$subexpression$1"],
    postprocess: ([r, [e]]) => ({
      type: Qe.statement,
      children: r,
      hasSemicolon: e.type === ee.DELIMITER
    })
  }, {
    name: "expressions_or_clauses$ebnf$1",
    symbols: []
  }, {
    name: "expressions_or_clauses$ebnf$1",
    symbols: ["expressions_or_clauses$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expressions_or_clauses$ebnf$2",
    symbols: []
  }, {
    name: "expressions_or_clauses$ebnf$2",
    symbols: ["expressions_or_clauses$ebnf$2", "clause"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expressions_or_clauses",
    symbols: ["expressions_or_clauses$ebnf$1", "expressions_or_clauses$ebnf$2"],
    postprocess: ([r, e]) => [...r, ...e]
  }, {
    name: "clause$subexpression$1",
    symbols: ["limit_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["select_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["other_clause"]
  }, {
    name: "clause$subexpression$1",
    symbols: ["set_operation"]
  }, {
    name: "clause",
    symbols: ["clause$subexpression$1"],
    postprocess: Dh
  }, {
    name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
    symbols: ["free_form_sql"]
  }, {
    name: "limit_clause$ebnf$1$subexpression$1$ebnf$1",
    symbols: ["limit_clause$ebnf$1$subexpression$1$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "limit_clause$ebnf$1$subexpression$1",
    symbols: [ze.has("COMMA") ? {
      type: "COMMA"
    } : COMMA, "limit_clause$ebnf$1$subexpression$1$ebnf$1"]
  }, {
    name: "limit_clause$ebnf$1",
    symbols: ["limit_clause$ebnf$1$subexpression$1"],
    postprocess: HA
  }, {
    name: "limit_clause$ebnf$1",
    symbols: [],
    postprocess: () => null
  }, {
    name: "limit_clause",
    symbols: [ze.has("LIMIT") ? {
      type: "LIMIT"
    } : LIMIT, "_", "expression_chain_", "limit_clause$ebnf$1"],
    postprocess: ([r, e, t, i]) => {
      if (i) {
        const [n, a] = i;
        return {
          type: Qe.limit_clause,
          limitKw: Yr($r(r), {
            trailing: e
          }),
          offset: t,
          count: a
        };
      } else
        return {
          type: Qe.limit_clause,
          limitKw: Yr($r(r), {
            trailing: e
          }),
          count: t
        };
    }
  }, {
    name: "select_clause$subexpression$1$ebnf$1",
    symbols: []
  }, {
    name: "select_clause$subexpression$1$ebnf$1",
    symbols: ["select_clause$subexpression$1$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "select_clause$subexpression$1",
    symbols: ["all_columns_asterisk", "select_clause$subexpression$1$ebnf$1"]
  }, {
    name: "select_clause$subexpression$1$ebnf$2",
    symbols: []
  }, {
    name: "select_clause$subexpression$1$ebnf$2",
    symbols: ["select_clause$subexpression$1$ebnf$2", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "select_clause$subexpression$1",
    symbols: ["asteriskless_free_form_sql", "select_clause$subexpression$1$ebnf$2"]
  }, {
    name: "select_clause",
    symbols: [ze.has("RESERVED_SELECT") ? {
      type: "RESERVED_SELECT"
    } : RESERVED_SELECT, "select_clause$subexpression$1"],
    postprocess: ([r, [e, t]]) => ({
      type: Qe.clause,
      nameKw: $r(r),
      children: [e, ...t]
    })
  }, {
    name: "select_clause",
    symbols: [ze.has("RESERVED_SELECT") ? {
      type: "RESERVED_SELECT"
    } : RESERVED_SELECT],
    postprocess: ([r]) => ({
      type: Qe.clause,
      nameKw: $r(r),
      children: []
    })
  }, {
    name: "all_columns_asterisk",
    symbols: [ze.has("ASTERISK") ? {
      type: "ASTERISK"
    } : ASTERISK],
    postprocess: () => ({
      type: Qe.all_columns_asterisk
    })
  }, {
    name: "other_clause$ebnf$1",
    symbols: []
  }, {
    name: "other_clause$ebnf$1",
    symbols: ["other_clause$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "other_clause",
    symbols: [ze.has("RESERVED_CLAUSE") ? {
      type: "RESERVED_CLAUSE"
    } : RESERVED_CLAUSE, "other_clause$ebnf$1"],
    postprocess: ([r, e]) => ({
      type: Qe.clause,
      nameKw: $r(r),
      children: e
    })
  }, {
    name: "set_operation$ebnf$1",
    symbols: []
  }, {
    name: "set_operation$ebnf$1",
    symbols: ["set_operation$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "set_operation",
    symbols: [ze.has("RESERVED_SET_OPERATION") ? {
      type: "RESERVED_SET_OPERATION"
    } : RESERVED_SET_OPERATION, "set_operation$ebnf$1"],
    postprocess: ([r, e]) => ({
      type: Qe.set_operation,
      nameKw: $r(r),
      children: e
    })
  }, {
    name: "expression_chain_$ebnf$1",
    symbols: ["expression_with_comments_"]
  }, {
    name: "expression_chain_$ebnf$1",
    symbols: ["expression_chain_$ebnf$1", "expression_with_comments_"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expression_chain_",
    symbols: ["expression_chain_$ebnf$1"],
    postprocess: HA
  }, {
    name: "expression_chain$ebnf$1",
    symbols: []
  }, {
    name: "expression_chain$ebnf$1",
    symbols: ["expression_chain$ebnf$1", "_expression_with_comments"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "expression_chain",
    symbols: ["expression", "expression_chain$ebnf$1"],
    postprocess: ([r, e]) => [r, ...e]
  }, {
    name: "andless_expression_chain$ebnf$1",
    symbols: []
  }, {
    name: "andless_expression_chain$ebnf$1",
    symbols: ["andless_expression_chain$ebnf$1", "_andless_expression_with_comments"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "andless_expression_chain",
    symbols: ["andless_expression", "andless_expression_chain$ebnf$1"],
    postprocess: ([r, e]) => [r, ...e]
  }, {
    name: "expression_with_comments_",
    symbols: ["expression", "_"],
    postprocess: ([r, e]) => Yr(r, {
      trailing: e
    })
  }, {
    name: "_expression_with_comments",
    symbols: ["_", "expression"],
    postprocess: ([r, e]) => Yr(e, {
      leading: r
    })
  }, {
    name: "_andless_expression_with_comments",
    symbols: ["_", "andless_expression"],
    postprocess: ([r, e]) => Yr(e, {
      leading: r
    })
  }, {
    name: "free_form_sql$subexpression$1",
    symbols: ["asteriskless_free_form_sql"]
  }, {
    name: "free_form_sql$subexpression$1",
    symbols: ["asterisk"]
  }, {
    name: "free_form_sql",
    symbols: ["free_form_sql$subexpression$1"],
    postprocess: Dh
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["asteriskless_andless_expression"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["logic_operator"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["between_predicate"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["comma"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["comment"]
  }, {
    name: "asteriskless_free_form_sql$subexpression$1",
    symbols: ["other_keyword"]
  }, {
    name: "asteriskless_free_form_sql",
    symbols: ["asteriskless_free_form_sql$subexpression$1"],
    postprocess: Dh
  }, {
    name: "expression$subexpression$1",
    symbols: ["andless_expression"]
  }, {
    name: "expression$subexpression$1",
    symbols: ["logic_operator"]
  }, {
    name: "expression",
    symbols: ["expression$subexpression$1"],
    postprocess: Dh
  }, {
    name: "andless_expression$subexpression$1",
    symbols: ["asteriskless_andless_expression"]
  }, {
    name: "andless_expression$subexpression$1",
    symbols: ["asterisk"]
  }, {
    name: "andless_expression",
    symbols: ["andless_expression$subexpression$1"],
    postprocess: Dh
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["array_subscript"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["case_expression"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["function_call"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["property_access"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["parenthesis"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["curly_braces"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["square_brackets"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["operator"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["identifier"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["parameter"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["literal"]
  }, {
    name: "asteriskless_andless_expression$subexpression$1",
    symbols: ["keyword"]
  }, {
    name: "asteriskless_andless_expression",
    symbols: ["asteriskless_andless_expression$subexpression$1"],
    postprocess: Dh
  }, {
    name: "array_subscript",
    symbols: [ze.has("ARRAY_IDENTIFIER") ? {
      type: "ARRAY_IDENTIFIER"
    } : ARRAY_IDENTIFIER, "_", "square_brackets"],
    postprocess: ([r, e, t]) => ({
      type: Qe.array_subscript,
      array: Yr({
        type: Qe.identifier,
        text: r.text
      }, {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "array_subscript",
    symbols: [ze.has("ARRAY_KEYWORD") ? {
      type: "ARRAY_KEYWORD"
    } : ARRAY_KEYWORD, "_", "square_brackets"],
    postprocess: ([r, e, t]) => ({
      type: Qe.array_subscript,
      array: Yr($r(r), {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "function_call",
    symbols: [ze.has("RESERVED_FUNCTION_NAME") ? {
      type: "RESERVED_FUNCTION_NAME"
    } : RESERVED_FUNCTION_NAME, "_", "parenthesis"],
    postprocess: ([r, e, t]) => ({
      type: Qe.function_call,
      nameKw: Yr($r(r), {
        trailing: e
      }),
      parenthesis: t
    })
  }, {
    name: "parenthesis",
    symbols: [{
      literal: "("
    }, "expressions_or_clauses", {
      literal: ")"
    }],
    postprocess: ([r, e, t]) => ({
      type: Qe.parenthesis,
      children: e,
      openParen: "(",
      closeParen: ")"
    })
  }, {
    name: "curly_braces$ebnf$1",
    symbols: []
  }, {
    name: "curly_braces$ebnf$1",
    symbols: ["curly_braces$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "curly_braces",
    symbols: [{
      literal: "{"
    }, "curly_braces$ebnf$1", {
      literal: "}"
    }],
    postprocess: ([r, e, t]) => ({
      type: Qe.parenthesis,
      children: e,
      openParen: "{",
      closeParen: "}"
    })
  }, {
    name: "square_brackets$ebnf$1",
    symbols: []
  }, {
    name: "square_brackets$ebnf$1",
    symbols: ["square_brackets$ebnf$1", "free_form_sql"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "square_brackets",
    symbols: [{
      literal: "["
    }, "square_brackets$ebnf$1", {
      literal: "]"
    }],
    postprocess: ([r, e, t]) => ({
      type: Qe.parenthesis,
      children: e,
      openParen: "[",
      closeParen: "]"
    })
  }, {
    name: "property_access$subexpression$1",
    symbols: ["identifier"]
  }, {
    name: "property_access$subexpression$1",
    symbols: ["array_subscript"]
  }, {
    name: "property_access$subexpression$1",
    symbols: ["all_columns_asterisk"]
  }, {
    name: "property_access",
    symbols: ["expression", "_", ze.has("DOT") ? {
      type: "DOT"
    } : DOT, "_", "property_access$subexpression$1"],
    postprocess: (
      // Allowing property to be <array_subscript> is currently a hack.
      // A better way would be to allow <property_access> on the left side of array_subscript,
      // but we currently can't do that because of another hack that requires
      // %ARRAY_IDENTIFIER on the left side of <array_subscript>.
      ([r, e, t, i, [n]]) => ({
        type: Qe.property_access,
        object: Yr(r, {
          trailing: e
        }),
        property: Yr(n, {
          leading: i
        })
      })
    )
  }, {
    name: "between_predicate",
    symbols: [ze.has("BETWEEN") ? {
      type: "BETWEEN"
    } : BETWEEN, "_", "andless_expression_chain", "_", ze.has("AND") ? {
      type: "AND"
    } : AND, "_", "andless_expression"],
    postprocess: ([r, e, t, i, n, a, o]) => ({
      type: Qe.between_predicate,
      betweenKw: $r(r),
      expr1: Y$e(t, {
        leading: e,
        trailing: i
      }),
      andKw: $r(n),
      expr2: [Yr(o, {
        leading: a
      })]
    })
  }, {
    name: "case_expression$ebnf$1",
    symbols: ["expression_chain_"],
    postprocess: HA
  }, {
    name: "case_expression$ebnf$1",
    symbols: [],
    postprocess: () => null
  }, {
    name: "case_expression$ebnf$2",
    symbols: []
  }, {
    name: "case_expression$ebnf$2",
    symbols: ["case_expression$ebnf$2", "case_clause"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "case_expression",
    symbols: [ze.has("CASE") ? {
      type: "CASE"
    } : CASE, "_", "case_expression$ebnf$1", "case_expression$ebnf$2", ze.has("END") ? {
      type: "END"
    } : END],
    postprocess: ([r, e, t, i, n]) => ({
      type: Qe.case_expression,
      caseKw: Yr($r(r), {
        trailing: e
      }),
      endKw: $r(n),
      expr: t || [],
      clauses: i
    })
  }, {
    name: "case_clause",
    symbols: [ze.has("WHEN") ? {
      type: "WHEN"
    } : WHEN, "_", "expression_chain_", ze.has("THEN") ? {
      type: "THEN"
    } : THEN, "_", "expression_chain_"],
    postprocess: ([r, e, t, i, n, a]) => ({
      type: Qe.case_when,
      whenKw: Yr($r(r), {
        trailing: e
      }),
      thenKw: Yr($r(i), {
        trailing: n
      }),
      condition: t,
      result: a
    })
  }, {
    name: "case_clause",
    symbols: [ze.has("ELSE") ? {
      type: "ELSE"
    } : ELSE, "_", "expression_chain_"],
    postprocess: ([r, e, t]) => ({
      type: Qe.case_else,
      elseKw: Yr($r(r), {
        trailing: e
      }),
      result: t
    })
  }, {
    name: "comma$subexpression$1",
    symbols: [ze.has("COMMA") ? {
      type: "COMMA"
    } : COMMA]
  }, {
    name: "comma",
    symbols: ["comma$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Qe.comma
    })
  }, {
    name: "asterisk$subexpression$1",
    symbols: [ze.has("ASTERISK") ? {
      type: "ASTERISK"
    } : ASTERISK]
  }, {
    name: "asterisk",
    symbols: ["asterisk$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Qe.operator,
      text: r.text
    })
  }, {
    name: "operator$subexpression$1",
    symbols: [ze.has("OPERATOR") ? {
      type: "OPERATOR"
    } : OPERATOR]
  }, {
    name: "operator",
    symbols: ["operator$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Qe.operator,
      text: r.text
    })
  }, {
    name: "identifier$subexpression$1",
    symbols: [ze.has("IDENTIFIER") ? {
      type: "IDENTIFIER"
    } : IDENTIFIER]
  }, {
    name: "identifier$subexpression$1",
    symbols: [ze.has("QUOTED_IDENTIFIER") ? {
      type: "QUOTED_IDENTIFIER"
    } : QUOTED_IDENTIFIER]
  }, {
    name: "identifier$subexpression$1",
    symbols: [ze.has("VARIABLE") ? {
      type: "VARIABLE"
    } : VARIABLE]
  }, {
    name: "identifier",
    symbols: ["identifier$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Qe.identifier,
      text: r.text
    })
  }, {
    name: "parameter$subexpression$1",
    symbols: [ze.has("NAMED_PARAMETER") ? {
      type: "NAMED_PARAMETER"
    } : NAMED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ze.has("QUOTED_PARAMETER") ? {
      type: "QUOTED_PARAMETER"
    } : QUOTED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ze.has("NUMBERED_PARAMETER") ? {
      type: "NUMBERED_PARAMETER"
    } : NUMBERED_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ze.has("POSITIONAL_PARAMETER") ? {
      type: "POSITIONAL_PARAMETER"
    } : POSITIONAL_PARAMETER]
  }, {
    name: "parameter$subexpression$1",
    symbols: [ze.has("CUSTOM_PARAMETER") ? {
      type: "CUSTOM_PARAMETER"
    } : CUSTOM_PARAMETER]
  }, {
    name: "parameter",
    symbols: ["parameter$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Qe.parameter,
      key: r.key,
      text: r.text
    })
  }, {
    name: "literal$subexpression$1",
    symbols: [ze.has("NUMBER") ? {
      type: "NUMBER"
    } : NUMBER]
  }, {
    name: "literal$subexpression$1",
    symbols: [ze.has("STRING") ? {
      type: "STRING"
    } : STRING]
  }, {
    name: "literal",
    symbols: ["literal$subexpression$1"],
    postprocess: ([[r]]) => ({
      type: Qe.literal,
      text: r.text
    })
  }, {
    name: "keyword$subexpression$1",
    symbols: [ze.has("RESERVED_KEYWORD") ? {
      type: "RESERVED_KEYWORD"
    } : RESERVED_KEYWORD]
  }, {
    name: "keyword$subexpression$1",
    symbols: [ze.has("RESERVED_PHRASE") ? {
      type: "RESERVED_PHRASE"
    } : RESERVED_PHRASE]
  }, {
    name: "keyword$subexpression$1",
    symbols: [ze.has("RESERVED_JOIN") ? {
      type: "RESERVED_JOIN"
    } : RESERVED_JOIN]
  }, {
    name: "keyword",
    symbols: ["keyword$subexpression$1"],
    postprocess: ([[r]]) => $r(r)
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [ze.has("AND") ? {
      type: "AND"
    } : AND]
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [ze.has("OR") ? {
      type: "OR"
    } : OR]
  }, {
    name: "logic_operator$subexpression$1",
    symbols: [ze.has("XOR") ? {
      type: "XOR"
    } : XOR]
  }, {
    name: "logic_operator",
    symbols: ["logic_operator$subexpression$1"],
    postprocess: ([[r]]) => $r(r)
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ze.has("WHEN") ? {
      type: "WHEN"
    } : WHEN]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ze.has("THEN") ? {
      type: "THEN"
    } : THEN]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ze.has("ELSE") ? {
      type: "ELSE"
    } : ELSE]
  }, {
    name: "other_keyword$subexpression$1",
    symbols: [ze.has("END") ? {
      type: "END"
    } : END]
  }, {
    name: "other_keyword",
    symbols: ["other_keyword$subexpression$1"],
    postprocess: ([[r]]) => $r(r)
  }, {
    name: "_$ebnf$1",
    symbols: []
  }, {
    name: "_$ebnf$1",
    symbols: ["_$ebnf$1", "comment"],
    postprocess: (r) => r[0].concat([r[1]])
  }, {
    name: "_",
    symbols: ["_$ebnf$1"],
    postprocess: ([r]) => r
  }, {
    name: "comment",
    symbols: [ze.has("LINE_COMMENT") ? {
      type: "LINE_COMMENT"
    } : LINE_COMMENT],
    postprocess: ([r]) => ({
      type: Qe.line_comment,
      text: r.text,
      precedingWhitespace: r.precedingWhitespace
    })
  }, {
    name: "comment",
    symbols: [ze.has("BLOCK_COMMENT") ? {
      type: "BLOCK_COMMENT"
    } : BLOCK_COMMENT],
    postprocess: ([r]) => ({
      type: Qe.block_comment,
      text: r.text,
      precedingWhitespace: r.precedingWhitespace
    })
  }],
  ParserStart: "main"
}, W$e = H$e, {
  Parser: z$e,
  Grammar: Z$e
} = k$e;
function q$e(r) {
  let e = {};
  const t = new kq((n) => [...Q$e(r.tokenize(n, e)), Rq(n.length)]), i = new z$e(Z$e.fromCompiled(W$e), {
    lexer: t
  });
  return {
    parse: (n, a) => {
      e = a;
      const {
        results: o
      } = i.feed(n);
      if (o.length === 1)
        return o[0];
      throw o.length === 0 ? new Error("Parse error: Invalid SQL") : new Error(`Parse error: Ambiguous grammar
${JSON.stringify(o, void 0, 2)}`);
    }
  };
}
const j$e = /^\s+/u;
function K$e(r, e, t) {
  return J$e(r.split(`
`)).flatMap((i) => {
    if (i.length === 1)
      return i;
    if (e === "tabular")
      return eVe(i);
    if (e === "before")
      return rVe(i, t);
    throw new Error(`Unexpected commaPosition: ${e}`);
  }).join(`
`);
}
function J$e(r) {
  const e = [];
  for (let t = 0; t < r.length; t++) {
    const i = [r[t]];
    for (; r[t].match(/.*,(\s*(--.*)?$)/); )
      t++, i.push(r[t]);
    e.push(i);
  }
  return e;
}
function eVe(r) {
  const e = Iq(aVe(r)) - 1;
  return r.map((t, i) => i === r.length - 1 ? t : tVe(t, e));
}
function tVe(r, e) {
  const [, t, i] = r.match(/^(.*?),(\s*--.*)?$/) || [], n = " ".repeat(e - t.length);
  return `${t}${n},${i ?? ""}`;
}
function rVe(r, e) {
  return nVe(r).map((t, i) => {
    if (i === 0)
      return t;
    const [n] = t.match(j$e) || [""];
    return iVe(n, e) + e.replace(/ {2}$/, ", ") + // add comma to the end of last indent
    t.trimStart();
  });
}
function iVe(r, e) {
  return r.replace(new RegExp(e + "$"), "");
}
function nVe(r) {
  return r.map((e) => e.replace(/,(\s*(--.*)?$)/, "$1"));
}
function aVe(r) {
  return r.map((e) => e.replace(/\s*--.*/, ""));
}
function oVe(r) {
  const e = r.split(`
`);
  let t = [];
  for (let i = 0; i < e.length; i++) {
    if (e[i].match(/^\s*SELECT/i)) {
      let n = [];
      if (e[i].match(/.*,$/))
        n = [e[i]];
      else {
        if (t.push(e[i]), e[i].match(/^\s*SELECT\s+.+(?!,$)/i))
          continue;
        n.push(e[++i]);
      }
      for (; e[i++].match(/.*,$/); )
        n.push(e[i]);
      const a = n.map((s) => ({
        line: s,
        matches: s.match(/(^.*?\S) (AS )?(\S+,?$)/i)
      })).map(({
        line: s,
        matches: l
      }) => l ? {
        precedingText: l[1],
        as: l[2],
        alias: l[3]
      } : {
        precedingText: s
      }), o = Iq(a.map(({
        precedingText: s
      }) => s.replace(/\s*,\s*$/, "")));
      n = a.map(({
        precedingText: s,
        as: l,
        alias: u
      }) => s + (u ? " ".repeat(o - s.length + 1) + (l ?? "") + u : "")), t = [...t, ...n];
    }
    t.push(e[i]);
  }
  return t.join(`
`);
}
let q;
(function(r) {
  r[r.SPACE = 0] = "SPACE", r[r.NO_SPACE = 1] = "NO_SPACE", r[r.NO_NEWLINE = 2] = "NO_NEWLINE", r[r.NEWLINE = 3] = "NEWLINE", r[r.MANDATORY_NEWLINE = 4] = "MANDATORY_NEWLINE", r[r.INDENT = 5] = "INDENT", r[r.SINGLE_INDENT = 6] = "SINGLE_INDENT";
})(q || (q = {}));
let Qq = class {
  constructor(e) {
    ai(this, "items", []);
    this.indentation = e;
  }
  /**
   * Appends token strings and whitespace modifications to SQL string.
   */
  add(...e) {
    for (const t of e)
      switch (t) {
        case q.SPACE:
          this.items.push(q.SPACE);
          break;
        case q.NO_SPACE:
          this.trimHorizontalWhitespace();
          break;
        case q.NO_NEWLINE:
          this.trimWhitespace();
          break;
        case q.NEWLINE:
          this.trimHorizontalWhitespace(), this.addNewline(q.NEWLINE);
          break;
        case q.MANDATORY_NEWLINE:
          this.trimHorizontalWhitespace(), this.addNewline(q.MANDATORY_NEWLINE);
          break;
        case q.INDENT:
          this.addIndentation();
          break;
        case q.SINGLE_INDENT:
          this.items.push(q.SINGLE_INDENT);
          break;
        default:
          this.items.push(t);
      }
  }
  trimHorizontalWhitespace() {
    for (; sVe(lg(this.items)); )
      this.items.pop();
  }
  trimWhitespace() {
    for (; lVe(lg(this.items)); )
      this.items.pop();
  }
  addNewline(e) {
    if (this.items.length > 0)
      switch (lg(this.items)) {
        case q.NEWLINE:
          this.items.pop(), this.items.push(e);
          break;
        case q.MANDATORY_NEWLINE:
          break;
        default:
          this.items.push(e);
          break;
      }
  }
  addIndentation() {
    for (let e = 0; e < this.indentation.getLevel(); e++)
      this.items.push(q.SINGLE_INDENT);
  }
  /**
   * Returns the final SQL string.
   */
  toString() {
    return this.items.map((e) => this.itemToString(e)).join("");
  }
  /**
   * Returns the internal layout data
   */
  getLayoutItems() {
    return this.items;
  }
  itemToString(e) {
    switch (e) {
      case q.SPACE:
        return " ";
      case q.NEWLINE:
      case q.MANDATORY_NEWLINE:
        return `
`;
      case q.SINGLE_INDENT:
        return this.indentation.getSingleIndent();
      default:
        return e;
    }
  }
};
const sVe = (r) => r === q.SPACE || r === q.SINGLE_INDENT, lVe = (r) => r === q.SPACE || r === q.SINGLE_INDENT || r === q.NEWLINE;
function uVe(r, e) {
  if (e === "standard")
    return r;
  let t = [];
  return r.length >= 10 && r.includes(" ") && ([r, ...t] = r.split(" ")), e === "tabularLeft" ? r = r.padEnd(9, " ") : r = r.padStart(9, " "), r + ["", ...t].join(" ");
}
function cVe(r) {
  return MQe(r) || r === ee.RESERVED_CLAUSE || r === ee.RESERVED_SELECT || r === ee.RESERVED_SET_OPERATION || r === ee.RESERVED_JOIN || r === ee.LIMIT;
}
const WA = "top-level", hVe = "block-level";
class Uq {
  /**
   * @param {string} indent A string to indent with
   */
  constructor(e) {
    ai(this, "indentTypes", []);
    this.indent = e;
  }
  /**
   * Returns indentation string for single indentation step.
   */
  getSingleIndent() {
    return this.indent;
  }
  /**
   * Returns current indentation level
   */
  getLevel() {
    return this.indentTypes.length;
  }
  /**
   * Increases indentation by one top-level indent.
   */
  increaseTopLevel() {
    this.indentTypes.push(WA);
  }
  /**
   * Increases indentation by one block-level indent.
   */
  increaseBlockLevel() {
    this.indentTypes.push(hVe);
  }
  /**
   * Decreases indentation by one top-level indent.
   * Does nothing when the previous indent is not top-level.
   */
  decreaseTopLevel() {
    this.indentTypes.length > 0 && lg(this.indentTypes) === WA && this.indentTypes.pop();
  }
  /**
   * Decreases indentation by one block-level indent.
   * If there are top-level indents within the block-level indent,
   * throws away these as well.
   */
  decreaseBlockLevel() {
    for (; this.indentTypes.length > 0 && this.indentTypes.pop() === WA; )
      ;
  }
}
class fVe extends Qq {
  constructor(t) {
    super(new Uq(""));
    ai(this, "length", 0);
    // Keeps track of the trailing whitespace,
    // so that we can decrease length when encountering WS.NO_SPACE,
    // but only when there actually is a space to remove.
    ai(this, "trailingSpace", !1);
    this.expressionWidth = t;
  }
  add(...t) {
    if (t.forEach((i) => this.addToLength(i)), this.length > this.expressionWidth)
      throw new bw();
    super.add(...t);
  }
  addToLength(t) {
    if (typeof t == "string")
      this.length += t.length, this.trailingSpace = !1;
    else {
      if (t === q.MANDATORY_NEWLINE || t === q.NEWLINE)
        throw new bw();
      t === q.INDENT || t === q.SINGLE_INDENT || t === q.SPACE ? this.trailingSpace || (this.length++, this.trailingSpace = !0) : (t === q.NO_NEWLINE || t === q.NO_SPACE) && this.trailingSpace && (this.trailingSpace = !1, this.length--);
    }
  }
}
class bw extends Error {
}
class NS {
  constructor({
    cfg: e,
    dialectCfg: t,
    params: i,
    layout: n,
    inline: a = !1
  }) {
    ai(this, "inline", !1);
    ai(this, "nodes", []);
    ai(this, "index", -1);
    this.cfg = e, this.dialectCfg = t, this.inline = a, this.params = i, this.layout = n;
  }
  format(e) {
    for (this.nodes = e, this.index = 0; this.index < this.nodes.length; this.index++)
      this.formatNode(this.nodes[this.index]);
    return this.layout;
  }
  formatNode(e) {
    this.formatComments(e.leadingComments), this.formatNodeWithoutComments(e), this.formatComments(e.trailingComments);
  }
  formatNodeWithoutComments(e) {
    switch (e.type) {
      case Qe.function_call:
        return this.formatFunctionCall(e);
      case Qe.array_subscript:
        return this.formatArraySubscript(e);
      case Qe.property_access:
        return this.formatPropertyAccess(e);
      case Qe.parenthesis:
        return this.formatParenthesis(e);
      case Qe.between_predicate:
        return this.formatBetweenPredicate(e);
      case Qe.case_expression:
        return this.formatCaseExpression(e);
      case Qe.case_when:
        return this.formatCaseWhen(e);
      case Qe.case_else:
        return this.formatCaseElse(e);
      case Qe.clause:
        return this.formatClause(e);
      case Qe.set_operation:
        return this.formatSetOperation(e);
      case Qe.limit_clause:
        return this.formatLimitClause(e);
      case Qe.all_columns_asterisk:
        return this.formatAllColumnsAsterisk(e);
      case Qe.literal:
        return this.formatLiteral(e);
      case Qe.identifier:
        return this.formatIdentifier(e);
      case Qe.parameter:
        return this.formatParameter(e);
      case Qe.operator:
        return this.formatOperator(e);
      case Qe.comma:
        return this.formatComma(e);
      case Qe.line_comment:
        return this.formatLineComment(e);
      case Qe.block_comment:
        return this.formatBlockComment(e);
      case Qe.keyword:
        return this.formatKeywordNode(e);
    }
  }
  formatFunctionCall(e) {
    this.withComments(e.nameKw, () => {
      this.layout.add(this.showKw(e.nameKw));
    }), this.formatNode(e.parenthesis);
  }
  formatArraySubscript(e) {
    this.withComments(e.array, () => {
      this.layout.add(e.array.type === Qe.keyword ? this.showKw(e.array) : e.array.text);
    }), this.formatNode(e.parenthesis);
  }
  formatPropertyAccess(e) {
    this.formatNode(e.object), this.layout.add(q.NO_SPACE, "."), this.formatNode(e.property);
  }
  formatParenthesis(e) {
    const t = this.formatInlineExpression(e.children);
    t ? (this.layout.add(e.openParen), this.layout.add(...t.getLayoutItems()), this.layout.add(q.NO_SPACE, e.closeParen, q.SPACE)) : (this.layout.add(e.openParen, q.NEWLINE), lp(this.cfg) ? (this.layout.add(q.INDENT), this.layout = this.formatSubExpression(e.children)) : (this.layout.indentation.increaseBlockLevel(), this.layout.add(q.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseBlockLevel()), this.layout.add(q.NEWLINE, q.INDENT, e.closeParen, q.SPACE));
  }
  formatBetweenPredicate(e) {
    this.layout.add(this.showKw(e.betweenKw), q.SPACE), this.layout = this.formatSubExpression(e.expr1), this.layout.add(q.NO_SPACE, q.SPACE, this.showNonTabularKw(e.andKw), q.SPACE), this.layout = this.formatSubExpression(e.expr2), this.layout.add(q.SPACE);
  }
  formatCaseExpression(e) {
    this.formatNode(e.caseKw), this.layout.indentation.increaseBlockLevel(), this.layout = this.formatSubExpression(e.expr), this.layout = this.formatSubExpression(e.clauses), this.layout.indentation.decreaseBlockLevel(), this.layout.add(q.NEWLINE, q.INDENT), this.formatNode(e.endKw);
  }
  formatCaseWhen(e) {
    this.layout.add(q.NEWLINE, q.INDENT), this.formatNode(e.whenKw), this.layout = this.formatSubExpression(e.condition), this.formatNode(e.thenKw), this.layout = this.formatSubExpression(e.result);
  }
  formatCaseElse(e) {
    this.layout.add(q.NEWLINE, q.INDENT), this.formatNode(e.elseKw), this.layout = this.formatSubExpression(e.result);
  }
  formatClause(e) {
    this.isOnelineClause(e) ? this.formatClauseInOnelineStyle(e) : lp(this.cfg) ? this.formatClauseInTabularStyle(e) : this.formatClauseInIndentedStyle(e);
  }
  isOnelineClause(e) {
    return this.dialectCfg.onelineClauses[e.nameKw.text];
  }
  formatClauseInIndentedStyle(e) {
    this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e.nameKw), q.NEWLINE), this.layout.indentation.increaseTopLevel(), this.layout.add(q.INDENT), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel();
  }
  formatClauseInOnelineStyle(e) {
    this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e.nameKw), q.SPACE), this.layout = this.formatSubExpression(e.children);
  }
  formatClauseInTabularStyle(e) {
    this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e.nameKw), q.SPACE), this.layout.indentation.increaseTopLevel(), this.layout = this.formatSubExpression(e.children), this.layout.indentation.decreaseTopLevel();
  }
  formatSetOperation(e) {
    this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e.nameKw), q.NEWLINE), this.layout.add(q.INDENT), this.layout = this.formatSubExpression(e.children);
  }
  formatLimitClause(e) {
    this.withComments(e.limitKw, () => {
      this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e.limitKw));
    }), this.layout.indentation.increaseTopLevel(), lp(this.cfg) ? this.layout.add(q.SPACE) : this.layout.add(q.NEWLINE, q.INDENT), e.offset ? (this.layout = this.formatSubExpression(e.offset), this.layout.add(q.NO_SPACE, ",", q.SPACE), this.layout = this.formatSubExpression(e.count)) : this.layout = this.formatSubExpression(e.count), this.layout.indentation.decreaseTopLevel();
  }
  formatAllColumnsAsterisk(e) {
    this.layout.add("*", q.SPACE);
  }
  formatLiteral(e) {
    this.layout.add(e.text, q.SPACE);
  }
  formatIdentifier(e) {
    this.layout.add(e.text, q.SPACE);
  }
  formatParameter(e) {
    this.layout.add(this.params.get(e), q.SPACE);
  }
  formatOperator({
    text: e
  }) {
    this.cfg.denseOperators || this.dialectCfg.alwaysDenseOperators.includes(e) ? this.layout.add(q.NO_SPACE, e) : e === ":" ? this.layout.add(q.NO_SPACE, e, q.SPACE) : this.layout.add(e, q.SPACE);
  }
  formatComma(e) {
    this.inline ? this.layout.add(q.NO_SPACE, ",", q.SPACE) : this.layout.add(q.NO_SPACE, ",", q.NEWLINE, q.INDENT);
  }
  withComments(e, t) {
    this.formatComments(e.leadingComments), t(), this.formatComments(e.trailingComments);
  }
  formatComments(e) {
    e && e.forEach((t) => {
      t.type === Qe.line_comment ? this.formatLineComment(t) : this.formatBlockComment(t);
    });
  }
  formatLineComment(e) {
    XA(e.precedingWhitespace || "") ? this.layout.add(q.NEWLINE, q.INDENT, e.text, q.MANDATORY_NEWLINE, q.INDENT) : this.layout.getLayoutItems().length > 0 ? this.layout.add(q.NO_NEWLINE, q.SPACE, e.text, q.MANDATORY_NEWLINE, q.INDENT) : this.layout.add(e.text, q.MANDATORY_NEWLINE, q.INDENT);
  }
  formatBlockComment(e) {
    this.isMultilineBlockComment(e) ? (this.splitBlockComment(e.text).forEach((t) => {
      this.layout.add(q.NEWLINE, q.INDENT, t);
    }), this.layout.add(q.NEWLINE, q.INDENT)) : this.layout.add(e.text, q.SPACE);
  }
  isMultilineBlockComment(e) {
    return XA(e.text) || XA(e.precedingWhitespace || "");
  }
  isDocComment(e) {
    const t = e.split(/\n/);
    return (
      // first line starts with /* or /**
      /^\/\*\*?$/.test(t[0]) && // intermediate lines start with *
      t.slice(1, t.length - 1).every((i) => /^\s*\*/.test(i)) && // last line ends with */
      /^\s*\*\/$/.test(lg(t))
    );
  }
  // Breaks up block comment to multiple lines.
  // For example this doc-comment (dots representing leading whitespace):
  //
  //   ..../**
  //   .....* Some description here
  //   .....* and here too
  //   .....*/
  //
  // gets broken to this array (note the leading single spaces):
  //
  //   [ '/**',
  //     '.* Some description here',
  //     '.* and here too',
  //     '.*/' ]
  //
  // However, a normal comment (non-doc-comment) like this:
  //
  //   ..../*
  //   ....Some description here
  //   ....*/
  //
  // gets broken to this array (no leading spaces):
  //
  //   [ '/*',
  //     'Some description here',
  //     '*/' ]
  //
  splitBlockComment(e) {
    return this.isDocComment(e) ? e.split(/\n/).map((t) => /^\s*\*/.test(t) ? " " + t.replace(/^\s*/, "") : t) : e.split(/\n/).map((t) => t.replace(/^\s*/, ""));
  }
  formatSubExpression(e) {
    return new NS({
      cfg: this.cfg,
      dialectCfg: this.dialectCfg,
      params: this.params,
      layout: this.layout,
      inline: this.inline
    }).format(e);
  }
  formatInlineExpression(e) {
    const t = this.params.getPositionalParameterIndex();
    try {
      return new NS({
        cfg: this.cfg,
        dialectCfg: this.dialectCfg,
        params: this.params,
        layout: new fVe(this.cfg.expressionWidth),
        inline: !0
      }).format(e);
    } catch (i) {
      if (i instanceof bw) {
        this.params.setPositionalParameterIndex(t);
        return;
      } else
        throw i;
    }
  }
  formatKeywordNode(e) {
    switch (e.tokenType) {
      case ee.RESERVED_JOIN:
        return this.formatJoin(e);
      case ee.AND:
      case ee.OR:
      case ee.XOR:
        return this.formatLogicalOperator(e);
      default:
        return this.formatKeyword(e);
    }
  }
  formatJoin(e) {
    lp(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e), q.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e), q.SPACE);
  }
  formatKeyword(e) {
    this.layout.add(this.showKw(e), q.SPACE);
  }
  formatLogicalOperator(e) {
    this.cfg.logicalOperatorNewline === "before" ? lp(this.cfg) ? (this.layout.indentation.decreaseTopLevel(), this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e), q.SPACE), this.layout.indentation.increaseTopLevel()) : this.layout.add(q.NEWLINE, q.INDENT, this.showKw(e), q.SPACE) : this.layout.add(this.showKw(e), q.NEWLINE, q.INDENT);
  }
  showKw(e) {
    return cVe(e.tokenType) ? uVe(this.showNonTabularKw(e), this.cfg.indentStyle) : this.showNonTabularKw(e);
  }
  // Like showKw(), but skips tabular formatting
  showNonTabularKw(e) {
    switch (this.cfg.keywordCase) {
      case "preserve":
        return wq(e.raw);
      case "upper":
        return e.text;
      case "lower":
        return e.text.toLowerCase();
    }
  }
}
class dVe {
  constructor(e, t) {
    this.dialect = e, this.cfg = t, this.params = new P$e(this.cfg.params);
  }
  /**
   * Formats an SQL query.
   * @param {string} query - The SQL query string to be formatted
   * @return {string} The formatter query
   */
  format(e) {
    const t = this.parse(e), i = this.formatAst(t);
    return this.postFormat(i).trimEnd();
  }
  parse(e) {
    return q$e(this.dialect.tokenizer).parse(e, this.cfg.paramTypes || {});
  }
  formatAst(e) {
    return e.map((t) => this.formatStatement(t)).join(`
`.repeat(this.cfg.linesBetweenQueries + 1));
  }
  formatStatement(e) {
    const t = new NS({
      cfg: this.cfg,
      dialectCfg: this.dialect.formatOptions,
      params: this.params,
      layout: new Qq(new Uq(f5(this.cfg)))
    }).format(e.children);
    return e.hasSemicolon && (this.cfg.newlineBeforeSemicolon ? t.add(q.NEWLINE, ";") : t.add(q.NO_NEWLINE, ";")), t.toString();
  }
  postFormat(e) {
    return this.cfg.tabulateAlias && (e = oVe(e)), (this.cfg.commaPosition === "before" || this.cfg.commaPosition === "tabular") && (e = K$e(e, this.cfg.commaPosition, f5(this.cfg))), e;
  }
}
class Mu extends Error {
}
function pVe(r) {
  if ("multilineLists" in r)
    throw new Mu("multilineLists config is no more supported.");
  if ("newlineBeforeOpenParen" in r)
    throw new Mu("newlineBeforeOpenParen config is no more supported.");
  if ("newlineBeforeCloseParen" in r)
    throw new Mu("newlineBeforeCloseParen config is no more supported.");
  if ("aliasAs" in r)
    throw new Mu("aliasAs config is no more supported.");
  if (r.expressionWidth <= 0)
    throw new Mu(`expressionWidth config must be positive number. Received ${r.expressionWidth} instead.`);
  if (r.commaPosition === "before" && r.useTabs)
    throw new Mu("commaPosition: before does not work when tabs are used for indentation.");
  return r.params && !gVe(r.params) && console.warn('WARNING: All "params" option values should be strings.'), r;
}
function gVe(r) {
  return (r instanceof Array ? r : Object.values(r)).every((t) => typeof t == "string");
}
const $q = {
  bigquery: "bigquery",
  db2: "db2",
  hive: "hive",
  mariadb: "mariadb",
  mysql: "mysql",
  n1ql: "n1ql",
  plsql: "plsql",
  postgresql: "postgresql",
  redshift: "redshift",
  spark: "spark",
  sqlite: "sqlite",
  sql: "sql",
  trino: "trino",
  transactsql: "transactsql",
  tsql: "transactsql",
  // alias for transactsq
  singlestoredb: "singlestoredb",
  snowflake: "snowflake"
}, vVe = Object.keys($q), OVe = {
  tabWidth: 2,
  useTabs: !1,
  keywordCase: "preserve",
  indentStyle: "standard",
  logicalOperatorNewline: "before",
  tabulateAlias: !1,
  commaPosition: "after",
  expressionWidth: 50,
  linesBetweenQueries: 1,
  denseOperators: !1,
  newlineBeforeSemicolon: !1
}, mVe = (r, e = {}) => {
  if (typeof e.language == "string" && !vVe.includes(e.language))
    throw new Mu(`Unsupported SQL dialect: ${e.language}`);
  const t = $q[e.language || "sql"];
  return EVe(r, {
    ...e,
    dialect: p$e[t]
  });
}, EVe = (r, {
  dialect: e,
  ...t
}) => {
  if (typeof r != "string")
    throw new Error("Invalid query argument. Expected string, instead got " + typeof r);
  const i = pVe({
    ...OVe,
    ...t
  });
  return new dVe(w$e(e), i).format(r);
}, bVe = (r) => (j5("data-v-2c7105e7"), r = r(), K5(), r), SVe = { class: "ns-codeide-option-box" }, TVe = { class: "ns-codeide-optionleft-box" }, yVe = ["src"], RVe = ["src"], AVe = { class: "ns-codeide-optionright-box" }, _Ve = /* @__PURE__ */ bVe(() => /* @__PURE__ */ er("div", { id: "code" }, null, -1)), CVe = { class: "ns-codeide-hide" }, IVe = /* @__PURE__ */ An({
  __name: "codeide",
  props: {
    code: {
      type: String,
      default: ""
    },
    language: {
      type: String,
      default: "javascript"
    },
    formatterFn: {
      type: Function,
      default: void 0
    },
    theme: {
      type: String,
      default: "oneDark"
    }
  },
  emits: ["change", "keypress", "keydown"],
  setup(r, { emit: e }) {
    const t = r, i = Rr(), n = Rr();
    let a = null;
    function o(f) {
      switch (f) {
        case "java":
          return [DQe()];
        case "javascript":
          return [SE()];
        case "css":
          return [pw()];
        case "html":
          return [pw(), MMe(), SE()];
        case "json":
          return [VMe()];
        case "sql":
          return [Rke()];
        case "python":
          return [wQe()];
        default:
          return [SE()];
      }
    }
    function s(f, d) {
      if (!a)
        return;
      const p = a.state.update({
        changes: f,
        selection: d
      });
      a.dispatch(p);
    }
    function l() {
      n.value && n.value.click();
    }
    function u() {
      if (!n.value) {
        setTimeout(() => {
          u();
        }, 200);
        return;
      }
      n.value.addEventListener("change", (f) => {
        const d = f.target.files;
        if (!d)
          return;
        const p = d[0], g = new FileReader();
        g.onload = (v) => {
          var m;
          const O = (m = v.target) == null ? void 0 : m.result;
          if (O && a) {
            const { doc: E, selection: b } = a == null ? void 0 : a.state, S = { from: 0, to: E ? E.length : 0, insert: O };
            b.ranges[0] && (b.ranges[0].to = 0, b.ranges[0].from = 0), s(S, b);
          }
        }, g.readAsText(p);
      });
    }
    function c() {
      if (!a)
        return;
      function f(v) {
        const O = { from: 0, to: p ? p.length : 0, insert: v };
        e("change", v), s(O);
      }
      const { doc: d } = a.state, p = d.toString();
      let g = "";
      if (t.formatterFn)
        g = t.formatterFn(p);
      else
        switch (t.language) {
          case "sql":
            g = mVe(p, { language: "sql" });
            break;
          default:
            console.warn(`ns-codeide: don't supported this language[${t.language}] code formatter!`);
            break;
        }
      if (g)
        switch (eIe(g)) {
          case "promise":
            g.then((v) => {
              f(v);
            });
            break;
          default:
            f(g);
        }
    }
    function h() {
      switch (t.theme) {
        case "oneDark":
          return iB;
        case "materialLight":
          return ELe;
        case "materialDark":
          return TLe;
        case "solarizedLight":
          return ALe;
        case "solarizedDark":
          return ILe;
        case "dracula":
          return xLe;
        case "githubLight":
          return DLe;
        case "tokyoNight":
          return QLe;
        case "tokyoNightStorm":
          return VLe;
        default:
          return console.warn(`ns-codeide don't supported: set theme is ${t.theme}`), iB;
      }
    }
    return Ra(() => t.code, (f, d) => {
      if (a && f !== d) {
        const { doc: p, selection: g } = a.state, v = { from: 0, to: p ? p.length : 0, insert: f };
        s(v, g);
      }
    }), Os(() => {
      var p;
      u();
      const f = [];
      Object.keys(DG).forEach((g) => {
        f.push(DG[g]);
      });
      const d = Rt.create({
        doc: `${t.code}`,
        extensions: [
          oLe,
          Yv.of(f),
          Q8({
            defaultKeymap: !0
          }),
          ...o(t.language),
          h()
        ]
      });
      a = new me({
        state: d,
        parent: ((p = i.value) == null ? void 0 : p.children).code
      }), a == null || a.dom.addEventListener("keyup", (g) => {
        e("change", a == null ? void 0 : a.state.doc.toString());
      });
    }), (f, d) => (xt(), Pr("div", {
      class: "ns-code-ide-box",
      ref_key: "RefMainBox",
      ref: i
    }, [
      er("div", SVe, [
        er("div", TVe, [
          er("img", {
            src: Ef(tIe),
            onClick: c
          }, null, 8, yVe),
          er("img", {
            src: Ef(rIe),
            onClick: l
          }, null, 8, RVe),
          Di(f.$slots, "left-option", {}, void 0, !0)
        ]),
        er("div", AVe, [
          Di(f.$slots, "right-option", {}, void 0, !0)
        ])
      ]),
      _Ve,
      er("div", CVe, [
        er("input", {
          type: "file",
          ref_key: "RefInput",
          ref: n
        }, null, 512)
      ])
    ], 512));
  }
}), wVe = `.ns-code-ide-box[data-v-2c7105e7]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;overflow-y:auto}.ns-code-ide-box .ns-codeide-option-box[data-v-2c7105e7]{width:100%;height:24px;overflow:hidden;box-sizing:border-box;display:flex;justify-content:space-between;align-items:center;border:1px solid var(--ns-border-color);border-bottom:0;background-color:var(--ns-background-gray)}.ns-code-ide-box .ns-codeide-option-box[data-v-2c7105e7] img{width:16px;height:16px;margin:0 5px}.ns-code-ide-box .ns-codeide-option-box[data-v-2c7105e7] img:hover{cursor:pointer;filter:drop-shadow(0 0 1px var(--ns-primary-light-1))}.ns-code-ide-box .ns-codeide-option-box .ns-codeide-optionleft-box[data-v-2c7105e7]{width:50%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:flex-start;align-items:center}.ns-code-ide-box .ns-codeide-option-box .ns-codeide-optionright-box[data-v-2c7105e7]{width:50%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:flex-end;align-items:center}.ns-code-ide-box .ns-codeide-hide[data-v-2c7105e7]{display:none}.ns-code-ide-box #code[data-v-2c7105e7]{width:100%;height:calc(100% - 24px);overflow:hidden;box-sizing:border-box;overflow-y:auto;text-align:left}
`, NVe = `#code{background-color:#f7f7f7}#code .cm-editor{height:100%!important;width:100%}#code .cm-editor .cm-scroller{height:100%;overflow-y:auto}
`, xVe = /* @__PURE__ */ Es(IVe, [["styles", [wVe, NVe]], ["__scopeId", "data-v-2c7105e7"]]);
class an {
  constructor(e) {
    this.table = e;
  }
  //////////////////////////////////////////
  /////////////// DataLoad /////////////////
  //////////////////////////////////////////
  reloadData(e, t, i) {
    return this.table.dataLoader.load(e, void 0, void 0, void 0, t, i);
  }
  //////////////////////////////////////////
  ///////////// Localization ///////////////
  //////////////////////////////////////////
  langText() {
    return this.table.modules.localize.getText(...arguments);
  }
  langBind() {
    return this.table.modules.localize.bind(...arguments);
  }
  langLocale() {
    return this.table.modules.localize.getLocale(...arguments);
  }
  //////////////////////////////////////////
  ////////// Inter Table Comms /////////////
  //////////////////////////////////////////
  commsConnections() {
    return this.table.modules.comms.getConnections(...arguments);
  }
  commsSend() {
    return this.table.modules.comms.send(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Layout  /////////////////
  //////////////////////////////////////////
  layoutMode() {
    return this.table.modules.layout.getMode();
  }
  layoutRefresh(e) {
    return this.table.modules.layout.layout(e);
  }
  //////////////////////////////////////////
  /////////////// Event Bus ////////////////
  //////////////////////////////////////////
  subscribe() {
    return this.table.eventBus.subscribe(...arguments);
  }
  unsubscribe() {
    return this.table.eventBus.unsubscribe(...arguments);
  }
  subscribed(e) {
    return this.table.eventBus.subscribed(e);
  }
  subscriptionChange() {
    return this.table.eventBus.subscriptionChange(...arguments);
  }
  dispatch() {
    return this.table.eventBus.dispatch(...arguments);
  }
  chain() {
    return this.table.eventBus.chain(...arguments);
  }
  confirm() {
    return this.table.eventBus.confirm(...arguments);
  }
  dispatchExternal() {
    return this.table.externalEvents.dispatch(...arguments);
  }
  subscribedExternal(e) {
    return this.table.externalEvents.subscribed(e);
  }
  subscriptionChangeExternal() {
    return this.table.externalEvents.subscriptionChange(...arguments);
  }
  //////////////////////////////////////////
  //////////////// Options /////////////////
  //////////////////////////////////////////
  options(e) {
    return this.table.options[e];
  }
  setOption(e, t) {
    return typeof t < "u" && (this.table.options[e] = t), this.table.options[e];
  }
  //////////////////////////////////////////
  /////////// Deprecation Checks ///////////
  //////////////////////////////////////////
  deprecationCheck(e, t) {
    return this.table.deprecationAdvisor.check(e, t);
  }
  deprecationCheckMsg(e, t) {
    return this.table.deprecationAdvisor.checkMsg(e, t);
  }
  deprecationMsg(e) {
    return this.table.deprecationAdvisor.msg(e);
  }
  //////////////////////////////////////////
  //////////////// Modules /////////////////
  //////////////////////////////////////////
  module(e) {
    return this.table.module(e);
  }
}
class Zt {
  static elVisible(e) {
    return !(e.offsetWidth <= 0 && e.offsetHeight <= 0);
  }
  static elOffset(e) {
    var t = e.getBoundingClientRect();
    return {
      top: t.top + window.pageYOffset - document.documentElement.clientTop,
      left: t.left + window.pageXOffset - document.documentElement.clientLeft
    };
  }
  static deepClone(e, t, i = []) {
    var n = {}.__proto__, a = [].__proto__;
    t || (t = Object.assign(Array.isArray(e) ? [] : {}, e));
    for (var o in e) {
      let s = e[o], l, u;
      s != null && typeof s == "object" && (s.__proto__ === n || s.__proto__ === a) && (l = i.findIndex((c) => c.subject === s), l > -1 ? t[o] = i[l].copy : (u = Object.assign(Array.isArray(s) ? [] : {}, s), i.unshift({ subject: s, copy: u }), t[o] = this.deepClone(s, u, i)));
    }
    return t;
  }
}
class xP extends an {
  constructor(e, t, i) {
    super(e), this.element = t, this.container = this._lookupContainer(), this.parent = i, this.reversedX = !1, this.childPopup = null, this.blurable = !1, this.blurCallback = null, this.blurEventsBound = !1, this.renderedCallback = null, this.visible = !1, this.hideable = !0, this.element.classList.add("tabulator-popup-container"), this.blurEvent = this.hide.bind(this, !1), this.escEvent = this._escapeCheck.bind(this), this.destroyBinding = this.tableDestroyed.bind(this), this.destroyed = !1;
  }
  tableDestroyed() {
    this.destroyed = !0, this.hide(!0);
  }
  _lookupContainer() {
    var e = this.table.options.popupContainer;
    return typeof e == "string" ? (e = document.querySelector(e), e || console.warn("Menu Error - no container element found matching selector:", this.table.options.popupContainer, "(defaulting to document body)")) : e === !0 && (e = this.table.element), e && !this._checkContainerIsParent(e) && (e = !1, console.warn("Menu Error - container element does not contain this table:", this.table.options.popupContainer, "(defaulting to document body)")), e || (e = document.body), e;
  }
  _checkContainerIsParent(e, t = this.table.element) {
    return e === t ? !0 : t.parentNode ? this._checkContainerIsParent(e, t.parentNode) : !1;
  }
  renderCallback(e) {
    this.renderedCallback = e;
  }
  containerEventCoords(e) {
    var t = !(e instanceof MouseEvent), i = t ? e.touches[0].pageX : e.pageX, n = t ? e.touches[0].pageY : e.pageY;
    if (this.container !== document.body) {
      let a = Zt.elOffset(this.container);
      i -= a.left, n -= a.top;
    }
    return { x: i, y: n };
  }
  elementPositionCoords(e, t = "right") {
    var i = Zt.elOffset(e), n, a, o;
    switch (this.container !== document.body && (n = Zt.elOffset(this.container), i.left -= n.left, i.top -= n.top), t) {
      case "right":
        a = i.left + e.offsetWidth, o = i.top - 1;
        break;
      case "bottom":
        a = i.left, o = i.top + e.offsetHeight;
        break;
      case "left":
        a = i.left, o = i.top - 1;
        break;
      case "top":
        a = i.left, o = i.top;
        break;
      case "center":
        a = i.left + e.offsetWidth / 2, o = i.top + e.offsetHeight / 2;
        break;
    }
    return { x: a, y: o, offset: i };
  }
  show(e, t) {
    var i, n, a, o, s;
    return this.destroyed || this.table.destroyed ? this : (e instanceof HTMLElement ? (a = e, s = this.elementPositionCoords(e, t), o = s.offset, i = s.x, n = s.y) : typeof e == "number" ? (o = { top: 0, left: 0 }, i = e, n = t) : (s = this.containerEventCoords(e), i = s.x, n = s.y, this.reversedX = !1), this.element.style.top = n + "px", this.element.style.left = i + "px", this.container.appendChild(this.element), typeof this.renderedCallback == "function" && this.renderedCallback(), this._fitToScreen(i, n, a, o, t), this.visible = !0, this.subscribe("table-destroy", this.destroyBinding), this.element.addEventListener("mousedown", (l) => {
      l.stopPropagation();
    }), this);
  }
  _fitToScreen(e, t, i, n, a) {
    var o = this.container === document.body ? document.documentElement.scrollTop : this.container.scrollTop;
    if ((e + this.element.offsetWidth >= this.container.offsetWidth || this.reversedX) && (this.element.style.left = "", i ? this.element.style.right = this.container.offsetWidth - n.left + "px" : this.element.style.right = this.container.offsetWidth - e + "px", this.reversedX = !0), t + this.element.offsetHeight > Math.max(this.container.offsetHeight, o ? this.container.scrollHeight : 0))
      if (i)
        switch (a) {
          case "bottom":
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight - i.offsetHeight - 1 + "px";
            break;
          default:
            this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + i.offsetHeight + 1 + "px";
        }
      else
        this.element.style.top = parseInt(this.element.style.top) - this.element.offsetHeight + "px";
  }
  isVisible() {
    return this.visible;
  }
  hideOnBlur(e) {
    return this.blurable = !0, this.visible && (setTimeout(() => {
      this.visible && (this.table.rowManager.element.addEventListener("scroll", this.blurEvent), this.subscribe("cell-editing", this.blurEvent), document.body.addEventListener("click", this.blurEvent), document.body.addEventListener("contextmenu", this.blurEvent), document.body.addEventListener("mousedown", this.blurEvent), window.addEventListener("resize", this.blurEvent), document.body.addEventListener("keydown", this.escEvent), this.blurEventsBound = !0);
    }, 100), this.blurCallback = e), this;
  }
  _escapeCheck(e) {
    e.keyCode == 27 && this.hide();
  }
  blockHide() {
    this.hideable = !1;
  }
  restoreHide() {
    this.hideable = !0;
  }
  hide(e = !1) {
    return this.visible && this.hideable && (this.blurable && this.blurEventsBound && (document.body.removeEventListener("keydown", this.escEvent), document.body.removeEventListener("click", this.blurEvent), document.body.removeEventListener("contextmenu", this.blurEvent), document.body.removeEventListener("mousedown", this.blurEvent), window.removeEventListener("resize", this.blurEvent), this.table.rowManager.element.removeEventListener("scroll", this.blurEvent), this.unsubscribe("cell-editing", this.blurEvent), this.blurEventsBound = !1), this.childPopup && this.childPopup.hide(), this.parent && (this.parent.childPopup = null), this.element.parentNode && this.element.parentNode.removeChild(this.element), this.visible = !1, this.blurCallback && !e && this.blurCallback(), this.unsubscribe("table-destroy", this.destroyBinding)), this;
  }
  child(e) {
    return this.childPopup && this.childPopup.hide(), this.childPopup = new xP(this.table, e, this), this.childPopup;
  }
}
class mt extends an {
  constructor(e, t) {
    super(e), this._handler = null;
  }
  initialize() {
  }
  ///////////////////////////////////
  ////// Options Registration ///////
  ///////////////////////////////////
  registerTableOption(e, t) {
    this.table.optionsList.register(e, t);
  }
  registerColumnOption(e, t) {
    this.table.columnManager.optionsList.register(e, t);
  }
  ///////////////////////////////////
  /// Public Function Registration ///
  ///////////////////////////////////
  registerTableFunction(e, t) {
    typeof this.table[e] > "u" ? this.table[e] = (...i) => (this.table.initGuard(e), t(...i)) : console.warn("Unable to bind table function, name already in use", e);
  }
  registerComponentFunction(e, t, i) {
    return this.table.componentFunctionBinder.bind(e, t, i);
  }
  ///////////////////////////////////
  ////////// Data Pipeline //////////
  ///////////////////////////////////
  registerDataHandler(e, t) {
    this.table.rowManager.registerDataPipelineHandler(e, t), this._handler = e;
  }
  registerDisplayHandler(e, t) {
    this.table.rowManager.registerDisplayPipelineHandler(e, t), this._handler = e;
  }
  displayRows(e) {
    var t = this.table.rowManager.displayRows.length - 1, i;
    if (this._handler && (i = this.table.rowManager.displayPipeline.findIndex((n) => n.handler === this._handler), i > -1 && (t = i)), e && (t = t + e), this._handler)
      return t > -1 ? this.table.rowManager.getDisplayRows(t) : this.activeRows();
  }
  activeRows() {
    return this.table.rowManager.activeRows;
  }
  refreshData(e, t) {
    t || (t = this._handler), t && this.table.rowManager.refreshActiveData(t, !1, e);
  }
  ///////////////////////////////////
  //////// Footer Management ////////
  ///////////////////////////////////
  footerAppend(e) {
    return this.table.footerManager.append(e);
  }
  footerPrepend(e) {
    return this.table.footerManager.prepend(e);
  }
  footerRemove(e) {
    return this.table.footerManager.remove(e);
  }
  ///////////////////////////////////
  //////// Popups Management ////////
  ///////////////////////////////////
  popup(e, t) {
    return new xP(this.table, e, t);
  }
  ///////////////////////////////////
  //////// Alert Management ////////
  ///////////////////////////////////
  alert(e, t) {
    return this.table.alertManager.alert(e, t);
  }
  clearAlert() {
    return this.table.alertManager.clear();
  }
}
var PVe = {};
class $c extends mt {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "download", "clipboard", "print", "htmlOutput"], this.registerColumnOption("accessor"), this.registerColumnOption("accessorParams"), this.registerColumnOption("accessorData"), this.registerColumnOption("accessorDataParams"), this.registerColumnOption("accessorDownload"), this.registerColumnOption("accessorDownloadParams"), this.registerColumnOption("accessorClipboard"), this.registerColumnOption("accessorClipboardParams"), this.registerColumnOption("accessorPrint"), this.registerColumnOption("accessorPrintParams"), this.registerColumnOption("accessorHtmlOutput"), this.registerColumnOption("accessorHtmlOutputParams");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-retrieve", this.transformRow.bind(this));
  }
  //initialize column accessor
  initializeColumn(e) {
    var t = !1, i = {};
    this.allowedTypes.forEach((n) => {
      var a = "accessor" + (n.charAt(0).toUpperCase() + n.slice(1)), o;
      e.definition[a] && (o = this.lookupAccessor(e.definition[a]), o && (t = !0, i[a] = {
        accessor: o,
        params: e.definition[a + "Params"] || {}
      }));
    }), t && (e.modules.accessor = i);
  }
  lookupAccessor(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        $c.accessors[e] ? t = $c.accessors[e] : console.warn("Accessor Error - No such accessor found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply accessor to row
  transformRow(e, t) {
    var i = "accessor" + (t.charAt(0).toUpperCase() + t.slice(1)), n = e.getComponent(), a = Zt.deepClone(e.data || {});
    return this.table.columnManager.traverse(function(o) {
      var s, l, u, c;
      o.modules.accessor && (l = o.modules.accessor[i] || o.modules.accessor.accessor || !1, l && (s = o.getFieldValue(a), s != "undefined" && (c = o.getComponent(), u = typeof l.params == "function" ? l.params(s, a, t, c, n) : l.params, o.setFieldValue(a, l.accessor(s, a, t, u, c, n)))));
    }), a;
  }
}
$c.moduleName = "accessor";
$c.accessors = PVe;
var LVe = {
  method: "GET"
};
function Sw(r, e) {
  var t = [];
  if (e = e || "", Array.isArray(r))
    r.forEach((n, a) => {
      t = t.concat(Sw(n, e ? e + "[" + a + "]" : a));
    });
  else if (typeof r == "object")
    for (var i in r)
      t = t.concat(Sw(r[i], e ? e + "[" + i + "]" : i));
  else
    t.push({ key: e, value: r });
  return t;
}
function DVe(r) {
  var e = Sw(r), t = [];
  return e.forEach(function(i) {
    t.push(encodeURIComponent(i.key) + "=" + encodeURIComponent(i.value));
  }), t.join("&");
}
function Vq(r, e, t) {
  return r && t && Object.keys(t).length && (!e.method || e.method.toLowerCase() == "get") && (e.method = "get", r += (r.includes("?") ? "&" : "?") + DVe(t)), r;
}
function MVe(r, e, t) {
  var i;
  return new Promise((n, a) => {
    if (r = this.urlGenerator.call(this.table, r, e, t), e.method.toUpperCase() != "GET")
      if (i = typeof this.table.options.ajaxContentType == "object" ? this.table.options.ajaxContentType : this.contentTypeFormatters[this.table.options.ajaxContentType], i) {
        for (var o in i.headers)
          e.headers || (e.headers = {}), typeof e.headers[o] > "u" && (e.headers[o] = i.headers[o]);
        e.body = i.body.call(this, r, e, t);
      } else
        console.warn("Ajax Error - Invalid ajaxContentType value:", this.table.options.ajaxContentType);
    r ? (typeof e.headers > "u" && (e.headers = {}), typeof e.headers.Accept > "u" && (e.headers.Accept = "application/json"), typeof e.headers["X-Requested-With"] > "u" && (e.headers["X-Requested-With"] = "XMLHttpRequest"), typeof e.mode > "u" && (e.mode = "cors"), e.mode == "cors" ? (typeof e.headers.Origin > "u" && (e.headers.Origin = window.location.origin), typeof e.credentials > "u" && (e.credentials = "same-origin")) : typeof e.credentials > "u" && (e.credentials = "include"), fetch(r, e).then((s) => {
      s.ok ? s.json().then((l) => {
        n(l);
      }).catch((l) => {
        a(l), console.warn("Ajax Load Error - Invalid JSON returned", l);
      }) : (console.error("Ajax Load Error - Connection Error: " + s.status, s.statusText), a(s));
    }).catch((s) => {
      console.error("Ajax Load Error - Connection Error: ", s), a(s);
    })) : (console.warn("Ajax Load Error - No URL Set"), n([]));
  });
}
function Tw(r, e) {
  var t = [];
  if (e = e || "", Array.isArray(r))
    r.forEach((n, a) => {
      t = t.concat(Tw(n, e ? e + "[" + a + "]" : a));
    });
  else if (typeof r == "object")
    for (var i in r)
      t = t.concat(Tw(r[i], e ? e + "[" + i + "]" : i));
  else
    t.push({ key: e, value: r });
  return t;
}
var kVe = {
  json: {
    headers: {
      "Content-Type": "application/json"
    },
    body: function(r, e, t) {
      return JSON.stringify(t);
    }
  },
  form: {
    headers: {},
    body: function(r, e, t) {
      var i = Tw(t), n = new FormData();
      return i.forEach(function(a) {
        n.append(a.key, a.value);
      }), n;
    }
  }
};
class ya extends mt {
  constructor(e) {
    super(e), this.config = {}, this.url = "", this.urlGenerator = !1, this.params = !1, this.loaderPromise = !1, this.registerTableOption("ajaxURL", !1), this.registerTableOption("ajaxURLGenerator", !1), this.registerTableOption("ajaxParams", {}), this.registerTableOption("ajaxConfig", "get"), this.registerTableOption("ajaxContentType", "form"), this.registerTableOption("ajaxRequestFunc", !1), this.registerTableOption("ajaxRequesting", function() {
    }), this.registerTableOption("ajaxResponse", !1), this.contentTypeFormatters = ya.contentTypeFormatters;
  }
  //initialize setup options
  initialize() {
    this.loaderPromise = this.table.options.ajaxRequestFunc || ya.defaultLoaderPromise, this.urlGenerator = this.table.options.ajaxURLGenerator || ya.defaultURLGenerator, this.table.options.ajaxURL && this.setUrl(this.table.options.ajaxURL), this.setDefaultConfig(this.table.options.ajaxConfig), this.registerTableFunction("getAjaxUrl", this.getUrl.bind(this)), this.subscribe("data-loading", this.requestDataCheck.bind(this)), this.subscribe("data-params", this.requestParams.bind(this)), this.subscribe("data-load", this.requestData.bind(this));
  }
  requestParams(e, t, i, n) {
    var a = this.table.options.ajaxParams;
    return a && (typeof a == "function" && (a = a.call(this.table)), n = Object.assign(n, a)), n;
  }
  requestDataCheck(e, t, i, n) {
    return !!(!e && this.url || typeof e == "string");
  }
  requestData(e, t, i, n, a) {
    var o;
    return !a && this.requestDataCheck(e) ? (e && this.setUrl(e), o = this.generateConfig(i), this.sendRequest(this.url, t, o)) : a;
  }
  setDefaultConfig(e = {}) {
    this.config = Object.assign({}, ya.defaultConfig), typeof e == "string" ? this.config.method = e : Object.assign(this.config, e);
  }
  //load config object
  generateConfig(e = {}) {
    var t = Object.assign({}, this.config);
    return typeof e == "string" ? t.method = e : Object.assign(t, e), t;
  }
  //set request url
  setUrl(e) {
    this.url = e;
  }
  //get request url
  getUrl() {
    return this.url;
  }
  //send ajax request
  sendRequest(e, t, i) {
    return this.table.options.ajaxRequesting.call(this.table, e, t) !== !1 ? this.loaderPromise(e, i, t).then((n) => (this.table.options.ajaxResponse && (n = this.table.options.ajaxResponse.call(this.table, e, t, n)), n)) : Promise.reject();
  }
}
ya.moduleName = "ajax";
ya.defaultConfig = LVe;
ya.defaultURLGenerator = Vq;
ya.defaultLoaderPromise = MVe;
ya.contentTypeFormatters = kVe;
var QVe = {
  replace: function(r) {
    return this.table.setData(r);
  },
  update: function(r) {
    return this.table.updateOrAddData(r);
  },
  insert: function(r) {
    return this.table.addData(r);
  }
}, UVe = {
  table: function(r) {
    var e = [], t = !0, i = this.table.columnManager.columns, n = [], a = [];
    return r = r.split(`
`), r.forEach(function(o) {
      e.push(o.split("	"));
    }), e.length && !(e.length === 1 && e[0].length < 2) ? (e[0].forEach(function(o) {
      var s = i.find(function(l) {
        return o && l.definition.title && o.trim() && l.definition.title.trim() === o.trim();
      });
      s ? n.push(s) : t = !1;
    }), t || (t = !0, n = [], e[0].forEach(function(o) {
      var s = i.find(function(l) {
        return o && l.field && o.trim() && l.field.trim() === o.trim();
      });
      s ? n.push(s) : t = !1;
    }), t || (n = this.table.columnManager.columnsByIndex)), t && e.shift(), e.forEach(function(o) {
      var s = {};
      o.forEach(function(l, u) {
        n[u] && (s[n[u].field] = l);
      }), a.push(s);
    }), a) : !1;
  }
};
class Yl extends mt {
  constructor(e) {
    super(e), this.mode = !0, this.pasteParser = function() {
    }, this.pasteAction = function() {
    }, this.customSelection = !1, this.rowRange = !1, this.blocked = !0, this.registerTableOption("clipboard", !1), this.registerTableOption("clipboardCopyStyled", !0), this.registerTableOption("clipboardCopyConfig", !1), this.registerTableOption("clipboardCopyFormatter", !1), this.registerTableOption("clipboardCopyRowRange", "active"), this.registerTableOption("clipboardPasteParser", "table"), this.registerTableOption("clipboardPasteAction", "insert"), this.registerColumnOption("clipboard"), this.registerColumnOption("titleClipboard");
  }
  initialize() {
    this.mode = this.table.options.clipboard, this.rowRange = this.table.options.clipboardCopyRowRange, (this.mode === !0 || this.mode === "copy") && this.table.element.addEventListener("copy", (e) => {
      var t, i, n;
      this.blocked || (e.preventDefault(), this.customSelection ? (t = this.customSelection, this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t))) : (n = this.table.modules.export.generateExportList(this.table.options.clipboardCopyConfig, this.table.options.clipboardCopyStyled, this.rowRange, "clipboard"), i = this.table.modules.export.generateHTMLTable(n), t = i ? this.generatePlainContent(n) : "", this.table.options.clipboardCopyFormatter && (t = this.table.options.clipboardCopyFormatter("plain", t), i = this.table.options.clipboardCopyFormatter("html", i))), window.clipboardData && window.clipboardData.setData ? window.clipboardData.setData("Text", t) : e.clipboardData && e.clipboardData.setData ? (e.clipboardData.setData("text/plain", t), i && e.clipboardData.setData("text/html", i)) : e.originalEvent && e.originalEvent.clipboardData.setData && (e.originalEvent.clipboardData.setData("text/plain", t), i && e.originalEvent.clipboardData.setData("text/html", i)), this.dispatchExternal("clipboardCopied", t, i), this.reset());
    }), (this.mode === !0 || this.mode === "paste") && this.table.element.addEventListener("paste", (e) => {
      this.paste(e);
    }), this.setPasteParser(this.table.options.clipboardPasteParser), this.setPasteAction(this.table.options.clipboardPasteAction), this.registerTableFunction("copyToClipboard", this.copy.bind(this));
  }
  reset() {
    this.blocked = !0, this.customSelection = !1;
  }
  generatePlainContent(e) {
    var t = [];
    return e.forEach((i) => {
      var n = [];
      i.columns.forEach((a) => {
        var o = "";
        if (a)
          if (i.type === "group" && (a.value = a.component.getKey()), a.value === null)
            o = "";
          else
            switch (typeof a.value) {
              case "object":
                o = JSON.stringify(a.value);
                break;
              case "undefined":
                o = "";
                break;
              default:
                o = a.value;
            }
        n.push(o);
      }), t.push(n.join("	"));
    }), t.join(`
`);
  }
  copy(e, t) {
    var i, n;
    this.blocked = !1, this.customSelection = !1, (this.mode === !0 || this.mode === "copy") && (this.rowRange = e || this.table.options.clipboardCopyRowRange, typeof window.getSelection < "u" && typeof document.createRange < "u" ? (e = document.createRange(), e.selectNodeContents(this.table.element), i = window.getSelection(), i.toString() && t && (this.customSelection = i.toString()), i.removeAllRanges(), i.addRange(e)) : typeof document.selection < "u" && typeof document.body.createTextRange < "u" && (n = document.body.createTextRange(), n.moveToElementText(this.table.element), n.select()), document.execCommand("copy"), i && i.removeAllRanges());
  }
  //PASTE EVENT HANDLING
  setPasteAction(e) {
    switch (typeof e) {
      case "string":
        this.pasteAction = Yl.pasteActions[e], this.pasteAction || console.warn("Clipboard Error - No such paste action found:", e);
        break;
      case "function":
        this.pasteAction = e;
        break;
    }
  }
  setPasteParser(e) {
    switch (typeof e) {
      case "string":
        this.pasteParser = Yl.pasteParsers[e], this.pasteParser || console.warn("Clipboard Error - No such paste parser found:", e);
        break;
      case "function":
        this.pasteParser = e;
        break;
    }
  }
  paste(e) {
    var t, i, n;
    this.checkPaseOrigin(e) && (t = this.getPasteData(e), i = this.pasteParser.call(this, t), i ? (e.preventDefault(), this.table.modExists("mutator") && (i = this.mutateData(i)), n = this.pasteAction.call(this, i), this.dispatchExternal("clipboardPasted", t, i, n)) : this.dispatchExternal("clipboardPasteError", t));
  }
  mutateData(e) {
    var t = [];
    return Array.isArray(e) ? e.forEach((i) => {
      t.push(this.table.modules.mutator.transformRow(i, "clipboard"));
    }) : t = e, t;
  }
  checkPaseOrigin(e) {
    var t = !0;
    return (e.target.tagName != "DIV" || this.table.modules.edit.currentCell) && (t = !1), t;
  }
  getPasteData(e) {
    var t;
    return window.clipboardData && window.clipboardData.getData ? t = window.clipboardData.getData("Text") : e.clipboardData && e.clipboardData.getData ? t = e.clipboardData.getData("text/plain") : e.originalEvent && e.originalEvent.clipboardData.getData && (t = e.originalEvent.clipboardData.getData("text/plain")), t;
  }
}
Yl.moduleName = "clipboard";
Yl.pasteActions = QVe;
Yl.pasteParsers = UVe;
class $Ve {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._row.table.componentFunctionBinder.handle("row", t._row, i);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getTable() {
    return this._row.table;
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  _getSelf() {
    return this._row;
  }
}
class Gq {
  constructor(e) {
    return this._cell = e, new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._cell.table.componentFunctionBinder.handle("cell", t._cell, i);
      }
    });
  }
  getValue() {
    return this._cell.getValue();
  }
  getOldValue() {
    return this._cell.getOldValue();
  }
  getInitialValue() {
    return this._cell.initialValue;
  }
  getElement() {
    return this._cell.getElement();
  }
  getRow() {
    return this._cell.row.getComponent();
  }
  getData(e) {
    return this._cell.row.getData(e);
  }
  getType() {
    return "cell";
  }
  getField() {
    return this._cell.column.getField();
  }
  getColumn() {
    return this._cell.column.getComponent();
  }
  setValue(e, t) {
    typeof t > "u" && (t = !0), this._cell.setValue(e, t);
  }
  restoreOldValue() {
    this._cell.setValueActual(this._cell.getOldValue());
  }
  restoreInitialValue() {
    this._cell.setValueActual(this._cell.initialValue);
  }
  checkHeight() {
    this._cell.checkHeight();
  }
  getTable() {
    return this._cell.table;
  }
  _getSelf() {
    return this._cell;
  }
}
class Kv extends an {
  constructor(e, t) {
    super(e.table), this.table = e.table, this.column = e, this.row = t, this.element = null, this.value = null, this.initialValue, this.oldValue = null, this.modules = {}, this.height = null, this.width = null, this.minWidth = null, this.component = null, this.loaded = !1, this.build();
  }
  //////////////// Setup Functions /////////////////
  //generate element
  build() {
    this.generateElement(), this.setWidth(), this._configureCell(), this.setValueActual(this.column.getFieldValue(this.row.data)), this.initialValue = this.value;
  }
  generateElement() {
    this.element = document.createElement("div"), this.element.className = "tabulator-cell", this.element.setAttribute("role", "gridcell");
  }
  _configureCell() {
    var e = this.element, t = this.column.getField(), i = {
      top: "flex-start",
      bottom: "flex-end",
      middle: "center"
    }, n = {
      left: "flex-start",
      right: "flex-end",
      center: "center"
    };
    if (e.style.textAlign = this.column.hozAlign, this.column.vertAlign && (e.style.display = "inline-flex", e.style.alignItems = i[this.column.vertAlign] || "", this.column.hozAlign && (e.style.justifyContent = n[this.column.hozAlign] || "")), t && e.setAttribute("tabulator-field", t), this.column.definition.cssClass) {
      var a = this.column.definition.cssClass.split(" ");
      a.forEach((o) => {
        e.classList.add(o);
      });
    }
    this.dispatch("cell-init", this), this.column.visible || this.hide();
  }
  //generate cell contents
  _generateContents() {
    var e;
    switch (e = this.chain("cell-format", this, null, () => this.element.innerHTML = this.value), typeof e) {
      case "object":
        if (e instanceof Node) {
          for (; this.element.firstChild; )
            this.element.removeChild(this.element.firstChild);
          this.element.appendChild(e);
        } else
          this.element.innerHTML = "", e != null && console.warn("Format Error - Formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", e);
        break;
      case "undefined":
        this.element.innerHTML = "";
        break;
      default:
        this.element.innerHTML = e;
    }
  }
  cellRendered() {
    this.dispatch("cell-rendered", this);
  }
  //////////////////// Getters ////////////////////
  getElement(e) {
    return this.loaded || (this.loaded = !0, e || this.layoutElement()), this.element;
  }
  getValue() {
    return this.value;
  }
  getOldValue() {
    return this.oldValue;
  }
  //////////////////// Actions ////////////////////
  setValue(e, t, i) {
    var n = this.setValueProcessData(e, t, i);
    n && (this.dispatch("cell-value-updated", this), this.cellRendered(), this.column.definition.cellEdited && this.column.definition.cellEdited.call(this.table, this.getComponent()), this.dispatchExternal("cellEdited", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()));
  }
  setValueProcessData(e, t, i) {
    var n = !1;
    return (this.value !== e || i) && (n = !0, t && (e = this.chain("cell-value-changing", [this, e], null, e))), this.setValueActual(e), n && this.dispatch("cell-value-changed", this), n;
  }
  setValueActual(e) {
    this.oldValue = this.value, this.value = e, this.dispatch("cell-value-save-before", this), this.column.setFieldValue(this.row.data, e), this.dispatch("cell-value-save-after", this), this.loaded && this.layoutElement();
  }
  layoutElement() {
    this._generateContents(), this.dispatch("cell-layout", this);
  }
  setWidth() {
    this.width = this.column.width, this.element.style.width = this.column.widthStyled;
  }
  clearWidth() {
    this.width = "", this.element.style.width = "";
  }
  getWidth() {
    return this.width || this.element.offsetWidth;
  }
  setMinWidth() {
    this.minWidth = this.column.minWidth, this.element.style.minWidth = this.column.minWidthStyled;
  }
  setMaxWidth() {
    this.maxWidth = this.column.maxWidth, this.element.style.maxWidth = this.column.maxWidthStyled;
  }
  checkHeight() {
    this.row.reinitializeHeight();
  }
  clearHeight() {
    this.element.style.height = "", this.height = null, this.dispatch("cell-height", this, "");
  }
  setHeight() {
    this.height = this.row.height, this.element.style.height = this.row.heightStyled, this.dispatch("cell-height", this, this.row.heightStyled);
  }
  getHeight() {
    return this.height || this.element.offsetHeight;
  }
  show() {
    this.element.style.display = this.column.vertAlign ? "inline-flex" : "";
  }
  hide() {
    this.element.style.display = "none";
  }
  delete() {
    this.dispatch("cell-delete", this), !this.table.rowManager.redrawBlock && this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.column.deleteCell(this), this.row.deleteCell(this), this.calcs = {};
  }
  getIndex() {
    return this.row.getCellIndex(this);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new Gq(this)), this.component;
  }
}
class Bq {
  constructor(e) {
    return this._column = e, this.type = "ColumnComponent", new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._column.table.componentFunctionBinder.handle("column", t._column, i);
      }
    });
  }
  getElement() {
    return this._column.getElement();
  }
  getDefinition() {
    return this._column.getDefinition();
  }
  getField() {
    return this._column.getField();
  }
  getTitleDownload() {
    return this._column.getTitleDownload();
  }
  getCells() {
    var e = [];
    return this._column.cells.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  isVisible() {
    return this._column.visible;
  }
  show() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.show();
    }) : this._column.show();
  }
  hide() {
    this._column.isGroup ? this._column.columns.forEach(function(e) {
      e.hide();
    }) : this._column.hide();
  }
  toggle() {
    this._column.visible ? this.hide() : this.show();
  }
  delete() {
    return this._column.delete();
  }
  getSubColumns() {
    var e = [];
    return this._column.columns.length && this._column.columns.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getParentColumn() {
    return this._column.parent instanceof Eo ? this._column.parent.getComponent() : !1;
  }
  _getSelf() {
    return this._column;
  }
  scrollTo(e, t) {
    return this._column.table.columnManager.scrollToColumn(this._column, e, t);
  }
  getTable() {
    return this._column.table;
  }
  move(e, t) {
    var i = this._column.table.columnManager.findColumn(e);
    i ? this._column.table.columnManager.moveColumn(this._column, i, t) : console.warn("Move Error - No matching column found:", i);
  }
  getNextColumn() {
    var e = this._column.nextColumn();
    return e ? e.getComponent() : !1;
  }
  getPrevColumn() {
    var e = this._column.prevColumn();
    return e ? e.getComponent() : !1;
  }
  updateDefinition(e) {
    return this._column.updateDefinition(e);
  }
  getWidth() {
    return this._column.getWidth();
  }
  setWidth(e) {
    var t;
    return e === !0 ? t = this._column.reinitializeWidth(!0) : t = this._column.setWidth(e), this._column.table.columnManager.rerenderColumns(!0), t;
  }
}
var Fq = {
  title: void 0,
  field: void 0,
  columns: void 0,
  visible: void 0,
  hozAlign: void 0,
  vertAlign: void 0,
  width: void 0,
  minWidth: 40,
  maxWidth: void 0,
  maxInitialWidth: void 0,
  cssClass: void 0,
  variableHeight: void 0,
  headerVertical: void 0,
  headerHozAlign: void 0,
  headerWordWrap: !1,
  editableTitle: void 0
};
class Eo extends an {
  constructor(e, t) {
    super(t.table), this.definition = e, this.parent = t, this.type = "column", this.columns = [], this.cells = [], this.element = this.createElement(), this.contentElement = !1, this.titleHolderElement = !1, this.titleElement = !1, this.groupElement = this.createGroupElement(), this.isGroup = !1, this.hozAlign = "", this.vertAlign = "", this.field = "", this.fieldStructure = "", this.getFieldValue = "", this.setFieldValue = "", this.titleDownload = null, this.titleFormatterRendered = !1, this.mapDefinitions(), this.setField(this.definition.field), this.modules = {}, this.width = null, this.widthStyled = "", this.maxWidth = null, this.maxWidthStyled = "", this.maxInitialWidth = null, this.minWidth = null, this.minWidthStyled = "", this.widthFixed = !1, this.visible = !0, this.component = null, this.definition.columns ? (this.isGroup = !0, this.definition.columns.forEach((i, n) => {
      var a = new Eo(i, this);
      this.attachColumn(a);
    }), this.checkColumnVisibility()) : t.registerColumnField(this), this._initialize();
  }
  createElement() {
    var e = document.createElement("div");
    switch (e.classList.add("tabulator-col"), e.setAttribute("role", "columnheader"), e.setAttribute("aria-sort", "none"), this.table.options.columnHeaderVertAlign) {
      case "middle":
        e.style.justifyContent = "center";
        break;
      case "bottom":
        e.style.justifyContent = "flex-end";
        break;
    }
    return e;
  }
  createGroupElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-group-cols"), e;
  }
  mapDefinitions() {
    var e = this.table.options.columnDefaults;
    if (e)
      for (let t in e)
        typeof this.definition[t] > "u" && (this.definition[t] = e[t]);
    this.definition = this.table.columnManager.optionsList.generate(Eo.defaultOptionList, this.definition);
  }
  checkDefinition() {
    Object.keys(this.definition).forEach((e) => {
      Eo.defaultOptionList.indexOf(e) === -1 && console.warn("Invalid column definition option in '" + (this.field || this.definition.title) + "' column:", e);
    });
  }
  setField(e) {
    this.field = e, this.fieldStructure = e ? this.table.options.nestedFieldSeparator ? e.split(this.table.options.nestedFieldSeparator) : [e] : [], this.getFieldValue = this.fieldStructure.length > 1 ? this._getNestedData : this._getFlatData, this.setFieldValue = this.fieldStructure.length > 1 ? this._setNestedData : this._setFlatData;
  }
  //register column position with column manager
  registerColumnPosition(e) {
    this.parent.registerColumnPosition(e);
  }
  //register column position with column manager
  registerColumnField(e) {
    this.parent.registerColumnField(e);
  }
  //trigger position registration
  reRegisterPosition() {
    this.isGroup ? this.columns.forEach(function(e) {
      e.reRegisterPosition();
    }) : this.registerColumnPosition(this);
  }
  //build header element
  _initialize() {
    for (var e = this.definition; this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    e.headerVertical && (this.element.classList.add("tabulator-col-vertical"), e.headerVertical === "flip" && this.element.classList.add("tabulator-col-vertical-flip")), this.contentElement = this._buildColumnHeaderContent(), this.element.appendChild(this.contentElement), this.isGroup ? this._buildGroupHeader() : this._buildColumnHeader(), this.dispatch("column-init", this);
  }
  //build header element for header
  _buildColumnHeader() {
    var e = this.definition;
    if (this.dispatch("column-layout", this), typeof e.visible < "u" && (e.visible ? this.show(!0) : this.hide(!0)), e.cssClass) {
      var t = e.cssClass.split(" ");
      t.forEach((i) => {
        this.element.classList.add(i);
      });
    }
    e.field && this.element.setAttribute("tabulator-field", e.field), this.setMinWidth(parseInt(e.minWidth)), e.maxInitialWidth && (this.maxInitialWidth = parseInt(e.maxInitialWidth)), e.maxWidth && this.setMaxWidth(parseInt(e.maxWidth)), this.reinitializeWidth(), this.hozAlign = this.definition.hozAlign, this.vertAlign = this.definition.vertAlign, this.titleElement.style.textAlign = this.definition.headerHozAlign;
  }
  _buildColumnHeaderContent() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col-content"), this.titleHolderElement = document.createElement("div"), this.titleHolderElement.classList.add("tabulator-col-title-holder"), e.appendChild(this.titleHolderElement), this.titleElement = this._buildColumnHeaderTitle(), this.titleHolderElement.appendChild(this.titleElement), e;
  }
  //build title element of column
  _buildColumnHeaderTitle() {
    var e = this.definition, t = document.createElement("div");
    if (t.classList.add("tabulator-col-title"), e.headerWordWrap && t.classList.add("tabulator-col-title-wrap"), e.editableTitle) {
      var i = document.createElement("input");
      i.classList.add("tabulator-title-editor"), i.addEventListener("click", (n) => {
        n.stopPropagation(), i.focus();
      }), i.addEventListener("change", () => {
        e.title = i.value, this.dispatchExternal("columnTitleChanged", this.getComponent());
      }), t.appendChild(i), e.field ? this.langBind("columns|" + e.field, (n) => {
        i.value = n || e.title || "&nbsp;";
      }) : i.value = e.title || "&nbsp;";
    } else
      e.field ? this.langBind("columns|" + e.field, (n) => {
        this._formatColumnHeaderTitle(t, n || e.title || "&nbsp;");
      }) : this._formatColumnHeaderTitle(t, e.title || "&nbsp;");
    return t;
  }
  _formatColumnHeaderTitle(e, t) {
    var i = this.chain("column-format", [this, t, e], null, () => t);
    switch (typeof i) {
      case "object":
        i instanceof Node ? e.appendChild(i) : (e.innerHTML = "", console.warn("Format Error - Title formatter has returned a type of object, the only valid formatter object return is an instance of Node, the formatter returned:", i));
        break;
      case "undefined":
        e.innerHTML = "";
        break;
      default:
        e.innerHTML = i;
    }
  }
  //build header element for column group
  _buildGroupHeader() {
    if (this.element.classList.add("tabulator-col-group"), this.element.setAttribute("role", "columngroup"), this.element.setAttribute("aria-title", this.definition.title), this.definition.cssClass) {
      var e = this.definition.cssClass.split(" ");
      e.forEach((t) => {
        this.element.classList.add(t);
      });
    }
    this.titleElement.style.textAlign = this.definition.headerHozAlign, this.element.appendChild(this.groupElement);
  }
  //flat field lookup
  _getFlatData(e) {
    return e[this.field];
  }
  //nested field lookup
  _getNestedData(e) {
    var t = e, i = this.fieldStructure, n = i.length, a;
    for (let o = 0; o < n && (t = t[i[o]], a = t, !!t); o++)
      ;
    return a;
  }
  //flat field set
  _setFlatData(e, t) {
    this.field && (e[this.field] = t);
  }
  //nested field set
  _setNestedData(e, t) {
    var i = e, n = this.fieldStructure, a = n.length;
    for (let o = 0; o < a; o++)
      if (o == a - 1)
        i[n[o]] = t;
      else {
        if (!i[n[o]])
          if (typeof t < "u")
            i[n[o]] = {};
          else
            break;
        i = i[n[o]];
      }
  }
  //attach column to this group
  attachColumn(e) {
    this.groupElement ? (this.columns.push(e), this.groupElement.appendChild(e.getElement()), e.columnRendered()) : console.warn("Column Warning - Column being attached to another column instead of column group");
  }
  //vertically align header in column
  verticalAlign(e, t) {
    var i = this.parent.isGroup ? this.parent.getGroupElement().clientHeight : t || this.parent.getHeadersElement().clientHeight;
    this.element.style.height = i + "px", this.dispatch("column-height", this, this.element.style.height), this.isGroup && (this.groupElement.style.minHeight = i - this.contentElement.offsetHeight + "px"), this.columns.forEach(function(n) {
      n.verticalAlign(e);
    });
  }
  //clear vertical alignment
  clearVerticalAlign() {
    this.element.style.paddingTop = "", this.element.style.height = "", this.element.style.minHeight = "", this.groupElement.style.minHeight = "", this.columns.forEach(function(e) {
      e.clearVerticalAlign();
    }), this.dispatch("column-height", this, "");
  }
  //// Retrieve Column Information ////
  //return column header element
  getElement() {
    return this.element;
  }
  //return column group element
  getGroupElement() {
    return this.groupElement;
  }
  //return field name
  getField() {
    return this.field;
  }
  getTitleDownload() {
    return this.titleDownload;
  }
  //return the first column in a group
  getFirstColumn() {
    return this.isGroup ? this.columns.length ? this.columns[0].getFirstColumn() : !1 : this;
  }
  //return the last column in a group
  getLastColumn() {
    return this.isGroup ? this.columns.length ? this.columns[this.columns.length - 1].getLastColumn() : !1 : this;
  }
  //return all columns in a group
  getColumns(e) {
    var t = [];
    return e ? this.columns.forEach((i) => {
      t.push(i), t = t.concat(i.getColumns(!0));
    }) : t = this.columns, t;
  }
  //return all columns in a group
  getCells() {
    return this.cells;
  }
  //retrieve the top column in a group of columns
  getTopColumn() {
    return this.parent.isGroup ? this.parent.getTopColumn() : this;
  }
  //return column definition object
  getDefinition(e) {
    var t = [];
    return this.isGroup && e && (this.columns.forEach(function(i) {
      t.push(i.getDefinition(!0));
    }), this.definition.columns = t), this.definition;
  }
  //////////////////// Actions ////////////////////
  checkColumnVisibility() {
    var e = !1;
    this.columns.forEach(function(t) {
      t.visible && (e = !0);
    }), e ? (this.show(), this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1)) : this.hide();
  }
  //show column
  show(e, t) {
    this.visible || (this.visible = !0, this.element.style.display = "", this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(i) {
      i.show();
    }), !this.isGroup && this.width === null && this.reinitializeWidth(), this.table.columnManager.verticalAlignHeaders(), this.dispatch("column-show", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !0), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  //hide column
  hide(e, t) {
    this.visible && (this.visible = !1, this.element.style.display = "none", this.table.columnManager.verticalAlignHeaders(), this.parent.isGroup && this.parent.checkColumnVisibility(), this.cells.forEach(function(i) {
      i.hide();
    }), this.dispatch("column-hide", this, t), e || this.dispatchExternal("columnVisibilityChanged", this.getComponent(), !1), this.parent.isGroup && this.parent.matchChildWidths(), this.silent || this.table.columnManager.rerenderColumns());
  }
  matchChildWidths() {
    var e = 0;
    this.contentElement && this.columns.length && (this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }), this.contentElement.style.maxWidth = e - 1 + "px", this.parent.isGroup && this.parent.matchChildWidths());
  }
  removeChild(e) {
    var t = this.columns.indexOf(e);
    t > -1 && this.columns.splice(t, 1), this.columns.length || this.delete();
  }
  setWidth(e) {
    this.widthFixed = !0, this.setWidthActual(e);
  }
  setWidthActual(e) {
    isNaN(e) && (e = Math.floor(this.table.element.clientWidth / 100 * parseInt(e))), e = Math.max(this.minWidth, e), this.maxWidth && (e = Math.min(this.maxWidth, e)), this.width = e, this.widthStyled = e ? e + "px" : "", this.element.style.width = this.widthStyled, this.isGroup || this.cells.forEach(function(t) {
      t.setWidth();
    }), this.parent.isGroup && this.parent.matchChildWidths(), this.dispatch("column-width", this);
  }
  checkCellHeights() {
    var e = [];
    this.cells.forEach(function(t) {
      t.row.heightInitialized && (t.row.getElement().offsetParent !== null ? (e.push(t.row), t.row.clearCellHeight()) : t.row.heightInitialized = !1);
    }), e.forEach(function(t) {
      t.calcHeight();
    }), e.forEach(function(t) {
      t.setCellHeight();
    });
  }
  getWidth() {
    var e = 0;
    return this.isGroup ? this.columns.forEach(function(t) {
      t.visible && (e += t.getWidth());
    }) : e = this.width, e;
  }
  getLeftOffset() {
    var e = this.element.offsetLeft;
    return this.parent.isGroup && (e += this.parent.getLeftOffset()), e;
  }
  getHeight() {
    return Math.ceil(this.element.getBoundingClientRect().height);
  }
  setMinWidth(e) {
    this.maxWidth && e > this.maxWidth && (e = this.maxWidth, console.warn("the minWidth (" + e + "px) for column '" + this.field + "' cannot be bigger that its maxWidth (" + this.maxWidthStyled + ")")), this.minWidth = e, this.minWidthStyled = e ? e + "px" : "", this.element.style.minWidth = this.minWidthStyled, this.cells.forEach(function(t) {
      t.setMinWidth();
    });
  }
  setMaxWidth(e) {
    this.minWidth && e < this.minWidth && (e = this.minWidth, console.warn("the maxWidth (" + e + "px) for column '" + this.field + "' cannot be smaller that its minWidth (" + this.minWidthStyled + ")")), this.maxWidth = e, this.maxWidthStyled = e ? e + "px" : "", this.element.style.maxWidth = this.maxWidthStyled, this.cells.forEach(function(t) {
      t.setMaxWidth();
    });
  }
  delete() {
    return new Promise((e, t) => {
      this.isGroup && this.columns.forEach(function(n) {
        n.delete();
      }), this.dispatch("column-delete", this);
      var i = this.cells.length;
      for (let n = 0; n < i; n++)
        this.cells[0].delete();
      this.element.parentNode && this.element.parentNode.removeChild(this.element), this.element = !1, this.contentElement = !1, this.titleElement = !1, this.groupElement = !1, this.parent.isGroup && this.parent.removeChild(this), this.table.columnManager.deregisterColumn(this), this.table.columnManager.rerenderColumns(!0), e();
    });
  }
  columnRendered() {
    this.titleFormatterRendered && this.titleFormatterRendered(), this.dispatch("column-rendered", this);
  }
  //////////////// Cell Management /////////////////
  //generate cell for this column
  generateCell(e) {
    var t = new Kv(this, e);
    return this.cells.push(t), t;
  }
  nextColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._nextVisibleColumn(e + 1) : !1;
  }
  _nextVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._nextVisibleColumn(e + 1);
  }
  prevColumn() {
    var e = this.table.columnManager.findColumnIndex(this);
    return e > -1 ? this._prevVisibleColumn(e - 1) : !1;
  }
  _prevVisibleColumn(e) {
    var t = this.table.columnManager.getColumnByIndex(e);
    return !t || t.visible ? t : this._prevVisibleColumn(e - 1);
  }
  reinitializeWidth(e) {
    this.widthFixed = !1, typeof this.definition.width < "u" && !e && this.setWidth(this.definition.width), this.dispatch("column-width-fit-before", this), this.fitToData(e), this.dispatch("column-width-fit-after", this);
  }
  //set column width to maximum cell width for non group columns
  fitToData(e) {
    if (!this.isGroup) {
      this.widthFixed || (this.element.style.width = "", this.cells.forEach((n) => {
        n.clearWidth();
      }));
      var t = this.element.offsetWidth;
      if ((!this.width || !this.widthFixed) && (this.cells.forEach((n) => {
        var a = n.getWidth();
        a > t && (t = a);
      }), t)) {
        var i = t + 1;
        this.maxInitialWidth && !e && (i = Math.min(i, this.maxInitialWidth)), this.setWidthActual(i);
      }
    }
  }
  updateDefinition(e) {
    var t;
    return this.isGroup || this.parent.isGroup ? (console.error("Column Update Error - The updateDefinition function is only available on ungrouped columns"), Promise.reject("Column Update Error - The updateDefinition function is only available on columns, not column groups")) : (t = Object.assign({}, this.getDefinition()), t = Object.assign(t, e), this.table.columnManager.addColumn(t, !1, this).then((i) => (t.field == this.field && (this.field = !1), this.delete().then(() => i.getComponent()))));
  }
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new Bq(this)), this.component;
  }
}
Eo.defaultOptionList = Fq;
class Oy {
  constructor(e) {
    return this._row = e, new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._row.table.componentFunctionBinder.handle("row", t._row, i);
      }
    });
  }
  getData(e) {
    return this._row.getData(e);
  }
  getElement() {
    return this._row.getElement();
  }
  getCells() {
    var e = [];
    return this._row.getCells().forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  getCell(e) {
    var t = this._row.getCell(e);
    return t ? t.getComponent() : !1;
  }
  getIndex() {
    return this._row.getData("data")[this._row.table.options.index];
  }
  getPosition() {
    return this._row.getPosition();
  }
  watchPosition(e) {
    return this._row.watchPosition(e);
  }
  delete() {
    return this._row.delete();
  }
  scrollTo(e, t) {
    return this._row.table.rowManager.scrollToRow(this._row, e, t);
  }
  move(e, t) {
    this._row.moveToRow(e, t);
  }
  update(e) {
    return this._row.updateData(e);
  }
  normalizeHeight() {
    this._row.normalizeHeight(!0);
  }
  _getSelf() {
    return this._row;
  }
  reformat() {
    return this._row.reinitialize();
  }
  getTable() {
    return this._row.table;
  }
  getNextRow() {
    var e = this._row.nextRow();
    return e && e.getComponent();
  }
  getPrevRow() {
    var e = this._row.prevRow();
    return e && e.getComponent();
  }
}
class Pi extends an {
  constructor(e, t, i = "row") {
    super(t.table), this.parent = t, this.data = {}, this.type = i, this.element = !1, this.modules = {}, this.cells = [], this.height = 0, this.heightStyled = "", this.manualHeight = !1, this.outerHeight = 0, this.initialized = !1, this.heightInitialized = !1, this.position = 0, this.positionWatchers = [], this.component = null, this.created = !1, this.setData(e);
  }
  create() {
    this.created || (this.created = !0, this.generateElement());
  }
  createElement() {
    var e = document.createElement("div");
    e.classList.add("tabulator-row"), e.setAttribute("role", "row"), this.element = e;
  }
  getElement() {
    return this.create(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  generateElement() {
    this.createElement(), this.dispatch("row-init", this);
  }
  generateCells() {
    this.cells = this.table.columnManager.generateCells(this);
  }
  //functions to setup on first render
  initialize(e) {
    if (this.create(), !this.initialized || e) {
      for (this.deleteCells(); this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.dispatch("row-layout-before", this), this.generateCells(), this.initialized = !0, this.table.columnManager.renderer.renderRowCells(this), e && this.normalizeHeight(), this.dispatch("row-layout", this), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent()), this.dispatch("row-layout-after", this);
    } else
      this.table.columnManager.renderer.rerenderRowCells(this);
  }
  reinitializeHeight() {
    this.heightInitialized = !1, this.element && this.element.offsetParent !== null && this.normalizeHeight(!0);
  }
  deinitialize() {
    this.initialized = !1;
  }
  deinitializeHeight() {
    this.heightInitialized = !1;
  }
  reinitialize(e) {
    this.initialized = !1, this.heightInitialized = !1, this.manualHeight || (this.height = 0, this.heightStyled = ""), this.element && this.element.offsetParent !== null && this.initialize(!0), this.dispatch("row-relayout", this);
  }
  //get heights when doing bulk row style calcs in virtual DOM
  calcHeight(e) {
    var t = 0, i;
    this.table.options.rowHeight ? this.height = this.table.options.rowHeight : (i = this.table.options.resizableRows ? this.element.clientHeight : 0, this.cells.forEach(function(n) {
      var a = n.getHeight();
      a > t && (t = a);
    }), e ? this.height = Math.max(t, i) : this.height = this.manualHeight ? this.height : Math.max(t, i)), this.heightStyled = this.height ? this.height + "px" : "", this.outerHeight = this.element.offsetHeight;
  }
  //set of cells
  setCellHeight() {
    this.cells.forEach(function(e) {
      e.setHeight();
    }), this.heightInitialized = !0;
  }
  clearCellHeight() {
    this.cells.forEach(function(e) {
      e.clearHeight();
    });
  }
  //normalize the height of elements in the row
  normalizeHeight(e) {
    e && !this.table.options.rowHeight && this.clearCellHeight(), this.calcHeight(e), this.setCellHeight();
  }
  //set height of rows
  setHeight(e, t) {
    (this.height != e || t) && (this.manualHeight = !0, this.height = e, this.heightStyled = e ? e + "px" : "", this.setCellHeight(), this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  //return rows outer Width
  getWidth() {
    return this.element.offsetWidth;
  }
  //////////////// Cell Management /////////////////
  deleteCell(e) {
    var t = this.cells.indexOf(e);
    t > -1 && this.cells.splice(t, 1);
  }
  //////////////// Data Management /////////////////
  setData(e) {
    this.data = this.chain("row-data-init-before", [this, e], void 0, e), this.dispatch("row-data-init-after", this);
  }
  //update the rows data
  updateData(e) {
    var t = this.element && Zt.elVisible(this.element), i = {}, n;
    return new Promise((a, o) => {
      typeof e == "string" && (e = JSON.parse(e)), this.dispatch("row-data-save-before", this), this.subscribed("row-data-changing") && (i = Object.assign(i, this.data), i = Object.assign(i, e)), n = this.chain("row-data-changing", [this, i, e], null, e);
      for (let s in n)
        this.data[s] = n[s];
      this.dispatch("row-data-save-after", this);
      for (let s in e)
        this.table.columnManager.getColumnsByFieldRoot(s).forEach((u) => {
          let c = this.getCell(u.getField());
          if (c) {
            let h = u.getFieldValue(n);
            c.getValue() !== h && (c.setValueProcessData(h), t && c.cellRendered());
          }
        });
      t ? (this.normalizeHeight(!0), this.table.options.rowFormatter && this.table.options.rowFormatter(this.getComponent())) : (this.initialized = !1, this.height = 0, this.heightStyled = ""), this.dispatch("row-data-changed", this, t, e), this.dispatchExternal("rowUpdated", this.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), a();
    });
  }
  getData(e) {
    return e ? this.chain("row-data-retrieve", [this, e], null, this.data) : this.data;
  }
  getCell(e) {
    var t = !1;
    return e = this.table.columnManager.findColumn(e), !this.initialized && this.cells.length === 0 && this.generateCells(), t = this.cells.find(function(i) {
      return i.column === e;
    }), t;
  }
  getCellIndex(e) {
    return this.cells.findIndex(function(t) {
      return t === e;
    });
  }
  findCell(e) {
    return this.cells.find((t) => t.element === e);
  }
  getCells() {
    return !this.initialized && this.cells.length === 0 && this.generateCells(), this.cells;
  }
  nextRow() {
    var e = this.table.rowManager.nextDisplayRow(this, !0);
    return e || !1;
  }
  prevRow() {
    var e = this.table.rowManager.prevDisplayRow(this, !0);
    return e || !1;
  }
  moveToRow(e, t) {
    var i = this.table.rowManager.findRow(e);
    i ? (this.table.rowManager.moveRowActual(this, i, !t), this.table.rowManager.refreshActiveData("display", !1, !0)) : console.warn("Move Error - No matching row found:", e);
  }
  ///////////////////// Actions  /////////////////////
  delete() {
    return this.dispatch("row-delete", this), this.deleteActual(), Promise.resolve();
  }
  deleteActual(e) {
    this.detachModules(), this.table.rowManager.deleteRow(this, e), this.deleteCells(), this.initialized = !1, this.heightInitialized = !1, this.element = !1, this.dispatch("row-deleted", this);
  }
  detachModules() {
    this.dispatch("row-deleting", this);
  }
  deleteCells() {
    var e = this.cells.length;
    for (let t = 0; t < e; t++)
      this.cells[0].delete();
  }
  wipe() {
    if (this.detachModules(), this.deleteCells(), this.element) {
      for (; this.element.firstChild; )
        this.element.removeChild(this.element.firstChild);
      this.element.parentNode && this.element.parentNode.removeChild(this.element);
    }
    this.element = !1, this.modules = {};
  }
  isDisplayed() {
    return this.table.rowManager.getDisplayRows().includes(this);
  }
  getPosition() {
    return this.isDisplayed() ? this.position : !1;
  }
  setPosition(e) {
    e != this.position && (this.position = e, this.positionWatchers.forEach((t) => {
      t(this.position);
    }));
  }
  watchPosition(e) {
    this.positionWatchers.push(e), e(this.position);
  }
  getGroup() {
    return this.modules.group || !1;
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new Oy(this)), this.component;
  }
}
var VVe = {
  avg: function(r, e, t) {
    var i = 0, n = typeof t.precision < "u" ? t.precision : 2;
    return r.length && (i = r.reduce(function(a, o) {
      return Number(a) + Number(o);
    }), i = i / r.length, i = n !== !1 ? i.toFixed(n) : i), parseFloat(i).toString();
  },
  max: function(r, e, t) {
    var i = null, n = typeof t.precision < "u" ? t.precision : !1;
    return r.forEach(function(a) {
      a = Number(a), (a > i || i === null) && (i = a);
    }), i !== null ? n !== !1 ? i.toFixed(n) : i : "";
  },
  min: function(r, e, t) {
    var i = null, n = typeof t.precision < "u" ? t.precision : !1;
    return r.forEach(function(a) {
      a = Number(a), (a < i || i === null) && (i = a);
    }), i !== null ? n !== !1 ? i.toFixed(n) : i : "";
  },
  sum: function(r, e, t) {
    var i = 0, n = typeof t.precision < "u" ? t.precision : !1;
    return r.length && r.forEach(function(a) {
      a = Number(a), i += isNaN(a) ? 0 : Number(a);
    }), n !== !1 ? i.toFixed(n) : i;
  },
  concat: function(r, e, t) {
    var i = 0;
    return r.length && (i = r.reduce(function(n, a) {
      return String(n) + String(a);
    })), i;
  },
  count: function(r, e, t) {
    var i = 0;
    return r.length && r.forEach(function(n) {
      n && i++;
    }), i;
  },
  unique: function(r, e, t) {
    var i = r.filter((n, a) => (r || n === 0) && r.indexOf(n) === a);
    return i.length;
  }
};
class zo extends mt {
  constructor(e) {
    super(e), this.topCalcs = [], this.botCalcs = [], this.genColumn = !1, this.topElement = this.createElement(), this.botElement = this.createElement(), this.topRow = !1, this.botRow = !1, this.topInitialized = !1, this.botInitialized = !1, this.blocked = !1, this.recalcAfterBlock = !1, this.registerTableOption("columnCalcs", !0), this.registerColumnOption("topCalc"), this.registerColumnOption("topCalcParams"), this.registerColumnOption("topCalcFormatter"), this.registerColumnOption("topCalcFormatterParams"), this.registerColumnOption("bottomCalc"), this.registerColumnOption("bottomCalcParams"), this.registerColumnOption("bottomCalcFormatter"), this.registerColumnOption("bottomCalcFormatterParams");
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-calcs-holder"), e;
  }
  initialize() {
    this.genColumn = new Eo({ field: "value" }, this), this.subscribe("cell-value-changed", this.cellValueChanged.bind(this)), this.subscribe("column-init", this.initializeColumnCheck.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("column-moved", this.recalcActiveRows.bind(this)), this.subscribe("column-add", this.recalcActiveRows.bind(this)), this.subscribe("data-refreshed", this.recalcActiveRowsRefresh.bind(this)), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this)), this.subscribe("redraw-blocked", this.blockRedraw.bind(this)), this.subscribe("redraw-restored", this.restoreRedraw.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this)), this.registerTableFunction("getCalcResults", this.getResults.bind(this)), this.registerTableFunction("recalc", this.userRecalc.bind(this)), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  tableRedraw(e) {
    this.recalc(this.table.rowManager.activeRows), e && this.redraw();
  }
  blockRedraw() {
    this.blocked = !0, this.recalcAfterBlock = !1;
  }
  restoreRedraw() {
    this.blocked = !1, this.recalcAfterBlock && (this.recalcAfterBlock = !1, this.recalcActiveRowsRefresh());
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userRecalc() {
    this.recalc(this.table.rowManager.activeRows);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  blockCheck() {
    return this.blocked && (this.recalcAfterBlock = !0), this.blocked;
  }
  visibleRows(e, t) {
    return this.topRow && t.unshift(this.topRow), this.botRow && t.push(this.botRow), t;
  }
  rowsUpdated(e) {
    this.table.options.groupBy ? this.recalcRowGroup(e) : this.recalcActiveRows();
  }
  recalcActiveRowsRefresh() {
    this.table.options.groupBy && this.table.options.dataTreeStartExpanded && this.table.options.dataTree ? this.recalcAll() : this.recalcActiveRows();
  }
  recalcActiveRows() {
    this.recalc(this.table.rowManager.activeRows);
  }
  cellValueChanged(e) {
    (e.column.definition.topCalc || e.column.definition.bottomCalc) && (this.table.options.groupBy ? ((this.table.options.columnCalcs == "table" || this.table.options.columnCalcs == "both") && this.recalcActiveRows(), this.table.options.columnCalcs != "table" && this.recalcRowGroup(e.row)) : this.recalcActiveRows());
  }
  initializeColumnCheck(e) {
    (e.definition.topCalc || e.definition.bottomCalc) && this.initializeColumn(e);
  }
  //initialize column calcs
  initializeColumn(e) {
    var t = e.definition, i = {
      topCalcParams: t.topCalcParams || {},
      botCalcParams: t.bottomCalcParams || {}
    };
    if (t.topCalc) {
      switch (typeof t.topCalc) {
        case "string":
          zo.calculations[t.topCalc] ? i.topCalc = zo.calculations[t.topCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.topCalc);
          break;
        case "function":
          i.topCalc = t.topCalc;
          break;
      }
      i.topCalc && (e.modules.columnCalcs = i, this.topCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeTopRow());
    }
    if (t.bottomCalc) {
      switch (typeof t.bottomCalc) {
        case "string":
          zo.calculations[t.bottomCalc] ? i.botCalc = zo.calculations[t.bottomCalc] : console.warn("Column Calc Error - No such calculation found, ignoring: ", t.bottomCalc);
          break;
        case "function":
          i.botCalc = t.bottomCalc;
          break;
      }
      i.botCalc && (e.modules.columnCalcs = i, this.botCalcs.push(e), this.table.options.columnCalcs != "group" && this.initializeBottomRow());
    }
  }
  //dummy functions to handle being mock column manager
  registerColumnField() {
  }
  removeCalcs() {
    var e = !1;
    this.topInitialized && (this.topInitialized = !1, this.topElement.parentNode.removeChild(this.topElement), e = !0), this.botInitialized && (this.botInitialized = !1, this.footerRemove(this.botElement), e = !0), e && this.table.rowManager.adjustTableSize();
  }
  reinitializeCalcs() {
    this.topCalcs.length && this.initializeTopRow(), this.botCalcs.length && this.initializeBottomRow();
  }
  initializeTopRow() {
    this.topInitialized || (this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.topInitialized = !0);
  }
  initializeBottomRow() {
    this.botInitialized || (this.footerPrepend(this.botElement), this.botInitialized = !0);
  }
  scrollHorizontal(e) {
    this.botInitialized && this.botRow && (this.botElement.scrollLeft = e);
  }
  recalc(e) {
    var t, i;
    if (!this.blockCheck() && (this.topInitialized || this.botInitialized)) {
      if (t = this.rowsToData(e), this.topInitialized) {
        for (this.topRow && this.topRow.deleteCells(), i = this.generateRow("top", t), this.topRow = i; this.topElement.firstChild; )
          this.topElement.removeChild(this.topElement.firstChild);
        this.topElement.appendChild(i.getElement()), i.initialize(!0);
      }
      if (this.botInitialized) {
        for (this.botRow && this.botRow.deleteCells(), i = this.generateRow("bottom", t), this.botRow = i; this.botElement.firstChild; )
          this.botElement.removeChild(this.botElement.firstChild);
        this.botElement.appendChild(i.getElement()), i.initialize(!0);
      }
      this.table.rowManager.adjustTableSize(), this.table.modExists("frozenColumns") && this.table.modules.frozenColumns.layout();
    }
  }
  recalcRowGroup(e) {
    this.recalcGroup(this.table.modules.groupRows.getRowGroup(e));
  }
  recalcAll() {
    if ((this.topCalcs.length || this.botCalcs.length) && (this.table.options.columnCalcs !== "group" && this.recalcActiveRows(), this.table.options.groupBy && this.table.options.columnCalcs !== "table")) {
      var e = this.table.modules.groupRows.getChildGroups();
      e.forEach((t) => {
        this.recalcGroup(t);
      });
    }
  }
  recalcGroup(e) {
    var t, i;
    this.blockCheck() || e && e.calcs && (e.calcs.bottom && (t = this.rowsToData(e.rows), i = this.generateRowData("bottom", t), e.calcs.bottom.updateData(i), e.calcs.bottom.reinitialize()), e.calcs.top && (t = this.rowsToData(e.rows), i = this.generateRowData("top", t), e.calcs.top.updateData(i), e.calcs.top.reinitialize()));
  }
  //generate top stats row
  generateTopRow(e) {
    return this.generateRow("top", this.rowsToData(e));
  }
  //generate bottom stats row
  generateBottomRow(e) {
    return this.generateRow("bottom", this.rowsToData(e));
  }
  rowsToData(e) {
    var t = [];
    return e.forEach((i) => {
      if (t.push(i.getData()), this.table.options.dataTree && this.table.options.dataTreeChildColumnCalcs && i.modules.dataTree && i.modules.dataTree.open) {
        var n = this.rowsToData(this.table.modules.dataTree.getFilteredTreeChildren(i));
        t = t.concat(n);
      }
    }), t;
  }
  //generate stats row
  generateRow(e, t) {
    var i = this.generateRowData(e, t), n;
    return this.table.modExists("mutator") && this.table.modules.mutator.disable(), n = new Pi(i, this, "calc"), this.table.modExists("mutator") && this.table.modules.mutator.enable(), n.getElement().classList.add("tabulator-calcs", "tabulator-calcs-" + e), n.component = !1, n.getComponent = () => (n.component || (n.component = new $Ve(n)), n.component), n.generateCells = () => {
      var a = [];
      this.table.columnManager.columnsByIndex.forEach((o) => {
        this.genColumn.setField(o.getField()), this.genColumn.hozAlign = o.hozAlign, o.definition[e + "CalcFormatter"] && this.table.modExists("format") ? this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter(o.definition[e + "CalcFormatter"]),
          params: o.definition[e + "CalcFormatterParams"] || {}
        } : this.genColumn.modules.format = {
          formatter: this.table.modules.format.getFormatter("plaintext"),
          params: {}
        }, this.genColumn.definition.cssClass = o.definition.cssClass;
        var s = new Kv(this.genColumn, n);
        s.getElement(), s.column = o, s.setWidth(), o.cells.push(s), a.push(s), o.visible || s.hide();
      }), n.cells = a;
    }, n;
  }
  //generate stats row
  generateRowData(e, t) {
    var i = {}, n = e == "top" ? this.topCalcs : this.botCalcs, a = e == "top" ? "topCalc" : "botCalc", o, s;
    return n.forEach(function(l) {
      var u = [];
      l.modules.columnCalcs && l.modules.columnCalcs[a] && (t.forEach(function(c) {
        u.push(l.getFieldValue(c));
      }), s = a + "Params", o = typeof l.modules.columnCalcs[s] == "function" ? l.modules.columnCalcs[s](u, t) : l.modules.columnCalcs[s], l.setFieldValue(i, l.modules.columnCalcs[a](u, t, o)));
    }), i;
  }
  hasTopCalcs() {
    return !!this.topCalcs.length;
  }
  hasBottomCalcs() {
    return !!this.botCalcs.length;
  }
  //handle table redraw
  redraw() {
    this.topRow && this.topRow.normalizeHeight(!0), this.botRow && this.botRow.normalizeHeight(!0);
  }
  //return the calculated
  getResults() {
    var e = {}, t;
    return this.table.options.groupBy && this.table.modExists("groupRows") ? (t = this.table.modules.groupRows.getGroups(!0), t.forEach((i) => {
      e[i.getKey()] = this.getGroupResults(i);
    })) : e = {
      top: this.topRow ? this.topRow.getData() : {},
      bottom: this.botRow ? this.botRow.getData() : {}
    }, e;
  }
  //get results from a group
  getGroupResults(e) {
    var t = e._getSelf(), i = e.getSubGroups(), n = {}, a = {};
    return i.forEach((o) => {
      n[o.getKey()] = this.getGroupResults(o);
    }), a = {
      top: t.calcs.top ? t.calcs.top.getData() : {},
      bottom: t.calcs.bottom ? t.calcs.bottom.getData() : {},
      groups: n
    }, a;
  }
  adjustForScrollbar(e) {
    this.botRow && (this.table.rtl ? this.botElement.style.paddingLeft = e + "px" : this.botElement.style.paddingRight = e + "px");
  }
}
zo.moduleName = "columnCalcs";
zo.calculations = VVe;
class PP extends mt {
  constructor(e) {
    super(e), this.indent = 10, this.field = "", this.collapseEl = null, this.expandEl = null, this.branchEl = null, this.elementField = !1, this.startOpen = function() {
    }, this.registerTableOption("dataTree", !1), this.registerTableOption("dataTreeFilter", !0), this.registerTableOption("dataTreeSort", !0), this.registerTableOption("dataTreeElementColumn", !1), this.registerTableOption("dataTreeBranchElement", !0), this.registerTableOption("dataTreeChildIndent", 9), this.registerTableOption("dataTreeChildField", "_children"), this.registerTableOption("dataTreeCollapseElement", !1), this.registerTableOption("dataTreeExpandElement", !1), this.registerTableOption("dataTreeStartExpanded", !1), this.registerTableOption("dataTreeChildColumnCalcs", !1), this.registerTableOption("dataTreeSelectPropagate", !1), this.registerComponentFunction("row", "treeCollapse", this.collapseRow.bind(this)), this.registerComponentFunction("row", "treeExpand", this.expandRow.bind(this)), this.registerComponentFunction("row", "treeToggle", this.toggleRow.bind(this)), this.registerComponentFunction("row", "getTreeParent", this.getTreeParent.bind(this)), this.registerComponentFunction("row", "getTreeChildren", this.getRowChildren.bind(this)), this.registerComponentFunction("row", "addTreeChild", this.addTreeChildRow.bind(this)), this.registerComponentFunction("row", "isTreeExpanded", this.isRowExpanded.bind(this));
  }
  initialize() {
    if (this.table.options.dataTree) {
      var e = null, t = this.table.options;
      switch (this.field = t.dataTreeChildField, this.indent = t.dataTreeChildIndent, this.options("movableRows") && console.warn("The movableRows option is not available with dataTree enabled, moving of child rows could result in unpredictable behavior"), t.dataTreeBranchElement && (t.dataTreeBranchElement === !0 ? (this.branchEl = document.createElement("div"), this.branchEl.classList.add("tabulator-data-tree-branch")) : typeof t.dataTreeBranchElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeBranchElement, this.branchEl = e.firstChild) : this.branchEl = t.dataTreeBranchElement), t.dataTreeCollapseElement ? typeof t.dataTreeCollapseElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeCollapseElement, this.collapseEl = e.firstChild) : this.collapseEl = t.dataTreeCollapseElement : (this.collapseEl = document.createElement("div"), this.collapseEl.classList.add("tabulator-data-tree-control"), this.collapseEl.tabIndex = 0, this.collapseEl.innerHTML = "<div class='tabulator-data-tree-control-collapse'></div>"), t.dataTreeExpandElement ? typeof t.dataTreeExpandElement == "string" ? (e = document.createElement("div"), e.innerHTML = t.dataTreeExpandElement, this.expandEl = e.firstChild) : this.expandEl = t.dataTreeExpandElement : (this.expandEl = document.createElement("div"), this.expandEl.classList.add("tabulator-data-tree-control"), this.expandEl.tabIndex = 0, this.expandEl.innerHTML = "<div class='tabulator-data-tree-control-expand'></div>"), typeof t.dataTreeStartExpanded) {
        case "boolean":
          this.startOpen = function(i, n) {
            return t.dataTreeStartExpanded;
          };
          break;
        case "function":
          this.startOpen = t.dataTreeStartExpanded;
          break;
        default:
          this.startOpen = function(i, n) {
            return t.dataTreeStartExpanded[n];
          };
          break;
      }
      this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("row-deleted", this.rowDelete.bind(this), 0), this.subscribe("row-data-changed", this.rowDataChanged.bind(this), 10), this.subscribe("cell-value-updated", this.cellValueChanged.bind(this)), this.subscribe("edit-cancelled", this.cellValueChanged.bind(this)), this.subscribe("column-moving-rows", this.columnMoving.bind(this)), this.subscribe("table-built", this.initializeElementField.bind(this)), this.subscribe("table-redrawing", this.tableRedrawing.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 30);
    }
  }
  tableRedrawing(e) {
    var t;
    e && (t = this.table.rowManager.getRows(), t.forEach((i) => {
      this.reinitializeRowChildren(i);
    }));
  }
  initializeElementField() {
    var e = this.table.columnManager.getFirstVisibleColumn();
    this.elementField = this.table.options.dataTreeElementColumn || (e ? e.field : !1);
  }
  getRowChildren(e) {
    return this.getTreeChildren(e, !0);
  }
  columnMoving() {
    var e = [];
    return this.table.rowManager.rows.forEach((t) => {
      e = e.concat(this.getTreeChildren(t, !1, !0));
    }), e;
  }
  rowDataChanged(e, t, i) {
    this.redrawNeeded(i) && (this.initializeRow(e), t && (this.layoutRow(e), this.refreshData(!0)));
  }
  cellValueChanged(e) {
    var t = e.column.getField();
    t === this.elementField && this.layoutRow(e.row);
  }
  initializeRow(e) {
    var t = e.getData()[this.field], i = Array.isArray(t), n = i || !i && typeof t == "object" && t !== null;
    !n && e.modules.dataTree && e.modules.dataTree.branchEl && e.modules.dataTree.branchEl.parentNode.removeChild(e.modules.dataTree.branchEl), !n && e.modules.dataTree && e.modules.dataTree.controlEl && e.modules.dataTree.controlEl.parentNode.removeChild(e.modules.dataTree.controlEl), e.modules.dataTree = {
      index: e.modules.dataTree ? e.modules.dataTree.index : 0,
      open: n ? e.modules.dataTree ? e.modules.dataTree.open : this.startOpen(e.getComponent(), 0) : !1,
      controlEl: e.modules.dataTree && n ? e.modules.dataTree.controlEl : !1,
      branchEl: e.modules.dataTree && n ? e.modules.dataTree.branchEl : !1,
      parent: e.modules.dataTree ? e.modules.dataTree.parent : !1,
      children: n
    };
  }
  reinitializeRowChildren(e) {
    var t = this.getTreeChildren(e, !1, !0);
    t.forEach(function(i) {
      i.reinitialize(!0);
    });
  }
  layoutRow(e) {
    var t = this.elementField ? e.getCell(this.elementField) : e.getCells()[0], i = t.getElement(), n = e.modules.dataTree;
    n.branchEl && (n.branchEl.parentNode && n.branchEl.parentNode.removeChild(n.branchEl), n.branchEl = !1), n.controlEl && (n.controlEl.parentNode && n.controlEl.parentNode.removeChild(n.controlEl), n.controlEl = !1), this.generateControlElement(e, i), e.getElement().classList.add("tabulator-tree-level-" + n.index), n.index && (this.branchEl ? (n.branchEl = this.branchEl.cloneNode(!0), i.insertBefore(n.branchEl, i.firstChild), this.table.rtl ? n.branchEl.style.marginRight = (n.branchEl.offsetWidth + n.branchEl.style.marginLeft) * (n.index - 1) + n.index * this.indent + "px" : n.branchEl.style.marginLeft = (n.branchEl.offsetWidth + n.branchEl.style.marginRight) * (n.index - 1) + n.index * this.indent + "px") : this.table.rtl ? i.style.paddingRight = parseInt(window.getComputedStyle(i, null).getPropertyValue("padding-right")) + n.index * this.indent + "px" : i.style.paddingLeft = parseInt(window.getComputedStyle(i, null).getPropertyValue("padding-left")) + n.index * this.indent + "px");
  }
  generateControlElement(e, t) {
    var i = e.modules.dataTree, n = i.controlEl;
    t = t || e.getCells()[0].getElement(), i.children !== !1 && (i.open ? (i.controlEl = this.collapseEl.cloneNode(!0), i.controlEl.addEventListener("click", (a) => {
      a.stopPropagation(), this.collapseRow(e);
    })) : (i.controlEl = this.expandEl.cloneNode(!0), i.controlEl.addEventListener("click", (a) => {
      a.stopPropagation(), this.expandRow(e);
    })), i.controlEl.addEventListener("mousedown", (a) => {
      a.stopPropagation();
    }), n && n.parentNode === t ? n.parentNode.replaceChild(i.controlEl, n) : t.insertBefore(i.controlEl, t.firstChild));
  }
  getRows(e) {
    var t = [];
    return e.forEach((i, n) => {
      var a, o;
      t.push(i), i instanceof Pi && (i.create(), a = i.modules.dataTree, !a.index && a.children !== !1 && (o = this.getChildren(i), o.forEach((s) => {
        s.create(), t.push(s);
      })));
    }), t;
  }
  getChildren(e, t) {
    var i = e.modules.dataTree, n = [], a = [];
    return i.children !== !1 && (i.open || t) && (Array.isArray(i.children) || (i.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? n = this.table.modules.filter.filter(i.children) : n = i.children, this.table.modExists("sort") && this.table.options.dataTreeSort && this.table.modules.sort.sort(n), n.forEach((o) => {
      a.push(o);
      var s = this.getChildren(o);
      s.forEach((l) => {
        a.push(l);
      });
    })), a;
  }
  generateChildren(e) {
    var t = [], i = e.getData()[this.field];
    return Array.isArray(i) || (i = [i]), i.forEach((n) => {
      var a = new Pi(n || {}, this.table.rowManager);
      a.create(), a.modules.dataTree.index = e.modules.dataTree.index + 1, a.modules.dataTree.parent = e, a.modules.dataTree.children && (a.modules.dataTree.open = this.startOpen(a.getComponent(), a.modules.dataTree.index)), t.push(a);
    }), t;
  }
  expandRow(e, t) {
    var i = e.modules.dataTree;
    i.children !== !1 && (i.open = !0, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowExpanded", e.getComponent(), e.modules.dataTree.index));
  }
  collapseRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open = !1, e.reinitialize(), this.refreshData(!0), this.dispatchExternal("dataTreeRowCollapsed", e.getComponent(), e.modules.dataTree.index));
  }
  toggleRow(e) {
    var t = e.modules.dataTree;
    t.children !== !1 && (t.open ? this.collapseRow(e) : this.expandRow(e));
  }
  isRowExpanded(e) {
    return e.modules.dataTree.open;
  }
  getTreeParent(e) {
    return e.modules.dataTree.parent ? e.modules.dataTree.parent.getComponent() : !1;
  }
  getTreeParentRoot(e) {
    return e.modules.dataTree && e.modules.dataTree.parent ? this.getTreeParentRoot(e.modules.dataTree.parent) : e;
  }
  getFilteredTreeChildren(e) {
    var t = e.modules.dataTree, i = [], n;
    return t.children && (Array.isArray(t.children) || (t.children = this.generateChildren(e)), this.table.modExists("filter") && this.table.options.dataTreeFilter ? n = this.table.modules.filter.filter(t.children) : n = t.children, n.forEach((a) => {
      a instanceof Pi && i.push(a);
    })), i;
  }
  rowDelete(e) {
    var t = e.modules.dataTree.parent, i;
    t && (i = this.findChildIndex(e, t), i !== !1 && t.data[this.field].splice(i, 1), t.data[this.field].length || delete t.data[this.field], this.initializeRow(t), this.layoutRow(t)), this.refreshData(!0);
  }
  addTreeChildRow(e, t, i, n) {
    var a = !1;
    typeof t == "string" && (t = JSON.parse(t)), Array.isArray(e.data[this.field]) || (e.data[this.field] = [], e.modules.dataTree.open = this.startOpen(e.getComponent(), e.modules.dataTree.index)), typeof n < "u" && (a = this.findChildIndex(n, e), a !== !1 && e.data[this.field].splice(i ? a : a + 1, 0, t)), a === !1 && (i ? e.data[this.field].unshift(t) : e.data[this.field].push(t)), this.initializeRow(e), this.layoutRow(e), this.refreshData(!0);
  }
  findChildIndex(e, t) {
    var i = !1;
    return typeof e == "object" ? e instanceof Pi ? i = e.data : e instanceof Oy ? i = e._getSelf().data : typeof HTMLElement < "u" && e instanceof HTMLElement ? t.modules.dataTree && (i = t.modules.dataTree.children.find((n) => n instanceof Pi ? n.element === e : !1), i && (i = i.data)) : e === null && (i = !1) : typeof e > "u" ? i = !1 : i = t.data[this.field].find((n) => n.data[this.table.options.index] == e), i && (Array.isArray(t.data[this.field]) && (i = t.data[this.field].indexOf(i)), i == -1 && (i = !1)), i;
  }
  getTreeChildren(e, t, i) {
    var n = e.modules.dataTree, a = [];
    return n.children && (Array.isArray(n.children) || (n.children = this.generateChildren(e)), n.children.forEach((o) => {
      o instanceof Pi && (a.push(t ? o.getComponent() : o), i && (a = a.concat(this.getTreeChildren(o, t, i))));
    })), a;
  }
  getChildField() {
    return this.field;
  }
  redrawNeeded(e) {
    return (this.field ? typeof e[this.field] < "u" : !1) || (this.elementField ? typeof e[this.elementField] < "u" : !1);
  }
}
PP.moduleName = "dataTree";
function GVe(r, e = {}, t) {
  var i = e.delimiter ? e.delimiter : ",", n = [], a = [];
  r.forEach((o) => {
    var s = [];
    switch (o.type) {
      case "group":
        console.warn("Download Warning - CSV downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - CSV downloader cannot process column calculations");
        break;
      case "header":
        o.columns.forEach((l, u) => {
          l && l.depth === 1 && (a[u] = typeof l.value > "u" || l.value === null ? "" : '"' + String(l.value).split('"').join('""') + '"');
        });
        break;
      case "row":
        o.columns.forEach((l) => {
          if (l) {
            switch (typeof l.value) {
              case "object":
                l.value = l.value !== null ? JSON.stringify(l.value) : "";
                break;
              case "undefined":
                l.value = "";
                break;
            }
            s.push('"' + String(l.value).split('"').join('""') + '"');
          }
        }), n.push(s.join(i));
        break;
    }
  }), a.length && n.unshift(a.join(i)), n = n.join(`
`), e.bom && (n = "\uFEFF" + n), t(n, "text/csv");
}
function BVe(r, e, t) {
  var i = [];
  r.forEach((n) => {
    var a = {};
    switch (n.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        n.columns.forEach((o) => {
          o && (a[o.component.getTitleDownload() || o.component.getField()] = o.value);
        }), i.push(a);
        break;
    }
  }), i = JSON.stringify(i, null, "	"), t(i, "application/json");
}
function FVe(r, e = {}, t) {
  var i = [], n = [], a = {}, o = e.rowGroupStyles || {
    fontStyle: "bold",
    fontSize: 12,
    cellPadding: 6,
    fillColor: 220
  }, s = e.rowCalcStyles || {
    fontStyle: "bold",
    fontSize: 10,
    cellPadding: 4,
    fillColor: 232
  }, l = e.jsPDF || {}, u = e.title ? e.title : "";
  l.orientation || (l.orientation = e.orientation || "landscape"), l.unit || (l.unit = "pt"), r.forEach((f) => {
    switch (f.type) {
      case "header":
        i.push(c(f));
        break;
      case "group":
        n.push(c(f, o));
        break;
      case "calc":
        n.push(c(f, s));
        break;
      case "row":
        n.push(c(f));
        break;
    }
  });
  function c(f, d) {
    var p = [];
    return f.columns.forEach((g) => {
      var v;
      if (g) {
        switch (typeof g.value) {
          case "object":
            g.value = g.value !== null ? JSON.stringify(g.value) : "";
            break;
          case "undefined":
            g.value = "";
            break;
        }
        v = {
          content: g.value,
          colSpan: g.width,
          rowSpan: g.height
        }, d && (v.styles = d), p.push(v);
      }
    }), p;
  }
  var h = new jspdf.jsPDF(l);
  e.autoTable && (typeof e.autoTable == "function" ? a = e.autoTable(h) || {} : a = e.autoTable), u && (a.didDrawPage = function(f) {
    h.text(u, 40, 30);
  }), a.head = i, a.body = n, h.autoTable(a), e.documentProcessing && e.documentProcessing(h), t(h.output("arraybuffer"), "application/pdf");
}
function XVe(r, e, t) {
  var i = this, n = e.sheetName || "Sheet1", a = XLSX.utils.book_new(), o = new an(this), s = "compress" in e ? e.compress : !0, l = e.writeOptions || { bookType: "xlsx", bookSST: !0, compression: s }, u;
  l.type = "binary", a.SheetNames = [], a.Sheets = {};
  function c() {
    var d = [], p = [], g = {}, v = { s: { c: 0, r: 0 }, e: { c: r[0] ? r[0].columns.reduce((O, m) => O + (m && m.width ? m.width : 1), 0) : 0, r: r.length } };
    return r.forEach((O, m) => {
      var E = [];
      O.columns.forEach(function(b, S) {
        b ? (E.push(!(b.value instanceof Date) && typeof b.value == "object" ? JSON.stringify(b.value) : b.value), (b.width > 1 || b.height > -1) && (b.height > 1 || b.width > 1) && p.push({ s: { r: m, c: S }, e: { r: m + b.height - 1, c: S + b.width - 1 } })) : E.push("");
      }), d.push(E);
    }), XLSX.utils.sheet_add_aoa(g, d), g["!ref"] = XLSX.utils.encode_range(v), p.length && (g["!merges"] = p), g;
  }
  if (e.sheetOnly) {
    t(c());
    return;
  }
  if (e.sheets)
    for (var h in e.sheets)
      e.sheets[h] === !0 ? (a.SheetNames.push(h), a.Sheets[h] = c()) : (a.SheetNames.push(h), o.commsSend(e.sheets[h], "download", "intercept", {
        type: "xlsx",
        options: { sheetOnly: !0 },
        active: i.active,
        intercept: function(d) {
          a.Sheets[h] = d;
        }
      }));
  else
    a.SheetNames.push(n), a.Sheets[n] = c();
  e.documentProcessing && (a = e.documentProcessing(a));
  function f(d) {
    for (var p = new ArrayBuffer(d.length), g = new Uint8Array(p), v = 0; v != d.length; ++v)
      g[v] = d.charCodeAt(v) & 255;
    return p;
  }
  u = XLSX.write(a, l), t(f(u), "application/octet-stream");
}
function YVe(r, e, t) {
  this.modExists("export", !0) && t(this.modules.export.generateHTMLTable(r), "text/html");
}
function HVe(r, e, t) {
  const i = [];
  r.forEach((n) => {
    const a = {};
    switch (n.type) {
      case "header":
        break;
      case "group":
        console.warn("Download Warning - JSON downloader cannot process row groups");
        break;
      case "calc":
        console.warn("Download Warning - JSON downloader cannot process column calculations");
        break;
      case "row":
        n.columns.forEach((o) => {
          o && (a[o.component.getTitleDownload() || o.component.getField()] = o.value);
        }), i.push(JSON.stringify(a));
        break;
    }
  }), t(i.join(`
`), "application/x-ndjson");
}
var WVe = {
  csv: GVe,
  json: BVe,
  jsonLines: HVe,
  pdf: FVe,
  xlsx: XVe,
  html: YVe
};
class Vc extends mt {
  constructor(e) {
    super(e), this.registerTableOption("downloadEncoder", function(t, i) {
      return new Blob([t], { type: i });
    }), this.registerTableOption("downloadReady", void 0), this.registerTableOption("downloadConfig", {}), this.registerTableOption("downloadRowRange", "active"), this.registerColumnOption("download"), this.registerColumnOption("titleDownload");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.registerTableFunction("download", this.download.bind(this)), this.registerTableFunction("downloadToTab", this.downloadToTab.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("downloadReady", "downloadEncoder");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  downloadToTab(e, t, i, n) {
    this.download(e, t, i, n, !0);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //trigger file download
  download(e, t, i, n, a) {
    var o = !1;
    function s(u, c) {
      a ? a === !0 ? this.triggerDownload(u, c, e, t, !0) : a(u) : this.triggerDownload(u, c, e, t);
    }
    if (typeof e == "function" ? o = e : Vc.downloaders[e] ? o = Vc.downloaders[e] : console.warn("Download Error - No such download type found: ", e), o) {
      var l = this.generateExportList(n);
      o.call(this.table, l, i || {}, s.bind(this));
    }
  }
  generateExportList(e) {
    var t = this.table.modules.export.generateExportList(this.table.options.downloadConfig, !1, e || this.table.options.downloadRowRange, "download"), i = this.table.options.groupHeaderDownload;
    return i && !Array.isArray(i) && (i = [i]), t.forEach((n) => {
      var a;
      n.type === "group" && (a = n.columns[0], i && i[n.indent] && (a.value = i[n.indent](a.value, n.component._group.getRowCount(), n.component._group.getData(), n.component)));
    }), t;
  }
  triggerDownload(e, t, i, n, a) {
    var o = document.createElement("a"), s = this.table.options.downloadEncoder(e, t);
    s && (a ? window.open(window.URL.createObjectURL(s)) : (n = n || "Tabulator." + (typeof i == "function" ? "txt" : i), navigator.msSaveOrOpenBlob ? navigator.msSaveOrOpenBlob(s, n) : (o.setAttribute("href", window.URL.createObjectURL(s)), o.setAttribute("download", n), o.style.display = "none", document.body.appendChild(o), o.click(), document.body.removeChild(o))), this.dispatchExternal("downloadComplete"));
  }
  commsReceived(e, t, i) {
    switch (t) {
      case "intercept":
        this.download(i.type, "", i.options, i.active, i.intercept);
        break;
    }
  }
}
Vc.moduleName = "download";
Vc.downloaders = WVe;
function my(r, e) {
  var t = e.mask, i = typeof e.maskLetterChar < "u" ? e.maskLetterChar : "A", n = typeof e.maskNumberChar < "u" ? e.maskNumberChar : "9", a = typeof e.maskWildcardChar < "u" ? e.maskWildcardChar : "*";
  function o(s) {
    var l = t[s];
    typeof l < "u" && l !== a && l !== i && l !== n && (r.value = r.value + "" + l, o(s + 1));
  }
  r.addEventListener("keydown", (s) => {
    var l = r.value.length, u = s.key;
    if (s.keyCode > 46 && !s.ctrlKey && !s.metaKey) {
      if (l >= t.length)
        return s.preventDefault(), s.stopPropagation(), !1;
      switch (t[l]) {
        case i:
          if (u.toUpperCase() == u.toLowerCase())
            return s.preventDefault(), s.stopPropagation(), !1;
          break;
        case n:
          if (isNaN(u))
            return s.preventDefault(), s.stopPropagation(), !1;
          break;
        case a:
          break;
        default:
          if (u !== t[l])
            return s.preventDefault(), s.stopPropagation(), !1;
      }
    }
  }), r.addEventListener("keyup", (s) => {
    s.keyCode > 46 && e.maskAutoFill && o(r.value.length);
  }), r.placeholder || (r.placeholder = t), e.maskAutoFill && o(r.value.length);
}
function zVe(r, e, t, i, n) {
  var a = r.getValue(), o = document.createElement("input");
  if (o.setAttribute("type", n.search ? "search" : "text"), o.style.padding = "4px", o.style.width = "100%", o.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let l in n.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), o.setAttribute(l, o.getAttribute(l) + n.elementAttributes["+" + l])) : o.setAttribute(l, n.elementAttributes[l]);
  o.value = typeof a < "u" ? a : "", e(function() {
    r.getType() === "cell" && (o.focus({ preventScroll: !0 }), o.style.height = "100%", n.selectContents && o.select());
  });
  function s(l) {
    (a === null || typeof a > "u") && o.value !== "" || o.value !== a ? t(o.value) && (a = o.value) : i();
  }
  return o.addEventListener("change", s), o.addEventListener("blur", s), o.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        s();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        l.stopPropagation();
        break;
    }
  }), n.mask && my(o, n), o;
}
function ZVe(r, e, t, i, n) {
  var a = r.getValue(), o = n.verticalNavigation || "hybrid", s = String(a !== null && typeof a < "u" ? a : ""), l = document.createElement("textarea"), u = 0;
  if (l.style.display = "block", l.style.padding = "2px", l.style.height = "100%", l.style.width = "100%", l.style.boxSizing = "border-box", l.style.whiteSpace = "pre-wrap", l.style.resize = "none", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let h in n.elementAttributes)
      h.charAt(0) == "+" ? (h = h.slice(1), l.setAttribute(h, l.getAttribute(h) + n.elementAttributes["+" + h])) : l.setAttribute(h, n.elementAttributes[h]);
  l.value = s, e(function() {
    r.getType() === "cell" && (l.focus({ preventScroll: !0 }), l.style.height = "100%", l.scrollHeight, l.style.height = l.scrollHeight + "px", r.getRow().normalizeHeight(), n.selectContents && l.select());
  });
  function c(h) {
    (a === null || typeof a > "u") && l.value !== "" || l.value !== a ? (t(l.value) && (a = l.value), setTimeout(function() {
      r.getRow().normalizeHeight();
    }, 300)) : i();
  }
  return l.addEventListener("change", c), l.addEventListener("blur", c), l.addEventListener("keyup", function() {
    l.style.height = "";
    var h = l.scrollHeight;
    l.style.height = h + "px", h != u && (u = h, r.getRow().normalizeHeight());
  }), l.addEventListener("keydown", function(h) {
    switch (h.keyCode) {
      case 13:
        h.shiftKey && n.shiftEnterSubmit && c();
        break;
      case 27:
        i();
        break;
      case 38:
        (o == "editor" || o == "hybrid" && l.selectionStart) && (h.stopImmediatePropagation(), h.stopPropagation());
        break;
      case 40:
        (o == "editor" || o == "hybrid" && l.selectionStart !== l.value.length) && (h.stopImmediatePropagation(), h.stopPropagation());
        break;
      case 35:
      case 36:
        h.stopPropagation();
        break;
    }
  }), n.mask && my(l, n), l;
}
function qVe(r, e, t, i, n) {
  var a = r.getValue(), o = n.verticalNavigation || "editor", s = document.createElement("input");
  if (s.setAttribute("type", "number"), typeof n.max < "u" && s.setAttribute("max", n.max), typeof n.min < "u" && s.setAttribute("min", n.min), typeof n.step < "u" && s.setAttribute("step", n.step), s.style.padding = "4px", s.style.width = "100%", s.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let c in n.elementAttributes)
      c.charAt(0) == "+" ? (c = c.slice(1), s.setAttribute(c, s.getAttribute(c) + n.elementAttributes["+" + c])) : s.setAttribute(c, n.elementAttributes[c]);
  s.value = a;
  var l = function(c) {
    u();
  };
  e(function() {
    r.getType() === "cell" && (s.removeEventListener("blur", l), s.focus({ preventScroll: !0 }), s.style.height = "100%", s.addEventListener("blur", l), n.selectContents && s.select());
  });
  function u() {
    var c = s.value;
    !isNaN(c) && c !== "" && (c = Number(c)), c !== a ? t(c) && (a = c) : i();
  }
  return s.addEventListener("keydown", function(c) {
    switch (c.keyCode) {
      case 13:
        u();
        break;
      case 27:
        i();
        break;
      case 38:
      case 40:
        o == "editor" && (c.stopImmediatePropagation(), c.stopPropagation());
        break;
      case 35:
      case 36:
        c.stopPropagation();
        break;
    }
  }), n.mask && my(s, n), s;
}
function jVe(r, e, t, i, n) {
  var a = r.getValue(), o = document.createElement("input");
  if (o.setAttribute("type", "range"), typeof n.max < "u" && o.setAttribute("max", n.max), typeof n.min < "u" && o.setAttribute("min", n.min), typeof n.step < "u" && o.setAttribute("step", n.step), o.style.padding = "4px", o.style.width = "100%", o.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let l in n.elementAttributes)
      l.charAt(0) == "+" ? (l = l.slice(1), o.setAttribute(l, o.getAttribute(l) + n.elementAttributes["+" + l])) : o.setAttribute(l, n.elementAttributes[l]);
  o.value = a, e(function() {
    r.getType() === "cell" && (o.focus({ preventScroll: !0 }), o.style.height = "100%");
  });
  function s() {
    var l = o.value;
    !isNaN(l) && l !== "" && (l = Number(l)), l != a ? t(l) && (a = l) : i();
  }
  return o.addEventListener("blur", function(l) {
    s();
  }), o.addEventListener("keydown", function(l) {
    switch (l.keyCode) {
      case 13:
        s();
        break;
      case 27:
        i();
        break;
    }
  }), o;
}
function KVe(r, e, t, i, n) {
  var a = n.format, o = n.verticalNavigation || "editor", s = a ? window.DateTime || luxon.DateTime : null, l = r.getValue(), u = document.createElement("input");
  function c(f) {
    var d;
    return s.isDateTime(f) ? d = f : a === "iso" ? d = s.fromISO(String(f)) : d = s.fromFormat(String(f), a), d.toFormat("yyyy-MM-dd");
  }
  if (u.type = "date", u.style.padding = "4px", u.style.width = "100%", u.style.boxSizing = "border-box", n.max && u.setAttribute("max", a ? c(n.max) : n.max), n.min && u.setAttribute("min", a ? c(n.min) : n.min), n.elementAttributes && typeof n.elementAttributes == "object")
    for (let f in n.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), u.setAttribute(f, u.getAttribute(f) + n.elementAttributes["+" + f])) : u.setAttribute(f, n.elementAttributes[f]);
  l = typeof l < "u" ? l : "", a && (s ? l = c(l) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), u.value = l, e(function() {
    r.getType() === "cell" && (u.focus({ preventScroll: !0 }), u.style.height = "100%", n.selectContents && u.select());
  });
  function h() {
    var f = u.value, d;
    if ((l === null || typeof l > "u") && f !== "" || f !== l) {
      if (f && a)
        switch (d = s.fromFormat(String(f), "yyyy-MM-dd"), a) {
          case !0:
            f = d;
            break;
          case "iso":
            f = d.toISO();
            break;
          default:
            f = d.toFormat(a);
        }
      t(f) && (l = u.value);
    } else
      i();
  }
  return u.addEventListener("blur", function(f) {
    (f.relatedTarget || f.rangeParent || f.explicitOriginalTarget !== u) && h();
  }), u.addEventListener("keydown", function(f) {
    switch (f.keyCode) {
      case 13:
        h();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        f.stopPropagation();
        break;
      case 38:
      case 40:
        o == "editor" && (f.stopImmediatePropagation(), f.stopPropagation());
        break;
    }
  }), u;
}
function JVe(r, e, t, i, n) {
  var a = n.format, o = n.verticalNavigation || "editor", s = a ? window.DateTime || luxon.DateTime : null, l, u = r.getValue(), c = document.createElement("input");
  if (c.type = "time", c.style.padding = "4px", c.style.width = "100%", c.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let f in n.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), c.setAttribute(f, c.getAttribute(f) + n.elementAttributes["+" + f])) : c.setAttribute(f, n.elementAttributes[f]);
  u = typeof u < "u" ? u : "", a && (s ? (s.isDateTime(u) ? l = u : a === "iso" ? l = s.fromISO(String(u)) : l = s.fromFormat(String(u), a), u = l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), c.value = u, e(function() {
    r.getType() == "cell" && (c.focus({ preventScroll: !0 }), c.style.height = "100%", n.selectContents && c.select());
  });
  function h() {
    var f = c.value, d;
    if ((u === null || typeof u > "u") && f !== "" || f !== u) {
      if (f && a)
        switch (d = s.fromFormat(String(f), "hh:mm"), a) {
          case !0:
            f = d;
            break;
          case "iso":
            f = d.toISO();
            break;
          default:
            f = d.toFormat(a);
        }
      t(f) && (u = c.value);
    } else
      i();
  }
  return c.addEventListener("blur", function(f) {
    (f.relatedTarget || f.rangeParent || f.explicitOriginalTarget !== c) && h();
  }), c.addEventListener("keydown", function(f) {
    switch (f.keyCode) {
      case 13:
        h();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        f.stopPropagation();
        break;
      case 38:
      case 40:
        o == "editor" && (f.stopImmediatePropagation(), f.stopPropagation());
        break;
    }
  }), c;
}
function eGe(r, e, t, i, n) {
  var a = n.format, o = n.verticalNavigation || "editor", s = a ? window.DateTime || luxon.DateTime : null, l, u = r.getValue(), c = document.createElement("input");
  if (c.type = "datetime-local", c.style.padding = "4px", c.style.width = "100%", c.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let f in n.elementAttributes)
      f.charAt(0) == "+" ? (f = f.slice(1), c.setAttribute(f, c.getAttribute(f) + n.elementAttributes["+" + f])) : c.setAttribute(f, n.elementAttributes[f]);
  u = typeof u < "u" ? u : "", a && (s ? (s.isDateTime(u) ? l = u : a === "iso" ? l = s.fromISO(String(u)) : l = s.fromFormat(String(u), a), u = l.toFormat("yyyy-MM-dd") + "T" + l.toFormat("hh:mm")) : console.error("Editor Error - 'date' editor 'format' param is dependant on luxon.js")), c.value = u, e(function() {
    r.getType() === "cell" && (c.focus({ preventScroll: !0 }), c.style.height = "100%", n.selectContents && c.select());
  });
  function h() {
    var f = c.value, d;
    if ((u === null || typeof u > "u") && f !== "" || f !== u) {
      if (f && a)
        switch (d = s.fromISO(String(f)), a) {
          case !0:
            f = d;
            break;
          case "iso":
            f = d.toISO();
            break;
          default:
            f = d.toFormat(a);
        }
      t(f) && (u = c.value);
    } else
      i();
  }
  return c.addEventListener("blur", function(f) {
    (f.relatedTarget || f.rangeParent || f.explicitOriginalTarget !== c) && h();
  }), c.addEventListener("keydown", function(f) {
    switch (f.keyCode) {
      case 13:
        h();
        break;
      case 27:
        i();
        break;
      case 35:
      case 36:
        f.stopPropagation();
        break;
      case 38:
      case 40:
        o == "editor" && (f.stopImmediatePropagation(), f.stopPropagation());
        break;
    }
  }), c;
}
class LP {
  constructor(e, t, i, n, a, o) {
    this.edit = e, this.table = e.table, this.cell = t, this.params = this._initializeParams(o), this.data = [], this.displayItems = [], this.currentItems = [], this.focusedItem = null, this.input = this._createInputElement(), this.listEl = this._createListElement(), this.initialValues = null, this.isFilter = t.getType() === "header", this.filterTimeout = null, this.filtered = !1, this.typing = !1, this.values = [], this.popup = null, this.listIteration = 0, this.lastAction = "", this.filterTerm = "", this.blurable = !0, this.actions = {
      success: n,
      cancel: a
    }, this._deprecatedOptionsCheck(), this._initializeValue(), i(this._onRendered.bind(this));
  }
  _deprecatedOptionsCheck() {
    this.params.listItemFormatter && this.cell.getTable().deprecationAdvisor.msg("The listItemFormatter editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.sortValuesList && this.cell.getTable().deprecationAdvisor.msg("The sortValuesList editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchFunc && this.cell.getTable().deprecationAdvisor.msg("The searchFunc editor param has been deprecated, please see the latest editor documentation for updated options"), this.params.searchingPlaceholder && this.cell.getTable().deprecationAdvisor.msg("The searchingPlaceholder editor param has been deprecated, please see the latest editor documentation for updated options");
  }
  _initializeValue() {
    var e = this.cell.getValue();
    typeof e > "u" && typeof this.params.defaultValue < "u" && (e = this.params.defaultValue), this.initialValues = this.params.multiselect ? e : [e], this.isFilter && (this.input.value = this.initialValues ? this.initialValues.join(",") : "", this.headerFilterInitialListGen());
  }
  _onRendered() {
    var e = this.cell.getElement();
    function t(i) {
      i.stopPropagation();
    }
    this.isFilter || (this.input.style.height = "100%", this.input.focus({ preventScroll: !0 })), e.addEventListener("click", t), setTimeout(() => {
      e.removeEventListener("click", t);
    }, 1e3), this.input.addEventListener("mousedown", this._preventPopupBlur.bind(this));
  }
  _createListElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-edit-list"), e.addEventListener("mousedown", this._preventBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e;
  }
  _setListWidth() {
    var e = this.isFilter ? this.input : this.cell.getElement();
    this.listEl.style.minWidth = e.offsetWidth + "px", this.params.maxWidth && (this.params.maxWidth === !0 ? this.listEl.style.maxWidth = e.offsetWidth + "px" : typeof this.params.maxWidth == "number" ? this.listEl.style.maxWidth = this.params.maxWidth + "px" : this.listEl.style.maxWidth = this.params.maxWidth);
  }
  _createInputElement() {
    var e = this.params.elementAttributes, t = document.createElement("input");
    if (t.setAttribute("type", this.params.clearable ? "search" : "text"), t.style.padding = "4px", t.style.width = "100%", t.style.boxSizing = "border-box", this.params.autocomplete || (t.style.cursor = "default", t.style.caretColor = "transparent"), e && typeof e == "object")
      for (let i in e)
        i.charAt(0) == "+" ? (i = i.slice(1), t.setAttribute(i, t.getAttribute(i) + e["+" + i])) : t.setAttribute(i, e[i]);
    return this.params.mask && my(t, this.params), this._bindInputEvents(t), t;
  }
  _initializeParams(e) {
    var t = ["values", "valuesURL", "valuesLookup"], i;
    return e = Object.assign({}, e), e.verticalNavigation = e.verticalNavigation || "editor", e.placeholderLoading = typeof e.placeholderLoading > "u" ? "Searching ..." : e.placeholderLoading, e.placeholderEmpty = typeof e.placeholderEmpty > "u" ? "No Results Found" : e.placeholderEmpty, e.filterDelay = typeof e.filterDelay > "u" ? 300 : e.filterDelay, e.emptyValue = Object.keys(e).includes("emptyValue") ? e.emptyValue : "", i = Object.keys(e).filter((n) => t.includes(n)).length, i ? i > 1 && console.warn("list editor config error - only one of the values, valuesURL, or valuesLookup options can be set on the same editor") : console.warn("list editor config error - either the values, valuesURL, or valuesLookup option must be set"), e.autocomplete ? e.multiselect && (e.multiselect = !1, console.warn("list editor config error - multiselect option is not available when autocomplete is enabled")) : (e.freetext && (e.freetext = !1, console.warn("list editor config error - freetext option is only available when autocomplete is enabled")), e.filterFunc && (e.filterFunc = !1, console.warn("list editor config error - filterFunc option is only available when autocomplete is enabled")), e.filterRemote && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option is only available when autocomplete is enabled")), e.mask && (e.mask = !1, console.warn("list editor config error - mask option is only available when autocomplete is enabled")), e.allowEmpty && (e.allowEmpty = !1, console.warn("list editor config error - allowEmpty option is only available when autocomplete is enabled")), e.listOnEmpty && (e.listOnEmpty = !1, console.warn("list editor config error - listOnEmpty option is only available when autocomplete is enabled"))), e.filterRemote && !(typeof e.valuesLookup == "function" || e.valuesURL) && (e.filterRemote = !1, console.warn("list editor config error - filterRemote option should only be used when values list is populated from a remote source")), e;
  }
  //////////////////////////////////////
  ////////// Event Handling ////////////
  //////////////////////////////////////
  _bindInputEvents(e) {
    e.addEventListener("focus", this._inputFocus.bind(this)), e.addEventListener("click", this._inputClick.bind(this)), e.addEventListener("blur", this._inputBlur.bind(this)), e.addEventListener("keydown", this._inputKeyDown.bind(this)), e.addEventListener("search", this._inputSearch.bind(this)), this.params.autocomplete && e.addEventListener("keyup", this._inputKeyUp.bind(this));
  }
  _inputFocus(e) {
    this.rebuildOptionsList();
  }
  _filter() {
    this.params.filterRemote ? (clearTimeout(this.filterTimeout), this.filterTimeout = setTimeout(() => {
      this.rebuildOptionsList();
    }, this.params.filterDelay)) : this._filterList();
  }
  _inputClick(e) {
    e.stopPropagation();
  }
  _inputBlur(e) {
    this.blurable && (this.popup ? this.popup.hide() : this._resolveValue(!0));
  }
  _inputSearch() {
    this._clearChoices();
  }
  _inputKeyDown(e) {
    switch (e.keyCode) {
      case 38:
        this._keyUp(e);
        break;
      case 40:
        this._keyDown(e);
        break;
      case 37:
      case 39:
        this._keySide(e);
        break;
      case 13:
        this._keyEnter();
        break;
      case 27:
        this._keyEsc();
        break;
      case 36:
      case 35:
        this._keyHomeEnd(e);
        break;
      case 9:
        this._keyTab(e);
        break;
      default:
        this._keySelectLetter(e);
    }
  }
  _inputKeyUp(e) {
    switch (e.keyCode) {
      case 38:
      case 37:
      case 39:
      case 40:
      case 13:
      case 27:
        break;
      default:
        this._keyAutoCompLetter(e);
    }
  }
  _preventPopupBlur() {
    this.popup && this.popup.blockHide(), setTimeout(() => {
      this.popup && this.popup.restoreHide();
    }, 10);
  }
  _preventBlur() {
    this.blurable = !1, setTimeout(() => {
      this.blurable = !0;
    }, 10);
  }
  //////////////////////////////////////
  //////// Keyboard Navigation /////////
  //////////////////////////////////////
  _keyTab(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem, !0);
  }
  _keyUp(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t > 0 && this._focusItem(this.displayItems[t - 1]));
  }
  _keyDown(e) {
    var t = this.displayItems.indexOf(this.focusedItem);
    (this.params.verticalNavigation == "editor" || this.params.verticalNavigation == "hybrid" && t < this.displayItems.length - 1) && (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault(), t < this.displayItems.length - 1 && (t == -1 ? this._focusItem(this.displayItems[0]) : this._focusItem(this.displayItems[t + 1])));
  }
  _keySide(e) {
    this.params.autocomplete || (e.stopImmediatePropagation(), e.stopPropagation(), e.preventDefault());
  }
  _keyEnter(e) {
    this.params.autocomplete && this.lastAction === "typing" ? this._resolveValue(!0) : this.focusedItem && this._chooseItem(this.focusedItem);
  }
  _keyEsc(e) {
    this._cancel();
  }
  _keyHomeEnd(e) {
    this.params.autocomplete && e.stopImmediatePropagation();
  }
  _keySelectLetter(e) {
    this.params.autocomplete || (e.preventDefault(), e.keyCode >= 38 && e.keyCode <= 90 && this._scrollToValue(e.keyCode));
  }
  _keyAutoCompLetter(e) {
    this._filter(), this.lastAction = "typing", this.typing = !0;
  }
  _scrollToValue(e) {
    clearTimeout(this.filterTimeout);
    var t = String.fromCharCode(e).toLowerCase();
    this.filterTerm += t.toLowerCase();
    var i = this.displayItems.find((n) => typeof n.label < "u" && n.label.toLowerCase().startsWith(this.filterTerm));
    i && this._focusItem(i), this.filterTimeout = setTimeout(() => {
      this.filterTerm = "";
    }, 800);
  }
  _focusItem(e) {
    this.lastAction = "focus", this.focusedItem && this.focusedItem.element && this.focusedItem.element.classList.remove("focused"), this.focusedItem = e, e && e.element && (e.element.classList.add("focused"), e.element.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" }));
  }
  //////////////////////////////////////
  /////// Data List Generation /////////
  //////////////////////////////////////
  headerFilterInitialListGen() {
    this._generateOptions(!0);
  }
  rebuildOptionsList() {
    this._generateOptions().then(this._sortOptions.bind(this)).then(this._buildList.bind(this)).then(this._showList.bind(this)).catch((e) => {
      Number.isInteger(e) || console.error("List generation error", e);
    });
  }
  _filterList() {
    this._buildList(this._filterOptions()), this._showList();
  }
  _generateOptions(e) {
    var t = [], i = ++this.listIteration;
    return this.filtered = !1, this.params.values ? t = this.params.values : this.params.valuesURL ? t = this._ajaxRequest(this.params.valuesURL, this.input.value) : typeof this.params.valuesLookup == "function" ? t = this.params.valuesLookup(this.cell, this.input.value) : this.params.valuesLookup && (t = this._uniqueColumnValues(this.params.valuesLookupField)), t instanceof Promise ? (e || this._addPlaceholder(this.params.placeholderLoading), t.then().then((n) => this.listIteration === i ? this._parseList(n) : Promise.reject(i))) : Promise.resolve(this._parseList(t));
  }
  _addPlaceholder(e) {
    var t = document.createElement("div");
    typeof e == "function" && (e = e(this.cell.getComponent(), this.listEl)), e && (this._clearList(), e instanceof HTMLElement ? t = e : (t.classList.add("tabulator-edit-list-placeholder"), t.innerHTML = e), this.listEl.appendChild(t), this._showList());
  }
  _ajaxRequest(e, t) {
    var i = this.params.filterRemote ? { term: t } : {};
    return e = Vq(e, {}, i), fetch(e).then((n) => n.ok ? n.json().catch((a) => (console.warn("List Ajax Load Error - Invalid JSON returned", a), Promise.reject(a))) : (console.error("List Ajax Load Error - Connection Error: " + n.status, n.statusText), Promise.reject(n))).catch((n) => (console.error("List Ajax Load Error - Connection Error: ", n), Promise.reject(n)));
  }
  _uniqueColumnValues(e) {
    var t = {}, i = this.table.getData(this.params.valuesLookup), n;
    return e ? n = this.table.columnManager.getColumnByField(e) : n = this.cell.getColumn()._getSelf(), n ? i.forEach((a) => {
      var o = n.getFieldValue(a);
      o !== null && typeof o < "u" && o !== "" && (t[o] = !0);
    }) : (console.warn("unable to find matching column to create select lookup list:", e), t = []), Object.keys(t);
  }
  _parseList(e) {
    var t = [];
    return Array.isArray(e) || (e = Object.entries(e).map(([i, n]) => ({
      label: n,
      value: i
    }))), e.forEach((i) => {
      typeof i != "object" && (i = {
        label: i,
        value: i
      }), this._parseListItem(i, t, 0);
    }), !this.currentItems.length && this.params.freetext && (this.input.value = this.initialValues, this.typing = !0, this.lastAction = "typing"), this.data = t, t;
  }
  _parseListItem(e, t, i) {
    var n = {};
    e.options ? n = this._parseListGroup(e, i + 1) : (n = {
      label: e.label,
      value: e.value,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      selected: !1,
      visible: !0,
      level: i,
      original: e
    }, this.initialValues && this.initialValues.indexOf(e.value) > -1 && this._chooseItem(n, !0)), t.push(n);
  }
  _parseListGroup(e, t) {
    var i = {
      label: e.label,
      group: !0,
      itemParams: e.itemParams,
      elementAttributes: e.elementAttributes,
      element: !1,
      visible: !0,
      level: t,
      options: [],
      original: e
    };
    return e.options.forEach((n) => {
      this._parseListItem(n, i.options, t);
    }), i;
  }
  _sortOptions(e) {
    var t;
    return this.params.sort && (t = typeof this.params.sort == "function" ? this.params.sort : this._defaultSortFunction.bind(this), this._sortGroup(t, e)), e;
  }
  _sortGroup(e, t) {
    t.sort((i, n) => e(i.label, n.label, i.value, n.value, i.original, n.original)), t.forEach((i) => {
      i.group && this._sortGroup(e, i.options);
    });
  }
  _defaultSortFunction(e, t) {
    var i, n, a, o, s = 0, l, u = /(\d+)|(\D+)/g, c = /\d/, h = 0;
    if (this.params.sort === "desc" && ([e, t] = [t, e]), !e && e !== 0)
      h = !t && t !== 0 ? 0 : -1;
    else if (!t && t !== 0)
      h = 1;
    else {
      if (isFinite(e) && isFinite(t))
        return e - t;
      if (i = String(e).toLowerCase(), n = String(t).toLowerCase(), i === n)
        return 0;
      if (!(c.test(i) && c.test(n)))
        return i > n ? 1 : -1;
      for (i = i.match(u), n = n.match(u), l = i.length > n.length ? n.length : i.length; s < l; )
        if (a = i[s], o = n[s++], a !== o)
          return isFinite(a) && isFinite(o) ? (a.charAt(0) === "0" && (a = "." + a), o.charAt(0) === "0" && (o = "." + o), a - o) : a > o ? 1 : -1;
      return i.length > n.length;
    }
    return h;
  }
  _filterOptions() {
    var e = this.params.filterFunc || this._defaultFilterFunc, t = this.input.value;
    return t ? (this.filtered = !0, this.data.forEach((i) => {
      this._filterItem(e, t, i);
    })) : this.filtered = !1, this.data;
  }
  _filterItem(e, t, i) {
    var n = !1;
    return i.group ? (i.options.forEach((a) => {
      this._filterItem(e, t, a) && (n = !0);
    }), i.visible = n) : i.visible = e(t, i.label, i.value, i.original), i.visible;
  }
  _defaultFilterFunc(e, t, i, n) {
    return e = String(e).toLowerCase(), t !== null && typeof t < "u" && (String(t).toLowerCase().indexOf(e) > -1 || String(i).toLowerCase().indexOf(e) > -1);
  }
  //////////////////////////////////////
  /////////// Display List /////////////
  //////////////////////////////////////
  _clearList() {
    for (; this.listEl.firstChild; )
      this.listEl.removeChild(this.listEl.firstChild);
    this.displayItems = [];
  }
  _buildList(e) {
    this._clearList(), e.forEach((t) => {
      this._buildItem(t);
    }), this.displayItems.length || this._addPlaceholder(this.params.placeholderEmpty);
  }
  _buildItem(e) {
    var t = e.element, i;
    if (!this.filtered || e.visible) {
      if (!t) {
        if (t = document.createElement("div"), t.tabIndex = 0, i = this.params.itemFormatter ? this.params.itemFormatter(e.label, e.value, e.original, t) : e.label, i instanceof HTMLElement ? t.appendChild(i) : t.innerHTML = i, e.group ? t.classList.add("tabulator-edit-list-group") : t.classList.add("tabulator-edit-list-item"), t.classList.add("tabulator-edit-list-group-level-" + e.level), e.elementAttributes && typeof e.elementAttributes == "object")
          for (let n in e.elementAttributes)
            n.charAt(0) == "+" ? (n = n.slice(1), t.setAttribute(n, this.input.getAttribute(n) + e.elementAttributes["+" + n])) : t.setAttribute(n, e.elementAttributes[n]);
        e.group ? t.addEventListener("click", this._groupClick.bind(this, e)) : t.addEventListener("click", this._itemClick.bind(this, e)), t.addEventListener("mousedown", this._preventBlur.bind(this)), e.element = t;
      }
      this._styleItem(e), this.listEl.appendChild(t), e.group ? e.options.forEach((n) => {
        this._buildItem(n);
      }) : this.displayItems.push(e);
    }
  }
  _showList() {
    var e = this.popup && this.popup.isVisible();
    if (this.input.parentNode) {
      if (this.params.autocomplete && this.input.value === "" && !this.params.listOnEmpty) {
        this.popup && this.popup.hide(!0);
        return;
      }
      this._setListWidth(), this.popup || (this.popup = this.edit.popup(this.listEl)), this.popup.show(this.cell.getElement(), "bottom"), e || setTimeout(() => {
        this.popup.hideOnBlur(this._resolveValue.bind(this, !0));
      }, 10);
    }
  }
  _styleItem(e) {
    e && e.element && (e.selected ? e.element.classList.add("active") : e.element.classList.remove("active"));
  }
  //////////////////////////////////////
  ///////// User Interaction ///////////
  //////////////////////////////////////
  _itemClick(e, t) {
    t.stopPropagation(), this._chooseItem(e);
  }
  _groupClick(e, t) {
    t.stopPropagation();
  }
  //////////////////////////////////////
  ////// Current Item Management ///////
  //////////////////////////////////////
  _cancel() {
    this.popup.hide(!0), this.actions.cancel();
  }
  _clearChoices() {
    this.typing = !0, this.currentItems.forEach((e) => {
      e.selected = !1, this._styleItem(e);
    }), this.currentItems = [], this.focusedItem = null;
  }
  _chooseItem(e, t) {
    var i;
    this.typing = !1, this.params.multiselect ? (i = this.currentItems.indexOf(e), i > -1 ? (this.currentItems.splice(i, 1), e.selected = !1) : (this.currentItems.push(e), e.selected = !0), this.input.value = this.currentItems.map((n) => n.label).join(","), this._styleItem(e)) : (this.currentItems = [e], e.selected = !0, this.input.value = e.label, this._styleItem(e), t || this._resolveValue()), this._focusItem(e);
  }
  _resolveValue(e) {
    var t, i;
    if (this.popup && this.popup.hide(!0), this.params.multiselect)
      t = this.currentItems.map((n) => n.value);
    else if (e && this.params.autocomplete && this.typing)
      if (this.params.freetext || this.params.allowEmpty && this.input.value === "")
        t = this.input.value;
      else {
        this.actions.cancel();
        return;
      }
    else
      this.currentItems[0] ? t = this.currentItems[0].value : (i = Array.isArray(this.initialValues) ? this.initialValues[0] : this.initialValues, i === null || typeof i > "u" || i === "" ? t = i : t = this.params.emptyValue);
    t === "" && (t = this.params.emptyValue), this.actions.success(t), this.isFilter && (this.initialValues = t && !Array.isArray(t) ? [t] : t, this.currentItems = []);
  }
}
function tGe(r, e, t, i, n) {
  this.deprecationMsg("The select editor has been deprecated, please use the new list editor");
  var a = new LP(this, r, e, t, i, n);
  return a.input;
}
function rGe(r, e, t, i, n) {
  var a = new LP(this, r, e, t, i, n);
  return a.input;
}
function iGe(r, e, t, i, n) {
  this.deprecationMsg("The autocomplete editor has been deprecated, please use the new list editor with the 'autocomplete' editorParam"), n.autocomplete = !0;
  var a = new LP(this, r, e, t, i, n);
  return a.input;
}
function nGe(r, e, t, i, n) {
  var a = this, o = r.getElement(), s = r.getValue(), l = o.getElementsByTagName("svg").length || 5, u = o.getElementsByTagName("svg")[0] ? o.getElementsByTagName("svg")[0].getAttribute("width") : 14, c = [], h = document.createElement("div"), f = document.createElementNS("http://www.w3.org/2000/svg", "svg");
  function d(O) {
    c.forEach(function(m, E) {
      E < O ? (a.table.browser == "ie" ? m.setAttribute("class", "tabulator-star-active") : m.classList.replace("tabulator-star-inactive", "tabulator-star-active"), m.innerHTML = '<polygon fill="#488CE9" stroke="#014AAE" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>') : (a.table.browser == "ie" ? m.setAttribute("class", "tabulator-star-inactive") : m.classList.replace("tabulator-star-active", "tabulator-star-inactive"), m.innerHTML = '<polygon fill="#010155" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>');
    });
  }
  function p(O) {
    var m = document.createElement("span"), E = f.cloneNode(!0);
    c.push(E), m.addEventListener("mouseenter", function(b) {
      b.stopPropagation(), b.stopImmediatePropagation(), d(O);
    }), m.addEventListener("mousemove", function(b) {
      b.stopPropagation(), b.stopImmediatePropagation();
    }), m.addEventListener("click", function(b) {
      b.stopPropagation(), b.stopImmediatePropagation(), t(O), o.blur();
    }), m.appendChild(E), h.appendChild(m);
  }
  function g(O) {
    s = O, d(O);
  }
  if (o.style.whiteSpace = "nowrap", o.style.overflow = "hidden", o.style.textOverflow = "ellipsis", h.style.verticalAlign = "middle", h.style.display = "inline-block", h.style.padding = "4px", f.setAttribute("width", u), f.setAttribute("height", u), f.setAttribute("viewBox", "0 0 512 512"), f.setAttribute("xml:space", "preserve"), f.style.padding = "0 1px", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let O in n.elementAttributes)
      O.charAt(0) == "+" ? (O = O.slice(1), h.setAttribute(O, h.getAttribute(O) + n.elementAttributes["+" + O])) : h.setAttribute(O, n.elementAttributes[O]);
  for (var v = 1; v <= l; v++)
    p(v);
  return s = Math.min(parseInt(s), l), d(s), h.addEventListener("mousemove", function(O) {
    d(0);
  }), h.addEventListener("click", function(O) {
    t(0);
  }), o.addEventListener("blur", function(O) {
    i();
  }), o.addEventListener("keydown", function(O) {
    switch (O.keyCode) {
      case 39:
        g(s + 1);
        break;
      case 37:
        g(s - 1);
        break;
      case 13:
        t(s);
        break;
      case 27:
        i();
        break;
    }
  }), h;
}
function aGe(r, e, t, i, n) {
  var a = r.getElement(), o = typeof n.max > "u" ? a.getElementsByTagName("div")[0] && a.getElementsByTagName("div")[0].getAttribute("max") || 100 : n.max, s = typeof n.min > "u" ? a.getElementsByTagName("div")[0] && a.getElementsByTagName("div")[0].getAttribute("min") || 0 : n.min, l = (o - s) / 100, u = r.getValue() || 0, c = document.createElement("div"), h = document.createElement("div"), f, d;
  function p() {
    var g = window.getComputedStyle(a, null), v = l * Math.round(h.offsetWidth / ((a.clientWidth - parseInt(g.getPropertyValue("padding-left")) - parseInt(g.getPropertyValue("padding-right"))) / 100)) + s;
    t(v), a.setAttribute("aria-valuenow", v), a.setAttribute("aria-label", u);
  }
  if (c.style.position = "absolute", c.style.right = "0", c.style.top = "0", c.style.bottom = "0", c.style.width = "5px", c.classList.add("tabulator-progress-handle"), h.style.display = "inline-block", h.style.position = "relative", h.style.height = "100%", h.style.backgroundColor = "#488CE9", h.style.maxWidth = "100%", h.style.minWidth = "0%", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let g in n.elementAttributes)
      g.charAt(0) == "+" ? (g = g.slice(1), h.setAttribute(g, h.getAttribute(g) + n.elementAttributes["+" + g])) : h.setAttribute(g, n.elementAttributes[g]);
  return a.style.padding = "4px 4px", u = Math.min(parseFloat(u), o), u = Math.max(parseFloat(u), s), u = Math.round((u - s) / l), h.style.width = u + "%", a.setAttribute("aria-valuemin", s), a.setAttribute("aria-valuemax", o), h.appendChild(c), c.addEventListener("mousedown", function(g) {
    f = g.screenX, d = h.offsetWidth;
  }), c.addEventListener("mouseover", function() {
    c.style.cursor = "ew-resize";
  }), a.addEventListener("mousemove", function(g) {
    f && (h.style.width = d + g.screenX - f + "px");
  }), a.addEventListener("mouseup", function(g) {
    f && (g.stopPropagation(), g.stopImmediatePropagation(), f = !1, d = !1, p());
  }), a.addEventListener("keydown", function(g) {
    switch (g.keyCode) {
      case 39:
        g.preventDefault(), h.style.width = h.clientWidth + a.clientWidth / 100 + "px";
        break;
      case 37:
        g.preventDefault(), h.style.width = h.clientWidth - a.clientWidth / 100 + "px";
        break;
      case 9:
      case 13:
        p();
        break;
      case 27:
        i();
        break;
    }
  }), a.addEventListener("blur", function() {
    i();
  }), h;
}
function oGe(r, e, t, i, n) {
  var a = r.getValue(), o = document.createElement("input"), s = n.tristate, l = typeof n.indeterminateValue > "u" ? null : n.indeterminateValue, u = !1, c = Object.keys(n).includes("trueValue"), h = Object.keys(n).includes("falseValue");
  if (o.setAttribute("type", "checkbox"), o.style.marginTop = "5px", o.style.boxSizing = "border-box", n.elementAttributes && typeof n.elementAttributes == "object")
    for (let d in n.elementAttributes)
      d.charAt(0) == "+" ? (d = d.slice(1), o.setAttribute(d, o.getAttribute(d) + n.elementAttributes["+" + d])) : o.setAttribute(d, n.elementAttributes[d]);
  o.value = a, s && (typeof a > "u" || a === l || a === "") && (u = !0, o.indeterminate = !0), this.table.browser != "firefox" && this.table.browser != "safari" && e(function() {
    r.getType() === "cell" && o.focus({ preventScroll: !0 });
  }), o.checked = c ? a === n.trueValue : a === !0 || a === "true" || a === "True" || a === 1;
  function f(d) {
    var p = o.checked;
    return c && p ? p = n.trueValue : h && !p && (p = n.falseValue), s ? d ? u ? l : p : o.checked && !u ? (o.checked = !1, o.indeterminate = !0, u = !0, l) : (u = !1, p) : p;
  }
  return o.addEventListener("change", function(d) {
    t(f());
  }), o.addEventListener("blur", function(d) {
    t(f(!0));
  }), o.addEventListener("keydown", function(d) {
    d.keyCode == 13 && t(f()), d.keyCode == 27 && i();
  }), o;
}
var sGe = {
  input: zVe,
  textarea: ZVe,
  number: qVe,
  range: jVe,
  date: KVe,
  time: JVe,
  datetime: eGe,
  select: tGe,
  list: rGe,
  autocomplete: iGe,
  star: nGe,
  progress: aGe,
  tickCross: oGe
};
class gd extends mt {
  constructor(e) {
    super(e), this.currentCell = !1, this.mouseClick = !1, this.recursionBlock = !1, this.invalidEdit = !1, this.editedCells = [], this.editors = gd.editors, this.registerColumnOption("editable"), this.registerColumnOption("editor"), this.registerColumnOption("editorParams"), this.registerColumnOption("cellEditing"), this.registerColumnOption("cellEdited"), this.registerColumnOption("cellEditCancelled"), this.registerTableFunction("getEditedCells", this.getEditedCells.bind(this)), this.registerTableFunction("clearCellEdited", this.clearCellEdited.bind(this)), this.registerTableFunction("navigatePrev", this.navigatePrev.bind(this)), this.registerTableFunction("navigateNext", this.navigateNext.bind(this)), this.registerTableFunction("navigateLeft", this.navigateLeft.bind(this)), this.registerTableFunction("navigateRight", this.navigateRight.bind(this)), this.registerTableFunction("navigateUp", this.navigateUp.bind(this)), this.registerTableFunction("navigateDown", this.navigateDown.bind(this)), this.registerComponentFunction("cell", "isEdited", this.cellIsEdited.bind(this)), this.registerComponentFunction("cell", "clearEdited", this.clearEdited.bind(this)), this.registerComponentFunction("cell", "edit", this.editCell.bind(this)), this.registerComponentFunction("cell", "cancelEdit", this.cellCancelEdit.bind(this)), this.registerComponentFunction("cell", "navigatePrev", this.navigatePrev.bind(this)), this.registerComponentFunction("cell", "navigateNext", this.navigateNext.bind(this)), this.registerComponentFunction("cell", "navigateLeft", this.navigateLeft.bind(this)), this.registerComponentFunction("cell", "navigateRight", this.navigateRight.bind(this)), this.registerComponentFunction("cell", "navigateUp", this.navigateUp.bind(this)), this.registerComponentFunction("cell", "navigateDown", this.navigateDown.bind(this));
  }
  initialize() {
    this.subscribe("cell-init", this.bindEditor.bind(this)), this.subscribe("cell-delete", this.clearEdited.bind(this)), this.subscribe("cell-value-changed", this.updateCellClass.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("column-delete", this.columnDeleteCheck.bind(this)), this.subscribe("row-deleting", this.rowDeleteCheck.bind(this)), this.subscribe("row-layout", this.rowEditableCheck.bind(this)), this.subscribe("data-refreshing", this.cancelEdit.bind(this)), this.subscribe("keybinding-nav-prev", this.navigatePrev.bind(this, void 0)), this.subscribe("keybinding-nav-next", this.keybindingNavigateNext.bind(this)), this.subscribe("keybinding-nav-left", this.navigateLeft.bind(this, void 0)), this.subscribe("keybinding-nav-right", this.navigateRight.bind(this, void 0)), this.subscribe("keybinding-nav-up", this.navigateUp.bind(this, void 0)), this.subscribe("keybinding-nav-down", this.navigateDown.bind(this, void 0));
  }
  ///////////////////////////////////
  ////// Keybinding Functions ///////
  ///////////////////////////////////
  keybindingNavigateNext(e) {
    var t = this.currentCell, i = this.options("tabEndNewRow");
    t && (this.navigateNext(t, e) || i && (t.getElement().firstChild.blur(), i === !0 ? i = this.table.addRow({}) : typeof i == "function" ? i = this.table.addRow(i(t.row.getComponent())) : i = this.table.addRow(Object.assign({}, i)), i.then(() => {
      setTimeout(() => {
        t.getComponent().navigateNext();
      });
    })));
  }
  ///////////////////////////////////
  ///////// Cell Functions //////////
  ///////////////////////////////////
  cellIsEdited(e) {
    return !!e.modules.edit && e.modules.edit.edited;
  }
  cellCancelEdit(e) {
    e === this.currentCell ? this.table.modules.edit.cancelEdit() : console.warn("Cancel Editor Error - This cell is not currently being edited ");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  updateCellClass(e) {
    this.allowEdit(e) ? e.getElement().classList.add("tabulator-editable") : e.getElement().classList.remove("tabulator-editable");
  }
  clearCellEdited(e) {
    e || (e = this.table.modules.edit.getEditedCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.table.modules.edit.clearEdited(t._getSelf());
    });
  }
  navigatePrev(e = this.currentCell, t) {
    var i, n;
    if (e) {
      if (t && t.preventDefault(), i = this.navigateLeft(), i)
        return !0;
      if (n = this.table.rowManager.prevDisplayRow(e.row, !0), n && (i = this.findPrevEditableCell(n, n.cells.length), i))
        return i.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateNext(e = this.currentCell, t) {
    var i, n;
    if (e) {
      if (t && t.preventDefault(), i = this.navigateRight(), i)
        return !0;
      if (n = this.table.rowManager.nextDisplayRow(e.row, !0), n && (i = this.findNextEditableCell(n, -1), i))
        return i.getComponent().edit(), !0;
    }
    return !1;
  }
  navigateLeft(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.findPrevEditableCell(e.row, i), n) ? (n.getComponent().edit(), !0) : !1;
  }
  navigateRight(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.findNextEditableCell(e.row, i), n) ? (n.getComponent().edit(), !0) : !1;
  }
  navigateUp(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.table.rowManager.prevDisplayRow(e.row, !0), n) ? (n.cells[i].getComponent().edit(), !0) : !1;
  }
  navigateDown(e = this.currentCell, t) {
    var i, n;
    return e && (t && t.preventDefault(), i = e.getIndex(), n = this.table.rowManager.nextDisplayRow(e.row, !0), n) ? (n.cells[i].getComponent().edit(), !0) : !1;
  }
  findNextEditableCell(e, t) {
    var i = !1;
    if (t < e.cells.length - 1)
      for (var n = t + 1; n < e.cells.length; n++) {
        let a = e.cells[n];
        if (a.column.modules.edit && Zt.elVisible(a.getElement()) && this.allowEdit(a)) {
          i = a;
          break;
        }
      }
    return i;
  }
  findPrevEditableCell(e, t) {
    var i = !1;
    if (t > 0)
      for (var n = t - 1; n >= 0; n--) {
        let a = e.cells[n];
        if (a.column.modules.edit && Zt.elVisible(a.getElement()) && this.allowEdit(a)) {
          i = a;
          break;
        }
      }
    return i;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.editor < "u" && this.initializeColumn(e);
  }
  columnDeleteCheck(e) {
    this.currentCell && this.currentCell.column === e && this.cancelEdit();
  }
  rowDeleteCheck(e) {
    this.currentCell && this.currentCell.row === e && this.cancelEdit();
  }
  rowEditableCheck(e) {
    e.getCells().forEach((t) => {
      t.column.modules.edit && typeof t.column.modules.edit.check == "function" && this.updateCellClass(t);
    });
  }
  //initialize column editor
  initializeColumn(e) {
    var t = {
      editor: !1,
      blocked: !1,
      check: e.definition.editable,
      params: e.definition.editorParams || {}
    };
    switch (typeof e.definition.editor) {
      case "string":
        this.editors[e.definition.editor] ? t.editor = this.editors[e.definition.editor] : console.warn("Editor Error - No such editor found: ", e.definition.editor);
        break;
      case "function":
        t.editor = e.definition.editor;
        break;
      case "boolean":
        e.definition.editor === !0 && (typeof e.definition.formatter != "function" ? this.editors[e.definition.formatter] ? t.editor = this.editors[e.definition.formatter] : t.editor = this.editors.input : console.warn("Editor Error - Cannot auto lookup editor for a custom formatter: ", e.definition.formatter));
        break;
    }
    t.editor && (e.modules.edit = t);
  }
  getCurrentCell() {
    return this.currentCell ? this.currentCell.getComponent() : !1;
  }
  clearEditor(e) {
    var t = this.currentCell, i;
    if (this.invalidEdit = !1, t) {
      for (this.currentCell = !1, i = t.getElement(), this.dispatch("edit-editor-clear", t, e), i.classList.remove("tabulator-editing"); i.firstChild; )
        i.removeChild(i.firstChild);
      t.row.getElement().classList.remove("tabulator-editing"), t.table.element.classList.remove("tabulator-editing");
    }
  }
  cancelEdit() {
    if (this.currentCell) {
      var e = this.currentCell, t = this.currentCell.getComponent();
      this.clearEditor(!0), e.setValueActual(e.getValue()), e.cellRendered(), (e.column.definition.editor == "textarea" || e.column.definition.variableHeight) && e.row.normalizeHeight(!0), e.column.definition.cellEditCancelled && e.column.definition.cellEditCancelled.call(this.table, t), this.dispatch("edit-cancelled", e), this.dispatchExternal("cellEditCancelled", t);
    }
  }
  //return a formatted value for a cell
  bindEditor(e) {
    if (e.column.modules.edit) {
      var t = this, i = e.getElement(!0);
      this.updateCellClass(e), i.setAttribute("tabindex", 0), i.addEventListener("click", function(n) {
        i.classList.contains("tabulator-editing") || i.focus({ preventScroll: !0 });
      }), i.addEventListener("mousedown", function(n) {
        n.button === 2 ? n.preventDefault() : t.mouseClick = !0;
      }), i.addEventListener("focus", function(n) {
        t.recursionBlock || t.edit(e, n, !1);
      });
    }
  }
  focusCellNoEvent(e, t) {
    this.recursionBlock = !0, t && this.table.browser === "ie" || e.getElement().focus({ preventScroll: !0 }), this.recursionBlock = !1;
  }
  editCell(e, t) {
    this.focusCellNoEvent(e), this.edit(e, !1, t);
  }
  focusScrollAdjust(e) {
    if (this.table.rowManager.getRenderMode() == "virtual") {
      var t = this.table.rowManager.element.scrollTop, i = this.table.rowManager.element.clientHeight + this.table.rowManager.element.scrollTop, n = e.row.getElement();
      n.offsetTop < t ? this.table.rowManager.element.scrollTop -= t - n.offsetTop : n.offsetTop + n.offsetHeight > i && (this.table.rowManager.element.scrollTop += n.offsetTop + n.offsetHeight - i);
      var a = this.table.rowManager.element.scrollLeft, o = this.table.rowManager.element.clientWidth + this.table.rowManager.element.scrollLeft, s = e.getElement();
      this.table.modExists("frozenColumns") && (a += parseInt(this.table.modules.frozenColumns.leftMargin || 0), o -= parseInt(this.table.modules.frozenColumns.rightMargin || 0)), this.table.options.renderHorizontal === "virtual" && (a -= parseInt(this.table.columnManager.renderer.vDomPadLeft), o -= parseInt(this.table.columnManager.renderer.vDomPadLeft)), s.offsetLeft < a ? this.table.rowManager.element.scrollLeft -= a - s.offsetLeft : s.offsetLeft + s.offsetWidth > o && (this.table.rowManager.element.scrollLeft += s.offsetLeft + s.offsetWidth - o);
    }
  }
  allowEdit(e) {
    var t = !!e.column.modules.edit;
    if (e.column.modules.edit)
      switch (typeof e.column.modules.edit.check) {
        case "function":
          e.row.initialized && (t = e.column.modules.edit.check(e.getComponent()));
          break;
        case "string":
          t = !!e.row.data[e.column.modules.edit.check];
          break;
        case "boolean":
          t = e.column.modules.edit.check;
          break;
      }
    return t;
  }
  edit(e, t, i) {
    var n = this, a = !0, o = function() {
    }, s = e.getElement(), l, u, c;
    if (this.currentCell) {
      !this.invalidEdit && this.currentCell !== e && this.cancelEdit();
      return;
    }
    function h(v) {
      if (n.currentCell === e) {
        var O = n.chain("edit-success", [e, v], !0, !0);
        return O === !0 || n.table.options.validationMode === "highlight" ? (n.clearEditor(), e.modules.edit || (e.modules.edit = {}), e.modules.edit.edited = !0, n.editedCells.indexOf(e) == -1 && n.editedCells.push(e), e.setValue(v, !0), O === !0) : (n.invalidEdit = !0, n.focusCellNoEvent(e, !0), o(), !1);
      }
    }
    function f() {
      n.currentCell === e && n.cancelEdit();
    }
    function d(v) {
      o = v;
    }
    if (e.column.modules.edit.blocked)
      return this.mouseClick = !1, s.blur(), !1;
    if (t && t.stopPropagation(), a = this.allowEdit(e), a || i) {
      if (n.cancelEdit(), n.currentCell = e, this.focusScrollAdjust(e), u = e.getComponent(), this.mouseClick && (this.mouseClick = !1, e.column.definition.cellClick && e.column.definition.cellClick.call(this.table, t, u)), e.column.definition.cellEditing && e.column.definition.cellEditing.call(this.table, u), this.dispatch("cell-editing", e), this.dispatchExternal("cellEditing", u), c = typeof e.column.modules.edit.params == "function" ? e.column.modules.edit.params(u) : e.column.modules.edit.params, l = e.column.modules.edit.editor.call(n, u, d, h, f, c), this.currentCell && l !== !1)
        if (l instanceof Node) {
          for (s.classList.add("tabulator-editing"), e.row.getElement().classList.add("tabulator-editing"), e.table.element.classList.add("tabulator-editing"); s.firstChild; )
            s.removeChild(s.firstChild);
          s.appendChild(l), o();
          for (var p = s.children, g = 0; g < p.length; g++)
            p[g].addEventListener("click", function(v) {
              v.stopPropagation();
            });
        } else
          return console.warn("Edit Error - Editor should return an instance of Node, the editor returned:", l), s.blur(), !1;
      else
        return s.blur(), !1;
      return !0;
    } else
      return this.mouseClick = !1, s.blur(), !1;
  }
  getEditedCells() {
    var e = [];
    return this.editedCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearEdited(e) {
    var t;
    e.modules.edit && e.modules.edit.edited && (e.modules.edit.edited = !1, this.dispatch("edit-edited-clear", e)), t = this.editedCells.indexOf(e), t > -1 && this.editedCells.splice(t, 1);
  }
}
gd.moduleName = "edit";
gd.editors = sGe;
class d5 {
  constructor(e, t, i, n) {
    this.type = e, this.columns = t, this.component = i || !1, this.indent = n || 0;
  }
}
class zA {
  constructor(e, t, i, n, a) {
    this.value = e, this.component = t || !1, this.width = i, this.height = n, this.depth = a;
  }
}
class DP extends mt {
  constructor(e) {
    super(e), this.config = {}, this.cloneTableStyle = !0, this.colVisProp = "", this.registerTableOption("htmlOutputConfig", !1), this.registerColumnOption("htmlOutput"), this.registerColumnOption("titleHtmlOutput");
  }
  initialize() {
    this.registerTableFunction("getHtml", this.getHtml.bind(this));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  generateExportList(e, t, i, n) {
    this.cloneTableStyle = t, this.config = e || {}, this.colVisProp = n;
    var a = this.config.columnHeaders !== !1 ? this.headersToExportRows(this.generateColumnGroupHeaders()) : [], o = this.bodyToExportRows(this.rowLookup(i));
    return a.concat(o);
  }
  generateTable(e, t, i, n) {
    var a = this.generateExportList(e, t, i, n);
    return this.generateTableElement(a);
  }
  rowLookup(e) {
    var t = [];
    if (typeof e == "function")
      e.call(this.table).forEach((i) => {
        i = this.table.rowManager.findRow(i), i && t.push(i);
      });
    else
      switch (e) {
        case !0:
        case "visible":
          t = this.table.rowManager.getVisibleRows(!1, !0);
          break;
        case "all":
          t = this.table.rowManager.rows;
          break;
        case "selected":
          t = this.table.modules.selectRow.selectedRows;
          break;
        case "active":
        default:
          this.table.options.pagination ? t = this.table.rowManager.getDisplayRows(this.table.rowManager.displayRows.length - 2) : t = this.table.rowManager.getDisplayRows();
      }
    return Object.assign([], t);
  }
  generateColumnGroupHeaders() {
    var e = [], t = this.config.columnGroups !== !1 ? this.table.columnManager.columns : this.table.columnManager.columnsByIndex;
    return t.forEach((i) => {
      var n = this.processColumnGroup(i);
      n && e.push(n);
    }), e;
  }
  processColumnGroup(e) {
    var t = e.columns, i = 0, n = e.definition["title" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))] || e.definition.title, a = {
      title: n,
      column: e,
      depth: 1
    };
    if (t.length) {
      if (a.subGroups = [], a.width = 0, t.forEach((o) => {
        var s = this.processColumnGroup(o);
        s && (a.width += s.width, a.subGroups.push(s), s.depth > i && (i = s.depth));
      }), a.depth += i, !a.width)
        return !1;
    } else if (this.columnVisCheck(e))
      a.width = 1;
    else
      return !1;
    return a;
  }
  columnVisCheck(e) {
    var t = e.definition[this.colVisProp];
    return typeof t == "function" && (t = t.call(this.table, e.getComponent())), t !== !1 && (e.visible || !e.visible && t);
  }
  headersToExportRows(e) {
    var t = [], i = 0, n = [];
    function a(o, s) {
      var l = i - s;
      if (typeof t[s] > "u" && (t[s] = []), o.height = o.subGroups ? 1 : l - o.depth + 1, t[s].push(o), o.height > 1)
        for (let u = 1; u < o.height; u++)
          typeof t[s + u] > "u" && (t[s + u] = []), t[s + u].push(!1);
      if (o.width > 1)
        for (let u = 1; u < o.width; u++)
          t[s].push(!1);
      o.subGroups && o.subGroups.forEach(function(u) {
        a(u, s + 1);
      });
    }
    return e.forEach(function(o) {
      o.depth > i && (i = o.depth);
    }), e.forEach(function(o) {
      a(o, 0);
    }), t.forEach((o) => {
      var s = [];
      o.forEach((l) => {
        if (l) {
          let u = typeof l.title > "u" ? "" : l.title;
          s.push(new zA(u, l.column.getComponent(), l.width, l.height, l.depth));
        } else
          s.push(null);
      }), n.push(new d5("header", s));
    }), n;
  }
  bodyToExportRows(e) {
    var t = [], i = [];
    return this.table.columnManager.columnsByIndex.forEach((n) => {
      this.columnVisCheck(n) && t.push(n.getComponent());
    }), this.config.columnCalcs !== !1 && this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && e.unshift(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && e.push(this.table.modules.columnCalcs.botRow)), e = e.filter((n) => {
      switch (n.type) {
        case "group":
          return this.config.rowGroups !== !1;
        case "calc":
          return this.config.columnCalcs !== !1;
        case "row":
          return !(this.table.options.dataTree && this.config.dataTree === !1 && n.modules.dataTree.parent);
      }
      return !0;
    }), e.forEach((n, a) => {
      var o = n.getData(this.colVisProp), s = [], l = 0;
      switch (n.type) {
        case "group":
          l = n.level, s.push(new zA(n.key, n.getComponent(), t.length, 1));
          break;
        case "calc":
        case "row":
          t.forEach((u) => {
            s.push(new zA(u._column.getFieldValue(o), u, 1, 1));
          }), this.table.options.dataTree && this.config.dataTree !== !1 && (l = n.modules.dataTree.index);
          break;
      }
      i.push(new d5(n.type, s, n.getComponent(), l));
    }), i;
  }
  generateTableElement(e) {
    var t = document.createElement("table"), i = document.createElement("thead"), n = document.createElement("tbody"), a = this.lookupTableStyles(), o = this.table.options["rowFormatter" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], s = {};
    return s.rowFormatter = o !== null ? o : this.table.options.rowFormatter, this.table.options.dataTree && this.config.dataTree !== !1 && this.table.modExists("columnCalcs") && (s.treeElementField = this.table.modules.dataTree.elementField), s.groupHeader = this.table.options["groupHeader" + (this.colVisProp.charAt(0).toUpperCase() + this.colVisProp.slice(1))], s.groupHeader && !Array.isArray(s.groupHeader) && (s.groupHeader = [s.groupHeader]), t.classList.add("tabulator-print-table"), this.mapElementStyles(this.table.columnManager.getHeadersElement(), i, ["border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), e.length > 1e3 && console.warn("It may take a long time to render an HTML table with more than 1000 rows"), e.forEach((l, u) => {
      let c;
      switch (l.type) {
        case "header":
          i.appendChild(this.generateHeaderElement(l, s, a));
          break;
        case "group":
          n.appendChild(this.generateGroupElement(l, s, a));
          break;
        case "calc":
          n.appendChild(this.generateCalcElement(l, s, a));
          break;
        case "row":
          c = this.generateRowElement(l, s, a), this.mapElementStyles(u % 2 && a.evenRow ? a.evenRow : a.oddRow, c, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), n.appendChild(c);
          break;
      }
    }), i.innerHTML && t.appendChild(i), t.appendChild(n), this.mapElementStyles(this.table.element, t, ["border-top", "border-left", "border-right", "border-bottom"]), t;
  }
  lookupTableStyles() {
    var e = {};
    return this.cloneTableStyle && window.getComputedStyle && (e.oddRow = this.table.element.querySelector(".tabulator-row-odd:not(.tabulator-group):not(.tabulator-calcs)"), e.evenRow = this.table.element.querySelector(".tabulator-row-even:not(.tabulator-group):not(.tabulator-calcs)"), e.calcRow = this.table.element.querySelector(".tabulator-row.tabulator-calcs"), e.firstRow = this.table.element.querySelector(".tabulator-row:not(.tabulator-group):not(.tabulator-calcs)"), e.firstGroup = this.table.element.getElementsByClassName("tabulator-group")[0], e.firstRow && (e.styleCells = e.firstRow.getElementsByClassName("tabulator-cell"), e.firstCell = e.styleCells[0], e.lastCell = e.styleCells[e.styleCells.length - 1])), e;
  }
  generateHeaderElement(e, t, i) {
    var n = document.createElement("tr");
    return e.columns.forEach((a) => {
      if (a) {
        var o = document.createElement("th"), s = a.component._column.definition.cssClass ? a.component._column.definition.cssClass.split(" ") : [];
        o.colSpan = a.width, o.rowSpan = a.height, o.innerHTML = a.value, this.cloneTableStyle && (o.style.boxSizing = "border-box"), s.forEach(function(l) {
          o.classList.add(l);
        }), this.mapElementStyles(a.component.getElement(), o, ["text-align", "border-top", "border-left", "border-right", "border-bottom", "background-color", "color", "font-weight", "font-family", "font-size"]), this.mapElementStyles(a.component._column.contentElement, o, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), a.component._column.visible ? this.mapElementStyles(a.component.getElement(), o, ["width"]) : a.component._column.definition.width && (o.style.width = a.component._column.definition.width + "px"), a.component._column.parent && this.mapElementStyles(a.component._column.parent.groupElement, o, ["border-top"]), n.appendChild(o);
      }
    }), n;
  }
  generateGroupElement(e, t, i) {
    var n = document.createElement("tr"), a = document.createElement("td"), o = e.columns[0];
    return n.classList.add("tabulator-print-table-row"), t.groupHeader && t.groupHeader[e.indent] ? o.value = t.groupHeader[e.indent](o.value, e.component._group.getRowCount(), e.component._group.getData(), e.component) : t.groupHeader !== !1 && (o.value = e.component._group.generator(o.value, e.component._group.getRowCount(), e.component._group.getData(), e.component)), a.colSpan = o.width, a.innerHTML = o.value, n.classList.add("tabulator-print-table-group"), n.classList.add("tabulator-group-level-" + e.indent), o.component.isVisible() && n.classList.add("tabulator-group-visible"), this.mapElementStyles(i.firstGroup, n, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), this.mapElementStyles(i.firstGroup, a, ["padding-top", "padding-left", "padding-right", "padding-bottom"]), n.appendChild(a), n;
  }
  generateCalcElement(e, t, i) {
    var n = this.generateRowElement(e, t, i);
    return n.classList.add("tabulator-print-table-calcs"), this.mapElementStyles(i.calcRow, n, ["border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "background-color"]), n;
  }
  generateRowElement(e, t, i) {
    var n = document.createElement("tr");
    if (n.classList.add("tabulator-print-table-row"), e.columns.forEach((a, o) => {
      if (a) {
        var s = document.createElement("td"), l = a.component._column, u = this.table.columnManager.findColumnIndex(l), c = a.value, h, f = {
          modules: {},
          getValue: function() {
            return c;
          },
          getField: function() {
            return l.definition.field;
          },
          getElement: function() {
            return s;
          },
          getType: function() {
            return "cell";
          },
          getColumn: function() {
            return l.getComponent();
          },
          getData: function() {
            return e.component.getData();
          },
          getRow: function() {
            return e.component;
          },
          getComponent: function() {
            return f;
          },
          column: l
        }, d = l.definition.cssClass ? l.definition.cssClass.split(" ") : [];
        if (d.forEach(function(p) {
          s.classList.add(p);
        }), this.table.modExists("format") && this.config.formatCells !== !1)
          c = this.table.modules.format.formatExportValue(f, this.colVisProp);
        else
          switch (typeof c) {
            case "object":
              c = c !== null ? JSON.stringify(c) : "";
              break;
            case "undefined":
              c = "";
              break;
          }
        c instanceof Node ? s.appendChild(c) : s.innerHTML = c, h = i.styleCells && i.styleCells[u] ? i.styleCells[u] : i.firstCell, h && (this.mapElementStyles(h, s, ["padding-top", "padding-left", "padding-right", "padding-bottom", "border-top", "border-left", "border-right", "border-bottom", "color", "font-weight", "font-family", "font-size", "text-align"]), l.definition.align && (s.style.textAlign = l.definition.align)), this.table.options.dataTree && this.config.dataTree !== !1 && (t.treeElementField && t.treeElementField == l.field || !t.treeElementField && o == 0) && (e.component._row.modules.dataTree.controlEl && s.insertBefore(e.component._row.modules.dataTree.controlEl.cloneNode(!0), s.firstChild), e.component._row.modules.dataTree.branchEl && s.insertBefore(e.component._row.modules.dataTree.branchEl.cloneNode(!0), s.firstChild)), n.appendChild(s), f.modules.format && f.modules.format.renderedCallback && f.modules.format.renderedCallback();
      }
    }), t.rowFormatter && e.type === "row" && this.config.formatCells !== !1) {
      let a = Object.assign(e.component);
      a.getElement = function() {
        return n;
      }, t.rowFormatter(e.component);
    }
    return n;
  }
  generateHTMLTable(e) {
    var t = document.createElement("div");
    return t.appendChild(this.generateTableElement(e)), t.innerHTML;
  }
  getHtml(e, t, i, n) {
    var a = this.generateExportList(i || this.table.options.htmlOutputConfig, t, e, n || "htmlOutput");
    return this.generateHTMLTable(a);
  }
  mapElementStyles(e, t, i) {
    if (this.cloneTableStyle && e && t) {
      var n = {
        "background-color": "backgroundColor",
        color: "fontColor",
        width: "width",
        "font-weight": "fontWeight",
        "font-family": "fontFamily",
        "font-size": "fontSize",
        "text-align": "textAlign",
        "border-top": "borderTop",
        "border-left": "borderLeft",
        "border-right": "borderRight",
        "border-bottom": "borderBottom",
        "padding-top": "paddingTop",
        "padding-left": "paddingLeft",
        "padding-right": "paddingRight",
        "padding-bottom": "paddingBottom"
      };
      if (window.getComputedStyle) {
        var a = window.getComputedStyle(e);
        i.forEach(function(o) {
          t.style[n[o]] || (t.style[n[o]] = a.getPropertyValue(o));
        });
      }
    }
  }
}
DP.moduleName = "export";
var lGe = {
  //equal to
  "=": function(r, e, t, i) {
    return e == r;
  },
  //less than
  "<": function(r, e, t, i) {
    return e < r;
  },
  //less than or equal to
  "<=": function(r, e, t, i) {
    return e <= r;
  },
  //greater than
  ">": function(r, e, t, i) {
    return e > r;
  },
  //greater than or equal to
  ">=": function(r, e, t, i) {
    return e >= r;
  },
  //not equal to
  "!=": function(r, e, t, i) {
    return e != r;
  },
  regex: function(r, e, t, i) {
    return typeof r == "string" && (r = new RegExp(r)), r.test(e);
  },
  //contains the string
  like: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().indexOf(r.toLowerCase()) > -1 : !1;
  },
  //contains the keywords
  keywords: function(r, e, t, i) {
    var n = r.toLowerCase().split(typeof i.separator > "u" ? " " : i.separator), a = String(e === null || typeof e > "u" ? "" : e).toLowerCase(), o = [];
    return n.forEach((s) => {
      a.includes(s) && o.push(!0);
    }), i.matchAll ? o.length === n.length : !!o.length;
  },
  //starts with the string
  starts: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().startsWith(r.toLowerCase()) : !1;
  },
  //ends with the string
  ends: function(r, e, t, i) {
    return r === null || typeof r > "u" ? e === r : typeof e < "u" && e !== null ? String(e).toLowerCase().endsWith(r.toLowerCase()) : !1;
  },
  //in array
  in: function(r, e, t, i) {
    return Array.isArray(r) ? r.length ? r.indexOf(e) > -1 : !0 : (console.warn("Filter Error - filter value is not an array:", r), !1);
  }
};
class ao extends mt {
  constructor(e) {
    super(e), this.filterList = [], this.headerFilters = {}, this.headerFilterColumns = [], this.prevHeaderFilterChangeCheck = "", this.prevHeaderFilterChangeCheck = "{}", this.changed = !1, this.tableInitialized = !1, this.registerTableOption("filterMode", "local"), this.registerTableOption("initialFilter", !1), this.registerTableOption("initialHeaderFilter", !1), this.registerTableOption("headerFilterLiveFilterDelay", 300), this.registerTableOption("placeholderHeaderFilter", !1), this.registerColumnOption("headerFilter"), this.registerColumnOption("headerFilterPlaceholder"), this.registerColumnOption("headerFilterParams"), this.registerColumnOption("headerFilterEmptyCheck"), this.registerColumnOption("headerFilterFunc"), this.registerColumnOption("headerFilterFuncParams"), this.registerColumnOption("headerFilterLiveFilter"), this.registerTableFunction("searchRows", this.searchRows.bind(this)), this.registerTableFunction("searchData", this.searchData.bind(this)), this.registerTableFunction("setFilter", this.userSetFilter.bind(this)), this.registerTableFunction("refreshFilter", this.userRefreshFilter.bind(this)), this.registerTableFunction("addFilter", this.userAddFilter.bind(this)), this.registerTableFunction("getFilters", this.getFilters.bind(this)), this.registerTableFunction("setHeaderFilterFocus", this.userSetHeaderFilterFocus.bind(this)), this.registerTableFunction("getHeaderFilterValue", this.userGetHeaderFilterValue.bind(this)), this.registerTableFunction("setHeaderFilterValue", this.userSetHeaderFilterValue.bind(this)), this.registerTableFunction("getHeaderFilters", this.getHeaderFilters.bind(this)), this.registerTableFunction("removeFilter", this.userRemoveFilter.bind(this)), this.registerTableFunction("clearFilter", this.userClearFilter.bind(this)), this.registerTableFunction("clearHeaderFilter", this.userClearHeaderFilter.bind(this)), this.registerComponentFunction("column", "headerFilterFocus", this.setHeaderFilterFocus.bind(this)), this.registerComponentFunction("column", "reloadHeaderFilter", this.reloadHeaderFilter.bind(this)), this.registerComponentFunction("column", "getHeaderFilterValue", this.getHeaderFilterValue.bind(this)), this.registerComponentFunction("column", "setHeaderFilterValue", this.setHeaderFilterValue.bind(this));
  }
  initialize() {
    this.subscribe("column-init", this.initializeColumnHeaderFilter.bind(this)), this.subscribe("column-width-fit-before", this.hideHeaderFilterElements.bind(this)), this.subscribe("column-width-fit-after", this.showHeaderFilterElements.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.subscribe("placeholder", this.generatePlaceholder.bind(this)), this.table.options.filterMode === "remote" && this.subscribe("data-params", this.remoteFilterParams.bind(this)), this.registerDataHandler(this.filter.bind(this), 10);
  }
  tableBuilt() {
    this.table.options.initialFilter && this.setFilter(this.table.options.initialFilter), this.table.options.initialHeaderFilter && this.table.options.initialHeaderFilter.forEach((e) => {
      var t = this.table.columnManager.findColumn(e.field);
      if (t)
        this.setHeaderFilterValue(t, e.value);
      else
        return console.warn("Column Filter Error - No matching column found:", e.field), !1;
    }), this.tableInitialized = !0;
  }
  remoteFilterParams(e, t, i, n) {
    return n.filter = this.getFilters(!0, !0), n;
  }
  generatePlaceholder(e) {
    if (this.table.options.placeholderHeaderFilter && Object.keys(this.headerFilters).length)
      return this.table.options.placeholderHeaderFilter;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  //set standard filters
  userSetFilter(e, t, i, n) {
    this.setFilter(e, t, i, n), this.refreshFilter();
  }
  //set standard filters
  userRefreshFilter() {
    this.refreshFilter();
  }
  //add filter to array
  userAddFilter(e, t, i, n) {
    this.addFilter(e, t, i, n), this.refreshFilter();
  }
  userSetHeaderFilterFocus(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      this.setHeaderFilterFocus(t);
    else
      return console.warn("Column Filter Focus Error - No matching column found:", e), !1;
  }
  userGetHeaderFilterValue(e) {
    var t = this.table.columnManager.findColumn(e);
    if (t)
      return this.getHeaderFilterValue(t);
    console.warn("Column Filter Error - No matching column found:", e);
  }
  userSetHeaderFilterValue(e, t) {
    var i = this.table.columnManager.findColumn(e);
    if (i)
      this.setHeaderFilterValue(i, t);
    else
      return console.warn("Column Filter Error - No matching column found:", e), !1;
  }
  //remove filter from array
  userRemoveFilter(e, t, i) {
    this.removeFilter(e, t, i), this.refreshFilter();
  }
  //clear filters
  userClearFilter(e) {
    this.clearFilter(e), this.refreshFilter();
  }
  //clear header filters
  userClearHeaderFilter() {
    this.clearHeaderFilter(), this.refreshFilter();
  }
  //search for specific row components
  searchRows(e, t, i) {
    return this.search("rows", e, t, i);
  }
  //search for specific data
  searchData(e, t, i) {
    return this.search("data", e, t, i);
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnHeaderFilter(e) {
    var t = e.definition;
    t.headerFilter && this.initializeColumn(e);
  }
  //initialize column header filter
  initializeColumn(e, t) {
    var i = this, n = e.getField();
    function a(o) {
      var s = e.modules.filter.tagType == "input" && e.modules.filter.attrType == "text" || e.modules.filter.tagType == "textarea" ? "partial" : "match", l = "", u = "", c;
      if (typeof e.modules.filter.prevSuccess > "u" || e.modules.filter.prevSuccess !== o) {
        if (e.modules.filter.prevSuccess = o, e.modules.filter.emptyFunc(o))
          delete i.headerFilters[n];
        else {
          switch (e.modules.filter.value = o, typeof e.definition.headerFilterFunc) {
            case "string":
              ao.filters[e.definition.headerFilterFunc] ? (l = e.definition.headerFilterFunc, c = function(h) {
                var f = e.definition.headerFilterFuncParams || {}, d = e.getFieldValue(h);
                return f = typeof f == "function" ? f(o, d, h) : f, ao.filters[e.definition.headerFilterFunc](o, d, h, f);
              }) : console.warn("Header Filter Error - Matching filter function not found: ", e.definition.headerFilterFunc);
              break;
            case "function":
              c = function(h) {
                var f = e.definition.headerFilterFuncParams || {}, d = e.getFieldValue(h);
                return f = typeof f == "function" ? f(o, d, h) : f, e.definition.headerFilterFunc(o, d, h, f);
              }, l = c;
              break;
          }
          if (!c)
            switch (s) {
              case "partial":
                c = function(h) {
                  var f = e.getFieldValue(h);
                  return typeof f < "u" && f !== null ? String(f).toLowerCase().indexOf(String(o).toLowerCase()) > -1 : !1;
                }, l = "like";
                break;
              default:
                c = function(h) {
                  return e.getFieldValue(h) == o;
                }, l = "=";
            }
          i.headerFilters[n] = { value: o, func: c, type: l };
        }
        e.modules.filter.value = o, u = JSON.stringify(i.headerFilters), i.prevHeaderFilterChangeCheck !== u && (i.prevHeaderFilterChangeCheck = u, i.trackChanges(), i.refreshFilter());
      }
      return !0;
    }
    e.modules.filter = {
      success: a,
      attrType: !1,
      tagType: !1,
      emptyFunc: !1
    }, this.generateHeaderFilterElement(e);
  }
  generateHeaderFilterElement(e, t, i) {
    var n = this, a = e.modules.filter.success, o = e.getField(), s, l, u, c, h, f, d, p;
    e.modules.filter.value = t;
    function g() {
    }
    function v(O) {
      p = O;
    }
    if (e.modules.filter.headerElement && e.modules.filter.headerElement.parentNode && e.contentElement.removeChild(e.modules.filter.headerElement.parentNode), o) {
      switch (e.modules.filter.emptyFunc = e.definition.headerFilterEmptyCheck || function(O) {
        return !O && O !== 0;
      }, s = document.createElement("div"), s.classList.add("tabulator-header-filter"), typeof e.definition.headerFilter) {
        case "string":
          n.table.modules.edit.editors[e.definition.headerFilter] ? (l = n.table.modules.edit.editors[e.definition.headerFilter], (e.definition.headerFilter === "tick" || e.definition.headerFilter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(O) {
            return O !== !0 && O !== !1;
          })) : console.warn("Filter Error - Cannot build header filter, No such editor found: ", e.definition.editor);
          break;
        case "function":
          l = e.definition.headerFilter;
          break;
        case "boolean":
          e.modules.edit && e.modules.edit.editor ? l = e.modules.edit.editor : e.definition.formatter && n.table.modules.edit.editors[e.definition.formatter] ? (l = n.table.modules.edit.editors[e.definition.formatter], (e.definition.formatter === "tick" || e.definition.formatter === "tickCross") && !e.definition.headerFilterEmptyCheck && (e.modules.filter.emptyFunc = function(O) {
            return O !== !0 && O !== !1;
          })) : l = n.table.modules.edit.editors.input;
          break;
      }
      if (l) {
        if (c = {
          getValue: function() {
            return typeof t < "u" ? t : "";
          },
          getField: function() {
            return e.definition.field;
          },
          getElement: function() {
            return s;
          },
          getColumn: function() {
            return e.getComponent();
          },
          getTable: () => this.table,
          getType: () => "header",
          getRow: function() {
            return {
              normalizeHeight: function() {
              }
            };
          }
        }, d = e.definition.headerFilterParams || {}, d = typeof d == "function" ? d.call(n.table, c) : d, u = l.call(this.table.modules.edit, c, v, a, g, d), !u) {
          console.warn("Filter Error - Cannot add filter to " + o + " column, editor returned a value of false");
          return;
        }
        if (!(u instanceof Node)) {
          console.warn("Filter Error - Cannot add filter to " + o + " column, editor should return an instance of Node, the editor returned:", u);
          return;
        }
        n.langBind("headerFilters|columns|" + e.definition.field, function(O) {
          u.setAttribute("placeholder", typeof O < "u" && O ? O : e.definition.headerFilterPlaceholder || n.langText("headerFilters|default"));
        }), u.addEventListener("click", function(O) {
          O.stopPropagation(), u.focus();
        }), u.addEventListener("focus", (O) => {
          var m = this.table.columnManager.contentsElement.scrollLeft, E = this.table.rowManager.element.scrollLeft;
          m !== E && (this.table.rowManager.scrollHorizontal(m), this.table.columnManager.scrollHorizontal(m));
        }), h = !1, f = function(O) {
          h && clearTimeout(h), h = setTimeout(function() {
            a(u.value);
          }, n.table.options.headerFilterLiveFilterDelay);
        }, e.modules.filter.headerElement = u, e.modules.filter.attrType = u.hasAttribute("type") ? u.getAttribute("type").toLowerCase() : "", e.modules.filter.tagType = u.tagName.toLowerCase(), e.definition.headerFilterLiveFilter !== !1 && (e.definition.headerFilter === "autocomplete" || e.definition.headerFilter === "tickCross" || (e.definition.editor === "autocomplete" || e.definition.editor === "tickCross") && e.definition.headerFilter === !0 || (u.addEventListener("keyup", f), u.addEventListener("search", f), e.modules.filter.attrType == "number" && u.addEventListener("change", function(O) {
          a(u.value);
        }), e.modules.filter.attrType == "text" && this.table.browser !== "ie" && u.setAttribute("type", "search")), (e.modules.filter.tagType == "input" || e.modules.filter.tagType == "select" || e.modules.filter.tagType == "textarea") && u.addEventListener("mousedown", function(O) {
          O.stopPropagation();
        })), s.appendChild(u), e.contentElement.appendChild(s), i || n.headerFilterColumns.push(e), p && p();
      }
    } else
      console.warn("Filter Error - Cannot add header filter, column has no field set:", e.definition.title);
  }
  //hide all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  hideHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "none");
    });
  }
  //show all header filter elements (used to ensure correct column widths in "fitData" layout mode)
  showHeaderFilterElements() {
    this.headerFilterColumns.forEach(function(e) {
      e.modules.filter && e.modules.filter.headerElement && (e.modules.filter.headerElement.style.display = "");
    });
  }
  //programmatically set focus of header filter
  setHeaderFilterFocus(e) {
    e.modules.filter && e.modules.filter.headerElement ? e.modules.filter.headerElement.focus() : console.warn("Column Filter Focus Error - No header filter set on column:", e.getField());
  }
  //programmatically get value of header filter
  getHeaderFilterValue(e) {
    if (e.modules.filter && e.modules.filter.headerElement)
      return e.modules.filter.value;
    console.warn("Column Filter Error - No header filter set on column:", e.getField());
  }
  //programmatically set value of header filter
  setHeaderFilterValue(e, t) {
    e && (e.modules.filter && e.modules.filter.headerElement ? (this.generateHeaderFilterElement(e, t, !0), e.modules.filter.success(t)) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  reloadHeaderFilter(e) {
    e && (e.modules.filter && e.modules.filter.headerElement ? this.generateHeaderFilterElement(e, e.modules.filter.value, !0) : console.warn("Column Filter Error - No header filter set on column:", e.getField()));
  }
  refreshFilter() {
    this.tableInitialized && (this.table.options.filterMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0));
  }
  //check if the filters has changed since last use
  trackChanges() {
    this.changed = !0, this.dispatch("filter-changed");
  }
  //check if the filters has changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //set standard filters
  setFilter(e, t, i, n) {
    this.filterList = [], Array.isArray(e) || (e = [{ field: e, type: t, value: i, params: n }]), this.addFilter(e);
  }
  //add filter to array
  addFilter(e, t, i, n) {
    var a = !1;
    Array.isArray(e) || (e = [{ field: e, type: t, value: i, params: n }]), e.forEach((o) => {
      o = this.findFilter(o), o && (this.filterList.push(o), a = !0);
    }), a && this.trackChanges();
  }
  findFilter(e) {
    var t;
    if (Array.isArray(e))
      return this.findSubFilters(e);
    var i = !1;
    return typeof e.field == "function" ? i = function(n) {
      return e.field(n, e.type || {});
    } : ao.filters[e.type] ? (t = this.table.columnManager.getColumnByField(e.field), t ? i = function(n) {
      return ao.filters[e.type](e.value, t.getFieldValue(n), n, e.params || {});
    } : i = function(n) {
      return ao.filters[e.type](e.value, n[e.field], n, e.params || {});
    }) : console.warn("Filter Error - No such filter type found, ignoring: ", e.type), e.func = i, e.func ? e : !1;
  }
  findSubFilters(e) {
    var t = [];
    return e.forEach((i) => {
      i = this.findFilter(i), i && t.push(i);
    }), t.length ? t : !1;
  }
  //get all filters
  getFilters(e, t) {
    var i = [];
    return e && (i = this.getHeaderFilters()), t && i.forEach(function(n) {
      typeof n.type == "function" && (n.type = "function");
    }), i = i.concat(this.filtersToArray(this.filterList, t)), i;
  }
  //filter to Object
  filtersToArray(e, t) {
    var i = [];
    return e.forEach((n) => {
      var a;
      Array.isArray(n) ? i.push(this.filtersToArray(n, t)) : (a = { field: n.field, type: n.type, value: n.value }, t && typeof a.type == "function" && (a.type = "function"), i.push(a));
    }), i;
  }
  //get all filters
  getHeaderFilters() {
    var e = [];
    for (var t in this.headerFilters)
      e.push({ field: t, type: this.headerFilters[t].type, value: this.headerFilters[t].value });
    return e;
  }
  //remove filter from array
  removeFilter(e, t, i) {
    Array.isArray(e) || (e = [{ field: e, type: t, value: i }]), e.forEach((n) => {
      var a = -1;
      typeof n.field == "object" ? a = this.filterList.findIndex((o) => n === o) : a = this.filterList.findIndex((o) => n.field === o.field && n.type === o.type && n.value === o.value), a > -1 ? this.filterList.splice(a, 1) : console.warn("Filter Error - No matching filter type found, ignoring: ", n.type);
    }), this.trackChanges();
  }
  //clear filters
  clearFilter(e) {
    this.filterList = [], e && this.clearHeaderFilter(), this.trackChanges();
  }
  //clear header filters
  clearHeaderFilter() {
    this.headerFilters = {}, this.prevHeaderFilterChangeCheck = "{}", this.headerFilterColumns.forEach((e) => {
      typeof e.modules.filter.value < "u" && delete e.modules.filter.value, e.modules.filter.prevSuccess = void 0, this.reloadHeaderFilter(e);
    }), this.trackChanges();
  }
  //search data and return matching rows
  search(e, t, i, n) {
    var a = [], o = [];
    return Array.isArray(t) || (t = [{ field: t, type: i, value: n }]), t.forEach((s) => {
      s = this.findFilter(s), s && o.push(s);
    }), this.table.rowManager.rows.forEach((s) => {
      var l = !0;
      o.forEach((u) => {
        this.filterRecurse(u, s.getData()) || (l = !1);
      }), l && a.push(e === "data" ? s.getData("data") : s.getComponent());
    }), a;
  }
  //filter row array
  filter(e, t) {
    var i = [], n = [];
    return this.subscribedExternal("dataFiltering") && this.dispatchExternal("dataFiltering", this.getFilters(!0)), this.table.options.filterMode !== "remote" && (this.filterList.length || Object.keys(this.headerFilters).length) ? e.forEach((a) => {
      this.filterRow(a) && i.push(a);
    }) : i = e.slice(0), this.subscribedExternal("dataFiltered") && (i.forEach((a) => {
      n.push(a.getComponent());
    }), this.dispatchExternal("dataFiltered", this.getFilters(!0), n)), i;
  }
  //filter individual row
  filterRow(e, t) {
    var i = !0, n = e.getData();
    this.filterList.forEach((o) => {
      this.filterRecurse(o, n) || (i = !1);
    });
    for (var a in this.headerFilters)
      this.headerFilters[a].func(n) || (i = !1);
    return i;
  }
  filterRecurse(e, t) {
    var i = !1;
    return Array.isArray(e) ? e.forEach((n) => {
      this.filterRecurse(n, t) && (i = !0);
    }) : i = e.func(t), i;
  }
}
ao.moduleName = "filter";
ao.filters = lGe;
function uGe(r, e, t) {
  return this.emptyToSpace(this.sanitizeHTML(r.getValue()));
}
function cGe(r, e, t) {
  return r.getValue();
}
function hGe(r, e, t) {
  return r.getElement().style.whiteSpace = "pre-wrap", this.emptyToSpace(this.sanitizeHTML(r.getValue()));
}
function fGe(r, e, t) {
  var i = parseFloat(r.getValue()), n = "", a, o, s, l, u, c = e.decimal || ".", h = e.thousand || ",", f = e.negativeSign || "-", d = e.symbol || "", p = !!e.symbolAfter, g = typeof e.precision < "u" ? e.precision : 2;
  if (isNaN(i))
    return this.emptyToSpace(this.sanitizeHTML(r.getValue()));
  if (i < 0 && (i = Math.abs(i), n = f), a = g !== !1 ? i.toFixed(g) : i, a = String(a).split("."), o = a[0], s = a.length > 1 ? c + a[1] : "", e.thousand !== !1)
    for (l = /(\d+)(\d{3})/; l.test(o); )
      o = o.replace(l, "$1" + h + "$2");
  return u = o + s, n === !0 ? (u = "(" + u + ")", p ? u + d : d + u) : p ? n + u + d : n + d + u;
}
function dGe(r, e, t) {
  var i = r.getValue(), n = e.urlPrefix || "", a = e.download, o = i, s = document.createElement("a"), l;
  function u(c, h) {
    var f = c.shift(), d = h[f];
    return c.length && typeof d == "object" ? u(c, d) : d;
  }
  if (e.labelField && (l = r.getData(), o = u(e.labelField.split(this.table.options.nestedFieldSeparator), l)), e.label)
    switch (typeof e.label) {
      case "string":
        o = e.label;
        break;
      case "function":
        o = e.label(r);
        break;
    }
  if (o) {
    if (e.urlField && (l = r.getData(), i = l[e.urlField]), e.url)
      switch (typeof e.url) {
        case "string":
          i = e.url;
          break;
        case "function":
          i = e.url(r);
          break;
      }
    return s.setAttribute("href", n + i), e.target && s.setAttribute("target", e.target), e.download && (typeof a == "function" ? a = a(r) : a = a === !0 ? "" : a, s.setAttribute("download", a)), s.innerHTML = this.emptyToSpace(this.sanitizeHTML(o)), s;
  } else
    return "&nbsp;";
}
function pGe(r, e, t) {
  var i = document.createElement("img"), n = r.getValue();
  switch (e.urlPrefix && (n = e.urlPrefix + r.getValue()), e.urlSuffix && (n = n + e.urlSuffix), i.setAttribute("src", n), typeof e.height) {
    case "number":
      i.style.height = e.height + "px";
      break;
    case "string":
      i.style.height = e.height;
      break;
  }
  switch (typeof e.width) {
    case "number":
      i.style.width = e.width + "px";
      break;
    case "string":
      i.style.width = e.width;
      break;
  }
  return i.addEventListener("load", function() {
    r.getRow().normalizeHeight();
  }), i;
}
function gGe(r, e, t) {
  var i = r.getValue(), n = r.getElement(), a = e.allowEmpty, o = e.allowTruthy, s = Object.keys(e).includes("trueValue"), l = typeof e.tickElement < "u" ? e.tickElement : '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>', u = typeof e.crossElement < "u" ? e.crossElement : '<svg enable-background="new 0 0 24 24" height="14" width="14"  viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
  return s && i === e.trueValue || !s && (o && i || i === !0 || i === "true" || i === "True" || i === 1 || i === "1") ? (n.setAttribute("aria-checked", !0), l || "") : a && (i === "null" || i === "" || i === null || typeof i > "u") ? (n.setAttribute("aria-checked", "mixed"), "") : (n.setAttribute("aria-checked", !1), u || "");
}
function vGe(r, e, t) {
  var i = window.DateTime || luxon.DateTime, n = e.inputFormat || "yyyy-MM-dd HH:mm:ss", a = e.outputFormat || "dd/MM/yyyy HH:mm:ss", o = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", s = r.getValue();
  if (typeof i < "u") {
    var l;
    return i.isDateTime(s) ? l = s : n === "iso" ? l = i.fromISO(String(s)) : l = i.fromFormat(String(s), n), l.isValid ? (e.timezone && (l = l.setZone(e.timezone)), l.toFormat(a)) : o === !0 || !s ? s : typeof o == "function" ? o(s) : o;
  } else
    console.error("Format Error - 'datetime' formatter is dependant on luxon.js");
}
function OGe(r, e, t) {
  var i = window.DateTime || luxon.DateTime, n = e.inputFormat || "yyyy-MM-dd HH:mm:ss", a = typeof e.invalidPlaceholder < "u" ? e.invalidPlaceholder : "", o = typeof e.suffix < "u" ? e.suffix : !1, s = typeof e.unit < "u" ? e.unit : "days", l = typeof e.humanize < "u" ? e.humanize : !1, u = typeof e.date < "u" ? e.date : i.now(), c = r.getValue();
  if (typeof i < "u") {
    var h;
    return i.isDateTime(c) ? h = c : n === "iso" ? h = i.fromISO(String(c)) : h = i.fromFormat(String(c), n), h.isValid ? l ? h.diff(u, s).toHuman() + (o ? " " + o : "") : parseInt(h.diff(u, s)[s]) + (o ? " " + o : "") : a === !0 ? c : typeof a == "function" ? a(c) : a;
  } else
    console.error("Format Error - 'datetimediff' formatter is dependant on luxon.js");
}
function mGe(r, e, t) {
  var i = r.getValue();
  return typeof e[i] > "u" ? (console.warn("Missing display value for " + i), i) : e[i];
}
function EGe(r, e, t) {
  var i = r.getValue(), n = r.getElement(), a = e && e.stars ? e.stars : 5, o = document.createElement("span"), s = document.createElementNS("http://www.w3.org/2000/svg", "svg"), l = '<polygon fill="#FFEA00" stroke="#C1AB60" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>', u = '<polygon fill="#D2D2D2" stroke="#686868" stroke-width="37.6152" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" points="259.216,29.942 330.27,173.919 489.16,197.007 374.185,309.08 401.33,467.31 259.216,392.612 117.104,467.31 144.25,309.08 29.274,197.007 188.165,173.919 "/>';
  o.style.verticalAlign = "middle", s.setAttribute("width", "14"), s.setAttribute("height", "14"), s.setAttribute("viewBox", "0 0 512 512"), s.setAttribute("xml:space", "preserve"), s.style.padding = "0 1px", i = i && !isNaN(i) ? parseInt(i) : 0, i = Math.max(0, Math.min(i, a));
  for (var c = 1; c <= a; c++) {
    var h = s.cloneNode(!0);
    h.innerHTML = c <= i ? l : u, o.appendChild(h);
  }
  return n.style.whiteSpace = "nowrap", n.style.overflow = "hidden", n.style.textOverflow = "ellipsis", n.setAttribute("aria-label", i), o;
}
function bGe(r, e, t) {
  var i = this.sanitizeHTML(r.getValue()) || 0, n = document.createElement("span"), a = e && e.max ? e.max : 100, o = e && e.min ? e.min : 0, s = e && typeof e.color < "u" ? e.color : ["red", "orange", "green"], l = "#666666", u, c;
  if (!(isNaN(i) || typeof r.getValue() > "u")) {
    switch (n.classList.add("tabulator-traffic-light"), c = parseFloat(i) <= a ? parseFloat(i) : a, c = parseFloat(c) >= o ? parseFloat(c) : o, u = (a - o) / 100, c = Math.round((c - o) / u), typeof s) {
      case "string":
        l = s;
        break;
      case "function":
        l = s(i);
        break;
      case "object":
        if (Array.isArray(s)) {
          var h = 100 / s.length, f = Math.floor(c / h);
          f = Math.min(f, s.length - 1), f = Math.max(f, 0), l = s[f];
          break;
        }
    }
    return n.style.backgroundColor = l, n;
  }
}
function SGe(r, e = {}, t) {
  var i = this.sanitizeHTML(r.getValue()) || 0, n = r.getElement(), a = e.max ? e.max : 100, o = e.min ? e.min : 0, s = e.legendAlign ? e.legendAlign : "center", l, u, c, h, f;
  switch (u = parseFloat(i) <= a ? parseFloat(i) : a, u = parseFloat(u) >= o ? parseFloat(u) : o, l = (a - o) / 100, u = Math.round((u - o) / l), typeof e.color) {
    case "string":
      c = e.color;
      break;
    case "function":
      c = e.color(i);
      break;
    case "object":
      if (Array.isArray(e.color)) {
        let v = 100 / e.color.length, O = Math.floor(u / v);
        O = Math.min(O, e.color.length - 1), O = Math.max(O, 0), c = e.color[O];
        break;
      }
    default:
      c = "#2DC214";
  }
  switch (typeof e.legend) {
    case "string":
      h = e.legend;
      break;
    case "function":
      h = e.legend(i);
      break;
    case "boolean":
      h = i;
      break;
    default:
      h = !1;
  }
  switch (typeof e.legendColor) {
    case "string":
      f = e.legendColor;
      break;
    case "function":
      f = e.legendColor(i);
      break;
    case "object":
      if (Array.isArray(e.legendColor)) {
        let v = 100 / e.legendColor.length, O = Math.floor(u / v);
        O = Math.min(O, e.legendColor.length - 1), O = Math.max(O, 0), f = e.legendColor[O];
      }
      break;
    default:
      f = "#000";
  }
  n.style.minWidth = "30px", n.style.position = "relative", n.setAttribute("aria-label", u);
  var d = document.createElement("div");
  d.style.display = "inline-block", d.style.width = u + "%", d.style.backgroundColor = c, d.style.height = "100%", d.setAttribute("data-max", a), d.setAttribute("data-min", o);
  var p = document.createElement("div");
  if (p.style.position = "relative", p.style.width = "100%", p.style.height = "100%", h) {
    var g = document.createElement("div");
    g.style.position = "absolute", g.style.top = 0, g.style.left = 0, g.style.textAlign = s, g.style.width = "100%", g.style.color = f, g.innerHTML = h;
  }
  return t(function() {
    if (!(r instanceof Gq)) {
      var v = document.createElement("div");
      v.style.position = "absolute", v.style.top = "4px", v.style.bottom = "4px", v.style.left = "4px", v.style.right = "4px", n.appendChild(v), n = v;
    }
    n.appendChild(p), p.appendChild(d), h && p.appendChild(g);
  }), "";
}
function TGe(r, e, t) {
  return r.getElement().style.backgroundColor = this.sanitizeHTML(r.getValue()), "";
}
function yGe(r, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#2DC214" clip-rule="evenodd" d="M21.652,3.211c-0.293-0.295-0.77-0.295-1.061,0L9.41,14.34  c-0.293,0.297-0.771,0.297-1.062,0L3.449,9.351C3.304,9.203,3.114,9.13,2.923,9.129C2.73,9.128,2.534,9.201,2.387,9.351  l-2.165,1.946C0.078,11.445,0,11.63,0,11.823c0,0.194,0.078,0.397,0.223,0.544l4.94,5.184c0.292,0.296,0.771,0.776,1.062,1.07  l2.124,2.141c0.292,0.293,0.769,0.293,1.062,0l14.366-14.34c0.293-0.294,0.293-0.777,0-1.071L21.652,3.211z" fill-rule="evenodd"/></svg>';
}
function RGe(r, e, t) {
  return '<svg enable-background="new 0 0 24 24" height="14" width="14" viewBox="0 0 24 24" xml:space="preserve" ><path fill="#CE1515" d="M22.245,4.015c0.313,0.313,0.313,0.826,0,1.139l-6.276,6.27c-0.313,0.312-0.313,0.826,0,1.14l6.273,6.272  c0.313,0.313,0.313,0.826,0,1.14l-2.285,2.277c-0.314,0.312-0.828,0.312-1.142,0l-6.271-6.271c-0.313-0.313-0.828-0.313-1.141,0  l-6.276,6.267c-0.313,0.313-0.828,0.313-1.141,0l-2.282-2.28c-0.313-0.313-0.313-0.826,0-1.14l6.278-6.269  c0.313-0.312,0.313-0.826,0-1.14L1.709,5.147c-0.314-0.313-0.314-0.827,0-1.14l2.284-2.278C4.308,1.417,4.821,1.417,5.135,1.73  L11.405,8c0.314,0.314,0.828,0.314,1.141,0.001l6.276-6.267c0.312-0.312,0.826-0.312,1.141,0L22.245,4.015z"/></svg>';
}
function AGe(r, e, t) {
  var i = document.createElement("span"), n = r.getRow();
  return n.watchPosition((a) => {
    i.innerText = a;
  }), i;
}
function _Ge(r, e, t) {
  return r.getElement().classList.add("tabulator-row-handle"), "<div class='tabulator-row-handle-box'><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div><div class='tabulator-row-handle-bar'></div></div>";
}
function CGe(r, e, t) {
  var i = document.createElement("div"), n = r.getRow()._row.modules.responsiveLayout;
  i.classList.add("tabulator-responsive-collapse-toggle"), i.innerHTML = `<svg class='tabulator-responsive-collapse-toggle-open' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12" fill="none" stroke-width="3" stroke-linecap="round" />
  <line y1="7" x1="12" y2="17" x2="12" fill="none" stroke-width="3" stroke-linecap="round" />
</svg>

<svg class='tabulator-responsive-collapse-toggle-close' viewbox="0 0 24 24">
  <line x1="7" y1="12" x2="17" y2="12"  fill="none" stroke-width="3" stroke-linecap="round" />
</svg>`, r.getElement().classList.add("tabulator-row-handle");
  function a(o) {
    var s = n.element;
    n.open = o, s && (n.open ? (i.classList.add("open"), s.style.display = "") : (i.classList.remove("open"), s.style.display = "none"));
  }
  return i.addEventListener("click", function(o) {
    o.stopImmediatePropagation(), a(!n.open), r.getTable().rowManager.adjustTableSize();
  }), a(n.open), i;
}
function IGe(r, e, t) {
  var i = document.createElement("input"), n = !1;
  if (i.type = "checkbox", i.setAttribute("aria-label", "Select Row"), this.table.modExists("selectRow", !0))
    if (i.addEventListener("click", (o) => {
      o.stopPropagation();
    }), typeof r.getRow == "function") {
      var a = r.getRow();
      a instanceof Oy ? (i.addEventListener("change", (o) => {
        this.table.options.selectableRangeMode === "click" && n ? n = !1 : a.toggleSelect();
      }), this.table.options.selectableRangeMode === "click" && i.addEventListener("click", (o) => {
        n = !0, this.table.modules.selectRow.handleComplexRowClick(a._row, o);
      }), i.checked = a.isSelected && a.isSelected(), this.table.modules.selectRow.registerRowSelectCheckbox(a, i)) : i = "";
    } else
      i.addEventListener("change", (o) => {
        this.table.modules.selectRow.selectedRows.length ? this.table.deselectRow() : this.table.selectRow(e.rowRange);
      }), this.table.modules.selectRow.registerHeaderSelectCheckbox(i);
  return i;
}
var wGe = {
  plaintext: uGe,
  html: cGe,
  textarea: hGe,
  money: fGe,
  link: dGe,
  image: pGe,
  tickCross: gGe,
  datetime: vGe,
  datetimediff: OGe,
  lookup: mGe,
  star: EGe,
  traffic: bGe,
  progress: SGe,
  color: TGe,
  buttonTick: yGe,
  buttonCross: RGe,
  rownum: AGe,
  handle: _Ge,
  responsiveCollapse: CGe,
  rowSelection: IGe
};
class dn extends mt {
  constructor(e) {
    super(e), this.registerColumnOption("formatter"), this.registerColumnOption("formatterParams"), this.registerColumnOption("formatterPrint"), this.registerColumnOption("formatterPrintParams"), this.registerColumnOption("formatterClipboard"), this.registerColumnOption("formatterClipboardParams"), this.registerColumnOption("formatterHtmlOutput"), this.registerColumnOption("formatterHtmlOutputParams"), this.registerColumnOption("titleFormatter"), this.registerColumnOption("titleFormatterParams");
  }
  initialize() {
    this.subscribe("cell-format", this.formatValue.bind(this)), this.subscribe("cell-rendered", this.cellRendered.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-format", this.formatHeader.bind(this));
  }
  //initialize column formatter
  initializeColumn(e) {
    e.modules.format = this.lookupFormatter(e, ""), typeof e.definition.formatterPrint < "u" && (e.modules.format.print = this.lookupFormatter(e, "Print")), typeof e.definition.formatterClipboard < "u" && (e.modules.format.clipboard = this.lookupFormatter(e, "Clipboard")), typeof e.definition.formatterHtmlOutput < "u" && (e.modules.format.htmlOutput = this.lookupFormatter(e, "HtmlOutput"));
  }
  lookupFormatter(e, t) {
    var i = { params: e.definition["formatter" + t + "Params"] || {} }, n = e.definition["formatter" + t];
    switch (typeof n) {
      case "string":
        dn.formatters[n] ? i.formatter = dn.formatters[n] : (console.warn("Formatter Error - No such formatter found: ", n), i.formatter = dn.formatters.plaintext);
        break;
      case "function":
        i.formatter = n;
        break;
      default:
        i.formatter = dn.formatters.plaintext;
        break;
    }
    return i;
  }
  cellRendered(e) {
    e.modules.format && e.modules.format.renderedCallback && !e.modules.format.rendered && (e.modules.format.renderedCallback(), e.modules.format.rendered = !0);
  }
  //return a formatted value for a column header
  formatHeader(e, t, i) {
    var n, a, o, s;
    return e.definition.titleFormatter ? (n = this.getFormatter(e.definition.titleFormatter), o = (l) => {
      e.titleFormatterRendered = l;
    }, s = {
      getValue: function() {
        return t;
      },
      getElement: function() {
        return i;
      },
      getType: function() {
        return "header";
      },
      getColumn: function() {
        return e.getComponent();
      },
      getTable: () => this.table
    }, a = e.definition.titleFormatterParams || {}, a = typeof a == "function" ? a() : a, n.call(this, s, a, o)) : t;
  }
  //return a formatted value for a cell
  formatValue(e) {
    var t = e.getComponent(), i = typeof e.column.modules.format.params == "function" ? e.column.modules.format.params(t) : e.column.modules.format.params;
    function n(a) {
      e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = a, e.modules.format.rendered = !1;
    }
    return e.column.modules.format.formatter.call(this, t, i, n);
  }
  formatExportValue(e, t) {
    var i = e.column.modules.format[t], n;
    if (i) {
      let o = function(s) {
        e.modules.format || (e.modules.format = {}), e.modules.format.renderedCallback = s, e.modules.format.rendered = !1;
      };
      var a = o;
      return n = typeof i.params == "function" ? i.params(e.getComponent()) : i.params, i.formatter.call(this, e.getComponent(), n, o);
    } else
      return this.formatValue(e);
  }
  sanitizeHTML(e) {
    if (e) {
      var t = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      return String(e).replace(/[&<>"'`=/]/g, function(i) {
        return t[i];
      });
    } else
      return e;
  }
  emptyToSpace(e) {
    return e === null || typeof e > "u" || e === "" ? "&nbsp;" : e;
  }
  //get formatter for cell
  getFormatter(e) {
    switch (typeof e) {
      case "string":
        dn.formatters[e] ? e = dn.formatters[e] : (console.warn("Formatter Error - No such formatter found: ", e), e = dn.formatters.plaintext);
        break;
      case "function":
        break;
      default:
        e = dn.formatters.plaintext;
        break;
    }
    return e;
  }
}
dn.moduleName = "format";
dn.formatters = wGe;
class MP extends mt {
  constructor(e) {
    super(e), this.leftColumns = [], this.rightColumns = [], this.initializationMode = "left", this.active = !1, this.blocked = !0, this.registerColumnOption("frozen");
  }
  //reset initial state
  reset() {
    this.initializationMode = "left", this.leftColumns = [], this.rightColumns = [], this.active = !1;
  }
  initialize() {
    this.subscribe("cell-layout", this.layoutCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-width", this.layout.bind(this)), this.subscribe("row-layout-after", this.layoutRow.bind(this)), this.subscribe("table-layout", this.layout.bind(this)), this.subscribe("columns-loading", this.reset.bind(this)), this.subscribe("column-add", this.reinitializeColumns.bind(this)), this.subscribe("column-delete", this.reinitializeColumns.bind(this)), this.subscribe("table-redraw", this.layout.bind(this)), this.subscribe("layout-refreshing", this.blockLayout.bind(this)), this.subscribe("layout-refreshed", this.unblockLayout.bind(this)), this.subscribe("scrollbar-vertical", this.adjustForScrollbar.bind(this));
  }
  blockLayout() {
    this.blocked = !0;
  }
  unblockLayout() {
    this.blocked = !1;
  }
  layoutCell(e) {
    this.layoutElement(e.element, e.column);
  }
  reinitializeColumns() {
    this.reset(), this.table.columnManager.columnsByIndex.forEach((e) => {
      this.initializeColumn(e);
    });
  }
  //initialize specific column
  initializeColumn(e) {
    var t = { margin: 0, edge: !1 };
    e.isGroup || (this.frozenCheck(e) ? (t.position = this.initializationMode, this.initializationMode == "left" ? this.leftColumns.push(e) : this.rightColumns.unshift(e), this.active = !0, e.modules.frozen = t) : this.initializationMode = "right");
  }
  frozenCheck(e) {
    return e.parent.isGroup && e.definition.frozen && console.warn("Frozen Column Error - Parent column group must be frozen, not individual columns or sub column groups"), e.parent.isGroup ? this.frozenCheck(e.parent) : e.definition.frozen;
  }
  //layout calculation rows
  layoutCalcRows() {
    this.table.modExists("columnCalcs") && (this.table.modules.columnCalcs.topInitialized && this.table.modules.columnCalcs.topRow && this.layoutRow(this.table.modules.columnCalcs.topRow), this.table.modules.columnCalcs.botInitialized && this.table.modules.columnCalcs.botRow && this.layoutRow(this.table.modules.columnCalcs.botRow), this.table.modExists("groupRows") && this.layoutGroupCalcs(this.table.modules.groupRows.getGroups()));
  }
  layoutGroupCalcs(e) {
    e.forEach((t) => {
      t.calcs.top && this.layoutRow(t.calcs.top), t.calcs.bottom && this.layoutRow(t.calcs.bottom), t.groupList && t.groupList.length && this.layoutGroupCalcs(t.groupList);
    });
  }
  //calculate column positions and layout headers
  layoutColumnPosition(e) {
    var t = [], i = 0, n = 0;
    this.leftColumns.forEach((a, o) => {
      if (a.modules.frozen.marginValue = i, a.modules.frozen.margin = a.modules.frozen.marginValue + "px", a.visible && (i += a.getWidth()), o == this.leftColumns.length - 1 ? a.modules.frozen.edge = !0 : a.modules.frozen.edge = !1, a.parent.isGroup) {
        var s = this.getColGroupParentElement(a);
        t.includes(s) || (this.layoutElement(s, a), t.push(s)), a.modules.frozen.edge && s.classList.add("tabulator-frozen-" + a.modules.frozen.position);
      } else
        this.layoutElement(a.getElement(), a);
      e && a.cells.forEach((l) => {
        this.layoutElement(l.getElement(!0), a);
      });
    }), this.rightColumns.forEach((a, o) => {
      a.modules.frozen.marginValue = n, a.modules.frozen.margin = a.modules.frozen.marginValue + "px", a.visible && (n += a.getWidth()), o == this.rightColumns.length - 1 ? a.modules.frozen.edge = !0 : a.modules.frozen.edge = !1, a.parent.isGroup ? this.layoutElement(this.getColGroupParentElement(a), a) : this.layoutElement(a.getElement(), a), e && a.cells.forEach((s) => {
        this.layoutElement(s.getElement(!0), a);
      });
    });
  }
  getColGroupParentElement(e) {
    return e.parent.isGroup ? this.getColGroupParentElement(e.parent) : e.getElement();
  }
  //layout columns appropriately
  layout() {
    this.active && !this.blocked && (this.layoutColumnPosition(), this.reinitializeRows(), this.layoutCalcRows());
  }
  reinitializeRows() {
    var e = this.table.rowManager.getVisibleRows(!0), t = this.table.rowManager.getRows().filter((i) => !e.includes(i));
    t.forEach((i) => {
      i.deinitialize();
    }), e.forEach((i) => {
      i.type === "row" && this.layoutRow(i);
    });
  }
  layoutRow(e) {
    this.table.options.layout === "fitDataFill" && this.rightColumns.length && (this.table.rowManager.getTableElement().style.minWidth = "calc(100% - " + this.rightMargin + ")"), this.leftColumns.forEach((t) => {
      var i = e.getCell(t);
      i && this.layoutElement(i.getElement(!0), t);
    }), this.rightColumns.forEach((t) => {
      var i = e.getCell(t);
      i && this.layoutElement(i.getElement(!0), t);
    });
  }
  layoutElement(e, t) {
    var i;
    t.modules.frozen && e && (e.style.position = "sticky", this.table.rtl ? i = t.modules.frozen.position === "left" ? "right" : "left" : i = t.modules.frozen.position, e.style[i] = t.modules.frozen.margin, e.classList.add("tabulator-frozen"), t.modules.frozen.edge && e.classList.add("tabulator-frozen-" + t.modules.frozen.position));
  }
  adjustForScrollbar(e) {
    this.rightColumns.length && (this.table.columnManager.getContentsElement().style.width = "calc(100% - " + e + "px)");
  }
  _calcSpace(e, t) {
    var i = 0;
    for (let n = 0; n < t; n++)
      e[n].visible && (i += e[n].getWidth());
    return i;
  }
}
MP.moduleName = "frozenColumns";
class kP extends mt {
  constructor(e) {
    super(e), this.topElement = document.createElement("div"), this.rows = [], this.registerComponentFunction("row", "freeze", this.freezeRow.bind(this)), this.registerComponentFunction("row", "unfreeze", this.unfreezeRow.bind(this)), this.registerComponentFunction("row", "isFrozen", this.isRowFrozen.bind(this)), this.registerTableOption("frozenRowsField", "id"), this.registerTableOption("frozenRows", !1);
  }
  initialize() {
    this.rows = [], this.topElement.classList.add("tabulator-frozen-rows-holder"), this.table.columnManager.getContentsElement().insertBefore(this.topElement, this.table.columnManager.headersElement.nextSibling), this.subscribe("row-deleting", this.detachRow.bind(this)), this.subscribe("rows-visible", this.visibleRows.bind(this)), this.registerDisplayHandler(this.getRows.bind(this), 10), this.table.options.frozenRows && (this.subscribe("data-processed", this.initializeRows.bind(this)), this.subscribe("row-added", this.initializeRow.bind(this)), this.subscribe("table-redrawing", this.resizeHolderWidth.bind(this)), this.subscribe("column-resized", this.resizeHolderWidth.bind(this)), this.subscribe("column-show", this.resizeHolderWidth.bind(this)), this.subscribe("column-hide", this.resizeHolderWidth.bind(this))), this.resizeHolderWidth();
  }
  resizeHolderWidth() {
    this.topElement.style.minWidth = this.table.columnManager.headersElement.offsetWidth + "px";
  }
  initializeRows() {
    this.table.rowManager.getRows().forEach((e) => {
      this.initializeRow(e);
    });
  }
  initializeRow(e) {
    var t = this.table.options.frozenRows, i = typeof t;
    i === "number" ? e.getPosition() && e.getPosition() + this.rows.length <= t && this.freezeRow(e) : i === "function" ? t.call(this.table, e.getComponent()) && this.freezeRow(e) : Array.isArray(t) && t.includes(e.data[this.options("frozenRowsField")]) && this.freezeRow(e);
  }
  isRowFrozen(e) {
    var t = this.rows.indexOf(e);
    return t > -1;
  }
  isFrozen() {
    return !!this.rows.length;
  }
  visibleRows(e, t) {
    return this.rows.forEach((i) => {
      t.push(i);
    }), t;
  }
  //filter frozen rows out of display data
  getRows(e) {
    var t = e.slice(0);
    return this.rows.forEach(function(i) {
      var n = t.indexOf(i);
      n > -1 && t.splice(n, 1);
    }), t;
  }
  freezeRow(e) {
    e.modules.frozen ? console.warn("Freeze Error - Row is already frozen") : (e.modules.frozen = !0, this.topElement.appendChild(e.getElement()), e.initialize(), e.normalizeHeight(), this.rows.push(e), this.refreshData(!1, "display"), this.table.rowManager.adjustTableSize(), this.styleRows());
  }
  unfreezeRow(e) {
    e.modules.frozen ? (e.modules.frozen = !1, this.detachRow(e), this.table.rowManager.adjustTableSize(), this.refreshData(!1, "display"), this.rows.length && this.styleRows()) : console.warn("Freeze Error - Row is already unfrozen");
  }
  detachRow(e) {
    var t = this.rows.indexOf(e);
    if (t > -1) {
      var i = e.getElement();
      i.parentNode && i.parentNode.removeChild(i), this.rows.splice(t, 1);
    }
  }
  styleRows(e) {
    this.rows.forEach((t, i) => {
      this.table.rowManager.styleRow(t, i);
    });
  }
}
kP.moduleName = "frozenRows";
class NGe {
  constructor(e) {
    return this._group = e, this.type = "GroupComponent", new Proxy(this, {
      get: function(t, i, n) {
        return typeof t[i] < "u" ? t[i] : t._group.groupManager.table.componentFunctionBinder.handle("group", t._group, i);
      }
    });
  }
  getKey() {
    return this._group.key;
  }
  getField() {
    return this._group.field;
  }
  getElement() {
    return this._group.element;
  }
  getRows() {
    return this._group.getRows(!0);
  }
  getSubGroups() {
    return this._group.getSubGroups(!0);
  }
  getParentGroup() {
    return this._group.parent ? this._group.parent.getComponent() : !1;
  }
  isVisible() {
    return this._group.visible;
  }
  show() {
    this._group.show();
  }
  hide() {
    this._group.hide();
  }
  toggle() {
    this._group.toggleVisibility();
  }
  scrollTo(e, t) {
    return this._group.groupManager.table.rowManager.scrollToRow(this._group, e, t);
  }
  _getSelf() {
    return this._group;
  }
  getTable() {
    return this._group.groupManager.table;
  }
}
class ef {
  constructor(e, t, i, n, a, o, s) {
    this.groupManager = e, this.parent = t, this.key = n, this.level = i, this.field = a, this.hasSubGroups = i < e.groupIDLookups.length - 1, this.addRow = this.hasSubGroups ? this._addRowToGroup : this._addRow, this.type = "group", this.old = s, this.rows = [], this.groups = [], this.groupList = [], this.generator = o, this.element = !1, this.elementContents = !1, this.height = 0, this.outerHeight = 0, this.initialized = !1, this.calcs = {}, this.initialized = !1, this.modules = {}, this.arrowElement = !1, this.visible = s ? s.visible : typeof e.startOpen[i] < "u" ? e.startOpen[i] : e.startOpen[0], this.component = null, this.createElements(), this.addBindings(), this.createValueGroups();
  }
  wipe(e) {
    e || (this.groupList.length ? this.groupList.forEach(function(t) {
      t.wipe();
    }) : this.rows.forEach((t) => {
      t.modules && delete t.modules.group;
    })), this.element = !1, this.arrowElement = !1, this.elementContents = !1;
  }
  createElements() {
    var e = document.createElement("div");
    e.classList.add("tabulator-arrow"), this.element = document.createElement("div"), this.element.classList.add("tabulator-row"), this.element.classList.add("tabulator-group"), this.element.classList.add("tabulator-group-level-" + this.level), this.element.setAttribute("role", "rowgroup"), this.arrowElement = document.createElement("div"), this.arrowElement.classList.add("tabulator-group-toggle"), this.arrowElement.appendChild(e), this.groupManager.table.options.movableRows !== !1 && this.groupManager.table.modExists("moveRow") && this.groupManager.table.modules.moveRow.initializeGroupHeader(this);
  }
  createValueGroups() {
    var e = this.level + 1;
    this.groupManager.allowedValues && this.groupManager.allowedValues[e] && this.groupManager.allowedValues[e].forEach((t) => {
      this._createGroup(t, e);
    });
  }
  addBindings() {
    var e;
    this.groupManager.table.options.groupToggleElement && (e = this.groupManager.table.options.groupToggleElement == "arrow" ? this.arrowElement : this.element, e.addEventListener("click", (t) => {
      t.stopPropagation(), t.stopImmediatePropagation(), this.toggleVisibility();
    }));
  }
  _createGroup(e, t) {
    var i = t + "_" + e, n = new ef(this.groupManager, this, t, e, this.groupManager.groupIDLookups[t].field, this.groupManager.headerGenerator[t] || this.groupManager.headerGenerator[0], this.old ? this.old.groups[i] : !1);
    this.groups[i] = n, this.groupList.push(n);
  }
  _addRowToGroup(e) {
    var t = this.level + 1;
    if (this.hasSubGroups) {
      var i = this.groupManager.groupIDLookups[t].func(e.getData()), n = t + "_" + i;
      this.groupManager.allowedValues && this.groupManager.allowedValues[t] ? this.groups[n] && this.groups[n].addRow(e) : (this.groups[n] || this._createGroup(i, t), this.groups[n].addRow(e));
    }
  }
  _addRow(e) {
    this.rows.push(e), e.modules.group = this;
  }
  insertRow(e, t, i) {
    var n = this.conformRowData({});
    e.updateData(n);
    var a = this.rows.indexOf(t);
    a > -1 ? i ? this.rows.splice(a + 1, 0, e) : this.rows.splice(a, 0, e) : i ? this.rows.push(e) : this.rows.unshift(e), e.modules.group = this, this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this), this.groupManager.updateGroupRows(!0);
  }
  scrollHeader(e) {
    this.arrowElement && (this.arrowElement.style.marginLeft = e, this.groupList.forEach(function(t) {
      t.scrollHeader(e);
    }));
  }
  getRowIndex(e) {
  }
  //update row data to match grouping constraints
  conformRowData(e) {
    return this.field ? e[this.field] = this.key : console.warn("Data Conforming Error - Cannot conform row data to match new group as groupBy is a function"), this.parent && (e = this.parent.conformRowData(e)), e;
  }
  removeRow(e) {
    var t = this.rows.indexOf(e), i = e.getElement();
    t > -1 && this.rows.splice(t, 1), !this.groupManager.table.options.groupValues && !this.rows.length ? (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this), this.groupManager.updateGroupRows(!0)) : (i.parentNode && i.parentNode.removeChild(i), this.groupManager.blockRedraw || (this.generateGroupHeaderContents(), this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modules.columnCalcs.recalcGroup(this)));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, i;
    this.groups[t] && (delete this.groups[t], i = this.groupList.indexOf(e), i > -1 && this.groupList.splice(i, 1), this.groupList.length || (this.parent ? this.parent.removeGroup(this) : this.groupManager.removeGroup(this)));
  }
  getHeadersAndRows() {
    var e = [];
    return e.push(this), this._visSet(), this.calcs.top && (this.calcs.top.detachElement(), this.calcs.top.deleteCells()), this.calcs.bottom && (this.calcs.bottom.detachElement(), this.calcs.bottom.deleteCells()), this.visible ? this.groupList.length ? this.groupList.forEach(function(t) {
      e = e.concat(t.getHeadersAndRows());
    }) : (this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasTopCalcs() && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), e = e.concat(this.rows), this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))) : !this.groupList.length && this.groupManager.table.options.columnCalcs != "table" && this.groupManager.table.modExists("columnCalcs") && (this.groupManager.table.modules.columnCalcs.hasTopCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.top = this.groupManager.table.modules.columnCalcs.generateTopRow(this.rows), e.push(this.calcs.top)), this.groupManager.table.modules.columnCalcs.hasBottomCalcs() && this.groupManager.table.options.groupClosedShowCalcs && (this.calcs.bottom = this.groupManager.table.modules.columnCalcs.generateBottomRow(this.rows), e.push(this.calcs.bottom))), e;
  }
  getData(e, t) {
    var i = [];
    return this._visSet(), (!e || e && this.visible) && this.rows.forEach((n) => {
      i.push(n.getData(t || "data"));
    }), i;
  }
  getRowCount() {
    var e = 0;
    return this.groupList.length ? this.groupList.forEach((t) => {
      e += t.getRowCount();
    }) : e = this.rows.length, e;
  }
  toggleVisibility() {
    this.visible ? this.hide() : this.show();
  }
  hide() {
    this.visible = !1, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination ? (this.element.classList.remove("tabulator-group-visible"), this.groupList.length ? this.groupList.forEach((e) => {
      var t = e.getHeadersAndRows();
      t.forEach((i) => {
        i.detachElement();
      });
    }) : this.rows.forEach((e) => {
      var t = e.getElement();
      t.parentNode.removeChild(t);
    }), this.groupManager.updateGroupRows(!0)) : this.groupManager.updateGroupRows(!0), this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !1);
  }
  show() {
    if (this.visible = !0, this.groupManager.table.rowManager.getRenderMode() == "basic" && !this.groupManager.table.options.pagination) {
      this.element.classList.add("tabulator-group-visible");
      var e = this.generateElement();
      this.groupList.length ? this.groupList.forEach((t) => {
        var i = t.getHeadersAndRows();
        i.forEach((n) => {
          var a = n.getElement();
          e.parentNode.insertBefore(a, e.nextSibling), n.initialize(), e = a;
        });
      }) : this.rows.forEach((t) => {
        var i = t.getElement();
        e.parentNode.insertBefore(i, e.nextSibling), t.initialize(), e = i;
      }), this.groupManager.updateGroupRows(!0);
    } else
      this.groupManager.updateGroupRows(!0);
    this.groupManager.table.externalEvents.dispatch("groupVisibilityChanged", this.getComponent(), !0);
  }
  _visSet() {
    var e = [];
    typeof this.visible == "function" && (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.visible = this.visible(this.key, this.getRowCount(), e, this.getComponent()));
  }
  getRowGroup(e) {
    var t = !1;
    return this.groupList.length ? this.groupList.forEach(function(i) {
      var n = i.getRowGroup(e);
      n && (t = n);
    }) : this.rows.find(function(i) {
      return i === e;
    }) && (t = this), t;
  }
  getSubGroups(e) {
    var t = [];
    return this.groupList.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  getRows(e) {
    var t = [];
    return this.rows.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  generateGroupHeaderContents() {
    var e = [];
    for (this.rows.forEach(function(t) {
      e.push(t.getData());
    }), this.elementContents = this.generator(this.key, this.getRowCount(), e, this.getComponent()); this.element.firstChild; )
      this.element.removeChild(this.element.firstChild);
    typeof this.elementContents == "string" ? this.element.innerHTML = this.elementContents : this.element.appendChild(this.elementContents), this.element.insertBefore(this.arrowElement, this.element.firstChild);
  }
  getPath(e = []) {
    return e.unshift(this.key), this.parent && this.parent.getPath(e), e;
  }
  ////////////// Standard Row Functions //////////////
  getElement() {
    return this.elementContents ? this.element : this.generateElement();
  }
  generateElement() {
    this.addBindings = !1, this._visSet(), this.visible ? this.element.classList.add("tabulator-group-visible") : this.element.classList.remove("tabulator-group-visible");
    for (var e = 0; e < this.element.childNodes.length; ++e)
      this.element.childNodes[e].parentNode.removeChild(this.element.childNodes[e]);
    return this.generateGroupHeaderContents(), this.element;
  }
  detachElement() {
    this.element && this.element.parentNode && this.element.parentNode.removeChild(this.element);
  }
  //normalize the height of elements in the row
  normalizeHeight() {
    this.setHeight(this.element.clientHeight);
  }
  initialize(e) {
    (!this.initialized || e) && (this.normalizeHeight(), this.initialized = !0);
  }
  reinitialize() {
    this.initialized = !1, this.height = 0, Zt.elVisible(this.element) && this.initialize(!0);
  }
  setHeight(e) {
    this.height != e && (this.height = e, this.outerHeight = this.element.offsetHeight);
  }
  //return rows outer height
  getHeight() {
    return this.outerHeight;
  }
  getGroup() {
    return this;
  }
  reinitializeHeight() {
  }
  calcHeight() {
  }
  setCellHeight() {
  }
  clearCellHeight() {
  }
  deinitializeHeight() {
  }
  //////////////// Object Generation /////////////////
  getComponent() {
    return this.component || (this.component = new NGe(this)), this.component;
  }
}
class QP extends mt {
  constructor(e) {
    super(e), this.groupIDLookups = !1, this.startOpen = [function() {
      return !1;
    }], this.headerGenerator = [function() {
      return "";
    }], this.groupList = [], this.allowedValues = !1, this.groups = {}, this.displayHandler = this.getRows.bind(this), this.blockRedraw = !1, this.registerTableOption("groupBy", !1), this.registerTableOption("groupStartOpen", !0), this.registerTableOption("groupValues", !1), this.registerTableOption("groupUpdateOnCellEdit", !1), this.registerTableOption("groupHeader", !1), this.registerTableOption("groupHeaderPrint", null), this.registerTableOption("groupHeaderClipboard", null), this.registerTableOption("groupHeaderHtmlOutput", null), this.registerTableOption("groupHeaderDownload", null), this.registerTableOption("groupToggleElement", "arrow"), this.registerTableOption("groupClosedShowCalcs", !1), this.registerTableFunction("setGroupBy", this.setGroupBy.bind(this)), this.registerTableFunction("setGroupValues", this.setGroupValues.bind(this)), this.registerTableFunction("setGroupStartOpen", this.setGroupStartOpen.bind(this)), this.registerTableFunction("setGroupHeader", this.setGroupHeader.bind(this)), this.registerTableFunction("getGroups", this.userGetGroups.bind(this)), this.registerTableFunction("getGroupedData", this.userGetGroupedData.bind(this)), this.registerComponentFunction("row", "getGroup", this.rowGetGroup.bind(this));
  }
  //initialize group configuration
  initialize() {
    this.subscribe("table-destroy", this._blockRedrawing.bind(this)), this.subscribe("rows-wipe", this._blockRedrawing.bind(this)), this.subscribe("rows-wiped", this._restore_redrawing.bind(this)), this.table.options.groupBy && (this.table.options.groupUpdateOnCellEdit && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("row-data-changed", this.reassignRowToGroup.bind(this), 0)), this.subscribe("table-built", this.configureGroupSetup.bind(this)), this.subscribe("row-deleting", this.rowDeleting.bind(this)), this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("scroll-horizontal", this.scrollHeaders.bind(this)), this.subscribe("rows-wipe", this.wipe.bind(this)), this.subscribe("rows-added", this.rowsUpdated.bind(this)), this.subscribe("row-moving", this.rowMoving.bind(this)), this.subscribe("row-adding-index", this.rowAddingIndex.bind(this)), this.subscribe("rows-sample", this.rowSample.bind(this)), this.subscribe("render-virtual-fill", this.virtualRenderFill.bind(this)), this.registerDisplayHandler(this.displayHandler, 20), this.initialized = !0);
  }
  _blockRedrawing() {
    this.blockRedraw = !0;
  }
  _restore_redrawing() {
    this.blockRedraw = !1;
  }
  configureGroupSetup() {
    if (this.table.options.groupBy) {
      var e = this.table.options.groupBy, t = this.table.options.groupStartOpen, i = this.table.options.groupHeader;
      if (this.allowedValues = this.table.options.groupValues, Array.isArray(e) && Array.isArray(i) && e.length > i.length && console.warn("Error creating group headers, groupHeader array is shorter than groupBy array"), this.headerGenerator = [function() {
        return "";
      }], this.startOpen = [function() {
        return !1;
      }], this.langBind("groups|item", (a, o) => {
        this.headerGenerator[0] = (s, l, u) => (typeof s > "u" ? "" : s) + "<span>(" + l + " " + (l === 1 ? a : o.groups.items) + ")</span>";
      }), this.groupIDLookups = [], e)
        this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "table" && this.table.options.columnCalcs != "both" && this.table.modules.columnCalcs.removeCalcs();
      else if (this.table.modExists("columnCalcs") && this.table.options.columnCalcs != "group") {
        var n = this.table.columnManager.getRealColumns();
        n.forEach((a) => {
          a.definition.topCalc && this.table.modules.columnCalcs.initializeTopRow(), a.definition.bottomCalc && this.table.modules.columnCalcs.initializeBottomRow();
        });
      }
      Array.isArray(e) || (e = [e]), e.forEach((a, o) => {
        var s, l;
        typeof a == "function" ? s = a : (l = this.table.columnManager.getColumnByField(a), l ? s = function(u) {
          return l.getFieldValue(u);
        } : s = function(u) {
          return u[a];
        }), this.groupIDLookups.push({
          field: typeof a == "function" ? !1 : a,
          func: s,
          values: this.allowedValues ? this.allowedValues[o] : !1
        });
      }), t && (Array.isArray(t) || (t = [t]), t.forEach((a) => {
      }), this.startOpen = t), i && (this.headerGenerator = Array.isArray(i) ? i : [i]);
    } else
      this.groupList = [], this.groups = {};
  }
  rowSample(e, t) {
    if (this.table.options.groupBy) {
      var i = this.getGroups(!1)[0];
      t.push(i.getRows(!1)[0]);
    }
    return t;
  }
  virtualRenderFill() {
    var e = this.table.rowManager.tableElement, t = this.table.rowManager.getVisibleRows();
    if (this.table.options.groupBy)
      t = t.filter((i) => i.type !== "group"), e.style.minWidth = t.length ? "" : this.table.columnManager.getWidth() + "px";
    else
      return t;
  }
  rowAddingIndex(e, t, i) {
    if (this.table.options.groupBy) {
      this.assignRowToGroup(e);
      var n = e.modules.group.rows;
      return n.length > 1 && (!t || t && n.indexOf(t) == -1 ? i ? n[0] !== e && (t = n[0], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)) : n[n.length - 1] !== e && (t = n[n.length - 1], this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)) : this.table.rowManager.moveRowInArray(e.modules.group.rows, e, t, !i)), t;
    }
  }
  trackChanges() {
    this.dispatch("group-changed");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  setGroupBy(e) {
    this.table.options.groupBy = e, this.initialized || this.initialize(), this.configureGroupSetup(), !e && this.table.modExists("columnCalcs") && this.table.options.columnCalcs === !0 && this.table.modules.columnCalcs.reinitializeCalcs(), this.refreshData(), this.trackChanges();
  }
  setGroupValues(e) {
    this.table.options.groupValues = e, this.configureGroupSetup(), this.refreshData(), this.trackChanges();
  }
  setGroupStartOpen(e) {
    this.table.options.groupStartOpen = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  setGroupHeader(e) {
    this.table.options.groupHeader = e, this.configureGroupSetup(), this.table.options.groupBy ? (this.refreshData(), this.trackChanges()) : console.warn("Grouping Update - cant refresh view, no groups have been set");
  }
  userGetGroups(e) {
    return this.getGroups(!0);
  }
  // get grouped table data in the same format as getData()
  userGetGroupedData() {
    return this.table.options.groupBy ? this.getGroupedData() : this.getData();
  }
  ///////////////////////////////////////
  ///////// Component Functions /////////
  ///////////////////////////////////////
  rowGetGroup(e) {
    return e.modules.group ? e.modules.group.getComponent() : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  rowMoving(e, t, i) {
    if (this.table.options.groupBy) {
      !i && t instanceof ef && (t = this.table.rowManager.prevDisplayRow(e) || t);
      var n = t instanceof ef ? t : t.modules.group, a = e instanceof ef ? e : e.modules.group;
      n === a ? this.table.rowManager.moveRowInArray(n.rows, e, t, i) : (a && a.removeRow(e), n.insertRow(e, t, i));
    }
  }
  rowDeleting(e) {
    this.table.options.groupBy && e.modules.group && e.modules.group.removeRow(e);
  }
  rowsUpdated(e) {
    this.table.options.groupBy && this.updateGroupRows(!0);
  }
  cellUpdated(e) {
    this.table.options.groupBy && this.reassignRowToGroup(e.row);
  }
  //return appropriate rows with group headers
  getRows(e) {
    return this.table.options.groupBy && this.groupIDLookups.length ? (this.dispatchExternal("dataGrouping"), this.generateGroups(e), this.subscribedExternal("dataGrouped") && this.dispatchExternal("dataGrouped", this.getGroups(!0)), this.updateGroupRows()) : e.slice(0);
  }
  getGroups(e) {
    var t = [];
    return this.groupList.forEach(function(i) {
      t.push(e ? i.getComponent() : i);
    }), t;
  }
  getChildGroups(e) {
    var t = [];
    return e || (e = this), e.groupList.forEach((i) => {
      i.groupList.length ? t = t.concat(this.getChildGroups(i)) : t.push(i);
    }), t;
  }
  wipe() {
    this.table.options.groupBy && (this.groupList.forEach(function(e) {
      e.wipe();
    }), this.groupList = [], this.groups = {});
  }
  pullGroupListData(e) {
    var t = [];
    return e.forEach((i) => {
      var n = {};
      n.level = 0, n.rowCount = 0, n.headerContent = "";
      var a = [];
      i.hasSubGroups ? (a = this.pullGroupListData(i.groupList), n.level = i.level, n.rowCount = a.length - i.groupList.length, n.headerContent = i.generator(i.key, n.rowCount, i.rows, i), t.push(n), t = t.concat(a)) : (n.level = i.level, n.headerContent = i.generator(i.key, i.rows.length, i.rows, i), n.rowCount = i.getRows().length, t.push(n), i.getRows().forEach((o) => {
        t.push(o.getData("data"));
      }));
    }), t;
  }
  getGroupedData() {
    return this.pullGroupListData(this.groupList);
  }
  getRowGroup(e) {
    var t = !1;
    return this.options("dataTree") && (e = this.table.modules.dataTree.getTreeParentRoot(e)), this.groupList.forEach((i) => {
      var n = i.getRowGroup(e);
      n && (t = n);
    }), t;
  }
  countGroups() {
    return this.groupList.length;
  }
  generateGroups(e) {
    var t = this.groups;
    this.groups = {}, this.groupList = [], this.allowedValues && this.allowedValues[0] ? (this.allowedValues[0].forEach((i) => {
      this.createGroup(i, 0, t);
    }), e.forEach((i) => {
      this.assignRowToExistingGroup(i, t);
    })) : e.forEach((i) => {
      this.assignRowToGroup(i, t);
    }), Object.values(t).forEach((i) => {
      i.wipe(!0);
    });
  }
  createGroup(e, t, i) {
    var n = t + "_" + e, a;
    i = i || [], a = new ef(this, !1, t, e, this.groupIDLookups[0].field, this.headerGenerator[0], i[n]), this.groups[n] = a, this.groupList.push(a);
  }
  assignRowToExistingGroup(e, t) {
    var i = this.groupIDLookups[0].func(e.getData()), n = "0_" + i;
    this.groups[n] && this.groups[n].addRow(e);
  }
  assignRowToGroup(e, t) {
    var i = this.groupIDLookups[0].func(e.getData()), n = !this.groups["0_" + i];
    return n && this.createGroup(i, 0, t), this.groups["0_" + i].addRow(e), !n;
  }
  reassignRowToGroup(e) {
    if (e.type === "row") {
      var t = e.modules.group, i = t.getPath(), n = this.getExpectedPath(e), a;
      a = i.length == n.length && i.every((o, s) => o === n[s]), a || (t.removeRow(e), this.assignRowToGroup(e, this.groups), this.refreshData(!0));
    }
  }
  getExpectedPath(e) {
    var t = [], i = e.getData();
    return this.groupIDLookups.forEach((n) => {
      t.push(n.func(i));
    }), t;
  }
  updateGroupRows(e) {
    var t = [];
    return this.blockRedraw || (this.groupList.forEach((i) => {
      t = t.concat(i.getHeadersAndRows());
    }), e && this.refreshData(!0)), t;
  }
  scrollHeaders(e) {
    this.table.options.groupBy && (this.table.options.renderHorizontal === "virtual" && (e -= this.table.columnManager.renderer.vDomPadLeft), e = e + "px", this.groupList.forEach((t) => {
      t.scrollHeader(e);
    }));
  }
  removeGroup(e) {
    var t = e.level + "_" + e.key, i;
    this.groups[t] && (delete this.groups[t], i = this.groupList.indexOf(e), i > -1 && this.groupList.splice(i, 1));
  }
  checkBasicModeGroupHeaderWidth() {
    var e = this.table.rowManager.tableElement, t = !0;
    this.table.rowManager.getDisplayRows().forEach((i, n) => {
      this.table.rowManager.styleRow(i, n), e.appendChild(i.getElement()), i.initialize(!0), i.type !== "group" && (t = !1);
    }), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
}
QP.moduleName = "groupRows";
var xGe = {
  cellEdit: function(r) {
    r.component.setValueProcessData(r.data.oldValue), r.component.cellRendered();
  },
  rowAdd: function(r) {
    r.component.deleteActual();
  },
  rowDelete: function(r) {
    var e = this.table.rowManager.addRowActual(r.data.data, r.data.pos, r.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(r.component, e);
  },
  rowMove: function(r) {
    this.table.rowManager.moveRowActual(r.component, this.table.rowManager.rows[r.data.posFrom], !r.data.after), this.table.rowManager.redraw();
  }
}, PGe = {
  cellEdit: function(r) {
    r.component.setValueProcessData(r.data.newValue), r.component.cellRendered();
  },
  rowAdd: function(r) {
    var e = this.table.rowManager.addRowActual(r.data.data, r.data.pos, r.data.index);
    this.table.options.groupBy && this.table.modExists("groupRows") && this.table.modules.groupRows.updateGroupRows(!0), this._rebindRow(r.component, e);
  },
  rowDelete: function(r) {
    r.component.deleteActual();
  },
  rowMove: function(r) {
    this.table.rowManager.moveRowActual(r.component, this.table.rowManager.rows[r.data.posTo], r.data.after), this.table.rowManager.redraw();
  }
};
class Hl extends mt {
  constructor(e) {
    super(e), this.history = [], this.index = -1, this.registerTableOption("history", !1);
  }
  initialize() {
    this.table.options.history && (this.subscribe("cell-value-updated", this.cellUpdated.bind(this)), this.subscribe("cell-delete", this.clearComponentHistory.bind(this)), this.subscribe("row-delete", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clear.bind(this)), this.subscribe("row-added", this.rowAdded.bind(this)), this.subscribe("row-move", this.rowMoved.bind(this))), this.registerTableFunction("undo", this.undo.bind(this)), this.registerTableFunction("redo", this.redo.bind(this)), this.registerTableFunction("getHistoryUndoSize", this.getHistoryUndoSize.bind(this)), this.registerTableFunction("getHistoryRedoSize", this.getHistoryRedoSize.bind(this)), this.registerTableFunction("clearHistory", this.clear.bind(this));
  }
  rowMoved(e, t, i) {
    this.action("rowMove", e, { posFrom: e.getPosition(), posTo: t.getPosition(), to: t, after: i });
  }
  rowAdded(e, t, i, n) {
    this.action("rowAdd", e, { data: t, pos: i, index: n });
  }
  rowDeleted(e) {
    var t, i;
    this.table.options.groupBy ? (i = e.getComponent().getGroup()._getSelf().rows, t = i.indexOf(e), t && (t = i[t - 1])) : (t = e.table.rowManager.getRowIndex(e), t && (t = e.table.rowManager.rows[t - 1])), this.action("rowDelete", e, { data: e.getData(), pos: !t, index: t });
  }
  cellUpdated(e) {
    this.action("cellEdit", e, { oldValue: e.oldValue, newValue: e.value });
  }
  clear() {
    this.history = [], this.index = -1;
  }
  action(e, t, i) {
    this.history = this.history.slice(0, this.index + 1), this.history.push({
      type: e,
      component: t,
      data: i
    }), this.index++;
  }
  getHistoryUndoSize() {
    return this.index + 1;
  }
  getHistoryRedoSize() {
    return this.history.length - (this.index + 1);
  }
  clearComponentHistory(e) {
    var t = this.history.findIndex(function(i) {
      return i.component === e;
    });
    t > -1 && (this.history.splice(t, 1), t <= this.index && this.index--, this.clearComponentHistory(e));
  }
  undo() {
    if (this.index > -1) {
      let e = this.history[this.index];
      return Hl.undoers[e.type].call(this, e), this.index--, this.dispatchExternal("historyUndo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Undo Error - No more history to undo"), !1;
  }
  redo() {
    if (this.history.length - 1 > this.index) {
      this.index++;
      let e = this.history[this.index];
      return Hl.redoers[e.type].call(this, e), this.dispatchExternal("historyRedo", e.type, e.component.getComponent(), e.data), !0;
    } else
      return console.warn("History Redo Error - No more history to redo"), !1;
  }
  //rebind rows to new element after deletion
  _rebindRow(e, t) {
    this.history.forEach(function(i) {
      if (i.component instanceof Pi)
        i.component === e && (i.component = t);
      else if (i.component instanceof Kv && i.component.row === e) {
        var n = i.component.column.getField();
        n && (i.component = t.getCell(n));
      }
    });
  }
}
Hl.moduleName = "history";
Hl.undoers = xGe;
Hl.redoers = PGe;
class UP extends mt {
  constructor(e) {
    super(e), this.fieldIndex = [], this.hasIndex = !1;
  }
  initialize() {
    this.tableElementCheck();
  }
  tableElementCheck() {
    this.table.originalElement && this.table.originalElement.tagName === "TABLE" && (this.table.originalElement.childNodes.length ? this.parseTable() : console.warn("Unable to parse data from empty table tag, Tabulator should be initialized on a div tag unless importing data from a table element."));
  }
  parseTable() {
    var e = this.table.originalElement, t = this.table.options, i = e.getElementsByTagName("th"), n = e.getElementsByTagName("tbody")[0], a = [];
    this.hasIndex = !1, this.dispatchExternal("htmlImporting"), n = n ? n.getElementsByTagName("tr") : [], this._extractOptions(e, t), i.length ? this._extractHeaders(i, n) : this._generateBlankHeaders(i, n);
    for (var o = 0; o < n.length; o++) {
      var s = n[o], l = s.getElementsByTagName("td"), u = {};
      this.hasIndex || (u[t.index] = o);
      for (var c = 0; c < l.length; c++) {
        var h = l[c];
        typeof this.fieldIndex[c] < "u" && (u[this.fieldIndex[c]] = h.innerHTML);
      }
      a.push(u);
    }
    t.data = a, this.dispatchExternal("htmlImported");
  }
  //extract tabulator attribute options
  _extractOptions(e, t, i) {
    var n = e.attributes, a = Object.keys(i || t), o = {};
    a.forEach((c) => {
      o[c.toLowerCase()] = c;
    });
    for (var s in n) {
      var l = n[s], u;
      l && typeof l == "object" && l.name && l.name.indexOf("tabulator-") === 0 && (u = l.name.replace("tabulator-", ""), typeof o[u] < "u" && (t[o[u]] = this._attribValue(l.value)));
    }
  }
  //get value of attribute
  _attribValue(e) {
    return e === "true" ? !0 : e === "false" ? !1 : e;
  }
  //find column if it has already been defined
  _findCol(e) {
    var t = this.table.options.columns.find((i) => i.title === e);
    return t || !1;
  }
  //extract column from headers
  _extractHeaders(e, t) {
    for (var i = 0; i < e.length; i++) {
      var n = e[i], a = !1, o = this._findCol(n.textContent), s;
      o ? a = !0 : o = { title: n.textContent.trim() }, o.field || (o.field = n.textContent.trim().toLowerCase().replace(" ", "_")), s = n.getAttribute("width"), s && !o.width && (o.width = s), this._extractOptions(n, o, this.table.columnManager.optionsList.registeredDefaults), this.fieldIndex[i] = o.field, o.field == this.table.options.index && (this.hasIndex = !0), a || this.table.options.columns.push(o);
    }
  }
  //generate blank headers
  _generateBlankHeaders(e, t) {
    for (var i = 0; i < e.length; i++) {
      var n = e[i], a = { title: "", field: "col" + i };
      this.fieldIndex[i] = a.field;
      var o = n.getAttribute("width");
      o && (a.width = o), this.table.options.columns.push(a);
    }
  }
}
UP.moduleName = "htmlTableImport";
function LGe(r) {
  var e = [], t = 0, i = 0, n = !1;
  for (let a = 0; a < r.length; a++) {
    let o = r[a], s = r[a + 1];
    if (e[t] || (e[t] = []), e[t][i] || (e[t][i] = ""), o == '"' && n && s == '"') {
      e[t][i] += o, a++;
      continue;
    }
    if (o == '"') {
      n = !n;
      continue;
    }
    if (o == "," && !n) {
      i++;
      continue;
    }
    if (o == "\r" && s == `
` && !n) {
      i = 0, t++, a++;
      continue;
    }
    if ((o == "\r" || o == `
`) && !n) {
      i = 0, t++;
      continue;
    }
    e[t][i] += o;
  }
  return e;
}
function DGe(r) {
  try {
    return JSON.parse(r);
  } catch (e) {
    return console.warn("JSON Import Error - File contents is invalid JSON", e), Promise.reject();
  }
}
function MGe(r) {
  return r;
}
var kGe = {
  csv: LGe,
  json: DGe,
  array: MGe
};
class vd extends mt {
  constructor(e) {
    super(e), this.registerTableOption("importFormat"), this.registerTableOption("importReader", "text");
  }
  initialize() {
    this.registerTableFunction("import", this.importFromFile.bind(this)), this.table.options.importFormat && (this.subscribe("data-loading", this.loadDataCheck.bind(this), 10), this.subscribe("data-load", this.loadData.bind(this), 10));
  }
  loadDataCheck(e) {
    return this.table.options.importFormat && (typeof e == "string" || Array.isArray(e) && e.length && Array.isArray(e));
  }
  loadData(e, t, i, n, a) {
    return this.importData(this.lookupImporter(), e).then(this.structureData.bind(this)).catch((o) => (console.error("Import Error:", o || "Unable to import data"), Promise.reject(o)));
  }
  lookupImporter(e) {
    var t;
    return e || (e = this.table.options.importFormat), typeof e == "string" ? t = vd.importers[e] : t = e, t || console.error("Import Error - Importer not found:", e), t;
  }
  importFromFile(e, t) {
    var i = this.lookupImporter(e);
    if (i)
      return this.pickFile(t).then(this.importData.bind(this, i)).then(this.structureData.bind(this)).then(this.setData.bind(this)).catch((n) => (console.error("Import Error:", n || "Unable to import file"), Promise.reject(n)));
  }
  pickFile(e) {
    return new Promise((t, i) => {
      var n = document.createElement("input");
      n.type = "file", n.accept = e, n.addEventListener("change", (a) => {
        var o = n.files[0], s = new FileReader();
        switch (this.table.options.importReader) {
          case "buffer":
            s.readAsArrayBuffer(o);
            break;
          case "binary":
            s.readAsBinaryString(o);
            break;
          case "url":
            s.readAsDataURL(o);
            break;
          case "text":
          default:
            s.readAsText(o);
        }
        s.onload = (l) => {
          t(s.result);
        }, s.onerror = (l) => {
          console.warn("File Load Error - Unable to read file"), i();
        };
      }), n.click();
    });
  }
  importData(e, t) {
    var i = e.call(this.table, t);
    return i instanceof Promise ? i : i ? Promise.resolve(i) : Promise.reject();
  }
  structureData(e) {
    var t = [];
    return Array.isArray(e) && e.length && Array.isArray(e[0]) ? (this.table.options.autoColumns ? t = this.structureArrayToObject(e) : t = this.structureArrayToColumns(e), t) : e;
  }
  structureArrayToObject(e) {
    var t = e.shift(), i = e.map((n) => {
      var a = {};
      return t.forEach((o, s) => {
        a[o] = n[s];
      }), a;
    });
    return i;
  }
  structureArrayToColumns(e) {
    var t = [], i = this.table.getColumns();
    return i[0] && e[0][0] && i[0].getDefinition().title === e[0][0] && e.shift(), e.forEach((n) => {
      var a = {};
      n.forEach((o, s) => {
        var l = i[s];
        l && (a[l.getField()] = o);
      }), t.push(a);
    }), t;
  }
  setData(e) {
    return this.table.setData(e);
  }
}
vd.moduleName = "import";
vd.importers = kGe;
class $P extends mt {
  constructor(e) {
    super(e), this.eventMap = {
      //row events
      rowClick: "row-click",
      rowDblClick: "row-dblclick",
      rowContext: "row-contextmenu",
      rowMouseEnter: "row-mouseenter",
      rowMouseLeave: "row-mouseleave",
      rowMouseOver: "row-mouseover",
      rowMouseOut: "row-mouseout",
      rowMouseMove: "row-mousemove",
      rowMouseDown: "row-mousedown",
      rowMouseUp: "row-mouseup",
      rowTap: "row",
      rowDblTap: "row",
      rowTapHold: "row",
      //cell events
      cellClick: "cell-click",
      cellDblClick: "cell-dblclick",
      cellContext: "cell-contextmenu",
      cellMouseEnter: "cell-mouseenter",
      cellMouseLeave: "cell-mouseleave",
      cellMouseOver: "cell-mouseover",
      cellMouseOut: "cell-mouseout",
      cellMouseMove: "cell-mousemove",
      cellMouseDown: "cell-mousedown",
      cellMouseUp: "cell-mouseup",
      cellTap: "cell",
      cellDblTap: "cell",
      cellTapHold: "cell",
      //column header events
      headerClick: "column-click",
      headerDblClick: "column-dblclick",
      headerContext: "column-contextmenu",
      headerMouseEnter: "column-mouseenter",
      headerMouseLeave: "column-mouseleave",
      headerMouseOver: "column-mouseover",
      headerMouseOut: "column-mouseout",
      headerMouseMove: "column-mousemove",
      headerMouseDown: "column-mousedown",
      headerMouseUp: "column-mouseup",
      headerTap: "column",
      headerDblTap: "column",
      headerTapHold: "column",
      //group header
      groupClick: "group-click",
      groupDblClick: "group-dblclick",
      groupContext: "group-contextmenu",
      groupMouseEnter: "group-mouseenter",
      groupMouseLeave: "group-mouseleave",
      groupMouseOver: "group-mouseover",
      groupMouseOut: "group-mouseout",
      groupMouseMove: "group-mousemove",
      groupMouseDown: "group-mousedown",
      groupMouseUp: "group-mouseup",
      groupTap: "group",
      groupDblTap: "group",
      groupTapHold: "group"
    }, this.subscribers = {}, this.touchSubscribers = {}, this.columnSubscribers = {}, this.touchWatchers = {
      row: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      cell: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      column: {
        tap: null,
        tapDbl: null,
        tapHold: null
      },
      group: {
        tap: null,
        tapDbl: null,
        tapHold: null
      }
    }, this.registerColumnOption("headerClick"), this.registerColumnOption("headerDblClick"), this.registerColumnOption("headerContext"), this.registerColumnOption("headerMouseEnter"), this.registerColumnOption("headerMouseLeave"), this.registerColumnOption("headerMouseOver"), this.registerColumnOption("headerMouseOut"), this.registerColumnOption("headerMouseMove"), this.registerColumnOption("headerMouseDown"), this.registerColumnOption("headerMouseUp"), this.registerColumnOption("headerTap"), this.registerColumnOption("headerDblTap"), this.registerColumnOption("headerTapHold"), this.registerColumnOption("cellClick"), this.registerColumnOption("cellDblClick"), this.registerColumnOption("cellContext"), this.registerColumnOption("cellMouseEnter"), this.registerColumnOption("cellMouseLeave"), this.registerColumnOption("cellMouseOver"), this.registerColumnOption("cellMouseOut"), this.registerColumnOption("cellMouseMove"), this.registerColumnOption("cellMouseDown"), this.registerColumnOption("cellMouseUp"), this.registerColumnOption("cellTap"), this.registerColumnOption("cellDblTap"), this.registerColumnOption("cellTapHold");
  }
  initialize() {
    this.initializeExternalEvents(), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("cell-dblclick", this.cellContentsSelectionFixer.bind(this)), this.subscribe("scroll-horizontal", this.clearTouchWatchers.bind(this)), this.subscribe("scroll-vertical", this.clearTouchWatchers.bind(this));
  }
  clearTouchWatchers() {
    var e = Object.values(this.touchWatchers);
    e.forEach((t) => {
      for (let i in t)
        t[i] = null;
    });
  }
  cellContentsSelectionFixer(e, t) {
    var i;
    if (!(this.table.modExists("edit") && this.table.modules.edit.currentCell === t)) {
      e.preventDefault();
      try {
        document.selection ? (i = document.body.createTextRange(), i.moveToElementText(t.getElement()), i.select()) : window.getSelection && (i = document.createRange(), i.selectNode(t.getElement()), window.getSelection().removeAllRanges(), window.getSelection().addRange(i));
      } catch {
      }
    }
  }
  initializeExternalEvents() {
    for (let e in this.eventMap)
      this.subscriptionChangeExternal(e, this.subscriptionChanged.bind(this, e));
  }
  subscriptionChanged(e, t) {
    t ? this.subscribers[e] || (this.eventMap[e].includes("-") ? (this.subscribers[e] = this.handle.bind(this, e), this.subscribe(this.eventMap[e], this.subscribers[e])) : this.subscribeTouchEvents(e)) : this.eventMap[e].includes("-") ? this.subscribers[e] && !this.columnSubscribers[e] && !this.subscribedExternal(e) && (this.unsubscribe(this.eventMap[e], this.subscribers[e]), delete this.subscribers[e]) : this.unsubscribeTouchEvents(e);
  }
  subscribeTouchEvents(e) {
    var t = this.eventMap[e];
    this.touchSubscribers[t + "-touchstart"] || (this.touchSubscribers[t + "-touchstart"] = this.handleTouch.bind(this, t, "start"), this.touchSubscribers[t + "-touchend"] = this.handleTouch.bind(this, t, "end"), this.subscribe(t + "-touchstart", this.touchSubscribers[t + "-touchstart"]), this.subscribe(t + "-touchend", this.touchSubscribers[t + "-touchend"])), this.subscribers[e] = !0;
  }
  unsubscribeTouchEvents(e) {
    var t = !0, i = this.eventMap[e];
    if (this.subscribers[e] && !this.subscribedExternal(e)) {
      delete this.subscribers[e];
      for (let n in this.eventMap)
        this.eventMap[n] === i && this.subscribers[n] && (t = !1);
      t && (this.unsubscribe(i + "-touchstart", this.touchSubscribers[i + "-touchstart"]), this.unsubscribe(i + "-touchend", this.touchSubscribers[i + "-touchend"]), delete this.touchSubscribers[i + "-touchstart"], delete this.touchSubscribers[i + "-touchend"]);
    }
  }
  initializeColumn(e) {
    var t = e.definition;
    for (let i in this.eventMap)
      t[i] && (this.subscriptionChanged(i, !0), this.columnSubscribers[i] || (this.columnSubscribers[i] = []), this.columnSubscribers[i].push(e));
  }
  handle(e, t, i) {
    this.dispatchEvent(e, t, i);
  }
  handleTouch(e, t, i, n) {
    var a = this.touchWatchers[e];
    switch (e === "column" && (e = "header"), t) {
      case "start":
        a.tap = !0, clearTimeout(a.tapHold), a.tapHold = setTimeout(() => {
          clearTimeout(a.tapHold), a.tapHold = null, a.tap = null, clearTimeout(a.tapDbl), a.tapDbl = null, this.dispatchEvent(e + "TapHold", i, n);
        }, 1e3);
        break;
      case "end":
        a.tap && (a.tap = null, this.dispatchEvent(e + "Tap", i, n)), a.tapDbl ? (clearTimeout(a.tapDbl), a.tapDbl = null, this.dispatchEvent(e + "DblTap", i, n)) : a.tapDbl = setTimeout(() => {
          clearTimeout(a.tapDbl), a.tapDbl = null;
        }, 300), clearTimeout(a.tapHold), a.tapHold = null;
        break;
    }
  }
  dispatchEvent(e, t, i) {
    var n = i.getComponent(), a;
    this.columnSubscribers[e] && (i instanceof Kv ? a = i.column.definition[e] : i instanceof Eo && (a = i.definition[e]), a && a(t, n)), this.dispatchExternal(e, t, n);
  }
}
$P.moduleName = "interaction";
var QGe = {
  navPrev: "shift + 9",
  navNext: 9,
  navUp: 38,
  navDown: 40,
  scrollPageUp: 33,
  scrollPageDown: 34,
  scrollToStart: 36,
  scrollToEnd: 35,
  undo: ["ctrl + 90", "meta + 90"],
  redo: ["ctrl + 89", "meta + 89"],
  copyToClipboard: ["ctrl + 67", "meta + 89"]
}, UGe = {
  keyBlock: function(r) {
    r.stopPropagation(), r.preventDefault();
  },
  scrollPageUp: function(r) {
    var e = this.table.rowManager, t = e.scrollTop - e.element.clientHeight;
    r.preventDefault(), e.displayRowsCount && (t >= 0 ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[0])), this.table.element.focus();
  },
  scrollPageDown: function(r) {
    var e = this.table.rowManager, t = e.scrollTop + e.element.clientHeight, i = e.element.scrollHeight;
    r.preventDefault(), e.displayRowsCount && (t <= i ? e.element.scrollTop = t : e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1])), this.table.element.focus();
  },
  scrollToStart: function(r) {
    var e = this.table.rowManager;
    r.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[0]), this.table.element.focus();
  },
  scrollToEnd: function(r) {
    var e = this.table.rowManager;
    r.preventDefault(), e.displayRowsCount && e.scrollToRow(e.getDisplayRows()[e.displayRowsCount - 1]), this.table.element.focus();
  },
  navPrev: function(r) {
    this.dispatch("keybinding-nav-prev", r);
  },
  navNext: function(r) {
    this.dispatch("keybinding-nav-next", r);
  },
  navLeft: function(r) {
    this.dispatch("keybinding-nav-left", r);
  },
  navRight: function(r) {
    this.dispatch("keybinding-nav-right", r);
  },
  navUp: function(r) {
    this.dispatch("keybinding-nav-up", r);
  },
  navDown: function(r) {
    this.dispatch("keybinding-nav-down", r);
  },
  undo: function(r) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (r.preventDefault(), this.table.modules.history.undo()));
  },
  redo: function(r) {
    var e = !1;
    this.table.options.history && this.table.modExists("history") && this.table.modExists("edit") && (e = this.table.modules.edit.currentCell, e || (r.preventDefault(), this.table.modules.history.redo()));
  },
  copyToClipboard: function(r) {
    this.table.modules.edit.currentCell || this.table.modExists("clipboard", !0) && this.table.modules.clipboard.copy(!1, !0);
  }
};
class rs extends mt {
  constructor(e) {
    super(e), this.watchKeys = null, this.pressedKeys = null, this.keyupBinding = !1, this.keydownBinding = !1, this.registerTableOption("keybindings", {}), this.registerTableOption("tabEndNewRow", !1);
  }
  initialize() {
    var e = this.table.options.keybindings, t = {};
    this.watchKeys = {}, this.pressedKeys = [], e !== !1 && (Object.assign(t, rs.bindings), Object.assign(t, e), this.mapBindings(t), this.bindEvents()), this.subscribe("table-destroy", this.clearBindings.bind(this));
  }
  mapBindings(e) {
    for (let t in e)
      rs.actions[t] ? e[t] && (typeof e[t] != "object" && (e[t] = [e[t]]), e[t].forEach((i) => {
        var n = Array.isArray(i) ? i : [i];
        n.forEach((a) => {
          this.mapBinding(t, a);
        });
      })) : console.warn("Key Binding Error - no such action:", t);
  }
  mapBinding(e, t) {
    var i = {
      action: rs.actions[e],
      keys: [],
      ctrl: !1,
      shift: !1,
      meta: !1
    }, n = t.toString().toLowerCase().split(" ").join("").split("+");
    n.forEach((a) => {
      switch (a) {
        case "ctrl":
          i.ctrl = !0;
          break;
        case "shift":
          i.shift = !0;
          break;
        case "meta":
          i.meta = !0;
          break;
        default:
          a = isNaN(a) ? a.toUpperCase().charCodeAt(0) : parseInt(a), i.keys.push(a), this.watchKeys[a] || (this.watchKeys[a] = []), this.watchKeys[a].push(i);
      }
    });
  }
  bindEvents() {
    var e = this;
    this.keyupBinding = function(t) {
      var i = t.keyCode, n = e.watchKeys[i];
      n && (e.pressedKeys.push(i), n.forEach(function(a) {
        e.checkBinding(t, a);
      }));
    }, this.keydownBinding = function(t) {
      var i = t.keyCode, n = e.watchKeys[i];
      if (n) {
        var a = e.pressedKeys.indexOf(i);
        a > -1 && e.pressedKeys.splice(a, 1);
      }
    }, this.table.element.addEventListener("keydown", this.keyupBinding), this.table.element.addEventListener("keyup", this.keydownBinding);
  }
  clearBindings() {
    this.keyupBinding && this.table.element.removeEventListener("keydown", this.keyupBinding), this.keydownBinding && this.table.element.removeEventListener("keyup", this.keydownBinding);
  }
  checkBinding(e, t) {
    var i = !0;
    return e.ctrlKey == t.ctrl && e.shiftKey == t.shift && e.metaKey == t.meta ? (t.keys.forEach((n) => {
      var a = this.pressedKeys.indexOf(n);
      a == -1 && (i = !1);
    }), i && t.action.call(this, e), !0) : !1;
  }
}
rs.moduleName = "keybindings";
rs.bindings = QGe;
rs.actions = UGe;
class Xq extends mt {
  constructor(e) {
    super(e), this.menuContainer = null, this.nestedMenuBlock = !1, this.currentComponent = null, this.rootPopup = null, this.columnSubscribers = {}, this.registerTableOption("menuContainer", void 0), this.registerTableOption("rowContextMenu", !1), this.registerTableOption("rowClickMenu", !1), this.registerTableOption("rowDblClickMenu", !1), this.registerTableOption("groupContextMenu", !1), this.registerTableOption("groupClickMenu", !1), this.registerTableOption("groupDblClickMenu", !1), this.registerColumnOption("headerContextMenu"), this.registerColumnOption("headerClickMenu"), this.registerColumnOption("headerDblClickMenu"), this.registerColumnOption("headerMenu"), this.registerColumnOption("headerMenuIcon"), this.registerColumnOption("contextMenu"), this.registerColumnOption("clickMenu"), this.registerColumnOption("dblClickMenu");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheck("menuContainer", "popupContainer") || (this.table.options.popupContainer = this.table.options.menuContainer);
  }
  initializeRowWatchers() {
    this.table.options.rowContextMenu && (this.subscribe("row-contextmenu", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu)), this.table.on("rowTapHold", this.loadMenuEvent.bind(this, this.table.options.rowContextMenu))), this.table.options.rowClickMenu && this.subscribe("row-click", this.loadMenuEvent.bind(this, this.table.options.rowClickMenu)), this.table.options.rowDblClickMenu && this.subscribe("row-dblclick", this.loadMenuEvent.bind(this, this.table.options.rowDblClickMenu));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextMenu && (this.subscribe("group-contextmenu", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu)), this.table.on("groupTapHold", this.loadMenuEvent.bind(this, this.table.options.groupContextMenu))), this.table.options.groupClickMenu && this.subscribe("group-click", this.loadMenuEvent.bind(this, this.table.options.groupClickMenu)), this.table.options.groupDblClickMenu && this.subscribe("group-dblclick", this.loadMenuEvent.bind(this, this.table.options.groupDblClickMenu));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextMenu && !this.columnSubscribers.headerContextMenu && (this.columnSubscribers.headerContextMenu = this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextMenu), this.table.on("headerTapHold", this.loadMenuTableColumnEvent.bind(this, "headerContextMenu"))), t.headerClickMenu && !this.columnSubscribers.headerClickMenu && (this.columnSubscribers.headerClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerClickMenu"), this.subscribe("column-click", this.columnSubscribers.headerClickMenu)), t.headerDblClickMenu && !this.columnSubscribers.headerDblClickMenu && (this.columnSubscribers.headerDblClickMenu = this.loadMenuTableColumnEvent.bind(this, "headerDblClickMenu"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickMenu)), t.headerMenu && this.initializeColumnHeaderMenu(e), t.contextMenu && !this.columnSubscribers.contextMenu && (this.columnSubscribers.contextMenu = this.loadMenuTableCellEvent.bind(this, "contextMenu"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextMenu), this.table.on("cellTapHold", this.loadMenuTableCellEvent.bind(this, "contextMenu"))), t.clickMenu && !this.columnSubscribers.clickMenu && (this.columnSubscribers.clickMenu = this.loadMenuTableCellEvent.bind(this, "clickMenu"), this.subscribe("cell-click", this.columnSubscribers.clickMenu)), t.dblClickMenu && !this.columnSubscribers.dblClickMenu && (this.columnSubscribers.dblClickMenu = this.loadMenuTableCellEvent.bind(this, "dblClickMenu"), this.subscribe("cell-dblclick", this.columnSubscribers.dblClickMenu));
  }
  initializeColumnHeaderMenu(e) {
    var t = e.definition.headerMenuIcon, i;
    i = document.createElement("span"), i.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? i.appendChild(t) : i.innerHTML = t) : i.innerHTML = "&vellip;", i.addEventListener("click", (n) => {
      n.stopPropagation(), n.preventDefault(), this.loadMenuEvent(e.definition.headerMenu, n, e);
    }), e.titleElement.insertBefore(i, e.titleElement.firstChild);
  }
  loadMenuTableCellEvent(e, t, i) {
    i._cell && (i = i._cell), i.column.definition[e] && this.loadMenuEvent(i.column.definition[e], t, i);
  }
  loadMenuTableColumnEvent(e, t, i) {
    i._column && (i = i._column), i.definition[e] && this.loadMenuEvent(i.definition[e], t, i);
  }
  loadMenuEvent(e, t, i) {
    i._group ? i = i._group : i._row && (i = i._row), e = typeof e == "function" ? e.call(this.table, t, i.getComponent()) : e, this.loadMenu(t, i, e);
  }
  loadMenu(e, t, i, n, a) {
    var o = !(e instanceof MouseEvent), s = document.createElement("div"), l;
    if (s.classList.add("tabulator-menu"), o || e.preventDefault(), !(!i || !i.length)) {
      if (n)
        l = a.child(s);
      else {
        if (this.nestedMenuBlock) {
          if (this.rootPopup)
            return;
        } else
          this.nestedMenuBlock = setTimeout(() => {
            this.nestedMenuBlock = !1;
          }, 100);
        this.rootPopup && this.rootPopup.hide(), this.rootPopup = l = this.popup(s);
      }
      i.forEach((u) => {
        var c = document.createElement("div"), h = u.label, f = u.disabled;
        u.separator ? c.classList.add("tabulator-menu-separator") : (c.classList.add("tabulator-menu-item"), typeof h == "function" && (h = h.call(this.table, t.getComponent())), h instanceof Node ? c.appendChild(h) : c.innerHTML = h, typeof f == "function" && (f = f.call(this.table, t.getComponent())), f ? (c.classList.add("tabulator-menu-item-disabled"), c.addEventListener("click", (d) => {
          d.stopPropagation();
        })) : u.menu && u.menu.length ? c.addEventListener("click", (d) => {
          d.stopPropagation(), this.loadMenu(d, t, u.menu, c, l);
        }) : u.action && c.addEventListener("click", (d) => {
          u.action(d, t.getComponent());
        }), u.menu && u.menu.length && c.classList.add("tabulator-menu-item-submenu")), s.appendChild(c);
      }), s.addEventListener("click", (u) => {
        this.rootPopup && this.rootPopup.hide();
      }), l.show(n || e), l === this.rootPopup && (this.rootPopup.hideOnBlur(() => {
        this.rootPopup = null, this.currentComponent && (this.dispatchExternal("menuClosed", this.currentComponent.getComponent()), this.currentComponent = null);
      }), this.currentComponent = t, this.dispatchExternal("menuOpened", t.getComponent()));
    }
  }
}
Xq.moduleName = "menu";
class VP extends mt {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 250, this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.startX = 0, this.autoScrollMargin = 40, this.autoScrollStep = 5, this.autoScrollTimeout = !1, this.touchMove = !1, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.registerTableOption("movableColumns", !1);
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-col"), e.classList.add("tabulator-col-placeholder"), e;
  }
  initialize() {
    this.table.options.movableColumns && this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  initializeColumn(e) {
    var t = this, i = {}, n;
    !e.modules.frozen && !e.isGroup && (n = e.getElement(), i.mousemove = (function(a) {
      e.parent === t.moving.parent && ((t.touchMove ? a.touches[0].pageX : a.pageX) - Zt.elOffset(n).left + t.table.columnManager.contentsElement.scrollLeft > e.getWidth() / 2 ? (t.toCol !== e || !t.toColAfter) && (n.parentNode.insertBefore(t.placeholderElement, n.nextSibling), t.moveColumn(e, !0)) : (t.toCol !== e || t.toColAfter) && (n.parentNode.insertBefore(t.placeholderElement, n), t.moveColumn(e, !1)));
    }).bind(t), n.addEventListener("mousedown", function(a) {
      t.touchMove = !1, a.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(a, e);
      }, t.checkPeriod));
    }), n.addEventListener("mouseup", function(a) {
      a.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), t.bindTouchEvents(e)), e.modules.moveColumn = i;
  }
  bindTouchEvents(e) {
    var t = e.getElement(), i = !1, n, a, o, s, l, u;
    t.addEventListener("touchstart", (c) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, n = e.nextColumn(), o = n ? n.getWidth() / 2 : 0, a = e.prevColumn(), s = a ? a.getWidth() / 2 : 0, l = 0, u = 0, i = !1, this.startMove(c, e);
      }, this.checkPeriod);
    }, { passive: !0 }), t.addEventListener("touchmove", (c) => {
      var h, f;
      this.moving && (this.moveHover(c), i || (i = c.touches[0].pageX), h = c.touches[0].pageX - i, h > 0 ? n && h - l > o && (f = n, f !== e && (i = c.touches[0].pageX, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement().nextSibling), this.moveColumn(f, !0))) : a && -h - u > s && (f = a, f !== e && (i = c.touches[0].pageX, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement()), this.moveColumn(f, !1))), f && (n = f.nextColumn(), l = o, o = n ? n.getWidth() / 2 : 0, a = f.prevColumn(), u = s, s = a ? a.getWidth() / 2 : 0));
    }, { passive: !0 }), t.addEventListener("touchend", (c) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && this.endMove(c);
    });
  }
  startMove(e, t) {
    var i = t.getElement(), n = this.table.columnManager.getContentsElement(), a = this.table.columnManager.getHeadersElement();
    this.moving = t, this.startX = (this.touchMove ? e.touches[0].pageX : e.pageX) - Zt.elOffset(i).left, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", i.parentNode.insertBefore(this.placeholderElement, i), i.parentNode.removeChild(i), this.hoverElement = i.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), n.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.bottom = n.clientHeight - a.offsetHeight + "px", this.touchMove || (this._bindMouseMove(), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove)), this.moveHover(e);
  }
  _bindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.columnManager.columnsByIndex.forEach(function(e) {
      e.modules.moveColumn.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveColumn.mousemove);
    });
  }
  moveColumn(e, t) {
    var i = this.moving.getCells();
    this.toCol = e, this.toColAfter = t, t ? e.getCells().forEach(function(n, a) {
      var o = n.getElement(!0);
      o.parentNode && i[a] && o.parentNode.insertBefore(i[a].getElement(), o.nextSibling);
    }) : e.getCells().forEach(function(n, a) {
      var o = n.getElement(!0);
      o.parentNode && i[a] && o.parentNode.insertBefore(i[a].getElement(), o);
    });
  }
  endMove(e) {
    (e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toCol && this.table.columnManager.moveColumnActual(this.moving, this.toCol, this.toColAfter), this.moving = !1, this.toCol = !1, this.toColAfter = !1, this.touchMove || (document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove)));
  }
  moveHover(e) {
    var t = this.table.columnManager.getContentsElement(), i = t.scrollLeft, n = (this.touchMove ? e.touches[0].pageX : e.pageX) - Zt.elOffset(t).left + i, a;
    this.hoverElement.style.left = n - this.startX + "px", n - i < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      a = Math.max(0, i - 5), this.table.rowManager.getElement().scrollLeft = a, this.autoScrollTimeout = !1;
    }, 1))), i + t.clientWidth - n < this.autoScrollMargin && (this.autoScrollTimeout || (this.autoScrollTimeout = setTimeout(() => {
      a = Math.min(t.clientWidth, i + 5), this.table.rowManager.getElement().scrollLeft = a, this.autoScrollTimeout = !1;
    }, 1)));
  }
}
VP.moduleName = "moveColumn";
class Jv extends mt {
  constructor(e) {
    super(e), this.placeholderElement = this.createPlaceholderElement(), this.hoverElement = !1, this.checkTimeout = !1, this.checkPeriod = 150, this.moving = !1, this.toRow = !1, this.toRowAfter = !1, this.hasHandle = !1, this.startY = 0, this.startX = 0, this.moveHover = this.moveHover.bind(this), this.endMove = this.endMove.bind(this), this.tableRowDropEvent = !1, this.touchMove = !1, this.connection = !1, this.connectionSelectorsTables = !1, this.connectionSelectorsElements = !1, this.connectionElements = [], this.connections = [], this.connectedTable = !1, this.connectedRow = !1, this.registerTableOption("movableRows", !1), this.registerTableOption("movableRowsConnectedTables", !1), this.registerTableOption("movableRowsConnectedElements", !1), this.registerTableOption("movableRowsSender", !1), this.registerTableOption("movableRowsReceiver", "insert"), this.registerColumnOption("rowHandle");
  }
  createPlaceholderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-row"), e.classList.add("tabulator-row-placeholder"), e;
  }
  initialize() {
    this.table.options.movableRows && (this.connectionSelectorsTables = this.table.options.movableRowsConnectedTables, this.connectionSelectorsElements = this.table.options.movableRowsConnectedElements, this.connection = this.connectionSelectorsTables || this.connectionSelectorsElements, this.subscribe("cell-init", this.initializeCell.bind(this)), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)));
  }
  initializeGroupHeader(e) {
    var t = this, i = {};
    i.mouseup = (function(n) {
      t.tableRowDrop(n, e);
    }).bind(t), i.mousemove = (function(n) {
      var a;
      n.pageY - Zt.elOffset(e.element).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (a = e.getElement(), a.parentNode.insertBefore(t.placeholderElement, a.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (a = e.getElement(), a.previousSibling && (a.parentNode.insertBefore(t.placeholderElement, a), t.moveRow(e, !1)));
    }).bind(t), e.modules.moveRow = i;
  }
  initializeRow(e) {
    var t = this, i = {}, n;
    i.mouseup = (function(a) {
      t.tableRowDrop(a, e);
    }).bind(t), i.mousemove = (function(a) {
      var o = e.getElement();
      a.pageY - Zt.elOffset(o).top + t.table.rowManager.element.scrollTop > e.getHeight() / 2 ? (t.toRow !== e || !t.toRowAfter) && (o.parentNode.insertBefore(t.placeholderElement, o.nextSibling), t.moveRow(e, !0)) : (t.toRow !== e || t.toRowAfter) && (o.parentNode.insertBefore(t.placeholderElement, o), t.moveRow(e, !1));
    }).bind(t), this.hasHandle || (n = e.getElement(), n.addEventListener("mousedown", function(a) {
      a.which === 1 && (t.checkTimeout = setTimeout(function() {
        t.startMove(a, e);
      }, t.checkPeriod));
    }), n.addEventListener("mouseup", function(a) {
      a.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
    }), this.bindTouchEvents(e, e.getElement())), e.modules.moveRow = i;
  }
  initializeColumn(e) {
    e.definition.rowHandle && this.table.options.movableRows !== !1 && (this.hasHandle = !0);
  }
  initializeCell(e) {
    if (e.column.definition.rowHandle && this.table.options.movableRows !== !1) {
      var t = this, i = e.getElement(!0);
      i.addEventListener("mousedown", function(n) {
        n.which === 1 && (t.checkTimeout = setTimeout(function() {
          t.startMove(n, e.row);
        }, t.checkPeriod));
      }), i.addEventListener("mouseup", function(n) {
        n.which === 1 && t.checkTimeout && clearTimeout(t.checkTimeout);
      }), this.bindTouchEvents(e.row, i);
    }
  }
  bindTouchEvents(e, t) {
    var i = !1, n, a, o, s, l, u;
    t.addEventListener("touchstart", (c) => {
      this.checkTimeout = setTimeout(() => {
        this.touchMove = !0, n = e.nextRow(), o = n ? n.getHeight() / 2 : 0, a = e.prevRow(), s = a ? a.getHeight() / 2 : 0, l = 0, u = 0, i = !1, this.startMove(c, e);
      }, this.checkPeriod);
    }, { passive: !0 }), this.moving, this.toRow, this.toRowAfter, t.addEventListener("touchmove", (c) => {
      var h, f;
      this.moving && (c.preventDefault(), this.moveHover(c), i || (i = c.touches[0].pageY), h = c.touches[0].pageY - i, h > 0 ? n && h - l > o && (f = n, f !== e && (i = c.touches[0].pageY, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement().nextSibling), this.moveRow(f, !0))) : a && -h - u > s && (f = a, f !== e && (i = c.touches[0].pageY, f.getElement().parentNode.insertBefore(this.placeholderElement, f.getElement()), this.moveRow(f, !1))), f && (n = f.nextRow(), l = o, o = n ? n.getHeight() / 2 : 0, a = f.prevRow(), u = s, s = a ? a.getHeight() / 2 : 0));
    }), t.addEventListener("touchend", (c) => {
      this.checkTimeout && clearTimeout(this.checkTimeout), this.moving && (this.endMove(c), this.touchMove = !1);
    });
  }
  _bindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().addEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  _unbindMouseMove() {
    this.table.rowManager.getDisplayRows().forEach((e) => {
      (e.type === "row" || e.type === "group") && e.modules.moveRow && e.modules.moveRow.mousemove && e.getElement().removeEventListener("mousemove", e.modules.moveRow.mousemove);
    });
  }
  startMove(e, t) {
    var i = t.getElement();
    this.setStartPosition(e, t), this.moving = t, this.table.element.classList.add("tabulator-block-select"), this.placeholderElement.style.width = t.getWidth() + "px", this.placeholderElement.style.height = t.getHeight() + "px", this.connection ? (this.table.element.classList.add("tabulator-movingrow-sending"), this.connectToTables(t)) : (i.parentNode.insertBefore(this.placeholderElement, i), i.parentNode.removeChild(i)), this.hoverElement = i.cloneNode(!0), this.hoverElement.classList.add("tabulator-moving"), this.connection ? (document.body.appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this.hoverElement.style.width = this.table.element.clientWidth + "px", this.hoverElement.style.whiteSpace = "nowrap", this.hoverElement.style.overflow = "hidden", this.hoverElement.style.pointerEvents = "none") : (this.table.rowManager.getTableElement().appendChild(this.hoverElement), this.hoverElement.style.left = "0", this.hoverElement.style.top = "0", this._bindMouseMove()), document.body.addEventListener("mousemove", this.moveHover), document.body.addEventListener("mouseup", this.endMove), this.dispatchExternal("rowMoving", t.getComponent()), this.moveHover(e);
  }
  setStartPosition(e, t) {
    var i = this.touchMove ? e.touches[0].pageX : e.pageX, n = this.touchMove ? e.touches[0].pageY : e.pageY, a, o;
    a = t.getElement(), this.connection ? (o = a.getBoundingClientRect(), this.startX = o.left - i + window.pageXOffset, this.startY = o.top - n + window.pageYOffset) : this.startY = n - a.getBoundingClientRect().top;
  }
  endMove(e) {
    (!e || e.which === 1 || this.touchMove) && (this._unbindMouseMove(), this.connection || (this.placeholderElement.parentNode.insertBefore(this.moving.getElement(), this.placeholderElement.nextSibling), this.placeholderElement.parentNode.removeChild(this.placeholderElement)), this.hoverElement.parentNode.removeChild(this.hoverElement), this.table.element.classList.remove("tabulator-block-select"), this.toRow ? this.table.rowManager.moveRow(this.moving, this.toRow, this.toRowAfter) : this.dispatchExternal("rowMoveCancelled", this.moving.getComponent()), this.moving = !1, this.toRow = !1, this.toRowAfter = !1, document.body.removeEventListener("mousemove", this.moveHover), document.body.removeEventListener("mouseup", this.endMove), this.connection && (this.table.element.classList.remove("tabulator-movingrow-sending"), this.disconnectFromTables()));
  }
  moveRow(e, t) {
    this.toRow = e, this.toRowAfter = t;
  }
  moveHover(e) {
    this.connection ? this.moveHoverConnections.call(this, e) : this.moveHoverTable.call(this, e);
  }
  moveHoverTable(e) {
    var t = this.table.rowManager.getElement(), i = t.scrollTop, n = (this.touchMove ? e.touches[0].pageY : e.pageY) - t.getBoundingClientRect().top + i;
    this.hoverElement.style.top = Math.min(n - this.startY, this.table.rowManager.element.scrollHeight - this.hoverElement.offsetHeight) + "px";
  }
  moveHoverConnections(e) {
    this.hoverElement.style.left = this.startX + (this.touchMove ? e.touches[0].pageX : e.pageX) + "px", this.hoverElement.style.top = this.startY + (this.touchMove ? e.touches[0].pageY : e.pageY) + "px";
  }
  elementRowDrop(e, t, i) {
    this.dispatchExternal("movableRowsElementDrop", e, t, i ? i.getComponent() : !1);
  }
  //establish connection with other tables
  connectToTables(e) {
    var t;
    this.connectionSelectorsTables && (t = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStart", t), this.commsSend(this.connectionSelectorsTables, "moveRow", "connect", {
      row: e
    })), this.connectionSelectorsElements && (this.connectionElements = [], Array.isArray(this.connectionSelectorsElements) || (this.connectionSelectorsElements = [this.connectionSelectorsElements]), this.connectionSelectorsElements.forEach((i) => {
      typeof i == "string" ? this.connectionElements = this.connectionElements.concat(Array.prototype.slice.call(document.querySelectorAll(i))) : this.connectionElements.push(i);
    }), this.connectionElements.forEach((i) => {
      var n = (a) => {
        this.elementRowDrop(a, i, this.moving);
      };
      i.addEventListener("mouseup", n), i.tabulatorElementDropEvent = n, i.classList.add("tabulator-movingrow-receiving");
    }));
  }
  //disconnect from other tables
  disconnectFromTables() {
    var e;
    this.connectionSelectorsTables && (e = this.commsConnections(this.connectionSelectorsTables), this.dispatchExternal("movableRowsSendingStop", e), this.commsSend(this.connectionSelectorsTables, "moveRow", "disconnect")), this.connectionElements.forEach((t) => {
      t.classList.remove("tabulator-movingrow-receiving"), t.removeEventListener("mouseup", t.tabulatorElementDropEvent), delete t.tabulatorElementDropEvent;
    });
  }
  //accept incomming connection
  connect(e, t) {
    return this.connectedTable ? (console.warn("Move Row Error - Table cannot accept connection, already connected to table:", this.connectedTable), !1) : (this.connectedTable = e, this.connectedRow = t, this.table.element.classList.add("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((i) => {
      i.type === "row" && i.modules.moveRow && i.modules.moveRow.mouseup && i.getElement().addEventListener("mouseup", i.modules.moveRow.mouseup);
    }), this.tableRowDropEvent = this.tableRowDrop.bind(this), this.table.element.addEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStart", t, e), !0);
  }
  //close incoming connection
  disconnect(e) {
    e === this.connectedTable ? (this.connectedTable = !1, this.connectedRow = !1, this.table.element.classList.remove("tabulator-movingrow-receiving"), this.table.rowManager.getDisplayRows().forEach((t) => {
      t.type === "row" && t.modules.moveRow && t.modules.moveRow.mouseup && t.getElement().removeEventListener("mouseup", t.modules.moveRow.mouseup);
    }), this.table.element.removeEventListener("mouseup", this.tableRowDropEvent), this.dispatchExternal("movableRowsReceivingStop", e)) : console.warn("Move Row Error - trying to disconnect from non connected table");
  }
  dropComplete(e, t, i) {
    var n = !1;
    if (i) {
      switch (typeof this.table.options.movableRowsSender) {
        case "string":
          n = this.senders[this.table.options.movableRowsSender];
          break;
        case "function":
          n = this.table.options.movableRowsSender;
          break;
      }
      n ? n.call(this, this.moving ? this.moving.getComponent() : void 0, t ? t.getComponent() : void 0, e) : this.table.options.movableRowsSender && console.warn("Mover Row Error - no matching sender found:", this.table.options.movableRowsSender), this.dispatchExternal("movableRowsSent", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    } else
      this.dispatchExternal("movableRowsSentFailed", this.moving.getComponent(), t ? t.getComponent() : void 0, e);
    this.endMove();
  }
  tableRowDrop(e, t) {
    var i = !1, n = !1;
    switch (e.stopImmediatePropagation(), typeof this.table.options.movableRowsReceiver) {
      case "string":
        i = this.receivers[this.table.options.movableRowsReceiver];
        break;
      case "function":
        i = this.table.options.movableRowsReceiver;
        break;
    }
    i ? n = i.call(this, this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : console.warn("Mover Row Error - no matching receiver found:", this.table.options.movableRowsReceiver), n ? this.dispatchExternal("movableRowsReceived", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable) : this.dispatchExternal("movableRowsReceivedFailed", this.connectedRow.getComponent(), t ? t.getComponent() : void 0, this.connectedTable), this.commsSend(this.connectedTable, "moveRow", "dropcomplete", {
      row: t,
      success: n
    });
  }
  commsReceived(e, t, i) {
    switch (t) {
      case "connect":
        return this.connect(e, i.row);
      case "disconnect":
        return this.disconnect(e);
      case "dropcomplete":
        return this.dropComplete(e, i.row, i.success);
    }
  }
}
Jv.prototype.receivers = {
  insert: function(r, e, t) {
    return this.table.addRow(r.getData(), void 0, e), !0;
  },
  add: function(r, e, t) {
    return this.table.addRow(r.getData()), !0;
  },
  update: function(r, e, t) {
    return e ? (e.update(r.getData()), !0) : !1;
  },
  replace: function(r, e, t) {
    return e ? (this.table.addRow(r.getData(), void 0, e), e.delete(), !0) : !1;
  }
};
Jv.prototype.senders = {
  delete: function(r, e, t) {
    r.delete();
  }
};
Jv.moduleName = "moveRow";
var $Ge = {};
class Gc extends mt {
  constructor(e) {
    super(e), this.allowedTypes = ["", "data", "edit", "clipboard"], this.enabled = !0, this.registerColumnOption("mutator"), this.registerColumnOption("mutatorParams"), this.registerColumnOption("mutatorData"), this.registerColumnOption("mutatorDataParams"), this.registerColumnOption("mutatorEdit"), this.registerColumnOption("mutatorEditParams"), this.registerColumnOption("mutatorClipboard"), this.registerColumnOption("mutatorClipboardParams"), this.registerColumnOption("mutateLink");
  }
  initialize() {
    this.subscribe("cell-value-changing", this.transformCell.bind(this)), this.subscribe("cell-value-changed", this.mutateLink.bind(this)), this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("row-data-init-before", this.rowDataChanged.bind(this)), this.subscribe("row-data-changing", this.rowDataChanged.bind(this));
  }
  rowDataChanged(e, t, i) {
    return this.transformRow(t, "data", i);
  }
  //initialize column mutator
  initializeColumn(e) {
    var t = !1, i = {};
    this.allowedTypes.forEach((n) => {
      var a = "mutator" + (n.charAt(0).toUpperCase() + n.slice(1)), o;
      e.definition[a] && (o = this.lookupMutator(e.definition[a]), o && (t = !0, i[a] = {
        mutator: o,
        params: e.definition[a + "Params"] || {}
      }));
    }), t && (e.modules.mutate = i);
  }
  lookupMutator(e) {
    var t = !1;
    switch (typeof e) {
      case "string":
        Gc.mutators[e] ? t = Gc.mutators[e] : console.warn("Mutator Error - No such mutator found, ignoring: ", e);
        break;
      case "function":
        t = e;
        break;
    }
    return t;
  }
  //apply mutator to row
  transformRow(e, t, i) {
    var n = "mutator" + (t.charAt(0).toUpperCase() + t.slice(1)), a;
    return this.enabled && this.table.columnManager.traverse((o) => {
      var s, l, u;
      o.modules.mutate && (s = o.modules.mutate[n] || o.modules.mutate.mutator || !1, s && (a = o.getFieldValue(typeof i < "u" ? i : e), (t == "data" && !i || typeof a < "u") && (u = o.getComponent(), l = typeof s.params == "function" ? s.params(a, e, t, u) : s.params, o.setFieldValue(e, s.mutator(a, e, t, l, u)))));
    }), e;
  }
  //apply mutator to new cell value
  transformCell(e, t) {
    if (e.column.modules.mutate) {
      var i = e.column.modules.mutate.mutatorEdit || e.column.modules.mutate.mutator || !1, n = {};
      if (i)
        return n = Object.assign(n, e.row.getData()), e.column.setFieldValue(n, t), i.mutator(t, n, "edit", i.params, e.getComponent());
    }
    return t;
  }
  mutateLink(e) {
    var t = e.column.definition.mutateLink;
    t && (Array.isArray(t) || (t = [t]), t.forEach((i) => {
      var n = e.row.getCell(i);
      n && n.setValue(n.getValue(), !0, !0);
    }));
  }
  enable() {
    this.enabled = !0;
  }
  disable() {
    this.enabled = !1;
  }
}
Gc.moduleName = "mutator";
Gc.mutators = $Ge;
function VGe(r, e, t, i, n) {
  var a = document.createElement("span"), o = document.createElement("span"), s = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), c = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (h) => {
    o.innerHTML = h;
  }), this.table.modules.localize.langBind("pagination|counter|of", (h) => {
    l.innerHTML = h;
  }), this.table.modules.localize.langBind("pagination|counter|rows", (h) => {
    c.innerHTML = h;
  }), i ? (s.innerHTML = " " + e + "-" + Math.min(e + r - 1, i) + " ", u.innerHTML = " " + i + " ", a.appendChild(o), a.appendChild(s), a.appendChild(l), a.appendChild(u), a.appendChild(c)) : (s.innerHTML = " 0 ", a.appendChild(o), a.appendChild(s), a.appendChild(c)), a;
}
function GGe(r, e, t, i, n) {
  var a = document.createElement("span"), o = document.createElement("span"), s = document.createElement("span"), l = document.createElement("span"), u = document.createElement("span"), c = document.createElement("span");
  return this.table.modules.localize.langBind("pagination|counter|showing", (h) => {
    o.innerHTML = h;
  }), s.innerHTML = " " + t + " ", this.table.modules.localize.langBind("pagination|counter|of", (h) => {
    l.innerHTML = h;
  }), u.innerHTML = " " + n + " ", this.table.modules.localize.langBind("pagination|counter|pages", (h) => {
    c.innerHTML = h;
  }), a.appendChild(o), a.appendChild(s), a.appendChild(l), a.appendChild(u), a.appendChild(c), a;
}
var BGe = {
  rows: VGe,
  pages: GGe
};
class Od extends mt {
  constructor(e) {
    super(e), this.mode = "local", this.progressiveLoad = !1, this.element = null, this.pageCounterElement = null, this.pageCounter = null, this.size = 0, this.page = 1, this.count = 5, this.max = 1, this.remoteRowCountEstimate = null, this.initialLoad = !0, this.dataChanging = !1, this.pageSizes = [], this.registerTableOption("pagination", !1), this.registerTableOption("paginationMode", "local"), this.registerTableOption("paginationSize", !1), this.registerTableOption("paginationInitialPage", 1), this.registerTableOption("paginationCounter", !1), this.registerTableOption("paginationCounterElement", !1), this.registerTableOption("paginationButtonCount", 5), this.registerTableOption("paginationSizeSelector", !1), this.registerTableOption("paginationElement", !1), this.registerTableOption("paginationAddRow", "page"), this.registerTableOption("progressiveLoad", !1), this.registerTableOption("progressiveLoadDelay", 0), this.registerTableOption("progressiveLoadScrollMargin", 0), this.registerTableFunction("setMaxPage", this.setMaxPage.bind(this)), this.registerTableFunction("setPage", this.setPage.bind(this)), this.registerTableFunction("setPageToRow", this.userSetPageToRow.bind(this)), this.registerTableFunction("setPageSize", this.userSetPageSize.bind(this)), this.registerTableFunction("getPageSize", this.getPageSize.bind(this)), this.registerTableFunction("previousPage", this.previousPage.bind(this)), this.registerTableFunction("nextPage", this.nextPage.bind(this)), this.registerTableFunction("getPage", this.getPage.bind(this)), this.registerTableFunction("getPageMax", this.getPageMax.bind(this)), this.registerComponentFunction("row", "pageTo", this.setPageToRow.bind(this));
  }
  initialize() {
    this.table.options.pagination ? (this.subscribe("row-deleted", this.rowsUpdated.bind(this)), this.subscribe("row-added", this.rowsUpdated.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("footer-redraw", this.footerRedraw.bind(this)), this.table.options.paginationAddRow == "page" && this.subscribe("row-adding-position", this.rowAddingPosition.bind(this)), this.table.options.paginationMode === "remote" && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this))), this.table.options.progressiveLoad && console.error("Progressive Load Error - Pagination and progressive load cannot be used at the same time"), this.registerDisplayHandler(this.restOnRenderBefore.bind(this), 40), this.registerDisplayHandler(this.getRows.bind(this), 50), this.createElements(), this.initializePageCounter(), this.initializePaginator()) : this.table.options.progressiveLoad && (this.subscribe("data-params", this.remotePageParams.bind(this)), this.subscribe("data-loaded", this._parseRemoteData.bind(this)), this.subscribe("table-built", this.calculatePageSizes.bind(this)), this.subscribe("data-processed", this.initialLoadComplete.bind(this)), this.initializeProgressive(this.table.options.progressiveLoad), this.table.options.progressiveLoad === "scroll" && this.subscribe("scroll-vertical", this.scrollVertical.bind(this)));
  }
  rowAddingPosition(e, t) {
    var i = this.table.rowManager, n = i.getDisplayRows(), a;
    return t ? n.length ? a = n[0] : i.activeRows.length && (a = i.activeRows[i.activeRows.length - 1], t = !1) : n.length && (a = n[n.length - 1], t = !(n.length < this.size)), { index: a, top: t };
  }
  calculatePageSizes() {
    var e, t;
    this.table.options.paginationSize ? this.size = this.table.options.paginationSize : (e = document.createElement("div"), e.classList.add("tabulator-row"), e.style.visibility = "hidden", t = document.createElement("div"), t.classList.add("tabulator-cell"), t.innerHTML = "Page Row Test", e.appendChild(t), this.table.rowManager.getTableElement().appendChild(e), this.size = Math.floor(this.table.rowManager.getElement().clientHeight / e.offsetHeight), this.table.rowManager.getTableElement().removeChild(e)), this.dispatchExternal("pageSizeChanged", this.size), this.generatePageSizeSelectList();
  }
  initialLoadComplete() {
    this.initialLoad = !1;
  }
  remotePageParams(e, t, i, n) {
    return this.initialLoad || (this.progressiveLoad && !i || !this.progressiveLoad && !this.dataChanging) && this.reset(!0), n.page = this.page, this.size && (n.size = this.size), n;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetPageToRow(e) {
    return this.table.options.pagination && (e = this.rowManager.findRow(e), e) ? this.setPageToRow(e) : Promise.reject();
  }
  userSetPageSize(e) {
    return this.table.options.pagination ? (this.setPageSize(e), this.setPage(1)) : !1;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  scrollVertical(e, t) {
    var i, n, a;
    !t && !this.table.dataLoader.loading && (i = this.table.rowManager.getElement(), n = i.scrollHeight - i.clientHeight - e, a = this.table.options.progressiveLoadScrollMargin || i.clientHeight * 2, n < a && this.nextPage().catch(() => {
    }));
  }
  restOnRenderBefore(e, t) {
    return t || this.mode === "local" && this.reset(), e;
  }
  rowsUpdated() {
    this.refreshData(!0, "all");
  }
  createElements() {
    var e;
    this.element = document.createElement("span"), this.element.classList.add("tabulator-paginator"), this.pagesElement = document.createElement("span"), this.pagesElement.classList.add("tabulator-pages"), e = document.createElement("button"), e.classList.add("tabulator-page"), e.setAttribute("type", "button"), e.setAttribute("role", "button"), e.setAttribute("aria-label", ""), e.setAttribute("title", ""), this.firstBut = e.cloneNode(!0), this.firstBut.setAttribute("data-page", "first"), this.prevBut = e.cloneNode(!0), this.prevBut.setAttribute("data-page", "prev"), this.nextBut = e.cloneNode(!0), this.nextBut.setAttribute("data-page", "next"), this.lastBut = e.cloneNode(!0), this.lastBut.setAttribute("data-page", "last"), this.table.options.paginationSizeSelector && (this.pageSizeSelect = document.createElement("select"), this.pageSizeSelect.classList.add("tabulator-page-size"));
  }
  generatePageSizeSelectList() {
    var e = [];
    if (this.pageSizeSelect) {
      if (Array.isArray(this.table.options.paginationSizeSelector))
        e = this.table.options.paginationSizeSelector, this.pageSizes = e, this.pageSizes.indexOf(this.size) == -1 && e.unshift(this.size);
      else if (this.pageSizes.indexOf(this.size) == -1) {
        e = [];
        for (let t = 1; t < 5; t++)
          e.push(this.size * t);
        this.pageSizes = e;
      } else
        e = this.pageSizes;
      for (; this.pageSizeSelect.firstChild; )
        this.pageSizeSelect.removeChild(this.pageSizeSelect.firstChild);
      e.forEach((t) => {
        var i = document.createElement("option");
        i.value = t, t === !0 ? this.langBind("pagination|all", function(n) {
          i.innerHTML = n;
        }) : i.innerHTML = t, this.pageSizeSelect.appendChild(i);
      }), this.pageSizeSelect.value = this.size;
    }
  }
  initializePageCounter() {
    var e = this.table.options.paginationCounter, t = null;
    e && (typeof e == "function" ? t = e : t = Od.pageCounters[e], t ? (this.pageCounter = t, this.pageCounterElement = document.createElement("span"), this.pageCounterElement.classList.add("tabulator-page-counter")) : console.warn("Pagination Error - No such page counter found: ", e));
  }
  //setup pagination
  initializePaginator(e) {
    var t, i;
    e || (this.langBind("pagination|first", (n) => {
      this.firstBut.innerHTML = n;
    }), this.langBind("pagination|first_title", (n) => {
      this.firstBut.setAttribute("aria-label", n), this.firstBut.setAttribute("title", n);
    }), this.langBind("pagination|prev", (n) => {
      this.prevBut.innerHTML = n;
    }), this.langBind("pagination|prev_title", (n) => {
      this.prevBut.setAttribute("aria-label", n), this.prevBut.setAttribute("title", n);
    }), this.langBind("pagination|next", (n) => {
      this.nextBut.innerHTML = n;
    }), this.langBind("pagination|next_title", (n) => {
      this.nextBut.setAttribute("aria-label", n), this.nextBut.setAttribute("title", n);
    }), this.langBind("pagination|last", (n) => {
      this.lastBut.innerHTML = n;
    }), this.langBind("pagination|last_title", (n) => {
      this.lastBut.setAttribute("aria-label", n), this.lastBut.setAttribute("title", n);
    }), this.firstBut.addEventListener("click", () => {
      this.setPage(1);
    }), this.prevBut.addEventListener("click", () => {
      this.previousPage();
    }), this.nextBut.addEventListener("click", () => {
      this.nextPage();
    }), this.lastBut.addEventListener("click", () => {
      this.setPage(this.max);
    }), this.table.options.paginationElement && (this.element = this.table.options.paginationElement), this.pageSizeSelect && (t = document.createElement("label"), this.langBind("pagination|page_size", (n) => {
      this.pageSizeSelect.setAttribute("aria-label", n), this.pageSizeSelect.setAttribute("title", n), t.innerHTML = n;
    }), this.element.appendChild(t), this.element.appendChild(this.pageSizeSelect), this.pageSizeSelect.addEventListener("change", (n) => {
      this.setPageSize(this.pageSizeSelect.value == "true" ? !0 : this.pageSizeSelect.value), this.setPage(1);
    })), this.element.appendChild(this.firstBut), this.element.appendChild(this.prevBut), this.element.appendChild(this.pagesElement), this.element.appendChild(this.nextBut), this.element.appendChild(this.lastBut), this.table.options.paginationElement || (this.table.options.paginationCounter && (this.table.options.paginationCounterElement ? this.table.options.paginationCounterElement instanceof HTMLElement ? this.table.options.paginationCounterElement.appendChild(this.pageCounterElement) : typeof this.table.options.paginationCounterElement == "string" && (i = document.querySelector(this.table.options.paginationCounterElement), i ? i.appendChild(this.pageCounterElement) : console.warn("Pagination Error - Unable to find element matching paginationCounterElement selector:", this.table.options.paginationCounterElement)) : this.footerAppend(this.pageCounterElement)), this.footerAppend(this.element)), this.page = this.table.options.paginationInitialPage, this.count = this.table.options.paginationButtonCount), this.mode = this.table.options.paginationMode;
  }
  initializeProgressive(e) {
    this.initializePaginator(!0), this.mode = "progressive_" + e, this.progressiveLoad = !0;
  }
  trackChanges() {
    this.dispatch("page-changed");
  }
  //calculate maximum page from number of rows
  setMaxRows(e) {
    e ? this.max = this.size === !0 ? 1 : Math.ceil(e / this.size) : this.max = 1, this.page > this.max && (this.page = this.max);
  }
  //reset to first page without triggering action
  reset(e) {
    this.initialLoad || (this.mode == "local" || e) && (this.page = 1, this.trackChanges());
  }
  //set the maximum page
  setMaxPage(e) {
    e = parseInt(e), this.max = e || 1, this.page > this.max && (this.page = this.max, this.trigger());
  }
  //set current page number
  setPage(e) {
    switch (e) {
      case "first":
        return this.setPage(1);
      case "prev":
        return this.previousPage();
      case "next":
        return this.nextPage();
      case "last":
        return this.setPage(this.max);
    }
    return e = parseInt(e), e > 0 && e <= this.max || this.mode !== "local" ? (this.page = e, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Requested page is out of range of 1 - " + this.max + ":", e), Promise.reject());
  }
  setPageToRow(e) {
    var t = this.displayRows(-1), i = t.indexOf(e);
    if (i > -1) {
      var n = this.size === !0 ? 1 : Math.ceil((i + 1) / this.size);
      return this.setPage(n);
    } else
      return console.warn("Pagination Error - Requested row is not visible"), Promise.reject();
  }
  setPageSize(e) {
    e !== !0 && (e = parseInt(e)), e > 0 && (this.size = e, this.dispatchExternal("pageSizeChanged", e)), this.pageSizeSelect && this.generatePageSizeSelectList(), this.trackChanges();
  }
  _setPageCounter(e, t, i) {
    var n;
    if (this.pageCounter)
      switch (this.mode === "remote" && (t = this.size, i = (this.page - 1) * this.size + 1, e = this.remoteRowCountEstimate), n = this.pageCounter.call(this, t, i, this.page, e, this.max), typeof n) {
        case "object":
          if (n instanceof Node) {
            for (; this.pageCounterElement.firstChild; )
              this.pageCounterElement.removeChild(this.pageCounterElement.firstChild);
            this.pageCounterElement.appendChild(n);
          } else
            this.pageCounterElement.innerHTML = "", n != null && console.warn("Page Counter Error - Page Counter has returned a type of object, the only valid page counter object return is an instance of Node, the page counter returned:", n);
          break;
        case "undefined":
          this.pageCounterElement.innerHTML = "";
          break;
        default:
          this.pageCounterElement.innerHTML = n;
      }
  }
  //setup the pagination buttons
  _setPageButtons() {
    let e = Math.floor((this.count - 1) / 2), t = Math.ceil((this.count - 1) / 2), i = this.max - this.page + e + 1 < this.count ? this.max - this.count + 1 : Math.max(this.page - e, 1), n = this.page <= t ? Math.min(this.count, this.max) : Math.min(this.page + t, this.max);
    for (; this.pagesElement.firstChild; )
      this.pagesElement.removeChild(this.pagesElement.firstChild);
    this.page == 1 ? (this.firstBut.disabled = !0, this.prevBut.disabled = !0) : (this.firstBut.disabled = !1, this.prevBut.disabled = !1), this.page == this.max ? (this.lastBut.disabled = !0, this.nextBut.disabled = !0) : (this.lastBut.disabled = !1, this.nextBut.disabled = !1);
    for (let a = i; a <= n; a++)
      a > 0 && a <= this.max && this.pagesElement.appendChild(this._generatePageButton(a));
    this.footerRedraw();
  }
  _generatePageButton(e) {
    var t = document.createElement("button");
    return t.classList.add("tabulator-page"), e == this.page && t.classList.add("active"), t.setAttribute("type", "button"), t.setAttribute("role", "button"), this.langBind("pagination|page_title", (i) => {
      t.setAttribute("aria-label", i + " " + e), t.setAttribute("title", i + " " + e);
    }), t.setAttribute("data-page", e), t.textContent = e, t.addEventListener("click", (i) => {
      this.setPage(e);
    }), t;
  }
  //previous page
  previousPage() {
    return this.page > 1 ? (this.page--, this.trackChanges(), this.trigger()) : (console.warn("Pagination Error - Previous page would be less than page 1:", 0), Promise.reject());
  }
  //next page
  nextPage() {
    return this.page < this.max ? (this.page++, this.trackChanges(), this.trigger()) : (this.progressiveLoad || console.warn("Pagination Error - Next page would be greater than maximum page of " + this.max + ":", this.max + 1), Promise.reject());
  }
  //return current page number
  getPage() {
    return this.page;
  }
  //return max page number
  getPageMax() {
    return this.max;
  }
  getPageSize(e) {
    return this.size;
  }
  getMode() {
    return this.mode;
  }
  //return appropriate rows for current page
  getRows(e) {
    var t = 0, i, n, a, o, s = e.filter((l) => l.type === "row");
    if (this.mode == "local") {
      i = [], this.setMaxRows(e.length), this.size === !0 ? (n = 0, a = e.length) : (n = this.size * (this.page - 1), a = n + parseInt(this.size)), this._setPageButtons();
      for (let l = n; l < a; l++) {
        let u = e[l];
        u && (i.push(u), u.type === "row" && (o || (o = u), t++));
      }
      return this._setPageCounter(s.length, t, o ? s.indexOf(o) + 1 : 0), i;
    } else
      return this._setPageButtons(), this._setPageCounter(s.length), e.slice(0);
  }
  trigger() {
    var e;
    switch (this.mode) {
      case "local":
        return e = this.table.rowManager.scrollLeft, this.refreshData(), this.table.rowManager.scrollHorizontal(e), this.dispatchExternal("pageLoaded", this.getPage()), Promise.resolve();
      case "remote":
        return this.dataChanging = !0, this.reloadData(null).finally(() => {
          this.dataChanging = !1;
        });
      case "progressive_load":
      case "progressive_scroll":
        return this.reloadData(null, !0);
      default:
        return console.warn("Pagination Error - no such pagination mode:", this.mode), Promise.reject();
    }
  }
  _parseRemoteData(e) {
    var t;
    if (typeof e.last_page > "u" && console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").last_page || "last_page") + "' property"), e.data)
      if (this.max = parseInt(e.last_page) || 1, this.remoteRowCountEstimate = typeof e.last_row < "u" ? e.last_row : e.last_page * this.size - (this.page == e.last_page ? this.size - e.data.length : 0), this.progressiveLoad) {
        switch (this.mode) {
          case "progressive_load":
            this.page == 1 ? this.table.rowManager.setData(e.data, !1, this.page == 1) : this.table.rowManager.addRows(e.data), this.page < this.max && setTimeout(() => {
              this.nextPage();
            }, this.table.options.progressiveLoadDelay);
            break;
          case "progressive_scroll":
            e = this.page === 1 ? e.data : this.table.rowManager.getData().concat(e.data), this.table.rowManager.setData(e, this.page !== 1, this.page == 1), t = this.table.options.progressiveLoadScrollMargin || this.table.rowManager.element.clientHeight * 2, this.table.rowManager.element.scrollHeight <= this.table.rowManager.element.clientHeight + t && this.page < this.max && setTimeout(() => {
              this.nextPage();
            });
            break;
        }
        return !1;
      } else
        this.dispatchExternal("pageLoaded", this.getPage());
    else
      console.warn("Remote Pagination Error - Server response missing '" + (this.options("dataReceiveParams").data || "data") + "' property");
    return e.data;
  }
  //handle the footer element being redrawn
  footerRedraw() {
    var e = this.table.footerManager.containerElement;
    Math.ceil(e.clientWidth) - e.scrollWidth < 0 ? this.pagesElement.style.display = "none" : (this.pagesElement.style.display = "", Math.ceil(e.clientWidth) - e.scrollWidth < 0 && (this.pagesElement.style.display = "none"));
  }
}
Od.moduleName = "page";
Od.pageCounters = BGe;
var FGe = {
  local: function(r, e) {
    var t = localStorage.getItem(r + "-" + e);
    return t ? JSON.parse(t) : !1;
  },
  cookie: function(r, e) {
    var t = document.cookie, i = r + "-" + e, n = t.indexOf(i + "="), a, o;
    return n > -1 && (t = t.slice(n), a = t.indexOf(";"), a > -1 && (t = t.slice(0, a)), o = t.replace(i + "=", "")), o ? JSON.parse(o) : !1;
  }
}, XGe = {
  local: function(r, e, t) {
    localStorage.setItem(r + "-" + e, JSON.stringify(t));
  },
  cookie: function(r, e, t) {
    var i = /* @__PURE__ */ new Date();
    i.setDate(i.getDate() + 1e4), document.cookie = r + "-" + e + "=" + JSON.stringify(t) + "; expires=" + i.toUTCString();
  }
};
class wi extends mt {
  constructor(e) {
    super(e), this.mode = "", this.id = "", this.defWatcherBlock = !1, this.config = {}, this.readFunc = !1, this.writeFunc = !1, this.registerTableOption("persistence", !1), this.registerTableOption("persistenceID", ""), this.registerTableOption("persistenceMode", !0), this.registerTableOption("persistenceReaderFunc", !1), this.registerTableOption("persistenceWriterFunc", !1);
  }
  // Test for whether localStorage is available for use.
  localStorageTest() {
    var e = "_tabulator_test";
    try {
      return window.localStorage.setItem(e, e), window.localStorage.removeItem(e), !0;
    } catch {
      return !1;
    }
  }
  //setup parameters
  initialize() {
    if (this.table.options.persistence) {
      var e = this.table.options.persistenceMode, t = this.table.options.persistenceID, i;
      this.mode = e !== !0 ? e : this.localStorageTest() ? "local" : "cookie", this.table.options.persistenceReaderFunc ? typeof this.table.options.persistenceReaderFunc == "function" ? this.readFunc = this.table.options.persistenceReaderFunc : wi.readers[this.table.options.persistenceReaderFunc] ? this.readFunc = wi.readers[this.table.options.persistenceReaderFunc] : console.warn("Persistence Read Error - invalid reader set", this.table.options.persistenceReaderFunc) : wi.readers[this.mode] ? this.readFunc = wi.readers[this.mode] : console.warn("Persistence Read Error - invalid reader set", this.mode), this.table.options.persistenceWriterFunc ? typeof this.table.options.persistenceWriterFunc == "function" ? this.writeFunc = this.table.options.persistenceWriterFunc : wi.writers[this.table.options.persistenceWriterFunc] ? this.writeFunc = wi.writers[this.table.options.persistenceWriterFunc] : console.warn("Persistence Write Error - invalid reader set", this.table.options.persistenceWriterFunc) : wi.writers[this.mode] ? this.writeFunc = wi.writers[this.mode] : console.warn("Persistence Write Error - invalid writer set", this.mode), this.id = "tabulator-" + (t || this.table.element.getAttribute("id") || ""), this.config = {
        sort: this.table.options.persistence === !0 || this.table.options.persistence.sort,
        filter: this.table.options.persistence === !0 || this.table.options.persistence.filter,
        headerFilter: this.table.options.persistence === !0 || this.table.options.persistence.headerFilter,
        group: this.table.options.persistence === !0 || this.table.options.persistence.group,
        page: this.table.options.persistence === !0 || this.table.options.persistence.page,
        columns: this.table.options.persistence === !0 ? ["title", "width", "visible"] : this.table.options.persistence.columns
      }, this.config.page && (i = this.retrieveData("page"), i && (typeof i.paginationSize < "u" && (this.config.page === !0 || this.config.page.size) && (this.table.options.paginationSize = i.paginationSize), typeof i.paginationInitialPage < "u" && (this.config.page === !0 || this.config.page.page) && (this.table.options.paginationInitialPage = i.paginationInitialPage))), this.config.group && (i = this.retrieveData("group"), i && (typeof i.groupBy < "u" && (this.config.group === !0 || this.config.group.groupBy) && (this.table.options.groupBy = i.groupBy), typeof i.groupStartOpen < "u" && (this.config.group === !0 || this.config.group.groupStartOpen) && (this.table.options.groupStartOpen = i.groupStartOpen), typeof i.groupHeader < "u" && (this.config.group === !0 || this.config.group.groupHeader) && (this.table.options.groupHeader = i.groupHeader))), this.config.columns && (this.table.options.columns = this.load("columns", this.table.options.columns), this.subscribe("column-init", this.initializeColumn.bind(this)), this.subscribe("column-show", this.save.bind(this, "columns")), this.subscribe("column-hide", this.save.bind(this, "columns")), this.subscribe("column-moved", this.save.bind(this, "columns"))), this.subscribe("table-built", this.tableBuilt.bind(this), 0), this.subscribe("table-redraw", this.tableRedraw.bind(this)), this.subscribe("filter-changed", this.eventSave.bind(this, "filter")), this.subscribe("filter-changed", this.eventSave.bind(this, "headerFilter")), this.subscribe("sort-changed", this.eventSave.bind(this, "sort")), this.subscribe("group-changed", this.eventSave.bind(this, "group")), this.subscribe("page-changed", this.eventSave.bind(this, "page")), this.subscribe("column-resized", this.eventSave.bind(this, "columns")), this.subscribe("column-width", this.eventSave.bind(this, "columns")), this.subscribe("layout-refreshed", this.eventSave.bind(this, "columns"));
    }
    this.registerTableFunction("getColumnLayout", this.getColumnLayout.bind(this)), this.registerTableFunction("setColumnLayout", this.setColumnLayout.bind(this));
  }
  eventSave(e) {
    this.config[e] && this.save(e);
  }
  tableBuilt() {
    var e, t, i;
    this.config.sort && (e = this.load("sort"), e && (this.table.options.initialSort = e)), this.config.filter && (t = this.load("filter"), t && (this.table.options.initialFilter = t)), this.config.headerFilter && (i = this.load("headerFilter"), i && (this.table.options.initialHeaderFilter = i));
  }
  tableRedraw(e) {
    e && this.config.columns && this.save("columns");
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  getColumnLayout() {
    return this.parseColumns(this.table.columnManager.getColumns());
  }
  setColumnLayout(e) {
    return this.table.columnManager.setColumns(this.mergeDefinition(this.table.options.columns, e)), !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumn(e) {
    var t, i;
    this.config.columns && (this.defWatcherBlock = !0, t = e.getDefinition(), i = this.config.columns === !0 ? Object.keys(t) : this.config.columns, i.forEach((n) => {
      var a = Object.getOwnPropertyDescriptor(t, n), o = t[n];
      a && Object.defineProperty(t, n, {
        set: (s) => {
          o = s, this.defWatcherBlock || this.save("columns"), a.set && a.set(s);
        },
        get: () => (a.get && a.get(), o)
      });
    }), this.defWatcherBlock = !1);
  }
  //load saved definitions
  load(e, t) {
    var i = this.retrieveData(e);
    return t && (i = i ? this.mergeDefinition(t, i) : t), i;
  }
  //retrieve data from memory
  retrieveData(e) {
    return this.readFunc ? this.readFunc(this.id, e) : !1;
  }
  //merge old and new column definitions
  mergeDefinition(e, t) {
    var i = [];
    return t = t || [], t.forEach((n, a) => {
      var o = this._findColumn(e, n), s;
      o && (this.config.columns === !0 || this.config.columns == null ? (s = Object.keys(o), s.push("width")) : s = this.config.columns, s.forEach((l) => {
        l !== "columns" && typeof n[l] < "u" && (o[l] = n[l]);
      }), o.columns && (o.columns = this.mergeDefinition(o.columns, n.columns)), i.push(o));
    }), e.forEach((n, a) => {
      var o = this._findColumn(t, n);
      o || (i.length > a ? i.splice(a, 0, n) : i.push(n));
    }), i;
  }
  //find matching columns
  _findColumn(e, t) {
    var i = t.columns ? "group" : t.field ? "field" : "object";
    return e.find(function(n) {
      switch (i) {
        case "group":
          return n.title === t.title && n.columns.length === t.columns.length;
        case "field":
          return n.field === t.field;
        case "object":
          return n === t;
      }
    });
  }
  //save data
  save(e) {
    var t = {};
    switch (e) {
      case "columns":
        t = this.parseColumns(this.table.columnManager.getColumns());
        break;
      case "filter":
        t = this.table.modules.filter.getFilters();
        break;
      case "headerFilter":
        t = this.table.modules.filter.getHeaderFilters();
        break;
      case "sort":
        t = this.validateSorters(this.table.modules.sort.getSort());
        break;
      case "group":
        t = this.getGroupConfig();
        break;
      case "page":
        t = this.getPageConfig();
        break;
    }
    this.writeFunc && this.writeFunc(this.id, e, t);
  }
  //ensure sorters contain no function data
  validateSorters(e) {
    return e.forEach(function(t) {
      t.column = t.field, delete t.field;
    }), e;
  }
  getGroupConfig() {
    var e = {};
    return this.config.group && ((this.config.group === !0 || this.config.group.groupBy) && (e.groupBy = this.table.options.groupBy), (this.config.group === !0 || this.config.group.groupStartOpen) && (e.groupStartOpen = this.table.options.groupStartOpen), (this.config.group === !0 || this.config.group.groupHeader) && (e.groupHeader = this.table.options.groupHeader)), e;
  }
  getPageConfig() {
    var e = {};
    return this.config.page && ((this.config.page === !0 || this.config.page.size) && (e.paginationSize = this.table.modules.page.getPageSize()), (this.config.page === !0 || this.config.page.page) && (e.paginationInitialPage = this.table.modules.page.getPage())), e;
  }
  //parse columns for data to store
  parseColumns(e) {
    var t = [], i = ["headerContextMenu", "headerMenu", "contextMenu", "clickMenu"];
    return e.forEach((n) => {
      var a = {}, o = n.getDefinition(), s;
      n.isGroup ? (a.title = o.title, a.columns = this.parseColumns(n.getColumns())) : (a.field = n.getField(), this.config.columns === !0 || this.config.columns == null ? (s = Object.keys(o), s.push("width"), s.push("visible")) : s = this.config.columns, s.forEach((l) => {
        switch (l) {
          case "width":
            a.width = n.getWidth();
            break;
          case "visible":
            a.visible = n.visible;
            break;
          default:
            typeof o[l] != "function" && i.indexOf(l) === -1 && (a[l] = o[l]);
        }
      })), t.push(a);
    }), t;
  }
}
wi.moduleName = "persistence";
wi.moduleInitOrder = -10;
wi.readers = FGe;
wi.writers = XGe;
class GP extends mt {
  constructor(e) {
    super(e), this.columnSubscribers = {}, this.registerTableOption("rowContextPopup", !1), this.registerTableOption("rowClickPopup", !1), this.registerTableOption("rowDblClickPopup", !1), this.registerTableOption("groupContextPopup", !1), this.registerTableOption("groupClickPopup", !1), this.registerTableOption("groupDblClickPopup", !1), this.registerColumnOption("headerContextPopup"), this.registerColumnOption("headerClickPopup"), this.registerColumnOption("headerDblClickPopup"), this.registerColumnOption("headerPopup"), this.registerColumnOption("headerPopupIcon"), this.registerColumnOption("contextPopup"), this.registerColumnOption("clickPopup"), this.registerColumnOption("dblClickPopup"), this.registerComponentFunction("cell", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("column", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("row", "popup", this._componentPopupCall.bind(this)), this.registerComponentFunction("group", "popup", this._componentPopupCall.bind(this));
  }
  initialize() {
    this.initializeRowWatchers(), this.initializeGroupWatchers(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  _componentPopupCall(e, t, i) {
    this.loadPopupEvent(t, null, e, i);
  }
  initializeRowWatchers() {
    this.table.options.rowContextPopup && (this.subscribe("row-contextmenu", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup)), this.table.on("rowTapHold", this.loadPopupEvent.bind(this, this.table.options.rowContextPopup))), this.table.options.rowClickPopup && this.subscribe("row-click", this.loadPopupEvent.bind(this, this.table.options.rowClickPopup)), this.table.options.rowDblClickPopup && this.subscribe("row-dblclick", this.loadPopupEvent.bind(this, this.table.options.rowDblClickPopup));
  }
  initializeGroupWatchers() {
    this.table.options.groupContextPopup && (this.subscribe("group-contextmenu", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup)), this.table.on("groupTapHold", this.loadPopupEvent.bind(this, this.table.options.groupContextPopup))), this.table.options.groupClickPopup && this.subscribe("group-click", this.loadPopupEvent.bind(this, this.table.options.groupClickPopup)), this.table.options.groupDblClickPopup && this.subscribe("group-dblclick", this.loadPopupEvent.bind(this, this.table.options.groupDblClickPopup));
  }
  initializeColumn(e) {
    var t = e.definition;
    t.headerContextPopup && !this.columnSubscribers.headerContextPopup && (this.columnSubscribers.headerContextPopup = this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"), this.subscribe("column-contextmenu", this.columnSubscribers.headerContextPopup), this.table.on("headerTapHold", this.loadPopupTableColumnEvent.bind(this, "headerContextPopup"))), t.headerClickPopup && !this.columnSubscribers.headerClickPopup && (this.columnSubscribers.headerClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerClickPopup"), this.subscribe("column-click", this.columnSubscribers.headerClickPopup)), t.headerDblClickPopup && !this.columnSubscribers.headerDblClickPopup && (this.columnSubscribers.headerDblClickPopup = this.loadPopupTableColumnEvent.bind(this, "headerDblClickPopup"), this.subscribe("column-dblclick", this.columnSubscribers.headerDblClickPopup)), t.headerPopup && this.initializeColumnHeaderPopup(e), t.contextPopup && !this.columnSubscribers.contextPopup && (this.columnSubscribers.contextPopup = this.loadPopupTableCellEvent.bind(this, "contextPopup"), this.subscribe("cell-contextmenu", this.columnSubscribers.contextPopup), this.table.on("cellTapHold", this.loadPopupTableCellEvent.bind(this, "contextPopup"))), t.clickPopup && !this.columnSubscribers.clickPopup && (this.columnSubscribers.clickPopup = this.loadPopupTableCellEvent.bind(this, "clickPopup"), this.subscribe("cell-click", this.columnSubscribers.clickPopup)), t.dblClickPopup && !this.columnSubscribers.dblClickPopup && (this.columnSubscribers.dblClickPopup = this.loadPopupTableCellEvent.bind(this, "dblClickPopup"), this.subscribe("cell-click", this.columnSubscribers.dblClickPopup));
  }
  initializeColumnHeaderPopup(e) {
    var t = e.definition.headerPopupIcon, i;
    i = document.createElement("span"), i.classList.add("tabulator-header-popup-button"), t ? (typeof t == "function" && (t = t(e.getComponent())), t instanceof HTMLElement ? i.appendChild(t) : i.innerHTML = t) : i.innerHTML = "&vellip;", i.addEventListener("click", (n) => {
      n.stopPropagation(), n.preventDefault(), this.loadPopupEvent(e.definition.headerPopup, n, e);
    }), e.titleElement.insertBefore(i, e.titleElement.firstChild);
  }
  loadPopupTableCellEvent(e, t, i) {
    i._cell && (i = i._cell), i.column.definition[e] && this.loadPopupEvent(i.column.definition[e], t, i);
  }
  loadPopupTableColumnEvent(e, t, i) {
    i._column && (i = i._column), i.definition[e] && this.loadPopupEvent(i.definition[e], t, i);
  }
  loadPopupEvent(e, t, i, n) {
    var a;
    function o(s) {
      a = s;
    }
    i._group ? i = i._group : i._row && (i = i._row), e = typeof e == "function" ? e.call(this.table, t, i.getComponent(), o) : e, this.loadPopup(t, i, e, a, n);
  }
  loadPopup(e, t, i, n, a) {
    var o = !(e instanceof MouseEvent), s, l;
    i instanceof HTMLElement ? s = i : (s = document.createElement("div"), s.innerHTML = i), s.classList.add("tabulator-popup"), s.addEventListener("click", (u) => {
      u.stopPropagation();
    }), o || e.preventDefault(), l = this.popup(s), typeof n == "function" && l.renderCallback(n), e ? l.show(e) : l.show(t.getElement(), a || "center"), l.hideOnBlur(() => {
      this.dispatchExternal("popupClosed", t.getComponent());
    }), this.dispatchExternal("popupOpened", t.getComponent());
  }
}
GP.moduleName = "popup";
class BP extends mt {
  constructor(e) {
    super(e), this.element = !1, this.manualBlock = !1, this.beforeprintEventHandler = null, this.afterprintEventHandler = null, this.registerTableOption("printAsHtml", !1), this.registerTableOption("printFormatter", !1), this.registerTableOption("printHeader", !1), this.registerTableOption("printFooter", !1), this.registerTableOption("printStyled", !0), this.registerTableOption("printRowRange", "visible"), this.registerTableOption("printConfig", {}), this.registerColumnOption("print"), this.registerColumnOption("titlePrint");
  }
  initialize() {
    this.table.options.printAsHtml && (this.beforeprintEventHandler = this.replaceTable.bind(this), this.afterprintEventHandler = this.cleanup.bind(this), window.addEventListener("beforeprint", this.beforeprintEventHandler), window.addEventListener("afterprint", this.afterprintEventHandler), this.subscribe("table-destroy", this.destroy.bind(this))), this.registerTableFunction("print", this.printFullscreen.bind(this));
  }
  destroy() {
    this.table.options.printAsHtml && (window.removeEventListener("beforeprint", this.beforeprintEventHandler), window.removeEventListener("afterprint", this.afterprintEventHandler));
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  replaceTable() {
    this.manualBlock || (this.element = document.createElement("div"), this.element.classList.add("tabulator-print-table"), this.element.appendChild(this.table.modules.export.generateTable(this.table.options.printConfig, this.table.options.printStyled, this.table.options.printRowRange, "print")), this.table.element.style.display = "none", this.table.element.parentNode.insertBefore(this.element, this.table.element));
  }
  cleanup() {
    document.body.classList.remove("tabulator-print-fullscreen-hide"), this.element && this.element.parentNode && (this.element.parentNode.removeChild(this.element), this.table.element.style.display = "");
  }
  printFullscreen(e, t, i) {
    var n = window.scrollX, a = window.scrollY, o = document.createElement("div"), s = document.createElement("div"), l = this.table.modules.export.generateTable(typeof i < "u" ? i : this.table.options.printConfig, typeof t < "u" ? t : this.table.options.printStyled, e || this.table.options.printRowRange, "print"), u, c;
    this.manualBlock = !0, this.element = document.createElement("div"), this.element.classList.add("tabulator-print-fullscreen"), this.table.options.printHeader && (o.classList.add("tabulator-print-header"), u = typeof this.table.options.printHeader == "function" ? this.table.options.printHeader.call(this.table) : this.table.options.printHeader, typeof u == "string" ? o.innerHTML = u : o.appendChild(u), this.element.appendChild(o)), this.element.appendChild(l), this.table.options.printFooter && (s.classList.add("tabulator-print-footer"), c = typeof this.table.options.printFooter == "function" ? this.table.options.printFooter.call(this.table) : this.table.options.printFooter, typeof c == "string" ? s.innerHTML = c : s.appendChild(c), this.element.appendChild(s)), document.body.classList.add("tabulator-print-fullscreen-hide"), document.body.appendChild(this.element), this.table.options.printFormatter && this.table.options.printFormatter(this.element, l), window.print(), this.cleanup(), window.scrollTo(n, a), this.manualBlock = !1;
  }
}
BP.moduleName = "print";
class FP extends mt {
  constructor(e) {
    super(e), this.data = !1, this.blocked = !1, this.origFuncs = {}, this.currentVersion = 0, this.registerTableOption("reactiveData", !1);
  }
  initialize() {
    this.table.options.reactiveData && (this.subscribe("cell-value-save-before", this.block.bind(this, "cellsave")), this.subscribe("cell-value-save-after", this.unblock.bind(this, "cellsave")), this.subscribe("row-data-save-before", this.block.bind(this, "rowsave")), this.subscribe("row-data-save-after", this.unblock.bind(this, "rowsave")), this.subscribe("row-data-init-after", this.watchRow.bind(this)), this.subscribe("data-processing", this.watchData.bind(this)), this.subscribe("table-destroy", this.unwatchData.bind(this)));
  }
  watchData(e) {
    var t = this, i;
    this.currentVersion++, i = this.currentVersion, this.unwatchData(), this.data = e, this.origFuncs.push = e.push, Object.defineProperty(this.data, "push", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n = Array.from(arguments), a;
        return !t.blocked && i === t.currentVersion && (t.block("data-push"), n.forEach((o) => {
          t.table.rowManager.addRowActual(o, !1);
        }), a = t.origFuncs.push.apply(e, arguments), t.unblock("data-push")), a;
      }
    }), this.origFuncs.unshift = e.unshift, Object.defineProperty(this.data, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n = Array.from(arguments), a;
        return !t.blocked && i === t.currentVersion && (t.block("data-unshift"), n.forEach((o) => {
          t.table.rowManager.addRowActual(o, !0);
        }), a = t.origFuncs.unshift.apply(e, arguments), t.unblock("data-unshift")), a;
      }
    }), this.origFuncs.shift = e.shift, Object.defineProperty(this.data, "shift", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n, a;
        return !t.blocked && i === t.currentVersion && (t.block("data-shift"), t.data.length && (n = t.table.rowManager.getRowFromDataObject(t.data[0]), n && n.deleteActual()), a = t.origFuncs.shift.call(e), t.unblock("data-shift")), a;
      }
    }), this.origFuncs.pop = e.pop, Object.defineProperty(this.data, "pop", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n, a;
        return !t.blocked && i === t.currentVersion && (t.block("data-pop"), t.data.length && (n = t.table.rowManager.getRowFromDataObject(t.data[t.data.length - 1]), n && n.deleteActual()), a = t.origFuncs.pop.call(e), t.unblock("data-pop")), a;
      }
    }), this.origFuncs.splice = e.splice, Object.defineProperty(this.data, "splice", {
      enumerable: !1,
      configurable: !0,
      value: function() {
        var n = Array.from(arguments), a = n[0] < 0 ? e.length + n[0] : n[0], o = n[1], s = n[2] ? n.slice(2) : !1, l, u;
        if (!t.blocked && i === t.currentVersion) {
          if (t.block("data-splice"), s && (l = e[a] ? t.table.rowManager.getRowFromDataObject(e[a]) : !1, l ? s.forEach((h) => {
            t.table.rowManager.addRowActual(h, !0, l, !0);
          }) : (s = s.slice().reverse(), s.forEach((h) => {
            t.table.rowManager.addRowActual(h, !0, !1, !0);
          }))), o !== 0) {
            var c = e.slice(a, typeof n[1] > "u" ? n[1] : a + o);
            c.forEach((h, f) => {
              var d = t.table.rowManager.getRowFromDataObject(h);
              d && d.deleteActual(f !== c.length - 1);
            });
          }
          (s || o !== 0) && t.table.rowManager.reRenderInPosition(), u = t.origFuncs.splice.apply(e, arguments), t.unblock("data-splice");
        }
        return u;
      }
    });
  }
  unwatchData() {
    if (this.data !== !1)
      for (var e in this.origFuncs)
        Object.defineProperty(this.data, e, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: this.origFuncs.key
        });
  }
  watchRow(e) {
    var t = e.getData();
    for (var i in t)
      this.watchKey(e, t, i);
    this.table.options.dataTree && this.watchTreeChildren(e);
  }
  watchTreeChildren(e) {
    var t = this, i = e.getData()[this.table.options.dataTreeChildField], n = {};
    i && (n.push = i.push, Object.defineProperty(i, "push", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-push");
          var a = n.push.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-push");
        }
        return a;
      }
    }), n.unshift = i.unshift, Object.defineProperty(i, "unshift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-unshift");
          var a = n.unshift.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-unshift");
        }
        return a;
      }
    }), n.shift = i.shift, Object.defineProperty(i, "shift", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-shift");
          var a = n.shift.call(i);
          this.rebuildTree(e), t.unblock("tree-shift");
        }
        return a;
      }
    }), n.pop = i.pop, Object.defineProperty(i, "pop", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-pop");
          var a = n.pop.call(i);
          this.rebuildTree(e), t.unblock("tree-pop");
        }
        return a;
      }
    }), n.splice = i.splice, Object.defineProperty(i, "splice", {
      enumerable: !1,
      configurable: !0,
      value: () => {
        if (!t.blocked) {
          t.block("tree-splice");
          var a = n.splice.apply(i, arguments);
          this.rebuildTree(e), t.unblock("tree-splice");
        }
        return a;
      }
    }));
  }
  rebuildTree(e) {
    this.table.modules.dataTree.initializeRow(e), this.table.modules.dataTree.layoutRow(e), this.table.rowManager.refreshActiveData("tree", !1, !0);
  }
  watchKey(e, t, i) {
    var n = this, a = Object.getOwnPropertyDescriptor(t, i), o = t[i], s = this.currentVersion;
    Object.defineProperty(t, i, {
      set: (l) => {
        if (o = l, !n.blocked && s === n.currentVersion) {
          n.block("key");
          var u = {};
          u[i] = l, e.updateData(u), n.unblock("key");
        }
        a.set && a.set(l);
      },
      get: () => (a.get && a.get(), o)
    });
  }
  unwatchRow(e) {
    var t = e.getData();
    for (var i in t)
      Object.defineProperty(t, i, {
        value: t[i]
      });
  }
  block(e) {
    this.blocked || (this.blocked = e);
  }
  unblock(e) {
    this.blocked === e && (this.blocked = !1);
  }
}
FP.moduleName = "reactiveData";
class XP extends mt {
  constructor(e) {
    super(e), this.startColumn = !1, this.startX = !1, this.startWidth = !1, this.latestX = !1, this.handle = null, this.initialNextColumn = null, this.nextColumn = null, this.initialized = !1, this.registerColumnOption("resizable", !0), this.registerTableOption("resizableColumnFit", !1);
  }
  initialize() {
    this.subscribe("column-rendered", this.layoutColumnHeader.bind(this));
  }
  initializeEventWatchers() {
    this.initialized || (this.subscribe("cell-rendered", this.layoutCellHandles.bind(this)), this.subscribe("cell-delete", this.deInitializeComponent.bind(this)), this.subscribe("cell-height", this.resizeHandle.bind(this)), this.subscribe("column-moved", this.columnLayoutUpdated.bind(this)), this.subscribe("column-hide", this.deInitializeColumn.bind(this)), this.subscribe("column-show", this.columnLayoutUpdated.bind(this)), this.subscribe("column-width", this.columnWidthUpdated.bind(this)), this.subscribe("column-delete", this.deInitializeComponent.bind(this)), this.subscribe("column-height", this.resizeHandle.bind(this)), this.initialized = !0);
  }
  layoutCellHandles(e) {
    e.row.type === "row" && (this.deInitializeComponent(e), this.initializeColumn("cell", e, e.column, e.element));
  }
  layoutColumnHeader(e) {
    e.definition.resizable && (this.initializeEventWatchers(), this.deInitializeComponent(e), this.initializeColumn("header", e, e, e.element));
  }
  columnLayoutUpdated(e) {
    var t = e.prevColumn();
    this.reinitializeColumn(e), t && this.reinitializeColumn(t);
  }
  columnWidthUpdated(e) {
    e.modules.frozen && (this.table.modules.frozenColumns.leftColumns.includes(e) ? this.table.modules.frozenColumns.leftColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }) : this.table.modules.frozenColumns.rightColumns.includes(e) && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
      this.reinitializeColumn(t);
    }));
  }
  frozenColumnOffset(e) {
    var t = !1;
    return e.modules.frozen && (t = e.modules.frozen.marginValue, e.modules.frozen.position === "left" ? t += e.getWidth() - 3 : t && (t -= 3)), t !== !1 ? t + "px" : !1;
  }
  reinitializeColumn(e) {
    var t = this.frozenColumnOffset(e);
    e.cells.forEach((i) => {
      i.modules.resize && i.modules.resize.handleEl && (t && (i.modules.resize.handleEl.style[e.modules.frozen.position] = t), i.element.after(i.modules.resize.handleEl));
    }), e.modules.resize && e.modules.resize.handleEl && (t && (e.modules.resize.handleEl.style[e.modules.frozen.position] = t), e.element.after(e.modules.resize.handleEl));
  }
  initializeColumn(e, t, i, n) {
    var a = this, o = !1, s = i.definition.resizable, l = {}, u = i.getLastColumn();
    if (e === "header" && (o = i.definition.formatter == "textarea" || i.definition.variableHeight, l = { variableHeight: o }), (s === !0 || s == e) && this._checkResizability(u)) {
      var c = document.createElement("span");
      c.className = "tabulator-col-resize-handle", c.addEventListener("click", function(f) {
        f.stopPropagation();
      });
      var h = function(f) {
        a.startColumn = i, a.initialNextColumn = a.nextColumn = u.nextColumn(), a._mouseDown(f, u, c);
      };
      c.addEventListener("mousedown", h), c.addEventListener("touchstart", h, { passive: !0 }), c.addEventListener("dblclick", (f) => {
        var d = u.getWidth();
        f.stopPropagation(), u.reinitializeWidth(!0), d !== u.getWidth() && (a.dispatch("column-resized", u), a.table.externalEvents.dispatch("columnResized", u.getComponent()));
      }), i.modules.frozen && (c.style.position = "sticky", c.style[i.modules.frozen.position] = this.frozenColumnOffset(i)), l.handleEl = c, n.parentNode && i.visible && n.after(c);
    }
    t.modules.resize = l;
  }
  deInitializeColumn(e) {
    this.deInitializeComponent(e), e.cells.forEach((t) => {
      this.deInitializeComponent(t);
    });
  }
  deInitializeComponent(e) {
    var t;
    e.modules.resize && (t = e.modules.resize.handleEl, t && t.parentElement && t.parentElement.removeChild(t));
  }
  resizeHandle(e, t) {
    e.modules.resize && e.modules.resize.handleEl && (e.modules.resize.handleEl.style.height = t);
  }
  _checkResizability(e) {
    return e.definition.resizable;
  }
  _mouseDown(e, t, i) {
    var n = this;
    n.table.element.classList.add("tabulator-block-select");
    function a(s) {
      var l = typeof s.screenX > "u" ? s.touches[0].screenX : s.screenX, u = l - n.startX, c = l - n.latestX, h, f;
      if (n.latestX = l, n.table.rtl && (u = -u, c = -c), h = t.width == t.minWidth || t.width == t.maxWidth, t.setWidth(n.startWidth + u), f = t.width == t.minWidth || t.width == t.maxWidth, c < 0 && (n.nextColumn = n.initialNextColumn), n.table.options.resizableColumnFit && n.nextColumn && !(h && f)) {
        let d = n.nextColumn.getWidth();
        c > 0 && d <= n.nextColumn.minWidth && (n.nextColumn = n.nextColumn.nextColumn()), n.nextColumn && n.nextColumn.setWidth(n.nextColumn.getWidth() - c);
      }
      n.table.columnManager.rerenderColumns(!0), !n.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights();
    }
    function o(s) {
      n.startColumn.modules.edit && (n.startColumn.modules.edit.blocked = !1), n.table.browserSlow && t.modules.resize && t.modules.resize.variableHeight && t.checkCellHeights(), document.body.removeEventListener("mouseup", o), document.body.removeEventListener("mousemove", a), i.removeEventListener("touchmove", a), i.removeEventListener("touchend", o), n.table.element.classList.remove("tabulator-block-select"), n.startWidth !== t.getWidth() && (n.table.columnManager.verticalAlignHeaders(), n.dispatch("column-resized", t), n.table.externalEvents.dispatch("columnResized", t.getComponent()));
    }
    e.stopPropagation(), n.startColumn.modules.edit && (n.startColumn.modules.edit.blocked = !0), n.startX = typeof e.screenX > "u" ? e.touches[0].screenX : e.screenX, n.latestX = n.startX, n.startWidth = t.getWidth(), document.body.addEventListener("mousemove", a), document.body.addEventListener("mouseup", o), i.addEventListener("touchmove", a, { passive: !0 }), i.addEventListener("touchend", o);
  }
}
XP.moduleName = "resizeColumns";
class YP extends mt {
  constructor(e) {
    super(e), this.startColumn = !1, this.startY = !1, this.startHeight = !1, this.handle = null, this.prevHandle = null, this.registerTableOption("resizableRows", !1);
  }
  initialize() {
    this.table.options.resizableRows && this.subscribe("row-layout-after", this.initializeRow.bind(this));
  }
  initializeRow(e) {
    var t = this, i = e.getElement(), n = document.createElement("div");
    n.className = "tabulator-row-resize-handle";
    var a = document.createElement("div");
    a.className = "tabulator-row-resize-handle prev", n.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var o = function(l) {
      t.startRow = e, t._mouseDown(l, e, n);
    };
    n.addEventListener("mousedown", o), n.addEventListener("touchstart", o, { passive: !0 }), a.addEventListener("click", function(l) {
      l.stopPropagation();
    });
    var s = function(l) {
      var u = t.table.rowManager.prevDisplayRow(e);
      u && (t.startRow = u, t._mouseDown(l, u, a));
    };
    a.addEventListener("mousedown", s), a.addEventListener("touchstart", s, { passive: !0 }), i.appendChild(n), i.appendChild(a);
  }
  _mouseDown(e, t, i) {
    var n = this;
    n.table.element.classList.add("tabulator-block-select");
    function a(s) {
      t.setHeight(n.startHeight + ((typeof s.screenY > "u" ? s.touches[0].screenY : s.screenY) - n.startY));
    }
    function o(s) {
      document.body.removeEventListener("mouseup", a), document.body.removeEventListener("mousemove", a), i.removeEventListener("touchmove", a), i.removeEventListener("touchend", o), n.table.element.classList.remove("tabulator-block-select"), n.dispatchExternal("rowResized", t.getComponent());
    }
    e.stopPropagation(), n.startY = typeof e.screenY > "u" ? e.touches[0].screenY : e.screenY, n.startHeight = t.getHeight(), document.body.addEventListener("mousemove", a), document.body.addEventListener("mouseup", o), i.addEventListener("touchmove", a, { passive: !0 }), i.addEventListener("touchend", o);
  }
}
YP.moduleName = "resizeRows";
class HP extends mt {
  constructor(e) {
    super(e), this.binding = !1, this.visibilityObserver = !1, this.resizeObserver = !1, this.containerObserver = !1, this.tableHeight = 0, this.tableWidth = 0, this.containerHeight = 0, this.containerWidth = 0, this.autoResize = !1, this.visible = !1, this.initialized = !1, this.initialRedraw = !1, this.registerTableOption("autoResize", !0);
  }
  initialize() {
    if (this.table.options.autoResize) {
      var e = this.table, t;
      this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), typeof IntersectionObserver < "u" && typeof ResizeObserver < "u" && e.rowManager.getRenderMode() === "virtual" ? (this.initializeVisibilityObserver(), this.autoResize = !0, this.resizeObserver = new ResizeObserver((i) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var n = Math.floor(i[0].contentRect.height), a = Math.floor(i[0].contentRect.width);
          (this.tableHeight != n || this.tableWidth != a) && (this.tableHeight = n, this.tableWidth = a, e.element.parentNode && (this.containerHeight = e.element.parentNode.clientHeight, this.containerWidth = e.element.parentNode.clientWidth), this.redrawTable());
        }
      }), this.resizeObserver.observe(e.element), t = window.getComputedStyle(e.element), this.table.element.parentNode && !this.table.rowManager.fixedHeight && (t.getPropertyValue("max-height") || t.getPropertyValue("min-height")) && (this.containerObserver = new ResizeObserver((i) => {
        if (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) {
          var n = Math.floor(i[0].contentRect.height), a = Math.floor(i[0].contentRect.width);
          (this.containerHeight != n || this.containerWidth != a) && (this.containerHeight = n, this.containerWidth = a, this.tableHeight = e.element.clientHeight, this.tableWidth = e.element.clientWidth), this.redrawTable();
        }
      }), this.containerObserver.observe(this.table.element.parentNode)), this.subscribe("table-resize", this.tableResized.bind(this))) : (this.binding = function() {
        (!e.browserMobile || e.browserMobile && !e.modules.edit.currentCell) && (e.columnManager.rerenderColumns(!0), e.redraw());
      }, window.addEventListener("resize", this.binding)), this.subscribe("table-destroy", this.clearBindings.bind(this));
    }
  }
  initializeVisibilityObserver() {
    this.visibilityObserver = new IntersectionObserver((e) => {
      this.visible = e[0].isIntersecting, this.initialized ? this.visible && (this.redrawTable(this.initialRedraw), this.initialRedraw = !1) : (this.initialized = !0, this.initialRedraw = !this.visible);
    }), this.visibilityObserver.observe(this.table.element);
  }
  redrawTable(e) {
    this.initialized && this.visible && (this.table.columnManager.rerenderColumns(!0), this.table.redraw(e));
  }
  tableResized() {
    this.table.rowManager.redraw();
  }
  clearBindings() {
    this.binding && window.removeEventListener("resize", this.binding), this.resizeObserver && this.resizeObserver.unobserve(this.table.element), this.visibilityObserver && this.visibilityObserver.unobserve(this.table.element), this.containerObserver && this.containerObserver.unobserve(this.table.element.parentNode);
  }
}
HP.moduleName = "resizeTable";
class WP extends mt {
  constructor(e) {
    super(e), this.columns = [], this.hiddenColumns = [], this.mode = "", this.index = 0, this.collapseFormatter = [], this.collapseStartOpen = !0, this.collapseHandleColumn = !1, this.registerTableOption("responsiveLayout", !1), this.registerTableOption("responsiveLayoutCollapseStartOpen", !0), this.registerTableOption("responsiveLayoutCollapseUseFormatters", !0), this.registerTableOption("responsiveLayoutCollapseFormatter", !1), this.registerColumnOption("responsive");
  }
  //generate responsive columns list
  initialize() {
    this.table.options.responsiveLayout && (this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("column-show", this.updateColumnVisibility.bind(this)), this.subscribe("column-hide", this.updateColumnVisibility.bind(this)), this.subscribe("columns-loaded", this.initializeResponsivity.bind(this)), this.subscribe("column-moved", this.initializeResponsivity.bind(this)), this.subscribe("column-add", this.initializeResponsivity.bind(this)), this.subscribe("column-delete", this.initializeResponsivity.bind(this)), this.subscribe("table-redrawing", this.tableRedraw.bind(this)), this.table.options.responsiveLayout === "collapse" && (this.subscribe("row-data-changed", this.generateCollapsedRowContent.bind(this)), this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-layout", this.layoutRow.bind(this))));
  }
  tableRedraw(e) {
    ["fitColumns", "fitDataStretch"].indexOf(this.layoutMode()) === -1 && (e || this.update());
  }
  initializeResponsivity() {
    var e = [];
    this.mode = this.table.options.responsiveLayout, this.collapseFormatter = this.table.options.responsiveLayoutCollapseFormatter || this.formatCollapsedData, this.collapseStartOpen = this.table.options.responsiveLayoutCollapseStartOpen, this.hiddenColumns = [], this.table.columnManager.columnsByIndex.forEach((t, i) => {
      t.modules.responsive && t.modules.responsive.order && t.modules.responsive.visible && (t.modules.responsive.index = i, e.push(t), !t.visible && this.mode === "collapse" && this.hiddenColumns.push(t));
    }), e = e.reverse(), e = e.sort((t, i) => {
      var n = i.modules.responsive.order - t.modules.responsive.order;
      return n || i.modules.responsive.index - t.modules.responsive.index;
    }), this.columns = e, this.mode === "collapse" && this.generateCollapsedContent();
    for (let t of this.table.columnManager.columnsByIndex)
      if (t.definition.formatter == "responsiveCollapse") {
        this.collapseHandleColumn = t;
        break;
      }
    this.collapseHandleColumn && (this.hiddenColumns.length ? this.collapseHandleColumn.show() : this.collapseHandleColumn.hide());
  }
  //define layout information
  initializeColumn(e) {
    var t = e.getDefinition();
    e.modules.responsive = { order: typeof t.responsive > "u" ? 1 : t.responsive, visible: t.visible !== !1 };
  }
  initializeRow(e) {
    var t;
    e.type !== "calc" && (t = document.createElement("div"), t.classList.add("tabulator-responsive-collapse"), e.modules.responsiveLayout = {
      element: t,
      open: this.collapseStartOpen
    }, this.collapseStartOpen || (t.style.display = "none"));
  }
  layoutRow(e) {
    var t = e.getElement();
    e.modules.responsiveLayout && (t.appendChild(e.modules.responsiveLayout.element), this.generateCollapsedRowContent(e));
  }
  //update column visibility
  updateColumnVisibility(e, t) {
    !t && e.modules.responsive && (e.modules.responsive.visible = e.visible, this.initializeResponsivity());
  }
  hideColumn(e) {
    var t = this.hiddenColumns.length;
    e.hide(!1, !0), this.mode === "collapse" && (this.hiddenColumns.unshift(e), this.generateCollapsedContent(), this.collapseHandleColumn && !t && this.collapseHandleColumn.show());
  }
  showColumn(e) {
    var t;
    e.show(!1, !0), e.setWidth(e.getWidth()), this.mode === "collapse" && (t = this.hiddenColumns.indexOf(e), t > -1 && this.hiddenColumns.splice(t, 1), this.generateCollapsedContent(), this.collapseHandleColumn && !this.hiddenColumns.length && this.collapseHandleColumn.hide());
  }
  //redraw columns to fit space
  update() {
    for (var e = !0; e; ) {
      let t = this.table.modules.layout.getMode() == "fitColumns" ? this.table.columnManager.getFlexBaseWidth() : this.table.columnManager.getWidth(), i = (this.table.options.headerVisible ? this.table.columnManager.element.clientWidth : this.table.element.clientWidth) - t;
      if (i < 0) {
        let n = this.columns[this.index];
        n ? (this.hideColumn(n), this.index++) : e = !1;
      } else {
        let n = this.columns[this.index - 1];
        n && i > 0 && i >= n.getWidth() ? (this.showColumn(n), this.index--) : e = !1;
      }
      this.table.rowManager.activeRowsCount || this.table.rowManager.renderEmptyScroll();
    }
  }
  generateCollapsedContent() {
    var e = this.table.rowManager.getDisplayRows();
    e.forEach((t) => {
      this.generateCollapsedRowContent(t);
    });
  }
  generateCollapsedRowContent(e) {
    var t, i;
    if (e.modules.responsiveLayout) {
      for (t = e.modules.responsiveLayout.element; t.firstChild; )
        t.removeChild(t.firstChild);
      i = this.collapseFormatter(this.generateCollapsedRowData(e)), i && t.appendChild(i);
    }
  }
  generateCollapsedRowData(e) {
    var t = e.getData(), i = [], n;
    return this.hiddenColumns.forEach((a) => {
      var o = a.getFieldValue(t);
      if (a.definition.title && a.field)
        if (a.modules.format && this.table.options.responsiveLayoutCollapseUseFormatters) {
          let l = function(u) {
            u();
          };
          var s = l;
          n = {
            value: !1,
            data: {},
            getValue: function() {
              return o;
            },
            getData: function() {
              return t;
            },
            getType: function() {
              return "cell";
            },
            getElement: function() {
              return document.createElement("div");
            },
            getRow: function() {
              return e.getComponent();
            },
            getColumn: function() {
              return a.getComponent();
            },
            getTable: () => this.table
          }, i.push({
            field: a.field,
            title: a.definition.title,
            value: a.modules.format.formatter.call(this.table.modules.format, n, a.modules.format.params, l)
          });
        } else
          i.push({
            field: a.field,
            title: a.definition.title,
            value: o
          });
    }), i;
  }
  formatCollapsedData(e) {
    var t = document.createElement("table");
    return e.forEach(function(i) {
      var n = document.createElement("tr"), a = document.createElement("td"), o = document.createElement("td"), s, l = document.createElement("strong");
      a.appendChild(l), this.langBind("columns|" + i.field, function(u) {
        l.innerHTML = u || i.title;
      }), i.value instanceof Node ? (s = document.createElement("div"), s.appendChild(i.value), o.appendChild(s)) : o.innerHTML = i.value, n.appendChild(a), n.appendChild(o), t.appendChild(n);
    }, this), Object.keys(e).length ? t : "";
  }
}
WP.moduleName = "responsiveLayout";
class zP extends mt {
  constructor(e) {
    super(e), this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], this.headerCheckboxElement = null, this.registerTableOption("selectable", "highlight"), this.registerTableOption("selectableRangeMode", "drag"), this.registerTableOption("selectableRollingSelection", !0), this.registerTableOption("selectablePersistence", !0), this.registerTableOption("selectableCheck", function(t, i) {
      return !0;
    }), this.registerTableFunction("selectRow", this.selectRows.bind(this)), this.registerTableFunction("deselectRow", this.deselectRows.bind(this)), this.registerTableFunction("toggleSelectRow", this.toggleRow.bind(this)), this.registerTableFunction("getSelectedRows", this.getSelectedRows.bind(this)), this.registerTableFunction("getSelectedData", this.getSelectedData.bind(this)), this.registerComponentFunction("row", "select", this.selectRows.bind(this)), this.registerComponentFunction("row", "deselect", this.deselectRows.bind(this)), this.registerComponentFunction("row", "toggleSelect", this.toggleRow.bind(this)), this.registerComponentFunction("row", "isSelected", this.isRowSelected.bind(this));
  }
  initialize() {
    this.table.options.selectable !== !1 && (this.subscribe("row-init", this.initializeRow.bind(this)), this.subscribe("row-deleting", this.rowDeleted.bind(this)), this.subscribe("rows-wipe", this.clearSelectionData.bind(this)), this.subscribe("rows-retrieve", this.rowRetrieve.bind(this)), this.table.options.selectable && !this.table.options.selectablePersistence && this.subscribe("data-refreshing", this.deselectRows.bind(this)));
  }
  rowRetrieve(e, t) {
    return e === "selected" ? this.selectedRows : t;
  }
  rowDeleted(e) {
    this._deselectRow(e, !0);
  }
  clearSelectionData(e) {
    var t = this.selectedRows.length;
    this.selecting = !1, this.lastClickedRow = !1, this.selectPrev = [], this.selectedRows = [], t && e !== !0 && this._rowSelectionChanged();
  }
  initializeRow(e) {
    var t = this, i = e.getElement(), n = function() {
      setTimeout(function() {
        t.selecting = !1;
      }, 50), document.body.removeEventListener("mouseup", n);
    };
    e.modules.select = { selected: !1 }, t.checkRowSelectability(e) ? (i.classList.add("tabulator-selectable"), i.classList.remove("tabulator-unselectable"), t.table.options.selectable && t.table.options.selectable != "highlight" && (t.table.options.selectableRangeMode === "click" ? i.addEventListener("click", this.handleComplexRowClick.bind(this, e)) : (i.addEventListener("click", function(a) {
      (!t.table.modExists("edit") || !t.table.modules.edit.getCurrentCell()) && t.table._clearSelection(), t.selecting || t.toggleRow(e);
    }), i.addEventListener("mousedown", function(a) {
      if (a.shiftKey)
        return t.table._clearSelection(), t.selecting = !0, t.selectPrev = [], document.body.addEventListener("mouseup", n), document.body.addEventListener("keyup", n), t.toggleRow(e), !1;
    }), i.addEventListener("mouseenter", function(a) {
      t.selecting && (t.table._clearSelection(), t.toggleRow(e), t.selectPrev[1] == e && t.toggleRow(t.selectPrev[0]));
    }), i.addEventListener("mouseout", function(a) {
      t.selecting && (t.table._clearSelection(), t.selectPrev.unshift(e));
    })))) : (i.classList.add("tabulator-unselectable"), i.classList.remove("tabulator-selectable"));
  }
  handleComplexRowClick(e, t) {
    if (t.shiftKey) {
      this.table._clearSelection(), this.lastClickedRow = this.lastClickedRow || e;
      var i = this.table.rowManager.getDisplayRowIndex(this.lastClickedRow), n = this.table.rowManager.getDisplayRowIndex(e), a = i <= n ? i : n, o = i >= n ? i : n, s = this.table.rowManager.getDisplayRows().slice(0), l = s.splice(a, o - a + 1);
      t.ctrlKey || t.metaKey ? (l.forEach((u) => {
        u !== this.lastClickedRow && (this.table.options.selectable !== !0 && !this.isRowSelected(e) ? this.selectedRows.length < this.table.options.selectable && this.toggleRow(u) : this.toggleRow(u));
      }), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.table.options.selectable !== !0 && l.length > this.table.options.selectable && (l = l.slice(0, this.table.options.selectable)), this.selectRows(l)), this.table._clearSelection();
    } else
      t.ctrlKey || t.metaKey ? (this.toggleRow(e), this.lastClickedRow = e) : (this.deselectRows(void 0, !0), this.selectRows(e), this.lastClickedRow = e);
  }
  checkRowSelectability(e) {
    return e && e.type === "row" ? this.table.options.selectableCheck.call(this.table, e.getComponent()) : !1;
  }
  //toggle row selection
  toggleRow(e) {
    this.checkRowSelectability(e) && (e.modules.select && e.modules.select.selected ? this._deselectRow(e) : this._selectRow(e));
  }
  //select a number of rows
  selectRows(e) {
    var t = [], i, n;
    switch (typeof e) {
      case "undefined":
        i = this.table.rowManager.rows;
        break;
      case "string":
        i = this.table.rowManager.findRow(e), i || (i = this.table.rowManager.getRows(e));
        break;
      default:
        i = e;
        break;
    }
    Array.isArray(i) ? i.length && (i.forEach((a) => {
      n = this._selectRow(a, !0, !0), n && t.push(n);
    }), this._rowSelectionChanged(!1, t)) : i && this._selectRow(i, !1, !0);
  }
  //select an individual row
  _selectRow(e, t, i) {
    if (!isNaN(this.table.options.selectable) && this.table.options.selectable !== !0 && !i && this.selectedRows.length >= this.table.options.selectable)
      if (this.table.options.selectableRollingSelection)
        this._deselectRow(this.selectedRows[0]);
      else
        return !1;
    var n = this.table.rowManager.findRow(e);
    if (n) {
      if (this.selectedRows.indexOf(n) == -1)
        return n.getElement().classList.add("tabulator-selected"), n.modules.select || (n.modules.select = {}), n.modules.select.selected = !0, n.modules.select.checkboxEl && (n.modules.select.checkboxEl.checked = !0), this.selectedRows.push(n), this.table.options.dataTreeSelectPropagate && this.childRowSelection(n, !0), this.dispatchExternal("rowSelected", n.getComponent()), this._rowSelectionChanged(t, n), n;
    } else
      t || console.warn("Selection Error - No such row found, ignoring selection:" + e);
  }
  isRowSelected(e) {
    return this.selectedRows.indexOf(e) !== -1;
  }
  //deselect a number of rows
  deselectRows(e, t) {
    var i = [], n, a;
    switch (typeof e) {
      case "undefined":
        n = Object.assign([], this.selectedRows);
        break;
      case "string":
        n = this.table.rowManager.findRow(e), n || (n = this.table.rowManager.getRows(e));
        break;
      default:
        n = e;
        break;
    }
    Array.isArray(n) ? n.length && (n.forEach((o) => {
      a = this._deselectRow(o, !0, !0), a && i.push(a);
    }), this._rowSelectionChanged(t, [], i)) : n && this._deselectRow(n, t, !0);
  }
  //deselect an individual row
  _deselectRow(e, t) {
    var i = this, n = i.table.rowManager.findRow(e), a, o;
    if (n) {
      if (a = i.selectedRows.findIndex(function(s) {
        return s == n;
      }), a > -1)
        return o = n.getElement(), o && o.classList.remove("tabulator-selected"), n.modules.select || (n.modules.select = {}), n.modules.select.selected = !1, n.modules.select.checkboxEl && (n.modules.select.checkboxEl.checked = !1), i.selectedRows.splice(a, 1), this.table.options.dataTreeSelectPropagate && this.childRowSelection(n, !1), this.dispatchExternal("rowDeselected", n.getComponent()), i._rowSelectionChanged(t, void 0, n), n;
    } else
      t || console.warn("Deselection Error - No such row found, ignoring selection:" + e);
  }
  getSelectedData() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getData());
    }), e;
  }
  getSelectedRows() {
    var e = [];
    return this.selectedRows.forEach(function(t) {
      e.push(t.getComponent());
    }), e;
  }
  _rowSelectionChanged(e, t = [], i = []) {
    this.headerCheckboxElement && (this.selectedRows.length === 0 ? (this.headerCheckboxElement.checked = !1, this.headerCheckboxElement.indeterminate = !1) : this.table.rowManager.rows.length === this.selectedRows.length ? (this.headerCheckboxElement.checked = !0, this.headerCheckboxElement.indeterminate = !1) : (this.headerCheckboxElement.indeterminate = !0, this.headerCheckboxElement.checked = !1)), e || (Array.isArray(t) || (t = [t]), t = t.map((n) => n.getComponent()), Array.isArray(i) || (i = [i]), i = i.map((n) => n.getComponent()), this.dispatchExternal("rowSelectionChanged", this.getSelectedData(), this.getSelectedRows(), t, i));
  }
  registerRowSelectCheckbox(e, t) {
    e._row.modules.select || (e._row.modules.select = {}), e._row.modules.select.checkboxEl = t;
  }
  registerHeaderSelectCheckbox(e) {
    this.headerCheckboxElement = e;
  }
  childRowSelection(e, t) {
    var i = this.table.modules.dataTree.getChildren(e, !0);
    if (t)
      for (let n of i)
        this._selectRow(n, !0);
    else
      for (let n of i)
        this._deselectRow(n, !0);
  }
}
zP.moduleName = "selectRow";
function YGe(r, e, t, i, n, a, o) {
  var s = o.alignEmptyValues, l = o.decimalSeparator, u = o.thousandSeparator, c = 0;
  if (r = String(r), e = String(e), u && (r = r.split(u).join(""), e = e.split(u).join("")), l && (r = r.split(l).join("."), e = e.split(l).join(".")), r = parseFloat(r), e = parseFloat(e), isNaN(r))
    c = isNaN(e) ? 0 : -1;
  else if (isNaN(e))
    c = 1;
  else
    return r - e;
  return (s === "top" && a === "desc" || s === "bottom" && a === "asc") && (c *= -1), c;
}
function HGe(r, e, t, i, n, a, o) {
  var s = o.alignEmptyValues, l = 0, u;
  if (!r)
    l = e ? -1 : 0;
  else if (!e)
    l = 1;
  else {
    switch (typeof o.locale) {
      case "boolean":
        o.locale && (u = this.langLocale());
        break;
      case "string":
        u = o.locale;
        break;
    }
    return String(r).toLowerCase().localeCompare(String(e).toLowerCase(), u);
  }
  return (s === "top" && a === "desc" || s === "bottom" && a === "asc") && (l *= -1), l;
}
function ZP(r, e, t, i, n, a, o) {
  var s = window.DateTime || luxon.DateTime, l = o.format || "dd/MM/yyyy HH:mm:ss", u = o.alignEmptyValues, c = 0;
  if (typeof s < "u") {
    if (s.isDateTime(r) || (l === "iso" ? r = s.fromISO(String(r)) : r = s.fromFormat(String(r), l)), s.isDateTime(e) || (l === "iso" ? e = s.fromISO(String(e)) : e = s.fromFormat(String(e), l)), !r.isValid)
      c = e.isValid ? -1 : 0;
    else if (!e.isValid)
      c = 1;
    else
      return r - e;
    return (u === "top" && a === "desc" || u === "bottom" && a === "asc") && (c *= -1), c;
  } else
    console.error("Sort Error - 'datetime' sorter is dependant on luxon.js");
}
function WGe(r, e, t, i, n, a, o) {
  return o.format || (o.format = "dd/MM/yyyy"), ZP.call(this, r, e, t, i, n, a, o);
}
function zGe(r, e, t, i, n, a, o) {
  return o.format || (o.format = "HH:mm"), ZP.call(this, r, e, t, i, n, a, o);
}
function ZGe(r, e, t, i, n, a, o) {
  var s = r === !0 || r === "true" || r === "True" || r === 1 ? 1 : 0, l = e === !0 || e === "true" || e === "True" || e === 1 ? 1 : 0;
  return s - l;
}
function qGe(r, e, t, i, n, a, o) {
  var s = o.type || "length", l = o.alignEmptyValues, u = 0;
  function c(h) {
    var f;
    switch (s) {
      case "length":
        f = h.length;
        break;
      case "sum":
        f = h.reduce(function(d, p) {
          return d + p;
        });
        break;
      case "max":
        f = Math.max.apply(null, h);
        break;
      case "min":
        f = Math.min.apply(null, h);
        break;
      case "avg":
        f = h.reduce(function(d, p) {
          return d + p;
        }) / h.length;
        break;
    }
    return f;
  }
  if (!Array.isArray(r))
    u = Array.isArray(e) ? -1 : 0;
  else if (!Array.isArray(e))
    u = 1;
  else
    return c(e) - c(r);
  return (l === "top" && a === "desc" || l === "bottom" && a === "asc") && (u *= -1), u;
}
function jGe(r, e, t, i, n, a, o) {
  var s = typeof r > "u" ? 0 : 1, l = typeof e > "u" ? 0 : 1;
  return s - l;
}
function KGe(r, e, t, i, n, a, o) {
  var s, l, u, c, h = 0, f, d = /(\d+)|(\D+)/g, p = /\d/, g = o.alignEmptyValues, v = 0;
  if (!r && r !== 0)
    v = !e && e !== 0 ? 0 : -1;
  else if (!e && e !== 0)
    v = 1;
  else {
    if (isFinite(r) && isFinite(e))
      return r - e;
    if (s = String(r).toLowerCase(), l = String(e).toLowerCase(), s === l)
      return 0;
    if (!(p.test(s) && p.test(l)))
      return s > l ? 1 : -1;
    for (s = s.match(d), l = l.match(d), f = s.length > l.length ? l.length : s.length; h < f; )
      if (u = s[h], c = l[h++], u !== c)
        return isFinite(u) && isFinite(c) ? (u.charAt(0) === "0" && (u = "." + u), c.charAt(0) === "0" && (c = "." + c), u - c) : u > c ? 1 : -1;
    return s.length > l.length;
  }
  return (g === "top" && a === "desc" || g === "bottom" && a === "asc") && (v *= -1), v;
}
var JGe = {
  number: YGe,
  string: HGe,
  date: WGe,
  time: zGe,
  datetime: ZP,
  boolean: ZGe,
  array: qGe,
  exists: jGe,
  alphanum: KGe
};
class bl extends mt {
  constructor(e) {
    super(e), this.sortList = [], this.changed = !1, this.registerTableOption("sortMode", "local"), this.registerTableOption("initialSort", !1), this.registerTableOption("columnHeaderSortMulti", !0), this.registerTableOption("sortOrderReverse", !1), this.registerTableOption("headerSortElement", "<div class='tabulator-arrow'></div>"), this.registerTableOption("headerSortClickElement", "header"), this.registerColumnOption("sorter"), this.registerColumnOption("sorterParams"), this.registerColumnOption("headerSort", !0), this.registerColumnOption("headerSortStartingDir"), this.registerColumnOption("headerSortTristate");
  }
  initialize() {
    this.subscribe("column-layout", this.initializeColumn.bind(this)), this.subscribe("table-built", this.tableBuilt.bind(this)), this.registerDataHandler(this.sort.bind(this), 20), this.registerTableFunction("setSort", this.userSetSort.bind(this)), this.registerTableFunction("getSorters", this.getSort.bind(this)), this.registerTableFunction("clearSort", this.clearSort.bind(this)), this.table.options.sortMode === "remote" && this.subscribe("data-params", this.remoteSortParams.bind(this));
  }
  tableBuilt() {
    this.table.options.initialSort && this.setSort(this.table.options.initialSort);
  }
  remoteSortParams(e, t, i, n) {
    var a = this.getSort();
    return a.forEach((o) => {
      delete o.column;
    }), n.sort = a, n;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userSetSort(e, t) {
    this.setSort(e, t), this.refreshSort();
  }
  clearSort() {
    this.clear(), this.refreshSort();
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  //initialize column header for sorting
  initializeColumn(e) {
    var t = !1, i, n;
    switch (typeof e.definition.sorter) {
      case "string":
        bl.sorters[e.definition.sorter] ? t = bl.sorters[e.definition.sorter] : console.warn("Sort Error - No such sorter found: ", e.definition.sorter);
        break;
      case "function":
        t = e.definition.sorter;
        break;
    }
    if (e.modules.sort = {
      sorter: t,
      dir: "none",
      params: e.definition.sorterParams || {},
      startingDir: e.definition.headerSortStartingDir || "asc",
      tristate: e.definition.headerSortTristate
    }, e.definition.headerSort !== !1) {
      switch (i = e.getElement(), i.classList.add("tabulator-sortable"), n = document.createElement("div"), n.classList.add("tabulator-col-sorter"), this.table.options.headerSortClickElement) {
        case "icon":
          n.classList.add("tabulator-col-sorter-element");
          break;
        case "header":
          i.classList.add("tabulator-col-sorter-element");
          break;
        default:
          i.classList.add("tabulator-col-sorter-element");
          break;
      }
      switch (this.table.options.headerSortElement) {
        case "function":
          break;
        case "object":
          n.appendChild(this.table.options.headerSortElement);
          break;
        default:
          n.innerHTML = this.table.options.headerSortElement;
      }
      e.titleHolderElement.appendChild(n), e.modules.sort.element = n, this.setColumnHeaderSortIcon(e, "none"), (this.table.options.headerSortClickElement === "icon" ? n : i).addEventListener("click", (a) => {
        var o = "", s = [], l = !1;
        if (e.modules.sort) {
          if (e.modules.sort.tristate)
            e.modules.sort.dir == "none" ? o = e.modules.sort.startingDir : e.modules.sort.dir == e.modules.sort.startingDir ? o = e.modules.sort.dir == "asc" ? "desc" : "asc" : o = "none";
          else
            switch (e.modules.sort.dir) {
              case "asc":
                o = "desc";
                break;
              case "desc":
                o = "asc";
                break;
              default:
                o = e.modules.sort.startingDir;
            }
          this.table.options.columnHeaderSortMulti && (a.shiftKey || a.ctrlKey) ? (s = this.getSort(), l = s.findIndex((u) => u.field === e.getField()), l > -1 ? (s[l].dir = o, l = s.splice(l, 1)[0], o != "none" && s.push(l)) : o != "none" && s.push({ column: e, dir: o }), this.setSort(s)) : o == "none" ? this.clear() : this.setSort(e, o), this.refreshSort();
        }
      });
    }
  }
  refreshSort() {
    this.table.options.sortMode === "remote" ? this.reloadData(null, !1, !1) : this.refreshData(!0);
  }
  //check if the sorters have changed since last use
  hasChanged() {
    var e = this.changed;
    return this.changed = !1, e;
  }
  //return current sorters
  getSort() {
    var e = this, t = [];
    return e.sortList.forEach(function(i) {
      i.column && t.push({ column: i.column.getComponent(), field: i.column.getField(), dir: i.dir });
    }), t;
  }
  //change sort list and trigger sort
  setSort(e, t) {
    var i = this, n = [];
    Array.isArray(e) || (e = [{ column: e, dir: t }]), e.forEach(function(a) {
      var o;
      o = i.table.columnManager.findColumn(a.column), o ? (a.column = o, n.push(a), i.changed = !0) : console.warn("Sort Warning - Sort field does not exist and is being ignored: ", a.column);
    }), i.sortList = n, this.dispatch("sort-changed");
  }
  //clear sorters
  clear() {
    this.setSort([]);
  }
  //find appropriate sorter for column
  findSorter(e) {
    var t = this.table.rowManager.activeRows[0], i = "string", n, a;
    if (t && (t = t.getData(), n = e.getField(), n))
      switch (a = e.getFieldValue(t), typeof a) {
        case "undefined":
          i = "string";
          break;
        case "boolean":
          i = "boolean";
          break;
        default:
          !isNaN(a) && a !== "" ? i = "number" : a.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) && (i = "alphanum");
          break;
      }
    return bl.sorters[i];
  }
  //work through sort list sorting data
  sort(e) {
    var t = this, i = this.table.options.sortOrderReverse ? t.sortList.slice().reverse() : t.sortList, n = [], a = [];
    return this.subscribedExternal("dataSorting") && this.dispatchExternal("dataSorting", t.getSort()), t.clearColumnHeaders(), this.table.options.sortMode !== "remote" ? (i.forEach(function(o, s) {
      var l;
      o.column && (l = o.column.modules.sort, l && (l.sorter || (l.sorter = t.findSorter(o.column)), o.params = typeof l.params == "function" ? l.params(o.column.getComponent(), o.dir) : l.params, n.push(o)), t.setColumnHeader(o.column, o.dir));
    }), n.length && t._sortItems(e, n)) : i.forEach(function(o, s) {
      t.setColumnHeader(o.column, o.dir);
    }), this.subscribedExternal("dataSorted") && (e.forEach((o) => {
      a.push(o.getComponent());
    }), this.dispatchExternal("dataSorted", t.getSort(), a)), e;
  }
  //clear sort arrows on columns
  clearColumnHeaders() {
    this.table.columnManager.getRealColumns().forEach((e) => {
      e.modules.sort && (e.modules.sort.dir = "none", e.getElement().setAttribute("aria-sort", "none"), this.setColumnHeaderSortIcon(e, "none"));
    });
  }
  //set the column header sort direction
  setColumnHeader(e, t) {
    e.modules.sort.dir = t, e.getElement().setAttribute("aria-sort", t === "asc" ? "ascending" : "descending"), this.setColumnHeaderSortIcon(e, t);
  }
  setColumnHeaderSortIcon(e, t) {
    var i = e.modules.sort.element, n;
    if (e.definition.headerSort && typeof this.table.options.headerSortElement == "function") {
      for (; i.firstChild; )
        i.removeChild(i.firstChild);
      n = this.table.options.headerSortElement.call(this.table, e.getComponent(), t), typeof n == "object" ? i.appendChild(n) : i.innerHTML = n;
    }
  }
  //sort each item in sort list
  _sortItems(e, t) {
    var i = t.length - 1;
    e.sort((n, a) => {
      for (var o, s = i; s >= 0; s--) {
        let l = t[s];
        if (o = this._sortRow(n, a, l.column, l.dir, l.params), o !== 0)
          break;
      }
      return o;
    });
  }
  //process individual rows for a sort function on active data
  _sortRow(e, t, i, n, a) {
    var o, s, l = n == "asc" ? e : t, u = n == "asc" ? t : e;
    return e = i.getFieldValue(l.getData()), t = i.getFieldValue(u.getData()), e = typeof e < "u" ? e : "", t = typeof t < "u" ? t : "", o = l.getComponent(), s = u.getComponent(), i.modules.sort.sorter.call(this, e, t, o, s, i.getComponent(), n, a);
  }
}
bl.moduleName = "sort";
bl.sorters = JGe;
class Yq extends mt {
  constructor(e) {
    super(e), this.tooltipSubscriber = null, this.headerSubscriber = null, this.timeout = null, this.popupInstance = null, this.registerTableOption("tooltipGenerationMode", void 0), this.registerTableOption("tooltipDelay", 300), this.registerColumnOption("tooltip"), this.registerColumnOption("headerTooltip");
  }
  initialize() {
    this.deprecatedOptionsCheck(), this.subscribe("column-init", this.initializeColumn.bind(this));
  }
  deprecatedOptionsCheck() {
    this.deprecationCheckMsg("tooltipGenerationMode", "This option is no longer needed as tooltips are always generated on hover now");
  }
  initializeColumn(e) {
    e.definition.headerTooltip && !this.headerSubscriber && (this.headerSubscriber = !0, this.subscribe("column-mousemove", this.mousemoveCheck.bind(this, "headerTooltip")), this.subscribe("column-mouseout", this.mouseoutCheck.bind(this, "headerTooltip"))), e.definition.tooltip && !this.tooltipSubscriber && (this.tooltipSubscriber = !0, this.subscribe("cell-mousemove", this.mousemoveCheck.bind(this, "tooltip")), this.subscribe("cell-mouseout", this.mouseoutCheck.bind(this, "tooltip")));
  }
  mousemoveCheck(e, t, i) {
    var n = e === "tooltip" ? i.column.definition.tooltip : i.definition.headerTooltip;
    n && (this.clearPopup(), this.timeout = setTimeout(this.loadTooltip.bind(this, t, i, n), this.table.options.tooltipDelay));
  }
  mouseoutCheck(e, t, i) {
    this.popupInstance || this.clearPopup();
  }
  clearPopup(e, t, i) {
    clearTimeout(this.timeout), this.timeout = null, this.popupInstance && this.popupInstance.hide();
  }
  loadTooltip(e, t, i) {
    var n, a, o;
    function s(l) {
      a = l;
    }
    typeof i == "function" && (i = i(e, t.getComponent(), s)), i instanceof HTMLElement ? n = i : (n = document.createElement("div"), i === !0 && (t instanceof Kv ? i = t.value : t.definition.field ? this.langBind("columns|" + t.definition.field, (l) => {
      n.innerHTML = i = l || t.definition.title;
    }) : i = t.definition.title), n.innerHTML = i), (i || i === 0 || i === !1) && (n.classList.add("tabulator-tooltip"), n.addEventListener("mousemove", (l) => l.preventDefault()), this.popupInstance = this.popup(n), typeof a == "function" && this.popupInstance.renderCallback(a), o = this.popupInstance.containerEventCoords(e), this.popupInstance.show(o.x + 15, o.y + 15).hideOnBlur(() => {
      this.dispatchExternal("TooltipClosed", t.getComponent()), this.popupInstance = null;
    }), this.dispatchExternal("TooltipOpened", t.getComponent()));
  }
}
Yq.moduleName = "tooltip";
var eBe = {
  //is integer
  integer: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && Math.floor(e) === e);
  },
  //is float
  float: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (e = Number(e), !isNaN(e) && isFinite(e) && e % 1 !== 0);
  },
  //must be a number
  numeric: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : !isNaN(e);
  },
  //must be a string
  string: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : isNaN(e);
  },
  //maximum value
  max: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) <= t;
  },
  //minimum value
  min: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : parseFloat(e) >= t;
  },
  //starts with  value
  starts: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().startsWith(String(t).toLowerCase());
  },
  //ends with  value
  ends: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).toLowerCase().endsWith(String(t).toLowerCase());
  },
  //minimum string length
  minLength: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length >= t;
  },
  //maximum string length
  maxLength: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : String(e).length <= t;
  },
  //in provided value list
  in: function(r, e, t) {
    return e === "" || e === null || typeof e > "u" ? !0 : (typeof t == "string" && (t = t.split("|")), t.indexOf(e) > -1);
  },
  //must match provided regex
  regex: function(r, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var i = new RegExp(t);
    return i.test(e);
  },
  //value must be unique in this column
  unique: function(r, e, t) {
    if (e === "" || e === null || typeof e > "u")
      return !0;
    var i = !0, n = r.getData(), a = r.getColumn()._getSelf();
    return this.table.rowManager.rows.forEach(function(o) {
      var s = o.getData();
      s !== n && e == a.getFieldValue(s) && (i = !1);
    }), i;
  },
  //must have a value
  required: function(r, e, t) {
    return e !== "" && e !== null && typeof e < "u";
  }
};
class md extends mt {
  constructor(e) {
    super(e), this.invalidCells = [], this.registerTableOption("validationMode", "blocking"), this.registerColumnOption("validator"), this.registerTableFunction("getInvalidCells", this.getInvalidCells.bind(this)), this.registerTableFunction("clearCellValidation", this.userClearCellValidation.bind(this)), this.registerTableFunction("validate", this.userValidate.bind(this)), this.registerComponentFunction("cell", "isValid", this.cellIsValid.bind(this)), this.registerComponentFunction("cell", "clearValidation", this.clearValidation.bind(this)), this.registerComponentFunction("cell", "validate", this.cellValidate.bind(this)), this.registerComponentFunction("column", "validate", this.columnValidate.bind(this)), this.registerComponentFunction("row", "validate", this.rowValidate.bind(this));
  }
  initialize() {
    this.subscribe("cell-delete", this.clearValidation.bind(this)), this.subscribe("column-layout", this.initializeColumnCheck.bind(this)), this.subscribe("edit-success", this.editValidate.bind(this)), this.subscribe("edit-editor-clear", this.editorClear.bind(this)), this.subscribe("edit-edited-clear", this.editedClear.bind(this));
  }
  ///////////////////////////////////
  ///////// Event Handling //////////
  ///////////////////////////////////
  editValidate(e, t, i) {
    var n = this.table.options.validationMode !== "manual" ? this.validate(e.column.modules.validate, e, t) : !0;
    return n !== !0 && setTimeout(() => {
      e.getElement().classList.add("tabulator-validation-fail"), this.dispatchExternal("validationFailed", e.getComponent(), t, n);
    }), n;
  }
  editorClear(e, t) {
    t && e.column.modules.validate && this.cellValidate(e), e.getElement().classList.remove("tabulator-validation-fail");
  }
  editedClear(e) {
    e.modules.validate && (e.modules.validate.invalid = !1);
  }
  ///////////////////////////////////
  ////////// Cell Functions /////////
  ///////////////////////////////////
  cellIsValid(e) {
    return e.modules.validate && e.modules.validate.invalid || !0;
  }
  cellValidate(e) {
    return this.validate(e.column.modules.validate, e, e.getValue());
  }
  ///////////////////////////////////
  ///////// Column Functions ////////
  ///////////////////////////////////
  columnValidate(e) {
    var t = [];
    return e.cells.forEach((i) => {
      this.cellValidate(i) !== !0 && t.push(i.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ////////// Row Functions //////////
  ///////////////////////////////////
  rowValidate(e) {
    var t = [];
    return e.cells.forEach((i) => {
      this.cellValidate(i) !== !0 && t.push(i.getComponent());
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Table Functions /////////
  ///////////////////////////////////
  userClearCellValidation(e) {
    e || (e = this.getInvalidCells()), Array.isArray(e) || (e = [e]), e.forEach((t) => {
      this.clearValidation(t._getSelf());
    });
  }
  userValidate(e) {
    var t = [];
    return this.table.rowManager.rows.forEach((i) => {
      i = i.getComponent();
      var n = i.validate();
      n !== !0 && (t = t.concat(n));
    }), t.length ? t : !0;
  }
  ///////////////////////////////////
  ///////// Internal Logic //////////
  ///////////////////////////////////
  initializeColumnCheck(e) {
    typeof e.definition.validator < "u" && this.initializeColumn(e);
  }
  //validate
  initializeColumn(e) {
    var t = this, i = [], n;
    e.definition.validator && (Array.isArray(e.definition.validator) ? e.definition.validator.forEach((a) => {
      n = t._extractValidator(a), n && i.push(n);
    }) : (n = this._extractValidator(e.definition.validator), n && i.push(n)), e.modules.validate = i.length ? i : !1);
  }
  _extractValidator(e) {
    var t, i, n;
    switch (typeof e) {
      case "string":
        return n = e.indexOf(":"), n > -1 ? (t = e.substring(0, n), i = e.substring(n + 1)) : t = e, this._buildValidator(t, i);
      case "function":
        return this._buildValidator(e);
      case "object":
        return this._buildValidator(e.type, e.parameters);
    }
  }
  _buildValidator(e, t) {
    var i = typeof e == "function" ? e : md.validators[e];
    return i ? {
      type: typeof e == "function" ? "function" : e,
      func: i,
      params: t
    } : (console.warn("Validator Setup Error - No matching validator found:", e), !1);
  }
  validate(e, t, i) {
    var n = this, a = [], o = this.invalidCells.indexOf(t);
    return e && e.forEach((s) => {
      s.func.call(n, t.getComponent(), i, s.params) || a.push({
        type: s.type,
        parameters: s.params
      });
    }), t.modules.validate || (t.modules.validate = {}), a.length ? (t.modules.validate.invalid = a, this.table.options.validationMode !== "manual" && t.getElement().classList.add("tabulator-validation-fail"), o == -1 && this.invalidCells.push(t)) : (t.modules.validate.invalid = !1, t.getElement().classList.remove("tabulator-validation-fail"), o > -1 && this.invalidCells.splice(o, 1)), a.length ? a : !0;
  }
  getInvalidCells() {
    var e = [];
    return this.invalidCells.forEach((t) => {
      e.push(t.getComponent());
    }), e;
  }
  clearValidation(e) {
    var t;
    e.modules.validate && e.modules.validate.invalid && (e.getElement().classList.remove("tabulator-validation-fail"), e.modules.validate.invalid = !1, t = this.invalidCells.indexOf(e), t > -1 && this.invalidCells.splice(t, 1));
  }
}
md.moduleName = "validate";
md.validators = eBe;
var tBe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  AccessorModule: $c,
  AjaxModule: ya,
  ClipboardModule: Yl,
  ColumnCalcsModule: zo,
  DataTreeModule: PP,
  DownloadModule: Vc,
  EditModule: gd,
  ExportModule: DP,
  FilterModule: ao,
  FormatModule: dn,
  FrozenColumnsModule: MP,
  FrozenRowsModule: kP,
  GroupRowsModule: QP,
  HistoryModule: Hl,
  HtmlTableImportModule: UP,
  ImportModule: vd,
  InteractionModule: $P,
  KeybindingsModule: rs,
  MenuModule: Xq,
  MoveColumnsModule: VP,
  MoveRowsModule: Jv,
  MutatorModule: Gc,
  PageModule: Od,
  PersistenceModule: wi,
  PopupModule: GP,
  PrintModule: BP,
  ReactiveDataModule: FP,
  ResizeColumnsModule: XP,
  ResizeRowsModule: YP,
  ResizeTableModule: HP,
  ResponsiveLayoutModule: WP,
  SelectRowModule: zP,
  SortModule: bl,
  TooltipModule: Yq,
  ValidateModule: md
}), rBe = {
  debugEventsExternal: !1,
  //flag to console log events
  debugEventsInternal: !1,
  //flag to console log events
  debugInvalidOptions: !0,
  //allow toggling of invalid option warnings
  debugInvalidComponentFuncs: !0,
  //allow toggling of invalid component warnings
  debugInitialization: !0,
  //allow toggling of pre initialization function call warnings
  debugDeprecation: !0,
  //allow toggling of deprecation warnings
  height: !1,
  //height of tabulator
  minHeight: !1,
  //minimum height of tabulator
  maxHeight: !1,
  //maximum height of tabulator
  columnHeaderVertAlign: "top",
  //vertical alignment of column headers
  popupContainer: !1,
  columns: [],
  //store for colum header info
  columnDefaults: {},
  //store column default props
  data: !1,
  //default starting data
  autoColumns: !1,
  //build columns from data row structure
  autoColumnsDefinitions: !1,
  nestedFieldSeparator: ".",
  //separator for nested data
  footerElement: !1,
  //hold footer element
  index: "id",
  //filed for row index
  textDirection: "auto",
  addRowPos: "bottom",
  //position to insert blank rows, top|bottom
  headerVisible: !0,
  //hide header
  renderVertical: "virtual",
  renderHorizontal: "basic",
  renderVerticalBuffer: 0,
  // set virtual DOM buffer size
  scrollToRowPosition: "top",
  scrollToRowIfVisible: !0,
  scrollToColumnPosition: "left",
  scrollToColumnIfVisible: !0,
  rowFormatter: !1,
  rowFormatterPrint: null,
  rowFormatterClipboard: null,
  rowFormatterHtmlOutput: null,
  rowHeight: null,
  placeholder: !1,
  dataLoader: !0,
  dataLoaderLoading: !1,
  dataLoaderError: !1,
  dataLoaderErrorTimeout: 3e3,
  dataSendParams: {},
  dataReceiveParams: {}
};
class Hq {
  constructor(e, t, i = {}) {
    this.table = e, this.msgType = t, this.registeredDefaults = Object.assign({}, i);
  }
  register(e, t) {
    this.registeredDefaults[e] = t;
  }
  generate(e, t = {}) {
    var i = Object.assign({}, this.registeredDefaults), n = this.table.options.debugInvalidOptions || t.debugInvalidOptions === !0;
    Object.assign(i, e);
    for (let a in t)
      i.hasOwnProperty(a) || (n && console.warn("Invalid " + this.msgType + " option:", a), i[a] = t.key);
    for (let a in i)
      a in t ? i[a] = t[a] : Array.isArray(i[a]) ? i[a] = Object.assign([], i[a]) : typeof i[a] == "object" && i[a] !== null ? i[a] = Object.assign({}, i[a]) : typeof i[a] > "u" && delete i[a];
    return i;
  }
}
class Ey extends an {
  constructor(e) {
    super(e), this.elementVertical = e.rowManager.element, this.elementHorizontal = e.columnManager.element, this.tableElement = e.rowManager.tableElement, this.verticalFillMode = "fit";
  }
  ///////////////////////////////////
  /////// Internal Bindings /////////
  ///////////////////////////////////
  initialize() {
  }
  clearRows() {
  }
  clearColumns() {
  }
  reinitializeColumnWidths(e) {
  }
  renderRows() {
  }
  renderColumns() {
  }
  rerenderRows(e) {
    e && e();
  }
  rerenderColumns(e, t) {
  }
  renderRowCells(e) {
  }
  rerenderRowCells(e, t) {
  }
  scrollColumns(e, t) {
  }
  scrollRows(e, t) {
  }
  resize() {
  }
  scrollToRow(e) {
  }
  scrollToRowNearestTop(e) {
  }
  visibleRows(e) {
    return [];
  }
  ///////////////////////////////////
  //////// Helper Functions /////////
  ///////////////////////////////////
  rows() {
    return this.table.rowManager.getDisplayRows();
  }
  styleRow(e, t) {
    var i = e.getElement();
    t % 2 ? (i.classList.add("tabulator-row-even"), i.classList.remove("tabulator-row-odd")) : (i.classList.add("tabulator-row-odd"), i.classList.remove("tabulator-row-even"));
  }
  ///////////////////////////////////
  /////// External Triggers /////////
  /////// (DO NOT OVERRIDE) /////////
  ///////////////////////////////////
  clear() {
    this.clearRows(), this.clearColumns();
  }
  render() {
    this.renderRows(), this.renderColumns();
  }
  rerender(e) {
    this.rerenderRows(), this.rerenderColumns();
  }
  scrollToRowPosition(e, t, i) {
    var n = this.rows().indexOf(e), a = e.getElement(), o = 0;
    return new Promise((s, l) => {
      if (n > -1) {
        if (typeof i > "u" && (i = this.table.options.scrollToRowIfVisible), !i && Zt.elVisible(a) && (o = Zt.elOffset(a).top - Zt.elOffset(this.elementVertical).top, o > 0 && o < this.elementVertical.clientHeight - a.offsetHeight))
          return s(), !1;
        switch (typeof t > "u" && (t = this.table.options.scrollToRowPosition), t === "nearest" && (t = this.scrollToRowNearestTop(e) ? "top" : "bottom"), this.scrollToRow(e), t) {
          case "middle":
          case "center":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop + (a.offsetTop - this.elementVertical.scrollTop) - (this.elementVertical.scrollHeight - a.offsetTop) / 2 : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight / 2;
            break;
          case "bottom":
            this.elementVertical.scrollHeight - this.elementVertical.scrollTop == this.elementVertical.clientHeight ? this.elementVertical.scrollTop = this.elementVertical.scrollTop - (this.elementVertical.scrollHeight - a.offsetTop) + a.offsetHeight : this.elementVertical.scrollTop = this.elementVertical.scrollTop - this.elementVertical.clientHeight + a.offsetHeight;
            break;
          case "top":
            this.elementVertical.scrollTop = a.offsetTop;
            break;
        }
        s();
      } else
        console.warn("Scroll Error - Row not visible"), l("Scroll Error - Row not visible");
    });
  }
}
class iBe extends Ey {
  constructor(e) {
    super(e);
  }
  renderRowCells(e) {
    const t = document.createDocumentFragment();
    e.cells.forEach((i) => {
      t.appendChild(i.getElement());
    }), e.element.appendChild(t), e.cells.forEach((i) => {
      i.cellRendered();
    });
  }
  reinitializeColumnWidths(e) {
    e.forEach(function(t) {
      t.reinitializeWidth();
    });
  }
}
class nBe extends Ey {
  constructor(e) {
    super(e), this.leftCol = 0, this.rightCol = 0, this.scrollLeft = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0, this.fitDataColAvg = 0, this.windowBuffer = 200, this.visibleRows = null, this.initialized = !1, this.isFitData = !1, this.columns = [];
  }
  initialize() {
    this.compatibilityCheck(), this.layoutCheck(), this.vertScrollListen();
  }
  compatibilityCheck() {
    this.options("layout") == "fitDataTable" && console.warn("Horizontal Virtual DOM is not compatible with fitDataTable layout mode"), this.options("responsiveLayout") && console.warn("Horizontal Virtual DOM is not compatible with responsive columns"), this.options("rtl") && console.warn("Horizontal Virtual DOM is not currently compatible with RTL text direction");
  }
  layoutCheck() {
    this.isFitData = this.options("layout").startsWith("fitData");
  }
  vertScrollListen() {
    this.subscribe("scroll-vertical", this.clearVisRowCache.bind(this)), this.subscribe("data-refreshed", this.clearVisRowCache.bind(this));
  }
  clearVisRowCache() {
    this.visibleRows = null;
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  renderColumns(e, t) {
    this.dataChange();
  }
  scrollColumns(e, t) {
    this.scrollLeft != e && (this.scrollLeft = e, this.scroll(e - (this.vDomScrollPosLeft + this.windowBuffer)));
  }
  calcWindowBuffer() {
    var e = this.elementVertical.clientWidth;
    this.table.columnManager.columnsByIndex.forEach((t) => {
      if (t.visible) {
        var i = t.getWidth();
        i > e && (e = i);
      }
    }), this.windowBuffer = e * 2;
  }
  rerenderColumns(e, t) {
    var i = {
      cols: this.columns,
      leftCol: this.leftCol,
      rightCol: this.rightCol
    }, n = 0;
    e && !this.initialized || (this.clear(), this.calcWindowBuffer(), this.scrollLeft = this.elementVertical.scrollLeft, this.vDomScrollPosLeft = this.scrollLeft - this.windowBuffer, this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, this.table.columnManager.columnsByIndex.forEach((a) => {
      var o = {}, s;
      a.visible && (a.modules.frozen || (s = a.getWidth(), o.leftPos = n, o.rightPos = n + s, o.width = s, this.isFitData && (o.fitDataCheck = a.modules.vdomHoz ? a.modules.vdomHoz.fitDataCheck : !0), n + s > this.vDomScrollPosLeft && n < this.vDomScrollPosRight ? (this.leftCol == -1 && (this.leftCol = this.columns.length, this.vDomPadLeft = n), this.rightCol = this.columns.length) : this.leftCol !== -1 && (this.vDomPadRight += s), this.columns.push(a), a.modules.vdomHoz = o, n += s));
    }), this.tableElement.style.paddingLeft = this.vDomPadLeft + "px", this.tableElement.style.paddingRight = this.vDomPadRight + "px", this.initialized = !0, t || (!e || this.reinitChanged(i)) && this.reinitializeRows(), this.elementVertical.scrollLeft = this.scrollLeft);
  }
  renderRowCells(e) {
    if (this.initialized)
      this.initializeRow(e);
    else {
      const t = document.createDocumentFragment();
      e.cells.forEach((i) => {
        t.appendChild(i.getElement());
      }), e.element.appendChild(t), e.cells.forEach((i) => {
        i.cellRendered();
      });
    }
  }
  rerenderRowCells(e, t) {
    this.reinitializeRow(e, t);
  }
  reinitializeColumnWidths(e) {
    for (let t = this.leftCol; t <= this.rightCol; t++)
      this.columns[t].reinitializeWidth();
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  deinitialize() {
    this.initialized = !1;
  }
  clear() {
    this.columns = [], this.leftCol = -1, this.rightCol = 0, this.vDomScrollPosLeft = 0, this.vDomScrollPosRight = 0, this.vDomPadLeft = 0, this.vDomPadRight = 0;
  }
  dataChange() {
    var e = !1, t, i;
    if (this.isFitData) {
      if (this.table.columnManager.columnsByIndex.forEach((n) => {
        !n.definition.width && n.visible && (e = !0);
      }), e && this.table.rowManager.getDisplayRows().length && (this.vDomScrollPosRight = this.scrollLeft + this.elementVertical.clientWidth + this.windowBuffer, t = this.chain("rows-sample", [1], [], () => this.table.rowManager.getDisplayRows())[0], t)) {
        i = t.getElement(), t.generateCells(), this.tableElement.appendChild(i);
        for (let n = 0; n < t.cells.length; n++) {
          let a = t.cells[n];
          i.appendChild(a.getElement()), a.column.reinitializeWidth();
        }
        i.parentNode.removeChild(i), this.rerenderColumns(!1, !0);
      }
    } else
      this.options("layout") === "fitColumns" && (this.layoutRefresh(), this.rerenderColumns(!1, !0));
  }
  reinitChanged(e) {
    var t = !0;
    return e.cols.length !== this.columns.length || e.leftCol !== this.leftCol || e.rightCol !== this.rightCol ? !0 : (e.cols.forEach((i, n) => {
      i !== this.columns[n] && (t = !1);
    }), !t);
  }
  reinitializeRows() {
    var e = this.getVisibleRows(), t = this.table.rowManager.getRows().filter((i) => !e.includes(i));
    e.forEach((i) => {
      this.reinitializeRow(i, !0);
    }), t.forEach((i) => {
      i.deinitialize();
    });
  }
  getVisibleRows() {
    return this.visibleRows || (this.visibleRows = this.table.rowManager.getVisibleRows()), this.visibleRows;
  }
  scroll(e) {
    this.vDomScrollPosLeft += e, this.vDomScrollPosRight += e, Math.abs(e) > this.windowBuffer / 2 ? this.rerenderColumns() : e > 0 ? (this.addColRight(), this.removeColLeft()) : (this.addColLeft(), this.removeColRight());
  }
  colPositionAdjust(e, t, i) {
    for (let n = e; n < t; n++) {
      let a = this.columns[n];
      a.modules.vdomHoz.leftPos += i, a.modules.vdomHoz.rightPos += i;
    }
  }
  addColRight() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.rightCol + 1];
      i && i.modules.vdomHoz.leftPos <= this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((n) => {
        if (n.type !== "group") {
          var a = n.getCell(i);
          n.getElement().insertBefore(a.getElement(), n.getCell(this.columns[this.rightCol]).getElement().nextSibling), a.cellRendered();
        }
      }), this.fitDataColActualWidthCheck(i), this.rightCol++, this.getVisibleRows().forEach((n) => {
        n.type !== "group" && (n.modules.vdomHoz.rightCol = this.rightCol);
      }), this.rightCol >= this.columns.length - 1 ? this.vDomPadRight = 0 : this.vDomPadRight -= i.getWidth()) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  addColLeft() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.leftCol - 1];
      if (i)
        if (i.modules.vdomHoz.rightPos >= this.vDomScrollPosLeft) {
          e = !0, this.getVisibleRows().forEach((a) => {
            if (a.type !== "group") {
              var o = a.getCell(i);
              a.getElement().insertBefore(o.getElement(), a.getCell(this.columns[this.leftCol]).getElement()), o.cellRendered();
            }
          }), this.leftCol--, this.getVisibleRows().forEach((a) => {
            a.type !== "group" && (a.modules.vdomHoz.leftCol = this.leftCol);
          }), this.leftCol <= 0 ? this.vDomPadLeft = 0 : this.vDomPadLeft -= i.getWidth();
          let n = this.fitDataColActualWidthCheck(i);
          n && (this.scrollLeft = this.elementVertical.scrollLeft = this.elementVertical.scrollLeft + n, this.vDomPadRight -= n);
        } else
          t = !1;
      else
        t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  removeColRight() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.rightCol];
      i && i.modules.vdomHoz.leftPos > this.vDomScrollPosRight ? (e = !0, this.getVisibleRows().forEach((n) => {
        if (n.type !== "group") {
          var a = n.getCell(i);
          try {
            n.getElement().removeChild(a.getElement());
          } catch (o) {
            console.warn("Could not removeColRight", o.message);
          }
        }
      }), this.vDomPadRight += i.getWidth(), this.rightCol--, this.getVisibleRows().forEach((n) => {
        n.type !== "group" && (n.modules.vdomHoz.rightCol = this.rightCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingRight = this.vDomPadRight + "px");
  }
  removeColLeft() {
    for (var e = !1, t = !0; t; ) {
      let i = this.columns[this.leftCol];
      i && i.modules.vdomHoz.rightPos < this.vDomScrollPosLeft ? (e = !0, this.getVisibleRows().forEach((n) => {
        if (n.type !== "group") {
          var a = n.getCell(i);
          try {
            n.getElement().removeChild(a.getElement());
          } catch (o) {
            console.warn("Could not removeColLeft", o.message);
          }
        }
      }), this.vDomPadLeft += i.getWidth(), this.leftCol++, this.getVisibleRows().forEach((n) => {
        n.type !== "group" && (n.modules.vdomHoz.leftCol = this.leftCol);
      })) : t = !1;
    }
    e && (this.tableElement.style.paddingLeft = this.vDomPadLeft + "px");
  }
  fitDataColActualWidthCheck(e) {
    var t, i;
    return e.modules.vdomHoz.fitDataCheck && (e.reinitializeWidth(), t = e.getWidth(), i = t - e.modules.vdomHoz.width, i && (e.modules.vdomHoz.rightPos += i, e.modules.vdomHoz.width = t, this.colPositionAdjust(this.columns.indexOf(e) + 1, this.columns.length, i)), e.modules.vdomHoz.fitDataCheck = !1), i;
  }
  initializeRow(e) {
    if (e.type !== "group") {
      e.modules.vdomHoz = {
        leftCol: this.leftCol,
        rightCol: this.rightCol
      }, this.table.modules.frozenColumns && this.table.modules.frozenColumns.leftColumns.forEach((t) => {
        this.appendCell(e, t);
      });
      for (let t = this.leftCol; t <= this.rightCol; t++)
        this.appendCell(e, this.columns[t]);
      this.table.modules.frozenColumns && this.table.modules.frozenColumns.rightColumns.forEach((t) => {
        this.appendCell(e, t);
      });
    }
  }
  appendCell(e, t) {
    if (t && t.visible) {
      let i = e.getCell(t);
      e.getElement().appendChild(i.getElement()), i.cellRendered();
    }
  }
  reinitializeRow(e, t) {
    if (e.type !== "group" && (t || !e.modules.vdomHoz || e.modules.vdomHoz.leftCol !== this.leftCol || e.modules.vdomHoz.rightCol !== this.rightCol)) {
      for (var i = e.getElement(); i.firstChild; )
        i.removeChild(i.firstChild);
      this.initializeRow(e);
    }
  }
}
class aBe extends an {
  constructor(e) {
    super(e), this.blockHozScrollEvent = !1, this.headersElement = null, this.contentsElement = null, this.element = null, this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.scrollLeft = 0, this.optionsList = new Hq(this.table, "column definition", Fq), this.redrawBlock = !1, this.redrawBlockUpdate = null, this.renderer = null;
  }
  ////////////// Setup Functions /////////////////
  initialize() {
    this.initializeRenderer(), this.headersElement = this.createHeadersElement(), this.contentsElement = this.createHeaderContentsElement(), this.element = this.createHeaderElement(), this.contentsElement.insertBefore(this.headersElement, this.contentsElement.firstChild), this.element.insertBefore(this.contentsElement, this.element.firstChild), this.initializeScrollWheelWatcher(), this.subscribe("scroll-horizontal", this.scrollHorizontal.bind(this)), this.subscribe("scrollbar-vertical", this.padVerticalScrollbar.bind(this));
  }
  padVerticalScrollbar(e) {
    this.table.rtl ? this.headersElement.style.marginLeft = e + "px" : this.headersElement.style.marginRight = e + "px";
  }
  initializeRenderer() {
    var e, t = {
      virtual: nBe,
      basic: iBe
    };
    typeof this.table.options.renderHorizontal == "string" ? e = t[this.table.options.renderHorizontal] : e = this.table.options.renderHorizontal, e ? (this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize()) : console.error("Unable to find matching renderer:", this.table.options.renderHorizontal);
  }
  createHeadersElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-headers"), e.setAttribute("role", "row"), e;
  }
  createHeaderContentsElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header-contents"), e.setAttribute("role", "rowgroup"), e;
  }
  createHeaderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-header"), e.setAttribute("role", "rowgroup"), this.table.options.headerVisible || e.classList.add("tabulator-header-hidden"), e;
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return containing contents element
  getContentsElement() {
    return this.contentsElement;
  }
  //return header containing element
  getHeadersElement() {
    return this.headersElement;
  }
  //scroll horizontally to match table body
  scrollHorizontal(e) {
    this.contentsElement.scrollLeft = e, this.scrollLeft = e, this.renderer.scrollColumns(e);
  }
  initializeScrollWheelWatcher() {
    this.contentsElement.addEventListener("wheel", (e) => {
      var t;
      e.deltaX && (t = this.contentsElement.scrollLeft + e.deltaX, this.table.rowManager.scrollHorizontal(t), this.table.columnManager.scrollHorizontal(t));
    });
  }
  ///////////// Column Setup Functions /////////////
  generateColumnsFromRowData(e) {
    var t = [], i = this.table.options.autoColumnsDefinitions, n, a;
    if (e && e.length) {
      n = e[0];
      for (var o in n) {
        let s = {
          field: o,
          title: o
        }, l = n[o];
        switch (typeof l) {
          case "undefined":
            a = "string";
            break;
          case "boolean":
            a = "boolean";
            break;
          case "object":
            Array.isArray(l) ? a = "array" : a = "string";
            break;
          default:
            !isNaN(l) && l !== "" ? a = "number" : l.match(/((^[0-9]+[a-z]+)|(^[a-z]+[0-9]+))+$/i) ? a = "alphanum" : a = "string";
            break;
        }
        s.sorter = a, t.push(s);
      }
      if (i)
        switch (typeof i) {
          case "function":
            this.table.options.columns = i.call(this.table, t);
            break;
          case "object":
            Array.isArray(i) ? t.forEach((s) => {
              var l = i.find((u) => u.field === s.field);
              l && Object.assign(s, l);
            }) : t.forEach((s) => {
              i[s.field] && Object.assign(s, i[s.field]);
            }), this.table.options.columns = t;
            break;
        }
      else
        this.table.options.columns = t;
      this.setColumns(this.table.options.columns);
    }
  }
  setColumns(e, t) {
    for (; this.headersElement.firstChild; )
      this.headersElement.removeChild(this.headersElement.firstChild);
    this.columns = [], this.columnsByIndex = [], this.columnsByField = {}, this.dispatch("columns-loading"), e.forEach((i, n) => {
      this._addColumn(i);
    }), this._reIndexColumns(), this.dispatch("columns-loaded"), this.rerenderColumns(!1, !0), this.redraw(!0);
  }
  _addColumn(e, t, i) {
    var n = new Eo(e, this), a = n.getElement(), o = i && this.findColumnIndex(i);
    if (i && o > -1) {
      var s = i.getTopColumn(), l = this.columns.indexOf(s), u = s.getElement();
      t ? (this.columns.splice(l, 0, n), u.parentNode.insertBefore(a, u)) : (this.columns.splice(l + 1, 0, n), u.parentNode.insertBefore(a, u.nextSibling));
    } else
      t ? (this.columns.unshift(n), this.headersElement.insertBefore(n.getElement(), this.headersElement.firstChild)) : (this.columns.push(n), this.headersElement.appendChild(n.getElement()));
    return n.columnRendered(), n;
  }
  registerColumnField(e) {
    e.definition.field && (this.columnsByField[e.definition.field] = e);
  }
  registerColumnPosition(e) {
    this.columnsByIndex.push(e);
  }
  _reIndexColumns() {
    this.columnsByIndex = [], this.columns.forEach(function(e) {
      e.reRegisterPosition();
    });
  }
  //ensure column headers take up the correct amount of space in column groups
  verticalAlignHeaders() {
    var e = 0;
    this.redrawBlock || (this.headersElement.style.height = "", this.columns.forEach((t) => {
      t.clearVerticalAlign();
    }), this.columns.forEach((t) => {
      var i = t.getHeight();
      i > e && (e = i);
    }), this.headersElement.style.height = e + "px", this.columns.forEach((t) => {
      t.verticalAlign(this.table.options.columnHeaderVertAlign, e);
    }), this.table.rowManager.adjustTableSize());
  }
  //////////////// Column Details /////////////////
  findColumn(e) {
    var t;
    if (typeof e == "object") {
      if (e instanceof Eo)
        return e;
      if (e instanceof Bq)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return t = [], this.columns.forEach((n) => {
          t.push(n), t = t.concat(n.getColumns(!0));
        }), t.find((n) => n.element === e) || !1;
    } else
      return this.columnsByField[e] || !1;
    return !1;
  }
  getColumnByField(e) {
    return this.columnsByField[e];
  }
  getColumnsByFieldRoot(e) {
    var t = [];
    return Object.keys(this.columnsByField).forEach((i) => {
      var n = i.split(".")[0];
      n === e && t.push(this.columnsByField[i]);
    }), t;
  }
  getColumnByIndex(e) {
    return this.columnsByIndex[e];
  }
  getFirstVisibleColumn() {
    var e = this.columnsByIndex.findIndex((t) => t.visible);
    return e > -1 ? this.columnsByIndex[e] : !1;
  }
  getColumns() {
    return this.columns;
  }
  findColumnIndex(e) {
    return this.columnsByIndex.findIndex((t) => e === t);
  }
  //return all columns that are not groups
  getRealColumns() {
    return this.columnsByIndex;
  }
  //traverse across columns and call action
  traverse(e) {
    this.columnsByIndex.forEach((t, i) => {
      e(t, i);
    });
  }
  //get definitions of actual columns
  getDefinitions(e) {
    var t = [];
    return this.columnsByIndex.forEach((i) => {
      (!e || e && i.visible) && t.push(i.getDefinition());
    }), t;
  }
  //get full nested definition tree
  getDefinitionTree() {
    var e = [];
    return this.columns.forEach((t) => {
      e.push(t.getDefinition(!0));
    }), e;
  }
  getComponents(e) {
    var t = [], i = e ? this.columns : this.columnsByIndex;
    return i.forEach((n) => {
      t.push(n.getComponent());
    }), t;
  }
  getWidth() {
    var e = 0;
    return this.columnsByIndex.forEach((t) => {
      t.visible && (e += t.getWidth());
    }), e;
  }
  moveColumn(e, t, i) {
    t.element.parentNode.insertBefore(e.element, t.element), i && t.element.parentNode.insertBefore(t.element, e.element), this.moveColumnActual(e, t, i), this.verticalAlignHeaders(), this.table.rowManager.reinitialize();
  }
  moveColumnActual(e, t, i) {
    e.parent.isGroup ? this._moveColumnInArray(e.parent.columns, e, t, i) : this._moveColumnInArray(this.columns, e, t, i), this._moveColumnInArray(this.columnsByIndex, e, t, i, !0), this.rerenderColumns(!0), this.dispatch("column-moved", e, t, i), this.subscribedExternal("columnMoved") && this.dispatchExternal("columnMoved", e.getComponent(), this.table.columnManager.getComponents());
  }
  _moveColumnInArray(e, t, i, n, a) {
    var o = e.indexOf(t), s, l = [];
    o > -1 && (e.splice(o, 1), s = e.indexOf(i), s > -1 ? n && (s = s + 1) : s = o, e.splice(s, 0, t), a && (l = this.chain("column-moving-rows", [t, i, n], null, []) || [], l = l.concat(this.table.rowManager.rows), l.forEach(function(u) {
      if (u.cells.length) {
        var c = u.cells.splice(o, 1)[0];
        u.cells.splice(s, 0, c);
      }
    })));
  }
  scrollToColumn(e, t, i) {
    var n = 0, a = e.getLeftOffset(), o = 0, s = e.getElement();
    return new Promise((l, u) => {
      if (typeof t > "u" && (t = this.table.options.scrollToColumnPosition), typeof i > "u" && (i = this.table.options.scrollToColumnIfVisible), e.visible) {
        switch (t) {
          case "middle":
          case "center":
            o = -this.element.clientWidth / 2;
            break;
          case "right":
            o = s.clientWidth - this.headersElement.clientWidth;
            break;
        }
        if (!i && a > 0 && a + s.offsetWidth < this.element.clientWidth)
          return !1;
        n = a + o, n = Math.max(Math.min(n, this.table.rowManager.element.scrollWidth - this.table.rowManager.element.clientWidth), 0), this.table.rowManager.scrollHorizontal(n), this.scrollHorizontal(n), l();
      } else
        console.warn("Scroll Error - Column not visible"), u("Scroll Error - Column not visible");
    });
  }
  //////////////// Cell Management /////////////////
  generateCells(e) {
    var t = [];
    return this.columnsByIndex.forEach((i) => {
      t.push(i.generateCell(e));
    }), t;
  }
  //////////////// Column Management /////////////////
  getFlexBaseWidth() {
    var e = this.table.element.clientWidth, t = 0;
    return this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (e -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), this.columnsByIndex.forEach(function(i) {
      var n, a, o;
      i.visible && (n = i.definition.width || 0, a = parseInt(i.minWidth), typeof n == "string" ? n.indexOf("%") > -1 ? o = e / 100 * parseInt(n) : o = parseInt(n) : o = n, t += o > a ? o : a);
    }), t;
  }
  addColumn(e, t, i) {
    return new Promise((n, a) => {
      var o = this._addColumn(e, t, i);
      this._reIndexColumns(), this.dispatch("column-add", e, t, i), this.layoutMode() != "fitColumns" && o.reinitializeWidth(), this.redraw(!0), this.table.rowManager.reinitialize(), this.rerenderColumns(), n(o);
    });
  }
  //remove column from system
  deregisterColumn(e) {
    var t = e.getField(), i;
    t && delete this.columnsByField[t], i = this.columnsByIndex.indexOf(e), i > -1 && this.columnsByIndex.splice(i, 1), i = this.columns.indexOf(e), i > -1 && this.columns.splice(i, 1), this.verticalAlignHeaders(), this.redraw();
  }
  rerenderColumns(e, t) {
    this.redrawBlock ? (e === !1 || e === !0 && this.redrawBlockUpdate === null) && (this.redrawBlockUpdate = e) : this.renderer.rerenderColumns(e, t);
  }
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockUpdate = null;
  }
  restoreRedraw() {
    this.redrawBlock = !1, this.verticalAlignHeaders(), this.renderer.rerenderColumns(this.redrawBlockUpdate);
  }
  //redraw columns
  redraw(e) {
    Zt.elVisible(this.element) && this.verticalAlignHeaders(), e && (this.table.rowManager.resetScroll(), this.table.rowManager.reinitialize()), this.confirm("table-redrawing", e) || this.layoutRefresh(e), this.dispatch("table-redraw", e), this.table.footerManager.redraw();
  }
}
class oBe extends Ey {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0;
  }
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.scrollTop = 0, e.scrollLeft = 0, e.style.minWidth = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "";
  }
  renderRows() {
    var e = this.tableElement, t = !0, i = document.createDocumentFragment();
    this.rows().forEach((n, a) => {
      this.styleRow(n, a), n.initialize(!0), n.type !== "group" && (t = !1), i.appendChild(n.getElement());
    }), e.appendChild(i), t ? e.style.minWidth = this.table.columnManager.getWidth() + "px" : e.style.minWidth = "";
  }
  rerenderRows(e) {
    this.clearRows(), e && e(), this.renderRows();
  }
  scrollToRowNearestTop(e) {
    var t = Zt.elOffset(e.getElement()).top;
    return !(Math.abs(this.elementVertical.scrollTop - t) > Math.abs(this.elementVertical.scrollTop + this.elementVertical.clientHeight - t));
  }
  scrollToRow(e) {
    var t = e.getElement();
    this.elementVertical.scrollTop = Zt.elOffset(t).top - Zt.elOffset(this.elementVertical).top + this.elementVertical.scrollTop;
  }
  visibleRows(e) {
    return this.rows();
  }
}
class sBe extends Ey {
  constructor(e) {
    super(e), this.verticalFillMode = "fill", this.scrollTop = 0, this.scrollLeft = 0, this.vDomRowHeight = 20, this.vDomTop = 0, this.vDomBottom = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomMaxRenderChain = 90, this.vDomWindowBuffer = 0, this.vDomWindowMinTotalRows = 20, this.vDomWindowMinMarginRows = 5, this.vDomTopNewRows = [], this.vDomBottomNewRows = [];
  }
  //////////////////////////////////////
  ///////// Public Functions ///////////
  //////////////////////////////////////
  clearRows() {
    for (var e = this.tableElement; e.firstChild; )
      e.removeChild(e.firstChild);
    e.style.paddingTop = "", e.style.paddingBottom = "", e.style.minHeight = "", e.style.display = "", e.style.visibility = "", this.elementVertical.scrollTop = 0, this.elementVertical.scrollLeft = 0, this.scrollTop = 0, this.scrollLeft = 0, this.vDomTop = 0, this.vDomBottom = 0, this.vDomTopPad = 0, this.vDomBottomPad = 0, this.vDomScrollPosTop = 0, this.vDomScrollPosBottom = 0;
  }
  renderRows() {
    this._virtualRenderFill();
  }
  rerenderRows(e) {
    for (var t = this.elementVertical.scrollTop, i = !1, n = !1, a = this.table.rowManager.scrollLeft, o = this.rows(), s = this.vDomTop; s <= this.vDomBottom; s++)
      if (o[s]) {
        var l = t - o[s].getElement().offsetTop;
        if (n === !1 || Math.abs(l) < n)
          n = l, i = s;
        else
          break;
      }
    o.forEach((u) => {
      u.deinitializeHeight();
    }), e && e(), this.rows().length ? this._virtualRenderFill(i === !1 ? this.rows.length - 1 : i, !0, n || 0) : (this.clear(), this.table.rowManager.tableEmpty()), this.scrollColumns(a);
  }
  scrollColumns(e) {
    this.table.rowManager.scrollHorizontal(e);
  }
  scrollRows(e, t) {
    var i = e - this.vDomScrollPosTop, n = e - this.vDomScrollPosBottom, a = this.vDomWindowBuffer * 2, o = this.rows();
    if (this.scrollTop = e, -i > a || n > a) {
      var s = this.table.rowManager.scrollLeft;
      this._virtualRenderFill(Math.floor(this.elementVertical.scrollTop / this.elementVertical.scrollHeight * o.length)), this.scrollColumns(s);
    } else
      t ? (i < 0 && this._addTopRow(o, -i), n < 0 && (this.vDomScrollHeight - this.scrollTop > this.vDomWindowBuffer ? this._removeBottomRow(o, -n) : this.vDomScrollPosBottom = this.scrollTop)) : (n >= 0 && this._addBottomRow(o, n), i >= 0 && (this.scrollTop > this.vDomWindowBuffer ? this._removeTopRow(o, i) : this.vDomScrollPosTop = this.scrollTop));
  }
  resize() {
    this.vDomWindowBuffer = this.table.options.renderVerticalBuffer || this.elementVertical.clientHeight;
  }
  scrollToRowNearestTop(e) {
    var t = this.rows().indexOf(e);
    return !(Math.abs(this.vDomTop - t) > Math.abs(this.vDomBottom - t));
  }
  scrollToRow(e) {
    var t = this.rows().indexOf(e);
    t > -1 && this._virtualRenderFill(t, !0);
  }
  visibleRows(e) {
    var t = this.elementVertical.scrollTop, i = this.elementVertical.clientHeight + t, n = !1, a = 0, o = 0, s = this.rows();
    if (e)
      a = this.vDomTop, o = this.vDomBottom;
    else
      for (var l = this.vDomTop; l <= this.vDomBottom; l++)
        if (s[l])
          if (n)
            if (i - s[l].getElement().offsetTop >= 0)
              o = l;
            else
              break;
          else if (t - s[l].getElement().offsetTop >= 0)
            a = l;
          else if (n = !0, i - s[l].getElement().offsetTop >= 0)
            o = l;
          else
            break;
    return s.slice(a, o + 1);
  }
  //////////////////////////////////////
  //////// Internal Rendering //////////
  //////////////////////////////////////
  //full virtual render
  _virtualRenderFill(e, t, i) {
    var n = this.tableElement, a = this.elementVertical, o = 0, s = 0, l = 0, u = 0, c = 0, h = 0, f = this.rows(), d = f.length, p = 0, g, v, O = [], m = 0, E = 0, b = this.table.rowManager.fixedHeight, S = this.elementVertical.clientHeight, T = this.table.options.rowHeight, y = !0;
    if (e = e || 0, i = i || 0, !e)
      this.clear();
    else {
      for (; n.firstChild; )
        n.removeChild(n.firstChild);
      u = (d - e + 1) * this.vDomRowHeight, u < S && (e -= Math.ceil((S - u) / this.vDomRowHeight), e < 0 && (e = 0)), o = Math.min(Math.max(Math.floor(this.vDomWindowBuffer / this.vDomRowHeight), this.vDomWindowMinMarginRows), e), e -= o;
    }
    if (d && Zt.elVisible(this.elementVertical)) {
      for (this.vDomTop = e, this.vDomBottom = e - 1, b || this.table.options.maxHeight ? (T && (E = S / T + this.vDomWindowBuffer / T), E = Math.max(this.vDomWindowMinTotalRows, Math.ceil(E))) : E = d; (E == d || s <= S + this.vDomWindowBuffer || m < this.vDomWindowMinTotalRows) && this.vDomBottom < d - 1; ) {
        for (O = [], v = document.createDocumentFragment(), h = 0; h < E && this.vDomBottom < d - 1; )
          p = this.vDomBottom + 1, g = f[p], this.styleRow(g, p), g.initialize(), !g.heightInitialized && !this.table.options.rowHeight && g.clearCellHeight(), v.appendChild(g.getElement()), O.push(g), this.vDomBottom++, h++;
        if (!O.length)
          break;
        n.appendChild(v), O.forEach((R) => {
          R.heightInitialized || R.calcHeight(!0);
        }), O.forEach((R) => {
          R.heightInitialized || R.setCellHeight();
        }), O.forEach((R) => {
          l = R.getHeight(), m < o ? c += l : s += l, l > this.vDomWindowBuffer && (this.vDomWindowBuffer = l * 2), m++;
        }), y = this.table.rowManager.adjustTableSize(), S = this.elementVertical.clientHeight, y && (b || this.table.options.maxHeight) && (T = s / m, E = Math.max(this.vDomWindowMinTotalRows, Math.ceil(S / T + this.vDomWindowBuffer / T)));
      }
      e ? (this.vDomTopPad = t ? this.vDomRowHeight * this.vDomTop + i : this.scrollTop - c, this.vDomBottomPad = this.vDomBottom == d - 1 ? 0 : Math.max(this.vDomScrollHeight - this.vDomTopPad - s - c, 0)) : (this.vDomTopPad = 0, this.vDomRowHeight = Math.floor((s + c) / m), this.vDomBottomPad = this.vDomRowHeight * (d - this.vDomBottom - 1), this.vDomScrollHeight = c + s + this.vDomBottomPad - S), n.style.paddingTop = this.vDomTopPad + "px", n.style.paddingBottom = this.vDomBottomPad + "px", t && (this.scrollTop = this.vDomTopPad + c + i - (this.elementVertical.scrollWidth > this.elementVertical.clientWidth ? this.elementVertical.offsetHeight - S : 0)), this.scrollTop = Math.min(this.scrollTop, this.elementVertical.scrollHeight - S), this.elementVertical.scrollWidth > this.elementVertical.clientWidth && t && (this.scrollTop += this.elementVertical.offsetHeight - S), this.vDomScrollPosTop = this.scrollTop, this.vDomScrollPosBottom = this.scrollTop, a.scrollTop = this.scrollTop, this.dispatch("render-virtual-fill");
    }
  }
  _addTopRow(e, t) {
    for (var i = this.tableElement, n = [], a = 0, o = this.vDomTop - 1, s = 0, l = !0; l; )
      if (this.vDomTop) {
        let u = e[o], c, h;
        u && s < this.vDomMaxRenderChain ? (c = u.getHeight() || this.vDomRowHeight, h = u.initialized, t >= c ? (this.styleRow(u, o), i.insertBefore(u.getElement(), i.firstChild), (!u.initialized || !u.heightInitialized) && n.push(u), u.initialize(), h || (c = u.getElement().offsetHeight, c > this.vDomWindowBuffer && (this.vDomWindowBuffer = c * 2)), t -= c, a += c, this.vDomTop--, o--, s++) : l = !1) : l = !1;
      } else
        l = !1;
    for (let u of n)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(n), a && (this.vDomTopPad -= a, this.vDomTopPad < 0 && (this.vDomTopPad = o * this.vDomRowHeight), o < 1 && (this.vDomTopPad = 0), i.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop -= a);
  }
  _removeTopRow(e, t) {
    for (var i = [], n = 0, a = 0, o = !0; o; ) {
      let s = e[this.vDomTop], l;
      s && a < this.vDomMaxRenderChain ? (l = s.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomTop++, t -= l, n += l, i.push(s), a++) : o = !1) : o = !1;
    }
    for (let s of i) {
      let l = s.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    n && (this.vDomTopPad += n, this.tableElement.style.paddingTop = this.vDomTopPad + "px", this.vDomScrollPosTop += this.vDomTop ? n : n + this.vDomWindowBuffer);
  }
  _addBottomRow(e, t) {
    for (var i = this.tableElement, n = [], a = 0, o = this.vDomBottom + 1, s = 0, l = !0; l; ) {
      let u = e[o], c, h;
      u && s < this.vDomMaxRenderChain ? (c = u.getHeight() || this.vDomRowHeight, h = u.initialized, t >= c ? (this.styleRow(u, o), i.appendChild(u.getElement()), (!u.initialized || !u.heightInitialized) && n.push(u), u.initialize(), h || (c = u.getElement().offsetHeight, c > this.vDomWindowBuffer && (this.vDomWindowBuffer = c * 2)), t -= c, a += c, this.vDomBottom++, o++, s++) : l = !1) : l = !1;
    }
    for (let u of n)
      u.clearCellHeight();
    this._quickNormalizeRowHeight(n), a && (this.vDomBottomPad -= a, (this.vDomBottomPad < 0 || o == e.length - 1) && (this.vDomBottomPad = 0), i.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom += a);
  }
  _removeBottomRow(e, t) {
    for (var i = [], n = 0, a = 0, o = !0; o; ) {
      let s = e[this.vDomBottom], l;
      s && a < this.vDomMaxRenderChain ? (l = s.getHeight() || this.vDomRowHeight, t >= l ? (this.vDomBottom--, t -= l, n += l, i.push(s), a++) : o = !1) : o = !1;
    }
    for (let s of i) {
      let l = s.getElement();
      l.parentNode && l.parentNode.removeChild(l);
    }
    n && (this.vDomBottomPad += n, this.vDomBottomPad < 0 && (this.vDomBottomPad = 0), this.tableElement.style.paddingBottom = this.vDomBottomPad + "px", this.vDomScrollPosBottom -= n);
  }
  _quickNormalizeRowHeight(e) {
    for (let t of e)
      t.calcHeight();
    for (let t of e)
      t.setCellHeight();
  }
}
class lBe extends an {
  constructor(e) {
    super(e), this.element = this.createHolderElement(), this.tableElement = this.createTableElement(), this.heightFixer = this.createTableElement(), this.placeholder = null, this.placeholderContents = null, this.firstRender = !1, this.renderMode = "virtual", this.fixedHeight = !1, this.rows = [], this.activeRowsPipeline = [], this.activeRows = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0, this.scrollTop = 0, this.scrollLeft = 0, this.redrawBlock = !1, this.redrawBlockRestoreConfig = !1, this.redrawBlockRenderInPosition = !1, this.dataPipeline = [], this.displayPipeline = [], this.scrollbarWidth = 0, this.renderer = null;
  }
  //////////////// Setup Functions /////////////////
  createHolderElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-tableholder"), e.setAttribute("tabindex", 0), e;
  }
  createTableElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-table"), e.setAttribute("role", "rowgroup"), e;
  }
  initializePlaceholder() {
    var e = this.table.options.placeholder;
    if (typeof e == "function" && (e = e.call(this.table)), e = this.chain("placeholder", [e], e, e) || e, e) {
      let t = document.createElement("div");
      if (t.classList.add("tabulator-placeholder"), typeof e == "string") {
        let i = document.createElement("div");
        i.classList.add("tabulator-placeholder-contents"), i.innerHTML = e, t.appendChild(i), this.placeholderContents = i;
      } else
        typeof HTMLElement < "u" && e instanceof HTMLElement ? (t.appendChild(e), this.placeholderContents = e) : (console.warn("Invalid placeholder provided, must be string or HTML Element", e), this.el = null);
      this.placeholder = t;
    }
  }
  //return containing element
  getElement() {
    return this.element;
  }
  //return table element
  getTableElement() {
    return this.tableElement;
  }
  initialize() {
    this.initializePlaceholder(), this.initializeRenderer(), this.element.appendChild(this.tableElement), this.firstRender = !0, this.element.addEventListener("scroll", () => {
      var e = this.element.scrollLeft, t = this.scrollLeft > e, i = this.element.scrollTop, n = this.scrollTop > i;
      this.scrollLeft != e && (this.scrollLeft = e, this.dispatch("scroll-horizontal", e, t), this.dispatchExternal("scrollHorizontal", e, t), this._positionPlaceholder()), this.scrollTop != i && (this.scrollTop = i, this.renderer.scrollRows(i, n), this.dispatch("scroll-vertical", i, n), this.dispatchExternal("scrollVertical", i, n));
    });
  }
  ////////////////// Row Manipulation //////////////////
  findRow(e) {
    if (typeof e == "object") {
      if (e instanceof Pi)
        return e;
      if (e instanceof Oy)
        return e._getSelf() || !1;
      if (typeof HTMLElement < "u" && e instanceof HTMLElement)
        return this.rows.find((i) => i.getElement() === e) || !1;
      if (e === null)
        return !1;
    } else
      return typeof e > "u" ? !1 : this.rows.find((i) => i.data[this.table.options.index] == e) || !1;
    return !1;
  }
  getRowFromDataObject(e) {
    var t = this.rows.find((i) => i.data === e);
    return t || !1;
  }
  getRowFromPosition(e) {
    return this.getDisplayRows().find((t) => t.getPosition() === e && t.isDisplayed());
  }
  scrollToRow(e, t, i) {
    return this.renderer.scrollToRowPosition(e, t, i);
  }
  ////////////////// Data Handling //////////////////
  setData(e, t, i) {
    return new Promise((n, a) => {
      t && this.getDisplayRows().length ? this.table.options.pagination ? this._setDataActual(e, !0) : this.reRenderInPosition(() => {
        this._setDataActual(e);
      }) : (this.table.options.autoColumns && i && this.table.initialized && this.table.columnManager.generateColumnsFromRowData(e), this.resetScroll(), this._setDataActual(e)), n();
    });
  }
  _setDataActual(e, t) {
    this.dispatchExternal("dataProcessing", e), this._wipeElements(), Array.isArray(e) ? (this.dispatch("data-processing", e), e.forEach((i, n) => {
      if (i && typeof i == "object") {
        var a = new Pi(i, this);
        this.rows.push(a);
      } else
        console.warn("Data Loading Warning - Invalid row data detected and ignored, expecting object but received:", i);
    }), this.refreshActiveData(!1, !1, t), this.dispatch("data-processed", e), this.dispatchExternal("dataProcessed", e)) : console.error(`Data Loading Error - Unable to process data due to invalid data type 
Expecting: array 
Received: `, typeof e, `
Data:     `, e);
  }
  _wipeElements() {
    this.dispatch("rows-wipe"), this.destroy(), this.adjustTableSize(), this.dispatch("rows-wiped");
  }
  destroy() {
    this.rows.forEach((e) => {
      e.wipe();
    }), this.rows = [], this.activeRows = [], this.activeRowsPipeline = [], this.activeRowsCount = 0, this.displayRows = [], this.displayRowsCount = 0;
  }
  deleteRow(e, t) {
    var i = this.rows.indexOf(e), n = this.activeRows.indexOf(e);
    n > -1 && this.activeRows.splice(n, 1), i > -1 && this.rows.splice(i, 1), this.setActiveRows(this.activeRows), this.displayRowIterator((a) => {
      var o = a.indexOf(e);
      o > -1 && a.splice(o, 1);
    }), t || this.reRenderInPosition(), this.regenerateRowPositions(), this.dispatchExternal("rowDeleted", e.getComponent()), this.displayRowsCount || this.tableEmpty(), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.getData());
  }
  addRow(e, t, i, n) {
    var a = this.addRowActual(e, t, i, n);
    return a;
  }
  //add multiple rows
  addRows(e, t, i, n) {
    var a = [];
    return new Promise((o, s) => {
      t = this.findAddRowPos(t), Array.isArray(e) || (e = [e]), (typeof i > "u" && t || typeof i < "u" && !t) && e.reverse(), e.forEach((l, u) => {
        var c = this.addRow(l, t, i, !0);
        a.push(c), this.dispatch("row-added", c, l, t, i);
      }), this.refreshActiveData(n ? "displayPipeline" : !1, !1, !0), this.regenerateRowPositions(), a.length && this._clearPlaceholder(), o(a);
    });
  }
  findAddRowPos(e) {
    return typeof e > "u" && (e = this.table.options.addRowPos), e === "pos" && (e = !0), e === "bottom" && (e = !1), e;
  }
  addRowActual(e, t, i, n) {
    var a = e instanceof Pi ? e : new Pi(e || {}, this), o = this.findAddRowPos(t), s = -1, l, u;
    return i || (u = this.chain("row-adding-position", [a, o], null, { index: i, top: o }), i = u.index, o = u.top), typeof i < "u" && (i = this.findRow(i)), i = this.chain("row-adding-index", [a, i, o], null, i), i && (s = this.rows.indexOf(i)), i && s > -1 ? (l = this.activeRows.indexOf(i), this.displayRowIterator(function(c) {
      var h = c.indexOf(i);
      h > -1 && c.splice(o ? h : h + 1, 0, a);
    }), l > -1 && this.activeRows.splice(o ? l : l + 1, 0, a), this.rows.splice(o ? s : s + 1, 0, a)) : o ? (this.displayRowIterator(function(c) {
      c.unshift(a);
    }), this.activeRows.unshift(a), this.rows.unshift(a)) : (this.displayRowIterator(function(c) {
      c.push(a);
    }), this.activeRows.push(a), this.rows.push(a)), this.setActiveRows(this.activeRows), this.dispatchExternal("rowAdded", a.getComponent()), this.subscribedExternal("dataChanged") && this.dispatchExternal("dataChanged", this.table.rowManager.getData()), n || this.reRenderInPosition(), a;
  }
  moveRow(e, t, i) {
    this.dispatch("row-move", e, t, i), this.moveRowActual(e, t, i), this.regenerateRowPositions(), this.dispatch("row-moved", e, t, i), this.dispatchExternal("rowMoved", e.getComponent());
  }
  moveRowActual(e, t, i) {
    this.moveRowInArray(this.rows, e, t, i), this.moveRowInArray(this.activeRows, e, t, i), this.displayRowIterator((n) => {
      this.moveRowInArray(n, e, t, i);
    }), this.dispatch("row-moving", e, t, i);
  }
  moveRowInArray(e, t, i, n) {
    var a, o, s, l;
    if (t !== i && (a = e.indexOf(t), a > -1 && (e.splice(a, 1), o = e.indexOf(i), o > -1 ? n ? e.splice(o + 1, 0, t) : e.splice(o, 0, t) : e.splice(a, 0, t)), e === this.getDisplayRows())) {
      s = a < o ? a : o, l = o > a ? o : a + 1;
      for (let u = s; u <= l; u++)
        e[u] && this.styleRow(e[u], u);
    }
  }
  clearData() {
    this.setData([]);
  }
  getRowIndex(e) {
    return this.findRowIndex(e, this.rows);
  }
  getDisplayRowIndex(e) {
    var t = this.getDisplayRows().indexOf(e);
    return t > -1 ? t : !1;
  }
  nextDisplayRow(e, t) {
    var i = this.getDisplayRowIndex(e), n = !1;
    return i !== !1 && i < this.displayRowsCount - 1 && (n = this.getDisplayRows()[i + 1]), n && (!(n instanceof Pi) || n.type != "row") ? this.nextDisplayRow(n, t) : n;
  }
  prevDisplayRow(e, t) {
    var i = this.getDisplayRowIndex(e), n = !1;
    return i && (n = this.getDisplayRows()[i - 1]), t && n && (!(n instanceof Pi) || n.type != "row") ? this.prevDisplayRow(n, t) : n;
  }
  findRowIndex(e, t) {
    var i;
    return e = this.findRow(e), e && (i = t.indexOf(e), i > -1) ? i : !1;
  }
  getData(e, t) {
    var i = [], n = this.getRows(e);
    return n.forEach(function(a) {
      a.type == "row" && i.push(a.getData(t || "data"));
    }), i;
  }
  getComponents(e) {
    var t = [], i = this.getRows(e);
    return i.forEach(function(n) {
      t.push(n.getComponent());
    }), t;
  }
  getDataCount(e) {
    var t = this.getRows(e);
    return t.length;
  }
  scrollHorizontal(e) {
    this.scrollLeft = e, this.element.scrollLeft = e, this.dispatch("scroll-horizontal", e);
  }
  registerDataPipelineHandler(e, t) {
    typeof t < "u" ? (this.dataPipeline.push({ handler: e, priority: t }), this.dataPipeline.sort((i, n) => i.priority - n.priority)) : console.error("Data pipeline handlers must have a priority in order to be registered");
  }
  registerDisplayPipelineHandler(e, t) {
    typeof t < "u" ? (this.displayPipeline.push({ handler: e, priority: t }), this.displayPipeline.sort((i, n) => i.priority - n.priority)) : console.error("Display pipeline handlers must have a priority in order to be registered");
  }
  //set active data set
  refreshActiveData(e, t, i) {
    var n = this.table, a = "", o = 0, s = ["all", "dataPipeline", "display", "displayPipeline", "end"];
    if (!this.table.destroyed) {
      if (typeof e == "function")
        if (o = this.dataPipeline.findIndex((l) => l.handler === e), o > -1)
          a = "dataPipeline", t && (o == this.dataPipeline.length - 1 ? a = "display" : o++);
        else if (o = this.displayPipeline.findIndex((l) => l.handler === e), o > -1)
          a = "displayPipeline", t && (o == this.displayPipeline.length - 1 ? a = "end" : o++);
        else {
          console.error("Unable to refresh data, invalid handler provided", e);
          return;
        }
      else
        a = e || "all", o = 0;
      if (this.redrawBlock) {
        (!this.redrawBlockRestoreConfig || this.redrawBlockRestoreConfig && (this.redrawBlockRestoreConfig.stage === a && o < this.redrawBlockRestoreConfig.index || s.indexOf(a) < s.indexOf(this.redrawBlockRestoreConfig.stage))) && (this.redrawBlockRestoreConfig = {
          handler: e,
          skipStage: t,
          renderInPosition: i,
          stage: a,
          index: o
        });
        return;
      } else
        Zt.elVisible(this.element) ? i ? this.reRenderInPosition(this.refreshPipelines.bind(this, e, a, o, i)) : (this.refreshPipelines(e, a, o, i), e || this.table.columnManager.renderer.renderColumns(), this.renderTable(), n.options.layoutColumnsOnNewData && this.table.columnManager.redraw(!0)) : this.refreshPipelines(e, a, o, i), this.dispatch("data-refreshed");
    }
  }
  refreshPipelines(e, t, i, n) {
    switch (this.dispatch("data-refreshing"), e || (this.activeRowsPipeline[0] = this.rows.slice(0)), t) {
      case "all":
      case "dataPipeline":
        for (let a = i; a < this.dataPipeline.length; a++) {
          let o = this.dataPipeline[a].handler(this.activeRowsPipeline[a].slice(0));
          this.activeRowsPipeline[a + 1] = o || this.activeRowsPipeline[a].slice(0);
        }
        this.setActiveRows(this.activeRowsPipeline[this.dataPipeline.length]);
      case "display":
        i = 0, this.resetDisplayRows();
      case "displayPipeline":
        for (let a = i; a < this.displayPipeline.length; a++) {
          let o = this.displayPipeline[a].handler((a ? this.getDisplayRows(a - 1) : this.activeRows).slice(0), n);
          this.setDisplayRows(o || this.getDisplayRows(a - 1).slice(0), a);
        }
      case "end":
        this.regenerateRowPositions();
    }
    this.getDisplayRows().length && this._clearPlaceholder();
  }
  //regenerate row positions
  regenerateRowPositions() {
    var e = this.getDisplayRows(), t = 1;
    e.forEach((i) => {
      i.type === "row" && (i.setPosition(t), t++);
    });
  }
  setActiveRows(e) {
    this.activeRows = this.activeRows = Object.assign([], e), this.activeRowsCount = this.activeRows.length;
  }
  //reset display rows array
  resetDisplayRows() {
    this.displayRows = [], this.displayRows.push(this.activeRows.slice(0)), this.displayRowsCount = this.displayRows[0].length;
  }
  //set display row pipeline data
  setDisplayRows(e, t) {
    this.displayRows[t] = e, t == this.displayRows.length - 1 && (this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length);
  }
  getDisplayRows(e) {
    return typeof e > "u" ? this.displayRows.length ? this.displayRows[this.displayRows.length - 1] : [] : this.displayRows[e] || [];
  }
  getVisibleRows(e, t) {
    var i = Object.assign([], this.renderer.visibleRows(!t));
    return e && (i = this.chain("rows-visible", [t], i, i)), i;
  }
  //repeat action across display rows
  displayRowIterator(e) {
    this.activeRowsPipeline.forEach(e), this.displayRows.forEach(e), this.displayRowsCount = this.displayRows[this.displayRows.length - 1].length;
  }
  //return only actual rows (not group headers etc)
  getRows(e) {
    var t = [];
    switch (e) {
      case "active":
        t = this.activeRows;
        break;
      case "display":
        t = this.table.rowManager.getDisplayRows();
        break;
      case "visible":
        t = this.getVisibleRows(!1, !0);
        break;
      default:
        t = this.chain("rows-retrieve", e, null, this.rows) || this.rows;
    }
    return t;
  }
  ///////////////// Table Rendering /////////////////
  //trigger rerender of table in current position
  reRenderInPosition(e) {
    this.redrawBlock ? e ? e() : this.redrawBlockRenderInPosition = !0 : (this.dispatchExternal("renderStarted"), this.renderer.rerenderRows(e), this.fixedHeight || this.adjustTableSize(), this.scrollBarCheck(), this.dispatchExternal("renderComplete"));
  }
  scrollBarCheck() {
    var e = 0;
    this.element.scrollHeight > this.element.clientHeight && (e = this.element.offsetWidth - this.element.clientWidth), e !== this.scrollbarWidth && (this.scrollbarWidth = e, this.dispatch("scrollbar-vertical", e));
  }
  initializeRenderer() {
    var e, t = {
      virtual: sBe,
      basic: oBe
    };
    typeof this.table.options.renderVertical == "string" ? e = t[this.table.options.renderVertical] : e = this.table.options.renderVertical, e ? (this.renderMode = this.table.options.renderVertical, this.renderer = new e(this.table, this.element, this.tableElement), this.renderer.initialize(), (this.table.element.clientHeight || this.table.options.height) && !(this.table.options.minHeight && this.table.options.maxHeight) ? this.fixedHeight = !0 : this.fixedHeight = !1) : console.error("Unable to find matching renderer:", this.table.options.renderVertical);
  }
  getRenderMode() {
    return this.renderMode;
  }
  renderTable() {
    this.dispatchExternal("renderStarted"), this.element.scrollTop = 0, this._clearTable(), this.displayRowsCount ? (this.renderer.renderRows(), this.firstRender && (this.firstRender = !1, this.fixedHeight || this.adjustTableSize(), this.layoutRefresh(!0))) : this.renderEmptyScroll(), this.fixedHeight || this.adjustTableSize(), this.dispatch("table-layout"), this.displayRowsCount || this._showPlaceholder(), this.scrollBarCheck(), this.dispatchExternal("renderComplete");
  }
  //show scrollbars on empty table div
  renderEmptyScroll() {
    this.placeholder ? this.tableElement.style.display = "none" : this.tableElement.style.minWidth = this.table.columnManager.getWidth() + "px";
  }
  _clearTable() {
    this._clearPlaceholder(), this.scrollTop = 0, this.scrollLeft = 0, this.renderer.clearRows();
  }
  tableEmpty() {
    this.renderEmptyScroll(), this._showPlaceholder();
  }
  _showPlaceholder() {
    this.placeholder && (this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.initializePlaceholder(), this.placeholder.setAttribute("tabulator-render-mode", this.renderMode), this.getElement().appendChild(this.placeholder), this._positionPlaceholder());
  }
  _clearPlaceholder() {
    this.placeholder && this.placeholder.parentNode && this.placeholder.parentNode.removeChild(this.placeholder), this.tableElement.style.minWidth = "", this.tableElement.style.display = "";
  }
  _positionPlaceholder() {
    this.placeholder && this.placeholder.parentNode && (this.placeholder.style.width = this.table.columnManager.getWidth() + "px", this.placeholderContents.style.width = this.table.rowManager.element.clientWidth + "px", this.placeholderContents.style.marginLeft = this.scrollLeft + "px");
  }
  styleRow(e, t) {
    var i = e.getElement();
    t % 2 ? (i.classList.add("tabulator-row-even"), i.classList.remove("tabulator-row-odd")) : (i.classList.add("tabulator-row-odd"), i.classList.remove("tabulator-row-even"));
  }
  //normalize height of active rows
  normalizeHeight() {
    this.activeRows.forEach(function(e) {
      e.normalizeHeight();
    });
  }
  //adjust the height of the table holder to fit in the Tabulator element
  adjustTableSize() {
    let e = this.element.clientHeight, t, i = !1;
    if (this.renderer.verticalFillMode === "fill") {
      let n = Math.floor(this.table.columnManager.getElement().getBoundingClientRect().height + (this.table.footerManager && this.table.footerManager.active && !this.table.footerManager.external ? this.table.footerManager.getElement().getBoundingClientRect().height : 0));
      if (this.fixedHeight) {
        t = isNaN(this.table.options.minHeight) ? this.table.options.minHeight : this.table.options.minHeight + "px";
        const a = "calc(100% - " + n + "px)";
        this.element.style.minHeight = t || "calc(100% - " + n + "px)", this.element.style.height = a, this.element.style.maxHeight = a;
      } else
        this.element.style.height = "", this.element.style.height = this.table.element.clientHeight - n + "px", this.element.scrollTop = this.scrollTop;
      this.renderer.resize(), !this.fixedHeight && e != this.element.clientHeight && (i = !0, this.subscribed("table-resize") ? this.dispatch("table-resize") : this.redraw()), this.scrollBarCheck();
    }
    return this._positionPlaceholder(), i;
  }
  //reinitialize all rows
  reinitialize() {
    this.rows.forEach(function(e) {
      e.reinitialize(!0);
    });
  }
  //prevent table from being redrawn
  blockRedraw() {
    this.redrawBlock = !0, this.redrawBlockRestoreConfig = !1;
  }
  //restore table redrawing
  restoreRedraw() {
    this.redrawBlock = !1, this.redrawBlockRestoreConfig ? (this.refreshActiveData(this.redrawBlockRestoreConfig.handler, this.redrawBlockRestoreConfig.skipStage, this.redrawBlockRestoreConfig.renderInPosition), this.redrawBlockRestoreConfig = !1) : this.redrawBlockRenderInPosition && this.reRenderInPosition(), this.redrawBlockRenderInPosition = !1;
  }
  //redraw table
  redraw(e) {
    const t = this.adjustTableSize();
    this.table.tableWidth = this.table.element.clientWidth, e ? this.renderTable() : (t && this.reRenderInPosition(), this.scrollHorizontal(this.scrollLeft));
  }
  resetScroll() {
    if (this.element.scrollLeft = 0, this.element.scrollTop = 0, this.table.browser === "ie") {
      var e = document.createEvent("Event");
      e.initEvent("scroll", !1, !0), this.element.dispatchEvent(e);
    } else
      this.element.dispatchEvent(new Event("scroll"));
  }
}
class uBe extends an {
  constructor(e) {
    super(e), this.active = !1, this.element = this.createElement(), this.containerElement = this.createContainerElement(), this.external = !1;
  }
  initialize() {
    this.initializeElement();
  }
  createElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer"), e;
  }
  createContainerElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-footer-contents"), this.element.appendChild(e), e;
  }
  initializeElement() {
    if (this.table.options.footerElement)
      switch (typeof this.table.options.footerElement) {
        case "string":
          this.table.options.footerElement[0] === "<" ? this.containerElement.innerHTML = this.table.options.footerElement : (this.external = !0, this.containerElement = document.querySelector(this.table.options.footerElement));
          break;
        default:
          this.element = this.table.options.footerElement;
          break;
      }
  }
  getElement() {
    return this.element;
  }
  append(e) {
    this.activate(), this.containerElement.appendChild(e), this.table.rowManager.adjustTableSize();
  }
  prepend(e) {
    this.activate(), this.element.insertBefore(e, this.element.firstChild), this.table.rowManager.adjustTableSize();
  }
  remove(e) {
    e.parentNode.removeChild(e), this.deactivate();
  }
  deactivate(e) {
    (!this.element.firstChild || e) && (this.external || this.element.parentNode.removeChild(this.element), this.active = !1);
  }
  activate() {
    this.active || (this.active = !0, this.external || (this.table.element.appendChild(this.getElement()), this.table.element.style.display = ""));
  }
  redraw() {
    this.dispatch("footer-redraw");
  }
}
class cBe extends an {
  constructor(e) {
    super(e), this.el = null, this.abortClasses = ["tabulator-headers", "tabulator-table"], this.previousTargets = {}, this.listeners = [
      "click",
      "dblclick",
      "contextmenu",
      "mouseenter",
      "mouseleave",
      "mouseover",
      "mouseout",
      "mousemove",
      "mouseup",
      "mousedown",
      "touchstart",
      "touchend"
    ], this.componentMap = {
      "tabulator-cell": "cell",
      "tabulator-row": "row",
      "tabulator-group": "group",
      "tabulator-col": "column"
    }, this.pseudoTrackers = {
      row: {
        subscriber: null,
        target: null
      },
      cell: {
        subscriber: null,
        target: null
      },
      group: {
        subscriber: null,
        target: null
      },
      column: {
        subscriber: null,
        target: null
      }
    }, this.pseudoTracking = !1;
  }
  initialize() {
    this.el = this.table.element, this.buildListenerMap(), this.bindSubscriptionWatchers();
  }
  buildListenerMap() {
    var e = {};
    this.listeners.forEach((t) => {
      e[t] = {
        handler: null,
        components: []
      };
    }), this.listeners = e;
  }
  bindPseudoEvents() {
    Object.keys(this.pseudoTrackers).forEach((e) => {
      this.pseudoTrackers[e].subscriber = this.pseudoMouseEnter.bind(this, e), this.subscribe(e + "-mouseover", this.pseudoTrackers[e].subscriber);
    }), this.pseudoTracking = !0;
  }
  pseudoMouseEnter(e, t, i) {
    this.pseudoTrackers[e].target !== i && (this.pseudoTrackers[e].target && this.dispatch(e + "-mouseleave", t, this.pseudoTrackers[e].target), this.pseudoMouseLeave(e, t), this.pseudoTrackers[e].target = i, this.dispatch(e + "-mouseenter", t, i));
  }
  pseudoMouseLeave(e, t) {
    var i = Object.keys(this.pseudoTrackers), n = {
      row: ["cell"],
      cell: ["row"]
    };
    i = i.filter((a) => {
      var o = n[e];
      return a !== e && (!o || o && !o.includes(a));
    }), i.forEach((a) => {
      var o = this.pseudoTrackers[a].target;
      this.pseudoTrackers[a].target && (this.dispatch(a + "-mouseleave", t, o), this.pseudoTrackers[a].target = null);
    });
  }
  bindSubscriptionWatchers() {
    var e = Object.keys(this.listeners), t = Object.values(this.componentMap);
    for (let i of t)
      for (let n of e) {
        let a = i + "-" + n;
        this.subscriptionChange(a, this.subscriptionChanged.bind(this, i, n));
      }
    this.subscribe("table-destroy", this.clearWatchers.bind(this));
  }
  subscriptionChanged(e, t, i) {
    var n = this.listeners[t].components, a = n.indexOf(e), o = !1;
    i ? a === -1 && (n.push(e), o = !0) : this.subscribed(e + "-" + t) || a > -1 && (n.splice(a, 1), o = !0), (t === "mouseenter" || t === "mouseleave") && !this.pseudoTracking && this.bindPseudoEvents(), o && this.updateEventListeners();
  }
  updateEventListeners() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.components.length ? t.handler || (t.handler = this.track.bind(this, e), this.el.addEventListener(e, t.handler)) : t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
  track(e, t) {
    var i = t.composedPath && t.composedPath() || t.path, n = this.findTargets(i);
    n = this.bindComponents(e, n), this.triggerEvents(e, t, n), this.pseudoTracking && (e == "mouseover" || e == "mouseleave") && !Object.keys(n).length && this.pseudoMouseLeave("none", t);
  }
  findTargets(e) {
    var t = {};
    let i = Object.keys(this.componentMap);
    for (let n of e) {
      let a = n.classList ? [...n.classList] : [];
      if (a.filter((l) => this.abortClasses.includes(l)).length)
        break;
      let s = a.filter((l) => i.includes(l));
      for (let l of s)
        t[this.componentMap[l]] || (t[this.componentMap[l]] = n);
    }
    return t.group && t.group === t.row && delete t.row, t;
  }
  bindComponents(e, t) {
    var i = Object.keys(t).reverse(), n = this.listeners[e], a = {}, o = {};
    for (let s of i) {
      let l, u = t[s], c = this.previousTargets[s];
      if (c && c.target === u)
        l = c.component;
      else
        switch (s) {
          case "row":
          case "group":
            (n.components.includes("row") || n.components.includes("cell") || n.components.includes("group")) && (l = this.table.rowManager.getVisibleRows(!0).find((f) => f.getElement() === u), t.row && t.row.parentNode && t.row.parentNode.closest(".tabulator-row") && (t[s] = !1));
            break;
          case "column":
            n.components.includes("column") && (l = this.table.columnManager.findColumn(u));
            break;
          case "cell":
            n.components.includes("cell") && (a.row instanceof Pi ? l = a.row.findCell(u) : t.row && console.warn("Event Target Lookup Error - The row this cell is attached to cannot be found, has the table been reinitialized without being destroyed first?"));
            break;
        }
      l && (a[s] = l, o[s] = {
        target: u,
        component: l
      });
    }
    return this.previousTargets = o, a;
  }
  triggerEvents(e, t, i) {
    var n = this.listeners[e];
    for (let a in i)
      i[a] && n.components.includes(a) && this.dispatch(a + "-" + e, t, i[a]);
  }
  clearWatchers() {
    for (let e in this.listeners) {
      let t = this.listeners[e];
      t.handler && (this.el.removeEventListener(e, t.handler), t.handler = null);
    }
  }
}
class hBe {
  constructor(e) {
    this.table = e, this.bindings = {};
  }
  bind(e, t, i) {
    this.bindings[e] || (this.bindings[e] = {}), this.bindings[e][t] ? console.warn("Unable to bind component handler, a matching function name is already bound", e, t, i) : this.bindings[e][t] = i;
  }
  handle(e, t, i) {
    if (this.bindings[e] && this.bindings[e][i] && typeof this.bindings[e][i].bind == "function")
      return this.bindings[e][i].bind(null, t);
    i !== "then" && typeof i == "string" && !i.startsWith("_") && this.table.options.debugInvalidComponentFuncs && console.error("The " + e + " component does not have a " + i + " function, have you checked that you have the correct Tabulator module installed?");
  }
}
class fBe extends an {
  constructor(e) {
    super(e), this.requestOrder = 0, this.loading = !1;
  }
  initialize() {
  }
  load(e, t, i, n, a, o) {
    var s = ++this.requestOrder;
    if (this.dispatchExternal("dataLoading", e), e && (e.indexOf("{") == 0 || e.indexOf("[") == 0) && (e = JSON.parse(e)), this.confirm("data-loading", [e, t, i, a])) {
      this.loading = !0, a || this.alertLoader(), t = this.chain("data-params", [e, i, a], t || {}, t || {}), t = this.mapParams(t, this.table.options.dataSendParams);
      var l = this.chain("data-load", [e, t, i, a], !1, Promise.resolve([]));
      return l.then((u) => {
        !Array.isArray(u) && typeof u == "object" && (u = this.mapParams(u, this.objectInvert(this.table.options.dataReceiveParams)));
        var c = this.chain("data-loaded", u, null, u);
        s == this.requestOrder ? (this.clearAlert(), c !== !1 && (this.dispatchExternal("dataLoaded", c), this.table.rowManager.setData(c, n, typeof o > "u" ? !n : o))) : console.warn("Data Load Response Blocked - An active data load request was blocked by an attempt to change table data while the request was being made");
      }).catch((u) => {
        console.error("Data Load Error: ", u), this.dispatchExternal("dataLoadError", u), a || this.alertError(), setTimeout(() => {
          this.clearAlert();
        }, this.table.options.dataLoaderErrorTimeout);
      }).finally(() => {
        this.loading = !1;
      });
    } else
      return this.dispatchExternal("dataLoaded", e), e || (e = []), this.table.rowManager.setData(e, n, typeof o > "u" ? !n : o), Promise.resolve();
  }
  mapParams(e, t) {
    var i = {};
    for (let n in e)
      i[t.hasOwnProperty(n) ? t[n] : n] = e[n];
    return i;
  }
  objectInvert(e) {
    var t = {};
    for (let i in e)
      t[e[i]] = i;
    return t;
  }
  blockActiveLoad() {
    this.requestOrder++;
  }
  alertLoader() {
    var e = typeof this.table.options.dataLoader == "function" ? this.table.options.dataLoader() : this.table.options.dataLoader;
    e && this.table.alertManager.alert(this.table.options.dataLoaderLoading || this.langText("data|loading"));
  }
  alertError() {
    this.table.alertManager.alert(this.table.options.dataLoaderError || this.langText("data|error"), "error");
  }
  clearAlert() {
    this.table.alertManager.clear();
  }
}
class dBe {
  constructor(e, t, i) {
    this.table = e, this.events = {}, this.optionsList = t || {}, this.subscriptionNotifiers = {}, this.dispatch = i ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.debug = i;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t) {
    this.events[e] || (this.events[e] = []), this.events[e].push(t), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var i;
    if (this.events[e])
      if (t)
        if (i = this.events[e].findIndex((n) => n === t), i > -1)
          this.events[e].splice(i, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
      else
        delete this.events[e];
    else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _notifySubscriptionChange(e, t) {
    var i = this.subscriptionNotifiers[e];
    i && i.forEach((n) => {
      n(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift(), i;
    return this.events[t] && this.events[t].forEach((n, a) => {
      let o = n.apply(this.table, e);
      a || (i = o);
    }), i;
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "ExternalEvent:" + e[0], (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
}
class pBe {
  constructor(e) {
    this.events = {}, this.subscriptionNotifiers = {}, this.dispatch = e ? this._debugDispatch.bind(this) : this._dispatch.bind(this), this.chain = e ? this._debugChain.bind(this) : this._chain.bind(this), this.confirm = e ? this._debugConfirm.bind(this) : this._confirm.bind(this), this.debug = e;
  }
  subscriptionChange(e, t) {
    this.subscriptionNotifiers[e] || (this.subscriptionNotifiers[e] = []), this.subscriptionNotifiers[e].push(t), this.subscribed(e) && this._notifySubscriptionChange(e, !0);
  }
  subscribe(e, t, i = 1e4) {
    this.events[e] || (this.events[e] = []), this.events[e].push({ callback: t, priority: i }), this.events[e].sort((n, a) => n.priority - a.priority), this._notifySubscriptionChange(e, !0);
  }
  unsubscribe(e, t) {
    var i;
    if (this.events[e]) {
      if (t)
        if (i = this.events[e].findIndex((n) => n.callback === t), i > -1)
          this.events[e].splice(i, 1);
        else {
          console.warn("Cannot remove event, no matching event found:", e, t);
          return;
        }
    } else {
      console.warn("Cannot remove event, no events set on:", e);
      return;
    }
    this._notifySubscriptionChange(e, !1);
  }
  subscribed(e) {
    return this.events[e] && this.events[e].length;
  }
  _chain(e, t, i, n) {
    var a = i;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) ? (this.events[e].forEach((o, s) => {
      a = o.callback.apply(this, t.concat([a]));
    }), a) : typeof n == "function" ? n() : n;
  }
  _confirm(e, t) {
    var i = !1;
    return Array.isArray(t) || (t = [t]), this.subscribed(e) && this.events[e].forEach((n, a) => {
      n.callback.apply(this, t) && (i = !0);
    }), i;
  }
  _notifySubscriptionChange(e, t) {
    var i = this.subscriptionNotifiers[e];
    i && i.forEach((n) => {
      n(t);
    });
  }
  _dispatch() {
    var e = Array.from(arguments), t = e.shift();
    this.events[t] && this.events[t].forEach((i) => {
      i.callback.apply(this, e);
    });
  }
  _debugDispatch() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._dispatch(...arguments);
  }
  _debugChain() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._chain(...arguments);
  }
  _debugConfirm() {
    var e = Array.from(arguments), t = e[0];
    return e[0] = "InternalEvent:" + t, (this.debug === !0 || this.debug.includes(t)) && console.log(...e), this._confirm(...arguments);
  }
}
class gBe extends an {
  constructor(e) {
    super(e);
  }
  _warnUser() {
    this.options("debugDeprecation") && console.warn(...arguments);
  }
  check(e, t) {
    var i = "";
    return typeof this.options(e) < "u" ? (i = "Deprecated Setup Option - Use of the %c" + e + "%c option is now deprecated", t ? (i = i + ", Please use the %c" + t + "%c option instead", this._warnUser(i, "font-weight: bold;", "font-weight: normal;", "font-weight: bold;", "font-weight: normal;")) : this._warnUser(i, "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  checkMsg(e, t) {
    return typeof this.options(e) < "u" ? (this._warnUser("%cDeprecated Setup Option - Use of the %c" + e + " %c option is now deprecated, " + t, "font-weight: normal;", "font-weight: bold;", "font-weight: normal;"), !1) : !0;
  }
  msg(e) {
    this._warnUser(e);
  }
}
class pn {
  static register(e) {
    pn.tables.push(e);
  }
  static deregister(e) {
    var t = pn.tables.indexOf(e);
    t > -1 && pn.tables.splice(t, 1);
  }
  static lookupTable(e, t) {
    var i = [], n, a;
    if (typeof e == "string") {
      if (n = document.querySelectorAll(e), n.length)
        for (var o = 0; o < n.length; o++)
          a = pn.matchElement(n[o]), a && i.push(a);
    } else
      typeof HTMLElement < "u" && e instanceof HTMLElement || e instanceof gs ? (a = pn.matchElement(e), a && i.push(a)) : Array.isArray(e) ? e.forEach(function(s) {
        i = i.concat(pn.lookupTable(s));
      }) : t || console.warn("Table Connection Error - Invalid Selector", e);
    return i;
  }
  static matchElement(e) {
    return pn.tables.find(function(t) {
      return e instanceof gs ? t === e : t.element === e;
    });
  }
}
pn.tables = [];
function vBe(r, e) {
  e && this.table.columnManager.renderer.reinitializeColumnWidths(r), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function p5(r, e) {
  r.forEach(function(t) {
    t.reinitializeWidth();
  }), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function OBe(r, e) {
  var t = 0, i = this.table.rowManager.element.clientWidth, n = 0, a = !1;
  r.forEach((o, s) => {
    o.widthFixed || o.reinitializeWidth(), (this.table.options.responsiveLayout ? o.modules.responsive.visible : o.visible) && (a = o), o.visible && (t += o.getWidth());
  }), a ? (n = i - t + a.getWidth(), this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && (a.setWidth(0), this.table.modules.responsiveLayout.update()), n > 0 ? a.setWidth(n) : a.reinitializeWidth()) : this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update();
}
function mBe(r, e) {
  var t = this.table.rowManager.element.getBoundingClientRect().width, i = 0, n = 0, a = 0, o = 0, s = [], l = [], u = 0, c = 0, h = 0;
  function f(p) {
    var g;
    return typeof p == "string" ? p.indexOf("%") > -1 ? g = t / 100 * parseInt(p) : g = parseInt(p) : g = p, g;
  }
  function d(p, g, v, O) {
    var m = [], E = 0, b = 0, S = 0, T = a, y = 0, R = 0, _ = [];
    function C(w) {
      return v * (w.column.definition.widthGrow || 1);
    }
    function I(w) {
      return f(w.width) - v * (w.column.definition.widthShrink || 0);
    }
    return p.forEach(function(w, x) {
      var P = O ? I(w) : C(w);
      w.column.minWidth >= P ? m.push(w) : w.column.maxWidth && w.column.maxWidth < P ? (w.width = w.column.maxWidth, g -= w.column.maxWidth, T -= O ? w.column.definition.widthShrink || 1 : w.column.definition.widthGrow || 1, T && (v = Math.floor(g / T))) : (_.push(w), R += O ? w.column.definition.widthShrink || 1 : w.column.definition.widthGrow || 1);
    }), m.length ? (m.forEach(function(w) {
      E += O ? w.width - w.column.minWidth : w.column.minWidth, w.width = w.column.minWidth;
    }), b = g - E, S = R ? Math.floor(b / R) : b, y = d(_, b, S, O)) : (y = R ? g - Math.floor(g / R) * R : g, _.forEach(function(w) {
      w.width = O ? I(w) : C(w);
    })), y;
  }
  this.table.options.responsiveLayout && this.table.modExists("responsiveLayout", !0) && this.table.modules.responsiveLayout.update(), this.table.rowManager.element.scrollHeight > this.table.rowManager.element.clientHeight && (t -= this.table.rowManager.element.offsetWidth - this.table.rowManager.element.clientWidth), r.forEach(function(p) {
    var g, v, O;
    p.visible && (g = p.definition.width, v = parseInt(p.minWidth), g ? (O = f(g), i += O > v ? O : v, p.definition.widthShrink && (l.push({
      column: p,
      width: O > v ? O : v
    }), u += p.definition.widthShrink)) : (s.push({
      column: p,
      width: 0
    }), a += p.definition.widthGrow || 1));
  }), n = t - i, o = Math.floor(n / a), h = d(s, n, o, !1), s.length && h > 0 && (s[s.length - 1].width += h), s.forEach(function(p) {
    n -= p.width;
  }), c = Math.abs(h) + n, c > 0 && u && (h = d(l, c, Math.floor(c / u), !0)), h && l.length && (l[l.length - 1].width -= h), s.forEach(function(p) {
    p.column.setWidth(p.width);
  }), l.forEach(function(p) {
    p.column.setWidth(p.width);
  });
}
var EBe = {
  fitData: vBe,
  fitDataFill: p5,
  fitDataTable: p5,
  fitDataStretch: OBe,
  fitColumns: mBe
};
class Xf extends mt {
  constructor(e) {
    super(e, "layout"), this.mode = null, this.registerTableOption("layout", "fitData"), this.registerTableOption("layoutColumnsOnNewData", !1), this.registerColumnOption("widthGrow"), this.registerColumnOption("widthShrink");
  }
  //initialize layout system
  initialize() {
    var e = this.table.options.layout;
    Xf.modes[e] ? this.mode = e : (console.warn("Layout Error - invalid mode set, defaulting to 'fitData' : " + e), this.mode = "fitData"), this.table.element.setAttribute("tabulator-layout", this.mode);
  }
  getMode() {
    return this.mode;
  }
  //trigger table layout
  layout(e) {
    this.dispatch("layout-refreshing"), Xf.modes[this.mode].call(this, this.table.columnManager.columnsByIndex, e), this.dispatch("layout-refreshed");
  }
}
Xf.moduleName = "layout";
Xf.modes = EBe;
var bBe = {
  default: {
    //hold default locale text
    groups: {
      item: "item",
      items: "items"
    },
    columns: {},
    data: {
      loading: "Loading",
      error: "Error"
    },
    pagination: {
      page_size: "Page Size",
      page_title: "Show Page",
      first: "First",
      first_title: "First Page",
      last: "Last",
      last_title: "Last Page",
      prev: "Prev",
      prev_title: "Prev Page",
      next: "Next",
      next_title: "Next Page",
      all: "All",
      counter: {
        showing: "Showing",
        of: "of",
        rows: "rows",
        pages: "pages"
      }
    },
    headerFilters: {
      default: "filter column...",
      columns: {}
    }
  }
};
class eO extends mt {
  constructor(e) {
    super(e), this.locale = "default", this.lang = !1, this.bindings = {}, this.langList = {}, this.registerTableOption("locale", !1), this.registerTableOption("langs", {});
  }
  initialize() {
    this.langList = Zt.deepClone(eO.langs), this.table.options.columnDefaults.headerFilterPlaceholder !== !1 && this.setHeaderFilterPlaceholder(this.table.options.columnDefaults.headerFilterPlaceholder);
    for (let e in this.table.options.langs)
      this.installLang(e, this.table.options.langs[e]);
    this.setLocale(this.table.options.locale), this.registerTableFunction("setLocale", this.setLocale.bind(this)), this.registerTableFunction("getLocale", this.getLocale.bind(this)), this.registerTableFunction("getLang", this.getLang.bind(this));
  }
  //set header placeholder
  setHeaderFilterPlaceholder(e) {
    this.langList.default.headerFilters.default = e;
  }
  //setup a lang description object
  installLang(e, t) {
    this.langList[e] ? this._setLangProp(this.langList[e], t) : this.langList[e] = t;
  }
  _setLangProp(e, t) {
    for (let i in t)
      e[i] && typeof e[i] == "object" ? this._setLangProp(e[i], t[i]) : e[i] = t[i];
  }
  //set current locale
  setLocale(e) {
    e = e || "default";
    function t(i, n) {
      for (var a in i)
        typeof i[a] == "object" ? (n[a] || (n[a] = {}), t(i[a], n[a])) : n[a] = i[a];
    }
    if (e === !0 && navigator.language && (e = navigator.language.toLowerCase()), e && !this.langList[e]) {
      let i = e.split("-")[0];
      this.langList[i] ? (console.warn("Localization Error - Exact matching locale not found, using closest match: ", e, i), e = i) : (console.warn("Localization Error - Matching locale not found, using default: ", e), e = "default");
    }
    this.locale = e, this.lang = Zt.deepClone(this.langList.default || {}), e != "default" && t(this.langList[e], this.lang), this.dispatchExternal("localized", this.locale, this.lang), this._executeBindings();
  }
  //get current locale
  getLocale(e) {
    return this.locale;
  }
  //get lang object for given local or current if none provided
  getLang(e) {
    return e ? this.langList[e] : this.lang;
  }
  //get text for current locale
  getText(e, t) {
    var i = t ? e + "|" + t : e, n = i.split("|"), a = this._getLangElement(n, this.locale);
    return a || "";
  }
  //traverse langs object and find localized copy
  _getLangElement(e, t) {
    var i = this.lang;
    return e.forEach(function(n) {
      var a;
      i && (a = i[n], typeof a < "u" ? i = a : i = !1);
    }), i;
  }
  //set update binding
  bind(e, t) {
    this.bindings[e] || (this.bindings[e] = []), this.bindings[e].push(t), t(this.getText(e), this.lang);
  }
  //iterate through bindings and trigger updates
  _executeBindings() {
    for (let e in this.bindings)
      this.bindings[e].forEach((t) => {
        t(this.getText(e), this.lang);
      });
  }
}
eO.moduleName = "localize";
eO.langs = bBe;
class Wq extends mt {
  constructor(e) {
    super(e);
  }
  initialize() {
    this.registerTableFunction("tableComms", this.receive.bind(this));
  }
  getConnections(e) {
    var t = [], i;
    return i = pn.lookupTable(e), i.forEach((n) => {
      this.table !== n && t.push(n);
    }), t;
  }
  send(e, t, i, n) {
    var a = this.getConnections(e);
    a.forEach((o) => {
      o.tableComms(this.table.element, t, i, n);
    }), !a.length && e && console.warn("Table Connection Error - No tables matching selector found", e);
  }
  receive(e, t, i, n) {
    if (this.table.modExists(t))
      return this.table.modules[t].commsReceived(e, i, n);
    console.warn("Inter-table Comms Error - no such module:", t);
  }
}
Wq.moduleName = "comms";
var SBe = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  LayoutModule: Xf,
  LocalizeModule: eO,
  CommsModule: Wq
});
class zq {
  constructor(e, t) {
    this.bindStaticFunctionality(e), this.bindModules(e, SBe, !0), t && this.bindModules(e, t);
  }
  bindStaticFunctionality(e) {
    e.moduleBindings = {}, e.extendModule = function(t, i, n) {
      if (e.moduleBindings[t]) {
        var a = e.moduleBindings[t][i];
        if (a)
          if (typeof n == "object")
            for (let o in n)
              a[o] = n[o];
          else
            console.warn("Module Error - Invalid value type, it must be an object");
        else
          console.warn("Module Error - property does not exist:", i);
      } else
        console.warn("Module Error - module does not exist:", t);
    }, e.registerModule = function(t) {
      Array.isArray(t) || (t = [t]), t.forEach((i) => {
        e.registerModuleBinding(i);
      });
    }, e.registerModuleBinding = function(t) {
      e.moduleBindings[t.moduleName] = t;
    }, e.findTable = function(t) {
      var i = pn.lookupTable(t, !0);
      return Array.isArray(i) && !i.length ? !1 : i;
    }, e.prototype.bindModules = function() {
      var t = [], i = [], n = [];
      this.modules = {};
      for (var a in e.moduleBindings) {
        let o = e.moduleBindings[a], s = new o(this);
        this.modules[a] = s, o.prototype.moduleCore ? this.modulesCore.push(s) : o.moduleInitOrder ? o.moduleInitOrder < 0 ? t.push(s) : i.push(s) : n.push(s);
      }
      t.sort((o, s) => o.moduleInitOrder > s.moduleInitOrder ? 1 : -1), i.sort((o, s) => o.moduleInitOrder > s.moduleInitOrder ? 1 : -1), this.modulesRegular = t.concat(n.concat(i));
    };
  }
  bindModules(e, t, i) {
    var n = Object.values(t);
    i && n.forEach((a) => {
      a.prototype.moduleCore = !0;
    }), e.registerModule(n);
  }
}
class TBe extends an {
  constructor(e) {
    super(e), this.element = this._createAlertElement(), this.msgElement = this._createMsgElement(), this.type = null, this.element.appendChild(this.msgElement);
  }
  _createAlertElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert"), e;
  }
  _createMsgElement() {
    var e = document.createElement("div");
    return e.classList.add("tabulator-alert-msg"), e.setAttribute("role", "alert"), e;
  }
  _typeClass() {
    return "tabulator-alert-state-" + this.type;
  }
  alert(e, t = "msg") {
    if (e) {
      for (this.clear(), this.type = t; this.msgElement.firstChild; )
        this.msgElement.removeChild(this.msgElement.firstChild);
      this.msgElement.classList.add(this._typeClass()), typeof e == "function" && (e = e()), e instanceof HTMLElement ? this.msgElement.appendChild(e) : this.msgElement.innerHTML = e, this.table.element.appendChild(this.element);
    }
  }
  clear() {
    this.element.parentNode && this.element.parentNode.removeChild(this.element), this.msgElement.classList.remove(this._typeClass());
  }
}
class gs {
  constructor(e, t) {
    this.options = {}, this.columnManager = null, this.rowManager = null, this.footerManager = null, this.alertManager = null, this.vdomHoz = null, this.externalEvents = null, this.eventBus = null, this.interactionMonitor = !1, this.browser = "", this.browserSlow = !1, this.browserMobile = !1, this.rtl = !1, this.originalElement = null, this.componentFunctionBinder = new hBe(this), this.dataLoader = !1, this.modules = {}, this.modulesCore = [], this.modulesRegular = [], this.deprecationAdvisor = new gBe(this), this.optionsList = new Hq(this, "table constructor"), this.initialized = !1, this.destroyed = !1, this.initializeElement(e) && (this.initializeCoreSystems(t), setTimeout(() => {
      this._create();
    })), pn.register(this);
  }
  initializeElement(e) {
    return typeof HTMLElement < "u" && e instanceof HTMLElement ? (this.element = e, !0) : typeof e == "string" ? (this.element = document.querySelector(e), this.element ? !0 : (console.error("Tabulator Creation Error - no element found matching selector: ", e), !1)) : (console.error("Tabulator Creation Error - Invalid element provided:", e), !1);
  }
  initializeCoreSystems(e) {
    this.columnManager = new aBe(this), this.rowManager = new lBe(this), this.footerManager = new uBe(this), this.dataLoader = new fBe(this), this.alertManager = new TBe(this), this.bindModules(), this.options = this.optionsList.generate(gs.defaultOptions, e), this._clearObjectPointers(), this._mapDeprecatedFunctionality(), this.externalEvents = new dBe(this, this.options, this.options.debugEventsExternal), this.eventBus = new pBe(this.options.debugEventsInternal), this.interactionMonitor = new cBe(this), this.dataLoader.initialize(), this.footerManager.initialize();
  }
  //convert deprecated functionality to new functions
  _mapDeprecatedFunctionality() {
  }
  _clearSelection() {
    this.element.classList.add("tabulator-block-select"), window.getSelection ? window.getSelection().empty ? window.getSelection().empty() : window.getSelection().removeAllRanges && window.getSelection().removeAllRanges() : document.selection && document.selection.empty(), this.element.classList.remove("tabulator-block-select");
  }
  //create table
  _create() {
    this.externalEvents.dispatch("tableBuilding"), this.eventBus.dispatch("table-building"), this._rtlCheck(), this._buildElement(), this._initializeTable(), this._loadInitialData(), this.initialized = !0, this.externalEvents.dispatch("tableBuilt");
  }
  _rtlCheck() {
    var e = window.getComputedStyle(this.element);
    switch (this.options.textDirection) {
      case "auto":
        if (e.direction !== "rtl")
          break;
      case "rtl":
        this.element.classList.add("tabulator-rtl"), this.rtl = !0;
        break;
      case "ltr":
        this.element.classList.add("tabulator-ltr");
      default:
        this.rtl = !1;
    }
  }
  //clear pointers to objects in default config object
  _clearObjectPointers() {
    this.options.columns = this.options.columns.slice(0), Array.isArray(this.options.data) && !this.options.reactiveData && (this.options.data = this.options.data.slice(0));
  }
  //build tabulator element
  _buildElement() {
    var e = this.element, t = this.options, i;
    if (e.tagName === "TABLE") {
      this.originalElement = this.element, i = document.createElement("div");
      var n = e.attributes;
      for (var a in n)
        typeof n[a] == "object" && i.setAttribute(n[a].name, n[a].value);
      e.parentNode.replaceChild(i, e), this.element = e = i;
    }
    for (e.classList.add("tabulator"), e.setAttribute("role", "grid"); e.firstChild; )
      e.removeChild(e.firstChild);
    t.height && (t.height = isNaN(t.height) ? t.height : t.height + "px", e.style.height = t.height), t.minHeight !== !1 && (t.minHeight = isNaN(t.minHeight) ? t.minHeight : t.minHeight + "px", e.style.minHeight = t.minHeight), t.maxHeight !== !1 && (t.maxHeight = isNaN(t.maxHeight) ? t.maxHeight : t.maxHeight + "px", e.style.maxHeight = t.maxHeight);
  }
  //initialize core systems and modules
  _initializeTable() {
    var e = this.element, t = this.options;
    this.interactionMonitor.initialize(), this.columnManager.initialize(), this.rowManager.initialize(), this._detectBrowser(), this.modulesCore.forEach((i) => {
      i.initialize();
    }), e.appendChild(this.columnManager.getElement()), e.appendChild(this.rowManager.getElement()), t.footerElement && this.footerManager.activate(), t.autoColumns && t.data && this.columnManager.generateColumnsFromRowData(this.options.data), this.modulesRegular.forEach((i) => {
      i.initialize();
    }), this.columnManager.setColumns(t.columns), this.eventBus.dispatch("table-built");
  }
  _loadInitialData() {
    this.dataLoader.load(this.options.data);
  }
  //deconstructor
  destroy() {
    var e = this.element;
    for (this.destroyed = !0, pn.deregister(this), this.eventBus.dispatch("table-destroy"), this.rowManager.destroy(); e.firstChild; )
      e.removeChild(e.firstChild);
    e.classList.remove("tabulator"), this.externalEvents.dispatch("tableDestroyed");
  }
  _detectBrowser() {
    var e = navigator.userAgent || navigator.vendor || window.opera;
    e.indexOf("Trident") > -1 ? (this.browser = "ie", this.browserSlow = !0) : e.indexOf("Edge") > -1 ? (this.browser = "edge", this.browserSlow = !0) : e.indexOf("Firefox") > -1 ? (this.browser = "firefox", this.browserSlow = !1) : e.indexOf("Mac OS") > -1 ? (this.browser = "safari", this.browserSlow = !1) : (this.browser = "other", this.browserSlow = !1), this.browserMobile = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(e.slice(0, 4));
  }
  initGuard(e, t) {
    var i, n;
    return this.options.debugInitialization && !this.initialized && (e || (i = new Error().stack.split(`
`), n = i[0] == "Error" ? i[2] : i[1], n[0] == " " ? e = n.trim().split(" ")[1].split(".")[1] : e = n.trim().split("@")[0]), console.warn("Table Not Initialized - Calling the " + e + " function before the table is initialized may result in inconsistent behavior, Please wait for the `tableBuilt` event before calling this function." + (t ? " " + t : ""))), this.initialized;
  }
  ////////////////// Data Handling //////////////////
  //block table redrawing
  blockRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-blocking"), this.rowManager.blockRedraw(), this.columnManager.blockRedraw(), this.eventBus.dispatch("redraw-blocked");
  }
  //restore table redrawing
  restoreRedraw() {
    this.initGuard(), this.eventBus.dispatch("redraw-restoring"), this.rowManager.restoreRedraw(), this.columnManager.restoreRedraw(), this.eventBus.dispatch("redraw-restored");
  }
  //load data
  setData(e, t, i) {
    return this.initGuard(!1, "To set initial data please use the 'data' property in the table constructor."), this.dataLoader.load(e, t, i, !1);
  }
  //clear data
  clearData() {
    this.initGuard(), this.dataLoader.blockActiveLoad(), this.rowManager.clearData();
  }
  //get table data array
  getData(e) {
    return this.rowManager.getData(e);
  }
  //get table data array count
  getDataCount(e) {
    return this.rowManager.getDataCount(e);
  }
  //replace data, keeping table in position with same sort
  replaceData(e, t, i) {
    return this.initGuard(), this.dataLoader.load(e, t, i, !0, !0);
  }
  //update table data
  updateData(e) {
    var t = 0;
    return this.initGuard(), new Promise((i, n) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((a) => {
        var o = this.rowManager.findRow(a[this.options.index]);
        o ? (t++, o.updateData(a).then(() => {
          t--, t || i();
        }).catch((s) => {
          n("Update Error - Unable to update row", a, s);
        })) : n("Update Error - Unable to find row", a);
      }) : (console.warn("Update Error - No data provided"), n("Update Error - No data provided"));
    });
  }
  addData(e, t, i) {
    return this.initGuard(), new Promise((n, a) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e ? this.rowManager.addRows(e, t, i).then((o) => {
        var s = [];
        o.forEach(function(l) {
          s.push(l.getComponent());
        }), n(s);
      }) : (console.warn("Update Error - No data provided"), a("Update Error - No data provided"));
    });
  }
  //update table data
  updateOrAddData(e) {
    var t = [], i = 0;
    return this.initGuard(), new Promise((n, a) => {
      this.dataLoader.blockActiveLoad(), typeof e == "string" && (e = JSON.parse(e)), e && e.length > 0 ? e.forEach((o) => {
        var s = this.rowManager.findRow(o[this.options.index]);
        i++, s ? s.updateData(o).then(() => {
          i--, t.push(s.getComponent()), i || n(t);
        }) : this.rowManager.addRows(o).then((l) => {
          i--, t.push(l[0].getComponent()), i || n(t);
        });
      }) : (console.warn("Update Error - No data provided"), a("Update Error - No data provided"));
    });
  }
  //get row object
  getRow(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //get row object
  getRowFromPosition(e) {
    var t = this.rowManager.getRowFromPosition(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching row found:", e), !1);
  }
  //delete row from table
  deleteRow(e) {
    var t = [];
    this.initGuard(), Array.isArray(e) || (e = [e]);
    for (let i of e) {
      let n = this.rowManager.findRow(i, !0);
      if (n)
        t.push(n);
      else
        return console.error("Delete Error - No matching row found:", i), Promise.reject("Delete Error - No matching row found");
    }
    return t.sort((i, n) => this.rowManager.rows.indexOf(i) > this.rowManager.rows.indexOf(n) ? 1 : -1), t.forEach((i) => {
      i.delete();
    }), this.rowManager.reRenderInPosition(), Promise.resolve();
  }
  //add row to table
  addRow(e, t, i) {
    return this.initGuard(), typeof e == "string" && (e = JSON.parse(e)), this.rowManager.addRows(e, t, i, !0).then((n) => n[0].getComponent());
  }
  //update a row if it exists otherwise create it
  updateOrAddRow(e, t) {
    var i = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), i ? i.updateData(t).then(() => i.getComponent()) : this.rowManager.addRows(t).then((n) => n[0].getComponent());
  }
  //update row data
  updateRow(e, t) {
    var i = this.rowManager.findRow(e);
    return this.initGuard(), typeof t == "string" && (t = JSON.parse(t)), i ? i.updateData(t).then(() => Promise.resolve(i.getComponent())) : (console.warn("Update Error - No matching row found:", e), Promise.reject("Update Error - No matching row found"));
  }
  //scroll to row in DOM
  scrollToRow(e, t, i) {
    var n = this.rowManager.findRow(e);
    return n ? this.rowManager.scrollToRow(n, t, i) : (console.warn("Scroll Error - No matching row found:", e), Promise.reject("Scroll Error - No matching row found"));
  }
  moveRow(e, t, i) {
    var n = this.rowManager.findRow(e);
    this.initGuard(), n ? n.moveToRow(t, i) : console.warn("Move Error - No matching row found:", e);
  }
  getRows(e) {
    return this.rowManager.getComponents(e);
  }
  //get position of row in table
  getRowPosition(e) {
    var t = this.rowManager.findRow(e);
    return t ? t.getPosition() : (console.warn("Position Error - No matching row found:", e), !1);
  }
  /////////////// Column Functions  ///////////////
  setColumns(e) {
    this.initGuard(!1, "To set initial columns please use the 'columns' property in the table constructor"), this.columnManager.setColumns(e);
  }
  getColumns(e) {
    return this.columnManager.getComponents(e);
  }
  getColumn(e) {
    var t = this.columnManager.findColumn(e);
    return t ? t.getComponent() : (console.warn("Find Error - No matching column found:", e), !1);
  }
  getColumnDefinitions() {
    return this.columnManager.getDefinitionTree();
  }
  showColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.show();
    else
      return console.warn("Column Show Error - No matching column found:", e), !1;
  }
  hideColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.hide();
    else
      return console.warn("Column Hide Error - No matching column found:", e), !1;
  }
  toggleColumn(e) {
    var t = this.columnManager.findColumn(e);
    if (this.initGuard(), t)
      t.visible ? t.hide() : t.show();
    else
      return console.warn("Column Visibility Toggle Error - No matching column found:", e), !1;
  }
  addColumn(e, t, i) {
    var n = this.columnManager.findColumn(i);
    return this.initGuard(), this.columnManager.addColumn(e, t, n).then((a) => a.getComponent());
  }
  deleteColumn(e) {
    var t = this.columnManager.findColumn(e);
    return this.initGuard(), t ? t.delete() : (console.warn("Column Delete Error - No matching column found:", e), Promise.reject());
  }
  updateColumnDefinition(e, t) {
    var i = this.columnManager.findColumn(e);
    return this.initGuard(), i ? i.updateDefinition(t) : (console.warn("Column Update Error - No matching column found:", e), Promise.reject());
  }
  moveColumn(e, t, i) {
    var n = this.columnManager.findColumn(e), a = this.columnManager.findColumn(t);
    this.initGuard(), n ? a ? this.columnManager.moveColumn(n, a, i) : console.warn("Move Error - No matching column found:", a) : console.warn("Move Error - No matching column found:", e);
  }
  //scroll to column in DOM
  scrollToColumn(e, t, i) {
    return new Promise((n, a) => {
      var o = this.columnManager.findColumn(e);
      return o ? this.columnManager.scrollToColumn(o, t, i) : (console.warn("Scroll Error - No matching column found:", e), Promise.reject("Scroll Error - No matching column found"));
    });
  }
  //////////// General Public Functions ////////////
  //redraw list without updating data
  redraw(e) {
    this.initGuard(), this.columnManager.redraw(e), this.rowManager.redraw(e);
  }
  setHeight(e) {
    this.options.height = isNaN(e) ? e : e + "px", this.element.style.height = this.options.height, this.rowManager.initializeRenderer(), this.rowManager.redraw();
  }
  //////////////////// Event Bus ///////////////////
  on(e, t) {
    this.externalEvents.subscribe(e, t);
  }
  off(e, t) {
    this.externalEvents.unsubscribe(e, t);
  }
  dispatchEvent() {
    var e = Array.from(arguments);
    e.shift(), this.externalEvents.dispatch(...arguments);
  }
  //////////////////// Alerts ///////////////////
  alert(e, t) {
    this.initGuard(), this.alertManager.alert(e, t);
  }
  clearAlert() {
    this.initGuard(), this.alertManager.clear();
  }
  ////////////// Extension Management //////////////
  modExists(e, t) {
    return this.modules[e] ? !0 : (t && console.error("Tabulator Module Not Installed: " + e), !1);
  }
  module(e) {
    var t = this.modules[e];
    return t || console.error("Tabulator module not installed: " + e), t;
  }
}
gs.defaultOptions = rBe;
new zq(gs);
class yBe extends gs {
}
new zq(yBe, tBe);
const RBe = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #888;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}
.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}
.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}
.tabulator.tabulator-block-select {
  user-select: none;
}
.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}
.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}
.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #e6e6e6;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}
.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #cdcdcd;
  pointer-events: none;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: 0.6;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: clip;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}
.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #cdcdcd;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}
.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}
.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}
.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: #f3f3f3 !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f3f3f3 !important;
}
.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle,
.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}
.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator .tabulator-tableholder:focus {
  outline: none;
}
.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}
.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: 700;
  font-size: 20px;
  white-space: normal;
}
.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: 700;
  background: #e2e2e2 !important;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}
.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}
.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #e6e6e6;
  color: #555;
  font-weight: 700;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}
.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}
.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}
.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}
.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}
.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: 400;
}
.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}
.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}
.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}
.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: hsla(0, 0%, 100%, 0.2);
}
.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}
.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}
.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}
.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}
.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}
.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: 700;
  font-size: 16px;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}
.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #d00;
  color: #590000;
}
.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}
.tabulator-row.tabulator-row-even {
  background-color: #efefef;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-selected {
  background-color: #9abcea;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769bcc;
    cursor: pointer;
  }
}
.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}
.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}
.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}
.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}
.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}
.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}
.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}
.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}
.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}
.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}
.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1d68cd;
  outline: none;
  padding: 0;
}
.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #d00;
}
.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #d00;
}
.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}
.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: 700;
  font-size: 1.1em;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: 0.7;
    cursor: pointer;
  }
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}
.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}
.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}
.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}
.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}
.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}
.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}
.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}
.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}
.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}
.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}
.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: 0.5;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #efefef;
  }
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}
.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu:after {
  display: inline-block;
  position: absolute;
  top: calc(5px + 0.4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: "";
  border-color: #aaa;
  border-style: solid;
  border-width: 1px 1px 0 0;
  vertical-align: top;
  transform: rotate(45deg);
}
.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}
.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}
.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}
.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1d68cd;
}
.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid hsla(0, 0%, 100%, 0.5);
}
.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1d68cd;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1d68cd;
  }
}
.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}
.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 6px 4px 4px;
  color: #333;
  font-weight: 700;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}
.tabulator.tabulator-ltr {
  direction: ltr;
}
.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: 0;
  margin-left: -1px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}
.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: auto;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: 0;
  margin-left: 5px;
  border-bottom-left-radius: 0;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: 0;
  margin-left: 5px;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}
.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}
.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}
.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}
body.tabulator-print-fullscreen-hide > :not(.tabulator-print-fullscreen) {
  display: none !important;
}
.tabulator-print-table {
  border-collapse: collapse;
}
.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}
.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px 5px 5px 10px;
  background: #ccc;
  font-weight: 700;
  min-width: 100%;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}
.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}
.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}
.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}
.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}
@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}
.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}
`, ABe = {
  setup() {
    const r = Wl("style", {}, RBe);
    return () => r;
  }
}, _Be = `
.tabulator {
  position: relative;
  border: 1px solid #ddd;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #ddd;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #ddd;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ececec !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #ddd;
  background-color: #e6e6e6;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: #f3f3f3 !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: #f3f3f3 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #ddd;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #f9f9f9;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  background-color: #fff;
  margin-bottom: 20px;
  border: none;
}

.tabulator .tabulator-header {
  border-bottom: 2px solid #ddd;
  background-color: #fff;
  color: inherit;
}

.tabulator .tabulator-header .tabulator-col {
  background-color: #fff;
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 8px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  width: 100%;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-tableholder .tabulator-table {
  color: inherit;
}

.tabulator .tabulator-footer {
  border-top: 2px solid #ddd;
  background: inherit;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
}

.tabulator .tabulator-footer .tabulator-paginator {
  color: inherit;
}

.tabulator.table-striped .tabulator-row.tabulator-row-even {
  background-color: #f9f9f9;
}

.tabulator.table-bordered {
  border: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #ddd;
}

.tabulator.table-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #ddd;
}

.tabulator.table-condensed .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 5px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row {
  min-height: 24px;
}

.tabulator.table-condensed .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 5px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.active {
  background: #f5f5f5 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.success {
  background: #dff0d8 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.info {
  background: #d9edf7 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.warning {
  background: #fcf8e3 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.danger {
  background: #f2dede !important;
}

.tabulator-row {
  min-height: 30px;
  border-bottom: 1px solid #ddd;
}

.tabulator-row.tabulator-row-even {
  background-color: transparent;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #f5f5f5 !important;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC !important;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell {
  padding: 8px;
  border-right: none;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

.tabulator-row.tabulator-group {
  background: #fafafa;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-edit-select-list .tabulator-edit-select-list-item {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-notice {
  color: inherit;
}

.tabulator-edit-select-list .tabulator-edit-select-list-group {
  color: inherit;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  border: none;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-print-table-group {
  background: #fafafa;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #666;
}

.tabulator-print-table .tabulator-data-tree-control {
  border: 1px solid #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  background: #333;
}

`, CBe = {
  setup() {
    const r = Wl("style", {}, _Be);
    return () => r;
  }
}, IBe = `
.tabulator {
  position: relative;
  border: 1px solid #fff;
  background-color: #fff;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #3759D7;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #fff;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #3759D7;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #fff;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #b7c3f1;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #b7c3f1;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #3759D7;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #3759D7;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #f3f3f3;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #fff;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #fff;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #3759D7;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #fff;
  border-top: 1px solid #fff;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #3759D7;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #3759D7;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #fff;
  border-bottom: 1px solid #fff;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #fff;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #fff;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #f3f3f3;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #f3f3f3;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #f3f3f3;
  border: 1px solid #fff;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #fff;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #fff;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #f3f3f3;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(243, 243, 243, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #f3f3f3;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #fff;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #fff;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #fff;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #fff;
  border-bottom: 2px solid #fff;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #fff;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #3759D7;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #3759D7;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator .tabulator-header {
  border-bottom: 3px solid #3759D7;
  margin-bottom: 4px;
  padding-left: 10px;
  font-size: 1.1em;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: 2px solid #fff;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-col:nth-child(1) {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  border: 1px solid #3759D7;
  font-size: 1em;
  color: #3759D7;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  padding-left: 10px;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border-top: 2px solid #3759D7 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  padding-left: 0 !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #3759D7;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #3759D7;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  border-top: 3px solid #3759D7 !important;
  border-bottom: 2px solid #3759D7 !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  background: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid transparent;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  border-bottom: none !important;
}

.tabulator-row {
  margin-bottom: 2px;
}

.tabulator-row .tabulator-cell:first-child {
  border-left: 10px solid #3759D7;
}

.tabulator-row:nth-child(even) {
  background-color: #627ce0;
}

.tabulator-row:nth-child(even) .tabulator-cell {
  background-color: #fff;
}

.tabulator-row:nth-child(even) .tabulator-cell:first-child {
  border-left: 10px solid #627ce0;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    cursor: pointer;
  }
  .tabulator-row.tabulator-selectable:hover .tabulator-cell {
    background-color: #bbb;
  }
}

.tabulator-row.tabulator-selected .tabulator-cell {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover .tabulator-cell {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-moving {
  pointer-events: none !important;
}

.tabulator-row .tabulator-cell {
  padding: 6px 4px;
  border-right: 2px solid #fff;
  background-color: #f3f3f3;
}

.tabulator-row.tabulator-group {
  min-width: 100%;
  margin-bottom: 2px;
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  border-right: none;
  background: #8ca0e8;
}

.tabulator-row.tabulator-group span {
  color: #3759D7;
}

.tabulator-edit-select-list {
  border: 1px solid #1D68CD;
}

.tabulator-print-table .tabulator-print-table-group {
  border-bottom: 2px solid #3759D7;
  border-top: 2px solid #3759D7;
  background: #8ca0e8;
  margin-bottom: 2px;
}

.tabulator-print-table .tabulator-print-table-group span {
  color: #3759D7;
}

`, wBe = {
  setup() {
    const r = Wl("style", {}, IBe);
    return () => r;
  }
}, NBe = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: white;
  font-size: 16px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #aaa;
  background: transparent;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: rgba(0, 0, 0, 0);
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #aaa;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0);
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #363636;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #363636;
  color: #363636;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: rgba(13, 13, 13, 0) !important;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: transparent;
  white-space: nowrap;
  overflow: visible;
  color: #363636;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #ededed !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #aaa;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #aaa;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: transparent;
  color: #363636;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: rgba(13, 13, 13, 0) !important;
  border-bottom: 1px solid #aaa;
  border-top: 1px solid #aaa;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: rgba(13, 13, 13, 0) !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #363636;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #dbdbdb;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 24px;
  background-color: transparent;
}

.tabulator-row.tabulator-row-even {
  background-color: #fafafa;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #fafafa;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #aaa;
  border-bottom: 1px solid #aaa;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 16px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #aaa;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #aaa;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: transparent;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: transparent;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: transparent;
  border: 1px solid #aaa;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fafafa;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #aaa;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #aaa;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 16px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #363636;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: transparent;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(0, 0, 0, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: transparent;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #363636;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #aaa;
  padding: 4px;
  padding-top: 6px;
  color: #363636;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #aaa;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #aaa;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #aaa;
  border-bottom: 2px solid #aaa;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #aaa;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #363636;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #363636;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #363636;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #363636;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #363636;
}

.tabulator {
  border: none;
}

.tabulator .tabulator-header {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-header .tabulator-col {
  border-right: none;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  border: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.5em 0.75em;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  right: 0px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input {
  border: 1px solid #dbdbdb;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 2px 0 0;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  margin: -5px -10px 10px -10px;
  border: 1px solid #dbdbdb;
  border-width: 0 0 2px;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-cell {
  border-bottom-width: 0;
}

.tabulator .tabulator-footer .tabulator-page {
  margin: 0 0.1875em;
  padding: calc(0.375em - 1px) 0.75em;
  border: 1px solid #dbdbdb;
  font-size: 16px;
}

.tabulator .tabulator-footer .tabulator-page.active {
  border-color: #4a4a4a;
  color: #363636;
  font-weight: bold;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    border-color: #b5b5b5;
    background: inherit;
    color: inherit;
  }
}

.tabulator.is-striped .tabulator-row:nth-child(even) {
  background-color: #fafafa;
}

.tabulator.is-bordered {
  border: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-header .tabulator-col {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-bordered .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  border-right: 1px solid #dbdbdb;
}

.tabulator.is-narrow .tabulator-header .tabulator-col .tabulator-col-content {
  padding: 0.25em 0.5em;
}

.tabulator.is-narrow .tabulator-tableholder .tabulator-table .tabulator-row .tabulator-cell {
  padding: 0.25em 0.5em;
}

.tabulator-row {
  min-height: 22px;
}

.tabulator-row.tabulator-row-even {
  background-color: inherit;
}

.tabulator-row.tabulator-selected {
  background-color: #00d1b2 !important;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #009e86 !important;
  }
}

.tabulator-row .tabulator-cell {
  padding: 0.5em 0.75em;
  border: 1px solid #dbdbdb;
  border-width: 0 0 1px;
}

.tabulator-row.tabulator-group {
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: none;
  border-top: 1px solid #999;
  color: #363636;
}

.tabulator-popup-container {
  background: white;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: white;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    color: white;
  }
}

`, xBe = {
  setup() {
    const r = Wl("style", {}, NBe);
    return () => r;
  }
}, PBe = `
.tabulator {
  position: relative;
  border: 1px solid #999;
  background-color: #fff;
  font-size: 14px;
  text-align: left;
  overflow: hidden;
  -webkit-transform: translateZ(0);
  -moz-transform: translateZ(0);
  -ms-transform: translateZ(0);
  -o-transform: translateZ(0);
  transform: translateZ(0);
}

.tabulator[tabulator-layout="fitDataFill"] .tabulator-tableholder .tabulator-table {
  min-width: 100%;
}

.tabulator[tabulator-layout="fitDataTable"] {
  display: inline-block;
}

.tabulator.tabulator-block-select {
  user-select: none;
}

.tabulator .tabulator-header {
  position: relative;
  box-sizing: border-box;
  width: 100%;
  border-bottom: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  overflow: hidden;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-header.tabulator-header-hidden {
  display: none;
}

.tabulator .tabulator-header .tabulator-header-contents {
  position: relative;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-header-contents .tabulator-headers {
  display: inline-block;
}

.tabulator .tabulator-header .tabulator-col {
  display: inline-flex;
  position: relative;
  box-sizing: border-box;
  flex-direction: column;
  justify-content: flex-start;
  border-right: 1px solid #ddd;
  background: #fff;
  text-align: left;
  vertical-align: bottom;
  overflow: hidden;
}

.tabulator .tabulator-header .tabulator-col.tabulator-moving {
  position: absolute;
  border: 1px solid #999;
  background: #e6e6e6;
  pointer-events: none;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content {
  box-sizing: border-box;
  position: relative;
  padding: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button {
  padding: 0 8px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-header-popup-button:hover {
  cursor: pointer;
  opacity: .6;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title-holder {
  position: relative;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title {
  box-sizing: border-box;
  width: 100%;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  vertical-align: bottom;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title.tabulator-col-title-wrap {
  white-space: normal;
  text-overflow: initial;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-title-editor {
  box-sizing: border-box;
  width: 100%;
  border: 1px solid #999;
  padding: 1px;
  background: #fff;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-title .tabulator-header-popup-button + .tabulator-title-editor {
  width: calc(100% - 22px);
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  display: flex;
  align-items: center;
  position: absolute;
  top: 0;
  bottom: 0;
  right: 4px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  width: 0;
  height: 0;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  position: relative;
  display: flex;
  border-top: 1px solid #ddd;
  overflow: hidden;
  margin-right: -1px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter {
  position: relative;
  box-sizing: border-box;
  margin-top: 2px;
  width: 100%;
  text-align: center;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter textarea {
  height: auto !important;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter svg {
  margin-top: 3px;
}

.tabulator .tabulator-header .tabulator-col .tabulator-header-filter input::-ms-clear {
  width: 0;
  height: 0;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 25px;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable.tabulator-col-sorter-element:hover {
    cursor: pointer;
    background-color: #e6e6e6;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter {
  color: #bbb;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="none"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #bbb;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-bottom: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="ascending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-top: none;
  border-bottom: 6px solid #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter {
  color: #666;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter.tabulator-col-sorter-element .tabulator-arrow:hover {
    cursor: pointer;
    border-top: 6px solid #555;
  }
}

.tabulator .tabulator-header .tabulator-col.tabulator-sortable[aria-sort="descending"] .tabulator-col-content .tabulator-col-sorter .tabulator-arrow {
  border-bottom: none;
  border-top: 6px solid #666;
  color: #666;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical .tabulator-col-content .tabulator-col-title {
  writing-mode: vertical-rl;
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-col-vertical-flip .tabulator-col-title {
  transform: rotate(180deg);
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-top: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable.tabulator-col-vertical-flip .tabulator-col-title {
  padding-right: 0;
  padding-bottom: 20px;
}

.tabulator .tabulator-header .tabulator-col.tabulator-col-vertical.tabulator-sortable .tabulator-col-sorter {
  justify-content: center;
  left: 0;
  right: 0;
  top: 4px;
  bottom: auto;
}

.tabulator .tabulator-header .tabulator-frozen {
  position: sticky;
  left: 0;
  z-index: 10;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  box-sizing: border-box;
  background: white !important;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: white !important;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-header .tabulator-frozen-rows-holder:empty {
  display: none;
}

.tabulator .tabulator-tableholder {
  position: relative;
  width: 100%;
  white-space: nowrap;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator .tabulator-tableholder:focus {
  outline: none;
}

.tabulator .tabulator-tableholder .tabulator-placeholder {
  box-sizing: border-box;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder[tabulator-render-mode="virtual"] {
  min-height: 100%;
  min-width: 100%;
}

.tabulator .tabulator-tableholder .tabulator-placeholder .tabulator-placeholder-contents {
  display: inline-block;
  text-align: center;
  padding: 10px;
  color: #ccc;
  font-weight: bold;
  font-size: 20px;
  white-space: normal;
}

.tabulator .tabulator-tableholder .tabulator-table {
  position: relative;
  display: inline-block;
  background-color: #fff;
  white-space: nowrap;
  overflow: visible;
  color: #333;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs {
  font-weight: bold;
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-top {
  border-bottom: 2px solid #ddd;
}

.tabulator .tabulator-tableholder .tabulator-table .tabulator-row.tabulator-calcs.tabulator-calcs-bottom {
  border-top: 2px solid #ddd;
}

.tabulator .tabulator-footer {
  border-top: 1px solid #999;
  background-color: #fff;
  color: #555;
  font-weight: bold;
  white-space: nowrap;
  user-select: none;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator .tabulator-footer .tabulator-footer-contents {
  display: flex;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
  padding: 5px 10px;
}

.tabulator .tabulator-footer .tabulator-footer-contents:empty {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  box-sizing: border-box;
  width: 100%;
  text-align: left;
  background: white !important;
  border-bottom: 1px solid #ddd;
  border-top: 1px solid #ddd;
  overflow: hidden;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  display: inline-block;
  background: white !important;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row .tabulator-col-resize-handle {
  display: none;
}

.tabulator .tabulator-footer .tabulator-calcs-holder:only-child {
  margin-bottom: -5px;
  border-bottom: none;
}

.tabulator .tabulator-footer > * + .tabulator-page-counter {
  margin-left: 10px;
}

.tabulator .tabulator-footer .tabulator-page-counter {
  font-weight: normal;
}

.tabulator .tabulator-footer .tabulator-paginator {
  flex: 1;
  text-align: right;
  color: #555;
  font-family: inherit;
  font-weight: inherit;
  font-size: inherit;
}

.tabulator .tabulator-footer .tabulator-page-size {
  display: inline-block;
  margin: 0 5px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
}

.tabulator .tabulator-footer .tabulator-pages {
  margin: 0 7px;
}

.tabulator .tabulator-footer .tabulator-page {
  display: inline-block;
  margin: 0 2px;
  padding: 2px 5px;
  border: 1px solid #aaa;
  border-radius: 3px;
  background: rgba(255, 255, 255, 0.2);
}

.tabulator .tabulator-footer .tabulator-page.active {
  color: #d00;
}

.tabulator .tabulator-footer .tabulator-page:disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-footer .tabulator-page:not(.disabled):hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
    color: #fff;
  }
}

.tabulator .tabulator-col-resize-handle {
  position: relative;
  display: inline-block;
  width: 6px;
  margin-left: -3px;
  margin-right: -3px;
  z-index: 10;
  vertical-align: middle;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator .tabulator-col-resize-handle:hover {
    cursor: ew-resize;
  }
}

.tabulator .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-right: 0;
}

.tabulator .tabulator-alert {
  position: absolute;
  display: flex;
  align-items: center;
  top: 0;
  left: 0;
  z-index: 100;
  height: 100%;
  width: 100%;
  background: rgba(0, 0, 0, 0.4);
  text-align: center;
}

.tabulator .tabulator-alert .tabulator-alert-msg {
  display: inline-block;
  margin: 0 auto;
  padding: 10px 20px;
  border-radius: 10px;
  background: #fff;
  font-weight: bold;
  font-size: 16px;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-msg {
  border: 4px solid #333;
  color: #000;
}

.tabulator .tabulator-alert .tabulator-alert-msg.tabulator-alert-state-error {
  border: 4px solid #D00;
  color: #590000;
}

.tabulator-row {
  position: relative;
  box-sizing: border-box;
  min-height: 22px;
  background-color: #fff;
}

.tabulator-row.tabulator-row-even {
  background-color: #fff;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selectable:hover {
    background-color: #bbb;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-selected {
  background-color: #9ABCEA;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-selected:hover {
    background-color: #769BCC;
    cursor: pointer;
  }
}

.tabulator-row.tabulator-row-moving {
  border: 1px solid #000;
  background: #fff;
}

.tabulator-row.tabulator-moving {
  position: absolute;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
  pointer-events: none;
  z-index: 15;
}

.tabulator-row .tabulator-row-resize-handle {
  position: absolute;
  right: 0;
  bottom: 0;
  left: 0;
  height: 5px;
}

.tabulator-row .tabulator-row-resize-handle.prev {
  top: 0;
  bottom: auto;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-row-resize-handle:hover {
    cursor: ns-resize;
  }
}

.tabulator-row .tabulator-responsive-collapse {
  box-sizing: border-box;
  padding: 5px;
  border-top: 1px solid #ddd;
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-responsive-collapse:empty {
  display: none;
}

.tabulator-row .tabulator-responsive-collapse table {
  font-size: 14px;
}

.tabulator-row .tabulator-responsive-collapse table tr td {
  position: relative;
}

.tabulator-row .tabulator-responsive-collapse table tr td:first-of-type {
  padding-right: 10px;
}

.tabulator-row .tabulator-cell {
  display: inline-block;
  position: relative;
  box-sizing: border-box;
  padding: 4px;
  border-right: 1px solid #ddd;
  vertical-align: middle;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.tabulator-row .tabulator-cell.tabulator-frozen {
  display: inline-block;
  position: sticky;
  left: 0;
  background-color: inherit;
  z-index: 10;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-right: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-left: 2px solid #ddd;
}

.tabulator-row .tabulator-cell.tabulator-editing {
  border: 1px solid #1D68CD;
  outline: none;
  padding: 0;
}

.tabulator-row .tabulator-cell.tabulator-editing input,
.tabulator-row .tabulator-cell.tabulator-editing select {
  border: 1px;
  background: transparent;
  outline: none;
  color: #000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail {
  border: 1px solid #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-validation-fail input,
.tabulator-row .tabulator-cell.tabulator-validation-fail select {
  border: 1px;
  background: transparent;
  color: #dd0000;
}

.tabulator-row .tabulator-cell.tabulator-row-handle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box {
  width: 80%;
}

.tabulator-row .tabulator-cell.tabulator-row-handle .tabulator-row-handle-box .tabulator-row-handle-bar {
  width: 100%;
  height: 3px;
  margin-top: 2px;
  background: #666;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  -moz-user-select: none;
  -khtml-user-select: none;
  -webkit-user-select: none;
  -o-user-select: none;
  height: 15px;
  width: 15px;
  border-radius: 20px;
  background: #666;
  color: #fff;
  font-weight: bold;
  font-size: 1.1em;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle:hover {
    opacity: .7;
    cursor: pointer;
  }
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-close {
  display: initial;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle.open .tabulator-responsive-collapse-toggle-open {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle svg {
  stroke: #fff;
}

.tabulator-row .tabulator-cell .tabulator-responsive-collapse-toggle .tabulator-responsive-collapse-toggle-close {
  display: none;
}

.tabulator-row .tabulator-cell .tabulator-traffic-light {
  display: inline-block;
  height: 14px;
  width: 14px;
  border-radius: 14px;
}

.tabulator-row.tabulator-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-row.tabulator-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-row.tabulator-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-row.tabulator-group.tabulator-group-level-1 {
  padding-left: 30px;
}

.tabulator-row.tabulator-group.tabulator-group-level-2 {
  padding-left: 50px;
}

.tabulator-row.tabulator-group.tabulator-group-level-3 {
  padding-left: 70px;
}

.tabulator-row.tabulator-group.tabulator-group-level-4 {
  padding-left: 90px;
}

.tabulator-row.tabulator-group.tabulator-group-level-5 {
  padding-left: 110px;
}

.tabulator-row.tabulator-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-row.tabulator-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-row.tabulator-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-popup-container {
  position: absolute;
  display: inline-block;
  box-sizing: border-box;
  background: #fff;
  border: 1px solid #ddd;
  box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.2);
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
  z-index: 10000;
}

.tabulator-popup {
  padding: 5px;
  border-radius: 3px;
}

.tabulator-tooltip {
  max-width: Min(500px, 100%);
  padding: 3px 5px;
  border-radius: 2px;
  box-shadow: none;
  font-size: 12px;
  pointer-events: none;
}

.tabulator-menu .tabulator-menu-item {
  position: relative;
  box-sizing: border-box;
  padding: 5px 10px;
  user-select: none;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-disabled {
  opacity: .5;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-menu .tabulator-menu-item:not(.tabulator-menu-item-disabled):hover {
    cursor: pointer;
    background: #fff;
  }
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu {
  padding-right: 25px;
}

.tabulator-menu .tabulator-menu-item.tabulator-menu-item-submenu::after {
  display: inline-block;
  position: absolute;
  top: calc(5px + .4em);
  right: 10px;
  height: 7px;
  width: 7px;
  content: '';
  border-width: 1px 1px 0 0;
  border-style: solid;
  border-color: #ddd;
  vertical-align: top;
  transform: rotate(45deg);
}

.tabulator-menu .tabulator-menu-separator {
  border-top: 1px solid #ddd;
}

.tabulator-edit-list {
  max-height: 200px;
  font-size: 14px;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

.tabulator-edit-list .tabulator-edit-list-item {
  padding: 4px;
  color: #333;
  outline: none;
}

.tabulator-edit-list .tabulator-edit-list-item.active {
  color: #fff;
  background: #1D68CD;
}

.tabulator-edit-list .tabulator-edit-list-item.active.focused {
  outline: 1px solid rgba(255, 255, 255, 0.5);
}

.tabulator-edit-list .tabulator-edit-list-item.focused {
  outline: 1px solid #1D68CD;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-edit-list .tabulator-edit-list-item:hover {
    cursor: pointer;
    color: #fff;
    background: #1D68CD;
  }
}

.tabulator-edit-list .tabulator-edit-list-placeholder {
  padding: 4px;
  color: #333;
  text-align: center;
}

.tabulator-edit-list .tabulator-edit-list-group {
  border-bottom: 1px solid #ddd;
  padding: 4px;
  padding-top: 6px;
  color: #333;
  font-weight: bold;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-2,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-2 {
  padding-left: 12px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-3,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-3 {
  padding-left: 20px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-4,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-4 {
  padding-left: 28px;
}

.tabulator-edit-list .tabulator-edit-list-item.tabulator-edit-list-group-level-5,
.tabulator-edit-list .tabulator-edit-list-group.tabulator-edit-list-group-level-5 {
  padding-left: 36px;
}

.tabulator.tabulator-ltr {
  direction: ltr;
}

.tabulator.tabulator-rtl {
  text-align: initial;
  direction: rtl;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col {
  text-align: initial;
  border-left: 1px solid #ddd;
  border-right: initial;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-col-group .tabulator-col-group-cols {
  margin-right: initial;
  margin-left: -1px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col.tabulator-sortable .tabulator-col-title {
  padding-right: 0;
  padding-left: 25px;
}

.tabulator.tabulator-rtl .tabulator-header .tabulator-col .tabulator-col-content .tabulator-col-sorter {
  left: 8px;
  right: initial;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell {
  border-right: initial;
  border-left: 1px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-branch {
  margin-right: initial;
  margin-left: 5px;
  border-bottom-left-radius: initial;
  border-bottom-right-radius: 1px;
  border-left: initial;
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell .tabulator-data-tree-control {
  margin-right: initial;
  margin-left: 5px;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-left {
  border-left: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-cell.tabulator-frozen.tabulator-frozen-right {
  border-right: 2px solid #ddd;
}

.tabulator.tabulator-rtl .tabulator-row .tabulator-col-resize-handle:last-of-type {
  width: 3px;
  margin-left: 0;
  margin-right: -3px;
}

.tabulator.tabulator-rtl .tabulator-footer .tabulator-calcs-holder {
  text-align: initial;
}

.tabulator-print-fullscreen {
  position: absolute;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  z-index: 10000;
}

body.tabulator-print-fullscreen-hide > *:not(.tabulator-print-fullscreen) {
  display: none !important;
}

.tabulator-print-table {
  border-collapse: collapse;
}

.tabulator-print-table .tabulator-data-tree-branch {
  display: inline-block;
  vertical-align: middle;
  height: 9px;
  width: 7px;
  margin-top: -9px;
  margin-right: 5px;
  border-bottom-left-radius: 1px;
  border-left: 2px solid #ddd;
  border-bottom: 2px solid #ddd;
}

.tabulator-print-table .tabulator-print-table-group {
  box-sizing: border-box;
  border-bottom: 1px solid #999;
  border-right: 1px solid #ddd;
  border-top: 1px solid #999;
  padding: 5px;
  padding-left: 10px;
  background: #ccc;
  font-weight: bold;
  min-width: 100%;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-print-table-group:hover {
    cursor: pointer;
    background-color: rgba(0, 0, 0, 0.1);
  }
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-visible .tabulator-arrow {
  margin-right: 10px;
  border-left: 6px solid transparent;
  border-right: 6px solid transparent;
  border-top: 6px solid #666;
  border-bottom: 0;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-1 td {
  padding-left: 30px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-2 td {
  padding-left: 50px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-3 td {
  padding-left: 70px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-4 td {
  padding-left: 90px !important;
}

.tabulator-print-table .tabulator-print-table-group.tabulator-group-level-5 td {
  padding-left: 110px !important;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-group-toggle {
  display: inline-block;
}

.tabulator-print-table .tabulator-print-table-group .tabulator-arrow {
  display: inline-block;
  width: 0;
  height: 0;
  margin-right: 16px;
  border-top: 6px solid transparent;
  border-bottom: 6px solid transparent;
  border-right: 0;
  border-left: 6px solid #666;
  vertical-align: middle;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #d00;
}

.tabulator-print-table .tabulator-data-tree-control {
  display: inline-flex;
  justify-content: center;
  align-items: center;
  vertical-align: middle;
  height: 11px;
  width: 11px;
  margin-right: 5px;
  border: 1px solid #333;
  border-radius: 2px;
  background: rgba(0, 0, 0, 0.1);
  overflow: hidden;
}

@media (hover: hover) and (pointer: fine) {
  .tabulator-print-table .tabulator-data-tree-control:hover {
    cursor: pointer;
    background: rgba(0, 0, 0, 0.2);
  }
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: transparent;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-collapse:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand {
  display: inline-block;
  position: relative;
  height: 7px;
  width: 1px;
  background: #333;
}

.tabulator-print-table .tabulator-data-tree-control .tabulator-data-tree-control-expand:after {
  position: absolute;
  content: "";
  left: -3px;
  top: 3px;
  height: 1px;
  width: 7px;
  background: #333;
}

.tabulator {
  border: none;
  background-color: #fff;
}

.tabulator .tabulator-header .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #999;
}

.tabulator .tabulator-header .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator .tabulator-tableholder .tabulator-placeholder span {
  color: #000;
}

.tabulator .tabulator-footer .tabulator-calcs-holder {
  background: #f2f2f2 !important;
  border-bottom: 1px solid #fff;
}

.tabulator .tabulator-footer .tabulator-calcs-holder .tabulator-row {
  background: #f2f2f2 !important;
}

.tabulator-row {
  border-bottom: 1px solid #ddd;
}

.tabulator-row .tabulator-cell:last-of-type {
  border-right: none;
}

.tabulator-row.tabulator-group span {
  color: #666;
}

.tabulator-print-table .tabulator-print-table-group span {
  margin-left: 10px;
  color: #666;
}

`, LBe = {
  setup() {
    const r = Wl("style", {}, PBe);
    return () => r;
  }
}, DBe = { class: "ns-table-theme-box" }, MBe = /* @__PURE__ */ An({
  __name: "theme",
  props: {
    theme: {
      type: String,
      default: "default"
    }
  },
  setup(r) {
    return (e, t) => (xt(), Pr("span", DBe, [
      r.theme === "default" ? (xt(), va(ABe, { key: 0 })) : Fn("", !0),
      r.theme === "bootstrap3" ? (xt(), va(CBe, { key: 1 })) : Fn("", !0),
      r.theme === "modern" ? (xt(), va(wBe, { key: 2 })) : Fn("", !0),
      r.theme === "bulma" ? (xt(), va(xBe, { key: 3 })) : Fn("", !0),
      r.theme === "sample" ? (xt(), va(LBe, { key: 4 })) : Fn("", !0)
    ]));
  }
}), kBe = ["id"], QBe = /* @__PURE__ */ An({
  __name: "table",
  props: {
    columns: {
      // 
      type: Array,
      default: () => []
    },
    data: {
      // 
      type: Array,
      default: () => []
    },
    options: {
      // 
      type: Object,
      default: () => ({})
    },
    theme: {
      // 
      type: String,
      default: "default"
    }
  },
  emits: [
    "loaded"
  ],
  setup(r, { emit: e }) {
    const t = r;
    let i = null;
    const n = WE.v4(), a = Rr(null), o = Rr(null), s = Rr(!1);
    function l() {
      o.value || setTimeout(() => {
        l();
      }, 1e3), delete t.options.data, delete t.options.columns;
      const h = {
        height: "100%",
        layout: "fitColumns",
        columns: t.columns,
        reactiveData: !0,
        ...t.options
      };
      i = new gs(o.value, {
        ...h,
        data: t.data
      }), s.value = !0, e("loaded", n, i);
    }
    function u(h) {
      if (!i) {
        setTimeout(() => {
          u(h);
        }, 100);
        return;
      }
      i.setData(h);
    }
    function c(h) {
      if (!i) {
        setTimeout(() => {
          c(h);
        }, 100);
        return;
      }
      i.setColumns(h);
    }
    return Ra(() => t.columns, (h, f) => {
      h && c(h);
    }, {
      deep: !0
    }), Ra(() => t.data, (h, f) => {
      h && u(h);
    }, {
      deep: !0
    }), Os(() => {
      [
        dn,
        gd,
        VP,
        Jv,
        md,
        $c,
        Yl,
        zo,
        PP,
        Vc,
        DP,
        ao,
        MP,
        kP,
        QP,
        Hl,
        UP,
        vd,
        $P,
        rs,
        Gc,
        Od,
        wi,
        GP,
        BP,
        FP,
        XP,
        YP,
        HP,
        WP,
        zP,
        bl
      ].forEach((h) => {
        gs.registerModule(h);
      }), Sc(() => {
        l();
      });
    }), (h, f) => (xt(), Pr("div", {
      class: "ns-table-box",
      ref_key: "RefMain",
      ref: a
    }, [
      Yt(MBe, { theme: r.theme }, null, 8, ["theme"]),
      er("div", {
        class: "ns-table-body",
        id: Ef(n),
        ref_key: "RefBox",
        ref: o
      }, null, 8, kBe)
    ], 512));
  }
}), UBe = `.ns-table-box[data-v-641e1809],.ns-table-box .ns-table-body[data-v-641e1809]{width:100%;height:100%;overflow:hidden;box-sizing:border-box}
`, $Be = /* @__PURE__ */ Es(QBe, [["styles", [UBe]], ["__scopeId", "data-v-641e1809"]]), VBe = ["id"], GBe = /* @__PURE__ */ An({
  __name: "floatingbox",
  props: {
    width: {
      type: String,
      default: "100px"
    },
    id: {
      type: String,
      default: () => WE.v4()
    },
    style: {
      type: Object,
      default: () => ({})
    }
  },
  emits: ["loaded", "mouseleave", "update:show"],
  setup(r, { emit: e }) {
    const t = r, { NsFloatingbox: i } = window, n = Rr(), a = Rr(WE.v4());
    function o() {
      i.close(t.id), e("mouseleave", !1);
    }
    function s() {
      o();
    }
    return Os(() => {
      e("loaded", a.value);
    }), (l, u) => (xt(), Pr("div", {
      class: "ns-floating-box",
      id: r.id,
      style: Na({ width: `${t.width}`, ...t.style }),
      onMouseleave: o,
      ref_key: "RefBox",
      ref: n
    }, [
      er("div", {
        class: "ns-floating-box-content",
        onClick: s
      }, [
        Di(l.$slots, "items")
      ])
    ], 44, VBe));
  }
}), BBe = `:root,:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-error: #aa5032;--ns-warning-light-1: #c36955;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-floating-box{position:fixed;top:0;left:0;z-index:9999;box-shadow:1px 1px 5px var(--ns-border-shadow-color);border-radius:var(--ns-border-radius);background-color:#f7f7f7;padding:0;min-height:30px;display:flex;justify-content:flex-start;align-items:center;flex-direction:column;opacity:0;transition:opacity .2s}.ns-floating-box .ns-floating-box-content{width:100%;height:100%;overflow:hidden;box-sizing:border-box;min-height:30px}
`, FBe = /* @__PURE__ */ Es(GBe, [["styles", [BBe]]]), XBe = An({
  name: "",
  props: {
    hideHeader: {
      type: Boolean,
      default: !1
    },
    hideMenu: {
      type: Boolean,
      default: !1
    },
    menuWidth: {
      type: String,
      default: "200px"
    },
    expandMenu: {
      type: Boolean,
      default: !0
    }
  },
  setup(r, { emit: e }) {
    return {};
  }
}), YBe = `:root,:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-error: #aa5032;--ns-warning-light-1: #c36955;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-frame-main{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.ns-frame-main .ns-frame-header{width:100%;height:70px;overflow:hidden;box-sizing:border-box;position:relative;z-index:10;box-shadow:1px 1px 5px var(--ns-border-shadow-color);border:1px solid var(--ns-border-color);background-color:var(--ns-primary)}.ns-frame-main .ns-frame-body{width:100%;height:calc(100% - 70px);overflow:hidden;box-sizing:border-box;position:relative;z-index:5}.ns-frame-main .ns-frame-body .ns-frame-body-menu,.ns-frame-main .ns-frame-body .ns-frame-body-content{float:left;height:100%;overflow:hidden;box-sizing:border-box}.ns-none-header .ns-frame-body{height:100%!important}.ns-none-menu .ns-frame-body .ns-frame-body-content{width:100%!important}
`, HBe = {
  key: 0,
  class: "ns-frame-header"
}, WBe = { class: "ns-frame-body" };
function zBe(r, e, t, i, n, a) {
  return xt(), Pr("div", {
    class: Hf(`ns-frame-main ns-none-${r.hideHeader ? "header" : ""} ns-none-${r.hideMenu ? "menu" : ""}`)
  }, [
    r.hideHeader ? Fn("", !0) : (xt(), Pr("div", HBe, [
      Di(r.$slots, "header")
    ])),
    er("div", WBe, [
      r.hideMenu ? Fn("", !0) : (xt(), Pr("div", {
        key: 0,
        class: "ns-frame-body-menu",
        style: Na(`width: ${r.menuWidth}`)
      }, [
        Di(r.$slots, "menu")
      ], 4)),
      er("div", {
        class: "ns-frame-body-content",
        style: Na(`width: ${r.hideMenu ? "100%" : `calc(100% - ${r.menuWidth})`}`)
      }, [
        Di(r.$slots, "content")
      ], 4)
    ])
  ], 2);
}
const ZBe = /* @__PURE__ */ Es(XBe, [["render", zBe], ["styles", [YBe]]]);
function qBe(r) {
  const e = {
    header: 30,
    top: 50,
    bottom: 30
  };
  let t = 0;
  for (let i in r)
    r[i] !== void 0 && (e[i] = 0), t += e[i];
  return `calc(100% - ${t}px)`;
}
const jBe = An({
  name: "",
  props: {
    scope: {
      type: Array,
      default: () => ["header", "top", "middle", "bottom"]
    },
    hideHeader: {
      type: Boolean,
      default: void 0
    },
    hideTop: {
      type: Boolean,
      default: void 0
    },
    hideBottom: {
      type: Boolean,
      default: void 0
    }
  },
  setup(r, { emit: e }) {
    return {
      handlerScopesHeight: qBe
    };
  }
}), KBe = `.ns-content-box{width:100%;height:100%;overflow:hidden;box-sizing:border-box}.ns-content-box .ns-content-header{position:relative;z-index:10;padding:0 5px;width:100%;height:30px;overflow:hidden;box-sizing:border-box}.ns-content-box .ns-content-top{position:relative;z-index:10;padding:0 5px;width:100%;height:50px;overflow:hidden;box-sizing:border-box;background-color:#fff;border-bottom:1px solid #eee}.ns-content-box .ns-content-middle{position:relative;z-index:5;width:100%;overflow:hidden;box-sizing:border-box;background-color:#fff}.ns-content-box .ns-content-bottom{position:relative;z-index:10;padding:0 5px;width:100%;height:50px;overflow:hidden;box-sizing:border-box;border-top:1px solid #eee}
`, JBe = { class: "ns-content-box" }, e5e = {
  key: 0,
  class: "ns-content-header"
}, t5e = {
  key: 1,
  class: "ns-content-top"
}, r5e = {
  key: 2,
  class: "ns-content-bottom"
};
function i5e(r, e, t, i, n, a) {
  return xt(), Pr("div", JBe, [
    r.hideHeader === void 0 ? (xt(), Pr("div", e5e, [
      Di(r.$slots, "header")
    ])) : Fn("", !0),
    r.hideTop === void 0 ? (xt(), Pr("div", t5e, [
      Di(r.$slots, "top")
    ])) : Fn("", !0),
    er("div", {
      class: "ns-content-middle",
      style: Na(`height: ${r.handlerScopesHeight({ header: r.hideHeader, top: r.hideTop, bottom: r.hideBottom })};`)
    }, [
      Di(r.$slots, "middle")
    ], 4),
    r.hideBottom === void 0 ? (xt(), Pr("div", r5e, [
      Di(r.$slots, "bottom")
    ])) : Fn("", !0)
  ]);
}
const n5e = /* @__PURE__ */ Es(jBe, [["render", i5e], ["styles", [KBe]]]), a5e = ["width", "height"], o5e = ["fill"], s5e = /* @__PURE__ */ An({
  __name: "star",
  props: {
    size: {
      type: [Number, String],
      default: 16
    },
    fill: {
      type: String,
      default: "#CA2188"
    }
  },
  setup(r) {
    return (e, t) => (xt(), Pr("svg", {
      t: "1688548412453",
      class: "icon",
      viewBox: "0 0 1024 1024",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg",
      "p-id": "1611",
      "xmlns:xlink": "http://www.w3.org/1999/xlink",
      width: r.size,
      height: r.size
    }, [
      er("path", {
        d: "M894.91197 513.709945c0-33.604352-78.328973-62.839187-194.192817-78.305437 70.981634-92.947925 105.664551-169.093163 81.875752-192.829773-23.763217-23.789823-99.884918 10.891048-192.832843 81.899288-15.489786-115.863844-44.701085-194.219423-78.302367-194.219423-33.654494 0-62.892399 78.252225-78.434373 194.116069-92.921319-70.955028-168.964226-105.585757-192.703907-81.795934-23.789823 23.736611 10.9197 99.832729 81.875752 192.727443-115.913986 15.518438-194.192817 44.753273-194.192817 78.407768s78.328973 62.839187 194.192817 78.355579c-71.00824 92.897783-105.691157 168.990832-81.875752 192.779631 23.763217 23.789823 99.884918-10.891048 192.806237-81.899288 15.491833 115.860774 44.677549 194.219423 78.332043 194.219423 33.602306 0 62.889329-78.305437 78.381162-194.116069 92.894713 70.904886 168.990832 105.585757 192.754049 81.795934 23.788799-23.736611-10.917654-99.779517-81.875752-192.727443C816.609603 576.599274 894.91197 547.311227 894.91197 513.709945zM707.835224 316.665173c17.159822 17.107633 3.699252 61.040215-31.060413 115.758444-24.583908-2.723018-50.430576-4.982478-77.584006-6.471388-1.515516-27.541263-3.774977-53.745065-6.603395-78.613452C647.052882 312.811402 690.751127 299.555493 707.835224 316.665173zM600.784092 551.422871c8.528234-8.94165 16.851806-17.828041 24.944112-26.717502 14.873756 17.983583 28.774347 35.709293 40.333614 52.510958-20.296255 3.748371-42.569538 6.729262-66.151629 8.886391C600.450495 574.85249 600.474031 562.982138 600.784092 551.422871zM601.297792 530.049075c0.076748-5.550413 0.410346-10.738575 0.410346-16.33913 0-5.960759-0.152473-11.714809-0.231267-17.573237 5.216815 5.806239 9.633405 11.406794 14.542204 17.10968C611.214652 518.846942 606.332459 524.44852 601.297792 530.049075zM436.366416 566.016241c3.774977 3.853771 7.397481 7.655354 11.277858 11.509125 3.853771 3.853771 7.705496 7.449669 11.585873 11.251252-7.29515-0.410346-14.411221-0.873903-21.450545-1.38658C437.262832 580.350714 436.776761 573.260226 436.366416 566.016241zM439.08841 602.340541c11.585873 0.515746 23.326265 0.926092 35.298947 1.183965 8.707312 8.323573 17.288758 15.876596 25.946952 23.789823-17.983583 14.950504-35.605939 28.361955-52.408627 39.97341C444.276572 647.298476 441.24554 625.514333 439.08841 602.340541zM495.580029 603.77931c5.293563 0.052189 10.532891 0.205685 15.878642 0.205685 5.573949 0 10.788717-0.308015 16.260335-0.410346-5.395894 4.882194-10.765181 9.606799-16.158005 14.232143C506.268462 613.181447 500.92578 608.609315 495.580029 603.77931zM511.35634 590.163197c-10.532891 0-20.914332-0.152473-31.113625-0.512676-7.68196-7.142677-15.284101-14.284331-22.939455-21.939685-7.502881-7.499811-14.747889-15.052834-21.810748-22.555715-0.333598-10.378371-0.515746-20.86112-0.515746-31.547507 0-11.20111 0.310062-22.145369 0.694825-32.936133 6.78145-7.245008 13.745049-14.486946 20.964474-21.681812 7.603165-7.603165 15.260565-14.950504 22.889313-22.092158 10.480702-0.360204 21.013593-0.668219 31.830963-0.668219 10.738575 0 21.348214 0.254803 31.778774 0.565888 7.68196 7.192819 15.360849 14.384615 23.01825 22.092158 7.655354 7.605212 15.029298 15.260565 22.195511 22.968108 0.333598 10.428513 0.565888 21.013593 0.565888 31.752168 0 10.43056-0.308015 20.551058-0.641613 30.621415-7.373944 7.863085-14.926968 15.776312-22.813588 23.636327-7.449669 7.449669-14.95255 14.642488-22.426779 21.681812C532.602224 589.907371 522.094916 590.163197 511.35634 590.163197zM421.208181 513.709945c0 5.446036 0.102331 10.738575 0.155543 16.081257-5.163603-5.753027-9.583263-11.353582-14.490016-17.10968 4.777817-5.600555 9.710153-11.20111 14.771425-16.799618C421.541779 501.942947 421.208181 507.59569 421.208181 513.709945zM422.826028 586.103742c-23.63428-2.157129-45.702901-5.240351-66.049299-9.041934 11.688203-16.95516 25.252127-34.733059 40.383756-52.921303 8.094352 8.939603 15.876596 17.777899 24.483624 26.76969C421.901982 562.829665 422.312328 574.594617 422.826028 586.103742zM422.134273 476.048183c-8.326643 8.68173-16.365736 17.365506-24.252357 25.996071-15.002692-18.136056-29.006637-35.967166-40.641629-52.869115 20.216437-3.751441 42.311665-6.732331 65.791425-8.889461C422.465824 451.845968 422.441265 464.126666 422.134273 476.048183zM587.528184 462.482213c-4.086062-4.211928-8.068769-8.373715-12.280698-12.58769-4.213975-4.211928-8.402367-8.16803-12.590759-12.279674 7.939833 0.410346 15.724123 0.926092 23.379477 1.541099C586.655304 446.76116 587.141374 454.568986 587.528184 462.482213zM584.803119 425.181679c-11.892865-0.565888-23.967878-0.978281-36.248575-1.286296-8.965186-8.578376-17.777899-16.286941-26.717502-24.40483 18.470677-15.362896 36.582173-29.184693 53.795207-41.001833C579.48602 378.988614 582.569242 401.289526 584.803119 425.181679zM528.926508 423.689698c-5.831822-0.102331-11.559267-0.205685-17.467837-0.205685-6.089695 0-11.766998 0.308015-17.804505 0.410346 5.935176-5.342682 11.843746-10.532891 17.752316-15.568581C517.186116 413.311327 523.044544 418.347017 528.926508 423.689698zM601.271186 476.508671c-0.281409-12.227486-0.718361-24.302499-1.284249-36.22197 23.505343 2.209318 45.471634 5.240351 65.691141 8.991792-11.714809 17.057491-25.409716 34.990932-40.618093 53.28253C617.147782 493.877247 609.621365 485.245659 601.271186 476.508671zM511.919159 235.329726c24.150026 0 45.600571 40.383756 59.705823 103.375415-19.628036 15.620769-39.820937 32.67826-60.398602 51.075259-20.063965-18.035772-39.975457-35.195593-59.243289-50.559513C466.113927 275.918143 487.693408 235.329726 511.919159 235.329726zM447.951265 358.951255c16.905018 11.611455 34.630728 25.278733 52.690036 40.333614-8.889461 8.117888-17.801435 16.441461-26.793226 25.022906-11.587919 0.308015-23.508413 0.308015-34.759665 0.820692C441.272145 401.544329 444.199825 379.194298 447.951265 358.951255zM460.07642 437.769368c-4.13518 4.059456-8.271384 8.015557-12.406564 12.125155-3.777023 3.801583-7.373944 7.553023-11.072173 11.356652 0.410346-7.452739 0.77055-14.95255 1.333368-22.197558C445.125917 438.487729 452.652334 438.179714 460.07642 437.769368zM314.927599 316.50963c17.084097-17.057491 60.83453-3.801583 115.321492 30.726815-2.825348 24.868387-5.059226 51.224662-6.626931 78.715783-27.077705 1.488911-52.974515 3.64604-77.481675 6.421246C311.328631 377.653199 297.791313 333.620333 314.927599 316.50963zM233.05287 513.246387c0-24.200168 40.307008-45.676295 103.249549-59.806107 15.516392 19.472494 32.907481 39.665395 51.17452 60.114123-18.188244 20.246113-34.964326 40.181141-50.40397 59.551304C273.744641 558.975894 233.076406 537.446555 233.05287 513.246387zM314.233797 710.241017c-17.057491-17.10968-3.778046-60.83453 30.80254-115.351168 24.868387 2.828418 51.122331 5.087878 78.662571 6.628978 1.49198 27.127847 3.751441 52.974515 6.500041 77.531817C375.428531 713.890126 331.393619 727.350696 314.233797 710.241017zM511.919159 791.93769c-24.173562 0-45.702901-40.644699-59.753919-103.84102 19.343557-15.46625 39.228443-32.267914 59.521628-50.40397 20.37505 18.238386 40.541345 35.605939 60.013839 51.122331C557.572942 751.706407 536.069185 791.93769 511.919159 791.93769zM575.940265 667.954935c-16.928554-11.611455-34.759665-25.38311-52.895721-40.489156 8.631588-7.913227 17.315364-16.031115 26.049283-24.354688 11.895935-0.308015 24.12342-0.308015 35.684734-0.820692C582.595848 625.668853 579.691705 647.812175 575.940265 667.954935zM563.970652 588.570933c3.774977-3.699252 7.553023-7.245008 11.301394-11.04659 4.111644-4.111644 8.015557-8.1711 12.048407-12.279674-0.410346 7.347339-0.744967 14.84715-1.309832 22.043039C578.844407 587.853595 571.368132 588.160587 563.970652 588.570933zM708.503443 710.085474c-17.084097 17.10968-61.040215 3.701299-115.734908-31.03483 2.77316-24.557302 4.958942-50.506301 6.447852-77.584006 27.488051-1.488911 53.745065-3.699252 78.586846-6.5246C712.254883 649.353274 725.58754 693.027983 708.503443 710.085474zM685.895539 573.157895c-15.337313-19.269879-32.473599-39.152718-50.430576-59.243289 18.393929-20.551058 35.427884-40.74396 51.022047-60.371996 62.862723 14.0766 103.172801 35.553751 103.172801 59.703777C789.68437 537.446555 749.171678 559.026036 685.895539 573.157895z",
        fill: r.fill,
        "p-id": "1612"
      }, null, 8, o5e)
    ], 8, a5e));
  }
}), l5e = An({
  name: "",
  components: {
    star: s5e
  },
  props: {
    icon: {
      default: ""
    },
    logoWidth: {
      type: String,
      default: "70px"
    },
    title: {
      default: ""
    }
  },
  setup(r, { emit: e }) {
    return {};
  }
}), u5e = `[data-v-b1580676]:root,[data-v-b1580676]:host{--ns-primary: #28415a;--ns-primary-light-1: #3c5a7d;--ns-success: #5f785a;--ns-success-light-1: #73917d;--ns-warning: #dc8c50;--ns-warning-light-1: #f5a573;--ns-error: #aa5032;--ns-warning-light-1: #c36955;--ns-info: #b9beb4;--ns-text: #1d1d1d;--ns-border-shadow-color: #6c686e;--ns-border-color: #58545a;--ns-background-gray: #dfdfdf;--ns-size-text-normal: 14px;--ns-size-top-title: 22px;--ns-size-text-title: 18px;--ns-size-text-subtitle: 16px;--ns-weight-text: 900;--ns-border-radius: 4px;--ns-border-width: 1px;--ns-text-color-normal: var(--ns-text);--ns-text-color-primary: var(--ns-primary);--ns-text-color-success: var(--ns-success);--ns-text-color-warning: var(--ns-warning);--ns-text-color-error: var(--ns-error);--ns-text-color-info: var(--ns-info)}.ns-header-box[data-v-b1580676]{width:100%;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:space-evenly;align-items:center;position:relative;z-index:100}.ns-header-box .ns-header-item[data-v-b1580676]{width:33%;height:100%;overflow:hidden;box-sizing:border-box;padding:0 10px;display:flex;align-items:center;color:var(--ns-text-color-info)}.ns-header-box .ns-header-left[data-v-b1580676]{justify-content:flex-start}.ns-header-box .ns-header-left .ns-header-icon-box[data-v-b1580676]{width:200px;height:100%;overflow:hidden;box-sizing:border-box;display:flex;justify-content:center;align-items:center}.ns-header-box .ns-header-left .ns-header-title-box[data-v-b1580676]{flex-grow:1;font-size:var(--ns-size-top-title);color:var(--ns-text-color-info)}.ns-header-box .ns-header-middle[data-v-b1580676]{justify-content:center}.ns-header-box .ns-header-right[data-v-b1580676]{justify-content:flex-end}
`, c5e = { class: "ns-header-box" }, h5e = { class: "ns-header-item ns-header-left" }, f5e = ["src"], d5e = { class: "ns-header-title-box" }, p5e = { class: "ns-header-item ns-header-middle" }, g5e = { class: "ns-header-item ns-header-right" };
function v5e(r, e, t, i, n, a) {
  const o = gF("star");
  return xt(), Pr("div", c5e, [
    er("div", h5e, [
      er("div", {
        class: "ns-header-icon-box",
        style: Na(`width: ${r.logoWidth};`)
      }, [
        r.icon ? (xt(), Pr("img", {
          key: 1,
          src: r.icon
        }, null, 8, f5e)) : (xt(), va(o, {
          key: 0,
          size: "64",
          fill: "#f0f0f0"
        }))
      ], 4),
      er("div", d5e, R5(r.title), 1)
    ]),
    er("div", p5e, [
      Di(r.$slots, "middle", {}, void 0, !0)
    ]),
    er("div", g5e, [
      Di(r.$slots, "right", {}, void 0, !0)
    ])
  ]);
}
const O5e = /* @__PURE__ */ Es(l5e, [["render", v5e], ["styles", [u5e]], ["__scopeId", "data-v-b1580676"]]);
console.log(`  ns-table 
`, `Tabulator
 Tabulator  ns-table `, `
  ns-table `);
const g5 = {
  NsAjax: Jre
}, v5 = {
  "ns-sandbox": yie,
  "ns-splitpane": Pie,
  "ns-codeide": xVe,
  "ns-table": $Be,
  "ns-floatingbox": FBe,
  "ns-framebox": ZBe,
  "ns-contentbox": n5e,
  "ns-header": O5e
};
for (let r in v5) {
  const e = v5[r], t = Kw(e);
  customElements.define(r, t);
}
Object.keys(g5).forEach((r) => {
  window[r] = g5[r];
});
